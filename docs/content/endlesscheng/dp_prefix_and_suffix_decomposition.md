---
comments: True
---

# DP Prefix and Suffix Decomposition

- [ ] [724. Find Pivot Index](https://leetcode.cn/problems/find-pivot-index/) (Easy)
- [ ] [1991. Find the Middle Index in Array](https://leetcode.cn/problems/find-the-middle-index-in-array/) (Easy)
- [ ] [2270. Number of Ways to Split Array](https://leetcode.cn/problems/number-of-ways-to-split-array/) (Medium)
- [ ] [2256. Minimum Average Difference](https://leetcode.cn/problems/minimum-average-difference/) (Medium)
- [ ] [1422. Maximum Score After Splitting a String](https://leetcode.cn/problems/maximum-score-after-splitting-a-string/) (Easy)
- [x] [1493. Longest Subarray of 1's After Deleting One Element](https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/) (Medium)
- [x] [845. Longest Mountain in Array](https://leetcode.cn/problems/longest-mountain-in-array/) (Medium)
- [x] [2012. Sum of Beauty in the Array](https://leetcode.cn/problems/sum-of-beauty-in-the-array/) (Medium)
- [ ] [2909. Minimum Sum of Mountain Triplets II](https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-ii/) (Medium)
- [ ] [2483. Minimum Penalty for a Shop](https://leetcode.cn/problems/minimum-penalty-for-a-shop/) (Medium)
- [ ] [1525. Number of Good Ways to Split a String](https://leetcode.cn/problems/number-of-good-ways-to-split-a-string/) (Medium)
- [ ] [3354. Make Array Elements Equal to Zero](https://leetcode.cn/problems/make-array-elements-equal-to-zero/) (Easy)
- [ ] [2874. Maximum Value of an Ordered Triplet II](https://leetcode.cn/problems/maximum-value-of-an-ordered-triplet-ii/) (Medium)
- [x] [123. Best Time to Buy and Sell Stock III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/) (Hard)
- [ ] [2222. Number of Ways to Select Buildings](https://leetcode.cn/problems/number-of-ways-to-select-buildings/) (Medium)
- [ ] [1031. Maximum Sum of Two Non-Overlapping Subarrays](https://leetcode.cn/problems/maximum-sum-of-two-non-overlapping-subarrays/) (Medium)
- [ ] [689. Maximum Sum of 3 Non-Overlapping Subarrays](https://leetcode.cn/problems/maximum-sum-of-3-non-overlapping-subarrays/) (Hard)
- [ ] [2420. Find All Good Indices](https://leetcode.cn/problems/find-all-good-indices/) (Medium)
- [ ] [2100. Find Good Days to Rob the Bank](https://leetcode.cn/problems/find-good-days-to-rob-the-bank/) (Medium)
- [ ] [926. Flip String to Monotone Increasing](https://leetcode.cn/problems/flip-string-to-monotone-increasing/) (Medium)
- [ ] [334. Increasing Triplet Subsequence](https://leetcode.cn/problems/increasing-triplet-subsequence/) (Medium)
- [ ] [2712. Minimum Cost to Make All Characters Equal](https://leetcode.cn/problems/minimum-cost-to-make-all-characters-equal/) (Medium)
- [ ] [1653. Minimum Deletions to Make String Balanced](https://leetcode.cn/problems/minimum-deletions-to-make-string-balanced/) (Medium)
- [x] [1186. Maximum Subarray Sum with One Deletion](https://leetcode.cn/problems/maximum-subarray-sum-with-one-deletion/) (Medium)
- [x] [42. Trapping Rain Water](https://leetcode.cn/problems/trapping-rain-water/) (Hard)
- [ ] [2711. Difference of Number of Distinct Values on Diagonals](https://leetcode.cn/problems/difference-of-number-of-distinct-values-on-diagonals/) (Medium)
- [ ] [1477. Find Two Non-overlapping Sub-arrays Each With Target Sum](https://leetcode.cn/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/) (Medium)
- [ ] [2680. Maximum OR](https://leetcode.cn/problems/maximum-or/) (Medium)
- [x] [1671. Minimum Number of Removals to Make Mountain Array](https://leetcode.cn/problems/minimum-number-of-removals-to-make-mountain-array/) (Hard)
- [ ] [1888. Minimum Number of Flips to Make the Binary String Alternating](https://leetcode.cn/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/) (Medium)
- [x] [238. Product of Array Except Self](https://leetcode.cn/problems/product-of-array-except-self/) (Medium)
- [ ] [2906. Construct Product Matrix](https://leetcode.cn/problems/construct-product-matrix/) (Medium)
- [ ] [3334. Find the Maximum Factor Score of Array](https://leetcode.cn/problems/find-the-maximum-factor-score-of-array/) (Medium)
- [ ] [2167. Minimum Time to Remove All Cars Containing Illegal Goods](https://leetcode.cn/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/) (Hard)
- [ ] [2484. Count Palindromic Subsequences](https://leetcode.cn/problems/count-palindromic-subsequences/) (Hard)
- [ ] [2163. Minimum Difference in Sums After Removal of Elements](https://leetcode.cn/problems/minimum-difference-in-sums-after-removal-of-elements/) (Hard)
- [ ] [2565. Subsequence With the Minimum Score](https://leetcode.cn/problems/subsequence-with-the-minimum-score/) (Hard)
- [ ] [1995. Count Special Quadruplets](https://leetcode.cn/problems/count-special-quadruplets/) (Easy)
- [x] [2552. Count Increasing Quadruplets](https://leetcode.cn/problems/count-increasing-quadruplets/) (Hard)
- [ ] [3302. Find the Lexicographically Smallest Valid Sequence](https://leetcode.cn/problems/find-the-lexicographically-smallest-valid-sequence/) (Medium)
- [ ] [3404. Count Special Subsequences](https://leetcode.cn/problems/count-special-subsequences/) (Medium)
- [ ] [3303. Find the Occurrence of First Almost Equal Substring](https://leetcode.cn/problems/find-the-occurrence-of-first-almost-equal-substring/) (Hard)
- [ ] [3287. Find the Maximum Sequence Value of Array](https://leetcode.cn/problems/find-the-maximum-sequence-value-of-array/) (Hard)
- [ ] [3257. Maximum Value Sum by Placing Three Rooks II](https://leetcode.cn/problems/maximum-value-sum-by-placing-three-rooks-ii/) (Hard)
- [ ] [3410. Maximize Subarray Sum After Removing All Occurrences of One Element](https://leetcode.cn/problems/maximize-subarray-sum-after-removing-all-occurrences-of-one-element/) (Hard)
- [ ] [3003. Maximize the Number of Partitions After Operations](https://leetcode.cn/problems/maximize-the-number-of-partitions-after-operations/) (Hard)
- [ ] [487. Max Consecutive Ones II](https://leetcode.cn/problems/max-consecutive-ones-ii/) (Medium) ðŸ‘‘
- [ ] [1746. Maximum Subarray Sum After One Operation](https://leetcode.cn/problems/maximum-subarray-sum-after-one-operation/) (Medium) ðŸ‘‘

## 724. Find Pivot Index

-   [LeetCode](https://leetcode.com/problems/find-pivot-index/) | [LeetCode CH](https://leetcode.cn/problems/find-pivot-index/) (Easy)

-   Tags: array, prefix sum

## 1991. Find the Middle Index in Array

-   [LeetCode](https://leetcode.com/problems/find-the-middle-index-in-array/) | [LeetCode CH](https://leetcode.cn/problems/find-the-middle-index-in-array/) (Easy)

-   Tags: array, prefix sum

## 2270. Number of Ways to Split Array

-   [LeetCode](https://leetcode.com/problems/number-of-ways-to-split-array/) | [LeetCode CH](https://leetcode.cn/problems/number-of-ways-to-split-array/) (Medium)

-   Tags: array, prefix sum

## 2256. Minimum Average Difference

-   [LeetCode](https://leetcode.com/problems/minimum-average-difference/) | [LeetCode CH](https://leetcode.cn/problems/minimum-average-difference/) (Medium)

-   Tags: array, prefix sum

## 1422. Maximum Score After Splitting a String

-   [LeetCode](https://leetcode.com/problems/maximum-score-after-splitting-a-string/) | [LeetCode CH](https://leetcode.cn/problems/maximum-score-after-splitting-a-string/) (Easy)

-   Tags: string, prefix sum

## 1493. Longest Subarray of 1's After Deleting One Element

-   [LeetCode](https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/) | [LeetCode CH](https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/) (Medium)

-   Tags: array, dynamic programming, sliding window

```python title="1493. Longest Subarray of 1's After Deleting One Element - Python Solution"
from typing import List


# Sliding Window Variable Size
def longestSubarray(nums: List[int]) -> int:
    zeroCount = 0
    res = 0
    left = 0

    for right in range(len(nums)):
        if nums[right] == 0:
            zeroCount += 1

        while zeroCount > 1:
            if nums[left] == 0:
                zeroCount -= 1
            left += 1

        res = max(res, right - left)

    return res


nums = [1, 1, 0, 1]
print(longestSubarray(nums))  # 3

```

## 845. Longest Mountain in Array

-   [LeetCode](https://leetcode.com/problems/longest-mountain-in-array/) | [LeetCode CH](https://leetcode.cn/problems/longest-mountain-in-array/) (Medium)

-   Tags: array, two pointers, dynamic programming, enumeration

```python title="845. Longest Mountain in Array - Python Solution"
from typing import List


# Left Right Pointers
def longestMountain(arr: List[int]) -> int:
    n = len(arr)
    res = 0
    left = 0

    while left < n:
        right = left

        if right < n - 1 and arr[right] < arr[right + 1]:
            while right < n - 1 and arr[right] < arr[right + 1]:
                right += 1

            if right < n - 1 and arr[right] > arr[right + 1]:
                while right < n - 1 and arr[right] > arr[right + 1]:
                    right += 1
                res = max(res, right - left + 1)

        left = max(right, left + 1)

    return res


arr = [2, 1, 4, 7, 3, 2, 5]
print(longestMountain(arr))  # 5

```

## 2012. Sum of Beauty in the Array

-   [LeetCode](https://leetcode.com/problems/sum-of-beauty-in-the-array/) | [LeetCode CH](https://leetcode.cn/problems/sum-of-beauty-in-the-array/) (Medium)

-   Tags: array

```python title="2012. Sum of Beauty in the Array - Python Solution"
from typing import List


# DP Prefix and Suffix Decomposition
def sumOfBeauties(nums: List[int]) -> int:
    n = len(nums)
    suf_min = [0] * n
    suf_min[n - 1] = nums[n - 1]
    for i in range(n - 2, 1, -1):
        suf_min[i] = min(suf_min[i + 1], nums[i])

    res = 0
    pre_max = nums[0]
    for i in range(1, n - 1):
        x = nums[i]
        if pre_max < x < suf_min[i + 1]:
            res += 2
        elif nums[i - 1] < x < nums[i + 1]:
            res += 1
        pre_max = max(pre_max, x)

    return res


nums = [2, 4, 6, 4, 5]
print(sumOfBeauties(nums))  # 1

```

## 2909. Minimum Sum of Mountain Triplets II

-   [LeetCode](https://leetcode.com/problems/minimum-sum-of-mountain-triplets-ii/) | [LeetCode CH](https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-ii/) (Medium)

-   Tags: array

## 2483. Minimum Penalty for a Shop

-   [LeetCode](https://leetcode.com/problems/minimum-penalty-for-a-shop/) | [LeetCode CH](https://leetcode.cn/problems/minimum-penalty-for-a-shop/) (Medium)

-   Tags: string, prefix sum

## 1525. Number of Good Ways to Split a String

-   [LeetCode](https://leetcode.com/problems/number-of-good-ways-to-split-a-string/) | [LeetCode CH](https://leetcode.cn/problems/number-of-good-ways-to-split-a-string/) (Medium)

-   Tags: hash table, string, dynamic programming, bit manipulation

## 3354. Make Array Elements Equal to Zero

-   [LeetCode](https://leetcode.com/problems/make-array-elements-equal-to-zero/) | [LeetCode CH](https://leetcode.cn/problems/make-array-elements-equal-to-zero/) (Easy)

-   Tags: array, simulation, prefix sum

## 2874. Maximum Value of an Ordered Triplet II

-   [LeetCode](https://leetcode.com/problems/maximum-value-of-an-ordered-triplet-ii/) | [LeetCode CH](https://leetcode.cn/problems/maximum-value-of-an-ordered-triplet-ii/) (Medium)

-   Tags: array

## 123. Best Time to Buy and Sell Stock III

-   [LeetCode](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/) | [LeetCode CH](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/) (Hard)

-   Tags: array, dynamic programming

```python title="123. Best Time to Buy and Sell Stock III - Python Solution"
from typing import List


# 1. DP
def maxProfitDP1(prices: List[int]) -> int:
    n = len(prices)
    if n <= 1:
        return 0

    dp = [[0] * 5 for _ in range(n)]

    dp[0][0] = 0  # no transaction
    dp[0][1] = -prices[0]  # buy 1
    dp[0][2] = 0  # sell 1
    dp[0][3] = -prices[0]  # buy 2
    dp[0][4] = 0  # sell 2

    for i in range(1, n):
        dp[i][0] = dp[i - 1][0]
        dp[i][1] = max(dp[i - 1][1], -prices[i])
        dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i])
        dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i])
        dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i])

    return dp[-1][4]


# 2. DP - Optimized
def maxProfitDP2(prices: List[int]) -> int:
    b1, b2 = float("inf"), float("inf")
    s1, s2 = 0, 0

    for price in prices:
        b1 = min(b1, price)
        s1 = max(s1, price - b1)
        b2 = min(b2, price - s1)
        s2 = max(s2, price - b2)

    return s2


prices = [3, 3, 5, 0, 0, 3, 1, 4]
print(maxProfitDP1(prices))  # 6
print(maxProfitDP2(prices))  # 6

```

## 2222. Number of Ways to Select Buildings

-   [LeetCode](https://leetcode.com/problems/number-of-ways-to-select-buildings/) | [LeetCode CH](https://leetcode.cn/problems/number-of-ways-to-select-buildings/) (Medium)

-   Tags: string, dynamic programming, prefix sum

## 1031. Maximum Sum of Two Non-Overlapping Subarrays

-   [LeetCode](https://leetcode.com/problems/maximum-sum-of-two-non-overlapping-subarrays/) | [LeetCode CH](https://leetcode.cn/problems/maximum-sum-of-two-non-overlapping-subarrays/) (Medium)

-   Tags: array, dynamic programming, sliding window

## 689. Maximum Sum of 3 Non-Overlapping Subarrays

-   [LeetCode](https://leetcode.com/problems/maximum-sum-of-3-non-overlapping-subarrays/) | [LeetCode CH](https://leetcode.cn/problems/maximum-sum-of-3-non-overlapping-subarrays/) (Hard)

-   Tags: array, dynamic programming

## 2420. Find All Good Indices

-   [LeetCode](https://leetcode.com/problems/find-all-good-indices/) | [LeetCode CH](https://leetcode.cn/problems/find-all-good-indices/) (Medium)

-   Tags: array, dynamic programming, prefix sum

## 2100. Find Good Days to Rob the Bank

-   [LeetCode](https://leetcode.com/problems/find-good-days-to-rob-the-bank/) | [LeetCode CH](https://leetcode.cn/problems/find-good-days-to-rob-the-bank/) (Medium)

-   Tags: array, dynamic programming, prefix sum

## 926. Flip String to Monotone Increasing

-   [LeetCode](https://leetcode.com/problems/flip-string-to-monotone-increasing/) | [LeetCode CH](https://leetcode.cn/problems/flip-string-to-monotone-increasing/) (Medium)

-   Tags: string, dynamic programming

## 334. Increasing Triplet Subsequence

-   [LeetCode](https://leetcode.com/problems/increasing-triplet-subsequence/) | [LeetCode CH](https://leetcode.cn/problems/increasing-triplet-subsequence/) (Medium)

-   Tags: array, greedy

## 2712. Minimum Cost to Make All Characters Equal

-   [LeetCode](https://leetcode.com/problems/minimum-cost-to-make-all-characters-equal/) | [LeetCode CH](https://leetcode.cn/problems/minimum-cost-to-make-all-characters-equal/) (Medium)

-   Tags: string, dynamic programming, greedy

## 1653. Minimum Deletions to Make String Balanced

-   [LeetCode](https://leetcode.com/problems/minimum-deletions-to-make-string-balanced/) | [LeetCode CH](https://leetcode.cn/problems/minimum-deletions-to-make-string-balanced/) (Medium)

-   Tags: string, dynamic programming, stack

## 1186. Maximum Subarray Sum with One Deletion

-   [LeetCode](https://leetcode.com/problems/maximum-subarray-sum-with-one-deletion/) | [LeetCode CH](https://leetcode.cn/problems/maximum-subarray-sum-with-one-deletion/) (Medium)

-   Tags: array, dynamic programming

```python title="1186. Maximum Subarray Sum with One Deletion - Python Solution"
from typing import List


# DP - Kadane
def maximumSum(arr: List[int]) -> int:
    dp0 = arr[0]
    dp1 = 0
    maxSum = dp0

    for i in range(1, len(arr)):
        dp1 = max(dp1 + arr[i], dp0)  # delete previous element or not
        dp0 = max(dp0, 0) + arr[i]  # delete current element or not
        maxSum = max(maxSum, dp0, dp1)  # update result

    return maxSum


arr = [1, -2, 0, 3]
print(maximumSum(arr))  # 4

```

## 42. Trapping Rain Water

-   [LeetCode](https://leetcode.com/problems/trapping-rain-water/) | [LeetCode CH](https://leetcode.cn/problems/trapping-rain-water/) (Hard)

-   Tags: array, two pointers, dynamic programming, stack, monotonic stack
-   ![42](../assets/0042.png)

<iframe width="560" height="315" src="https://www.youtube.com/embed/ZI2z5pq0TqA?si=OEYg01dbmzvmtIwZ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

| Approach   | Time | Space |
| ---------- | ---- | ----- |
| DP         | O(N) | O(N)  |
| Left Right | O(N) | O(1)  |
| Monotonic  | O(N) | O(N)  |

```python title="42. Trapping Rain Water - Python Solution"
from typing import List


# DP
def trapDP(height: List[int]) -> int:
    if not height:
        return 0

    n = len(height)
    maxLeft, maxRight = [0 for _ in range(n)], [0 for _ in range(n)]

    for i in range(1, n):
        maxLeft[i] = max(maxLeft[i - 1], height[i - 1])

    for i in range(n - 2, -1, -1):
        maxRight[i] = max(maxRight[i + 1], height[i + 1])

    res = 0
    for i in range(n):
        res += max(0, min(maxLeft[i], maxRight[i]) - height[i])

    return res


# Left Right Pointers
def trapLR(height: List[int]) -> int:
    if not height:
        return 0

    left, right = 0, len(height) - 1
    maxL, maxR = height[left], height[right]
    res = 0

    while left < right:
        if maxL < maxR:
            left += 1
            maxL = max(maxL, height[left])
            res += maxL - height[left]
        else:
            right -= 1
            maxR = max(maxR, height[right])
            res += maxR - height[right]

    return res


# Monotonic Stack
def trapStack(height: List[int]) -> int:
    stack = []
    total = 0

    for i in range(len(height)):
        while stack and height[i] > height[stack[-1]]:
            top = stack.pop()
            if not stack:
                break
            distance = i - stack[-1] - 1
            bounded_height = min(height[i], height[stack[-1]]) - height[top]
            total += distance * bounded_height
        stack.append(i)

    return total


height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]
print(trapDP(height))  # 6
print(trapLR(height))  # 6
print(trapStack(height))  # 6

```

```cpp title="42. Trapping Rain Water - C++ Solution"
#include <vector>
#include <algorithm>
#include <iostream>
using namespace std;

class Solution
{
public:
    int trap(vector<int> &height)
    {
        if (height.empty())
            return 0;

        int res = 0;
        int left = 0, right = height.size() - 1;
        int maxL = height[left], maxR = height[right];

        while (left < right)
        {
            if (maxL < maxR)
            {
                left++;
                maxL = max(maxL, height[left]);
                res += maxL - height[left];
            }
            else
            {
                right--;
                maxR = max(maxR, height[right]);
                res += maxR - height[right];
            }
        }
        return res;
    }
};

int main()
{
    vector<int> height = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};
    Solution solution;
    cout << solution.trap(height) << endl;
    return 0;
}

```

## 2711. Difference of Number of Distinct Values on Diagonals

-   [LeetCode](https://leetcode.com/problems/difference-of-number-of-distinct-values-on-diagonals/) | [LeetCode CH](https://leetcode.cn/problems/difference-of-number-of-distinct-values-on-diagonals/) (Medium)

-   Tags: array, hash table, matrix

## 1477. Find Two Non-overlapping Sub-arrays Each With Target Sum

-   [LeetCode](https://leetcode.com/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/) | [LeetCode CH](https://leetcode.cn/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/) (Medium)

-   Tags: array, hash table, binary search, dynamic programming, sliding window

## 2680. Maximum OR

-   [LeetCode](https://leetcode.com/problems/maximum-or/) | [LeetCode CH](https://leetcode.cn/problems/maximum-or/) (Medium)

-   Tags: array, greedy, bit manipulation, prefix sum

## 1671. Minimum Number of Removals to Make Mountain Array

-   [LeetCode](https://leetcode.com/problems/minimum-number-of-removals-to-make-mountain-array/) | [LeetCode CH](https://leetcode.cn/problems/minimum-number-of-removals-to-make-mountain-array/) (Hard)

-   Tags: array, binary search, dynamic programming, greedy

```python title="1671. Minimum Number of Removals to Make Mountain Array - Python Solution"
from typing import List


# DP - LIS
def minimumMountainRemovals(nums: List[int]) -> int:
    n = len(nums)
    lis = [1 for _ in range(n)]
    lds = [1 for _ in range(n)]

    for i in range(1, n):
        for j in range(i):
            if nums[i] > nums[j]:
                lis[i] = max(lis[i], lis[j] + 1)

    for i in range(n - 2, -1, -1):
        for j in range(n - 1, i, -1):
            if nums[i] > nums[j]:
                lds[i] = max(lds[i], lds[j] + 1)

    maxLen = 0
    for i in range(1, n - 1):
        if lis[i] > 1 and lds[i] > 1:
            maxLen = max(maxLen, lis[i] + lds[i] - 1)

    return n - maxLen


nums = [2, 1, 1, 5, 6, 2, 3, 1]
print(minimumMountainRemovals(nums))  # 3

```

## 1888. Minimum Number of Flips to Make the Binary String Alternating

-   [LeetCode](https://leetcode.com/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/) | [LeetCode CH](https://leetcode.cn/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/) (Medium)

-   Tags: string, dynamic programming, greedy, sliding window

## 238. Product of Array Except Self

-   [LeetCode](https://leetcode.com/problems/product-of-array-except-self/) | [LeetCode CH](https://leetcode.cn/problems/product-of-array-except-self/) (Medium)

-   Tags: array, prefix sum
-   Classic **Prefix Sum** problem
-   Return an array `output` such that `output[i]` is equal to the product of all the elements of `nums` except `nums[i]`.

| Approach           | Time | Space |
| ------------------ | ---- | ----- |
| Prefix             | O(n) | O(n)  |
| Prefix (Optimized) | O(n) | O(1)  |

```python title="238. Product of Array Except Self - Python Solution"
from typing import List


# Prefix
def productExceptSelf(nums: List[int]) -> List[int]:
    n = len(nums)
    prefix = [1 for _ in range(n)]
    suffix = [1 for _ in range(n)]

    for i in range(1, n):
        prefix[i] = nums[i - 1] * prefix[i - 1]

    for i in range(n - 2, -1, -1):
        suffix[i] = nums[i + 1] * suffix[i + 1]

    result = [i * j for i, j in zip(prefix, suffix)]

    return result


# Prefix (Optimized)
def productExceptSelfOptimized(nums: List[int]) -> List[int]:
    n = len(nums)
    result = [1 for _ in range(n)]

    prefix = 1
    for i in range(n):
        result[i] = prefix
        prefix *= nums[i]

    suffix = 1
    for i in range(n - 1, -1, -1):
        result[i] *= suffix
        suffix *= nums[i]

    return result


print(productExceptSelf([1, 2, 3, 4]))
# [24, 12, 8, 6]
print(productExceptSelfOptimized([1, 2, 3, 4]))
# [24, 12, 8, 6]

```

```cpp title="238. Product of Array Except Self - C++ Solution"
#include <vector>
#include <iostream>
using namespace std;

// Prefix Sum
class Solution
{
public:
    vector<int> productExceptSelf(vector<int> &nums)
    {
        int n = nums.size();
        vector<int> prefix(n, 1);
        vector<int> suffix(n, 1);
        vector<int> res(n, 1);

        for (int i = 1; i < n; i++)
        {
            prefix[i] = prefix[i - 1] * nums[i - 1];
        }

        for (int i = n - 2; i >= 0; i--)
        {
            suffix[i] = suffix[i + 1] * nums[i + 1];
        }

        for (int i = 0; i < n; i++)
        {
            res[i] = prefix[i] * suffix[i];
        }
        return res;
    }
};

int main()
{
    vector<int> nums = {1, 2, 3, 4};
    Solution obj;
    vector<int> result = obj.productExceptSelf(nums);

    for (int i = 0; i < result.size(); i++)
    {
        cout << result[i] << "\n";
    }
    cout << endl;
    // 24, 12, 8, 6
    return 0;
}

```

## 2906. Construct Product Matrix

-   [LeetCode](https://leetcode.com/problems/construct-product-matrix/) | [LeetCode CH](https://leetcode.cn/problems/construct-product-matrix/) (Medium)

-   Tags: array, matrix, prefix sum

## 3334. Find the Maximum Factor Score of Array

-   [LeetCode](https://leetcode.com/problems/find-the-maximum-factor-score-of-array/) | [LeetCode CH](https://leetcode.cn/problems/find-the-maximum-factor-score-of-array/) (Medium)

-   Tags: array, math, number theory

## 2167. Minimum Time to Remove All Cars Containing Illegal Goods

-   [LeetCode](https://leetcode.com/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/) | [LeetCode CH](https://leetcode.cn/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/) (Hard)

-   Tags: string, dynamic programming

## 2484. Count Palindromic Subsequences

-   [LeetCode](https://leetcode.com/problems/count-palindromic-subsequences/) | [LeetCode CH](https://leetcode.cn/problems/count-palindromic-subsequences/) (Hard)

-   Tags: string, dynamic programming

## 2163. Minimum Difference in Sums After Removal of Elements

-   [LeetCode](https://leetcode.com/problems/minimum-difference-in-sums-after-removal-of-elements/) | [LeetCode CH](https://leetcode.cn/problems/minimum-difference-in-sums-after-removal-of-elements/) (Hard)

-   Tags: array, dynamic programming, heap priority queue

## 2565. Subsequence With the Minimum Score

-   [LeetCode](https://leetcode.com/problems/subsequence-with-the-minimum-score/) | [LeetCode CH](https://leetcode.cn/problems/subsequence-with-the-minimum-score/) (Hard)

-   Tags: two pointers, string, binary search

## 1995. Count Special Quadruplets

-   [LeetCode](https://leetcode.com/problems/count-special-quadruplets/) | [LeetCode CH](https://leetcode.cn/problems/count-special-quadruplets/) (Easy)

-   Tags: array, hash table, enumeration

## 2552. Count Increasing Quadruplets

-   [LeetCode](https://leetcode.com/problems/count-increasing-quadruplets/) | [LeetCode CH](https://leetcode.cn/problems/count-increasing-quadruplets/) (Hard)

-   Tags: array, dynamic programming, binary indexed tree, enumeration, prefix sum

```python title="2552. Count Increasing Quadruplets - Python Solution"
from typing import List


# DP
def countQuadruplets(nums: List[int]) -> int:
    n = len(nums)
    great = [[0] * (n + 1) for _ in range(n)]
    less = [0 for _ in range(n + 1)]

    for k in range(n - 2, 1, -1):
        great[k] = great[k + 1].copy()
        for x in range(1, nums[k + 1]):
            great[k][x] += 1

    ans = 0

    for j in range(1, n - 1):
        for x in range(nums[j - 1] + 1, n + 1):
            less[x] += 1
        for k in range(j + 1, n - 1):
            if nums[j] > nums[k]:
                ans += less[nums[k]] * great[k][nums[j]]
    return ans


nums = [1, 3, 2, 4, 5]
print(countQuadruplets(nums))  # 2

```

## 3302. Find the Lexicographically Smallest Valid Sequence

-   [LeetCode](https://leetcode.com/problems/find-the-lexicographically-smallest-valid-sequence/) | [LeetCode CH](https://leetcode.cn/problems/find-the-lexicographically-smallest-valid-sequence/) (Medium)

-   Tags: two pointers, string, dynamic programming, greedy

## 3404. Count Special Subsequences

-   [LeetCode](https://leetcode.com/problems/count-special-subsequences/) | [LeetCode CH](https://leetcode.cn/problems/count-special-subsequences/) (Medium)

-   Tags: array, hash table, math, enumeration

## 3303. Find the Occurrence of First Almost Equal Substring

-   [LeetCode](https://leetcode.com/problems/find-the-occurrence-of-first-almost-equal-substring/) | [LeetCode CH](https://leetcode.cn/problems/find-the-occurrence-of-first-almost-equal-substring/) (Hard)

-   Tags: string, string matching

## 3287. Find the Maximum Sequence Value of Array

-   [LeetCode](https://leetcode.com/problems/find-the-maximum-sequence-value-of-array/) | [LeetCode CH](https://leetcode.cn/problems/find-the-maximum-sequence-value-of-array/) (Hard)

-   Tags: array, dynamic programming, bit manipulation

## 3257. Maximum Value Sum by Placing Three Rooks II

-   [LeetCode](https://leetcode.com/problems/maximum-value-sum-by-placing-three-rooks-ii/) | [LeetCode CH](https://leetcode.cn/problems/maximum-value-sum-by-placing-three-rooks-ii/) (Hard)

-   Tags: array, dynamic programming, matrix, enumeration

## 3410. Maximize Subarray Sum After Removing All Occurrences of One Element

-   [LeetCode](https://leetcode.com/problems/maximize-subarray-sum-after-removing-all-occurrences-of-one-element/) | [LeetCode CH](https://leetcode.cn/problems/maximize-subarray-sum-after-removing-all-occurrences-of-one-element/) (Hard)

-   Tags: array, dynamic programming, segment tree

## 3003. Maximize the Number of Partitions After Operations

-   [LeetCode](https://leetcode.com/problems/maximize-the-number-of-partitions-after-operations/) | [LeetCode CH](https://leetcode.cn/problems/maximize-the-number-of-partitions-after-operations/) (Hard)

-   Tags: string, dynamic programming, bit manipulation, bitmask

## 487. Max Consecutive Ones II

-   [LeetCode](https://leetcode.com/problems/max-consecutive-ones-ii/) | [LeetCode CH](https://leetcode.cn/problems/max-consecutive-ones-ii/) (Medium)

-   Tags: array, dynamic programming, sliding window

## 1746. Maximum Subarray Sum After One Operation

-   [LeetCode](https://leetcode.com/problems/maximum-subarray-sum-after-one-operation/) | [LeetCode CH](https://leetcode.cn/problems/maximum-subarray-sum-after-one-operation/) (Medium)

-   Tags: array, dynamic programming
