{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83d\ude80LeetPattern","text":"<p>Welcome! This project is dedicated to helping you master coding interviews by breaking down common problem-solving patterns.</p> <p>If you find this resource useful, please consider starring \u2b50\ufe0f the repository on GitHub. Your support helps others discover the project and motivates continued development!</p> <p>\ud83d\udcda Inside, you'll find a curated collection of patterns for tackling LeetCode problems. Use these guides to strengthen your understanding of algorithms and data structures, and to approach interview questions with confidence.</p> <p>\ud83c\udf1f Remember, every expert was once a beginner! Start simple and build your confidence. Why not begin with LeetCode Problem 2235 - it's a perfect warm-up that will get you in the coding mindset. You've got this! \ud83d\udcaa</p>"},{"location":"Company/amazon/","title":"Amazon","text":""},{"location":"Company/amazon/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1. Two Sum (Easy)</li> <li> 42. Trapping Rain Water (Hard)</li> <li> 121. Best Time to Buy and Sell Stock (Easy)</li> <li> 3. Longest Substring Without Repeating Characters (Medium)</li> <li> 56. Merge Intervals (Medium)</li> <li> 49. Group Anagrams (Medium)</li> <li> 2. Add Two Numbers (Medium)</li> <li> 23. Merge k Sorted Lists (Hard)</li> <li> 15. 3Sum (Medium)</li> <li> 20. Valid Parentheses (Easy)</li> <li> 33. Search in Rotated Sorted Array (Medium)</li> <li> 53. Maximum Subarray (Medium)</li> <li> 138. Copy List with Random Pointer (Medium)</li> <li> 127. Word Ladder (Hard)</li> <li> 5. Longest Palindromic Substring (Medium)</li> <li> 79. Word Search (Medium)</li> <li> 88. Merge Sorted Array (Easy)</li> <li> 55. Jump Game (Medium)</li> <li> 70. Climbing Stairs (Easy)</li> <li> 22. Generate Parentheses (Medium)</li> <li> 128. Longest Consecutive Sequence (Medium)</li> <li> 14. Longest Common Prefix (Easy)</li> <li> 11. Container With Most Water (Medium)</li> <li> 140. Word Break II (Hard)</li> <li> 26. Remove Duplicates from Sorted Array (Easy)</li> <li> 21. Merge Two Sorted Lists (Easy)</li> <li> 45. Jump Game II (Medium)</li> <li> 54. Spiral Matrix (Medium)</li> <li> 34. Find First and Last Position of Element in Sorted Array (Medium)</li> <li> 62. Unique Paths (Medium)</li> </ul>"},{"location":"Company/amazon/#1-two-sum","title":"1. Two Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return the indices of the two numbers such that they add up to a specific target.\n- Approach: Use a hashmap to store the indices of the numbers.\n- Time Complexity: O(n)\n- Space Complexity: O(n)\n\"\"\"\n\nfrom typing import List\n\n\ndef two_sum(nums: List[int], target: int) -&gt; List[int]:\n    hashmap = {}  # val: idx\n\n    for idx, val in enumerate(nums):\n        if (target - val) in hashmap:\n            return [hashmap[target - val], idx]\n\n        hashmap[val] = idx\n\n    return []\n\n\ndef test_two_sum():\n    assert two_sum([2, 7, 11, 15], 9) == [0, 1]\n    assert two_sum([3, 2, 4], 6) == [1, 2]\n    assert two_sum([3, 3], 6) == [0, 1]\n    assert two_sum([1, 2, 3, 4, 5], 10) == []\n    assert two_sum([-1, -2, -3, -4, -5], -8) == [2, 4]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Solution {\n   public:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {\n        unordered_map&lt;int, int&gt; map;\n\n        for (size_t i = 0; i &lt; nums.size(); i++) {\n            int diff = target - nums[i];\n            if (map.find(diff) != map.end()) {\n                return {map[diff], (int)i};\n            }\n            map[nums[i]] = (int)i;\n        }\n        return {-1, -1};\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; nums = {2, 7, 11, 15};\n    int target = 9;\n    vector&lt;int&gt; result = solution.twoSum(nums, target);\n    assert((result == vector&lt;int&gt;{0, 1}));\n    return 0;\n}\n</code></pre>"},{"location":"Company/amazon/#42-trapping-rain-water","title":"42. Trapping Rain Water","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Dynamic Programming, Stack, Monotonic Stack</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- ![42](../../assets/0042.png)\n\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/ZI2z5pq0TqA?si=OEYg01dbmzvmtIwZ\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen&gt;&lt;/iframe&gt;\n\n| Approach   | Time | Space |\n| ---------- | ---- | ----- |\n| DP         | O(N) | O(N)  |\n| Left Right | O(N) | O(1)  |\n| Monotonic  | O(N) | O(N)  |\n\"\"\"\n\nfrom typing import List\n\n\n# DP\ndef trapDP(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    n = len(height)\n    maxLeft, maxRight = [0 for _ in range(n)], [0 for _ in range(n)]\n\n    for i in range(1, n):\n        maxLeft[i] = max(maxLeft[i - 1], height[i - 1])\n\n    for i in range(n - 2, -1, -1):\n        maxRight[i] = max(maxRight[i + 1], height[i + 1])\n\n    res = 0\n    for i in range(n):\n        res += max(0, min(maxLeft[i], maxRight[i]) - height[i])\n\n    return res\n\n\n# Left Right Pointers\ndef trapLR(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    left, right = 0, len(height) - 1\n    maxL, maxR = height[left], height[right]\n    res = 0\n\n    while left &lt; right:\n        if maxL &lt; maxR:\n            left += 1\n            maxL = max(maxL, height[left])\n            res += maxL - height[left]\n        else:\n            right -= 1\n            maxR = max(maxR, height[right])\n            res += maxR - height[right]\n\n    return res\n\n\n# Monotonic Stack\ndef trapStack(height: List[int]) -&gt; int:\n    stack = []\n    total = 0\n\n    for i in range(len(height)):\n        while stack and height[i] &gt; height[stack[-1]]:\n            top = stack.pop()\n            if not stack:\n                break\n            distance = i - stack[-1] - 1\n            bounded_height = min(height[i], height[stack[-1]]) - height[top]\n            total += distance * bounded_height\n        stack.append(i)\n\n    return total\n\n\nheight = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\nprint(trapDP(height))  # 6\nprint(trapLR(height))  # 6\nprint(trapStack(height))  # 6\n</code></pre> <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int trap(vector&lt;int&gt; &amp;height)\n    {\n        if (height.empty())\n            return 0;\n\n        int res = 0;\n        int left = 0, right = height.size() - 1;\n        int maxL = height[left], maxR = height[right];\n\n        while (left &lt; right)\n        {\n            if (maxL &lt; maxR)\n            {\n                left++;\n                maxL = max(maxL, height[left]);\n                res += maxL - height[left];\n            }\n            else\n            {\n                right--;\n                maxR = max(maxR, height[right]);\n                res += maxR - height[right];\n            }\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    vector&lt;int&gt; height = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};\n    Solution solution;\n    cout &lt;&lt; solution.trap(height) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"Company/amazon/#121-best-time-to-buy-and-sell-stock","title":"121. Best Time to Buy and Sell Stock","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return the maximum profit that can be achieved from buying on one day and selling on another day.\n\"\"\"\n\nfrom typing import List\n\n\n# Brute Force\ndef maxProfitBF(prices: List[int]) -&gt; int:\n    max_profit = 0\n    n = len(prices)\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_profit = max(max_profit, prices[j] - prices[i])\n\n    return max_profit\n\n\n# DP\ndef maxProfitDP(prices: List[int]) -&gt; int:\n    dp = [[0] * 2 for _ in range(len(prices))]\n    dp[0][0] = -prices[0]  # buy\n    dp[0][1] = 0  # sell\n\n    for i in range(1, len(prices)):\n        dp[i][0] = max(dp[i - 1][0], -prices[i])  # the lowest price to buy\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    max_profit = 0\n    seen_min = prices[0]\n\n    for i in range(1, len(prices)):\n        max_profit = max(max_profit, prices[i] - seen_min)\n        seen_min = min(seen_min, prices[i])\n\n    return max_profit\n\n\n# Fast Slow Pointers\ndef maxProfitFS(prices: List[int]) -&gt; int:\n    max_profit = 0\n    slow, fast = 0, 1\n\n    while fast &lt; len(prices):\n        if prices[fast] &gt; prices[slow]:\n            max_profit = max(max_profit, prices[fast] - prices[slow])\n        else:\n            slow = fast\n        fast += 1\n\n    return max_profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force|  O(n^2)|  O(1)   |\n# | DP         |  O(n)  |  O(n)   |\n# | Greedy     |  O(n)  |  O(1)   |\n# | Fast Slow  |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitBF(prices))  # 5\nprint(maxProfitDP(prices))  # 5\nprint(maxProfitGreedy(prices))  # 5\nprint(maxProfitFS(prices))  # 5\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int maxProfitMemo(vector&lt;int&gt; &amp;prices) {\n        if (prices.size() &lt;= 1) return 0;\n\n        int seen_min = prices[0];\n        int res = 0;\n\n        for (int &amp;price : prices) {\n            res = max(res, price - seen_min);\n            seen_min = min(seen_min, price);\n        }\n        return res;\n    }\n};\n\nint main() {\n    vector&lt;int&gt; prices = {7, 1, 5, 3, 6, 4};\n    Solution obj;\n    cout &lt;&lt; obj.maxProfitMemo(prices) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"Company/amazon/#3-longest-substring-without-repeating-characters","title":"3. Longest Substring Without Repeating Characters","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Classic variable sliding window problem. Use a set to keep track of the characters in the current window.\n- Return the length of the longest substring without repeating characters.\n- [Template tutorial by \u7075\u5c71\u8336\u827e\u5e9c](https://leetcode.cn/problems/longest-substring-without-repeating-characters/solutions/1959540/xia-biao-zong-suan-cuo-qing-kan-zhe-by-e-iaks)\n\"\"\"\n\nfrom collections import defaultdict\n\n\n# Sliding Window Variable Max - HashMap\ndef lengthOfLongestSubstringHash(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    left = 0\n    cnt = defaultdict(int)\n    res = 0\n\n    for right in range(n):\n        cnt[s[right]] += 1\n\n        while cnt[s[right]] &gt; 1:\n            cnt[s[left]] -= 1\n            left += 1\n\n        res = max(res, right - left + 1)\n\n    return res\n\n\n# Sliding Window Variable Max - Set\ndef lengthOfLongestSubstringSet(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    left = 0\n    res = 0\n    window = set()\n\n    for right in range(n):\n        while left &lt; right and s[right] in window:\n            window.remove(s[left])\n            left += 1\n        window.add(s[right])\n        res = max(res, right - left + 1)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    s = \"abcabcbb\"\n    assert lengthOfLongestSubstringHash(s) == 3\n    assert lengthOfLongestSubstringSet(s) == 3\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;unordered_set&gt;\nusing namespace std;\n\nint lengthOfLongestSubstring(string s) {\n    int n = s.length();\n    int res = 0;\n    int left = 0;\n    unordered_set&lt;char&gt; window;\n\n    for (int right = 0; right &lt; n; right++) {\n        char ch = s[right];\n\n        while (window.find(ch) != window.end()) {\n            window.erase(s[left]);\n            left++;\n        }\n\n        window.insert(ch);\n        res = max(res, right - left + 1);\n    }\n    return (int)res;\n}\n\nint main() {\n    string s = \"abcabcbb\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 3\n    s = \"bbbbb\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 1\n    s = \"pwwkew\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 3\n    return 0;\n}\n</code></pre>"},{"location":"Company/amazon/#56-merge-intervals","title":"56. Merge Intervals","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sorting</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Merge all overlapping intervals.\n\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/44H3cEC2fFM?si=J-Jr_Fg2eDse3-de\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen&gt;&lt;/iframe&gt;\n\"\"\"\n\nfrom typing import List\n\n\n# Intervals\ndef merge(intervals: List[List[int]]) -&gt; List[List[int]]:\n    n = len(intervals)\n    if n &lt;= 1:\n        return intervals\n\n    intervals.sort(key=lambda x: x[0])\n    res = [intervals[0]]\n\n    for i in range(1, n):\n        if intervals[i][0] &lt;= res[-1][1]:\n            res[-1][1] = max(res[-1][1], intervals[i][1])\n        else:\n            res.append(intervals[i])\n\n    return res\n\n\nprint(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))\n# [[1, 6], [8, 10], [15, 18]]\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// Interval\nvector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {\n    sort(intervals.begin(), intervals.end());\n    vector&lt;vector&lt;int&gt;&gt; res;\n\n    for (auto&amp; range : intervals) {\n        if (!res.empty() &amp;&amp; range[0] &lt;= res.back()[1]) {\n            res.back()[1] = max(res.back()[1], range[1]);\n        } else {\n            res.emplace_back(range);\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;vector&lt;int&gt;&gt; intervals = {{1, 3}, {2, 6}, {8, 10}, {15, 18}};\n    vector&lt;vector&lt;int&gt;&gt; res = merge(intervals);\n    for (auto&amp; range : res) {\n        cout &lt;&lt; range[0] &lt;&lt; \", \" &lt;&lt; range[1] &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Company/amazon/#49-group-anagrams","title":"49. Group Anagrams","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Sorting</p> </li> </ul> PythonCPP <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash - List\ndef groupAnagrams(strs: List[str]) -&gt; List[List[str]]:\n    result = defaultdict(list)\n\n    for s in strs:\n        count = [0] * 26\n        for i in s:\n            count[ord(i) - ord(\"a\")] += 1\n\n        result[tuple(count)].append(s)\n\n    return list(result.values())\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Hash     |     O(n * k)    |     O(n)     |\n# |-------------|-----------------|--------------|\n\n\nstrs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\nprint(groupAnagrams(strs))\n# [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;cassert&gt;\n#include &lt;ranges&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Solution {\n   public:\n    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) {\n        unordered_map&lt;string, vector&lt;string&gt;&gt; map;\n\n        for (string&amp; s : strs) {\n            string sorted = s;\n            ranges::sort(sorted);\n            map[sorted].push_back(s);\n        }\n\n        vector&lt;vector&lt;string&gt;&gt; res;\n\n        for (auto&amp; kv : map) {\n            res.push_back(kv.second);\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;string&gt; strs = {\"eat\", \"tea\", \"tan\"};\n    vector&lt;vector&lt;string&gt;&gt; res = solution.groupAnagrams(strs);\n    assert((res == vector&lt;vector&lt;string&gt;&gt;{{\"eat\", \"tea\"}, {\"tan\"}} ||\n            res == vector&lt;vector&lt;string&gt;&gt;{{\"tan\"}, {\"eat\", \"tea\"}}));\n\n    return 0;\n}\n</code></pre>"},{"location":"Company/amazon/#2-add-two-numbers","title":"2. Add Two Numbers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Math, Recursion</p> </li> </ul> PythonCPP <pre><code>from typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\ndef add_two_numbers(l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]:\n    \"\"\"Add two numbers represented by linked lists.\"\"\"\n    dummy = ListNode()\n    cur = dummy\n    carry = 0\n\n    while l1 or l2:\n        v1 = l1.val if l1 else 0\n        v2 = l2.val if l2 else 0\n\n        carry, val = divmod(v1 + v2 + carry, 10)\n        cur.next = ListNode(val)\n        cur = cur.next\n\n        if l1:\n            l1 = l1.next\n        if l2:\n            l2 = l2.next\n\n    if carry:\n        cur.next = ListNode(val=carry)\n\n    return dummy.next\n\n\ndef test_add_two_numbers():\n    l1 = LinkedList([2, 4, 3]).head\n    l2 = LinkedList([5, 6, 4]).head\n    added = add_two_numbers(l1, l2)\n    assert LinkedList(added).to_array() == [7, 0, 8]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode* next) : val(x), next(next) {}\n};\n\nclass Solution {\n   public:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode dummy;\n        ListNode* cur = &amp;dummy;\n        int carry = 0;\n\n        while (l1 || l2 || carry) {\n            if (l1) {\n                carry += l1-&gt;val;\n                l1 = l1-&gt;next;\n            }\n            if (l2) {\n                carry += l2-&gt;val;\n                l2 = l2-&gt;next;\n            }\n            cur-&gt;next = new ListNode(carry % 10);\n            cur = cur-&gt;next;\n            carry /= 10;\n        }\n        return dummy.next;\n    }\n};\n\nint main() {\n    Solution sol;\n\n    ListNode* l1 = new ListNode(2, new ListNode(4, new ListNode(3)));\n    ListNode* l2 = new ListNode(5, new ListNode(6, new ListNode(4)));\n    ListNode* result = sol.addTwoNumbers(l1, l2);\n\n    vector&lt;int&gt; expected = {7, 0, 8};\n    for (int val : expected) {\n        assert(result != nullptr &amp;&amp; result-&gt;val == val);\n        result = result-&gt;next;\n    }\n    assert(result == nullptr);  // End of list\n\n    return 0;\n}\n</code></pre>"},{"location":"Company/amazon/#23-merge-k-sorted-lists","title":"23. Merge k Sorted Lists","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Divide And Conquer, Heap Priority Queue, Merge Sort</p> </li> </ul> Python <pre><code>\"\"\"\n-   Prerequisite: 21. Merge Two Sorted Lists\n-   Video explanation: [23. Merge K Sorted Lists - NeetCode](https://youtu.be/q5a5OiGbT6Q?si=SQ2dCvsYQ3LQctPh)\n\"\"\"\n\nimport copy\nimport heapq\nfrom typing import List, Optional\n\nfrom leetpattern.utils import ListNode, list_from_array, list_to_array\n\n\ndef merge_k_lists_divide_conquer(\n    lists: List[Optional[ListNode]],\n) -&gt; Optional[ListNode]:\n    if not lists or len(lists) == 0:\n        return None\n\n    def mergeTwo(l1, l2):\n        dummy = ListNode()\n        cur = dummy\n\n        while l1 and l2:\n            if l1.val &lt; l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n\n            cur = cur.next\n\n        cur.next = l1 if l1 else l2\n\n        return dummy.next\n\n    while len(lists) &gt; 1:\n        merged = []\n\n        for i in range(0, len(lists), 2):\n            l1 = lists[i]\n            l2 = lists[i + 1] if i + 1 &lt; len(lists) else None\n            merged.append(mergeTwo(l1, l2))\n\n        lists = merged\n\n    return lists[0]\n\n\ndef merge_k_lists_heap(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    min_heap = []  # (val, idx, node)\n\n    for idx, head in enumerate(lists):\n        if head:\n            heapq.heappush(min_heap, (head.val, idx, head))\n\n    while min_heap:\n        _, idx, node = heapq.heappop(min_heap)\n        cur.next = node\n        cur = cur.next\n\n        node = node.next\n        if node:\n            heapq.heappush(min_heap, (node.val, idx, node))\n\n    return dummy.next\n\n\ndef test_merge_k_lists() -&gt; None:\n    n1 = list_from_array([1, 4])\n    n2 = list_from_array([1, 3])\n    n3 = list_from_array([2, 6])\n    lists = [n1, n2, n3]\n    lists1 = copy.deepcopy(lists)\n    lists2 = copy.deepcopy(lists)\n    assert (list_to_array(merge_k_lists_divide_conquer(lists1))) == [\n        1,\n        1,\n        2,\n        3,\n        4,\n        6,\n    ]\n    assert (list_to_array(merge_k_lists_heap(lists2))) == [1, 1, 2, 3, 4, 6]\n</code></pre>"},{"location":"Company/amazon/#15-3sum","title":"15. 3Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Sorting</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef threeSum(nums: List[int]) -&gt; List[List[int]]:\n    nums.sort()\n    res = []\n    n = len(nums)\n\n    for i in range(n - 2):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        left, right = i + 1, n - 1\n\n        while left &lt; right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total &gt; 0:\n                right -= 1\n            elif total &lt; 0:\n                left += 1\n            else:\n                res.append([nums[i], nums[left], nums[right]])\n\n                while left &lt; right and nums[left] == nums[left + 1]:\n                    left += 1\n\n                while left &lt; right and nums[right] == nums[right - 1]:\n                    right -= 1\n\n                left += 1\n                right -= 1\n\n    return res\n\n\nnums = [-1, 0, 1, 2, -1, -4]\nassert threeSum(nums) == [[-1, -1, 2], [-1, 0, 1]]\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {\n    sort(nums.begin(), nums.end());\n    vector&lt;vector&lt;int&gt;&gt; res;\n    int n = nums.size();\n\n    for (int i = 0; i &lt; n - 2; i++) {\n        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) {\n            continue;\n        }\n\n        int left = i + 1, right = n - 1;\n\n        while (left &lt; right) {\n            int total = nums[i] + nums[left] + nums[right];\n\n            if (total &gt; 0)\n                right--;\n            else if (total &lt; 0)\n                left++;\n            else {\n                res.push_back({nums[i], nums[left], nums[right]});\n                while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++;\n                while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--;\n                left++;\n                right--;\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {-1, 0, 1, 2, -1, -4};\n    vector&lt;vector&lt;int&gt;&gt; res = threeSum(nums);\n    for (auto&amp; v : res) {\n        for (int i : v) {\n            cout &lt;&lt; i &lt;&lt; \" \";\n        }\n        cout &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Company/amazon/#20-valid-parentheses","title":"20. Valid Parentheses","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack</p> </li> </ul> PythonCPP <pre><code># Stack\ndef is_valid(s: str) -&gt; bool:\n    if len(s) % 2:\n        return False\n\n    pairs = {\n        \"(\": \")\",\n        \"{\": \"}\",\n        \"[\": \"]\",\n    }\n    stack = []\n    for ch in s:\n        if ch in pairs:\n            stack.append(ch)\n        elif not stack or ch != pairs[stack.pop()]:\n            return False\n\n    return True if not stack else False\n\n\ndef test_is_valid():\n    assert is_valid(\"()[]{}\")\n    assert not is_valid(\"(]\")\n    assert not is_valid(\"([)]\")\n    assert is_valid(\"{[]}\")\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;stack&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool isValid(string s) {\n        unordered_map&lt;char, char&gt; map{{')', '('}, {'}', '{'}, {']', '['}};\n        stack&lt;char&gt; stack;\n        if (s.length() % 2 == 1) return false;\n\n        for (char&amp; ch : s) {\n            if (stack.empty() || map.find(ch) == map.end()) {\n                stack.push(ch);\n            } else {\n                if (map[ch] != stack.top()) {\n                    return false;\n                }\n                stack.pop();\n            }\n        }\n        return stack.empty();\n    }\n};\n\nint main() {\n    Solution s;\n    assert(s.isValid(\"()\") == true);\n    assert(s.isValid(\"()[]{}\") == true);\n    assert(s.isValid(\"(]\") == false);\n    assert(s.isValid(\"([)]\") == false);\n    assert(s.isValid(\"{[]}\") == true);\n    return 0;\n}\n</code></pre>"},{"location":"Company/amazon/#33-search-in-rotated-sorted-array","title":"33. Search in Rotated Sorted Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Binary Search\ndef search(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] == target:\n            return mid\n\n        if nums[left] &lt;= nums[mid]:\n            if nums[left] &lt;= target &lt; nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if nums[mid] &lt; target &lt;= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n    return -1\n\n\nnums = [4, 5, 6, 7, 0, 1, 2]\ntarget = 0\nprint(search(nums, target))  # 4\n</code></pre>"},{"location":"Company/amazon/#53-maximum-subarray","title":"53. Maximum Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Divide And Conquer, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP Kadane\ndef maxSubArrayDP(nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n\n    dp[0] = nums[0]\n    maxSum = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(\n            dp[i - 1] + nums[i],  # continue the previous subarray\n            nums[i],  # start a new subarray\n        )\n        maxSum = max(maxSum, dp[i])\n\n    return maxSum\n\n\n# Greedy\ndef maxSubArrayGreedy(nums: List[int]) -&gt; int:\n    max_sum = nums[0]\n    cur_sum = 0\n\n    for num in nums:\n        cur_sum = max(cur_sum + num, num)\n        max_sum = max(max_sum, cur_sum)\n\n    return max_sum\n\n\n# Prefix Sum\ndef maxSubArrayPrefixSum(nums: List[int]) -&gt; int:\n    prefix_sum = 0\n    prefix_sum_min = 0\n    res = float(\"-inf\")\n\n    for num in nums:\n        prefix_sum += num\n        res = max(res, prefix_sum - prefix_sum_min)\n        prefix_sum_min = min(prefix_sum_min, prefix_sum)\n\n    return res\n\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArrayDP(nums))  # 6\nprint(maxSubArrayGreedy(nums))  # 6\nprint(maxSubArrayPrefixSum(nums))  # 6\n</code></pre>"},{"location":"Company/amazon/#138-copy-list-with-random-pointer","title":"138. Copy List with Random Pointer","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Linked List</p> </li> </ul> Python <pre><code>from typing import Optional\n\n\nclass Node:\n    def __init__(self, x: int, next: \"Node\" = None, random: \"Node\" = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\n\ndef copyRandomList(head: \"Optional[Node]\") -&gt; \"Optional[Node]\":\n    if not head:\n        return None\n\n    # Copy nodes and link them together\n    cur = head\n    while cur:\n        new_node = Node(cur.val)\n        new_node.next = cur.next\n        cur.next = new_node\n        cur = new_node.next\n\n    # Copy random pointers\n    cur = head\n    while cur:\n        cur.next.random = cur.random.next if cur.random else None\n        cur = cur.next.next\n\n    # Separate the original and copied lists\n    cur = head\n    new_head = head.next\n    while cur:\n        new_node = cur.next\n        cur.next = new_node.next\n        new_node.next = new_node.next.next if new_node.next else None\n        cur = cur.next\n\n    return new_head\n</code></pre>"},{"location":"Company/amazon/#127-word-ladder","title":"127. Word Ladder","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Breadth First Search</p> </li> </ul> Python <pre><code>\"\"\"\n-   The most classic BFS problem.\n-   Return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\n-   Approach: BFS\n-   Time Complexity: O(n * m^2)\n-   Space Complexity: O(n * m)\n\"\"\"\n\nfrom collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef ladderLength(beginWord: str, endWord: str, wordList: List[str]) -&gt; int:\n    if endWord not in wordList:\n        return 0\n\n    n = len(beginWord)\n    graph = defaultdict(list)  # pattern: words\n    wordList.append(beginWord)\n\n    for word in wordList:\n        for i in range(n):\n            pattern = word[:i] + \"*\" + word[i + 1 :]\n            graph[pattern].append(word)\n\n    visited = set([beginWord])\n    q = deque([beginWord])\n    res = 1\n\n    while q:\n        size = len(q)\n        for _ in range(size):\n            word = q.popleft()\n            if word == endWord:\n                return res\n\n            for i in range(n):\n                pattern = word[:i] + \"*\" + word[i + 1 :]\n                for neighbor in graph[pattern]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        q.append(neighbor)\n        res += 1\n\n    return 0\n\n\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]\nprint(ladderLength(beginWord, endWord, wordList))  # 5\n</code></pre>"},{"location":"Company/amazon/#5-longest-palindromic-substring","title":"5. Longest Palindromic Substring","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Dynamic Programming</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the longest palindromic substring in `s`.\n\"\"\"\n\n\n# DP - Interval\ndef longestPalindromeDP(s: str) -&gt; str:\n    n = len(s)\n    if n &lt;= 1:\n        return s\n\n    start, maxLen = 0, 1\n\n    # Init\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for j in range(1, n):\n        for i in range(j):\n            if s[i] == s[j]:\n                if j - i &lt;= 2:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1]\n\n                if dp[i][j] and j - i + 1 &gt; maxLen:\n                    maxLen = j - i + 1\n                    start = i\n\n    return s[start : start + maxLen]\n\n\n# Expand Around Center\ndef longestPalindromeCenter(s: str) -&gt; str:\n    def expand_around_center(left, right):\n        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n\n    if len(s) &lt;= 1:\n        return s\n\n    start, end = 0, 0\n    for i in range(len(s)):\n        len1 = expand_around_center(i, i)  # odd\n        len2 = expand_around_center(i, i + 1)  # even\n\n        maxLen = max(len1, len2)\n        if maxLen &gt; end - start:\n            start = i - (maxLen - 1) // 2\n            end = i + maxLen // 2\n\n    return s[start : end + 1]\n\n\ns = \"babad\"\nprint(longestPalindromeDP(s))  # \"bab\"\nprint(longestPalindromeCenter(s))  # \"aba\"\n</code></pre>"},{"location":"Company/amazon/#79-word-search","title":"79. Word Search","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Backtracking, Depth First Search, Matrix</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef exist(board: List[List[str]], word: str) -&gt; bool:\n    m, n = len(board), len(board[0])\n    path = set()\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n\n    def dfs(r, c, i):\n        if i == len(word):\n            return True\n\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or board[r][c] != word[i] or (r, c) in path:\n            return False\n\n        path.add((r, c))\n\n        for dr, dc in dirs:\n            if dfs(r + dr, c + dc, i + 1):\n                return True\n\n        path.remove((r, c))\n        return False\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, 0):\n                return True\n\n    return False\n\n\nboard = [\n    [\"A\", \"B\", \"C\", \"E\"],\n    [\"S\", \"F\", \"C\", \"S\"],\n    [\"A\", \"D\", \"E\", \"E\"],\n]\nword = \"ABCCED\"\nprint(exist(board, word))  # True\n</code></pre>"},{"location":"Company/amazon/#88-merge-sorted-array","title":"88. Merge Sorted Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Sorting</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\nclass merge:\n    @staticmethod\n    def lr(nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None:\n        \"\"\"\n        Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        p1, p2, t = m - 1, n - 1, m + n - 1\n\n        while p1 &gt;= 0 or p2 &gt;= 0:\n            if p1 == -1:\n                nums1[t] = nums2[p2]\n                p2 -= 1\n            elif p2 == -1:\n                nums1[t] = nums1[p1]\n                p1 -= 1\n            elif nums1[p1] &gt; nums2[p2]:\n                nums1[t] = nums1[p1]\n                p1 -= 1\n            else:\n                nums1[t] = nums2[p2]\n                p2 -= 1\n\n            t -= 1\n\n\nif __name__ == \"__main__\":\n    nums1 = [1, 2, 3, 0, 0, 0]\n    m = 3\n    nums2 = [2, 5, 6]\n    n = 3\n    merge.lr(nums1, m, nums2, n)\n    assert nums1 == [1, 2, 2, 3, 5, 6]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {\n        int p1 = m - 1, p2 = n - 1, t = m + n - 1;\n\n        while (p1 &gt;= 0 || p2 &gt;= 0) {\n            if (p1 == -1) {\n                nums1[t] = nums2[p2];\n                p2--;\n            } else if (p2 == -1) {\n                nums1[t] = nums1[p1];\n                p1--;\n            } else if (nums1[p1] &gt; nums2[p2]) {\n                nums1[t] = nums1[p1];\n                p1--;\n            } else {\n                nums1[t] = nums2[p2];\n                p2--;\n            }\n            t--;\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; nums1 = {1, 3, 6, 0, 0, 0};\n    vector&lt;int&gt; nums2 = {2, 5, 6};\n    vector&lt;int&gt; output = {1, 2, 3, 5, 6, 6};\n    solution.merge(nums1, 3, nums2, 3);\n    assert(nums1 == output);\n    return 0;\n}\n</code></pre>"},{"location":"Company/amazon/#55-jump-game","title":"55. Jump Game","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return `True` if you can reach the last index, otherwise `False`.\n\"\"\"\n\nfrom typing import List\n\n\n# Greedy - Interval\ndef canJump(nums: List[int]) -&gt; bool:\n    n = len(nums)\n    reach = 0\n    i = 0\n\n    while reach &gt;= i:\n        if reach &gt;= n - 1:\n            return True\n        reach = max(reach, i + nums[i])\n        i += 1\n\n    return False\n\n\nif __name__ == \"__main__\":\n    assert canJump([2, 3, 1, 1, 4]) is True\n    assert canJump([3, 2, 1, 0, 4]) is False\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool canJump(vector&lt;int&gt;&amp; nums) {\n        int canReach = 0;\n        int n = nums.size();\n\n        for (int i = 0; i &lt; n; i++) {\n            if (i &gt; canReach) return false;\n            canReach = max(canReach, i + nums[i]);\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution obj;\n    vector&lt;int&gt; nums = {2, 3, 1, 1, 4};\n    cout &lt;&lt; obj.canJump(nums) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"Company/amazon/#70-climbing-stairs","title":"70. Climbing Stairs","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Memoization</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return the number of distinct ways to reach the top of the stairs.\n- `dp[n]` stores the number of distinct ways to reach the `n-th` stair.\n- Formula: `dp[n] = dp[n - 1] + dp[n - 2]`.\n- Initialize `dp[0] = 0`, `dp[1] = 1`, and `dp[2] = 2`.\n\"\"\"\n\nfrom functools import cache\n\n\n# DP\ndef climbStairsDP(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    dp = [i for i in range(n + 1)]\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\n# DP (Optimized)\ndef climbStairsDPOptimized(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    first, second = 1, 2\n\n    for _ in range(3, n + 1):\n        first, second = second, first + second\n\n    return second\n\n\n# Recursion\ndef climbStairsRecursion(n: int) -&gt; int:\n    @cache\n    def dfs(i: int) -&gt; int:\n        if i &lt;= 1:\n            return 1\n        return dfs(i - 1) + dfs(i - 2)\n\n    return dfs(n)\n\n\n# Greedy\ndef climbStairsGreedy(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    p1, p2 = 1, 2\n\n    for _ in range(3, n + 1):\n        p1, p2 = p2, p1 + p2\n\n    return p2\n\n\nif __name__ == \"__main__\":\n    assert climbStairsDP(10) == 89\n    assert climbStairsDPOptimized(10) == 89\n    assert climbStairsRecursion(10) == 89\n    assert climbStairsGreedy(10) == 89\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nint climbStairs(int n) {\n    if (n &lt;= 2) return n;\n    int f1 = 1, f2 = 2;\n    int res;\n\n    int i = 3;\n    while (i &lt;= n) {\n        res = f1 + f2;\n        f1 = f2;\n        f2 = res;\n        i++;\n    }\n    return res;\n}\n\nint main() {\n    assert(climbStairs(2) == 2);\n    assert(climbStairs(5) == 8);\n    assert(climbStairs(10) == 89);\n    return 0;\n}\n</code></pre>"},{"location":"Company/amazon/#22-generate-parentheses","title":"22. Generate Parentheses","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Backtracking</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Backtracking\ndef generateParenthesis1(n: int) -&gt; List[str]:\n    path, res = [], []\n\n    def dfs(openN, closeN):\n        if openN == closeN == n:\n            res.append(\"\".join(path))\n            return\n\n        if openN &lt; n:\n            path.append(\"(\")\n            dfs(openN + 1, closeN)\n            path.pop()\n\n        if closeN &lt; openN:\n            path.append(\")\")\n            dfs(openN, closeN + 1)\n            path.pop()\n\n    dfs(0, 0)\n\n    return res\n\n\n# Backtracking\ndef generateParenthesis2(n: int) -&gt; List[str]:\n    m = n * 2\n    res, path = [], [\"\"] * m\n\n    def dfs(i, left):\n        if i == m:\n            res.append(\"\".join(path))\n            return\n\n        if left &lt; n:\n            path[i] = \"(\"\n            dfs(i + 1, left + 1)\n        if i - left &lt; left:\n            path[i] = \")\"\n            dfs(i + 1, left)\n\n    dfs(0, 0)\n    return res\n\n\nif __name__ == \"__main__\":\n    print(generateParenthesis1(3))\n    # ['((()))', '(()())', '(())()', '()(())', '()()()']\n    print(generateParenthesis2(3))\n    # ['((()))', '(()())', '(())()', '()(())', '()()()']\n</code></pre>"},{"location":"Company/amazon/#128-longest-consecutive-sequence","title":"128. Longest Consecutive Sequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Union Find</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Set\ndef longestConsecutiveSet(nums: List[int]) -&gt; int:\n    num_set = set(nums)  # O(n)\n    longest = 0\n\n    for n in nums:\n        if (n - 1) not in num_set:  # left boundary\n            length = 1\n\n            while (n + length) in num_set:\n                length += 1\n\n            longest = max(longest, length)\n\n    return longest\n\n\n# Union Find\ndef longestConsecutiveUF(nums: List[int]) -&gt; int:\n    if not nums:\n        return 0\n\n    par = {num: num for num in nums}\n    rank = {num: 1 for num in nums}\n\n    def find(num):\n        p = par[num]\n        while p != par[p]:\n            p = par[p]\n        return p\n\n    def union(num1, num2):\n        p1, p2 = find(num1), find(num2)\n        if p1 == p2:\n            return\n\n        if rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n            rank[p2] += rank[p1]\n        else:\n            par[p2] = p1\n            rank[p1] += rank[p2]\n\n    for num in nums:\n        if num - 1 in par:\n            union(num, num - 1)\n\n    return max(rank.values())\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |  Set       |  O(N)  |  O(N)   |\n# | Union Find |  O(N)  |  O(N)   |\n# |------------|--------|---------|\n\n\nnums = [100, 4, 200, 1, 3, 2]\nprint(longestConsecutiveSet(nums))  # 4\nprint(longestConsecutiveUF(nums))  # 4\n</code></pre>"},{"location":"Company/amazon/#14-longest-common-prefix","title":"14. Longest Common Prefix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Trie</p> </li> </ul> Python <pre><code>from typing import List\n\n\nclass longestCommonPrefix:\n    def horizontal_scan(self, strs: List[str]) -&gt; str:\n        if not strs:\n            return \"\"\n\n        prefix = strs[0]\n        for i in range(1, len(strs)):\n            while not strs[i].startswith(prefix):\n                prefix = prefix[:-1]\n                if not prefix:\n                    return \"\"\n\n        return prefix\n\n    def vertical_scan(self, strs: List[str]) -&gt; str:\n        if not strs:\n            return \"\"\n\n        for i in range(len(strs[0])):\n            char = strs[0][i]\n            for j in range(1, len(strs)):\n                if i &gt;= len(strs[j]) or strs[j][i] != char:\n                    return strs[0][:i]\n\n        return strs[0]\n\n    def divide_conquer(self, strs: List[str]) -&gt; str:\n        if not strs:\n            return \"\"\n\n        def merge(left, right):\n            n = min(len(left), len(right))\n            for i in range(n):\n                if left[i] != right[i]:\n                    return left[:i]\n            return left[:n]\n\n        def find(strs, start, end):\n            if start == end:\n                return strs[start]\n            mid = start + (end - start) // 2\n            left = find(strs, start, mid)\n            right = find(strs, mid + 1, end)\n            return merge(left, right)\n\n        return find(strs, 0, len(strs) - 1)\n\n    def binary_search(self, strs: List[str]) -&gt; str:\n        if not strs:\n            return \"\"\n\n        def isCommonPrefix(strs, length):\n            prefix = strs[0][:length]\n            return all(s.startswith(prefix) for s in strs)\n\n        minLen = min(len(s) for s in strs)\n        low, high = 0, minLen\n        while low &lt; high:\n            mid = low + (high - low) // 2\n            if isCommonPrefix(strs, mid + 1):\n                low = mid + 1\n            else:\n                high = mid\n\n        return strs[0][:low]\n\n\nif __name__ == \"__main__\":\n    solution = longestCommonPrefix()\n    strs = [\"flower\", \"flow\", \"flight\"]\n    assert solution.horizontal_scan(strs) == \"fl\"\n    assert solution.vertical_scan(strs) == \"fl\"\n    assert solution.divide_conquer(strs) == \"fl\"\n    assert solution.binary_search(strs) == \"fl\"\n</code></pre>"},{"location":"Company/amazon/#11-container-with-most-water","title":"11. Container With Most Water","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Greedy</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return the maximum area of water that can be trapped between the vertical lines.\n\n![11](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)\n\"\"\"\n\nfrom typing import List\n\n\n# Brute Force\ndef maxAreaBF(height: List[int]) -&gt; int:\n    max_area = 0\n\n    for i in range(len(height)):\n        for j in range(i + 1, len(height)):\n            h = min(height[i], height[j])\n            w = j - i\n            max_area = max(max_area, h * w)\n\n    return max_area\n\n\n# Left Right Pointers\ndef maxAreaLR(height: List[int]) -&gt; int:\n    left, right = 0, len(height) - 1\n    res = 0\n\n    while left &lt; right:\n        h = min(height[left], height[right])\n        w = right - left\n        res = max(res, h * w)\n\n        if height[left] &lt; height[right]:\n            left += 1\n        else:\n            right -= 1\n\n    return res\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force| O(n^2) |  O(1)   |\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nheight = [1, 8, 6, 2, 5, 4, 8, 3, 7]\nprint(maxAreaBF(height))  # 49\nprint(maxAreaLR(height))  # 49\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint maxArea(vector&lt;int&gt;&amp; height) {\n    int left = 0, right = height.size() - 1;\n    int res = 0;\n\n    while (left &lt; right) {\n        int h = min(height[left], height[right]);\n        int w = right - left;\n        res = max(res, h * w);\n\n        if (height[left] &lt; height[right])\n            left++;\n        else\n            right--;\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; height = {1, 8, 6, 2, 5, 4, 8, 3, 7};\n    cout &lt;&lt; maxArea(height) &lt;&lt; endl;  // 49\n    return 0;\n}\n</code></pre>"},{"location":"Company/amazon/#140-word-break-ii","title":"140. Word Break II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Dynamic Programming, Backtracking, Trie, Memoization</p> </li> </ul>"},{"location":"Company/amazon/#26-remove-duplicates-from-sorted-array","title":"26. Remove Duplicates from Sorted Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Remove duplicates in-place.\n\"\"\"\n\nfrom typing import List\n\n\ndef removeDuplicates(nums: List[int]) -&gt; int:\n    fast, slow = 1, 1\n\n    while fast &lt; len(nums):\n        if nums[fast] != nums[fast - 1]:\n            nums[slow] = nums[fast]\n            slow += 1\n        fast += 1\n\n    return slow\n\n\nnums = [1, 1, 2]\nprint(removeDuplicates(nums))  # 2\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int removeDuplicates(vector&lt;int&gt;&amp; nums) {\n        int fast = 1, slow = 1;\n        int n = nums.size();\n\n        while (fast &lt; n) {\n            if (nums[fast] != nums[fast - 1]) {\n                nums[slow] = nums[fast];\n                slow++;\n            }\n            fast++;\n        }\n        return slow;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; nums = {0, 0, 1, 1, 1, 2, 2, 3, 3, 4};\n    assert(solution.removeDuplicates(nums) == 5);\n    return 0;\n}\n</code></pre>"},{"location":"Company/amazon/#21-merge-two-sorted-lists","title":"21. Merge Two Sorted Lists","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Recursion</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Task: Merge the two linked lists into one sorted list.\n\"\"\"\n\nfrom typing import Optional\n\nfrom leetpattern.utils import ListNode\n\n\n# Linked List\ndef merge_two_lists(\n    list1: Optional[ListNode], list2: Optional[ListNode]\n) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    while list1 and list2:\n        if list1.val &lt; list2.val:\n            cur.next = list1\n            list1 = list1.next\n        else:\n            cur.next = list2\n            list2 = list2.next\n        cur = cur.next\n\n    if list1:\n        cur.next = list1\n    elif list2:\n        cur.next = list2\n\n    return dummy.next\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode* next) : val(x), next(next) {}\n};\n\nclass Solution {\n   public:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        ListNode dummy;\n        ListNode* cur = &amp;dummy;\n\n        while (list1 &amp;&amp; list2) {\n            if (list1-&gt;val &lt; list2-&gt;val) {\n                cur-&gt;next = list1;\n                list1 = list1-&gt;next;\n            } else {\n                cur-&gt;next = list2;\n                list2 = list2-&gt;next;\n            }\n            cur = cur-&gt;next;\n        }\n\n        cur-&gt;next = list1 ? list1 : list2;\n\n        return dummy.next;\n    }\n};\n\nint main() {\n    Solution sol;\n    ListNode* list1 = new ListNode(1, new ListNode(2, new ListNode(4)));\n    ListNode* list2 = new ListNode(1, new ListNode(3, new ListNode(4)));\n    ListNode* merged = sol.mergeTwoLists(list1, list2);\n    vector&lt;int&gt; res;\n    while (merged) {\n        res.push_back(merged-&gt;val);\n        merged = merged-&gt;next;\n    }\n    assert(res == std::vector&lt;int&gt;({1, 1, 2, 3, 4, 4}));\n    return 0;\n}\n</code></pre>"},{"location":"Company/amazon/#45-jump-game-ii","title":"45. Jump Game II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy</p> </li> </ul> Python <pre><code>\"\"\"\n- Return the minimum number of jumps to reach the last index.\n\"\"\"\n\nfrom typing import List\n\n\n# Greedy - Interval\ndef jump(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n == 1:\n        return 0\n\n    reach = 0\n    left, right = 0, 0\n    res = 0\n\n    while right &lt; n - 1:\n        for i in range(left, right + 1):\n            reach = max(reach, i + nums[i])\n\n        left = right + 1\n        right = reach\n        res += 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert jump([2, 3, 1, 1, 4]) == 2\n    assert jump([2, 3, 0, 1, 4]) == 2\n</code></pre>"},{"location":"Company/amazon/#54-spiral-matrix","title":"54. Spiral Matrix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Matrix, Simulation</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return all elements of the matrix in spiral order.\n\"\"\"\n\nfrom typing import List\n\n\n# Array\ndef spiralOrder(matrix: List[List[int]]) -&gt; List[int]:\n    if not matrix or not matrix[0]:\n        return []\n\n    res = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n\n    while top &lt;= bottom and left &lt;= right:\n\n        for i in range(left, right + 1):\n            res.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            res.append(matrix[i][right])\n        right -= 1\n\n        if top &lt;= bottom:\n\n            for i in range(right, left - 1, -1):\n                res.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left &lt;= right:\n\n            for i in range(bottom, top - 1, -1):\n                res.append(matrix[i][left])\n            left += 1\n\n    return res\n\n\n# Math\ndef spiralOrderMath(matrix: List[List[int]]) -&gt; List[int]:\n    dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]]  # Right Down Left Up\n    m, n = len(matrix), len(matrix[0])\n    size = m * n\n    res = []\n    i, j, di = 0, -1, 0\n\n    while len(res) &lt; size:\n        dx, dy = dirs[di]\n        for _ in range(n):\n            i += dx\n            j += dy\n            res.append(matrix[i][j])\n        di = (di + 1) % 4\n        n, m = m - 1, n\n\n    return res\n\n\nprint(spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n# [1, 2, 3, 6, 9, 8, 7, 4, 5]\nprint(spiralOrderMath([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]))\n# [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]\n</code></pre>"},{"location":"Company/amazon/#34-find-first-and-last-position-of-element-in-sorted-array","title":"34. Find First and Last Position of Element in Sorted Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> PythonCPP <pre><code>from bisect import bisect_left\nfrom typing import List\n\n\nclass searchRange:\n    \"\"\"\n    \u627e lower bound \u548c upper bound\n    \u770b\u7075\u795e\u5bf9\u8fd9\u9053\u9898\u7684\u9898\u89e3\uff0c\u5206\u7c7b\u8ba8\u8bba\u533a\u95f4\u7684\u5199\u6cd5\n    target \u7684 upper bound \u662f target + 1 \u7684 lower bound - 1\n    \u8fd9\u6837\u5c31\u80fd\u7edf\u4e00\u7528 lower bound \u7684\u5199\u6cd5\n    \"\"\"\n\n    # [left, right]\n    def bisect_left_closed(self, nums, target):\n        \"\"\"\n        \u95ed\u533a\u95f4\u5199\u6cd5\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left &lt;= right:\n            mid = left + (right - left) // 2\n            if nums[mid] &lt; target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n\n    # [left, right)\n    def bisect_left_right_open(self, nums, target):\n        \"\"\"\n        \u5de6\u95ed\u53f3\u5f00\u533a\u95f4\u5199\u6cd5\n        \"\"\"\n        left, right = 0, len(nums)\n        while left &lt; right:\n            mid = left + (right - left) // 2\n            if nums[mid] &gt;= target:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\n    # (left, right)\n    def bisect_left_open(self, nums, target):\n        \"\"\"\n        \u63a8\u8350\u5f00\u533a\u95f4\u5199\u6cd5\n        \"\"\"\n        left, right = -1, len(nums)\n        while left + 1 &lt; right:\n            mid = left + (right - left) // 2\n            if nums[mid] &lt; target:\n                left = mid\n            else:\n                right = mid\n        return right\n\n    def search_range(self, nums: List[int], target: int) -&gt; List[int]:\n        # edge case\n        if not nums:\n            return [-1, -1]\n\n        lower = self.bisect_left_closed(nums, target)\n        upper = self.bisect_left_closed(nums, target + 1) - 1\n\n        return [lower, upper] if lower &lt;= upper else [-1, -1]\n\n    def search_range_bisect(self, nums: List[int], target: int) -&gt; List[int]:\n        \"\"\"\u7528 python bisect \u5e93\u51fd\u6570\"\"\"\n        # edge case\n        if not nums:\n            return [-1, -1]\n\n        lower = bisect_left(nums, target)\n        upper = bisect_left(nums, target + 1) - 1\n\n        return [lower, upper] if lower &lt;= upper else [-1, -1]\n\n\nif __name__ == \"__main__\":\n    nums = [5, 7, 7, 8, 8, 10]\n    target = 8\n    sol = searchRange()\n    assert sol.search_range(nums, target) == [3, 4]\n    assert sol.search_range_bisect(nums, target) == [3, 4]\n</code></pre> <pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\n  int bisect_left(vector&lt;int&gt; &amp;nums, int target)\n  {\n    int left = 0, right = (int)nums.size() - 1;\n\n    while (left &lt;= right)\n    {\n      int mid = left + (right - left) / 2;\n      if (nums[mid] &lt; target)\n      {\n        left = mid + 1;\n      }\n      else\n      {\n        right = mid - 1;\n      }\n    }\n    return left;\n  }\n\npublic:\n  vector&lt;int&gt; searchRange(vector&lt;int&gt; &amp;nums, int target)\n  {\n    int left = bisect_left(nums, target);\n    if (left == (int)nums.size() || nums[left] != target)\n    {\n      return {-1, -1};\n    }\n    int right = bisect_left(nums, target + 1) - 1;\n    return {left, right};\n  }\n};\n\nint main()\n{\n  vector&lt;int&gt; nums = {5, 7, 7, 8, 8, 10};\n  int target = 8;\n  Solution s;\n  vector&lt;int&gt; res = s.searchRange(nums, target);\n  cout &lt;&lt; res[0] &lt;&lt; \", \" &lt;&lt; res[1] &lt;&lt; endl;\n  return 0;\n}\n</code></pre>"},{"location":"Company/amazon/#62-unique-paths","title":"62. Unique Paths","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Combinatorics</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Count the number of unique paths to reach the bottom-right corner of a `m x n` grid.\n\n![62](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)\n\"\"\"\n\n\n# DP - 2D\ndef uniquePaths(m: int, n: int) -&gt; int:\n    if m == 1 or n == 1:\n        return 1\n\n    dp = [[1] * n for _ in range(m)]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]\n\n\nprint(uniquePaths(m=3, n=7))  # 28\n# [[1, 1, 1,  1,  1,  1,  1],\n#  [1, 2, 3,  4,  5,  6,  7],\n#  [1, 3, 6, 10, 15, 21, 28]]\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint uniquePaths(int m, int n) {\n    vector dp(m, vector&lt;int&gt;(n, 1));\n\n    for (int i = 1; i &lt; m; i++) {\n        for (int j = 1; j &lt; n; j++) {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n\n    return dp[m - 1][n - 1];\n}\n\nint main() {\n    int m = 3, n = 7;\n    cout &lt;&lt; uniquePaths(m, n) &lt;&lt; endl;  // 28\n    return 0;\n}\n</code></pre>"},{"location":"Company/apple/","title":"Apple","text":""},{"location":"Company/apple/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 146. LRU Cache (Medium)</li> <li> 121. Best Time to Buy and Sell Stock (Easy)</li> <li> 347. Top K Frequent Elements (Medium)</li> <li> 139. Word Break (Medium)</li> <li> 1. Two Sum (Easy)</li> <li> 56. Merge Intervals (Medium)</li> <li> 155. Min Stack (Medium)</li> <li> 36. Valid Sudoku (Medium)</li> <li> 1606. Find Servers That Handled Most Number of Requests (Hard)</li> <li> 49. Group Anagrams (Medium)</li> <li> 189. Rotate Array (Medium)</li> <li> 200. Number of Islands (Medium)</li> <li> 122. Best Time to Buy and Sell Stock II (Medium)</li> <li> 125. Valid Palindrome (Easy)</li> <li> 14. Longest Common Prefix (Easy)</li> <li> 54. Spiral Matrix (Medium)</li> <li> 215. Kth Largest Element in an Array (Medium)</li> <li> 387. First Unique Character in a String (Easy)</li> <li> 622. Design Circular Queue (Medium)</li> <li> 88. Merge Sorted Array (Easy)</li> <li> 714. Best Time to Buy and Sell Stock with Transaction Fee (Medium)</li> <li> 560. Subarray Sum Equals K (Medium)</li> <li> 362. Design Hit Counter (Medium) \ud83d\udc51</li> <li> 283. Move Zeroes (Easy)</li> <li> 34. Find First and Last Position of Element in Sorted Array (Medium)</li> <li> 3. Longest Substring Without Repeating Characters (Medium)</li> <li> 208. Implement Trie (Prefix Tree) (Medium)</li> <li> 348. Design Tic-Tac-Toe (Medium) \ud83d\udc51</li> <li> 151. Reverse Words in a String (Medium)</li> <li> 53. Maximum Subarray (Medium)</li> </ul>"},{"location":"Company/apple/#146-lru-cache","title":"146. LRU Cache","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Linked List, Design, Doubly Linked List</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Design and implement a data structure for **Least Recently Used (LRU) cache**. It should support the following operations: get and put.\n- [lru](https://media.geeksforgeeks.org/wp-content/uploads/20240909142802/Working-of-LRU-Cache-copy-2.webp)\n- ![146](https://miro.medium.com/v2/resize:fit:650/0*fOwBd3z0XtHh7WN1.png)\n\n| Data structure     | Description                   |\n| ------------------ | ----------------------------- |\n| Doubly Linked List | To store the key-value pairs. |\n| Hash Map           | To store the key-node pairs.  |\n\"\"\"\n\nfrom collections import OrderedDict\n\n\n# Doubly Linked List\nclass Node:\n    def __init__(self, key=0, val=0):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.cache = {}\n        self.head = Node()\n        self.tail = Node()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def add_to_last(self, node):\n        self.tail.prev.next = node\n        node.prev = self.tail.prev\n        node.next = self.tail\n        self.tail.prev = node\n\n    def move_to_last(self, node):\n        self.remove(node)\n        self.add_to_last(node)\n\n    def get(self, key: int) -&gt; int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self.move_to_last(node)\n        return node.val\n\n    def put(self, key: int, value: int) -&gt; None:\n        if key in self.cache:\n            node = self.cache[key]\n            node.val = value\n            self.move_to_last(node)\n            return None\n\n        if len(self.cache) == self.cap:\n            del self.cache[self.head.next.key]\n            self.remove(self.head.next)\n\n        node = Node(key=key, val=value)\n        self.cache[key] = node\n        self.add_to_last(node)\n\n\n# OrderedDict\nclass LRUCacheOrderedDict:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.cap = capacity\n\n    def get(self, key: int):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key, last=True)\n        return self.cache[key]\n\n    def put(self, key: int, value: int):\n        if key in self.cache:\n            self.cache.move_to_end(key, last=True)\n        elif len(self.cache) &gt;= self.cap:\n            self.cache.popitem(last=False)\n\n        self.cache[key] = value\n\n\ncache = LRUCache(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\n\ncache = LRUCacheOrderedDict(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\nprint(\"LRU Cache passed\")\nprint(\"LRU Cache Ordered Dict passed\")\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nclass Node {\n   public:\n    int key;\n    int val;\n    Node *prev;\n    Node *next;\n\n    Node(int k = 0, int v = 0) : key(k), val(v), prev(nullptr), next(nullptr) {}\n};\n\nclass LRUCache {\n   private:\n    int cap;\n    unordered_map&lt;int, Node *&gt; cache;\n    Node *head;\n    Node *tail;\n\n    void remove(Node *node) {\n        node-&gt;prev-&gt;next = node-&gt;next;\n        node-&gt;next-&gt;prev = node-&gt;prev;\n    }\n\n    void insert_to_last(Node *node) {\n        tail-&gt;prev-&gt;next = node;\n        node-&gt;prev = tail-&gt;prev;\n        tail-&gt;prev = node;\n        node-&gt;next = tail;\n    }\n\n    void move_to_last(Node *node) {\n        remove(node);\n        insert_to_last(node);\n    }\n\n   public:\n    LRUCache(int capacity) {\n        this-&gt;cap = capacity;\n        head = new Node();\n        tail = new Node();\n        head-&gt;next = tail;\n        tail-&gt;prev = head;\n    }\n\n    int get(int key) {\n        if (cache.find(key) != cache.end()) {\n            Node *node = cache[key];\n            move_to_last(node);\n            return node-&gt;val;\n        }\n        return -1;\n    }\n\n    void put(int key, int value) {\n        if (cache.find(key) != cache.end()) {\n            Node *node = cache[key];\n            node-&gt;val = value;\n            move_to_last(node);\n        } else {\n            Node *newNode = new Node(key, value);\n            cache[key] = newNode;\n            insert_to_last(newNode);\n\n            if ((int)cache.size() &gt; cap) {\n                Node *removed = head-&gt;next;\n                remove(removed);\n                cache.erase(removed-&gt;key);\n                delete removed;\n            }\n        }\n    }\n};\n\nint main() {\n    LRUCache lru(2);\n    lru.put(1, 1);\n    lru.put(2, 2);\n    assert(lru.get(1) == 1);   // returns 1\n    lru.put(3, 3);             // evicts key 2\n    assert(lru.get(2) == -1);  // returns -1 (not found)\n    lru.put(4, 4);             // evicts key 1\n    assert(lru.get(1) == -1);  // returns -1 (not found)\n    assert(lru.get(3) == 3);   // returns 3\n    assert(lru.get(4) == 4);   // returns 4\n    return 0;\n}\n</code></pre>"},{"location":"Company/apple/#121-best-time-to-buy-and-sell-stock","title":"121. Best Time to Buy and Sell Stock","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return the maximum profit that can be achieved from buying on one day and selling on another day.\n\"\"\"\n\nfrom typing import List\n\n\n# Brute Force\ndef maxProfitBF(prices: List[int]) -&gt; int:\n    max_profit = 0\n    n = len(prices)\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_profit = max(max_profit, prices[j] - prices[i])\n\n    return max_profit\n\n\n# DP\ndef maxProfitDP(prices: List[int]) -&gt; int:\n    dp = [[0] * 2 for _ in range(len(prices))]\n    dp[0][0] = -prices[0]  # buy\n    dp[0][1] = 0  # sell\n\n    for i in range(1, len(prices)):\n        dp[i][0] = max(dp[i - 1][0], -prices[i])  # the lowest price to buy\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    max_profit = 0\n    seen_min = prices[0]\n\n    for i in range(1, len(prices)):\n        max_profit = max(max_profit, prices[i] - seen_min)\n        seen_min = min(seen_min, prices[i])\n\n    return max_profit\n\n\n# Fast Slow Pointers\ndef maxProfitFS(prices: List[int]) -&gt; int:\n    max_profit = 0\n    slow, fast = 0, 1\n\n    while fast &lt; len(prices):\n        if prices[fast] &gt; prices[slow]:\n            max_profit = max(max_profit, prices[fast] - prices[slow])\n        else:\n            slow = fast\n        fast += 1\n\n    return max_profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force|  O(n^2)|  O(1)   |\n# | DP         |  O(n)  |  O(n)   |\n# | Greedy     |  O(n)  |  O(1)   |\n# | Fast Slow  |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitBF(prices))  # 5\nprint(maxProfitDP(prices))  # 5\nprint(maxProfitGreedy(prices))  # 5\nprint(maxProfitFS(prices))  # 5\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int maxProfitMemo(vector&lt;int&gt; &amp;prices) {\n        if (prices.size() &lt;= 1) return 0;\n\n        int seen_min = prices[0];\n        int res = 0;\n\n        for (int &amp;price : prices) {\n            res = max(res, price - seen_min);\n            seen_min = min(seen_min, price);\n        }\n        return res;\n    }\n};\n\nint main() {\n    vector&lt;int&gt; prices = {7, 1, 5, 3, 6, 4};\n    Solution obj;\n    cout &lt;&lt; obj.maxProfitMemo(prices) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"Company/apple/#347-top-k-frequent-elements","title":"347. Top K Frequent Elements","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Divide And Conquer, Sorting, Heap Priority Queue, Bucket Sort, Counting, Quickselect</p> </li> </ul> Python <pre><code>import heapq\nfrom collections import Counter\nfrom typing import List\n\n\n# Heap + Counter\ndef topKFrequent(nums: List[int], k: int) -&gt; List[int]:\n    minHeap = []\n\n    for val, freq in Counter(nums).items():\n        if len(minHeap) &lt; k:\n            heapq.heappush(minHeap, (freq, val))\n        else:\n            heapq.heappushpop(minHeap, (freq, val))\n\n    return [i for _, i in minHeap]\n\n\n# Counter (Most Common)\ndef topKFrequentCounter(nums: List[int], k: int) -&gt; List[int]:\n    commons = Counter(nums).most_common(k)\n    return [i for i, _ in commons]\n\n\nnums = [1, 1, 1, 2, 2, 3]\nk = 2\nprint(topKFrequent(nums, k))  # [1, 2]\nprint(topKFrequentCounter(nums, k))  # [1, 2]\n</code></pre>"},{"location":"Company/apple/#139-word-break","title":"139. Word Break","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Dynamic Programming, Trie, Memoization</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\n# DP (Unbounded Knapsack)\ndef wordBreak(s: str, wordDict: List[str]) -&gt; bool:\n    n = len(s)\n    dp = [False for _ in range(n + 1)]\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for word in wordDict:\n            m = len(word)\n            if s[i - m : i] == word and dp[i - m]:\n                dp[i] = True\n    return dp[-1]\n\n\ns = \"leetcode\"\nwordDict = [\"leet\", \"code\"]\nprint(wordBreak(s, wordDict))  # True\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;cassert&gt;\n#include &lt;ranges&gt;\n#include &lt;string&gt;\n#include &lt;unordered_set&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) {\n        int max_len = ranges::max(wordDict, {}, &amp;string::length).length();\n        unordered_set&lt;string&gt; words(wordDict.begin(), wordDict.end());\n\n        int n = s.length();\n        vector&lt;int&gt; f(n + 1);\n        f[0] = true;\n        for (int i = 1; i &lt;= n; i++) {\n            for (int j = i - 1; j &gt;= max(i - max_len, 0); j--) {\n                if (f[j] &amp;&amp; words.count(s.substr(j, i - j))) {\n                    f[i] = true;\n                    break;\n                }\n            }\n        }\n        return f[n];\n    }\n};\n\nint main() {\n    Solution solution;\n    string s = \"leetcode\";\n    vector&lt;string&gt; wordDict = {\"leet\", \"code\"};\n    assert(solution.wordBreak(s, wordDict) == true);\n    return 0;\n}\n</code></pre>"},{"location":"Company/apple/#1-two-sum","title":"1. Two Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return the indices of the two numbers such that they add up to a specific target.\n- Approach: Use a hashmap to store the indices of the numbers.\n- Time Complexity: O(n)\n- Space Complexity: O(n)\n\"\"\"\n\nfrom typing import List\n\n\ndef two_sum(nums: List[int], target: int) -&gt; List[int]:\n    hashmap = {}  # val: idx\n\n    for idx, val in enumerate(nums):\n        if (target - val) in hashmap:\n            return [hashmap[target - val], idx]\n\n        hashmap[val] = idx\n\n    return []\n\n\ndef test_two_sum():\n    assert two_sum([2, 7, 11, 15], 9) == [0, 1]\n    assert two_sum([3, 2, 4], 6) == [1, 2]\n    assert two_sum([3, 3], 6) == [0, 1]\n    assert two_sum([1, 2, 3, 4, 5], 10) == []\n    assert two_sum([-1, -2, -3, -4, -5], -8) == [2, 4]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Solution {\n   public:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {\n        unordered_map&lt;int, int&gt; map;\n\n        for (size_t i = 0; i &lt; nums.size(); i++) {\n            int diff = target - nums[i];\n            if (map.find(diff) != map.end()) {\n                return {map[diff], (int)i};\n            }\n            map[nums[i]] = (int)i;\n        }\n        return {-1, -1};\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; nums = {2, 7, 11, 15};\n    int target = 9;\n    vector&lt;int&gt; result = solution.twoSum(nums, target);\n    assert((result == vector&lt;int&gt;{0, 1}));\n    return 0;\n}\n</code></pre>"},{"location":"Company/apple/#56-merge-intervals","title":"56. Merge Intervals","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sorting</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Merge all overlapping intervals.\n\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/44H3cEC2fFM?si=J-Jr_Fg2eDse3-de\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen&gt;&lt;/iframe&gt;\n\"\"\"\n\nfrom typing import List\n\n\n# Intervals\ndef merge(intervals: List[List[int]]) -&gt; List[List[int]]:\n    n = len(intervals)\n    if n &lt;= 1:\n        return intervals\n\n    intervals.sort(key=lambda x: x[0])\n    res = [intervals[0]]\n\n    for i in range(1, n):\n        if intervals[i][0] &lt;= res[-1][1]:\n            res[-1][1] = max(res[-1][1], intervals[i][1])\n        else:\n            res.append(intervals[i])\n\n    return res\n\n\nprint(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))\n# [[1, 6], [8, 10], [15, 18]]\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// Interval\nvector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {\n    sort(intervals.begin(), intervals.end());\n    vector&lt;vector&lt;int&gt;&gt; res;\n\n    for (auto&amp; range : intervals) {\n        if (!res.empty() &amp;&amp; range[0] &lt;= res.back()[1]) {\n            res.back()[1] = max(res.back()[1], range[1]);\n        } else {\n            res.emplace_back(range);\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;vector&lt;int&gt;&gt; intervals = {{1, 3}, {2, 6}, {8, 10}, {15, 18}};\n    vector&lt;vector&lt;int&gt;&gt; res = merge(intervals);\n    for (auto&amp; range : res) {\n        cout &lt;&lt; range[0] &lt;&lt; \", \" &lt;&lt; range[1] &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Company/apple/#155-min-stack","title":"155. Min Stack","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Stack, Design</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Implement a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\"\"\"\n\n\n# Stack\nclass MinStack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, val: int) -&gt; None:\n        if self.stack:\n            self.stack.append((val, min(val, self.getMin())))\n        else:\n            self.stack.append((val, val))\n\n    def pop(self) -&gt; None:\n        self.stack.pop()\n\n    def top(self) -&gt; int:\n        return self.stack[-1][0]\n\n    def getMin(self) -&gt; int:\n        return self.stack[-1][1]\n\n\nobj = MinStack()\nobj.push(3)\nobj.push(2)\nobj.pop()\nprint(obj.top())  # 3\nprint(obj.getMin())  # 3\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;climits&gt;\n#include &lt;iostream&gt;\n#include &lt;stack&gt;\n#include &lt;utility&gt;\nusing namespace std;\n\nclass MinStack {\n    stack&lt;pair&lt;int, int&gt;&gt; st;\n\n   public:\n    MinStack() { st.emplace(0, INT_MAX); }\n\n    void push(int val) { st.emplace(val, min(getMin(), val)); }\n\n    void pop() { st.pop(); }\n\n    int top() { return st.top().first; }\n\n    int getMin() { return st.top().second; }\n};\n\nint main() {\n    MinStack minStack;\n    minStack.push(-2);\n    minStack.push(0);\n    minStack.push(-3);\n    cout &lt;&lt; minStack.getMin() &lt;&lt; endl;  // -3\n    minStack.pop();\n    cout &lt;&lt; minStack.top() &lt;&lt; endl;     // 0\n    cout &lt;&lt; minStack.getMin() &lt;&lt; endl;  // -2\n    return 0;\n}\n</code></pre>"},{"location":"Company/apple/#36-valid-sudoku","title":"36. Valid Sudoku","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Matrix</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Set\ndef isValidSudoku(board: List[List[str]]) -&gt; bool:\n    rows = [set() for _ in range(9)]\n    cols = [set() for _ in range(9)]\n    boxes = [set() for _ in range(9)]\n\n    for i in range(9):\n        for j in range(9):\n            if board[i][j] == \".\":\n                continue\n\n            if board[i][j] in rows[i]:\n                return False\n            rows[i].add(board[i][j])\n\n            if board[i][j] in cols[j]:\n                return False\n            cols[j].add(board[i][j])\n\n            box_index = (i // 3) * 3 + j // 3\n            if board[i][j] in boxes[box_index]:\n                return False\n            boxes[box_index].add(board[i][j])\n\n    return True\n\n\nboard = [\n    [\"5\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],\n    [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n    [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n    [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n    [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n    [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n    [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"],\n    [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n    [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"],\n]\nprint(isValidSudoku(board))  # True\n</code></pre>"},{"location":"Company/apple/#1606-find-servers-that-handled-most-number-of-requests","title":"1606. Find Servers That Handled Most Number of Requests","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Heap Priority Queue, Ordered Set</p> </li> </ul>"},{"location":"Company/apple/#49-group-anagrams","title":"49. Group Anagrams","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Sorting</p> </li> </ul> PythonCPP <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash - List\ndef groupAnagrams(strs: List[str]) -&gt; List[List[str]]:\n    result = defaultdict(list)\n\n    for s in strs:\n        count = [0] * 26\n        for i in s:\n            count[ord(i) - ord(\"a\")] += 1\n\n        result[tuple(count)].append(s)\n\n    return list(result.values())\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Hash     |     O(n * k)    |     O(n)     |\n# |-------------|-----------------|--------------|\n\n\nstrs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\nprint(groupAnagrams(strs))\n# [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;cassert&gt;\n#include &lt;ranges&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Solution {\n   public:\n    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) {\n        unordered_map&lt;string, vector&lt;string&gt;&gt; map;\n\n        for (string&amp; s : strs) {\n            string sorted = s;\n            ranges::sort(sorted);\n            map[sorted].push_back(s);\n        }\n\n        vector&lt;vector&lt;string&gt;&gt; res;\n\n        for (auto&amp; kv : map) {\n            res.push_back(kv.second);\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;string&gt; strs = {\"eat\", \"tea\", \"tan\"};\n    vector&lt;vector&lt;string&gt;&gt; res = solution.groupAnagrams(strs);\n    assert((res == vector&lt;vector&lt;string&gt;&gt;{{\"eat\", \"tea\"}, {\"tan\"}} ||\n            res == vector&lt;vector&lt;string&gt;&gt;{{\"tan\"}, {\"eat\", \"tea\"}}));\n\n    return 0;\n}\n</code></pre>"},{"location":"Company/apple/#189-rotate-array","title":"189. Rotate Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Two Pointers</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Rotate array with reversing subarrays\n\"\"\"\n\nfrom typing import List\n\n\n# Array\ndef rotate(nums: List[int], k: int) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n\n    def reverse(i: int, j: int) -&gt; None:\n        while i &lt; j:\n            nums[i], nums[j] = nums[j], nums[i]\n            i += 1\n            j -= 1\n\n    n = len(nums)\n    k %= n\n    reverse(0, n - 1)\n    reverse(0, k - 1)\n    reverse(k, n - 1)\n\n\nnums = [1, 2, 3, 4, 5, 6, 7]\nk = 3\nrotate(nums, k)\nprint(nums)  # [5, 6, 7, 1, 2, 3, 4]\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// Array\nvoid rotate(vector&lt;int&gt;&amp; nums, int k) {\n    k %= nums.size();\n\n    reverse(nums.begin(), nums.end());\n    reverse(nums.begin(), nums.begin() + k);\n    reverse(nums.begin() + k, nums.end());\n}\n\nint main() {\n    vector&lt;int&gt; nums = {1, 2, 3, 4, 5, 6, 7};\n    int k = 3;\n    rotate(nums, k);\n    // [5, 6, 7, 1, 2, 3, 4]\n    for (const auto&amp; num : nums) {\n        cout &lt;&lt; num &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"Company/apple/#200-number-of-islands","title":"200. Number of Islands","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Union Find, Matrix</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Count the number of islands in a 2D grid.\n-   Method 1: DFS\n-   Method 2: BFS (use a queue to traverse the grid)\n\n-   How to keep track of visited cells?\n\n    1. Mark the visited cell as `0` (or any other value) to avoid revisiting it.\n    2. Use a set to store the visited cells.\n\n-   Steps:\n    1. Init: variables\n    2. DFS/BFS: starting from the cell with `1`, turn all the connected `1`s to `0`.\n    3. Traverse the grid, and if the cell is `1`, increment the count and call DFS/BFS.\n\n![0200](../../assets/0200.jpg)\n\"\"\"\n\nfrom collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef numIslandsDFS(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    res = 0\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] != \"1\":\n            return\n\n        grid[r][c] = \"2\"\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                dfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Set\ndef numIslandsBFS1(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == \"0\"\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\" and (r, c) not in visited:\n                visited.add((r, c))\n                bfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = dr + row, dc + col\n                if nr &lt; 0 or nr &gt;= m or nc &lt; 0 or nc &gt;= n or grid[nr][nc] != \"1\":\n                    continue\n                grid[nr][nc] = \"2\"\n                q.append((nr, nc))\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == \"1\":\n                grid[i][j] = \"2\"\n                bfs(i, j)\n                res += 1\n\n    return res\n\n\ngrid = [\n    [\"1\", \"1\", \"1\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"0\", \"0\", \"0\", \"0\", \"0\"],\n]\n\nprint(numIslandsDFS(deepcopy(grid)))  # 1\nprint(numIslandsBFS1(deepcopy(grid)))  # 1\nprint(numIslandsBFS2(deepcopy(grid)))  # 1\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    // dfs\n    int num_islands_dfs(vector&lt;vector&lt;char&gt;&gt; &amp;grid) {\n        int m = grid.size(), n = grid[0].size();\n        int res = 0;\n\n        // c++23 lambda recursion\n        auto dfs = [&amp;](this auto &amp;&amp;dfs, int r, int c) -&gt; void {\n            if (r &lt; 0 || r &gt;= m || c &lt; 0 || c &gt;= n || grid[r][c] != '1') {\n                return;\n            }\n            grid[r][c] = '0';\n            dfs(r + 1, c);\n            dfs(r - 1, c);\n            dfs(r, c + 1);\n            dfs(r, c - 1);\n        };\n\n        for (int i = 0; i &lt; m; i++) {\n            for (int j = 0; j &lt; n; j++) {\n                if (grid[i][j] == '1') {\n                    res++;\n                    dfs(i, j);\n                }\n            }\n        }\n        return res;\n    }\n\n    // bfs\n    int num_islands_bfs(vector&lt;vector&lt;char&gt;&gt; &amp;grid) {\n        int m = grid.size(), n = grid[0].size();\n        int res = 0;\n        vector&lt;pair&lt;int, int&gt;&gt; dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\n        auto bfs = [&amp;](int r, int c) {\n            queue&lt;pair&lt;int, int&gt;&gt; q;\n            q.push({r, c});\n            grid[r][c] = '0';\n            while (!q.empty()) {\n                auto [cr, cc] = q.front();\n                q.pop();\n                for (auto &amp;[dr, dc] : dirs) {\n                    int nr = cr + dr, nc = cc + dc;\n                    if (nr &gt;= 0 &amp;&amp; nr &lt; m &amp;&amp; nc &gt;= 0 &amp;&amp; nc &lt; n &amp;&amp;\n                        grid[nr][nc] == '1') {\n                        grid[nr][nc] = '0';\n                        q.push({nr, nc});\n                    }\n                }\n            }\n        };\n\n        for (int i = 0; i &lt; m; i++) {\n            for (int j = 0; j &lt; n; j++) {\n                if (grid[i][j] == '1') {\n                    res++;\n                    bfs(i, j);\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;vector&lt;char&gt;&gt; grid = {{'1', '1', '0', '0', '0'},\n                                 {'1', '1', '0', '0', '0'},\n                                 {'0', '0', '1', '0', '0'},\n                                 {'0', '0', '0', '1', '1'}};\n    assert(solution.num_islands_dfs(grid) == 3);\n    grid = {{'1', '1', '0', '0', '0'},\n            {'1', '1', '0', '0', '0'},\n            {'0', '0', '1', '0', '0'},\n            {'0', '0', '0', '1', '1'}};\n    assert(solution.num_islands_bfs(grid) == 3);\n    return 0;\n}\n</code></pre>"},{"location":"Company/apple/#122-best-time-to-buy-and-sell-stock-ii","title":"122. Best Time to Buy and Sell Stock II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return the maximum profit you can achieve.\n\"\"\"\n\nfrom typing import List\n\n\n# DP\ndef maxProfitDP1(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 2 for _ in range(n)]\n    dp[0][0] = -prices[0]\n    dp[0][1] = 0\n\n    for i in range(1, n):\n        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i])\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# DP - Optimized\ndef maxProfitDP2(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    hold = -prices[0]\n    profit = 0\n\n    for i in range(1, n):\n        hold = max(hold, profit - prices[i])\n        profit = max(profit, hold + prices[i])\n\n    return profit\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    profit = 0\n\n    for i in range(1, len(prices)):\n        profit += max(prices[i] - prices[i - 1], 0)\n\n    return profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |     DP1    |  O(n)  |   O(n)  |\n# |     DP2    |  O(n)  |   O(1)  |\n# |   Greedy   |  O(n)  |   O(1)  |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitDP1(prices))  # 7\nprint(maxProfitDP2(prices))  # 7\nprint(maxProfitGreedy(prices))  # 7\n</code></pre> <pre><code>#include &lt;array&gt;\n#include &lt;cassert&gt;\n#include &lt;climits&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int maxProfitMemo(vector&lt;int&gt;&amp; prices) {\n        int n = prices.size();\n        vector&lt;array&lt;int, 2&gt;&gt; memo(n, {-1, -1});\n\n        auto dfs = [&amp;](this auto&amp;&amp; dfs, int i, bool hold) -&gt; int {\n            if (i &lt; 0) {\n                return hold ? INT_MIN : 0;\n            }\n            int&amp; res = memo[i][hold];\n            if (res != -1) {\n                return res;\n            }\n            if (hold) {\n                return res = max(dfs(i - 1, true),                // skip\n                                 dfs(i - 1, false) - prices[i]);  // buy\n            } else {\n                return res = max(dfs(i - 1, false),              // skip\n                                 dfs(i - 1, true) + prices[i]);  // sell\n            }\n        };\n\n        return dfs(n - 1, false);\n    }\n\n    int maxProfitIterative(vector&lt;int&gt;&amp; prices) {\n        int n = prices.size();\n        vector&lt;array&lt;int, 2&gt;&gt; dp(n, {0, 0});\n        dp[0][0] = -prices[0];\n        dp[0][1] = 0;\n\n        for (int i = 1; i &lt; n; i++) {\n            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);  // buy\n            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);  // sell\n        }\n        return dp[n - 1][1];\n    }\n\n    int maxProfitIterativeOptimized(vector&lt;int&gt;&amp; prices) {\n        int n = prices.size();\n        if (n &lt;= 1) return 0;\n\n        int hold = -prices[0], res = 0;\n\n        for (int i = 1; i &lt; n; i++) {\n            hold = max(hold, res - prices[i]);  // buy\n            res = max(res, hold + prices[i]);   // sell\n        }\n        return res;\n    }\n\n    int maxProfitGreedy(vector&lt;int&gt;&amp; prices) {\n        int n = prices.size();\n        if (n &lt;= 1) return 0;\n\n        int res = 0;\n\n        for (int i = 1; i &lt; n; i++) {\n            if (prices[i] &gt; prices[i - 1]) {\n                res += prices[i] - prices[i - 1];\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; prices = {7, 1, 5, 3, 6, 4};\n    assert(solution.maxProfitMemo(prices) == 7);\n    assert(solution.maxProfitIterative(prices) == 7);\n    assert(solution.maxProfitIterativeOptimized(prices) == 7);\n    assert(solution.maxProfitGreedy(prices) == 7);\n    return 0;\n}\n</code></pre>"},{"location":"Company/apple/#125-valid-palindrome","title":"125. Valid Palindrome","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String</p> </li> </ul> Python <pre><code># List Comprehension\ndef isPalindrome(s: str) -&gt; bool:\n    s = [char.lower() for char in s if char.isalnum()]\n    return s == s[::-1]\n\n\n# Left Right Pointers\ndef isPalindromeLR(s: str) -&gt; bool:\n    left, right = 0, len(s) - 1\n\n    while left &lt; right:\n        while left &lt; right and not s[left].isalnum():\n            left += 1\n        while left &lt; right and not s[right].isalnum():\n            right -= 1\n\n        if s[left].lower() != s[right].lower():\n            return False\n\n        left += 1\n        right -= 1\n\n    return True\n\n\ns = \"A man, a plan, a canal: Panama\"\nprint(isPalindrome(s))  # True\nprint(isPalindromeLR(s))  # True\n</code></pre>"},{"location":"Company/apple/#14-longest-common-prefix","title":"14. Longest Common Prefix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Trie</p> </li> </ul> Python <pre><code>from typing import List\n\n\nclass longestCommonPrefix:\n    def horizontal_scan(self, strs: List[str]) -&gt; str:\n        if not strs:\n            return \"\"\n\n        prefix = strs[0]\n        for i in range(1, len(strs)):\n            while not strs[i].startswith(prefix):\n                prefix = prefix[:-1]\n                if not prefix:\n                    return \"\"\n\n        return prefix\n\n    def vertical_scan(self, strs: List[str]) -&gt; str:\n        if not strs:\n            return \"\"\n\n        for i in range(len(strs[0])):\n            char = strs[0][i]\n            for j in range(1, len(strs)):\n                if i &gt;= len(strs[j]) or strs[j][i] != char:\n                    return strs[0][:i]\n\n        return strs[0]\n\n    def divide_conquer(self, strs: List[str]) -&gt; str:\n        if not strs:\n            return \"\"\n\n        def merge(left, right):\n            n = min(len(left), len(right))\n            for i in range(n):\n                if left[i] != right[i]:\n                    return left[:i]\n            return left[:n]\n\n        def find(strs, start, end):\n            if start == end:\n                return strs[start]\n            mid = start + (end - start) // 2\n            left = find(strs, start, mid)\n            right = find(strs, mid + 1, end)\n            return merge(left, right)\n\n        return find(strs, 0, len(strs) - 1)\n\n    def binary_search(self, strs: List[str]) -&gt; str:\n        if not strs:\n            return \"\"\n\n        def isCommonPrefix(strs, length):\n            prefix = strs[0][:length]\n            return all(s.startswith(prefix) for s in strs)\n\n        minLen = min(len(s) for s in strs)\n        low, high = 0, minLen\n        while low &lt; high:\n            mid = low + (high - low) // 2\n            if isCommonPrefix(strs, mid + 1):\n                low = mid + 1\n            else:\n                high = mid\n\n        return strs[0][:low]\n\n\nif __name__ == \"__main__\":\n    solution = longestCommonPrefix()\n    strs = [\"flower\", \"flow\", \"flight\"]\n    assert solution.horizontal_scan(strs) == \"fl\"\n    assert solution.vertical_scan(strs) == \"fl\"\n    assert solution.divide_conquer(strs) == \"fl\"\n    assert solution.binary_search(strs) == \"fl\"\n</code></pre>"},{"location":"Company/apple/#54-spiral-matrix","title":"54. Spiral Matrix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Matrix, Simulation</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return all elements of the matrix in spiral order.\n\"\"\"\n\nfrom typing import List\n\n\n# Array\ndef spiralOrder(matrix: List[List[int]]) -&gt; List[int]:\n    if not matrix or not matrix[0]:\n        return []\n\n    res = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n\n    while top &lt;= bottom and left &lt;= right:\n\n        for i in range(left, right + 1):\n            res.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            res.append(matrix[i][right])\n        right -= 1\n\n        if top &lt;= bottom:\n\n            for i in range(right, left - 1, -1):\n                res.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left &lt;= right:\n\n            for i in range(bottom, top - 1, -1):\n                res.append(matrix[i][left])\n            left += 1\n\n    return res\n\n\n# Math\ndef spiralOrderMath(matrix: List[List[int]]) -&gt; List[int]:\n    dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]]  # Right Down Left Up\n    m, n = len(matrix), len(matrix[0])\n    size = m * n\n    res = []\n    i, j, di = 0, -1, 0\n\n    while len(res) &lt; size:\n        dx, dy = dirs[di]\n        for _ in range(n):\n            i += dx\n            j += dy\n            res.append(matrix[i][j])\n        di = (di + 1) % 4\n        n, m = m - 1, n\n\n    return res\n\n\nprint(spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n# [1, 2, 3, 6, 9, 8, 7, 4, 5]\nprint(spiralOrderMath([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]))\n# [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]\n</code></pre>"},{"location":"Company/apple/#215-kth-largest-element-in-an-array","title":"215. Kth Largest Element in an Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Divide And Conquer, Sorting, Heap Priority Queue, Quickselect</p> </li> </ul> Python <pre><code>import heapq\nfrom typing import List\n\n\ndef findKthLargest(nums: List[int], k: int) -&gt; int:\n    min_heap = []\n\n    for i, num in enumerate(nums):\n        heapq.heappush(min_heap, num)\n        if i &gt;= k:\n            heapq.heappop(min_heap)\n\n    return min_heap[0]\n\n\nif __name__ == \"__main__\":\n    assert findKthLargest([3, 2, 1, 5, 6, 4], 2) == 5\n</code></pre>"},{"location":"Company/apple/#387-first-unique-character-in-a-string","title":"387. First Unique Character in a String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Queue, Counting</p> </li> </ul>"},{"location":"Company/apple/#622-design-circular-queue","title":"622. Design Circular Queue","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Linked List, Design, Queue</p> </li> </ul> Python <pre><code># Design\nclass MyCircularQueue:\n\n    def __init__(self, k: int):\n        self.queue = [0] * k\n        self.head = 0\n        self.tail = -1\n        self.size = 0\n        self.capacity = k\n\n    def enQueue(self, value: int) -&gt; bool:\n        if self.isFull():\n            return False\n        self.tail = (self.tail + 1) % self.capacity\n        self.queue[self.tail] = value\n        self.size += 1\n        return True\n\n    def deQueue(self) -&gt; bool:\n        if self.isEmpty():\n            return False\n        self.head = (self.head + 1) % self.capacity\n        self.size -= 1\n        return True\n\n    def Front(self) -&gt; int:\n        if self.isEmpty():\n            return -1\n        return self.queue[self.head]\n\n    def Rear(self) -&gt; int:\n        if self.isEmpty():\n            return -1\n        return self.queue[self.tail]\n\n    def isEmpty(self) -&gt; bool:\n        return self.size == 0\n\n    def isFull(self) -&gt; bool:\n        return self.size == self.capacity\n\n\nobj = MyCircularQueue(3)\nprint(obj.enQueue(1))  # True\nprint(obj.enQueue(2))  # True\nprint(obj.enQueue(3))  # True\nprint(obj.enQueue(4))  # False\nprint(obj.Rear())  # 3\nprint(obj.isFull())  # True\nprint(obj.deQueue())  # True\n</code></pre>"},{"location":"Company/apple/#88-merge-sorted-array","title":"88. Merge Sorted Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Sorting</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\nclass merge:\n    @staticmethod\n    def lr(nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None:\n        \"\"\"\n        Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        p1, p2, t = m - 1, n - 1, m + n - 1\n\n        while p1 &gt;= 0 or p2 &gt;= 0:\n            if p1 == -1:\n                nums1[t] = nums2[p2]\n                p2 -= 1\n            elif p2 == -1:\n                nums1[t] = nums1[p1]\n                p1 -= 1\n            elif nums1[p1] &gt; nums2[p2]:\n                nums1[t] = nums1[p1]\n                p1 -= 1\n            else:\n                nums1[t] = nums2[p2]\n                p2 -= 1\n\n            t -= 1\n\n\nif __name__ == \"__main__\":\n    nums1 = [1, 2, 3, 0, 0, 0]\n    m = 3\n    nums2 = [2, 5, 6]\n    n = 3\n    merge.lr(nums1, m, nums2, n)\n    assert nums1 == [1, 2, 2, 3, 5, 6]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {\n        int p1 = m - 1, p2 = n - 1, t = m + n - 1;\n\n        while (p1 &gt;= 0 || p2 &gt;= 0) {\n            if (p1 == -1) {\n                nums1[t] = nums2[p2];\n                p2--;\n            } else if (p2 == -1) {\n                nums1[t] = nums1[p1];\n                p1--;\n            } else if (nums1[p1] &gt; nums2[p2]) {\n                nums1[t] = nums1[p1];\n                p1--;\n            } else {\n                nums1[t] = nums2[p2];\n                p2--;\n            }\n            t--;\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; nums1 = {1, 3, 6, 0, 0, 0};\n    vector&lt;int&gt; nums2 = {2, 5, 6};\n    vector&lt;int&gt; output = {1, 2, 3, 5, 6, 6};\n    solution.merge(nums1, 3, nums2, 3);\n    assert(nums1 == output);\n    return 0;\n}\n</code></pre>"},{"location":"Company/apple/#714-best-time-to-buy-and-sell-stock-with-transaction-fee","title":"714. Best Time to Buy and Sell Stock with Transaction Fee","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the maximum profit you can achieve with the given transaction fee.\n\"\"\"\n\nfrom typing import List\n\n\n# 1. DP\ndef maxProfitDP(prices: List[int], fee: int) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 2 for _ in range(n)]\n\n    dp[0][0] = -prices[0] - fee\n    dp[0][1] = 0\n\n    for i in range(1, n):\n        dp[i][0] = max(\n            dp[i - 1][0],  # hold\n            dp[i - 1][1] - prices[i] - fee,  # buy\n        )\n        dp[i][1] = max(\n            dp[i - 1][1],  # hold\n            dp[i - 1][0] + prices[i],  # sell\n        )\n\n    return max(dp[-1])\n\n\n# 2. Greedy\ndef maxProfitGreedy(prices: List[int], fee: int) -&gt; int:\n    n = len(prices)\n    if n == 0:\n        return 0\n\n    buy = prices[0]\n    profit = 0\n\n    for i in range(1, n):\n        if prices[i] &lt; buy:\n            buy = prices[i]\n        elif prices[i] &gt; buy + fee:\n            profit += prices[i] - buy - fee\n            buy = prices[i] - fee\n\n    return profit\n\n\nprices = [1, 3, 2, 8, 4, 9]\nfee = 2\nprint(maxProfitDP(prices, fee))  # 8\nprint(maxProfitGreedy(prices, fee))  # 8\n</code></pre>"},{"location":"Company/apple/#560-subarray-sum-equals-k","title":"560. Subarray Sum Equals K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Prefix Sum</p> </li> </ul> PythonCPP <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Prefix Sum\ndef subarraySum(nums: List[int], k: int) -&gt; int:\n    preSums = defaultdict(int)\n    preSums[0] = 1\n    curSum = 0\n    res = 0\n\n    for num in nums:\n        curSum += num\n        res += preSums[curSum - k]\n        preSums[curSum] += 1\n\n    return res\n\n\nnums = [1, 1, 1]\nk = 2\nprint(subarraySum(nums, k))  # 2\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint subarraySum(vector&lt;int&gt;&amp; nums, int k) {\n    int n = nums.size();\n    vector&lt;int&gt; prefixSum(n + 1);\n    for (int i = 0; i &lt; n; i++) {\n        prefixSum[i + 1] = prefixSum[i] + nums[i];\n    }\n\n    int res = 0;\n    unordered_map&lt;int, int&gt; cnt;\n\n    for (int ps : prefixSum) {\n        if (cnt.find(ps - k) != cnt.end()) res += cnt[ps - k];\n        cnt[ps]++;\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {1, 1, 1};\n    int k = 2;\n    cout &lt;&lt; subarraySum(nums, k) &lt;&lt; endl;  // 2\n    return 0;\n}\n</code></pre>"},{"location":"Company/apple/#362-design-hit-counter","title":"362. Design Hit Counter \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Design, Queue, Data Stream</p> </li> </ul> Python <pre><code>from collections import deque\n\n\nclass HitCounter:\n\n    def __init__(self):\n        self.hits = deque()\n\n    def hit(self, timestamp: int) -&gt; None:\n        self.hits.append(timestamp)\n\n    def getHits(self, timestamp: int) -&gt; int:\n        # Remove hits that are older than 5 minutes (300 seconds)\n        while self.hits and self.hits[0] &lt;= timestamp - 300:\n            self.hits.popleft()\n        return len(self.hits)\n\n\nobj = HitCounter()\nobj.hit(1)\nobj.hit(2)\nobj.hit(3)\nprint(obj.getHits(4))  # 3\nobj.hit(300)\nprint(obj.getHits(300))  # 4\nprint(obj.getHits(301))  # 3\n</code></pre>"},{"location":"Company/apple/#283-move-zeroes","title":"283. Move Zeroes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Move all zeroes to the end of the array while maintaining the relative order of the non-zero elements.\n\"\"\"\n\nfrom typing import List\n\n\ndef moveZeroes(nums: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    fast, slow = 0, 0\n\n    while fast &lt; len(nums):\n        if nums[fast] != 0:\n            nums[slow], nums[fast] = nums[fast], nums[slow]\n            slow += 1\n        fast += 1\n\n\nnums = [0, 1, 0, 3, 12]\nmoveZeroes(nums)\nprint(nums)  # [1, 3, 12, 0, 0]\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvoid moveZeroes(vector&lt;int&gt;&amp; nums) {\n    size_t n = nums.size();\n    size_t fast = 0, slow = 0;\n\n    while (fast &lt; n) {\n        if (nums[fast] != 0) {\n            swap(nums[slow], nums[fast]);\n            slow++;\n        }\n        fast++;\n    }\n}\n\nint main() {\n    vector&lt;int&gt; nums = {0, 1, 0, 3, 12};\n    moveZeroes(nums);\n    // [1, 3, 12, 0, 0]\n    for (size_t i = 0; i &lt; nums.size(); i++) {\n        cout &lt;&lt; nums[i] &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"Company/apple/#34-find-first-and-last-position-of-element-in-sorted-array","title":"34. Find First and Last Position of Element in Sorted Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> PythonCPP <pre><code>from bisect import bisect_left\nfrom typing import List\n\n\nclass searchRange:\n    \"\"\"\n    \u627e lower bound \u548c upper bound\n    \u770b\u7075\u795e\u5bf9\u8fd9\u9053\u9898\u7684\u9898\u89e3\uff0c\u5206\u7c7b\u8ba8\u8bba\u533a\u95f4\u7684\u5199\u6cd5\n    target \u7684 upper bound \u662f target + 1 \u7684 lower bound - 1\n    \u8fd9\u6837\u5c31\u80fd\u7edf\u4e00\u7528 lower bound \u7684\u5199\u6cd5\n    \"\"\"\n\n    # [left, right]\n    def bisect_left_closed(self, nums, target):\n        \"\"\"\n        \u95ed\u533a\u95f4\u5199\u6cd5\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left &lt;= right:\n            mid = left + (right - left) // 2\n            if nums[mid] &lt; target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n\n    # [left, right)\n    def bisect_left_right_open(self, nums, target):\n        \"\"\"\n        \u5de6\u95ed\u53f3\u5f00\u533a\u95f4\u5199\u6cd5\n        \"\"\"\n        left, right = 0, len(nums)\n        while left &lt; right:\n            mid = left + (right - left) // 2\n            if nums[mid] &gt;= target:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\n    # (left, right)\n    def bisect_left_open(self, nums, target):\n        \"\"\"\n        \u63a8\u8350\u5f00\u533a\u95f4\u5199\u6cd5\n        \"\"\"\n        left, right = -1, len(nums)\n        while left + 1 &lt; right:\n            mid = left + (right - left) // 2\n            if nums[mid] &lt; target:\n                left = mid\n            else:\n                right = mid\n        return right\n\n    def search_range(self, nums: List[int], target: int) -&gt; List[int]:\n        # edge case\n        if not nums:\n            return [-1, -1]\n\n        lower = self.bisect_left_closed(nums, target)\n        upper = self.bisect_left_closed(nums, target + 1) - 1\n\n        return [lower, upper] if lower &lt;= upper else [-1, -1]\n\n    def search_range_bisect(self, nums: List[int], target: int) -&gt; List[int]:\n        \"\"\"\u7528 python bisect \u5e93\u51fd\u6570\"\"\"\n        # edge case\n        if not nums:\n            return [-1, -1]\n\n        lower = bisect_left(nums, target)\n        upper = bisect_left(nums, target + 1) - 1\n\n        return [lower, upper] if lower &lt;= upper else [-1, -1]\n\n\nif __name__ == \"__main__\":\n    nums = [5, 7, 7, 8, 8, 10]\n    target = 8\n    sol = searchRange()\n    assert sol.search_range(nums, target) == [3, 4]\n    assert sol.search_range_bisect(nums, target) == [3, 4]\n</code></pre> <pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\n  int bisect_left(vector&lt;int&gt; &amp;nums, int target)\n  {\n    int left = 0, right = (int)nums.size() - 1;\n\n    while (left &lt;= right)\n    {\n      int mid = left + (right - left) / 2;\n      if (nums[mid] &lt; target)\n      {\n        left = mid + 1;\n      }\n      else\n      {\n        right = mid - 1;\n      }\n    }\n    return left;\n  }\n\npublic:\n  vector&lt;int&gt; searchRange(vector&lt;int&gt; &amp;nums, int target)\n  {\n    int left = bisect_left(nums, target);\n    if (left == (int)nums.size() || nums[left] != target)\n    {\n      return {-1, -1};\n    }\n    int right = bisect_left(nums, target + 1) - 1;\n    return {left, right};\n  }\n};\n\nint main()\n{\n  vector&lt;int&gt; nums = {5, 7, 7, 8, 8, 10};\n  int target = 8;\n  Solution s;\n  vector&lt;int&gt; res = s.searchRange(nums, target);\n  cout &lt;&lt; res[0] &lt;&lt; \", \" &lt;&lt; res[1] &lt;&lt; endl;\n  return 0;\n}\n</code></pre>"},{"location":"Company/apple/#3-longest-substring-without-repeating-characters","title":"3. Longest Substring Without Repeating Characters","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Classic variable sliding window problem. Use a set to keep track of the characters in the current window.\n- Return the length of the longest substring without repeating characters.\n- [Template tutorial by \u7075\u5c71\u8336\u827e\u5e9c](https://leetcode.cn/problems/longest-substring-without-repeating-characters/solutions/1959540/xia-biao-zong-suan-cuo-qing-kan-zhe-by-e-iaks)\n\"\"\"\n\nfrom collections import defaultdict\n\n\n# Sliding Window Variable Max - HashMap\ndef lengthOfLongestSubstringHash(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    left = 0\n    cnt = defaultdict(int)\n    res = 0\n\n    for right in range(n):\n        cnt[s[right]] += 1\n\n        while cnt[s[right]] &gt; 1:\n            cnt[s[left]] -= 1\n            left += 1\n\n        res = max(res, right - left + 1)\n\n    return res\n\n\n# Sliding Window Variable Max - Set\ndef lengthOfLongestSubstringSet(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    left = 0\n    res = 0\n    window = set()\n\n    for right in range(n):\n        while left &lt; right and s[right] in window:\n            window.remove(s[left])\n            left += 1\n        window.add(s[right])\n        res = max(res, right - left + 1)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    s = \"abcabcbb\"\n    assert lengthOfLongestSubstringHash(s) == 3\n    assert lengthOfLongestSubstringSet(s) == 3\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;unordered_set&gt;\nusing namespace std;\n\nint lengthOfLongestSubstring(string s) {\n    int n = s.length();\n    int res = 0;\n    int left = 0;\n    unordered_set&lt;char&gt; window;\n\n    for (int right = 0; right &lt; n; right++) {\n        char ch = s[right];\n\n        while (window.find(ch) != window.end()) {\n            window.erase(s[left]);\n            left++;\n        }\n\n        window.insert(ch);\n        res = max(res, right - left + 1);\n    }\n    return (int)res;\n}\n\nint main() {\n    string s = \"abcabcbb\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 3\n    s = \"bbbbb\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 1\n    s = \"pwwkew\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 3\n    return 0;\n}\n</code></pre>"},{"location":"Company/apple/#208-implement-trie-prefix-tree","title":"208. Implement Trie (Prefix Tree)","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Design, Trie</p> </li> </ul> Python <pre><code>\"\"\"\n### Trie\n\n- A trie is a tree-like data structure whose nodes store the letters of an alphabet.\n\"\"\"\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.endOfWord = None\n\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.endOfWord = True\n\n    def search(self, word: str) -&gt; bool:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return node.endOfWord\n\n    def startsWith(self, prefix: str) -&gt; bool:\n        node = self.root\n\n        for c in prefix:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return True\n\n\n# Your Trie object will be instantiated and called as such:\nobj = Trie()\nobj.insert(\"apple\")\nprint(obj.search(\"word\"))  # False\nprint(obj.startsWith(\"app\"))  # True\n</code></pre>"},{"location":"Company/apple/#348-design-tic-tac-toe","title":"348. Design Tic-Tac-Toe \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Design, Matrix, Simulation</p> </li> </ul>"},{"location":"Company/apple/#151-reverse-words-in-a-string","title":"151. Reverse Words in a String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String</p> </li> </ul> Python <pre><code>def reverseWords(s: str) -&gt; str:\n    words = s.split()\n\n    left, right = 0, len(words) - 1\n\n    while left &lt; right:\n        words[left], words[right] = words[right], words[left]\n        left += 1\n        right -= 1\n\n    return \" \".join(words)\n\n\ns = \"the sky is blue\"\nprint(reverseWords(s))  # \"blue is sky the\"\n</code></pre>"},{"location":"Company/apple/#53-maximum-subarray","title":"53. Maximum Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Divide And Conquer, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP Kadane\ndef maxSubArrayDP(nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n\n    dp[0] = nums[0]\n    maxSum = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(\n            dp[i - 1] + nums[i],  # continue the previous subarray\n            nums[i],  # start a new subarray\n        )\n        maxSum = max(maxSum, dp[i])\n\n    return maxSum\n\n\n# Greedy\ndef maxSubArrayGreedy(nums: List[int]) -&gt; int:\n    max_sum = nums[0]\n    cur_sum = 0\n\n    for num in nums:\n        cur_sum = max(cur_sum + num, num)\n        max_sum = max(max_sum, cur_sum)\n\n    return max_sum\n\n\n# Prefix Sum\ndef maxSubArrayPrefixSum(nums: List[int]) -&gt; int:\n    prefix_sum = 0\n    prefix_sum_min = 0\n    res = float(\"-inf\")\n\n    for num in nums:\n        prefix_sum += num\n        res = max(res, prefix_sum - prefix_sum_min)\n        prefix_sum_min = min(prefix_sum_min, prefix_sum)\n\n    return res\n\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArrayDP(nums))  # 6\nprint(maxSubArrayGreedy(nums))  # 6\nprint(maxSubArrayPrefixSum(nums))  # 6\n</code></pre>"},{"location":"Company/bloomberg/","title":"Bloomberg","text":""},{"location":"Company/bloomberg/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1. Two Sum (Easy)</li> <li> 56. Merge Intervals (Medium)</li> <li> 3. Longest Substring Without Repeating Characters (Medium)</li> <li> 430. Flatten a Multilevel Doubly Linked List (Medium)</li> <li> 20. Valid Parentheses (Easy)</li> <li> 380. Insert Delete GetRandom O(1) (Medium)</li> <li> 2. Add Two Numbers (Medium)</li> <li> 79. Word Search (Medium)</li> <li> 121. Best Time to Buy and Sell Stock (Easy)</li> <li> 88. Merge Sorted Array (Easy)</li> <li> 42. Trapping Rain Water (Hard)</li> <li> 242. Valid Anagram (Easy)</li> <li> 4. Median of Two Sorted Arrays (Hard)</li> <li> 1169. Invalid Transactions (Medium)</li> <li> 31. Next Permutation (Medium)</li> <li> 5. Longest Palindromic Substring (Medium)</li> <li> 394. Decode String (Medium)</li> <li> 78. Subsets (Medium)</li> <li> 146. LRU Cache (Medium)</li> <li> 14. Longest Common Prefix (Easy)</li> <li> 128. Longest Consecutive Sequence (Medium)</li> <li> 34. Find First and Last Position of Element in Sorted Array (Medium)</li> <li> 217. Contains Duplicate (Easy)</li> <li> 22. Generate Parentheses (Medium)</li> <li> 560. Subarray Sum Equals K (Medium)</li> <li> 21. Merge Two Sorted Lists (Easy)</li> <li> 2667. Create Hello World Function (Easy)</li> <li> 13. Roman to Integer (Easy)</li> <li> 53. Maximum Subarray (Medium)</li> <li> 1244. Design A Leaderboard (Medium) \ud83d\udc51</li> </ul>"},{"location":"Company/bloomberg/#1-two-sum","title":"1. Two Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return the indices of the two numbers such that they add up to a specific target.\n- Approach: Use a hashmap to store the indices of the numbers.\n- Time Complexity: O(n)\n- Space Complexity: O(n)\n\"\"\"\n\nfrom typing import List\n\n\ndef two_sum(nums: List[int], target: int) -&gt; List[int]:\n    hashmap = {}  # val: idx\n\n    for idx, val in enumerate(nums):\n        if (target - val) in hashmap:\n            return [hashmap[target - val], idx]\n\n        hashmap[val] = idx\n\n    return []\n\n\ndef test_two_sum():\n    assert two_sum([2, 7, 11, 15], 9) == [0, 1]\n    assert two_sum([3, 2, 4], 6) == [1, 2]\n    assert two_sum([3, 3], 6) == [0, 1]\n    assert two_sum([1, 2, 3, 4, 5], 10) == []\n    assert two_sum([-1, -2, -3, -4, -5], -8) == [2, 4]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Solution {\n   public:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {\n        unordered_map&lt;int, int&gt; map;\n\n        for (size_t i = 0; i &lt; nums.size(); i++) {\n            int diff = target - nums[i];\n            if (map.find(diff) != map.end()) {\n                return {map[diff], (int)i};\n            }\n            map[nums[i]] = (int)i;\n        }\n        return {-1, -1};\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; nums = {2, 7, 11, 15};\n    int target = 9;\n    vector&lt;int&gt; result = solution.twoSum(nums, target);\n    assert((result == vector&lt;int&gt;{0, 1}));\n    return 0;\n}\n</code></pre>"},{"location":"Company/bloomberg/#56-merge-intervals","title":"56. Merge Intervals","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sorting</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Merge all overlapping intervals.\n\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/44H3cEC2fFM?si=J-Jr_Fg2eDse3-de\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen&gt;&lt;/iframe&gt;\n\"\"\"\n\nfrom typing import List\n\n\n# Intervals\ndef merge(intervals: List[List[int]]) -&gt; List[List[int]]:\n    n = len(intervals)\n    if n &lt;= 1:\n        return intervals\n\n    intervals.sort(key=lambda x: x[0])\n    res = [intervals[0]]\n\n    for i in range(1, n):\n        if intervals[i][0] &lt;= res[-1][1]:\n            res[-1][1] = max(res[-1][1], intervals[i][1])\n        else:\n            res.append(intervals[i])\n\n    return res\n\n\nprint(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))\n# [[1, 6], [8, 10], [15, 18]]\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// Interval\nvector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {\n    sort(intervals.begin(), intervals.end());\n    vector&lt;vector&lt;int&gt;&gt; res;\n\n    for (auto&amp; range : intervals) {\n        if (!res.empty() &amp;&amp; range[0] &lt;= res.back()[1]) {\n            res.back()[1] = max(res.back()[1], range[1]);\n        } else {\n            res.emplace_back(range);\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;vector&lt;int&gt;&gt; intervals = {{1, 3}, {2, 6}, {8, 10}, {15, 18}};\n    vector&lt;vector&lt;int&gt;&gt; res = merge(intervals);\n    for (auto&amp; range : res) {\n        cout &lt;&lt; range[0] &lt;&lt; \", \" &lt;&lt; range[1] &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Company/bloomberg/#3-longest-substring-without-repeating-characters","title":"3. Longest Substring Without Repeating Characters","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Classic variable sliding window problem. Use a set to keep track of the characters in the current window.\n- Return the length of the longest substring without repeating characters.\n- [Template tutorial by \u7075\u5c71\u8336\u827e\u5e9c](https://leetcode.cn/problems/longest-substring-without-repeating-characters/solutions/1959540/xia-biao-zong-suan-cuo-qing-kan-zhe-by-e-iaks)\n\"\"\"\n\nfrom collections import defaultdict\n\n\n# Sliding Window Variable Max - HashMap\ndef lengthOfLongestSubstringHash(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    left = 0\n    cnt = defaultdict(int)\n    res = 0\n\n    for right in range(n):\n        cnt[s[right]] += 1\n\n        while cnt[s[right]] &gt; 1:\n            cnt[s[left]] -= 1\n            left += 1\n\n        res = max(res, right - left + 1)\n\n    return res\n\n\n# Sliding Window Variable Max - Set\ndef lengthOfLongestSubstringSet(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    left = 0\n    res = 0\n    window = set()\n\n    for right in range(n):\n        while left &lt; right and s[right] in window:\n            window.remove(s[left])\n            left += 1\n        window.add(s[right])\n        res = max(res, right - left + 1)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    s = \"abcabcbb\"\n    assert lengthOfLongestSubstringHash(s) == 3\n    assert lengthOfLongestSubstringSet(s) == 3\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;unordered_set&gt;\nusing namespace std;\n\nint lengthOfLongestSubstring(string s) {\n    int n = s.length();\n    int res = 0;\n    int left = 0;\n    unordered_set&lt;char&gt; window;\n\n    for (int right = 0; right &lt; n; right++) {\n        char ch = s[right];\n\n        while (window.find(ch) != window.end()) {\n            window.erase(s[left]);\n            left++;\n        }\n\n        window.insert(ch);\n        res = max(res, right - left + 1);\n    }\n    return (int)res;\n}\n\nint main() {\n    string s = \"abcabcbb\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 3\n    s = \"bbbbb\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 1\n    s = \"pwwkew\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 3\n    return 0;\n}\n</code></pre>"},{"location":"Company/bloomberg/#430-flatten-a-multilevel-doubly-linked-list","title":"430. Flatten a Multilevel Doubly Linked List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Depth First Search, Doubly Linked List</p> </li> </ul>"},{"location":"Company/bloomberg/#20-valid-parentheses","title":"20. Valid Parentheses","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack</p> </li> </ul> PythonCPP <pre><code># Stack\ndef is_valid(s: str) -&gt; bool:\n    if len(s) % 2:\n        return False\n\n    pairs = {\n        \"(\": \")\",\n        \"{\": \"}\",\n        \"[\": \"]\",\n    }\n    stack = []\n    for ch in s:\n        if ch in pairs:\n            stack.append(ch)\n        elif not stack or ch != pairs[stack.pop()]:\n            return False\n\n    return True if not stack else False\n\n\ndef test_is_valid():\n    assert is_valid(\"()[]{}\")\n    assert not is_valid(\"(]\")\n    assert not is_valid(\"([)]\")\n    assert is_valid(\"{[]}\")\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;stack&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool isValid(string s) {\n        unordered_map&lt;char, char&gt; map{{')', '('}, {'}', '{'}, {']', '['}};\n        stack&lt;char&gt; stack;\n        if (s.length() % 2 == 1) return false;\n\n        for (char&amp; ch : s) {\n            if (stack.empty() || map.find(ch) == map.end()) {\n                stack.push(ch);\n            } else {\n                if (map[ch] != stack.top()) {\n                    return false;\n                }\n                stack.pop();\n            }\n        }\n        return stack.empty();\n    }\n};\n\nint main() {\n    Solution s;\n    assert(s.isValid(\"()\") == true);\n    assert(s.isValid(\"()[]{}\") == true);\n    assert(s.isValid(\"(]\") == false);\n    assert(s.isValid(\"([)]\") == false);\n    assert(s.isValid(\"{[]}\") == true);\n    return 0;\n}\n</code></pre>"},{"location":"Company/bloomberg/#380-insert-delete-getrandom-o1","title":"380. Insert Delete GetRandom O(1)","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Design, Randomized</p> </li> </ul> Python <pre><code>import random\n\n\nclass RandomizedSet:\n    def __init__(self):\n        self.nums = []\n        self.pos = {}  # num: idx\n\n    def insert(self, val: int) -&gt; bool:\n        if val in self.pos:\n            return False\n        self.pos[val] = len(self.nums)\n        self.nums.append(val)\n        return True\n\n    def remove(self, val: int) -&gt; bool:\n        if val not in self.pos:\n            return False\n\n        idx = self.pos[val]\n        last_val = self.nums[-1]\n        self.nums[idx] = last_val\n        self.pos[last_val] = idx\n\n        self.nums.pop()\n        del self.pos[val]\n        return True\n\n    def getRandom(self) -&gt; int:\n        return random.choice(self.nums)\n\n\ndef test_RandomizedSet():\n    obj = RandomizedSet()\n    assert obj.insert(1)\n    assert not obj.remove(2)\n    assert obj.insert(2)\n    assert obj.getRandom() in [1, 2]\n    assert obj.remove(1)\n    assert not obj.insert(2)\n    assert obj.getRandom() == 2\n</code></pre>"},{"location":"Company/bloomberg/#2-add-two-numbers","title":"2. Add Two Numbers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Math, Recursion</p> </li> </ul> PythonCPP <pre><code>from typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\ndef add_two_numbers(l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]:\n    \"\"\"Add two numbers represented by linked lists.\"\"\"\n    dummy = ListNode()\n    cur = dummy\n    carry = 0\n\n    while l1 or l2:\n        v1 = l1.val if l1 else 0\n        v2 = l2.val if l2 else 0\n\n        carry, val = divmod(v1 + v2 + carry, 10)\n        cur.next = ListNode(val)\n        cur = cur.next\n\n        if l1:\n            l1 = l1.next\n        if l2:\n            l2 = l2.next\n\n    if carry:\n        cur.next = ListNode(val=carry)\n\n    return dummy.next\n\n\ndef test_add_two_numbers():\n    l1 = LinkedList([2, 4, 3]).head\n    l2 = LinkedList([5, 6, 4]).head\n    added = add_two_numbers(l1, l2)\n    assert LinkedList(added).to_array() == [7, 0, 8]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode* next) : val(x), next(next) {}\n};\n\nclass Solution {\n   public:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode dummy;\n        ListNode* cur = &amp;dummy;\n        int carry = 0;\n\n        while (l1 || l2 || carry) {\n            if (l1) {\n                carry += l1-&gt;val;\n                l1 = l1-&gt;next;\n            }\n            if (l2) {\n                carry += l2-&gt;val;\n                l2 = l2-&gt;next;\n            }\n            cur-&gt;next = new ListNode(carry % 10);\n            cur = cur-&gt;next;\n            carry /= 10;\n        }\n        return dummy.next;\n    }\n};\n\nint main() {\n    Solution sol;\n\n    ListNode* l1 = new ListNode(2, new ListNode(4, new ListNode(3)));\n    ListNode* l2 = new ListNode(5, new ListNode(6, new ListNode(4)));\n    ListNode* result = sol.addTwoNumbers(l1, l2);\n\n    vector&lt;int&gt; expected = {7, 0, 8};\n    for (int val : expected) {\n        assert(result != nullptr &amp;&amp; result-&gt;val == val);\n        result = result-&gt;next;\n    }\n    assert(result == nullptr);  // End of list\n\n    return 0;\n}\n</code></pre>"},{"location":"Company/bloomberg/#79-word-search","title":"79. Word Search","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Backtracking, Depth First Search, Matrix</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef exist(board: List[List[str]], word: str) -&gt; bool:\n    m, n = len(board), len(board[0])\n    path = set()\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n\n    def dfs(r, c, i):\n        if i == len(word):\n            return True\n\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or board[r][c] != word[i] or (r, c) in path:\n            return False\n\n        path.add((r, c))\n\n        for dr, dc in dirs:\n            if dfs(r + dr, c + dc, i + 1):\n                return True\n\n        path.remove((r, c))\n        return False\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, 0):\n                return True\n\n    return False\n\n\nboard = [\n    [\"A\", \"B\", \"C\", \"E\"],\n    [\"S\", \"F\", \"C\", \"S\"],\n    [\"A\", \"D\", \"E\", \"E\"],\n]\nword = \"ABCCED\"\nprint(exist(board, word))  # True\n</code></pre>"},{"location":"Company/bloomberg/#121-best-time-to-buy-and-sell-stock","title":"121. Best Time to Buy and Sell Stock","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return the maximum profit that can be achieved from buying on one day and selling on another day.\n\"\"\"\n\nfrom typing import List\n\n\n# Brute Force\ndef maxProfitBF(prices: List[int]) -&gt; int:\n    max_profit = 0\n    n = len(prices)\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_profit = max(max_profit, prices[j] - prices[i])\n\n    return max_profit\n\n\n# DP\ndef maxProfitDP(prices: List[int]) -&gt; int:\n    dp = [[0] * 2 for _ in range(len(prices))]\n    dp[0][0] = -prices[0]  # buy\n    dp[0][1] = 0  # sell\n\n    for i in range(1, len(prices)):\n        dp[i][0] = max(dp[i - 1][0], -prices[i])  # the lowest price to buy\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    max_profit = 0\n    seen_min = prices[0]\n\n    for i in range(1, len(prices)):\n        max_profit = max(max_profit, prices[i] - seen_min)\n        seen_min = min(seen_min, prices[i])\n\n    return max_profit\n\n\n# Fast Slow Pointers\ndef maxProfitFS(prices: List[int]) -&gt; int:\n    max_profit = 0\n    slow, fast = 0, 1\n\n    while fast &lt; len(prices):\n        if prices[fast] &gt; prices[slow]:\n            max_profit = max(max_profit, prices[fast] - prices[slow])\n        else:\n            slow = fast\n        fast += 1\n\n    return max_profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force|  O(n^2)|  O(1)   |\n# | DP         |  O(n)  |  O(n)   |\n# | Greedy     |  O(n)  |  O(1)   |\n# | Fast Slow  |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitBF(prices))  # 5\nprint(maxProfitDP(prices))  # 5\nprint(maxProfitGreedy(prices))  # 5\nprint(maxProfitFS(prices))  # 5\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int maxProfitMemo(vector&lt;int&gt; &amp;prices) {\n        if (prices.size() &lt;= 1) return 0;\n\n        int seen_min = prices[0];\n        int res = 0;\n\n        for (int &amp;price : prices) {\n            res = max(res, price - seen_min);\n            seen_min = min(seen_min, price);\n        }\n        return res;\n    }\n};\n\nint main() {\n    vector&lt;int&gt; prices = {7, 1, 5, 3, 6, 4};\n    Solution obj;\n    cout &lt;&lt; obj.maxProfitMemo(prices) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"Company/bloomberg/#88-merge-sorted-array","title":"88. Merge Sorted Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Sorting</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\nclass merge:\n    @staticmethod\n    def lr(nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None:\n        \"\"\"\n        Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        p1, p2, t = m - 1, n - 1, m + n - 1\n\n        while p1 &gt;= 0 or p2 &gt;= 0:\n            if p1 == -1:\n                nums1[t] = nums2[p2]\n                p2 -= 1\n            elif p2 == -1:\n                nums1[t] = nums1[p1]\n                p1 -= 1\n            elif nums1[p1] &gt; nums2[p2]:\n                nums1[t] = nums1[p1]\n                p1 -= 1\n            else:\n                nums1[t] = nums2[p2]\n                p2 -= 1\n\n            t -= 1\n\n\nif __name__ == \"__main__\":\n    nums1 = [1, 2, 3, 0, 0, 0]\n    m = 3\n    nums2 = [2, 5, 6]\n    n = 3\n    merge.lr(nums1, m, nums2, n)\n    assert nums1 == [1, 2, 2, 3, 5, 6]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {\n        int p1 = m - 1, p2 = n - 1, t = m + n - 1;\n\n        while (p1 &gt;= 0 || p2 &gt;= 0) {\n            if (p1 == -1) {\n                nums1[t] = nums2[p2];\n                p2--;\n            } else if (p2 == -1) {\n                nums1[t] = nums1[p1];\n                p1--;\n            } else if (nums1[p1] &gt; nums2[p2]) {\n                nums1[t] = nums1[p1];\n                p1--;\n            } else {\n                nums1[t] = nums2[p2];\n                p2--;\n            }\n            t--;\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; nums1 = {1, 3, 6, 0, 0, 0};\n    vector&lt;int&gt; nums2 = {2, 5, 6};\n    vector&lt;int&gt; output = {1, 2, 3, 5, 6, 6};\n    solution.merge(nums1, 3, nums2, 3);\n    assert(nums1 == output);\n    return 0;\n}\n</code></pre>"},{"location":"Company/bloomberg/#42-trapping-rain-water","title":"42. Trapping Rain Water","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Dynamic Programming, Stack, Monotonic Stack</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- ![42](../../assets/0042.png)\n\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/ZI2z5pq0TqA?si=OEYg01dbmzvmtIwZ\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen&gt;&lt;/iframe&gt;\n\n| Approach   | Time | Space |\n| ---------- | ---- | ----- |\n| DP         | O(N) | O(N)  |\n| Left Right | O(N) | O(1)  |\n| Monotonic  | O(N) | O(N)  |\n\"\"\"\n\nfrom typing import List\n\n\n# DP\ndef trapDP(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    n = len(height)\n    maxLeft, maxRight = [0 for _ in range(n)], [0 for _ in range(n)]\n\n    for i in range(1, n):\n        maxLeft[i] = max(maxLeft[i - 1], height[i - 1])\n\n    for i in range(n - 2, -1, -1):\n        maxRight[i] = max(maxRight[i + 1], height[i + 1])\n\n    res = 0\n    for i in range(n):\n        res += max(0, min(maxLeft[i], maxRight[i]) - height[i])\n\n    return res\n\n\n# Left Right Pointers\ndef trapLR(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    left, right = 0, len(height) - 1\n    maxL, maxR = height[left], height[right]\n    res = 0\n\n    while left &lt; right:\n        if maxL &lt; maxR:\n            left += 1\n            maxL = max(maxL, height[left])\n            res += maxL - height[left]\n        else:\n            right -= 1\n            maxR = max(maxR, height[right])\n            res += maxR - height[right]\n\n    return res\n\n\n# Monotonic Stack\ndef trapStack(height: List[int]) -&gt; int:\n    stack = []\n    total = 0\n\n    for i in range(len(height)):\n        while stack and height[i] &gt; height[stack[-1]]:\n            top = stack.pop()\n            if not stack:\n                break\n            distance = i - stack[-1] - 1\n            bounded_height = min(height[i], height[stack[-1]]) - height[top]\n            total += distance * bounded_height\n        stack.append(i)\n\n    return total\n\n\nheight = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\nprint(trapDP(height))  # 6\nprint(trapLR(height))  # 6\nprint(trapStack(height))  # 6\n</code></pre> <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int trap(vector&lt;int&gt; &amp;height)\n    {\n        if (height.empty())\n            return 0;\n\n        int res = 0;\n        int left = 0, right = height.size() - 1;\n        int maxL = height[left], maxR = height[right];\n\n        while (left &lt; right)\n        {\n            if (maxL &lt; maxR)\n            {\n                left++;\n                maxL = max(maxL, height[left]);\n                res += maxL - height[left];\n            }\n            else\n            {\n                right--;\n                maxR = max(maxR, height[right]);\n                res += maxR - height[right];\n            }\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    vector&lt;int&gt; height = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};\n    Solution solution;\n    cout &lt;&lt; solution.trap(height) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"Company/bloomberg/#242-valid-anagram","title":"242. Valid Anagram","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sorting</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return true if an input string is an anagram of another string.\n-   An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once, e.g., `listen` is an anagram of `silent`.\n\"\"\"\n\nfrom collections import Counter\n\n\n# Hashmap\ndef isAnagramHash(s: str, t: str) -&gt; bool:\n    \"\"\"Return True if t is an anagram of s, False otherwise.\"\"\"\n    if len(s) != len(t):\n        return False\n\n    count = dict()\n\n    for i in s:\n        if i in count:\n            count[i] += 1\n        else:\n            count[i] = 1\n\n    for j in t:\n        if j in count:\n            count[j] -= 1\n        else:\n            return False\n\n    for count in count.values():\n        if count != 0:\n            return False\n\n    return True\n\n\n# Array\ndef isAnagramArray(s: str, t: str) -&gt; bool:\n    if len(s) != len(t):\n        return False\n\n    count = [0 for _ in range(26)]\n\n    for i in s:\n        count[ord(i) - ord(\"a\")] += 1\n\n    for j in t:\n        count[ord(j) - ord(\"a\")] -= 1\n\n    for i in count:\n        if i != 0:\n            return False\n\n    return True\n\n\n# Counter\ndef isAnagramCounter(s: str, t: str) -&gt; bool:\n    return Counter(s) == Counter(t)\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |   Hashmap   |       O(n)      |     O(1)     |\n# |    Array    |       O(n)      |     O(1)     |\n# |   Counter   |       O(n)      |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\ns = \"anagram\"\nt = \"nagaram\"\nprint(isAnagramHash(s, t))  # True\nprint(isAnagramArray(s, t))  # True\nprint(isAnagramCounter(s, t))  # True\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool isAnagram(string s, string t) {\n        if (s.size() != t.size()) return false;\n\n        vector&lt;int&gt; count(26, 0);\n\n        for (char ch : s) count[ch - 'a']++;\n        for (char ch : t) count[ch - 'a']--;\n        for (int c : count) {\n            if (c != 0) return false;\n        }\n\n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n    assert(solution.isAnagram(\"anagram\", \"nagaram\") == true);\n    assert(solution.isAnagram(\"rat\", \"car\") == false);\n    assert(solution.isAnagram(\"a\", \"ab\") == false);\n    assert(solution.isAnagram(\"a\", \"a\") == true);\n    return 0;\n}\n</code></pre>"},{"location":"Company/bloomberg/#4-median-of-two-sorted-arrays","title":"4. Median of Two Sorted Arrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Divide And Conquer</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Brute Force\ndef findMedianSortedArraysBF(nums1: List[int], nums2: List[int]) -&gt; float:\n    nums = sorted(nums1 + nums2)\n    n = len(nums)\n    if n % 2 == 0:\n        return (nums[n // 2 - 1] + nums[n // 2]) / 2\n    else:\n        return nums[n // 2]\n\n\n# Binary Search\ndef findMedianSortedArraysBS(nums1: List[int], nums2: List[int]) -&gt; float:\n    if len(nums1) &gt; len(nums2):\n        nums1, nums2 = nums2, nums1\n\n    m, n = len(nums1), len(nums2)\n    imin, imax, half_len = 0, m, (m + n + 1) // 2\n\n    while imin &lt;= imax:\n        i = (imin + imax) // 2\n        j = half_len - i\n\n        if i &lt; m and nums2[j - 1] &gt; nums1[i]:\n            imin = i + 1\n        elif i &gt; 0 and nums1[i - 1] &gt; nums2[j]:\n            imax = i - 1\n        else:\n            if i == 0:\n                max_of_left = nums2[j - 1]\n            elif j == 0:\n                max_of_left = nums1[i - 1]\n            else:\n                max_of_left = max(nums1[i - 1], nums2[j - 1])\n\n            if (m + n) % 2 == 1:\n                return max_of_left\n\n            if i == m:\n                min_of_right = nums2[j]\n            elif j == n:\n                min_of_right = nums1[i]\n            else:\n                min_of_right = min(nums1[i], nums2[j])\n\n            return (max_of_left + min_of_right) / 2\n\n\n# |--------------|-----------------|--------------|\n# | Approach     | Time            | Space        |\n# |--------------|-----------------|--------------|\n# | Brute Force  | O((n+m)log(n+m))| O(n+m)       |\n# | Binary Search| O(log(min(n,m)))| O(1)         |\n# |--------------|-----------------|--------------|\n\n\nnums1 = [1, 3]\nnums2 = [2]\nprint(findMedianSortedArraysBF(nums1, nums2))  # 2.0\nprint(findMedianSortedArraysBS(nums1, nums2))  # 2.0\n</code></pre>"},{"location":"Company/bloomberg/#1169-invalid-transactions","title":"1169. Invalid Transactions","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Sorting</p> </li> </ul>"},{"location":"Company/bloomberg/#31-next-permutation","title":"31. Next Permutation","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef nextPermutation(nums: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    n = len(nums)\n    i = n - 1\n    while i &gt; 0 and nums[i - 1] &gt;= nums[i]:\n        i -= 1\n    if i != 0:\n        j = n - 1\n        while nums[j] &lt;= nums[i - 1]:\n            j -= 1\n        nums[i - 1], nums[j] = nums[j], nums[i - 1]\n\n    left, right = i, n - 1\n    while left &lt; right:\n        nums[left], nums[right] = nums[right], nums[left]\n        left += 1\n        right -= 1\n\n\nnums = [1, 2, 3]\nnextPermutation(nums)\nprint(nums)  # [1, 3, 2]\nnums = [1, 2, 3, 4, 6, 5]\nnextPermutation(nums)\nprint(nums)  # [1, 2, 3, 5, 4, 6]\n</code></pre>"},{"location":"Company/bloomberg/#5-longest-palindromic-substring","title":"5. Longest Palindromic Substring","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Dynamic Programming</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the longest palindromic substring in `s`.\n\"\"\"\n\n\n# DP - Interval\ndef longestPalindromeDP(s: str) -&gt; str:\n    n = len(s)\n    if n &lt;= 1:\n        return s\n\n    start, maxLen = 0, 1\n\n    # Init\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for j in range(1, n):\n        for i in range(j):\n            if s[i] == s[j]:\n                if j - i &lt;= 2:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1]\n\n                if dp[i][j] and j - i + 1 &gt; maxLen:\n                    maxLen = j - i + 1\n                    start = i\n\n    return s[start : start + maxLen]\n\n\n# Expand Around Center\ndef longestPalindromeCenter(s: str) -&gt; str:\n    def expand_around_center(left, right):\n        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n\n    if len(s) &lt;= 1:\n        return s\n\n    start, end = 0, 0\n    for i in range(len(s)):\n        len1 = expand_around_center(i, i)  # odd\n        len2 = expand_around_center(i, i + 1)  # even\n\n        maxLen = max(len1, len2)\n        if maxLen &gt; end - start:\n            start = i - (maxLen - 1) // 2\n            end = i + maxLen // 2\n\n    return s[start : end + 1]\n\n\ns = \"babad\"\nprint(longestPalindromeDP(s))  # \"bab\"\nprint(longestPalindromeCenter(s))  # \"aba\"\n</code></pre>"},{"location":"Company/bloomberg/#394-decode-string","title":"394. Decode String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack, Recursion</p> </li> </ul> Python <pre><code># Stack\ndef decodeString(s: str) -&gt; str:\n    stack = []  # (str, int)\n    num = 0\n    res = \"\"\n\n    for c in s:\n        if c.isdigit():\n            num = num * 10 + int(c)\n        elif c == \"[\":\n            stack.append((res, num))\n            res, num = \"\", 0\n        elif c == \"]\":\n            top = stack.pop()\n            res = top[0] + res * top[1]\n        else:\n            res += c\n\n    return res\n\n\ns = \"3[a2[c]]\"\nprint(decodeString(s))  # accaccacc\n</code></pre>"},{"location":"Company/bloomberg/#78-subsets","title":"78. Subsets","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking, Bit Manipulation</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Iterative Inclusion Backtracking\ndef subsets_iterative_inclusion(nums: List[int]) -&gt; List[List[int]]:\n    n = len(nums)\n    res, path = [], []\n\n    def dfs(i):\n        res.append(path.copy())\n\n        for j in range(i, n):\n            path.append(nums[j])\n            dfs(j + 1)\n            path.pop()\n\n    dfs(0)\n\n    return res\n\n\n# Binary Decision Backtracking\ndef subsets_binary_decision(nums: List[int]) -&gt; List[List[int]]:\n    n = len(nums)\n    res, path = [], []\n\n    def dfs(i):\n        if i == n:\n            res.append(path.copy())\n            return\n\n        # Exclude\n        dfs(i + 1)\n\n        # Include\n        path.append(nums[i])\n        dfs(i + 1)\n        path.pop()\n\n    dfs(0)\n\n    return res\n\n\nprint(subsets_iterative_inclusion([1, 2, 3]))\n# [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]\nprint(subsets_binary_decision([1, 2, 3]))\n# [[], [3], [2], [2, 3], [1], [1, 3], [1, 2], [1, 2, 3]]\n</code></pre>"},{"location":"Company/bloomberg/#146-lru-cache","title":"146. LRU Cache","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Linked List, Design, Doubly Linked List</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Design and implement a data structure for **Least Recently Used (LRU) cache**. It should support the following operations: get and put.\n- [lru](https://media.geeksforgeeks.org/wp-content/uploads/20240909142802/Working-of-LRU-Cache-copy-2.webp)\n- ![146](https://miro.medium.com/v2/resize:fit:650/0*fOwBd3z0XtHh7WN1.png)\n\n| Data structure     | Description                   |\n| ------------------ | ----------------------------- |\n| Doubly Linked List | To store the key-value pairs. |\n| Hash Map           | To store the key-node pairs.  |\n\"\"\"\n\nfrom collections import OrderedDict\n\n\n# Doubly Linked List\nclass Node:\n    def __init__(self, key=0, val=0):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.cache = {}\n        self.head = Node()\n        self.tail = Node()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def add_to_last(self, node):\n        self.tail.prev.next = node\n        node.prev = self.tail.prev\n        node.next = self.tail\n        self.tail.prev = node\n\n    def move_to_last(self, node):\n        self.remove(node)\n        self.add_to_last(node)\n\n    def get(self, key: int) -&gt; int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self.move_to_last(node)\n        return node.val\n\n    def put(self, key: int, value: int) -&gt; None:\n        if key in self.cache:\n            node = self.cache[key]\n            node.val = value\n            self.move_to_last(node)\n            return None\n\n        if len(self.cache) == self.cap:\n            del self.cache[self.head.next.key]\n            self.remove(self.head.next)\n\n        node = Node(key=key, val=value)\n        self.cache[key] = node\n        self.add_to_last(node)\n\n\n# OrderedDict\nclass LRUCacheOrderedDict:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.cap = capacity\n\n    def get(self, key: int):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key, last=True)\n        return self.cache[key]\n\n    def put(self, key: int, value: int):\n        if key in self.cache:\n            self.cache.move_to_end(key, last=True)\n        elif len(self.cache) &gt;= self.cap:\n            self.cache.popitem(last=False)\n\n        self.cache[key] = value\n\n\ncache = LRUCache(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\n\ncache = LRUCacheOrderedDict(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\nprint(\"LRU Cache passed\")\nprint(\"LRU Cache Ordered Dict passed\")\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nclass Node {\n   public:\n    int key;\n    int val;\n    Node *prev;\n    Node *next;\n\n    Node(int k = 0, int v = 0) : key(k), val(v), prev(nullptr), next(nullptr) {}\n};\n\nclass LRUCache {\n   private:\n    int cap;\n    unordered_map&lt;int, Node *&gt; cache;\n    Node *head;\n    Node *tail;\n\n    void remove(Node *node) {\n        node-&gt;prev-&gt;next = node-&gt;next;\n        node-&gt;next-&gt;prev = node-&gt;prev;\n    }\n\n    void insert_to_last(Node *node) {\n        tail-&gt;prev-&gt;next = node;\n        node-&gt;prev = tail-&gt;prev;\n        tail-&gt;prev = node;\n        node-&gt;next = tail;\n    }\n\n    void move_to_last(Node *node) {\n        remove(node);\n        insert_to_last(node);\n    }\n\n   public:\n    LRUCache(int capacity) {\n        this-&gt;cap = capacity;\n        head = new Node();\n        tail = new Node();\n        head-&gt;next = tail;\n        tail-&gt;prev = head;\n    }\n\n    int get(int key) {\n        if (cache.find(key) != cache.end()) {\n            Node *node = cache[key];\n            move_to_last(node);\n            return node-&gt;val;\n        }\n        return -1;\n    }\n\n    void put(int key, int value) {\n        if (cache.find(key) != cache.end()) {\n            Node *node = cache[key];\n            node-&gt;val = value;\n            move_to_last(node);\n        } else {\n            Node *newNode = new Node(key, value);\n            cache[key] = newNode;\n            insert_to_last(newNode);\n\n            if ((int)cache.size() &gt; cap) {\n                Node *removed = head-&gt;next;\n                remove(removed);\n                cache.erase(removed-&gt;key);\n                delete removed;\n            }\n        }\n    }\n};\n\nint main() {\n    LRUCache lru(2);\n    lru.put(1, 1);\n    lru.put(2, 2);\n    assert(lru.get(1) == 1);   // returns 1\n    lru.put(3, 3);             // evicts key 2\n    assert(lru.get(2) == -1);  // returns -1 (not found)\n    lru.put(4, 4);             // evicts key 1\n    assert(lru.get(1) == -1);  // returns -1 (not found)\n    assert(lru.get(3) == 3);   // returns 3\n    assert(lru.get(4) == 4);   // returns 4\n    return 0;\n}\n</code></pre>"},{"location":"Company/bloomberg/#14-longest-common-prefix","title":"14. Longest Common Prefix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Trie</p> </li> </ul> Python <pre><code>from typing import List\n\n\nclass longestCommonPrefix:\n    def horizontal_scan(self, strs: List[str]) -&gt; str:\n        if not strs:\n            return \"\"\n\n        prefix = strs[0]\n        for i in range(1, len(strs)):\n            while not strs[i].startswith(prefix):\n                prefix = prefix[:-1]\n                if not prefix:\n                    return \"\"\n\n        return prefix\n\n    def vertical_scan(self, strs: List[str]) -&gt; str:\n        if not strs:\n            return \"\"\n\n        for i in range(len(strs[0])):\n            char = strs[0][i]\n            for j in range(1, len(strs)):\n                if i &gt;= len(strs[j]) or strs[j][i] != char:\n                    return strs[0][:i]\n\n        return strs[0]\n\n    def divide_conquer(self, strs: List[str]) -&gt; str:\n        if not strs:\n            return \"\"\n\n        def merge(left, right):\n            n = min(len(left), len(right))\n            for i in range(n):\n                if left[i] != right[i]:\n                    return left[:i]\n            return left[:n]\n\n        def find(strs, start, end):\n            if start == end:\n                return strs[start]\n            mid = start + (end - start) // 2\n            left = find(strs, start, mid)\n            right = find(strs, mid + 1, end)\n            return merge(left, right)\n\n        return find(strs, 0, len(strs) - 1)\n\n    def binary_search(self, strs: List[str]) -&gt; str:\n        if not strs:\n            return \"\"\n\n        def isCommonPrefix(strs, length):\n            prefix = strs[0][:length]\n            return all(s.startswith(prefix) for s in strs)\n\n        minLen = min(len(s) for s in strs)\n        low, high = 0, minLen\n        while low &lt; high:\n            mid = low + (high - low) // 2\n            if isCommonPrefix(strs, mid + 1):\n                low = mid + 1\n            else:\n                high = mid\n\n        return strs[0][:low]\n\n\nif __name__ == \"__main__\":\n    solution = longestCommonPrefix()\n    strs = [\"flower\", \"flow\", \"flight\"]\n    assert solution.horizontal_scan(strs) == \"fl\"\n    assert solution.vertical_scan(strs) == \"fl\"\n    assert solution.divide_conquer(strs) == \"fl\"\n    assert solution.binary_search(strs) == \"fl\"\n</code></pre>"},{"location":"Company/bloomberg/#128-longest-consecutive-sequence","title":"128. Longest Consecutive Sequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Union Find</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Set\ndef longestConsecutiveSet(nums: List[int]) -&gt; int:\n    num_set = set(nums)  # O(n)\n    longest = 0\n\n    for n in nums:\n        if (n - 1) not in num_set:  # left boundary\n            length = 1\n\n            while (n + length) in num_set:\n                length += 1\n\n            longest = max(longest, length)\n\n    return longest\n\n\n# Union Find\ndef longestConsecutiveUF(nums: List[int]) -&gt; int:\n    if not nums:\n        return 0\n\n    par = {num: num for num in nums}\n    rank = {num: 1 for num in nums}\n\n    def find(num):\n        p = par[num]\n        while p != par[p]:\n            p = par[p]\n        return p\n\n    def union(num1, num2):\n        p1, p2 = find(num1), find(num2)\n        if p1 == p2:\n            return\n\n        if rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n            rank[p2] += rank[p1]\n        else:\n            par[p2] = p1\n            rank[p1] += rank[p2]\n\n    for num in nums:\n        if num - 1 in par:\n            union(num, num - 1)\n\n    return max(rank.values())\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |  Set       |  O(N)  |  O(N)   |\n# | Union Find |  O(N)  |  O(N)   |\n# |------------|--------|---------|\n\n\nnums = [100, 4, 200, 1, 3, 2]\nprint(longestConsecutiveSet(nums))  # 4\nprint(longestConsecutiveUF(nums))  # 4\n</code></pre>"},{"location":"Company/bloomberg/#34-find-first-and-last-position-of-element-in-sorted-array","title":"34. Find First and Last Position of Element in Sorted Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> PythonCPP <pre><code>from bisect import bisect_left\nfrom typing import List\n\n\nclass searchRange:\n    \"\"\"\n    \u627e lower bound \u548c upper bound\n    \u770b\u7075\u795e\u5bf9\u8fd9\u9053\u9898\u7684\u9898\u89e3\uff0c\u5206\u7c7b\u8ba8\u8bba\u533a\u95f4\u7684\u5199\u6cd5\n    target \u7684 upper bound \u662f target + 1 \u7684 lower bound - 1\n    \u8fd9\u6837\u5c31\u80fd\u7edf\u4e00\u7528 lower bound \u7684\u5199\u6cd5\n    \"\"\"\n\n    # [left, right]\n    def bisect_left_closed(self, nums, target):\n        \"\"\"\n        \u95ed\u533a\u95f4\u5199\u6cd5\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left &lt;= right:\n            mid = left + (right - left) // 2\n            if nums[mid] &lt; target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n\n    # [left, right)\n    def bisect_left_right_open(self, nums, target):\n        \"\"\"\n        \u5de6\u95ed\u53f3\u5f00\u533a\u95f4\u5199\u6cd5\n        \"\"\"\n        left, right = 0, len(nums)\n        while left &lt; right:\n            mid = left + (right - left) // 2\n            if nums[mid] &gt;= target:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\n    # (left, right)\n    def bisect_left_open(self, nums, target):\n        \"\"\"\n        \u63a8\u8350\u5f00\u533a\u95f4\u5199\u6cd5\n        \"\"\"\n        left, right = -1, len(nums)\n        while left + 1 &lt; right:\n            mid = left + (right - left) // 2\n            if nums[mid] &lt; target:\n                left = mid\n            else:\n                right = mid\n        return right\n\n    def search_range(self, nums: List[int], target: int) -&gt; List[int]:\n        # edge case\n        if not nums:\n            return [-1, -1]\n\n        lower = self.bisect_left_closed(nums, target)\n        upper = self.bisect_left_closed(nums, target + 1) - 1\n\n        return [lower, upper] if lower &lt;= upper else [-1, -1]\n\n    def search_range_bisect(self, nums: List[int], target: int) -&gt; List[int]:\n        \"\"\"\u7528 python bisect \u5e93\u51fd\u6570\"\"\"\n        # edge case\n        if not nums:\n            return [-1, -1]\n\n        lower = bisect_left(nums, target)\n        upper = bisect_left(nums, target + 1) - 1\n\n        return [lower, upper] if lower &lt;= upper else [-1, -1]\n\n\nif __name__ == \"__main__\":\n    nums = [5, 7, 7, 8, 8, 10]\n    target = 8\n    sol = searchRange()\n    assert sol.search_range(nums, target) == [3, 4]\n    assert sol.search_range_bisect(nums, target) == [3, 4]\n</code></pre> <pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\n  int bisect_left(vector&lt;int&gt; &amp;nums, int target)\n  {\n    int left = 0, right = (int)nums.size() - 1;\n\n    while (left &lt;= right)\n    {\n      int mid = left + (right - left) / 2;\n      if (nums[mid] &lt; target)\n      {\n        left = mid + 1;\n      }\n      else\n      {\n        right = mid - 1;\n      }\n    }\n    return left;\n  }\n\npublic:\n  vector&lt;int&gt; searchRange(vector&lt;int&gt; &amp;nums, int target)\n  {\n    int left = bisect_left(nums, target);\n    if (left == (int)nums.size() || nums[left] != target)\n    {\n      return {-1, -1};\n    }\n    int right = bisect_left(nums, target + 1) - 1;\n    return {left, right};\n  }\n};\n\nint main()\n{\n  vector&lt;int&gt; nums = {5, 7, 7, 8, 8, 10};\n  int target = 8;\n  Solution s;\n  vector&lt;int&gt; res = s.searchRange(nums, target);\n  cout &lt;&lt; res[0] &lt;&lt; \", \" &lt;&lt; res[1] &lt;&lt; endl;\n  return 0;\n}\n</code></pre>"},{"location":"Company/bloomberg/#217-contains-duplicate","title":"217. Contains Duplicate","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Sorting</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return True if the array contains any duplicates, otherwise return False.\n\"\"\"\n\nfrom typing import List\n\n\n# Brute Force\ndef containsDuplicateBF(nums: List[int]) -&gt; bool:\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] == nums[j]:\n                return True\n\n    return False\n\n\n# Sort\ndef containsDuplicateSort(nums: List[int]) -&gt; bool:\n    nums.sort()\n\n    for i in range(1, len(nums)):\n        if nums[i] == nums[i - 1]:\n            return True\n\n    return False\n\n\n# Set\ndef containsDuplicateSet(nums: List[int]) -&gt; bool:\n    seen = set()\n\n    for i in nums:\n        if i in seen:\n            return True\n        seen.add(i)\n\n    return False\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# | Brute Force |    O(n^2)       |    O(1)      |\n# |     Sort    |    O(n log n)   |    O(1)      |\n# |     Set     |    O(n)         |    O(n)      |\n# |-------------|-----------------|--------------|\n\nprint(containsDuplicateBF([1, 2, 3, 1]))  # True\nprint(containsDuplicateSort([1, 2, 3, 1]))  # True\nprint(containsDuplicateSet([1, 2, 3, 1]))  # True\n</code></pre>"},{"location":"Company/bloomberg/#22-generate-parentheses","title":"22. Generate Parentheses","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Backtracking</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Backtracking\ndef generateParenthesis1(n: int) -&gt; List[str]:\n    path, res = [], []\n\n    def dfs(openN, closeN):\n        if openN == closeN == n:\n            res.append(\"\".join(path))\n            return\n\n        if openN &lt; n:\n            path.append(\"(\")\n            dfs(openN + 1, closeN)\n            path.pop()\n\n        if closeN &lt; openN:\n            path.append(\")\")\n            dfs(openN, closeN + 1)\n            path.pop()\n\n    dfs(0, 0)\n\n    return res\n\n\n# Backtracking\ndef generateParenthesis2(n: int) -&gt; List[str]:\n    m = n * 2\n    res, path = [], [\"\"] * m\n\n    def dfs(i, left):\n        if i == m:\n            res.append(\"\".join(path))\n            return\n\n        if left &lt; n:\n            path[i] = \"(\"\n            dfs(i + 1, left + 1)\n        if i - left &lt; left:\n            path[i] = \")\"\n            dfs(i + 1, left)\n\n    dfs(0, 0)\n    return res\n\n\nif __name__ == \"__main__\":\n    print(generateParenthesis1(3))\n    # ['((()))', '(()())', '(())()', '()(())', '()()()']\n    print(generateParenthesis2(3))\n    # ['((()))', '(()())', '(())()', '()(())', '()()()']\n</code></pre>"},{"location":"Company/bloomberg/#560-subarray-sum-equals-k","title":"560. Subarray Sum Equals K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Prefix Sum</p> </li> </ul> PythonCPP <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Prefix Sum\ndef subarraySum(nums: List[int], k: int) -&gt; int:\n    preSums = defaultdict(int)\n    preSums[0] = 1\n    curSum = 0\n    res = 0\n\n    for num in nums:\n        curSum += num\n        res += preSums[curSum - k]\n        preSums[curSum] += 1\n\n    return res\n\n\nnums = [1, 1, 1]\nk = 2\nprint(subarraySum(nums, k))  # 2\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint subarraySum(vector&lt;int&gt;&amp; nums, int k) {\n    int n = nums.size();\n    vector&lt;int&gt; prefixSum(n + 1);\n    for (int i = 0; i &lt; n; i++) {\n        prefixSum[i + 1] = prefixSum[i] + nums[i];\n    }\n\n    int res = 0;\n    unordered_map&lt;int, int&gt; cnt;\n\n    for (int ps : prefixSum) {\n        if (cnt.find(ps - k) != cnt.end()) res += cnt[ps - k];\n        cnt[ps]++;\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {1, 1, 1};\n    int k = 2;\n    cout &lt;&lt; subarraySum(nums, k) &lt;&lt; endl;  // 2\n    return 0;\n}\n</code></pre>"},{"location":"Company/bloomberg/#21-merge-two-sorted-lists","title":"21. Merge Two Sorted Lists","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Recursion</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Task: Merge the two linked lists into one sorted list.\n\"\"\"\n\nfrom typing import Optional\n\nfrom leetpattern.utils import ListNode\n\n\n# Linked List\ndef merge_two_lists(\n    list1: Optional[ListNode], list2: Optional[ListNode]\n) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    while list1 and list2:\n        if list1.val &lt; list2.val:\n            cur.next = list1\n            list1 = list1.next\n        else:\n            cur.next = list2\n            list2 = list2.next\n        cur = cur.next\n\n    if list1:\n        cur.next = list1\n    elif list2:\n        cur.next = list2\n\n    return dummy.next\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode* next) : val(x), next(next) {}\n};\n\nclass Solution {\n   public:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        ListNode dummy;\n        ListNode* cur = &amp;dummy;\n\n        while (list1 &amp;&amp; list2) {\n            if (list1-&gt;val &lt; list2-&gt;val) {\n                cur-&gt;next = list1;\n                list1 = list1-&gt;next;\n            } else {\n                cur-&gt;next = list2;\n                list2 = list2-&gt;next;\n            }\n            cur = cur-&gt;next;\n        }\n\n        cur-&gt;next = list1 ? list1 : list2;\n\n        return dummy.next;\n    }\n};\n\nint main() {\n    Solution sol;\n    ListNode* list1 = new ListNode(1, new ListNode(2, new ListNode(4)));\n    ListNode* list2 = new ListNode(1, new ListNode(3, new ListNode(4)));\n    ListNode* merged = sol.mergeTwoLists(list1, list2);\n    vector&lt;int&gt; res;\n    while (merged) {\n        res.push_back(merged-&gt;val);\n        merged = merged-&gt;next;\n    }\n    assert(res == std::vector&lt;int&gt;({1, 1, 2, 3, 4, 4}));\n    return 0;\n}\n</code></pre>"},{"location":"Company/bloomberg/#2667-create-hello-world-function","title":"2667. Create Hello World Function","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: None</p> </li> </ul>"},{"location":"Company/bloomberg/#13-roman-to-integer","title":"13. Roman to Integer","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Math, String</p> </li> </ul> Python <pre><code>from itertools import pairwise\n\n\n# Arrays\ndef romanToInt(s: str) -&gt; int:\n    ROMAN = {\n        \"I\": 1,\n        \"V\": 5,\n        \"X\": 10,\n        \"L\": 50,\n        \"C\": 100,\n        \"D\": 500,\n        \"M\": 1000,\n    }\n\n    res = 0\n\n    for x, y in pairwise(s):\n        x, y = ROMAN[x], ROMAN[y]\n        res += x if x &gt;= y else -x\n\n    return res + ROMAN[s[-1]]\n\n\nif __name__ == \"__main__\":\n    assert romanToInt(\"III\") == 3\n    assert romanToInt(\"IV\") == 4\n    assert romanToInt(\"IX\") == 9\n    assert romanToInt(\"LVIII\") == 58\n    assert romanToInt(\"MCMXCIV\") == 1994\n    assert romanToInt(\"MMXXIII\") == 2023\n</code></pre>"},{"location":"Company/bloomberg/#53-maximum-subarray","title":"53. Maximum Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Divide And Conquer, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP Kadane\ndef maxSubArrayDP(nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n\n    dp[0] = nums[0]\n    maxSum = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(\n            dp[i - 1] + nums[i],  # continue the previous subarray\n            nums[i],  # start a new subarray\n        )\n        maxSum = max(maxSum, dp[i])\n\n    return maxSum\n\n\n# Greedy\ndef maxSubArrayGreedy(nums: List[int]) -&gt; int:\n    max_sum = nums[0]\n    cur_sum = 0\n\n    for num in nums:\n        cur_sum = max(cur_sum + num, num)\n        max_sum = max(max_sum, cur_sum)\n\n    return max_sum\n\n\n# Prefix Sum\ndef maxSubArrayPrefixSum(nums: List[int]) -&gt; int:\n    prefix_sum = 0\n    prefix_sum_min = 0\n    res = float(\"-inf\")\n\n    for num in nums:\n        prefix_sum += num\n        res = max(res, prefix_sum - prefix_sum_min)\n        prefix_sum_min = min(prefix_sum_min, prefix_sum)\n\n    return res\n\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArrayDP(nums))  # 6\nprint(maxSubArrayGreedy(nums))  # 6\nprint(maxSubArrayPrefixSum(nums))  # 6\n</code></pre>"},{"location":"Company/bloomberg/#1244-design-a-leaderboard","title":"1244. Design A Leaderboard \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Design, Sorting</p> </li> </ul> Python <pre><code>class Leaderboard:\n\n    def __init__(self):\n        self.scores = {}\n\n    def addScore(self, playerId: int, score: int) -&gt; None:\n        if playerId in self.scores:\n            self.scores[playerId] += score\n        else:\n            self.scores[playerId] = score\n\n    def top(self, K: int) -&gt; int:\n        topK = sorted(self.scores.values(), reverse=True)[:K]\n        return sum(topK)\n\n    def reset(self, playerId: int) -&gt; None:\n        if playerId in self.scores:\n            self.scores[playerId] = 0\n\n\nboard = Leaderboard()\nboard.addScore(1, 73)\nboard.addScore(2, 56)\nboard.addScore(3, 39)\nboard.addScore(4, 51)\nprint(board.top(1))  # 73\nboard.reset(1)\nboard.reset(2)\nprint(board.top(2))  # 90\n</code></pre>"},{"location":"Company/bytedance/","title":"ByteDance","text":""},{"location":"Company/bytedance/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 146. LRU Cache (Medium)</li> <li> 2. Add Two Numbers (Medium)</li> <li> 317. Shortest Distance from All Buildings (Hard) \ud83d\udc51</li> <li> 347. Top K Frequent Elements (Medium)</li> <li> 39. Combination Sum (Medium)</li> <li> 424. Longest Repeating Character Replacement (Medium)</li> <li> 560. Subarray Sum Equals K (Medium)</li> <li> 10. Regular Expression Matching (Hard)</li> <li> 224. Basic Calculator (Hard)</li> <li> 56. Merge Intervals (Medium)</li> <li> 1171. Remove Zero Sum Consecutive Nodes from Linked List (Medium)</li> </ul>"},{"location":"Company/bytedance/#146-lru-cache","title":"146. LRU Cache","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Linked List, Design, Doubly Linked List</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Design and implement a data structure for **Least Recently Used (LRU) cache**. It should support the following operations: get and put.\n- [lru](https://media.geeksforgeeks.org/wp-content/uploads/20240909142802/Working-of-LRU-Cache-copy-2.webp)\n- ![146](https://miro.medium.com/v2/resize:fit:650/0*fOwBd3z0XtHh7WN1.png)\n\n| Data structure     | Description                   |\n| ------------------ | ----------------------------- |\n| Doubly Linked List | To store the key-value pairs. |\n| Hash Map           | To store the key-node pairs.  |\n\"\"\"\n\nfrom collections import OrderedDict\n\n\n# Doubly Linked List\nclass Node:\n    def __init__(self, key=0, val=0):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.cache = {}\n        self.head = Node()\n        self.tail = Node()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def add_to_last(self, node):\n        self.tail.prev.next = node\n        node.prev = self.tail.prev\n        node.next = self.tail\n        self.tail.prev = node\n\n    def move_to_last(self, node):\n        self.remove(node)\n        self.add_to_last(node)\n\n    def get(self, key: int) -&gt; int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self.move_to_last(node)\n        return node.val\n\n    def put(self, key: int, value: int) -&gt; None:\n        if key in self.cache:\n            node = self.cache[key]\n            node.val = value\n            self.move_to_last(node)\n            return None\n\n        if len(self.cache) == self.cap:\n            del self.cache[self.head.next.key]\n            self.remove(self.head.next)\n\n        node = Node(key=key, val=value)\n        self.cache[key] = node\n        self.add_to_last(node)\n\n\n# OrderedDict\nclass LRUCacheOrderedDict:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.cap = capacity\n\n    def get(self, key: int):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key, last=True)\n        return self.cache[key]\n\n    def put(self, key: int, value: int):\n        if key in self.cache:\n            self.cache.move_to_end(key, last=True)\n        elif len(self.cache) &gt;= self.cap:\n            self.cache.popitem(last=False)\n\n        self.cache[key] = value\n\n\ncache = LRUCache(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\n\ncache = LRUCacheOrderedDict(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\nprint(\"LRU Cache passed\")\nprint(\"LRU Cache Ordered Dict passed\")\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nclass Node {\n   public:\n    int key;\n    int val;\n    Node *prev;\n    Node *next;\n\n    Node(int k = 0, int v = 0) : key(k), val(v), prev(nullptr), next(nullptr) {}\n};\n\nclass LRUCache {\n   private:\n    int cap;\n    unordered_map&lt;int, Node *&gt; cache;\n    Node *head;\n    Node *tail;\n\n    void remove(Node *node) {\n        node-&gt;prev-&gt;next = node-&gt;next;\n        node-&gt;next-&gt;prev = node-&gt;prev;\n    }\n\n    void insert_to_last(Node *node) {\n        tail-&gt;prev-&gt;next = node;\n        node-&gt;prev = tail-&gt;prev;\n        tail-&gt;prev = node;\n        node-&gt;next = tail;\n    }\n\n    void move_to_last(Node *node) {\n        remove(node);\n        insert_to_last(node);\n    }\n\n   public:\n    LRUCache(int capacity) {\n        this-&gt;cap = capacity;\n        head = new Node();\n        tail = new Node();\n        head-&gt;next = tail;\n        tail-&gt;prev = head;\n    }\n\n    int get(int key) {\n        if (cache.find(key) != cache.end()) {\n            Node *node = cache[key];\n            move_to_last(node);\n            return node-&gt;val;\n        }\n        return -1;\n    }\n\n    void put(int key, int value) {\n        if (cache.find(key) != cache.end()) {\n            Node *node = cache[key];\n            node-&gt;val = value;\n            move_to_last(node);\n        } else {\n            Node *newNode = new Node(key, value);\n            cache[key] = newNode;\n            insert_to_last(newNode);\n\n            if ((int)cache.size() &gt; cap) {\n                Node *removed = head-&gt;next;\n                remove(removed);\n                cache.erase(removed-&gt;key);\n                delete removed;\n            }\n        }\n    }\n};\n\nint main() {\n    LRUCache lru(2);\n    lru.put(1, 1);\n    lru.put(2, 2);\n    assert(lru.get(1) == 1);   // returns 1\n    lru.put(3, 3);             // evicts key 2\n    assert(lru.get(2) == -1);  // returns -1 (not found)\n    lru.put(4, 4);             // evicts key 1\n    assert(lru.get(1) == -1);  // returns -1 (not found)\n    assert(lru.get(3) == 3);   // returns 3\n    assert(lru.get(4) == 4);   // returns 4\n    return 0;\n}\n</code></pre>"},{"location":"Company/bytedance/#2-add-two-numbers","title":"2. Add Two Numbers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Math, Recursion</p> </li> </ul> PythonCPP <pre><code>from typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\ndef add_two_numbers(l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]:\n    \"\"\"Add two numbers represented by linked lists.\"\"\"\n    dummy = ListNode()\n    cur = dummy\n    carry = 0\n\n    while l1 or l2:\n        v1 = l1.val if l1 else 0\n        v2 = l2.val if l2 else 0\n\n        carry, val = divmod(v1 + v2 + carry, 10)\n        cur.next = ListNode(val)\n        cur = cur.next\n\n        if l1:\n            l1 = l1.next\n        if l2:\n            l2 = l2.next\n\n    if carry:\n        cur.next = ListNode(val=carry)\n\n    return dummy.next\n\n\ndef test_add_two_numbers():\n    l1 = LinkedList([2, 4, 3]).head\n    l2 = LinkedList([5, 6, 4]).head\n    added = add_two_numbers(l1, l2)\n    assert LinkedList(added).to_array() == [7, 0, 8]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode* next) : val(x), next(next) {}\n};\n\nclass Solution {\n   public:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode dummy;\n        ListNode* cur = &amp;dummy;\n        int carry = 0;\n\n        while (l1 || l2 || carry) {\n            if (l1) {\n                carry += l1-&gt;val;\n                l1 = l1-&gt;next;\n            }\n            if (l2) {\n                carry += l2-&gt;val;\n                l2 = l2-&gt;next;\n            }\n            cur-&gt;next = new ListNode(carry % 10);\n            cur = cur-&gt;next;\n            carry /= 10;\n        }\n        return dummy.next;\n    }\n};\n\nint main() {\n    Solution sol;\n\n    ListNode* l1 = new ListNode(2, new ListNode(4, new ListNode(3)));\n    ListNode* l2 = new ListNode(5, new ListNode(6, new ListNode(4)));\n    ListNode* result = sol.addTwoNumbers(l1, l2);\n\n    vector&lt;int&gt; expected = {7, 0, 8};\n    for (int val : expected) {\n        assert(result != nullptr &amp;&amp; result-&gt;val == val);\n        result = result-&gt;next;\n    }\n    assert(result == nullptr);  // End of list\n\n    return 0;\n}\n</code></pre>"},{"location":"Company/bytedance/#317-shortest-distance-from-all-buildings","title":"317. Shortest Distance from All Buildings \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Breadth First Search, Matrix</p> </li> </ul>"},{"location":"Company/bytedance/#347-top-k-frequent-elements","title":"347. Top K Frequent Elements","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Divide And Conquer, Sorting, Heap Priority Queue, Bucket Sort, Counting, Quickselect</p> </li> </ul> Python <pre><code>import heapq\nfrom collections import Counter\nfrom typing import List\n\n\n# Heap + Counter\ndef topKFrequent(nums: List[int], k: int) -&gt; List[int]:\n    minHeap = []\n\n    for val, freq in Counter(nums).items():\n        if len(minHeap) &lt; k:\n            heapq.heappush(minHeap, (freq, val))\n        else:\n            heapq.heappushpop(minHeap, (freq, val))\n\n    return [i for _, i in minHeap]\n\n\n# Counter (Most Common)\ndef topKFrequentCounter(nums: List[int], k: int) -&gt; List[int]:\n    commons = Counter(nums).most_common(k)\n    return [i for i, _ in commons]\n\n\nnums = [1, 1, 1, 2, 2, 3]\nk = 2\nprint(topKFrequent(nums, k))  # [1, 2]\nprint(topKFrequentCounter(nums, k))  # [1, 2]\n</code></pre>"},{"location":"Company/bytedance/#39-combination-sum","title":"39. Combination Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef combinationSum(candidates: List[int], target: int) -&gt; List[List[int]]:\n    n = len(candidates)\n    res, path = [], []\n\n    def dfs(total, start):\n        if total &gt; target:\n            return\n        if total == target:\n            res.append(path.copy())\n            return\n\n        for i in range(start, n):\n            total += candidates[i]\n            path.append(candidates[i])\n            dfs(total, i)\n            total -= candidates[i]\n            path.pop()\n\n    dfs(0, 0)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(combinationSum([2, 3, 5], 8))\n    # [[2, 2, 2, 2], [2, 3, 3], [3, 5]]\n    print(combinationSum([2, 3, 6, 7], 7))\n    # [[2, 2, 3], [7]]\n</code></pre>"},{"location":"Company/bytedance/#424-longest-repeating-character-replacement","title":"424. Longest Repeating Character Replacement","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> Python <pre><code>from collections import defaultdict\n\n\n# Sliding Window - Variable\ndef characterReplacement(s: str, k: int) -&gt; int:\n    left = 0\n    maxCount = 0\n    counts = defaultdict(int)\n    maxLen = 0\n\n    for right in range(len(s)):\n        counts[s[right]] += 1\n        maxCount = max(maxCount, counts[s[right]])\n\n        while right - left + 1 - maxCount &gt; k:\n            counts[s[left]] -= 1\n            left += 1\n\n        maxLen = max(maxLen, right - left + 1)\n\n    return maxLen\n\n\ns = \"ABAB\"\nk = 2\nprint(characterReplacement(s, k))  # 4\n</code></pre>"},{"location":"Company/bytedance/#560-subarray-sum-equals-k","title":"560. Subarray Sum Equals K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Prefix Sum</p> </li> </ul> PythonCPP <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Prefix Sum\ndef subarraySum(nums: List[int], k: int) -&gt; int:\n    preSums = defaultdict(int)\n    preSums[0] = 1\n    curSum = 0\n    res = 0\n\n    for num in nums:\n        curSum += num\n        res += preSums[curSum - k]\n        preSums[curSum] += 1\n\n    return res\n\n\nnums = [1, 1, 1]\nk = 2\nprint(subarraySum(nums, k))  # 2\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint subarraySum(vector&lt;int&gt;&amp; nums, int k) {\n    int n = nums.size();\n    vector&lt;int&gt; prefixSum(n + 1);\n    for (int i = 0; i &lt; n; i++) {\n        prefixSum[i + 1] = prefixSum[i] + nums[i];\n    }\n\n    int res = 0;\n    unordered_map&lt;int, int&gt; cnt;\n\n    for (int ps : prefixSum) {\n        if (cnt.find(ps - k) != cnt.end()) res += cnt[ps - k];\n        cnt[ps]++;\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {1, 1, 1};\n    int k = 2;\n    cout &lt;&lt; subarraySum(nums, k) &lt;&lt; endl;  // 2\n    return 0;\n}\n</code></pre>"},{"location":"Company/bytedance/#10-regular-expression-matching","title":"10. Regular Expression Matching","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Recursion</p> </li> </ul>"},{"location":"Company/bytedance/#224-basic-calculator","title":"224. Basic Calculator","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String, Stack, Recursion</p> </li> </ul> Python <pre><code># Stack\ndef calculate(s: str) -&gt; int:\n    stack = []\n    result = 0\n    number = 0\n    sign = 1\n\n    for char in s:\n        if char.isdigit():\n            number = number * 10 + int(char)\n\n        elif char == \"+\":\n            result += sign * number\n            number = 0\n            sign = 1\n        elif char == \"-\":\n            result += sign * number\n            number = 0\n            sign = -1\n\n        elif char == \"(\":\n            stack.append(result)\n            stack.append(sign)\n            result = 0\n            sign = 1\n        elif char == \")\":\n            result += sign * number\n            number = 0\n            result *= stack.pop()  # pop sign\n            result += stack.pop()  # pop previous result\n\n    result += sign * number\n\n    return result\n\n\nprint(calculate(\"(1+(4+5+2)-3)+(6+8)\"))  # 23\n</code></pre>"},{"location":"Company/bytedance/#56-merge-intervals","title":"56. Merge Intervals","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sorting</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Merge all overlapping intervals.\n\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/44H3cEC2fFM?si=J-Jr_Fg2eDse3-de\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen&gt;&lt;/iframe&gt;\n\"\"\"\n\nfrom typing import List\n\n\n# Intervals\ndef merge(intervals: List[List[int]]) -&gt; List[List[int]]:\n    n = len(intervals)\n    if n &lt;= 1:\n        return intervals\n\n    intervals.sort(key=lambda x: x[0])\n    res = [intervals[0]]\n\n    for i in range(1, n):\n        if intervals[i][0] &lt;= res[-1][1]:\n            res[-1][1] = max(res[-1][1], intervals[i][1])\n        else:\n            res.append(intervals[i])\n\n    return res\n\n\nprint(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))\n# [[1, 6], [8, 10], [15, 18]]\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// Interval\nvector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {\n    sort(intervals.begin(), intervals.end());\n    vector&lt;vector&lt;int&gt;&gt; res;\n\n    for (auto&amp; range : intervals) {\n        if (!res.empty() &amp;&amp; range[0] &lt;= res.back()[1]) {\n            res.back()[1] = max(res.back()[1], range[1]);\n        } else {\n            res.emplace_back(range);\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;vector&lt;int&gt;&gt; intervals = {{1, 3}, {2, 6}, {8, 10}, {15, 18}};\n    vector&lt;vector&lt;int&gt;&gt; res = merge(intervals);\n    for (auto&amp; range : res) {\n        cout &lt;&lt; range[0] &lt;&lt; \", \" &lt;&lt; range[1] &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Company/bytedance/#1171-remove-zero-sum-consecutive-nodes-from-linked-list","title":"1171. Remove Zero Sum Consecutive Nodes from Linked List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Linked List</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom leetpattern.utils import ListNode\n\n\n# Prefix Sum\ndef removeZeroSumSublists(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    dummy = ListNode(0)\n    dummy.next = head\n    cur = head\n    prefix_sum = 0\n    seen = {0: dummy}\n\n    while cur:\n        prefix_sum += cur.val\n        if prefix_sum in seen:\n            node = seen[prefix_sum].next\n            temp_sum = prefix_sum\n            while node != cur:\n                temp_sum += node.val\n                del seen[temp_sum]\n                node = node.next\n            seen[prefix_sum].next = cur.next\n        else:\n            seen[prefix_sum] = cur\n        cur = cur.next\n\n    return dummy.next\n\n\nhead = ListNode().create([1, 2, -3, 3, 1])\nprint(removeZeroSumSublists(head))  # 3 -&gt; 1\n</code></pre>"},{"location":"Company/databricks/","title":"Databricks","text":""},{"location":"Company/databricks/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 362. Design Hit Counter (Medium) \ud83d\udc51</li> <li> 751. IP to CIDR (Medium) \ud83d\udc51</li> <li> 348. Design Tic-Tac-Toe (Medium) \ud83d\udc51</li> <li> 213. House Robber II (Medium)</li> <li> 198. House Robber (Medium)</li> <li> 1146. Snapshot Array (Medium)</li> <li> 2096. Step-By-Step Directions From a Binary Tree Node to Another (Medium)</li> <li> 933. Number of Recent Calls (Easy)</li> </ul>"},{"location":"Company/databricks/#362-design-hit-counter","title":"362. Design Hit Counter \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Design, Queue, Data Stream</p> </li> </ul> Python <pre><code>from collections import deque\n\n\nclass HitCounter:\n\n    def __init__(self):\n        self.hits = deque()\n\n    def hit(self, timestamp: int) -&gt; None:\n        self.hits.append(timestamp)\n\n    def getHits(self, timestamp: int) -&gt; int:\n        # Remove hits that are older than 5 minutes (300 seconds)\n        while self.hits and self.hits[0] &lt;= timestamp - 300:\n            self.hits.popleft()\n        return len(self.hits)\n\n\nobj = HitCounter()\nobj.hit(1)\nobj.hit(2)\nobj.hit(3)\nprint(obj.getHits(4))  # 3\nobj.hit(300)\nprint(obj.getHits(300))  # 4\nprint(obj.getHits(301))  # 3\n</code></pre>"},{"location":"Company/databricks/#751-ip-to-cidr","title":"751. IP to CIDR \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Bit Manipulation</p> </li> </ul>"},{"location":"Company/databricks/#348-design-tic-tac-toe","title":"348. Design Tic-Tac-Toe \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Design, Matrix, Simulation</p> </li> </ul>"},{"location":"Company/databricks/#213-house-robber-ii","title":"213. House Robber II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return the maximum amount of money that can be robbed from the houses arranged in a circle.\n-   Circular \u2192 Linear: `nums[0]` and `nums[-1]` cannot be robbed together.\n-   Rob from `0` to `n - 2`\n\n|  n  | `nums[n]` | `dp[n-2]` | `dp[n-1]` | `dp[n-2] + nums[n]` | `dp[n]` |\n| :-: | :-------: | :-------: | :-------: | :-----------------: | :-----: |\n|  0  |     2     |     -     |     2     |          -          |    2    |\n|  1  |     7     |     -     |     7     |          -          |    7    |\n|  2  |     9     |     2     |     7     |         11          |   11    |\n|  3  |     3     |     7     |    11     |         10          |   11    |\n\n-   Rob from `1` to `n - 1`\n\n|  n  | `nums[n]` | `dp[n-2]` | `dp[n-1]` | `dp[n-2] + nums[n]` | `dp[n]` |\n| :-: | :-------: | :-------: | :-------: | :-----------------: | :-----: |\n|  1  |     7     |     -     |     -     |          -          |    7    |\n|  2  |     9     |     -     |     7     |          -          |    9    |\n|  3  |     3     |     7     |     9     |         10          |   10    |\n|  4  |     1     |     9     |    10     |         10          |   10    |\n\"\"\"\n\nfrom typing import List\n\n\n# DP\ndef rob(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 3:\n        return max(nums)\n\n    def robLinear(nums: List[int]) -&gt; int:\n        dp = [0 for _ in range(len(nums))]\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n        return dp[-1]\n\n    # circle -&gt; linear\n    a = robLinear(nums[1:])  # 2nd house to the last house\n    b = robLinear(nums[:-1])  # 1st house to the 2nd last house\n\n    return max(a, b)\n\n\nnums = [2, 7, 9, 3, 1]\nprint(rob(nums))  # 11\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// DP\nint robDP(vector&lt;int&gt;&amp; nums) {\n    int n = nums.size();\n    if (n &lt;= 3) return *max_element(nums.begin(), nums.end());\n\n    vector&lt;int&gt; dp1(n, 0), dp2(n, 0);\n\n    dp1[0] = nums[0];\n    dp2[1] = max(nums[0], nums[1]);\n    for (int i = 2; i &lt; n - 1; i++) {\n        dp1[i] = max(dp1[i - 1], dp1[i - 2] + nums[i]);\n    }\n\n    dp2[1] = nums[1];\n    dp2[2] = max(nums[1], nums[2]);\n    for (int i = 3; i &lt; n; i++) {\n        dp1[i] = max(dp1[i - 1], dp1[i - 2] + nums[i]);\n    }\n\n    return max(dp1[n - 2], dp2[n - 1]);\n}\n\n// DP (Space Optimized)\nint robDPOptimized(vector&lt;int&gt;&amp; nums) {\n    int n = nums.size();\n    if (n &lt;= 3) return *max_element(nums.begin(), nums.end());\n\n    int f1 = nums[0];\n    int f2 = max(nums[0], nums[1]);\n    int res1;\n    for (int i = 2; i &lt; n - 1; i++) {\n        res1 = max(f2, f1 + nums[i]);\n        f1 = f2;\n        f2 = res1;\n    }\n\n    f1 = nums[1];\n    f2 = max(nums[1], nums[2]);\n    int res2;\n    for (int i = 3; i &lt; n; i++) {\n        res2 = max(f2, f1 + nums[i]);\n        f1 = f2;\n        f2 = res2;\n    }\n\n    return max(res1, res2);\n}\n\nint main() {\n    vector&lt;int&gt; nums = {2, 3, 2};\n    cout &lt;&lt; robDP(nums) &lt;&lt; endl;           // 3\n    cout &lt;&lt; robDPOptimized(nums) &lt;&lt; endl;  // 3\n\n    nums = {1, 2, 3, 1};\n    cout &lt;&lt; robDP(nums) &lt;&lt; endl;           // 4\n    cout &lt;&lt; robDPOptimized(nums) &lt;&lt; endl;  // 4\n\n    return 0;\n}\n</code></pre>"},{"location":"Company/databricks/#198-house-robber","title":"198. House Robber","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> PythonCPP <pre><code>from functools import cache\nfrom typing import List\n\n\nclass Rob:\n    \"\"\"\n    dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n    \"\"\"\n\n    def incursive(self, nums: List[int]) -&gt; int:\n        \"\"\"\n        time complexity: O(n)\n        space complexity: O(n)\n        \"\"\"\n        n = len(nums)\n        if n &lt;= 2:\n            return max(nums)\n\n        # init\n        dp = [0 for _ in range(n)]\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n        # update\n        for i in range(2, n):\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n        return dp[-1]\n\n    def incursive_optimized(self, nums: List[int]) -&gt; int:\n        \"\"\"\n        time complexity: O(n)\n        space complexity: O(1)\n        \"\"\"\n        f0, f1 = 0, 0\n\n        for num in nums:\n            f0, f1 = f1, max(f1, f0 + num)\n\n        return f1\n\n    def memoization(self, nums: List[int]) -&gt; int:\n        \"\"\"\n        time complexity: O(n)\n        space complexity: O(n)\n        \"\"\"\n        n = len(nums)\n\n        @cache\n        def dp(i: int) -&gt; int:\n            if i &lt; 0:\n                return 0\n            return max(dp(i - 1), dp(i - 2) + nums[i])\n\n        return dp(n - 1)\n\n\nif __name__ == \"__main__\":\n    nums = [2, 7, 9, 3, 1]\n    rob = Rob()\n    assert rob.incursive(nums) == 12\n    assert rob.incursive_optimized(nums) == 12\n    assert rob.memoization(nums) == 12\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint rob(vector&lt;int&gt; &amp;nums) {\n    int prev = 0, cur = 0, temp = 0;\n\n    for (int num : nums) {\n        temp = cur;\n        cur = max(cur, prev + num);\n        prev = temp;\n    }\n    return cur;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {2, 7, 9, 3, 1};\n    cout &lt;&lt; rob(nums) &lt;&lt; endl;  // 12\n    return 0;\n}\n</code></pre>"},{"location":"Company/databricks/#1146-snapshot-array","title":"1146. Snapshot Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Binary Search, Design</p> </li> </ul>"},{"location":"Company/databricks/#2096-step-by-step-directions-from-a-binary-tree-node-to-another","title":"2096. Step-By-Step Directions From a Binary Tree Node to Another","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Tree, Depth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\n\n\nclass GetDirections:\n    def lca(self, root: Optional[TreeNode], startValue: int, destValue: int) -&gt; str:\n        path_s, path_t = [], []\n\n        def dfs(node, target, path):\n            if not node:\n                return False\n            if node.val == target:\n                return True\n\n            path.append(\"L\")\n            if dfs(node.left, target, path):\n                return True\n            path.pop()\n\n            path.append(\"R\")\n            if dfs(node.right, target, path):\n                return True\n            path.pop()\n\n            return False\n\n        dfs(root, startValue, path_s)\n        dfs(root, destValue, path_t)\n\n        i = 0\n        while i &lt; len(path_s) and i &lt; len(path_t) and path_s[i] == path_t[i]:\n            i += 1\n\n        UP = \"U\" * (len(path_s) - i)\n        DOWN = \"\".join(path_t[i:])\n        return UP + DOWN\n</code></pre>"},{"location":"Company/databricks/#933-number-of-recent-calls","title":"933. Number of Recent Calls","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Design, Queue, Data Stream</p> </li> </ul>"},{"location":"Company/google/","title":"Google","text":""},{"location":"Company/google/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1. Two Sum (Easy)</li> <li> 2667. Create Hello World Function (Easy)</li> <li> 2. Add Two Numbers (Medium)</li> <li> 1757. Recyclable and Low Fat Products (Easy)</li> <li> 9. Palindrome Number (Easy)</li> <li> 15. 3Sum (Medium)</li> <li> 4. Median of Two Sorted Arrays (Hard)</li> <li> 14. Longest Common Prefix (Easy)</li> <li> 42. Trapping Rain Water (Hard)</li> <li> 3. Longest Substring Without Repeating Characters (Medium)</li> <li> 26. Remove Duplicates from Sorted Array (Easy)</li> <li> 20. Valid Parentheses (Easy)</li> <li> 11. Container With Most Water (Medium)</li> <li> 5. Longest Palindromic Substring (Medium)</li> <li> 13. Roman to Integer (Easy)</li> <li> 22. Generate Parentheses (Medium)</li> <li> 128. Longest Consecutive Sequence (Medium)</li> <li> 21. Merge Two Sorted Lists (Easy)</li> <li> 560. Subarray Sum Equals K (Medium)</li> <li> 27. Remove Element (Easy)</li> <li> 31. Next Permutation (Medium)</li> <li> 53. Maximum Subarray (Medium)</li> <li> 7. Reverse Integer (Medium)</li> <li> 6. Zigzag Conversion (Medium)</li> <li> 118. Pascal's Triangle (Easy)</li> <li> 394. Decode String (Medium)</li> <li> 242. Valid Anagram (Easy)</li> <li> 18. 4Sum (Medium)</li> <li> 50. Pow(x, n) (Medium)</li> <li> 54. Spiral Matrix (Medium)</li> </ul>"},{"location":"Company/google/#1-two-sum","title":"1. Two Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return the indices of the two numbers such that they add up to a specific target.\n- Approach: Use a hashmap to store the indices of the numbers.\n- Time Complexity: O(n)\n- Space Complexity: O(n)\n\"\"\"\n\nfrom typing import List\n\n\ndef two_sum(nums: List[int], target: int) -&gt; List[int]:\n    hashmap = {}  # val: idx\n\n    for idx, val in enumerate(nums):\n        if (target - val) in hashmap:\n            return [hashmap[target - val], idx]\n\n        hashmap[val] = idx\n\n    return []\n\n\ndef test_two_sum():\n    assert two_sum([2, 7, 11, 15], 9) == [0, 1]\n    assert two_sum([3, 2, 4], 6) == [1, 2]\n    assert two_sum([3, 3], 6) == [0, 1]\n    assert two_sum([1, 2, 3, 4, 5], 10) == []\n    assert two_sum([-1, -2, -3, -4, -5], -8) == [2, 4]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Solution {\n   public:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {\n        unordered_map&lt;int, int&gt; map;\n\n        for (size_t i = 0; i &lt; nums.size(); i++) {\n            int diff = target - nums[i];\n            if (map.find(diff) != map.end()) {\n                return {map[diff], (int)i};\n            }\n            map[nums[i]] = (int)i;\n        }\n        return {-1, -1};\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; nums = {2, 7, 11, 15};\n    int target = 9;\n    vector&lt;int&gt; result = solution.twoSum(nums, target);\n    assert((result == vector&lt;int&gt;{0, 1}));\n    return 0;\n}\n</code></pre>"},{"location":"Company/google/#2667-create-hello-world-function","title":"2667. Create Hello World Function","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: None</p> </li> </ul>"},{"location":"Company/google/#2-add-two-numbers","title":"2. Add Two Numbers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Math, Recursion</p> </li> </ul> PythonCPP <pre><code>from typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\ndef add_two_numbers(l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]:\n    \"\"\"Add two numbers represented by linked lists.\"\"\"\n    dummy = ListNode()\n    cur = dummy\n    carry = 0\n\n    while l1 or l2:\n        v1 = l1.val if l1 else 0\n        v2 = l2.val if l2 else 0\n\n        carry, val = divmod(v1 + v2 + carry, 10)\n        cur.next = ListNode(val)\n        cur = cur.next\n\n        if l1:\n            l1 = l1.next\n        if l2:\n            l2 = l2.next\n\n    if carry:\n        cur.next = ListNode(val=carry)\n\n    return dummy.next\n\n\ndef test_add_two_numbers():\n    l1 = LinkedList([2, 4, 3]).head\n    l2 = LinkedList([5, 6, 4]).head\n    added = add_two_numbers(l1, l2)\n    assert LinkedList(added).to_array() == [7, 0, 8]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode* next) : val(x), next(next) {}\n};\n\nclass Solution {\n   public:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode dummy;\n        ListNode* cur = &amp;dummy;\n        int carry = 0;\n\n        while (l1 || l2 || carry) {\n            if (l1) {\n                carry += l1-&gt;val;\n                l1 = l1-&gt;next;\n            }\n            if (l2) {\n                carry += l2-&gt;val;\n                l2 = l2-&gt;next;\n            }\n            cur-&gt;next = new ListNode(carry % 10);\n            cur = cur-&gt;next;\n            carry /= 10;\n        }\n        return dummy.next;\n    }\n};\n\nint main() {\n    Solution sol;\n\n    ListNode* l1 = new ListNode(2, new ListNode(4, new ListNode(3)));\n    ListNode* l2 = new ListNode(5, new ListNode(6, new ListNode(4)));\n    ListNode* result = sol.addTwoNumbers(l1, l2);\n\n    vector&lt;int&gt; expected = {7, 0, 8};\n    for (int val : expected) {\n        assert(result != nullptr &amp;&amp; result-&gt;val == val);\n        result = result-&gt;next;\n    }\n    assert(result == nullptr);  // End of list\n\n    return 0;\n}\n</code></pre>"},{"location":"Company/google/#1757-recyclable-and-low-fat-products","title":"1757. Recyclable and Low Fat Products","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul> SQLTXT <pre><code>SELECT product_id\nFROM\n    products\nWHERE\n    low_fats = 'Y'\n    AND recyclable = 'Y';\n</code></pre> <pre><code>Input:\nProducts table:\n+-------------+----------+------------+\n| product_id  | low_fats | recyclable |\n+-------------+----------+------------+\n| 0           | Y        | N          |\n| 1           | Y        | Y          |\n| 2           | N        | Y          |\n| 3           | Y        | Y          |\n| 4           | N        | N          |\n+-------------+----------+------------+\nOutput:\n+-------------+\n| product_id  |\n+-------------+\n| 1           |\n| 3           |\n+-------------+\n</code></pre>"},{"location":"Company/google/#9-palindrome-number","title":"9. Palindrome Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return true if the given number is a palindrome. Otherwise, return false.\n\"\"\"\n\n\n# Reverse\ndef isPalindromeReverse(x: int) -&gt; bool:\n    if x &lt; 0:\n        return False\n\n    return str(x) == str(x)[::-1]\n\n\n# Left Right Pointers\ndef isPalindromeLR(x: int) -&gt; bool:\n    if x &lt; 0:\n        return False\n\n    x = list(str(x))  # 121 -&gt; ['1', '2', '1']\n\n    left, right = 0, len(x) - 1\n\n    while left &lt; right:\n        if x[left] != x[right]:\n            return False\n        left += 1\n        right -= 1\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |  Reverse   |  O(N)  |   O(N)  |\n# | Left Right |  O(N)  |   O(1)  |\n# |------------|--------|---------|\n\n\nx = 121\nprint(isPalindromeReverse(x))  # True\nprint(isPalindromeLR(x))  # True\n</code></pre>"},{"location":"Company/google/#15-3sum","title":"15. 3Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Sorting</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef threeSum(nums: List[int]) -&gt; List[List[int]]:\n    nums.sort()\n    res = []\n    n = len(nums)\n\n    for i in range(n - 2):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        left, right = i + 1, n - 1\n\n        while left &lt; right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total &gt; 0:\n                right -= 1\n            elif total &lt; 0:\n                left += 1\n            else:\n                res.append([nums[i], nums[left], nums[right]])\n\n                while left &lt; right and nums[left] == nums[left + 1]:\n                    left += 1\n\n                while left &lt; right and nums[right] == nums[right - 1]:\n                    right -= 1\n\n                left += 1\n                right -= 1\n\n    return res\n\n\nnums = [-1, 0, 1, 2, -1, -4]\nassert threeSum(nums) == [[-1, -1, 2], [-1, 0, 1]]\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {\n    sort(nums.begin(), nums.end());\n    vector&lt;vector&lt;int&gt;&gt; res;\n    int n = nums.size();\n\n    for (int i = 0; i &lt; n - 2; i++) {\n        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) {\n            continue;\n        }\n\n        int left = i + 1, right = n - 1;\n\n        while (left &lt; right) {\n            int total = nums[i] + nums[left] + nums[right];\n\n            if (total &gt; 0)\n                right--;\n            else if (total &lt; 0)\n                left++;\n            else {\n                res.push_back({nums[i], nums[left], nums[right]});\n                while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++;\n                while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--;\n                left++;\n                right--;\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {-1, 0, 1, 2, -1, -4};\n    vector&lt;vector&lt;int&gt;&gt; res = threeSum(nums);\n    for (auto&amp; v : res) {\n        for (int i : v) {\n            cout &lt;&lt; i &lt;&lt; \" \";\n        }\n        cout &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Company/google/#4-median-of-two-sorted-arrays","title":"4. Median of Two Sorted Arrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Divide And Conquer</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Brute Force\ndef findMedianSortedArraysBF(nums1: List[int], nums2: List[int]) -&gt; float:\n    nums = sorted(nums1 + nums2)\n    n = len(nums)\n    if n % 2 == 0:\n        return (nums[n // 2 - 1] + nums[n // 2]) / 2\n    else:\n        return nums[n // 2]\n\n\n# Binary Search\ndef findMedianSortedArraysBS(nums1: List[int], nums2: List[int]) -&gt; float:\n    if len(nums1) &gt; len(nums2):\n        nums1, nums2 = nums2, nums1\n\n    m, n = len(nums1), len(nums2)\n    imin, imax, half_len = 0, m, (m + n + 1) // 2\n\n    while imin &lt;= imax:\n        i = (imin + imax) // 2\n        j = half_len - i\n\n        if i &lt; m and nums2[j - 1] &gt; nums1[i]:\n            imin = i + 1\n        elif i &gt; 0 and nums1[i - 1] &gt; nums2[j]:\n            imax = i - 1\n        else:\n            if i == 0:\n                max_of_left = nums2[j - 1]\n            elif j == 0:\n                max_of_left = nums1[i - 1]\n            else:\n                max_of_left = max(nums1[i - 1], nums2[j - 1])\n\n            if (m + n) % 2 == 1:\n                return max_of_left\n\n            if i == m:\n                min_of_right = nums2[j]\n            elif j == n:\n                min_of_right = nums1[i]\n            else:\n                min_of_right = min(nums1[i], nums2[j])\n\n            return (max_of_left + min_of_right) / 2\n\n\n# |--------------|-----------------|--------------|\n# | Approach     | Time            | Space        |\n# |--------------|-----------------|--------------|\n# | Brute Force  | O((n+m)log(n+m))| O(n+m)       |\n# | Binary Search| O(log(min(n,m)))| O(1)         |\n# |--------------|-----------------|--------------|\n\n\nnums1 = [1, 3]\nnums2 = [2]\nprint(findMedianSortedArraysBF(nums1, nums2))  # 2.0\nprint(findMedianSortedArraysBS(nums1, nums2))  # 2.0\n</code></pre>"},{"location":"Company/google/#14-longest-common-prefix","title":"14. Longest Common Prefix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Trie</p> </li> </ul> Python <pre><code>from typing import List\n\n\nclass longestCommonPrefix:\n    def horizontal_scan(self, strs: List[str]) -&gt; str:\n        if not strs:\n            return \"\"\n\n        prefix = strs[0]\n        for i in range(1, len(strs)):\n            while not strs[i].startswith(prefix):\n                prefix = prefix[:-1]\n                if not prefix:\n                    return \"\"\n\n        return prefix\n\n    def vertical_scan(self, strs: List[str]) -&gt; str:\n        if not strs:\n            return \"\"\n\n        for i in range(len(strs[0])):\n            char = strs[0][i]\n            for j in range(1, len(strs)):\n                if i &gt;= len(strs[j]) or strs[j][i] != char:\n                    return strs[0][:i]\n\n        return strs[0]\n\n    def divide_conquer(self, strs: List[str]) -&gt; str:\n        if not strs:\n            return \"\"\n\n        def merge(left, right):\n            n = min(len(left), len(right))\n            for i in range(n):\n                if left[i] != right[i]:\n                    return left[:i]\n            return left[:n]\n\n        def find(strs, start, end):\n            if start == end:\n                return strs[start]\n            mid = start + (end - start) // 2\n            left = find(strs, start, mid)\n            right = find(strs, mid + 1, end)\n            return merge(left, right)\n\n        return find(strs, 0, len(strs) - 1)\n\n    def binary_search(self, strs: List[str]) -&gt; str:\n        if not strs:\n            return \"\"\n\n        def isCommonPrefix(strs, length):\n            prefix = strs[0][:length]\n            return all(s.startswith(prefix) for s in strs)\n\n        minLen = min(len(s) for s in strs)\n        low, high = 0, minLen\n        while low &lt; high:\n            mid = low + (high - low) // 2\n            if isCommonPrefix(strs, mid + 1):\n                low = mid + 1\n            else:\n                high = mid\n\n        return strs[0][:low]\n\n\nif __name__ == \"__main__\":\n    solution = longestCommonPrefix()\n    strs = [\"flower\", \"flow\", \"flight\"]\n    assert solution.horizontal_scan(strs) == \"fl\"\n    assert solution.vertical_scan(strs) == \"fl\"\n    assert solution.divide_conquer(strs) == \"fl\"\n    assert solution.binary_search(strs) == \"fl\"\n</code></pre>"},{"location":"Company/google/#42-trapping-rain-water","title":"42. Trapping Rain Water","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Dynamic Programming, Stack, Monotonic Stack</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- ![42](../../assets/0042.png)\n\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/ZI2z5pq0TqA?si=OEYg01dbmzvmtIwZ\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen&gt;&lt;/iframe&gt;\n\n| Approach   | Time | Space |\n| ---------- | ---- | ----- |\n| DP         | O(N) | O(N)  |\n| Left Right | O(N) | O(1)  |\n| Monotonic  | O(N) | O(N)  |\n\"\"\"\n\nfrom typing import List\n\n\n# DP\ndef trapDP(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    n = len(height)\n    maxLeft, maxRight = [0 for _ in range(n)], [0 for _ in range(n)]\n\n    for i in range(1, n):\n        maxLeft[i] = max(maxLeft[i - 1], height[i - 1])\n\n    for i in range(n - 2, -1, -1):\n        maxRight[i] = max(maxRight[i + 1], height[i + 1])\n\n    res = 0\n    for i in range(n):\n        res += max(0, min(maxLeft[i], maxRight[i]) - height[i])\n\n    return res\n\n\n# Left Right Pointers\ndef trapLR(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    left, right = 0, len(height) - 1\n    maxL, maxR = height[left], height[right]\n    res = 0\n\n    while left &lt; right:\n        if maxL &lt; maxR:\n            left += 1\n            maxL = max(maxL, height[left])\n            res += maxL - height[left]\n        else:\n            right -= 1\n            maxR = max(maxR, height[right])\n            res += maxR - height[right]\n\n    return res\n\n\n# Monotonic Stack\ndef trapStack(height: List[int]) -&gt; int:\n    stack = []\n    total = 0\n\n    for i in range(len(height)):\n        while stack and height[i] &gt; height[stack[-1]]:\n            top = stack.pop()\n            if not stack:\n                break\n            distance = i - stack[-1] - 1\n            bounded_height = min(height[i], height[stack[-1]]) - height[top]\n            total += distance * bounded_height\n        stack.append(i)\n\n    return total\n\n\nheight = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\nprint(trapDP(height))  # 6\nprint(trapLR(height))  # 6\nprint(trapStack(height))  # 6\n</code></pre> <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int trap(vector&lt;int&gt; &amp;height)\n    {\n        if (height.empty())\n            return 0;\n\n        int res = 0;\n        int left = 0, right = height.size() - 1;\n        int maxL = height[left], maxR = height[right];\n\n        while (left &lt; right)\n        {\n            if (maxL &lt; maxR)\n            {\n                left++;\n                maxL = max(maxL, height[left]);\n                res += maxL - height[left];\n            }\n            else\n            {\n                right--;\n                maxR = max(maxR, height[right]);\n                res += maxR - height[right];\n            }\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    vector&lt;int&gt; height = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};\n    Solution solution;\n    cout &lt;&lt; solution.trap(height) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"Company/google/#3-longest-substring-without-repeating-characters","title":"3. Longest Substring Without Repeating Characters","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Classic variable sliding window problem. Use a set to keep track of the characters in the current window.\n- Return the length of the longest substring without repeating characters.\n- [Template tutorial by \u7075\u5c71\u8336\u827e\u5e9c](https://leetcode.cn/problems/longest-substring-without-repeating-characters/solutions/1959540/xia-biao-zong-suan-cuo-qing-kan-zhe-by-e-iaks)\n\"\"\"\n\nfrom collections import defaultdict\n\n\n# Sliding Window Variable Max - HashMap\ndef lengthOfLongestSubstringHash(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    left = 0\n    cnt = defaultdict(int)\n    res = 0\n\n    for right in range(n):\n        cnt[s[right]] += 1\n\n        while cnt[s[right]] &gt; 1:\n            cnt[s[left]] -= 1\n            left += 1\n\n        res = max(res, right - left + 1)\n\n    return res\n\n\n# Sliding Window Variable Max - Set\ndef lengthOfLongestSubstringSet(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    left = 0\n    res = 0\n    window = set()\n\n    for right in range(n):\n        while left &lt; right and s[right] in window:\n            window.remove(s[left])\n            left += 1\n        window.add(s[right])\n        res = max(res, right - left + 1)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    s = \"abcabcbb\"\n    assert lengthOfLongestSubstringHash(s) == 3\n    assert lengthOfLongestSubstringSet(s) == 3\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;unordered_set&gt;\nusing namespace std;\n\nint lengthOfLongestSubstring(string s) {\n    int n = s.length();\n    int res = 0;\n    int left = 0;\n    unordered_set&lt;char&gt; window;\n\n    for (int right = 0; right &lt; n; right++) {\n        char ch = s[right];\n\n        while (window.find(ch) != window.end()) {\n            window.erase(s[left]);\n            left++;\n        }\n\n        window.insert(ch);\n        res = max(res, right - left + 1);\n    }\n    return (int)res;\n}\n\nint main() {\n    string s = \"abcabcbb\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 3\n    s = \"bbbbb\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 1\n    s = \"pwwkew\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 3\n    return 0;\n}\n</code></pre>"},{"location":"Company/google/#26-remove-duplicates-from-sorted-array","title":"26. Remove Duplicates from Sorted Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Remove duplicates in-place.\n\"\"\"\n\nfrom typing import List\n\n\ndef removeDuplicates(nums: List[int]) -&gt; int:\n    fast, slow = 1, 1\n\n    while fast &lt; len(nums):\n        if nums[fast] != nums[fast - 1]:\n            nums[slow] = nums[fast]\n            slow += 1\n        fast += 1\n\n    return slow\n\n\nnums = [1, 1, 2]\nprint(removeDuplicates(nums))  # 2\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int removeDuplicates(vector&lt;int&gt;&amp; nums) {\n        int fast = 1, slow = 1;\n        int n = nums.size();\n\n        while (fast &lt; n) {\n            if (nums[fast] != nums[fast - 1]) {\n                nums[slow] = nums[fast];\n                slow++;\n            }\n            fast++;\n        }\n        return slow;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; nums = {0, 0, 1, 1, 1, 2, 2, 3, 3, 4};\n    assert(solution.removeDuplicates(nums) == 5);\n    return 0;\n}\n</code></pre>"},{"location":"Company/google/#20-valid-parentheses","title":"20. Valid Parentheses","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack</p> </li> </ul> PythonCPP <pre><code># Stack\ndef is_valid(s: str) -&gt; bool:\n    if len(s) % 2:\n        return False\n\n    pairs = {\n        \"(\": \")\",\n        \"{\": \"}\",\n        \"[\": \"]\",\n    }\n    stack = []\n    for ch in s:\n        if ch in pairs:\n            stack.append(ch)\n        elif not stack or ch != pairs[stack.pop()]:\n            return False\n\n    return True if not stack else False\n\n\ndef test_is_valid():\n    assert is_valid(\"()[]{}\")\n    assert not is_valid(\"(]\")\n    assert not is_valid(\"([)]\")\n    assert is_valid(\"{[]}\")\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;stack&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool isValid(string s) {\n        unordered_map&lt;char, char&gt; map{{')', '('}, {'}', '{'}, {']', '['}};\n        stack&lt;char&gt; stack;\n        if (s.length() % 2 == 1) return false;\n\n        for (char&amp; ch : s) {\n            if (stack.empty() || map.find(ch) == map.end()) {\n                stack.push(ch);\n            } else {\n                if (map[ch] != stack.top()) {\n                    return false;\n                }\n                stack.pop();\n            }\n        }\n        return stack.empty();\n    }\n};\n\nint main() {\n    Solution s;\n    assert(s.isValid(\"()\") == true);\n    assert(s.isValid(\"()[]{}\") == true);\n    assert(s.isValid(\"(]\") == false);\n    assert(s.isValid(\"([)]\") == false);\n    assert(s.isValid(\"{[]}\") == true);\n    return 0;\n}\n</code></pre>"},{"location":"Company/google/#11-container-with-most-water","title":"11. Container With Most Water","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Greedy</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return the maximum area of water that can be trapped between the vertical lines.\n\n![11](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)\n\"\"\"\n\nfrom typing import List\n\n\n# Brute Force\ndef maxAreaBF(height: List[int]) -&gt; int:\n    max_area = 0\n\n    for i in range(len(height)):\n        for j in range(i + 1, len(height)):\n            h = min(height[i], height[j])\n            w = j - i\n            max_area = max(max_area, h * w)\n\n    return max_area\n\n\n# Left Right Pointers\ndef maxAreaLR(height: List[int]) -&gt; int:\n    left, right = 0, len(height) - 1\n    res = 0\n\n    while left &lt; right:\n        h = min(height[left], height[right])\n        w = right - left\n        res = max(res, h * w)\n\n        if height[left] &lt; height[right]:\n            left += 1\n        else:\n            right -= 1\n\n    return res\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force| O(n^2) |  O(1)   |\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nheight = [1, 8, 6, 2, 5, 4, 8, 3, 7]\nprint(maxAreaBF(height))  # 49\nprint(maxAreaLR(height))  # 49\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint maxArea(vector&lt;int&gt;&amp; height) {\n    int left = 0, right = height.size() - 1;\n    int res = 0;\n\n    while (left &lt; right) {\n        int h = min(height[left], height[right]);\n        int w = right - left;\n        res = max(res, h * w);\n\n        if (height[left] &lt; height[right])\n            left++;\n        else\n            right--;\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; height = {1, 8, 6, 2, 5, 4, 8, 3, 7};\n    cout &lt;&lt; maxArea(height) &lt;&lt; endl;  // 49\n    return 0;\n}\n</code></pre>"},{"location":"Company/google/#5-longest-palindromic-substring","title":"5. Longest Palindromic Substring","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Dynamic Programming</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the longest palindromic substring in `s`.\n\"\"\"\n\n\n# DP - Interval\ndef longestPalindromeDP(s: str) -&gt; str:\n    n = len(s)\n    if n &lt;= 1:\n        return s\n\n    start, maxLen = 0, 1\n\n    # Init\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for j in range(1, n):\n        for i in range(j):\n            if s[i] == s[j]:\n                if j - i &lt;= 2:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1]\n\n                if dp[i][j] and j - i + 1 &gt; maxLen:\n                    maxLen = j - i + 1\n                    start = i\n\n    return s[start : start + maxLen]\n\n\n# Expand Around Center\ndef longestPalindromeCenter(s: str) -&gt; str:\n    def expand_around_center(left, right):\n        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n\n    if len(s) &lt;= 1:\n        return s\n\n    start, end = 0, 0\n    for i in range(len(s)):\n        len1 = expand_around_center(i, i)  # odd\n        len2 = expand_around_center(i, i + 1)  # even\n\n        maxLen = max(len1, len2)\n        if maxLen &gt; end - start:\n            start = i - (maxLen - 1) // 2\n            end = i + maxLen // 2\n\n    return s[start : end + 1]\n\n\ns = \"babad\"\nprint(longestPalindromeDP(s))  # \"bab\"\nprint(longestPalindromeCenter(s))  # \"aba\"\n</code></pre>"},{"location":"Company/google/#13-roman-to-integer","title":"13. Roman to Integer","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Math, String</p> </li> </ul> Python <pre><code>from itertools import pairwise\n\n\n# Arrays\ndef romanToInt(s: str) -&gt; int:\n    ROMAN = {\n        \"I\": 1,\n        \"V\": 5,\n        \"X\": 10,\n        \"L\": 50,\n        \"C\": 100,\n        \"D\": 500,\n        \"M\": 1000,\n    }\n\n    res = 0\n\n    for x, y in pairwise(s):\n        x, y = ROMAN[x], ROMAN[y]\n        res += x if x &gt;= y else -x\n\n    return res + ROMAN[s[-1]]\n\n\nif __name__ == \"__main__\":\n    assert romanToInt(\"III\") == 3\n    assert romanToInt(\"IV\") == 4\n    assert romanToInt(\"IX\") == 9\n    assert romanToInt(\"LVIII\") == 58\n    assert romanToInt(\"MCMXCIV\") == 1994\n    assert romanToInt(\"MMXXIII\") == 2023\n</code></pre>"},{"location":"Company/google/#22-generate-parentheses","title":"22. Generate Parentheses","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Backtracking</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Backtracking\ndef generateParenthesis1(n: int) -&gt; List[str]:\n    path, res = [], []\n\n    def dfs(openN, closeN):\n        if openN == closeN == n:\n            res.append(\"\".join(path))\n            return\n\n        if openN &lt; n:\n            path.append(\"(\")\n            dfs(openN + 1, closeN)\n            path.pop()\n\n        if closeN &lt; openN:\n            path.append(\")\")\n            dfs(openN, closeN + 1)\n            path.pop()\n\n    dfs(0, 0)\n\n    return res\n\n\n# Backtracking\ndef generateParenthesis2(n: int) -&gt; List[str]:\n    m = n * 2\n    res, path = [], [\"\"] * m\n\n    def dfs(i, left):\n        if i == m:\n            res.append(\"\".join(path))\n            return\n\n        if left &lt; n:\n            path[i] = \"(\"\n            dfs(i + 1, left + 1)\n        if i - left &lt; left:\n            path[i] = \")\"\n            dfs(i + 1, left)\n\n    dfs(0, 0)\n    return res\n\n\nif __name__ == \"__main__\":\n    print(generateParenthesis1(3))\n    # ['((()))', '(()())', '(())()', '()(())', '()()()']\n    print(generateParenthesis2(3))\n    # ['((()))', '(()())', '(())()', '()(())', '()()()']\n</code></pre>"},{"location":"Company/google/#128-longest-consecutive-sequence","title":"128. Longest Consecutive Sequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Union Find</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Set\ndef longestConsecutiveSet(nums: List[int]) -&gt; int:\n    num_set = set(nums)  # O(n)\n    longest = 0\n\n    for n in nums:\n        if (n - 1) not in num_set:  # left boundary\n            length = 1\n\n            while (n + length) in num_set:\n                length += 1\n\n            longest = max(longest, length)\n\n    return longest\n\n\n# Union Find\ndef longestConsecutiveUF(nums: List[int]) -&gt; int:\n    if not nums:\n        return 0\n\n    par = {num: num for num in nums}\n    rank = {num: 1 for num in nums}\n\n    def find(num):\n        p = par[num]\n        while p != par[p]:\n            p = par[p]\n        return p\n\n    def union(num1, num2):\n        p1, p2 = find(num1), find(num2)\n        if p1 == p2:\n            return\n\n        if rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n            rank[p2] += rank[p1]\n        else:\n            par[p2] = p1\n            rank[p1] += rank[p2]\n\n    for num in nums:\n        if num - 1 in par:\n            union(num, num - 1)\n\n    return max(rank.values())\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |  Set       |  O(N)  |  O(N)   |\n# | Union Find |  O(N)  |  O(N)   |\n# |------------|--------|---------|\n\n\nnums = [100, 4, 200, 1, 3, 2]\nprint(longestConsecutiveSet(nums))  # 4\nprint(longestConsecutiveUF(nums))  # 4\n</code></pre>"},{"location":"Company/google/#21-merge-two-sorted-lists","title":"21. Merge Two Sorted Lists","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Recursion</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Task: Merge the two linked lists into one sorted list.\n\"\"\"\n\nfrom typing import Optional\n\nfrom leetpattern.utils import ListNode\n\n\n# Linked List\ndef merge_two_lists(\n    list1: Optional[ListNode], list2: Optional[ListNode]\n) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    while list1 and list2:\n        if list1.val &lt; list2.val:\n            cur.next = list1\n            list1 = list1.next\n        else:\n            cur.next = list2\n            list2 = list2.next\n        cur = cur.next\n\n    if list1:\n        cur.next = list1\n    elif list2:\n        cur.next = list2\n\n    return dummy.next\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode* next) : val(x), next(next) {}\n};\n\nclass Solution {\n   public:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        ListNode dummy;\n        ListNode* cur = &amp;dummy;\n\n        while (list1 &amp;&amp; list2) {\n            if (list1-&gt;val &lt; list2-&gt;val) {\n                cur-&gt;next = list1;\n                list1 = list1-&gt;next;\n            } else {\n                cur-&gt;next = list2;\n                list2 = list2-&gt;next;\n            }\n            cur = cur-&gt;next;\n        }\n\n        cur-&gt;next = list1 ? list1 : list2;\n\n        return dummy.next;\n    }\n};\n\nint main() {\n    Solution sol;\n    ListNode* list1 = new ListNode(1, new ListNode(2, new ListNode(4)));\n    ListNode* list2 = new ListNode(1, new ListNode(3, new ListNode(4)));\n    ListNode* merged = sol.mergeTwoLists(list1, list2);\n    vector&lt;int&gt; res;\n    while (merged) {\n        res.push_back(merged-&gt;val);\n        merged = merged-&gt;next;\n    }\n    assert(res == std::vector&lt;int&gt;({1, 1, 2, 3, 4, 4}));\n    return 0;\n}\n</code></pre>"},{"location":"Company/google/#560-subarray-sum-equals-k","title":"560. Subarray Sum Equals K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Prefix Sum</p> </li> </ul> PythonCPP <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Prefix Sum\ndef subarraySum(nums: List[int], k: int) -&gt; int:\n    preSums = defaultdict(int)\n    preSums[0] = 1\n    curSum = 0\n    res = 0\n\n    for num in nums:\n        curSum += num\n        res += preSums[curSum - k]\n        preSums[curSum] += 1\n\n    return res\n\n\nnums = [1, 1, 1]\nk = 2\nprint(subarraySum(nums, k))  # 2\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint subarraySum(vector&lt;int&gt;&amp; nums, int k) {\n    int n = nums.size();\n    vector&lt;int&gt; prefixSum(n + 1);\n    for (int i = 0; i &lt; n; i++) {\n        prefixSum[i + 1] = prefixSum[i] + nums[i];\n    }\n\n    int res = 0;\n    unordered_map&lt;int, int&gt; cnt;\n\n    for (int ps : prefixSum) {\n        if (cnt.find(ps - k) != cnt.end()) res += cnt[ps - k];\n        cnt[ps]++;\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {1, 1, 1};\n    int k = 2;\n    cout &lt;&lt; subarraySum(nums, k) &lt;&lt; endl;  // 2\n    return 0;\n}\n</code></pre>"},{"location":"Company/google/#27-remove-element","title":"27. Remove Element","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Remove all instances of a given value in-place.\n\"\"\"\n\nfrom typing import List\n\n\n# Fast Slow Pointers\ndef removeElement(nums: List[int], val: int) -&gt; int:\n    fast, slow = 0, 0\n\n    while fast &lt; len(nums):\n        if nums[fast] != val:\n            nums[slow] = nums[fast]\n            slow += 1\n        fast += 1\n\n    return slow\n\n\nnums = [0, 1, 2, 2, 3, 0, 4, 2]\nval = 2\nprint(removeElement(nums, val))  # 5\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// Fast Slow Pointers\nint removeElement(vector&lt;int&gt;&amp; nums, int val) {\n    size_t n = nums.size();\n    size_t slow = 0, fast = 0;\n\n    while (fast &lt; n) {\n        if (nums[fast] != val) {\n            nums[slow] = nums[fast];\n            slow++;\n        }\n        fast++;\n    }\n    return (int)slow;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {3, 2, 2, 3};\n    int val = 3;\n    cout &lt;&lt; removeElement(nums, val) &lt;&lt; endl;  // 2\n    return 0;\n}\n</code></pre>"},{"location":"Company/google/#31-next-permutation","title":"31. Next Permutation","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef nextPermutation(nums: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    n = len(nums)\n    i = n - 1\n    while i &gt; 0 and nums[i - 1] &gt;= nums[i]:\n        i -= 1\n    if i != 0:\n        j = n - 1\n        while nums[j] &lt;= nums[i - 1]:\n            j -= 1\n        nums[i - 1], nums[j] = nums[j], nums[i - 1]\n\n    left, right = i, n - 1\n    while left &lt; right:\n        nums[left], nums[right] = nums[right], nums[left]\n        left += 1\n        right -= 1\n\n\nnums = [1, 2, 3]\nnextPermutation(nums)\nprint(nums)  # [1, 3, 2]\nnums = [1, 2, 3, 4, 6, 5]\nnextPermutation(nums)\nprint(nums)  # [1, 2, 3, 5, 4, 6]\n</code></pre>"},{"location":"Company/google/#53-maximum-subarray","title":"53. Maximum Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Divide And Conquer, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP Kadane\ndef maxSubArrayDP(nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n\n    dp[0] = nums[0]\n    maxSum = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(\n            dp[i - 1] + nums[i],  # continue the previous subarray\n            nums[i],  # start a new subarray\n        )\n        maxSum = max(maxSum, dp[i])\n\n    return maxSum\n\n\n# Greedy\ndef maxSubArrayGreedy(nums: List[int]) -&gt; int:\n    max_sum = nums[0]\n    cur_sum = 0\n\n    for num in nums:\n        cur_sum = max(cur_sum + num, num)\n        max_sum = max(max_sum, cur_sum)\n\n    return max_sum\n\n\n# Prefix Sum\ndef maxSubArrayPrefixSum(nums: List[int]) -&gt; int:\n    prefix_sum = 0\n    prefix_sum_min = 0\n    res = float(\"-inf\")\n\n    for num in nums:\n        prefix_sum += num\n        res = max(res, prefix_sum - prefix_sum_min)\n        prefix_sum_min = min(prefix_sum_min, prefix_sum)\n\n    return res\n\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArrayDP(nums))  # 6\nprint(maxSubArrayGreedy(nums))  # 6\nprint(maxSubArrayPrefixSum(nums))  # 6\n</code></pre>"},{"location":"Company/google/#7-reverse-integer","title":"7. Reverse Integer","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math</p> </li> </ul> Python <pre><code># Math\ndef reverse(x: int) -&gt; int:\n    INT_MAX = 2**31 - 1\n\n    sign = -1 if x &lt; 0 else 1\n    x = abs(x)\n    res = 0\n\n    while x != 0:\n        x, pop = divmod(x, 10)\n\n        if res &gt; (INT_MAX - pop) // 10:\n            return 0\n\n        res = res * 10 + pop\n\n    return res * sign\n\n\nprint(reverse(123))  # 321\nprint(reverse(-123))  # -321\n</code></pre>"},{"location":"Company/google/#6-zigzag-conversion","title":"6. Zigzag Conversion","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String</p> </li> </ul>"},{"location":"Company/google/#118-pascals-triangle","title":"118. Pascal's Triangle","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <p><pre><code>\"\"\"\n-   Generate the first `numRows` of Pascal's triangle.\n\n```plaintext\n                 numRows\n     1              1\n    1 1             2\n   1 2 1            3\n  1 3 3 1           4\n 1 4 6 4 1          5\n</code></pre> \"\"\"</p> <p>from typing import List</p> <p>def generate(numRows: int) -&gt; List[List[int]]:     dp = [[1] * i for i in range(1, numRows + 1)]</p> <pre><code>if numRows &lt;= 2:\n    return dp\n\nfor i in range(2, numRows):\n    for j in range(1, i):\n        dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n\nreturn dp\n</code></pre> <p>if name == \"main\":     print(generate(numRows=5))     # [[1],     #  [1, 1],     #  [1, 2, 1],     #  [1, 3, 3, 1],     #  [1, 4, 6, 4, 1]]</p> <p>```</p>"},{"location":"Company/google/#394-decode-string","title":"394. Decode String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack, Recursion</p> </li> </ul> Python <pre><code># Stack\ndef decodeString(s: str) -&gt; str:\n    stack = []  # (str, int)\n    num = 0\n    res = \"\"\n\n    for c in s:\n        if c.isdigit():\n            num = num * 10 + int(c)\n        elif c == \"[\":\n            stack.append((res, num))\n            res, num = \"\", 0\n        elif c == \"]\":\n            top = stack.pop()\n            res = top[0] + res * top[1]\n        else:\n            res += c\n\n    return res\n\n\ns = \"3[a2[c]]\"\nprint(decodeString(s))  # accaccacc\n</code></pre>"},{"location":"Company/google/#242-valid-anagram","title":"242. Valid Anagram","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sorting</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return true if an input string is an anagram of another string.\n-   An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once, e.g., `listen` is an anagram of `silent`.\n\"\"\"\n\nfrom collections import Counter\n\n\n# Hashmap\ndef isAnagramHash(s: str, t: str) -&gt; bool:\n    \"\"\"Return True if t is an anagram of s, False otherwise.\"\"\"\n    if len(s) != len(t):\n        return False\n\n    count = dict()\n\n    for i in s:\n        if i in count:\n            count[i] += 1\n        else:\n            count[i] = 1\n\n    for j in t:\n        if j in count:\n            count[j] -= 1\n        else:\n            return False\n\n    for count in count.values():\n        if count != 0:\n            return False\n\n    return True\n\n\n# Array\ndef isAnagramArray(s: str, t: str) -&gt; bool:\n    if len(s) != len(t):\n        return False\n\n    count = [0 for _ in range(26)]\n\n    for i in s:\n        count[ord(i) - ord(\"a\")] += 1\n\n    for j in t:\n        count[ord(j) - ord(\"a\")] -= 1\n\n    for i in count:\n        if i != 0:\n            return False\n\n    return True\n\n\n# Counter\ndef isAnagramCounter(s: str, t: str) -&gt; bool:\n    return Counter(s) == Counter(t)\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |   Hashmap   |       O(n)      |     O(1)     |\n# |    Array    |       O(n)      |     O(1)     |\n# |   Counter   |       O(n)      |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\ns = \"anagram\"\nt = \"nagaram\"\nprint(isAnagramHash(s, t))  # True\nprint(isAnagramArray(s, t))  # True\nprint(isAnagramCounter(s, t))  # True\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool isAnagram(string s, string t) {\n        if (s.size() != t.size()) return false;\n\n        vector&lt;int&gt; count(26, 0);\n\n        for (char ch : s) count[ch - 'a']++;\n        for (char ch : t) count[ch - 'a']--;\n        for (int c : count) {\n            if (c != 0) return false;\n        }\n\n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n    assert(solution.isAnagram(\"anagram\", \"nagaram\") == true);\n    assert(solution.isAnagram(\"rat\", \"car\") == false);\n    assert(solution.isAnagram(\"a\", \"ab\") == false);\n    assert(solution.isAnagram(\"a\", \"a\") == true);\n    return 0;\n}\n</code></pre>"},{"location":"Company/google/#18-4sum","title":"18. 4Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Sorting</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef fourSum(nums: List[int], target: int) -&gt; List[List[int]]:\n    \"\"\"Returns all unique quadruplets that sum up to the target.\"\"\"\n    nums.sort()\n    result = []\n\n    for i in range(len(nums) - 3):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        for j in range(i + 1, len(nums) - 2):\n            if j &gt; i + 1 and nums[j] == nums[j - 1]:\n                continue\n\n            left = j + 1\n            right = len(nums) - 1\n\n            while left &lt; right:\n                total = nums[i] + nums[j] + nums[left] + nums[right]\n\n                if total &gt; target:\n                    right -= 1\n                elif total &lt; target:\n                    left += 1\n                else:\n                    result.append([nums[i], nums[j], nums[left], nums[right]])\n                    while left &lt; right and nums[left] == nums[left + 1]:\n                        left += 1\n                    while left &lt; right and nums[right] == nums[right - 1]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n\n    return result\n\n\nnums = [1, 0, -1, 0, -2, 2]\ntarget = 0\nprint(fourSum(nums, target))\n# [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]\n</code></pre>"},{"location":"Company/google/#50-powx-n","title":"50. Pow(x, n)","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Recursion</p> </li> </ul> Python <pre><code># Iterative\ndef myPowIterative(x: float, n: int) -&gt; float:\n    if n == 0:\n        return 1\n    if n &lt; 0:\n        x = 1 / x\n        n = -n\n\n    result = 1\n    cur = x\n\n    while n &gt; 0:\n        if n % 2 == 1:\n            result *= cur\n\n        cur *= cur\n        n //= 2\n\n    return result\n\n\n# Recursive\ndef myPowRecursive(x: float, n: int) -&gt; float:\n    if n == 0:\n        return 1\n    if n &lt; 0:\n        x = 1 / x\n        n = -n\n\n    if n % 2 == 0:\n        return myPowRecursive(x * x, n // 2)\n    else:\n        return x * myPowRecursive(x * x, n // 2)\n\n\nx = 2.00000\nn = 10\nprint(myPowIterative(x, n))  # 1024.0\nprint(myPowRecursive(x, n))  # 1024.0\n</code></pre>"},{"location":"Company/google/#54-spiral-matrix","title":"54. Spiral Matrix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Matrix, Simulation</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return all elements of the matrix in spiral order.\n\"\"\"\n\nfrom typing import List\n\n\n# Array\ndef spiralOrder(matrix: List[List[int]]) -&gt; List[int]:\n    if not matrix or not matrix[0]:\n        return []\n\n    res = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n\n    while top &lt;= bottom and left &lt;= right:\n\n        for i in range(left, right + 1):\n            res.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            res.append(matrix[i][right])\n        right -= 1\n\n        if top &lt;= bottom:\n\n            for i in range(right, left - 1, -1):\n                res.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left &lt;= right:\n\n            for i in range(bottom, top - 1, -1):\n                res.append(matrix[i][left])\n            left += 1\n\n    return res\n\n\n# Math\ndef spiralOrderMath(matrix: List[List[int]]) -&gt; List[int]:\n    dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]]  # Right Down Left Up\n    m, n = len(matrix), len(matrix[0])\n    size = m * n\n    res = []\n    i, j, di = 0, -1, 0\n\n    while len(res) &lt; size:\n        dx, dy = dirs[di]\n        for _ in range(n):\n            i += dx\n            j += dy\n            res.append(matrix[i][j])\n        di = (di + 1) % 4\n        n, m = m - 1, n\n\n    return res\n\n\nprint(spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n# [1, 2, 3, 6, 9, 8, 7, 4, 5]\nprint(spiralOrderMath([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]))\n# [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]\n</code></pre>"},{"location":"Company/meta/","title":"Meta","text":""},{"location":"Company/meta/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 215. Kth Largest Element in an Array (Medium)</li> <li> 162. Find Peak Element (Medium)</li> <li> 199. Binary Tree Right Side View (Medium)</li> <li> 88. Merge Sorted Array (Easy)</li> <li> 1. Two Sum (Easy)</li> <li> 50. Pow(x, n) (Medium)</li> <li> 125. Valid Palindrome (Easy)</li> <li> 71. Simplify Path (Medium)</li> <li> 56. Merge Intervals (Medium)</li> <li> 129. Sum Root to Leaf Numbers (Medium)</li> <li> 138. Copy List with Random Pointer (Medium)</li> <li> 146. LRU Cache (Medium)</li> <li> 121. Best Time to Buy and Sell Stock (Easy)</li> <li> 23. Merge k Sorted Lists (Hard)</li> <li> 31. Next Permutation (Medium)</li> <li> 34. Find First and Last Position of Element in Sorted Array (Medium)</li> <li> 76. Minimum Window Substring (Hard)</li> <li> 133. Clone Graph (Medium)</li> <li> 65. Valid Number (Hard)</li> <li> 20. Valid Parentheses (Easy)</li> <li> 19. Remove Nth Node From End of List (Medium)</li> <li> 14. Longest Common Prefix (Easy)</li> <li> 207. Course Schedule (Medium)</li> <li> 2. Add Two Numbers (Medium)</li> <li> 3. Longest Substring Without Repeating Characters (Medium)</li> <li> 173. Binary Search Tree Iterator (Medium)</li> <li> 26. Remove Duplicates from Sorted Array (Easy)</li> <li> 4. Median of Two Sorted Arrays (Hard)</li> <li> 15. 3Sum (Medium)</li> <li> 9. Palindrome Number (Easy)</li> </ul>"},{"location":"Company/meta/#215-kth-largest-element-in-an-array","title":"215. Kth Largest Element in an Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Divide And Conquer, Sorting, Heap Priority Queue, Quickselect</p> </li> </ul> Python <pre><code>import heapq\nfrom typing import List\n\n\ndef findKthLargest(nums: List[int], k: int) -&gt; int:\n    min_heap = []\n\n    for i, num in enumerate(nums):\n        heapq.heappush(min_heap, num)\n        if i &gt;= k:\n            heapq.heappop(min_heap)\n\n    return min_heap[0]\n\n\nif __name__ == \"__main__\":\n    assert findKthLargest([3, 2, 1, 5, 6, 4], 2) == 5\n</code></pre>"},{"location":"Company/meta/#162-find-peak-element","title":"162. Find Peak Element","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul>"},{"location":"Company/meta/#199-binary-tree-right-side-view","title":"199. Binary Tree Right Side View","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Binary Tree BFS\ndef rightSideViewBFS(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        n = len(q)\n        for i in range(n):\n            node = q.popleft()\n            if i == n - 1:\n                res.append(node.val)\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return res\n\n\n# Binary Tree DFS\ndef rightSideViewDFS(root: Optional[TreeNode]) -&gt; List[int]:\n    \"\"\"\u540e\u5e8f\u904d\u5386\uff0c\u5148\u53f3\u540e\u5de6\uff0c\u9047\u5230\u7684\u7b2c\u4e00\u4e2a\u8282\u70b9\u5c31\u662f\u8be5\u6df1\u5ea6\u7684\u6700\u53f3\u4fa7\u8282\u70b9\"\"\"\n    ans = []\n\n    def dfs(node, depth):\n        if node is None:\n            return\n        if depth == len(ans):  # \u8fd9\u4e2a\u6df1\u5ea6\u9996\u6b21\u9047\u5230\n            ans.append(node.val)\n\n        dfs(node.right, depth + 1)\n        dfs(node.left, depth + 1)\n\n    dfs(root, 0)\n\n    return ans\n\n\nif __name__ == \"__main__\":\n    root = [1, 2, 2, 3, 4, None, 3, None, None, 5]\n    root = build(root)\n    print(root)\n    #     ____1\n    #    /     \\\n    #   2__     2\n    #  /   \\     \\\n    # 3     4     3\n    #      /\n    #     5\n    assert rightSideViewBFS(root) == [1, 2, 3, 5]\n    assert rightSideViewDFS(root) == [1, 2, 3, 5]\n</code></pre>"},{"location":"Company/meta/#88-merge-sorted-array","title":"88. Merge Sorted Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Sorting</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\nclass merge:\n    @staticmethod\n    def lr(nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None:\n        \"\"\"\n        Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        p1, p2, t = m - 1, n - 1, m + n - 1\n\n        while p1 &gt;= 0 or p2 &gt;= 0:\n            if p1 == -1:\n                nums1[t] = nums2[p2]\n                p2 -= 1\n            elif p2 == -1:\n                nums1[t] = nums1[p1]\n                p1 -= 1\n            elif nums1[p1] &gt; nums2[p2]:\n                nums1[t] = nums1[p1]\n                p1 -= 1\n            else:\n                nums1[t] = nums2[p2]\n                p2 -= 1\n\n            t -= 1\n\n\nif __name__ == \"__main__\":\n    nums1 = [1, 2, 3, 0, 0, 0]\n    m = 3\n    nums2 = [2, 5, 6]\n    n = 3\n    merge.lr(nums1, m, nums2, n)\n    assert nums1 == [1, 2, 2, 3, 5, 6]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {\n        int p1 = m - 1, p2 = n - 1, t = m + n - 1;\n\n        while (p1 &gt;= 0 || p2 &gt;= 0) {\n            if (p1 == -1) {\n                nums1[t] = nums2[p2];\n                p2--;\n            } else if (p2 == -1) {\n                nums1[t] = nums1[p1];\n                p1--;\n            } else if (nums1[p1] &gt; nums2[p2]) {\n                nums1[t] = nums1[p1];\n                p1--;\n            } else {\n                nums1[t] = nums2[p2];\n                p2--;\n            }\n            t--;\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; nums1 = {1, 3, 6, 0, 0, 0};\n    vector&lt;int&gt; nums2 = {2, 5, 6};\n    vector&lt;int&gt; output = {1, 2, 3, 5, 6, 6};\n    solution.merge(nums1, 3, nums2, 3);\n    assert(nums1 == output);\n    return 0;\n}\n</code></pre>"},{"location":"Company/meta/#1-two-sum","title":"1. Two Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return the indices of the two numbers such that they add up to a specific target.\n- Approach: Use a hashmap to store the indices of the numbers.\n- Time Complexity: O(n)\n- Space Complexity: O(n)\n\"\"\"\n\nfrom typing import List\n\n\ndef two_sum(nums: List[int], target: int) -&gt; List[int]:\n    hashmap = {}  # val: idx\n\n    for idx, val in enumerate(nums):\n        if (target - val) in hashmap:\n            return [hashmap[target - val], idx]\n\n        hashmap[val] = idx\n\n    return []\n\n\ndef test_two_sum():\n    assert two_sum([2, 7, 11, 15], 9) == [0, 1]\n    assert two_sum([3, 2, 4], 6) == [1, 2]\n    assert two_sum([3, 3], 6) == [0, 1]\n    assert two_sum([1, 2, 3, 4, 5], 10) == []\n    assert two_sum([-1, -2, -3, -4, -5], -8) == [2, 4]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Solution {\n   public:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {\n        unordered_map&lt;int, int&gt; map;\n\n        for (size_t i = 0; i &lt; nums.size(); i++) {\n            int diff = target - nums[i];\n            if (map.find(diff) != map.end()) {\n                return {map[diff], (int)i};\n            }\n            map[nums[i]] = (int)i;\n        }\n        return {-1, -1};\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; nums = {2, 7, 11, 15};\n    int target = 9;\n    vector&lt;int&gt; result = solution.twoSum(nums, target);\n    assert((result == vector&lt;int&gt;{0, 1}));\n    return 0;\n}\n</code></pre>"},{"location":"Company/meta/#50-powx-n","title":"50. Pow(x, n)","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Recursion</p> </li> </ul> Python <pre><code># Iterative\ndef myPowIterative(x: float, n: int) -&gt; float:\n    if n == 0:\n        return 1\n    if n &lt; 0:\n        x = 1 / x\n        n = -n\n\n    result = 1\n    cur = x\n\n    while n &gt; 0:\n        if n % 2 == 1:\n            result *= cur\n\n        cur *= cur\n        n //= 2\n\n    return result\n\n\n# Recursive\ndef myPowRecursive(x: float, n: int) -&gt; float:\n    if n == 0:\n        return 1\n    if n &lt; 0:\n        x = 1 / x\n        n = -n\n\n    if n % 2 == 0:\n        return myPowRecursive(x * x, n // 2)\n    else:\n        return x * myPowRecursive(x * x, n // 2)\n\n\nx = 2.00000\nn = 10\nprint(myPowIterative(x, n))  # 1024.0\nprint(myPowRecursive(x, n))  # 1024.0\n</code></pre>"},{"location":"Company/meta/#125-valid-palindrome","title":"125. Valid Palindrome","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String</p> </li> </ul> Python <pre><code># List Comprehension\ndef isPalindrome(s: str) -&gt; bool:\n    s = [char.lower() for char in s if char.isalnum()]\n    return s == s[::-1]\n\n\n# Left Right Pointers\ndef isPalindromeLR(s: str) -&gt; bool:\n    left, right = 0, len(s) - 1\n\n    while left &lt; right:\n        while left &lt; right and not s[left].isalnum():\n            left += 1\n        while left &lt; right and not s[right].isalnum():\n            right -= 1\n\n        if s[left].lower() != s[right].lower():\n            return False\n\n        left += 1\n        right -= 1\n\n    return True\n\n\ns = \"A man, a plan, a canal: Panama\"\nprint(isPalindrome(s))  # True\nprint(isPalindromeLR(s))  # True\n</code></pre>"},{"location":"Company/meta/#71-simplify-path","title":"71. Simplify Path","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack</p> </li> </ul> Python <pre><code>def simplify_path_stack(path: str) -&gt; str:\n    if not path:\n        return \"/\"\n\n    stack = []\n\n    for p in path.split(\"/\"):\n        if p == \"\" or p == \".\":\n            continue\n        if p != \"..\":\n            stack.append(p)\n        elif stack:\n            stack.pop()\n    return \"/\" + \"/\".join(stack)\n\n\ndef test_simplify_path_stack():\n    assert simplify_path_stack(\"/home/\") == \"/home\"\n    assert simplify_path_stack(\"/../\") == \"/\"\n    assert simplify_path_stack(\"/home//foo/\") == \"/home/foo\"\n    assert simplify_path_stack(\"/a/./b/../../c/\") == \"/c\"\n</code></pre>"},{"location":"Company/meta/#56-merge-intervals","title":"56. Merge Intervals","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sorting</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Merge all overlapping intervals.\n\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/44H3cEC2fFM?si=J-Jr_Fg2eDse3-de\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen&gt;&lt;/iframe&gt;\n\"\"\"\n\nfrom typing import List\n\n\n# Intervals\ndef merge(intervals: List[List[int]]) -&gt; List[List[int]]:\n    n = len(intervals)\n    if n &lt;= 1:\n        return intervals\n\n    intervals.sort(key=lambda x: x[0])\n    res = [intervals[0]]\n\n    for i in range(1, n):\n        if intervals[i][0] &lt;= res[-1][1]:\n            res[-1][1] = max(res[-1][1], intervals[i][1])\n        else:\n            res.append(intervals[i])\n\n    return res\n\n\nprint(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))\n# [[1, 6], [8, 10], [15, 18]]\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// Interval\nvector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {\n    sort(intervals.begin(), intervals.end());\n    vector&lt;vector&lt;int&gt;&gt; res;\n\n    for (auto&amp; range : intervals) {\n        if (!res.empty() &amp;&amp; range[0] &lt;= res.back()[1]) {\n            res.back()[1] = max(res.back()[1], range[1]);\n        } else {\n            res.emplace_back(range);\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;vector&lt;int&gt;&gt; intervals = {{1, 3}, {2, 6}, {8, 10}, {15, 18}};\n    vector&lt;vector&lt;int&gt;&gt; res = merge(intervals);\n    for (auto&amp; range : res) {\n        cout &lt;&lt; range[0] &lt;&lt; \", \" &lt;&lt; range[1] &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Company/meta/#129-sum-root-to-leaf-numbers","title":"129. Sum Root to Leaf Numbers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\nclass sumNumbers:\n    def dfs(self, root: Optional[TreeNode]) -&gt; int:\n        self.res = 0\n\n        def dfs(node, cur):\n            if not node:\n                return\n\n            cur = cur * 10 + node.val\n\n            if not node.left and not node.right:\n                self.res += cur\n                return\n\n            dfs(node.left, cur)\n            dfs(node.right, cur)\n\n        dfs(root, 0)\n\n        return self.res\n\n\nif __name__ == \"__main__\":\n    root = [1, 2, 3]\n    root = build(root)\n    print(root)\n    #   1\n    #  / \\\n    # 2   3\n    assert sumNumbers().dfs(root) == 25\n</code></pre>"},{"location":"Company/meta/#138-copy-list-with-random-pointer","title":"138. Copy List with Random Pointer","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Linked List</p> </li> </ul> Python <pre><code>from typing import Optional\n\n\nclass Node:\n    def __init__(self, x: int, next: \"Node\" = None, random: \"Node\" = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\n\ndef copyRandomList(head: \"Optional[Node]\") -&gt; \"Optional[Node]\":\n    if not head:\n        return None\n\n    # Copy nodes and link them together\n    cur = head\n    while cur:\n        new_node = Node(cur.val)\n        new_node.next = cur.next\n        cur.next = new_node\n        cur = new_node.next\n\n    # Copy random pointers\n    cur = head\n    while cur:\n        cur.next.random = cur.random.next if cur.random else None\n        cur = cur.next.next\n\n    # Separate the original and copied lists\n    cur = head\n    new_head = head.next\n    while cur:\n        new_node = cur.next\n        cur.next = new_node.next\n        new_node.next = new_node.next.next if new_node.next else None\n        cur = cur.next\n\n    return new_head\n</code></pre>"},{"location":"Company/meta/#146-lru-cache","title":"146. LRU Cache","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Linked List, Design, Doubly Linked List</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Design and implement a data structure for **Least Recently Used (LRU) cache**. It should support the following operations: get and put.\n- [lru](https://media.geeksforgeeks.org/wp-content/uploads/20240909142802/Working-of-LRU-Cache-copy-2.webp)\n- ![146](https://miro.medium.com/v2/resize:fit:650/0*fOwBd3z0XtHh7WN1.png)\n\n| Data structure     | Description                   |\n| ------------------ | ----------------------------- |\n| Doubly Linked List | To store the key-value pairs. |\n| Hash Map           | To store the key-node pairs.  |\n\"\"\"\n\nfrom collections import OrderedDict\n\n\n# Doubly Linked List\nclass Node:\n    def __init__(self, key=0, val=0):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.cache = {}\n        self.head = Node()\n        self.tail = Node()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def add_to_last(self, node):\n        self.tail.prev.next = node\n        node.prev = self.tail.prev\n        node.next = self.tail\n        self.tail.prev = node\n\n    def move_to_last(self, node):\n        self.remove(node)\n        self.add_to_last(node)\n\n    def get(self, key: int) -&gt; int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self.move_to_last(node)\n        return node.val\n\n    def put(self, key: int, value: int) -&gt; None:\n        if key in self.cache:\n            node = self.cache[key]\n            node.val = value\n            self.move_to_last(node)\n            return None\n\n        if len(self.cache) == self.cap:\n            del self.cache[self.head.next.key]\n            self.remove(self.head.next)\n\n        node = Node(key=key, val=value)\n        self.cache[key] = node\n        self.add_to_last(node)\n\n\n# OrderedDict\nclass LRUCacheOrderedDict:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.cap = capacity\n\n    def get(self, key: int):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key, last=True)\n        return self.cache[key]\n\n    def put(self, key: int, value: int):\n        if key in self.cache:\n            self.cache.move_to_end(key, last=True)\n        elif len(self.cache) &gt;= self.cap:\n            self.cache.popitem(last=False)\n\n        self.cache[key] = value\n\n\ncache = LRUCache(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\n\ncache = LRUCacheOrderedDict(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\nprint(\"LRU Cache passed\")\nprint(\"LRU Cache Ordered Dict passed\")\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nclass Node {\n   public:\n    int key;\n    int val;\n    Node *prev;\n    Node *next;\n\n    Node(int k = 0, int v = 0) : key(k), val(v), prev(nullptr), next(nullptr) {}\n};\n\nclass LRUCache {\n   private:\n    int cap;\n    unordered_map&lt;int, Node *&gt; cache;\n    Node *head;\n    Node *tail;\n\n    void remove(Node *node) {\n        node-&gt;prev-&gt;next = node-&gt;next;\n        node-&gt;next-&gt;prev = node-&gt;prev;\n    }\n\n    void insert_to_last(Node *node) {\n        tail-&gt;prev-&gt;next = node;\n        node-&gt;prev = tail-&gt;prev;\n        tail-&gt;prev = node;\n        node-&gt;next = tail;\n    }\n\n    void move_to_last(Node *node) {\n        remove(node);\n        insert_to_last(node);\n    }\n\n   public:\n    LRUCache(int capacity) {\n        this-&gt;cap = capacity;\n        head = new Node();\n        tail = new Node();\n        head-&gt;next = tail;\n        tail-&gt;prev = head;\n    }\n\n    int get(int key) {\n        if (cache.find(key) != cache.end()) {\n            Node *node = cache[key];\n            move_to_last(node);\n            return node-&gt;val;\n        }\n        return -1;\n    }\n\n    void put(int key, int value) {\n        if (cache.find(key) != cache.end()) {\n            Node *node = cache[key];\n            node-&gt;val = value;\n            move_to_last(node);\n        } else {\n            Node *newNode = new Node(key, value);\n            cache[key] = newNode;\n            insert_to_last(newNode);\n\n            if ((int)cache.size() &gt; cap) {\n                Node *removed = head-&gt;next;\n                remove(removed);\n                cache.erase(removed-&gt;key);\n                delete removed;\n            }\n        }\n    }\n};\n\nint main() {\n    LRUCache lru(2);\n    lru.put(1, 1);\n    lru.put(2, 2);\n    assert(lru.get(1) == 1);   // returns 1\n    lru.put(3, 3);             // evicts key 2\n    assert(lru.get(2) == -1);  // returns -1 (not found)\n    lru.put(4, 4);             // evicts key 1\n    assert(lru.get(1) == -1);  // returns -1 (not found)\n    assert(lru.get(3) == 3);   // returns 3\n    assert(lru.get(4) == 4);   // returns 4\n    return 0;\n}\n</code></pre>"},{"location":"Company/meta/#121-best-time-to-buy-and-sell-stock","title":"121. Best Time to Buy and Sell Stock","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return the maximum profit that can be achieved from buying on one day and selling on another day.\n\"\"\"\n\nfrom typing import List\n\n\n# Brute Force\ndef maxProfitBF(prices: List[int]) -&gt; int:\n    max_profit = 0\n    n = len(prices)\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_profit = max(max_profit, prices[j] - prices[i])\n\n    return max_profit\n\n\n# DP\ndef maxProfitDP(prices: List[int]) -&gt; int:\n    dp = [[0] * 2 for _ in range(len(prices))]\n    dp[0][0] = -prices[0]  # buy\n    dp[0][1] = 0  # sell\n\n    for i in range(1, len(prices)):\n        dp[i][0] = max(dp[i - 1][0], -prices[i])  # the lowest price to buy\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    max_profit = 0\n    seen_min = prices[0]\n\n    for i in range(1, len(prices)):\n        max_profit = max(max_profit, prices[i] - seen_min)\n        seen_min = min(seen_min, prices[i])\n\n    return max_profit\n\n\n# Fast Slow Pointers\ndef maxProfitFS(prices: List[int]) -&gt; int:\n    max_profit = 0\n    slow, fast = 0, 1\n\n    while fast &lt; len(prices):\n        if prices[fast] &gt; prices[slow]:\n            max_profit = max(max_profit, prices[fast] - prices[slow])\n        else:\n            slow = fast\n        fast += 1\n\n    return max_profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force|  O(n^2)|  O(1)   |\n# | DP         |  O(n)  |  O(n)   |\n# | Greedy     |  O(n)  |  O(1)   |\n# | Fast Slow  |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitBF(prices))  # 5\nprint(maxProfitDP(prices))  # 5\nprint(maxProfitGreedy(prices))  # 5\nprint(maxProfitFS(prices))  # 5\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int maxProfitMemo(vector&lt;int&gt; &amp;prices) {\n        if (prices.size() &lt;= 1) return 0;\n\n        int seen_min = prices[0];\n        int res = 0;\n\n        for (int &amp;price : prices) {\n            res = max(res, price - seen_min);\n            seen_min = min(seen_min, price);\n        }\n        return res;\n    }\n};\n\nint main() {\n    vector&lt;int&gt; prices = {7, 1, 5, 3, 6, 4};\n    Solution obj;\n    cout &lt;&lt; obj.maxProfitMemo(prices) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"Company/meta/#23-merge-k-sorted-lists","title":"23. Merge k Sorted Lists","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Divide And Conquer, Heap Priority Queue, Merge Sort</p> </li> </ul> Python <pre><code>\"\"\"\n-   Prerequisite: 21. Merge Two Sorted Lists\n-   Video explanation: [23. Merge K Sorted Lists - NeetCode](https://youtu.be/q5a5OiGbT6Q?si=SQ2dCvsYQ3LQctPh)\n\"\"\"\n\nimport copy\nimport heapq\nfrom typing import List, Optional\n\nfrom leetpattern.utils import ListNode, list_from_array, list_to_array\n\n\ndef merge_k_lists_divide_conquer(\n    lists: List[Optional[ListNode]],\n) -&gt; Optional[ListNode]:\n    if not lists or len(lists) == 0:\n        return None\n\n    def mergeTwo(l1, l2):\n        dummy = ListNode()\n        cur = dummy\n\n        while l1 and l2:\n            if l1.val &lt; l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n\n            cur = cur.next\n\n        cur.next = l1 if l1 else l2\n\n        return dummy.next\n\n    while len(lists) &gt; 1:\n        merged = []\n\n        for i in range(0, len(lists), 2):\n            l1 = lists[i]\n            l2 = lists[i + 1] if i + 1 &lt; len(lists) else None\n            merged.append(mergeTwo(l1, l2))\n\n        lists = merged\n\n    return lists[0]\n\n\ndef merge_k_lists_heap(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    min_heap = []  # (val, idx, node)\n\n    for idx, head in enumerate(lists):\n        if head:\n            heapq.heappush(min_heap, (head.val, idx, head))\n\n    while min_heap:\n        _, idx, node = heapq.heappop(min_heap)\n        cur.next = node\n        cur = cur.next\n\n        node = node.next\n        if node:\n            heapq.heappush(min_heap, (node.val, idx, node))\n\n    return dummy.next\n\n\ndef test_merge_k_lists() -&gt; None:\n    n1 = list_from_array([1, 4])\n    n2 = list_from_array([1, 3])\n    n3 = list_from_array([2, 6])\n    lists = [n1, n2, n3]\n    lists1 = copy.deepcopy(lists)\n    lists2 = copy.deepcopy(lists)\n    assert (list_to_array(merge_k_lists_divide_conquer(lists1))) == [\n        1,\n        1,\n        2,\n        3,\n        4,\n        6,\n    ]\n    assert (list_to_array(merge_k_lists_heap(lists2))) == [1, 1, 2, 3, 4, 6]\n</code></pre>"},{"location":"Company/meta/#31-next-permutation","title":"31. Next Permutation","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef nextPermutation(nums: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    n = len(nums)\n    i = n - 1\n    while i &gt; 0 and nums[i - 1] &gt;= nums[i]:\n        i -= 1\n    if i != 0:\n        j = n - 1\n        while nums[j] &lt;= nums[i - 1]:\n            j -= 1\n        nums[i - 1], nums[j] = nums[j], nums[i - 1]\n\n    left, right = i, n - 1\n    while left &lt; right:\n        nums[left], nums[right] = nums[right], nums[left]\n        left += 1\n        right -= 1\n\n\nnums = [1, 2, 3]\nnextPermutation(nums)\nprint(nums)  # [1, 3, 2]\nnums = [1, 2, 3, 4, 6, 5]\nnextPermutation(nums)\nprint(nums)  # [1, 2, 3, 5, 4, 6]\n</code></pre>"},{"location":"Company/meta/#34-find-first-and-last-position-of-element-in-sorted-array","title":"34. Find First and Last Position of Element in Sorted Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> PythonCPP <pre><code>from bisect import bisect_left\nfrom typing import List\n\n\nclass searchRange:\n    \"\"\"\n    \u627e lower bound \u548c upper bound\n    \u770b\u7075\u795e\u5bf9\u8fd9\u9053\u9898\u7684\u9898\u89e3\uff0c\u5206\u7c7b\u8ba8\u8bba\u533a\u95f4\u7684\u5199\u6cd5\n    target \u7684 upper bound \u662f target + 1 \u7684 lower bound - 1\n    \u8fd9\u6837\u5c31\u80fd\u7edf\u4e00\u7528 lower bound \u7684\u5199\u6cd5\n    \"\"\"\n\n    # [left, right]\n    def bisect_left_closed(self, nums, target):\n        \"\"\"\n        \u95ed\u533a\u95f4\u5199\u6cd5\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left &lt;= right:\n            mid = left + (right - left) // 2\n            if nums[mid] &lt; target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n\n    # [left, right)\n    def bisect_left_right_open(self, nums, target):\n        \"\"\"\n        \u5de6\u95ed\u53f3\u5f00\u533a\u95f4\u5199\u6cd5\n        \"\"\"\n        left, right = 0, len(nums)\n        while left &lt; right:\n            mid = left + (right - left) // 2\n            if nums[mid] &gt;= target:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\n    # (left, right)\n    def bisect_left_open(self, nums, target):\n        \"\"\"\n        \u63a8\u8350\u5f00\u533a\u95f4\u5199\u6cd5\n        \"\"\"\n        left, right = -1, len(nums)\n        while left + 1 &lt; right:\n            mid = left + (right - left) // 2\n            if nums[mid] &lt; target:\n                left = mid\n            else:\n                right = mid\n        return right\n\n    def search_range(self, nums: List[int], target: int) -&gt; List[int]:\n        # edge case\n        if not nums:\n            return [-1, -1]\n\n        lower = self.bisect_left_closed(nums, target)\n        upper = self.bisect_left_closed(nums, target + 1) - 1\n\n        return [lower, upper] if lower &lt;= upper else [-1, -1]\n\n    def search_range_bisect(self, nums: List[int], target: int) -&gt; List[int]:\n        \"\"\"\u7528 python bisect \u5e93\u51fd\u6570\"\"\"\n        # edge case\n        if not nums:\n            return [-1, -1]\n\n        lower = bisect_left(nums, target)\n        upper = bisect_left(nums, target + 1) - 1\n\n        return [lower, upper] if lower &lt;= upper else [-1, -1]\n\n\nif __name__ == \"__main__\":\n    nums = [5, 7, 7, 8, 8, 10]\n    target = 8\n    sol = searchRange()\n    assert sol.search_range(nums, target) == [3, 4]\n    assert sol.search_range_bisect(nums, target) == [3, 4]\n</code></pre> <pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\n  int bisect_left(vector&lt;int&gt; &amp;nums, int target)\n  {\n    int left = 0, right = (int)nums.size() - 1;\n\n    while (left &lt;= right)\n    {\n      int mid = left + (right - left) / 2;\n      if (nums[mid] &lt; target)\n      {\n        left = mid + 1;\n      }\n      else\n      {\n        right = mid - 1;\n      }\n    }\n    return left;\n  }\n\npublic:\n  vector&lt;int&gt; searchRange(vector&lt;int&gt; &amp;nums, int target)\n  {\n    int left = bisect_left(nums, target);\n    if (left == (int)nums.size() || nums[left] != target)\n    {\n      return {-1, -1};\n    }\n    int right = bisect_left(nums, target + 1) - 1;\n    return {left, right};\n  }\n};\n\nint main()\n{\n  vector&lt;int&gt; nums = {5, 7, 7, 8, 8, 10};\n  int target = 8;\n  Solution s;\n  vector&lt;int&gt; res = s.searchRange(nums, target);\n  cout &lt;&lt; res[0] &lt;&lt; \", \" &lt;&lt; res[1] &lt;&lt; endl;\n  return 0;\n}\n</code></pre>"},{"location":"Company/meta/#76-minimum-window-substring","title":"76. Minimum Window Substring","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> Python <pre><code>from collections import Counter\n\n\ndef minWindow(s: str, t: str) -&gt; str:\n    if not t or not s:\n        return \"\"\n\n    counts = Counter(t)\n    required = len(counts)\n\n    left, right = 0, 0\n    formed = 0\n    window_counts = dict()\n\n    result = float(\"inf\"), None, None\n\n    while right &lt; len(s):\n        char = s[right]\n        window_counts[char] = window_counts.get(char, 0) + 1\n        if char in counts and window_counts[char] == counts[char]:\n            formed += 1\n\n        while left &lt;= right and formed == required:\n            char = s[left]\n            if right - left + 1 &lt; result[0]:\n                result = (right - left + 1, left, right)\n            window_counts[char] -= 1\n            if char in counts and window_counts[char] &lt; counts[char]:\n                formed -= 1\n            left += 1\n\n        right += 1\n\n    return \"\" if result[0] == float(\"inf\") else s[result[1] : result[2] + 1]\n\n\ns = \"ADOBECODEBANC\"\nt = \"ABC\"\nprint(minWindow(s, t))  # BANC\n</code></pre>"},{"location":"Company/meta/#133-clone-graph","title":"133. Clone Graph","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Depth First Search, Breadth First Search, Graph</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import Optional\n\n\nclass Node:\n    def __init__(self, val=0, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\n\nclass CloneGraph:\n    def dfs(self, node: Optional[\"Node\"]) -&gt; Optional[\"Node\"]:\n        hashmap = {}\n\n        def dfs(node):\n            if node in hashmap:\n                return hashmap[node]\n\n            res = Node(node.val)\n            hashmap[node] = res\n\n            for nei in node.neighbors:\n                res.neighbors.append(dfs(nei))\n\n            return res\n\n        return dfs(node) if node else None\n\n    def bfs(self, node: Optional[\"Node\"]) -&gt; Optional[\"Node\"]:\n        if not node:\n            return None\n\n        hashmap = {node: Node(node.val)}\n        q = deque([node])\n\n        while q:\n            cur = q.popleft()\n\n            for nei in cur.neighbors:\n                if nei not in hashmap:\n                    hashmap[nei] = Node(nei.val)\n                    q.append(nei)\n\n                hashmap[cur].neighbors.append(hashmap[nei])\n\n        return hashmap[node]\n</code></pre>"},{"location":"Company/meta/#65-valid-number","title":"65. Valid Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String</p> </li> </ul>"},{"location":"Company/meta/#20-valid-parentheses","title":"20. Valid Parentheses","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack</p> </li> </ul> PythonCPP <pre><code># Stack\ndef is_valid(s: str) -&gt; bool:\n    if len(s) % 2:\n        return False\n\n    pairs = {\n        \"(\": \")\",\n        \"{\": \"}\",\n        \"[\": \"]\",\n    }\n    stack = []\n    for ch in s:\n        if ch in pairs:\n            stack.append(ch)\n        elif not stack or ch != pairs[stack.pop()]:\n            return False\n\n    return True if not stack else False\n\n\ndef test_is_valid():\n    assert is_valid(\"()[]{}\")\n    assert not is_valid(\"(]\")\n    assert not is_valid(\"([)]\")\n    assert is_valid(\"{[]}\")\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;stack&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool isValid(string s) {\n        unordered_map&lt;char, char&gt; map{{')', '('}, {'}', '{'}, {']', '['}};\n        stack&lt;char&gt; stack;\n        if (s.length() % 2 == 1) return false;\n\n        for (char&amp; ch : s) {\n            if (stack.empty() || map.find(ch) == map.end()) {\n                stack.push(ch);\n            } else {\n                if (map[ch] != stack.top()) {\n                    return false;\n                }\n                stack.pop();\n            }\n        }\n        return stack.empty();\n    }\n};\n\nint main() {\n    Solution s;\n    assert(s.isValid(\"()\") == true);\n    assert(s.isValid(\"()[]{}\") == true);\n    assert(s.isValid(\"(]\") == false);\n    assert(s.isValid(\"([)]\") == false);\n    assert(s.isValid(\"{[]}\") == true);\n    return 0;\n}\n</code></pre>"},{"location":"Company/meta/#19-remove-nth-node-from-end-of-list","title":"19. Remove Nth Node From End of List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Two Pointers</p> </li> </ul> Python <pre><code>\"\"\"\n-   Given the `head` of a linked list, remove the `n-th` node from the end of the list and return its head.\n\"\"\"\n\nfrom typing import Optional\n\nfrom leetpattern.utils import ListNode, list_from_array, list_to_array\n\n\n# Linked List\ndef removeNthFromEnd(head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:\n    dummy = ListNode(0, head)\n    fast, slow = dummy, dummy\n\n    for _ in range(n):\n        fast = fast.next\n\n    while fast.next:\n        fast = fast.next\n        slow = slow.next\n\n    slow.next = slow.next.next\n\n    return dummy.next\n\n\ndef test_removeNthFromEnd() -&gt; None:\n    head = list_from_array([1, 2, 3, 4, 5])\n    assert (list_to_array(removeNthFromEnd(head, 2))) == [1, 2, 3, 5]\n</code></pre>"},{"location":"Company/meta/#14-longest-common-prefix","title":"14. Longest Common Prefix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Trie</p> </li> </ul> Python <pre><code>from typing import List\n\n\nclass longestCommonPrefix:\n    def horizontal_scan(self, strs: List[str]) -&gt; str:\n        if not strs:\n            return \"\"\n\n        prefix = strs[0]\n        for i in range(1, len(strs)):\n            while not strs[i].startswith(prefix):\n                prefix = prefix[:-1]\n                if not prefix:\n                    return \"\"\n\n        return prefix\n\n    def vertical_scan(self, strs: List[str]) -&gt; str:\n        if not strs:\n            return \"\"\n\n        for i in range(len(strs[0])):\n            char = strs[0][i]\n            for j in range(1, len(strs)):\n                if i &gt;= len(strs[j]) or strs[j][i] != char:\n                    return strs[0][:i]\n\n        return strs[0]\n\n    def divide_conquer(self, strs: List[str]) -&gt; str:\n        if not strs:\n            return \"\"\n\n        def merge(left, right):\n            n = min(len(left), len(right))\n            for i in range(n):\n                if left[i] != right[i]:\n                    return left[:i]\n            return left[:n]\n\n        def find(strs, start, end):\n            if start == end:\n                return strs[start]\n            mid = start + (end - start) // 2\n            left = find(strs, start, mid)\n            right = find(strs, mid + 1, end)\n            return merge(left, right)\n\n        return find(strs, 0, len(strs) - 1)\n\n    def binary_search(self, strs: List[str]) -&gt; str:\n        if not strs:\n            return \"\"\n\n        def isCommonPrefix(strs, length):\n            prefix = strs[0][:length]\n            return all(s.startswith(prefix) for s in strs)\n\n        minLen = min(len(s) for s in strs)\n        low, high = 0, minLen\n        while low &lt; high:\n            mid = low + (high - low) // 2\n            if isCommonPrefix(strs, mid + 1):\n                low = mid + 1\n            else:\n                high = mid\n\n        return strs[0][:low]\n\n\nif __name__ == \"__main__\":\n    solution = longestCommonPrefix()\n    strs = [\"flower\", \"flow\", \"flight\"]\n    assert solution.horizontal_scan(strs) == \"fl\"\n    assert solution.vertical_scan(strs) == \"fl\"\n    assert solution.divide_conquer(strs) == \"fl\"\n    assert solution.binary_search(strs) == \"fl\"\n</code></pre>"},{"location":"Company/meta/#207-course-schedule","title":"207. Course Schedule","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Graph, Topological Sort</p> </li> </ul> PythonCPP <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS (Kahn's Algorithm)\ndef canFinishBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    count = 0\n\n    while q:\n        crs = q.popleft()\n        count += 1\n\n        for nxt in graph[crs]:\n            indegree[nxt] -= 1\n\n            if indegree[nxt] == 0:\n                q.append(nxt)\n\n    return count == numCourses\n\n\n# DFS + Set\ndef canFinishDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for crs, pre in prerequisites:\n        graph[crs].append(pre)\n\n    visiting = set()\n\n    def dfs(crs):\n        if crs in visiting:  # cycle detected\n            return False\n        if graph[crs] == []:\n            return True\n\n        visiting.add(crs)\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        visiting.remove(crs)\n        graph[crs] = []\n\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\n# DFS + List\ndef canFinishDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for pre, crs in prerequisites:\n        graph[crs].append(pre)\n\n    # 0: init, 1: visiting, 2: visited\n    status = [0] * numCourses\n\n    def dfs(crs):\n        if status[crs] == 1:  # cycle detected\n            return False\n        if status[crs] == 2:\n            return True\n\n        status[crs] = 1\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        status[crs] = 2\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(canFinishBFS(5, prerequisites))  # True\nprint(canFinishDFS1(5, prerequisites))  # True\nprint(canFinishDFS2(5, prerequisites))  # True\n</code></pre> <pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    // BFS\n    bool canFinishBFS(int numCourses, vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        vector&lt;int&gt; indegree(numCourses, 0);\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n            indegree[pre[0]]++;\n        }\n\n        queue&lt;int&gt; q;\n        for (int i = 0; i &lt; numCourses; i++) {\n            if (indegree[i] == 0) {\n                q.push(i);\n            }\n        }\n\n        int cnt = 0;\n        while (!q.empty()) {\n            int cur = q.front();\n            q.pop();\n            cnt++;\n\n            for (int nxt : graph[cur]) {\n                indegree[nxt]--;\n                if (indegree[nxt] == 0) {\n                    q.push(nxt);\n                }\n            }\n        }\n        return cnt == numCourses;\n    }\n\n    // DFS\n    bool canFinishDFS(int numCourses, vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n        }\n        // 0: not visited, 1: visiting, 2: visited\n        vector&lt;int&gt; state(numCourses, 0);\n\n        function&lt;bool(int)&gt; dfs = [&amp;](int pre) -&gt; bool {\n            state[pre] = 1;  // visiting\n            for (int crs : graph[pre]) {\n                if (state[crs] == 1 || (state[crs] == 0 &amp;&amp; dfs(crs))) {\n                    return true;\n                }\n            }\n            state[pre] = 2;  // visited\n            return false;\n        };\n\n        for (int i = 0; i &lt; numCourses; i++) {\n            if (state[i] == 0 &amp;&amp; dfs(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution sol;\n    vector&lt;vector&lt;int&gt;&gt; prerequisites = {{1, 0}, {2, 1}, {3, 2}, {4, 3},\n                                         {5, 4}, {6, 5}, {7, 6}, {8, 7},\n                                         {9, 8}, {10, 9}};\n    int numCourses = 11;\n    cout &lt;&lt; sol.canFinishBFS(numCourses, prerequisites) &lt;&lt; endl;\n    cout &lt;&lt; sol.canFinishDFS(numCourses, prerequisites) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"Company/meta/#2-add-two-numbers","title":"2. Add Two Numbers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Math, Recursion</p> </li> </ul> PythonCPP <pre><code>from typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\ndef add_two_numbers(l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]:\n    \"\"\"Add two numbers represented by linked lists.\"\"\"\n    dummy = ListNode()\n    cur = dummy\n    carry = 0\n\n    while l1 or l2:\n        v1 = l1.val if l1 else 0\n        v2 = l2.val if l2 else 0\n\n        carry, val = divmod(v1 + v2 + carry, 10)\n        cur.next = ListNode(val)\n        cur = cur.next\n\n        if l1:\n            l1 = l1.next\n        if l2:\n            l2 = l2.next\n\n    if carry:\n        cur.next = ListNode(val=carry)\n\n    return dummy.next\n\n\ndef test_add_two_numbers():\n    l1 = LinkedList([2, 4, 3]).head\n    l2 = LinkedList([5, 6, 4]).head\n    added = add_two_numbers(l1, l2)\n    assert LinkedList(added).to_array() == [7, 0, 8]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode* next) : val(x), next(next) {}\n};\n\nclass Solution {\n   public:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode dummy;\n        ListNode* cur = &amp;dummy;\n        int carry = 0;\n\n        while (l1 || l2 || carry) {\n            if (l1) {\n                carry += l1-&gt;val;\n                l1 = l1-&gt;next;\n            }\n            if (l2) {\n                carry += l2-&gt;val;\n                l2 = l2-&gt;next;\n            }\n            cur-&gt;next = new ListNode(carry % 10);\n            cur = cur-&gt;next;\n            carry /= 10;\n        }\n        return dummy.next;\n    }\n};\n\nint main() {\n    Solution sol;\n\n    ListNode* l1 = new ListNode(2, new ListNode(4, new ListNode(3)));\n    ListNode* l2 = new ListNode(5, new ListNode(6, new ListNode(4)));\n    ListNode* result = sol.addTwoNumbers(l1, l2);\n\n    vector&lt;int&gt; expected = {7, 0, 8};\n    for (int val : expected) {\n        assert(result != nullptr &amp;&amp; result-&gt;val == val);\n        result = result-&gt;next;\n    }\n    assert(result == nullptr);  // End of list\n\n    return 0;\n}\n</code></pre>"},{"location":"Company/meta/#3-longest-substring-without-repeating-characters","title":"3. Longest Substring Without Repeating Characters","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Classic variable sliding window problem. Use a set to keep track of the characters in the current window.\n- Return the length of the longest substring without repeating characters.\n- [Template tutorial by \u7075\u5c71\u8336\u827e\u5e9c](https://leetcode.cn/problems/longest-substring-without-repeating-characters/solutions/1959540/xia-biao-zong-suan-cuo-qing-kan-zhe-by-e-iaks)\n\"\"\"\n\nfrom collections import defaultdict\n\n\n# Sliding Window Variable Max - HashMap\ndef lengthOfLongestSubstringHash(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    left = 0\n    cnt = defaultdict(int)\n    res = 0\n\n    for right in range(n):\n        cnt[s[right]] += 1\n\n        while cnt[s[right]] &gt; 1:\n            cnt[s[left]] -= 1\n            left += 1\n\n        res = max(res, right - left + 1)\n\n    return res\n\n\n# Sliding Window Variable Max - Set\ndef lengthOfLongestSubstringSet(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    left = 0\n    res = 0\n    window = set()\n\n    for right in range(n):\n        while left &lt; right and s[right] in window:\n            window.remove(s[left])\n            left += 1\n        window.add(s[right])\n        res = max(res, right - left + 1)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    s = \"abcabcbb\"\n    assert lengthOfLongestSubstringHash(s) == 3\n    assert lengthOfLongestSubstringSet(s) == 3\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;unordered_set&gt;\nusing namespace std;\n\nint lengthOfLongestSubstring(string s) {\n    int n = s.length();\n    int res = 0;\n    int left = 0;\n    unordered_set&lt;char&gt; window;\n\n    for (int right = 0; right &lt; n; right++) {\n        char ch = s[right];\n\n        while (window.find(ch) != window.end()) {\n            window.erase(s[left]);\n            left++;\n        }\n\n        window.insert(ch);\n        res = max(res, right - left + 1);\n    }\n    return (int)res;\n}\n\nint main() {\n    string s = \"abcabcbb\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 3\n    s = \"bbbbb\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 1\n    s = \"pwwkew\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 3\n    return 0;\n}\n</code></pre>"},{"location":"Company/meta/#173-binary-search-tree-iterator","title":"173. Binary Search Tree Iterator","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Stack, Tree, Design, Binary Search Tree, Binary Tree, Iterator</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BST\nclass BSTIterator:\n\n    def __init__(self, root: Optional[TreeNode]):\n        self.stack = []\n        self._leftmost_inorder(root)\n\n    def _leftmost_inorder(self, root):\n        while root:\n            self.stack.append(root)\n            root = root.left\n\n    def next(self) -&gt; int:\n        topmost_node = self.stack.pop()\n\n        if topmost_node.right:\n            self._leftmost_inorder(topmost_node.right)\n\n        return topmost_node.val\n\n    def hasNext(self) -&gt; bool:\n        return len(self.stack) &gt; 0\n\n\nroot = build([7, 3, 15, None, None, 9, 20])\nprint(root)\n#   7__\n#  /   \\\n# 3     15\n#      /  \\\n#     9    20\nobj = BSTIterator(root)\nprint(obj.next())  # 3\nprint(obj.next())  # 7\nprint(obj.hasNext())  # True\n</code></pre>"},{"location":"Company/meta/#26-remove-duplicates-from-sorted-array","title":"26. Remove Duplicates from Sorted Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Remove duplicates in-place.\n\"\"\"\n\nfrom typing import List\n\n\ndef removeDuplicates(nums: List[int]) -&gt; int:\n    fast, slow = 1, 1\n\n    while fast &lt; len(nums):\n        if nums[fast] != nums[fast - 1]:\n            nums[slow] = nums[fast]\n            slow += 1\n        fast += 1\n\n    return slow\n\n\nnums = [1, 1, 2]\nprint(removeDuplicates(nums))  # 2\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int removeDuplicates(vector&lt;int&gt;&amp; nums) {\n        int fast = 1, slow = 1;\n        int n = nums.size();\n\n        while (fast &lt; n) {\n            if (nums[fast] != nums[fast - 1]) {\n                nums[slow] = nums[fast];\n                slow++;\n            }\n            fast++;\n        }\n        return slow;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; nums = {0, 0, 1, 1, 1, 2, 2, 3, 3, 4};\n    assert(solution.removeDuplicates(nums) == 5);\n    return 0;\n}\n</code></pre>"},{"location":"Company/meta/#4-median-of-two-sorted-arrays","title":"4. Median of Two Sorted Arrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Divide And Conquer</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Brute Force\ndef findMedianSortedArraysBF(nums1: List[int], nums2: List[int]) -&gt; float:\n    nums = sorted(nums1 + nums2)\n    n = len(nums)\n    if n % 2 == 0:\n        return (nums[n // 2 - 1] + nums[n // 2]) / 2\n    else:\n        return nums[n // 2]\n\n\n# Binary Search\ndef findMedianSortedArraysBS(nums1: List[int], nums2: List[int]) -&gt; float:\n    if len(nums1) &gt; len(nums2):\n        nums1, nums2 = nums2, nums1\n\n    m, n = len(nums1), len(nums2)\n    imin, imax, half_len = 0, m, (m + n + 1) // 2\n\n    while imin &lt;= imax:\n        i = (imin + imax) // 2\n        j = half_len - i\n\n        if i &lt; m and nums2[j - 1] &gt; nums1[i]:\n            imin = i + 1\n        elif i &gt; 0 and nums1[i - 1] &gt; nums2[j]:\n            imax = i - 1\n        else:\n            if i == 0:\n                max_of_left = nums2[j - 1]\n            elif j == 0:\n                max_of_left = nums1[i - 1]\n            else:\n                max_of_left = max(nums1[i - 1], nums2[j - 1])\n\n            if (m + n) % 2 == 1:\n                return max_of_left\n\n            if i == m:\n                min_of_right = nums2[j]\n            elif j == n:\n                min_of_right = nums1[i]\n            else:\n                min_of_right = min(nums1[i], nums2[j])\n\n            return (max_of_left + min_of_right) / 2\n\n\n# |--------------|-----------------|--------------|\n# | Approach     | Time            | Space        |\n# |--------------|-----------------|--------------|\n# | Brute Force  | O((n+m)log(n+m))| O(n+m)       |\n# | Binary Search| O(log(min(n,m)))| O(1)         |\n# |--------------|-----------------|--------------|\n\n\nnums1 = [1, 3]\nnums2 = [2]\nprint(findMedianSortedArraysBF(nums1, nums2))  # 2.0\nprint(findMedianSortedArraysBS(nums1, nums2))  # 2.0\n</code></pre>"},{"location":"Company/meta/#15-3sum","title":"15. 3Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Sorting</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef threeSum(nums: List[int]) -&gt; List[List[int]]:\n    nums.sort()\n    res = []\n    n = len(nums)\n\n    for i in range(n - 2):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        left, right = i + 1, n - 1\n\n        while left &lt; right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total &gt; 0:\n                right -= 1\n            elif total &lt; 0:\n                left += 1\n            else:\n                res.append([nums[i], nums[left], nums[right]])\n\n                while left &lt; right and nums[left] == nums[left + 1]:\n                    left += 1\n\n                while left &lt; right and nums[right] == nums[right - 1]:\n                    right -= 1\n\n                left += 1\n                right -= 1\n\n    return res\n\n\nnums = [-1, 0, 1, 2, -1, -4]\nassert threeSum(nums) == [[-1, -1, 2], [-1, 0, 1]]\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {\n    sort(nums.begin(), nums.end());\n    vector&lt;vector&lt;int&gt;&gt; res;\n    int n = nums.size();\n\n    for (int i = 0; i &lt; n - 2; i++) {\n        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) {\n            continue;\n        }\n\n        int left = i + 1, right = n - 1;\n\n        while (left &lt; right) {\n            int total = nums[i] + nums[left] + nums[right];\n\n            if (total &gt; 0)\n                right--;\n            else if (total &lt; 0)\n                left++;\n            else {\n                res.push_back({nums[i], nums[left], nums[right]});\n                while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++;\n                while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--;\n                left++;\n                right--;\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {-1, 0, 1, 2, -1, -4};\n    vector&lt;vector&lt;int&gt;&gt; res = threeSum(nums);\n    for (auto&amp; v : res) {\n        for (int i : v) {\n            cout &lt;&lt; i &lt;&lt; \" \";\n        }\n        cout &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Company/meta/#9-palindrome-number","title":"9. Palindrome Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return true if the given number is a palindrome. Otherwise, return false.\n\"\"\"\n\n\n# Reverse\ndef isPalindromeReverse(x: int) -&gt; bool:\n    if x &lt; 0:\n        return False\n\n    return str(x) == str(x)[::-1]\n\n\n# Left Right Pointers\ndef isPalindromeLR(x: int) -&gt; bool:\n    if x &lt; 0:\n        return False\n\n    x = list(str(x))  # 121 -&gt; ['1', '2', '1']\n\n    left, right = 0, len(x) - 1\n\n    while left &lt; right:\n        if x[left] != x[right]:\n            return False\n        left += 1\n        right -= 1\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |  Reverse   |  O(N)  |   O(N)  |\n# | Left Right |  O(N)  |   O(1)  |\n# |------------|--------|---------|\n\n\nx = 121\nprint(isPalindromeReverse(x))  # True\nprint(isPalindromeLR(x))  # True\n</code></pre>"},{"location":"Company/microsoft/","title":"Microsoft","text":""},{"location":"Company/microsoft/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1. Two Sum (Easy)</li> <li> 121. Best Time to Buy and Sell Stock (Easy)</li> <li> 88. Merge Sorted Array (Easy)</li> <li> 3. Longest Substring Without Repeating Characters (Medium)</li> <li> 15. 3Sum (Medium)</li> <li> 2. Add Two Numbers (Medium)</li> <li> 146. LRU Cache (Medium)</li> <li> 169. Majority Element (Easy)</li> <li> 14. Longest Common Prefix (Easy)</li> <li> 9. Palindrome Number (Easy)</li> <li> 56. Merge Intervals (Medium)</li> <li> 162. Find Peak Element (Medium)</li> <li> 42. Trapping Rain Water (Hard)</li> <li> 5. Longest Palindromic Substring (Medium)</li> <li> 4. Median of Two Sorted Arrays (Hard)</li> <li> 70. Climbing Stairs (Easy)</li> <li> 53. Maximum Subarray (Medium)</li> <li> 49. Group Anagrams (Medium)</li> <li> 48. Rotate Image (Medium)</li> <li> 224. Basic Calculator (Hard)</li> <li> 283. Move Zeroes (Easy)</li> <li> 75. Sort Colors (Medium)</li> <li> 51. N-Queens (Hard)</li> <li> 206. Reverse Linked List (Easy)</li> <li> 35. Search Insert Position (Easy)</li> <li> 11. Container With Most Water (Medium)</li> <li> 13. Roman to Integer (Easy)</li> <li> 21. Merge Two Sorted Lists (Easy)</li> <li> 200. Number of Islands (Medium)</li> <li> 20. Valid Parentheses (Easy)</li> </ul>"},{"location":"Company/microsoft/#1-two-sum","title":"1. Two Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return the indices of the two numbers such that they add up to a specific target.\n- Approach: Use a hashmap to store the indices of the numbers.\n- Time Complexity: O(n)\n- Space Complexity: O(n)\n\"\"\"\n\nfrom typing import List\n\n\ndef two_sum(nums: List[int], target: int) -&gt; List[int]:\n    hashmap = {}  # val: idx\n\n    for idx, val in enumerate(nums):\n        if (target - val) in hashmap:\n            return [hashmap[target - val], idx]\n\n        hashmap[val] = idx\n\n    return []\n\n\ndef test_two_sum():\n    assert two_sum([2, 7, 11, 15], 9) == [0, 1]\n    assert two_sum([3, 2, 4], 6) == [1, 2]\n    assert two_sum([3, 3], 6) == [0, 1]\n    assert two_sum([1, 2, 3, 4, 5], 10) == []\n    assert two_sum([-1, -2, -3, -4, -5], -8) == [2, 4]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Solution {\n   public:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {\n        unordered_map&lt;int, int&gt; map;\n\n        for (size_t i = 0; i &lt; nums.size(); i++) {\n            int diff = target - nums[i];\n            if (map.find(diff) != map.end()) {\n                return {map[diff], (int)i};\n            }\n            map[nums[i]] = (int)i;\n        }\n        return {-1, -1};\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; nums = {2, 7, 11, 15};\n    int target = 9;\n    vector&lt;int&gt; result = solution.twoSum(nums, target);\n    assert((result == vector&lt;int&gt;{0, 1}));\n    return 0;\n}\n</code></pre>"},{"location":"Company/microsoft/#121-best-time-to-buy-and-sell-stock","title":"121. Best Time to Buy and Sell Stock","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return the maximum profit that can be achieved from buying on one day and selling on another day.\n\"\"\"\n\nfrom typing import List\n\n\n# Brute Force\ndef maxProfitBF(prices: List[int]) -&gt; int:\n    max_profit = 0\n    n = len(prices)\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_profit = max(max_profit, prices[j] - prices[i])\n\n    return max_profit\n\n\n# DP\ndef maxProfitDP(prices: List[int]) -&gt; int:\n    dp = [[0] * 2 for _ in range(len(prices))]\n    dp[0][0] = -prices[0]  # buy\n    dp[0][1] = 0  # sell\n\n    for i in range(1, len(prices)):\n        dp[i][0] = max(dp[i - 1][0], -prices[i])  # the lowest price to buy\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    max_profit = 0\n    seen_min = prices[0]\n\n    for i in range(1, len(prices)):\n        max_profit = max(max_profit, prices[i] - seen_min)\n        seen_min = min(seen_min, prices[i])\n\n    return max_profit\n\n\n# Fast Slow Pointers\ndef maxProfitFS(prices: List[int]) -&gt; int:\n    max_profit = 0\n    slow, fast = 0, 1\n\n    while fast &lt; len(prices):\n        if prices[fast] &gt; prices[slow]:\n            max_profit = max(max_profit, prices[fast] - prices[slow])\n        else:\n            slow = fast\n        fast += 1\n\n    return max_profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force|  O(n^2)|  O(1)   |\n# | DP         |  O(n)  |  O(n)   |\n# | Greedy     |  O(n)  |  O(1)   |\n# | Fast Slow  |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitBF(prices))  # 5\nprint(maxProfitDP(prices))  # 5\nprint(maxProfitGreedy(prices))  # 5\nprint(maxProfitFS(prices))  # 5\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int maxProfitMemo(vector&lt;int&gt; &amp;prices) {\n        if (prices.size() &lt;= 1) return 0;\n\n        int seen_min = prices[0];\n        int res = 0;\n\n        for (int &amp;price : prices) {\n            res = max(res, price - seen_min);\n            seen_min = min(seen_min, price);\n        }\n        return res;\n    }\n};\n\nint main() {\n    vector&lt;int&gt; prices = {7, 1, 5, 3, 6, 4};\n    Solution obj;\n    cout &lt;&lt; obj.maxProfitMemo(prices) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"Company/microsoft/#88-merge-sorted-array","title":"88. Merge Sorted Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Sorting</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\nclass merge:\n    @staticmethod\n    def lr(nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None:\n        \"\"\"\n        Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        p1, p2, t = m - 1, n - 1, m + n - 1\n\n        while p1 &gt;= 0 or p2 &gt;= 0:\n            if p1 == -1:\n                nums1[t] = nums2[p2]\n                p2 -= 1\n            elif p2 == -1:\n                nums1[t] = nums1[p1]\n                p1 -= 1\n            elif nums1[p1] &gt; nums2[p2]:\n                nums1[t] = nums1[p1]\n                p1 -= 1\n            else:\n                nums1[t] = nums2[p2]\n                p2 -= 1\n\n            t -= 1\n\n\nif __name__ == \"__main__\":\n    nums1 = [1, 2, 3, 0, 0, 0]\n    m = 3\n    nums2 = [2, 5, 6]\n    n = 3\n    merge.lr(nums1, m, nums2, n)\n    assert nums1 == [1, 2, 2, 3, 5, 6]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {\n        int p1 = m - 1, p2 = n - 1, t = m + n - 1;\n\n        while (p1 &gt;= 0 || p2 &gt;= 0) {\n            if (p1 == -1) {\n                nums1[t] = nums2[p2];\n                p2--;\n            } else if (p2 == -1) {\n                nums1[t] = nums1[p1];\n                p1--;\n            } else if (nums1[p1] &gt; nums2[p2]) {\n                nums1[t] = nums1[p1];\n                p1--;\n            } else {\n                nums1[t] = nums2[p2];\n                p2--;\n            }\n            t--;\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; nums1 = {1, 3, 6, 0, 0, 0};\n    vector&lt;int&gt; nums2 = {2, 5, 6};\n    vector&lt;int&gt; output = {1, 2, 3, 5, 6, 6};\n    solution.merge(nums1, 3, nums2, 3);\n    assert(nums1 == output);\n    return 0;\n}\n</code></pre>"},{"location":"Company/microsoft/#3-longest-substring-without-repeating-characters","title":"3. Longest Substring Without Repeating Characters","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Classic variable sliding window problem. Use a set to keep track of the characters in the current window.\n- Return the length of the longest substring without repeating characters.\n- [Template tutorial by \u7075\u5c71\u8336\u827e\u5e9c](https://leetcode.cn/problems/longest-substring-without-repeating-characters/solutions/1959540/xia-biao-zong-suan-cuo-qing-kan-zhe-by-e-iaks)\n\"\"\"\n\nfrom collections import defaultdict\n\n\n# Sliding Window Variable Max - HashMap\ndef lengthOfLongestSubstringHash(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    left = 0\n    cnt = defaultdict(int)\n    res = 0\n\n    for right in range(n):\n        cnt[s[right]] += 1\n\n        while cnt[s[right]] &gt; 1:\n            cnt[s[left]] -= 1\n            left += 1\n\n        res = max(res, right - left + 1)\n\n    return res\n\n\n# Sliding Window Variable Max - Set\ndef lengthOfLongestSubstringSet(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    left = 0\n    res = 0\n    window = set()\n\n    for right in range(n):\n        while left &lt; right and s[right] in window:\n            window.remove(s[left])\n            left += 1\n        window.add(s[right])\n        res = max(res, right - left + 1)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    s = \"abcabcbb\"\n    assert lengthOfLongestSubstringHash(s) == 3\n    assert lengthOfLongestSubstringSet(s) == 3\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;unordered_set&gt;\nusing namespace std;\n\nint lengthOfLongestSubstring(string s) {\n    int n = s.length();\n    int res = 0;\n    int left = 0;\n    unordered_set&lt;char&gt; window;\n\n    for (int right = 0; right &lt; n; right++) {\n        char ch = s[right];\n\n        while (window.find(ch) != window.end()) {\n            window.erase(s[left]);\n            left++;\n        }\n\n        window.insert(ch);\n        res = max(res, right - left + 1);\n    }\n    return (int)res;\n}\n\nint main() {\n    string s = \"abcabcbb\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 3\n    s = \"bbbbb\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 1\n    s = \"pwwkew\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 3\n    return 0;\n}\n</code></pre>"},{"location":"Company/microsoft/#15-3sum","title":"15. 3Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Sorting</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef threeSum(nums: List[int]) -&gt; List[List[int]]:\n    nums.sort()\n    res = []\n    n = len(nums)\n\n    for i in range(n - 2):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        left, right = i + 1, n - 1\n\n        while left &lt; right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total &gt; 0:\n                right -= 1\n            elif total &lt; 0:\n                left += 1\n            else:\n                res.append([nums[i], nums[left], nums[right]])\n\n                while left &lt; right and nums[left] == nums[left + 1]:\n                    left += 1\n\n                while left &lt; right and nums[right] == nums[right - 1]:\n                    right -= 1\n\n                left += 1\n                right -= 1\n\n    return res\n\n\nnums = [-1, 0, 1, 2, -1, -4]\nassert threeSum(nums) == [[-1, -1, 2], [-1, 0, 1]]\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {\n    sort(nums.begin(), nums.end());\n    vector&lt;vector&lt;int&gt;&gt; res;\n    int n = nums.size();\n\n    for (int i = 0; i &lt; n - 2; i++) {\n        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) {\n            continue;\n        }\n\n        int left = i + 1, right = n - 1;\n\n        while (left &lt; right) {\n            int total = nums[i] + nums[left] + nums[right];\n\n            if (total &gt; 0)\n                right--;\n            else if (total &lt; 0)\n                left++;\n            else {\n                res.push_back({nums[i], nums[left], nums[right]});\n                while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++;\n                while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--;\n                left++;\n                right--;\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {-1, 0, 1, 2, -1, -4};\n    vector&lt;vector&lt;int&gt;&gt; res = threeSum(nums);\n    for (auto&amp; v : res) {\n        for (int i : v) {\n            cout &lt;&lt; i &lt;&lt; \" \";\n        }\n        cout &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Company/microsoft/#2-add-two-numbers","title":"2. Add Two Numbers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Math, Recursion</p> </li> </ul> PythonCPP <pre><code>from typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\ndef add_two_numbers(l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]:\n    \"\"\"Add two numbers represented by linked lists.\"\"\"\n    dummy = ListNode()\n    cur = dummy\n    carry = 0\n\n    while l1 or l2:\n        v1 = l1.val if l1 else 0\n        v2 = l2.val if l2 else 0\n\n        carry, val = divmod(v1 + v2 + carry, 10)\n        cur.next = ListNode(val)\n        cur = cur.next\n\n        if l1:\n            l1 = l1.next\n        if l2:\n            l2 = l2.next\n\n    if carry:\n        cur.next = ListNode(val=carry)\n\n    return dummy.next\n\n\ndef test_add_two_numbers():\n    l1 = LinkedList([2, 4, 3]).head\n    l2 = LinkedList([5, 6, 4]).head\n    added = add_two_numbers(l1, l2)\n    assert LinkedList(added).to_array() == [7, 0, 8]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode* next) : val(x), next(next) {}\n};\n\nclass Solution {\n   public:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode dummy;\n        ListNode* cur = &amp;dummy;\n        int carry = 0;\n\n        while (l1 || l2 || carry) {\n            if (l1) {\n                carry += l1-&gt;val;\n                l1 = l1-&gt;next;\n            }\n            if (l2) {\n                carry += l2-&gt;val;\n                l2 = l2-&gt;next;\n            }\n            cur-&gt;next = new ListNode(carry % 10);\n            cur = cur-&gt;next;\n            carry /= 10;\n        }\n        return dummy.next;\n    }\n};\n\nint main() {\n    Solution sol;\n\n    ListNode* l1 = new ListNode(2, new ListNode(4, new ListNode(3)));\n    ListNode* l2 = new ListNode(5, new ListNode(6, new ListNode(4)));\n    ListNode* result = sol.addTwoNumbers(l1, l2);\n\n    vector&lt;int&gt; expected = {7, 0, 8};\n    for (int val : expected) {\n        assert(result != nullptr &amp;&amp; result-&gt;val == val);\n        result = result-&gt;next;\n    }\n    assert(result == nullptr);  // End of list\n\n    return 0;\n}\n</code></pre>"},{"location":"Company/microsoft/#146-lru-cache","title":"146. LRU Cache","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Linked List, Design, Doubly Linked List</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Design and implement a data structure for **Least Recently Used (LRU) cache**. It should support the following operations: get and put.\n- [lru](https://media.geeksforgeeks.org/wp-content/uploads/20240909142802/Working-of-LRU-Cache-copy-2.webp)\n- ![146](https://miro.medium.com/v2/resize:fit:650/0*fOwBd3z0XtHh7WN1.png)\n\n| Data structure     | Description                   |\n| ------------------ | ----------------------------- |\n| Doubly Linked List | To store the key-value pairs. |\n| Hash Map           | To store the key-node pairs.  |\n\"\"\"\n\nfrom collections import OrderedDict\n\n\n# Doubly Linked List\nclass Node:\n    def __init__(self, key=0, val=0):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.cache = {}\n        self.head = Node()\n        self.tail = Node()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def add_to_last(self, node):\n        self.tail.prev.next = node\n        node.prev = self.tail.prev\n        node.next = self.tail\n        self.tail.prev = node\n\n    def move_to_last(self, node):\n        self.remove(node)\n        self.add_to_last(node)\n\n    def get(self, key: int) -&gt; int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self.move_to_last(node)\n        return node.val\n\n    def put(self, key: int, value: int) -&gt; None:\n        if key in self.cache:\n            node = self.cache[key]\n            node.val = value\n            self.move_to_last(node)\n            return None\n\n        if len(self.cache) == self.cap:\n            del self.cache[self.head.next.key]\n            self.remove(self.head.next)\n\n        node = Node(key=key, val=value)\n        self.cache[key] = node\n        self.add_to_last(node)\n\n\n# OrderedDict\nclass LRUCacheOrderedDict:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.cap = capacity\n\n    def get(self, key: int):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key, last=True)\n        return self.cache[key]\n\n    def put(self, key: int, value: int):\n        if key in self.cache:\n            self.cache.move_to_end(key, last=True)\n        elif len(self.cache) &gt;= self.cap:\n            self.cache.popitem(last=False)\n\n        self.cache[key] = value\n\n\ncache = LRUCache(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\n\ncache = LRUCacheOrderedDict(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\nprint(\"LRU Cache passed\")\nprint(\"LRU Cache Ordered Dict passed\")\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nclass Node {\n   public:\n    int key;\n    int val;\n    Node *prev;\n    Node *next;\n\n    Node(int k = 0, int v = 0) : key(k), val(v), prev(nullptr), next(nullptr) {}\n};\n\nclass LRUCache {\n   private:\n    int cap;\n    unordered_map&lt;int, Node *&gt; cache;\n    Node *head;\n    Node *tail;\n\n    void remove(Node *node) {\n        node-&gt;prev-&gt;next = node-&gt;next;\n        node-&gt;next-&gt;prev = node-&gt;prev;\n    }\n\n    void insert_to_last(Node *node) {\n        tail-&gt;prev-&gt;next = node;\n        node-&gt;prev = tail-&gt;prev;\n        tail-&gt;prev = node;\n        node-&gt;next = tail;\n    }\n\n    void move_to_last(Node *node) {\n        remove(node);\n        insert_to_last(node);\n    }\n\n   public:\n    LRUCache(int capacity) {\n        this-&gt;cap = capacity;\n        head = new Node();\n        tail = new Node();\n        head-&gt;next = tail;\n        tail-&gt;prev = head;\n    }\n\n    int get(int key) {\n        if (cache.find(key) != cache.end()) {\n            Node *node = cache[key];\n            move_to_last(node);\n            return node-&gt;val;\n        }\n        return -1;\n    }\n\n    void put(int key, int value) {\n        if (cache.find(key) != cache.end()) {\n            Node *node = cache[key];\n            node-&gt;val = value;\n            move_to_last(node);\n        } else {\n            Node *newNode = new Node(key, value);\n            cache[key] = newNode;\n            insert_to_last(newNode);\n\n            if ((int)cache.size() &gt; cap) {\n                Node *removed = head-&gt;next;\n                remove(removed);\n                cache.erase(removed-&gt;key);\n                delete removed;\n            }\n        }\n    }\n};\n\nint main() {\n    LRUCache lru(2);\n    lru.put(1, 1);\n    lru.put(2, 2);\n    assert(lru.get(1) == 1);   // returns 1\n    lru.put(3, 3);             // evicts key 2\n    assert(lru.get(2) == -1);  // returns -1 (not found)\n    lru.put(4, 4);             // evicts key 1\n    assert(lru.get(1) == -1);  // returns -1 (not found)\n    assert(lru.get(3) == 3);   // returns 3\n    assert(lru.get(4) == 4);   // returns 4\n    return 0;\n}\n</code></pre>"},{"location":"Company/microsoft/#169-majority-element","title":"169. Majority Element","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Divide And Conquer, Sorting, Counting</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the majority element in an array. The majority element is the element that appears more than `n // 2` times.\n\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/7pnhv842keE?si=fBYlNfKzdkiLgkF1\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen&gt;&lt;/iframe&gt;\n\n| `num` | `count` | `res` |\n| ----- | ------- | ----- |\n| 2     | 1       | 2     |\n| 2     | 2       | 2     |\n| 1     | 1       | 2     |\n| 1     | 0       | 2     |\n| 1     | 1       | 1     |\n| 2     | 0       | 1     |\n| 2     | 1       | 2     |\n\"\"\"\n\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Hash Map\ndef majorityElementHashMap(nums: List[int]) -&gt; int:\n    n = len(nums)\n    freq = defaultdict(int)\n\n    for num in nums:\n        freq[num] += 1\n        if freq[num] &gt; n // 2:\n            return num\n\n\n# Array - Boyer-Moore Voting Algorithm\ndef majorityElementArray(nums: List[int]) -&gt; int:\n    res = None\n    count = 0\n\n    for num in nums:\n        if count == 0:\n            res = num\n        count += 1 if num == res else -1\n\n    return res\n\n\n# | Algorithm | Time Complexity | Space Complexity |\n# |-----------|-----------------|------------------|\n# | HashMap   | O(N)            | O(N)             |\n# | Array     | O(N)            | O(1)             |\n# |-----------|-----------------|------------------|\n\n\nnums = [2, 2, 1, 1, 1, 2, 2]\nprint(majorityElementArray(nums))  # 2\nprint(majorityElementHashMap(nums))  # 2\n</code></pre>"},{"location":"Company/microsoft/#14-longest-common-prefix","title":"14. Longest Common Prefix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Trie</p> </li> </ul> Python <pre><code>from typing import List\n\n\nclass longestCommonPrefix:\n    def horizontal_scan(self, strs: List[str]) -&gt; str:\n        if not strs:\n            return \"\"\n\n        prefix = strs[0]\n        for i in range(1, len(strs)):\n            while not strs[i].startswith(prefix):\n                prefix = prefix[:-1]\n                if not prefix:\n                    return \"\"\n\n        return prefix\n\n    def vertical_scan(self, strs: List[str]) -&gt; str:\n        if not strs:\n            return \"\"\n\n        for i in range(len(strs[0])):\n            char = strs[0][i]\n            for j in range(1, len(strs)):\n                if i &gt;= len(strs[j]) or strs[j][i] != char:\n                    return strs[0][:i]\n\n        return strs[0]\n\n    def divide_conquer(self, strs: List[str]) -&gt; str:\n        if not strs:\n            return \"\"\n\n        def merge(left, right):\n            n = min(len(left), len(right))\n            for i in range(n):\n                if left[i] != right[i]:\n                    return left[:i]\n            return left[:n]\n\n        def find(strs, start, end):\n            if start == end:\n                return strs[start]\n            mid = start + (end - start) // 2\n            left = find(strs, start, mid)\n            right = find(strs, mid + 1, end)\n            return merge(left, right)\n\n        return find(strs, 0, len(strs) - 1)\n\n    def binary_search(self, strs: List[str]) -&gt; str:\n        if not strs:\n            return \"\"\n\n        def isCommonPrefix(strs, length):\n            prefix = strs[0][:length]\n            return all(s.startswith(prefix) for s in strs)\n\n        minLen = min(len(s) for s in strs)\n        low, high = 0, minLen\n        while low &lt; high:\n            mid = low + (high - low) // 2\n            if isCommonPrefix(strs, mid + 1):\n                low = mid + 1\n            else:\n                high = mid\n\n        return strs[0][:low]\n\n\nif __name__ == \"__main__\":\n    solution = longestCommonPrefix()\n    strs = [\"flower\", \"flow\", \"flight\"]\n    assert solution.horizontal_scan(strs) == \"fl\"\n    assert solution.vertical_scan(strs) == \"fl\"\n    assert solution.divide_conquer(strs) == \"fl\"\n    assert solution.binary_search(strs) == \"fl\"\n</code></pre>"},{"location":"Company/microsoft/#9-palindrome-number","title":"9. Palindrome Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return true if the given number is a palindrome. Otherwise, return false.\n\"\"\"\n\n\n# Reverse\ndef isPalindromeReverse(x: int) -&gt; bool:\n    if x &lt; 0:\n        return False\n\n    return str(x) == str(x)[::-1]\n\n\n# Left Right Pointers\ndef isPalindromeLR(x: int) -&gt; bool:\n    if x &lt; 0:\n        return False\n\n    x = list(str(x))  # 121 -&gt; ['1', '2', '1']\n\n    left, right = 0, len(x) - 1\n\n    while left &lt; right:\n        if x[left] != x[right]:\n            return False\n        left += 1\n        right -= 1\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |  Reverse   |  O(N)  |   O(N)  |\n# | Left Right |  O(N)  |   O(1)  |\n# |------------|--------|---------|\n\n\nx = 121\nprint(isPalindromeReverse(x))  # True\nprint(isPalindromeLR(x))  # True\n</code></pre>"},{"location":"Company/microsoft/#56-merge-intervals","title":"56. Merge Intervals","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sorting</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Merge all overlapping intervals.\n\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/44H3cEC2fFM?si=J-Jr_Fg2eDse3-de\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen&gt;&lt;/iframe&gt;\n\"\"\"\n\nfrom typing import List\n\n\n# Intervals\ndef merge(intervals: List[List[int]]) -&gt; List[List[int]]:\n    n = len(intervals)\n    if n &lt;= 1:\n        return intervals\n\n    intervals.sort(key=lambda x: x[0])\n    res = [intervals[0]]\n\n    for i in range(1, n):\n        if intervals[i][0] &lt;= res[-1][1]:\n            res[-1][1] = max(res[-1][1], intervals[i][1])\n        else:\n            res.append(intervals[i])\n\n    return res\n\n\nprint(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))\n# [[1, 6], [8, 10], [15, 18]]\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// Interval\nvector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {\n    sort(intervals.begin(), intervals.end());\n    vector&lt;vector&lt;int&gt;&gt; res;\n\n    for (auto&amp; range : intervals) {\n        if (!res.empty() &amp;&amp; range[0] &lt;= res.back()[1]) {\n            res.back()[1] = max(res.back()[1], range[1]);\n        } else {\n            res.emplace_back(range);\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;vector&lt;int&gt;&gt; intervals = {{1, 3}, {2, 6}, {8, 10}, {15, 18}};\n    vector&lt;vector&lt;int&gt;&gt; res = merge(intervals);\n    for (auto&amp; range : res) {\n        cout &lt;&lt; range[0] &lt;&lt; \", \" &lt;&lt; range[1] &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Company/microsoft/#162-find-peak-element","title":"162. Find Peak Element","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul>"},{"location":"Company/microsoft/#42-trapping-rain-water","title":"42. Trapping Rain Water","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Dynamic Programming, Stack, Monotonic Stack</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- ![42](../../assets/0042.png)\n\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/ZI2z5pq0TqA?si=OEYg01dbmzvmtIwZ\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen&gt;&lt;/iframe&gt;\n\n| Approach   | Time | Space |\n| ---------- | ---- | ----- |\n| DP         | O(N) | O(N)  |\n| Left Right | O(N) | O(1)  |\n| Monotonic  | O(N) | O(N)  |\n\"\"\"\n\nfrom typing import List\n\n\n# DP\ndef trapDP(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    n = len(height)\n    maxLeft, maxRight = [0 for _ in range(n)], [0 for _ in range(n)]\n\n    for i in range(1, n):\n        maxLeft[i] = max(maxLeft[i - 1], height[i - 1])\n\n    for i in range(n - 2, -1, -1):\n        maxRight[i] = max(maxRight[i + 1], height[i + 1])\n\n    res = 0\n    for i in range(n):\n        res += max(0, min(maxLeft[i], maxRight[i]) - height[i])\n\n    return res\n\n\n# Left Right Pointers\ndef trapLR(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    left, right = 0, len(height) - 1\n    maxL, maxR = height[left], height[right]\n    res = 0\n\n    while left &lt; right:\n        if maxL &lt; maxR:\n            left += 1\n            maxL = max(maxL, height[left])\n            res += maxL - height[left]\n        else:\n            right -= 1\n            maxR = max(maxR, height[right])\n            res += maxR - height[right]\n\n    return res\n\n\n# Monotonic Stack\ndef trapStack(height: List[int]) -&gt; int:\n    stack = []\n    total = 0\n\n    for i in range(len(height)):\n        while stack and height[i] &gt; height[stack[-1]]:\n            top = stack.pop()\n            if not stack:\n                break\n            distance = i - stack[-1] - 1\n            bounded_height = min(height[i], height[stack[-1]]) - height[top]\n            total += distance * bounded_height\n        stack.append(i)\n\n    return total\n\n\nheight = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\nprint(trapDP(height))  # 6\nprint(trapLR(height))  # 6\nprint(trapStack(height))  # 6\n</code></pre> <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int trap(vector&lt;int&gt; &amp;height)\n    {\n        if (height.empty())\n            return 0;\n\n        int res = 0;\n        int left = 0, right = height.size() - 1;\n        int maxL = height[left], maxR = height[right];\n\n        while (left &lt; right)\n        {\n            if (maxL &lt; maxR)\n            {\n                left++;\n                maxL = max(maxL, height[left]);\n                res += maxL - height[left];\n            }\n            else\n            {\n                right--;\n                maxR = max(maxR, height[right]);\n                res += maxR - height[right];\n            }\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    vector&lt;int&gt; height = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};\n    Solution solution;\n    cout &lt;&lt; solution.trap(height) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"Company/microsoft/#5-longest-palindromic-substring","title":"5. Longest Palindromic Substring","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Dynamic Programming</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the longest palindromic substring in `s`.\n\"\"\"\n\n\n# DP - Interval\ndef longestPalindromeDP(s: str) -&gt; str:\n    n = len(s)\n    if n &lt;= 1:\n        return s\n\n    start, maxLen = 0, 1\n\n    # Init\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for j in range(1, n):\n        for i in range(j):\n            if s[i] == s[j]:\n                if j - i &lt;= 2:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1]\n\n                if dp[i][j] and j - i + 1 &gt; maxLen:\n                    maxLen = j - i + 1\n                    start = i\n\n    return s[start : start + maxLen]\n\n\n# Expand Around Center\ndef longestPalindromeCenter(s: str) -&gt; str:\n    def expand_around_center(left, right):\n        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n\n    if len(s) &lt;= 1:\n        return s\n\n    start, end = 0, 0\n    for i in range(len(s)):\n        len1 = expand_around_center(i, i)  # odd\n        len2 = expand_around_center(i, i + 1)  # even\n\n        maxLen = max(len1, len2)\n        if maxLen &gt; end - start:\n            start = i - (maxLen - 1) // 2\n            end = i + maxLen // 2\n\n    return s[start : end + 1]\n\n\ns = \"babad\"\nprint(longestPalindromeDP(s))  # \"bab\"\nprint(longestPalindromeCenter(s))  # \"aba\"\n</code></pre>"},{"location":"Company/microsoft/#4-median-of-two-sorted-arrays","title":"4. Median of Two Sorted Arrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Divide And Conquer</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Brute Force\ndef findMedianSortedArraysBF(nums1: List[int], nums2: List[int]) -&gt; float:\n    nums = sorted(nums1 + nums2)\n    n = len(nums)\n    if n % 2 == 0:\n        return (nums[n // 2 - 1] + nums[n // 2]) / 2\n    else:\n        return nums[n // 2]\n\n\n# Binary Search\ndef findMedianSortedArraysBS(nums1: List[int], nums2: List[int]) -&gt; float:\n    if len(nums1) &gt; len(nums2):\n        nums1, nums2 = nums2, nums1\n\n    m, n = len(nums1), len(nums2)\n    imin, imax, half_len = 0, m, (m + n + 1) // 2\n\n    while imin &lt;= imax:\n        i = (imin + imax) // 2\n        j = half_len - i\n\n        if i &lt; m and nums2[j - 1] &gt; nums1[i]:\n            imin = i + 1\n        elif i &gt; 0 and nums1[i - 1] &gt; nums2[j]:\n            imax = i - 1\n        else:\n            if i == 0:\n                max_of_left = nums2[j - 1]\n            elif j == 0:\n                max_of_left = nums1[i - 1]\n            else:\n                max_of_left = max(nums1[i - 1], nums2[j - 1])\n\n            if (m + n) % 2 == 1:\n                return max_of_left\n\n            if i == m:\n                min_of_right = nums2[j]\n            elif j == n:\n                min_of_right = nums1[i]\n            else:\n                min_of_right = min(nums1[i], nums2[j])\n\n            return (max_of_left + min_of_right) / 2\n\n\n# |--------------|-----------------|--------------|\n# | Approach     | Time            | Space        |\n# |--------------|-----------------|--------------|\n# | Brute Force  | O((n+m)log(n+m))| O(n+m)       |\n# | Binary Search| O(log(min(n,m)))| O(1)         |\n# |--------------|-----------------|--------------|\n\n\nnums1 = [1, 3]\nnums2 = [2]\nprint(findMedianSortedArraysBF(nums1, nums2))  # 2.0\nprint(findMedianSortedArraysBS(nums1, nums2))  # 2.0\n</code></pre>"},{"location":"Company/microsoft/#70-climbing-stairs","title":"70. Climbing Stairs","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Memoization</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return the number of distinct ways to reach the top of the stairs.\n- `dp[n]` stores the number of distinct ways to reach the `n-th` stair.\n- Formula: `dp[n] = dp[n - 1] + dp[n - 2]`.\n- Initialize `dp[0] = 0`, `dp[1] = 1`, and `dp[2] = 2`.\n\"\"\"\n\nfrom functools import cache\n\n\n# DP\ndef climbStairsDP(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    dp = [i for i in range(n + 1)]\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\n# DP (Optimized)\ndef climbStairsDPOptimized(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    first, second = 1, 2\n\n    for _ in range(3, n + 1):\n        first, second = second, first + second\n\n    return second\n\n\n# Recursion\ndef climbStairsRecursion(n: int) -&gt; int:\n    @cache\n    def dfs(i: int) -&gt; int:\n        if i &lt;= 1:\n            return 1\n        return dfs(i - 1) + dfs(i - 2)\n\n    return dfs(n)\n\n\n# Greedy\ndef climbStairsGreedy(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    p1, p2 = 1, 2\n\n    for _ in range(3, n + 1):\n        p1, p2 = p2, p1 + p2\n\n    return p2\n\n\nif __name__ == \"__main__\":\n    assert climbStairsDP(10) == 89\n    assert climbStairsDPOptimized(10) == 89\n    assert climbStairsRecursion(10) == 89\n    assert climbStairsGreedy(10) == 89\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nint climbStairs(int n) {\n    if (n &lt;= 2) return n;\n    int f1 = 1, f2 = 2;\n    int res;\n\n    int i = 3;\n    while (i &lt;= n) {\n        res = f1 + f2;\n        f1 = f2;\n        f2 = res;\n        i++;\n    }\n    return res;\n}\n\nint main() {\n    assert(climbStairs(2) == 2);\n    assert(climbStairs(5) == 8);\n    assert(climbStairs(10) == 89);\n    return 0;\n}\n</code></pre>"},{"location":"Company/microsoft/#53-maximum-subarray","title":"53. Maximum Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Divide And Conquer, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP Kadane\ndef maxSubArrayDP(nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n\n    dp[0] = nums[0]\n    maxSum = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(\n            dp[i - 1] + nums[i],  # continue the previous subarray\n            nums[i],  # start a new subarray\n        )\n        maxSum = max(maxSum, dp[i])\n\n    return maxSum\n\n\n# Greedy\ndef maxSubArrayGreedy(nums: List[int]) -&gt; int:\n    max_sum = nums[0]\n    cur_sum = 0\n\n    for num in nums:\n        cur_sum = max(cur_sum + num, num)\n        max_sum = max(max_sum, cur_sum)\n\n    return max_sum\n\n\n# Prefix Sum\ndef maxSubArrayPrefixSum(nums: List[int]) -&gt; int:\n    prefix_sum = 0\n    prefix_sum_min = 0\n    res = float(\"-inf\")\n\n    for num in nums:\n        prefix_sum += num\n        res = max(res, prefix_sum - prefix_sum_min)\n        prefix_sum_min = min(prefix_sum_min, prefix_sum)\n\n    return res\n\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArrayDP(nums))  # 6\nprint(maxSubArrayGreedy(nums))  # 6\nprint(maxSubArrayPrefixSum(nums))  # 6\n</code></pre>"},{"location":"Company/microsoft/#49-group-anagrams","title":"49. Group Anagrams","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Sorting</p> </li> </ul> PythonCPP <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash - List\ndef groupAnagrams(strs: List[str]) -&gt; List[List[str]]:\n    result = defaultdict(list)\n\n    for s in strs:\n        count = [0] * 26\n        for i in s:\n            count[ord(i) - ord(\"a\")] += 1\n\n        result[tuple(count)].append(s)\n\n    return list(result.values())\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Hash     |     O(n * k)    |     O(n)     |\n# |-------------|-----------------|--------------|\n\n\nstrs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\nprint(groupAnagrams(strs))\n# [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;cassert&gt;\n#include &lt;ranges&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Solution {\n   public:\n    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) {\n        unordered_map&lt;string, vector&lt;string&gt;&gt; map;\n\n        for (string&amp; s : strs) {\n            string sorted = s;\n            ranges::sort(sorted);\n            map[sorted].push_back(s);\n        }\n\n        vector&lt;vector&lt;string&gt;&gt; res;\n\n        for (auto&amp; kv : map) {\n            res.push_back(kv.second);\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;string&gt; strs = {\"eat\", \"tea\", \"tan\"};\n    vector&lt;vector&lt;string&gt;&gt; res = solution.groupAnagrams(strs);\n    assert((res == vector&lt;vector&lt;string&gt;&gt;{{\"eat\", \"tea\"}, {\"tan\"}} ||\n            res == vector&lt;vector&lt;string&gt;&gt;{{\"tan\"}, {\"eat\", \"tea\"}}));\n\n    return 0;\n}\n</code></pre>"},{"location":"Company/microsoft/#48-rotate-image","title":"48. Rotate Image","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Matrix</p> </li> </ul> Python <pre><code>from copy import deepcopy\nfrom typing import List\n\n\n# Math\ndef rotate1(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    n = len(matrix)\n\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n\n\ndef rotate2(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    n = len(matrix)\n    for i in range(n):\n        for j in range(i, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\n    for i in range(n):\n        matrix[i].reverse()\n\n\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nprint(matrix)\n# [[1, 2, 3],\n#  [4, 5, 6],\n#  [7, 8, 9]]\nmatrix1 = deepcopy(matrix)\nrotate1(matrix1)\nprint(matrix1)\n# [[7, 4, 1],\n#  [8, 5, 2],\n#  [9, 6, 3]]\nmatrix2 = deepcopy(matrix)\nrotate2(matrix2)\nprint(matrix2)\n# [[7, 4, 1],\n#  [8, 5, 2],\n#  [9, 6, 3]]\n</code></pre>"},{"location":"Company/microsoft/#224-basic-calculator","title":"224. Basic Calculator","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String, Stack, Recursion</p> </li> </ul> Python <pre><code># Stack\ndef calculate(s: str) -&gt; int:\n    stack = []\n    result = 0\n    number = 0\n    sign = 1\n\n    for char in s:\n        if char.isdigit():\n            number = number * 10 + int(char)\n\n        elif char == \"+\":\n            result += sign * number\n            number = 0\n            sign = 1\n        elif char == \"-\":\n            result += sign * number\n            number = 0\n            sign = -1\n\n        elif char == \"(\":\n            stack.append(result)\n            stack.append(sign)\n            result = 0\n            sign = 1\n        elif char == \")\":\n            result += sign * number\n            number = 0\n            result *= stack.pop()  # pop sign\n            result += stack.pop()  # pop previous result\n\n    result += sign * number\n\n    return result\n\n\nprint(calculate(\"(1+(4+5+2)-3)+(6+8)\"))  # 23\n</code></pre>"},{"location":"Company/microsoft/#283-move-zeroes","title":"283. Move Zeroes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Move all zeroes to the end of the array while maintaining the relative order of the non-zero elements.\n\"\"\"\n\nfrom typing import List\n\n\ndef moveZeroes(nums: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    fast, slow = 0, 0\n\n    while fast &lt; len(nums):\n        if nums[fast] != 0:\n            nums[slow], nums[fast] = nums[fast], nums[slow]\n            slow += 1\n        fast += 1\n\n\nnums = [0, 1, 0, 3, 12]\nmoveZeroes(nums)\nprint(nums)  # [1, 3, 12, 0, 0]\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvoid moveZeroes(vector&lt;int&gt;&amp; nums) {\n    size_t n = nums.size();\n    size_t fast = 0, slow = 0;\n\n    while (fast &lt; n) {\n        if (nums[fast] != 0) {\n            swap(nums[slow], nums[fast]);\n            slow++;\n        }\n        fast++;\n    }\n}\n\nint main() {\n    vector&lt;int&gt; nums = {0, 1, 0, 3, 12};\n    moveZeroes(nums);\n    // [1, 3, 12, 0, 0]\n    for (size_t i = 0; i &lt; nums.size(); i++) {\n        cout &lt;&lt; nums[i] &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"Company/microsoft/#75-sort-colors","title":"75. Sort Colors","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Sorting</p> </li> </ul> Python <pre><code>from copy import deepcopy\nfrom typing import List\n\n\n# Left Right Pointers\ndef sort_colors_lr_pointers(nums: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    n = len(nums)\n    left = 0\n    for right in range(n):\n        if nums[right] == 0:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n\n    for right in range(left, n):\n        if nums[right] == 1:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n\n\n# Three Pointers\ndef sort_colors_three_pointers(nums: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    cur = 0\n\n    while cur &lt;= right:\n        if nums[cur] == 0:\n            nums[left], nums[cur] = nums[cur], nums[left]\n            left += 1\n            cur += 1\n        elif nums[cur] == 2:\n            nums[right], nums[cur] = nums[cur], nums[right]\n            right -= 1\n        else:\n            cur += 1\n\n\nnums = [2, 0, 2, 1, 1, 0]\nnums1, nums2 = deepcopy(nums), deepcopy(nums)\nsort_colors_lr_pointers(nums1)\nprint(nums1)  # [0, 0, 1, 1, 2, 2]\nsort_colors_three_pointers(nums2)\nprint(nums2)  # [0, 0, 1, 1, 2, 2]\n</code></pre>"},{"location":"Company/microsoft/#51-n-queens","title":"51. N-Queens","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking</p> </li> </ul> Python <pre><code>\"\"\"\n- Hard\n- [N-Queens](https://leetcode.com/problems/n-queens/)\n- [N \u7687\u540e](https://leetcode.cn/problems/n-queens/)\n\"\"\"\n\nfrom typing import List\n\n\n# Backtracking\ndef solveNQueens(n: int) -&gt; List[List[str]]:\n    res = []\n    board = [\".\" * n for _ in range(n)]\n\n    def dfs(row):\n        if row == n:\n            res.append(board[:])\n            return None\n        for col in range(n):\n            if is_valid(row, col, board):\n                board[row] = board[row][:col] + \"Q\" + board[row][col + 1 :]\n                dfs(row + 1)\n                board[row] = board[row][:col] + \".\" + board[row][col + 1 :]\n\n    def is_valid(row, col, chessboard):\n        for i in range(row):\n            if chessboard[i][col] == \"Q\":\n                return False\n\n        i, j = row - 1, col - 1\n        while i &gt;= 0 and j &gt;= 0:\n            if chessboard[i][j] == \"Q\":\n                return False\n            i -= 1\n            j -= 1\n\n        i, j = row - 1, col + 1\n        while i &gt;= 0 and j &lt; len(chessboard):\n            if chessboard[i][j] == \"Q\":\n                return False\n            i -= 1\n            j += 1\n\n        return True\n\n    dfs(0)\n\n    return [[\"\".join(row) for row in i] for i in res]\n\n\n# Backtracking\ndef solveNQueens2(n: int) -&gt; List[List[str]]:\n    res = []\n    queens = [0] * n\n    col = [False] * n\n    diag1 = [False] * (n * 2 - 1)\n    diag2 = [False] * (n * 2 - 1)\n\n    def dfs(r: int) -&gt; None:\n        if r == n:\n            res.append([\".\" * c + \"Q\" + \".\" * (n - 1 - c) for c in queens])\n            return\n\n        for c, ok in enumerate(col):\n            if not ok and not diag1[r + c] and not diag2[r - c]:\n                queens[r] = c\n                col[c] = diag1[r + c] = diag2[r - c] = True\n                dfs(r + 1)\n                col[c] = diag1[r + c] = diag2[r - c] = False\n\n    dfs(0)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(solveNQueens(4))\n    # [['.Q..', '...Q', 'Q...', '..Q.'],\n    #  ['..Q.', 'Q...', '...Q', '.Q..']]\n    print(solveNQueens(1))\n    # [['Q']]\n    print(solveNQueens2(4))\n    # [['.Q..', '...Q', 'Q...', '..Q.'],\n    #  ['..Q.', 'Q...', '...Q', '.Q..']]\n    print(solveNQueens2(1))\n    # [['Q']]\n</code></pre>"},{"location":"Company/microsoft/#206-reverse-linked-list","title":"206. Reverse Linked List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Recursion</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\ndef reverse_list_iterative(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    cur = head\n    prev = None\n\n    while cur:\n        temp = cur.next\n        cur.next = prev\n\n        prev = cur\n        cur = temp\n\n    return prev\n\n\ndef reverse_list_recursive(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    def reverse(cur, prev):\n        if not cur:\n            return prev\n\n        temp = cur.next\n        cur.next = prev\n        return reverse(temp, cur)\n\n    return reverse(head, None)\n\n\ndef test_reverse_list():\n    ll = LinkedList([1, 2, 3, 4, 5])\n    ll.head = reverse_list_iterative(ll.head)\n    assert ll.to_array() == [5, 4, 3, 2, 1]\n\n    ll = LinkedList([1, 2, 3, 4, 5])\n    ll.head = reverse_list_recursive(ll.head)\n    assert ll.to_array() == [5, 4, 3, 2, 1]\n</code></pre>"},{"location":"Company/microsoft/#35-search-insert-position","title":"35. Search Insert Position","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return the index of the target if it is found. If not, return the index where it would be if it were inserted in order.\n\"\"\"\n\nfrom typing import List\n\n\n# Binary Search\ndef searchInsert(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        if nums[mid] &lt; target:\n            left = mid + 1\n        elif nums[mid] &gt; target:\n            right = mid - 1\n        else:\n            return mid\n\n    return left\n\n\nnums = [1, 3, 5, 6]\ntarget = 5\nprint(searchInsert(nums, target))  # 2\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int searchInsert(vector&lt;int&gt;&amp; nums, int target) {\n        int left = 0, right = nums.size() - 1;\n\n        while (left &lt;= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] &lt; target)\n                left = mid + 1;\n            else\n                right = mid - 1;\n        }\n        return left;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; nums = {1, 3, 5, 6};\n    assert(solution.searchInsert(nums, 5) == 2);\n    assert(solution.searchInsert(nums, 2) == 1);\n    assert(solution.searchInsert(nums, 7) == 4);\n    assert(solution.searchInsert(nums, 0) == 0);\n    return 0;\n}\n</code></pre>"},{"location":"Company/microsoft/#11-container-with-most-water","title":"11. Container With Most Water","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Greedy</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return the maximum area of water that can be trapped between the vertical lines.\n\n![11](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)\n\"\"\"\n\nfrom typing import List\n\n\n# Brute Force\ndef maxAreaBF(height: List[int]) -&gt; int:\n    max_area = 0\n\n    for i in range(len(height)):\n        for j in range(i + 1, len(height)):\n            h = min(height[i], height[j])\n            w = j - i\n            max_area = max(max_area, h * w)\n\n    return max_area\n\n\n# Left Right Pointers\ndef maxAreaLR(height: List[int]) -&gt; int:\n    left, right = 0, len(height) - 1\n    res = 0\n\n    while left &lt; right:\n        h = min(height[left], height[right])\n        w = right - left\n        res = max(res, h * w)\n\n        if height[left] &lt; height[right]:\n            left += 1\n        else:\n            right -= 1\n\n    return res\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force| O(n^2) |  O(1)   |\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nheight = [1, 8, 6, 2, 5, 4, 8, 3, 7]\nprint(maxAreaBF(height))  # 49\nprint(maxAreaLR(height))  # 49\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint maxArea(vector&lt;int&gt;&amp; height) {\n    int left = 0, right = height.size() - 1;\n    int res = 0;\n\n    while (left &lt; right) {\n        int h = min(height[left], height[right]);\n        int w = right - left;\n        res = max(res, h * w);\n\n        if (height[left] &lt; height[right])\n            left++;\n        else\n            right--;\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; height = {1, 8, 6, 2, 5, 4, 8, 3, 7};\n    cout &lt;&lt; maxArea(height) &lt;&lt; endl;  // 49\n    return 0;\n}\n</code></pre>"},{"location":"Company/microsoft/#13-roman-to-integer","title":"13. Roman to Integer","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Math, String</p> </li> </ul> Python <pre><code>from itertools import pairwise\n\n\n# Arrays\ndef romanToInt(s: str) -&gt; int:\n    ROMAN = {\n        \"I\": 1,\n        \"V\": 5,\n        \"X\": 10,\n        \"L\": 50,\n        \"C\": 100,\n        \"D\": 500,\n        \"M\": 1000,\n    }\n\n    res = 0\n\n    for x, y in pairwise(s):\n        x, y = ROMAN[x], ROMAN[y]\n        res += x if x &gt;= y else -x\n\n    return res + ROMAN[s[-1]]\n\n\nif __name__ == \"__main__\":\n    assert romanToInt(\"III\") == 3\n    assert romanToInt(\"IV\") == 4\n    assert romanToInt(\"IX\") == 9\n    assert romanToInt(\"LVIII\") == 58\n    assert romanToInt(\"MCMXCIV\") == 1994\n    assert romanToInt(\"MMXXIII\") == 2023\n</code></pre>"},{"location":"Company/microsoft/#21-merge-two-sorted-lists","title":"21. Merge Two Sorted Lists","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Recursion</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Task: Merge the two linked lists into one sorted list.\n\"\"\"\n\nfrom typing import Optional\n\nfrom leetpattern.utils import ListNode\n\n\n# Linked List\ndef merge_two_lists(\n    list1: Optional[ListNode], list2: Optional[ListNode]\n) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    while list1 and list2:\n        if list1.val &lt; list2.val:\n            cur.next = list1\n            list1 = list1.next\n        else:\n            cur.next = list2\n            list2 = list2.next\n        cur = cur.next\n\n    if list1:\n        cur.next = list1\n    elif list2:\n        cur.next = list2\n\n    return dummy.next\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode* next) : val(x), next(next) {}\n};\n\nclass Solution {\n   public:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        ListNode dummy;\n        ListNode* cur = &amp;dummy;\n\n        while (list1 &amp;&amp; list2) {\n            if (list1-&gt;val &lt; list2-&gt;val) {\n                cur-&gt;next = list1;\n                list1 = list1-&gt;next;\n            } else {\n                cur-&gt;next = list2;\n                list2 = list2-&gt;next;\n            }\n            cur = cur-&gt;next;\n        }\n\n        cur-&gt;next = list1 ? list1 : list2;\n\n        return dummy.next;\n    }\n};\n\nint main() {\n    Solution sol;\n    ListNode* list1 = new ListNode(1, new ListNode(2, new ListNode(4)));\n    ListNode* list2 = new ListNode(1, new ListNode(3, new ListNode(4)));\n    ListNode* merged = sol.mergeTwoLists(list1, list2);\n    vector&lt;int&gt; res;\n    while (merged) {\n        res.push_back(merged-&gt;val);\n        merged = merged-&gt;next;\n    }\n    assert(res == std::vector&lt;int&gt;({1, 1, 2, 3, 4, 4}));\n    return 0;\n}\n</code></pre>"},{"location":"Company/microsoft/#200-number-of-islands","title":"200. Number of Islands","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Union Find, Matrix</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Count the number of islands in a 2D grid.\n-   Method 1: DFS\n-   Method 2: BFS (use a queue to traverse the grid)\n\n-   How to keep track of visited cells?\n\n    1. Mark the visited cell as `0` (or any other value) to avoid revisiting it.\n    2. Use a set to store the visited cells.\n\n-   Steps:\n    1. Init: variables\n    2. DFS/BFS: starting from the cell with `1`, turn all the connected `1`s to `0`.\n    3. Traverse the grid, and if the cell is `1`, increment the count and call DFS/BFS.\n\n![0200](../../assets/0200.jpg)\n\"\"\"\n\nfrom collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef numIslandsDFS(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    res = 0\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] != \"1\":\n            return\n\n        grid[r][c] = \"2\"\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                dfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Set\ndef numIslandsBFS1(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == \"0\"\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\" and (r, c) not in visited:\n                visited.add((r, c))\n                bfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = dr + row, dc + col\n                if nr &lt; 0 or nr &gt;= m or nc &lt; 0 or nc &gt;= n or grid[nr][nc] != \"1\":\n                    continue\n                grid[nr][nc] = \"2\"\n                q.append((nr, nc))\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == \"1\":\n                grid[i][j] = \"2\"\n                bfs(i, j)\n                res += 1\n\n    return res\n\n\ngrid = [\n    [\"1\", \"1\", \"1\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"0\", \"0\", \"0\", \"0\", \"0\"],\n]\n\nprint(numIslandsDFS(deepcopy(grid)))  # 1\nprint(numIslandsBFS1(deepcopy(grid)))  # 1\nprint(numIslandsBFS2(deepcopy(grid)))  # 1\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    // dfs\n    int num_islands_dfs(vector&lt;vector&lt;char&gt;&gt; &amp;grid) {\n        int m = grid.size(), n = grid[0].size();\n        int res = 0;\n\n        // c++23 lambda recursion\n        auto dfs = [&amp;](this auto &amp;&amp;dfs, int r, int c) -&gt; void {\n            if (r &lt; 0 || r &gt;= m || c &lt; 0 || c &gt;= n || grid[r][c] != '1') {\n                return;\n            }\n            grid[r][c] = '0';\n            dfs(r + 1, c);\n            dfs(r - 1, c);\n            dfs(r, c + 1);\n            dfs(r, c - 1);\n        };\n\n        for (int i = 0; i &lt; m; i++) {\n            for (int j = 0; j &lt; n; j++) {\n                if (grid[i][j] == '1') {\n                    res++;\n                    dfs(i, j);\n                }\n            }\n        }\n        return res;\n    }\n\n    // bfs\n    int num_islands_bfs(vector&lt;vector&lt;char&gt;&gt; &amp;grid) {\n        int m = grid.size(), n = grid[0].size();\n        int res = 0;\n        vector&lt;pair&lt;int, int&gt;&gt; dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\n        auto bfs = [&amp;](int r, int c) {\n            queue&lt;pair&lt;int, int&gt;&gt; q;\n            q.push({r, c});\n            grid[r][c] = '0';\n            while (!q.empty()) {\n                auto [cr, cc] = q.front();\n                q.pop();\n                for (auto &amp;[dr, dc] : dirs) {\n                    int nr = cr + dr, nc = cc + dc;\n                    if (nr &gt;= 0 &amp;&amp; nr &lt; m &amp;&amp; nc &gt;= 0 &amp;&amp; nc &lt; n &amp;&amp;\n                        grid[nr][nc] == '1') {\n                        grid[nr][nc] = '0';\n                        q.push({nr, nc});\n                    }\n                }\n            }\n        };\n\n        for (int i = 0; i &lt; m; i++) {\n            for (int j = 0; j &lt; n; j++) {\n                if (grid[i][j] == '1') {\n                    res++;\n                    bfs(i, j);\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;vector&lt;char&gt;&gt; grid = {{'1', '1', '0', '0', '0'},\n                                 {'1', '1', '0', '0', '0'},\n                                 {'0', '0', '1', '0', '0'},\n                                 {'0', '0', '0', '1', '1'}};\n    assert(solution.num_islands_dfs(grid) == 3);\n    grid = {{'1', '1', '0', '0', '0'},\n            {'1', '1', '0', '0', '0'},\n            {'0', '0', '1', '0', '0'},\n            {'0', '0', '0', '1', '1'}};\n    assert(solution.num_islands_bfs(grid) == 3);\n    return 0;\n}\n</code></pre>"},{"location":"Company/microsoft/#20-valid-parentheses","title":"20. Valid Parentheses","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack</p> </li> </ul> PythonCPP <pre><code># Stack\ndef is_valid(s: str) -&gt; bool:\n    if len(s) % 2:\n        return False\n\n    pairs = {\n        \"(\": \")\",\n        \"{\": \"}\",\n        \"[\": \"]\",\n    }\n    stack = []\n    for ch in s:\n        if ch in pairs:\n            stack.append(ch)\n        elif not stack or ch != pairs[stack.pop()]:\n            return False\n\n    return True if not stack else False\n\n\ndef test_is_valid():\n    assert is_valid(\"()[]{}\")\n    assert not is_valid(\"(]\")\n    assert not is_valid(\"([)]\")\n    assert is_valid(\"{[]}\")\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;stack&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool isValid(string s) {\n        unordered_map&lt;char, char&gt; map{{')', '('}, {'}', '{'}, {']', '['}};\n        stack&lt;char&gt; stack;\n        if (s.length() % 2 == 1) return false;\n\n        for (char&amp; ch : s) {\n            if (stack.empty() || map.find(ch) == map.end()) {\n                stack.push(ch);\n            } else {\n                if (map[ch] != stack.top()) {\n                    return false;\n                }\n                stack.pop();\n            }\n        }\n        return stack.empty();\n    }\n};\n\nint main() {\n    Solution s;\n    assert(s.isValid(\"()\") == true);\n    assert(s.isValid(\"()[]{}\") == true);\n    assert(s.isValid(\"(]\") == false);\n    assert(s.isValid(\"([)]\") == false);\n    assert(s.isValid(\"{[]}\") == true);\n    return 0;\n}\n</code></pre>"},{"location":"Company/openai/","title":"OpenAI","text":""},{"location":"Company/openai/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2408. Design SQL (Medium) \ud83d\udc51</li> <li> 341. Flatten Nested List Iterator (Medium)</li> <li> 981. Time Based Key-Value Store (Medium)</li> <li> 2502. Design Memory Allocator (Medium)</li> <li> 735. Asteroid Collision (Medium)</li> </ul>"},{"location":"Company/openai/#2408-design-sql","title":"2408. Design SQL \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Design</p> </li> </ul>"},{"location":"Company/openai/#341-flatten-nested-list-iterator","title":"341. Flatten Nested List Iterator","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Stack, Tree, Depth First Search, Design, Queue, Iterator</p> </li> </ul>"},{"location":"Company/openai/#981-time-based-key-value-store","title":"981. Time Based Key-Value Store","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Binary Search, Design</p> </li> </ul> Python <pre><code>from collections import defaultdict\n\n\n# Binary Search\nclass TimeMap:\n\n    def __init__(self):\n        self.keys = defaultdict(list)\n        self.times = dict()\n\n    def set(self, key: str, value: str, timestamp: int) -&gt; None:\n        self.keys[key].append(timestamp)\n        self.times[timestamp] = value\n\n    def get(self, key: str, timestamp: int) -&gt; str:\n        tmp = self.keys[key]\n\n        left, right = 0, len(tmp) - 1\n        while left &lt;= right:\n            mid = left + (right - left) // 2\n            if tmp[mid] &gt; timestamp:\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        return self.times[tmp[right]] if right &gt;= 0 else \"\"\n\n\nobj = TimeMap()\nobj.set(\"foo\", \"bar\", 1)\nprint(obj.get(\"foo\", 1))  # bar\nprint(obj.get(\"foo\", 3))  # bar\nobj.set(\"foo\", \"bar2\", 4)\nprint(obj.get(\"foo\", 4))  # bar2\nprint(obj.get(\"foo\", 5))  # bar2\n</code></pre>"},{"location":"Company/openai/#2502-design-memory-allocator","title":"2502. Design Memory Allocator","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Design, Simulation</p> </li> </ul>"},{"location":"Company/openai/#735-asteroid-collision","title":"735. Asteroid Collision","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Stack, Simulation</p> </li> </ul>"},{"location":"Company/paypay/","title":"PayPay","text":""},{"location":"Company/paypay/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3161. Block Placement Queries (Hard)</li> <li> 6. Zigzag Conversion (Medium)</li> </ul>"},{"location":"Company/paypay/#3161-block-placement-queries","title":"3161. Block Placement Queries","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Binary Indexed Tree, Segment Tree</p> </li> </ul>"},{"location":"Company/paypay/#6-zigzag-conversion","title":"6. Zigzag Conversion","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String</p> </li> </ul>"},{"location":"EndlessCheng/1d_difference_array/","title":"1D Difference Array","text":""},{"location":"EndlessCheng/1d_difference_array/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2848. Points That Intersect With Cars (Easy)</li> <li> 1893. Check if All the Integers in a Range Are Covered (Easy)</li> <li> 1854. Maximum Population Year (Easy)</li> <li> 2960. Count Tested Devices After Test Operations (Easy)</li> <li> 1094. Car Pooling (Medium)</li> <li> 1109. Corporate Flight Bookings (Medium)</li> <li> 3355. Zero Array Transformation I (Medium)</li> <li> 56. Merge Intervals (Medium)</li> <li> 57. Insert Interval (Medium)</li> <li> 732. My Calendar III (Hard)</li> <li> 2406. Divide Intervals Into Minimum Number of Groups (Medium)</li> <li> 2381. Shifting Letters II (Medium)</li> <li> 3453. Separate Squares I (Medium)</li> <li> 995. Minimum Number of K Consecutive Bit Flips (Hard)</li> <li> 1589. Maximum Sum Obtained of Any Permutation (Medium)</li> <li> 1526. Minimum Number of Increments on Subarrays to Form a Target Array (Hard)</li> <li> 3356. Zero Array Transformation II (Medium)</li> <li> 1943. Describe the Painting (Medium)</li> <li> 3224. Minimum Array Changes to Make Differences Equal (Medium)</li> <li> 2251. Number of Flowers in Full Bloom (Hard)</li> <li> 2772. Apply Operations to Make All Array Elements Equal to Zero (Medium)</li> <li> 3229. Minimum Operations to Make Array Equal to Target (Hard)</li> <li> 798. Smallest Rotation with Highest Score (Hard)</li> <li> 3347. Maximum Frequency of an Element After Performing Operations II (Hard)</li> <li> 2528. Maximize the Minimum Powered City (Hard)</li> <li> 1674. Minimum Moves to Make Array Complementary (Medium)</li> <li> 3362. Zero Array Transformation III (Medium)</li> <li> 3017. Count the Number of Houses at a Certain Distance II (Hard)</li> <li> 253. Meeting Rooms II (Medium) \ud83d\udc51</li> <li> 370. Range Addition (Medium) \ud83d\udc51</li> <li> 1989. Maximum Number of People That Can Be Caught in Tag (Medium) \ud83d\udc51</li> <li> 759. Employee Free Time (Hard) \ud83d\udc51</li> <li> 2021. Brightest Position on Street (Medium) \ud83d\udc51</li> <li> 2015. Average Height of Buildings in Each Segment (Medium) \ud83d\udc51</li> <li> 2237. Count Positions on Street With Required Brightness (Medium) \ud83d\udc51</li> <li> 3009. Maximum Number of Intersections on the Chart (Hard) \ud83d\udc51</li> <li> 3279. Maximum Total Area Occupied by Pistons (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/1d_difference_array/#2848-points-that-intersect-with-cars","title":"2848. Points That Intersect With Cars","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Prefix Sum</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the number of points that intersect with cars.\n\"\"\"\n\nfrom itertools import accumulate\nfrom typing import List\n\n\n# Differnce Array\ndef numberOfPoints(nums: List[List[int]]) -&gt; int:\n    max_end = max(end for _, end in nums)\n\n    diff = [0] * (max_end + 2)\n\n    for start, end in nums:\n        diff[start] += 1\n        diff[end + 1] -= 1\n\n    return sum(s &gt; 0 for s in accumulate(diff))\n\n\nnums = [[3, 6], [1, 5], [4, 7]]\nprint(numberOfPoints(nums))  # 7\n</code></pre>"},{"location":"EndlessCheng/1d_difference_array/#1893-check-if-all-the-integers-in-a-range-are-covered","title":"1893. Check if All the Integers in a Range Are Covered","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/1d_difference_array/#1854-maximum-population-year","title":"1854. Maximum Population Year","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Counting, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/1d_difference_array/#2960-count-tested-devices-after-test-operations","title":"2960. Count Tested Devices After Test Operations","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Simulation, Counting</p> </li> </ul>"},{"location":"EndlessCheng/1d_difference_array/#1094-car-pooling","title":"1094. Car Pooling","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sorting, Heap Priority Queue, Simulation, Prefix Sum</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return `False` if the total number of passengers at any point is greater than `capacity`. Otherwise, return `True`.\n\"\"\"\n\nfrom itertools import accumulate\nfrom typing import List\n\n\n# Difference Array\ndef carPooling1(trips: List[List[int]], capacity: int) -&gt; bool:\n    max_location = 0\n    for trip in trips:\n        max_location = max(max_location, trip[2])\n\n    diff = [0] * (max_location + 1)\n    n = len(diff)\n\n    for num, start, end in trips:\n        diff[start] += num\n        if end &lt; n:\n            diff[end] -= num\n\n    cur = 0\n    for i in range(n):\n        cur += diff[i]\n        if cur &gt; capacity:\n            return False\n\n    return True\n\n\n# Difference Array\ndef carPooling2(trips: List[List[int]], capacity: int) -&gt; bool:\n    diff = [0] * 1001\n\n    for num, start, end in trips:\n        diff[start] += num\n        diff[end] -= num\n\n    return all(s &lt;= capacity for s in accumulate(diff))\n\n\ntrips = [[2, 1, 5], [3, 3, 7]]\ncapacity = 4\nprint(carPooling1(trips, capacity))  # False\nprint(carPooling2(trips, capacity))  # False\n</code></pre>"},{"location":"EndlessCheng/1d_difference_array/#1109-corporate-flight-bookings","title":"1109. Corporate Flight Bookings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Prefix Sum</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the number of seats booked on each flight.\n\"\"\"\n\nfrom typing import List\n\n\n# Difference Array\ndef corpFlightBookings(bookings: List[List[int]], n: int) -&gt; List[int]:\n    \"\"\"Return the number of seats booked for each flight.\"\"\"\n    res = [0 for _ in range(n)]\n\n    for i, j, k in bookings:\n        res[i - 1] += k\n        if j &lt; n:\n            res[j] -= k\n\n    for i in range(1, n):\n        res[i] += res[i - 1]\n\n    return res\n\n\nbookings = [[1, 2, 10], [2, 3, 20], [2, 5, 25]]\nn = 5\nprint(corpFlightBookings(bookings, n))  # [10, 55, 45, 25, 25]\n</code></pre>"},{"location":"EndlessCheng/1d_difference_array/#3355-zero-array-transformation-i","title":"3355. Zero Array Transformation I","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/1d_difference_array/#56-merge-intervals","title":"56. Merge Intervals","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sorting</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Merge all overlapping intervals.\n\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/44H3cEC2fFM?si=J-Jr_Fg2eDse3-de\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen&gt;&lt;/iframe&gt;\n\"\"\"\n\nfrom typing import List\n\n\n# Intervals\ndef merge(intervals: List[List[int]]) -&gt; List[List[int]]:\n    n = len(intervals)\n    if n &lt;= 1:\n        return intervals\n\n    intervals.sort(key=lambda x: x[0])\n    res = [intervals[0]]\n\n    for i in range(1, n):\n        if intervals[i][0] &lt;= res[-1][1]:\n            res[-1][1] = max(res[-1][1], intervals[i][1])\n        else:\n            res.append(intervals[i])\n\n    return res\n\n\nprint(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))\n# [[1, 6], [8, 10], [15, 18]]\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// Interval\nvector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {\n    sort(intervals.begin(), intervals.end());\n    vector&lt;vector&lt;int&gt;&gt; res;\n\n    for (auto&amp; range : intervals) {\n        if (!res.empty() &amp;&amp; range[0] &lt;= res.back()[1]) {\n            res.back()[1] = max(res.back()[1], range[1]);\n        } else {\n            res.emplace_back(range);\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;vector&lt;int&gt;&gt; intervals = {{1, 3}, {2, 6}, {8, 10}, {15, 18}};\n    vector&lt;vector&lt;int&gt;&gt; res = merge(intervals);\n    for (auto&amp; range : res) {\n        cout &lt;&lt; range[0] &lt;&lt; \", \" &lt;&lt; range[1] &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/1d_difference_array/#57-insert-interval","title":"57. Insert Interval","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Interval\ndef insert(intervals: List[List[int]], newInterval: List[int]) -&gt; List[List[int]]:\n    n = len(intervals)\n\n    if n == 0:\n        return [newInterval]\n\n    if newInterval[1] &lt; intervals[0][0]:\n        return [newInterval] + intervals\n\n    if newInterval[0] &gt; intervals[-1][1]:\n        return intervals + [newInterval]\n\n    i = 0\n    result = []\n\n    while i &lt; n and intervals[i][1] &lt; newInterval[0]:\n        result.append(intervals[i])\n        i += 1\n\n    while i &lt; n and intervals[i][0] &lt;= newInterval[1]:\n        newInterval[0] = min(newInterval[0], intervals[i][0])\n        newInterval[1] = max(newInterval[1], intervals[i][1])\n        i += 1\n\n    result.append(newInterval)\n\n    while i &lt; n:\n        result.append(intervals[i])\n        i += 1\n\n    return result\n\n\nintervals = [[1, 3], [6, 9]]\nnewInterval = [2, 5]\nprint(insert(intervals, newInterval))  # [[1, 5], [6, 9]]\n</code></pre>"},{"location":"EndlessCheng/1d_difference_array/#732-my-calendar-iii","title":"732. My Calendar III","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Binary Search, Design, Segment Tree, Prefix Sum, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/1d_difference_array/#2406-divide-intervals-into-minimum-number-of-groups","title":"2406. Divide Intervals Into Minimum Number of Groups","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Greedy, Sorting, Heap Priority Queue, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/1d_difference_array/#2381-shifting-letters-ii","title":"2381. Shifting Letters II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/1d_difference_array/#3453-separate-squares-i","title":"3453. Separate Squares I","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul>"},{"location":"EndlessCheng/1d_difference_array/#995-minimum-number-of-k-consecutive-bit-flips","title":"995. Minimum Number of K Consecutive Bit Flips","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation, Queue, Sliding Window, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/1d_difference_array/#1589-maximum-sum-obtained-of-any-permutation","title":"1589. Maximum Sum Obtained of Any Permutation","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting, Prefix Sum</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Greedy\ndef maxSumRangeQuery(nums: List[int], requests: List[List[int]]) -&gt; int:\n    n = len(nums)\n    freq = [0 for _ in range(n + 1)]\n\n    for start, end in requests:\n        freq[start] += 1\n        if end + 1 &lt; n:\n            freq[end + 1] -= 1\n\n    for i in range(1, n):\n        freq[i] += freq[i - 1]\n\n    freq.pop()\n\n    freq.sort(reverse=True)\n    nums.sort(reverse=True)\n\n    max_sum = 0\n    mod = 10**9 + 7\n\n    for i, j in zip(nums, freq):\n        max_sum += i * j\n        max_sum %= mod\n\n    return max_sum\n\n\nnums = [1, 2, 3, 4, 5]\nrequests = [[1, 3], [0, 1]]\nprint(maxSumRangeQuery(nums, requests))  # 19\n</code></pre>"},{"location":"EndlessCheng/1d_difference_array/#1526-minimum-number-of-increments-on-subarrays-to-form-a-target-array","title":"1526. Minimum Number of Increments on Subarrays to Form a Target Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Stack, Greedy, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/1d_difference_array/#3356-zero-array-transformation-ii","title":"3356. Zero Array Transformation II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/1d_difference_array/#1943-describe-the-painting","title":"1943. Describe the Painting","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Sorting, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/1d_difference_array/#3224-minimum-array-changes-to-make-differences-equal","title":"3224. Minimum Array Changes to Make Differences Equal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/1d_difference_array/#2251-number-of-flowers-in-full-bloom","title":"2251. Number of Flowers in Full Bloom","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Binary Search, Sorting, Prefix Sum, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/1d_difference_array/#2772-apply-operations-to-make-all-array-elements-equal-to-zero","title":"2772. Apply Operations to Make All Array Elements Equal to Zero","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/1d_difference_array/#3229-minimum-operations-to-make-array-equal-to-target","title":"3229. Minimum Operations to Make Array Equal to Target","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Stack, Greedy, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/1d_difference_array/#798-smallest-rotation-with-highest-score","title":"798. Smallest Rotation with Highest Score","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/1d_difference_array/#3347-maximum-frequency-of-an-element-after-performing-operations-ii","title":"3347. Maximum Frequency of an Element After Performing Operations II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Sliding Window, Sorting, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/1d_difference_array/#2528-maximize-the-minimum-powered-city","title":"2528. Maximize the Minimum Powered City","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Greedy, Queue, Sliding Window, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/1d_difference_array/#1674-minimum-moves-to-make-array-complementary","title":"1674. Minimum Moves to Make Array Complementary","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/1d_difference_array/#3362-zero-array-transformation-iii","title":"3362. Zero Array Transformation III","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting, Heap Priority Queue, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/1d_difference_array/#3017-count-the-number-of-houses-at-a-certain-distance-ii","title":"3017. Count the Number of Houses at a Certain Distance II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Graph, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/1d_difference_array/#253-meeting-rooms-ii","title":"253. Meeting Rooms II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Greedy, Sorting, Heap Priority Queue, Prefix Sum</p> </li> </ul> Python <pre><code>\"\"\"\n- Given an array of meeting time `intervals` where `intervals[i] = [start_i, end_i]`, return the minimum number of conference rooms required.\n\"\"\"\n\nimport heapq\nfrom typing import List\n\n\n# Heap\ndef minMeetingRooms(intervals: List[List[int]]) -&gt; int:\n    if not intervals:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n    minHeap = [intervals[0][1]]\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &gt;= minHeap[0]:\n            heapq.heappop(minHeap)\n        heapq.heappush(minHeap, intervals[i][1])\n\n    return len(minHeap)\n\n\nif __name__ == \"__main__\":\n    intervals = [[0, 30], [5, 10], [15, 20]]\n    assert minMeetingRooms(intervals) == 2\n</code></pre>"},{"location":"EndlessCheng/1d_difference_array/#370-range-addition","title":"370. Range Addition \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Prefix Sum</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef getModifiedArray(length: int, updates: List[List[int]]) -&gt; List[int]:\n    \"\"\"\n    Return the final array after applying all the Adition operations.\n    method: difference array\n    \"\"\"\n\n    res = [0 for _ in range(length)]\n\n    for start, end, inc in updates:\n        res[start] += inc\n\n        if end + 1 &lt; length:\n            res[end + 1] -= inc\n\n    for i in range(1, length):\n        res[i] += res[i - 1]\n\n    return res\n\n\nif __name__ == \"__main__\":\n    length = 5\n    updates = [[1, 3, 2], [2, 4, 3], [0, 2, -2]]\n    assert getModifiedArray(length, updates) == [-2, 0, 3, 5, 3]\n</code></pre>"},{"location":"EndlessCheng/1d_difference_array/#1989-maximum-number-of-people-that-can-be-caught-in-tag","title":"1989. Maximum Number of People That Can Be Caught in Tag \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/1d_difference_array/#759-employee-free-time","title":"759. Employee Free Time \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sorting, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/1d_difference_array/#2021-brightest-position-on-street","title":"2021. Brightest Position on Street \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sorting, Prefix Sum, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/1d_difference_array/#2015-average-height-of-buildings-in-each-segment","title":"2015. Average Height of Buildings in Each Segment \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/1d_difference_array/#2237-count-positions-on-street-with-required-brightness","title":"2237. Count Positions on Street With Required Brightness \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/1d_difference_array/#3009-maximum-number-of-intersections-on-the-chart","title":"3009. Maximum Number of Intersections on the Chart \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Binary Indexed Tree, Geometry</p> </li> </ul>"},{"location":"EndlessCheng/1d_difference_array/#3279-maximum-total-area-occupied-by-pistons","title":"3279. Maximum Total Area Occupied by Pistons \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Simulation, Counting, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/1d_prefix_sum/","title":"1D Prefix Sum","text":""},{"location":"EndlessCheng/1d_prefix_sum/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1310. XOR Queries of a Subarray (Medium)</li> <li> 2438. Range Product Queries of Powers (Medium)</li> <li> 1895. Largest Magic Square (Medium)</li> <li> 1878. Get Biggest Three Rhombus Sums in a Grid (Medium)</li> <li> 1031. Maximum Sum of Two Non-Overlapping Subarrays (Medium)</li> <li> 2245. Maximum Trailing Zeros in a Cornered Path (Medium)</li> <li> 1712. Ways to Split Array Into Three Subarrays (Medium)</li> <li> 1862. Sum of Floored Pairs (Hard)</li> <li> 363. Max Sum of Rectangle No Larger Than K (Hard)</li> <li> 2281. Sum of Total Strength of Wizards (Hard)</li> <li> 3445. Maximum Difference Between Even and Odd Frequency II (Hard)</li> <li> 2983. Palindrome Rearrangement Queries (Hard)</li> <li> 2955. Number of Same-End Substrings (Medium) \ud83d\udc51</li> <li> 1788. Maximize the Beauty of the Garden (Hard) \ud83d\udc51</li> <li> 2819. Minimum Relative Loss After Buying Chocolates (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/1d_prefix_sum/#1310-xor-queries-of-a-subarray","title":"1310. XOR Queries of a Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/1d_prefix_sum/#2438-range-product-queries-of-powers","title":"2438. Range Product Queries of Powers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/1d_prefix_sum/#1895-largest-magic-square","title":"1895. Largest Magic Square","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Matrix, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/1d_prefix_sum/#1878-get-biggest-three-rhombus-sums-in-a-grid","title":"1878. Get Biggest Three Rhombus Sums in a Grid","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Sorting, Heap Priority Queue, Matrix, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/1d_prefix_sum/#1031-maximum-sum-of-two-non-overlapping-subarrays","title":"1031. Maximum Sum of Two Non-Overlapping Subarrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/1d_prefix_sum/#2245-maximum-trailing-zeros-in-a-cornered-path","title":"2245. Maximum Trailing Zeros in a Cornered Path","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Matrix, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/1d_prefix_sum/#1712-ways-to-split-array-into-three-subarrays","title":"1712. Ways to Split Array Into Three Subarrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/1d_prefix_sum/#1862-sum-of-floored-pairs","title":"1862. Sum of Floored Pairs","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Binary Search, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/1d_prefix_sum/#363-max-sum-of-rectangle-no-larger-than-k","title":"363. Max Sum of Rectangle No Larger Than K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Matrix, Prefix Sum, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/1d_prefix_sum/#2281-sum-of-total-strength-of-wizards","title":"2281. Sum of Total Strength of Wizards","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Stack, Monotonic Stack, Prefix Sum</p> </li> </ul> Python <pre><code>from itertools import accumulate\nfrom typing import List\n\n\n# Monotonic Stack\ndef totalStrength(strength: List[int]) -&gt; int:\n    n = len(strength)\n    left = [-1 for _ in range(n)]\n    right = [n for _ in range(n)]\n    stack = []\n\n    for i, v in enumerate(strength):\n        while stack and strength[stack[-1]] &gt;= v:\n            right[stack.pop()] = i\n        if stack:\n            left[i] = stack[-1]\n        stack.append(i)\n\n    prefix_sum = list(accumulate(accumulate(strength, initial=0), initial=0))\n\n    ans = 0\n    for i, v in enumerate(strength):\n        l, r = left[i] + 1, right[i] - 1\n        tot = (i - l + 1) * (prefix_sum[r + 2] - prefix_sum[i + 1]) - (r - i + 1) * (\n            prefix_sum[i + 1] - prefix_sum[l]\n        )\n        ans += v * tot\n\n    return ans % (10**9 + 7)\n\n\nstrength = [1, 3, 1, 2]\nprint(totalStrength(strength))  # 44\n</code></pre>"},{"location":"EndlessCheng/1d_prefix_sum/#3445-maximum-difference-between-even-and-odd-frequency-ii","title":"3445. Maximum Difference Between Even and Odd Frequency II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Sliding Window, Enumeration, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/1d_prefix_sum/#2983-palindrome-rearrangement-queries","title":"2983. Palindrome Rearrangement Queries","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/1d_prefix_sum/#2955-number-of-same-end-substrings","title":"2955. Number of Same-End Substrings \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Counting, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/1d_prefix_sum/#1788-maximize-the-beauty-of-the-garden","title":"1788. Maximize the Beauty of the Garden \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Greedy, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/1d_prefix_sum/#2819-minimum-relative-loss-after-buying-chocolates","title":"2819. Minimum Relative Loss After Buying Chocolates \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Sorting, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/2d_difference_array/","title":"2D Difference Array","text":""},{"location":"EndlessCheng/2d_difference_array/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2536. Increment Submatrices by One (Medium)</li> <li> 850. Rectangle Area II (Hard)</li> <li> 2132. Stamping the Grid (Hard)</li> </ul>"},{"location":"EndlessCheng/2d_difference_array/#2536-increment-submatrices-by-one","title":"2536. Increment Submatrices by One","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Matrix, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/2d_difference_array/#850-rectangle-area-ii","title":"850. Rectangle Area II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Segment Tree, Line Sweep, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/2d_difference_array/#2132-stamping-the-grid","title":"2132. Stamping the Grid","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Matrix, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/2d_prefix_sum/","title":"2D Prefix Sum","text":""},{"location":"EndlessCheng/2d_prefix_sum/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 304. Range Sum Query 2D - Immutable (Medium)</li> <li> 1314. Matrix Block Sum (Medium)</li> <li> 3070. Count Submatrices with Top-Left Element and Sum Less Than k (Medium)</li> <li> 1738. Find Kth Largest XOR Coordinate Value (Medium)</li> <li> 3212. Count Submatrices With Equal Frequency of X and Y (Medium)</li> <li> 1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold (Medium)</li> <li> 221. Maximal Square (Medium)</li> <li> 1277. Count Square Submatrices with All Ones (Medium)</li> <li> 1504. Count Submatrices With All Ones (Medium)</li> <li> 1074. Number of Submatrices That Sum to Target (Hard)</li> <li> 3148. Maximum Difference Score in a Grid (Medium)</li> </ul>"},{"location":"EndlessCheng/2d_prefix_sum/#304-range-sum-query-2d-immutable","title":"304. Range Sum Query 2D - Immutable","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Design, Matrix, Prefix Sum</p> </li> </ul> Python <pre><code>from typing import List\n\n\nclass NumMatrix:\n\n    def __init__(self, matrix: List[List[int]]):\n        m, n = len(matrix), len(matrix[0])\n        if m == 0 or n == 0:\n            return None\n\n        self.sum = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                self.sum[i][j] = (\n                    matrix[i - 1][j - 1]\n                    + self.sum[i - 1][j]\n                    + self.sum[i][j - 1]\n                    - self.sum[i - 1][j - 1]  # to avoid double counting\n                )\n\n    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -&gt; int:\n        return (\n            self.sum[row2 + 1][col2 + 1]\n            - self.sum[row1][col2 + 1]\n            - self.sum[row2 + 1][col1]\n            + self.sum[row1][col1]\n        )\n\n\nmatrix = [\n    [3, 0, 1, 4, 2],\n    [5, 6, 3, 2, 1],\n    [1, 2, 0, 1, 5],\n    [4, 1, 0, 1, 7],\n    [1, 0, 3, 0, 5],\n]\nobj = NumMatrix(matrix)\nassert obj.sumRegion(2, 1, 4, 3) == 8\nassert obj.sumRegion(1, 1, 2, 2) == 11\nassert obj.sumRegion(1, 2, 2, 4) == 12\nprint(\"PASSED\")\n</code></pre>"},{"location":"EndlessCheng/2d_prefix_sum/#1314-matrix-block-sum","title":"1314. Matrix Block Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Matrix, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/2d_prefix_sum/#3070-count-submatrices-with-top-left-element-and-sum-less-than-k","title":"3070. Count Submatrices with Top-Left Element and Sum Less Than k","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Matrix, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/2d_prefix_sum/#1738-find-kth-largest-xor-coordinate-value","title":"1738. Find Kth Largest XOR Coordinate Value","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Divide And Conquer, Bit Manipulation, Sorting, Heap Priority Queue, Matrix, Prefix Sum, Quickselect</p> </li> </ul>"},{"location":"EndlessCheng/2d_prefix_sum/#3212-count-submatrices-with-equal-frequency-of-x-and-y","title":"3212. Count Submatrices With Equal Frequency of X and Y","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Matrix, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/2d_prefix_sum/#1292-maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold","title":"1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Matrix, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/2d_prefix_sum/#221-maximal-square","title":"221. Maximal Square","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/2d_prefix_sum/#1277-count-square-submatrices-with-all-ones","title":"1277. Count Square Submatrices with All Ones","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/2d_prefix_sum/#1504-count-submatrices-with-all-ones","title":"1504. Count Submatrices With All Ones","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Stack, Matrix, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/2d_prefix_sum/#1074-number-of-submatrices-that-sum-to-target","title":"1074. Number of Submatrices That Sum to Target","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Matrix, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/2d_prefix_sum/#3148-maximum-difference-score-in-a-grid","title":"3148. Maximum Difference Score in a Grid","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/adjacent_different/","title":"Adjacent Different","text":""},{"location":"EndlessCheng/adjacent_different/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2335. Minimum Amount of Time to Fill Cups (Easy)</li> <li> 1753. Maximum Score From Removing Stones (Medium)</li> <li> 1054. Distant Barcodes (Medium)</li> <li> 2856. Minimum Array Length After Pair Removals (Medium)</li> <li> 1953. Maximum Number of Weeks for Which You Can Work (Medium)</li> <li> 767. Reorganize String (Medium)</li> <li> 3139. Minimum Cost to Equalize Array (Hard)</li> <li> 621. Task Scheduler (Medium)</li> <li> 358. Rearrange String k Distance Apart (Hard) \ud83d\udc51</li> <li> 984. String Without AAA or BBB (Medium)</li> <li> 1405. Longest Happy String (Medium)</li> </ul>"},{"location":"EndlessCheng/adjacent_different/#2335-minimum-amount-of-time-to-fill-cups","title":"2335. Minimum Amount of Time to Fill Cups","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/adjacent_different/#1753-maximum-score-from-removing-stones","title":"1753. Maximum Score From Removing Stones","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Greedy, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/adjacent_different/#1054-distant-barcodes","title":"1054. Distant Barcodes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Greedy, Sorting, Heap Priority Queue, Counting</p> </li> </ul>"},{"location":"EndlessCheng/adjacent_different/#2856-minimum-array-length-after-pair-removals","title":"2856. Minimum Array Length After Pair Removals","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Two Pointers, Binary Search, Greedy, Counting</p> </li> </ul>"},{"location":"EndlessCheng/adjacent_different/#1953-maximum-number-of-weeks-for-which-you-can-work","title":"1953. Maximum Number of Weeks for Which You Can Work","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/adjacent_different/#767-reorganize-string","title":"767. Reorganize String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Greedy, Sorting, Heap Priority Queue, Counting</p> </li> </ul> Python <pre><code>import heapq\nfrom collections import Counter\n\n\ndef reorganizeString(s: str) -&gt; str:\n    if not s:\n        return \"\"\n\n    heap = [(-freq, char) for char, freq in Counter(s).items()]  # max heap\n    heapq.heapify(heap)\n\n    result = []\n    prev_count, prev_char = 0, \"\"\n\n    while heap:\n        count, char = heapq.heappop(heap)  # pop the most frequent character\n        result.append(char)  # append the character to the result\n\n        if prev_count &lt; 0:  # if the previous character still has remaining count\n            heapq.heappush(heap, (prev_count, prev_char))\n\n        prev_count = count + 1  # update the current character's remaining count\n        prev_char = char  # update the current character\n\n    # check if there is any invalid result\n    if len(result) != len(s):\n        return \"\"\n\n    return \"\".join(result)\n\n\nprint(reorganizeString(\"aab\"))\n</code></pre>"},{"location":"EndlessCheng/adjacent_different/#3139-minimum-cost-to-equalize-array","title":"3139. Minimum Cost to Equalize Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/adjacent_different/#621-task-scheduler","title":"621. Task Scheduler","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Greedy, Sorting, Heap Priority Queue, Counting</p> </li> </ul> Python <pre><code>import heapq\nfrom collections import Counter, deque\nfrom typing import List\n\n\n# Heap\ndef leastInterval1(tasks: List[str], n: int) -&gt; int:\n    count = Counter(tasks)\n    heap = [-c for c in count.values()]\n    heapq.heapify(heap)\n\n    time = 0\n\n    q = deque()\n\n    while heap or q:\n        time += 1\n\n        if heap:\n            cnt = 1 + heapq.heappop(heap)\n            if cnt:\n                q.append((cnt, time + n))\n\n        if q and q[0][1] == time:\n            heapq.heappush(heap, q.popleft()[0])\n\n    return time\n\n\ndef leastInterval2(tasks: List[str], n: int) -&gt; int:\n    freq = Counter(tasks)\n\n    maxExec = max(freq.values())\n    maxCount = sum(1 for v in freq.values() if v == maxExec)\n\n    return max((maxExec - 1) * (n + 1) + maxCount, len(tasks))\n\n\ntasks = [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\"]\nn = 2\nprint(leastInterval1(tasks, n))  # 8\nprint(leastInterval2(tasks, n))  # 8\n</code></pre>"},{"location":"EndlessCheng/adjacent_different/#358-rearrange-string-k-distance-apart","title":"358. Rearrange String k Distance Apart \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Greedy, Sorting, Heap Priority Queue, Counting</p> </li> </ul>"},{"location":"EndlessCheng/adjacent_different/#984-string-without-aaa-or-bbb","title":"984. String Without AAA or BBB","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/adjacent_different/#1405-longest-happy-string","title":"1405. Longest Happy String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Greedy, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/adjacent_elimination/","title":"Adjacent Elimination","text":""},{"location":"EndlessCheng/adjacent_elimination/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2696. Minimum String Length After Removing Substrings (Easy)</li> <li> 1047. Remove All Adjacent Duplicates In String (Easy)</li> <li> 1544. Make The String Great (Easy)</li> <li> 1003. Check If Word Is Valid After Substitutions (Medium)</li> <li> 2216. Minimum Deletions to Make Array Beautiful (Medium)</li> <li> 1209. Remove All Adjacent Duplicates in String II (Medium)</li> <li> 2211. Count Collisions on a Road (Medium)</li> <li> 735. Asteroid Collision (Medium)</li> <li> 1717. Maximum Score From Removing Substrings (Medium)</li> <li> 2197. Replace Non-Coprime Numbers in Array (Hard)</li> <li> 2751. Robot Collisions (Hard)</li> </ul>"},{"location":"EndlessCheng/adjacent_elimination/#2696-minimum-string-length-after-removing-substrings","title":"2696. Minimum String Length After Removing Substrings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack, Simulation</p> </li> </ul>"},{"location":"EndlessCheng/adjacent_elimination/#1047-remove-all-adjacent-duplicates-in-string","title":"1047. Remove All Adjacent Duplicates In String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack</p> </li> </ul>"},{"location":"EndlessCheng/adjacent_elimination/#1544-make-the-string-great","title":"1544. Make The String Great","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack</p> </li> </ul> Python <pre><code>\"\"\"\n-   Remove all adjacent characters that are the same and have different cases.\n-   Steps for the string `leEeetcode`:\n\n| char | action | stack      |\n| ---- | ------ | ---------- |\n| l    | push   | \"l\"        |\n| e    | push   | \"le\"       |\n| E    | pop    | \"l\"        |\n| e    | push   | \"le\"       |\n| e    | push   | \"lee\"      |\n| t    | push   | \"leet\"     |\n| c    | push   | \"leetc\"    |\n| o    | push   | \"leetco\"   |\n| d    | push   | \"leetcod\"  |\n| e    | push   | \"leetcode\" |\n\"\"\"\n\n\n# Stack\ndef makeGood(s: str) -&gt; str:\n    stack = []\n\n    for i in range(len(s)):\n        if stack and stack[-1] == s[i].swapcase():\n            stack.pop()\n        else:\n            stack.append(s[i])\n    return \"\".join(stack)\n\n\nprint(makeGood(\"leEeetcode\"))  # \"leetcode\"\n</code></pre>"},{"location":"EndlessCheng/adjacent_elimination/#1003-check-if-word-is-valid-after-substitutions","title":"1003. Check If Word Is Valid After Substitutions","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack</p> </li> </ul>"},{"location":"EndlessCheng/adjacent_elimination/#2216-minimum-deletions-to-make-array-beautiful","title":"2216. Minimum Deletions to Make Array Beautiful","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Stack, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/adjacent_elimination/#1209-remove-all-adjacent-duplicates-in-string-ii","title":"1209. Remove All Adjacent Duplicates in String II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack</p> </li> </ul>"},{"location":"EndlessCheng/adjacent_elimination/#2211-count-collisions-on-a-road","title":"2211. Count Collisions on a Road","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack, Simulation</p> </li> </ul>"},{"location":"EndlessCheng/adjacent_elimination/#735-asteroid-collision","title":"735. Asteroid Collision","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Stack, Simulation</p> </li> </ul>"},{"location":"EndlessCheng/adjacent_elimination/#1717-maximum-score-from-removing-substrings","title":"1717. Maximum Score From Removing Substrings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/adjacent_elimination/#2197-replace-non-coprime-numbers-in-array","title":"2197. Replace Non-Coprime Numbers in Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Stack, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/adjacent_elimination/#2751-robot-collisions","title":"2751. Robot Collisions","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Stack, Sorting, Simulation</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_basic/","title":"Backtracking Basic","text":""},{"location":"EndlessCheng/backtracking_basic/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 17. Letter Combinations of a Phone Number (Medium)</li> </ul>"},{"location":"EndlessCheng/backtracking_basic/#17-letter-combinations-of-a-phone-number","title":"17. Letter Combinations of a Phone Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Backtracking</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return all possible letter combinations that the number could represent.\n\n![17](https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png)\n\"\"\"\n\nfrom typing import List\n\n\n# Backtracking\ndef letterCombinations(digits: str) -&gt; List[str]:\n    letter_map = {\n        \"2\": \"abc\",\n        \"3\": \"def\",\n        \"4\": \"ghi\",\n        \"5\": \"jkl\",\n        \"6\": \"mno\",\n        \"7\": \"pqrs\",\n        \"8\": \"tuv\",\n        \"9\": \"wxyz\",\n    }\n\n    n = len(digits)\n    if n == 0:\n        return []\n\n    res = []\n\n    def dfs(idx, path):\n        if idx == n:\n            res.append(path)\n            return None\n\n        letters = letter_map[digits[idx]]\n\n        for i in range(len(letters)):\n            dfs(idx + 1, path + letters[i])\n\n    dfs(0, \"\")\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert letterCombinations(\"23\") == [\n        \"ad\",\n        \"ae\",\n        \"af\",\n        \"bd\",\n        \"be\",\n        \"bf\",\n        \"cd\",\n        \"ce\",\n        \"cf\",\n    ]\n</code></pre>"},{"location":"EndlessCheng/backtracking_combination/","title":"Backtracking Combination","text":""},{"location":"EndlessCheng/backtracking_combination/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 77. Combinations (Medium)</li> <li> 216. Combination Sum III (Medium)</li> <li> 22. Generate Parentheses (Medium)</li> <li> 301. Remove Invalid Parentheses (Hard)</li> </ul>"},{"location":"EndlessCheng/backtracking_combination/#77-combinations","title":"77. Combinations","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Backtracking</p> </li> </ul> Python <pre><code>import itertools\nfrom typing import List\n\n\n# Backtracking\ndef combine(n: int, k: int) -&gt; List[List[int]]:\n    res = []\n\n    def backtrack(start, path):\n        if len(path) == k:\n            res.append(path[:])\n            return None\n\n        for i in range(start, n + 1):\n            path.append(i)\n            backtrack(i + 1, path)\n            path.pop()\n\n    backtrack(1, [])\n\n    return res\n\n\n# itertools\ndef combineItertools(n: int, k: int) -&gt; List[List[int]]:\n    path = itertools.combinations(range(1, n + 1), k)\n    return path\n\n\nprint(combine(4, 2))\n# [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\nprint(list(combineItertools(4, 2)))\n# [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]\n</code></pre>"},{"location":"EndlessCheng/backtracking_combination/#216-combination-sum-iii","title":"216. Combination Sum III","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking</p> </li> </ul> Python <pre><code>import itertools\nfrom typing import List\n\n\n# 1. Backtracking\ndef combinationSum3(k: int, n: int) -&gt; List[List[int]]:\n    path, result = [], []\n\n    def backtracking(start):\n        if len(path) == k and sum(path) == n:\n            result.append(path[:])\n            return\n\n        for i in range(start, 10):\n            path.append(i)\n            backtracking(i + 1)\n            path.pop()\n\n    backtracking(1)\n\n    return result\n\n\n# 2. Itertools\ndef combinationSum3Itertools(k: int, n: int) -&gt; List[List[int]]:\n    combinations = itertools.combinations(range(1, 10), k)\n    result = []\n\n    for i in combinations:\n        if sum(i) == n:\n            result.append(i)\n\n    return result\n\n\nprint(combinationSum3(3, 7))  # [[1, 2, 4]]\nprint(combinationSum3Itertools(3, 7))  # [(1, 2, 4)]\n</code></pre>"},{"location":"EndlessCheng/backtracking_combination/#22-generate-parentheses","title":"22. Generate Parentheses","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Backtracking</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Backtracking\ndef generateParenthesis1(n: int) -&gt; List[str]:\n    path, res = [], []\n\n    def dfs(openN, closeN):\n        if openN == closeN == n:\n            res.append(\"\".join(path))\n            return\n\n        if openN &lt; n:\n            path.append(\"(\")\n            dfs(openN + 1, closeN)\n            path.pop()\n\n        if closeN &lt; openN:\n            path.append(\")\")\n            dfs(openN, closeN + 1)\n            path.pop()\n\n    dfs(0, 0)\n\n    return res\n\n\n# Backtracking\ndef generateParenthesis2(n: int) -&gt; List[str]:\n    m = n * 2\n    res, path = [], [\"\"] * m\n\n    def dfs(i, left):\n        if i == m:\n            res.append(\"\".join(path))\n            return\n\n        if left &lt; n:\n            path[i] = \"(\"\n            dfs(i + 1, left + 1)\n        if i - left &lt; left:\n            path[i] = \")\"\n            dfs(i + 1, left)\n\n    dfs(0, 0)\n    return res\n\n\nif __name__ == \"__main__\":\n    print(generateParenthesis1(3))\n    # ['((()))', '(()())', '(())()', '()(())', '()()()']\n    print(generateParenthesis2(3))\n    # ['((()))', '(()())', '(())()', '()(())', '()()()']\n</code></pre>"},{"location":"EndlessCheng/backtracking_combination/#301-remove-invalid-parentheses","title":"301. Remove Invalid Parentheses","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Backtracking, Breadth First Search</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_exhaustive_search_and_pruning/","title":"Backtracking Exhaustive Search and Pruning","text":""},{"location":"EndlessCheng/backtracking_exhaustive_search_and_pruning/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3211. Generate Binary Strings Without Adjacent Zeros (Medium)</li> <li> 967. Numbers With Same Consecutive Differences (Medium)</li> <li> 1415. The k-th Lexicographical String of All Happy Strings of Length n (Medium)</li> <li> 1219. Path with Maximum Gold (Medium)</li> <li> 79. Word Search (Medium)</li> <li> 980. Unique Paths III (Hard)</li> <li> 1255. Maximum Score Words Formed by Letters (Hard)</li> <li> 473. Matchsticks to Square (Medium)</li> <li> 212. Word Search II (Hard)</li> <li> 37. Sudoku Solver (Hard)</li> <li> 638. Shopping Offers (Medium)</li> <li> 1240. Tiling a Rectangle with the Fewest Squares (Hard)</li> <li> 679. 24 Game (Hard)</li> <li> 282. Expression Add Operators (Hard)</li> <li> 126. Word Ladder II (Hard)</li> <li> 691. Stickers to Spell Word (Hard)</li> <li> 2056. Number of Valid Move Combinations On Chessboard (Hard)</li> <li> 2386. Find the K-Sum of an Array (Hard)</li> <li> 488. Zuma Game (Hard)</li> <li> 2664. The Knight\u2019s Tour (Medium) \ud83d\udc51</li> <li> 247. Strobogrammatic Number II (Medium) \ud83d\udc51</li> <li> 248. Strobogrammatic Number III (Hard) \ud83d\udc51</li> <li> 411. Minimum Unique Word Abbreviation (Hard) \ud83d\udc51</li> <li> 1088. Confusing Number II (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/backtracking_exhaustive_search_and_pruning/#3211-generate-binary-strings-without-adjacent-zeros","title":"3211. Generate Binary Strings Without Adjacent Zeros","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Backtracking, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_exhaustive_search_and_pruning/#967-numbers-with-same-consecutive-differences","title":"967. Numbers With Same Consecutive Differences","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Backtracking, Breadth First Search</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_exhaustive_search_and_pruning/#1415-the-k-th-lexicographical-string-of-all-happy-strings-of-length-n","title":"1415. The k-th Lexicographical String of All Happy Strings of Length n","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Backtracking</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_exhaustive_search_and_pruning/#1219-path-with-maximum-gold","title":"1219. Path with Maximum Gold","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_exhaustive_search_and_pruning/#79-word-search","title":"79. Word Search","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Backtracking, Depth First Search, Matrix</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef exist(board: List[List[str]], word: str) -&gt; bool:\n    m, n = len(board), len(board[0])\n    path = set()\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n\n    def dfs(r, c, i):\n        if i == len(word):\n            return True\n\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or board[r][c] != word[i] or (r, c) in path:\n            return False\n\n        path.add((r, c))\n\n        for dr, dc in dirs:\n            if dfs(r + dr, c + dc, i + 1):\n                return True\n\n        path.remove((r, c))\n        return False\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, 0):\n                return True\n\n    return False\n\n\nboard = [\n    [\"A\", \"B\", \"C\", \"E\"],\n    [\"S\", \"F\", \"C\", \"S\"],\n    [\"A\", \"D\", \"E\", \"E\"],\n]\nword = \"ABCCED\"\nprint(exist(board, word))  # True\n</code></pre>"},{"location":"EndlessCheng/backtracking_exhaustive_search_and_pruning/#980-unique-paths-iii","title":"980. Unique Paths III","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking, Bit Manipulation, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_exhaustive_search_and_pruning/#1255-maximum-score-words-formed-by-letters","title":"1255. Maximum Score Words Formed by Letters","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Dynamic Programming, Backtracking, Bit Manipulation, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_exhaustive_search_and_pruning/#473-matchsticks-to-square","title":"473. Matchsticks to Square","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Backtracking, Bit Manipulation, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_exhaustive_search_and_pruning/#212-word-search-ii","title":"212. Word Search II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Backtracking, Trie, Matrix</p> </li> </ul> Python <pre><code>from typing import List\n\nfrom leetpattern.utils import Trie\n\n\n# Backtracking + Trie\ndef findWords(board: List[List[str]], words: List[str]) -&gt; List[str]:\n    trie = Trie()\n    for word in words:\n        trie.add_word(word)\n\n    m, n = len(board), len(board[0])\n    result, visit = set(), set()\n\n    def dfs(r, c, node, word):\n        if (\n            r &lt; 0\n            or r &gt;= m\n            or c &lt; 0\n            or c &gt;= n\n            or (r, c) in visit\n            or board[r][c] not in node.children\n        ):\n            return None\n\n        visit.add((r, c))\n\n        node = node.children[board[r][c]]\n        word += board[r][c]\n        if node.is_word:\n            result.add(word)\n\n        dfs(r - 1, c, node, word)\n        dfs(r + 1, c, node, word)\n        dfs(r, c - 1, node, word)\n        dfs(r, c + 1, node, word)\n\n        visit.remove((r, c))\n\n    for r in range(m):\n        for c in range(n):\n            dfs(r, c, trie.root, \"\")\n\n    return list(result)\n\n\ndef test_find_words():\n    board = [\n        [\"o\", \"a\", \"a\", \"n\"],\n        [\"e\", \"t\", \"a\", \"e\"],\n        [\"i\", \"h\", \"k\", \"r\"],\n        [\"i\", \"f\", \"l\", \"v\"],\n    ]\n    words = [\"oath\", \"pea\", \"eat\", \"rain\"]\n    result = findWords(board, words)\n    assert sorted(result) == [\"eat\", \"oath\"]\n</code></pre>"},{"location":"EndlessCheng/backtracking_exhaustive_search_and_pruning/#37-sudoku-solver","title":"37. Sudoku Solver","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Backtracking, Matrix</p> </li> </ul> Python <pre><code>\"\"\"\n- [Sudoku Solver](https://leetcode.com/problems/sudoku-solver/)\n- [\u89e3\u6570\u72ec](https://leetcode.cn/problems/sudoku-solver/)\n- Hard\n\"\"\"\n\nfrom pprint import pprint\nfrom typing import List\n\n\n# Backtracking - Board\ndef solveSudoku(board: List[List[str]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n\n    def backtracking(board: List[List[str]]) -&gt; bool:\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] != \".\":\n                    continue\n                for k in range(1, 10):\n                    if is_valid(i, j, k, board):\n                        board[i][j] = str(k)\n                        if backtracking(board):\n                            return True\n                        board[i][j] = \".\"\n                return False\n        return True\n\n    def is_valid(row: int, col: int, val: int, board: List[List[str]]) -&gt; bool:\n        for i in range(9):\n            if board[row][i] == str(val):\n                return False\n        for j in range(9):\n            if board[j][col] == str(val):\n                return False\n        start_row = (row // 3) * 3\n        start_col = (col // 3) * 3\n        for i in range(start_row, start_row + 3):\n            for j in range(start_col, start_col + 3):\n                if board[i][j] == str(val):\n                    return False\n        return True\n\n    backtracking(board)\n\n\nboard = [\n    [\"5\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],\n    [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n    [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n    [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n    [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n    [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n    [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"],\n    [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n    [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"],\n]\n\nsolveSudoku(board)\npprint(board)\n# [['5', '3', '4', '6', '7', '8', '9', '1', '2'],\n#  ['6', '7', '2', '1', '9', '5', '3', '4', '8'],\n#  ['1', '9', '8', '3', '4', '2', '5', '6', '7'],\n#  ['8', '5', '9', '7', '6', '1', '4', '2', '3'],\n#  ['4', '2', '6', '8', '5', '3', '7', '9', '1'],\n#  ['7', '1', '3', '9', '2', '4', '8', '5', '6'],\n#  ['9', '6', '1', '5', '3', '7', '2', '8', '4'],\n#  ['2', '8', '7', '4', '1', '9', '6', '3', '5'],\n#  ['3', '4', '5', '2', '8', '6', '1', '7', '9']]\n</code></pre>"},{"location":"EndlessCheng/backtracking_exhaustive_search_and_pruning/#638-shopping-offers","title":"638. Shopping Offers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Backtracking, Bit Manipulation, Memoization, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_exhaustive_search_and_pruning/#1240-tiling-a-rectangle-with-the-fewest-squares","title":"1240. Tiling a Rectangle with the Fewest Squares","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Backtracking</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_exhaustive_search_and_pruning/#679-24-game","title":"679. 24 Game","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Backtracking</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_exhaustive_search_and_pruning/#282-expression-add-operators","title":"282. Expression Add Operators","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String, Backtracking</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_exhaustive_search_and_pruning/#126-word-ladder-ii","title":"126. Word Ladder II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Backtracking, Breadth First Search</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_exhaustive_search_and_pruning/#691-stickers-to-spell-word","title":"691. Stickers to Spell Word","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Dynamic Programming, Backtracking, Bit Manipulation, Memoization, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_exhaustive_search_and_pruning/#2056-number-of-valid-move-combinations-on-chessboard","title":"2056. Number of Valid Move Combinations On Chessboard","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Backtracking, Simulation</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_exhaustive_search_and_pruning/#2386-find-the-k-sum-of-an-array","title":"2386. Find the K-Sum of an Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sorting, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_exhaustive_search_and_pruning/#488-zuma-game","title":"488. Zuma Game","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Stack, Breadth First Search, Memoization</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_exhaustive_search_and_pruning/#2664-the-knights-tour","title":"2664. The Knight\u2019s Tour \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_exhaustive_search_and_pruning/#247-strobogrammatic-number-ii","title":"247. Strobogrammatic Number II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Recursion</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_exhaustive_search_and_pruning/#248-strobogrammatic-number-iii","title":"248. Strobogrammatic Number III \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Recursion</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_exhaustive_search_and_pruning/#411-minimum-unique-word-abbreviation","title":"411. Minimum Unique Word Abbreviation \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Backtracking, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_exhaustive_search_and_pruning/#1088-confusing-number-ii","title":"1088. Confusing Number II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Backtracking</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_partition/","title":"Backtracking Partition","text":""},{"location":"EndlessCheng/backtracking_partition/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 131. Palindrome Partitioning (Medium)</li> <li> 2698. Find the Punishment Number of an Integer (Medium)</li> <li> 1593. Split a String Into the Max Number of Unique Substrings (Medium)</li> <li> 1849. Splitting a String Into Descending Consecutive Values (Medium)</li> <li> 306. Additive Number (Medium)</li> <li> 842. Split Array into Fibonacci Sequence (Medium)</li> <li> 93. Restore IP Addresses (Medium)</li> <li> 816. Ambiguous Coordinates (Medium)</li> <li> 140. Word Break II (Hard)</li> <li> 291. Word Pattern II (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/backtracking_partition/#131-palindrome-partitioning","title":"131. Palindrome Partitioning","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Backtracking</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Backtracking\ndef partition(s: str) -&gt; List[List[str]]:\n    n = len(s)\n    res, path = [], []\n\n    def dfs(start):\n        if start == n:\n            res.append(path.copy())\n            return\n\n        for end in range(start, n):\n            cur = s[start : end + 1]\n            if cur == cur[::-1]:\n                path.append(cur)\n                dfs(end + 1)\n                path.pop()\n\n    dfs(0)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(partition(\"aab\"))\n    # [['a', 'a', 'b'], ['aa', 'b']]\n</code></pre>"},{"location":"EndlessCheng/backtracking_partition/#2698-find-the-punishment-number-of-an-integer","title":"2698. Find the Punishment Number of an Integer","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Backtracking</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_partition/#1593-split-a-string-into-the-max-number-of-unique-substrings","title":"1593. Split a String Into the Max Number of Unique Substrings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Backtracking</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_partition/#1849-splitting-a-string-into-descending-consecutive-values","title":"1849. Splitting a String Into Descending Consecutive Values","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Backtracking</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_partition/#306-additive-number","title":"306. Additive Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Backtracking</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_partition/#842-split-array-into-fibonacci-sequence","title":"842. Split Array into Fibonacci Sequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Backtracking</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_partition/#93-restore-ip-addresses","title":"93. Restore IP Addresses","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Backtracking</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef restoreIpAddresses(s: str) -&gt; List[str]:\n    result = []\n\n    def backtracking(start_index, point_num, current, result):\n        # stop condition\n        if point_num == 3:\n            if is_valid(s, start_index, len(s) - 1):\n                current += s[start_index:]\n                result.append(current)\n            return\n\n        for i in range(start_index, len(s)):\n            if is_valid(s, start_index, i):\n                sub = s[start_index : i + 1]\n                backtracking(i + 1, point_num + 1, current + sub + \".\", result)\n            else:\n                break\n\n    def is_valid(s, start, end):\n        if start &gt; end:\n            return False\n\n        if s[start] == \"0\" and start != end:\n            return False\n\n        num = 0\n        for i in range(start, end + 1):\n            if not s[i].isdigit():\n                return False\n            num = num * 10 + int(s[i])\n            if num &gt; 255:\n                return False\n        return True\n\n    backtracking(0, 0, \"\", result)\n\n    return result\n\n\nprint(restoreIpAddresses(\"25525511135\"))\n# ['255.255.11.135', '255.255.111.35']\n</code></pre>"},{"location":"EndlessCheng/backtracking_partition/#816-ambiguous-coordinates","title":"816. Ambiguous Coordinates","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Backtracking, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_partition/#140-word-break-ii","title":"140. Word Break II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Dynamic Programming, Backtracking, Trie, Memoization</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_partition/#291-word-pattern-ii","title":"291. Word Pattern II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Backtracking</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_permutation/","title":"Backtracking Permutation","text":""},{"location":"EndlessCheng/backtracking_permutation/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 46. Permutations (Medium)</li> <li> 3376. Minimum Time to Break Locks I (Medium)</li> <li> 51. N-Queens (Hard)</li> <li> 52. N-Queens II (Hard)</li> <li> 2850. Minimum Moves to Spread Stones Over Grid (Medium)</li> <li> 1718. Construct the Lexicographically Largest Valid Sequence (Medium)</li> <li> 1307. Verbal Arithmetic Puzzle (Hard)</li> <li> 2014. Longest Subsequence Repeated k Times (Hard)</li> <li> 267. Palindrome Permutation II (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/backtracking_permutation/#46-permutations","title":"46. Permutations","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Backtracking\ndef permute(nums: List[int]) -&gt; List[List[int]]:\n    n = len(nums)\n    path, res = [], []\n    used = [False for _ in range(n)]\n\n    def dfs(x: int):\n        if x == n:\n            res.append(path[:])\n            return\n\n        for i in range(n):\n            if used[i]:\n                continue\n            used[i] = True\n            path.append(nums[i])\n            dfs(x + 1)\n            path.pop()\n            used[i] = False\n\n    dfs(0)\n\n    return res\n\n\nprint(permute([1, 2, 3]))\n# [[1, 2, 3], [1, 3, 2], [2, 1, 3],\n#  [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n</code></pre>"},{"location":"EndlessCheng/backtracking_permutation/#3376-minimum-time-to-break-locks-i","title":"3376. Minimum Time to Break Locks I","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Backtracking, Bit Manipulation, Depth First Search, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_permutation/#51-n-queens","title":"51. N-Queens","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking</p> </li> </ul> Python <pre><code>\"\"\"\n- Hard\n- [N-Queens](https://leetcode.com/problems/n-queens/)\n- [N \u7687\u540e](https://leetcode.cn/problems/n-queens/)\n\"\"\"\n\nfrom typing import List\n\n\n# Backtracking\ndef solveNQueens(n: int) -&gt; List[List[str]]:\n    res = []\n    board = [\".\" * n for _ in range(n)]\n\n    def dfs(row):\n        if row == n:\n            res.append(board[:])\n            return None\n        for col in range(n):\n            if is_valid(row, col, board):\n                board[row] = board[row][:col] + \"Q\" + board[row][col + 1 :]\n                dfs(row + 1)\n                board[row] = board[row][:col] + \".\" + board[row][col + 1 :]\n\n    def is_valid(row, col, chessboard):\n        for i in range(row):\n            if chessboard[i][col] == \"Q\":\n                return False\n\n        i, j = row - 1, col - 1\n        while i &gt;= 0 and j &gt;= 0:\n            if chessboard[i][j] == \"Q\":\n                return False\n            i -= 1\n            j -= 1\n\n        i, j = row - 1, col + 1\n        while i &gt;= 0 and j &lt; len(chessboard):\n            if chessboard[i][j] == \"Q\":\n                return False\n            i -= 1\n            j += 1\n\n        return True\n\n    dfs(0)\n\n    return [[\"\".join(row) for row in i] for i in res]\n\n\n# Backtracking\ndef solveNQueens2(n: int) -&gt; List[List[str]]:\n    res = []\n    queens = [0] * n\n    col = [False] * n\n    diag1 = [False] * (n * 2 - 1)\n    diag2 = [False] * (n * 2 - 1)\n\n    def dfs(r: int) -&gt; None:\n        if r == n:\n            res.append([\".\" * c + \"Q\" + \".\" * (n - 1 - c) for c in queens])\n            return\n\n        for c, ok in enumerate(col):\n            if not ok and not diag1[r + c] and not diag2[r - c]:\n                queens[r] = c\n                col[c] = diag1[r + c] = diag2[r - c] = True\n                dfs(r + 1)\n                col[c] = diag1[r + c] = diag2[r - c] = False\n\n    dfs(0)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(solveNQueens(4))\n    # [['.Q..', '...Q', 'Q...', '..Q.'],\n    #  ['..Q.', 'Q...', '...Q', '.Q..']]\n    print(solveNQueens(1))\n    # [['Q']]\n    print(solveNQueens2(4))\n    # [['.Q..', '...Q', 'Q...', '..Q.'],\n    #  ['..Q.', 'Q...', '...Q', '.Q..']]\n    print(solveNQueens2(1))\n    # [['Q']]\n</code></pre>"},{"location":"EndlessCheng/backtracking_permutation/#52-n-queens-ii","title":"52. N-Queens II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Backtracking</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_permutation/#2850-minimum-moves-to-spread-stones-over-grid","title":"2850. Minimum Moves to Spread Stones Over Grid","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Breadth First Search, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_permutation/#1718-construct-the-lexicographically-largest-valid-sequence","title":"1718. Construct the Lexicographically Largest Valid Sequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_permutation/#1307-verbal-arithmetic-puzzle","title":"1307. Verbal Arithmetic Puzzle","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, String, Backtracking</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_permutation/#2014-longest-subsequence-repeated-k-times","title":"2014. Longest Subsequence Repeated k Times","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Backtracking, Greedy, Counting, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_permutation/#267-palindrome-permutation-ii","title":"267. Palindrome Permutation II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Backtracking</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_subset/","title":"Backtracking Subset","text":""},{"location":"EndlessCheng/backtracking_subset/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 78. Subsets (Medium)</li> <li> 784. Letter Case Permutation (Medium)</li> <li> 1286. Iterator for Combination (Medium)</li> <li> 494. Target Sum (Medium)</li> <li> 2397. Maximum Rows Covered by Columns (Medium)</li> <li> 1239. Maximum Length of a Concatenated String with Unique Characters (Medium)</li> <li> 2212. Maximum Points in an Archery Competition (Medium)</li> <li> 1255. Maximum Score Words Formed by Letters (Hard)</li> <li> 2151. Maximum Good People Based on Statements (Hard)</li> <li> 2597. The Number of Beautiful Subsets (Medium)</li> <li> 2959. Number of Possible Sets of Closing Branches (Hard)</li> <li> 1601. Maximum Number of Achievable Transfer Requests (Hard)</li> <li> 1617. Count Subtrees With Max Distance Between Cities (Hard)</li> <li> 320. Generalized Abbreviation (Medium) \ud83d\udc51</li> <li> 254. Factor Combinations (Medium) \ud83d\udc51</li> <li> 39. Combination Sum (Medium)</li> </ul>"},{"location":"EndlessCheng/backtracking_subset/#78-subsets","title":"78. Subsets","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking, Bit Manipulation</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Iterative Inclusion Backtracking\ndef subsets_iterative_inclusion(nums: List[int]) -&gt; List[List[int]]:\n    n = len(nums)\n    res, path = [], []\n\n    def dfs(i):\n        res.append(path.copy())\n\n        for j in range(i, n):\n            path.append(nums[j])\n            dfs(j + 1)\n            path.pop()\n\n    dfs(0)\n\n    return res\n\n\n# Binary Decision Backtracking\ndef subsets_binary_decision(nums: List[int]) -&gt; List[List[int]]:\n    n = len(nums)\n    res, path = [], []\n\n    def dfs(i):\n        if i == n:\n            res.append(path.copy())\n            return\n\n        # Exclude\n        dfs(i + 1)\n\n        # Include\n        path.append(nums[i])\n        dfs(i + 1)\n        path.pop()\n\n    dfs(0)\n\n    return res\n\n\nprint(subsets_iterative_inclusion([1, 2, 3]))\n# [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]\nprint(subsets_binary_decision([1, 2, 3]))\n# [[], [3], [2], [2, 3], [1], [1, 3], [1, 2], [1, 2, 3]]\n</code></pre>"},{"location":"EndlessCheng/backtracking_subset/#784-letter-case-permutation","title":"784. Letter Case Permutation","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Backtracking, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_subset/#1286-iterator-for-combination","title":"1286. Iterator for Combination","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Backtracking, Design, Iterator</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_subset/#494-target-sum","title":"494. Target Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Backtracking</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef findTargetSumWays(nums: List[int], target: int) -&gt; int:\n\n    totalSum = sum(nums)\n\n    if abs(target) &gt; totalSum:\n        return 0\n    if (target + totalSum) % 2 == 1:\n        return 0\n\n    targetSum = (target + totalSum) // 2\n    dp = [0] * (targetSum + 1)\n    dp[0] = 1\n\n    for i in range(len(nums)):\n        for j in range(targetSum, nums[i] - 1, -1):\n            dp[j] += dp[j - nums[i]]\n\n    return dp[targetSum]\n\n\nnums = [1, 1, 1, 1, 1]\ntarget = 3\nprint(findTargetSumWays(nums, target))  # 5\n</code></pre>"},{"location":"EndlessCheng/backtracking_subset/#2397-maximum-rows-covered-by-columns","title":"2397. Maximum Rows Covered by Columns","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking, Bit Manipulation, Matrix, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_subset/#1239-maximum-length-of-a-concatenated-string-with-unique-characters","title":"1239. Maximum Length of a Concatenated String with Unique Characters","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Backtracking, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_subset/#2212-maximum-points-in-an-archery-competition","title":"2212. Maximum Points in an Archery Competition","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking, Bit Manipulation, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_subset/#1255-maximum-score-words-formed-by-letters","title":"1255. Maximum Score Words Formed by Letters","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Dynamic Programming, Backtracking, Bit Manipulation, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_subset/#2151-maximum-good-people-based-on-statements","title":"2151. Maximum Good People Based on Statements","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking, Bit Manipulation, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_subset/#2597-the-number-of-beautiful-subsets","title":"2597. The Number of Beautiful Subsets","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Dynamic Programming, Backtracking, Sorting, Combinatorics</p> </li> </ul> CPP <pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Solution {\n   public:\n    int beautifulSubsets(vector&lt;int&gt;&amp; nums, int k) {\n        int res = 0;\n        unordered_map&lt;int, int&gt; cnt;\n\n        auto dfs = [&amp;](auto&amp;&amp; self, int i) -&gt; void {\n            if (i == (int)nums.size()) {\n                res++;\n                return;\n            }\n            self(self, i + 1);  // Skip nums[i]\n            int x = nums[i];\n            if (cnt[x - k] == 0 &amp;&amp; cnt[x + k] == 0) {\n                cnt[x]++;\n                self(self, i + 1);  // Include nums[i]\n                cnt[x]--;           // Backtrack\n            }\n        };\n\n        dfs(dfs, 0);\n\n        return res - 1;\n    }\n};\n\nint main() {\n    Solution sol;\n    vector&lt;int&gt; nums = {1, 2, 3, 4};\n    int k = 1;\n    cout &lt;&lt; sol.beautifulSubsets(nums, k) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/backtracking_subset/#2959-number-of-possible-sets-of-closing-branches","title":"2959. Number of Possible Sets of Closing Branches","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Bit Manipulation, Graph, Heap Priority Queue, Enumeration, Shortest Path</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_subset/#1601-maximum-number-of-achievable-transfer-requests","title":"1601. Maximum Number of Achievable Transfer Requests","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking, Bit Manipulation, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_subset/#1617-count-subtrees-with-max-distance-between-cities","title":"1617. Count Subtrees With Max Distance Between Cities","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Bit Manipulation, Tree, Enumeration, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_subset/#320-generalized-abbreviation","title":"320. Generalized Abbreviation \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Backtracking, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_subset/#254-factor-combinations","title":"254. Factor Combinations \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Backtracking</p> </li> </ul>"},{"location":"EndlessCheng/backtracking_subset/#39-combination-sum","title":"39. Combination Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef combinationSum(candidates: List[int], target: int) -&gt; List[List[int]]:\n    n = len(candidates)\n    res, path = [], []\n\n    def dfs(total, start):\n        if total &gt; target:\n            return\n        if total == target:\n            res.append(path.copy())\n            return\n\n        for i in range(start, n):\n            total += candidates[i]\n            path.append(candidates[i])\n            dfs(total, i)\n            total -= candidates[i]\n            path.pop()\n\n    dfs(0, 0)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(combinationSum([2, 3, 5], 8))\n    # [[2, 2, 2, 2], [2, 3, 3], [3, 5]]\n    print(combinationSum([2, 3, 6, 7], 7))\n    # [[2, 2, 3], [7]]\n</code></pre>"},{"location":"EndlessCheng/backtracking_with_duplicates/","title":"Backtracking with Duplicates","text":""},{"location":"EndlessCheng/backtracking_with_duplicates/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 90. Subsets II (Medium)</li> <li> 40. Combination Sum II (Medium)</li> <li> 491. Non-decreasing Subsequences (Medium)</li> <li> 47. Permutations II (Medium)</li> <li> 1079. Letter Tile Possibilities (Medium)</li> </ul>"},{"location":"EndlessCheng/backtracking_with_duplicates/#90-subsets-ii","title":"90. Subsets II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking, Bit Manipulation</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef subsetsWithDup(nums: List[int]) -&gt; List[List[int]]:\n    path, result = [], []\n    nums.sort()\n\n    def backtracking(startIndex):\n        if path not in result:\n            result.append(path[:])\n\n        for i in range(startIndex, len(nums)):\n            path.append(nums[i])\n            backtracking(i + 1)\n            path.pop()\n\n    backtracking(startIndex=0)\n\n    return result\n\n\nprint(subsetsWithDup([1, 2, 2]))\n# [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]\n</code></pre>"},{"location":"EndlessCheng/backtracking_with_duplicates/#40-combination-sum-ii","title":"40. Combination Sum II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef combinationSum2(candidates: List[int], target: int) -&gt; List[List[int]]:\n    result, path = [], []\n    candidates.sort()\n\n    def backtracking(total, start):\n        if total == target:\n            result.append(path[:])\n            return None\n\n        for i in range(start, len(candidates)):\n\n            if i &gt; start and candidates[i] == candidates[i - 1]:\n                continue\n\n            if total + candidates[i] &gt; target:\n                break\n\n            total += candidates[i]\n            path.append(candidates[i])\n            backtracking(total, i + 1)\n            total -= candidates[i]\n            path.pop()\n\n    backtracking(0, 0)\n\n    return result\n\n\nprint(combinationSum2([10, 1, 2, 7, 6, 1, 5], 8))\n# [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n</code></pre>"},{"location":"EndlessCheng/backtracking_with_duplicates/#491-non-decreasing-subsequences","title":"491. Non-decreasing Subsequences","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Backtracking, Bit Manipulation</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef findSubsequences(nums: List[int]) -&gt; List[List[int]]:\n    path, result = [], []\n\n    def backtracking(startIndex):\n        if len(path) &gt; 1:\n            result.append(path[:])\n\n        used = set()\n        for i in range(startIndex, len(nums)):\n\n            if (path and nums[i] &lt; path[-1]) or nums[i] in used:\n                continue\n\n            used.add(nums[i])\n            path.append(nums[i])\n            backtracking(i + 1)\n            path.pop()\n\n    backtracking(0)\n\n    return result\n\n\nprint(findSubsequences([4, 6, 7, 7]))\n# [[4, 6], [4, 6, 7], [4, 6, 7, 7], [4, 7], [4, 7, 7], [6, 7], [6, 7, 7], [7, 7]]\n</code></pre>"},{"location":"EndlessCheng/backtracking_with_duplicates/#47-permutations-ii","title":"47. Permutations II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking, Sorting</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef permuteUnique(nums: List[int]) -&gt; List[List[int]]:\n    nums.sort()\n    path, result = [], []\n    used = [False for _ in range(len(nums))]\n\n    def backtracking():\n        if len(path) == len(nums):\n            result.append(path[:])\n\n        for i in range(len(nums)):\n            if used[i]:\n                continue\n            if i &gt; 0 and nums[i] == nums[i - 1] and not used[i - 1]:\n                continue\n\n            used[i] = True\n            path.append(nums[i])\n            backtracking()\n            path.pop()\n            used[i] = False\n\n    backtracking()\n\n    return result\n\n\nprint(permuteUnique([1, 1, 2]))\n# [[1, 1, 2], [1, 2, 1], [2, 1, 1]]\n</code></pre>"},{"location":"EndlessCheng/backtracking_with_duplicates/#1079-letter-tile-possibilities","title":"1079. Letter Tile Possibilities","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Backtracking, Counting</p> </li> </ul>"},{"location":"EndlessCheng/ball_placement_problems/","title":"Ball Placement Problems","text":""},{"location":"EndlessCheng/ball_placement_problems/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1641. Count Sorted Vowel Strings (Medium)</li> <li> 1621. Number of Sets of K Non-Overlapping Line Segments (Medium)</li> <li> 920. Number of Music Playlists (Hard)</li> <li> 1735. Count Ways to Make Array With Product (Hard)</li> <li> 2338. Count the Number of Ideal Arrays (Hard)</li> </ul>"},{"location":"EndlessCheng/ball_placement_problems/#1641-count-sorted-vowel-strings","title":"1641. Count Sorted Vowel Strings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Combinatorics</p> </li> </ul>"},{"location":"EndlessCheng/ball_placement_problems/#1621-number-of-sets-of-k-non-overlapping-line-segments","title":"1621. Number of Sets of K Non-Overlapping Line Segments","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Combinatorics</p> </li> </ul>"},{"location":"EndlessCheng/ball_placement_problems/#920-number-of-music-playlists","title":"920. Number of Music Playlists","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Combinatorics</p> </li> </ul>"},{"location":"EndlessCheng/ball_placement_problems/#1735-count-ways-to-make-array-with-product","title":"1735. Count Ways to Make Array With Product","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Combinatorics, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/ball_placement_problems/#2338-count-the-number-of-ideal-arrays","title":"2338. Count the Number of Ideal Arrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Combinatorics, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/basic_inequality/","title":"Basic Inequality","text":""},{"location":"EndlessCheng/basic_inequality/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3081. Replace Question Marks in String to Minimize Its Value (Medium)</li> <li> 1969. Minimum Non-Zero Product of the Array Elements (Medium)</li> <li> 2939. Maximum Xor Product (Medium)</li> <li> 2897. Apply Operations on Array to Maximize Sum of Squares (Hard)</li> </ul>"},{"location":"EndlessCheng/basic_inequality/#3081-replace-question-marks-in-string-to-minimize-its-value","title":"3081. Replace Question Marks in String to Minimize Its Value","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Greedy, Sorting, Heap Priority Queue, Counting</p> </li> </ul>"},{"location":"EndlessCheng/basic_inequality/#1969-minimum-non-zero-product-of-the-array-elements","title":"1969. Minimum Non-Zero Product of the Array Elements","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Greedy, Recursion</p> </li> </ul>"},{"location":"EndlessCheng/basic_inequality/#2939-maximum-xor-product","title":"2939. Maximum Xor Product","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Greedy, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/basic_inequality/#2897-apply-operations-on-array-to-maximize-sum-of-squares","title":"2897. Apply Operations on Array to Maximize Sum of Squares","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Greedy, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bfs_basics/","title":"BFS Basics","text":""},{"location":"EndlessCheng/bfs_basics/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3243. Shortest Distance After Road Addition Queries I (Medium)</li> <li> 1311. Get Watched Videos by Your Friends (Medium)</li> <li> 1129. Shortest Path with Alternating Colors (Medium)</li> <li> 1298. Maximum Candies You Can Get from Boxes (Hard)</li> <li> 2039. The Time When the Network Becomes Idle (Medium)</li> <li> 2608. Shortest Cycle in a Graph (Hard)</li> <li> 815. Bus Routes (Hard)</li> </ul>"},{"location":"EndlessCheng/bfs_basics/#3243-shortest-distance-after-road-addition-queries-i","title":"3243. Shortest Distance After Road Addition Queries I","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Breadth First Search, Graph</p> </li> </ul> Python <pre><code>\"\"\"\n- `n=5`, `queries = [[2,4],[0,2],[0,4]]`\n- ![1](https://assets.leetcode.com/uploads/2024/06/28/image8.jpg)\n- ![2](https://assets.leetcode.com/uploads/2024/06/28/image9.jpg)\n- ![3](https://assets.leetcode.com/uploads/2024/06/28/image10.jpg)\n- Output: `[3,2,1]`\n\"\"\"\n\nfrom collections import deque\nfrom itertools import count\nfrom typing import List\n\n\n# BFS\ndef shortestDistanceAfterQueries(n: int, queries: List[List[int]]) -&gt; List[int]:\n    g = [[] for _ in range(n)]\n    for i in range(n - 1):\n        g[i].append(i + 1)\n\n    vis = [-1 for _ in range(n)]\n\n    def bfs(i: int) -&gt; int:\n        q = deque([0])\n        for step in count(1):\n            tmp = q\n            q = deque()\n            for x in tmp:\n                for y in g[x]:\n                    if y == n - 1:\n                        return step\n                    if vis[y] != i:\n                        vis[y] = i\n                        q.append(y)\n        return -1\n\n    res = [0] * len(queries)\n    for i, (l, r) in enumerate(queries):\n        g[l].append(r)\n        res[i] = bfs(i)\n\n    return res\n\n\nn = 5\nqueries = [[2, 4], [0, 2], [0, 4]]\nprint(shortestDistanceAfterQueries(n, queries))  # [3, 2, 1]\n</code></pre>"},{"location":"EndlessCheng/bfs_basics/#1311-get-watched-videos-by-your-friends","title":"1311. Get Watched Videos by Your Friends","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Breadth First Search, Graph, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/bfs_basics/#1129-shortest-path-with-alternating-colors","title":"1129. Shortest Path with Alternating Colors","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Breadth First Search, Graph</p> </li> </ul> Python <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef shortestAlternatingPaths(\n    n: int, redEdges: List[List[int]], blueEdges: List[List[int]]\n) -&gt; List[int]:\n    red_graph = defaultdict(list)\n    blue_graph = defaultdict(list)\n\n    for u, v in redEdges:\n        red_graph[u].append(v)\n    for u, v in blueEdges:\n        blue_graph[u].append(v)\n\n    answer = [-1 for _ in range(n)]\n    q = deque([(0, 0, 0), (0, 0, 1)])  # (node, distance, color)\n    visited = set()\n\n    while q:\n        node, dist, color = q.popleft()\n        if (node, color) in visited:\n            continue\n        visited.add((node, color))\n        if answer[node] == -1:\n            answer[node] = dist\n        if color == 0:\n            for neighbor in blue_graph[node]:\n                q.append((neighbor, dist + 1, 1))\n        else:\n            for neighbor in red_graph[node]:\n                q.append((neighbor, dist + 1, 0))\n\n    return answer\n\n\nn = 3\nred_edges = [[0, 1], [1, 2]]\nblue_edges = []\nprint(shortestAlternatingPaths(n, red_edges, blue_edges))  # [0, 1, -1]\n</code></pre>"},{"location":"EndlessCheng/bfs_basics/#1298-maximum-candies-you-can-get-from-boxes","title":"1298. Maximum Candies You Can Get from Boxes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Breadth First Search, Graph</p> </li> </ul>"},{"location":"EndlessCheng/bfs_basics/#2039-the-time-when-the-network-becomes-idle","title":"2039. The Time When the Network Becomes Idle","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Breadth First Search, Graph</p> </li> </ul>"},{"location":"EndlessCheng/bfs_basics/#2608-shortest-cycle-in-a-graph","title":"2608. Shortest Cycle in a Graph","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Breadth First Search, Graph</p> </li> </ul>"},{"location":"EndlessCheng/bfs_basics/#815-bus-routes","title":"815. Bus Routes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Breadth First Search</p> </li> </ul> Python <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef numBusesToDestination(routes: List[List[int]], source: int, target: int) -&gt; int:\n    if source == target:\n        return 0\n\n    graph = defaultdict(set)  # {stop: buses}\n    for buses, route in enumerate(routes):\n        for stop in route:\n            graph[stop].add(buses)\n\n    q = deque([(source, 0)])  # (stop, bus)\n    visited_stops = set([source])\n    visited_buses = set()\n\n    while q:\n        stop, bus = q.popleft()\n\n        if stop == target:\n            return bus\n\n        for buses in graph[stop]:\n            if buses not in visited_buses:\n                visited_buses.add(buses)\n                for next_stop in routes[buses]:\n                    if next_stop not in visited_stops:\n                        visited_stops.add(next_stop)\n                        q.append((next_stop, bus + 1))\n\n    return -1\n\n\nroutes = [[1, 2, 7], [3, 6, 7]]\nsource = 1\ntarget = 6\nprint(numBusesToDestination(routes, source, target))  # 2\n</code></pre>"},{"location":"EndlessCheng/binary_search_advanced/","title":"Binary Search Advanced","text":""},{"location":"EndlessCheng/binary_search_advanced/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2300. Successful Pairs of Spells and Potions (Medium)</li> <li> 1385. Find the Distance Value Between Two Arrays (Easy)</li> <li> 2389. Longest Subsequence With Limited Sum (Easy)</li> <li> 1170. Compare Strings by Frequency of the Smallest Character (Medium)</li> <li> 2080. Range Frequency Queries (Medium)</li> <li> 2563. Count the Number of Fair Pairs (Medium)</li> <li> 2070. Most Beautiful Item for Each Query (Medium)</li> <li> 981. Time Based Key-Value Store (Medium)</li> <li> 1146. Snapshot Array (Medium)</li> <li> 658. Find K Closest Elements (Medium)</li> <li> 1818. Minimum Absolute Sum Difference (Medium)</li> <li> 911. Online Election (Medium)</li> <li> 1182. Shortest Distance to Target Color (Medium) \ud83d\udc51</li> <li> 2819. Minimum Relative Loss After Buying Chocolates (Hard) \ud83d\udc51</li> <li> 1287. Element Appearing More Than 25% In Sorted Array (Easy)</li> <li> 1150. Check If a Number Is Majority Element in a Sorted Array (Easy) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/binary_search_advanced/#2300-successful-pairs-of-spells-and-potions","title":"2300. Successful Pairs of Spells and Potions","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Sorting</p> </li> </ul> Python <pre><code>import bisect\nfrom typing import List\n\n\nclass successfulPairs:\n    @staticmethod\n    def binary_search(spells: List[int], potions: List[int], success: int) -&gt; List[int]:\n        n = len(potions)\n        res = []\n\n        potions.sort()\n\n        for spell in spells:\n            target = (success + spell - 1) // spell\n            index = bisect.bisect_left(potions, target)\n            res.append(n - index)\n\n        return res\n\n\nif __name__ == \"__main__\":\n    spells = [5, 1, 3]\n    potions = [1, 2, 3, 4, 5]\n    success = 7\n    assert successfulPairs.binary_search(spells, potions, success) == [4, 0, 3]\n</code></pre>"},{"location":"EndlessCheng/binary_search_advanced/#1385-find-the-distance-value-between-two-arrays","title":"1385. Find the Distance Value Between Two Arrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Sorting</p> </li> </ul> Python <pre><code>from bisect import bisect_left\nfrom typing import List\n\n\n# Binary Search\ndef findTheDistanceValue(arr1: List[int], arr2: List[int], d: int) -&gt; int:\n    arr2.sort()\n    res = 0\n\n    for x in arr1:\n        i = bisect_left(arr2, x - d)\n        if i == len(arr2) or arr2[i] &gt; x + d:\n            res += 1\n\n    return res\n\n\narr1 = [4, 5, 8]\narr2 = [10, 9, 1, 8]\nd = 2\nprint(findTheDistanceValue(arr1, arr2, d))  # 2\n</code></pre>"},{"location":"EndlessCheng/binary_search_advanced/#2389-longest-subsequence-with-limited-sum","title":"2389. Longest Subsequence With Limited Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Greedy, Sorting, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_advanced/#1170-compare-strings-by-frequency-of-the-smallest-character","title":"1170. Compare Strings by Frequency of the Smallest Character","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Binary Search, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_advanced/#2080-range-frequency-queries","title":"2080. Range Frequency Queries","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Binary Search, Design, Segment Tree</p> </li> </ul> Python <pre><code>from bisect import bisect_left, bisect_right\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Binary Search\nclass RangeFreqQuery:\n    def __init__(self, arr: List[int]):\n        self.freq = defaultdict(list)\n        for idx, val in enumerate(arr):\n            self.freq[val].append(idx)\n\n    def query(self, left: int, right: int, value: int) -&gt; int:\n        idxs = self.freq[value]\n        return bisect_right(idxs, right) - bisect_left(idxs, left)\n\n\narr = [1, 3, 1, 2, 4, 1, 3, 2, 1]\nrfq = RangeFreqQuery(arr)\nprint(rfq.query(0, 4, 1))  # 2\nprint(rfq.query(2, 8, 1))  # 3\nprint(rfq.query(0, 8, 3))  # 2\nprint(rfq.query(4, 7, 2))  # 1\n</code></pre>"},{"location":"EndlessCheng/binary_search_advanced/#2563-count-the-number-of-fair-pairs","title":"2563. Count the Number of Fair Pairs","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_advanced/#2070-most-beautiful-item-for-each-query","title":"2070. Most Beautiful Item for Each Query","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Sorting</p> </li> </ul> CPP <pre><code>#include &lt;algorithm&gt;\n#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;numeric&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;int&gt; maximumBeauty(vector&lt;vector&lt;int&gt;&gt;&amp; items, vector&lt;int&gt;&amp; queries) {\n    std::sort(items.begin(), items.end(),\n              [](const auto&amp; a, const auto&amp; b) { return a[0] &lt; b[0]; });\n    vector&lt;int&gt; idx(queries.size());\n    iota(idx.begin(), idx.end(), 0);\n    std::sort(idx.begin(), idx.end(),\n              [&amp;](int i, int j) { return queries[i] &lt; queries[j]; });\n\n    vector&lt;int&gt; res(queries.size());\n    int max_beauty = 0;\n    size_t j = 0;\n    for (int i : idx) {\n        int q = queries[i];\n        while (j &lt; items.size() &amp;&amp; items[j][0] &lt;= q) {\n            max_beauty = max(max_beauty, items[j][1]);\n            j++;\n        }\n        res[i] = max_beauty;\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;vector&lt;int&gt;&gt; items = {{1, 2}, {2, 4}, {3, 2}, {5, 6}, {3, 5}};\n    vector&lt;int&gt; queries = {1, 2, 3, 4, 5, 6};\n    vector&lt;int&gt; res = maximumBeauty(items, queries);\n    assert((res == vector&lt;int&gt;{2, 4, 5, 5, 6, 6}));\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/binary_search_advanced/#981-time-based-key-value-store","title":"981. Time Based Key-Value Store","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Binary Search, Design</p> </li> </ul> Python <pre><code>from collections import defaultdict\n\n\n# Binary Search\nclass TimeMap:\n\n    def __init__(self):\n        self.keys = defaultdict(list)\n        self.times = dict()\n\n    def set(self, key: str, value: str, timestamp: int) -&gt; None:\n        self.keys[key].append(timestamp)\n        self.times[timestamp] = value\n\n    def get(self, key: str, timestamp: int) -&gt; str:\n        tmp = self.keys[key]\n\n        left, right = 0, len(tmp) - 1\n        while left &lt;= right:\n            mid = left + (right - left) // 2\n            if tmp[mid] &gt; timestamp:\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        return self.times[tmp[right]] if right &gt;= 0 else \"\"\n\n\nobj = TimeMap()\nobj.set(\"foo\", \"bar\", 1)\nprint(obj.get(\"foo\", 1))  # bar\nprint(obj.get(\"foo\", 3))  # bar\nobj.set(\"foo\", \"bar2\", 4)\nprint(obj.get(\"foo\", 4))  # bar2\nprint(obj.get(\"foo\", 5))  # bar2\n</code></pre>"},{"location":"EndlessCheng/binary_search_advanced/#1146-snapshot-array","title":"1146. Snapshot Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Binary Search, Design</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_advanced/#658-find-k-closest-elements","title":"658. Find K Closest Elements","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Sliding Window, Sorting, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_advanced/#1818-minimum-absolute-sum-difference","title":"1818. Minimum Absolute Sum Difference","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Sorting, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_advanced/#911-online-election","title":"911. Online Election","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Binary Search, Design</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_advanced/#1182-shortest-distance-to-target-color","title":"1182. Shortest Distance to Target Color \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_advanced/#2819-minimum-relative-loss-after-buying-chocolates","title":"2819. Minimum Relative Loss After Buying Chocolates \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Sorting, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_advanced/#1287-element-appearing-more-than-25-in-sorted-array","title":"1287. Element Appearing More Than 25% In Sorted Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array</p> </li> </ul> Python <pre><code>from bisect import bisect_left, bisect_right\nfrom typing import List\n\n\n# Binary Search\ndef findSpecialInteger(arr: List[int]) -&gt; int:\n    n = len(arr)\n    span = n // 4 + 1\n\n    for i in range(0, n, span):\n        left = bisect_left(arr, arr[i])\n        right = bisect_right(arr, arr[i])\n        if right - left &gt;= span:\n            return arr[i]\n\n    return -1\n</code></pre>"},{"location":"EndlessCheng/binary_search_advanced/#1150-check-if-a-number-is-majority-element-in-a-sorted-array","title":"1150. Check If a Number Is Majority Element in a Sorted Array \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_basics/","title":"Binary Search Basics","text":""},{"location":"EndlessCheng/binary_search_basics/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 34. Find First and Last Position of Element in Sorted Array (Medium)</li> <li> 35. Search Insert Position (Easy)</li> <li> 704. Binary Search (Easy)</li> <li> 744. Find Smallest Letter Greater Than Target (Easy)</li> <li> 2529. Maximum Count of Positive Integer and Negative Integer (Easy)</li> </ul>"},{"location":"EndlessCheng/binary_search_basics/#34-find-first-and-last-position-of-element-in-sorted-array","title":"34. Find First and Last Position of Element in Sorted Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> PythonCPP <pre><code>from bisect import bisect_left\nfrom typing import List\n\n\nclass searchRange:\n    \"\"\"\n    \u627e lower bound \u548c upper bound\n    \u770b\u7075\u795e\u5bf9\u8fd9\u9053\u9898\u7684\u9898\u89e3\uff0c\u5206\u7c7b\u8ba8\u8bba\u533a\u95f4\u7684\u5199\u6cd5\n    target \u7684 upper bound \u662f target + 1 \u7684 lower bound - 1\n    \u8fd9\u6837\u5c31\u80fd\u7edf\u4e00\u7528 lower bound \u7684\u5199\u6cd5\n    \"\"\"\n\n    # [left, right]\n    def bisect_left_closed(self, nums, target):\n        \"\"\"\n        \u95ed\u533a\u95f4\u5199\u6cd5\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left &lt;= right:\n            mid = left + (right - left) // 2\n            if nums[mid] &lt; target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n\n    # [left, right)\n    def bisect_left_right_open(self, nums, target):\n        \"\"\"\n        \u5de6\u95ed\u53f3\u5f00\u533a\u95f4\u5199\u6cd5\n        \"\"\"\n        left, right = 0, len(nums)\n        while left &lt; right:\n            mid = left + (right - left) // 2\n            if nums[mid] &gt;= target:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\n    # (left, right)\n    def bisect_left_open(self, nums, target):\n        \"\"\"\n        \u63a8\u8350\u5f00\u533a\u95f4\u5199\u6cd5\n        \"\"\"\n        left, right = -1, len(nums)\n        while left + 1 &lt; right:\n            mid = left + (right - left) // 2\n            if nums[mid] &lt; target:\n                left = mid\n            else:\n                right = mid\n        return right\n\n    def search_range(self, nums: List[int], target: int) -&gt; List[int]:\n        # edge case\n        if not nums:\n            return [-1, -1]\n\n        lower = self.bisect_left_closed(nums, target)\n        upper = self.bisect_left_closed(nums, target + 1) - 1\n\n        return [lower, upper] if lower &lt;= upper else [-1, -1]\n\n    def search_range_bisect(self, nums: List[int], target: int) -&gt; List[int]:\n        \"\"\"\u7528 python bisect \u5e93\u51fd\u6570\"\"\"\n        # edge case\n        if not nums:\n            return [-1, -1]\n\n        lower = bisect_left(nums, target)\n        upper = bisect_left(nums, target + 1) - 1\n\n        return [lower, upper] if lower &lt;= upper else [-1, -1]\n\n\nif __name__ == \"__main__\":\n    nums = [5, 7, 7, 8, 8, 10]\n    target = 8\n    sol = searchRange()\n    assert sol.search_range(nums, target) == [3, 4]\n    assert sol.search_range_bisect(nums, target) == [3, 4]\n</code></pre> <pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\n  int bisect_left(vector&lt;int&gt; &amp;nums, int target)\n  {\n    int left = 0, right = (int)nums.size() - 1;\n\n    while (left &lt;= right)\n    {\n      int mid = left + (right - left) / 2;\n      if (nums[mid] &lt; target)\n      {\n        left = mid + 1;\n      }\n      else\n      {\n        right = mid - 1;\n      }\n    }\n    return left;\n  }\n\npublic:\n  vector&lt;int&gt; searchRange(vector&lt;int&gt; &amp;nums, int target)\n  {\n    int left = bisect_left(nums, target);\n    if (left == (int)nums.size() || nums[left] != target)\n    {\n      return {-1, -1};\n    }\n    int right = bisect_left(nums, target + 1) - 1;\n    return {left, right};\n  }\n};\n\nint main()\n{\n  vector&lt;int&gt; nums = {5, 7, 7, 8, 8, 10};\n  int target = 8;\n  Solution s;\n  vector&lt;int&gt; res = s.searchRange(nums, target);\n  cout &lt;&lt; res[0] &lt;&lt; \", \" &lt;&lt; res[1] &lt;&lt; endl;\n  return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/binary_search_basics/#35-search-insert-position","title":"35. Search Insert Position","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return the index of the target if it is found. If not, return the index where it would be if it were inserted in order.\n\"\"\"\n\nfrom typing import List\n\n\n# Binary Search\ndef searchInsert(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        if nums[mid] &lt; target:\n            left = mid + 1\n        elif nums[mid] &gt; target:\n            right = mid - 1\n        else:\n            return mid\n\n    return left\n\n\nnums = [1, 3, 5, 6]\ntarget = 5\nprint(searchInsert(nums, target))  # 2\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int searchInsert(vector&lt;int&gt;&amp; nums, int target) {\n        int left = 0, right = nums.size() - 1;\n\n        while (left &lt;= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] &lt; target)\n                left = mid + 1;\n            else\n                right = mid - 1;\n        }\n        return left;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; nums = {1, 3, 5, 6};\n    assert(solution.searchInsert(nums, 5) == 2);\n    assert(solution.searchInsert(nums, 2) == 1);\n    assert(solution.searchInsert(nums, 7) == 4);\n    assert(solution.searchInsert(nums, 0) == 0);\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/binary_search_basics/#704-binary-search","title":"704. Binary Search","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> Python <pre><code>\"\"\"\n- Implement binary search algorithm.\n\"\"\"\n\nfrom typing import List\n\n\n# Binary Search [left, right]\ndef search(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] &lt; target:\n            left = mid + 1\n        elif nums[mid] &gt; target:\n            right = mid - 1\n        else:\n            return mid\n\n    return -1\n\n\n# Binary Search [left, right)\ndef search_half_open(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums)\n\n    while left &lt; right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] &lt; target:\n            left = mid + 1\n        elif nums[mid] &gt; target:\n            right = mid\n        else:\n            return mid\n\n    return -1\n\n\n# Binary Search (left, right)\ndef search_open_interval(nums: List[int], target: int) -&gt; int:\n    left, right = -1, len(nums)\n\n    while left + 1 &lt; right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] &lt; target:\n            left = mid\n        elif nums[mid] &gt; target:\n            right = mid\n        else:\n            return mid\n\n    return -1\n\n\nif __name__ == \"__main__\":\n    nums = [-1, 0, 3, 5, 9, 12]\n    target = 9\n    assert search(nums, target) == 4\n    assert search_half_open(nums, target) == 4\n    assert search_open_interval(nums, target) == 4\n</code></pre>"},{"location":"EndlessCheng/binary_search_basics/#744-find-smallest-letter-greater-than-target","title":"744. Find Smallest Letter Greater Than Target","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Binary Search\ndef nextGreatestLetter(letters: List[str], target: str) -&gt; str:\n    left, right = 0, len(letters)\n\n    while left &lt; right:\n        mid = left + (right - left) // 2\n        if letters[mid] &gt; target:\n            right = mid\n        else:\n            left = mid + 1\n\n    return letters[left] if left &lt; len(letters) else letters[0]\n\n\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"a\"\nprint(nextGreatestLetter(letters, target))  # c\n</code></pre>"},{"location":"EndlessCheng/binary_search_basics/#2529-maximum-count-of-positive-integer-and-negative-integer","title":"2529. Maximum Count of Positive Integer and Negative Integer","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Counting</p> </li> </ul> Python <pre><code>from bisect import bisect_left, bisect_right\nfrom typing import List\n\n\n# Binary Search\ndef maximumCount(nums: List[int]) -&gt; int:\n    pos = bisect_left(nums, 0)\n    neg = len(nums) - bisect_right(nums, 0)\n\n    return max(pos, neg)\n\n\nnums = [-2, -1, -1, 1, 2, 3]\nprint(maximumCount(nums))  # 3\n</code></pre>"},{"location":"EndlessCheng/binary_search_indirect_value/","title":"Binary Search Indirect Value","text":""},{"location":"EndlessCheng/binary_search_indirect_value/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3143. Maximum Points Inside the Square (Medium)</li> <li> 1648. Sell Diminishing-Valued Colored Balls (Medium)</li> </ul>"},{"location":"EndlessCheng/binary_search_indirect_value/#3143-maximum-points-inside-the-square","title":"3143. Maximum Points Inside the Square","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Binary Search, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_indirect_value/#1648-sell-diminishing-valued-colored-balls","title":"1648. Sell Diminishing-Valued Colored Balls","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Binary Search, Greedy, Sorting, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_kth_min_max/","title":"Binary Search Kth Min Max","text":""},{"location":"EndlessCheng/binary_search_kth_min_max/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 668. Kth Smallest Number in Multiplication Table (Hard)</li> <li> 378. Kth Smallest Element in a Sorted Matrix (Medium)</li> <li> 719. Find K-th Smallest Pair Distance (Hard)</li> <li> 878. Nth Magical Number (Hard)</li> <li> 1201. Ugly Number III (Medium)</li> <li> 793. Preimage Size of Factorial Zeroes Function (Hard)</li> <li> 373. Find K Pairs with Smallest Sums (Medium)</li> <li> 1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows (Hard)</li> <li> 786. K-th Smallest Prime Fraction (Medium)</li> <li> 3116. Kth Smallest Amount With Single Denomination Combination (Hard)</li> <li> 3134. Find the Median of the Uniqueness Array (Hard)</li> <li> 2040. Kth Smallest Product of Two Sorted Arrays (Hard)</li> <li> 2386. Find the K-Sum of an Array (Hard)</li> <li> 1508. Range Sum of Sorted Subarray Sums (Medium)</li> <li> 1918. Kth Smallest Subarray Sum (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/binary_search_kth_min_max/#668-kth-smallest-number-in-multiplication-table","title":"668. Kth Smallest Number in Multiplication Table","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Binary Search</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_kth_min_max/#378-kth-smallest-element-in-a-sorted-matrix","title":"378. Kth Smallest Element in a Sorted Matrix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Sorting, Heap Priority Queue, Matrix</p> </li> </ul> Python <pre><code>\"\"\"\n-   Given an `n x n` matrix where each of the rows and columns are sorted in ascending order, return the `k-th` smallest element in the matrix.\n\"\"\"\n\nfrom heapq import heapify, heappop, heappush\nfrom typing import List\n\n\n# Heap - Merge K Sorted\ndef kthSmallestHeap(matrix: List[List[int]], k: int) -&gt; int:\n    n = len(matrix)\n    heap = [(matrix[i][0], i, 0) for i in range(n)]\n    heapify(heap)\n\n    for _ in range(k - 1):\n        _, row, col = heappop(heap)\n\n        if col + 1 &lt; n:\n            heappush(heap, (matrix[row][col + 1], row, col + 1))\n\n    return heappop(heap)[0]\n\n\n# Binary Search\ndef kthSmallestBinarySearch(matrix: List[List[int]], k: int) -&gt; int:\n    n = len(matrix)\n\n    def check(mid):\n        i, j = n - 1, 0\n        num = 0\n\n        while i &gt;= 0 and j &lt; n:\n            if matrix[i][j] &lt;= mid:\n                num += i + 1\n                j += 1\n            else:\n                i -= 1\n\n        return num &gt;= k\n\n    left, right = matrix[0][0], matrix[-1][-1]\n\n    while left &lt; right:\n        mid = (left + right) // 2\n        if check(mid):\n            right = mid\n        else:\n            left = mid + 1\n\n    return left\n\n\nmatrix = [[1, 5, 9], [10, 11, 13], [12, 13, 15]]\nk = 8\n\nprint(kthSmallestHeap(matrix, k))  # 13\nprint(kthSmallestBinarySearch(matrix, k))  # 13\n</code></pre>"},{"location":"EndlessCheng/binary_search_kth_min_max/#719-find-k-th-smallest-pair-distance","title":"719. Find K-th Smallest Pair Distance","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_kth_min_max/#878-nth-magical-number","title":"878. Nth Magical Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Binary Search</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_kth_min_max/#1201-ugly-number-iii","title":"1201. Ugly Number III","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Binary Search, Combinatorics, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_kth_min_max/#793-preimage-size-of-factorial-zeroes-function","title":"793. Preimage Size of Factorial Zeroes Function","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Binary Search</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_kth_min_max/#373-find-k-pairs-with-smallest-sums","title":"373. Find K Pairs with Smallest Sums","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Heap Priority Queue</p> </li> </ul> Python <pre><code>import heapq\nfrom typing import List\n\n\n# Heap - Merge K Sorted\ndef kSmallestPairs(nums1: List[int], nums2: List[int], k: int) -&gt; List[List[int]]:\n    if not nums1 or not nums2 or k &lt;= 0:\n        return []\n\n    res = []\n    min_heap = []\n\n    for j in range(min(k, len(nums2))):\n        heapq.heappush(min_heap, (nums1[0] + nums2[j], 0, j))\n\n    while k &gt; 0 and min_heap:\n        _, i, j = heapq.heappop(min_heap)\n        res.append([nums1[i], nums2[j]])\n        k -= 1\n\n        if i + 1 &lt; len(nums1):\n            heapq.heappush(min_heap, (nums1[i + 1] + nums2[j], i + 1, j))\n\n    return res\n\n\nif __name__ == \"__main__\":\n    nums1 = [1, 2, 4, 5, 6]\n    nums2 = [3, 5, 7, 9]\n    k = 3\n    assert kSmallestPairs(nums1, nums2, k) == [[1, 3], [2, 3], [1, 5]]\n</code></pre>"},{"location":"EndlessCheng/binary_search_kth_min_max/#1439-find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows","title":"1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Heap Priority Queue, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_kth_min_max/#786-k-th-smallest-prime-fraction","title":"786. K-th Smallest Prime Fraction","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Sorting, Heap Priority Queue</p> </li> </ul> Python <pre><code>import heapq\nfrom typing import List\n\n\ndef kthSmallestPrimeFraction(arr: List[int], k: int) -&gt; List[int]:\n    max_heap = []\n\n    for j in range(1, len(arr)):\n        for i in range(j):\n            heapq.heappush(max_heap, (-arr[i] / arr[j], arr[i], arr[j]))\n\n            if len(max_heap) &gt; k:\n                heapq.heappop(max_heap)\n\n    return [max_heap[0][1], max_heap[0][2]]\n\n\narr = [1, 2, 3, 5]\nk = 3\nprint(kthSmallestPrimeFraction(arr, k))  # [2, 5]\n</code></pre>"},{"location":"EndlessCheng/binary_search_kth_min_max/#3116-kth-smallest-amount-with-single-denomination-combination","title":"3116. Kth Smallest Amount With Single Denomination Combination","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Binary Search, Bit Manipulation, Combinatorics, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_kth_min_max/#3134-find-the-median-of-the-uniqueness-array","title":"3134. Find the Median of the Uniqueness Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Binary Search, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_kth_min_max/#2040-kth-smallest-product-of-two-sorted-arrays","title":"2040. Kth Smallest Product of Two Sorted Arrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_kth_min_max/#2386-find-the-k-sum-of-an-array","title":"2386. Find the K-Sum of an Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sorting, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_kth_min_max/#1508-range-sum-of-sorted-subarray-sums","title":"1508. Range Sum of Sorted Subarray Sums","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_kth_min_max/#1918-kth-smallest-subarray-sum","title":"1918. Kth Smallest Subarray Sum \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_max_answer/","title":"Binary Search Max Answer","text":""},{"location":"EndlessCheng/binary_search_max_answer/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 275. H-Index II (Medium)</li> <li> 2226. Maximum Candies Allocated to K Children (Medium)</li> <li> 2982. Find Longest Special Substring That Occurs Thrice II (Medium)</li> <li> 2576. Find the Maximum Number of Marked Indices (Medium)</li> <li> 1898. Maximum Number of Removable Characters (Medium)</li> <li> 1802. Maximum Value at a Given Index in a Bounded Array (Medium)</li> <li> 1642. Furthest Building You Can Reach (Medium)</li> <li> 2861. Maximum Number of Alloys (Medium)</li> <li> 3007. Maximum Number That Sum of the Prices Is Less Than or Equal to K (Medium)</li> <li> 2141. Maximum Running Time of N Computers (Hard)</li> <li> 2258. Escape the Spreading Fire (Hard)</li> <li> 2071. Maximum Number of Tasks You Can Assign (Hard)</li> <li> 1618. Maximum Font to Fit a Sentence in a Screen (Medium) \ud83d\udc51</li> <li> 1891. Cutting Ribbons (Medium) \ud83d\udc51</li> <li> 2137. Pour Water Between Buckets to Make Water Levels Equal (Medium) \ud83d\udc51</li> <li> 644. Maximum Average Subarray II (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/binary_search_max_answer/#275-h-index-ii","title":"275. H-Index II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> Python <pre><code>\"\"\"\n- Hint: logarithmic time -- binary search\n\"\"\"\n\nfrom typing import List\n\n\n# Binary Search Max Answer\ndef hIndex(citations: List[int]) -&gt; int:\n    n = len(citations)\n    left, right = 0, n - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if citations[mid] &gt;= n - mid:\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return n - left\n\n\nif __name__ == \"__main__\":\n    citations = [0, 1, 3, 5, 6]\n    assert hIndex(citations) == 3\n</code></pre>"},{"location":"EndlessCheng/binary_search_max_answer/#2226-maximum-candies-allocated-to-k-children","title":"2226. Maximum Candies Allocated to K Children","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Binary Search Max Answer\ndef maximumCandies(candies: List[int], k: int) -&gt; int:\n    def check(low):\n        return sum(c // low for c in candies) &gt;= k\n\n    left, right = 0, max(candies) + 1\n    while left + 1 &lt; right:\n        mid = left + (right - left) // 2\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n\n    return left\n\n\n# Binary Search Max Answer - Optimized\ndef maximumCandiesOptimized(candies: List[int], k: int) -&gt; int:\n    def check(low):\n        return sum(c // low for c in candies) &gt;= k\n\n    # Use the minimum of max(candies) and sum(candies) // k to limit the search space\n    left, right = 0, min(max(candies), sum(candies) // k) + 1\n\n    while left + 1 &lt; right:\n        mid = left + (right - left) // 2\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n\n    return left\n\n\nif __name__ == \"__main__\":\n    candies = [5, 8, 6]\n    k = 3\n    assert maximumCandies(candies, k) == 5\n    assert maximumCandiesOptimized(candies, k) == 5\n</code></pre>"},{"location":"EndlessCheng/binary_search_max_answer/#2982-find-longest-special-substring-that-occurs-thrice-ii","title":"2982. Find Longest Special Substring That Occurs Thrice II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Binary Search, Sliding Window, Counting</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_max_answer/#2576-find-the-maximum-number-of-marked-indices","title":"2576. Find the Maximum Number of Marked Indices","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Greedy, Sorting</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Fast Slow Pointers\ndef maxNumOfMarkedIndices(nums: List[int]) -&gt; int:\n    nums.sort()\n    n = len(nums)\n    slow, fast = 0, n // 2\n    count = 0\n\n    while slow &lt; n // 2 and fast &lt; n:\n        if nums[fast] &gt;= 2 * nums[slow]:\n            count += 2\n            slow += 1\n        fast += 1\n\n    return count\n\n\nnums = [3, 5, 2, 4]\nprint(maxNumOfMarkedIndices(nums))  # 2\n</code></pre>"},{"location":"EndlessCheng/binary_search_max_answer/#1898-maximum-number-of-removable-characters","title":"1898. Maximum Number of Removable Characters","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, String, Binary Search</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_max_answer/#1802-maximum-value-at-a-given-index-in-a-bounded-array","title":"1802. Maximum Value at a Given Index in a Bounded Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Binary Search, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_max_answer/#1642-furthest-building-you-can-reach","title":"1642. Furthest Building You Can Reach","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_max_answer/#2861-maximum-number-of-alloys","title":"2861. Maximum Number of Alloys","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_max_answer/#3007-maximum-number-that-sum-of-the-prices-is-less-than-or-equal-to-k","title":"3007. Maximum Number That Sum of the Prices Is Less Than or Equal to K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Binary Search, Dynamic Programming, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_max_answer/#2141-maximum-running-time-of-n-computers","title":"2141. Maximum Running Time of N Computers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_max_answer/#2258-escape-the-spreading-fire","title":"2258. Escape the Spreading Fire","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Breadth First Search, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_max_answer/#2071-maximum-number-of-tasks-you-can-assign","title":"2071. Maximum Number of Tasks You Can Assign","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Greedy, Queue, Sorting, Monotonic Queue</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_max_answer/#1618-maximum-font-to-fit-a-sentence-in-a-screen","title":"1618. Maximum Font to Fit a Sentence in a Screen \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Binary Search, Interactive</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_max_answer/#1891-cutting-ribbons","title":"1891. Cutting Ribbons \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_max_answer/#2137-pour-water-between-buckets-to-make-water-levels-equal","title":"2137. Pour Water Between Buckets to Make Water Levels Equal \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_max_answer/#644-maximum-average-subarray-ii","title":"644. Maximum Average Subarray II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_maximize_min/","title":"Binary Search Maximize Min","text":""},{"location":"EndlessCheng/binary_search_maximize_min/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3281. Maximize Score of Numbers in Ranges (Medium)</li> <li> 2517. Maximum Tastiness of Candy Basket (Medium)</li> <li> 1552. Magnetic Force Between Two Balls (Medium)</li> <li> 2812. Find the Safest Path in a Grid (Medium)</li> <li> 2528. Maximize the Minimum Powered City (Hard)</li> <li> 3449. Maximize the Minimum Game Score (Hard)</li> <li> 1102. Path With Maximum Minimum Value (Medium) \ud83d\udc51</li> <li> 1231. Divide Chocolate (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/binary_search_maximize_min/#3281-maximize-score-of-numbers-in-ranges","title":"3281. Maximize Score of Numbers in Ranges","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_maximize_min/#2517-maximum-tastiness-of-candy-basket","title":"2517. Maximum Tastiness of Candy Basket","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_maximize_min/#1552-magnetic-force-between-two-balls","title":"1552. Magnetic Force Between Two Balls","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_maximize_min/#2812-find-the-safest-path-in-a-grid","title":"2812. Find the Safest Path in a Grid","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Breadth First Search, Union Find, Heap Priority Queue, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_maximize_min/#2528-maximize-the-minimum-powered-city","title":"2528. Maximize the Minimum Powered City","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Greedy, Queue, Sliding Window, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_maximize_min/#3449-maximize-the-minimum-game-score","title":"3449. Maximize the Minimum Game Score","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_maximize_min/#1102-path-with-maximum-minimum-value","title":"1102. Path With Maximum Minimum Value \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Depth First Search, Breadth First Search, Union Find, Heap Priority Queue, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_maximize_min/#1231-divide-chocolate","title":"1231. Divide Chocolate \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_min_answer/","title":"Binary Search Min Answer","text":""},{"location":"EndlessCheng/binary_search_min_answer/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1283. Find the Smallest Divisor Given a Threshold (Medium)</li> <li> 2187. Minimum Time to Complete Trips (Medium)</li> <li> 1870. Minimum Speed to Arrive on Time (Medium)</li> <li> 1011. Capacity To Ship Packages Within D Days (Medium)</li> <li> 875. Koko Eating Bananas (Medium)</li> <li> 3296. Minimum Number of Seconds to Make Mountain Height Zero (Medium)</li> <li> 475. Heaters (Medium)</li> <li> 2594. Minimum Time to Repair Cars (Medium)</li> <li> 1482. Minimum Number of Days to Make m Bouquets (Medium)</li> <li> 3048. Earliest Second to Mark Indices I (Medium)</li> <li> 2604. Minimum Time to Eat All Grains (Hard) \ud83d\udc51</li> <li> 2702. Minimum Operations to Make Numbers Non-positive (Hard) \ud83d\udc51</li> <li> 3453. Separate Squares I (Medium)</li> </ul>"},{"location":"EndlessCheng/binary_search_min_answer/#1283-find-the-smallest-divisor-given-a-threshold","title":"1283. Find the Smallest Divisor Given a Threshold","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> Python <pre><code>\"\"\"\n- \u4e8c\u5206\u7b54\u6848\u7684\u5173\u952e\u662f\u627e\u5230\u5355\u8c03\u6027\uff0c\u7136\u540e\u5206\u6790\u51fa\u5224\u65ad\u6761\u4ef6\n\"\"\"\n\nfrom typing import List\n\n\n# Binary Search Min Answer\ndef smallestDivisor(nums: List[int], threshold: int) -&gt; int:\n    left, right = 0, max(nums)\n\n    while left + 1 &lt; right:\n        mid = left + (right - left) // 2\n        if sum((x - 1) // mid for x in nums) &lt;= threshold - len(nums):\n            right = mid\n        else:\n            left = mid\n\n    return right\n\n\nif __name__ == \"__main__\":\n    nums = [1, 2, 5, 9]\n    threshold = 6\n    assert smallestDivisor(nums, threshold) == 5\n</code></pre>"},{"location":"EndlessCheng/binary_search_min_answer/#2187-minimum-time-to-complete-trips","title":"2187. Minimum Time to Complete Trips","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> Python <pre><code>\"\"\"\n- Left: always insufficient trips\n- Right: always sufficient trips\n\"\"\"\n\nfrom typing import List\n\n\n# Binary Search Min Answer\ndef minimumTime(time: List[int], totalTrips: int) -&gt; int:\n    min_t = min(time)\n    left = min_t - 1\n    right = min_t * totalTrips\n\n    while left + 1 &lt; right:\n        mid = left + (right - left) // 2\n        if sum(mid // t for t in time) &gt;= totalTrips:\n            right = mid\n        else:\n            left = mid\n\n    return right\n\n\nif __name__ == \"__main__\":\n    time = [1, 2, 3]\n    totalTrips = 5\n    assert minimumTime(time, totalTrips) == 3\n</code></pre>"},{"location":"EndlessCheng/binary_search_min_answer/#1870-minimum-speed-to-arrive-on-time","title":"1870. Minimum Speed to Arrive on Time","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> Python <pre><code>import math\nfrom typing import List\n\n\n# Binary Search\ndef minSpeedOnTime(dist: List[int], hour: float) -&gt; int:\n    if hour &lt; len(dist) - 1:\n        return -1\n\n    def time_needed(speed):\n        total_time = 0\n        for i in range(len(dist) - 1):\n            total_time += math.ceil(dist[i] / speed)\n        total_time += dist[-1] / speed\n        return total_time\n\n    left, right = 1, 10**7\n    result = -1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        if time_needed(mid) &lt;= hour:\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return result\n\n\ndist = [1, 3, 2]\nhour = 6\nprint(minSpeedOnTime(dist, hour))  # 1\n</code></pre>"},{"location":"EndlessCheng/binary_search_min_answer/#1011-capacity-to-ship-packages-within-d-days","title":"1011. Capacity To Ship Packages Within D Days","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> Python <pre><code>\"\"\"\n-   A conveyor belt has packages that must be shipped from one port to another within `D` days. The `i-th` package has a weight of `weights[i]`. Each day, we load the ship with packages on the conveyor belt. The ship will be loaded with packages up to its capacity. The ship will not be loaded beyond its capacity. Return the least weight capacity of the ship.\n\"\"\"\n\nfrom typing import List\n\n\n# Binary Search\ndef shipWithinDays(weights: List[int], days: int) -&gt; int:\n\n    def canShip(weights, D, capacity):\n        days = 1\n        current_weight = 0\n\n        for weight in weights:\n            if current_weight + weight &gt; capacity:\n                days += 1\n                current_weight = 0\n            current_weight += weight\n\n        return days &lt;= D\n\n    left, right = max(weights), sum(weights)\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if canShip(weights, days, mid):\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return left\n\n\nweights = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\ndays = 5\nprint(shipWithinDays(weights, days))  # 15\n</code></pre>"},{"location":"EndlessCheng/binary_search_min_answer/#875-koko-eating-bananas","title":"875. Koko Eating Bananas","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> Python <pre><code>from typing import List\n\n\nclass minEatingSpeed:\n    def minEatingSpeed(self, piles: List[int], h: int) -&gt; int:\n        def canEat(piles, k, h):\n            hours = 0\n            for pile in piles:\n                hours += (pile + k - 1) // k\n            return hours &lt;= h\n\n        left, right = 1, max(piles) - 1\n\n        while left &lt;= right:\n            mid = left + (right - left) // 2\n\n            if canEat(piles, mid, h):\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        return left\n\n\nif __name__ == \"__main__\":\n    piles = [3, 6, 7, 11]\n    h = 8\n    sol = minEatingSpeed()\n    assert sol.minEatingSpeed(piles, h) == 4\n</code></pre>"},{"location":"EndlessCheng/binary_search_min_answer/#3296-minimum-number-of-seconds-to-make-mountain-height-zero","title":"3296. Minimum Number of Seconds to Make Mountain Height Zero","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Binary Search, Greedy, Heap Priority Queue</p> </li> </ul> Python <pre><code>from bisect import bisect_left\nfrom heapq import heapify, heapreplace\nfrom math import isqrt\nfrom typing import List\n\n\n# Min Heap\ndef minNumberOfSecondsMinHeap(mountainHeight: int, workerTimes: List[int]) -&gt; int:\n    minHeap = [(t, t, t) for t in workerTimes]\n    heapify(minHeap)\n\n    for _ in range(mountainHeight):\n        nxt, delta, base = minHeap[0]\n        heapreplace(\n            minHeap,\n            (\n                nxt + delta + base,\n                delta + base,\n                base,\n            ),\n        )\n    return nxt\n\n\n# Binary Search Min Answer\ndef minNumberOfSecondsBinarySearchMin(mountainHeight: int, workerTimes: List[int]) -&gt; int:\n    def check(m: int) -&gt; bool:\n        left_h = mountainHeight\n        for t in workerTimes:\n            left_h -= (isqrt(m // t * 8 + 1) - 1) // 2\n            if left_h &lt;= 0:\n                return True\n        return False\n\n    max_t = max(workerTimes)\n    h = (mountainHeight - 1) // len(workerTimes) + 1\n    return bisect_left(range(max_t * h * (h + 1) // 2), True, 1, key=check)\n\n\nif __name__ == \"__main__\":\n    mountainHeight = 4\n    workerTimes = [2, 1, 1]\n    assert minNumberOfSecondsMinHeap(mountainHeight, workerTimes) == 3\n    assert minNumberOfSecondsBinarySearchMin(mountainHeight, workerTimes) == 3\n</code></pre>"},{"location":"EndlessCheng/binary_search_min_answer/#475-heaters","title":"475. Heaters","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Sorting</p> </li> </ul> Python <pre><code>from bisect import bisect_left, bisect_right\nfrom math import inf\nfrom typing import List\n\n\n# Left Right Pointers\ndef findRadiusLR(houses: List[int], heaters: List[int]) -&gt; int:\n    heaters = heaters + [-inf, inf]\n    houses.sort()\n    heaters.sort()\n    i, j, res = 0, 0, 0\n\n    while i &lt; len(houses):\n        cur = inf\n        while heaters[j] &lt;= houses[i]:\n            cur = houses[i] - heaters[j]\n            j += 1\n        cur = min(cur, heaters[j] - houses[i])\n        res = max(cur, res)\n        i += 1\n        j -= 1\n\n    return res\n\n\n# Binary Search Min Answer\ndef findRadiusBS(houses: List[int], heaters: List[int]) -&gt; int:\n    houses.sort()\n    heaters.sort()\n\n    def closest(house):\n        left = bisect_right(heaters, house) - 1\n        d1 = abs(heaters[left] - house) if left &gt;= 0 else inf\n\n        right = bisect_left(heaters, house)\n        d2 = abs(heaters[right] - house) if right &lt; len(heaters) else inf\n\n        return min(d1, d2)\n\n    return max(closest(house) for house in houses)\n\n\nif __name__ == \"__main__\":\n    houses = [1, 2, 3]\n    heaters = [2]\n    assert findRadiusLR(houses, heaters) == 1\n    assert findRadiusBS(houses, heaters) == 1\n</code></pre>"},{"location":"EndlessCheng/binary_search_min_answer/#2594-minimum-time-to-repair-cars","title":"2594. Minimum Time to Repair Cars","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> Python <pre><code>from math import isqrt\nfrom typing import List\n\n\n# Binary Search Min Answer\ndef repairCars(ranks: List[int], cars: int) -&gt; int:\n    left, right = 0, max(ranks) * cars * cars\n\n    while left + 1 &lt; right:\n        mid = left + (right - left) // 2\n        if sum(isqrt(mid // rank) for rank in ranks) &gt;= cars:\n            right = mid\n        else:\n            left = mid\n    return right\n\n\nif __name__ == \"__main__\":\n    ranks = [4, 2, 3, 1]\n    cars = 10\n    assert repairCars(ranks, cars) == 16\n</code></pre>"},{"location":"EndlessCheng/binary_search_min_answer/#1482-minimum-number-of-days-to-make-m-bouquets","title":"1482. Minimum Number of Days to Make m Bouquets","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Binary Search Min Answer\ndef minDays(bloomDay: List[int], m: int, k: int) -&gt; int:\n    n = len(bloomDay)\n    if m * k &gt; n:\n        return -1\n\n    def canMake(day: int) -&gt; bool:\n        bouquets = 0\n        flowers = 0\n        for bloom in bloomDay:\n            if bloom &lt;= day:\n                flowers += 1\n                if flowers == k:\n                    bouquets += 1\n                    flowers = 0\n            else:\n                flowers = 0\n        return bouquets &gt;= m\n\n    left, right = min(bloomDay), max(bloomDay)\n    res = -1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        if canMake(mid):\n            res = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    bloomDay = [1, 10, 3, 10, 2]\n    m = 3\n    k = 1\n    assert minDays(bloomDay, m, k) == 3\n</code></pre>"},{"location":"EndlessCheng/binary_search_min_answer/#3048-earliest-second-to-mark-indices-i","title":"3048. Earliest Second to Mark Indices I","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> Python <pre><code>from bisect import bisect_left\nfrom typing import List\n\n\n# Binary Search Min Answer\ndef earliestSecondToMarkIndices(nums: List[int], changeIndices: List[int]) -&gt; int:\n    n, m = len(nums), len(changeIndices)\n    if n &gt; m:\n        return -1\n\n    def check(mx: int) -&gt; bool:\n        last_t = [-1] * n\n        for t, idx in enumerate(changeIndices[:mx]):\n            last_t[idx - 1] = t\n        if -1 in last_t:\n            return False\n\n        cnt = 0\n        for i, idx in enumerate(changeIndices[:mx]):\n            idx -= 1\n            if i == last_t[idx]:\n                if nums[idx] &gt; cnt:\n                    return False\n                cnt -= nums[idx]\n            else:\n                cnt += 1\n        return True\n\n    left = n + sum(nums)\n    res = left + bisect_left(range(left, m + 1), True, key=check)\n    return -1 if res &gt; m else res\n\n\nif __name__ == \"__main__\":\n    nums = [2, 2, 0]\n    changeIndices = [2, 2, 2, 2, 3, 2, 2, 1]\n    assert earliestSecondToMarkIndices(nums, changeIndices) == 8\n</code></pre>"},{"location":"EndlessCheng/binary_search_min_answer/#2604-minimum-time-to-eat-all-grains","title":"2604. Minimum Time to Eat All Grains \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_min_answer/#2702-minimum-operations-to-make-numbers-non-positive","title":"2702. Minimum Operations to Make Numbers Non-positive \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_min_answer/#3453-separate-squares-i","title":"3453. Separate Squares I","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_minimize_max/","title":"Binary Search Minimize Max","text":""},{"location":"EndlessCheng/binary_search_minimize_max/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 410. Split Array Largest Sum (Hard)</li> <li> 2064. Minimized Maximum of Products Distributed to Any Store (Medium)</li> <li> 1760. Minimum Limit of Balls in a Bag (Medium)</li> <li> 1631. Path With Minimum Effort (Medium)</li> <li> 2439. Minimize Maximum of Array (Medium)</li> <li> 2560. House Robber IV (Medium)</li> <li> 778. Swim in Rising Water (Hard)</li> <li> 2616. Minimize the Maximum Difference of Pairs (Medium)</li> <li> 3419. Minimize the Maximum Edge Weight of Graph (Medium)</li> <li> 2513. Minimize the Maximum of Two Arrays (Medium)</li> <li> 3399. Smallest Substring With Identical Characters II (Hard)</li> <li> 774. Minimize Max Distance to Gas Station (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/binary_search_minimize_max/#410-split-array-largest-sum","title":"410. Split Array Largest Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Dynamic Programming, Greedy, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_minimize_max/#2064-minimized-maximum-of-products-distributed-to-any-store","title":"2064. Minimized Maximum of Products Distributed to Any Store","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_minimize_max/#1760-minimum-limit-of-balls-in-a-bag","title":"1760. Minimum Limit of Balls in a Bag","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_minimize_max/#1631-path-with-minimum-effort","title":"1631. Path With Minimum Effort","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Depth First Search, Breadth First Search, Union Find, Heap Priority Queue, Matrix</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the minimum effort required to travel from the top-left to the bottom-right corner.\n\"\"\"\n\nimport heapq\nfrom typing import List\n\n\n# Prim\ndef minimumEffortPath(heights: List[List[int]]) -&gt; int:\n    m, n = len(heights), len(heights[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * n for _ in range(m)]\n    heap = [(0, 0, 0)]  # (effort, row, col)\n\n    while heap:\n        effort, r, c = heapq.heappop(heap)\n\n        if visited[r][c]:\n            continue\n\n        if r == m - 1 and c == n - 1:\n            return effort\n\n        visited[r][c] = True\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and not visited[nr][nc]:\n                updated = max(effort, abs(heights[r][c] - heights[nr][nc]))\n                heapq.heappush(heap, (updated, nr, nc))\n\n    return -1\n\n\nheights = [[1, 2, 2], [3, 8, 2], [5, 3, 5]]\nprint(minimumEffortPath(heights))  # 2\n</code></pre>"},{"location":"EndlessCheng/binary_search_minimize_max/#2439-minimize-maximum-of-array","title":"2439. Minimize Maximum of Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Dynamic Programming, Greedy, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_minimize_max/#2560-house-robber-iv","title":"2560. House Robber IV","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_minimize_max/#778-swim-in-rising-water","title":"778. Swim in Rising Water","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Depth First Search, Breadth First Search, Union Find, Heap Priority Queue, Matrix</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the minimum time when you can reach the target.\n\n![778](https://assets.leetcode.com/uploads/2021/06/29/swim2-grid-1.jpg)\n\"\"\"\n\nimport heapq\nfrom typing import List\n\n\n# Dijkstra's\ndef swimInWater(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    visited = set()\n    minHeap = [(grid[0][0], 0, 0)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    visited.add((0, 0))\n\n    while minHeap:\n        time, r, c = heapq.heappop(minHeap)\n\n        if r == n - 1 and c == n - 1:\n            return time\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if nr in range(n) and nc in range(n) and (nr, nc) not in visited:\n                visited.add((nr, nc))\n                heapq.heappush(minHeap, (max(time, grid[nr][nc]), nr, nc))\n\n\ngrid = [\n    [0, 1, 2, 3, 4],\n    [24, 23, 22, 21, 5],\n    [12, 13, 14, 15, 16],\n    [11, 17, 18, 19, 20],\n    [10, 9, 8, 7, 6],\n]\nprint(swimInWater(grid))  # 16\n</code></pre>"},{"location":"EndlessCheng/binary_search_minimize_max/#2616-minimize-the-maximum-difference-of-pairs","title":"2616. Minimize the Maximum Difference of Pairs","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_minimize_max/#3419-minimize-the-maximum-edge-weight-of-graph","title":"3419. Minimize the Maximum Edge Weight of Graph","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Binary Search, Depth First Search, Breadth First Search, Graph, Shortest Path</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_minimize_max/#2513-minimize-the-maximum-of-two-arrays","title":"2513. Minimize the Maximum of Two Arrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Binary Search, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_minimize_max/#3399-smallest-substring-with-identical-characters-ii","title":"3399. Smallest Substring With Identical Characters II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Binary Search</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_minimize_max/#774-minimize-max-distance-to-gas-station","title":"774. Minimize Max Distance to Gas Station \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_others/","title":"Binary Search Others","text":""},{"location":"EndlessCheng/binary_search_others/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 69. Sqrt(x) (Easy)</li> <li> 74. Search a 2D Matrix (Medium)</li> <li> 240. Search a 2D Matrix II (Medium)</li> <li> 2476. Closest Nodes Queries in a Binary Search Tree (Medium)</li> <li> 278. First Bad Version (Easy)</li> <li> 374. Guess Number Higher or Lower (Easy)</li> <li> 162. Find Peak Element (Medium)</li> <li> 1901. Find a Peak Element II (Medium)</li> <li> 852. Peak Index in a Mountain Array (Medium)</li> <li> 1095. Find in Mountain Array (Hard)</li> <li> 153. Find Minimum in Rotated Sorted Array (Medium)</li> <li> 154. Find Minimum in Rotated Sorted Array II (Hard)</li> <li> 33. Search in Rotated Sorted Array (Medium)</li> <li> 81. Search in Rotated Sorted Array II (Medium)</li> <li> 222. Count Complete Tree Nodes (Easy)</li> <li> 1539. Kth Missing Positive Number (Easy)</li> <li> 540. Single Element in a Sorted Array (Medium)</li> <li> 4. Median of Two Sorted Arrays (Hard)</li> <li> 1064. Fixed Point (Easy) \ud83d\udc51</li> <li> 702. Search in a Sorted Array of Unknown Size (Medium) \ud83d\udc51</li> <li> 2936. Number of Equal Numbers Blocks (Medium) \ud83d\udc51</li> <li> 1060. Missing Element in Sorted Array (Medium) \ud83d\udc51</li> <li> 1198. Find Smallest Common Element in All Rows (Medium) \ud83d\udc51</li> <li> 1428. Leftmost Column with at Least a One (Medium) \ud83d\udc51</li> <li> 1533. Find the Index of the Large Integer (Medium) \ud83d\udc51</li> <li> 2387. Median of a Row Wise Sorted Matrix (Medium) \ud83d\udc51</li> <li> 302. Smallest Rectangle Enclosing Black Pixels (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/binary_search_others/#69-sqrtx","title":"69. Sqrt(x)","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Binary Search</p> </li> </ul> PythonCPP <pre><code># Left Right Pointers\ndef mySqrt(x: int) -&gt; int:\n    \"\"\"Returns the square root of a number.\"\"\"\n    if x &lt; 2:\n        return x\n\n    left, right = 0, x // 2\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        if mid * mid &lt;= x &lt; (mid + 1) * (mid + 1):\n            return mid\n        elif mid * mid &lt; x:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n\nx = 8\nprint(mySqrt(x))  # 2\n</code></pre> <pre><code>#include &lt;cassert&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int mySqrt(int x) {\n        if (x &lt; 2) return x;\n        int left = 0, right = x / 2;\n        int mid = 0;\n\n        while (left &lt;= right) {\n            mid = left + (right - left) / 2;\n            long long a = 1LL * mid * mid;\n            long long b = 1LL * (mid + 1) * (mid + 1);\n\n            if (a &lt;= x &amp;&amp; x &lt; b) {\n                return mid;\n            } else if (a &lt; x)\n                left = mid + 1;\n            else\n                right = mid - 1;\n        }\n        return right;\n    }\n};\n\nint main() {\n    Solution solution;\n    assert(solution.mySqrt(4) == 2);\n    assert(solution.mySqrt(8) == 2);\n    assert(solution.mySqrt(1999) == 44);\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/binary_search_others/#74-search-a-2d-matrix","title":"74. Search a 2D Matrix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Matrix</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Binary Search\ndef searchMatrix(matrix: List[List[int]], target: int) -&gt; bool:\n    if not matrix or not matrix[0]:\n        return False\n\n    m, n = len(matrix), len(matrix[0])\n    left, right = 0, m * n - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        x = matrix[mid // n][mid % n]\n\n        if x &lt; target:\n            left = mid + 1\n        elif x &gt; target:\n            right = mid - 1\n        else:\n            return True\n\n    return False\n\n\nif __name__ == \"__main__\":\n    matrix = [[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]]\n    target = 3\n    print(searchMatrix(matrix, target))  # True\n</code></pre>"},{"location":"EndlessCheng/binary_search_others/#240-search-a-2d-matrix-ii","title":"240. Search a 2D Matrix II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Divide And Conquer, Matrix</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Matrix\ndef searchMatrix(matrix: List[List[int]], target: int) -&gt; bool:\n    m, n = len(matrix), len(matrix[0])\n    i, j = 0, n - 1\n\n    while i &lt; m and j &gt;= 0:\n        if matrix[i][j] == target:\n            return True\n        elif matrix[i][j] &lt; target:\n            i += 1\n        else:\n            j -= 1\n\n    return False\n\n\nmatrix = [\n    [1, 4, 7, 11, 15],\n    [2, 5, 8, 12, 19],\n    [3, 6, 9, 16, 22],\n    [10, 13, 14, 17, 24],\n    [18, 21, 23, 26, 30],\n]\ntarget = 20\nprint(searchMatrix(matrix, target))  # False\n</code></pre>"},{"location":"EndlessCheng/binary_search_others/#2476-closest-nodes-queries-in-a-binary-search-tree","title":"2476. Closest Nodes Queries in a Binary Search Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Tree, Depth First Search, Binary Search Tree, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_others/#278-first-bad-version","title":"278. First Bad Version","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Binary Search, Interactive</p> </li> </ul> Python <pre><code>\"\"\"\n-   Find the first bad version given a function `isBadVersion`.\n\"\"\"\n\n\n# Binary Search\ndef firstBadVersion(n: int) -&gt; int:\n    left, right = 1, n\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if isBadVersion(mid):\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return left\n\n\ndef isBadVersion(version: int) -&gt; bool:\n    pass\n</code></pre>"},{"location":"EndlessCheng/binary_search_others/#374-guess-number-higher-or-lower","title":"374. Guess Number Higher or Lower","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Binary Search, Interactive</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_others/#162-find-peak-element","title":"162. Find Peak Element","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_others/#1901-find-a-peak-element-ii","title":"1901. Find a Peak Element II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_others/#852-peak-index-in-a-mountain-array","title":"852. Peak Index in a Mountain Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_others/#1095-find-in-mountain-array","title":"1095. Find in Mountain Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Interactive</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_others/#153-find-minimum-in-rotated-sorted-array","title":"153. Find Minimum in Rotated Sorted Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Binary Search\ndef findMin(nums: List[int]) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt; right:\n        mid = left + (right - left) // 2\n        if nums[mid] &gt; nums[right]:\n            left = mid + 1\n        else:\n            right = mid\n\n    return nums[right]\n\n\nnums = [4, 5, 6, 7, 0, 1, 2]\nprint(findMin(nums))  # 0\n</code></pre>"},{"location":"EndlessCheng/binary_search_others/#154-find-minimum-in-rotated-sorted-array-ii","title":"154. Find Minimum in Rotated Sorted Array II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_others/#33-search-in-rotated-sorted-array","title":"33. Search in Rotated Sorted Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Binary Search\ndef search(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] == target:\n            return mid\n\n        if nums[left] &lt;= nums[mid]:\n            if nums[left] &lt;= target &lt; nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if nums[mid] &lt; target &lt;= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n    return -1\n\n\nnums = [4, 5, 6, 7, 0, 1, 2]\ntarget = 0\nprint(search(nums, target))  # 4\n</code></pre>"},{"location":"EndlessCheng/binary_search_others/#81-search-in-rotated-sorted-array-ii","title":"81. Search in Rotated Sorted Array II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_others/#222-count-complete-tree-nodes","title":"222. Count Complete Tree Nodes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Binary Search, Bit Manipulation, Tree, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef countNodesRecursive(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    num = 1 + countNodesRecursive(root.left) + countNodesRecursive(root.right)\n\n    return num\n\n\n# Iterative\ndef countNodesIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n    count = 0\n\n    while q:\n        n = len(q)\n\n        for _ in range(n):\n            node = q.popleft()\n            count += 1\n\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return count\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Recursive  |  O(n)  |  O(n)   |\n# | Iterative  |  O(n)  |  O(n)   |\n# |------------|--------|---------|\n\nroot = [1, 2, 3, 4, 5, 6]\nroot = build(root)\nprint(root)\n#     __1__\n#    /     \\\n#   2       3\n#  / \\     /\n# 4   5   6\nprint(countNodesRecursive(root))  # 6\nprint(countNodesIterative(root))  # 6\n</code></pre>"},{"location":"EndlessCheng/binary_search_others/#1539-kth-missing-positive-number","title":"1539. Kth Missing Positive Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_others/#540-single-element-in-a-sorted-array","title":"540. Single Element in a Sorted Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_others/#4-median-of-two-sorted-arrays","title":"4. Median of Two Sorted Arrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Divide And Conquer</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Brute Force\ndef findMedianSortedArraysBF(nums1: List[int], nums2: List[int]) -&gt; float:\n    nums = sorted(nums1 + nums2)\n    n = len(nums)\n    if n % 2 == 0:\n        return (nums[n // 2 - 1] + nums[n // 2]) / 2\n    else:\n        return nums[n // 2]\n\n\n# Binary Search\ndef findMedianSortedArraysBS(nums1: List[int], nums2: List[int]) -&gt; float:\n    if len(nums1) &gt; len(nums2):\n        nums1, nums2 = nums2, nums1\n\n    m, n = len(nums1), len(nums2)\n    imin, imax, half_len = 0, m, (m + n + 1) // 2\n\n    while imin &lt;= imax:\n        i = (imin + imax) // 2\n        j = half_len - i\n\n        if i &lt; m and nums2[j - 1] &gt; nums1[i]:\n            imin = i + 1\n        elif i &gt; 0 and nums1[i - 1] &gt; nums2[j]:\n            imax = i - 1\n        else:\n            if i == 0:\n                max_of_left = nums2[j - 1]\n            elif j == 0:\n                max_of_left = nums1[i - 1]\n            else:\n                max_of_left = max(nums1[i - 1], nums2[j - 1])\n\n            if (m + n) % 2 == 1:\n                return max_of_left\n\n            if i == m:\n                min_of_right = nums2[j]\n            elif j == n:\n                min_of_right = nums1[i]\n            else:\n                min_of_right = min(nums1[i], nums2[j])\n\n            return (max_of_left + min_of_right) / 2\n\n\n# |--------------|-----------------|--------------|\n# | Approach     | Time            | Space        |\n# |--------------|-----------------|--------------|\n# | Brute Force  | O((n+m)log(n+m))| O(n+m)       |\n# | Binary Search| O(log(min(n,m)))| O(1)         |\n# |--------------|-----------------|--------------|\n\n\nnums1 = [1, 3]\nnums2 = [2]\nprint(findMedianSortedArraysBF(nums1, nums2))  # 2.0\nprint(findMedianSortedArraysBS(nums1, nums2))  # 2.0\n</code></pre>"},{"location":"EndlessCheng/binary_search_others/#1064-fixed-point","title":"1064. Fixed Point \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_others/#702-search-in-a-sorted-array-of-unknown-size","title":"702. Search in a Sorted Array of Unknown Size \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Interactive</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_others/#2936-number-of-equal-numbers-blocks","title":"2936. Number of Equal Numbers Blocks \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Interactive</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_others/#1060-missing-element-in-sorted-array","title":"1060. Missing Element in Sorted Array \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_others/#1198-find-smallest-common-element-in-all-rows","title":"1198. Find Smallest Common Element in All Rows \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Binary Search, Matrix, Counting</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_others/#1428-leftmost-column-with-at-least-a-one","title":"1428. Leftmost Column with at Least a One \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Matrix, Interactive</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_others/#1533-find-the-index-of-the-large-integer","title":"1533. Find the Index of the Large Integer \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Interactive</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_others/#2387-median-of-a-row-wise-sorted-matrix","title":"2387. Median of a Row Wise Sorted Matrix \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_others/#302-smallest-rectangle-enclosing-black-pixels","title":"302. Smallest Rectangle Enclosing Black Pixels \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Depth First Search, Breadth First Search, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_tree/","title":"Binary Search Tree","text":""},{"location":"EndlessCheng/binary_search_tree/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 98. Validate Binary Search Tree (Medium)</li> <li> 230. Kth Smallest Element in a BST (Medium)</li> <li> 501. Find Mode in Binary Search Tree (Easy)</li> <li> 99. Recover Binary Search Tree (Medium)</li> <li> 700. Search in a Binary Search Tree (Easy)</li> <li> 530. Minimum Absolute Difference in BST (Easy)</li> <li> 783. Minimum Distance Between BST Nodes (Easy)</li> <li> 1305. All Elements in Two Binary Search Trees (Medium)</li> <li> 938. Range Sum of BST (Easy)</li> <li> 897. Increasing Order Search Tree (Easy)</li> <li> 2476. Closest Nodes Queries in a Binary Search Tree (Medium)</li> <li> 653. Two Sum IV - Input is a BST (Easy)</li> <li> 1373. Maximum Sum BST in Binary Tree (Hard)</li> <li> 1932. Merge BSTs to Create Single BST (Hard)</li> <li> 285. Inorder Successor in BST (Medium) \ud83d\udc51</li> <li> 510. Inorder Successor in BST II (Medium) \ud83d\udc51</li> <li> 270. Closest Binary Search Tree Value (Easy) \ud83d\udc51</li> <li> 272. Closest Binary Search Tree Value II (Hard) \ud83d\udc51</li> <li> 255. Verify Preorder Sequence in Binary Search Tree (Medium) \ud83d\udc51</li> <li> 1902. Depth of BST Given Insertion Order (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/binary_search_tree/#98-validate-binary-search-tree","title":"98. Validate Binary Search Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Search Tree, Binary Tree</p> </li> </ul> PythonCPP <pre><code>from itertools import pairwise\nfrom math import inf\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef isValidBST1(root: Optional[TreeNode]) -&gt; bool:\n    inorder = []  # inorder traversal\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    for a, b in pairwise(inorder):\n        if a &gt;= b:\n            return False\n\n    return True\n\n\ndef isValidBST2(root: Optional[TreeNode]) -&gt; bool:\n    if not root:\n        return True\n    pre = -inf\n\n    def dfs(node):\n        if not node:\n            return True\n        if not dfs(node.left):\n            return False\n\n        nonlocal pre\n        if node.val &lt;= pre:\n            return False\n        pre = node.val\n\n        return dfs(node.right)\n\n    return dfs(root)\n\n\nif __name__ == \"__main__\":\n    root = [5, 1, 4, None, None, 3, 6]\n    root = build(root)\n    print(root)\n    #   5__\n    #  /   \\\n    # 1     4\n    #      / \\\n    #     3   6\n    assert not isValidBST1(root)  # [1, 5, 3, 4, 6]\n    assert not isValidBST2(root)  # [1, 5, 3, 4, 6]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   private:\n    vector&lt;int&gt; inorder;\n    bool check(vector&lt;int&gt; inorder) {\n        int n = inorder.size();\n        if (n &lt;= 1) return true;\n        for (int i = 1; i &lt; n; i++) {\n            if (inorder[i] &lt;= inorder[i - 1]) return false;\n        }\n        return true;\n    }\n\n   public:\n    bool isValidBST(TreeNode *root) {\n        auto dfs = [&amp;](auto &amp;&amp;self, TreeNode *node) -&gt; void {\n            if (!node) return;\n\n            self(self, node-&gt;left);\n            inorder.push_back(node-&gt;val);\n            self(self, node-&gt;right);\n        };\n\n        dfs(dfs, root);\n\n        return check(inorder);\n    }\n};\n\nint main() {\n    Solution s;\n    TreeNode *root = new TreeNode(2);\n    root-&gt;left = new TreeNode(1);\n    root-&gt;right = new TreeNode(3);\n    assert(s.isValidBST(root) == true);\n\n    root = new TreeNode(5);\n    root-&gt;left = new TreeNode(1);\n    root-&gt;right = new TreeNode(4);\n    root-&gt;right-&gt;left = new TreeNode(3);\n    root-&gt;right-&gt;right = new TreeNode(6);\n    assert(s.isValidBST(root) == false);\n\n    root = new TreeNode(5);\n    root-&gt;left = new TreeNode(4);\n    root-&gt;right = new TreeNode(6);\n    root-&gt;right-&gt;left = new TreeNode(3);\n    root-&gt;right-&gt;right = new TreeNode(7);\n    assert(s.isValidBST(root) == false);\n\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/binary_search_tree/#230-kth-smallest-element-in-a-bst","title":"230. Kth Smallest Element in a BST","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Search Tree, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef kthSmallestRecursive(root: Optional[TreeNode], k: int) -&gt; int:\n    inorder = []\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n    return inorder[k - 1]\n\n\n# Iteratve\ndef kthSmallestIteratve(root: Optional[TreeNode], k: int) -&gt; int:\n    stack = []\n    while True:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        k -= 1\n        if not k:\n            return root.val\n        root = root.right\n\n\nif __name__ == \"__main__\":\n    root = build([3, 1, 4, None, 2])\n    k = 1\n    assert kthSmallestRecursive(root, k) == 1\n    assert kthSmallestIteratve(root, k) == 1\n</code></pre>"},{"location":"EndlessCheng/binary_search_tree/#501-find-mode-in-binary-search-tree","title":"501. Find Mode in Binary Search Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Search Tree, Binary Tree</p> </li> </ul> Python <pre><code>from typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef findMode(root: Optional[TreeNode]) -&gt; List[int]:\n    hashmap = dict()\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        if node.val not in hashmap:\n            hashmap[node.val] = 1\n        else:\n            hashmap[node.val] += 1\n        dfs(node.right)\n\n    dfs(root)\n    max_counts = max(hashmap.values())\n    result = []\n\n    for key, value in hashmap.items():\n        if value == max_counts:\n            result.append(key)\n\n    return result\n\n\nroot = [1, None, 2, None, None, 2]\nroot = build(root)\nprint(root)\n# 1__\n#    \\\n#     2\n#    /\n#   2\nprint(findMode(root))  # [2]\n</code></pre>"},{"location":"EndlessCheng/binary_search_tree/#99-recover-binary-search-tree","title":"99. Recover Binary Search Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Search Tree, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_tree/#700-search-in-a-binary-search-tree","title":"700. Search in a Binary Search Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Binary Search Tree, Binary Tree</p> </li> </ul> Python <pre><code>\"\"\"\n### Binary Search Tree\n\n1. Binary Tree\n2. Left subtree of a node contains only nodes with keys less than the node's key\n3. Right subtree of a node contains only nodes with keys greater than the node's key\n4. The left and right subtree each must also be a binary search tree\n5. There must be no duplicate nodes\n6. Inorder traversal of a BST gives a sorted list of keys\n\"\"\"\n\nfrom typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# 1. Recursive\ndef searchBSTRecursive(root: Optional[TreeNode], val: int) -&gt; Optional[TreeNode]:\n    if not root:\n        return None\n\n    if root.val &gt; val:\n        return searchBSTRecursive(root.left, val)\n\n    elif root.val &lt; val:\n        return searchBSTRecursive(root.right, val)\n\n    else:\n        return root\n\n\n# 2. Iterative\ndef searchBSTIterative(root: Optional[TreeNode], val: int) -&gt; Optional[TreeNode]:\n    while root:\n        if root.val &gt; val:\n            root = root.left\n        elif root.val &lt; val:\n            root = root.right\n        else:\n            return root\n    return None\n\n\nroot = [4, 2, 7, 1, 3]\nval = 2\nroot = build(root)\nprint(root)\n#     __4\n#    /   \\\n#   2     7\n#  / \\\n# 1   3\nprint(searchBSTRecursive(root, val))\n#   2\n#  / \\\n# 1   3\nprint(searchBSTIterative(root, val))\n#   2\n#  / \\\n# 1   3\n</code></pre>"},{"location":"EndlessCheng/binary_search_tree/#530-minimum-absolute-difference-in-bst","title":"530. Minimum Absolute Difference in BST","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Search Tree, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef getMinimumDifference(root: Optional[TreeNode]) -&gt; int:\n    res = float(\"inf\")\n    pre = float(\"-inf\")\n\n    def dfs(node):  # inorder traversal\n        if not node:\n            return\n\n        dfs(node.left)\n\n        nonlocal res, pre\n        res = min(res, node.val - pre)\n        pre = node.val\n\n        if res == 1:  # the minimum possible difference\n            return\n\n        dfs(node.right)\n\n    dfs(root)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    root = [4, 2, 6, 1, 3]\n    root = build(root)\n    print(root)\n    #     __4\n    #    /   \\\n    #   2     6\n    #  / \\\n    # 1   3\n    assert getMinimumDifference(root) == 1\n</code></pre>"},{"location":"EndlessCheng/binary_search_tree/#783-minimum-distance-between-bst-nodes","title":"783. Minimum Distance Between BST Nodes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Search Tree, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_tree/#1305-all-elements-in-two-binary-search-trees","title":"1305. All Elements in Two Binary Search Trees","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Search Tree, Sorting, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_tree/#938-range-sum-of-bst","title":"938. Range Sum of BST","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Search Tree, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_tree/#897-increasing-order-search-tree","title":"897. Increasing Order Search Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Stack, Tree, Depth First Search, Binary Search Tree, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_tree/#2476-closest-nodes-queries-in-a-binary-search-tree","title":"2476. Closest Nodes Queries in a Binary Search Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Tree, Depth First Search, Binary Search Tree, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_tree/#653-two-sum-iv-input-is-a-bst","title":"653. Two Sum IV - Input is a BST","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Two Pointers, Tree, Depth First Search, Breadth First Search, Binary Search Tree, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_tree/#1373-maximum-sum-bst-in-binary-tree","title":"1373. Maximum Sum BST in Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Tree, Depth First Search, Binary Search Tree, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_tree/#1932-merge-bsts-to-create-single-bst","title":"1932. Merge BSTs to Create Single BST","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Binary Search, Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_tree/#285-inorder-successor-in-bst","title":"285. Inorder Successor in BST \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Search Tree, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_tree/#510-inorder-successor-in-bst-ii","title":"510. Inorder Successor in BST II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Binary Search Tree, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_tree/#270-closest-binary-search-tree-value","title":"270. Closest Binary Search Tree Value \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Binary Search, Tree, Depth First Search, Binary Search Tree, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_tree/#272-closest-binary-search-tree-value-ii","title":"272. Closest Binary Search Tree Value II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, Stack, Tree, Depth First Search, Binary Search Tree, Heap Priority Queue, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_search_tree/#255-verify-preorder-sequence-in-binary-search-tree","title":"255. Verify Preorder Sequence in Binary Search Tree \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Stack, Tree, Binary Search Tree, Recursion, Monotonic Stack, Binary Tree</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# BST\ndef verifyPreorder(preorder: List[int]) -&gt; bool:\n    stack = []\n    low = float(\"-inf\")\n\n    for value in preorder:\n        if value &lt; low:\n            return False\n        while stack and value &gt; stack[-1]:\n            low = stack.pop()\n        stack.append(value)\n\n    return True\n\n\nif __name__ == \"__main__\":\n    assert verifyPreorder([8, 5, 1, 7, 10, 12]) is True\n    assert verifyPreorder([8, 5, 4, 3, 2, 1]) is True\n</code></pre>"},{"location":"EndlessCheng/binary_search_tree/#1902-depth-of-bst-given-insertion-order","title":"1902. Depth of BST Given Insertion Order \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Tree, Binary Search Tree, Binary Tree, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_backtracking/","title":"Binary Tree Backtracking","text":""},{"location":"EndlessCheng/binary_tree_backtracking/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 257. Binary Tree Paths (Easy)</li> <li> 113. Path Sum II (Medium)</li> <li> 437. Path Sum III (Medium)</li> </ul>"},{"location":"EndlessCheng/binary_tree_backtracking/#257-binary-tree-paths","title":"257. Binary Tree Paths","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Backtracking, Tree, Depth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef binaryTreePaths(root: Optional[TreeNode]) -&gt; List[str]:\n    res = []\n\n    def dfs(node, path):\n        if not node:\n            return\n        path += str(node.val)\n\n        if not node.left and not node.right:\n            res.append(path)\n            return\n\n        path += \"-&gt;\"\n\n        dfs(node.left, path)\n        dfs(node.right, path)\n\n    dfs(root, \"\")\n\n    return res\n\n\nroot = build([1, 2, 3, None, 5])\nprint(root)\n#   __1\n#  /   \\\n# 2     3\n#  \\\n#   5\nprint(binaryTreePaths(root))  # ['1-&gt;2-&gt;5', '1-&gt;3']\n</code></pre>"},{"location":"EndlessCheng/binary_tree_backtracking/#113-path-sum-ii","title":"113. Path Sum II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Backtracking, Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_backtracking/#437-path-sum-iii","title":"437. Path Sum III","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul> CPP <pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   public:\n    int pathSum(TreeNode *root, int targetSum) {\n        int res = 0;\n        unordered_map&lt;long long, int&gt; cnt{{0, 1}};\n\n        auto dfs = [&amp;](auto &amp;&amp;self, TreeNode *node, long long cur) {\n            if (!node) return;\n            cur += node-&gt;val;\n\n            if (cnt.find(cur - targetSum) != cnt.end())\n                res += cnt[cur - targetSum];\n\n            cnt[cur]++;\n            self(self, node-&gt;left, cur);\n            self(self, node-&gt;right, cur);\n            cnt[cur]--;\n        };\n\n        dfs(dfs, root, 0);\n        return res;\n    }\n};\n\nint main() {\n    Solution s;\n    {\n        TreeNode *root = new TreeNode(10);\n        root-&gt;left = new TreeNode(5);\n        root-&gt;right = new TreeNode(-3);\n        root-&gt;left-&gt;left = new TreeNode(3);\n        root-&gt;left-&gt;right = new TreeNode(2);\n        root-&gt;right-&gt;right = new TreeNode(11);\n        root-&gt;left-&gt;left-&gt;left = new TreeNode(3);\n        root-&gt;left-&gt;left-&gt;right = new TreeNode(-2);\n        root-&gt;left-&gt;right-&gt;right = new TreeNode(1);\n        cout &lt;&lt; s.pathSum(root, 8) &lt;&lt; endl;  // 3\n    }\n    {\n        TreeNode *root = new TreeNode(5);\n        root-&gt;left = new TreeNode(4);\n        root-&gt;right = new TreeNode(8);\n        root-&gt;left-&gt;left = new TreeNode(11);\n        root-&gt;right-&gt;left = new TreeNode(13);\n        root-&gt;right-&gt;right = new TreeNode(4);\n        root-&gt;left-&gt;left-&gt;left = new TreeNode(7);\n        root-&gt;left-&gt;left-&gt;right = new TreeNode(2);\n        root-&gt;right-&gt;right-&gt;left = new TreeNode(5);\n        root-&gt;right-&gt;right-&gt;right = new TreeNode(1);\n        cout &lt;&lt; s.pathSum(root, 22) &lt;&lt; endl;  // 3\n    }\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/binary_tree_bfs/","title":"Binary Tree BFS","text":""},{"location":"EndlessCheng/binary_tree_bfs/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 102. Binary Tree Level Order Traversal (Medium)</li> <li> 103. Binary Tree Zigzag Level Order Traversal (Medium)</li> <li> 107. Binary Tree Level Order Traversal II (Medium)</li> <li> 199. Binary Tree Right Side View (Medium)</li> <li> 513. Find Bottom Left Tree Value (Medium)</li> <li> 515. Find Largest Value in Each Tree Row (Medium)</li> <li> 637. Average of Levels in Binary Tree (Easy)</li> <li> 1161. Maximum Level Sum of a Binary Tree (Medium)</li> <li> 993. Cousins in Binary Tree (Easy)</li> <li> 2583. Kth Largest Sum in a Binary Tree (Medium)</li> <li> 1302. Deepest Leaves Sum (Medium)</li> <li> 2415. Reverse Odd Levels of Binary Tree (Medium)</li> <li> 1609. Even Odd Tree (Medium)</li> <li> 623. Add One Row to Tree (Medium)</li> <li> 2471. Minimum Number of Operations to Sort a Binary Tree by Level (Medium)</li> <li> 863. All Nodes Distance K in Binary Tree (Medium)</li> <li> 2641. Cousins in Binary Tree II (Medium)</li> <li> 919. Complete Binary Tree Inserter (Medium)</li> <li> 331. Verify Preorder Serialization of a Binary Tree (Medium)</li> <li> 958. Check Completeness of a Binary Tree (Medium)</li> <li> 662. Maximum Width of Binary Tree (Medium)</li> <li> 3157. Find the Level of Tree with Minimum Sum (Medium) \ud83d\udc51</li> <li> 1602. Find Nearest Right Node in Binary Tree (Medium) \ud83d\udc51</li> <li> 742. Closest Leaf in a Binary Tree (Medium) \ud83d\udc51</li> <li> 1660. Correct a Binary Tree (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/binary_tree_bfs/#102-binary-tree-level-order-traversal","title":"102. Binary Tree Level Order Traversal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef levelOrder(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        level = []\n        size = len(q)\n\n        for _ in range(size):\n            cur = q.popleft()\n            level.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(level)\n\n    return res\n\n\ntree = build([3, 9, 20, None, None, 15, 7])\nprint(tree)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(levelOrder(tree))  # [[3], [9, 20], [15, 7]]\n</code></pre>"},{"location":"EndlessCheng/binary_tree_bfs/#103-binary-tree-zigzag-level-order-traversal","title":"103. Binary Tree Zigzag Level Order Traversal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef zigzagLevelOrder(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        level = []\n        size = len(q)\n\n        for _ in range(size):\n            cur = q.popleft()\n            level.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(level if not len(res) % 2 else level[::-1])\n\n    return res\n\n\nif __name__ == \"__main__\":\n    tree = build([3, 9, 20, None, None, 15, 7])\n    print(tree)\n    #   3___\n    #  /    \\\n    # 9     _20\n    #      /   \\\n    #     15    7\n    assert zigzagLevelOrder(tree) == [[3], [20, 9], [15, 7]]\n</code></pre>"},{"location":"EndlessCheng/binary_tree_bfs/#107-binary-tree-level-order-traversal-ii","title":"107. Binary Tree Level Order Traversal II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef levelOrderBottom(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    res = []\n    q = deque([root])\n\n    while q:\n        level = []\n        n = len(q)\n\n        for _ in range(n):\n            cur = q.popleft()\n            level.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(level)\n\n    return res[::-1]\n\n\ntree = build([3, 9, 20, None, None, 15, 7])\nprint(tree)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(levelOrderBottom(tree))  # [[15, 7], [9, 20], [3]]\n</code></pre>"},{"location":"EndlessCheng/binary_tree_bfs/#199-binary-tree-right-side-view","title":"199. Binary Tree Right Side View","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Binary Tree BFS\ndef rightSideViewBFS(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        n = len(q)\n        for i in range(n):\n            node = q.popleft()\n            if i == n - 1:\n                res.append(node.val)\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return res\n\n\n# Binary Tree DFS\ndef rightSideViewDFS(root: Optional[TreeNode]) -&gt; List[int]:\n    \"\"\"\u540e\u5e8f\u904d\u5386\uff0c\u5148\u53f3\u540e\u5de6\uff0c\u9047\u5230\u7684\u7b2c\u4e00\u4e2a\u8282\u70b9\u5c31\u662f\u8be5\u6df1\u5ea6\u7684\u6700\u53f3\u4fa7\u8282\u70b9\"\"\"\n    ans = []\n\n    def dfs(node, depth):\n        if node is None:\n            return\n        if depth == len(ans):  # \u8fd9\u4e2a\u6df1\u5ea6\u9996\u6b21\u9047\u5230\n            ans.append(node.val)\n\n        dfs(node.right, depth + 1)\n        dfs(node.left, depth + 1)\n\n    dfs(root, 0)\n\n    return ans\n\n\nif __name__ == \"__main__\":\n    root = [1, 2, 2, 3, 4, None, 3, None, None, 5]\n    root = build(root)\n    print(root)\n    #     ____1\n    #    /     \\\n    #   2__     2\n    #  /   \\     \\\n    # 3     4     3\n    #      /\n    #     5\n    assert rightSideViewBFS(root) == [1, 2, 3, 5]\n    assert rightSideViewDFS(root) == [1, 2, 3, 5]\n</code></pre>"},{"location":"EndlessCheng/binary_tree_bfs/#513-find-bottom-left-tree-value","title":"513. Find Bottom Left Tree Value","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef findBottomLeftValue(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    queue = deque([root])\n    result = 0\n\n    while queue:\n        size = len(queue)\n\n        for i in range(size):\n            node = queue.popleft()\n            if i == 0:\n                result = node.val\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n    return result\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n#     ____1\n#    /     \\\n#   2__     2\n#  /   \\\n# 3     4\n#      /\n#     5\n\nprint(findBottomLeftValue(root))  # 5\n</code></pre>"},{"location":"EndlessCheng/binary_tree_bfs/#515-find-largest-value-in-each-tree-row","title":"515. Find Largest Value in Each Tree Row","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef largestValues(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    queue = deque([root])\n    result = []\n\n    while queue:\n        levelMax = float(\"-inf\")\n        for _ in range(len(queue)):\n            node = queue.popleft()\n\n            levelMax = max(levelMax, node.val)\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n        result.append(levelMax)\n\n    return result\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n#     ____1\n#    /     \\\n#   2__     2\n#  /   \\\n# 3     4\n#      /\n#     5\nprint(largestValues(root))  # [1, 2, 4, 5]\n</code></pre>"},{"location":"EndlessCheng/binary_tree_bfs/#637-average-of-levels-in-binary-tree","title":"637. Average of Levels in Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Binary Tree BFS\ndef averageOfLevels(root: Optional[TreeNode]) -&gt; List[float]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        n = len(q)\n        level = 0\n        for _ in range(n):\n            cur = q.popleft()\n            level += cur.val\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(float(level / n))\n\n    return res\n\n\nif __name__ == \"__main__\":\n    root = [3, 9, 20, None, None, 15, 7]\n    root = build(root)\n    print(root)\n    #   3___\n    #  /    \\\n    # 9     _20\n    #      /   \\\n    #     15    7\n    assert averageOfLevels(root) == [3.00000, 14.50000, 11.00000]\n</code></pre>"},{"location":"EndlessCheng/binary_tree_bfs/#1161-maximum-level-sum-of-a-binary-tree","title":"1161. Maximum Level Sum of a Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BFS\ndef maxLevelSum(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n    res = 0\n    maxSum = float(\"-inf\")\n    level = 1\n\n    while q:\n        n = len(q)\n        curSum = 0\n\n        for _ in range(n):\n            node = q.popleft()\n            curSum += node.val\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n        if curSum &gt; maxSum:\n            maxSum = curSum\n            res = level\n        level += 1\n\n    return res\n\n\nroot = [1, 7, 0, 7, -8, None, None]\nroot = build(root)\nprint(root)\n#     ___1\n#    /    \\\n#   7      0\n#  / \\\n# 7   -8\nprint(maxLevelSum(root))  # 2\n</code></pre>"},{"location":"EndlessCheng/binary_tree_bfs/#993-cousins-in-binary-tree","title":"993. Cousins in Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom math import inf\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef is_cousins_bfs(root: Optional[TreeNode], x: int, y: int) -&gt; bool:\n    if not root:\n        return False\n\n    q = deque([(root, inf)])\n\n    while q:\n        size = len(q)\n        p1, p2 = None, None\n\n        for _ in range(size):\n            cur, par = q.popleft()\n            val = cur.val\n            if x == val:\n                p1 = par\n            if y == val:\n                p2 = par\n\n            if cur.left:\n                q.append((cur.left, val))\n            if cur.right:\n                q.append((cur.right, val))\n\n        # Check if both found at same level\n        if p1 and p2:\n            return p1 != p2  # Same level, different parents\n        elif p1 or p2:\n            return False  # Only one found at this level\n\n    return False\n\n\nif __name__ == \"__main__\":\n    root = build([1, 2, 3, None, 4, None, 5])\n    assert is_cousins_bfs(root, 5, 4)\n    root = build([1, 2, 3, None, 4])\n    assert not is_cousins_bfs(root, 2, 3)\n    root = build([1, 2, 3, 4])\n    assert not is_cousins_bfs(root, 4, 3)\n</code></pre>"},{"location":"EndlessCheng/binary_tree_bfs/#2583-kth-largest-sum-in-a-binary-tree","title":"2583. Kth Largest Sum in a Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Breadth First Search, Sorting, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BFS\ndef kthLargestLevelSum(root: Optional[TreeNode], k: int) -&gt; int:\n    if not root:\n        return 0\n    sums = []\n    q = deque([root])\n\n    while q:\n        size = len(q)\n        level = 0\n        for _ in range(size):\n            node = q.popleft()\n            level += node.val\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n        sums.append(level)\n\n    if len(sums) &lt; k:\n        return -1\n\n    sums.sort()\n    return sums[-k]\n\n\nroot = [5, 8, 9, 2, 1, 3, 7, 4, 6]\nroot = build(root)\nk = 2\nprint(kthLargestLevelSum(root, k))  # 13\n</code></pre>"},{"location":"EndlessCheng/binary_tree_bfs/#1302-deepest-leaves-sum","title":"1302. Deepest Leaves Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BFS\ndef deepestLeavesSum(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n\n    while q:\n        n = len(q)\n        res = 0\n        for _ in range(n):\n            node = q.popleft()\n            res += node.val\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return res\n\n\nroot = [1, 2, 3, 4, 5, None, 6, 7, None, None, None, None, None, 8]\nroot = build(root)\nprint(root)\n#       __1\n#      /   \\\n#     2     3__\n#    / \\       \\\n#   4   5       6\n#  /           /\n# 7           8\nprint(deepestLeavesSum(root))  # 15\n</code></pre>"},{"location":"EndlessCheng/binary_tree_bfs/#2415-reverse-odd-levels-of-binary-tree","title":"2415. Reverse Odd Levels of Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef reverseOddLevels(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return None\n\n    q = deque([root])\n    level = -1\n\n    while q:\n        size = len(q)\n        nodes = []\n        level += 1\n\n        for _ in range(size):\n            node = q.popleft()\n            nodes.append(node)\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n        if level % 2 == 1:\n            i, j = 0, len(nodes) - 1\n            while i &lt; j:\n                nodes[i].val, nodes[j].val = nodes[j].val, nodes[i].val\n                i += 1\n                j -= 1\n\n    return root\n\n\nif __name__ == \"__main__\":\n    root = build([2, 3, 5, 8, 13, 21, 34])\n    print(root)\n    #     ___2___\n    #    /       \\\n    #   3        _5\n    #  / \\      /  \\\n    # 8   13   21   34\n    print(reverseOddLevels(root))\n    #     ___2___\n    #    /       \\\n    #   5        _3\n    #  / \\      /  \\\n    # 8   13   21   34\n</code></pre>"},{"location":"EndlessCheng/binary_tree_bfs/#1609-even-odd-tree","title":"1609. Even Odd Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef isEvenOddTree(root: Optional[TreeNode]) -&gt; bool:\n    if not root:\n        return True\n\n    q = deque([root])\n    level = 0\n\n    while q:\n        size = len(q)\n        prev = None\n\n        for _ in range(size):\n            node = q.popleft()\n\n            if level % 2 == 0:\n                if node.val % 2 == 0:\n                    return False\n                if prev and node.val &lt;= prev:\n                    return False\n            else:\n                if node.val % 2 == 1:\n                    return False\n                if prev and node.val &gt;= prev:\n                    return False\n\n            prev = node.val\n\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n        level += 1\n\n    return True\n\n\nif __name__ == \"__main__\":\n    root = build([5, 4, 2, 3, 3, 7])\n    print(root)\n    #     __5__\n    #    /     \\\n    #   4       2\n    #  / \\     /\n    # 3   3   7\n    assert isEvenOddTree(root) is False\n</code></pre>"},{"location":"EndlessCheng/binary_tree_bfs/#623-add-one-row-to-tree","title":"623. Add One Row to Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BFS\ndef addOneRow_bfs(root: Optional[TreeNode], val: int, depth: int) -&gt; Optional[TreeNode]:\n    if not root:\n        return None\n\n    if depth == 1:\n        new = TreeNode(val)\n        new.left = root\n        return new\n\n    q = deque([root])\n    cur = 1\n\n    while q:\n        size = len(q)\n        for _ in range(size):\n            node = q.popleft()\n\n            if cur == depth - 1:\n                old_left, old_right = node.left, node.right\n                node.left, node.right = TreeNode(val), TreeNode(val)\n                node.left.left = old_left\n                node.right.right = old_right\n            else:\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n        cur += 1\n\n    return root\n\n\n# DFS\ndef addOneRow_dfs(root: Optional[TreeNode], val: int, depth: int) -&gt; Optional[TreeNode]:\n    if depth == 1:\n        new = TreeNode(val)\n        new.left = root\n        return new\n\n    def dfs(node, cur):\n        if not node:\n            return\n        if cur == depth - 1:\n            old_left, old_right = node.left, node.right\n            node.left = TreeNode(val, old_left, None)\n            node.right = TreeNode(val, None, old_right)\n        else:\n            dfs(node.left, cur + 1)\n            dfs(node.right, cur + 1)\n\n    dfs(root, 1)\n\n    return root\n\n\nif __name__ == \"__main__\":\n    root = build([4, 2, 6, 3, 1, 5])\n    print(root)\n    #     __4__\n    #    /     \\\n    #   2       6\n    #  / \\     /\n    # 3   1   5\n    print(addOneRow_bfs(deepcopy(root), 1, 2))\n    #         4\n    #        / \\\n    #     __1   1__\n    #    /         \\\n    #   2           6\n    #  / \\         /\n    # 3   1       5\n    print(addOneRow_dfs(deepcopy(root), 1, 2))\n    #         4\n    #        / \\\n    #     __1   1__\n    #    /         \\\n    #   2           6\n    #  / \\         /\n    # 3   1       5\n</code></pre>"},{"location":"EndlessCheng/binary_tree_bfs/#2471-minimum-number-of-operations-to-sort-a-binary-tree-by-level","title":"2471. Minimum Number of Operations to Sort a Binary Tree by Level","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef _min_swaps_to_sort(nums):\n    \"\"\"\n    Calculate the minimum number of swaps to sort the array.\n    Method: Permutation Cycle\n    \"\"\"\n    n = len(nums)\n    arr = [(num, i) for i, num in enumerate(nums)]\n    arr.sort(key=lambda x: x[0])\n\n    visited = [False] * n\n    res = 0\n\n    for i in range(n):\n        if visited[i] or arr[i][1] == i:\n            continue\n\n        cycle_len = 0\n        j = i\n        while not visited[j]:\n            visited[j] = True\n            j = arr[j][1]\n            cycle_len += 1\n\n        if cycle_len &gt; 1:\n            res += cycle_len - 1\n\n    return res\n\n\ndef minimumOperations_bfs(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    res = 0\n    q = deque([root])\n\n    while q:\n        size = len(q)\n        level = []\n        for _ in range(size):\n            node = q.popleft()\n            level.append(node.val)\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n        res += _min_swaps_to_sort(level)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    root = build([1, 4, 3, 7, 6, 8, 5, None, None, None, None, 9, None, 10])\n    print(root)\n    #     __1____\n    #    /       \\\n    #   4         3___\n    #  / \\       /    \\\n    # 7   6     8     _5\n    #          /     /\n    #         9     10\n    assert minimumOperations_bfs(root) == 3\n</code></pre>"},{"location":"EndlessCheng/binary_tree_bfs/#863-all-nodes-distance-k-in-binary-tree","title":"863. All Nodes Distance K in Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BFS\ndef distanceK(root: TreeNode, target: TreeNode, k: int) -&gt; List[int]:\n    parent = dict()\n\n    def dfs(node, par=None):\n        if node:\n            parent[node] = par\n            dfs(node.left, node)\n            dfs(node.right, node)\n\n    dfs(root)\n\n    q = deque([(target, 0)])\n    seen = set([target])\n\n    while q:\n        node, dist = q.popleft()\n\n        if dist == k:\n            return [node.val] + [node.val for node, _ in q]\n\n        for nei in (node.left, node.right, parent[node]):\n            if nei and nei not in seen:\n                seen.add(nei)\n                q.append((nei, dist + 1))\n\n    return []\n\n\nroot = build([3, 5, 1, 6, 2, 0, 8, None, None, 7, 4])\nprint(root)\n#     ______3__\n#    /         \\\n#   5__         1\n#  /   \\       / \\\n# 6     2     0   8\n#      / \\\n#     7   4\ntarget = root.left\nk = 2\nprint(distanceK(root, target, k))  # [7, 4, 1]\n</code></pre>"},{"location":"EndlessCheng/binary_tree_bfs/#2641-cousins-in-binary-tree-ii","title":"2641. Cousins in Binary Tree II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_bfs/#919-complete-binary-tree-inserter","title":"919. Complete Binary Tree Inserter","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Breadth First Search, Design, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_bfs/#331-verify-preorder-serialization-of-a-binary-tree","title":"331. Verify Preorder Serialization of a Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack, Tree, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_bfs/#958-check-completeness-of-a-binary-tree","title":"958. Check Completeness of a Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Breadth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_bfs/#662-maximum-width-of-binary-tree","title":"662. Maximum Width of Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_bfs/#3157-find-the-level-of-tree-with-minimum-sum","title":"3157. Find the Level of Tree with Minimum Sum \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_bfs/#1602-find-nearest-right-node-in-binary-tree","title":"1602. Find Nearest Right Node in Binary Tree \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Breadth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_bfs/#742-closest-leaf-in-a-binary-tree","title":"742. Closest Leaf in a Binary Tree \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_bfs/#1660-correct-a-binary-tree","title":"1660. Correct a Binary Tree \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_bottom-up_dfs/","title":"Binary Tree Bottom-Up DFS","text":""},{"location":"EndlessCheng/binary_tree_bottom-up_dfs/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 104. Maximum Depth of Binary Tree (Easy)</li> <li> 111. Minimum Depth of Binary Tree (Easy)</li> <li> 965. Univalued Binary Tree (Easy)</li> <li> 100. Same Tree (Easy)</li> <li> 101. Symmetric Tree (Easy)</li> <li> 951. Flip Equivalent Binary Trees (Medium)</li> <li> 1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree (Easy)</li> <li> 110. Balanced Binary Tree (Easy)</li> <li> 226. Invert Binary Tree (Easy)</li> <li> 617. Merge Two Binary Trees (Easy)</li> <li> 2331. Evaluate Boolean Binary Tree (Easy)</li> <li> 508. Most Frequent Subtree Sum (Medium)</li> <li> 563. Binary Tree Tilt (Easy)</li> <li> 606. Construct String from Binary Tree (Medium)</li> <li> 2265. Count Nodes Equal to Average of Subtree (Medium)</li> <li> 1026. Maximum Difference Between Node and Ancestor (Medium)</li> <li> 3319. K-th Largest Perfect Subtree Size in Binary Tree (Medium)</li> <li> 1339. Maximum Product of Splitted Binary Tree (Medium)</li> <li> 1372. Longest ZigZag Path in a Binary Tree (Medium)</li> <li> 1145. Binary Tree Coloring Game (Medium)</li> <li> 572. Subtree of Another Tree (Easy)</li> <li> 1530. Number of Good Leaf Nodes Pairs (Medium)</li> <li> 298. Binary Tree Longest Consecutive Sequence (Medium) \ud83d\udc51</li> <li> 250. Count Univalue Subtrees (Medium) \ud83d\udc51</li> <li> 1973. Count Nodes Equal to Sum of Descendants (Medium) \ud83d\udc51</li> <li> 663. Equal Tree Partition (Medium) \ud83d\udc51</li> <li> 1120. Maximum Average Subtree (Medium) \ud83d\udc51</li> <li> 2792. Count Nodes That Are Great Enough (Hard) \ud83d\udc51</li> <li> 333. Largest BST Subtree (Medium) \ud83d\udc51</li> <li> 366. Find Leaves of Binary Tree (Medium) \ud83d\udc51</li> <li> 156. Binary Tree Upside Down (Medium) \ud83d\udc51</li> <li> 1612. Check If Two Expression Trees are Equivalent (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/binary_tree_bottom-up_dfs/#104-maximum-depth-of-binary-tree","title":"104. Maximum Depth of Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef maxDepthRecursive(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    left = maxDepthRecursive(root.left)\n    right = maxDepthRecursive(root.right)\n\n    return 1 + max(left, right)\n\n\n# DFS\ndef maxDepthDFS(root: Optional[TreeNode]) -&gt; int:\n    res = 0\n\n    def dfs(node, cnt):\n        if node is None:\n            return\n        cnt += 1\n        nonlocal res\n        res = max(res, cnt)\n\n        dfs(node.left, cnt)\n        dfs(node.right, cnt)\n\n    dfs(root, 0)\n\n    return res\n\n\n# Iterative\ndef maxDepthIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n    res = 0\n\n    while q:\n        res += 1\n        n = len(q)\n\n        for _ in range(n):\n            node = q.popleft()\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    root = [1, 2, 2, 3, 4, None, None, None, None, 5]\n    root = build(root)\n    print(root)\n    #     ____1\n    #    /     \\\n    #   2__     2\n    #  /   \\\n    # 3     4\n    #      /\n    #     5\n    assert maxDepthRecursive(root) == 4\n    assert maxDepthDFS(root) == 4\n    assert maxDepthIterative(root) == 4\n</code></pre>"},{"location":"EndlessCheng/binary_tree_bottom-up_dfs/#111-minimum-depth-of-binary-tree","title":"111. Minimum Depth of Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Iterative\ndef minDepthIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n    res = 0\n\n    while q:\n        res += 1\n\n        for _ in range(len(q)):\n            node = q.popleft()\n\n            if not node.left and not node.right:\n                return res\n\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n\n# Recursive\ndef minDepthRecursive(root: Optional[TreeNode]) -&gt; int:\n    if root is None:\n        return 0\n\n    if root.left is None and root.right is not None:\n        return 1 + minDepthRecursive(root.right)\n    if root.left is not None and root.right is None:\n        return 1 + minDepthRecursive(root.left)\n\n    return 1 + min(minDepthRecursive(root.left), minDepthRecursive(root.right))\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n\"\"\"\n    ____1\n   /     \\\n  2__     2\n /   \\\n3     4\n     /\n    5\n\n\"\"\"\nprint(minDepthIterative(root))  # 2\nprint(minDepthRecursive(root))  # 2\n</code></pre>"},{"location":"EndlessCheng/binary_tree_bottom-up_dfs/#965-univalued-binary-tree","title":"965. Univalued Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_bottom-up_dfs/#100-same-tree","title":"100. Same Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# 1. Recursive\ndef isSameTreeRecursive(p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:\n    if not p and not q:\n        return True\n    elif not p or not q:\n        return False\n    elif p.val != q.val:\n        return False\n\n    return isSameTreeRecursive(p.left, q.left) and isSameTreeRecursive(p.right, q.right)\n\n\n# 2. Iterative with queue\ndef isSameTreeIterativeQueue(p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:\n    queue = deque([(p, q)])\n\n    while queue:\n        p, q = queue.popleft()\n\n        if not p and not q:\n            continue\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n\n        queue.append((p.left, q.left))\n        queue.append((p.right, q.right))\n\n    return True\n\n\n# 3. Iterative with stack\ndef isSameTreeIterativeStack(p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:\n    stack = [(p, q)]\n\n    while stack:\n        n1, n2 = stack.pop()\n\n        if not n1 and not n2:\n            continue\n        if not n1 or not n2:\n            return False\n        if n1.val != n2.val:\n            return False\n\n        stack.append((n1.left, n2.left))\n        stack.append((n1.right, n2.right))\n\n    return True\n\n\nif __name__ == \"__main__\":\n    p1 = build([1, 2, 3])\n    q1 = build([1, 2, 3])\n    p2 = build([1, 2])\n    q2 = build([1, None, 2])\n\n    assert isSameTreeRecursive(p1, q1) is True\n    assert isSameTreeRecursive(p2, q2) is False\n    assert isSameTreeIterativeQueue(p1, q1) is True\n    assert isSameTreeIterativeQueue(p2, q2) is False\n    assert isSameTreeIterativeStack(p1, q1) is True\n    assert isSameTreeIterativeStack(p2, q2) is False\n</code></pre>"},{"location":"EndlessCheng/binary_tree_bottom-up_dfs/#101-symmetric-tree","title":"101. Symmetric Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> PythonCPP <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef is_symmetric_recursive(root: Optional[TreeNode]) -&gt; bool:\n    if not root:\n        return True\n\n    def check(left, right):\n        if left is right:\n            return True\n        if not left or not right or left.val != right.val:\n            return False\n        outside = check(left.left, right.right)\n        inside = check(left.right, right.left)\n        return outside and inside\n\n    return check(root.left, root.right)\n\n\n# Iterative\ndef is_symmetric_iterative(root: Optional[TreeNode]) -&gt; bool:\n    if not root:\n        return True\n\n    q = deque()\n    q.append(root.left)\n    q.append(root.right)\n\n    while q:\n        left = q.popleft()\n        right = q.popleft()\n\n        if not left and not right:\n            continue\n\n        if not left or not right or left.val != right.val:\n            return False\n\n        q.append(left.left)\n        q.append(right.right)\n        q.append(left.right)\n        q.append(right.left)\n\n    return True\n\n\nif __name__ == \"__main__\":\n    root = [1, 2, 2, 3, 4, 4, 3]\n    root = build(root)\n    print(root)\n    #     __1__\n    #    /     \\\n    #   2       2\n    #  / \\     / \\\n    # 3   4   4   3\n    assert is_symmetric_recursive(root) is True\n    assert is_symmetric_iterative(root) is True\n</code></pre> <pre><code>#include &lt;iostream&gt;\n\n#include \"include/trees.hpp\"\n\nclass Solution {\n   private:\n    bool dfs(TreeNode *Left, TreeNode *Right) {\n        if (Left == nullptr &amp;&amp; Right == nullptr) return true;\n        if (Left == nullptr || Right == nullptr || Left-&gt;val != Right-&gt;val)\n            return false;\n        return dfs(Left-&gt;left, Right-&gt;right) &amp;&amp; dfs(Left-&gt;right, Right-&gt;left);\n    }\n\n   public:\n    bool isSymmetric(TreeNode *root) {\n        return root == nullptr || dfs(root-&gt;left, root-&gt;right);\n    }\n};\n\nint main() {\n    Solution solution;\n    // Test with a symmetric tree\n    std::vector&lt;int&gt; values = {1, 2, 2, 3, 4, 4, 3};\n    TreeNode *root = TreeUtils::buildTree(values);\n    bool result = solution.isSymmetric(root);\n    std::cout &lt;&lt; \"Is symmetric: \" &lt;&lt; (result ? \"true\" : \"false\") &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/binary_tree_bottom-up_dfs/#951-flip-equivalent-binary-trees","title":"951. Flip Equivalent Binary Trees","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_bottom-up_dfs/#1379-find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree","title":"1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_bottom-up_dfs/#110-balanced-binary-tree","title":"110. Balanced Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef isBalanced(root: Optional[TreeNode]) -&gt; bool:\n    def getHeight(node):\n        if not node:\n            return 0\n\n        # post order\n        leftHeight = getHeight(node.left)\n        rightHeight = getHeight(node.right)\n\n        if leftHeight == -1 or rightHeight == -1:\n            return -1\n\n        if abs(leftHeight - rightHeight) &gt; 1:\n            return -1\n        else:\n            return 1 + max(leftHeight, rightHeight)\n\n    if getHeight(root) != -1:\n        return True\n    else:\n        return False\n\n\nroot = [3, 9, 20, None, None, 15, 7]\nroot = build(root)\nprint(root)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(isBalanced(root))  # True\n</code></pre>"},{"location":"EndlessCheng/binary_tree_bottom-up_dfs/#226-invert-binary-tree","title":"226. Invert Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef invertTreeRecursive(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    root.left, root.right = root.right, root.left\n\n    invertTreeRecursive(root.left)\n    invertTreeRecursive(root.right)\n\n    return root\n\n\n# Iterative\ndef invertTreeIterative(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    stack = [root]\n\n    while stack:\n        node = stack.pop()\n\n        node.left, node.right = node.right, node.left\n        if node.left:\n            stack.append(node.left)\n        if node.right:\n            stack.append(node.right)\n\n    return root\n\n\nroot = build([4, 2, 7, 1, 3, 6, 9])\nprint(root)\n#     __4__\n#    /     \\\n#   2       7\n#  / \\     / \\\n# 1   3   6   9\ninvertedRecursive = invertTreeRecursive(root)\nprint(invertedRecursive)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\nroot = build([4, 2, 7, 1, 3, 6, 9])\ninvertedIterative = invertTreeIterative(root)\nprint(invertedIterative)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\n</code></pre>"},{"location":"EndlessCheng/binary_tree_bottom-up_dfs/#617-merge-two-binary-trees","title":"617. Merge Two Binary Trees","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import List, Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef mergeTrees(\n    root1: Optional[TreeNode], root2: Optional[TreeNode]\n) -&gt; Optional[TreeNode]:\n\n    if not root1:\n        return root2\n    if not root2:\n        return root1\n\n    root = TreeNode()\n\n    root.val += root1.val + root2.val\n    root.left = mergeTrees(root1.left, root2.left)\n    root.right = mergeTrees(root1.right, root2.right)\n\n    return root\n\n\nroot1 = TreeNode(1)\nroot1.left = TreeNode(3)\nroot1.right = TreeNode(2)\nroot1.left.left = TreeNode(5)\n#     1\n#    / \\\n#   3   2\n#  /\n# 5\n\nroot2 = TreeNode(2)\nroot2.left = TreeNode(1)\nroot2.right = TreeNode(3)\nroot2.left.right = TreeNode(4)\nroot2.right.right = TreeNode(7)\n#     2\n#    / \\\n#   1   3\n#    \\   \\\n#     4   7\n\nroot = mergeTrees(root1, root2)\n#     3\n#    / \\\n#   4   5\n#  / \\   \\\n# 5   4   7\n</code></pre>"},{"location":"EndlessCheng/binary_tree_bottom-up_dfs/#2331-evaluate-boolean-binary-tree","title":"2331. Evaluate Boolean Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef evaluateTree(root: Optional[TreeNode]) -&gt; bool:\n    if not root.left and not root.right:\n        return root.val\n\n    left = evaluateTree(root.left)\n    right = evaluateTree(root.right)\n\n    if root.val == 2:\n        return left or right\n    elif root.val == 3:\n        return left and right\n\n\nroot = build([2, 1, 3, None, None, 0, 1])\nprint(root)\n#   2__\n#  /   \\\n# 1     3\n#      / \\\n#     0   1\nboolTree = build([\"OR\", \"True\", \"AND\", None, None, \"False\", \"True\"])\nprint(boolTree)\n#    __OR_______\n#   /           \\\n# True        __AND_\n#            /      \\\n#         False     True\nprint(evaluateTree(root))  # 1\n</code></pre>"},{"location":"EndlessCheng/binary_tree_bottom-up_dfs/#508-most-frequent-subtree-sum","title":"508. Most Frequent Subtree Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_bottom-up_dfs/#563-binary-tree-tilt","title":"563. Binary Tree Tilt","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_bottom-up_dfs/#606-construct-string-from-binary-tree","title":"606. Construct String from Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_bottom-up_dfs/#2265-count-nodes-equal-to-average-of-subtree","title":"2265. Count Nodes Equal to Average of Subtree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_bottom-up_dfs/#1026-maximum-difference-between-node-and-ancestor","title":"1026. Maximum Difference Between Node and Ancestor","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_bottom-up_dfs/#3319-k-th-largest-perfect-subtree-size-in-binary-tree","title":"3319. K-th Largest Perfect Subtree Size in Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Sorting, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_bottom-up_dfs/#1339-maximum-product-of-splitted-binary-tree","title":"1339. Maximum Product of Splitted Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_bottom-up_dfs/#1372-longest-zigzag-path-in-a-binary-tree","title":"1372. Longest ZigZag Path in a Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_bottom-up_dfs/#1145-binary-tree-coloring-game","title":"1145. Binary Tree Coloring Game","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_bottom-up_dfs/#572-subtree-of-another-tree","title":"572. Subtree of Another Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, String Matching, Binary Tree, Hash Function</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# DFS - Tree\ndef isSubtree(root: Optional[TreeNode], subRoot: Optional[TreeNode]) -&gt; bool:\n    def isSameTree(p, q):\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n\n        return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)\n\n    if not root:\n        return False\n\n    return (\n        isSameTree(root, subRoot)\n        or isSubtree(root.left, subRoot)\n        or isSubtree(root.right, subRoot)\n    )\n\n\n# |------------|---------|----------|\n# | Approach   | Time    | Space    |\n# |------------|---------|----------|\n# | DFS        | O(n * m)| O(n)     |\n# |------------|---------|----------|\n\n\nroot = build([3, 4, 5, 1, 2, None, None, None, None, 0])\nsubRoot = build([4, 1, 2])\nprint(root)\n#     ____3\n#    /     \\\n#   4__     5\n#  /   \\\n# 1     2\n#      /\n#     0\nprint(subRoot)\n#   4\n#  / \\\n# 1   2\nprint(isSubtree(root, subRoot))  # False\n</code></pre>"},{"location":"EndlessCheng/binary_tree_bottom-up_dfs/#1530-number-of-good-leaf-nodes-pairs","title":"1530. Number of Good Leaf Nodes Pairs","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_bottom-up_dfs/#298-binary-tree-longest-consecutive-sequence","title":"298. Binary Tree Longest Consecutive Sequence \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Binary Tree\ndef longestConsecutive(root: Optional[TreeNode]) -&gt; int:\n    res = 0\n\n    def dfs(node):\n        if not node:\n            return 0\n\n        left, right = dfs(node.left), dfs(node.right)\n        cur = 1\n        if node.left and node.left.val == (node.val + 1):\n            cur = max(cur, left + 1)\n        if node.right and node.right.val == (node.val + 1):\n            cur = max(cur, right + 1)\n\n        nonlocal res\n        res = max(res, cur)\n        return cur\n\n    dfs(root)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    root = build([1, 3, 2, 4, None, None, None, 5])\n    print(root)\n    #       1\n    #      / \\\n    #     3   2\n    #    /\n    #   4\n    #  /\n    # 5\n    print(longestConsecutive(root))  # 3\n</code></pre>"},{"location":"EndlessCheng/binary_tree_bottom-up_dfs/#250-count-univalue-subtrees","title":"250. Count Univalue Subtrees \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_bottom-up_dfs/#1973-count-nodes-equal-to-sum-of-descendants","title":"1973. Count Nodes Equal to Sum of Descendants \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_bottom-up_dfs/#663-equal-tree-partition","title":"663. Equal Tree Partition \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_bottom-up_dfs/#1120-maximum-average-subtree","title":"1120. Maximum Average Subtree \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_bottom-up_dfs/#2792-count-nodes-that-are-great-enough","title":"2792. Count Nodes That Are Great Enough \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Divide And Conquer, Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_bottom-up_dfs/#333-largest-bst-subtree","title":"333. Largest BST Subtree \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Tree, Depth First Search, Binary Search Tree, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_bottom-up_dfs/#366-find-leaves-of-binary-tree","title":"366. Find Leaves of Binary Tree \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef findLeaves(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    depths = defaultdict(list)\n\n    def dfs(node):\n        if not node:\n            return 0\n        l, r = dfs(node.left), dfs(node.right)\n        depth = 1 + max(l, r)\n        depths[depth].append(node.val)\n        return depth\n\n    dfs(root)\n    return [i for i in depths.values()]\n\n\nif __name__ == \"__main__\":\n    root = build([1, 2, 3, 4, 5])\n    print(root)\n    #     __1\n    #    /   \\\n    #   2     3\n    #  / \\\n    # 4   5\n    print(findLeaves(root))  # [[4, 5, 3], [2], [1]]\n</code></pre>"},{"location":"EndlessCheng/binary_tree_bottom-up_dfs/#156-binary-tree-upside-down","title":"156. Binary Tree Upside Down \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_bottom-up_dfs/#1612-check-if-two-expression-trees-are-equivalent","title":"1612. Check If Two Expression Trees are Equivalent \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Tree, Depth First Search, Binary Tree, Counting</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_bottom-up_dfs_node_deletion/","title":"Binary Tree Bottom-Up DFS Node Deletion","text":""},{"location":"EndlessCheng/binary_tree_bottom-up_dfs_node_deletion/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 814. Binary Tree Pruning (Medium)</li> <li> 1325. Delete Leaves With a Given Value (Medium)</li> <li> 1110. Delete Nodes And Return Forest (Medium)</li> </ul>"},{"location":"EndlessCheng/binary_tree_bottom-up_dfs_node_deletion/#814-binary-tree-pruning","title":"814. Binary Tree Pruning","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_bottom-up_dfs_node_deletion/#1325-delete-leaves-with-a-given-value","title":"1325. Delete Leaves With a Given Value","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_bottom-up_dfs_node_deletion/#1110-delete-nodes-and-return-forest","title":"1110. Delete Nodes And Return Forest","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_construction/","title":"Binary Tree Construction","text":""},{"location":"EndlessCheng/binary_tree_construction/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 108. Convert Sorted Array to Binary Search Tree (Easy)</li> <li> 654. Maximum Binary Tree (Medium)</li> <li> 998. Maximum Binary Tree II (Medium)</li> <li> 1008. Construct Binary Search Tree from Preorder Traversal (Medium)</li> <li> 1382. Balance a Binary Search Tree (Medium)</li> <li> 2196. Create Binary Tree From Descriptions (Medium)</li> <li> 105. Construct Binary Tree from Preorder and Inorder Traversal (Medium)</li> <li> 106. Construct Binary Tree from Inorder and Postorder Traversal (Medium)</li> <li> 889. Construct Binary Tree from Preorder and Postorder Traversal (Medium)</li> <li> 1028. Recover a Tree From Preorder Traversal (Hard)</li> <li> 536. Construct Binary Tree from String (Medium) \ud83d\udc51</li> <li> 1628. Design an Expression Tree With Evaluate Function (Medium) \ud83d\udc51</li> <li> 1597. Build Binary Expression Tree From Infix Expression (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/binary_tree_construction/#108-convert-sorted-array-to-binary-search-tree","title":"108. Convert Sorted Array to Binary Search Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Divide And Conquer, Tree, Binary Search Tree, Binary Tree</p> </li> </ul> PythonCPP <pre><code>from typing import List, Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef sortedArrayToBST(nums: List[int]) -&gt; Optional[TreeNode]:\n    if len(nums) == 0:\n        return None\n\n    mid = len(nums) // 2\n    root = TreeNode(nums[mid])\n\n    root.left = sortedArrayToBST(nums[:mid])\n    root.right = sortedArrayToBST(nums[mid + 1 :])\n\n    return root\n\n\nnums = [-10, -3, 0, 5, 9]\nroot = sortedArrayToBST(nums)\n#      0\n#     / \\\n#   -3   9\n#   /   /\n# -10  5\n</code></pre> <pre><code>#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   public:\n    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) {\n        if (nums.size() == 0) return nullptr;\n\n        int mid = nums.size() / 2;\n        TreeNode* root = new TreeNode(nums[mid]);\n\n        vector&lt;int&gt; left(nums.begin(), nums.begin() + mid);\n        vector&lt;int&gt; right(nums.begin() + mid + 1, nums.end());\n\n        root-&gt;left = sortedArrayToBST(left);\n        root-&gt;right = sortedArrayToBST(right);\n\n        return root;\n    }\n};\n\nint main() { return 0; }\n</code></pre>"},{"location":"EndlessCheng/binary_tree_construction/#654-maximum-binary-tree","title":"654. Maximum Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Divide And Conquer, Stack, Tree, Monotonic Stack, Binary Tree</p> </li> </ul> Python <pre><code>from typing import List, Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef constructMaximumBinaryTree(nums: List[int]) -&gt; Optional[TreeNode]:\n    if len(nums) == 0:\n        return None\n\n    maximum = max(nums)\n    rootIndex = nums.index(maximum)\n\n    root = TreeNode(maximum)\n\n    left_nums = nums[:rootIndex]\n    right_nums = nums[rootIndex + 1 :]\n\n    root.left = constructMaximumBinaryTree(left_nums)\n    root.right = constructMaximumBinaryTree(right_nums)\n\n    return root\n\n\nnums = [3, 2, 1, 6, 0, 5]\nroot = constructMaximumBinaryTree(nums)\n#     __6__\n#    /     \\\n#   3       5\n#    \\     /\n#     2   0\n#      \\\n#       1\n</code></pre>"},{"location":"EndlessCheng/binary_tree_construction/#998-maximum-binary-tree-ii","title":"998. Maximum Binary Tree II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_construction/#1008-construct-binary-search-tree-from-preorder-traversal","title":"1008. Construct Binary Search Tree from Preorder Traversal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Stack, Tree, Binary Search Tree, Monotonic Stack, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_construction/#1382-balance-a-binary-search-tree","title":"1382. Balance a Binary Search Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Divide And Conquer, Greedy, Tree, Depth First Search, Binary Search Tree, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_construction/#2196-create-binary-tree-from-descriptions","title":"2196. Create Binary Tree From Descriptions","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Tree, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_construction/#105-construct-binary-tree-from-preorder-and-inorder-traversal","title":"105. Construct Binary Tree from Preorder and Inorder Traversal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Divide And Conquer, Tree, Binary Tree</p> </li> </ul> PythonCPP <pre><code>from typing import List, Optional\n\nfrom helper import TreeNode\n\n\ndef buildTree(preorder: List[int], inorder: List[int]) -&gt; Optional[TreeNode]:\n    \"\"\"\n    preorder  root left right  1  2  3\n    inorder   left root right  4  5  6\n    \"\"\"\n    if len(preorder) == 0:\n        return None\n\n    root_val = preorder[0]  # 1\n    root = TreeNode(root_val)\n\n    separator_idx = inorder.index(root_val)  # 5\n\n    left_inorder = inorder[:separator_idx]  # 4\n    right_inorder = inorder[separator_idx + 1 :]  # 6\n\n    left_preorder = preorder[1 : 1 + len(left_inorder)]  # 2\n    right_preorder = preorder[1 + len(left_inorder) :]  # 3\n\n    root.left = buildTree(left_preorder, left_inorder)\n    root.right = buildTree(right_preorder, right_inorder)\n\n    return root\n\n\npreorder = [3, 9, 20, 15, 7]\ninorder = [9, 3, 15, 20, 7]\nroot = buildTree(preorder, inorder)\nprint(root)\n#     3\n#    / \\\n#   9  20\n#     /  \\\n#    15   7\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   public:\n    vector&lt;int&gt; preorder;\n    unordered_map&lt;int, int&gt; inorderMap;\n\n    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {\n        this-&gt;preorder = preorder;\n        for (size_t i = 0; i &lt; inorder.size(); i++) {\n            inorderMap[inorder[i]] = i;\n        }\n        return buildSubtree(0, 0, inorder.size() - 1);\n    }\n\n   private:\n    TreeNode* buildSubtree(int rootIndex, int left, int right) {\n        if (left &gt; right) return nullptr;\n\n        TreeNode* root = new TreeNode(preorder[rootIndex]);\n        int inorderIndex = inorderMap[preorder[rootIndex]];\n\n        root-&gt;left = buildSubtree(rootIndex + 1, left, inorderIndex - 1);\n        root-&gt;right = buildSubtree(rootIndex + (inorderIndex - left + 1),\n                                   inorderIndex + 1, right);\n\n        return root;\n    }\n};\n\nint main() {\n    vector&lt;int&gt; preorder = {3, 9, 20, 15, 7};\n    vector&lt;int&gt; inorder = {9, 3, 15, 20, 7};\n    Solution solution;\n    TreeNode* root = solution.buildTree(preorder, inorder);\n    cout &lt;&lt; root-&gt;val &lt;&lt; endl;                // 3\n    cout &lt;&lt; root-&gt;left-&gt;val &lt;&lt; endl;          // 9\n    cout &lt;&lt; root-&gt;right-&gt;val &lt;&lt; endl;         // 20\n    cout &lt;&lt; root-&gt;right-&gt;left-&gt;val &lt;&lt; endl;   // 15\n    cout &lt;&lt; root-&gt;right-&gt;right-&gt;val &lt;&lt; endl;  // 7\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/binary_tree_construction/#106-construct-binary-tree-from-inorder-and-postorder-traversal","title":"106. Construct Binary Tree from Inorder and Postorder Traversal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Divide And Conquer, Tree, Binary Tree</p> </li> </ul> Python <pre><code>from typing import List, Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef buildTree(inorder: List[int], postorder: List[int]) -&gt; Optional[TreeNode]:\n    \"\"\"\n    inorder:    left root  right   1  2  3\n    postorder:  left right root    4  5  6\n    \"\"\"\n\n    if not postorder:\n        return None\n\n    root_val = postorder[-1]  # 6\n    root = TreeNode(root_val)\n\n    separator_idx = inorder.index(root_val)  # 2\n\n    left_inorder = inorder[:separator_idx]  # 1\n    right_inorder = inorder[separator_idx + 1 :]  # 3\n\n    left_postorder = postorder[: len(left_inorder)]  # 4\n    right_postorder = postorder[len(left_inorder) : -1]  # 5\n\n    root.left = buildTree(left_inorder, left_postorder)\n    root.right = buildTree(right_inorder, right_postorder)\n\n    return root\n\n\ninorder = [9, 3, 15, 20, 7]\npostorder = [9, 15, 7, 20, 3]\nroot = buildTree(inorder, postorder)\nprint(root)\n#     3\n#    / \\\n#   9  20\n#     /  \\\n#    15   7\n</code></pre>"},{"location":"EndlessCheng/binary_tree_construction/#889-construct-binary-tree-from-preorder-and-postorder-traversal","title":"889. Construct Binary Tree from Preorder and Postorder Traversal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Divide And Conquer, Tree, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_construction/#1028-recover-a-tree-from-preorder-traversal","title":"1028. Recover a Tree From Preorder Traversal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_construction/#536-construct-binary-tree-from-string","title":"536. Construct Binary Tree from String \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack, Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_construction/#1628-design-an-expression-tree-with-evaluate-function","title":"1628. Design an Expression Tree With Evaluate Function \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Stack, Tree, Design, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_construction/#1597-build-binary-expression-tree-from-infix-expression","title":"1597. Build Binary Expression Tree From Infix Expression \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack, Tree, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_diameter/","title":"Binary Tree Diameter","text":""},{"location":"EndlessCheng/binary_tree_diameter/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 543. Diameter of Binary Tree (Easy)</li> <li> 687. Longest Univalue Path (Medium)</li> <li> 124. Binary Tree Maximum Path Sum (Hard)</li> <li> 2385. Amount of Time for Binary Tree to Be Infected (Medium)</li> <li> 549. Binary Tree Longest Consecutive Sequence II (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/binary_tree_diameter/#543-diameter-of-binary-tree","title":"543. Diameter of Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul> PythonCPP <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Tree DFS\nclass Solution:\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -&gt; int:\n        self.diameter = 0\n\n        def dfs(node):\n            if not node:\n                return 0\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n            self.diameter = max(self.diameter, left + right)\n\n            return 1 + max(left, right)\n\n        dfs(root)\n\n        return self.diameter\n\n\nroot = build([1, 2, 3, 4, 5])\nprint(root)\n#     __1\n#    /   \\\n#   2     3\n#  / \\\n# 4   5\nobj = Solution()\nprint(obj.diameterOfBinaryTree(root))  # 3\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nint diameterOfBinaryTree(TreeNode* root) {\n    int diameter = 0;\n\n    auto dfs = [&amp;](auto&amp;&amp; self, TreeNode* node) -&gt; int {\n        if (!node) return 0;\n        int left = self(self, node-&gt;left);\n        int right = self(self, node-&gt;right);\n\n        diameter = max(diameter, left + right);\n\n        return 1 + max(left, right);\n    };\n\n    dfs(dfs, root);\n    return diameter;\n}\n\nint main() {\n    // [1, 2, 3, 4, 5]\n    TreeNode* root = new TreeNode(1);\n    root-&gt;left = new TreeNode(2);\n    root-&gt;right = new TreeNode(3);\n    root-&gt;left-&gt;left = new TreeNode(4);\n    root-&gt;left-&gt;right = new TreeNode(5);\n    cout &lt;&lt; diameterOfBinaryTree(root) &lt;&lt; endl;  // 3\n\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/binary_tree_diameter/#687-longest-univalue-path","title":"687. Longest Univalue Path","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_diameter/#124-binary-tree-maximum-path-sum","title":"124. Binary Tree Maximum Path Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Tree, Depth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef maxPathSum(root: Optional[TreeNode]) -&gt; int:\n    res = float(\"-inf\")\n\n    def dfs(node):\n        if not node:\n            return 0\n\n        leftMax = max(dfs(node.left), 0)\n        rightMax = max(dfs(node.right), 0)\n\n        cur = node.val + leftMax + rightMax\n        nonlocal res\n        res = max(res, cur)\n\n        return node.val + max(leftMax, rightMax)\n\n    dfs(root)\n\n    return res\n\n\nroot = build([-10, 9, 20, None, None, 15, 7])\nprint(root)\n#   -10___\n#  /      \\\n# 9       _20\n#        /   \\\n#       15    7\nprint(maxPathSum(root))  # 42\n</code></pre>"},{"location":"EndlessCheng/binary_tree_diameter/#2385-amount-of-time-for-binary-tree-to-be-infected","title":"2385. Amount of Time for Binary Tree to Be Infected","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_diameter/#549-binary-tree-longest-consecutive-sequence-ii","title":"549. Binary Tree Longest Consecutive Sequence II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_insert_delete_nodes/","title":"Binary Tree Insert Delete Nodes","text":""},{"location":"EndlessCheng/binary_tree_insert_delete_nodes/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 701. Insert into a Binary Search Tree (Medium)</li> <li> 450. Delete Node in a BST (Medium)</li> <li> 669. Trim a Binary Search Tree (Medium)</li> <li> 776. Split BST (Medium) \ud83d\udc51</li> <li> 1666. Change the Root of a Binary Tree (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/binary_tree_insert_delete_nodes/#701-insert-into-a-binary-search-tree","title":"701. Insert into a Binary Search Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Binary Search Tree, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef insertIntoBST(root: Optional[TreeNode], val: int) -&gt; Optional[TreeNode]:\n    if root is None:\n        return TreeNode(val)\n\n    if root.val &gt; val:\n        root.left = insertIntoBST(root.left, val)\n    if root.val &lt; val:\n        root.right = insertIntoBST(root.right, val)\n\n    return root\n\n\nroot = TreeNode(4)\nroot.left = TreeNode(2)\nroot.right = TreeNode(6)\nroot.left.left = TreeNode(1)\nroot.left.right = TreeNode(3)\n#     __4\n#    /   \\\n#   2     6\n#  / \\\n# 1   3\n\ninsertIntoBST(root, 5)\n#     __4\n#    /   \\\n#   2     6\n#  / \\   /\n# 1   3 5\n</code></pre>"},{"location":"EndlessCheng/binary_tree_insert_delete_nodes/#450-delete-node-in-a-bst","title":"450. Delete Node in a BST","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Binary Search Tree, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef deleteNode(root: Optional[TreeNode], key: int) -&gt; Optional[TreeNode]:\n    if root is None:\n        return root\n\n    if root.val == key:\n        if root.left is None and root.right is None:\n            return None\n        elif root.left is None:\n            return root.right\n        elif root.right is None:\n            return root.left\n        else:\n            cur = root.right\n            while cur.left is not None:\n                cur = cur.left\n            cur.left = root.left\n            return root.right\n\n    if root.val &gt; key:\n        root.left = deleteNode(root.left, key)\n    if root.val &lt; key:\n        root.right = deleteNode(root.right, key)\n\n    return root\n\n\nroot = TreeNode(5)\nroot.left = TreeNode(3)\nroot.right = TreeNode(6)\nroot.left.left = TreeNode(2)\nroot.left.right = TreeNode(4)\nroot.right.right = TreeNode(7)\n#     __5\n#    /   \\\n#   3     6\n#  / \\     \\\n# 2   4     7\n\ndeleteNode(root, 3)\n#     __5\n#    /   \\\n#   4     6\n#  /       \\\n# 2         7\n</code></pre>"},{"location":"EndlessCheng/binary_tree_insert_delete_nodes/#669-trim-a-binary-search-tree","title":"669. Trim a Binary Search Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Search Tree, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef trimBST(root: Optional[TreeNode], low: int, high: int) -&gt; Optional[TreeNode]:\n    if root is None:\n        return None\n\n    if root.val &lt; low:\n        return trimBST(root.right, low, high)\n    if root.val &gt; high:\n        return trimBST(root.left, low, high)\n\n    root.left = trimBST(root.left, low, high)\n    root.right = trimBST(root.right, low, high)\n\n    return root\n\n\nroot = TreeNode(3)\nroot.left = TreeNode(0)\nroot.right = TreeNode(4)\nroot.left.right = TreeNode(2)\nroot.left.right.left = TreeNode(1)\n#     __3\n#    /   \\\n#   0     4\n#    \\\n#     2\n#    /\n#   1\n\ntrimBST(root, 1, 3)\n#     __3\n#    /\n#   2\n#  /\n# 1\n</code></pre>"},{"location":"EndlessCheng/binary_tree_insert_delete_nodes/#776-split-bst","title":"776. Split BST \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Binary Search Tree, Recursion, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_insert_delete_nodes/#1666-change-the-root-of-a-binary-tree","title":"1666. Change the Root of a Binary Tree \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_linked_list/","title":"Binary Tree Linked List","text":""},{"location":"EndlessCheng/binary_tree_linked_list/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 114. Flatten Binary Tree to Linked List (Medium)</li> <li> 1367. Linked List in Binary Tree (Medium)</li> <li> 109. Convert Sorted List to Binary Search Tree (Medium)</li> <li> 116. Populating Next Right Pointers in Each Node (Medium)</li> <li> 117. Populating Next Right Pointers in Each Node II (Medium)</li> <li> 426. Convert Binary Search Tree to Sorted Doubly Linked List (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/binary_tree_linked_list/#114-flatten-binary-tree-to-linked-list","title":"114. Flatten Binary Tree to Linked List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Stack, Tree, Depth First Search, Binary Tree</p> </li> </ul> CPP <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   public:\n    void flatten(TreeNode* root) {\n        if (!root) return;\n\n        flatten(root-&gt;left);\n        flatten(root-&gt;right);\n\n        TreeNode* left = root-&gt;left;\n        TreeNode* right = root-&gt;right;\n\n        root-&gt;left = nullptr;\n        root-&gt;right = left;\n\n        TreeNode* curr = root;\n        while (curr-&gt;right) curr = curr-&gt;right;\n        curr-&gt;right = right;\n    }\n};\n\nint main() {\n    Solution sol;\n    TreeNode* root =\n        new TreeNode(1, new TreeNode(2, new TreeNode(3), new TreeNode(4)),\n                     new TreeNode(5, nullptr, new TreeNode(6)));\n    sol.flatten(root);\n\n    TreeNode* cur = root;\n    std::vector&lt;int&gt; expected = {1, 2, 3, 4, 5, 6};\n    for (int val : expected) {\n        assert(cur != nullptr &amp;&amp; cur-&gt;val == val);\n        cur = cur-&gt;right;\n    }\n    assert(cur == nullptr);  // End of list\n\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/binary_tree_linked_list/#1367-linked-list-in-binary-tree","title":"1367. Linked List in Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_linked_list/#109-convert-sorted-list-to-binary-search-tree","title":"109. Convert Sorted List to Binary Search Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Divide And Conquer, Tree, Binary Search Tree, Binary Tree</p> </li> </ul> Python <pre><code>\"\"\"\n![109](https://assets.leetcode.com/uploads/2020/08/17/linked.jpg)\n\"\"\"\n\nfrom typing import Optional\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef sortedListToBST(head: Optional[ListNode]) -&gt; Optional[TreeNode]:\n    if not head:\n        return None\n\n    def find_mid(head: ListNode) -&gt; ListNode:\n        prev = None\n        slow = head\n        fast = head\n\n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n\n        if prev:\n            prev.next = None\n\n        return slow\n\n    mid = find_mid(head)\n\n    node = TreeNode(mid.val)\n\n    if head == mid:\n        return node\n\n    node.left = sortedListToBST(head)\n    node.right = sortedListToBST(mid.next)\n\n    return node\n\n\nhead = ListNode(-10)\nhead.next = ListNode(-3)\nhead.next.next = ListNode(0)\nhead.next.next.next = ListNode(5)\nhead.next.next.next.next = ListNode(9)\n\nroot = sortedListToBST(head)\nassert root.val == 0\nassert root.left.val == -3\nassert root.left.left.val == -10\nassert root.right.val == 9\nassert root.right.left.val == 5\nprint(\"All passed\")\n\n#      0\n#     / \\\n#   -3   9\n#   /   /\n# -10  5\n</code></pre>"},{"location":"EndlessCheng/binary_tree_linked_list/#116-populating-next-right-pointers-in-each-node","title":"116. Populating Next Right Pointers in Each Node","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>\"\"\"\n-   Perfect Binary Tree\n\"\"\"\n\nfrom collections import deque\nfrom typing import Optional\n\n\nclass Node:\n    def __init__(\n        self,\n        val: int = 0,\n        left: \"Node\" = None,\n        right: \"Node\" = None,\n        next: \"Node\" = None,\n    ):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\n\ndef connect(root: \"Optional[Node]\") -&gt; \"Optional[Node]\":\n    if not root:\n        return root\n\n    queue = deque([root])\n\n    while queue:\n        size = len(queue)\n        prev = None\n\n        for _ in range(size):\n            node = queue.popleft()\n\n            if prev:\n                prev.next = node\n            prev = node\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n    return root\n\n\n# Perfect binary tree creation\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.right.left = Node(6)\nroot.right.right = Node(7)\n#     __1__\n#    /     \\\n#   2__     3\n#  /   \\   / \\\n# 4     5 6   7\n\n\n# Connect the nodes\nconnect(root)\n#      __1__ -&gt; None\n#     /     \\\n#   _2_ -&gt;  3 -&gt; None\n#  /   \\   / \\\n# 4 -&gt; 5-&gt;6-&gt; 7 -&gt; None\n\n\nassert root.next is None\nassert root.left.next == root.right\nassert root.left.left.next == root.left.right\nassert root.left.right.next == root.right.left\nassert root.right.left.next == root.right.right\nassert root.right.right.next is None\nprint(\"All tests passed.\")\n</code></pre>"},{"location":"EndlessCheng/binary_tree_linked_list/#117-populating-next-right-pointers-in-each-node-ii","title":"117. Populating Next Right Pointers in Each Node II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import Optional\n\n\nclass Node:\n    def __init__(\n        self,\n        val: int = 0,\n        left: Optional[\"Node\"] = None,\n        right: Optional[\"Node\"] = None,\n        next: Optional[\"Node\"] = None,\n    ):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\n\nclass connect:\n    def level_order(self, root: \"Node\") -&gt; \"Node\":\n        if not root:\n            return None\n\n        q = deque([root])\n\n        while q:\n            size = len(q)\n            prev = None\n\n            for _ in range(size):\n                node = q.popleft()\n\n                if prev:\n                    prev.next = node\n                prev = node\n\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n\n        return root\n\n\nif __name__ == \"__main__\":\n\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    root.right.right = Node(7)\n    #       1\n    #      / \\\n    #     2   3\n    #    / \\   \\\n    #   4   5   7\n\n    solution = connect()\n    root = solution.level_order(root)\n    assert root.next is None\n    assert root.left.next == root.right\n    assert root.right.next is None\n    assert root.left.left.next == root.left.right\n    assert root.left.right.next == root.right.right\n    assert root.right.right.next is None\n    #       1 -&gt; None\n    #      / \\\n    #     2 -&gt; 3 -&gt; None\n    #    / \\    \\\n    #   4 -&gt; 5 -&gt; 7 -&gt; None\n</code></pre>"},{"location":"EndlessCheng/binary_tree_linked_list/#426-convert-binary-search-tree-to-sorted-doubly-linked-list","title":"426. Convert Binary Search Tree to Sorted Doubly Linked List \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Stack, Tree, Depth First Search, Binary Search Tree, Binary Tree, Doubly Linked List</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_lowest_common_ancestor/","title":"Binary Tree Lowest Common Ancestor","text":""},{"location":"EndlessCheng/binary_tree_lowest_common_ancestor/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 235. Lowest Common Ancestor of a Binary Search Tree (Medium)</li> <li> 236. Lowest Common Ancestor of a Binary Tree (Medium)</li> <li> 1123. Lowest Common Ancestor of Deepest Leaves (Medium)</li> <li> 2096. Step-By-Step Directions From a Binary Tree Node to Another (Medium)</li> <li> 1740. Find Distance in a Binary Tree (Medium) \ud83d\udc51</li> <li> 1644. Lowest Common Ancestor of a Binary Tree II (Medium) \ud83d\udc51</li> <li> 1650. Lowest Common Ancestor of a Binary Tree III (Medium) \ud83d\udc51</li> <li> 1676. Lowest Common Ancestor of a Binary Tree IV (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/binary_tree_lowest_common_ancestor/#235-lowest-common-ancestor-of-a-binary-search-tree","title":"235. Lowest Common Ancestor of a Binary Search Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Search Tree, Binary Tree</p> </li> </ul> Python <pre><code>from binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef lowestCommonAncestor(root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\") -&gt; \"TreeNode\":\n    while root:\n        if root.val &gt; p.val and root.val &gt; q.val:\n            root = root.left\n        elif root.val &lt; p.val and root.val &lt; q.val:\n            root = root.right\n        else:\n            return root\n\n\nroot = [6, 2, 8, 0, 4, 7, 9, None, None, 3, 5]\nroot = build(root)\np = root.left\nq = root.right\nprint(root)\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\nprint(lowestCommonAncestor(root, p, q))\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\n</code></pre>"},{"location":"EndlessCheng/binary_tree_lowest_common_ancestor/#236-lowest-common-ancestor-of-a-binary-tree","title":"236. Lowest Common Ancestor of a Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul> PythonCPP <pre><code>from typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass LowestCommonAncestor:\n    def lowestCommonAncestor(\n        self, root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n    ) -&gt; \"TreeNode\":\n        if not root or q == root or p == root:\n            return root\n\n        left = self.lowestCommonAncestor(root.left, p, q)\n        right = self.lowestCommonAncestor(root.right, p, q)\n\n        if left and right:\n            return root\n\n        return left or right\n\n\nif __name__ == \"__main__\":\n    root = build([3, 5, 1, 6, 2, 0, 8, None, None, 7, 4])\n    print(root)\n    #     ______3__\n    #    /         \\\n    #   5__         1\n    #  /   \\       / \\\n    # 6     2     0   8\n    #      / \\\n    #     7   4\n    p = root.left  # 5\n    q = root.right  # 1\n    sol = LowestCommonAncestor()\n    print(sol.lowestCommonAncestor(root, p, q))\n    #     ______3__\n    #    /         \\\n    #   5__         1\n    #  /   \\       / \\\n    # 6     2     0   8\n    #      / \\\n    #     7   4\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   public:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if (root == nullptr || root == p || root == q) {\n            return root;\n        }\n\n        TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);\n        TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);\n\n        if (left &amp;&amp; right) {\n            return root;\n        }\n\n        return left ? left : right;\n    }\n};\n\nint main() { return 0; }\n</code></pre>"},{"location":"EndlessCheng/binary_tree_lowest_common_ancestor/#1123-lowest-common-ancestor-of-deepest-leaves","title":"1123. Lowest Common Ancestor of Deepest Leaves","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Lowest Common Ancestor\ndef lcaDeepestLeaves(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    res = None\n    max_depth = -1\n\n    def dfs(node, depth) -&gt; int:\n        nonlocal res, max_depth\n        if not node:\n            max_depth = max(max_depth, depth)\n            return depth\n        left_max_depth = dfs(node.left, depth + 1)\n        right_max_depth = dfs(node.right, depth + 1)\n        if left_max_depth == right_max_depth == max_depth:\n            res = node\n        return max(left_max_depth, right_max_depth)\n\n    dfs(root, 0)\n    return res\n\n\nif __name__ == \"__main__\":\n    root = [3, 5, 1, 6, 2, 0, 8, None, None, 7, 4]\n    root = build(root)\n    print(root)\n    #     ______3__\n    #    /         \\\n    #   5__         1\n    #  /   \\       / \\\n    # 6     2     0   8\n    #      / \\\n    #     7   4\n    print(lcaDeepestLeaves(root))  # 2\n    #   2\n    #  / \\\n    # 7   4\n</code></pre>"},{"location":"EndlessCheng/binary_tree_lowest_common_ancestor/#2096-step-by-step-directions-from-a-binary-tree-node-to-another","title":"2096. Step-By-Step Directions From a Binary Tree Node to Another","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Tree, Depth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\n\n\nclass GetDirections:\n    def lca(self, root: Optional[TreeNode], startValue: int, destValue: int) -&gt; str:\n        path_s, path_t = [], []\n\n        def dfs(node, target, path):\n            if not node:\n                return False\n            if node.val == target:\n                return True\n\n            path.append(\"L\")\n            if dfs(node.left, target, path):\n                return True\n            path.pop()\n\n            path.append(\"R\")\n            if dfs(node.right, target, path):\n                return True\n            path.pop()\n\n            return False\n\n        dfs(root, startValue, path_s)\n        dfs(root, destValue, path_t)\n\n        i = 0\n        while i &lt; len(path_s) and i &lt; len(path_t) and path_s[i] == path_t[i]:\n            i += 1\n\n        UP = \"U\" * (len(path_s) - i)\n        DOWN = \"\".join(path_t[i:])\n        return UP + DOWN\n</code></pre>"},{"location":"EndlessCheng/binary_tree_lowest_common_ancestor/#1740-find-distance-in-a-binary-tree","title":"1740. Find Distance in a Binary Tree \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\n\n\nclass Solution:\n    def findDistance(self, root: Optional[TreeNode], p: int, q: int) -&gt; int:\n        LCA = self.find_LCA(root, p, q)  # Least Common Ancestor\n\n        p_dep = self.dfs(LCA, p)\n        q_dep = self.dfs(LCA, q)\n        return p_dep + q_dep\n\n    def dfs(self, root: TreeNode, target: int) -&gt; int:\n        \"\"\"Depth of target node from node\"\"\"\n        if not root:\n            return -1\n        if root.val == target:\n            return 0\n        L = self.dfs(root.left, target)\n        R = self.dfs(root.right, target)\n\n        if L == -1 and R == -1:\n            return -1\n        return max(L, R) + 1\n\n    def find_LCA(self, root: TreeNode, p: int, q: int) -&gt; TreeNode:\n        if not root or root.val == p or root.val == q:\n            return root\n        L = self.find_LCA(root.left, p, q)\n        R = self.find_LCA(root.right, p, q)\n        if L and R:\n            return root\n        elif L and not R:\n            return L\n        elif not L and R:\n            return R\n        else:\n            return None\n</code></pre>"},{"location":"EndlessCheng/binary_tree_lowest_common_ancestor/#1644-lowest-common-ancestor-of-a-binary-tree-ii","title":"1644. Lowest Common Ancestor of a Binary Tree II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_lowest_common_ancestor/#1650-lowest-common-ancestor-of-a-binary-tree-iii","title":"1650. Lowest Common Ancestor of a Binary Tree III \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Two Pointers, Tree, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_lowest_common_ancestor/#1676-lowest-common-ancestor-of-a-binary-tree-iv","title":"1676. Lowest Common Ancestor of a Binary Tree IV \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_others/","title":"Binary Tree Others","text":""},{"location":"EndlessCheng/binary_tree_others/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 297. Serialize and Deserialize Binary Tree (Hard)</li> <li> 449. Serialize and Deserialize BST (Medium)</li> <li> 652. Find Duplicate Subtrees (Medium)</li> <li> 173. Binary Search Tree Iterator (Medium)</li> <li> 1261. Find Elements in a Contaminated Binary Tree (Medium)</li> <li> 1104. Path In Zigzag Labelled Binary Tree (Medium)</li> <li> 987. Vertical Order Traversal of a Binary Tree (Hard)</li> <li> 655. Print Binary Tree (Medium)</li> <li> 979. Distribute Coins in Binary Tree (Medium)</li> <li> 222. Count Complete Tree Nodes (Easy)</li> <li> 2049. Count Nodes With the Highest Score (Medium)</li> <li> 2673. Make Costs of Paths Equal in a Binary Tree (Medium)</li> <li> 2509. Cycle Length Queries in a Tree (Hard)</li> <li> 2458. Height of Binary Tree After Subtree Removal Queries (Hard)</li> <li> 314. Binary Tree Vertical Order Traversal (Medium) \ud83d\udc51</li> <li> 666. Path Sum IV (Medium) \ud83d\udc51</li> <li> 1586. Binary Search Tree Iterator II (Medium) \ud83d\udc51</li> <li> 2773. Height of Special Binary Tree (Medium) \ud83d\udc51</li> <li> 1485. Clone Binary Tree With Random Pointer (Medium) \ud83d\udc51</li> <li> 2445. Number of Nodes With Value One (Medium) \ud83d\udc51</li> <li> 431. Encode N-ary Tree to Binary Tree (Hard) \ud83d\udc51</li> <li> 2005. Subtree Removal Game with Fibonacci Tree (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/binary_tree_others/#297-serialize-and-deserialize-binary-tree","title":"297. Serialize and Deserialize Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Tree, Depth First Search, Breadth First Search, Design, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BFS\nclass BFS:\n    def serialize(self, root: Optional[TreeNode]) -&gt; str:\n        if not root:\n            return \"\"\n\n        res = []\n        q = deque([root])\n\n        while q:\n            node = q.popleft()\n\n            if node:\n                res.append(str(node.val))\n                q.append(node.left)\n                q.append(node.right)\n            else:\n                res.append(\"null\")\n\n        return \",\".join(res)\n\n    def deserialize(self, data: str) -&gt; Optional[TreeNode]:\n        if not data:\n            return None\n\n        nodes = data.split(\",\")\n        root = TreeNode(int(nodes[0]))\n        q = deque([root])\n        index = 1\n\n        while q:\n            node = q.popleft()\n\n            if nodes[index] != \"null\":\n                node.left = TreeNode(int(nodes[index]))\n                q.append(node.left)\n            index += 1\n\n            if nodes[index] != \"null\":\n                node.right = TreeNode(int(nodes[index]))\n                q.append(node.right)\n            index += 1\n\n        return root\n\n\n# DFS\nclass DFS:\n    def serialize(self, root: Optional[TreeNode]) -&gt; str:\n        def dfs(node):\n            if not node:\n                return [\"null\"]\n            return [str(node.val)] + dfs(node.left) + dfs(node.right)\n\n        return \",\".join(dfs(root))\n\n    def deserialize(self, data: str) -&gt; Optional[TreeNode]:\n        nodes = data.split(\",\")\n        self.index = 0\n\n        def dfs():\n            if nodes[self.index] == \"null\":\n                self.index += 1\n                return None\n\n            node = TreeNode(int(nodes[self.index]))\n            self.index += 1\n\n            node.left = dfs()\n            node.right = dfs()\n\n            return node\n\n        root = dfs()\n        return root\n\n\nroot = build([1, 2, 3, None, None, 4, 5])\nprint(root)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n\nbfs = BFS()\ndata1 = bfs.serialize(root)\nprint(data1)  # \"1,2,3,null,null,4,5,null,null,null,null\"\nroot1 = bfs.deserialize(data1)\nprint(root1)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n\ndfs = DFS()\ndata2 = dfs.serialize(root)\nprint(data2)  # \"1,2,null,null,3,4,null,null,5,null,null\"\nroot2 = dfs.deserialize(data2)\nprint(root2)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n</code></pre>"},{"location":"EndlessCheng/binary_tree_others/#449-serialize-and-deserialize-bst","title":"449. Serialize and Deserialize BST","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Tree, Depth First Search, Breadth First Search, Design, Binary Search Tree, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_others/#652-find-duplicate-subtrees","title":"652. Find Duplicate Subtrees","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_others/#173-binary-search-tree-iterator","title":"173. Binary Search Tree Iterator","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Stack, Tree, Design, Binary Search Tree, Binary Tree, Iterator</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BST\nclass BSTIterator:\n\n    def __init__(self, root: Optional[TreeNode]):\n        self.stack = []\n        self._leftmost_inorder(root)\n\n    def _leftmost_inorder(self, root):\n        while root:\n            self.stack.append(root)\n            root = root.left\n\n    def next(self) -&gt; int:\n        topmost_node = self.stack.pop()\n\n        if topmost_node.right:\n            self._leftmost_inorder(topmost_node.right)\n\n        return topmost_node.val\n\n    def hasNext(self) -&gt; bool:\n        return len(self.stack) &gt; 0\n\n\nroot = build([7, 3, 15, None, None, 9, 20])\nprint(root)\n#   7__\n#  /   \\\n# 3     15\n#      /  \\\n#     9    20\nobj = BSTIterator(root)\nprint(obj.next())  # 3\nprint(obj.next())  # 7\nprint(obj.hasNext())  # True\n</code></pre>"},{"location":"EndlessCheng/binary_tree_others/#1261-find-elements-in-a-contaminated-binary-tree","title":"1261. Find Elements in a Contaminated Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Tree, Depth First Search, Breadth First Search, Design, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_others/#1104-path-in-zigzag-labelled-binary-tree","title":"1104. Path In Zigzag Labelled Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Tree, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_others/#987-vertical-order-traversal-of-a-binary-tree","title":"987. Vertical Order Traversal of a Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Tree, Depth First Search, Breadth First Search, Sorting, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_others/#655-print-binary-tree","title":"655. Print Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_others/#979-distribute-coins-in-binary-tree","title":"979. Distribute Coins in Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_others/#222-count-complete-tree-nodes","title":"222. Count Complete Tree Nodes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Binary Search, Bit Manipulation, Tree, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef countNodesRecursive(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    num = 1 + countNodesRecursive(root.left) + countNodesRecursive(root.right)\n\n    return num\n\n\n# Iterative\ndef countNodesIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n    count = 0\n\n    while q:\n        n = len(q)\n\n        for _ in range(n):\n            node = q.popleft()\n            count += 1\n\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return count\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Recursive  |  O(n)  |  O(n)   |\n# | Iterative  |  O(n)  |  O(n)   |\n# |------------|--------|---------|\n\nroot = [1, 2, 3, 4, 5, 6]\nroot = build(root)\nprint(root)\n#     __1__\n#    /     \\\n#   2       3\n#  / \\     /\n# 4   5   6\nprint(countNodesRecursive(root))  # 6\nprint(countNodesIterative(root))  # 6\n</code></pre>"},{"location":"EndlessCheng/binary_tree_others/#2049-count-nodes-with-the-highest-score","title":"2049. Count Nodes With the Highest Score","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_others/#2673-make-costs-of-paths-equal-in-a-binary-tree","title":"2673. Make Costs of Paths Equal in a Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy, Tree, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_others/#2509-cycle-length-queries-in-a-tree","title":"2509. Cycle Length Queries in a Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Tree, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_others/#2458-height-of-binary-tree-after-subtree-removal-queries","title":"2458. Height of Binary Tree After Subtree Removal Queries","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_others/#314-binary-tree-vertical-order-traversal","title":"314. Binary Tree Vertical Order Traversal \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Tree, Depth First Search, Breadth First Search, Sorting, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_others/#666-path-sum-iv","title":"666. Path Sum IV \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_others/#1586-binary-search-tree-iterator-ii","title":"1586. Binary Search Tree Iterator II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Stack, Tree, Design, Binary Search Tree, Binary Tree, Iterator</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BST\nclass BSTIterator:\n    def __init__(self, root: Optional[TreeNode]):\n        self.nodes = self._inorder(root)\n        self.index = -1\n        self.size = len(self.nodes)\n\n    def _inorder(self, node):\n        if not node:\n            return []\n        return self._inorder(node.left) + [node.val] + self._inorder(node.right)\n\n    def hasNext(self) -&gt; bool:\n        return self.index &lt; self.size - 1\n\n    def next(self) -&gt; int:\n        self.index += 1\n        return self.nodes[min(self.index, self.size - 1)]\n\n    def hasPrev(self) -&gt; bool:\n        return self.index &gt; 0\n\n    def prev(self) -&gt; int:\n        self.index -= 1\n        return self.nodes[max(self.index, 0)]\n\n\nroot = build([7, 3, 15, None, None, 9, 20])\nprint(root)\n#   7__\n#  /   \\\n# 3     15\n#      /  \\\n#     9    20\nobj = BSTIterator(root)\nprint(obj.next())  # 3\nprint(obj.next())  # 7\nprint(obj.hasNext())  # True\nprint(obj.prev())  # 3\nprint(obj.prev())  # None\n</code></pre>"},{"location":"EndlessCheng/binary_tree_others/#2773-height-of-special-binary-tree","title":"2773. Height of Special Binary Tree \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_others/#1485-clone-binary-tree-with-random-pointer","title":"1485. Clone Binary Tree With Random Pointer \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_others/#2445-number-of-nodes-with-value-one","title":"2445. Number of Nodes With Value One \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_others/#431-encode-n-ary-tree-to-binary-tree","title":"431. Encode N-ary Tree to Binary Tree \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Design, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_others/#2005-subtree-removal-game-with-fibonacci-tree","title":"2005. Subtree Removal Game with Fibonacci Tree \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Tree, Binary Tree, Game Theory</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_recursion/","title":"Binary Tree Recursion","text":""},{"location":"EndlessCheng/binary_tree_recursion/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 538. Convert BST to Greater Tree (Medium)</li> <li> 1038. Binary Search Tree to Greater Sum Tree (Medium)</li> <li> 865. Smallest Subtree with all the Deepest Nodes (Medium)</li> <li> 1080. Insufficient Nodes in Root to Leaf Paths (Medium)</li> </ul>"},{"location":"EndlessCheng/binary_tree_recursion/#538-convert-bst-to-greater-tree","title":"538. Convert BST to Greater Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Search Tree, Binary Tree</p> </li> </ul> Python <pre><code>\"\"\"\n![538](https://assets.leetcode.com/uploads/2019/05/02/tree.png)\n\"\"\"\n\nfrom typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef convertBST(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    prev = 0\n\n    def dfs(node):\n        if not node:\n            return None\n        nonlocal prev\n\n        dfs(node.right)\n\n        node.val += prev\n        prev = node.val\n\n        dfs(node.left)\n\n    dfs(root)\n\n    return root\n\n\nroot = [4, 1, 6, 0, 2, 5, 7, None, None, None, 3, None, None, None, 8]\nroot = build(root)\nprint(root)\n#     ____4__\n#    /       \\\n#   1         6\n#  / \\       / \\\n# 0   2     5   7\n#      \\         \\\n#       3         8\ngreater_tree = convertBST(root)\nprint(greater_tree)\n#      _______30___\n#     /            \\\n#   _36            _21\n#  /   \\          /   \\\n# 36    35       26    15\n#         \\              \\\n#          33             8\n</code></pre>"},{"location":"EndlessCheng/binary_tree_recursion/#1038-binary-search-tree-to-greater-sum-tree","title":"1038. Binary Search Tree to Greater Sum Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Search Tree, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_recursion/#865-smallest-subtree-with-all-the-deepest-nodes","title":"865. Smallest Subtree with all the Deepest Nodes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_recursion/#1080-insufficient-nodes-in-root-to-leaf-paths","title":"1080. Insufficient Nodes in Root to Leaf Paths","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_top-down_dfs/","title":"Binary Tree Top-Down DFS","text":""},{"location":"EndlessCheng/binary_tree_top-down_dfs/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 104. Maximum Depth of Binary Tree (Easy)</li> <li> 111. Minimum Depth of Binary Tree (Easy)</li> <li> 112. Path Sum (Easy)</li> <li> 129. Sum Root to Leaf Numbers (Medium)</li> <li> 199. Binary Tree Right Side View (Medium)</li> <li> 1448. Count Good Nodes in Binary Tree (Medium)</li> <li> 1457. Pseudo-Palindromic Paths in a Binary Tree (Medium)</li> <li> 1315. Sum of Nodes with Even-Valued Grandparent (Medium)</li> <li> 988. Smallest String Starting From Leaf (Medium)</li> <li> 1026. Maximum Difference Between Node and Ancestor (Medium)</li> <li> 1022. Sum of Root To Leaf Binary Numbers (Easy)</li> <li> 623. Add One Row to Tree (Medium)</li> <li> 1372. Longest ZigZag Path in a Binary Tree (Medium)</li> <li> 971. Flip Binary Tree To Match Preorder Traversal (Medium)</li> <li> 2689. Extract Kth Character From The Rope Tree (Easy) \ud83d\udc51</li> <li> 298. Binary Tree Longest Consecutive Sequence (Medium) \ud83d\udc51</li> <li> 1430. Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree (Medium) \ud83d\udc51</li> <li> 545. Boundary of Binary Tree (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/binary_tree_top-down_dfs/#104-maximum-depth-of-binary-tree","title":"104. Maximum Depth of Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef maxDepthRecursive(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    left = maxDepthRecursive(root.left)\n    right = maxDepthRecursive(root.right)\n\n    return 1 + max(left, right)\n\n\n# DFS\ndef maxDepthDFS(root: Optional[TreeNode]) -&gt; int:\n    res = 0\n\n    def dfs(node, cnt):\n        if node is None:\n            return\n        cnt += 1\n        nonlocal res\n        res = max(res, cnt)\n\n        dfs(node.left, cnt)\n        dfs(node.right, cnt)\n\n    dfs(root, 0)\n\n    return res\n\n\n# Iterative\ndef maxDepthIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n    res = 0\n\n    while q:\n        res += 1\n        n = len(q)\n\n        for _ in range(n):\n            node = q.popleft()\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    root = [1, 2, 2, 3, 4, None, None, None, None, 5]\n    root = build(root)\n    print(root)\n    #     ____1\n    #    /     \\\n    #   2__     2\n    #  /   \\\n    # 3     4\n    #      /\n    #     5\n    assert maxDepthRecursive(root) == 4\n    assert maxDepthDFS(root) == 4\n    assert maxDepthIterative(root) == 4\n</code></pre>"},{"location":"EndlessCheng/binary_tree_top-down_dfs/#111-minimum-depth-of-binary-tree","title":"111. Minimum Depth of Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Iterative\ndef minDepthIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n    res = 0\n\n    while q:\n        res += 1\n\n        for _ in range(len(q)):\n            node = q.popleft()\n\n            if not node.left and not node.right:\n                return res\n\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n\n# Recursive\ndef minDepthRecursive(root: Optional[TreeNode]) -&gt; int:\n    if root is None:\n        return 0\n\n    if root.left is None and root.right is not None:\n        return 1 + minDepthRecursive(root.right)\n    if root.left is not None and root.right is None:\n        return 1 + minDepthRecursive(root.left)\n\n    return 1 + min(minDepthRecursive(root.left), minDepthRecursive(root.right))\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n\"\"\"\n    ____1\n   /     \\\n  2__     2\n /   \\\n3     4\n     /\n    5\n\n\"\"\"\nprint(minDepthIterative(root))  # 2\nprint(minDepthRecursive(root))  # 2\n</code></pre>"},{"location":"EndlessCheng/binary_tree_top-down_dfs/#112-path-sum","title":"112. Path Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef hasPathSum(root: Optional[TreeNode], targetSum: int) -&gt; bool:\n    if not root:\n        return False\n\n    if not root.left and not root.right:\n        return root.val == targetSum\n\n    targetSum -= root.val\n\n    return hasPathSum(root.left, targetSum) or hasPathSum(root.right, targetSum)\n\n\nroot = build([5, 4, 8, 11, None, 13, 4, 7, 2, None, None, None, None, None, 1])\nprint(root)\n#          5___\n#         /    \\\n#     ___4     _8\n#    /        /  \\\n#   11       13   4\n#  /  \\            \\\n# 7    2            1\nprint(hasPathSum(root, 22))  # True\n</code></pre>"},{"location":"EndlessCheng/binary_tree_top-down_dfs/#129-sum-root-to-leaf-numbers","title":"129. Sum Root to Leaf Numbers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\nclass sumNumbers:\n    def dfs(self, root: Optional[TreeNode]) -&gt; int:\n        self.res = 0\n\n        def dfs(node, cur):\n            if not node:\n                return\n\n            cur = cur * 10 + node.val\n\n            if not node.left and not node.right:\n                self.res += cur\n                return\n\n            dfs(node.left, cur)\n            dfs(node.right, cur)\n\n        dfs(root, 0)\n\n        return self.res\n\n\nif __name__ == \"__main__\":\n    root = [1, 2, 3]\n    root = build(root)\n    print(root)\n    #   1\n    #  / \\\n    # 2   3\n    assert sumNumbers().dfs(root) == 25\n</code></pre>"},{"location":"EndlessCheng/binary_tree_top-down_dfs/#199-binary-tree-right-side-view","title":"199. Binary Tree Right Side View","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Binary Tree BFS\ndef rightSideViewBFS(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        n = len(q)\n        for i in range(n):\n            node = q.popleft()\n            if i == n - 1:\n                res.append(node.val)\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return res\n\n\n# Binary Tree DFS\ndef rightSideViewDFS(root: Optional[TreeNode]) -&gt; List[int]:\n    \"\"\"\u540e\u5e8f\u904d\u5386\uff0c\u5148\u53f3\u540e\u5de6\uff0c\u9047\u5230\u7684\u7b2c\u4e00\u4e2a\u8282\u70b9\u5c31\u662f\u8be5\u6df1\u5ea6\u7684\u6700\u53f3\u4fa7\u8282\u70b9\"\"\"\n    ans = []\n\n    def dfs(node, depth):\n        if node is None:\n            return\n        if depth == len(ans):  # \u8fd9\u4e2a\u6df1\u5ea6\u9996\u6b21\u9047\u5230\n            ans.append(node.val)\n\n        dfs(node.right, depth + 1)\n        dfs(node.left, depth + 1)\n\n    dfs(root, 0)\n\n    return ans\n\n\nif __name__ == \"__main__\":\n    root = [1, 2, 2, 3, 4, None, 3, None, None, 5]\n    root = build(root)\n    print(root)\n    #     ____1\n    #    /     \\\n    #   2__     2\n    #  /   \\     \\\n    # 3     4     3\n    #      /\n    #     5\n    assert rightSideViewBFS(root) == [1, 2, 3, 5]\n    assert rightSideViewDFS(root) == [1, 2, 3, 5]\n</code></pre>"},{"location":"EndlessCheng/binary_tree_top-down_dfs/#1448-count-good-nodes-in-binary-tree","title":"1448. Count Good Nodes in Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import List\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Tree\ndef goodNodes(root: TreeNode) -&gt; int:\n    def dfs(node, max_val):\n        if not node:\n            return 0\n\n        good = 1 if node.val &gt;= max_val else 0\n\n        max_val = max(max_val, node.val)\n\n        good += dfs(node.left, max_val)\n        good += dfs(node.right, max_val)\n\n        return good\n\n    return dfs(root, root.val)\n\n\nroot = build([3, 1, 4, 3, None, 1, 5])\nprint(root)\n#     3__\n#    /   \\\n#   1     4\n#  /     / \\\n# 3     1   5\nprint(goodNodes(root))  # 4\n</code></pre>"},{"location":"EndlessCheng/binary_tree_top-down_dfs/#1457-pseudo-palindromic-paths-in-a-binary-tree","title":"1457. Pseudo-Palindromic Paths in a Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Bit Manipulation, Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_top-down_dfs/#1315-sum-of-nodes-with-even-valued-grandparent","title":"1315. Sum of Nodes with Even-Valued Grandparent","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_top-down_dfs/#988-smallest-string-starting-from-leaf","title":"988. Smallest String Starting From Leaf","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Backtracking, Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_top-down_dfs/#1026-maximum-difference-between-node-and-ancestor","title":"1026. Maximum Difference Between Node and Ancestor","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_top-down_dfs/#1022-sum-of-root-to-leaf-binary-numbers","title":"1022. Sum of Root To Leaf Binary Numbers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_top-down_dfs/#623-add-one-row-to-tree","title":"623. Add One Row to Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BFS\ndef addOneRow_bfs(root: Optional[TreeNode], val: int, depth: int) -&gt; Optional[TreeNode]:\n    if not root:\n        return None\n\n    if depth == 1:\n        new = TreeNode(val)\n        new.left = root\n        return new\n\n    q = deque([root])\n    cur = 1\n\n    while q:\n        size = len(q)\n        for _ in range(size):\n            node = q.popleft()\n\n            if cur == depth - 1:\n                old_left, old_right = node.left, node.right\n                node.left, node.right = TreeNode(val), TreeNode(val)\n                node.left.left = old_left\n                node.right.right = old_right\n            else:\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n        cur += 1\n\n    return root\n\n\n# DFS\ndef addOneRow_dfs(root: Optional[TreeNode], val: int, depth: int) -&gt; Optional[TreeNode]:\n    if depth == 1:\n        new = TreeNode(val)\n        new.left = root\n        return new\n\n    def dfs(node, cur):\n        if not node:\n            return\n        if cur == depth - 1:\n            old_left, old_right = node.left, node.right\n            node.left = TreeNode(val, old_left, None)\n            node.right = TreeNode(val, None, old_right)\n        else:\n            dfs(node.left, cur + 1)\n            dfs(node.right, cur + 1)\n\n    dfs(root, 1)\n\n    return root\n\n\nif __name__ == \"__main__\":\n    root = build([4, 2, 6, 3, 1, 5])\n    print(root)\n    #     __4__\n    #    /     \\\n    #   2       6\n    #  / \\     /\n    # 3   1   5\n    print(addOneRow_bfs(deepcopy(root), 1, 2))\n    #         4\n    #        / \\\n    #     __1   1__\n    #    /         \\\n    #   2           6\n    #  / \\         /\n    # 3   1       5\n    print(addOneRow_dfs(deepcopy(root), 1, 2))\n    #         4\n    #        / \\\n    #     __1   1__\n    #    /         \\\n    #   2           6\n    #  / \\         /\n    # 3   1       5\n</code></pre>"},{"location":"EndlessCheng/binary_tree_top-down_dfs/#1372-longest-zigzag-path-in-a-binary-tree","title":"1372. Longest ZigZag Path in a Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_top-down_dfs/#971-flip-binary-tree-to-match-preorder-traversal","title":"971. Flip Binary Tree To Match Preorder Traversal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_top-down_dfs/#2689-extract-kth-character-from-the-rope-tree","title":"2689. Extract Kth Character From The Rope Tree \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_top-down_dfs/#298-binary-tree-longest-consecutive-sequence","title":"298. Binary Tree Longest Consecutive Sequence \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Binary Tree\ndef longestConsecutive(root: Optional[TreeNode]) -&gt; int:\n    res = 0\n\n    def dfs(node):\n        if not node:\n            return 0\n\n        left, right = dfs(node.left), dfs(node.right)\n        cur = 1\n        if node.left and node.left.val == (node.val + 1):\n            cur = max(cur, left + 1)\n        if node.right and node.right.val == (node.val + 1):\n            cur = max(cur, right + 1)\n\n        nonlocal res\n        res = max(res, cur)\n        return cur\n\n    dfs(root)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    root = build([1, 3, 2, 4, None, None, None, 5])\n    print(root)\n    #       1\n    #      / \\\n    #     3   2\n    #    /\n    #   4\n    #  /\n    # 5\n    print(longestConsecutive(root))  # 3\n</code></pre>"},{"location":"EndlessCheng/binary_tree_top-down_dfs/#1430-check-if-a-string-is-a-valid-sequence-from-root-to-leaves-path-in-a-binary-tree","title":"1430. Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_top-down_dfs/#545-boundary-of-binary-tree","title":"545. Boundary of Binary Tree \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_traversal/","title":"Binary Tree Traversal","text":""},{"location":"EndlessCheng/binary_tree_traversal/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 144. Binary Tree Preorder Traversal (Easy)</li> <li> 94. Binary Tree Inorder Traversal (Easy)</li> <li> 145. Binary Tree Postorder Traversal (Easy)</li> <li> 872. Leaf-Similar Trees (Easy)</li> <li> 404. Sum of Left Leaves (Easy)</li> <li> 671. Second Minimum Node In a Binary Tree (Easy)</li> <li> 1469. Find All The Lonely Nodes (Easy) \ud83d\udc51</li> <li> 1214. Two Sum BSTs (Medium) \ud83d\udc51</li> <li> 2764. Is Array a Preorder of Some \u200cBinary Tree (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/binary_tree_traversal/#144-binary-tree-preorder-traversal","title":"144. Binary Tree Preorder Traversal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Stack, Tree, Depth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\nclass PreorderTraversal:\n    def recursive(self, root: Optional[TreeNode]) -&gt; List[int]:\n        res = []\n\n        def dfs(node):\n            if not node:\n                return None\n\n            res.append(node.val)  # &lt;--\n            dfs(node.left)\n            dfs(node.right)\n\n        dfs(root)\n\n        return res\n\n    def iterative(self, root: Optional[TreeNode]) -&gt; List[int]:\n        if not root:\n            return []\n\n        stack = [root]\n        res = []\n\n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n\n        return res\n\n\nif __name__ == \"__main__\":\n    tree = build([0, 1, 2, 3, 4, 5, 6])\n    print(tree)\n    #     __0__\n    #    /     \\\n    #   1       2\n    #  / \\     / \\\n    # 3   4   5   6\n    sol = PreorderTraversal()\n    assert sol.recursive(tree) == [0, 1, 3, 4, 2, 5, 6]\n    assert sol.iterative(tree) == [0, 1, 3, 4, 2, 5, 6]\n</code></pre>"},{"location":"EndlessCheng/binary_tree_traversal/#94-binary-tree-inorder-traversal","title":"94. Binary Tree Inorder Traversal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Stack, Tree, Depth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef inorderTraversalRecursive(root: TreeNode) -&gt; List[int]:\n    res = []\n\n    def dfs(node):\n        if not node:\n            return\n\n        dfs(node.left)\n        res.append(node.val)  # &lt;--\n        dfs(node.right)\n\n    dfs(root)\n\n    return res\n\n\n# Iterative\ndef inorderTraversalIterative(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    stack = []\n    res = []\n    cur = root\n\n    while cur or stack:\n        if cur:\n            stack.append(cur)\n            cur = cur.left\n        else:\n            cur = stack.pop()\n            res.append(cur.val)\n            cur = cur.right\n\n    return res\n\n\ntree = build([0, 1, 2, 3, 4, 5, 6])\nprint(tree)\n#     __0__\n#    /     \\\n#   1       2\n#  / \\     / \\\n# 3   4   5   6\nprint(inorderTraversalRecursive(tree))  # [3, 1, 4, 0, 5, 2, 6]\nprint(inorderTraversalIterative(tree))  # [3, 1, 4, 0, 5, 2, 6]\n</code></pre>"},{"location":"EndlessCheng/binary_tree_traversal/#145-binary-tree-postorder-traversal","title":"145. Binary Tree Postorder Traversal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Stack, Tree, Depth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef postorderTraversalRecursive(root: Optional[TreeNode]) -&gt; List[int]:\n    res = []\n\n    def dfs(node):\n        if not node:\n            return\n\n        dfs(node.left)\n        dfs(node.right)\n        res.append(node.val)  # &lt;--\n\n    dfs(root)\n\n    return res\n\n\n# Iterative\ndef postorderTraversalIterative(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    res = []\n    stack = [root]\n\n    while stack:\n        node = stack.pop()\n        res.append(node.val)\n\n        if node.left:\n            stack.append(node.left)\n        if node.right:\n            stack.append(node.right)\n\n    return res[::-1]\n\n\ntree = build([0, 1, 2, 3, 4, 5, 6])\nprint(tree)\n#     __0__\n#    /     \\\n#   1       2\n#  / \\     / \\\n# 3   4   5   6\nprint(postorderTraversalRecursive(tree))  # [3, 4, 1, 5, 6, 2, 0]\nprint(postorderTraversalIterative(tree))  # [3, 4, 1, 5, 6, 2, 0]\n</code></pre>"},{"location":"EndlessCheng/binary_tree_traversal/#872-leaf-similar-trees","title":"872. Leaf-Similar Trees","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Tree\ndef leafSimilar(root1: Optional[TreeNode], root2: Optional[TreeNode]) -&gt; bool:\n\n    def dfs(node, leaf):\n        if not node:\n            return\n        if not node.left and not node.right:\n            leaf.append(node.val)\n        dfs(node.left, leaf)\n        dfs(node.right, leaf)\n\n    leaf1, leaf2 = [], []\n    dfs(root1, leaf1)\n    dfs(root2, leaf2)\n\n    return leaf1 == leaf2\n\n\nroot1 = [3, 5, 1, 6, 2, 9, 8, None, None, 7, 4]\nroot2 = [3, 5, 1, 6, 7, 4, 2, None, None, None, None, None, None, 9, 8]\nroot1 = build(root1)\n\nroot2 = build(root2)\nprint(root1)\n#     ______3__\n#    /         \\\n#   5__         1\n#  /   \\       / \\\n# 6     2     9   8\n#      / \\\n#     7   4\nprint(root2)\n#     __3__\n#    /     \\\n#   5       1__\n#  / \\     /   \\\n# 6   7   4     2\n#              / \\\n#             9   8\nprint(leafSimilar(root1, root2))  # True\n</code></pre>"},{"location":"EndlessCheng/binary_tree_traversal/#404-sum-of-left-leaves","title":"404. Sum of Left Leaves","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Iterative\ndef sumOfLeftLeaves(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    stack = [root]\n    sumLL = 0\n\n    while stack:\n        node = stack.pop()\n\n        if node.left and not node.left.left and not node.left.right:\n            sumLL += node.left.val\n\n        if node.right:\n            stack.append(node.right)\n        if node.left:\n            stack.append(node.left)\n\n    return sumLL\n\n\n# Left Leave None:\n#   - node.left is not None\n#   - node.left.left is None\n#   - node.left.right is None\n\nroot = build([3, 9, 20, None, None, 15, 7])\nprint(root)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(sumOfLeftLeaves(root))  # 24\n</code></pre>"},{"location":"EndlessCheng/binary_tree_traversal/#671-second-minimum-node-in-a-binary-tree","title":"671. Second Minimum Node In a Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_traversal/#1469-find-all-the-lonely-nodes","title":"1469. Find All The Lonely Nodes \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Binary Tree Traversal\ndef getLonelyNodes(root: Optional[TreeNode]) -&gt; List[int]:\n    res = []\n\n    def dfs(node):\n        if not node:\n            return False\n\n        left = dfs(node.left)\n        right = dfs(node.right)\n        if left and not right:\n            res.append(node.left.val)\n        if not left and right:\n            res.append(node.right.val)\n\n        return True\n\n    dfs(root)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    root = build([1, 2, 3, None, 4])\n    print(root)\n    #    __1\n    #  /   \\\n    # 2     3\n    #  \\\n    #   4\n    assert getLonelyNodes(root) == [4]\n\n    root = build([7, 1, 4, 6, None, 5, 3, None, None, None, None, None, 2])\n    print(root)\n    #     7____\n    #    /     \\\n    #   1     __4\n    #  /     /   \\\n    # 6     5     3\n    #        \\\n    #         2\n    assert getLonelyNodes(root) == [6, 2]\n</code></pre>"},{"location":"EndlessCheng/binary_tree_traversal/#1214-two-sum-bsts","title":"1214. Two Sum BSTs \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, Binary Search, Stack, Tree, Depth First Search, Binary Search Tree, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/binary_tree_traversal/#2764-is-array-a-preorder-of-some-binary-tree","title":"2764. Is Array a Preorder of Some \u200cBinary Tree \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Stack, Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/bipartite_graph_coloring/","title":"Bipartite Graph Coloring","text":""},{"location":"EndlessCheng/bipartite_graph_coloring/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 785. Is Graph Bipartite? (Medium)</li> <li> 886. Possible Bipartition (Medium)</li> </ul>"},{"location":"EndlessCheng/bipartite_graph_coloring/#785-is-graph-bipartite","title":"785. Is Graph Bipartite?","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Union Find, Graph</p> </li> </ul> Python <pre><code>\"\"\"\n-   Determine if a graph is bipartite.\n\nHow to group\n\n|          | Uncolored | Color 1 | Color 2 | Operation   |\n| -------- | --------- | ------- | ------- | ----------- |\n| Method 1 | -1        | 0       | 1       | `1 - color` |\n| Method 2 | 0         | 1       | -1      | `-color`    |\n\"\"\"\n\nfrom collections import deque\nfrom typing import List\n\n\n# BFS\ndef isBipartiteBFS(graph: List[List[int]]) -&gt; bool:\n    n = len(graph)\n    # -1: not colored; 0: blue; 1: red\n    color = [-1 for _ in range(n)]\n\n    def bfs(node):\n        q = deque([node])\n        color[node] = 0\n\n        while q:\n            cur = q.popleft()\n\n            for neighbor in graph[cur]:\n                if color[neighbor] == -1:\n                    color[neighbor] = 1 - color[cur]\n                    q.append(neighbor)\n                elif color[neighbor] == color[cur]:\n                    return False\n        return True\n\n    for i in range(n):\n        if color[i] == -1:\n            if not bfs(i):\n                return False\n\n    return True\n\n\n# DFS\ndef isBipartiteDFS(graph: List[List[int]]) -&gt; bool:\n    n = len(graph)\n    # -1: not colored; 0: blue; 1: red\n    color = [-1] * n\n\n    def dfs(node, c):\n        color[node] = c\n        for neighbor in graph[node]:\n            if color[neighbor] == -1:\n                if not dfs(neighbor, 1 - c):\n                    return False\n            elif color[neighbor] == c:\n                return False\n        return True\n\n    for i in range(n):\n        if color[i] == -1:\n            if not dfs(i, 0):\n                return False\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |    BFS     | O(V+E) |  O(V)   |\n# |    DFS     | O(V+E) |  O(V)   |\n# |------------|--------|---------|\n\n\ngraph = [[1, 2, 3], [0, 2], [0, 1, 3], [0, 2]]\nprint(isBipartiteBFS(graph))  # False\nprint(isBipartiteDFS(graph))  # False\n</code></pre>"},{"location":"EndlessCheng/bipartite_graph_coloring/#886-possible-bipartition","title":"886. Possible Bipartition","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Union Find, Graph</p> </li> </ul> Python <pre><code>\"\"\"\n-   Determine if a graph can be divided into two groups such that no two nodes of the same group are connected.\n\"\"\"\n\nfrom collections import deque\nfrom typing import List\n\n\n# BFS\ndef possibleBipartitionBFS(n: int, dislikes: List[List[int]]) -&gt; bool:\n    group = {i: -1 for i in range(1, n + 1)}\n\n    # Undirected graph\n    graph = {i: [] for i in range(1, n + 1)}\n    for i, j in dislikes:\n        graph[i].append(j)\n        graph[j].append(i)\n\n    def bfs(person):\n        q = deque([person])\n        group[person] = 0\n\n        while q:\n            cur = q.popleft()\n\n            for neighbor in graph[cur]:\n                if group[neighbor] == -1:\n                    group[neighbor] = 1 - group[cur]\n                    q.append(neighbor)\n                elif group[neighbor] == group[cur]:\n                    return False\n        return True\n\n    for i in range(1, n + 1):\n        if group[i] == -1:\n            if not bfs(i):\n                return False\n    return True\n\n\n# DFS\ndef possibleBipartitionDFS(n: int, dislikes: List[List[int]]) -&gt; bool:\n    group = {i: -1 for i in range(1, n + 1)}\n    graph = {i: [] for i in range(1, n + 1)}\n    for i, j in dislikes:\n        graph[i].append(j)\n        graph[j].append(i)\n\n    def dfs(person, g):\n        group[person] = g\n\n        for neighbor in graph[person]:\n            if group[neighbor] == -1:\n                if not dfs(neighbor, 1 - g):\n                    return False\n            elif group[neighbor] == g:\n                return False\n\n        return True\n\n    for i in range(1, n + 1):\n        if group[i] == -1:\n            if not dfs(i, 0):\n                return False\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |    BFS     | O(V+E) |  O(V+E) |\n# |    DFS     | O(V+E) |  O(V+E) |\n# |------------|--------|---------|\n\n\nn = 4\ndislikes = [[1, 2], [1, 3], [2, 4]]\nprint(possibleBipartitionBFS(n, dislikes))  # True\nprint(possibleBipartitionDFS(n, dislikes))  # True\n</code></pre>"},{"location":"EndlessCheng/bit_and_or/","title":"Bit AND OR","text":""},{"location":"EndlessCheng/bit_and_or/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2980. Check if Bitwise OR Has Trailing Zeros (Easy)</li> <li> 1318. Minimum Flips to Make a OR b Equal to c (Medium)</li> <li> 2419. Longest Subarray With Maximum Bitwise AND (Medium)</li> <li> 2871. Split Array Into Maximum Number of Subarrays (Medium)</li> <li> 2401. Longest Nice Subarray (Medium)</li> <li> 2680. Maximum OR (Medium)</li> <li> 3133. Minimum Array End (Medium)</li> <li> 3108. Minimum Cost Walk in Weighted Graph (Hard)</li> <li> 3117. Minimum Sum of Values by Dividing Array (Hard)</li> <li> 3125. Maximum Number That Makes Result of Bitwise AND Zero (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/bit_and_or/#2980-check-if-bitwise-or-has-trailing-zeros","title":"2980. Check if Bitwise OR Has Trailing Zeros","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_and_or/#1318-minimum-flips-to-make-a-or-b-equal-to-c","title":"1318. Minimum Flips to Make a OR b Equal to c","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_and_or/#2419-longest-subarray-with-maximum-bitwise-and","title":"2419. Longest Subarray With Maximum Bitwise AND","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation, Brainteaser</p> </li> </ul>"},{"location":"EndlessCheng/bit_and_or/#2871-split-array-into-maximum-number-of-subarrays","title":"2871. Split Array Into Maximum Number of Subarrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_and_or/#2401-longest-nice-subarray","title":"2401. Longest Nice Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/bit_and_or/#2680-maximum-or","title":"2680. Maximum OR","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Bit Manipulation, Prefix Sum</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Greedy\ndef maximumOr(nums: List[int], k: int) -&gt; int:\n    \"\"\"Maximum OR of Array After k Operations\n\n    Args:\n        nums (List[int]): provided list of integers\n        k (int): number of operations\n\n    Returns:\n        int: maximum OR of array after k operations\n    \"\"\"\n    n = len(nums)\n    suffix = [0 for _ in range(n)]\n\n    for i in range(n - 2, -1, -1):\n        suffix[i] = suffix[i + 1] | nums[i + 1]\n\n    res, pre = 0, 0\n    for num, suf in zip(nums, suffix):\n        res = max(res, pre | (num &lt;&lt; k) | suf)\n        pre |= num\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(maximumOr(nums=[8, 1, 2], k=2))  # 35\n</code></pre>"},{"location":"EndlessCheng/bit_and_or/#3133-minimum-array-end","title":"3133. Minimum Array End","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_and_or/#3108-minimum-cost-walk-in-weighted-graph","title":"3108. Minimum Cost Walk in Weighted Graph","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation, Union Find, Graph</p> </li> </ul>"},{"location":"EndlessCheng/bit_and_or/#3117-minimum-sum-of-values-by-dividing-array","title":"3117. Minimum Sum of Values by Dividing Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Dynamic Programming, Bit Manipulation, Segment Tree, Queue</p> </li> </ul>"},{"location":"EndlessCheng/bit_and_or/#3125-maximum-number-that-makes-result-of-bitwise-and-zero","title":"3125. Maximum Number That Makes Result of Bitwise AND Zero \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/bit_basics/","title":"Bit Basics","text":""},{"location":"EndlessCheng/bit_basics/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3370. Smallest Number With All Set Bits (Easy)</li> <li> 3226. Number of Bit Changes to Make Two Integers Equal (Easy)</li> <li> 1356. Sort Integers by The Number of 1 Bits (Easy)</li> <li> 461. Hamming Distance (Easy)</li> <li> 2220. Minimum Bit Flips to Convert Number (Easy)</li> <li> 476. Number Complement (Easy)</li> <li> 1009. Complement of Base 10 Integer (Easy)</li> <li> 868. Binary Gap (Easy)</li> <li> 3211. Generate Binary Strings Without Adjacent Zeros (Medium)</li> <li> 2917. Find the K-or of an Array (Easy)</li> <li> 693. Binary Number with Alternating Bits (Easy)</li> <li> 2657. Find the Prefix Common Array of Two Arrays (Medium)</li> <li> 231. Power of Two (Easy)</li> <li> 342. Power of Four (Easy)</li> <li> 191. Number of 1 Bits (Easy)</li> <li> 2595. Number of Even and Odd Bits (Easy)</li> <li> 338. Counting Bits (Easy)</li> </ul>"},{"location":"EndlessCheng/bit_basics/#3370-smallest-number-with-all-set-bits","title":"3370. Smallest Number With All Set Bits","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_basics/#3226-number-of-bit-changes-to-make-two-integers-equal","title":"3226. Number of Bit Changes to Make Two Integers Equal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_basics/#1356-sort-integers-by-the-number-of-1-bits","title":"1356. Sort Integers by The Number of 1 Bits","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation, Sorting, Counting</p> </li> </ul>"},{"location":"EndlessCheng/bit_basics/#461-hamming-distance","title":"461. Hamming Distance","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_basics/#2220-minimum-bit-flips-to-convert-number","title":"2220. Minimum Bit Flips to Convert Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_basics/#476-number-complement","title":"476. Number Complement","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_basics/#1009-complement-of-base-10-integer","title":"1009. Complement of Base 10 Integer","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_basics/#868-binary-gap","title":"868. Binary Gap","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_basics/#3211-generate-binary-strings-without-adjacent-zeros","title":"3211. Generate Binary Strings Without Adjacent Zeros","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Backtracking, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_basics/#2917-find-the-k-or-of-an-array","title":"2917. Find the K-or of an Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_basics/#693-binary-number-with-alternating-bits","title":"693. Binary Number with Alternating Bits","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_basics/#2657-find-the-prefix-common-array-of-two-arrays","title":"2657. Find the Prefix Common Array of Two Arrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_basics/#231-power-of-two","title":"231. Power of Two","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Bit Manipulation, Recursion</p> </li> </ul>"},{"location":"EndlessCheng/bit_basics/#342-power-of-four","title":"342. Power of Four","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Bit Manipulation, Recursion</p> </li> </ul>"},{"location":"EndlessCheng/bit_basics/#191-number-of-1-bits","title":"191. Number of 1 Bits","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Divide And Conquer, Bit Manipulation</p> </li> </ul> Python <pre><code># Bit Manipulation\ndef hammingWeight1(n: int) -&gt; int:\n    res = 0\n\n    while n != 0:\n        n = n &amp; (n - 1)  # Unset the rightmost 1-bit\n        res += 1\n\n    return res\n\n\ndef hammingWeight2(n: int) -&gt; int:\n    return bin(n).count(\"1\")\n\n\ndef hammingWeight3(n: int) -&gt; int:\n    def decimalToBinary(n: int) -&gt; str:\n        if n == 0:\n            return \"0\"\n\n        binary = \"\"\n        while n &gt; 0:\n            binary = str(n % 2) + binary\n            n //= 2\n\n        return binary\n\n    binary = decimalToBinary(n)\n\n    return binary.count(\"1\")\n\n\nn = 11\nprint(hammingWeight1(n))  # 3\nprint(hammingWeight2(n))  # 3\n\nn = 47\nprint(bin(n))\n</code></pre>"},{"location":"EndlessCheng/bit_basics/#2595-number-of-even-and-odd-bits","title":"2595. Number of Even and Odd Bits","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Bit Manipulation</p> </li> </ul> Python <pre><code>\"\"\"\n-   Topic: Bit Manipulation\n-   Difficulty: Easy\n\n&gt; You are given a positive integer n.\n&gt; Let even denote the number of even indices in the binary representation of n with value 1.\n&gt; Let odd denote the number of odd indices in the binary representation of n with value 1.\n&gt; Note that bits are indexed from right to left in the binary representation of a number.\n&gt; Return the array [even, odd].\n\"\"\"\n</code></pre>"},{"location":"EndlessCheng/bit_basics/#338-counting-bits","title":"338. Counting Bits","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Bit Manipulation</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Bit Manipulation\ndef countBits(n: int) -&gt; List[int]:\n    bits = [0 for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        bits[i] = bits[i &gt;&gt; 1] + (i &amp; 1)\n\n    return bits\n\n\nn = 5\nprint(countBits(n))  # [0, 1, 1, 2, 1, 2]\n</code></pre>"},{"location":"EndlessCheng/bit_contribution_method/","title":"Bit Contribution Method","text":""},{"location":"EndlessCheng/bit_contribution_method/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 477. Total Hamming Distance (Medium)</li> <li> 1863. Sum of All Subset XOR Totals (Easy)</li> <li> 2425. Bitwise XOR of All Pairings (Medium)</li> <li> 2275. Largest Combination With Bitwise AND Greater Than Zero (Medium)</li> <li> 1835. Find XOR Sum of All Pairs Bitwise AND (Hard)</li> <li> 2505. Bitwise OR of All Subsequence Sums (Medium) \ud83d\udc51</li> <li> 3153. Sum of Digit Differences of All Pairs (Medium)</li> </ul>"},{"location":"EndlessCheng/bit_contribution_method/#477-total-hamming-distance","title":"477. Total Hamming Distance","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_contribution_method/#1863-sum-of-all-subset-xor-totals","title":"1863. Sum of All Subset XOR Totals","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Backtracking, Bit Manipulation, Combinatorics, Enumeration</p> </li> </ul> Python <pre><code>from functools import reduce\nfrom operator import or_\nfrom typing import List\n\n\ndef subsetXORSum(nums: List[int]) -&gt; int:\n    return reduce(or_, nums) &lt;&lt; (len(nums) - 1)\n\n\nif __name__ == \"__main__\":\n    nums = [5, 1, 6]\n    print(subsetXORSum(nums))  # 28\n</code></pre>"},{"location":"EndlessCheng/bit_contribution_method/#2425-bitwise-xor-of-all-pairings","title":"2425. Bitwise XOR of All Pairings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation, Brainteaser</p> </li> </ul>"},{"location":"EndlessCheng/bit_contribution_method/#2275-largest-combination-with-bitwise-and-greater-than-zero","title":"2275. Largest Combination With Bitwise AND Greater Than Zero","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Bit Manipulation, Counting</p> </li> </ul>"},{"location":"EndlessCheng/bit_contribution_method/#1835-find-xor-sum-of-all-pairs-bitwise-and","title":"1835. Find XOR Sum of All Pairs Bitwise AND","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_contribution_method/#2505-bitwise-or-of-all-subsequence-sums","title":"2505. Bitwise OR of All Subsequence Sums \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Bit Manipulation, Brainteaser</p> </li> </ul>"},{"location":"EndlessCheng/bit_contribution_method/#3153-sum-of-digit-differences-of-all-pairs","title":"3153. Sum of Digit Differences of All Pairs","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Counting</p> </li> </ul>"},{"location":"EndlessCheng/bit_identity_law/","title":"Bit Identity Law","text":""},{"location":"EndlessCheng/bit_identity_law/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1835. Find XOR Sum of All Pairs Bitwise AND (Hard)</li> <li> 2354. Number of Excellent Pairs (Hard)</li> </ul>"},{"location":"EndlessCheng/bit_identity_law/#1835-find-xor-sum-of-all-pairs-bitwise-and","title":"1835. Find XOR Sum of All Pairs Bitwise AND","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_identity_law/#2354-number-of-excellent-pairs","title":"2354. Number of Excellent Pairs","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Binary Search, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_logtrick/","title":"Bit LogTrick","text":""},{"location":"EndlessCheng/bit_logtrick/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3097. Shortest Subarray With OR at Least K II (Medium)</li> <li> 2411. Smallest Subarrays With Maximum Bitwise OR (Medium)</li> <li> 3209. Number of Subarrays With AND Value of K (Hard)</li> <li> 3171. Find Subarray With Bitwise OR Closest to K (Hard)</li> <li> 1521. Find a Value of a Mysterious Function Closest to Target (Hard)</li> <li> 898. Bitwise ORs of Subarrays (Medium)</li> </ul>"},{"location":"EndlessCheng/bit_logtrick/#3097-shortest-subarray-with-or-at-least-k-ii","title":"3097. Shortest Subarray With OR at Least K II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/bit_logtrick/#2411-smallest-subarrays-with-maximum-bitwise-or","title":"2411. Smallest Subarrays With Maximum Bitwise OR","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Bit Manipulation, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/bit_logtrick/#3209-number-of-subarrays-with-and-value-of-k","title":"3209. Number of Subarrays With AND Value of K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Bit Manipulation, Segment Tree</p> </li> </ul>"},{"location":"EndlessCheng/bit_logtrick/#3171-find-subarray-with-bitwise-or-closest-to-k","title":"3171. Find Subarray With Bitwise OR Closest to K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Bit Manipulation, Segment Tree</p> </li> </ul>"},{"location":"EndlessCheng/bit_logtrick/#1521-find-a-value-of-a-mysterious-function-closest-to-target","title":"1521. Find a Value of a Mysterious Function Closest to Target","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Bit Manipulation, Segment Tree</p> </li> </ul>"},{"location":"EndlessCheng/bit_logtrick/#898-bitwise-ors-of-subarrays","title":"898. Bitwise ORs of Subarrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_others/","title":"Bit Others","text":""},{"location":"EndlessCheng/bit_others/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 136. Single Number (Easy)</li> <li> 287. Find the Duplicate Number (Medium)</li> <li> 260. Single Number III (Medium)</li> <li> 2965. Find Missing and Repeated Values (Easy)</li> <li> 137. Single Number II (Medium)</li> <li> 645. Set Mismatch (Easy)</li> <li> 190. Reverse Bits (Easy)</li> <li> 371. Sum of Two Integers (Medium)</li> <li> 201. Bitwise AND of Numbers Range (Medium)</li> <li> 2154. Keep Multiplying Found Values by Two (Easy)</li> <li> 2044. Count Number of Maximum Bitwise-OR Subsets (Medium)</li> <li> 2438. Range Product Queries of Powers (Medium)</li> <li> 1680. Concatenation of Consecutive Binary Numbers (Medium)</li> <li> 1261. Find Elements in a Contaminated Binary Tree (Medium)</li> <li> 89. Gray Code (Medium)</li> <li> 1238. Circular Permutation in Binary Representation (Medium)</li> <li> 982. Triples with Bitwise AND Equal To Zero (Hard)</li> <li> 3307. Find the K-th Character in String Game II (Hard)</li> <li> 1611. Minimum One Bit Operations to Make Integers Zero (Hard)</li> <li> 751. IP to CIDR (Medium) \ud83d\udc51</li> <li> 3141. Maximum Hamming Distances (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/bit_others/#136-single-number","title":"136. Single Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation</p> </li> </ul> Python <pre><code>from functools import reduce\nfrom operator import xor\nfrom typing import List\n\n\n# XOR\ndef singleNumber(nums: List[int]) -&gt; int:\n    res = 0\n    for num in nums:\n        res ^= num\n    return res\n\n\n# XOR\ndef singleNumberXOR(nums: List[int]) -&gt; int:\n    return reduce(xor, nums)\n\n\n# XOR\ndef singleNumberXORLambda(nums: List[int]) -&gt; int:\n    return reduce(lambda x, y: x ^ y, nums)\n\n\nnums = [4, 1, 2, 1, 2]\nprint(singleNumber(nums))  # 4\nprint(singleNumberXOR(nums))  # 4\nprint(singleNumberXORLambda(nums))  # 4\n</code></pre>"},{"location":"EndlessCheng/bit_others/#287-find-the-duplicate-number","title":"287. Find the Duplicate Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Bit Manipulation</p> </li> </ul> Python <pre><code>\"\"\"\n-   Find the duplicate number in an array containing `n + 1` integers where each integer is between `1` and `n` inclusive.\n-   Floyd's Tortoise and Hare (Cycle Detection)\n    -   141. Linked List Cycle\n    -   142. Linked List Cycle II\n-   Time Complexity: O(n)\n-   Space Complexity: O(1)\n\nExample: `nums = [1, 3, 4, 2, 2]`\n\n|  0   |  1   |  2   |  3   |  4   |\n| :--: | :--: | :--: | :--: | :--: |\n|  1   |  3   |  4   |  2   |  2   |\n\n\n\"\"\"\n\nfrom typing import List\n\n\n# Floyd Cycle Detection Algorithm\ndef findDuplicate(nums: List[int]) -&gt; int:\n    fast, slow = nums[0], nums[0]\n\n    while True:\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n        if slow == fast:\n            break\n\n    slow = nums[0]\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[fast]\n\n    return slow\n\n\nnums = [1, 3, 4, 2, 2]\nprint(findDuplicate(nums))  # 2\n</code></pre>"},{"location":"EndlessCheng/bit_others/#260-single-number-iii","title":"260. Single Number III","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_others/#2965-find-missing-and-repeated-values","title":"2965. Find Missing and Repeated Values","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/bit_others/#137-single-number-ii","title":"137. Single Number II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_others/#645-set-mismatch","title":"645. Set Mismatch","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Bit Manipulation, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/bit_others/#190-reverse-bits","title":"190. Reverse Bits","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Divide And Conquer, Bit Manipulation</p> </li> </ul> Python <pre><code># Bit Manipulation\ndef reverseBits(n: int) -&gt; int:\n    res = 0\n\n    for i in range(32):\n        res = (res &lt;&lt; 1) | (n &amp; 1)\n        n &gt;&gt;= 1\n\n    return res\n\n\nn = 0b00000010100101000001111010011100\nprint(reverseBits(n))  # 964176192\n</code></pre>"},{"location":"EndlessCheng/bit_others/#371-sum-of-two-integers","title":"371. Sum of Two Integers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Bit Manipulation</p> </li> </ul> Python <pre><code># Bit Manipulation\ndef getSum(a: int, b: int) -&gt; int:\n    MASK = 0xFFFFFFFF\n    MAX_INT = 0x7FFFFFFF\n\n    while b != 0:\n        temp = (a ^ b) &amp; MASK\n        b = ((a &amp; b) &lt;&lt; 1) &amp; MASK\n        a = temp\n\n    return a if a &lt;= MAX_INT else ~(a ^ MASK)\n\n\nprint(getSum(1, 2))  # 3\n</code></pre>"},{"location":"EndlessCheng/bit_others/#201-bitwise-and-of-numbers-range","title":"201. Bitwise AND of Numbers Range","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_others/#2154-keep-multiplying-found-values-by-two","title":"2154. Keep Multiplying Found Values by Two","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Sorting, Simulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_others/#2044-count-number-of-maximum-bitwise-or-subsets","title":"2044. Count Number of Maximum Bitwise-OR Subsets","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking, Bit Manipulation, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/bit_others/#2438-range-product-queries-of-powers","title":"2438. Range Product Queries of Powers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/bit_others/#1680-concatenation-of-consecutive-binary-numbers","title":"1680. Concatenation of Consecutive Binary Numbers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Bit Manipulation, Simulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_others/#1261-find-elements-in-a-contaminated-binary-tree","title":"1261. Find Elements in a Contaminated Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Tree, Depth First Search, Breadth First Search, Design, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/bit_others/#89-gray-code","title":"89. Gray Code","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Backtracking, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_others/#1238-circular-permutation-in-binary-representation","title":"1238. Circular Permutation in Binary Representation","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Backtracking, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_others/#982-triples-with-bitwise-and-equal-to-zero","title":"982. Triples with Bitwise AND Equal To Zero","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_others/#3307-find-the-k-th-character-in-string-game-ii","title":"3307. Find the K-th Character in String Game II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Bit Manipulation, Recursion</p> </li> </ul>"},{"location":"EndlessCheng/bit_others/#1611-minimum-one-bit-operations-to-make-integers-zero","title":"1611. Minimum One Bit Operations to Make Integers Zero","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Bit Manipulation, Memoization</p> </li> </ul>"},{"location":"EndlessCheng/bit_others/#751-ip-to-cidr","title":"751. IP to CIDR \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_others/#3141-maximum-hamming-distances","title":"3141. Maximum Hamming Distances \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation, Breadth First Search</p> </li> </ul>"},{"location":"EndlessCheng/bit_thinking_problems/","title":"Bit Thinking Problems","text":""},{"location":"EndlessCheng/bit_thinking_problems/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2546. Apply Bitwise Operations to Make Strings Equal (Medium)</li> <li> 1558. Minimum Numbers of Function Calls to Make Target Array (Medium)</li> <li> 2571. Minimum Operations to Reduce an Integer to 0 (Medium)</li> <li> 3315. Construct the Minimum Bitwise Array II (Medium)</li> <li> 2568. Minimum Impossible OR (Medium)</li> <li> 2509. Cycle Length Queries in a Tree (Hard)</li> <li> 2939. Maximum Xor Product (Medium)</li> <li> 2749. Minimum Operations to Make the Integer Zero (Medium)</li> <li> 2835. Minimum Operations to Form Subsequence With Target Sum (Hard)</li> <li> 2897. Apply Operations on Array to Maximize Sum of Squares (Hard)</li> <li> 810. Chalkboard XOR Game (Hard)</li> <li> 3064. Guess the Number Using Bitwise Questions I (Medium) \ud83d\udc51</li> <li> 3094. Guess the Number Using Bitwise Questions II (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/bit_thinking_problems/#2546-apply-bitwise-operations-to-make-strings-equal","title":"2546. Apply Bitwise Operations to Make Strings Equal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_thinking_problems/#1558-minimum-numbers-of-function-calls-to-make-target-array","title":"1558. Minimum Numbers of Function Calls to Make Target Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_thinking_problems/#2571-minimum-operations-to-reduce-an-integer-to-0","title":"2571. Minimum Operations to Reduce an Integer to 0","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Greedy, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_thinking_problems/#3315-construct-the-minimum-bitwise-array-ii","title":"3315. Construct the Minimum Bitwise Array II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_thinking_problems/#2568-minimum-impossible-or","title":"2568. Minimum Impossible OR","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation, Brainteaser</p> </li> </ul>"},{"location":"EndlessCheng/bit_thinking_problems/#2509-cycle-length-queries-in-a-tree","title":"2509. Cycle Length Queries in a Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Tree, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/bit_thinking_problems/#2939-maximum-xor-product","title":"2939. Maximum Xor Product","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Greedy, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_thinking_problems/#2749-minimum-operations-to-make-the-integer-zero","title":"2749. Minimum Operations to Make the Integer Zero","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Bit Manipulation, Brainteaser, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/bit_thinking_problems/#2835-minimum-operations-to-form-subsequence-with-target-sum","title":"2835. Minimum Operations to Form Subsequence With Target Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_thinking_problems/#2897-apply-operations-on-array-to-maximize-sum-of-squares","title":"2897. Apply Operations on Array to Maximize Sum of Squares","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Greedy, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_thinking_problems/#810-chalkboard-xor-game","title":"810. Chalkboard XOR Game","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Bit Manipulation, Brainteaser, Game Theory</p> </li> </ul>"},{"location":"EndlessCheng/bit_thinking_problems/#3064-guess-the-number-using-bitwise-questions-i","title":"3064. Guess the Number Using Bitwise Questions I \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Bit Manipulation, Interactive</p> </li> </ul>"},{"location":"EndlessCheng/bit_thinking_problems/#3094-guess-the-number-using-bitwise-questions-ii","title":"3094. Guess the Number Using Bitwise Questions II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Bit Manipulation, Interactive</p> </li> </ul>"},{"location":"EndlessCheng/bit_trial_and_error_method/","title":"Bit Trial and Error Method","text":""},{"location":"EndlessCheng/bit_trial_and_error_method/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3007. Maximum Number That Sum of the Prices Is Less Than or Equal to K (Medium)</li> <li> 421. Maximum XOR of Two Numbers in an Array (Medium)</li> <li> 2935. Maximum Strong Pair XOR II (Hard)</li> <li> 3145. Find Products of Elements of Big Array (Hard)</li> <li> 3022. Minimize OR of Remaining Elements Using Operations (Hard)</li> <li> 3287. Find the Maximum Sequence Value of Array (Hard)</li> </ul>"},{"location":"EndlessCheng/bit_trial_and_error_method/#3007-maximum-number-that-sum-of-the-prices-is-less-than-or-equal-to-k","title":"3007. Maximum Number That Sum of the Prices Is Less Than or Equal to K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Binary Search, Dynamic Programming, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_trial_and_error_method/#421-maximum-xor-of-two-numbers-in-an-array","title":"421. Maximum XOR of Two Numbers in an Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Bit Manipulation, Trie</p> </li> </ul>"},{"location":"EndlessCheng/bit_trial_and_error_method/#2935-maximum-strong-pair-xor-ii","title":"2935. Maximum Strong Pair XOR II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Bit Manipulation, Trie, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/bit_trial_and_error_method/#3145-find-products-of-elements-of-big-array","title":"3145. Find Products of Elements of Big Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_trial_and_error_method/#3022-minimize-or-of-remaining-elements-using-operations","title":"3022. Minimize OR of Remaining Elements Using Operations","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_trial_and_error_method/#3287-find-the-maximum-sequence-value-of-array","title":"3287. Find the Maximum Sequence Value of Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_xor/","title":"Bit XOR","text":""},{"location":"EndlessCheng/bit_xor/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1486. XOR Operation in an Array (Easy)</li> <li> 1720. Decode XORed Array (Easy)</li> <li> 2433. Find The Original Array of Prefix Xor (Medium)</li> <li> 1310. XOR Queries of a Subarray (Medium)</li> <li> 2683. Neighboring Bitwise XOR (Medium)</li> <li> 1829. Maximum XOR for Each Query (Medium)</li> <li> 2997. Minimum Number of Operations to Make Array XOR Equal to K (Medium)</li> <li> 1442. Count Triplets That Can Form Two Arrays of Equal XOR (Medium)</li> <li> 2429. Minimize XOR (Medium)</li> <li> 2527. Find Xor-Beauty of Array (Medium)</li> <li> 2317. Maximum XOR After Operations  (Medium)</li> <li> 2588. Count the Number of Beautiful Subarrays (Medium)</li> <li> 2564. Substring XOR Queries (Medium)</li> <li> 1734. Decode XORed Permutation (Medium)</li> <li> 2857. Count Pairs of Points With Distance k (Medium)</li> <li> 1803. Count Pairs With XOR in a Range (Hard)</li> <li> 3215. Count Triplets with Even XOR Set Bits II (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/bit_xor/#1486-xor-operation-in-an-array","title":"1486. XOR Operation in an Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_xor/#1720-decode-xored-array","title":"1720. Decode XORed Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_xor/#2433-find-the-original-array-of-prefix-xor","title":"2433. Find The Original Array of Prefix Xor","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_xor/#1310-xor-queries-of-a-subarray","title":"1310. XOR Queries of a Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/bit_xor/#2683-neighboring-bitwise-xor","title":"2683. Neighboring Bitwise XOR","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_xor/#1829-maximum-xor-for-each-query","title":"1829. Maximum XOR for Each Query","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/bit_xor/#2997-minimum-number-of-operations-to-make-array-xor-equal-to-k","title":"2997. Minimum Number of Operations to Make Array XOR Equal to K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_xor/#1442-count-triplets-that-can-form-two-arrays-of-equal-xor","title":"1442. Count Triplets That Can Form Two Arrays of Equal XOR","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Bit Manipulation, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/bit_xor/#2429-minimize-xor","title":"2429. Minimize XOR","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Greedy, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_xor/#2527-find-xor-beauty-of-array","title":"2527. Find Xor-Beauty of Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_xor/#2317-maximum-xor-after-operations","title":"2317. Maximum XOR After Operations","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_xor/#2588-count-the-number-of-beautiful-subarrays","title":"2588. Count the Number of Beautiful Subarrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Bit Manipulation, Prefix Sum</p> </li> </ul> Python <p><pre><code>\"\"\"\n- `nums = [4, 3, 1, 2, 4]`\n- In bianry\n</code></pre> 4 -&gt; 100 3 -&gt; 011 1 -&gt; 001 2 -&gt; 010 4 -&gt; 100 <pre><code>\"\"\"\n\nfrom collections import defaultdict\nfrom typing import List\n\n\ndef beautifulSubarrays(nums: List[int]) -&gt; int:\n    res, s = 0, 0\n    cnt = defaultdict(int)\n    cnt[0] = 1\n\n    for x in nums:\n        s ^= x\n        res += cnt[s]\n        cnt[s] += 1\n\n    return res\n\n\nnums = [4, 3, 1, 2, 4]\nprint(beautifulSubarrays(nums))  # 2\n</code></pre></p>"},{"location":"EndlessCheng/bit_xor/#2564-substring-xor-queries","title":"2564. Substring XOR Queries","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_xor/#1734-decode-xored-permutation","title":"1734. Decode XORed Permutation","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_xor/#2857-count-pairs-of-points-with-distance-k","title":"2857. Count Pairs of Points With Distance k","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/bit_xor/#1803-count-pairs-with-xor-in-a-range","title":"1803. Count Pairs With XOR in a Range","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation, Trie</p> </li> </ul>"},{"location":"EndlessCheng/bit_xor/#3215-count-triplets-with-even-xor-set-bits-ii","title":"3215. Count Triplets with Even XOR Set Bits II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/brain_teasers/","title":"Brain Teasers","text":""},{"location":"EndlessCheng/brain_teasers/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2733. Neither Minimum nor Maximum (Easy)</li> <li> 1903. Largest Odd Number in String (Easy)</li> <li> 2549. Count Distinct Numbers on Board (Easy)</li> <li> 3432. Count Partitions with Even Sum Difference (Easy)</li> <li> 2396. Strictly Palindromic Number (Medium)</li> <li> 1689. Partitioning Into Minimum Number Of Deci-Binary Numbers (Medium)</li> <li> 598. Range Addition II (Easy)</li> <li> 521. Longest Uncommon Subsequence I (Easy)</li> <li> 3227. Vowels Game in a String (Medium)</li> <li> 2419. Longest Subarray With Maximum Bitwise AND (Medium)</li> <li> 3424. Minimum Cost to Make Arrays Identical (Medium)</li> <li> 1992. Find All Groups of Farmland (Medium)</li> <li> 1007. Minimum Domino Rotations For Equal Row (Medium)</li> <li> 2811. Check if it is Possible to Split Array (Medium)</li> <li> 2211. Count Collisions on a Road (Medium)</li> <li> 3207. Maximum Points After Enemy Battles (Medium)</li> <li> 2546. Apply Bitwise Operations to Make Strings Equal (Medium)</li> <li> 1503. Last Moment Before All Ants Fall Out of a Plank (Medium)</li> <li> 2860. Happy Students (Medium)</li> <li> 1332. Remove Palindromic Subsequences (Easy)</li> <li> 1975. Maximum Matrix Sum (Medium)</li> <li> 1145. Binary Tree Coloring Game (Medium)</li> <li> 1297. Maximum Number of Occurrences of a Substring (Medium)</li> <li> 3282. Reach End of Array With Max Score (Medium)</li> <li> 2332. The Latest Time to Catch a Bus (Medium)</li> <li> 2680. Maximum OR (Medium)</li> <li> 2731. Movement of Robots (Medium)</li> <li> 2556. Disconnect Path in a Binary Matrix by at Most One Flip (Medium)</li> <li> 3125. Maximum Number That Makes Result of Bitwise AND Zero (Medium) \ud83d\udc51</li> <li> 1794. Count Pairs of Equal Substrings With Minimum Difference (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/brain_teasers/#2733-neither-minimum-nor-maximum","title":"2733. Neither Minimum nor Maximum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/brain_teasers/#1903-largest-odd-number-in-string","title":"1903. Largest Odd Number in String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/brain_teasers/#2549-count-distinct-numbers-on-board","title":"2549. Count Distinct Numbers on Board","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Simulation</p> </li> </ul>"},{"location":"EndlessCheng/brain_teasers/#3432-count-partitions-with-even-sum-difference","title":"3432. Count Partitions with Even Sum Difference","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/brain_teasers/#2396-strictly-palindromic-number","title":"2396. Strictly Palindromic Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Two Pointers, Brainteaser</p> </li> </ul>"},{"location":"EndlessCheng/brain_teasers/#1689-partitioning-into-minimum-number-of-deci-binary-numbers","title":"1689. Partitioning Into Minimum Number Of Deci-Binary Numbers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/brain_teasers/#598-range-addition-ii","title":"598. Range Addition II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math</p> </li> </ul>"},{"location":"EndlessCheng/brain_teasers/#521-longest-uncommon-subsequence-i","title":"521. Longest Uncommon Subsequence I","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String</p> </li> </ul>"},{"location":"EndlessCheng/brain_teasers/#3227-vowels-game-in-a-string","title":"3227. Vowels Game in a String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String, Brainteaser, Game Theory</p> </li> </ul>"},{"location":"EndlessCheng/brain_teasers/#2419-longest-subarray-with-maximum-bitwise-and","title":"2419. Longest Subarray With Maximum Bitwise AND","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation, Brainteaser</p> </li> </ul>"},{"location":"EndlessCheng/brain_teasers/#3424-minimum-cost-to-make-arrays-identical","title":"3424. Minimum Cost to Make Arrays Identical","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/brain_teasers/#1992-find-all-groups-of-farmland","title":"1992. Find All Groups of Farmland","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/brain_teasers/#1007-minimum-domino-rotations-for-equal-row","title":"1007. Minimum Domino Rotations For Equal Row","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/brain_teasers/#2811-check-if-it-is-possible-to-split-array","title":"2811. Check if it is Possible to Split Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/brain_teasers/#2211-count-collisions-on-a-road","title":"2211. Count Collisions on a Road","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack, Simulation</p> </li> </ul>"},{"location":"EndlessCheng/brain_teasers/#3207-maximum-points-after-enemy-battles","title":"3207. Maximum Points After Enemy Battles","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/brain_teasers/#2546-apply-bitwise-operations-to-make-strings-equal","title":"2546. Apply Bitwise Operations to Make Strings Equal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/brain_teasers/#1503-last-moment-before-all-ants-fall-out-of-a-plank","title":"1503. Last Moment Before All Ants Fall Out of a Plank","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Brainteaser, Simulation</p> </li> </ul>"},{"location":"EndlessCheng/brain_teasers/#2860-happy-students","title":"2860. Happy Students","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sorting, Enumeration</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Sort\ndef countWays(nums: List[int]) -&gt; int:\n    nums.sort()\n    n = len(nums)\n    count = 0\n\n    if nums[0] &gt; 0:\n        count += 1\n\n    for x in range(1, n):\n        if nums[x - 1] &lt; x &lt; nums[x]:\n            count += 1\n\n    if nums[n - 1] &lt; n:\n        count += 1\n\n    return count\n\n\nnums = [6, 0, 3, 3, 6, 7, 2, 7]\nprint(countWays(nums))  # 3\n</code></pre>"},{"location":"EndlessCheng/brain_teasers/#1332-remove-palindromic-subsequences","title":"1332. Remove Palindromic Subsequences","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String</p> </li> </ul>"},{"location":"EndlessCheng/brain_teasers/#1975-maximum-matrix-sum","title":"1975. Maximum Matrix Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/brain_teasers/#1145-binary-tree-coloring-game","title":"1145. Binary Tree Coloring Game","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/brain_teasers/#1297-maximum-number-of-occurrences-of-a-substring","title":"1297. Maximum Number of Occurrences of a Substring","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/brain_teasers/#3282-reach-end-of-array-with-max-score","title":"3282. Reach End of Array With Max Score","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/brain_teasers/#2332-the-latest-time-to-catch-a-bus","title":"2332. The Latest Time to Catch a Bus","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/brain_teasers/#2680-maximum-or","title":"2680. Maximum OR","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Bit Manipulation, Prefix Sum</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Greedy\ndef maximumOr(nums: List[int], k: int) -&gt; int:\n    \"\"\"Maximum OR of Array After k Operations\n\n    Args:\n        nums (List[int]): provided list of integers\n        k (int): number of operations\n\n    Returns:\n        int: maximum OR of array after k operations\n    \"\"\"\n    n = len(nums)\n    suffix = [0 for _ in range(n)]\n\n    for i in range(n - 2, -1, -1):\n        suffix[i] = suffix[i + 1] | nums[i + 1]\n\n    res, pre = 0, 0\n    for num, suf in zip(nums, suffix):\n        res = max(res, pre | (num &lt;&lt; k) | suf)\n        pre |= num\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(maximumOr(nums=[8, 1, 2], k=2))  # 35\n</code></pre>"},{"location":"EndlessCheng/brain_teasers/#2731-movement-of-robots","title":"2731. Movement of Robots","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Brainteaser, Sorting, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/brain_teasers/#2556-disconnect-path-in-a-binary-matrix-by-at-most-one-flip","title":"2556. Disconnect Path in a Binary Matrix by at Most One Flip","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Depth First Search, Breadth First Search, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/brain_teasers/#3125-maximum-number-that-makes-result-of-bitwise-and-zero","title":"3125. Maximum Number That Makes Result of Bitwise AND Zero \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/brain_teasers/#1794-count-pairs-of-equal-substrings-with-minimum-difference","title":"1794. Count Pairs of Equal Substrings With Minimum Difference \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/circles/","title":"Circles","text":""},{"location":"EndlessCheng/circles/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1401. Circle and Rectangle Overlapping (Medium)</li> <li> 1453. Maximum Number of Darts Inside of a Circular Dartboard (Hard)</li> <li> 3235. Check if the Rectangle Corner Is Reachable (Hard)</li> <li> 1924. Erect the Fence II (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/circles/#1401-circle-and-rectangle-overlapping","title":"1401. Circle and Rectangle Overlapping","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Geometry</p> </li> </ul>"},{"location":"EndlessCheng/circles/#1453-maximum-number-of-darts-inside-of-a-circular-dartboard","title":"1453. Maximum Number of Darts Inside of a Circular Dartboard","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Geometry</p> </li> </ul>"},{"location":"EndlessCheng/circles/#3235-check-if-the-rectangle-corner-is-reachable","title":"3235. Check if the Rectangle Corner Is Reachable","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Depth First Search, Breadth First Search, Union Find, Geometry</p> </li> </ul>"},{"location":"EndlessCheng/circles/#1924-erect-the-fence-ii","title":"1924. Erect the Fence II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Geometry</p> </li> </ul>"},{"location":"EndlessCheng/combinatorial_counting/","title":"Combinatorial Counting","text":""},{"location":"EndlessCheng/combinatorial_counting/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 62. Unique Paths (Medium)</li> <li> 357. Count Numbers with Unique Digits (Medium)</li> <li> 1175. Prime Arrangements (Easy)</li> <li> 3179. Find the N-th Value After K Seconds (Medium)</li> <li> 1359. Count All Valid Pickup and Delivery Options (Hard)</li> <li> 2400. Number of Ways to Reach a Position After Exactly k Steps (Medium)</li> <li> 2514. Count Anagrams (Hard)</li> <li> 3154. Find Number of Ways to Reach the K-th Stair (Hard)</li> <li> 1643. Kth Smallest Instructions (Hard)</li> <li> 2842. Count K-Subsequences of a String With Maximum Beauty (Hard)</li> <li> 1569. Number of Ways to Reorder Array to Get Same BST (Hard)</li> <li> 3405. Count the Number of Arrays with K Matching Adjacent Elements (Hard)</li> <li> 1866. Number of Ways to Rearrange Sticks With K Sticks Visible (Hard)</li> <li> 1467. Probability of a Two Boxes Having The Same Number of Distinct Balls (Hard)</li> <li> 3272. Find the Count of Good Integers (Hard)</li> <li> 3317. Find the Number of Possible Ways for an Event (Hard)</li> <li> 1916. Count Ways to Build Rooms in an Ant Colony (Hard)</li> <li> 3343. Count Number of Balanced Permutations (Hard)</li> <li> 1830. Minimum Number of Operations to Make String Sorted (Hard)</li> <li> 2954. Count the Number of Infection Sequences (Hard)</li> <li> 3395. Subsequences with a Unique Middle Mode I (Hard)</li> <li> 1575. Count All Possible Routes (Hard)</li> <li> 3251. Find the Count of Monotonic Pairs II (Hard)</li> <li> 2539. Count the Number of Good Subsequences (Medium) \ud83d\udc51</li> <li> 634. Find the Derangement of An Array (Medium) \ud83d\udc51</li> <li> 1692. Count Ways to Distribute Candies (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/combinatorial_counting/#62-unique-paths","title":"62. Unique Paths","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Combinatorics</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Count the number of unique paths to reach the bottom-right corner of a `m x n` grid.\n\n![62](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)\n\"\"\"\n\n\n# DP - 2D\ndef uniquePaths(m: int, n: int) -&gt; int:\n    if m == 1 or n == 1:\n        return 1\n\n    dp = [[1] * n for _ in range(m)]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]\n\n\nprint(uniquePaths(m=3, n=7))  # 28\n# [[1, 1, 1,  1,  1,  1,  1],\n#  [1, 2, 3,  4,  5,  6,  7],\n#  [1, 3, 6, 10, 15, 21, 28]]\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint uniquePaths(int m, int n) {\n    vector dp(m, vector&lt;int&gt;(n, 1));\n\n    for (int i = 1; i &lt; m; i++) {\n        for (int j = 1; j &lt; n; j++) {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n\n    return dp[m - 1][n - 1];\n}\n\nint main() {\n    int m = 3, n = 7;\n    cout &lt;&lt; uniquePaths(m, n) &lt;&lt; endl;  // 28\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/combinatorial_counting/#357-count-numbers-with-unique-digits","title":"357. Count Numbers with Unique Digits","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Backtracking</p> </li> </ul>"},{"location":"EndlessCheng/combinatorial_counting/#1175-prime-arrangements","title":"1175. Prime Arrangements","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math</p> </li> </ul>"},{"location":"EndlessCheng/combinatorial_counting/#3179-find-the-n-th-value-after-k-seconds","title":"3179. Find the N-th Value After K Seconds","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Simulation, Combinatorics, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/combinatorial_counting/#1359-count-all-valid-pickup-and-delivery-options","title":"1359. Count All Valid Pickup and Delivery Options","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Combinatorics</p> </li> </ul>"},{"location":"EndlessCheng/combinatorial_counting/#2400-number-of-ways-to-reach-a-position-after-exactly-k-steps","title":"2400. Number of Ways to Reach a Position After Exactly k Steps","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Combinatorics</p> </li> </ul>"},{"location":"EndlessCheng/combinatorial_counting/#2514-count-anagrams","title":"2514. Count Anagrams","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Math, String, Combinatorics, Counting</p> </li> </ul>"},{"location":"EndlessCheng/combinatorial_counting/#3154-find-number-of-ways-to-reach-the-k-th-stair","title":"3154. Find Number of Ways to Reach the K-th Stair","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Bit Manipulation, Memoization, Combinatorics</p> </li> </ul>"},{"location":"EndlessCheng/combinatorial_counting/#1643-kth-smallest-instructions","title":"1643. Kth Smallest Instructions","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Combinatorics</p> </li> </ul>"},{"location":"EndlessCheng/combinatorial_counting/#2842-count-k-subsequences-of-a-string-with-maximum-beauty","title":"2842. Count K-Subsequences of a String With Maximum Beauty","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Math, String, Greedy, Combinatorics</p> </li> </ul>"},{"location":"EndlessCheng/combinatorial_counting/#1569-number-of-ways-to-reorder-array-to-get-same-bst","title":"1569. Number of Ways to Reorder Array to Get Same BST","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Divide And Conquer, Dynamic Programming, Tree, Union Find, Binary Search Tree, Memoization, Combinatorics, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/combinatorial_counting/#3405-count-the-number-of-arrays-with-k-matching-adjacent-elements","title":"3405. Count the Number of Arrays with K Matching Adjacent Elements","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Combinatorics</p> </li> </ul>"},{"location":"EndlessCheng/combinatorial_counting/#1866-number-of-ways-to-rearrange-sticks-with-k-sticks-visible","title":"1866. Number of Ways to Rearrange Sticks With K Sticks Visible","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Combinatorics</p> </li> </ul>"},{"location":"EndlessCheng/combinatorial_counting/#1467-probability-of-a-two-boxes-having-the-same-number-of-distinct-balls","title":"1467. Probability of a Two Boxes Having The Same Number of Distinct Balls","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Backtracking, Combinatorics, Probability And Statistics</p> </li> </ul>"},{"location":"EndlessCheng/combinatorial_counting/#3272-find-the-count-of-good-integers","title":"3272. Find the Count of Good Integers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Math, Combinatorics, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/combinatorial_counting/#3317-find-the-number-of-possible-ways-for-an-event","title":"3317. Find the Number of Possible Ways for an Event","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Combinatorics</p> </li> </ul>"},{"location":"EndlessCheng/combinatorial_counting/#1916-count-ways-to-build-rooms-in-an-ant-colony","title":"1916. Count Ways to Build Rooms in an Ant Colony","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Tree, Graph, Topological Sort, Combinatorics</p> </li> </ul>"},{"location":"EndlessCheng/combinatorial_counting/#3343-count-number-of-balanced-permutations","title":"3343. Count Number of Balanced Permutations","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String, Dynamic Programming, Combinatorics</p> </li> </ul>"},{"location":"EndlessCheng/combinatorial_counting/#1830-minimum-number-of-operations-to-make-string-sorted","title":"1830. Minimum Number of Operations to Make String Sorted","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String, Combinatorics</p> </li> </ul>"},{"location":"EndlessCheng/combinatorial_counting/#2954-count-the-number-of-infection-sequences","title":"2954. Count the Number of Infection Sequences","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Combinatorics</p> </li> </ul>"},{"location":"EndlessCheng/combinatorial_counting/#3395-subsequences-with-a-unique-middle-mode-i","title":"3395. Subsequences with a Unique Middle Mode I","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Combinatorics</p> </li> </ul>"},{"location":"EndlessCheng/combinatorial_counting/#1575-count-all-possible-routes","title":"1575. Count All Possible Routes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Memoization</p> </li> </ul>"},{"location":"EndlessCheng/combinatorial_counting/#3251-find-the-count-of-monotonic-pairs-ii","title":"3251. Find the Count of Monotonic Pairs II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Combinatorics, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/combinatorial_counting/#2539-count-the-number-of-good-subsequences","title":"2539. Count the Number of Good Subsequences \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Math, String, Combinatorics, Counting</p> </li> </ul>"},{"location":"EndlessCheng/combinatorial_counting/#634-find-the-derangement-of-an-array","title":"634. Find the Derangement of An Array \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Combinatorics</p> </li> </ul>"},{"location":"EndlessCheng/combinatorial_counting/#1692-count-ways-to-distribute-candies","title":"1692. Count Ways to Distribute Candies \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/combinatorics_contribution_method/","title":"Combinatorics Contribution Method","text":""},{"location":"EndlessCheng/combinatorics_contribution_method/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2063. Vowels of All Substrings (Medium)</li> <li> 1588. Sum of All Odd Length Subarrays (Easy)</li> <li> 2681. Power of Heroes (Hard)</li> <li> 891. Sum of Subsequence Widths (Hard)</li> <li> 3428. Maximum and Minimum Sums of at Most Size K Subsequences (Medium)</li> <li> 3426. Manhattan Distances of All Arrangements of Pieces (Hard)</li> <li> 2763. Sum of Imbalance Numbers of All Subarrays (Hard)</li> <li> 979. Distribute Coins in Binary Tree (Medium)</li> <li> 2477. Minimum Fuel Cost to Report to the Capital (Medium)</li> </ul>"},{"location":"EndlessCheng/combinatorics_contribution_method/#2063-vowels-of-all-substrings","title":"2063. Vowels of All Substrings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String, Dynamic Programming, Combinatorics</p> </li> </ul>"},{"location":"EndlessCheng/combinatorics_contribution_method/#1588-sum-of-all-odd-length-subarrays","title":"1588. Sum of All Odd Length Subarrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/combinatorics_contribution_method/#2681-power-of-heroes","title":"2681. Power of Heroes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Sorting, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/combinatorics_contribution_method/#891-sum-of-subsequence-widths","title":"891. Sum of Subsequence Widths","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/combinatorics_contribution_method/#3428-maximum-and-minimum-sums-of-at-most-size-k-subsequences","title":"3428. Maximum and Minimum Sums of at Most Size K Subsequences","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Sorting, Combinatorics</p> </li> </ul>"},{"location":"EndlessCheng/combinatorics_contribution_method/#3426-manhattan-distances-of-all-arrangements-of-pieces","title":"3426. Manhattan Distances of All Arrangements of Pieces","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Combinatorics</p> </li> </ul>"},{"location":"EndlessCheng/combinatorics_contribution_method/#2763-sum-of-imbalance-numbers-of-all-subarrays","title":"2763. Sum of Imbalance Numbers of All Subarrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/combinatorics_contribution_method/#979-distribute-coins-in-binary-tree","title":"979. Distribute Coins in Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/combinatorics_contribution_method/#2477-minimum-fuel-cost-to-report-to-the-capital","title":"2477. Minimum Fuel Cost to Report to the Capital","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Graph</p> </li> </ul>"},{"location":"EndlessCheng/construction_problems/","title":"Construction Problems","text":""},{"location":"EndlessCheng/construction_problems/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 942. DI String Match (Easy)</li> <li> 1968. Array With Elements Not Equal to Average of Neighbors (Medium)</li> <li> 1253. Reconstruct a 2-Row Binary Matrix (Medium)</li> <li> 2182. Construct String With Repeat Limit (Medium)</li> <li> 969. Pancake Sorting (Medium)</li> <li> 1605. Find Valid Matrix Given Row and Column Sums (Medium)</li> <li> 2375. Construct Smallest Number From DI String (Medium)</li> <li> 324. Wiggle Sort II (Medium)</li> <li> 667. Beautiful Arrangement II (Medium)</li> <li> 2122. Recover the Original Array (Hard)</li> <li> 932. Beautiful Array (Medium)</li> <li> 3311. Construct 2D Grid Matching Graph Layout (Hard)</li> <li> 2573. Find the String with LCP (Hard)</li> <li> 1982. Find Array Given Subset Sums (Hard)</li> <li> 280. Wiggle Sort (Medium) \ud83d\udc51</li> <li> 484. Find Permutation (Medium) \ud83d\udc51</li> <li> 1980. Find Unique Binary String (Medium)</li> </ul>"},{"location":"EndlessCheng/construction_problems/#942-di-string-match","title":"942. DI String Match","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, String, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/construction_problems/#1968-array-with-elements-not-equal-to-average-of-neighbors","title":"1968. Array With Elements Not Equal to Average of Neighbors","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/construction_problems/#1253-reconstruct-a-2-row-binary-matrix","title":"1253. Reconstruct a 2-Row Binary Matrix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/construction_problems/#2182-construct-string-with-repeat-limit","title":"2182. Construct String With Repeat Limit","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Greedy, Heap Priority Queue, Counting</p> </li> </ul>"},{"location":"EndlessCheng/construction_problems/#969-pancake-sorting","title":"969. Pancake Sorting","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/construction_problems/#1605-find-valid-matrix-given-row-and-column-sums","title":"1605. Find Valid Matrix Given Row and Column Sums","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/construction_problems/#2375-construct-smallest-number-from-di-string","title":"2375. Construct Smallest Number From DI String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Backtracking, Stack, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/construction_problems/#324-wiggle-sort-ii","title":"324. Wiggle Sort II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Divide And Conquer, Greedy, Sorting, Quickselect</p> </li> </ul>"},{"location":"EndlessCheng/construction_problems/#667-beautiful-arrangement-ii","title":"667. Beautiful Arrangement II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math</p> </li> </ul>"},{"location":"EndlessCheng/construction_problems/#2122-recover-the-original-array","title":"2122. Recover the Original Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Two Pointers, Sorting, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/construction_problems/#932-beautiful-array","title":"932. Beautiful Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Divide And Conquer</p> </li> </ul>"},{"location":"EndlessCheng/construction_problems/#3311-construct-2d-grid-matching-graph-layout","title":"3311. Construct 2D Grid Matching Graph Layout","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Graph, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/construction_problems/#2573-find-the-string-with-lcp","title":"2573. Find the String with LCP","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Dynamic Programming, Greedy, Union Find, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/construction_problems/#1982-find-array-given-subset-sums","title":"1982. Find Array Given Subset Sums","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Divide And Conquer</p> </li> </ul>"},{"location":"EndlessCheng/construction_problems/#280-wiggle-sort","title":"280. Wiggle Sort \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\ndef wiggleSort(nums: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    n = len(nums)\n    for i in range(n - 1):\n        if i % 2 == 0:\n            if nums[i] &gt; nums[i + 1]:\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]\n        else:\n            if nums[i] &lt; nums[i + 1]:\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]\n\n\nnum = [3, 5, 2, 1, 6, 4]\nwiggleSort(num)\nprint(num)  # [3, 5, 1, 6, 2, 4]\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvoid wiggleSort(vector&lt;int&gt;&amp; nums) {\n    int n = nums.size();\n\n    for (int i = 0; i &lt; n - 1; i++) {\n        if (i % 2 == 0) {\n            if (nums[i] &gt; nums[i + 1]) swap(nums[i], nums[i + 1]);\n        } else {\n            if (nums[i] &lt; nums[i + 1]) swap(nums[i], nums[i + 1]);\n        }\n    }\n}\n\nint main() {\n    vector&lt;int&gt; nums = {3, 5, 2, 1, 6, 4};\n    wiggleSort(nums);\n    // 3 5 1 6 2 4\n    for (size_t i = 0; i &lt; nums.size(); i++) {\n        cout &lt;&lt; nums[i] &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/construction_problems/#484-find-permutation","title":"484. Find Permutation \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Stack, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/construction_problems/#1980-find-unique-binary-string","title":"1980. Find Unique Binary String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Backtracking</p> </li> </ul>"},{"location":"EndlessCheng/contribution_method/","title":"Contribution Method","text":""},{"location":"EndlessCheng/contribution_method/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 907. Sum of Subarray Minimums (Medium)</li> <li> 2104. Sum of Subarray Ranges (Medium)</li> <li> 1856. Maximum Subarray Min-Product (Medium)</li> <li> 2818. Apply Operations to Maximize Score (Hard)</li> <li> 2281. Sum of Total Strength of Wizards (Hard)</li> <li> 3359. Find Sorted Submatrices With Maximum Element at Most K (Hard) \ud83d\udc51</li> <li> 2334. Subarray With Elements Greater Than Varying Threshold (Hard)</li> </ul>"},{"location":"EndlessCheng/contribution_method/#907-sum-of-subarray-minimums","title":"907. Sum of Subarray Minimums","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Stack, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/contribution_method/#2104-sum-of-subarray-ranges","title":"2104. Sum of Subarray Ranges","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Stack, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/contribution_method/#1856-maximum-subarray-min-product","title":"1856. Maximum Subarray Min-Product","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Stack, Monotonic Stack, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/contribution_method/#2818-apply-operations-to-maximize-score","title":"2818. Apply Operations to Maximize Score","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Stack, Greedy, Sorting, Monotonic Stack, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/contribution_method/#2281-sum-of-total-strength-of-wizards","title":"2281. Sum of Total Strength of Wizards","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Stack, Monotonic Stack, Prefix Sum</p> </li> </ul> Python <pre><code>from itertools import accumulate\nfrom typing import List\n\n\n# Monotonic Stack\ndef totalStrength(strength: List[int]) -&gt; int:\n    n = len(strength)\n    left = [-1 for _ in range(n)]\n    right = [n for _ in range(n)]\n    stack = []\n\n    for i, v in enumerate(strength):\n        while stack and strength[stack[-1]] &gt;= v:\n            right[stack.pop()] = i\n        if stack:\n            left[i] = stack[-1]\n        stack.append(i)\n\n    prefix_sum = list(accumulate(accumulate(strength, initial=0), initial=0))\n\n    ans = 0\n    for i, v in enumerate(strength):\n        l, r = left[i] + 1, right[i] - 1\n        tot = (i - l + 1) * (prefix_sum[r + 2] - prefix_sum[i + 1]) - (r - i + 1) * (\n            prefix_sum[i + 1] - prefix_sum[l]\n        )\n        ans += v * tot\n\n    return ans % (10**9 + 7)\n\n\nstrength = [1, 3, 1, 2]\nprint(totalStrength(strength))  # 44\n</code></pre>"},{"location":"EndlessCheng/contribution_method/#3359-find-sorted-submatrices-with-maximum-element-at-most-k","title":"3359. Find Sorted Submatrices With Maximum Element at Most K \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Stack, Matrix, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/contribution_method/#2334-subarray-with-elements-greater-than-varying-threshold","title":"2334. Subarray With Elements Greater Than Varying Threshold","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Stack, Union Find, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/convex_hull/","title":"Convex Hull","text":""},{"location":"EndlessCheng/convex_hull/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 587. Erect the Fence (Hard)</li> </ul>"},{"location":"EndlessCheng/convex_hull/#587-erect-the-fence","title":"587. Erect the Fence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Geometry</p> </li> </ul>"},{"location":"EndlessCheng/coprime/","title":"Coprime","text":""},{"location":"EndlessCheng/coprime/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2748. Number of Beautiful Pairs (Easy)</li> <li> 1447. Simplified Fractions (Medium)</li> <li> 1766. Tree of Coprimes (Hard)</li> <li> 3411. Maximum Subarray With Equal Products (Easy)</li> </ul>"},{"location":"EndlessCheng/coprime/#2748-number-of-beautiful-pairs","title":"2748. Number of Beautiful Pairs","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Counting, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/coprime/#1447-simplified-fractions","title":"1447. Simplified Fractions","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/coprime/#1766-tree-of-coprimes","title":"1766. Tree of Coprimes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Tree, Depth First Search, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/coprime/#3411-maximum-subarray-with-equal-products","title":"3411. Maximum Subarray With Equal Products","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Sliding Window, Enumeration, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/deque/","title":"Deque","text":""},{"location":"EndlessCheng/deque/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2810. Faulty Keyboard (Easy)</li> </ul>"},{"location":"EndlessCheng/deque/#2810-faulty-keyboard","title":"2810. Faulty Keyboard","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Simulation</p> </li> </ul>"},{"location":"EndlessCheng/dfs_basics/","title":"DFS Basics","text":""},{"location":"EndlessCheng/dfs_basics/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 547. Number of Provinces (Medium)</li> <li> 1971. Find if Path Exists in Graph (Easy)</li> <li> 797. All Paths From Source to Target (Medium)</li> <li> 841. Keys and Rooms (Medium)</li> <li> 2316. Count Unreachable Pairs of Nodes in an Undirected Graph (Medium)</li> <li> 1319. Number of Operations to Make Network Connected (Medium)</li> <li> 2492. Minimum Score of a Path Between Two Cities (Medium)</li> <li> 3387. Maximize Amount After Two Days of Conversions (Medium)</li> <li> 3310. Remove Methods From Project (Medium)</li> <li> 2685. Count the Number of Complete Components (Medium)</li> <li> 2192. All Ancestors of a Node in a Directed Acyclic Graph (Medium)</li> <li> 924. Minimize Malware Spread (Hard)</li> <li> 2101. Detonate the Maximum Bombs (Medium)</li> <li> 721. Accounts Merge (Medium)</li> <li> 207. Course Schedule (Medium)</li> <li> 802. Find Eventual Safe States (Medium)</li> <li> 928. Minimize Malware Spread II (Hard)</li> <li> 2092. Find All People With Secret (Hard)</li> <li> 3108. Minimum Cost Walk in Weighted Graph (Hard)</li> <li> 261. Graph Valid Tree (Medium) \ud83d\udc51</li> <li> 323. Number of Connected Components in an Undirected Graph (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/dfs_basics/#547-number-of-provinces","title":"547. Number of Provinces","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Union Find, Graph</p> </li> </ul> Python <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\nclass FindCircleNum:\n    def dfs_adjacency_list(self, isConnected: List[List[int]]) -&gt; int:\n        # edge case\n        if not isConnected:\n            return 0\n\n        # init\n        n = len(isConnected)\n        visited = set()\n        res = 0\n\n        # build adjacency list\n        graph = defaultdict(list)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if isConnected[i][j] == 1:\n                    graph[i].append(j)\n                    graph[j].append(i)\n\n        def dfs(node):\n            if node in visited:\n                return\n            visited.add(node)\n            for adj in graph[node]:\n                dfs(adj)\n\n        # loop\n        for i in range(n):\n            if i not in visited:\n                res += 1\n                dfs(i)\n\n        return res\n\n    def dfs_adjacency_matrix(self, isConnected: List[List[int]]) -&gt; int:\n        \"\"\"\n        Time complexity: O(V + E)\n        Space complexity: O(V)\n        \"\"\"\n        # edge case\n        if not isConnected:\n            return 0\n\n        # init\n        n = len(isConnected)\n        visited = set()\n        res = 0\n\n        def dfs(node):\n            if node in visited:\n                return\n            visited.add(node)\n            for adj in range(n):\n                if node != adj and isConnected[node][adj] == 1:\n                    dfs(adj)\n\n        # loop\n        for i in range(n):\n            if i not in visited:\n                res += 1\n                dfs(i)\n\n        return res\n\n    def bfs_adjacency_list(self, isConnected: List[List[int]]) -&gt; int:\n        # edge case\n        if not isConnected:\n            return 0\n\n        # init\n        n = len(isConnected)\n        visited = set()\n        res = 0\n\n        # build adjacency list\n        graph = defaultdict(list)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if isConnected[i][j] == 1:\n                    graph[i].append(j)\n                    graph[j].append(i)\n\n        # loop\n        for i in range(n):\n            if i not in visited:\n                q = deque([i])\n                visited.add(i)\n                res += 1\n\n                while q:\n                    node = q.popleft()\n                    for adj in graph[node]:\n                        if adj not in visited:\n                            q.append(adj)\n                            visited.add(adj)\n\n        return res\n\n    def bfs_adjacency_matrix(self, isConnected: List[List[int]]) -&gt; int:\n        if not isConnected:\n            return 0\n\n        res = 0\n        visited = set()\n        n = len(isConnected)\n\n        for i in range(n):\n            if i not in visited:\n                q = deque([i])\n                visited.add(i)\n                res += 1\n\n                while q:\n                    cur = q.popleft()\n                    for adj in range(n):\n                        if (\n                            adj != cur\n                            and adj not in visited\n                            and isConnected[adj][cur] == 1\n                        ):\n                            q.append(adj)\n                            visited.add(adj)\n\n        return res\n\n    def union_find(self, isConnected: List[List[int]]) -&gt; int:\n        n = len(isConnected)\n        par = {i: i for i in range(n)}\n        rank = {i: 0 for i in range(n)}\n\n        def find(n):\n            if par[n] != n:\n                par[n] = find(par[n])\n            return par[n]\n\n        def union(n1, n2):\n            p1, p2 = find(n1), find(n2)\n\n            if p1 == p2:\n                return None\n\n            if rank[p1] &gt; rank[p2]:\n                par[p2] = p1\n            elif rank[p1] &lt; rank[p2]:\n                par[p1] = p2\n            else:\n                par[p2] = p1\n                rank[p1] += 1\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if isConnected[i][j] == 1:\n                    union(i, j)\n\n        res = len(set(find(i) for i in range(n)))\n\n        return res\n\n\nif __name__ == \"__main__\":\n    isConnected = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]\n    sol = FindCircleNum()\n    assert sol.dfs_adjacency_list(isConnected) == 2\n    assert sol.dfs_adjacency_matrix(isConnected) == 2\n    assert sol.bfs_adjacency_list(isConnected) == 2\n    assert sol.bfs_adjacency_matrix(isConnected) == 2\n    assert sol.union_find(isConnected) == 2\n</code></pre>"},{"location":"EndlessCheng/dfs_basics/#1971-find-if-path-exists-in-graph","title":"1971. Find if Path Exists in Graph","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Union Find, Graph</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# DFS (Adjacency List)\ndef validPathDFS(n: int, edges: List[List[int]], source: int, destination: int) -&gt; bool:\n    if not edges and source != destination:\n        return False\n\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = set()\n\n    def dfs(node):\n        if node == destination:\n            return True\n\n        visited.add(node)\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n\n        return False\n\n    return dfs(source)\n\n\nn = 3\nedges = [[0, 1], [1, 2], [2, 0]]\nsource = 0\ndestination = 2\nprint(validPathDFS(n, edges, source, destination))  # True\n</code></pre>"},{"location":"EndlessCheng/dfs_basics/#797-all-paths-from-source-to-target","title":"797. All Paths From Source to Target","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Backtracking, Depth First Search, Breadth First Search, Graph</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS (Backtracking)\ndef allPathsSourceTargetDFS(graph: List[List[int]]) -&gt; List[List[int]]:\n    res = []\n    n = len(graph)\n\n    def dfs(node, path):\n        if node == n - 1:\n            res.append(path.copy())\n            return None\n\n        for nei in graph[node]:\n            path.append(nei)\n            dfs(nei, path)\n            path.pop()\n\n    dfs(0, [0])\n\n    return res\n\n\n# BFS\ndef allPathsSourceTargetBFS(graph: List[List[int]]) -&gt; List[List[int]]:\n    n = len(graph)\n    res = []\n    q = deque([(0, [0])])\n\n    while q:\n        node, path = q.popleft()\n\n        if node == n - 1:\n            res.append(path)\n\n        for nei in graph[node]:\n            q.append((nei, path + [nei]))\n\n    return res\n\n\ngraph = [[1, 2], [3], [3], []]\nprint(allPathsSourceTargetDFS(graph))  # [[0, 1, 3], [0, 2, 3]]\nprint(allPathsSourceTargetBFS(graph))  # [[0, 1, 3], [0, 2, 3]]\n</code></pre>"},{"location":"EndlessCheng/dfs_basics/#841-keys-and-rooms","title":"841. Keys and Rooms","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Graph</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef canVisitAllRoomsDFS(rooms: List[List[int]]) -&gt; bool:\n    n = len(rooms)\n    visited = [False for _ in range(n)]\n\n    def dfs(room):\n        visited[room] = True\n        for key in rooms[room]:\n            if not visited[key]:\n                dfs(key)\n\n    dfs(0)\n\n    return all(visited)\n\n\n# BFS\ndef canVisitAllRoomsBFS(rooms):\n    n = len(rooms)\n    visited = [False for _ in range(n)]\n    q = deque([0])\n    visited[0] = True\n\n    while q:\n        room = q.popleft()\n        for key in rooms[room]:\n            if not visited[key]:\n                visited[key] = True\n                q.append(key)\n\n    return all(visited)\n\n\nrooms = [[1, 3], [3, 0, 1], [2], [0]]\nprint(canVisitAllRoomsDFS(rooms))  # False\nprint(canVisitAllRoomsBFS(rooms))  # False\n</code></pre>"},{"location":"EndlessCheng/dfs_basics/#2316-count-unreachable-pairs-of-nodes-in-an-undirected-graph","title":"2316. Count Unreachable Pairs of Nodes in an Undirected Graph","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Union Find, Graph</p> </li> </ul> PythonCPP <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# DFS (Adjacency List)\ndef countPairsList1(n: int, edges: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = set()\n\n    def dfs(node):\n        visited.add(node)\n        size = 1\n\n        for nei in graph[node]:\n            if nei not in visited:\n                size += dfs(nei)\n\n        return size\n\n    res = 0\n    for i in range(n):\n        if i not in visited:\n            size = dfs(i)\n            res += size * (n - size)\n\n    return res // 2\n\n\n# DFS(Adjacency List)\ndef countPairsList2(n: int, edges: List[List[int]]) -&gt; int:\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = [False for _ in range(n)]\n\n    def dfs(node):\n        visited[node] = True\n        size = 1\n        for nei in graph[node]:\n            if not visited[nei]:\n                size += dfs(nei)\n        return size\n\n    res, total = 0, 0\n    for i in range(n):\n        if not visited[i]:\n            size = dfs(i)\n            res += size * total\n            total += size\n\n    return res\n\n\nn = 7\nedges = [[0, 2], [0, 5], [2, 4], [1, 6], [5, 4]]\nprint(countPairsList1(n, edges))  # 14\nprint(countPairsList2(n, edges))  # 14\n</code></pre> <pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;unordered_set&gt;\n#include &lt;functional&gt;\nusing namespace std;\n\nclass Solution\n{\npublic:\n    long long countPairs(int n, vector&lt;vector&lt;int&gt;&gt; &amp;edges)\n    {\n        unordered_map&lt;int, unordered_set&lt;int&gt;&gt; graph;\n        for (const auto &amp;edge : edges)\n        {\n            graph[edge[0]].insert(edge[1]);\n            graph[edge[1]].insert(edge[0]);\n        }\n\n        unordered_set&lt;int&gt; visited;\n\n        function&lt;int(int)&gt; dfs = [&amp;](int node) -&gt; int\n        {\n            if (visited.count(node))\n            {\n                return 0;\n            }\n            visited.insert(node);\n            int count = 1;\n            for (const auto &amp;neighbor : graph[node])\n            {\n                if (!visited.count(neighbor))\n                {\n                    count += dfs(neighbor);\n                }\n            }\n            return count;\n        };\n\n        long long res = 0;\n        long long total = n;\n\n        for (int i = 0; i &lt; n; ++i)\n        {\n            if (!visited.count(i))\n            {\n                int count = dfs(i);\n                res += count * (total - count);\n            }\n        }\n        return res / 2;\n    }\n};\n\nint main()\n{\n    Solution s;\n    vector&lt;vector&lt;int&gt;&gt; edges = {{0, 2}, {0, 5}, {2, 4}, {1, 6}, {5, 4}};\n    cout &lt;&lt; s.countPairs(7, edges) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/dfs_basics/#1319-number-of-operations-to-make-network-connected","title":"1319. Number of Operations to Make Network Connected","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Union Find, Graph</p> </li> </ul> Python <pre><code>\"\"\"\n- Return the minimum number of operations needed to make all computers connected.\n\n![1319](https://assets.leetcode.com/uploads/2020/01/02/sample_1_1677.png)\n\"\"\"\n\n\"\"\"\nEdge case: If the number of connections is less than n - 1, it is impossible to connect all the computers.\n\"\"\"\n\nfrom collections import defaultdict, deque\nfrom typing import List\n\n\n# DFS\ndef makeConnectedDFS(n: int, connections: List[List[int]]) -&gt; int:\n    if len(connections) &lt; n - 1:\n        return -1\n\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = set()\n    component_count = 0\n\n    def dfs(node):\n        for i in graph[node]:\n            if i not in visited:\n                visited.add(i)\n                dfs(i)\n\n    for i in range(n):\n        if i not in visited:\n            visited.add(i)\n            dfs(i)\n            component_count += 1\n\n    return component_count - 1\n\n\n# BFS\ndef makeConnectedBFS(n: int, connections: List[List[int]]) -&gt; int:\n    if len(connections) &lt; n - 1:\n        return -1\n\n    visited = set()\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def bfs(node):\n        q = deque([node])\n        while q:\n            cur = q.popleft()\n            for nxt in graph[cur]:\n                if nxt not in visited:\n                    q.append(nxt)\n                    visited.add(nxt)\n\n    component_count = 0\n    for i in range(n):\n        if i not in visited:\n            visited.add(i)\n            bfs(i)\n            component_count += 1\n\n    return component_count - 1\n\n\nn = 4\nconnections = [[0, 1], [0, 2], [1, 2]]\nprint(makeConnectedDFS(n, connections))  # 1\nprint(makeConnectedBFS(n, connections))  # 1\n</code></pre>"},{"location":"EndlessCheng/dfs_basics/#2492-minimum-score-of-a-path-between-two-cities","title":"2492. Minimum Score of a Path Between Two Cities","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Union Find, Graph</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# DFS\ndef minScoreDFS(n: int, roads: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n\n    res = float(\"inf\")\n    visited = set([1])\n\n    def dfs(node):\n        nonlocal res\n        for nxt, dist in graph[node]:\n            res = min(res, dist)\n            if nxt not in visited:\n                visited.add(nxt)\n                dfs(nxt)\n\n    dfs(1)\n\n    return res\n\n\nn = 4\nroads = [[1, 2, 9], [2, 3, 6], [2, 4, 5], [1, 4, 7]]\nprint(minScoreDFS(n, roads))  # 5\n</code></pre>"},{"location":"EndlessCheng/dfs_basics/#3387-maximize-amount-after-two-days-of-conversions","title":"3387. Maximize Amount After Two Days of Conversions","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Depth First Search, Breadth First Search, Graph</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# DFS\ndef maxAmount(\n    initialCurrency: str,\n    pairs1: List[List[str]],\n    rates1: List[float],\n    pairs2: List[List[str]],\n    rates2: List[float],\n) -&gt; float:\n\n    def cal_amount(pairs, rates, initialCurrency):\n        graph = defaultdict(list)\n\n        for (u, v), r in zip(pairs, rates):\n            graph[u].append((v, r))\n            graph[v].append((u, 1.0 / r))\n\n        amount = {}\n\n        def dfs(x, cur):\n            amount[x] = cur\n            for to, rate in graph[x]:\n                if to not in amount:\n                    dfs(to, cur * rate)\n\n        dfs(initialCurrency, 1.0)\n\n        return amount\n\n    day1 = cal_amount(pairs1, rates1, initialCurrency)\n    day2 = cal_amount(pairs2, rates2, initialCurrency)\n\n    return max(day1.get(x, 0.0) / a2 for x, a2 in day2.items())\n\n\nif __name__ == \"__main__\":\n    initialCurrency = \"EUR\"\n    pairs1 = [[\"EUR\", \"USD\"], [\"USD\", \"JPY\"]]\n    rates1 = [2.0, 3.0]\n    pairs2 = [[\"JPY\", \"USD\"], [\"USD\", \"CHF\"], [\"CHF\", \"EUR\"]]\n    rates2 = [4.0, 5.0, 6.0]\n\n    assert maxAmount(initialCurrency, pairs1, rates1, pairs2, rates2) == 720.0\n</code></pre>"},{"location":"EndlessCheng/dfs_basics/#3310-remove-methods-from-project","title":"3310. Remove Methods From Project","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Graph</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\nclass remainingMethods:\n    def DFS(self, n: int, k: int, invocations: List[List[int]]) -&gt; List[int]:\n        graph = defaultdict(list)\n        for i, j in invocations:\n            graph[i].append(j)\n\n        sus = set()\n\n        def dfs(node):\n            sus.add(node)\n            for adj in graph[node]:\n                if adj not in sus:\n                    dfs(adj)\n\n        dfs(k)\n\n        for i, j in invocations:\n            if i not in sus and j in sus:\n                return list(range(n))\n\n        return list(set(range(n)) - sus)\n</code></pre>"},{"location":"EndlessCheng/dfs_basics/#2685-count-the-number-of-complete-components","title":"2685. Count the Number of Complete Components","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Union Find, Graph</p> </li> </ul>"},{"location":"EndlessCheng/dfs_basics/#2192-all-ancestors-of-a-node-in-a-directed-acyclic-graph","title":"2192. All Ancestors of a Node in a Directed Acyclic Graph","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Graph, Topological Sort</p> </li> </ul>"},{"location":"EndlessCheng/dfs_basics/#924-minimize-malware-spread","title":"924. Minimize Malware Spread","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Depth First Search, Breadth First Search, Union Find, Graph</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Coloring\ndef minMalwareSpread(graph: List[List[int]], initial: List[int]) -&gt; int:\n    n = len(graph)\n    initial = set(initial)\n\n    def dfs(x):\n        visited.add(x)\n        mark[x] = 1\n        if x in initial:\n            v.append(x)\n        for nxt in range(n):\n            if graph[x][nxt] and nxt != x and not mark[nxt]:\n                dfs(nxt)\n\n    ans = min(initial)\n    mx = 0\n    mark = [0] * n\n    for i in range(n):\n        if not mark[i]:\n            visited = set()\n            v = []\n            dfs(i)\n            if len(v) == 1 and (len(visited) &gt; mx or len(visited) == mx and v[0] &lt; ans):\n                ans, mx = v[0], len(visited)\n    return ans\n\n\ngraph = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]\ninitial = [0, 1]\nprint(minMalwareSpread(graph, initial))  # 0\n</code></pre>"},{"location":"EndlessCheng/dfs_basics/#2101-detonate-the-maximum-bombs","title":"2101. Detonate the Maximum Bombs","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Depth First Search, Breadth First Search, Graph, Geometry</p> </li> </ul>"},{"location":"EndlessCheng/dfs_basics/#721-accounts-merge","title":"721. Accounts Merge","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Depth First Search, Breadth First Search, Union Find, Sorting</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef accountsMerge(accounts: List[List[str]]) -&gt; List[List[str]]:\n    parent = defaultdict(str)\n    rank = defaultdict(int)\n    email_to_name = defaultdict(str)\n    merged_accounts = defaultdict(list)\n\n    def find(n):\n        p = parent[n]\n        while p != parent[p]:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    for account in accounts:\n        name = account[0]\n        first_email = account[1]\n\n        for email in account[1:]:\n            if email not in parent:\n                parent[email] = email\n                rank[email] = 1\n            email_to_name[email] = name\n            union(first_email, email)\n\n    for email in parent:\n        root_email = find(email)\n        merged_accounts[root_email].append(email)\n\n    result = []\n    for root_email, emails in merged_accounts.items():\n        result.append([email_to_name[root_email]] + sorted(emails))\n\n    return result\n\n\naccounts = [\n    [\"John\", \"johnsmith@mail.com\", \"john_newyork@mail.com\"],\n    [\"John\", \"johnsmith@mail.com\", \"john00@mail.com\"],\n    [\"Mary\", \"mary@mail.com\"],\n    [\"John\", \"johnnybravo@mail.com\"],\n]\nprint(accountsMerge(accounts))\n# [['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],\n# ['Mary', 'mary@mail.com'],\n# ['John', 'johnnybravo@mail.com']]\n</code></pre>"},{"location":"EndlessCheng/dfs_basics/#207-course-schedule","title":"207. Course Schedule","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Graph, Topological Sort</p> </li> </ul> PythonCPP <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS (Kahn's Algorithm)\ndef canFinishBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    count = 0\n\n    while q:\n        crs = q.popleft()\n        count += 1\n\n        for nxt in graph[crs]:\n            indegree[nxt] -= 1\n\n            if indegree[nxt] == 0:\n                q.append(nxt)\n\n    return count == numCourses\n\n\n# DFS + Set\ndef canFinishDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for crs, pre in prerequisites:\n        graph[crs].append(pre)\n\n    visiting = set()\n\n    def dfs(crs):\n        if crs in visiting:  # cycle detected\n            return False\n        if graph[crs] == []:\n            return True\n\n        visiting.add(crs)\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        visiting.remove(crs)\n        graph[crs] = []\n\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\n# DFS + List\ndef canFinishDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for pre, crs in prerequisites:\n        graph[crs].append(pre)\n\n    # 0: init, 1: visiting, 2: visited\n    status = [0] * numCourses\n\n    def dfs(crs):\n        if status[crs] == 1:  # cycle detected\n            return False\n        if status[crs] == 2:\n            return True\n\n        status[crs] = 1\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        status[crs] = 2\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(canFinishBFS(5, prerequisites))  # True\nprint(canFinishDFS1(5, prerequisites))  # True\nprint(canFinishDFS2(5, prerequisites))  # True\n</code></pre> <pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    // BFS\n    bool canFinishBFS(int numCourses, vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        vector&lt;int&gt; indegree(numCourses, 0);\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n            indegree[pre[0]]++;\n        }\n\n        queue&lt;int&gt; q;\n        for (int i = 0; i &lt; numCourses; i++) {\n            if (indegree[i] == 0) {\n                q.push(i);\n            }\n        }\n\n        int cnt = 0;\n        while (!q.empty()) {\n            int cur = q.front();\n            q.pop();\n            cnt++;\n\n            for (int nxt : graph[cur]) {\n                indegree[nxt]--;\n                if (indegree[nxt] == 0) {\n                    q.push(nxt);\n                }\n            }\n        }\n        return cnt == numCourses;\n    }\n\n    // DFS\n    bool canFinishDFS(int numCourses, vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n        }\n        // 0: not visited, 1: visiting, 2: visited\n        vector&lt;int&gt; state(numCourses, 0);\n\n        function&lt;bool(int)&gt; dfs = [&amp;](int pre) -&gt; bool {\n            state[pre] = 1;  // visiting\n            for (int crs : graph[pre]) {\n                if (state[crs] == 1 || (state[crs] == 0 &amp;&amp; dfs(crs))) {\n                    return true;\n                }\n            }\n            state[pre] = 2;  // visited\n            return false;\n        };\n\n        for (int i = 0; i &lt; numCourses; i++) {\n            if (state[i] == 0 &amp;&amp; dfs(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution sol;\n    vector&lt;vector&lt;int&gt;&gt; prerequisites = {{1, 0}, {2, 1}, {3, 2}, {4, 3},\n                                         {5, 4}, {6, 5}, {7, 6}, {8, 7},\n                                         {9, 8}, {10, 9}};\n    int numCourses = 11;\n    cout &lt;&lt; sol.canFinishBFS(numCourses, prerequisites) &lt;&lt; endl;\n    cout &lt;&lt; sol.canFinishDFS(numCourses, prerequisites) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/dfs_basics/#802-find-eventual-safe-states","title":"802. Find Eventual Safe States","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Graph, Topological Sort</p> </li> </ul> Python <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# Topological Sort\ndef eventualSafeNodesTS(graph: List[List[int]]) -&gt; List[int]:\n    n = len(graph)\n    reverse_graph = defaultdict(list)\n    indegree = [0 for _ in range(n)]\n    safe = [False for _ in range(n)]\n\n    for u in range(n):\n        for v in graph[u]:\n            reverse_graph[v].append(u)\n        indegree[u] = len(graph[u])\n\n    q = deque([i for i in range(n) if indegree[i] == 0])\n\n    while q:\n        node = q.popleft()\n        safe[node] = True\n\n        for neighbor in reverse_graph[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n\n    return [i for i in range(n) if safe[i]]\n\n\n# DFS\ndef eventualSafeNodesDFS(graph: List[List[int]]) -&gt; List[int]:\n    n = len(graph)\n    state = [0 for _ in range(n)]  # 0: unvisited, 1: visiting, 2: visited\n\n    def dfs(node):\n        if state[node] &gt; 0:\n            return state[node] == 2\n        state[node] = 1\n        for neighbor in graph[node]:\n            if state[neighbor] == 1 or not dfs(neighbor):\n                return False\n        state[node] = 2\n        return True\n\n    return [i for i in range(n) if dfs(i)]\n\n\ngraph = [[1, 2], [2, 3], [5], [0], [5], [], []]\nprint(eventualSafeNodesTS(graph))  # [2, 4, 5, 6]\nprint(eventualSafeNodesDFS(graph))  # [2, 4, 5, 6]\n</code></pre>"},{"location":"EndlessCheng/dfs_basics/#928-minimize-malware-spread-ii","title":"928. Minimize Malware Spread II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Depth First Search, Breadth First Search, Union Find, Graph</p> </li> </ul>"},{"location":"EndlessCheng/dfs_basics/#2092-find-all-people-with-secret","title":"2092. Find All People With Secret","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Union Find, Graph, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/dfs_basics/#3108-minimum-cost-walk-in-weighted-graph","title":"3108. Minimum Cost Walk in Weighted Graph","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation, Union Find, Graph</p> </li> </ul>"},{"location":"EndlessCheng/dfs_basics/#261-graph-valid-tree","title":"261. Graph Valid Tree \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Union Find, Graph</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Graph\ndef validTree(n: int, edges: List[List[int]]) -&gt; bool:\n    if n == 0:\n        return False\n    if len(edges) != n - 1:\n        return False\n\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = set()\n\n    def dfs(node, parent):\n        if node in visited:\n            return False\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor != parent and not dfs(neighbor, node):\n                return False\n        return True\n\n    return dfs(0, -1) and len(visited) == n\n\n\nprint(validTree(5, [[0, 1], [0, 2], [0, 3], [1, 4]]))  # True\nprint(validTree(5, [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]))  # False\n</code></pre>"},{"location":"EndlessCheng/dfs_basics/#323-number-of-connected-components-in-an-undirected-graph","title":"323. Number of Connected Components in an Undirected Graph \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Union Find, Graph</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Union Find\ndef countComponents(n: int, edges: List[List[int]]) -&gt; int:\n    uf = UnionFind(n)\n    count = n\n\n    for u, v in edges:\n        count -= uf.union(u, v)\n\n    return count\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(n)}\n        self.rank = {i: 1 for i in range(n)}\n\n    def find(self, n):\n        p = self.par[n]\n        while self.par[p] != p:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return 0\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.par[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.par[p1] = p2\n        else:\n            self.par[p2] = p1\n            self.rank[p1] += 1\n\n        return 1\n\n\nprint(countComponents(5, [[0, 1], [1, 2], [3, 4]]))  # 2\n</code></pre>"},{"location":"EndlessCheng/distance_sum/","title":"Distance Sum","text":""},{"location":"EndlessCheng/distance_sum/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1685. Sum of Absolute Differences in a Sorted Array (Medium)</li> <li> 2615. Sum of Distances (Medium)</li> <li> 2602. Minimum Operations to Make All Array Elements Equal (Medium)</li> <li> 2968. Apply Operations to Maximize Frequency Score (Hard)</li> <li> 1703. Minimum Adjacent Swaps for K Consecutive Ones (Hard)</li> <li> 3086. Minimum Moves to Pick K Ones (Hard)</li> <li> 3422. Minimum Operations to Make Subarray Elements Equal (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/distance_sum/#1685-sum-of-absolute-differences-in-a-sorted-array","title":"1685. Sum of Absolute Differences in a Sorted Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Prefix Sum</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Prefix Sum\ndef getSumAbsoluteDifferences(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    totalSum = sum(nums)\n    prefixSum = 0\n    res = [0 for _ in range(n)]\n\n    for i in range(n):\n        leftSum = prefixSum\n        rightSum = totalSum - prefixSum - nums[i]\n\n        leftCount = i\n        rightCount = n - i - 1\n\n        res[i] = (nums[i] * leftCount - leftSum) + (rightSum - nums[i] * rightCount)\n        prefixSum += nums[i]\n\n    return res\n\n\nnums = [1, 4, 6, 8, 10]\nprint(getSumAbsoluteDifferences(nums))  # [24, 15, 13, 15, 21]\n</code></pre>"},{"location":"EndlessCheng/distance_sum/#2615-sum-of-distances","title":"2615. Sum of Distances","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/distance_sum/#2602-minimum-operations-to-make-all-array-elements-equal","title":"2602. Minimum Operations to Make All Array Elements Equal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Sorting, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/distance_sum/#2968-apply-operations-to-maximize-frequency-score","title":"2968. Apply Operations to Maximize Frequency Score","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Sliding Window, Sorting, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/distance_sum/#1703-minimum-adjacent-swaps-for-k-consecutive-ones","title":"1703. Minimum Adjacent Swaps for K Consecutive Ones","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sliding Window, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/distance_sum/#3086-minimum-moves-to-pick-k-ones","title":"3086. Minimum Moves to Pick K Ones","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sliding Window, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/distance_sum/#3422-minimum-operations-to-make-subarray-elements-equal","title":"3422. Minimum Operations to Make Subarray Elements Equal \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Sliding Window, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/double_sequence_pairing/","title":"Double Sequence Pairing","text":""},{"location":"EndlessCheng/double_sequence_pairing/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2037. Minimum Number of Moves to Seat Everyone (Easy)</li> <li> 455. Assign Cookies (Easy)</li> <li> 2410. Maximum Matching of Players With Trainers (Medium)</li> <li> 1433. Check If a String Can Break Another String (Medium)</li> <li> 870. Advantage Shuffle (Medium)</li> <li> 826. Most Profit Assigning Work (Medium)</li> <li> 2449. Minimum Number of Operations to Make Arrays Similar (Hard)</li> <li> 1889. Minimum Space Wasted From Packaging (Hard)</li> <li> 2561. Rearranging Fruits (Hard)</li> <li> 2323. Find Minimum Time to Finish All Jobs II (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/double_sequence_pairing/#2037-minimum-number-of-moves-to-seat-everyone","title":"2037. Minimum Number of Moves to Seat Everyone","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting, Counting Sort</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the minimum number of moves needed to seat everyone.\n\"\"\"\n\nfrom typing import List\n\n\n# Greedy\ndef minMovesToSeat(seats: List[int], students: List[int]) -&gt; int:\n    seats.sort()\n    students.sort()\n    moves = 0\n\n    for i, j in zip(seats, students):\n        moves += abs(i - j)\n\n    return moves\n\n\nprint(minMovesToSeat([3, 1, 5], [2, 7, 4]))  # 4\n</code></pre>"},{"location":"EndlessCheng/double_sequence_pairing/#455-assign-cookies","title":"455. Assign Cookies","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Greedy, Sorting</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the maximum number of your content children that can be satisfied.\n\"\"\"\n\nfrom typing import List\n\n\n# Greedy\ndef findContentChildren(g: List[int], s: List[int]) -&gt; int:\n    g.sort()\n    s.sort()\n    i, j = 0, 0\n\n    while i &lt; len(g) and j &lt; len(s):\n        if g[i] &lt;= s[j]:\n            i += 1\n        j += 1\n\n    return i\n\n\n# |-------------|-------------|--------------|\n# |   Approach  |    Time     |    Space     |\n# |-------------|-------------|--------------|\n# |   Greedy    | O(N * logN) |    O(1)      |\n# |-------------|-------------|--------------|\n\n\ng = [1, 2, 3]\ns = [1, 1]\nprint(findContentChildren(g, s))  # 1\n</code></pre>"},{"location":"EndlessCheng/double_sequence_pairing/#2410-maximum-matching-of-players-with-trainers","title":"2410. Maximum Matching of Players With Trainers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/double_sequence_pairing/#1433-check-if-a-string-can-break-another-string","title":"1433. Check If a String Can Break Another String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/double_sequence_pairing/#870-advantage-shuffle","title":"870. Advantage Shuffle","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/double_sequence_pairing/#826-most-profit-assigning-work","title":"826. Most Profit Assigning Work","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/double_sequence_pairing/#2449-minimum-number-of-operations-to-make-arrays-similar","title":"2449. Minimum Number of Operations to Make Arrays Similar","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/double_sequence_pairing/#1889-minimum-space-wasted-from-packaging","title":"1889. Minimum Space Wasted From Packaging","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Sorting, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/double_sequence_pairing/#2561-rearranging-fruits","title":"2561. Rearranging Fruits","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Greedy</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\ndef minCost(basket1: List[int], basket2: List[int]) -&gt; int:\n    cnt = defaultdict(int)\n    for x, y in zip(basket1, basket2):\n        cnt[x] += 1\n        cnt[y] -= 1\n\n    a, b = [], []\n    for x, c in cnt.items():\n        if c % 2:\n            return -1\n\n        if c &gt; 0:\n            a.extend([x] * (c // 2))\n        else:\n            b.extend([x] * (-c // 2))\n\n    a.sort()\n    b.sort(reverse=True)\n    mn = min(cnt)\n\n    return sum(min(x, y, mn * 2) for x, y in zip(a, b))\n\n\nif __name__ == \"__main__\":\n    basket1 = [4, 2, 2, 2]\n    basket2 = [1, 4, 1, 2]\n    assert minCost(basket1, basket2) == 1\n</code></pre>"},{"location":"EndlessCheng/double_sequence_pairing/#2323-find-minimum-time-to-finish-all-jobs-ii","title":"2323. Find Minimum Time to Finish All Jobs II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/dp_0-1_knapsack/","title":"DP 0-1 Knapsack","text":""},{"location":"EndlessCheng/dp_0-1_knapsack/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2915. Length of the Longest Subsequence That Sums to Target (Medium)</li> <li> 416. Partition Equal Subset Sum (Medium)</li> <li> 494. Target Sum (Medium)</li> <li> 2787. Ways to Express an Integer as Sum of Powers (Medium)</li> <li> 3180. Maximum Total Reward Using Operations I (Medium)</li> <li> 474. Ones and Zeroes (Medium)</li> <li> 1049. Last Stone Weight II (Medium)</li> <li> 1774. Closest Dessert Cost (Medium)</li> <li> 879. Profitable Schemes (Hard)</li> <li> 3082. Find the Sum of the Power of All Subsequences (Hard)</li> <li> 956. Tallest Billboard (Hard)</li> <li> 2518. Number of Great Partitions (Hard)</li> <li> 2742. Painting the Walls (Hard)</li> <li> 3287. Find the Maximum Sequence Value of Array (Hard)</li> <li> 2291. Maximum Profit From Trading Stocks (Medium) \ud83d\udc51</li> <li> 2431. Maximize Total Tastiness of Purchased Fruits (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/dp_0-1_knapsack/#2915-length-of-the-longest-subsequence-that-sums-to-target","title":"2915. Length of the Longest Subsequence That Sums to Target","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_0-1_knapsack/#416-partition-equal-subset-sum","title":"416. Partition Equal Subset Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>from functools import cache\nfrom typing import List\n\nfrom leetpattern.utils import knapsack01\n\n\n# Memoization\ndef canPartitionMemoization(nums: List[int]) -&gt; bool:\n    total = sum(nums)\n    n = len(nums)\n\n    if total % 2 == 1 or n &lt;= 1:\n        return False\n\n    @cache\n    def dfs(i, j):\n        if i &lt; 0:\n            return j == 0\n        return j &gt;= nums[i] and dfs(i - 1, j - nums[i]) or dfs(i - 1, j)\n\n    return dfs(n - 1, total // 2)\n\n\n# DP - Knapsack 01\ndef canPartitionTemplate(nums: List[int]) -&gt; bool:\n    total = sum(nums)\n\n    if total % 2 == 1 or len(nums) &lt; 2:\n        return False\n\n    target = total // 2\n\n    return knapsack01(nums, nums, target) == target\n\n\n# DP - Knapsack 01\ndef canPartition(nums: List[int]) -&gt; bool:\n    total = sum(nums)\n\n    if total % 2 == 1 or len(nums) &lt; 2:\n        return False\n\n    target = total // 2\n\n    dp = [0 for _ in range(target + 1)]\n\n    for i in range(len(nums)):\n        for j in range(target, nums[i] - 1, -1):\n            dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])\n\n    return dp[target] == target\n\n\nif __name__ == \"__main__\":\n    nums = [1, 5, 11, 5]\n    print(canPartitionTemplate(nums))  # True\n    print(canPartition(nums))  # True\n    print(canPartitionMemoization(nums))  # True\n</code></pre>"},{"location":"EndlessCheng/dp_0-1_knapsack/#494-target-sum","title":"494. Target Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Backtracking</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef findTargetSumWays(nums: List[int], target: int) -&gt; int:\n\n    totalSum = sum(nums)\n\n    if abs(target) &gt; totalSum:\n        return 0\n    if (target + totalSum) % 2 == 1:\n        return 0\n\n    targetSum = (target + totalSum) // 2\n    dp = [0] * (targetSum + 1)\n    dp[0] = 1\n\n    for i in range(len(nums)):\n        for j in range(targetSum, nums[i] - 1, -1):\n            dp[j] += dp[j - nums[i]]\n\n    return dp[targetSum]\n\n\nnums = [1, 1, 1, 1, 1]\ntarget = 3\nprint(findTargetSumWays(nums, target))  # 5\n</code></pre>"},{"location":"EndlessCheng/dp_0-1_knapsack/#2787-ways-to-express-an-integer-as-sum-of-powers","title":"2787. Ways to Express an Integer as Sum of Powers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_0-1_knapsack/#3180-maximum-total-reward-using-operations-i","title":"3180. Maximum Total Reward Using Operations I","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_0-1_knapsack/#474-ones-and-zeroes","title":"474. Ones and Zeroes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef findMaxForm(strs: List[str], m: int, n: int) -&gt; int:\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for s in strs:\n        zerosNum = s.count(\"0\")\n        onesNum = len(s) - zerosNum\n\n        for i in range(m, zerosNum - 1, -1):\n            for j in range(n, onesNum - 1, -1):\n                dp[i][j] = max(dp[i][j], dp[i - zerosNum][j - onesNum] + 1)\n\n    return dp[m][n]\n\n\nstrs = [\"10\", \"0001\", \"111001\", \"1\", \"0\"]\nm = 5\nn = 3\nprint(findMaxForm(strs, m, n))  # 4\n</code></pre>"},{"location":"EndlessCheng/dp_0-1_knapsack/#1049-last-stone-weight-ii","title":"1049. Last Stone Weight II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef lastStoneWeightII(stones: List[int]) -&gt; int:\n    target = sum(stones) // 2\n\n    dp = [0 for _ in range(target + 1)]\n\n    for i in range(len(stones)):\n        for j in range(target, stones[i] - 1, -1):\n            dp[j] = max(dp[j], dp[j - stones[i]] + stones[i])\n\n    result = (sum(stones) - dp[target]) - dp[target]\n\n    return result\n\n\nstones = [2, 7, 4, 1, 8, 1]\nprint(lastStoneWeightII(stones))  # 1\n</code></pre>"},{"location":"EndlessCheng/dp_0-1_knapsack/#1774-closest-dessert-cost","title":"1774. Closest Dessert Cost","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Backtracking</p> </li> </ul>"},{"location":"EndlessCheng/dp_0-1_knapsack/#879-profitable-schemes","title":"879. Profitable Schemes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_0-1_knapsack/#3082-find-the-sum-of-the-power-of-all-subsequences","title":"3082. Find the Sum of the Power of All Subsequences","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_0-1_knapsack/#956-tallest-billboard","title":"956. Tallest Billboard","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_0-1_knapsack/#2518-number-of-great-partitions","title":"2518. Number of Great Partitions","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_0-1_knapsack/#2742-painting-the-walls","title":"2742. Painting the Walls","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_0-1_knapsack/#3287-find-the-maximum-sequence-value-of-array","title":"3287. Find the Maximum Sequence Value of Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/dp_0-1_knapsack/#2291-maximum-profit-from-trading-stocks","title":"2291. Maximum Profit From Trading Stocks \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_0-1_knapsack/#2431-maximize-total-tastiness-of-purchased-fruits","title":"2431. Maximize Total Tastiness of Purchased Fruits \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_1d/","title":"DP 1D","text":""},{"location":"EndlessCheng/dp_1d/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2944. Minimum Number of Coins for Fruits (Medium)</li> <li> 2140. Solving Questions With Brainpower (Medium)</li> <li> 983. Minimum Cost For Tickets (Medium)</li> <li> 2901. Longest Unequal Adjacent Groups Subsequence II (Medium)</li> <li> 3144. Minimum Substring Partition of Equal Character Frequency (Medium)</li> <li> 871. Minimum Number of Refueling Stops (Hard)</li> <li> 2896. Apply Operations to Make Two Strings Equal (Medium)</li> <li> 2167. Minimum Time to Remove All Cars Containing Illegal Goods (Hard)</li> <li> 2188. Minimum Time to Finish the Race (Hard)</li> <li> 3389. Minimum Operations to Make Character Frequencies Equal (Hard)</li> <li> 3205. Maximum Array Hopping Score I (Medium) \ud83d\udc51</li> <li> 1259. Handshakes That Don't Cross (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/dp_1d/#2944-minimum-number-of-coins-for-fruits","title":"2944. Minimum Number of Coins for Fruits","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Queue, Heap Priority Queue, Monotonic Queue</p> </li> </ul>"},{"location":"EndlessCheng/dp_1d/#2140-solving-questions-with-brainpower","title":"2140. Solving Questions With Brainpower","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>from functools import cache\nfrom typing import List\n\n\n# Memoization\ndef mostPoints(questions: List[List[int]]) -&gt; int:\n    @cache\n    def dfs(i: int) -&gt; int:\n        if i &gt;= len(questions):\n            return 0\n        return max(dfs(i + 1), dfs(i + questions[i][1] + 1) + questions[i][0])\n\n    return dfs(0)\n\n\nif __name__ == \"__main__\":\n    questions = [[3, 2], [4, 3], [4, 4], [2, 5]]\n    print(mostPoints(questions))  # 5\n</code></pre>"},{"location":"EndlessCheng/dp_1d/#983-minimum-cost-for-tickets","title":"983. Minimum Cost For Tickets","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP\ndef mincostTickets(days: List[int], costs: List[int]) -&gt; int:\n    last = days[-1]\n    dayset = set(days)\n    dp = [0 for _ in range(last + 1)]\n\n    for i in range(1, last + 1):\n        if i not in dayset:\n            dp[i] = dp[i - 1]\n        else:\n            dp[i] = min(\n                dp[i - 1] + costs[0],\n                dp[max(0, i - 7)] + costs[1],\n                dp[max(0, i - 30)] + costs[2],\n            )\n\n    return dp[last]\n\n\ndays = [1, 4, 6, 7, 8, 20]\ncosts = [2, 7, 15]\nprint(mincostTickets(days, costs))  # 11\n</code></pre>"},{"location":"EndlessCheng/dp_1d/#2901-longest-unequal-adjacent-groups-subsequence-ii","title":"2901. Longest Unequal Adjacent Groups Subsequence II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_1d/#3144-minimum-substring-partition-of-equal-character-frequency","title":"3144. Minimum Substring Partition of Equal Character Frequency","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Dynamic Programming, Counting</p> </li> </ul>"},{"location":"EndlessCheng/dp_1d/#871-minimum-number-of-refueling-stops","title":"871. Minimum Number of Refueling Stops","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/dp_1d/#2896-apply-operations-to-make-two-strings-equal","title":"2896. Apply Operations to Make Two Strings Equal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_1d/#2167-minimum-time-to-remove-all-cars-containing-illegal-goods","title":"2167. Minimum Time to Remove All Cars Containing Illegal Goods","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_1d/#2188-minimum-time-to-finish-the-race","title":"2188. Minimum Time to Finish the Race","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_1d/#3389-minimum-operations-to-make-character-frequencies-equal","title":"3389. Minimum Operations to Make Character Frequencies Equal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Dynamic Programming, Counting, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/dp_1d/#3205-maximum-array-hopping-score-i","title":"3205. Maximum Array Hopping Score I \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Stack, Greedy, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/dp_1d/#1259-handshakes-that-dont-cross","title":"1259. Handshakes That Don't Cross \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_climbing_stairs/","title":"DP Climbing Stairs","text":""},{"location":"EndlessCheng/dp_climbing_stairs/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 70. Climbing Stairs (Easy)</li> <li> 746. Min Cost Climbing Stairs (Easy)</li> <li> 377. Combination Sum IV (Medium)</li> <li> 2466. Count Ways To Build Good Strings (Medium)</li> <li> 2266. Count Number of Texts (Medium)</li> <li> 2533. Number of Good Binary Strings (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/dp_climbing_stairs/#70-climbing-stairs","title":"70. Climbing Stairs","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Memoization</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return the number of distinct ways to reach the top of the stairs.\n- `dp[n]` stores the number of distinct ways to reach the `n-th` stair.\n- Formula: `dp[n] = dp[n - 1] + dp[n - 2]`.\n- Initialize `dp[0] = 0`, `dp[1] = 1`, and `dp[2] = 2`.\n\"\"\"\n\nfrom functools import cache\n\n\n# DP\ndef climbStairsDP(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    dp = [i for i in range(n + 1)]\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\n# DP (Optimized)\ndef climbStairsDPOptimized(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    first, second = 1, 2\n\n    for _ in range(3, n + 1):\n        first, second = second, first + second\n\n    return second\n\n\n# Recursion\ndef climbStairsRecursion(n: int) -&gt; int:\n    @cache\n    def dfs(i: int) -&gt; int:\n        if i &lt;= 1:\n            return 1\n        return dfs(i - 1) + dfs(i - 2)\n\n    return dfs(n)\n\n\n# Greedy\ndef climbStairsGreedy(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    p1, p2 = 1, 2\n\n    for _ in range(3, n + 1):\n        p1, p2 = p2, p1 + p2\n\n    return p2\n\n\nif __name__ == \"__main__\":\n    assert climbStairsDP(10) == 89\n    assert climbStairsDPOptimized(10) == 89\n    assert climbStairsRecursion(10) == 89\n    assert climbStairsGreedy(10) == 89\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nint climbStairs(int n) {\n    if (n &lt;= 2) return n;\n    int f1 = 1, f2 = 2;\n    int res;\n\n    int i = 3;\n    while (i &lt;= n) {\n        res = f1 + f2;\n        f1 = f2;\n        f2 = res;\n        i++;\n    }\n    return res;\n}\n\nint main() {\n    assert(climbStairs(2) == 2);\n    assert(climbStairs(5) == 8);\n    assert(climbStairs(10) == 89);\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/dp_climbing_stairs/#746-min-cost-climbing-stairs","title":"746. Min Cost Climbing Stairs","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the minimum cost to reach the top of the stairs.\n\n-   `dp[n]` stores the &lt;u&gt;minimum cost&lt;/u&gt; to reach the `n-th` stair.\n-   Formula: `dp[n] = cost[n] + min(dp[n - 1], dp[n - 2])`.\n-   Initialize `dp[0] = cost[0]` and `dp[1] = cost[1]`.\n-   Return `min(dp[-1], dp[-2])`.\n\n-   Example: `cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]`\n\n|  n  | `cost[n]` | `dp[n-2]` | `dp[n-1]` | `dp[n]` |\n| :-: | :-------: | :-------: | :-------: | :-----: |\n|  0  |     1     |     -     |     -     |    1    |\n|  1  |    100    |     -     |     1     |   100   |\n|  2  |     1     |     1     |    100    |    2    |\n|  3  |     1     |    100    |     2     |    3    |\n|  4  |     1     |     2     |     3     |    3    |\n|  5  |    100    |     3     |     3     |   103   |\n|  6  |     1     |     3     |    103    |    4    |\n|  7  |     1     |    103    |     4     |    5    |\n|  8  |    100    |     4     |     5     |   104   |\n|  9  |     1     |     5     |    104    |    6    |\n\"\"\"\n\nfrom typing import List\n\n\ndef minCostClimbingStairs(cost: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(cost))]\n\n    dp[0], dp[1] = cost[0], cost[1]\n\n    for i in range(2, len(cost)):\n        dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]\n    print(dp)\n    return min(dp[-1], dp[-2])\n\n\ncost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]\nprint(minCostClimbingStairs(cost))  # 6\n</code></pre>"},{"location":"EndlessCheng/dp_climbing_stairs/#377-combination-sum-iv","title":"377. Combination Sum IV","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef combinationSum4(nums: List[int], target: int) -&gt; int:\n    dp = [0 for _ in range(target + 1)]\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for j in range(len(nums)):\n            if i - nums[j] &gt;= 0:\n                dp[i] += dp[i - nums[j]]\n\n        return dp[target]\n\n\nnums = [1, 2, 3]\ntarget = 4\nprint(combinationSum4(nums, target))  # 7\n</code></pre>"},{"location":"EndlessCheng/dp_climbing_stairs/#2466-count-ways-to-build-good-strings","title":"2466. Count Ways To Build Good Strings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_climbing_stairs/#2266-count-number-of-texts","title":"2266. Count Number of Texts","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Math, String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_climbing_stairs/#2533-number-of-good-binary-strings","title":"2533. Number of Good Binary Strings \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_complete_knapsack/","title":"DP Complete Knapsack","text":""},{"location":"EndlessCheng/dp_complete_knapsack/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 322. Coin Change (Medium)</li> <li> 518. Coin Change II (Medium)</li> <li> 279. Perfect Squares (Medium)</li> <li> 1449. Form Largest Integer With Digits That Add up to Target (Hard)</li> <li> 3183. The Number of Ways to Make the Sum (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/dp_complete_knapsack/#322-coin-change","title":"322. Coin Change","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Breadth First Search</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef coinChange(coins: List[int], amount: int) -&gt; int:\n    dp = [float(\"inf\") for _ in range(amount + 1)]\n\n    dp[0] = 0\n\n    for i in range(1, amount + 1):\n        for c in coins:\n            if i - c &gt;= 0:\n                dp[i] = min(dp[i], 1 + dp[i - c])\n\n    return dp[amount] if dp[amount] != float(\"inf\") else -1\n\n\ncoins = [1, 2, 5]\namount = 11\nprint(coinChange(coins, amount))  # 3\n</code></pre>"},{"location":"EndlessCheng/dp_complete_knapsack/#518-coin-change-ii","title":"518. Coin Change II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef change(amount: int, coins: List[int]) -&gt; int:\n    dp = [0 for _ in range(amount + 1)]\n    dp[0] = 1\n\n    for i in range(len(coins)):\n        for j in range(coins[i], amount + 1):\n            dp[j] += dp[j - coins[i]]\n\n    return dp[-1]\n\n\namount = 5\ncoins = [1, 2, 5]\nprint(change(amount, coins))  # 4\n</code></pre>"},{"location":"EndlessCheng/dp_complete_knapsack/#279-perfect-squares","title":"279. Perfect Squares","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Breadth First Search</p> </li> </ul> Python <pre><code>import math\n\n\n# DP - Knapsack Unbounded\ndef numSquares(n: int) -&gt; int:\n    dp = [float(\"inf\") for _ in range(n + 1)]\n    dp[0] = 0\n\n    for i in range(1, n + 1):\n        for j in range(1, int(math.sqrt(n)) + 1):\n            dp[i] = min(dp[i], dp[i - j**2] + 1)\n\n    return dp[n]\n\n\nn = 12\nprint(numSquares(n))  # 3\n</code></pre>"},{"location":"EndlessCheng/dp_complete_knapsack/#1449-form-largest-integer-with-digits-that-add-up-to-target","title":"1449. Form Largest Integer With Digits That Add up to Target","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_complete_knapsack/#3183-the-number-of-ways-to-make-the-sum","title":"3183. The Number of Ways to Make the Sum \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_constrained_number_of_partitions/","title":"DP Constrained Number of Partitions","text":""},{"location":"EndlessCheng/dp_constrained_number_of_partitions/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 410. Split Array Largest Sum (Hard)</li> <li> 813. Largest Sum of Averages (Medium)</li> <li> 1278. Palindrome Partitioning III (Hard)</li> <li> 1745. Palindrome Partitioning IV (Hard)</li> <li> 1335. Minimum Difficulty of a Job Schedule (Hard)</li> <li> 1473. Paint House III (Hard)</li> <li> 2209. Minimum White Tiles After Covering With Carpets (Hard)</li> <li> 1478. Allocate Mailboxes (Hard)</li> <li> 1959. Minimum Total Space Wasted With K Resizing Operations (Medium)</li> <li> 2478. Number of Beautiful Partitions (Hard)</li> <li> 3077. Maximum Strength of K Disjoint Subarrays (Hard)</li> <li> 2911. Minimum Changes to Make K Semi-palindromes (Hard)</li> <li> 3117. Minimum Sum of Values by Dividing Array (Hard)</li> </ul>"},{"location":"EndlessCheng/dp_constrained_number_of_partitions/#410-split-array-largest-sum","title":"410. Split Array Largest Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Dynamic Programming, Greedy, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/dp_constrained_number_of_partitions/#813-largest-sum-of-averages","title":"813. Largest Sum of Averages","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/dp_constrained_number_of_partitions/#1278-palindrome-partitioning-iii","title":"1278. Palindrome Partitioning III","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul> Python <pre><code># DP\ndef palindromePartition(s: str, k: int) -&gt; int:\n    n = len(s)\n    min_change = [[0] * n for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        for j in range(i + 1, n):\n            min_change[i][j] = min_change[i + 1][j - 1] + (1 if s[i] != s[j] else 0)\n\n    dp = min_change[0]\n    for i in range(1, k):\n        for right in range(n - k + i, i - 1, -1):\n            dp[right] = min(\n                dp[left - 1] + min_change[left][right] for left in range(i, right + 1)\n            )\n\n    return dp[-1]\n\n\ns = \"aabbc\"\nk = 3\nprint(palindromePartition(s, k))  # 0\n</code></pre>"},{"location":"EndlessCheng/dp_constrained_number_of_partitions/#1745-palindrome-partitioning-iv","title":"1745. Palindrome Partitioning IV","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul> Python <pre><code># DP\ndef checkPartitioning(s: str) -&gt; bool:\n    def palidrome_partition(s, k):\n        n = len(s)\n        min_change = [[0] * n for _ in range(n)]\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 1, n):\n                min_change[i][j] = min_change[i + 1][j - 1] + (1 if s[i] != s[j] else 0)\n\n        dp = min_change[0]\n\n        for i in range(1, k):\n            for right in range(n - k + i, i - 1, -1):\n                dp[right] = min(\n                    dp[left - 1] + min_change[left][right] for left in range(i, right + 1)\n                )\n\n        return dp[-1]\n\n    return palidrome_partition(s, 3) == 0\n\n\ns = \"abcbdd\"\nprint(checkPartitioning(s))  # True\n</code></pre>"},{"location":"EndlessCheng/dp_constrained_number_of_partitions/#1335-minimum-difficulty-of-a-job-schedule","title":"1335. Minimum Difficulty of a Job Schedule","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_constrained_number_of_partitions/#1473-paint-house-iii","title":"1473. Paint House III","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_constrained_number_of_partitions/#2209-minimum-white-tiles-after-covering-with-carpets","title":"2209. Minimum White Tiles After Covering With Carpets","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/dp_constrained_number_of_partitions/#1478-allocate-mailboxes","title":"1478. Allocate Mailboxes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/dp_constrained_number_of_partitions/#1959-minimum-total-space-wasted-with-k-resizing-operations","title":"1959. Minimum Total Space Wasted With K Resizing Operations","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_constrained_number_of_partitions/#2478-number-of-beautiful-partitions","title":"2478. Number of Beautiful Partitions","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_constrained_number_of_partitions/#3077-maximum-strength-of-k-disjoint-subarrays","title":"3077. Maximum Strength of K Disjoint Subarrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/dp_constrained_number_of_partitions/#2911-minimum-changes-to-make-k-semi-palindromes","title":"2911. Minimum Changes to Make K Semi-palindromes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_constrained_number_of_partitions/#3117-minimum-sum-of-values-by-dividing-array","title":"3117. Minimum Sum of Values by Dividing Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Dynamic Programming, Bit Manipulation, Segment Tree, Queue</p> </li> </ul>"},{"location":"EndlessCheng/dp_digit/","title":"DP Digit","text":""},{"location":"EndlessCheng/dp_digit/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2719. Count of Integers (Hard)</li> <li> 1742. Maximum Number of Balls in a Box (Easy)</li> <li> 2843.   Count Symmetric Integers (Easy)</li> <li> 788. Rotated Digits (Medium)</li> <li> 902. Numbers At Most N Given Digit Set (Hard)</li> <li> 600. Non-negative Integers without Consecutive Ones (Hard)</li> <li> 2376. Count Special Integers (Hard)</li> <li> 1012. Numbers With Repeated Digits (Hard)</li> <li> 357. Count Numbers with Unique Digits (Medium)</li> <li> 2827. Number of Beautiful Integers in the Range (Hard)</li> <li> 2999. Count the Number of Powerful Integers (Hard)</li> <li> 2801. Count Stepping Numbers in Range (Hard)</li> <li> 3352. Count K-Reducible Numbers Less Than N (Hard)</li> <li> 1397. Find All Good Strings (Hard)</li> <li> 3348. Smallest Divisible Digit Product II (Hard)</li> <li> 1215. Stepping Numbers (Medium) \ud83d\udc51</li> <li> 1067. Digit Count in Range (Hard) \ud83d\udc51</li> <li> 3032. Count Numbers With Unique Digits II (Easy) \ud83d\udc51</li> <li> 233. Number of Digit One (Hard)</li> <li> 3007. Maximum Number That Sum of the Prices Is Less Than or Equal to K (Medium)</li> </ul>"},{"location":"EndlessCheng/dp_digit/#2719-count-of-integers","title":"2719. Count of Integers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_digit/#1742-maximum-number-of-balls-in-a-box","title":"1742. Maximum Number of Balls in a Box","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Math, Counting</p> </li> </ul>"},{"location":"EndlessCheng/dp_digit/#2843-count-symmetric-integers","title":"2843.   Count Symmetric Integers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/dp_digit/#788-rotated-digits","title":"788. Rotated Digits","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_digit/#902-numbers-at-most-n-given-digit-set","title":"902. Numbers At Most N Given Digit Set","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, String, Binary Search, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_digit/#600-non-negative-integers-without-consecutive-ones","title":"600. Non-negative Integers without Consecutive Ones","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_digit/#2376-count-special-integers","title":"2376. Count Special Integers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_digit/#1012-numbers-with-repeated-digits","title":"1012. Numbers With Repeated Digits","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_digit/#357-count-numbers-with-unique-digits","title":"357. Count Numbers with Unique Digits","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Backtracking</p> </li> </ul>"},{"location":"EndlessCheng/dp_digit/#2827-number-of-beautiful-integers-in-the-range","title":"2827. Number of Beautiful Integers in the Range","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_digit/#2999-count-the-number-of-powerful-integers","title":"2999. Count the Number of Powerful Integers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_digit/#2801-count-stepping-numbers-in-range","title":"2801. Count Stepping Numbers in Range","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_digit/#3352-count-k-reducible-numbers-less-than-n","title":"3352. Count K-Reducible Numbers Less Than N","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String, Dynamic Programming, Combinatorics</p> </li> </ul>"},{"location":"EndlessCheng/dp_digit/#1397-find-all-good-strings","title":"1397. Find All Good Strings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, String Matching</p> </li> </ul>"},{"location":"EndlessCheng/dp_digit/#3348-smallest-divisible-digit-product-ii","title":"3348. Smallest Divisible Digit Product II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String, Backtracking, Greedy, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/dp_digit/#1215-stepping-numbers","title":"1215. Stepping Numbers \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Backtracking, Breadth First Search</p> </li> </ul>"},{"location":"EndlessCheng/dp_digit/#1067-digit-count-in-range","title":"1067. Digit Count in Range \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_digit/#3032-count-numbers-with-unique-digits-ii","title":"3032. Count Numbers With Unique Digits II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Math, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_digit/#233-number-of-digit-one","title":"233. Number of Digit One","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Recursion</p> </li> </ul>"},{"location":"EndlessCheng/dp_digit/#3007-maximum-number-that-sum-of-the-prices-is-less-than-or-equal-to-k","title":"3007. Maximum Number That Sum of the Prices Is Less Than or Equal to K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Binary Search, Dynamic Programming, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/dp_fenwick_tree_segment_tree/","title":"DP Fenwick Tree Segment Tree","text":""},{"location":"EndlessCheng/dp_fenwick_tree_segment_tree/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1626. Best Team With No Conflicts (Medium)</li> <li> 2407. Longest Increasing Subsequence II (Hard)</li> <li> 2770. Maximum Number of Jumps to Reach the Last Index (Medium)</li> <li> 2926. Maximum Balanced Subsequence Sum (Hard)</li> <li> 2916. Subarrays Distinct Element Sum of Squares II (Hard)</li> <li> 3410. Maximize Subarray Sum After Removing All Occurrences of One Element (Hard)</li> </ul>"},{"location":"EndlessCheng/dp_fenwick_tree_segment_tree/#1626-best-team-with-no-conflicts","title":"1626. Best Team With No Conflicts","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Sorting</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP - LIS\ndef bestTeamScore(scores: List[int], ages: List[int]) -&gt; int:\n    n = len(scores)\n    pairs = sorted(zip(scores, ages))  # sort\n    dp = [0 for _ in range(n)]\n\n    # LIS\n    for i in range(n):\n        for j in range(i):\n            if pairs[i][1] &gt;= pairs[j][1]:\n                dp[i] = max(dp[i], dp[j])\n        dp[i] += pairs[i][0]\n\n    return max(dp)\n\n\nif __name__ == \"__main__\":\n    assert bestTeamScore([1, 3, 5, 10, 15], [1, 2, 3, 4, 5]) == 34\n    assert bestTeamScore([4, 5, 6, 5], [2, 1, 2, 1]) == 16\n</code></pre>"},{"location":"EndlessCheng/dp_fenwick_tree_segment_tree/#2407-longest-increasing-subsequence-ii","title":"2407. Longest Increasing Subsequence II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Divide And Conquer, Dynamic Programming, Binary Indexed Tree, Segment Tree, Queue, Monotonic Queue</p> </li> </ul>"},{"location":"EndlessCheng/dp_fenwick_tree_segment_tree/#2770-maximum-number-of-jumps-to-reach-the-last-index","title":"2770. Maximum Number of Jumps to Reach the Last Index","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_fenwick_tree_segment_tree/#2926-maximum-balanced-subsequence-sum","title":"2926. Maximum Balanced Subsequence Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Dynamic Programming, Binary Indexed Tree, Segment Tree</p> </li> </ul>"},{"location":"EndlessCheng/dp_fenwick_tree_segment_tree/#2916-subarrays-distinct-element-sum-of-squares-ii","title":"2916. Subarrays Distinct Element Sum of Squares II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Binary Indexed Tree, Segment Tree</p> </li> </ul>"},{"location":"EndlessCheng/dp_fenwick_tree_segment_tree/#3410-maximize-subarray-sum-after-removing-all-occurrences-of-one-element","title":"3410. Maximize Subarray Sum After Removing All Occurrences of One Element","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Segment Tree</p> </li> </ul>"},{"location":"EndlessCheng/dp_game_theory/","title":"DP Game Theory","text":""},{"location":"EndlessCheng/dp_game_theory/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1025. Divisor Game (Easy)</li> <li> 877. Stone Game (Medium)</li> <li> 486. Predict the Winner (Medium)</li> <li> 1510. Stone Game IV (Hard)</li> <li> 1690. Stone Game VII (Medium)</li> <li> 1406. Stone Game III (Hard)</li> <li> 1140. Stone Game II (Medium)</li> <li> 1563. Stone Game V (Hard)</li> <li> 464. Can I Win (Medium)</li> <li> 1872. Stone Game VIII (Hard)</li> <li> 913. Cat and Mouse (Hard)</li> <li> 1728. Cat and Mouse II (Hard)</li> <li> 294. Flip Game II (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/dp_game_theory/#1025-divisor-game","title":"1025. Divisor Game","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Brainteaser, Game Theory</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return `True` if Alice wins the game, assuming both players play optimally.\n-   `dp[n]` stores the result of the game when the number is `n`.\n-   Initialize `dp[1] = False`.\n\"\"\"\n\n\n# DP\ndef divisorGameDP(n: int) -&gt; bool:\n    if n &lt;= 1:\n        return False\n\n    dp = [False for _ in range(n + 1)]\n\n    for i in range(2, n + 1):\n        for j in range(1, i):\n            if i % j == 0 and not dp[i - j]:\n                dp[i] = True\n                break\n\n    return dp[n]\n\n\n# Math\ndef divisorGameDPMath(n: int) -&gt; bool:\n    return n % 2 == 0\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |  DP         |      O(n^2)     |    O(n)      |\n# |  Math       |      O(1)       |    O(1)      |\n# |-------------|-----------------|--------------|\n\nn = 2\nprint(divisorGameDP(n))  # True\nprint(divisorGameDPMath(n))  # True\n</code></pre>"},{"location":"EndlessCheng/dp_game_theory/#877-stone-game","title":"877. Stone Game","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Game Theory</p> </li> </ul>"},{"location":"EndlessCheng/dp_game_theory/#486-predict-the-winner","title":"486. Predict the Winner","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Recursion, Game Theory</p> </li> </ul>"},{"location":"EndlessCheng/dp_game_theory/#1510-stone-game-iv","title":"1510. Stone Game IV","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Game Theory</p> </li> </ul>"},{"location":"EndlessCheng/dp_game_theory/#1690-stone-game-vii","title":"1690. Stone Game VII","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Game Theory</p> </li> </ul>"},{"location":"EndlessCheng/dp_game_theory/#1406-stone-game-iii","title":"1406. Stone Game III","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Game Theory</p> </li> </ul>"},{"location":"EndlessCheng/dp_game_theory/#1140-stone-game-ii","title":"1140. Stone Game II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Prefix Sum, Game Theory</p> </li> </ul>"},{"location":"EndlessCheng/dp_game_theory/#1563-stone-game-v","title":"1563. Stone Game V","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Game Theory</p> </li> </ul>"},{"location":"EndlessCheng/dp_game_theory/#464-can-i-win","title":"464. Can I Win","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Bit Manipulation, Memoization, Game Theory, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_game_theory/#1872-stone-game-viii","title":"1872. Stone Game VIII","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Prefix Sum, Game Theory</p> </li> </ul>"},{"location":"EndlessCheng/dp_game_theory/#913-cat-and-mouse","title":"913. Cat and Mouse","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Graph, Topological Sort, Memoization, Game Theory</p> </li> </ul>"},{"location":"EndlessCheng/dp_game_theory/#1728-cat-and-mouse-ii","title":"1728. Cat and Mouse II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Graph, Topological Sort, Memoization, Matrix, Game Theory</p> </li> </ul>"},{"location":"EndlessCheng/dp_game_theory/#294-flip-game-ii","title":"294. Flip Game II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Backtracking, Memoization, Game Theory</p> </li> </ul>"},{"location":"EndlessCheng/dp_graph/","title":"DP Graph","text":""},{"location":"EndlessCheng/dp_graph/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3243. Shortest Distance After Road Addition Queries I (Medium)</li> <li> 787. Cheapest Flights Within K Stops (Medium)</li> <li> 1786. Number of Restricted Paths From First to Last Node (Medium)</li> <li> 2050. Parallel Courses III (Hard)</li> <li> 1976. Number of Ways to Arrive at Destination (Medium)</li> <li> 1857. Largest Color Value in a Directed Graph (Hard)</li> <li> 1928. Minimum Cost to Reach Destination in Time (Hard)</li> <li> 913. Cat and Mouse (Hard)</li> <li> 1728. Cat and Mouse II (Hard)</li> <li> 1548. The Most Similar Path in a Graph (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/dp_graph/#3243-shortest-distance-after-road-addition-queries-i","title":"3243. Shortest Distance After Road Addition Queries I","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Breadth First Search, Graph</p> </li> </ul> Python <pre><code>\"\"\"\n- `n=5`, `queries = [[2,4],[0,2],[0,4]]`\n- ![1](https://assets.leetcode.com/uploads/2024/06/28/image8.jpg)\n- ![2](https://assets.leetcode.com/uploads/2024/06/28/image9.jpg)\n- ![3](https://assets.leetcode.com/uploads/2024/06/28/image10.jpg)\n- Output: `[3,2,1]`\n\"\"\"\n\nfrom collections import deque\nfrom itertools import count\nfrom typing import List\n\n\n# BFS\ndef shortestDistanceAfterQueries(n: int, queries: List[List[int]]) -&gt; List[int]:\n    g = [[] for _ in range(n)]\n    for i in range(n - 1):\n        g[i].append(i + 1)\n\n    vis = [-1 for _ in range(n)]\n\n    def bfs(i: int) -&gt; int:\n        q = deque([0])\n        for step in count(1):\n            tmp = q\n            q = deque()\n            for x in tmp:\n                for y in g[x]:\n                    if y == n - 1:\n                        return step\n                    if vis[y] != i:\n                        vis[y] = i\n                        q.append(y)\n        return -1\n\n    res = [0] * len(queries)\n    for i, (l, r) in enumerate(queries):\n        g[l].append(r)\n        res[i] = bfs(i)\n\n    return res\n\n\nn = 5\nqueries = [[2, 4], [0, 2], [0, 4]]\nprint(shortestDistanceAfterQueries(n, queries))  # [3, 2, 1]\n</code></pre>"},{"location":"EndlessCheng/dp_graph/#787-cheapest-flights-within-k-stops","title":"787. Cheapest Flights Within K Stops","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Depth First Search, Breadth First Search, Graph, Heap Priority Queue, Shortest Path</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return the cheapest price from `src` to `dst` with at most `K` stops.\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/5eIK3zUdYmE?si=aBR0VbHXTgNuVlGz\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen&gt;&lt;/iframe&gt;\n\"\"\"\n\nimport heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Bellman-Ford\ndef findCheapestPriceBF(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    prices = [float(\"inf\") for _ in range(n)]\n    prices[src] = 0\n\n    for _ in range(k + 1):\n        temp = prices[:]\n        for u, v, w in flights:\n            temp[v] = min(temp[v], prices[u] + w)\n        prices = temp\n\n    return prices[dst] if prices[dst] != float(\"inf\") else -1\n\n\n# Dijkstra\ndef findCheapestPriceDijkstra(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in flights:\n        graph[u].append((v, w))\n\n    heap = [(0, src, 0)]  # (price, city, stops)\n    visited = defaultdict(int)  # {city: stops}\n\n    while heap:\n        price, city, stops = heapq.heappop(heap)\n\n        if city == dst:\n            return price\n\n        if stops &gt; k:\n            continue\n\n        if city in visited and visited[city] &lt;= stops:\n            continue\n\n        visited[city] = stops\n\n        for neighbor, cost in graph[city]:\n            heapq.heappush(heap, (price + cost, neighbor, stops + 1))\n\n    return -1\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |Bellman-Ford|    O(k * E)      |  O(n)   |\n# | Dijkstra   | O(E * log(V))    |  O(n)   |\n# |------------|------------------|---------|\n\n\nn = 4\nflights = [[0, 1, 100], [1, 2, 100], [2, 0, 100], [1, 3, 600], [2, 3, 200]]\nsrc = 0\ndst = 3\nk = 1\nprint(findCheapestPriceBF(n, flights, src, dst, k))  # 700\nprint(findCheapestPriceDijkstra(n, flights, src, dst, k))  # 700\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;climits&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass FindCheapestPrice {\n   public:\n    int bellman_ford(int n, vector&lt;vector&lt;int&gt;&gt;&amp; flights, int src, int dst,\n                     int k) {\n        vector&lt;int&gt; dist(n, INT_MAX);\n        dist[src] = 0;\n\n        for (int i = 0; i &lt;= k; ++i) {\n            vector&lt;int&gt; temp(dist);\n            for (auto&amp; flight : flights) {\n                int u = flight[0], v = flight[1], w = flight[2];\n                if (dist[u] != INT_MAX &amp;&amp; dist[u] + w &lt; temp[v]) {\n                    temp[v] = dist[u] + w;\n                }\n            }\n            dist = temp;\n        }\n        return dist[dst] == INT_MAX ? -1 : dist[dst];\n    }\n\n    int dijkstra(int n, vector&lt;vector&lt;int&gt;&gt;&amp; flights, int src, int dst, int k) {\n        vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; graph(n);\n        for (auto&amp; flight : flights) {\n            graph[flight[0]].push_back({flight[1], flight[2]});\n        }\n        priority_queue&lt;array&lt;int, 3&gt;, vector&lt;array&lt;int, 3&gt;&gt;,\n                       greater&lt;array&lt;int, 3&gt;&gt;&gt;\n            min_heap;\n        min_heap.push({0, src, k + 1});\n\n        while (!min_heap.empty()) {\n            auto [cost, u, stops] = min_heap.top();\n            min_heap.pop();\n            if (u == dst) {\n                return cost;\n            }\n            if (stops &gt; 0) {\n                for (auto&amp; [v, w] : graph[u]) {\n                    min_heap.push({cost + w, v, stops - 1});\n                }\n            }\n        }\n\n        return -1;\n    }\n};\n\nint main() {\n    FindCheapestPrice solution;\n    int n = 4;\n    vector&lt;vector&lt;int&gt;&gt; flights = {\n        {0, 1, 100}, {1, 2, 100}, {2, 0, 100}, {1, 3, 600}, {2, 3, 200}};\n    int src = 0, dst = 3, k = 1;\n    assert(solution.bellman_ford(n, flights, src, dst, k) == 700);\n    assert(solution.dijkstra(n, flights, src, dst, k) == 700);\n\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/dp_graph/#1786-number-of-restricted-paths-from-first-to-last-node","title":"1786. Number of Restricted Paths From First to Last Node","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Graph, Topological Sort, Heap Priority Queue, Shortest Path</p> </li> </ul>"},{"location":"EndlessCheng/dp_graph/#2050-parallel-courses-iii","title":"2050. Parallel Courses III","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Graph, Topological Sort</p> </li> </ul>"},{"location":"EndlessCheng/dp_graph/#1976-number-of-ways-to-arrive-at-destination","title":"1976. Number of Ways to Arrive at Destination","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Graph, Topological Sort, Shortest Path</p> </li> </ul> Python <pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra\ndef countPaths(n: int, roads: List[List[int]]) -&gt; int:\n    mod = 10**9 + 7\n    graph = [[] for _ in range(n)]\n    for u, v, w in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n\n    dist = [float(\"inf\") for _ in range(n)]\n    dist[0] = 0\n    count = [0 for _ in range(n)]\n    count[0] = 1\n\n    heap = [(0, 0)]\n\n    while heap:\n        d, u = heapq.heappop(heap)\n        if d &gt; dist[u]:\n            continue\n\n        for v, w in graph[u]:\n            if dist[u] + w &lt; dist[v]:\n                dist[v] = dist[u] + w\n                count[v] = count[u]\n                heapq.heappush(heap, (dist[v], v))\n            elif dist[u] + w == dist[v]:\n                count[v] += count[u]\n                count[v] %= mod\n\n    return count[-1]\n\n\nn = 7\nroads = [\n    [0, 6, 7],\n    [0, 1, 2],\n    [1, 2, 3],\n    [1, 3, 3],\n    [6, 3, 3],\n    [3, 5, 1],\n    [6, 5, 1],\n    [2, 5, 1],\n    [0, 4, 5],\n    [4, 6, 2],\n]\nprint(countPaths(n, roads))  # 4\n</code></pre>"},{"location":"EndlessCheng/dp_graph/#1857-largest-color-value-in-a-directed-graph","title":"1857. Largest Color Value in a Directed Graph","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Dynamic Programming, Graph, Topological Sort, Memoization, Counting</p> </li> </ul> Python <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# Topological Sort\ndef largestPathValue(colors: str, edges: List[List[int]]) -&gt; int:\n    n = len(colors)\n    graph = defaultdict(list)\n    indegree = [0 for _ in range(n)]\n\n    for u, v in edges:\n        graph[u].append(v)\n        indegree[v] += 1\n\n    q = deque([i for i in range(n) if indegree[i] == 0])\n\n    dp = [[0] * 26 for _ in range(n)]\n\n    for i in range(n):\n        dp[i][ord(colors[i]) - ord(\"a\")] = 1\n\n    processed, max_color = 0, 0\n\n    while q:\n        n1 = q.popleft()\n        processed += 1\n        max_color = max(max_color, max(dp[n1]))\n\n        for n2 in graph[n1]:\n            indegree[n2] -= 1\n            for i in range(26):\n                dp[n2][i] = max(\n                    dp[n2][i],\n                    dp[n1][i] + (1 if i == ord(colors[n2]) - ord(\"a\") else 0),\n                )\n            if indegree[n2] == 0:\n                q.append(n2)\n\n    return max_color if processed == n else -1\n\n\ncolors = \"abaca\"\nedges = [[0, 1], [0, 2], [2, 3], [3, 4]]\nprint(largestPathValue(colors, edges))  # 3\n</code></pre>"},{"location":"EndlessCheng/dp_graph/#1928-minimum-cost-to-reach-destination-in-time","title":"1928. Minimum Cost to Reach Destination in Time","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Graph</p> </li> </ul>"},{"location":"EndlessCheng/dp_graph/#913-cat-and-mouse","title":"913. Cat and Mouse","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Graph, Topological Sort, Memoization, Game Theory</p> </li> </ul>"},{"location":"EndlessCheng/dp_graph/#1728-cat-and-mouse-ii","title":"1728. Cat and Mouse II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Graph, Topological Sort, Memoization, Matrix, Game Theory</p> </li> </ul>"},{"location":"EndlessCheng/dp_graph/#1548-the-most-similar-path-in-a-graph","title":"1548. The Most Similar Path in a Graph \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Graph</p> </li> </ul>"},{"location":"EndlessCheng/dp_grid_advanced/","title":"DP Grid Advanced","text":""},{"location":"EndlessCheng/dp_grid_advanced/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1594. Maximum Non Negative Product in a Matrix (Medium)</li> <li> 1301. Number of Paths with Max Score (Hard)</li> <li> 2435. Paths in Matrix Whose Sum Is Divisible by K (Hard)</li> <li> 174. Dungeon Game (Hard)</li> <li> 329. Longest Increasing Path in a Matrix (Hard)</li> <li> 2328. Number of Increasing Paths in a Grid (Hard)</li> <li> 2267.  Check if There Is a Valid Parentheses String Path (Hard)</li> <li> 1937. Maximum Number of Points with Cost (Medium)</li> <li> 3363. Find the Maximum Number of Fruits Collected (Hard)</li> <li> 1463. Cherry Pickup II (Hard)</li> <li> 741. Cherry Pickup (Hard)</li> <li> 3459. Length of Longest V-Shaped Diagonal Segment (Hard)</li> <li> 2510. Check if There is a Path With Equal Number of 0's And 1's (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/dp_grid_advanced/#1594-maximum-non-negative-product-in-a-matrix","title":"1594. Maximum Non Negative Product in a Matrix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/dp_grid_advanced/#1301-number-of-paths-with-max-score","title":"1301. Number of Paths with Max Score","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/dp_grid_advanced/#2435-paths-in-matrix-whose-sum-is-divisible-by-k","title":"2435. Paths in Matrix Whose Sum Is Divisible by K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/dp_grid_advanced/#174-dungeon-game","title":"174. Dungeon Game","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/dp_grid_advanced/#329-longest-increasing-path-in-a-matrix","title":"329. Longest Increasing Path in a Matrix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Depth First Search, Breadth First Search, Graph, Topological Sort, Memoization, Matrix</p> </li> </ul> Python <pre><code>from collections import deque\nfrom functools import cache\nfrom typing import List\n\n\n# BFS - Topological Sort\ndef longestIncreasingPathBFS(matrix: List[List[int]]) -&gt; int:\n    if not matrix:\n        return 0\n\n    m, n = len(matrix), len(matrix[0])\n    dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    # Calculate indegrees and initialize queue in one pass\n    indegree = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            for dr, dc in dirs:\n                nr, nc = i + dr, j + dc\n                if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and matrix[nr][nc] &gt; matrix[i][j]:\n                    indegree[nr][nc] += 1\n\n    # Start with cells that have no smaller neighbors\n    queue = deque((i, j) for i in range(m) for j in range(n) if indegree[i][j] == 0)\n\n    res = 0\n    while queue:\n        res += 1\n        for _ in range(len(queue)):\n            r, c = queue.popleft()\n            for dr, dc in dirs:\n                nr, nc = r + dr, c + dc\n                if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and matrix[nr][nc] &gt; matrix[r][c]:\n                    indegree[nr][nc] -= 1\n                    if indegree[nr][nc] == 0:\n                        queue.append((nr, nc))\n\n    return res\n\n\n# DP - 2D\ndef longestIncreasingPath(matrix: List[List[int]]) -&gt; int:\n    if not matrix:\n        return 0\n\n    m, n = len(matrix), len(matrix[0])\n    dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    @cache\n    def dfs(r, c):\n        path = 1\n        for dr, dc in dirs:\n            nr, nc = r + dr, c + dc\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and matrix[nr][nc] &gt; matrix[r][c]:\n                path = max(path, dfs(nr, nc) + 1)\n        return path\n\n    res = 0\n    for i in range(m):\n        for j in range(n):\n            res = max(res, dfs(i, j))\n\n    return res\n\n\nif __name__ == \"__main__\":\n    matrix = [[9, 9, 4], [6, 6, 8], [2, 1, 1]]\n    assert longestIncreasingPath(matrix) == 4\n    assert longestIncreasingPathBFS(matrix) == 4\n</code></pre>"},{"location":"EndlessCheng/dp_grid_advanced/#2328-number-of-increasing-paths-in-a-grid","title":"2328. Number of Increasing Paths in a Grid","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Depth First Search, Breadth First Search, Graph, Topological Sort, Memoization, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/dp_grid_advanced/#2267-check-if-there-is-a-valid-parentheses-string-path","title":"2267.  Check if There Is a Valid Parentheses String Path","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/dp_grid_advanced/#1937-maximum-number-of-points-with-cost","title":"1937. Maximum Number of Points with Cost","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/dp_grid_advanced/#3363-find-the-maximum-number-of-fruits-collected","title":"3363. Find the Maximum Number of Fruits Collected","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/dp_grid_advanced/#1463-cherry-pickup-ii","title":"1463. Cherry Pickup II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/dp_grid_advanced/#741-cherry-pickup","title":"741. Cherry Pickup","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/dp_grid_advanced/#3459-length-of-longest-v-shaped-diagonal-segment","title":"3459. Length of Longest V-Shaped Diagonal Segment","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Memoization, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/dp_grid_advanced/#2510-check-if-there-is-a-path-with-equal-number-of-0s-and-1s","title":"2510. Check if There is a Path With Equal Number of 0's And 1's \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/dp_grid_basics/","title":"DP Grid Basics","text":""},{"location":"EndlessCheng/dp_grid_basics/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 64. Minimum Path Sum (Medium)</li> <li> 62. Unique Paths (Medium)</li> <li> 63. Unique Paths II (Medium)</li> <li> 120. Triangle (Medium)</li> <li> 3393. Count Paths With the Given XOR Value (Medium)</li> <li> 931. Minimum Falling Path Sum (Medium)</li> <li> 2684. Maximum Number of Moves in a Grid (Medium)</li> <li> 2304. Minimum Path Cost in a Grid (Medium)</li> <li> 1289. Minimum Falling Path Sum II (Hard)</li> <li> 3418. Maximum Amount of Money Robot Can Earn (Medium)</li> </ul>"},{"location":"EndlessCheng/dp_grid_basics/#64-minimum-path-sum","title":"64. Minimum Path Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Matrix</p> </li> </ul> Python <pre><code>from functools import cache\nfrom typing import List\n\n\n# Iterative\ndef minPathSum(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n\n    # init\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = grid[i][0] + dp[i - 1][0]\n    for j in range(1, n):\n        dp[0][j] = grid[0][j] + dp[0][j - 1]\n\n    # update\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[-1][-1]\n\n\n# Recursive\ndef minPathSumDFS(grid: List[List[int]]) -&gt; int:\n    INF = 10**18\n\n    @cache\n    def dfs(i, j):\n        if i &lt; 0 or j &lt; 0:\n            return INF\n        if i == 0 and j == 0:\n            return grid[i][j]\n        return min(dfs(i, j - 1), dfs(i - 1, j)) + grid[i][j]\n\n    return dfs(len(grid) - 1, len(grid[0]) - 1)\n\n\ngrid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\nprint(minPathSum(grid))  # 7\nprint(minPathSumDFS(grid))  # 7\n</code></pre>"},{"location":"EndlessCheng/dp_grid_basics/#62-unique-paths","title":"62. Unique Paths","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Combinatorics</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Count the number of unique paths to reach the bottom-right corner of a `m x n` grid.\n\n![62](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)\n\"\"\"\n\n\n# DP - 2D\ndef uniquePaths(m: int, n: int) -&gt; int:\n    if m == 1 or n == 1:\n        return 1\n\n    dp = [[1] * n for _ in range(m)]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]\n\n\nprint(uniquePaths(m=3, n=7))  # 28\n# [[1, 1, 1,  1,  1,  1,  1],\n#  [1, 2, 3,  4,  5,  6,  7],\n#  [1, 3, 6, 10, 15, 21, 28]]\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint uniquePaths(int m, int n) {\n    vector dp(m, vector&lt;int&gt;(n, 1));\n\n    for (int i = 1; i &lt; m; i++) {\n        for (int j = 1; j &lt; n; j++) {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n\n    return dp[m - 1][n - 1];\n}\n\nint main() {\n    int m = 3, n = 7;\n    cout &lt;&lt; uniquePaths(m, n) &lt;&lt; endl;  // 28\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/dp_grid_basics/#63-unique-paths-ii","title":"63. Unique Paths II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Matrix</p> </li> </ul> Python <pre><code>from functools import cache\nfrom typing import List\n\n\nclass UniquePathsWithObstacles:\n    def memoization(self, obstacleGrid: List[List[int]]) -&gt; int:\n        \"\"\"\n        Approach: DFS with Memoization\n        Time complexity: O(mn).\n        Space complexity: O(mn).\n        \"\"\"\n\n        @cache\n        def dfs(i: int, j: int) -&gt; int:\n            if i &lt; 0 or j &lt; 0 or obstacleGrid[i][j]:\n                return 0\n            if i == 0 and j == 0:\n                return 1\n            return dfs(i - 1, j) + dfs(i, j - 1)\n\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\n        return dfs(m - 1, n - 1)\n\n    def dp_2d(self, obstacleGrid: List[List[int]]) -&gt; int:\n        \"\"\"\n        Approach: 2D Dynamic Programming\n        Time complexity: O(mn).\n        Space complexity: O(mn).\n        \"\"\"\n        # edge cases\n        if obstacleGrid[0][0] == 1 or obstacleGrid[-1][-1] == 1:\n            return 0\n\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\n\n        # init dp\n        dp = [[0] * n for _ in range(m)]\n\n        for i in range(m):\n            if obstacleGrid[i][0] == 0:\n                dp[i][0] = 1\n            else:\n                break\n\n        for j in range(n):\n            if obstacleGrid[0][j] == 0:\n                dp[0][j] = 1\n            else:\n                break\n\n        # update dp\n        for i in range(1, m):\n            for j in range(1, n):\n                if obstacleGrid[i][j] == 1:\n                    continue\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n        return dp[-1][-1]\n\n    def dp_1d(self, obstacleGrid: List[List[int]]) -&gt; int:\n        \"\"\"\n        Approach: 1D Dynamic Programming\n        Time complexity: O(mn).\n        Space complexity: O(n).\n        \"\"\"\n        n = len(obstacleGrid[0])\n        dp = [0] * (n + 1)\n        dp[1] = 1\n\n        for row in obstacleGrid:\n            for j, x in enumerate(row):\n                if x == 0:\n                    dp[j + 1] += dp[j]\n                else:\n                    dp[j + 1] = 0\n        return dp[n]\n\n\nif __name__ == \"__main__\":\n    solution = UniquePathsWithObstacles()\n    obstacleGrid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n    assert solution.dp_2d(obstacleGrid) == 2\n    assert solution.memoization(obstacleGrid) == 2\n    assert solution.dp_1d(obstacleGrid) == 2\n</code></pre>"},{"location":"EndlessCheng/dp_grid_basics/#120-triangle","title":"120. Triangle","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>from functools import cache\nfrom typing import List\n\n\nclass Solution:\n    # Recursive\n    def minimumTotalRecursive(self, triangle: List[List[int]]) -&gt; int:\n        n = len(triangle)\n\n        @cache\n        def dfs(i, j):\n            if i == n - 1:\n                return triangle[i][j]\n            return min(dfs(i + 1, j), dfs(i + 1, j + 1)) + triangle[i][j]\n\n        return dfs(0, 0)\n\n    # Iterative\n    def minimumTotalIterative(self, triangle: List[List[int]]) -&gt; int:\n        for i in range(len(triangle) - 2, -1, -1):\n            for j in range(i + 1):\n                triangle[i][j] += min(triangle[i + 1][j], triangle[i + 1][j + 1])\n        return triangle[0][0]\n\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    triangle = [[2], [3, 4], [6, 5, 7], [4, 1, 8, 3]]\n    assert solution.minimumTotalRecursive(triangle) == 11\n    assert solution.minimumTotalIterative(triangle) == 11\n</code></pre>"},{"location":"EndlessCheng/dp_grid_basics/#3393-count-paths-with-the-given-xor-value","title":"3393. Count Paths With the Given XOR Value","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Bit Manipulation, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/dp_grid_basics/#931-minimum-falling-path-sum","title":"931. Minimum Falling Path Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/dp_grid_basics/#2684-maximum-number-of-moves-in-a-grid","title":"2684. Maximum Number of Moves in a Grid","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Matrix</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DFS\ndef maxMovesDFS(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    res = 0\n\n    def dfs(r, c):\n        nonlocal res\n        res = max(res, c)\n        if res == n - 1:\n            return\n\n        for k in r - 1, r, r + 1:\n            if 0 &lt;= k &lt; m and grid[k][c + 1] &gt; grid[r][c]:\n                dfs(k, c + 1)\n        grid[r][c] = 0\n\n    for i in range(m):\n        dfs(i, 0)\n\n    return res\n\n\ngrid = [[2, 4, 3, 5], [5, 4, 9, 3], [3, 4, 2, 11], [10, 9, 13, 15]]\nprint(maxMovesDFS(grid))  # 3\n</code></pre>"},{"location":"EndlessCheng/dp_grid_basics/#2304-minimum-path-cost-in-a-grid","title":"2304. Minimum Path Cost in a Grid","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/dp_grid_basics/#1289-minimum-falling-path-sum-ii","title":"1289. Minimum Falling Path Sum II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/dp_grid_basics/#3418-maximum-amount-of-money-robot-can-earn","title":"3418. Maximum Amount of Money Robot Can Earn","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/dp_grouped_knapsack/","title":"DP Grouped Knapsack","text":""},{"location":"EndlessCheng/dp_grouped_knapsack/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1155. Number of Dice Rolls With Target Sum (Medium)</li> <li> 1981. Minimize the Difference Between Target and Chosen Elements (Medium)</li> <li> 2218. Maximum Value of K Coins From Piles (Hard)</li> </ul>"},{"location":"EndlessCheng/dp_grouped_knapsack/#1155-number-of-dice-rolls-with-target-sum","title":"1155. Number of Dice Rolls With Target Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_grouped_knapsack/#1981-minimize-the-difference-between-target-and-chosen-elements","title":"1981. Minimize the Difference Between Target and Chosen Elements","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/dp_grouped_knapsack/#2218-maximum-value-of-k-coins-from-piles","title":"2218. Maximum Value of K Coins From Piles","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/dp_house_robber/","title":"DP House Robber","text":""},{"location":"EndlessCheng/dp_house_robber/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 198. House Robber (Medium)</li> <li> 740. Delete and Earn (Medium)</li> <li> 2320. Count Number of Ways to Place Houses (Medium)</li> <li> 213. House Robber II (Medium)</li> <li> 3186. Maximum Total Damage With Spell Casting (Medium)</li> </ul>"},{"location":"EndlessCheng/dp_house_robber/#198-house-robber","title":"198. House Robber","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> PythonCPP <pre><code>from functools import cache\nfrom typing import List\n\n\nclass Rob:\n    \"\"\"\n    dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n    \"\"\"\n\n    def incursive(self, nums: List[int]) -&gt; int:\n        \"\"\"\n        time complexity: O(n)\n        space complexity: O(n)\n        \"\"\"\n        n = len(nums)\n        if n &lt;= 2:\n            return max(nums)\n\n        # init\n        dp = [0 for _ in range(n)]\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n        # update\n        for i in range(2, n):\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n        return dp[-1]\n\n    def incursive_optimized(self, nums: List[int]) -&gt; int:\n        \"\"\"\n        time complexity: O(n)\n        space complexity: O(1)\n        \"\"\"\n        f0, f1 = 0, 0\n\n        for num in nums:\n            f0, f1 = f1, max(f1, f0 + num)\n\n        return f1\n\n    def memoization(self, nums: List[int]) -&gt; int:\n        \"\"\"\n        time complexity: O(n)\n        space complexity: O(n)\n        \"\"\"\n        n = len(nums)\n\n        @cache\n        def dp(i: int) -&gt; int:\n            if i &lt; 0:\n                return 0\n            return max(dp(i - 1), dp(i - 2) + nums[i])\n\n        return dp(n - 1)\n\n\nif __name__ == \"__main__\":\n    nums = [2, 7, 9, 3, 1]\n    rob = Rob()\n    assert rob.incursive(nums) == 12\n    assert rob.incursive_optimized(nums) == 12\n    assert rob.memoization(nums) == 12\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint rob(vector&lt;int&gt; &amp;nums) {\n    int prev = 0, cur = 0, temp = 0;\n\n    for (int num : nums) {\n        temp = cur;\n        cur = max(cur, prev + num);\n        prev = temp;\n    }\n    return cur;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {2, 7, 9, 3, 1};\n    cout &lt;&lt; rob(nums) &lt;&lt; endl;  // 12\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/dp_house_robber/#740-delete-and-earn","title":"740. Delete and Earn","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP (House Robber)\ndef deleteAndEarn(nums: List[int]) -&gt; int:\n    def rob(nums):\n        f0, f1 = 0, 0\n        for x in nums:\n            f0, f1 = f1, max(f1, f0 + x)\n        return f1\n\n    res = [0 for _ in range(max(nums) + 1)]\n\n    for x in nums:\n        res[x] += x\n\n    return rob(res)\n\n\nnums = [2, 2, 3, 3, 3, 4]\nprint(deleteAndEarn(nums))  # 9\n</code></pre>"},{"location":"EndlessCheng/dp_house_robber/#2320-count-number-of-ways-to-place-houses","title":"2320. Count Number of Ways to Place Houses","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_house_robber/#213-house-robber-ii","title":"213. House Robber II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return the maximum amount of money that can be robbed from the houses arranged in a circle.\n-   Circular \u2192 Linear: `nums[0]` and `nums[-1]` cannot be robbed together.\n-   Rob from `0` to `n - 2`\n\n|  n  | `nums[n]` | `dp[n-2]` | `dp[n-1]` | `dp[n-2] + nums[n]` | `dp[n]` |\n| :-: | :-------: | :-------: | :-------: | :-----------------: | :-----: |\n|  0  |     2     |     -     |     2     |          -          |    2    |\n|  1  |     7     |     -     |     7     |          -          |    7    |\n|  2  |     9     |     2     |     7     |         11          |   11    |\n|  3  |     3     |     7     |    11     |         10          |   11    |\n\n-   Rob from `1` to `n - 1`\n\n|  n  | `nums[n]` | `dp[n-2]` | `dp[n-1]` | `dp[n-2] + nums[n]` | `dp[n]` |\n| :-: | :-------: | :-------: | :-------: | :-----------------: | :-----: |\n|  1  |     7     |     -     |     -     |          -          |    7    |\n|  2  |     9     |     -     |     7     |          -          |    9    |\n|  3  |     3     |     7     |     9     |         10          |   10    |\n|  4  |     1     |     9     |    10     |         10          |   10    |\n\"\"\"\n\nfrom typing import List\n\n\n# DP\ndef rob(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 3:\n        return max(nums)\n\n    def robLinear(nums: List[int]) -&gt; int:\n        dp = [0 for _ in range(len(nums))]\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n        return dp[-1]\n\n    # circle -&gt; linear\n    a = robLinear(nums[1:])  # 2nd house to the last house\n    b = robLinear(nums[:-1])  # 1st house to the 2nd last house\n\n    return max(a, b)\n\n\nnums = [2, 7, 9, 3, 1]\nprint(rob(nums))  # 11\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// DP\nint robDP(vector&lt;int&gt;&amp; nums) {\n    int n = nums.size();\n    if (n &lt;= 3) return *max_element(nums.begin(), nums.end());\n\n    vector&lt;int&gt; dp1(n, 0), dp2(n, 0);\n\n    dp1[0] = nums[0];\n    dp2[1] = max(nums[0], nums[1]);\n    for (int i = 2; i &lt; n - 1; i++) {\n        dp1[i] = max(dp1[i - 1], dp1[i - 2] + nums[i]);\n    }\n\n    dp2[1] = nums[1];\n    dp2[2] = max(nums[1], nums[2]);\n    for (int i = 3; i &lt; n; i++) {\n        dp1[i] = max(dp1[i - 1], dp1[i - 2] + nums[i]);\n    }\n\n    return max(dp1[n - 2], dp2[n - 1]);\n}\n\n// DP (Space Optimized)\nint robDPOptimized(vector&lt;int&gt;&amp; nums) {\n    int n = nums.size();\n    if (n &lt;= 3) return *max_element(nums.begin(), nums.end());\n\n    int f1 = nums[0];\n    int f2 = max(nums[0], nums[1]);\n    int res1;\n    for (int i = 2; i &lt; n - 1; i++) {\n        res1 = max(f2, f1 + nums[i]);\n        f1 = f2;\n        f2 = res1;\n    }\n\n    f1 = nums[1];\n    f2 = max(nums[1], nums[2]);\n    int res2;\n    for (int i = 3; i &lt; n; i++) {\n        res2 = max(f2, f1 + nums[i]);\n        f1 = f2;\n        f2 = res2;\n    }\n\n    return max(res1, res2);\n}\n\nint main() {\n    vector&lt;int&gt; nums = {2, 3, 2};\n    cout &lt;&lt; robDP(nums) &lt;&lt; endl;           // 3\n    cout &lt;&lt; robDPOptimized(nums) &lt;&lt; endl;  // 3\n\n    nums = {1, 2, 3, 1};\n    cout &lt;&lt; robDP(nums) &lt;&lt; endl;           // 4\n    cout &lt;&lt; robDPOptimized(nums) &lt;&lt; endl;  // 4\n\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/dp_house_robber/#3186-maximum-total-damage-with-spell-casting","title":"3186. Maximum Total Damage With Spell Casting","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Two Pointers, Binary Search, Dynamic Programming, Sorting, Counting</p> </li> </ul>"},{"location":"EndlessCheng/dp_jump_game/","title":"DP Jump Game","text":""},{"location":"EndlessCheng/dp_jump_game/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1306. Jump Game III (Medium)</li> <li> 2770. Maximum Number of Jumps to Reach the Last Index (Medium)</li> <li> 403. Frog Jump (Hard)</li> <li> 1340. Jump Game V (Hard)</li> <li> 1871. Jump Game VII (Medium)</li> <li> 1696. Jump Game VI (Medium)</li> <li> 975. Odd Even Jump (Hard)</li> <li> 1654. Minimum Jumps to Reach Home (Medium)</li> <li> 656. Coin Path (Hard) \ud83d\udc51</li> <li> 2297. Jump Game VIII (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/dp_jump_game/#1306-jump-game-iii","title":"1306. Jump Game III","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef canReach(arr: List[int], start: int) -&gt; bool:\n    n = len(arr)\n    visited = [False for _ in range(n)]\n    q = deque([start])\n\n    while q:\n        i = q.popleft()\n\n        if arr[i] == 0:\n            return True\n\n        visited[i] = True\n\n        for j in [i - arr[i], i + arr[i]]:\n            if j in range(n) and not visited[j]:\n                q.append(j)\n\n    return False\n\n\narr = [4, 2, 3, 0, 3, 1, 2]\nstart = 5\nprint(canReach(arr, start))  # True\n</code></pre>"},{"location":"EndlessCheng/dp_jump_game/#2770-maximum-number-of-jumps-to-reach-the-last-index","title":"2770. Maximum Number of Jumps to Reach the Last Index","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_jump_game/#403-frog-jump","title":"403. Frog Jump","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_jump_game/#1340-jump-game-v","title":"1340. Jump Game V","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/dp_jump_game/#1871-jump-game-vii","title":"1871. Jump Game VII","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Sliding Window, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/dp_jump_game/#1696-jump-game-vi","title":"1696. Jump Game VI","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Queue, Heap Priority Queue, Monotonic Queue</p> </li> </ul>"},{"location":"EndlessCheng/dp_jump_game/#975-odd-even-jump","title":"975. Odd Even Jump","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Stack, Monotonic Stack, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/dp_jump_game/#1654-minimum-jumps-to-reach-home","title":"1654. Minimum Jumps to Reach Home","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Breadth First Search</p> </li> </ul>"},{"location":"EndlessCheng/dp_jump_game/#656-coin-path","title":"656. Coin Path \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_jump_game/#2297-jump-game-viii","title":"2297. Jump Game VIII \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Stack, Graph, Monotonic Stack, Shortest Path</p> </li> </ul>"},{"location":"EndlessCheng/dp_lcs_advanced/","title":"DP LCS Advanced","text":""},{"location":"EndlessCheng/dp_lcs_advanced/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3290. Maximum Multiplication Score (Medium)</li> <li> 115. Distinct Subsequences (Hard)</li> <li> 3316. Find Maximum Removals From Source String (Medium)</li> <li> 1639. Number of Ways to Form a Target String Given a Dictionary (Hard)</li> <li> 97. Interleaving String (Medium)</li> <li> 1092. Shortest Common Supersequence  (Hard)</li> <li> 44. Wildcard Matching (Hard)</li> <li> 10. Regular Expression Matching (Hard)</li> </ul>"},{"location":"EndlessCheng/dp_lcs_advanced/#3290-maximum-multiplication-score","title":"3290. Maximum Multiplication Score","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_lcs_advanced/#115-distinct-subsequences","title":"115. Distinct Subsequences","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul> Python <pre><code>def numDistinct(s: str, t: str) -&gt; int:\n    m = len(s)\n    n = len(t)\n    dp = [[0] * (n + 1) for _ in range((m + 1))]\n\n    for i in range(m):\n        dp[i][0] = 1\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                # include and exclude s[i-1]\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]  # exclude s[i-1]\n\n    return dp[-1][-1]\n\n\ns = \"rabbbit\"\nt = \"rabbit\"\nprint(numDistinct(s, t))  # 3\n</code></pre>"},{"location":"EndlessCheng/dp_lcs_advanced/#3316-find-maximum-removals-from-source-string","title":"3316. Find Maximum Removals From Source String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Two Pointers, String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_lcs_advanced/#1639-number-of-ways-to-form-a-target-string-given-a-dictionary","title":"1639. Number of Ways to Form a Target String Given a Dictionary","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_lcs_advanced/#97-interleaving-string","title":"97. Interleaving String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul> Python <pre><code># DP - 2D\ndef isInterleaveDP(s1: str, s2: str, s3: str) -&gt; bool:\n    m, n, k = len(s1), len(s2), len(s3)\n\n    if m + n != k:\n        return False\n\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    for i in range(1, m + 1):\n        dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n\n    for j in range(1, n + 1):\n        dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (\n                dp[i][j - 1] and s2[j - 1] == s3[i + j - 1]\n            )\n\n    return dp[m][n]\n\n\n# DFS\ndef isInterleaveDFS(s1: str, s2: str, s3: str) -&gt; bool:\n    memo = {}\n\n    def dfs(i, j, k):\n        if i == len(s1) and j == len(s2) and k == len(s3):\n            return True\n\n        if (i, j) in memo:\n            return memo[(i, j)]\n\n        res = False\n\n        if i &lt; len(s1) and k &lt; len(s3) and s1[i] == s3[k]:\n            res |= dfs(i + 1, j, k + 1)\n\n        if j &lt; len(s2) and k &lt; len(s3) and s2[j] == s3[k]:\n            res |= dfs(i, j + 1, k + 1)\n\n        memo[(i, j)] = res\n\n        return res\n\n    return dfs(0, 0, 0)\n\n\ns1 = \"aabcc\"\ns2 = \"dbbca\"\ns3 = \"aadbbbaccc\"\nprint(isInterleaveDP(s1, s2, s3))  # False\nprint(isInterleaveDFS(s1, s2, s3))  # False\n</code></pre>"},{"location":"EndlessCheng/dp_lcs_advanced/#1092-shortest-common-supersequence","title":"1092. Shortest Common Supersequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_lcs_advanced/#44-wildcard-matching","title":"44. Wildcard Matching","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Greedy, Recursion</p> </li> </ul>"},{"location":"EndlessCheng/dp_lcs_advanced/#10-regular-expression-matching","title":"10. Regular Expression Matching","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Recursion</p> </li> </ul>"},{"location":"EndlessCheng/dp_lcs_basics/","title":"DP LCS Basics","text":""},{"location":"EndlessCheng/dp_lcs_basics/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1143. Longest Common Subsequence (Medium)</li> <li> 583. Delete Operation for Two Strings (Medium)</li> <li> 712. Minimum ASCII Delete Sum for Two Strings (Medium)</li> <li> 72. Edit Distance (Medium)</li> <li> 1035. Uncrossed Lines (Medium)</li> <li> 1458. Max Dot Product of Two Subsequences (Hard)</li> </ul>"},{"location":"EndlessCheng/dp_lcs_basics/#1143-longest-common-subsequence","title":"1143. Longest Common Subsequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul> Python <pre><code>from functools import cache\n\n\nclass LongestCommonSubsequence:\n    def memoization(self, text1: str, text2: str) -&gt; int:\n        m, n = len(text1), len(text2)\n\n        @cache\n        def dfs(i: int, j: int) -&gt; int:\n            if i &lt; 0 or j &lt; 0:\n                return 0\n            if text1[i] == text2[j]:\n                return dfs(i - 1, j - 1) + 1\n            return max(dfs(i - 1, j), dfs(i, j - 1))\n\n        return dfs(m - 1, n - 1)\n\n    def iterative(self, text1: str, text2: str) -&gt; int:\n        m, n = len(text1), len(text2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for i, x in enumerate(text1):\n            for j, y in enumerate(text2):\n                if x == y:\n                    dp[i + 1][j + 1] = dp[i][j] + 1\n                else:\n                    dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1])\n\n        return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    lcs = LongestCommonSubsequence()\n    assert lcs.memoization(\"abcde\", \"ace\") == 3\n    assert lcs.iterative(\"abcde\", \"ace\") == 3\n    assert lcs.memoization(\"abc\", \"abc\") == 3\n    assert lcs.iterative(\"abc\", \"abc\") == 3\n</code></pre>"},{"location":"EndlessCheng/dp_lcs_basics/#583-delete-operation-for-two-strings","title":"583. Delete Operation for Two Strings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul> Python <pre><code># DP - LCS\ndef minDistance1(word1: str, word2: str) -&gt; int:\n    m = len(word1)\n    n = len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]  # no need to delete\n            else:\n                dp[i][j] = min(\n                    dp[i - 1][j] + 1,  # delete word1[i]\n                    dp[i][j - 1] + 1,  # delete word2[j]\n                    dp[i - 1][j - 1] + 2,  # delete both\n                )\n    return dp[-1][-1]\n\n\n# DP - LCS\ndef minDistance2(word1: str, word2: str) -&gt; int:\n    def LCS(word1: str, word2: str) -&gt; int:\n        m = len(word1)\n        n = len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        lcs = 0\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n                if lcs &lt; dp[i][j]:\n                    lcs = dp[i][j]\n        return lcs\n\n    lcs = LCS(word1, word2)\n    return len(word1) + len(word2) - 2 * lcs\n\n\nword1 = \"sea\"\nword2 = \"eat\"\nprint(minDistance1(word1, word2))  # 2\nprint(minDistance2(word1, word2))  # 2\n</code></pre>"},{"location":"EndlessCheng/dp_lcs_basics/#712-minimum-ascii-delete-sum-for-two-strings","title":"712. Minimum ASCII Delete Sum for Two Strings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul> Python <pre><code>class Solution:\n    def minimumDeleteSum(self, s1: str, s2: str) -&gt; int:\n        \"\"\"\n        \u9898\u76ee\u8981\u6c42: \u8ba1\u7b97\u5c06\u4e24\u4e2a\u5b57\u7b26\u4e32\u53d8\u4e3a\u76f8\u540c\u6240\u9700\u5220\u9664\u5b57\u7b26\u7684\u6700\u5c0f ASCII \u503c\u548c\u3002\n        \u601d\u8def: \u4fdd\u7559\u6700\u5927\u516c\u5171\u5b50\u5e8f\u5217\u7684\u5b57\u7b26\uff0c\u5176\u4f59\u5b57\u7b26\u5220\u9664\u3002\u4f7f\u7528\u52a8\u6001\u89c4\u5212\u8ba1\u7b97\u6700\u5927\u516c\u5171\u5b50\u5e8f\u5217\u7684 ASCII \u503c\u548c\u3002\n        \"\"\"\n        m, n = len(s1), len(s2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        total = sum(map(ord, s1)) + sum(map(ord, s2))\n\n        for i, x in enumerate(s1):\n            for j, y in enumerate(s2):\n                if x == y:\n                    dp[i + 1][j + 1] = dp[i][j] + ord(x)\n                else:\n                    dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1])\n\n        return total - dp[-1][-1] * 2\n</code></pre>"},{"location":"EndlessCheng/dp_lcs_basics/#72-edit-distance","title":"72. Edit Distance","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul> Python <pre><code>from functools import cache\n\n\n# Recursive\ndef minDistanceDFS(word1: str, word2: str) -&gt; int:\n    n, m = len(word1), len(word2)\n\n    @cache\n    def dfs(i: int, j: int) -&gt; int:\n        if i &lt; 0:\n            return j + 1\n        if j &lt; 0:\n            return i + 1\n        if word1[i] == word2[j]:\n            return dfs(i - 1, j - 1)\n\n        return 1 + min(dfs(i - 1, j), dfs(i, j - 1), dfs(i - 1, j - 1))\n\n    return dfs(n - 1, m - 1)\n\n\n# Iterative\ndef minDistanceDP(word1: str, word2: str) -&gt; int:\n    m, n = len(word1), len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]  # no operation\n            else:\n                dp[i][j] = 1 + min(\n                    dp[i - 1][j],  # delete\n                    dp[i][j - 1],  # insert\n                    dp[i - 1][j - 1],  # replace\n                )\n    return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    word1 = \"horse\"\n    word2 = \"ros\"\n    print(minDistanceDFS(word1, word2))  # 3\n    print(minDistanceDP(word1, word2))  # 3\n</code></pre>"},{"location":"EndlessCheng/dp_lcs_basics/#1035-uncrossed-lines","title":"1035. Uncrossed Lines","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef maxUncrossedLines(nums1: List[int], nums2: List[int]) -&gt; int:\n    m = len(nums1)\n    n = len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    num = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if nums1[i - 1] == nums2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n            if num &lt; dp[i][j]:\n                num = dp[i][j]\n\n    return num\n\n\nprint(maxUncrossedLines([1, 4, 2], [1, 2, 4]))  # 2\n</code></pre>"},{"location":"EndlessCheng/dp_lcs_basics/#1458-max-dot-product-of-two-subsequences","title":"1458. Max Dot Product of Two Subsequences","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_lis_advanced/","title":"DP LIS Advanced","text":""},{"location":"EndlessCheng/dp_lis_advanced/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1626. Best Team With No Conflicts (Medium)</li> <li> 673. Number of Longest Increasing Subsequence (Medium)</li> <li> 354. Russian Doll Envelopes (Hard)</li> <li> 1691. Maximum Height by Stacking Cuboids  (Hard)</li> <li> 960. Delete Columns to Make Sorted III (Hard)</li> <li> 2407. Longest Increasing Subsequence II (Hard)</li> <li> 1187. Make Array Strictly Increasing (Hard)</li> <li> 1713. Minimum Operations to Make a Subsequence (Hard)</li> <li> 3288. Length of the Longest Increasing Path (Hard)</li> <li> 368. Largest Divisible Subset (Medium)</li> </ul>"},{"location":"EndlessCheng/dp_lis_advanced/#1626-best-team-with-no-conflicts","title":"1626. Best Team With No Conflicts","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Sorting</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP - LIS\ndef bestTeamScore(scores: List[int], ages: List[int]) -&gt; int:\n    n = len(scores)\n    pairs = sorted(zip(scores, ages))  # sort\n    dp = [0 for _ in range(n)]\n\n    # LIS\n    for i in range(n):\n        for j in range(i):\n            if pairs[i][1] &gt;= pairs[j][1]:\n                dp[i] = max(dp[i], dp[j])\n        dp[i] += pairs[i][0]\n\n    return max(dp)\n\n\nif __name__ == \"__main__\":\n    assert bestTeamScore([1, 3, 5, 10, 15], [1, 2, 3, 4, 5]) == 34\n    assert bestTeamScore([4, 5, 6, 5], [2, 1, 2, 1]) == 16\n</code></pre>"},{"location":"EndlessCheng/dp_lis_advanced/#673-number-of-longest-increasing-subsequence","title":"673. Number of Longest Increasing Subsequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Binary Indexed Tree, Segment Tree</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP - LIS\ndef findNumberOfLIS(nums: List[int]) -&gt; int:\n    if not nums:\n        return 0\n\n    n = len(nums)\n    dp = [1 for _ in range(n)]\n    counts = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] &gt; nums[j]:\n                if dp[j] + 1 &gt; dp[i]:\n                    dp[i] = dp[j] + 1\n                    counts[i] = counts[j]\n                elif dp[j] + 1 == dp[i]:\n                    counts[i] += counts[j]\n\n    longest = max(dp)\n    return sum(c for i, c in enumerate(counts) if dp[i] == longest)\n\n\nnums = [1, 3, 5, 4, 7]\nprint(findNumberOfLIS(nums))  # 2\n</code></pre>"},{"location":"EndlessCheng/dp_lis_advanced/#354-russian-doll-envelopes","title":"354. Russian Doll Envelopes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Dynamic Programming, Sorting</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP - LIS\ndef maxEnvelopes(envelopes: List[List[int]]) -&gt; int:\n    envelopes.sort(key=lambda x: (x[0], -x[1]))\n    dp = []\n\n    for w, h in envelopes:\n        left, right = 0, len(dp)\n        while left &lt; right:\n            mid = left + (right - left) // 2\n            if dp[mid][1] &lt; h:\n                left = mid + 1\n            else:\n                right = mid\n        if right == len(dp):\n            dp.append((w, h))\n        else:\n            dp[right] = (w, h)\n\n    return len(dp)\n\n\nenvelopes = [[5, 4], [6, 4], [6, 7], [2, 3]]\nprint(maxEnvelopes(envelopes))  # 3\n</code></pre>"},{"location":"EndlessCheng/dp_lis_advanced/#1691-maximum-height-by-stacking-cuboids","title":"1691. Maximum Height by Stacking Cuboids","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/dp_lis_advanced/#960-delete-columns-to-make-sorted-iii","title":"960. Delete Columns to Make Sorted III","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP - LIS\ndef minDeletionSize(strs: List[str]) -&gt; int:\n    if not strs:\n        return 0\n\n    n = len(strs[0])\n    dp = [1 for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i):\n            if all(row[j] &lt;= row[i] for row in strs):\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return n - max(dp)\n</code></pre>"},{"location":"EndlessCheng/dp_lis_advanced/#2407-longest-increasing-subsequence-ii","title":"2407. Longest Increasing Subsequence II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Divide And Conquer, Dynamic Programming, Binary Indexed Tree, Segment Tree, Queue, Monotonic Queue</p> </li> </ul>"},{"location":"EndlessCheng/dp_lis_advanced/#1187-make-array-strictly-increasing","title":"1187. Make Array Strictly Increasing","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Dynamic Programming, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/dp_lis_advanced/#1713-minimum-operations-to-make-a-subsequence","title":"1713. Minimum Operations to Make a Subsequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Binary Search, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/dp_lis_advanced/#3288-length-of-the-longest-increasing-path","title":"3288. Length of the Longest Increasing Path","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/dp_lis_advanced/#368-largest-divisible-subset","title":"368. Largest Divisible Subset","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/dp_lis_basics/","title":"DP LIS Basics","text":""},{"location":"EndlessCheng/dp_lis_basics/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 300. Longest Increasing Subsequence (Medium)</li> <li> 2826. Sorting Three Groups (Medium)</li> <li> 1671. Minimum Number of Removals to Make Mountain Array (Hard)</li> <li> 1964. Find the Longest Valid Obstacle Course at Each Position (Hard)</li> <li> 2111. Minimum Operations to Make the Array K-Increasing (Hard)</li> </ul>"},{"location":"EndlessCheng/dp_lis_basics/#300-longest-increasing-subsequence","title":"300. Longest Increasing Subsequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Dynamic Programming</p> </li> </ul> Python <pre><code>from functools import cache\nfrom typing import List\n\n\n# DP - LIS\ndef lengthOfLISMemo(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return n\n\n    @cache\n    def dfs(i: int) -&gt; int:\n        res = 0\n        for j in range(i):\n            if nums[j] &lt; nums[i]:\n                res = max(res, dfs(j))\n        return res + 1\n\n    return max(dfs(i) for i in range(n))\n\n\n# DP - LIS\ndef lengthOfLISTable(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return n\n\n    dp = [1 for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i):\n            if nums[i] &gt; nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\n\nif __name__ == \"__main__\":\n    assert lengthOfLISMemo([10, 9, 2, 5, 3, 7, 101, 18]) == 4\n    assert lengthOfLISTable([10, 9, 2, 5, 3, 7, 101, 18]) == 4\n    assert lengthOfLISMemo([0, 1, 0, 3, 2, 3]) == 4\n    assert lengthOfLISTable([0, 1, 0, 3, 2, 3]) == 4\n    assert lengthOfLISMemo([7, 7, 7, 7]) == 1\n    assert lengthOfLISTable([7, 7, 7, 7]) == 1\n</code></pre>"},{"location":"EndlessCheng/dp_lis_basics/#2826-sorting-three-groups","title":"2826. Sorting Three Groups","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Dynamic Programming</p> </li> </ul> Python <pre><code>from functools import cache\nfrom typing import List\n\n\n# DP - LIS\ndef minimumOperationsMemo(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return 0\n\n    @cache\n    def dfs(i):\n        res = 0\n        for j in range(i):\n            if nums[i] &gt;= nums[j]:\n                res = max(res, dfs(j))\n        return res + 1\n\n    LIS = max(dfs(i) for i in range(n))\n\n    return n - LIS\n\n\n# DP - LIS\ndef minimumOperationsTable(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return 0\n\n    dp = [1 for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i):\n            if nums[i] &gt;= nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return n - max(dp)\n\n\n# DP - LIS\ndef minimumOperationsTableOptimized(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return 0\n\n    dp = [0 for _ in range(4)]\n\n    for num in nums:\n        dp[num] += 1\n        dp[2] = max(dp[2], dp[1])\n        dp[3] = max(dp[3], dp[2])\n\n    return n - dp[3]\n\n\nif __name__ == \"__main__\":\n    assert minimumOperationsMemo([2, 1, 3, 2, 1]) == 3\n    assert minimumOperationsTable([2, 1, 3, 2, 1]) == 3\n    assert minimumOperationsTableOptimized([2, 1, 3, 2, 1]) == 3\n</code></pre>"},{"location":"EndlessCheng/dp_lis_basics/#1671-minimum-number-of-removals-to-make-mountain-array","title":"1671. Minimum Number of Removals to Make Mountain Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Dynamic Programming, Greedy</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP - LIS\ndef minimumMountainRemovals(nums: List[int]) -&gt; int:\n    n = len(nums)\n    lis = [1 for _ in range(n)]\n    lds = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] &gt; nums[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    for i in range(n - 2, -1, -1):\n        for j in range(n - 1, i, -1):\n            if nums[i] &gt; nums[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    maxLen = 0\n    for i in range(1, n - 1):\n        if lis[i] &gt; 1 and lds[i] &gt; 1:\n            maxLen = max(maxLen, lis[i] + lds[i] - 1)\n\n    return n - maxLen\n\n\nnums = [2, 1, 1, 5, 6, 2, 3, 1]\nprint(minimumMountainRemovals(nums))  # 3\n</code></pre>"},{"location":"EndlessCheng/dp_lis_basics/#1964-find-the-longest-valid-obstacle-course-at-each-position","title":"1964. Find the Longest Valid Obstacle Course at Each Position","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Binary Indexed Tree</p> </li> </ul>"},{"location":"EndlessCheng/dp_lis_basics/#2111-minimum-operations-to-make-the-array-k-increasing","title":"2111. Minimum Operations to Make the Array K-Increasing","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul>"},{"location":"EndlessCheng/dp_longest_palindromic_subsequence/","title":"DP Longest Palindromic Subsequence","text":""},{"location":"EndlessCheng/dp_longest_palindromic_subsequence/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 516. Longest Palindromic Subsequence (Medium)</li> <li> 730. Count Different Palindromic Subsequences (Hard)</li> <li> 1312. Minimum Insertion Steps to Make a String Palindrome (Hard)</li> <li> 1771. Maximize Palindrome Length From Subsequences (Hard)</li> <li> 1682. Longest Palindromic Subsequence II (Medium) \ud83d\udc51</li> <li> 1216. Valid Palindrome III (Hard) \ud83d\udc51</li> <li> 1246. Palindrome Removal (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/dp_longest_palindromic_subsequence/#516-longest-palindromic-subsequence","title":"516. Longest Palindromic Subsequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the length of the longest palindromic subsequence in `s`.\n-   Bottom-up DP table\n\n| dp  |  b  |  b  |  b  |        a         |      b       |\n| :-: | :-: | :-: | :-: | :--------------: | :----------: |\n|  b  |  1  |  2  |  3  |        3         |      4       |\n|  b  |  0  |  1  |  2  |        2         | 3 `dp[i][j]` |\n|  b  |  0  |  0  |  1  | 1 `dp[i+1][j-1]` |      2       |\n|  a  |  0  |  0  |  0  |        1         |      1       |\n|  b  |  0  |  0  |  0  |        0         |      1       |\n\"\"\"\n\n\ndef longestPalindromeSubseq(s: str) -&gt; int:\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            if s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])\n\n    return dp[0][-1]\n\n\nprint(longestPalindromeSubseq(\"bbbab\"))  # 4\n</code></pre>"},{"location":"EndlessCheng/dp_longest_palindromic_subsequence/#730-count-different-palindromic-subsequences","title":"730. Count Different Palindromic Subsequences","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_longest_palindromic_subsequence/#1312-minimum-insertion-steps-to-make-a-string-palindrome","title":"1312. Minimum Insertion Steps to Make a String Palindrome","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_longest_palindromic_subsequence/#1771-maximize-palindrome-length-from-subsequences","title":"1771. Maximize Palindrome Length From Subsequences","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_longest_palindromic_subsequence/#1682-longest-palindromic-subsequence-ii","title":"1682. Longest Palindromic Subsequence II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_longest_palindromic_subsequence/#1216-valid-palindrome-iii","title":"1216. Valid Palindrome III \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_longest_palindromic_subsequence/#1246-palindrome-removal","title":"1246. Palindrome Removal \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_matrix_exponentiation_optimized/","title":"DP Matrix Exponentiation Optimized","text":""},{"location":"EndlessCheng/dp_matrix_exponentiation_optimized/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 70. Climbing Stairs (Easy)</li> <li> 509. Fibonacci Number (Easy)</li> <li> 1137. N-th Tribonacci Number (Easy)</li> <li> 1220. Count Vowels Permutation (Hard)</li> <li> 552. Student Attendance Record II (Hard)</li> <li> 935. Knight Dialer (Medium)</li> <li> 790. Domino and Tromino Tiling (Medium)</li> <li> 3337. Total Characters in String After Transformations II (Hard)</li> <li> 2851. String Transformation (Hard)</li> <li> 2912. Number of Ways to Reach Destination in the Grid (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/dp_matrix_exponentiation_optimized/#70-climbing-stairs","title":"70. Climbing Stairs","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Memoization</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return the number of distinct ways to reach the top of the stairs.\n- `dp[n]` stores the number of distinct ways to reach the `n-th` stair.\n- Formula: `dp[n] = dp[n - 1] + dp[n - 2]`.\n- Initialize `dp[0] = 0`, `dp[1] = 1`, and `dp[2] = 2`.\n\"\"\"\n\nfrom functools import cache\n\n\n# DP\ndef climbStairsDP(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    dp = [i for i in range(n + 1)]\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\n# DP (Optimized)\ndef climbStairsDPOptimized(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    first, second = 1, 2\n\n    for _ in range(3, n + 1):\n        first, second = second, first + second\n\n    return second\n\n\n# Recursion\ndef climbStairsRecursion(n: int) -&gt; int:\n    @cache\n    def dfs(i: int) -&gt; int:\n        if i &lt;= 1:\n            return 1\n        return dfs(i - 1) + dfs(i - 2)\n\n    return dfs(n)\n\n\n# Greedy\ndef climbStairsGreedy(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    p1, p2 = 1, 2\n\n    for _ in range(3, n + 1):\n        p1, p2 = p2, p1 + p2\n\n    return p2\n\n\nif __name__ == \"__main__\":\n    assert climbStairsDP(10) == 89\n    assert climbStairsDPOptimized(10) == 89\n    assert climbStairsRecursion(10) == 89\n    assert climbStairsGreedy(10) == 89\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nint climbStairs(int n) {\n    if (n &lt;= 2) return n;\n    int f1 = 1, f2 = 2;\n    int res;\n\n    int i = 3;\n    while (i &lt;= n) {\n        res = f1 + f2;\n        f1 = f2;\n        f2 = res;\n        i++;\n    }\n    return res;\n}\n\nint main() {\n    assert(climbStairs(2) == 2);\n    assert(climbStairs(5) == 8);\n    assert(climbStairs(10) == 89);\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/dp_matrix_exponentiation_optimized/#509-fibonacci-number","title":"509. Fibonacci Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Recursion, Memoization</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the `n-th` Fibonacci number.\n-   `dp[n]` stores the `n-th` Fibonacci number.\n-   Formula: `dp[n] = dp[n - 1] + dp[n - 2]`.\n-   Initialize `dp[0] = 0` and `dp[1] = 1`.\n\n|  n  | `dp[n-2]` | `dp[n-1]` | `dp[n]` |\n| :-: | :-------: | :-------: | :-----: |\n|  0  |     -     |     -     |    0    |\n|  1  |     -     |     0     |    1    |\n|  2  |     0     |     1     |    1    |\n|  3  |     1     |     1     |    2    |\n|  4  |     1     |     2     |    3    |\n|  5  |     2     |     3     |    5    |\n|  6  |     3     |     5     |    8    |\n|  7  |     5     |     8     |   13    |\n|  8  |     8     |    13     |   21    |\n|  9  |    13     |    21     |   34    |\n| 10  |    21     |    34     |   55    |\n\"\"\"\n\nfrom functools import cache\n\n\n# DP\ndef fibDP(n: int) -&gt; int:\n    if n &lt;= 1:\n        return n\n\n    dp = [i for i in range(n + 1)]\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\n# DP (Optimized)\ndef fibDPOptimized(n: int) -&gt; int:\n    if n &lt;= 1:\n        return n\n\n    n1, n2 = 0, 1\n    for _ in range(2, n + 1):\n        n1, n2 = n2, n1 + n2\n\n    return n2\n\n\n# Recursive\n@cache\ndef fibRecursive(n: int) -&gt; int:\n    if n &lt;= 1:\n        return n\n\n    return fibRecursive(n - 1) + fibRecursive(n - 2)\n\n\nn = 10\nprint(fibDP(n))  # 55\nprint(fibDPOptimized(n))  # 55\nprint(fibRecursive(n))  # 55\n</code></pre>"},{"location":"EndlessCheng/dp_matrix_exponentiation_optimized/#1137-n-th-tribonacci-number","title":"1137. N-th Tribonacci Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Memoization</p> </li> </ul>"},{"location":"EndlessCheng/dp_matrix_exponentiation_optimized/#1220-count-vowels-permutation","title":"1220. Count Vowels Permutation","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_matrix_exponentiation_optimized/#552-student-attendance-record-ii","title":"552. Student Attendance Record II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_matrix_exponentiation_optimized/#935-knight-dialer","title":"935. Knight Dialer","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_matrix_exponentiation_optimized/#790-domino-and-tromino-tiling","title":"790. Domino and Tromino Tiling","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_matrix_exponentiation_optimized/#3337-total-characters-in-string-after-transformations-ii","title":"3337. Total Characters in String After Transformations II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Math, String, Dynamic Programming, Counting</p> </li> </ul>"},{"location":"EndlessCheng/dp_matrix_exponentiation_optimized/#2851-string-transformation","title":"2851. String Transformation","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String, Dynamic Programming, String Matching</p> </li> </ul>"},{"location":"EndlessCheng/dp_matrix_exponentiation_optimized/#2912-number-of-ways-to-reach-destination-in-the-grid","title":"2912. Number of Ways to Reach Destination in the Grid \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Combinatorics</p> </li> </ul>"},{"location":"EndlessCheng/dp_max_subarray_sum/","title":"DP Max Subarray Sum","text":""},{"location":"EndlessCheng/dp_max_subarray_sum/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 53. Maximum Subarray (Medium)</li> <li> 2606. Find the Substring With Maximum Cost (Medium)</li> <li> 1749. Maximum Absolute Sum of Any Subarray (Medium)</li> <li> 1191. K-Concatenation Maximum Sum (Medium)</li> <li> 918. Maximum Sum Circular Subarray (Medium)</li> <li> 2321. Maximum Score Of Spliced Array (Hard)</li> <li> 152. Maximum Product Subarray (Medium)</li> </ul>"},{"location":"EndlessCheng/dp_max_subarray_sum/#53-maximum-subarray","title":"53. Maximum Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Divide And Conquer, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP Kadane\ndef maxSubArrayDP(nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n\n    dp[0] = nums[0]\n    maxSum = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(\n            dp[i - 1] + nums[i],  # continue the previous subarray\n            nums[i],  # start a new subarray\n        )\n        maxSum = max(maxSum, dp[i])\n\n    return maxSum\n\n\n# Greedy\ndef maxSubArrayGreedy(nums: List[int]) -&gt; int:\n    max_sum = nums[0]\n    cur_sum = 0\n\n    for num in nums:\n        cur_sum = max(cur_sum + num, num)\n        max_sum = max(max_sum, cur_sum)\n\n    return max_sum\n\n\n# Prefix Sum\ndef maxSubArrayPrefixSum(nums: List[int]) -&gt; int:\n    prefix_sum = 0\n    prefix_sum_min = 0\n    res = float(\"-inf\")\n\n    for num in nums:\n        prefix_sum += num\n        res = max(res, prefix_sum - prefix_sum_min)\n        prefix_sum_min = min(prefix_sum_min, prefix_sum)\n\n    return res\n\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArrayDP(nums))  # 6\nprint(maxSubArrayGreedy(nums))  # 6\nprint(maxSubArrayPrefixSum(nums))  # 6\n</code></pre>"},{"location":"EndlessCheng/dp_max_subarray_sum/#2606-find-the-substring-with-maximum-cost","title":"2606. Find the Substring With Maximum Cost","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_max_subarray_sum/#1749-maximum-absolute-sum-of-any-subarray","title":"1749. Maximum Absolute Sum of Any Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_max_subarray_sum/#1191-k-concatenation-maximum-sum","title":"1191. K-Concatenation Maximum Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_max_subarray_sum/#918-maximum-sum-circular-subarray","title":"918. Maximum Sum Circular Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Divide And Conquer, Dynamic Programming, Queue, Monotonic Queue</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# DP - Kadane\ndef maxSubarraySumCircularKadane(nums: List[int]) -&gt; int:\n    max_sum = min_sum = nums[0]\n    max_cur = min_cur = 0\n    total = 0\n\n    for num in nums:\n        max_cur = max(max_cur + num, num)\n        min_cur = min(min_cur + num, num)\n        total += num\n\n        max_sum = max(max_sum, max_cur)\n        min_sum = min(min_sum, min_cur)\n\n    return max(max_sum, total - min_sum) if max_sum &gt; 0 else max_sum\n\n\n# Monotonic Queue\ndef maxSubarraySumCircularMQ(nums: List[int]) -&gt; int:\n    n = len(nums)\n    prefix_sum = [0] * (2 * n + 1)\n\n    for i in range(1, 2 * n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + nums[(i - 1) % n]\n\n    q = deque([0])\n    max_sum = float(\"-inf\")\n\n    for i in range(1, 2 * n + 1):\n        if q[0] &lt; i - n:\n            q.popleft()\n\n        max_sum = max(max_sum, prefix_sum[i] - prefix_sum[q[0]])\n\n        while q and prefix_sum[q[-1]] &gt;= prefix_sum[i]:\n            q.pop()\n\n        q.append(i)\n\n    return max_sum\n\n\nnums = [1, -2, 3, -2]\nprint(maxSubarraySumCircularKadane(nums))  # 3\nprint(maxSubarraySumCircularMQ(nums))  # 3\n</code></pre>"},{"location":"EndlessCheng/dp_max_subarray_sum/#2321-maximum-score-of-spliced-array","title":"2321. Maximum Score Of Spliced Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_max_subarray_sum/#152-maximum-product-subarray","title":"152. Maximum Product Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxProduct(nums: List[int]) -&gt; int:\n    n = len(nums)\n    dp_max = [0 for _ in range(n)]\n    dp_min = [0 for _ in range(n)]\n\n    dp_max[0] = nums[0]\n    dp_min[0] = nums[0]\n    max_product = nums[0]\n\n    for i in range(1, n):\n        dp_max[i] = max(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n        dp_min[i] = min(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n\n        max_product = max(max_product, dp_max[i])\n\n    return max_product\n\n\nnums = [2, 3, -2, 4]\nprint(maxProduct(nums))  # 6\n</code></pre>"},{"location":"EndlessCheng/dp_monotonic_queue/","title":"DP Monotonic Queue","text":""},{"location":"EndlessCheng/dp_monotonic_queue/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2944. Minimum Number of Coins for Fruits (Medium)</li> <li> 1696. Jump Game VI (Medium)</li> <li> 1425. Constrained Subsequence Sum (Hard)</li> <li> 375. Guess Number Higher or Lower II (Medium)</li> <li> 1687. Delivering Boxes from Storage to Ports (Hard)</li> <li> 2463. Minimum Total Distance Traveled (Hard)</li> <li> 3117. Minimum Sum of Values by Dividing Array (Hard)</li> <li> 2945. Find Maximum Non-decreasing Array Length (Hard)</li> <li> 2969. Minimum Number of Coins for Fruits II (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/dp_monotonic_queue/#2944-minimum-number-of-coins-for-fruits","title":"2944. Minimum Number of Coins for Fruits","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Queue, Heap Priority Queue, Monotonic Queue</p> </li> </ul>"},{"location":"EndlessCheng/dp_monotonic_queue/#1696-jump-game-vi","title":"1696. Jump Game VI","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Queue, Heap Priority Queue, Monotonic Queue</p> </li> </ul>"},{"location":"EndlessCheng/dp_monotonic_queue/#1425-constrained-subsequence-sum","title":"1425. Constrained Subsequence Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Queue, Sliding Window, Heap Priority Queue, Monotonic Queue</p> </li> </ul>"},{"location":"EndlessCheng/dp_monotonic_queue/#375-guess-number-higher-or-lower-ii","title":"375. Guess Number Higher or Lower II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Game Theory</p> </li> </ul>"},{"location":"EndlessCheng/dp_monotonic_queue/#1687-delivering-boxes-from-storage-to-ports","title":"1687. Delivering Boxes from Storage to Ports","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Segment Tree, Queue, Heap Priority Queue, Prefix Sum, Monotonic Queue</p> </li> </ul>"},{"location":"EndlessCheng/dp_monotonic_queue/#2463-minimum-total-distance-traveled","title":"2463. Minimum Total Distance Traveled","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/dp_monotonic_queue/#3117-minimum-sum-of-values-by-dividing-array","title":"3117. Minimum Sum of Values by Dividing Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Dynamic Programming, Bit Manipulation, Segment Tree, Queue</p> </li> </ul>"},{"location":"EndlessCheng/dp_monotonic_queue/#2945-find-maximum-non-decreasing-array-length","title":"2945. Find Maximum Non-decreasing Array Length","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Dynamic Programming, Stack, Queue, Monotonic Stack, Monotonic Queue</p> </li> </ul>"},{"location":"EndlessCheng/dp_monotonic_queue/#2969-minimum-number-of-coins-for-fruits-ii","title":"2969. Minimum Number of Coins for Fruits II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Queue, Heap Priority Queue, Monotonic Queue</p> </li> </ul>"},{"location":"EndlessCheng/dp_monotonic_stack/","title":"DP Monotonic Stack","text":""},{"location":"EndlessCheng/dp_monotonic_stack/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1335. Minimum Difficulty of a Job Schedule (Hard)</li> <li> 2866. Beautiful Towers II (Medium)</li> <li> 2617. Minimum Number of Visited Cells in a Grid (Hard)</li> <li> 2355. Maximum Number of Books You Can Take (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/dp_monotonic_stack/#1335-minimum-difficulty-of-a-job-schedule","title":"1335. Minimum Difficulty of a Job Schedule","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_monotonic_stack/#2866-beautiful-towers-ii","title":"2866. Beautiful Towers II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Stack, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/dp_monotonic_stack/#2617-minimum-number-of-visited-cells-in-a-grid","title":"2617. Minimum Number of Visited Cells in a Grid","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Stack, Breadth First Search, Union Find, Heap Priority Queue, Matrix, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/dp_monotonic_stack/#2355-maximum-number-of-books-you-can-take","title":"2355. Maximum Number of Books You Can Take \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Stack, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/","title":"DP Multi-Dimensional","text":""},{"location":"EndlessCheng/dp_multi-dimensional/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2400. Number of Ways to Reach a Position After Exactly k Steps (Medium)</li> <li> 1824. Minimum Sideway Jumps (Medium)</li> <li> 3332. Maximum Points Tourist Can Earn (Medium)</li> <li> 2370. Longest Ideal Subsequence (Medium)</li> <li> 3176. Find the Maximum Length of a Good Subsequence I (Medium)</li> <li> 1269. Number of Ways to Stay in the Same Place After Some Steps (Hard)</li> <li> 3250. Find the Count of Monotonic Pairs I (Hard)</li> <li> 3218. Minimum Cost for Cutting Cake I (Medium)</li> <li> 3122. Minimum Number of Operations to Satisfy Conditions (Medium)</li> <li> 576. Out of Boundary Paths (Medium)</li> <li> 403. Frog Jump (Hard)</li> <li> 1223. Dice Roll Simulation (Hard)</li> <li> 1320. Minimum Distance to Type a Word Using Two Fingers (Hard)</li> <li> 3366. Minimum Array Sum (Medium)</li> <li> 1575. Count All Possible Routes (Hard)</li> <li> 3154. Find Number of Ways to Reach the K-th Stair (Hard)</li> <li> 2318. Number of Distinct Roll Sequences (Hard)</li> <li> 1444. Number of Ways of Cutting a Pizza (Hard)</li> <li> 3320. Count The Number of Winning Sequences (Hard)</li> <li> 3429. Paint House IV (Medium)</li> <li> 1420. Build Array Where You Can Find The Maximum Exactly K Comparisons (Hard)</li> <li> 3193. Count the Number of Inversions (Hard)</li> <li> 629. K Inverse Pairs Array (Hard)</li> <li> 1079. Letter Tile Possibilities (Medium)</li> <li> 1866. Number of Ways to Rearrange Sticks With K Sticks Visible (Hard)</li> <li> 2312. Selling Pieces of Wood (Hard)</li> <li> 3177. Find the Maximum Length of a Good Subsequence II (Hard)</li> <li> 1884. Egg Drop With 2 Eggs and N Floors (Medium)</li> <li> 887. Super Egg Drop (Hard)</li> <li> 3448. Count Substrings Divisible By Last Digit (Hard)</li> <li> 514. Freedom Trail (Hard)</li> <li> 3336. Find the Number of Subsequences With Equal GCD (Hard)</li> <li> 1388. Pizza With 3n Slices (Hard)</li> <li> 1900. The Earliest and Latest Rounds Where Players Compete (Hard)</li> <li> 1883. Minimum Skips to Arrive at Meeting On Time (Hard)</li> <li> 3343. Count Number of Balanced Permutations (Hard)</li> <li> 3441. Minimum Cost Good Caption (Hard)</li> <li> 3225. Maximum Score From Grid Operations (Hard)</li> <li> 256. Paint House (Medium) \ud83d\udc51</li> <li> 265. Paint House II (Hard) \ud83d\udc51</li> <li> 3339. Find the Number of K-Even Arrays (Medium) \ud83d\udc51</li> <li> 568. Maximum Vacation Days (Hard) \ud83d\udc51</li> <li> 1692. Count Ways to Distribute Candies (Hard) \ud83d\udc51</li> <li> 2143. Choose Numbers From Two Arrays in Range (Hard) \ud83d\udc51</li> <li> 3269. Constructing Two Increasing Arrays (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#2400-number-of-ways-to-reach-a-position-after-exactly-k-steps","title":"2400. Number of Ways to Reach a Position After Exactly k Steps","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Combinatorics</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#1824-minimum-sideway-jumps","title":"1824. Minimum Sideway Jumps","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#3332-maximum-points-tourist-can-earn","title":"3332. Maximum Points Tourist Can Earn","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#2370-longest-ideal-subsequence","title":"2370. Longest Ideal Subsequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#3176-find-the-maximum-length-of-a-good-subsequence-i","title":"3176. Find the Maximum Length of a Good Subsequence I","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Dynamic Programming</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# DP\ndef maximumLength(nums: List[int], k: int) -&gt; int:\n    frequency = defaultdict(lambda: [0 for _ in range(k + 1)])\n    dp = [0 for _ in range(k + 1)]\n\n    for num in nums:\n        f = frequency[num]\n        for j in range(k, -1, -1):\n            f[j] += 1\n            if j &gt; 0:\n                f[j] = max(f[j], dp[j - 1] + 1)\n            dp[j] = max(f[j], dp[j])\n\n    return dp[-1]\n\n\nnums = [1, 2, 1, 1, 3]\nk = 2\nprint(maximumLength(nums, k))  # 4\n</code></pre>"},{"location":"EndlessCheng/dp_multi-dimensional/#1269-number-of-ways-to-stay-in-the-same-place-after-some-steps","title":"1269. Number of Ways to Stay in the Same Place After Some Steps","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#3250-find-the-count-of-monotonic-pairs-i","title":"3250. Find the Count of Monotonic Pairs I","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Combinatorics, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#3218-minimum-cost-for-cutting-cake-i","title":"3218. Minimum Cost for Cutting Cake I","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#3122-minimum-number-of-operations-to-satisfy-conditions","title":"3122. Minimum Number of Operations to Satisfy Conditions","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#576-out-of-boundary-paths","title":"576. Out of Boundary Paths","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#403-frog-jump","title":"403. Frog Jump","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#1223-dice-roll-simulation","title":"1223. Dice Roll Simulation","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#1320-minimum-distance-to-type-a-word-using-two-fingers","title":"1320. Minimum Distance to Type a Word Using Two Fingers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#3366-minimum-array-sum","title":"3366. Minimum Array Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#1575-count-all-possible-routes","title":"1575. Count All Possible Routes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Memoization</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#3154-find-number-of-ways-to-reach-the-k-th-stair","title":"3154. Find Number of Ways to Reach the K-th Stair","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Bit Manipulation, Memoization, Combinatorics</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#2318-number-of-distinct-roll-sequences","title":"2318. Number of Distinct Roll Sequences","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Memoization</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#1444-number-of-ways-of-cutting-a-pizza","title":"1444. Number of Ways of Cutting a Pizza","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Memoization, Matrix, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#3320-count-the-number-of-winning-sequences","title":"3320. Count The Number of Winning Sequences","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#3429-paint-house-iv","title":"3429. Paint House IV","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#1420-build-array-where-you-can-find-the-maximum-exactly-k-comparisons","title":"1420. Build Array Where You Can Find The Maximum Exactly K Comparisons","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#3193-count-the-number-of-inversions","title":"3193. Count the Number of Inversions","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#629-k-inverse-pairs-array","title":"629. K Inverse Pairs Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#1079-letter-tile-possibilities","title":"1079. Letter Tile Possibilities","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Backtracking, Counting</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#1866-number-of-ways-to-rearrange-sticks-with-k-sticks-visible","title":"1866. Number of Ways to Rearrange Sticks With K Sticks Visible","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Combinatorics</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#2312-selling-pieces-of-wood","title":"2312. Selling Pieces of Wood","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Memoization</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#3177-find-the-maximum-length-of-a-good-subsequence-ii","title":"3177. Find the Maximum Length of a Good Subsequence II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Dynamic Programming</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# DP\ndef maximumLength(nums: List[int], k: int) -&gt; int:\n    count = [defaultdict(int) for _ in range(k + 1)]\n    result = [0 for _ in range(k + 1)]\n\n    for num in nums:\n        for c in range(k, -1, -1):\n            count[c][num] = max(count[c][num], result[c - 1] if c &gt; 0 else 0) + 1\n            result[c] = max(result[c], count[c][num])\n\n    return max(result)\n\n\nnums = [1, 2, 1, 1, 3]\nk = 2\nprint(maximumLength(nums, k))  # 4\n</code></pre>"},{"location":"EndlessCheng/dp_multi-dimensional/#1884-egg-drop-with-2-eggs-and-n-floors","title":"1884. Egg Drop With 2 Eggs and N Floors","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#887-super-egg-drop","title":"887. Super Egg Drop","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Binary Search, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#3448-count-substrings-divisible-by-last-digit","title":"3448. Count Substrings Divisible By Last Digit","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#514-freedom-trail","title":"514. Freedom Trail","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Depth First Search, Breadth First Search</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#3336-find-the-number-of-subsequences-with-equal-gcd","title":"3336. Find the Number of Subsequences With Equal GCD","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#1388-pizza-with-3n-slices","title":"1388. Pizza With 3n Slices","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#1900-the-earliest-and-latest-rounds-where-players-compete","title":"1900. The Earliest and Latest Rounds Where Players Compete","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Memoization</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#1883-minimum-skips-to-arrive-at-meeting-on-time","title":"1883. Minimum Skips to Arrive at Meeting On Time","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#3343-count-number-of-balanced-permutations","title":"3343. Count Number of Balanced Permutations","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String, Dynamic Programming, Combinatorics</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#3441-minimum-cost-good-caption","title":"3441. Minimum Cost Good Caption","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#3225-maximum-score-from-grid-operations","title":"3225. Maximum Score From Grid Operations","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Matrix, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#256-paint-house","title":"256. Paint House \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#265-paint-house-ii","title":"265. Paint House II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#3339-find-the-number-of-k-even-arrays","title":"3339. Find the Number of K-Even Arrays \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#568-maximum-vacation-days","title":"568. Maximum Vacation Days \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#1692-count-ways-to-distribute-candies","title":"1692. Count Ways to Distribute Candies \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#2143-choose-numbers-from-two-arrays-in-range","title":"2143. Choose Numbers From Two Arrays in Range \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_multi-dimensional/#3269-constructing-two-increasing-arrays","title":"3269. Constructing Two Increasing Arrays \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_multiple_knapsack/","title":"DP Multiple Knapsack","text":""},{"location":"EndlessCheng/dp_multiple_knapsack/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2585. Number of Ways to Earn Points (Hard)</li> <li> 3333. Find the Original Typed String II (Hard)</li> <li> 2902. Count of Sub-Multisets With Bounded Sum (Hard)</li> </ul>"},{"location":"EndlessCheng/dp_multiple_knapsack/#2585-number-of-ways-to-earn-points","title":"2585. Number of Ways to Earn Points","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_multiple_knapsack/#3333-find-the-original-typed-string-ii","title":"3333. Find the Original Typed String II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/dp_multiple_knapsack/#2902-count-of-sub-multisets-with-bounded-sum","title":"2902. Count of Sub-Multisets With Bounded Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Dynamic Programming, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/dp_non-overlapping_intervals/","title":"DP Non-Overlapping Intervals","text":""},{"location":"EndlessCheng/dp_non-overlapping_intervals/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2830. Maximize the Profit as the Salesman (Medium)</li> <li> 2008. Maximum Earnings From Taxi (Medium)</li> <li> 2054. Two Best Non-Overlapping Events (Medium)</li> <li> 1235. Maximum Profit in Job Scheduling (Hard)</li> <li> 1751. Maximum Number of Events That Can Be Attended II (Hard)</li> <li> 3414. Maximum Score of Non-overlapping Intervals (Hard)</li> </ul>"},{"location":"EndlessCheng/dp_non-overlapping_intervals/#2830-maximize-the-profit-as-the-salesman","title":"2830. Maximize the Profit as the Salesman","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Binary Search, Dynamic Programming, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/dp_non-overlapping_intervals/#2008-maximum-earnings-from-taxi","title":"2008. Maximum Earnings From Taxi","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Binary Search, Dynamic Programming, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/dp_non-overlapping_intervals/#2054-two-best-non-overlapping-events","title":"2054. Two Best Non-Overlapping Events","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Dynamic Programming, Sorting, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/dp_non-overlapping_intervals/#1235-maximum-profit-in-job-scheduling","title":"1235. Maximum Profit in Job Scheduling","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Dynamic Programming, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/dp_non-overlapping_intervals/#1751-maximum-number-of-events-that-can-be-attended-ii","title":"1751. Maximum Number of Events That Can Be Attended II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Dynamic Programming, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/dp_non-overlapping_intervals/#3414-maximum-score-of-non-overlapping-intervals","title":"3414. Maximum Score of Non-overlapping Intervals","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Dynamic Programming, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/dp_optimal_partitioning/","title":"DP Optimal Partitioning","text":""},{"location":"EndlessCheng/dp_optimal_partitioning/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 132. Palindrome Partitioning II (Hard)</li> <li> 2707. Extra Characters in a String (Medium)</li> <li> 3196. Maximize Total Cost of Alternating Subarrays (Medium)</li> <li> 2767. Partition String Into Minimum Beautiful Substrings (Medium)</li> <li> 91. Decode Ways (Medium)</li> <li> 639. Decode Ways II (Hard)</li> <li> 1043. Partition Array for Maximum Sum (Medium)</li> <li> 1416. Restore The Array (Hard)</li> <li> 2472. Maximum Number of Non-overlapping Palindrome Substrings (Hard)</li> <li> 1105. Filling Bookcase Shelves (Medium)</li> <li> 2547. Minimum Cost to Split an Array (Hard)</li> <li> 2430. Maximum Deletions on a String (Hard)</li> <li> 2463. Minimum Total Distance Traveled (Hard)</li> <li> 2977. Minimum Cost to Convert String II (Hard)</li> <li> 3441. Minimum Cost Good Caption (Hard)</li> <li> 2052. Minimum Cost to Separate Sentence Into Rows (Medium) \ud83d\udc51</li> <li> 2464. Minimum Subarrays in a Valid Split (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/dp_optimal_partitioning/#132-palindrome-partitioning-ii","title":"132. Palindrome Partitioning II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul> Python <pre><code>\"\"\"\n- [\u6559\u4f60\u4e00\u6b65\u6b65\u601d\u8003 DP\uff1a\u4ece\u8bb0\u5fc6\u5316\u641c\u7d22\u5230\u9012\u63a8\uff08Python/Java/C++/Go\uff09](https://leetcode.cn/problems/palindrome-partitioning-ii/solutions/3588633/jiao-ni-yi-bu-bu-si-kao-dpcong-ji-yi-hua-bnlb)\n\"\"\"\n\nfrom functools import cache\n\n\n# Memoization\ndef minCutMemoization(s: str) -&gt; int:\n    @cache\n    def is_palindrome(left, right):\n        if left &gt;= right:\n            return True\n        return s[left] == s[right] and is_palindrome(left + 1, right - 1)\n\n    @cache\n    def dfs(right):\n        if is_palindrome(0, right):\n            return 0\n        res = float(\"inf\")\n        for left in range(1, right + 1):\n            if is_palindrome(left, right):\n                res = min(res, 1 + dfs(left - 1))\n        return res\n\n    return dfs(len(s) - 1)\n\n\n# Tabulation\ndef minCutTabulation(s: str) -&gt; int:\n    n = len(s)\n    is_palindrome = [[True] * n for _ in range(n)]\n\n    for left in range(n - 2, -1, -1):\n        for right in range(left + 1, n):\n            is_palindrome[left][right] = (\n                s[left] == s[right] and is_palindrome[left + 1][right - 1]\n            )\n\n    dp = [0 for _ in range(n)]\n\n    for right, is_pal in enumerate(is_palindrome[0]):\n        if is_pal:\n            continue\n        res = float(\"inf\")\n        for left in range(1, right + 1):\n            if is_palindrome[left][right]:\n                res = min(res, 1 + dp[left - 1])\n        dp[right] = res\n\n    return dp[-1]\n\n\ns = \"aab\"\nprint(minCutMemoization(s))  # 1\nprint(minCutTabulation(s))  # 1\n</code></pre>"},{"location":"EndlessCheng/dp_optimal_partitioning/#2707-extra-characters-in-a-string","title":"2707. Extra Characters in a String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Dynamic Programming, Trie</p> </li> </ul>"},{"location":"EndlessCheng/dp_optimal_partitioning/#3196-maximize-total-cost-of-alternating-subarrays","title":"3196. Maximize Total Cost of Alternating Subarrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_optimal_partitioning/#2767-partition-string-into-minimum-beautiful-substrings","title":"2767. Partition String Into Minimum Beautiful Substrings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Dynamic Programming, Backtracking</p> </li> </ul>"},{"location":"EndlessCheng/dp_optimal_partitioning/#91-decode-ways","title":"91. Decode Ways","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul> Python <pre><code># DP\ndef numDecodingsDP(s: str) -&gt; int:\n    if not s or s[0] == \"0\":\n        return 0\n\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for i in range(1, n + 1):\n        # Check single digit decode\n        if s[i - 1] != \"0\":\n            dp[i] += dp[i - 1]\n\n        # Check two digit decode\n        if i &gt; 1 and \"10\" &lt;= s[i - 2 : i] &lt;= \"26\":\n            dp[i] += dp[i - 2]\n\n    return dp[n]\n\n\n# DFS\ndef numDecodingsDFS(s: str) -&gt; int:\n    memo = {}\n\n    def dfs(i):\n        if i == len(s):\n            return 1\n\n        if s[i] == \"0\":\n            return 0\n\n        if i in memo:\n            return memo[i]\n\n        # Single digit decode\n        ways = dfs(i + 1)\n\n        # Two digits decode\n        if i + 1 &lt; len(s) and \"10\" &lt;= s[i : i + 2] &lt;= \"26\":\n            ways += dfs(i + 2)\n\n        memo[i] = ways\n\n        return ways\n\n    return dfs(0)\n\n\ns = \"226\"\nprint(numDecodingsDP(s))  # 3\nprint(numDecodingsDFS(s))  # 3\n</code></pre>"},{"location":"EndlessCheng/dp_optimal_partitioning/#639-decode-ways-ii","title":"639. Decode Ways II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_optimal_partitioning/#1043-partition-array-for-maximum-sum","title":"1043. Partition Array for Maximum Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_optimal_partitioning/#1416-restore-the-array","title":"1416. Restore The Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_optimal_partitioning/#2472-maximum-number-of-non-overlapping-palindrome-substrings","title":"2472. Maximum Number of Non-overlapping Palindrome Substrings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Dynamic Programming, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/dp_optimal_partitioning/#1105-filling-bookcase-shelves","title":"1105. Filling Bookcase Shelves","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_optimal_partitioning/#2547-minimum-cost-to-split-an-array","title":"2547. Minimum Cost to Split an Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Dynamic Programming, Counting</p> </li> </ul>"},{"location":"EndlessCheng/dp_optimal_partitioning/#2430-maximum-deletions-on-a-string","title":"2430. Maximum Deletions on a String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Rolling Hash, String Matching, Hash Function</p> </li> </ul>"},{"location":"EndlessCheng/dp_optimal_partitioning/#2463-minimum-total-distance-traveled","title":"2463. Minimum Total Distance Traveled","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/dp_optimal_partitioning/#2977-minimum-cost-to-convert-string-ii","title":"2977. Minimum Cost to Convert String II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Dynamic Programming, Graph, Trie, Shortest Path</p> </li> </ul>"},{"location":"EndlessCheng/dp_optimal_partitioning/#3441-minimum-cost-good-caption","title":"3441. Minimum Cost Good Caption","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_optimal_partitioning/#2052-minimum-cost-to-separate-sentence-into-rows","title":"2052. Minimum Cost to Separate Sentence Into Rows \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_optimal_partitioning/#2464-minimum-subarrays-in-a-valid-split","title":"2464. Minimum Subarrays in a Valid Split \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_dp/","title":"DP Other DP","text":""},{"location":"EndlessCheng/dp_other_dp/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1387. Sort Integers by The Power Value (Medium)</li> <li> 823. Binary Trees With Factors (Medium)</li> <li> 940. Distinct Subsequences II (Hard)</li> <li> 135. Candy (Hard)</li> <li> 650. 2 Keys Keyboard (Medium)</li> <li> 638. Shopping Offers (Medium)</li> <li> 467. Unique Substrings in Wraparound String (Medium)</li> <li> 2262. Total Appeal of A String (Hard)</li> <li> 828. Count Unique Characters of All Substrings of a Given String (Hard)</li> <li> 2746. Decremental String Concatenation (Medium)</li> <li> 2930. Number of Strings Which Can Be Rearranged to Contain Substring (Medium)</li> <li> 1569. Number of Ways to Reorder Array to Get Same BST (Hard)</li> <li> 818. Race Car (Hard)</li> <li> 920. Number of Music Playlists (Hard)</li> <li> 1388. Pizza With 3n Slices (Hard)</li> <li> 1987. Number of Unique Good Subsequences (Hard)</li> <li> 903. Valid Permutations for DI Sequence (Hard)</li> <li> 1896. Minimum Cost to Change the Final Value of Expression (Hard)</li> <li> 1531. String Compression II (Hard)</li> <li> 964. Least Operators to Express Number (Hard)</li> <li> 1787. Make the XOR of All Segments Equal to Zero (Hard)</li> <li> 2060. Check if an Original String Exists Given Two Encoded Strings (Hard)</li> <li> 2809. Minimum Time to Make Array Sum At Most x (Hard)</li> <li> 3299. Sum of Consecutive Subsequences (Hard) \ud83d\udc51</li> <li> 2189. Number of Ways to Build House of Cards (Medium) \ud83d\udc51</li> <li> 2597. The Number of Beautiful Subsets (Medium)</li> <li> 2638. Count the Number of K-Free Subsets (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/dp_other_dp/#1387-sort-integers-by-the-power-value","title":"1387. Sort Integers by The Power Value","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Memoization, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_dp/#823-binary-trees-with-factors","title":"823. Binary Trees With Factors","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Dynamic Programming, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_dp/#940-distinct-subsequences-ii","title":"940. Distinct Subsequences II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_dp/#135-candy","title":"135. Candy","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the minimum number of candies you must give.\n\"\"\"\n\nfrom typing import List\n\n\n# Greedy\ndef candy(ratings: List[int]) -&gt; int:\n    # TC: O(n)\n    # SC: O(n)\n    n = len(ratings)\n\n    if n &lt;= 1:\n        return n\n\n    candy = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        if ratings[i] &gt; ratings[i - 1]:\n            candy[i] = candy[i - 1] + 1\n\n    for j in range(n - 2, -1, -1):\n        if ratings[j] &gt; ratings[j + 1]:\n            candy[j] = max(candy[j], candy[j + 1] + 1)\n\n    return sum(candy)\n\n\nratings = [1, 0, 2]\nprint(candy(ratings))  # 5\n</code></pre>"},{"location":"EndlessCheng/dp_other_dp/#650-2-keys-keyboard","title":"650. 2 Keys Keyboard","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_dp/#638-shopping-offers","title":"638. Shopping Offers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Backtracking, Bit Manipulation, Memoization, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_dp/#467-unique-substrings-in-wraparound-string","title":"467. Unique Substrings in Wraparound String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_dp/#2262-total-appeal-of-a-string","title":"2262. Total Appeal of A String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_dp/#828-count-unique-characters-of-all-substrings-of-a-given-string","title":"828. Count Unique Characters of All Substrings of a Given String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_dp/#2746-decremental-string-concatenation","title":"2746. Decremental String Concatenation","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_dp/#2930-number-of-strings-which-can-be-rearranged-to-contain-substring","title":"2930. Number of Strings Which Can Be Rearranged to Contain Substring","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Combinatorics</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_dp/#1569-number-of-ways-to-reorder-array-to-get-same-bst","title":"1569. Number of Ways to Reorder Array to Get Same BST","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Divide And Conquer, Dynamic Programming, Tree, Union Find, Binary Search Tree, Memoization, Combinatorics, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_dp/#818-race-car","title":"818. Race Car","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_dp/#920-number-of-music-playlists","title":"920. Number of Music Playlists","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Combinatorics</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_dp/#1388-pizza-with-3n-slices","title":"1388. Pizza With 3n Slices","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_dp/#1987-number-of-unique-good-subsequences","title":"1987. Number of Unique Good Subsequences","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_dp/#903-valid-permutations-for-di-sequence","title":"903. Valid Permutations for DI Sequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_dp/#1896-minimum-cost-to-change-the-final-value-of-expression","title":"1896. Minimum Cost to Change the Final Value of Expression","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String, Dynamic Programming, Stack</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_dp/#1531-string-compression-ii","title":"1531. String Compression II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_dp/#964-least-operators-to-express-number","title":"964. Least Operators to Express Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Memoization</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_dp/#1787-make-the-xor-of-all-segments-equal-to-zero","title":"1787. Make the XOR of All Segments Equal to Zero","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_dp/#2060-check-if-an-original-string-exists-given-two-encoded-strings","title":"2060. Check if an Original String Exists Given Two Encoded Strings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_dp/#2809-minimum-time-to-make-array-sum-at-most-x","title":"2809. Minimum Time to Make Array Sum At Most x","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_dp/#3299-sum-of-consecutive-subsequences","title":"3299. Sum of Consecutive Subsequences \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_dp/#2189-number-of-ways-to-build-house-of-cards","title":"2189. Number of Ways to Build House of Cards \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_dp/#2597-the-number-of-beautiful-subsets","title":"2597. The Number of Beautiful Subsets","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Dynamic Programming, Backtracking, Sorting, Combinatorics</p> </li> </ul> CPP <pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Solution {\n   public:\n    int beautifulSubsets(vector&lt;int&gt;&amp; nums, int k) {\n        int res = 0;\n        unordered_map&lt;int, int&gt; cnt;\n\n        auto dfs = [&amp;](auto&amp;&amp; self, int i) -&gt; void {\n            if (i == (int)nums.size()) {\n                res++;\n                return;\n            }\n            self(self, i + 1);  // Skip nums[i]\n            int x = nums[i];\n            if (cnt[x - k] == 0 &amp;&amp; cnt[x + k] == 0) {\n                cnt[x]++;\n                self(self, i + 1);  // Include nums[i]\n                cnt[x]--;           // Backtrack\n            }\n        };\n\n        dfs(dfs, 0);\n\n        return res - 1;\n    }\n};\n\nint main() {\n    Solution sol;\n    vector&lt;int&gt; nums = {1, 2, 3, 4};\n    int k = 1;\n    cout &lt;&lt; sol.beautifulSubsets(nums, k) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/dp_other_dp/#2638-count-the-number-of-k-free-subsets","title":"2638. Count the Number of K-Free Subsets \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Sorting, Combinatorics</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_interval_dp/","title":"DP Other Interval DP","text":""},{"location":"EndlessCheng/dp_other_interval_dp/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 5. Longest Palindromic Substring (Medium)</li> <li> 647. Palindromic Substrings (Medium)</li> <li> 3040. Maximum Number of Operations With the Same Score II (Medium)</li> <li> 375. Guess Number Higher or Lower II (Medium)</li> <li> 1130. Minimum Cost Tree From Leaf Values (Medium)</li> <li> 96. Unique Binary Search Trees (Medium)</li> <li> 1770. Maximum Score from Performing Multiplication Operations (Hard)</li> <li> 1547. Minimum Cost to Cut a Stick (Hard)</li> <li> 1039. Minimum Score Triangulation of Polygon (Medium)</li> <li> 1000. Minimum Cost to Merge Stones (Hard)</li> <li> 2019. The Score of Students Solving Math Expression (Hard)</li> <li> 3277. Maximum XOR Score Subarray Queries (Hard)</li> <li> 87. Scramble String (Hard)</li> <li> 312. Burst Balloons (Hard)</li> <li> 664. Strange Printer (Hard)</li> <li> 546. Remove Boxes (Hard)</li> <li> 471. Encode String with Shortest Length (Hard) \ud83d\udc51</li> <li> 3018. Maximum Number of Removal Queries That Can Be Processed I (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/dp_other_interval_dp/#5-longest-palindromic-substring","title":"5. Longest Palindromic Substring","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Dynamic Programming</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the longest palindromic substring in `s`.\n\"\"\"\n\n\n# DP - Interval\ndef longestPalindromeDP(s: str) -&gt; str:\n    n = len(s)\n    if n &lt;= 1:\n        return s\n\n    start, maxLen = 0, 1\n\n    # Init\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for j in range(1, n):\n        for i in range(j):\n            if s[i] == s[j]:\n                if j - i &lt;= 2:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1]\n\n                if dp[i][j] and j - i + 1 &gt; maxLen:\n                    maxLen = j - i + 1\n                    start = i\n\n    return s[start : start + maxLen]\n\n\n# Expand Around Center\ndef longestPalindromeCenter(s: str) -&gt; str:\n    def expand_around_center(left, right):\n        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n\n    if len(s) &lt;= 1:\n        return s\n\n    start, end = 0, 0\n    for i in range(len(s)):\n        len1 = expand_around_center(i, i)  # odd\n        len2 = expand_around_center(i, i + 1)  # even\n\n        maxLen = max(len1, len2)\n        if maxLen &gt; end - start:\n            start = i - (maxLen - 1) // 2\n            end = i + maxLen // 2\n\n    return s[start : end + 1]\n\n\ns = \"babad\"\nprint(longestPalindromeDP(s))  # \"bab\"\nprint(longestPalindromeCenter(s))  # \"aba\"\n</code></pre>"},{"location":"EndlessCheng/dp_other_interval_dp/#647-palindromic-substrings","title":"647. Palindromic Substrings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Dynamic Programming</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the number of palindromic substrings in `s`.\n-   Bottom-up DP table\n\n|  dp   |  a  |  b  |  b  |  a  |  e  |\n| :---: | :-: | :-: | :-: | :-: | :-: |\n| **a** |  1  |  0  |  0  |  1  |  0  |\n| **b** |  0  |  1  |  1  |  0  |  0  |\n| **b** |  0  |  0  |  1  |  0  |  0  |\n| **a** |  0  |  0  |  0  |  1  |  0  |\n| **e** |  0  |  0  |  0  |  0  |  1  |\n\"\"\"\n\n\ndef countSubstrings(s: str) -&gt; int:\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    res = 0\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i, n):\n            if s[i] == s[j]:\n                if j - i &lt;= 1:\n                    dp[i][j] = 1\n                    res += 1\n                elif dp[i + 1][j - 1]:\n                    dp[i][j] = 1\n                    res += 1\n\n    return res\n\n\nprint(countSubstrings(\"abbae\"))  # 7\n</code></pre>"},{"location":"EndlessCheng/dp_other_interval_dp/#3040-maximum-number-of-operations-with-the-same-score-ii","title":"3040. Maximum Number of Operations With the Same Score II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Memoization</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_interval_dp/#375-guess-number-higher-or-lower-ii","title":"375. Guess Number Higher or Lower II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Game Theory</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_interval_dp/#1130-minimum-cost-tree-from-leaf-values","title":"1130. Minimum Cost Tree From Leaf Values","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Stack, Greedy, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_interval_dp/#96-unique-binary-search-trees","title":"96. Unique Binary Search Trees","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Tree, Binary Search Tree, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_interval_dp/#1770-maximum-score-from-performing-multiplication-operations","title":"1770. Maximum Score from Performing Multiplication Operations","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_interval_dp/#1547-minimum-cost-to-cut-a-stick","title":"1547. Minimum Cost to Cut a Stick","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_interval_dp/#1039-minimum-score-triangulation-of-polygon","title":"1039. Minimum Score Triangulation of Polygon","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_interval_dp/#1000-minimum-cost-to-merge-stones","title":"1000. Minimum Cost to Merge Stones","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_interval_dp/#2019-the-score-of-students-solving-math-expression","title":"2019. The Score of Students Solving Math Expression","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, String, Dynamic Programming, Stack, Memoization</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_interval_dp/#3277-maximum-xor-score-subarray-queries","title":"3277. Maximum XOR Score Subarray Queries","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_interval_dp/#87-scramble-string","title":"87. Scramble String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_interval_dp/#312-burst-balloons","title":"312. Burst Balloons","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_interval_dp/#664-strange-printer","title":"664. Strange Printer","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_interval_dp/#546-remove-boxes","title":"546. Remove Boxes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Memoization</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_interval_dp/#471-encode-string-with-shortest-length","title":"471. Encode String with Shortest Length \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_interval_dp/#3018-maximum-number-of-removal-queries-that-can-be-processed-i","title":"3018. Maximum Number of Removal Queries That Can Be Processed I \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_optimized/","title":"DP Other Optimized","text":""},{"location":"EndlessCheng/dp_other_optimized/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1937. Maximum Number of Points with Cost (Medium)</li> <li> 2713. Maximum Strictly Increasing Cells in a Matrix (Hard)</li> <li> 3181. Maximum Total Reward Using Operations II (Hard)</li> <li> 2267.  Check if There Is a Valid Parentheses String Path (Hard)</li> <li> 3213. Construct String with Minimum Cost (Hard)</li> <li> 3292. Minimum Number of Valid Strings to Form Target II (Hard)</li> <li> 2263. Make Array Non-decreasing or Non-increasing (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/dp_other_optimized/#1937-maximum-number-of-points-with-cost","title":"1937. Maximum Number of Points with Cost","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_optimized/#2713-maximum-strictly-increasing-cells-in-a-matrix","title":"2713. Maximum Strictly Increasing Cells in a Matrix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Binary Search, Dynamic Programming, Memoization, Sorting, Matrix, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_optimized/#3181-maximum-total-reward-using-operations-ii","title":"3181. Maximum Total Reward Using Operations II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_optimized/#2267-check-if-there-is-a-valid-parentheses-string-path","title":"2267.  Check if There Is a Valid Parentheses String Path","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_optimized/#3213-construct-string-with-minimum-cost","title":"3213. Construct String with Minimum Cost","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Dynamic Programming, Suffix Array</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_optimized/#3292-minimum-number-of-valid-strings-to-form-target-ii","title":"3292. Minimum Number of Valid Strings to Form Target II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Binary Search, Dynamic Programming, Segment Tree, Rolling Hash, String Matching, Hash Function</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_optimized/#2263-make-array-non-decreasing-or-non-increasing","title":"2263. Make Array Non-decreasing or Non-increasing \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_state_compression/","title":"DP Other State Compression","text":""},{"location":"EndlessCheng/dp_other_state_compression/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 698. Partition to K Equal Sum Subsets (Medium)</li> <li> 1411. Number of Ways to Paint N \u00d7 3 Grid (Hard)</li> <li> 2002. Maximum Product of the Length of Two Palindromic Subsequences (Medium)</li> <li> 473. Matchsticks to Square (Medium)</li> <li> 1931. Painting a Grid With Three Different Colors (Hard)</li> <li> 1125. Smallest Sufficient Team (Hard)</li> <li> 1434. Number of Ways to Wear Different Hats to Each Other (Hard)</li> <li> 464. Can I Win (Medium)</li> <li> 691. Stickers to Spell Word (Hard)</li> <li> 3276. Select Cells in Grid With Maximum Score (Hard)</li> <li> 1595. Minimum Cost to Connect Two Groups of Points (Hard)</li> <li> 1815. Maximum Number of Groups Getting Fresh Donuts (Hard)</li> <li> 1659. Maximize Grid Happiness (Hard)</li> <li> 351. Android Unlock Patterns (Medium) \ud83d\udc51</li> <li> 2184. Number of Ways to Build Sturdy Brick Wall (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/dp_other_state_compression/#698-partition-to-k-equal-sum-subsets","title":"698. Partition to K Equal Sum Subsets","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Backtracking, Bit Manipulation, Memoization, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_state_compression/#1411-number-of-ways-to-paint-n-3-grid","title":"1411. Number of Ways to Paint N \u00d7 3 Grid","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_state_compression/#2002-maximum-product-of-the-length-of-two-palindromic-subsequences","title":"2002. Maximum Product of the Length of Two Palindromic Subsequences","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Backtracking, Bit Manipulation, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_state_compression/#473-matchsticks-to-square","title":"473. Matchsticks to Square","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Backtracking, Bit Manipulation, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_state_compression/#1931-painting-a-grid-with-three-different-colors","title":"1931. Painting a Grid With Three Different Colors","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_state_compression/#1125-smallest-sufficient-team","title":"1125. Smallest Sufficient Team","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Bit Manipulation, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_state_compression/#1434-number-of-ways-to-wear-different-hats-to-each-other","title":"1434. Number of Ways to Wear Different Hats to Each Other","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Bit Manipulation, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_state_compression/#464-can-i-win","title":"464. Can I Win","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Bit Manipulation, Memoization, Game Theory, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_state_compression/#691-stickers-to-spell-word","title":"691. Stickers to Spell Word","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Dynamic Programming, Backtracking, Bit Manipulation, Memoization, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_state_compression/#3276-select-cells-in-grid-with-maximum-score","title":"3276. Select Cells in Grid With Maximum Score","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Bit Manipulation, Matrix, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_state_compression/#1595-minimum-cost-to-connect-two-groups-of-points","title":"1595. Minimum Cost to Connect Two Groups of Points","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Bit Manipulation, Matrix, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_state_compression/#1815-maximum-number-of-groups-getting-fresh-donuts","title":"1815. Maximum Number of Groups Getting Fresh Donuts","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Bit Manipulation, Memoization, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_state_compression/#1659-maximize-grid-happiness","title":"1659. Maximize Grid Happiness","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Bit Manipulation, Memoization, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_state_compression/#351-android-unlock-patterns","title":"351. Android Unlock Patterns \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Backtracking, Bit Manipulation, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_other_state_compression/#2184-number-of-ways-to-build-sturdy-brick-wall","title":"2184. Number of Ways to Build Sturdy Brick Wall \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Bit Manipulation, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_partitioning_feasibility/","title":"DP Partitioning Feasibility","text":""},{"location":"EndlessCheng/dp_partitioning_feasibility/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2369. Check if There is a Valid Partition For The Array (Medium)</li> <li> 139. Word Break (Medium)</li> </ul>"},{"location":"EndlessCheng/dp_partitioning_feasibility/#2369-check-if-there-is-a-valid-partition-for-the-array","title":"2369. Check if There is a Valid Partition For The Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_partitioning_feasibility/#139-word-break","title":"139. Word Break","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Dynamic Programming, Trie, Memoization</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\n# DP (Unbounded Knapsack)\ndef wordBreak(s: str, wordDict: List[str]) -&gt; bool:\n    n = len(s)\n    dp = [False for _ in range(n + 1)]\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for word in wordDict:\n            m = len(word)\n            if s[i - m : i] == word and dp[i - m]:\n                dp[i] = True\n    return dp[-1]\n\n\ns = \"leetcode\"\nwordDict = [\"leet\", \"code\"]\nprint(wordBreak(s, wordDict))  # True\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;cassert&gt;\n#include &lt;ranges&gt;\n#include &lt;string&gt;\n#include &lt;unordered_set&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) {\n        int max_len = ranges::max(wordDict, {}, &amp;string::length).length();\n        unordered_set&lt;string&gt; words(wordDict.begin(), wordDict.end());\n\n        int n = s.length();\n        vector&lt;int&gt; f(n + 1);\n        f[0] = true;\n        for (int i = 1; i &lt;= n; i++) {\n            for (int j = i - 1; j &gt;= max(i - max_len, 0); j--) {\n                if (f[j] &amp;&amp; words.count(s.substr(j, i - j))) {\n                    f[i] = true;\n                    break;\n                }\n            }\n        }\n        return f[n];\n    }\n};\n\nint main() {\n    Solution solution;\n    string s = \"leetcode\";\n    vector&lt;string&gt; wordDict = {\"leet\", \"code\"};\n    assert(solution.wordBreak(s, wordDict) == true);\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/dp_permutation_type_adjacent_related/","title":"DP Permutation Type Adjacent Related","text":""},{"location":"EndlessCheng/dp_permutation_type_adjacent_related/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 996. Number of Squareful Arrays (Hard)</li> <li> 2741. Special Permutations (Medium)</li> <li> 1681. Minimum Incompatibility (Hard)</li> <li> 3283. Maximum Number of Moves to Kill All Pawns (Hard)</li> <li> 3149. Find the Minimum Cost Array Permutation (Hard)</li> </ul>"},{"location":"EndlessCheng/dp_permutation_type_adjacent_related/#996-number-of-squareful-arrays","title":"996. Number of Squareful Arrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Dynamic Programming, Backtracking, Bit Manipulation, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_permutation_type_adjacent_related/#2741-special-permutations","title":"2741. Special Permutations","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Bit Manipulation, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_permutation_type_adjacent_related/#1681-minimum-incompatibility","title":"1681. Minimum Incompatibility","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Bit Manipulation, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_permutation_type_adjacent_related/#3283-maximum-number-of-moves-to-kill-all-pawns","title":"3283. Maximum Number of Moves to Kill All Pawns","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Bit Manipulation, Breadth First Search, Game Theory, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_permutation_type_adjacent_related/#3149-find-the-minimum-cost-array-permutation","title":"3149. Find the Minimum Cost Array Permutation","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Bit Manipulation, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_permutation_type_adjacent_unrelated/","title":"DP Permutation Type Adjacent Unrelated","text":""},{"location":"EndlessCheng/dp_permutation_type_adjacent_unrelated/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 526. Beautiful Arrangement (Medium)</li> <li> 3376. Minimum Time to Break Locks I (Medium)</li> <li> 1879. Minimum XOR Sum of Two Arrays (Hard)</li> <li> 2850. Minimum Moves to Spread Stones Over Grid (Medium)</li> <li> 1947. Maximum Compatibility Score Sum (Medium)</li> <li> 1799. Maximize Score After N Operations (Hard)</li> <li> 2172. Maximum AND Sum of Array (Hard)</li> <li> 2992. Number of Self-Divisible Permutations (Medium) \ud83d\udc51</li> <li> 2403. Minimum Time to Kill All Monsters (Hard) \ud83d\udc51</li> <li> 1066. Campus Bikes II (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/dp_permutation_type_adjacent_unrelated/#526-beautiful-arrangement","title":"526. Beautiful Arrangement","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Backtracking, Bit Manipulation, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_permutation_type_adjacent_unrelated/#3376-minimum-time-to-break-locks-i","title":"3376. Minimum Time to Break Locks I","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Backtracking, Bit Manipulation, Depth First Search, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_permutation_type_adjacent_unrelated/#1879-minimum-xor-sum-of-two-arrays","title":"1879. Minimum XOR Sum of Two Arrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Bit Manipulation, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_permutation_type_adjacent_unrelated/#2850-minimum-moves-to-spread-stones-over-grid","title":"2850. Minimum Moves to Spread Stones Over Grid","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Breadth First Search, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/dp_permutation_type_adjacent_unrelated/#1947-maximum-compatibility-score-sum","title":"1947. Maximum Compatibility Score Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Backtracking, Bit Manipulation, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_permutation_type_adjacent_unrelated/#1799-maximize-score-after-n-operations","title":"1799. Maximize Score After N Operations","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Backtracking, Bit Manipulation, Number Theory, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_permutation_type_adjacent_unrelated/#2172-maximum-and-sum-of-array","title":"2172. Maximum AND Sum of Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Bit Manipulation, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_permutation_type_adjacent_unrelated/#2992-number-of-self-divisible-permutations","title":"2992. Number of Self-Divisible Permutations \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Backtracking, Bit Manipulation, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_permutation_type_adjacent_unrelated/#2403-minimum-time-to-kill-all-monsters","title":"2403. Minimum Time to Kill All Monsters \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Bit Manipulation, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_permutation_type_adjacent_unrelated/#1066-campus-bikes-ii","title":"1066. Campus Bikes II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Backtracking, Bit Manipulation, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/","title":"DP Prefix and Suffix Decomposition","text":""},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 724. Find Pivot Index (Easy)</li> <li> 1991. Find the Middle Index in Array (Easy)</li> <li> 2270. Number of Ways to Split Array (Medium)</li> <li> 2256. Minimum Average Difference (Medium)</li> <li> 1422. Maximum Score After Splitting a String (Easy)</li> <li> 1493. Longest Subarray of 1's After Deleting One Element (Medium)</li> <li> 845. Longest Mountain in Array (Medium)</li> <li> 2012. Sum of Beauty in the Array (Medium)</li> <li> 2909. Minimum Sum of Mountain Triplets II (Medium)</li> <li> 2483. Minimum Penalty for a Shop (Medium)</li> <li> 1525. Number of Good Ways to Split a String (Medium)</li> <li> 3354. Make Array Elements Equal to Zero (Easy)</li> <li> 2874. Maximum Value of an Ordered Triplet II (Medium)</li> <li> 123. Best Time to Buy and Sell Stock III (Hard)</li> <li> 2222. Number of Ways to Select Buildings (Medium)</li> <li> 1031. Maximum Sum of Two Non-Overlapping Subarrays (Medium)</li> <li> 689. Maximum Sum of 3 Non-Overlapping Subarrays (Hard)</li> <li> 2420. Find All Good Indices (Medium)</li> <li> 2100. Find Good Days to Rob the Bank (Medium)</li> <li> 926. Flip String to Monotone Increasing (Medium)</li> <li> 334. Increasing Triplet Subsequence (Medium)</li> <li> 2712. Minimum Cost to Make All Characters Equal (Medium)</li> <li> 1653. Minimum Deletions to Make String Balanced (Medium)</li> <li> 1186. Maximum Subarray Sum with One Deletion (Medium)</li> <li> 42. Trapping Rain Water (Hard)</li> <li> 2711. Difference of Number of Distinct Values on Diagonals (Medium)</li> <li> 1477. Find Two Non-overlapping Sub-arrays Each With Target Sum (Medium)</li> <li> 2680. Maximum OR (Medium)</li> <li> 1671. Minimum Number of Removals to Make Mountain Array (Hard)</li> <li> 1888. Minimum Number of Flips to Make the Binary String Alternating (Medium)</li> <li> 238. Product of Array Except Self (Medium)</li> <li> 2906. Construct Product Matrix (Medium)</li> <li> 3334. Find the Maximum Factor Score of Array (Medium)</li> <li> 2167. Minimum Time to Remove All Cars Containing Illegal Goods (Hard)</li> <li> 2484. Count Palindromic Subsequences (Hard)</li> <li> 2163. Minimum Difference in Sums After Removal of Elements (Hard)</li> <li> 2565. Subsequence With the Minimum Score (Hard)</li> <li> 1995. Count Special Quadruplets (Easy)</li> <li> 2552. Count Increasing Quadruplets (Hard)</li> <li> 3302. Find the Lexicographically Smallest Valid Sequence (Medium)</li> <li> 3404. Count Special Subsequences (Medium)</li> <li> 3303. Find the Occurrence of First Almost Equal Substring (Hard)</li> <li> 3287. Find the Maximum Sequence Value of Array (Hard)</li> <li> 3257. Maximum Value Sum by Placing Three Rooks II (Hard)</li> <li> 3410. Maximize Subarray Sum After Removing All Occurrences of One Element (Hard)</li> <li> 3003. Maximize the Number of Partitions After Operations (Hard)</li> <li> 487. Max Consecutive Ones II (Medium) \ud83d\udc51</li> <li> 1746. Maximum Subarray Sum After One Operation (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#724-find-pivot-index","title":"724. Find Pivot Index","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#1991-find-the-middle-index-in-array","title":"1991. Find the Middle Index in Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#2270-number-of-ways-to-split-array","title":"2270. Number of Ways to Split Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#2256-minimum-average-difference","title":"2256. Minimum Average Difference","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#1422-maximum-score-after-splitting-a-string","title":"1422. Maximum Score After Splitting a String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#1493-longest-subarray-of-1s-after-deleting-one-element","title":"1493. Longest Subarray of 1's After Deleting One Element","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Sliding Window</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Sliding Window Variable Max\ndef longestSubarray(nums: List[int]) -&gt; int:\n    zeroCount = 0\n    res = 0\n    left = 0\n\n    for right in range(len(nums)):\n        if nums[right] == 0:\n            zeroCount += 1\n\n        while zeroCount &gt; 1:\n            if nums[left] == 0:\n                zeroCount -= 1\n            left += 1\n\n        res = max(res, right - left)\n\n    return res\n\n\nnums = [1, 1, 0, 1]\nprint(longestSubarray(nums))  # 3\n</code></pre>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#845-longest-mountain-in-array","title":"845. Longest Mountain in Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Dynamic Programming, Enumeration</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef longestMountain(arr: List[int]) -&gt; int:\n    n = len(arr)\n    res = 0\n    left = 0\n\n    while left &lt; n:\n        right = left\n\n        if right &lt; n - 1 and arr[right] &lt; arr[right + 1]:\n            while right &lt; n - 1 and arr[right] &lt; arr[right + 1]:\n                right += 1\n\n            if right &lt; n - 1 and arr[right] &gt; arr[right + 1]:\n                while right &lt; n - 1 and arr[right] &gt; arr[right + 1]:\n                    right += 1\n                res = max(res, right - left + 1)\n\n        left = max(right, left + 1)\n\n    return res\n\n\narr = [2, 1, 4, 7, 3, 2, 5]\nprint(longestMountain(arr))  # 5\n</code></pre>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#2012-sum-of-beauty-in-the-array","title":"2012. Sum of Beauty in the Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP Prefix and Suffix Decomposition\ndef sumOfBeauties(nums: List[int]) -&gt; int:\n    n = len(nums)\n    suf_min = [0] * n\n    suf_min[n - 1] = nums[n - 1]\n    for i in range(n - 2, 1, -1):\n        suf_min[i] = min(suf_min[i + 1], nums[i])\n\n    res = 0\n    pre_max = nums[0]\n    for i in range(1, n - 1):\n        x = nums[i]\n        if pre_max &lt; x &lt; suf_min[i + 1]:\n            res += 2\n        elif nums[i - 1] &lt; x &lt; nums[i + 1]:\n            res += 1\n        pre_max = max(pre_max, x)\n\n    return res\n\n\nnums = [2, 4, 6, 4, 5]\nprint(sumOfBeauties(nums))  # 1\n</code></pre>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#2909-minimum-sum-of-mountain-triplets-ii","title":"2909. Minimum Sum of Mountain Triplets II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#2483-minimum-penalty-for-a-shop","title":"2483. Minimum Penalty for a Shop","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#1525-number-of-good-ways-to-split-a-string","title":"1525. Number of Good Ways to Split a String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Dynamic Programming, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#3354-make-array-elements-equal-to-zero","title":"3354. Make Array Elements Equal to Zero","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Simulation, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#2874-maximum-value-of-an-ordered-triplet-ii","title":"2874. Maximum Value of an Ordered Triplet II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef maximumTripletValue(nums: List[int]) -&gt; int:\n    res = 0\n    max_diff = 0\n    max_prev = 0\n\n    for num in nums:\n        res = max(res, max_diff * num)\n        max_diff = max(max_diff, max_prev - num)\n        max_prev = max(max_prev, num)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    nums = [12, 6, 1, 2, 7]\n    print(maximumTripletValue(nums))  # 77\n</code></pre>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#123-best-time-to-buy-and-sell-stock-iii","title":"123. Best Time to Buy and Sell Stock III","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# 1. DP\ndef maxProfitDP1(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 5 for _ in range(n)]\n\n    dp[0][0] = 0  # no transaction\n    dp[0][1] = -prices[0]  # buy 1\n    dp[0][2] = 0  # sell 1\n    dp[0][3] = -prices[0]  # buy 2\n    dp[0][4] = 0  # sell 2\n\n    for i in range(1, n):\n        dp[i][0] = dp[i - 1][0]\n        dp[i][1] = max(dp[i - 1][1], -prices[i])\n        dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i])\n        dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i])\n        dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i])\n\n    return dp[-1][4]\n\n\n# 2. DP - Optimized\ndef maxProfitDP2(prices: List[int]) -&gt; int:\n    b1, b2 = float(\"inf\"), float(\"inf\")\n    s1, s2 = 0, 0\n\n    for price in prices:\n        b1 = min(b1, price)\n        s1 = max(s1, price - b1)\n        b2 = min(b2, price - s1)\n        s2 = max(s2, price - b2)\n\n    return s2\n\n\nprices = [3, 3, 5, 0, 0, 3, 1, 4]\nprint(maxProfitDP1(prices))  # 6\nprint(maxProfitDP2(prices))  # 6\n</code></pre>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#2222-number-of-ways-to-select-buildings","title":"2222. Number of Ways to Select Buildings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#1031-maximum-sum-of-two-non-overlapping-subarrays","title":"1031. Maximum Sum of Two Non-Overlapping Subarrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#689-maximum-sum-of-3-non-overlapping-subarrays","title":"689. Maximum Sum of 3 Non-Overlapping Subarrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#2420-find-all-good-indices","title":"2420. Find All Good Indices","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#2100-find-good-days-to-rob-the-bank","title":"2100. Find Good Days to Rob the Bank","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#926-flip-string-to-monotone-increasing","title":"926. Flip String to Monotone Increasing","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#334-increasing-triplet-subsequence","title":"334. Increasing Triplet Subsequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#2712-minimum-cost-to-make-all-characters-equal","title":"2712. Minimum Cost to Make All Characters Equal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Greedy</p> </li> </ul> Python <pre><code>def minimumCost(s: str) -&gt; int:\n    n = len(s)\n    res = 0\n    for i in range(1, n):\n        if s[i - 1] != s[i]:\n            res += min(i, n - i)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    s = \"0011\"\n    print(minimumCost(s))  # 2\n</code></pre>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#1653-minimum-deletions-to-make-string-balanced","title":"1653. Minimum Deletions to Make String Balanced","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Stack</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#1186-maximum-subarray-sum-with-one-deletion","title":"1186. Maximum Subarray Sum with One Deletion","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>\"\"\"\n- [\u7075\u795e\uff1a\u6559\u4f60\u4e00\u6b65\u6b65\u601d\u8003\u52a8\u6001\u89c4\u5212 - \u4ece\u8bb0\u5fc6\u5316\u641c\u7d22\u5230\u9012\u63a8](https://leetcode.cn/problems/maximum-subarray-sum-with-one-deletion/solutions/2321829/jiao-ni-yi-bu-bu-si-kao-dong-tai-gui-hua-hzz6))\n\"\"\"\n\nfrom functools import cache\nfrom math import inf\nfrom typing import List\n\n\n# DP - Kadane\ndef maximumSum(arr: List[int]) -&gt; int:\n    dp0 = arr[0]\n    dp1 = 0\n    res = dp0\n\n    for i in range(1, len(arr)):\n        dp1 = max(dp1 + arr[i], dp0)  # delete previous element or not\n        dp0 = max(dp0, 0) + arr[i]  # delete current element or not\n        res = max(res, dp0, dp1)  # update result\n\n    return res\n\n\n# DP - Memoization\ndef maximumSumMemo(arr: List[int]) -&gt; int:\n    @cache\n    def dfs(i: int, j: int) -&gt; int:\n        if i &lt; 0:\n            return -inf\n        if j == 0:\n            return max(dfs(i - 1, 0), 0) + arr[i]\n        return max(dfs(i - 1, 1) + arr[i], dfs(i - 1, 0))\n\n    return max(max(dfs(i, 0), dfs(i, 1)) for i in range(len(arr)))\n\n\nif __name__ == \"__main__\":\n    arr = [1, -2, 0, 3]\n    assert maximumSum(arr) == 4\n    assert maximumSumMemo(arr) == 4\n</code></pre>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#42-trapping-rain-water","title":"42. Trapping Rain Water","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Dynamic Programming, Stack, Monotonic Stack</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- ![42](../../assets/0042.png)\n\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/ZI2z5pq0TqA?si=OEYg01dbmzvmtIwZ\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen&gt;&lt;/iframe&gt;\n\n| Approach   | Time | Space |\n| ---------- | ---- | ----- |\n| DP         | O(N) | O(N)  |\n| Left Right | O(N) | O(1)  |\n| Monotonic  | O(N) | O(N)  |\n\"\"\"\n\nfrom typing import List\n\n\n# DP\ndef trapDP(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    n = len(height)\n    maxLeft, maxRight = [0 for _ in range(n)], [0 for _ in range(n)]\n\n    for i in range(1, n):\n        maxLeft[i] = max(maxLeft[i - 1], height[i - 1])\n\n    for i in range(n - 2, -1, -1):\n        maxRight[i] = max(maxRight[i + 1], height[i + 1])\n\n    res = 0\n    for i in range(n):\n        res += max(0, min(maxLeft[i], maxRight[i]) - height[i])\n\n    return res\n\n\n# Left Right Pointers\ndef trapLR(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    left, right = 0, len(height) - 1\n    maxL, maxR = height[left], height[right]\n    res = 0\n\n    while left &lt; right:\n        if maxL &lt; maxR:\n            left += 1\n            maxL = max(maxL, height[left])\n            res += maxL - height[left]\n        else:\n            right -= 1\n            maxR = max(maxR, height[right])\n            res += maxR - height[right]\n\n    return res\n\n\n# Monotonic Stack\ndef trapStack(height: List[int]) -&gt; int:\n    stack = []\n    total = 0\n\n    for i in range(len(height)):\n        while stack and height[i] &gt; height[stack[-1]]:\n            top = stack.pop()\n            if not stack:\n                break\n            distance = i - stack[-1] - 1\n            bounded_height = min(height[i], height[stack[-1]]) - height[top]\n            total += distance * bounded_height\n        stack.append(i)\n\n    return total\n\n\nheight = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\nprint(trapDP(height))  # 6\nprint(trapLR(height))  # 6\nprint(trapStack(height))  # 6\n</code></pre> <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int trap(vector&lt;int&gt; &amp;height)\n    {\n        if (height.empty())\n            return 0;\n\n        int res = 0;\n        int left = 0, right = height.size() - 1;\n        int maxL = height[left], maxR = height[right];\n\n        while (left &lt; right)\n        {\n            if (maxL &lt; maxR)\n            {\n                left++;\n                maxL = max(maxL, height[left]);\n                res += maxL - height[left];\n            }\n            else\n            {\n                right--;\n                maxR = max(maxR, height[right]);\n                res += maxR - height[right];\n            }\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    vector&lt;int&gt; height = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};\n    Solution solution;\n    cout &lt;&lt; solution.trap(height) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#2711-difference-of-number-of-distinct-values-on-diagonals","title":"2711. Difference of Number of Distinct Values on Diagonals","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Matrix</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef differenceOfDistinctValues(grid: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(grid), len(grid[0])\n    res = [[0] * n for _ in range(m)]\n    st = set()\n\n    for k in range(1, m + n):\n        min_j = max(n - k, 0)\n        max_j = min(m + n - 1 - k, n - 1)\n\n        st.clear()\n        for j in range(min_j, max_j + 1):\n            i = k + j - n\n            res[i][j] = len(st)\n            st.add(grid[i][j])\n\n        st.clear()\n        for j in range(max_j, min_j - 1, -1):\n            i = k + j - n\n            res[i][j] = abs(res[i][j] - len(st))\n            st.add(grid[i][j])\n\n    return res\n\n\nif __name__ == \"__main__\":\n    grid = [[1, 2, 3], [3, 1, 5], [3, 2, 1]]\n    print(differenceOfDistinctValues(grid))\n    # [[1, 1, 0], [1, 0, 1], [0, 1, 1]]\n</code></pre>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#1477-find-two-non-overlapping-sub-arrays-each-with-target-sum","title":"1477. Find Two Non-overlapping Sub-arrays Each With Target Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Binary Search, Dynamic Programming, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#2680-maximum-or","title":"2680. Maximum OR","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Bit Manipulation, Prefix Sum</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Greedy\ndef maximumOr(nums: List[int], k: int) -&gt; int:\n    \"\"\"Maximum OR of Array After k Operations\n\n    Args:\n        nums (List[int]): provided list of integers\n        k (int): number of operations\n\n    Returns:\n        int: maximum OR of array after k operations\n    \"\"\"\n    n = len(nums)\n    suffix = [0 for _ in range(n)]\n\n    for i in range(n - 2, -1, -1):\n        suffix[i] = suffix[i + 1] | nums[i + 1]\n\n    res, pre = 0, 0\n    for num, suf in zip(nums, suffix):\n        res = max(res, pre | (num &lt;&lt; k) | suf)\n        pre |= num\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(maximumOr(nums=[8, 1, 2], k=2))  # 35\n</code></pre>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#1671-minimum-number-of-removals-to-make-mountain-array","title":"1671. Minimum Number of Removals to Make Mountain Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Dynamic Programming, Greedy</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP - LIS\ndef minimumMountainRemovals(nums: List[int]) -&gt; int:\n    n = len(nums)\n    lis = [1 for _ in range(n)]\n    lds = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] &gt; nums[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    for i in range(n - 2, -1, -1):\n        for j in range(n - 1, i, -1):\n            if nums[i] &gt; nums[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    maxLen = 0\n    for i in range(1, n - 1):\n        if lis[i] &gt; 1 and lds[i] &gt; 1:\n            maxLen = max(maxLen, lis[i] + lds[i] - 1)\n\n    return n - maxLen\n\n\nnums = [2, 1, 1, 5, 6, 2, 3, 1]\nprint(minimumMountainRemovals(nums))  # 3\n</code></pre>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#1888-minimum-number-of-flips-to-make-the-binary-string-alternating","title":"1888. Minimum Number of Flips to Make the Binary String Alternating","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Greedy, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#238-product-of-array-except-self","title":"238. Product of Array Except Self","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Prefix Sum</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Classic **Prefix Sum** problem\n-   Return an array `output` such that `output[i]` is equal to the product of all the elements of `nums` except `nums[i]`.\n\n| Approach           | Time | Space |\n| ------------------ | ---- | ----- |\n| Prefix             | O(n) | O(n)  |\n| Prefix (Optimized) | O(n) | O(1)  |\n\"\"\"\n\nfrom typing import List\n\n\n# Prefix\ndef productExceptSelf(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    prefix = [1 for _ in range(n)]\n    suffix = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        prefix[i] = nums[i - 1] * prefix[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        suffix[i] = nums[i + 1] * suffix[i + 1]\n\n    result = [i * j for i, j in zip(prefix, suffix)]\n\n    return result\n\n\n# Prefix (Optimized)\ndef productExceptSelfOptimized(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    result = [1 for _ in range(n)]\n\n    prefix = 1\n    for i in range(n):\n        result[i] = prefix\n        prefix *= nums[i]\n\n    suffix = 1\n    for i in range(n - 1, -1, -1):\n        result[i] *= suffix\n        suffix *= nums[i]\n\n    return result\n\n\nprint(productExceptSelf([1, 2, 3, 4]))\n# [24, 12, 8, 6]\nprint(productExceptSelfOptimized([1, 2, 3, 4]))\n# [24, 12, 8, 6]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt; &amp;nums) {\n        int n = nums.size();\n        vector&lt;int&gt; prefix(n, 1);\n        vector&lt;int&gt; suffix(n, 1);\n        vector&lt;int&gt; res(n, 1);\n\n        for (int i = 1; i &lt; n; i++) {\n            prefix[i] = prefix[i - 1] * nums[i - 1];\n        }\n\n        for (int i = n - 2; i &gt;= 0; i--) {\n            suffix[i] = suffix[i + 1] * nums[i + 1];\n        }\n\n        for (int i = 0; i &lt; n; i++) {\n            res[i] = prefix[i] * suffix[i];\n        }\n        return res;\n    }\n};\n\nint main() {\n    vector&lt;int&gt; nums = {1, 2, 3, 4};\n    Solution obj;\n    vector&lt;int&gt; result = obj.productExceptSelf(nums);\n    assert(result == vector&lt;int&gt;({24, 12, 8, 6}));\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#2906-construct-product-matrix","title":"2906. Construct Product Matrix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Matrix, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#3334-find-the-maximum-factor-score-of-array","title":"3334. Find the Maximum Factor Score of Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#2167-minimum-time-to-remove-all-cars-containing-illegal-goods","title":"2167. Minimum Time to Remove All Cars Containing Illegal Goods","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#2484-count-palindromic-subsequences","title":"2484. Count Palindromic Subsequences","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#2163-minimum-difference-in-sums-after-removal-of-elements","title":"2163. Minimum Difference in Sums After Removal of Elements","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#2565-subsequence-with-the-minimum-score","title":"2565. Subsequence With the Minimum Score","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Binary Search</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#1995-count-special-quadruplets","title":"1995. Count Special Quadruplets","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#2552-count-increasing-quadruplets","title":"2552. Count Increasing Quadruplets","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Binary Indexed Tree, Enumeration, Prefix Sum</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP\ndef countQuadruplets(nums: List[int]) -&gt; int:\n    n = len(nums)\n    great = [[0] * (n + 1) for _ in range(n)]\n    less = [0 for _ in range(n + 1)]\n\n    for k in range(n - 2, 1, -1):\n        great[k] = great[k + 1].copy()\n        for x in range(1, nums[k + 1]):\n            great[k][x] += 1\n\n    ans = 0\n\n    for j in range(1, n - 1):\n        for x in range(nums[j - 1] + 1, n + 1):\n            less[x] += 1\n        for k in range(j + 1, n - 1):\n            if nums[j] &gt; nums[k]:\n                ans += less[nums[k]] * great[k][nums[j]]\n    return ans\n\n\nnums = [1, 3, 2, 4, 5]\nprint(countQuadruplets(nums))  # 2\n</code></pre>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#3302-find-the-lexicographically-smallest-valid-sequence","title":"3302. Find the Lexicographically Smallest Valid Sequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Dynamic Programming, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#3404-count-special-subsequences","title":"3404. Count Special Subsequences","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#3303-find-the-occurrence-of-first-almost-equal-substring","title":"3303. Find the Occurrence of First Almost Equal Substring","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, String Matching</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#3287-find-the-maximum-sequence-value-of-array","title":"3287. Find the Maximum Sequence Value of Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#3257-maximum-value-sum-by-placing-three-rooks-ii","title":"3257. Maximum Value Sum by Placing Three Rooks II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Matrix, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#3410-maximize-subarray-sum-after-removing-all-occurrences-of-one-element","title":"3410. Maximize Subarray Sum After Removing All Occurrences of One Element","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Segment Tree</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#3003-maximize-the-number-of-partitions-after-operations","title":"3003. Maximize the Number of Partitions After Operations","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Bit Manipulation, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#487-max-consecutive-ones-ii","title":"487. Max Consecutive Ones II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_and_suffix_decomposition/#1746-maximum-subarray-sum-after-one-operation","title":"1746. Maximum Subarray Sum After One Operation \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_sum/","title":"DP Prefix Sum","text":""},{"location":"EndlessCheng/dp_prefix_sum/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2327. Number of People Aware of a Secret (Medium)</li> <li> 1871. Jump Game VII (Medium)</li> <li> 1997. First Day Where You Have Been in All the Rooms (Medium)</li> <li> 3251. Find the Count of Monotonic Pairs II (Hard)</li> <li> 2478. Number of Beautiful Partitions (Hard)</li> <li> 837. New 21 Game (Medium)</li> <li> 2463. Minimum Total Distance Traveled (Hard)</li> <li> 3333. Find the Original Typed String II (Hard)</li> <li> 2902. Count of Sub-Multisets With Bounded Sum (Hard)</li> <li> 629. K Inverse Pairs Array (Hard)</li> <li> 1977. Number of Ways to Separate Numbers (Hard)</li> <li> 3130. Find All Possible Stable Binary Arrays II (Hard)</li> </ul>"},{"location":"EndlessCheng/dp_prefix_sum/#2327-number-of-people-aware-of-a-secret","title":"2327. Number of People Aware of a Secret","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Queue, Simulation</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_sum/#1871-jump-game-vii","title":"1871. Jump Game VII","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Sliding Window, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_sum/#1997-first-day-where-you-have-been-in-all-the-rooms","title":"1997. First Day Where You Have Been in All the Rooms","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_sum/#3251-find-the-count-of-monotonic-pairs-ii","title":"3251. Find the Count of Monotonic Pairs II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Combinatorics, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_sum/#2478-number-of-beautiful-partitions","title":"2478. Number of Beautiful Partitions","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_sum/#837-new-21-game","title":"837. New 21 Game","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Sliding Window, Probability And Statistics</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_sum/#2463-minimum-total-distance-traveled","title":"2463. Minimum Total Distance Traveled","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_sum/#3333-find-the-original-typed-string-ii","title":"3333. Find the Original Typed String II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_sum/#2902-count-of-sub-multisets-with-bounded-sum","title":"2902. Count of Sub-Multisets With Bounded Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Dynamic Programming, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_sum/#629-k-inverse-pairs-array","title":"629. K Inverse Pairs Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_sum/#1977-number-of-ways-to-separate-numbers","title":"1977. Number of Ways to Separate Numbers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Suffix Array</p> </li> </ul>"},{"location":"EndlessCheng/dp_prefix_sum/#3130-find-all-possible-stable-binary-arrays-ii","title":"3130. Find All Possible Stable Binary Arrays II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/dp_print_solutions/","title":"DP Print Solutions","text":""},{"location":"EndlessCheng/dp_print_solutions/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 368. Largest Divisible Subset (Medium)</li> <li> 1449. Form Largest Integer With Digits That Add up to Target (Hard)</li> <li> 1092. Shortest Common Supersequence  (Hard)</li> <li> 943. Find the Shortest Superstring (Hard)</li> <li> 1125. Smallest Sufficient Team (Hard)</li> <li> 3260. Find the Largest Palindrome Divisible by K (Hard)</li> <li> 3149. Find the Minimum Cost Array Permutation (Hard)</li> <li> 3441. Minimum Cost Good Caption (Hard)</li> <li> 3348. Smallest Divisible Digit Product II (Hard)</li> <li> 656. Coin Path (Hard) \ud83d\udc51</li> <li> 471. Encode String with Shortest Length (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/dp_print_solutions/#368-largest-divisible-subset","title":"368. Largest Divisible Subset","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/dp_print_solutions/#1449-form-largest-integer-with-digits-that-add-up-to-target","title":"1449. Form Largest Integer With Digits That Add up to Target","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_print_solutions/#1092-shortest-common-supersequence","title":"1092. Shortest Common Supersequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_print_solutions/#943-find-the-shortest-superstring","title":"943. Find the Shortest Superstring","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Dynamic Programming, Bit Manipulation, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_print_solutions/#1125-smallest-sufficient-team","title":"1125. Smallest Sufficient Team","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Bit Manipulation, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_print_solutions/#3260-find-the-largest-palindrome-divisible-by-k","title":"3260. Find the Largest Palindrome Divisible by K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String, Dynamic Programming, Greedy, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/dp_print_solutions/#3149-find-the-minimum-cost-array-permutation","title":"3149. Find the Minimum Cost Array Permutation","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Bit Manipulation, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_print_solutions/#3441-minimum-cost-good-caption","title":"3441. Minimum Cost Good Caption","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_print_solutions/#3348-smallest-divisible-digit-product-ii","title":"3348. Smallest Divisible Digit Product II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String, Backtracking, Greedy, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/dp_print_solutions/#656-coin-path","title":"656. Coin Path \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_print_solutions/#471-encode-string-with-shortest-length","title":"471. Encode String with Shortest Length \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_probability_expectation/","title":"DP Probability Expectation","text":""},{"location":"EndlessCheng/dp_probability_expectation/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 688. Knight Probability in Chessboard (Medium)</li> <li> 837. New 21 Game (Medium)</li> <li> 1467. Probability of a Two Boxes Having The Same Number of Distinct Balls (Hard)</li> <li> 808. Soup Servings (Medium)</li> <li> 1230. Toss Strange Coins (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/dp_probability_expectation/#688-knight-probability-in-chessboard","title":"688. Knight Probability in Chessboard","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_probability_expectation/#837-new-21-game","title":"837. New 21 Game","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Sliding Window, Probability And Statistics</p> </li> </ul>"},{"location":"EndlessCheng/dp_probability_expectation/#1467-probability-of-a-two-boxes-having-the-same-number-of-distinct-balls","title":"1467. Probability of a Two Boxes Having The Same Number of Distinct Balls","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Backtracking, Combinatorics, Probability And Statistics</p> </li> </ul>"},{"location":"EndlessCheng/dp_probability_expectation/#808-soup-servings","title":"808. Soup Servings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Probability And Statistics</p> </li> </ul>"},{"location":"EndlessCheng/dp_probability_expectation/#1230-toss-strange-coins","title":"1230. Toss Strange Coins \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Probability And Statistics</p> </li> </ul>"},{"location":"EndlessCheng/dp_state_machine_advanced/","title":"DP State Machine Advanced","text":""},{"location":"EndlessCheng/dp_state_machine_advanced/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1262. Greatest Sum Divisible by Three (Medium)</li> <li> 1363. Largest Multiple of Three (Hard)</li> <li> 2771. Longest Non-decreasing Subarray From Two Arrays (Medium)</li> <li> 1594. Maximum Non Negative Product in a Matrix (Medium)</li> <li> 3196. Maximize Total Cost of Alternating Subarrays (Medium)</li> <li> 935. Knight Dialer (Medium)</li> <li> 1537. Get the Maximum Score (Hard)</li> <li> 2919. Minimum Increment Operations to Make Array Beautiful (Medium)</li> <li> 801. Minimum Swaps To Make Sequences Increasing (Hard)</li> <li> 3434. Maximum Frequency After Subarray Operation (Medium)</li> <li> 1955. Count Number of Special Subsequences (Hard)</li> <li> 3068. Find the Maximum Sum of Node Values (Hard)</li> <li> 2272. Substring With Largest Variance (Hard)</li> <li> 276. Paint Fence (Medium) \ud83d\udc51</li> <li> 1746. Maximum Subarray Sum After One Operation (Medium) \ud83d\udc51</li> <li> 2036. Maximum Alternating Subarray Sum (Medium) \ud83d\udc51</li> <li> 2361. Minimum Costs Using the Train Line (Hard) \ud83d\udc51</li> <li> 3269. Constructing Two Increasing Arrays (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/dp_state_machine_advanced/#1262-greatest-sum-divisible-by-three","title":"1262. Greatest Sum Divisible by Three","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/dp_state_machine_advanced/#1363-largest-multiple-of-three","title":"1363. Largest Multiple of Three","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/dp_state_machine_advanced/#2771-longest-non-decreasing-subarray-from-two-arrays","title":"2771. Longest Non-decreasing Subarray From Two Arrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_state_machine_advanced/#1594-maximum-non-negative-product-in-a-matrix","title":"1594. Maximum Non Negative Product in a Matrix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/dp_state_machine_advanced/#3196-maximize-total-cost-of-alternating-subarrays","title":"3196. Maximize Total Cost of Alternating Subarrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_state_machine_advanced/#935-knight-dialer","title":"935. Knight Dialer","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_state_machine_advanced/#1537-get-the-maximum-score","title":"1537. Get the Maximum Score","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Dynamic Programming, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/dp_state_machine_advanced/#2919-minimum-increment-operations-to-make-array-beautiful","title":"2919. Minimum Increment Operations to Make Array Beautiful","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_state_machine_advanced/#801-minimum-swaps-to-make-sequences-increasing","title":"801. Minimum Swaps To Make Sequences Increasing","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_state_machine_advanced/#3434-maximum-frequency-after-subarray-operation","title":"3434. Maximum Frequency After Subarray Operation","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Dynamic Programming, Greedy, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/dp_state_machine_advanced/#1955-count-number-of-special-subsequences","title":"1955. Count Number of Special Subsequences","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_state_machine_advanced/#3068-find-the-maximum-sum-of-node-values","title":"3068. Find the Maximum Sum of Node Values","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy, Bit Manipulation, Tree, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/dp_state_machine_advanced/#2272-substring-with-largest-variance","title":"2272. Substring With Largest Variance","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>from itertools import permutations\nfrom math import inf\nfrom string import ascii_lowercase\n\n\n# DP State Machine\ndef largestVariance(s: str) -&gt; int:\n    res = 0\n\n    for a, b in permutations(ascii_lowercase, 2):\n        f0, f1 = 0, -inf\n        for ch in s:\n            if ch == a:\n                f0 = max(f0, 0) + 1\n                f1 += 1\n            elif ch == b:\n                f1 = f0 = max(f0, 0) - 1\n\n            res = max(res, f1)\n    return res\n\n\nif __name__ == \"__main__\":\n    s = \"aababbb\"\n    print(largestVariance(s))  # 3\n</code></pre>"},{"location":"EndlessCheng/dp_state_machine_advanced/#276-paint-fence","title":"276. Paint Fence \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_state_machine_advanced/#1746-maximum-subarray-sum-after-one-operation","title":"1746. Maximum Subarray Sum After One Operation \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_state_machine_advanced/#2036-maximum-alternating-subarray-sum","title":"2036. Maximum Alternating Subarray Sum \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_state_machine_advanced/#2361-minimum-costs-using-the-train-line","title":"2361. Minimum Costs Using the Train Line \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_state_machine_advanced/#3269-constructing-two-increasing-arrays","title":"3269. Constructing Two Increasing Arrays \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_state_machine_basics/","title":"DP State Machine Basics","text":""},{"location":"EndlessCheng/dp_state_machine_basics/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3259. Maximum Energy Boost From Two Drinks (Medium)</li> <li> 2222. Number of Ways to Select Buildings (Medium)</li> <li> 1567. Maximum Length of Subarray With Positive Product (Medium)</li> <li> 2708. Maximum Strength of a Group (Medium)</li> <li> 2826. Sorting Three Groups (Medium)</li> <li> 2786. Visit Array Positions to Maximize Score (Medium)</li> <li> 1911. Maximum Alternating Subsequence Sum (Medium)</li> <li> 376. Wiggle Subsequence (Medium)</li> <li> 1186. Maximum Subarray Sum with One Deletion (Medium)</li> </ul>"},{"location":"EndlessCheng/dp_state_machine_basics/#3259-maximum-energy-boost-from-two-drinks","title":"3259. Maximum Energy Boost From Two Drinks","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_state_machine_basics/#2222-number-of-ways-to-select-buildings","title":"2222. Number of Ways to Select Buildings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/dp_state_machine_basics/#1567-maximum-length-of-subarray-with-positive-product","title":"1567. Maximum Length of Subarray With Positive Product","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/dp_state_machine_basics/#2708-maximum-strength-of-a-group","title":"2708. Maximum Strength of a Group","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Backtracking, Greedy, Bit Manipulation, Sorting, Enumeration</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP\ndef maxStrength(nums: List[int]) -&gt; int:\n    if not nums:\n        return 0\n\n    cur_min, cur_max = nums[0], nums[0]\n\n    for i, num in enumerate(nums):\n        if i == 0:\n            continue\n\n        temp_min = min(cur_min, num, num * cur_min, num * cur_max)\n        temp_max = max(cur_max, num, num * cur_min, num * cur_max)\n        cur_min, cur_max = temp_min, temp_max\n\n    return cur_max\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |  DP        |  O(N)  |  O(1)   |\n# |------------|--------|---------|\n\n\nnums = [3, -1, -5, 2, 5, -9]\nprint(maxStrength(nums))  # 1350\n</code></pre>"},{"location":"EndlessCheng/dp_state_machine_basics/#2826-sorting-three-groups","title":"2826. Sorting Three Groups","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Dynamic Programming</p> </li> </ul> Python <pre><code>from functools import cache\nfrom typing import List\n\n\n# DP - LIS\ndef minimumOperationsMemo(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return 0\n\n    @cache\n    def dfs(i):\n        res = 0\n        for j in range(i):\n            if nums[i] &gt;= nums[j]:\n                res = max(res, dfs(j))\n        return res + 1\n\n    LIS = max(dfs(i) for i in range(n))\n\n    return n - LIS\n\n\n# DP - LIS\ndef minimumOperationsTable(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return 0\n\n    dp = [1 for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i):\n            if nums[i] &gt;= nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return n - max(dp)\n\n\n# DP - LIS\ndef minimumOperationsTableOptimized(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return 0\n\n    dp = [0 for _ in range(4)]\n\n    for num in nums:\n        dp[num] += 1\n        dp[2] = max(dp[2], dp[1])\n        dp[3] = max(dp[3], dp[2])\n\n    return n - dp[3]\n\n\nif __name__ == \"__main__\":\n    assert minimumOperationsMemo([2, 1, 3, 2, 1]) == 3\n    assert minimumOperationsTable([2, 1, 3, 2, 1]) == 3\n    assert minimumOperationsTableOptimized([2, 1, 3, 2, 1]) == 3\n</code></pre>"},{"location":"EndlessCheng/dp_state_machine_basics/#2786-visit-array-positions-to-maximize-score","title":"2786. Visit Array Positions to Maximize Score","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_state_machine_basics/#1911-maximum-alternating-subsequence-sum","title":"1911. Maximum Alternating Subsequence Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_state_machine_basics/#376-wiggle-subsequence","title":"376. Wiggle Subsequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the length of the longest wiggle subsequence.\n-   `up[n]` stores the length of the longest wiggle subsequence ending at `n` with a rising wiggle.\n-   `down[n]` stores the length of the longest wiggle subsequence ending at `n` with a falling wiggle.\n-   Initialize `up[0] = 1` and `down[0] = 1`.\n-   Example: `nums = [1, 7, 4, 9, 2, 5]`\n\n| `nums[n]` | `nums[n-1]` | `up[n-1]` | `down[n-1]` | `up[n]` | `down[n]` |\n| :-------: | :---------: | :-------: | :---------: | :-----: | :-------: |\n|     1     |      -      |     -     |      -      |    1    |     1     |\n|     7     |      1      |     1     |      1      |    2    |     1     |\n|     4     |      7      |     2     |      1      |    2    |     3     |\n|     9     |      4      |     2     |      3      |    4    |     3     |\n|     2     |      9      |     4     |      3      |    4    |     5     |\n|     5     |      2      |     4     |      5      |    6    |     5     |\n\"\"\"\n\nfrom typing import List\n\n\n# DP\ndef wiggleMaxLengthDP(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 1:\n        return len(nums)\n\n    up = [0 for _ in range(len(nums))]\n    down = [0 for _ in range(len(nums))]\n\n    up[0], down[0] = 1, 1\n\n    for i in range(1, len(nums)):\n        if nums[i] &gt; nums[i - 1]:\n            up[i] = down[i - 1] + 1\n            down[i] = down[i - 1]\n        elif nums[i] &lt; nums[i - 1]:\n            down[i] = up[i - 1] + 1\n            up[i] = up[i - 1]\n        else:\n            up[i] = up[i - 1]\n            down[i] = down[i - 1]\n\n    return max(up[-1], down[-1])\n\n\n# Greedy\ndef wiggleMaxLengthGreedy(nums: List[int]) -&gt; int:\n    if len(nums) &lt; 2:\n        return len(nums)\n\n    prev_diff = nums[1] - nums[0]\n    count = 2 if prev_diff != 0 else 1\n\n    for i in range(2, len(nums)):\n        diff = nums[i] - nums[i - 1]\n        if (diff &gt; 0 and prev_diff &lt;= 0) or (diff &lt; 0 and prev_diff &gt;= 0):\n            count += 1\n            prev_diff = diff\n\n    return count\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    DP       |      O(n)       |     O(n)     |\n# |  Greedy     |      O(n)       |     O(1)     |\n# |-------------|-----------------|--------------|\n\nnums = [1, 7, 4, 9, 2, 5]\nprint(wiggleMaxLengthDP(nums))  # 6\nprint(wiggleMaxLengthGreedy(nums))  # 6\n</code></pre>"},{"location":"EndlessCheng/dp_state_machine_basics/#1186-maximum-subarray-sum-with-one-deletion","title":"1186. Maximum Subarray Sum with One Deletion","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>\"\"\"\n- [\u7075\u795e\uff1a\u6559\u4f60\u4e00\u6b65\u6b65\u601d\u8003\u52a8\u6001\u89c4\u5212 - \u4ece\u8bb0\u5fc6\u5316\u641c\u7d22\u5230\u9012\u63a8](https://leetcode.cn/problems/maximum-subarray-sum-with-one-deletion/solutions/2321829/jiao-ni-yi-bu-bu-si-kao-dong-tai-gui-hua-hzz6))\n\"\"\"\n\nfrom functools import cache\nfrom math import inf\nfrom typing import List\n\n\n# DP - Kadane\ndef maximumSum(arr: List[int]) -&gt; int:\n    dp0 = arr[0]\n    dp1 = 0\n    res = dp0\n\n    for i in range(1, len(arr)):\n        dp1 = max(dp1 + arr[i], dp0)  # delete previous element or not\n        dp0 = max(dp0, 0) + arr[i]  # delete current element or not\n        res = max(res, dp0, dp1)  # update result\n\n    return res\n\n\n# DP - Memoization\ndef maximumSumMemo(arr: List[int]) -&gt; int:\n    @cache\n    def dfs(i: int, j: int) -&gt; int:\n        if i &lt; 0:\n            return -inf\n        if j == 0:\n            return max(dfs(i - 1, 0), 0) + arr[i]\n        return max(dfs(i - 1, 1) + arr[i], dfs(i - 1, 0))\n\n    return max(max(dfs(i, 0), dfs(i, 1)) for i in range(len(arr)))\n\n\nif __name__ == \"__main__\":\n    arr = [1, -2, 0, 3]\n    assert maximumSum(arr) == 4\n    assert maximumSumMemo(arr) == 4\n</code></pre>"},{"location":"EndlessCheng/dp_stock_trading/","title":"DP Stock Trading","text":""},{"location":"EndlessCheng/dp_stock_trading/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 121. Best Time to Buy and Sell Stock (Easy)</li> <li> 122. Best Time to Buy and Sell Stock II (Medium)</li> <li> 123. Best Time to Buy and Sell Stock III (Hard)</li> <li> 188. Best Time to Buy and Sell Stock IV (Hard)</li> <li> 309. Best Time to Buy and Sell Stock with Cooldown (Medium)</li> <li> 714. Best Time to Buy and Sell Stock with Transaction Fee (Medium)</li> </ul>"},{"location":"EndlessCheng/dp_stock_trading/#121-best-time-to-buy-and-sell-stock","title":"121. Best Time to Buy and Sell Stock","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return the maximum profit that can be achieved from buying on one day and selling on another day.\n\"\"\"\n\nfrom typing import List\n\n\n# Brute Force\ndef maxProfitBF(prices: List[int]) -&gt; int:\n    max_profit = 0\n    n = len(prices)\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_profit = max(max_profit, prices[j] - prices[i])\n\n    return max_profit\n\n\n# DP\ndef maxProfitDP(prices: List[int]) -&gt; int:\n    dp = [[0] * 2 for _ in range(len(prices))]\n    dp[0][0] = -prices[0]  # buy\n    dp[0][1] = 0  # sell\n\n    for i in range(1, len(prices)):\n        dp[i][0] = max(dp[i - 1][0], -prices[i])  # the lowest price to buy\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    max_profit = 0\n    seen_min = prices[0]\n\n    for i in range(1, len(prices)):\n        max_profit = max(max_profit, prices[i] - seen_min)\n        seen_min = min(seen_min, prices[i])\n\n    return max_profit\n\n\n# Fast Slow Pointers\ndef maxProfitFS(prices: List[int]) -&gt; int:\n    max_profit = 0\n    slow, fast = 0, 1\n\n    while fast &lt; len(prices):\n        if prices[fast] &gt; prices[slow]:\n            max_profit = max(max_profit, prices[fast] - prices[slow])\n        else:\n            slow = fast\n        fast += 1\n\n    return max_profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force|  O(n^2)|  O(1)   |\n# | DP         |  O(n)  |  O(n)   |\n# | Greedy     |  O(n)  |  O(1)   |\n# | Fast Slow  |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitBF(prices))  # 5\nprint(maxProfitDP(prices))  # 5\nprint(maxProfitGreedy(prices))  # 5\nprint(maxProfitFS(prices))  # 5\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int maxProfitMemo(vector&lt;int&gt; &amp;prices) {\n        if (prices.size() &lt;= 1) return 0;\n\n        int seen_min = prices[0];\n        int res = 0;\n\n        for (int &amp;price : prices) {\n            res = max(res, price - seen_min);\n            seen_min = min(seen_min, price);\n        }\n        return res;\n    }\n};\n\nint main() {\n    vector&lt;int&gt; prices = {7, 1, 5, 3, 6, 4};\n    Solution obj;\n    cout &lt;&lt; obj.maxProfitMemo(prices) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/dp_stock_trading/#122-best-time-to-buy-and-sell-stock-ii","title":"122. Best Time to Buy and Sell Stock II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return the maximum profit you can achieve.\n\"\"\"\n\nfrom typing import List\n\n\n# DP\ndef maxProfitDP1(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 2 for _ in range(n)]\n    dp[0][0] = -prices[0]\n    dp[0][1] = 0\n\n    for i in range(1, n):\n        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i])\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# DP - Optimized\ndef maxProfitDP2(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    hold = -prices[0]\n    profit = 0\n\n    for i in range(1, n):\n        hold = max(hold, profit - prices[i])\n        profit = max(profit, hold + prices[i])\n\n    return profit\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    profit = 0\n\n    for i in range(1, len(prices)):\n        profit += max(prices[i] - prices[i - 1], 0)\n\n    return profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |     DP1    |  O(n)  |   O(n)  |\n# |     DP2    |  O(n)  |   O(1)  |\n# |   Greedy   |  O(n)  |   O(1)  |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitDP1(prices))  # 7\nprint(maxProfitDP2(prices))  # 7\nprint(maxProfitGreedy(prices))  # 7\n</code></pre> <pre><code>#include &lt;array&gt;\n#include &lt;cassert&gt;\n#include &lt;climits&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int maxProfitMemo(vector&lt;int&gt;&amp; prices) {\n        int n = prices.size();\n        vector&lt;array&lt;int, 2&gt;&gt; memo(n, {-1, -1});\n\n        auto dfs = [&amp;](this auto&amp;&amp; dfs, int i, bool hold) -&gt; int {\n            if (i &lt; 0) {\n                return hold ? INT_MIN : 0;\n            }\n            int&amp; res = memo[i][hold];\n            if (res != -1) {\n                return res;\n            }\n            if (hold) {\n                return res = max(dfs(i - 1, true),                // skip\n                                 dfs(i - 1, false) - prices[i]);  // buy\n            } else {\n                return res = max(dfs(i - 1, false),              // skip\n                                 dfs(i - 1, true) + prices[i]);  // sell\n            }\n        };\n\n        return dfs(n - 1, false);\n    }\n\n    int maxProfitIterative(vector&lt;int&gt;&amp; prices) {\n        int n = prices.size();\n        vector&lt;array&lt;int, 2&gt;&gt; dp(n, {0, 0});\n        dp[0][0] = -prices[0];\n        dp[0][1] = 0;\n\n        for (int i = 1; i &lt; n; i++) {\n            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);  // buy\n            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);  // sell\n        }\n        return dp[n - 1][1];\n    }\n\n    int maxProfitIterativeOptimized(vector&lt;int&gt;&amp; prices) {\n        int n = prices.size();\n        if (n &lt;= 1) return 0;\n\n        int hold = -prices[0], res = 0;\n\n        for (int i = 1; i &lt; n; i++) {\n            hold = max(hold, res - prices[i]);  // buy\n            res = max(res, hold + prices[i]);   // sell\n        }\n        return res;\n    }\n\n    int maxProfitGreedy(vector&lt;int&gt;&amp; prices) {\n        int n = prices.size();\n        if (n &lt;= 1) return 0;\n\n        int res = 0;\n\n        for (int i = 1; i &lt; n; i++) {\n            if (prices[i] &gt; prices[i - 1]) {\n                res += prices[i] - prices[i - 1];\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; prices = {7, 1, 5, 3, 6, 4};\n    assert(solution.maxProfitMemo(prices) == 7);\n    assert(solution.maxProfitIterative(prices) == 7);\n    assert(solution.maxProfitIterativeOptimized(prices) == 7);\n    assert(solution.maxProfitGreedy(prices) == 7);\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/dp_stock_trading/#123-best-time-to-buy-and-sell-stock-iii","title":"123. Best Time to Buy and Sell Stock III","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# 1. DP\ndef maxProfitDP1(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 5 for _ in range(n)]\n\n    dp[0][0] = 0  # no transaction\n    dp[0][1] = -prices[0]  # buy 1\n    dp[0][2] = 0  # sell 1\n    dp[0][3] = -prices[0]  # buy 2\n    dp[0][4] = 0  # sell 2\n\n    for i in range(1, n):\n        dp[i][0] = dp[i - 1][0]\n        dp[i][1] = max(dp[i - 1][1], -prices[i])\n        dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i])\n        dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i])\n        dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i])\n\n    return dp[-1][4]\n\n\n# 2. DP - Optimized\ndef maxProfitDP2(prices: List[int]) -&gt; int:\n    b1, b2 = float(\"inf\"), float(\"inf\")\n    s1, s2 = 0, 0\n\n    for price in prices:\n        b1 = min(b1, price)\n        s1 = max(s1, price - b1)\n        b2 = min(b2, price - s1)\n        s2 = max(s2, price - b2)\n\n    return s2\n\n\nprices = [3, 3, 5, 0, 0, 3, 1, 4]\nprint(maxProfitDP1(prices))  # 6\nprint(maxProfitDP2(prices))  # 6\n</code></pre>"},{"location":"EndlessCheng/dp_stock_trading/#188-best-time-to-buy-and-sell-stock-iv","title":"188. Best Time to Buy and Sell Stock IV","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP\ndef maxProfit(k: int, prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * (2 * k + 1) for _ in range(n)]\n\n    for j in range(1, 2 * k, 2):\n        dp[0][j] = -prices[0]\n\n    for i in range(1, n):\n        for j in range(0, 2 * k - 1, 2):\n            dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i])\n            dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i])\n\n    return dp[-1][2 * k]\n\n\nk = 2\nprices = [2, 4, 1]\nprint(maxProfit(k, prices))  # 2\n</code></pre>"},{"location":"EndlessCheng/dp_stock_trading/#309-best-time-to-buy-and-sell-stock-with-cooldown","title":"309. Best Time to Buy and Sell Stock with Cooldown","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP\ndef maxProfit(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 4 for _ in range(n)]\n\n    dp[0][0] = -prices[0]  # poessess\n    dp[0][1] = 0  # stay sold\n    dp[0][2] = 0  # sell\n    dp[0][3] = 0  # cooldown\n\n    for i in range(1, n):\n        dp[i][0] = max(\n            dp[i - 1][0],  # stay poessess\n            dp[i - 1][1] - prices[i],  # buy after stay sold\n            dp[i - 1][3] - prices[i],  # buy after cooldown\n        )\n        dp[i][1] = max(\n            dp[i - 1][1],  # stay sold\n            dp[i - 1][3],  # stay cooldown\n        )\n        dp[i][2] = dp[i - 1][0] + prices[i]\n        dp[i][3] = dp[i - 1][2]\n\n    return max(dp[-1])\n\n\nprices = [1, 2, 3, 0, 2]\nprint(maxProfit(prices))  # 3\n</code></pre>"},{"location":"EndlessCheng/dp_stock_trading/#714-best-time-to-buy-and-sell-stock-with-transaction-fee","title":"714. Best Time to Buy and Sell Stock with Transaction Fee","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the maximum profit you can achieve with the given transaction fee.\n\"\"\"\n\nfrom typing import List\n\n\n# 1. DP\ndef maxProfitDP(prices: List[int], fee: int) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 2 for _ in range(n)]\n\n    dp[0][0] = -prices[0] - fee\n    dp[0][1] = 0\n\n    for i in range(1, n):\n        dp[i][0] = max(\n            dp[i - 1][0],  # hold\n            dp[i - 1][1] - prices[i] - fee,  # buy\n        )\n        dp[i][1] = max(\n            dp[i - 1][1],  # hold\n            dp[i - 1][0] + prices[i],  # sell\n        )\n\n    return max(dp[-1])\n\n\n# 2. Greedy\ndef maxProfitGreedy(prices: List[int], fee: int) -&gt; int:\n    n = len(prices)\n    if n == 0:\n        return 0\n\n    buy = prices[0]\n    profit = 0\n\n    for i in range(1, n):\n        if prices[i] &lt; buy:\n            buy = prices[i]\n        elif prices[i] &gt; buy + fee:\n            profit += prices[i] - buy - fee\n            buy = prices[i] - fee\n\n    return profit\n\n\nprices = [1, 3, 2, 8, 4, 9]\nfee = 2\nprint(maxProfitDP(prices, fee))  # 8\nprint(maxProfitGreedy(prices, fee))  # 8\n</code></pre>"},{"location":"EndlessCheng/dp_subrectangle/","title":"DP Subrectangle","text":""},{"location":"EndlessCheng/dp_subrectangle/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3148. Maximum Difference Score in a Grid (Medium)</li> <li> 221. Maximal Square (Medium)</li> <li> 1277. Count Square Submatrices with All Ones (Medium)</li> <li> 2088. Count Fertile Pyramids in a Land (Hard)</li> <li> 3197. Find the Minimum Area to Cover All Ones II (Hard)</li> </ul>"},{"location":"EndlessCheng/dp_subrectangle/#3148-maximum-difference-score-in-a-grid","title":"3148. Maximum Difference Score in a Grid","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/dp_subrectangle/#221-maximal-square","title":"221. Maximal Square","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/dp_subrectangle/#1277-count-square-submatrices-with-all-ones","title":"1277. Count Square Submatrices with All Ones","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/dp_subrectangle/#2088-count-fertile-pyramids-in-a-land","title":"2088. Count Fertile Pyramids in a Land","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/dp_subrectangle/#3197-find-the-minimum-area-to-cover-all-ones-ii","title":"3197. Find the Minimum Area to Cover All Ones II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Matrix, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/dp_subset_state_compression/","title":"DP Subset State Compression","text":""},{"location":"EndlessCheng/dp_subset_state_compression/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2305. Fair Distribution of Cookies (Medium)</li> <li> 1986. Minimum Number of Work Sessions to Finish the Tasks (Medium)</li> <li> 1723. Find Minimum Time to Finish All Jobs (Hard)</li> <li> 1655. Distribute Repeating Integers (Hard)</li> <li> 1349. Maximum Students Taking Exam (Hard)</li> <li> 1681. Minimum Incompatibility (Hard)</li> <li> 3444. Minimum Increments for Target Multiples in an Array (Hard)</li> <li> 2572. Count the Number of Square-Free Subsets (Medium)</li> <li> 1994. The Number of Good Subsets (Hard)</li> <li> 1494. Parallel Courses II (Hard)</li> <li> 465. Optimal Account Balancing (Hard) \ud83d\udc51</li> <li> 2152. Minimum Number of Lines to Cover Points (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/dp_subset_state_compression/#2305-fair-distribution-of-cookies","title":"2305. Fair Distribution of Cookies","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Backtracking, Bit Manipulation, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_subset_state_compression/#1986-minimum-number-of-work-sessions-to-finish-the-tasks","title":"1986. Minimum Number of Work Sessions to Finish the Tasks","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Backtracking, Bit Manipulation, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_subset_state_compression/#1723-find-minimum-time-to-finish-all-jobs","title":"1723. Find Minimum Time to Finish All Jobs","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Backtracking, Bit Manipulation, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_subset_state_compression/#1655-distribute-repeating-integers","title":"1655. Distribute Repeating Integers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Backtracking, Bit Manipulation, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_subset_state_compression/#1349-maximum-students-taking-exam","title":"1349. Maximum Students Taking Exam","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Bit Manipulation, Matrix, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_subset_state_compression/#1681-minimum-incompatibility","title":"1681. Minimum Incompatibility","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Bit Manipulation, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_subset_state_compression/#3444-minimum-increments-for-target-multiples-in-an-array","title":"3444. Minimum Increments for Target Multiples in an Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Bit Manipulation, Number Theory, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_subset_state_compression/#2572-count-the-number-of-square-free-subsets","title":"2572. Count the Number of Square-Free Subsets","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Bit Manipulation, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_subset_state_compression/#1994-the-number-of-good-subsets","title":"1994. The Number of Good Subsets","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Bit Manipulation, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_subset_state_compression/#1494-parallel-courses-ii","title":"1494. Parallel Courses II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Bit Manipulation, Graph, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_subset_state_compression/#465-optimal-account-balancing","title":"465. Optimal Account Balancing \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Backtracking, Bit Manipulation, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_subset_state_compression/#2152-minimum-number-of-lines-to-cover-points","title":"2152. Minimum Number of Lines to Cover Points \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Dynamic Programming, Backtracking, Bit Manipulation, Geometry, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_transform_x_to_y/","title":"DP Transform X to Y","text":""},{"location":"EndlessCheng/dp_transform_x_to_y/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 397. Integer Replacement (Medium)</li> <li> 2998. Minimum Number of Operations to Make X and Y Equal (Medium)</li> <li> 2059. Minimum Operations to Convert Number (Medium)</li> <li> 991. Broken Calculator (Medium)</li> <li> 1553. Minimum Number of Days to Eat N Oranges (Hard)</li> <li> 3377. Digit Operations to Make Two Integers Equal (Medium)</li> </ul>"},{"location":"EndlessCheng/dp_transform_x_to_y/#397-integer-replacement","title":"397. Integer Replacement","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Greedy, Bit Manipulation, Memoization</p> </li> </ul>"},{"location":"EndlessCheng/dp_transform_x_to_y/#2998-minimum-number-of-operations-to-make-x-and-y-equal","title":"2998. Minimum Number of Operations to Make X and Y Equal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Breadth First Search, Memoization</p> </li> </ul>"},{"location":"EndlessCheng/dp_transform_x_to_y/#2059-minimum-operations-to-convert-number","title":"2059. Minimum Operations to Convert Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Breadth First Search</p> </li> </ul>"},{"location":"EndlessCheng/dp_transform_x_to_y/#991-broken-calculator","title":"991. Broken Calculator","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/dp_transform_x_to_y/#1553-minimum-number-of-days-to-eat-n-oranges","title":"1553. Minimum Number of Days to Eat N Oranges","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Memoization</p> </li> </ul>"},{"location":"EndlessCheng/dp_transform_x_to_y/#3377-digit-operations-to-make-two-integers-equal","title":"3377. Digit Operations to Make Two Integers Equal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Graph, Heap Priority Queue, Number Theory, Shortest Path</p> </li> </ul>"},{"location":"EndlessCheng/dp_traveling_salesman_problem/","title":"DP Traveling Salesman Problem","text":""},{"location":"EndlessCheng/dp_traveling_salesman_problem/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 943. Find the Shortest Superstring (Hard)</li> <li> 847. Shortest Path Visiting All Nodes (Hard)</li> <li> 2247. Maximum Cost of Trip With K Highways (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/dp_traveling_salesman_problem/#943-find-the-shortest-superstring","title":"943. Find the Shortest Superstring","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Dynamic Programming, Bit Manipulation, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_traveling_salesman_problem/#847-shortest-path-visiting-all-nodes","title":"847. Shortest Path Visiting All Nodes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Bit Manipulation, Breadth First Search, Graph, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_traveling_salesman_problem/#2247-maximum-cost-of-trip-with-k-highways","title":"2247. Maximum Cost of Trip With K Highways \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Bit Manipulation, Graph, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/dp_trie/","title":"DP Trie","text":""},{"location":"EndlessCheng/dp_trie/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 139. Word Break (Medium)</li> <li> 140. Word Break II (Hard)</li> <li> 472. Concatenated Words (Hard)</li> <li> 2977. Minimum Cost to Convert String II (Hard)</li> </ul>"},{"location":"EndlessCheng/dp_trie/#139-word-break","title":"139. Word Break","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Dynamic Programming, Trie, Memoization</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\n# DP (Unbounded Knapsack)\ndef wordBreak(s: str, wordDict: List[str]) -&gt; bool:\n    n = len(s)\n    dp = [False for _ in range(n + 1)]\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for word in wordDict:\n            m = len(word)\n            if s[i - m : i] == word and dp[i - m]:\n                dp[i] = True\n    return dp[-1]\n\n\ns = \"leetcode\"\nwordDict = [\"leet\", \"code\"]\nprint(wordBreak(s, wordDict))  # True\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;cassert&gt;\n#include &lt;ranges&gt;\n#include &lt;string&gt;\n#include &lt;unordered_set&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) {\n        int max_len = ranges::max(wordDict, {}, &amp;string::length).length();\n        unordered_set&lt;string&gt; words(wordDict.begin(), wordDict.end());\n\n        int n = s.length();\n        vector&lt;int&gt; f(n + 1);\n        f[0] = true;\n        for (int i = 1; i &lt;= n; i++) {\n            for (int j = i - 1; j &gt;= max(i - max_len, 0); j--) {\n                if (f[j] &amp;&amp; words.count(s.substr(j, i - j))) {\n                    f[i] = true;\n                    break;\n                }\n            }\n        }\n        return f[n];\n    }\n};\n\nint main() {\n    Solution solution;\n    string s = \"leetcode\";\n    vector&lt;string&gt; wordDict = {\"leet\", \"code\"};\n    assert(solution.wordBreak(s, wordDict) == true);\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/dp_trie/#140-word-break-ii","title":"140. Word Break II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Dynamic Programming, Backtracking, Trie, Memoization</p> </li> </ul>"},{"location":"EndlessCheng/dp_trie/#472-concatenated-words","title":"472. Concatenated Words","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Dynamic Programming, Depth First Search, Trie</p> </li> </ul>"},{"location":"EndlessCheng/dp_trie/#2977-minimum-cost-to-convert-string-ii","title":"2977. Minimum Cost to Convert String II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Dynamic Programming, Graph, Trie, Shortest Path</p> </li> </ul>"},{"location":"EndlessCheng/dp_valid_subsequence/","title":"DP Valid Subsequence","text":""},{"location":"EndlessCheng/dp_valid_subsequence/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2501. Longest Square Streak in an Array (Medium)</li> <li> 1218. Longest Arithmetic Subsequence of Given Difference (Medium)</li> <li> 1027. Longest Arithmetic Subsequence (Medium)</li> <li> 873. Length of Longest Fibonacci Subsequence (Medium)</li> <li> 3202. Find the Maximum Length of Valid Subsequence II (Medium)</li> <li> 446. Arithmetic Slices II - Subsequence (Hard)</li> <li> 3351. Sum of Good Subsequences (Hard)</li> <li> 3041. Maximize Consecutive Elements in an Array After Modification (Hard)</li> <li> 3409. Longest Subsequence With Decreasing Adjacent Difference (Medium)</li> <li> 3098. Find the Sum of Subsequence Powers (Hard)</li> <li> 1048. Longest String Chain (Medium)</li> </ul>"},{"location":"EndlessCheng/dp_valid_subsequence/#2501-longest-square-streak-in-an-array","title":"2501. Longest Square Streak in an Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Binary Search, Dynamic Programming, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/dp_valid_subsequence/#1218-longest-arithmetic-subsequence-of-given-difference","title":"1218. Longest Arithmetic Subsequence of Given Difference","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_valid_subsequence/#1027-longest-arithmetic-subsequence","title":"1027. Longest Arithmetic Subsequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Binary Search, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_valid_subsequence/#873-length-of-longest-fibonacci-subsequence","title":"873. Length of Longest Fibonacci Subsequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_valid_subsequence/#3202-find-the-maximum-length-of-valid-subsequence-ii","title":"3202. Find the Maximum Length of Valid Subsequence II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_valid_subsequence/#446-arithmetic-slices-ii-subsequence","title":"446. Arithmetic Slices II - Subsequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_valid_subsequence/#3351-sum-of-good-subsequences","title":"3351. Sum of Good Subsequences","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_valid_subsequence/#3041-maximize-consecutive-elements-in-an-array-after-modification","title":"3041. Maximize Consecutive Elements in an Array After Modification","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/dp_valid_subsequence/#3409-longest-subsequence-with-decreasing-adjacent-difference","title":"3409. Longest Subsequence With Decreasing Adjacent Difference","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/dp_valid_subsequence/#3098-find-the-sum-of-subsequence-powers","title":"3098. Find the Sum of Subsequence Powers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/dp_valid_subsequence/#1048-longest-string-chain","title":"1048. Longest String Chain","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Two Pointers, String, Dynamic Programming, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/dp_wqs_binary_search/","title":"DP WQS Binary Search","text":""},{"location":"EndlessCheng/dp_wqs_binary_search/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 188. Best Time to Buy and Sell Stock IV (Hard)</li> <li> 2209. Minimum White Tiles After Covering With Carpets (Hard)</li> </ul>"},{"location":"EndlessCheng/dp_wqs_binary_search/#188-best-time-to-buy-and-sell-stock-iv","title":"188. Best Time to Buy and Sell Stock IV","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP\ndef maxProfit(k: int, prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * (2 * k + 1) for _ in range(n)]\n\n    for j in range(1, 2 * k, 2):\n        dp[0][j] = -prices[0]\n\n    for i in range(1, n):\n        for j in range(0, 2 * k - 1, 2):\n            dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i])\n            dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i])\n\n    return dp[-1][2 * k]\n\n\nk = 2\nprices = [2, 4, 1]\nprint(maxProfit(k, prices))  # 2\n</code></pre>"},{"location":"EndlessCheng/dp_wqs_binary_search/#2209-minimum-white-tiles-after-covering-with-carpets","title":"2209. Minimum White Tiles After Covering With Carpets","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/dual_heap/","title":"Dual Heap","text":""},{"location":"EndlessCheng/dual_heap/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2102. Sequentially Ordinal Rank Tracker (Hard)</li> <li> 295. Find Median from Data Stream (Hard)</li> <li> 480. Sliding Window Median (Hard)</li> <li> 1825. Finding MK Average (Hard)</li> <li> 3013. Divide an Array Into Subarrays With Minimum Cost II (Hard)</li> <li> 3321. Find X-Sum of All K-Long Subarrays II (Hard)</li> <li> 3369. Design an Array Statistics Tracker  (Hard) \ud83d\udc51</li> <li> 3422. Minimum Operations to Make Subarray Elements Equal (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/dual_heap/#2102-sequentially-ordinal-rank-tracker","title":"2102. Sequentially Ordinal Rank Tracker","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Design, Heap Priority Queue, Data Stream, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/dual_heap/#295-find-median-from-data-stream","title":"295. Find Median from Data Stream","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, Design, Sorting, Heap Priority Queue, Data Stream</p> </li> </ul> PythonCPP <pre><code>from heapq import heappop, heappush\n\n\nclass MedianFinder:\n\n    def __init__(self):\n        self.minHeap = []\n        self.maxHeap = []\n        self.min_size = 0\n        self.max_size = 0\n\n    def addNum(self, num: int) -&gt; None:\n        heappush(self.maxHeap, -num)\n        heappush(self.minHeap, -heappop(self.maxHeap))\n        self.min_size += 1\n\n        if self.min_size &gt; self.max_size:\n            heappush(self.maxHeap, -heappop(self.minHeap))\n            self.min_size -= 1\n            self.max_size += 1\n\n    def findMedian(self) -&gt; float:\n        if self.min_size == self.max_size:\n            return (-self.maxHeap[0] + self.minHeap[0]) / 2.0\n        return float(-self.maxHeap[0])\n\n\ndef test_median_finder():\n    obj = MedianFinder()\n    obj.addNum(1)\n    obj.addNum(2)\n    assert obj.findMedian() == 1.5\n    obj.addNum(3)\n    assert obj.findMedian() == 2.0\n    obj.addNum(4)\n    assert obj.findMedian() == 2.5\n    obj.addNum(5)\n    assert obj.findMedian() == 3.0\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass MedianFinder {\n   private:\n    priority_queue&lt;int&gt; maxHeap;\n    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;\n    int max_size = 0;\n    int min_size = 0;\n\n   public:\n    MedianFinder() {}\n\n    void addNum(int num) {\n        if (min_size == max_size) {\n            minHeap.push(num);\n            maxHeap.push(minHeap.top());\n            minHeap.pop();\n            max_size++;\n        } else {\n            maxHeap.push(num);\n            minHeap.push(maxHeap.top());\n            maxHeap.pop();\n            min_size++;\n        }\n    }\n\n    double findMedian() {\n        if (min_size == max_size) {\n            return (maxHeap.top() + minHeap.top()) / 2.0;\n        } else {\n            return (double)maxHeap.top();\n        }\n    }\n};\n\nint main() {\n    MedianFinder* obj = new MedianFinder();\n    obj-&gt;addNum(1);\n    obj-&gt;addNum(2);\n    cout &lt;&lt; obj-&gt;findMedian() &lt;&lt; endl;  // 1.5\n    obj-&gt;addNum(3);\n    cout &lt;&lt; obj-&gt;findMedian() &lt;&lt; endl;  // 2\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/dual_heap/#480-sliding-window-median","title":"480. Sliding Window Median","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Sliding Window, Heap Priority Queue</p> </li> </ul> Python <pre><code>import heapq\nfrom typing import List\n\nfrom sortedcontainers import SortedList\n\n\n# Heap - Two Heaps\ndef medianSlidingWindow1(nums: List[int], k: int) -&gt; List[float]:\n    min_heap, max_heap = [], []\n\n    for i in range(k):\n        heapq.heappush(min_heap, (nums[i], i))\n    for i in range(k // 2):\n        n, idx = heapq.heappop(min_heap)\n        heapq.heappush(max_heap, (-n, idx))\n\n    res = [(min_heap[0][0] - max_heap[0][0]) / 2 if k % 2 == 0 else min_heap[0][0] * 1.0]\n\n    for i in range(k, len(nums)):\n        if nums[i] &lt; min_heap[0][0]:\n            heapq.heappush(max_heap, (-nums[i], i))\n\n            if nums[i - k] &gt;= min_heap[0][0]:\n                n, idx = heapq.heappop(max_heap)\n                heapq.heappush(min_heap, (-n, idx))\n        else:\n            heapq.heappush(min_heap, (nums[i], i))\n\n            if nums[i - k] &lt;= min_heap[0][0]:\n                n, idx = heapq.heappop(min_heap)\n                heapq.heappush(max_heap, (-n, idx))\n\n        while min_heap and min_heap[0][1] &lt;= i - k:\n            heapq.heappop(min_heap)\n        while max_heap and max_heap[0][1] &lt;= i - k:\n            heapq.heappop(max_heap)\n\n        res.append(\n            (min_heap[0][0] - max_heap[0][0]) / 2 if k % 2 == 0 else min_heap[0][0] * 1.0\n        )\n\n    return res\n\n\n# Sorted List\ndef medianSlidingWindow2(nums: List[int], k: int) -&gt; List[float]:\n    window = SortedList()\n    res = []\n\n    for i in range(len(nums)):\n        window.add(nums[i])\n\n        if len(window) == k:\n            if k % 2 == 1:\n                res.append(window[k // 2])\n            else:\n                res.append((window[k // 2 - 1] + window[k // 2]) / 2.0)\n\n            window.remove(nums[i - k + 1])\n\n    return res\n\n\nnums = [1, 2, 3, 4, 2, 3, 1, 4, 2]\nk = 3\nprint(medianSlidingWindow1(nums, k))\nprint(medianSlidingWindow2(nums, k))\n</code></pre>"},{"location":"EndlessCheng/dual_heap/#1825-finding-mk-average","title":"1825. Finding MK Average","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Design, Queue, Heap Priority Queue, Data Stream, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/dual_heap/#3013-divide-an-array-into-subarrays-with-minimum-cost-ii","title":"3013. Divide an Array Into Subarrays With Minimum Cost II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Sliding Window, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/dual_heap/#3321-find-x-sum-of-all-k-long-subarrays-ii","title":"3321. Find X-Sum of All K-Long Subarrays II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Sliding Window, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/dual_heap/#3369-design-an-array-statistics-tracker","title":"3369. Design an Array Statistics Tracker  \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Binary Search, Design, Queue, Heap Priority Queue, Data Stream, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/dual_heap/#3422-minimum-operations-to-make-subarray-elements-equal","title":"3422. Minimum Operations to Make Subarray Elements Equal \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Sliding Window, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/dual_stack/","title":"Dual Stack","text":""},{"location":"EndlessCheng/dual_stack/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2296. Design a Text Editor (Hard)</li> </ul>"},{"location":"EndlessCheng/dual_stack/#2296-design-a-text-editor","title":"2296. Design a Text Editor","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, String, Stack, Design, Simulation, Doubly Linked List</p> </li> </ul>"},{"location":"EndlessCheng/dynamic_segment_tree/","title":"Dynamic Segment Tree","text":""},{"location":"EndlessCheng/dynamic_segment_tree/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 699. Falling Squares (Hard)</li> <li> 715. Range Module (Hard)</li> <li> 729. My Calendar I (Medium)</li> <li> 731. My Calendar II (Medium)</li> <li> 732. My Calendar III (Hard)</li> <li> 2276. Count Integers in Intervals (Hard)</li> <li> 2770. Maximum Number of Jumps to Reach the Last Index (Medium)</li> </ul>"},{"location":"EndlessCheng/dynamic_segment_tree/#699-falling-squares","title":"699. Falling Squares","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Segment Tree, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/dynamic_segment_tree/#715-range-module","title":"715. Range Module","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Design, Segment Tree, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/dynamic_segment_tree/#729-my-calendar-i","title":"729. My Calendar I","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Design, Segment Tree, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/dynamic_segment_tree/#731-my-calendar-ii","title":"731. My Calendar II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Design, Segment Tree, Prefix Sum, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/dynamic_segment_tree/#732-my-calendar-iii","title":"732. My Calendar III","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Binary Search, Design, Segment Tree, Prefix Sum, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/dynamic_segment_tree/#2276-count-integers-in-intervals","title":"2276. Count Integers in Intervals","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Design, Segment Tree, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/dynamic_segment_tree/#2770-maximum-number-of-jumps-to-reach-the-last-index","title":"2770. Maximum Number of Jumps to Reach the Last Index","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/edge_weighted_union_find/","title":"Edge Weighted Union Find","text":""},{"location":"EndlessCheng/edge_weighted_union_find/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 399. Evaluate Division (Medium)</li> <li> 2307. Check for Contradictions in Equations (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/edge_weighted_union_find/#399-evaluate-division","title":"399. Evaluate Division","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Depth First Search, Breadth First Search, Union Find, Graph, Shortest Path</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef calcEquation(\n    equations: List[List[str]], values: List[float], queries: List[List[str]]\n) -&gt; List[float]:\n    graph = defaultdict(dict)\n    for (a, b), v in zip(equations, values):\n        graph[a][b] = v\n        graph[b][a] = 1 / v\n\n    def dfs(a, b, visited):\n        if a not in graph or b not in graph:\n            return -1.0\n\n        if b in graph[a]:\n            return graph[a][b]\n\n        for c in graph[a]:\n            if c not in visited:\n                visited.add(c)\n                d = dfs(c, b, visited)\n                if d != -1.0:\n                    return graph[a][c] * d\n        return -1.0\n\n    result = []\n    for a, b in queries:\n        result.append(dfs(a, b, set()))\n\n    return result\n\n\nequations = [[\"a\", \"b\"], [\"b\", \"c\"]]\nvalues = [2.0, 3.0]\nqueries = [[\"a\", \"c\"], [\"b\", \"a\"], [\"a\", \"e\"], [\"a\", \"a\"], [\"x\", \"x\"]]\nprint(calcEquation(equations, values, queries))  # [6.0, 0.5, -1.0, 1.0, -1.0]\n</code></pre>"},{"location":"EndlessCheng/edge_weighted_union_find/#2307-check-for-contradictions-in-equations","title":"2307. Check for Contradictions in Equations \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Union Find, Graph</p> </li> </ul>"},{"location":"EndlessCheng/enumerate_middle/","title":"Enumerate Middle","text":""},{"location":"EndlessCheng/enumerate_middle/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2909. Minimum Sum of Mountain Triplets II (Medium)</li> <li> 1930. Unique Length-3 Palindromic Subsequences (Medium)</li> <li> 3128. Right Triangles (Medium)</li> <li> 2874. Maximum Value of an Ordered Triplet II (Medium)</li> <li> 447. Number of Boomerangs (Medium)</li> <li> 456. 132 Pattern (Medium)</li> <li> 3067. Count Pairs of Connectable Servers in a Weighted Tree Network (Medium)</li> <li> 3455. Shortest Matching Substring (Hard)</li> <li> 2242. Maximum Score of a Node Sequence (Hard)</li> <li> 2867. Count Valid Paths in a Tree (Hard)</li> <li> 2552. Count Increasing Quadruplets (Hard)</li> <li> 3257. Maximum Value Sum by Placing Three Rooks II (Hard)</li> <li> 3073. Maximum Increasing Triplet Value (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/enumerate_middle/#2909-minimum-sum-of-mountain-triplets-ii","title":"2909. Minimum Sum of Mountain Triplets II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array</p> </li> </ul>"},{"location":"EndlessCheng/enumerate_middle/#1930-unique-length-3-palindromic-subsequences","title":"1930. Unique Length-3 Palindromic Subsequences","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Bit Manipulation, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/enumerate_middle/#3128-right-triangles","title":"3128. Right Triangles","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Combinatorics, Counting</p> </li> </ul>"},{"location":"EndlessCheng/enumerate_middle/#2874-maximum-value-of-an-ordered-triplet-ii","title":"2874. Maximum Value of an Ordered Triplet II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef maximumTripletValue(nums: List[int]) -&gt; int:\n    res = 0\n    max_diff = 0\n    max_prev = 0\n\n    for num in nums:\n        res = max(res, max_diff * num)\n        max_diff = max(max_diff, max_prev - num)\n        max_prev = max(max_prev, num)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    nums = [12, 6, 1, 2, 7]\n    print(maximumTripletValue(nums))  # 77\n</code></pre>"},{"location":"EndlessCheng/enumerate_middle/#447-number-of-boomerangs","title":"447. Number of Boomerangs","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math</p> </li> </ul>"},{"location":"EndlessCheng/enumerate_middle/#456-132-pattern","title":"456. 132 Pattern","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Stack, Monotonic Stack, Ordered Set</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Monotonic Stack\ndef find132pattern(nums: List[int]) -&gt; bool:\n    n = len(nums)\n    if n &lt; 3:\n        return False\n\n    stack = []\n    second_max = float(\"-inf\")\n\n    for i in range(n - 1, -1, -1):\n        if nums[i] &lt; second_max:\n            return True\n\n        while stack and stack[-1] &lt; nums[i]:\n            second_max = stack.pop()\n\n        stack.append(nums[i])\n\n    return False\n\n\nnums = [-1, 3, 2, 0]\nprint(find132pattern(nums))  # True\n</code></pre>"},{"location":"EndlessCheng/enumerate_middle/#3067-count-pairs-of-connectable-servers-in-a-weighted-tree-network","title":"3067. Count Pairs of Connectable Servers in a Weighted Tree Network","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Tree, Depth First Search</p> </li> </ul>"},{"location":"EndlessCheng/enumerate_middle/#3455-shortest-matching-substring","title":"3455. Shortest Matching Substring","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Binary Search, String Matching</p> </li> </ul>"},{"location":"EndlessCheng/enumerate_middle/#2242-maximum-score-of-a-node-sequence","title":"2242. Maximum Score of a Node Sequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Graph, Sorting, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/enumerate_middle/#2867-count-valid-paths-in-a-tree","title":"2867. Count Valid Paths in a Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Tree, Depth First Search, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/enumerate_middle/#2552-count-increasing-quadruplets","title":"2552. Count Increasing Quadruplets","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Binary Indexed Tree, Enumeration, Prefix Sum</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP\ndef countQuadruplets(nums: List[int]) -&gt; int:\n    n = len(nums)\n    great = [[0] * (n + 1) for _ in range(n)]\n    less = [0 for _ in range(n + 1)]\n\n    for k in range(n - 2, 1, -1):\n        great[k] = great[k + 1].copy()\n        for x in range(1, nums[k + 1]):\n            great[k][x] += 1\n\n    ans = 0\n\n    for j in range(1, n - 1):\n        for x in range(nums[j - 1] + 1, n + 1):\n            less[x] += 1\n        for k in range(j + 1, n - 1):\n            if nums[j] &gt; nums[k]:\n                ans += less[nums[k]] * great[k][nums[j]]\n    return ans\n\n\nnums = [1, 3, 2, 4, 5]\nprint(countQuadruplets(nums))  # 2\n</code></pre>"},{"location":"EndlessCheng/enumerate_middle/#3257-maximum-value-sum-by-placing-three-rooks-ii","title":"3257. Maximum Value Sum by Placing Three Rooks II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Matrix, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/enumerate_middle/#3073-maximum-increasing-triplet-value","title":"3073. Maximum Increasing Triplet Value \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/enumerate_right_maintain_left/","title":"Enumerate Right Maintain Left","text":""},{"location":"EndlessCheng/enumerate_right_maintain_left/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1. Two Sum (Easy)</li> <li> 1512. Number of Good Pairs (Easy)</li> <li> 2001. Number of Pairs of Interchangeable Rectangles (Medium)</li> <li> 219. Contains Duplicate II (Easy)</li> <li> 121. Best Time to Buy and Sell Stock (Easy)</li> <li> 624. Maximum Distance in Arrays (Medium)</li> <li> 2815. Max Pair Sum in an Array (Easy)</li> <li> 2342. Max Sum of a Pair With Equal Sum of Digits (Medium)</li> <li> 1679. Max Number of K-Sum Pairs (Medium)</li> <li> 2260. Minimum Consecutive Cards to Pick Up (Medium)</li> <li> 1010. Pairs of Songs With Total Durations Divisible by 60 (Medium)</li> <li> 3185. Count Pairs That Form a Complete Day II (Medium)</li> <li> 2506. Count Pairs Of Similar Strings (Easy)</li> <li> 2748. Number of Beautiful Pairs (Easy)</li> <li> 2874. Maximum Value of an Ordered Triplet II (Medium)</li> <li> 1014. Best Sightseeing Pair (Medium)</li> <li> 1814. Count Nice Pairs in an Array (Medium)</li> <li> 2905. Find Indices With Index and Value Difference II (Medium)</li> <li> 1031. Maximum Sum of Two Non-Overlapping Subarrays (Medium)</li> <li> 2555. Maximize Win From Two Segments (Medium)</li> <li> 1995. Count Special Quadruplets (Easy)</li> <li> 3404. Count Special Subsequences (Medium)</li> <li> 3267. Count Almost Equal Pairs II (Hard)</li> <li> 1214. Two Sum BSTs (Medium) \ud83d\udc51</li> <li> 2964. Number of Divisible Triplet Sums (Medium) \ud83d\udc51</li> <li> 2441. Largest Positive Integer That Exists With Its Negative (Easy)</li> <li> 454. 4Sum II (Medium)</li> <li> 3371. Identify the Largest Outlier in an Array (Medium)</li> </ul>"},{"location":"EndlessCheng/enumerate_right_maintain_left/#1-two-sum","title":"1. Two Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return the indices of the two numbers such that they add up to a specific target.\n- Approach: Use a hashmap to store the indices of the numbers.\n- Time Complexity: O(n)\n- Space Complexity: O(n)\n\"\"\"\n\nfrom typing import List\n\n\ndef two_sum(nums: List[int], target: int) -&gt; List[int]:\n    hashmap = {}  # val: idx\n\n    for idx, val in enumerate(nums):\n        if (target - val) in hashmap:\n            return [hashmap[target - val], idx]\n\n        hashmap[val] = idx\n\n    return []\n\n\ndef test_two_sum():\n    assert two_sum([2, 7, 11, 15], 9) == [0, 1]\n    assert two_sum([3, 2, 4], 6) == [1, 2]\n    assert two_sum([3, 3], 6) == [0, 1]\n    assert two_sum([1, 2, 3, 4, 5], 10) == []\n    assert two_sum([-1, -2, -3, -4, -5], -8) == [2, 4]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Solution {\n   public:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {\n        unordered_map&lt;int, int&gt; map;\n\n        for (size_t i = 0; i &lt; nums.size(); i++) {\n            int diff = target - nums[i];\n            if (map.find(diff) != map.end()) {\n                return {map[diff], (int)i};\n            }\n            map[nums[i]] = (int)i;\n        }\n        return {-1, -1};\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; nums = {2, 7, 11, 15};\n    int target = 9;\n    vector&lt;int&gt; result = solution.twoSum(nums, target);\n    assert((result == vector&lt;int&gt;{0, 1}));\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/enumerate_right_maintain_left/#1512-number-of-good-pairs","title":"1512. Number of Good Pairs","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Counting</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash\ndef numIdenticalPairs(nums: List[int]) -&gt; int:\n    res = 0\n    counts = defaultdict(int)  # num: count\n\n    for num in nums:\n        res += counts[num]\n        counts[num] += 1\n\n    return res\n\n\nnums = [1, 2, 3, 1, 1, 3]\nprint(numIdenticalPairs(nums))  # 4\n</code></pre>"},{"location":"EndlessCheng/enumerate_right_maintain_left/#2001-number-of-pairs-of-interchangeable-rectangles","title":"2001. Number of Pairs of Interchangeable Rectangles","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Counting, Number Theory</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash\ndef interchangeableRectangles(rectangles: List[List[int]]) -&gt; int:\n    res = 0\n    counts = defaultdict(int)\n\n    for w, h in rectangles:\n        ratio = w / h\n        res += counts[ratio]\n        counts[ratio] += 1\n\n    return res\n\n\nrectangles = [[4, 8], [3, 6], [10, 20], [15, 30]]\nprint(interchangeableRectangles(rectangles))  # 6\n</code></pre>"},{"location":"EndlessCheng/enumerate_right_maintain_left/#219-contains-duplicate-ii","title":"219. Contains Duplicate II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Sliding Window</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\n# Hash\ndef containsNearbyDuplicateHash(nums: List[int], k: int) -&gt; bool:\n    hashmap = {}  # num: last index\n\n    for idx, num in enumerate(nums):\n        if num in hashmap:\n            if idx - hashmap[num] &lt;= k:\n                return True\n\n        hashmap[num] = idx\n\n    return False\n\n\n# Sliding window - Fixed\ndef containsNearbyDuplicateWindow(nums: List[int], k: int) -&gt; bool:\n    window = set()\n    left = 0\n\n    for right in range(len(nums)):\n        if right - left &gt; k:\n            window.remove(nums[left])\n            left += 1\n        if nums[right] in window:\n            return True\n        window.add(nums[right])\n\n    return False\n\n\nnums = [1, 2, 3, 1]\nk = 3\nprint(containsNearbyDuplicateHash(nums, k))  # True\nprint(containsNearbyDuplicateWindow(nums, k))  # True\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;unordered_map&gt;\n#include &lt;unordered_set&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) {\n        unordered_map&lt;int, int&gt; last;\n\n        for (size_t i = 0; i &lt; nums.size(); i++) {\n            int num = nums[i];\n            if (last.contains(num) &amp;&amp; ((int)i - last[num] &lt;= k)) return true;\n            last[num] = i;\n        }\n        return false;\n    }\n    bool containsNearbyDuplicateSlidingWindow(vector&lt;int&gt;&amp; nums, int k) {\n        unordered_set&lt;int&gt; window;\n\n        for (size_t i = 0; i &lt; nums.size(); i++) {\n            if (window.contains(nums[i])) return true;\n            window.insert(nums[i]);\n\n            if ((int)i - k &gt;= 0) {\n                window.erase(nums[i - k]);\n            }\n        }\n        return false;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; nums = {1, 2, 3, 1};\n    assert(solution.containsNearbyDuplicate(nums, 3));\n    assert(solution.containsNearbyDuplicateSlidingWindow(nums, 3));\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/enumerate_right_maintain_left/#121-best-time-to-buy-and-sell-stock","title":"121. Best Time to Buy and Sell Stock","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return the maximum profit that can be achieved from buying on one day and selling on another day.\n\"\"\"\n\nfrom typing import List\n\n\n# Brute Force\ndef maxProfitBF(prices: List[int]) -&gt; int:\n    max_profit = 0\n    n = len(prices)\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_profit = max(max_profit, prices[j] - prices[i])\n\n    return max_profit\n\n\n# DP\ndef maxProfitDP(prices: List[int]) -&gt; int:\n    dp = [[0] * 2 for _ in range(len(prices))]\n    dp[0][0] = -prices[0]  # buy\n    dp[0][1] = 0  # sell\n\n    for i in range(1, len(prices)):\n        dp[i][0] = max(dp[i - 1][0], -prices[i])  # the lowest price to buy\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    max_profit = 0\n    seen_min = prices[0]\n\n    for i in range(1, len(prices)):\n        max_profit = max(max_profit, prices[i] - seen_min)\n        seen_min = min(seen_min, prices[i])\n\n    return max_profit\n\n\n# Fast Slow Pointers\ndef maxProfitFS(prices: List[int]) -&gt; int:\n    max_profit = 0\n    slow, fast = 0, 1\n\n    while fast &lt; len(prices):\n        if prices[fast] &gt; prices[slow]:\n            max_profit = max(max_profit, prices[fast] - prices[slow])\n        else:\n            slow = fast\n        fast += 1\n\n    return max_profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force|  O(n^2)|  O(1)   |\n# | DP         |  O(n)  |  O(n)   |\n# | Greedy     |  O(n)  |  O(1)   |\n# | Fast Slow  |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitBF(prices))  # 5\nprint(maxProfitDP(prices))  # 5\nprint(maxProfitGreedy(prices))  # 5\nprint(maxProfitFS(prices))  # 5\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int maxProfitMemo(vector&lt;int&gt; &amp;prices) {\n        if (prices.size() &lt;= 1) return 0;\n\n        int seen_min = prices[0];\n        int res = 0;\n\n        for (int &amp;price : prices) {\n            res = max(res, price - seen_min);\n            seen_min = min(seen_min, price);\n        }\n        return res;\n    }\n};\n\nint main() {\n    vector&lt;int&gt; prices = {7, 1, 5, 3, 6, 4};\n    Solution obj;\n    cout &lt;&lt; obj.maxProfitMemo(prices) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/enumerate_right_maintain_left/#624-maximum-distance-in-arrays","title":"624. Maximum Distance in Arrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Array\ndef maxDistance(arrays: List[List[int]]) -&gt; int:\n    mn, mx = float(\"inf\"), float(\"-inf\")\n    res = 0\n\n    for arr in arrays:\n        res = max(res, arr[-1] - mn, mx - arr[0])\n        mn = min(mn, arr[0])\n        mx = max(mx, arr[-1])\n\n    return res\n\n\narrays = [[1, 2, 3], [4, 5], [1, 2, 3]]\nprint(maxDistance(arrays))  # 4\n</code></pre>"},{"location":"EndlessCheng/enumerate_right_maintain_left/#2815-max-pair-sum-in-an-array","title":"2815. Max Pair Sum in an Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash\ndef maxSumHash(nums: List[int]) -&gt; int:\n    def find(num):\n        res = 0\n        while num != 0:\n            num, carry = divmod(num, 10)\n            res = max(res, carry)\n        return res\n\n    freqs = defaultdict(list)\n\n    for num in nums:\n        x = find(num)\n        freqs[x].append(num)\n\n    res = -1\n    for vals in freqs.values():\n        if len(vals) &gt; 1:\n            vals = sorted(vals, reverse=True)\n            res = max(res, sum(vals[:2]))\n\n    return res\n\n\n# Array\ndef maxSumArray(nums: List[int]) -&gt; int:\n    res = -1\n    max_val = [float(\"-inf\") for _ in range(10)]\n\n    for num in nums:\n        maxDigit = max(map(int, str(num)))\n        res = max(res, num + max_val[maxDigit])\n        max_val[maxDigit] = max(max_val[maxDigit], num)\n\n    return res\n\n\nnums = [2536, 1613, 3366, 162]\nprint(maxSumHash(nums))  # 5902\nprint(maxSumArray(nums))  # 5902\n</code></pre>"},{"location":"EndlessCheng/enumerate_right_maintain_left/#2342-max-sum-of-a-pair-with-equal-sum-of-digits","title":"2342. Max Sum of a Pair With Equal Sum of Digits","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Sorting, Heap Priority Queue</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Enumerate Right Maintain Left\ndef maximumSum(nums: List[int]) -&gt; int:\n    def digits_sum(num):\n        res = 0\n        while num:\n            num, carry = divmod(num, 10)\n            res += carry\n        return res\n\n    hashmap = {}  # digit sum: largest num\n    res = -1\n\n    for num in nums:\n        ds = digits_sum(num)\n\n        if ds not in hashmap:\n            hashmap[ds] = num\n        else:\n            res = max(res, num + hashmap[ds])\n            hashmap[ds] = max(hashmap[ds], num)\n\n    return res\n\n\nnums = [18, 43, 36, 13, 7]\nprint(maximumSum(nums))  # 54\n</code></pre>"},{"location":"EndlessCheng/enumerate_right_maintain_left/#1679-max-number-of-k-sum-pairs","title":"1679. Max Number of K-Sum Pairs","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Two Pointers, Sorting</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Enumerate Right Maintain Left\ndef maxOperations(nums: List[int], k: int) -&gt; int:\n    counts = defaultdict(int)\n\n    res = 0\n    for num in nums:\n        if num &gt;= k:\n            continue\n\n        j = k - num\n        if j in counts:\n            res += 1\n            counts[j] -= 1\n            if counts[j] == 0:\n                del counts[j]\n        else:\n            counts[num] += 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert maxOperations([1, 2, 3, 4], 5) == 2\n    assert maxOperations([3, 1, 3, 4, 3], 6) == 1\n</code></pre>"},{"location":"EndlessCheng/enumerate_right_maintain_left/#2260-minimum-consecutive-cards-to-pick-up","title":"2260. Minimum Consecutive Cards to Pick Up","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Sliding Window</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Enumerate Right Maintain Left\ndef minimumCardPickup(cards: List[int]) -&gt; int:\n    n = len(cards)\n    res = n + 1\n    last = {}\n\n    for idx, card in enumerate(cards):\n        if card in last:\n            res = min(res, idx - last[card] + 1)\n        last[card] = idx\n\n    return res if res != n + 1 else -1\n\n\nif __name__ == \"__main__\":\n    assert minimumCardPickup([1, 2, 3, 4, 5]) == -1\n    assert minimumCardPickup([1, 2, 3, 2, 3]) == 3\n</code></pre>"},{"location":"EndlessCheng/enumerate_right_maintain_left/#1010-pairs-of-songs-with-total-durations-divisible-by-60","title":"1010. Pairs of Songs With Total Durations Divisible by 60","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Counting</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Enumerate Right Maintain Left\ndef numPairsDivisibleBy60(time: List[int]) -&gt; int:\n    if not time or len(time) &lt; 2:\n        return 0\n\n    count = defaultdict(int)\n    res = 0\n    time = [t % 60 for t in time]\n\n    for t in time:\n        if t == 0:\n            res += count[0]\n        else:\n            res += count[60 - t]\n        count[t] += 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert numPairsDivisibleBy60([30, 20, 150, 100, 40]) == 3\n    assert numPairsDivisibleBy60([60, 60, 60]) == 3\n    assert numPairsDivisibleBy60([10, 50, 30, 20, 40]) == 2\n</code></pre>"},{"location":"EndlessCheng/enumerate_right_maintain_left/#3185-count-pairs-that-form-a-complete-day-ii","title":"3185. Count Pairs That Form a Complete Day II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Counting</p> </li> </ul>"},{"location":"EndlessCheng/enumerate_right_maintain_left/#2506-count-pairs-of-similar-strings","title":"2506. Count Pairs Of Similar Strings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Bit Manipulation, Counting</p> </li> </ul>"},{"location":"EndlessCheng/enumerate_right_maintain_left/#2748-number-of-beautiful-pairs","title":"2748. Number of Beautiful Pairs","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Counting, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/enumerate_right_maintain_left/#2874-maximum-value-of-an-ordered-triplet-ii","title":"2874. Maximum Value of an Ordered Triplet II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef maximumTripletValue(nums: List[int]) -&gt; int:\n    res = 0\n    max_diff = 0\n    max_prev = 0\n\n    for num in nums:\n        res = max(res, max_diff * num)\n        max_diff = max(max_diff, max_prev - num)\n        max_prev = max(max_prev, num)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    nums = [12, 6, 1, 2, 7]\n    print(maximumTripletValue(nums))  # 77\n</code></pre>"},{"location":"EndlessCheng/enumerate_right_maintain_left/#1014-best-sightseeing-pair","title":"1014. Best Sightseeing Pair","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Enumeate Right Maintain Left\ndef maxScoreSightseeingPair(values: List[int]) -&gt; int:\n    max_i = values[0] + 0\n    res = 0\n\n    for j in range(1, len(values)):\n        res = max(res, max_i + values[j] - j)\n        max_i = max(max_i, values[j] + j)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert maxScoreSightseeingPair([8, 1, 5, 2, 6]) == 11\n    assert maxScoreSightseeingPair([1, 2]) == 2\n    assert maxScoreSightseeingPair([1, 3, 5]) == 7\n    assert maxScoreSightseeingPair([1, 2, 3, 4, 5]) == 8\n</code></pre>"},{"location":"EndlessCheng/enumerate_right_maintain_left/#1814-count-nice-pairs-in-an-array","title":"1814. Count Nice Pairs in an Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Counting</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Enumerate Right Maintain Left\ndef countNicePairs(nums: List[int]) -&gt; int:\n    rev = lambda n: int(str(n)[::-1])\n    cnt = defaultdict(int)\n    MOD = 10**9 + 7\n    res = 0\n\n    for num in nums:\n        cnt[num - rev(num)] += 1\n\n    for i in cnt.values():\n        res += i * (i - 1) // 2  # math.comb(i, 2)\n\n    return res % MOD\n\n\nif __name__ == \"__main__\":\n    assert countNicePairs([42, 11, 1, 97]) == 2\n    assert countNicePairs([13, 10, 35, 24, 76]) == 4\n    assert countNicePairs([100, 200, 300]) == 0\n    assert countNicePairs([123, 321, 456, 654]) == 2\n    assert countNicePairs([12, 21, 34, 43]) == 2\n</code></pre>"},{"location":"EndlessCheng/enumerate_right_maintain_left/#2905-find-indices-with-index-and-value-difference-ii","title":"2905. Find Indices With Index and Value Difference II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers</p> </li> </ul>"},{"location":"EndlessCheng/enumerate_right_maintain_left/#1031-maximum-sum-of-two-non-overlapping-subarrays","title":"1031. Maximum Sum of Two Non-Overlapping Subarrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/enumerate_right_maintain_left/#2555-maximize-win-from-two-segments","title":"2555. Maximize Win From Two Segments","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Sliding Window</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Sliding Window - Variable\ndef maximizeWin(prizePositions: List[int], k: int) -&gt; int:\n    n = len(prizePositions)\n\n    if 2 * k &gt;= prizePositions[-1] - prizePositions[0]:\n        return n\n\n    ans = left = 0\n    mx = [0] * (n + 1)\n\n    for right, p in enumerate(prizePositions):\n        while p - prizePositions[left] &gt; k:\n            left += 1\n        ans = max(ans, mx[left] + right - left + 1)\n        mx[right + 1] = max(mx[right], right - left + 1)\n\n    return ans\n\n\nprizePositions = [1, 1, 2, 2, 3, 3, 5]\nk = 2\nprint(maximizeWin(prizePositions, k))  # 7\n</code></pre>"},{"location":"EndlessCheng/enumerate_right_maintain_left/#1995-count-special-quadruplets","title":"1995. Count Special Quadruplets","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/enumerate_right_maintain_left/#3404-count-special-subsequences","title":"3404. Count Special Subsequences","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/enumerate_right_maintain_left/#3267-count-almost-equal-pairs-ii","title":"3267. Count Almost Equal Pairs II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Sorting, Counting, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/enumerate_right_maintain_left/#1214-two-sum-bsts","title":"1214. Two Sum BSTs \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, Binary Search, Stack, Tree, Depth First Search, Binary Search Tree, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/enumerate_right_maintain_left/#2964-number-of-divisible-triplet-sums","title":"2964. Number of Divisible Triplet Sums \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table</p> </li> </ul>"},{"location":"EndlessCheng/enumerate_right_maintain_left/#2441-largest-positive-integer-that-exists-with-its-negative","title":"2441. Largest Positive Integer That Exists With Its Negative","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Two Pointers, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/enumerate_right_maintain_left/#454-4sum-ii","title":"454. 4Sum II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the number of tuples `(i, j, k, l)` such that `A[i] + B[j] + C[k] + D[l] == 0`.\n\"\"\"\n\nfrom collections import defaultdict\nfrom typing import List\n\n\ndef fourSumCount(\n    nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]\n) -&gt; int:\n\n    sumAB = defaultdict(int)\n    result = 0\n\n    for i in nums1:\n        for j in nums2:\n            sumAB[i + j] += 1\n\n    for i in nums3:\n        for j in nums4:\n            if -(i + j) in sumAB:\n                result += sumAB[-(i + j)]\n\n    return result\n\n\nnums1 = [1, 2]\nnums2 = [-2, -1]\nnums3 = [-1, 2]\nnums4 = [0, 2]\nprint(fourSumCount(nums1, nums2, nums3, nums4))  # 2\n</code></pre>"},{"location":"EndlessCheng/enumerate_right_maintain_left/#3371-identify-the-largest-outlier-in-an-array","title":"3371. Identify the Largest Outlier in an Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Counting, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/enumerate_then_greedy/","title":"Enumerate then Greedy","text":""},{"location":"EndlessCheng/enumerate_then_greedy/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2171. Removing Minimum Number of Magic Beans (Medium)</li> <li> 3085. Minimum Deletions to Make String K-Special (Medium)</li> <li> 1727. Largest Submatrix With Rearrangements (Medium)</li> <li> 2749. Minimum Operations to Make the Integer Zero (Medium)</li> <li> 2910. Minimum Number of Groups to Create a Valid Assignment (Medium)</li> <li> 2234. Maximum Total Beauty of the Gardens (Hard)</li> </ul>"},{"location":"EndlessCheng/enumerate_then_greedy/#2171-removing-minimum-number-of-magic-beans","title":"2171. Removing Minimum Number of Magic Beans","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting, Enumeration, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/enumerate_then_greedy/#3085-minimum-deletions-to-make-string-k-special","title":"3085. Minimum Deletions to Make String K-Special","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Greedy, Sorting, Counting</p> </li> </ul>"},{"location":"EndlessCheng/enumerate_then_greedy/#1727-largest-submatrix-with-rearrangements","title":"1727. Largest Submatrix With Rearrangements","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/enumerate_then_greedy/#2749-minimum-operations-to-make-the-integer-zero","title":"2749. Minimum Operations to Make the Integer Zero","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Bit Manipulation, Brainteaser, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/enumerate_then_greedy/#2910-minimum-number-of-groups-to-create-a-valid-assignment","title":"2910. Minimum Number of Groups to Create a Valid Assignment","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/enumerate_then_greedy/#2234-maximum-total-beauty-of-the-gardens","title":"2234. Maximum Total Beauty of the Gardens","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Greedy, Sorting</p> </li> </ul> CPP <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nlong long maximumBeauty(vector&lt;int&gt;&amp; flowers, long long newFlowers, int target,\n                        int full, int partial) {\n    int n = flowers.size();\n\n    long long left = newFlowers - 1LL * target * n;\n    for (int&amp; flower : flowers) {\n        flower = min(flower, target);\n        left += flower;\n    }\n\n    if (left == newFlowers) return 1LL * full * n;\n\n    if (left &gt;= 0) {\n        return max(1LL * (target - 1) * partial + 1LL * (n - 1) * full,\n                   1LL * n * full);\n    }\n\n    sort(flowers.begin(), flowers.end());\n    long long res = 0, pre_sum = 0;\n\n    int j = 0;\n    for (int i = 1; i &lt;= n; i++) {\n        left += target - flowers[i - 1];\n        if (left &lt; 0) {\n            continue;\n        }\n\n        while (j &lt; i &amp;&amp; 1LL * flowers[j] * j &lt;= pre_sum + left) {\n            pre_sum += flowers[j];\n            j++;\n        }\n\n        long long avg = (left + pre_sum) / j;\n        long long total_beauty = avg * partial + 1LL * (n - i) * full;\n        res = max(res, total_beauty);\n    }\n\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; flowers = {1, 3, 1, 1};\n    long long newFlowers = 7;\n    int target = 6;\n    int full = 12;\n    int partial = 1;\n    long long res = maximumBeauty(flowers, newFlowers, target, full, partial);\n    cout &lt;&lt; res &lt;&lt; endl;  // 14\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/equivalent_transformation/","title":"Equivalent Transformation","text":""},{"location":"EndlessCheng/equivalent_transformation/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3375. Minimum Operations to Make Array Values Equal to K (Easy)</li> <li> 2914. Minimum Number of Changes to Make Binary String Beautiful (Medium)</li> <li> 3365. Rearrange K Substrings to Form Target String (Medium)</li> <li> 1657. Determine if Two Strings Are Close (Medium)</li> <li> 2551. Put Marbles in Bags (Hard)</li> <li> 1585. Check If String Is Transformable With Substring Sort Operations (Hard)</li> <li> 1040. Moving Stones Until Consecutive II (Medium)</li> <li> 249. Group Shifted Strings (Medium) \ud83d\udc51</li> <li> 49. Group Anagrams (Medium)</li> <li> 1183. Maximum Number of Ones (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/equivalent_transformation/#3375-minimum-operations-to-make-array-values-equal-to-k","title":"3375. Minimum Operations to Make Array Values Equal to K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table</p> </li> </ul>"},{"location":"EndlessCheng/equivalent_transformation/#2914-minimum-number-of-changes-to-make-binary-string-beautiful","title":"2914. Minimum Number of Changes to Make Binary String Beautiful","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String</p> </li> </ul>"},{"location":"EndlessCheng/equivalent_transformation/#3365-rearrange-k-substrings-to-form-target-string","title":"3365. Rearrange K Substrings to Form Target String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/equivalent_transformation/#1657-determine-if-two-strings-are-close","title":"1657. Determine if Two Strings Are Close","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sorting, Counting</p> </li> </ul>"},{"location":"EndlessCheng/equivalent_transformation/#2551-put-marbles-in-bags","title":"2551. Put Marbles in Bags","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/equivalent_transformation/#1585-check-if-string-is-transformable-with-substring-sort-operations","title":"1585. Check If String Is Transformable With Substring Sort Operations","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/equivalent_transformation/#1040-moving-stones-until-consecutive-ii","title":"1040. Moving Stones Until Consecutive II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Two Pointers, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/equivalent_transformation/#249-group-shifted-strings","title":"249. Group Shifted Strings \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String</p> </li> </ul>"},{"location":"EndlessCheng/equivalent_transformation/#49-group-anagrams","title":"49. Group Anagrams","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Sorting</p> </li> </ul> PythonCPP <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash - List\ndef groupAnagrams(strs: List[str]) -&gt; List[List[str]]:\n    result = defaultdict(list)\n\n    for s in strs:\n        count = [0] * 26\n        for i in s:\n            count[ord(i) - ord(\"a\")] += 1\n\n        result[tuple(count)].append(s)\n\n    return list(result.values())\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Hash     |     O(n * k)    |     O(n)     |\n# |-------------|-----------------|--------------|\n\n\nstrs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\nprint(groupAnagrams(strs))\n# [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;cassert&gt;\n#include &lt;ranges&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Solution {\n   public:\n    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) {\n        unordered_map&lt;string, vector&lt;string&gt;&gt; map;\n\n        for (string&amp; s : strs) {\n            string sorted = s;\n            ranges::sort(sorted);\n            map[sorted].push_back(s);\n        }\n\n        vector&lt;vector&lt;string&gt;&gt; res;\n\n        for (auto&amp; kv : map) {\n            res.push_back(kv.second);\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;string&gt; strs = {\"eat\", \"tea\", \"tan\"};\n    vector&lt;vector&lt;string&gt;&gt; res = solution.groupAnagrams(strs);\n    assert((res == vector&lt;vector&lt;string&gt;&gt;{{\"eat\", \"tea\"}, {\"tan\"}} ||\n            res == vector&lt;vector&lt;string&gt;&gt;{{\"tan\"}, {\"eat\", \"tea\"}}));\n\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/equivalent_transformation/#1183-maximum-number-of-ones","title":"1183. Maximum Number of Ones \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Greedy, Sorting, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/eulerian_path_and_circuit/","title":"Eulerian Path and Circuit","text":""},{"location":"EndlessCheng/eulerian_path_and_circuit/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 332. Reconstruct Itinerary (Hard)</li> <li> 753. Cracking the Safe (Hard)</li> <li> 2097. Valid Arrangement of Pairs (Hard)</li> </ul>"},{"location":"EndlessCheng/eulerian_path_and_circuit/#332-reconstruct-itinerary","title":"332. Reconstruct Itinerary","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Graph, Eulerian Circuit</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the itinerary in order that visits every airport exactly once.\n-   The starting airport is `JFK`.\n-   If there are multiple valid itineraries, return the lexicographically smallest one.\n-   Eulerian path: A path that visits every edge exactly once.\n\"\"\"\n\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Hierholzer\ndef findItinerary1(tickets: List[List[str]]) -&gt; List[str]:\n    graph = defaultdict(list)\n    for u, v in sorted(tickets, reverse=True):\n        graph[u].append(v)\n\n    route = []\n\n    def dfs(node):\n        while graph[node]:\n            dest = graph[node].pop()\n            dfs(dest)\n        route.append(node)\n\n    dfs(\"JFK\")\n\n    return route[::-1]\n\n\n# Backtracking\ndef findItinerary2(tickets: List[List[str]]) -&gt; List[str]:\n    graph = defaultdict(list)\n    tickets.sort()\n    for u, v in tickets:\n        graph[u].append(v)\n\n    route = [\"JFK\"]\n\n    def backtraking(node):\n        if len(route) == len(tickets) + 1:\n            return True\n        if node not in graph:\n            return False\n\n        temp = list(graph[node])\n        for i, v in enumerate(temp):\n            graph[node].pop(i)\n            route.append(v)\n\n            if backtraking(v):\n                return True\n\n            graph[node].insert(i, v)\n            route.pop()\n\n        return False\n\n    backtraking(\"JFK\")\n\n    return route\n\n\ntickets = tickets = [\n    [\"JFK\", \"SFO\"],\n    [\"JFK\", \"ATL\"],\n    [\"SFO\", \"ATL\"],\n    [\"ATL\", \"JFK\"],\n    [\"ATL\", \"SFO\"],\n]\nprint(findItinerary1(tickets))\n# ['JFK', 'ATL', 'JFK', 'SFO', 'ATL', 'SFO']\nprint(findItinerary2(tickets))\n# ['JFK', 'ATL', 'JFK', 'SFO', 'ATL', 'SFO']\n</code></pre>"},{"location":"EndlessCheng/eulerian_path_and_circuit/#753-cracking-the-safe","title":"753. Cracking the Safe","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Graph, Eulerian Circuit</p> </li> </ul>"},{"location":"EndlessCheng/eulerian_path_and_circuit/#2097-valid-arrangement-of-pairs","title":"2097. Valid Arrangement of Pairs","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Graph, Eulerian Circuit</p> </li> </ul>"},{"location":"EndlessCheng/exchange_argument/","title":"Exchange Argument","text":""},{"location":"EndlessCheng/exchange_argument/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2895. Minimum Processing Time (Medium)</li> <li> 3457. Eat Pizzas! (Medium)</li> <li> 1665. Minimum Initial Energy to Finish Tasks (Hard)</li> <li> 3273. Minimum Amount of Damage Dealt to Bob (Hard)</li> <li> 2136. Earliest Possible Day of Full Bloom (Hard)</li> <li> 179. Largest Number (Medium)</li> <li> 3309. Maximum Possible Number by Binary Concatenation (Medium)</li> </ul>"},{"location":"EndlessCheng/exchange_argument/#2895-minimum-processing-time","title":"2895. Minimum Processing Time","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/exchange_argument/#3457-eat-pizzas","title":"3457. Eat Pizzas!","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/exchange_argument/#1665-minimum-initial-energy-to-finish-tasks","title":"1665. Minimum Initial Energy to Finish Tasks","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/exchange_argument/#3273-minimum-amount-of-damage-dealt-to-bob","title":"3273. Minimum Amount of Damage Dealt to Bob","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/exchange_argument/#2136-earliest-possible-day-of-full-bloom","title":"2136. Earliest Possible Day of Full Bloom","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/exchange_argument/#179-largest-number","title":"179. Largest Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Greedy, Sorting</p> </li> </ul> Python <pre><code>from functools import cmp_to_key\nfrom typing import List\n\n\n# Greedy\ndef largestNumber(nums: List[int]) -&gt; str:\n    strs = map(str, nums)\n\n    def cmp(a, b):\n        if a + b == b + a:\n            return 0\n        elif a + b &gt; b + a:\n            return 1\n        else:\n            return -1\n\n    strs = sorted(strs, key=cmp_to_key(cmp), reverse=True)\n\n    return \"\".join(strs) if strs[0] != \"0\" else \"0\"\n\n\nnums = [3, 30, 34, 5, 9]\nprint(largestNumber(nums))  # 9534330\n</code></pre>"},{"location":"EndlessCheng/exchange_argument/#3309-maximum-possible-number-by-binary-concatenation","title":"3309. Maximum Possible Number by Binary Concatenation","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/expression_parsing/","title":"Expression Parsing","text":""},{"location":"EndlessCheng/expression_parsing/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 150. Evaluate Reverse Polish Notation (Medium)</li> <li> 1006. Clumsy Factorial (Medium)</li> <li> 224. Basic Calculator (Hard)</li> <li> 227. Basic Calculator II (Medium)</li> <li> 726. Number of Atoms (Hard)</li> <li> 1106. Parsing A Boolean Expression (Hard)</li> <li> 591. Tag Validator (Hard)</li> <li> 736. Parse Lisp Expression (Hard)</li> <li> 1096. Brace Expansion II (Hard)</li> <li> 1896. Minimum Cost to Change the Final Value of Expression (Hard)</li> <li> 770. Basic Calculator IV (Hard)</li> <li> 439. Ternary Expression Parser (Medium) \ud83d\udc51</li> <li> 772. Basic Calculator III (Hard) \ud83d\udc51</li> <li> 1087. Brace Expansion (Medium) \ud83d\udc51</li> <li> 1597. Build Binary Expression Tree From Infix Expression (Hard) \ud83d\udc51</li> <li> 1628. Design an Expression Tree With Evaluate Function (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/expression_parsing/#150-evaluate-reverse-polish-notation","title":"150. Evaluate Reverse Polish Notation","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Stack</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Stack\ndef evalRPN(tokens: List[str]) -&gt; int:\n    stack = []\n\n    for c in tokens:\n        if c == \"+\":\n            stack.append(stack.pop() + stack.pop())\n        elif c == \"-\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(b - a)\n        elif c == \"*\":\n            stack.append(stack.pop() * stack.pop())\n        elif c == \"/\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(int(b / a))\n        else:\n            stack.append(int(c))\n\n    return stack[0]\n\n\ndef test_evalRPN():\n    print(evalRPN([\"2\", \"1\", \"+\", \"3\", \"*\"]))  # 9\n    print(evalRPN([\"4\", \"13\", \"5\", \"/\", \"-\"]))  # 2\n    print(evalRPN([\"18\"]))  # 18\n    print(evalRPN([\"4\", \"3\", \"-\"]))  # 1\n</code></pre>"},{"location":"EndlessCheng/expression_parsing/#1006-clumsy-factorial","title":"1006. Clumsy Factorial","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Stack, Simulation</p> </li> </ul>"},{"location":"EndlessCheng/expression_parsing/#224-basic-calculator","title":"224. Basic Calculator","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String, Stack, Recursion</p> </li> </ul> Python <pre><code># Stack\ndef calculate(s: str) -&gt; int:\n    stack = []\n    result = 0\n    number = 0\n    sign = 1\n\n    for char in s:\n        if char.isdigit():\n            number = number * 10 + int(char)\n\n        elif char == \"+\":\n            result += sign * number\n            number = 0\n            sign = 1\n        elif char == \"-\":\n            result += sign * number\n            number = 0\n            sign = -1\n\n        elif char == \"(\":\n            stack.append(result)\n            stack.append(sign)\n            result = 0\n            sign = 1\n        elif char == \")\":\n            result += sign * number\n            number = 0\n            result *= stack.pop()  # pop sign\n            result += stack.pop()  # pop previous result\n\n    result += sign * number\n\n    return result\n\n\nprint(calculate(\"(1+(4+5+2)-3)+(6+8)\"))  # 23\n</code></pre>"},{"location":"EndlessCheng/expression_parsing/#227-basic-calculator-ii","title":"227. Basic Calculator II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String, Stack</p> </li> </ul> Python <pre><code># Stack\ndef calculate(s: str) -&gt; int:\n    stack = []\n    num = 0\n    sign = \"+\"\n\n    for index, char in enumerate(s):\n        if char.isdigit():\n            num = num * 10 + int(char)\n\n        if char in \"+-*/\" or index == len(s) - 1:\n            if sign == \"+\":\n                stack.append(num)\n            elif sign == \"-\":\n                stack.append(-num)\n            elif sign == \"*\":\n                stack.append(stack.pop() * num)\n            elif sign == \"/\":\n                stack.append(int(stack.pop() / num))\n            sign = char\n            num = 0\n\n    return sum(stack)\n\n\ns = \"3+2*2\"\nprint(calculate(s))  # 7\n</code></pre>"},{"location":"EndlessCheng/expression_parsing/#726-number-of-atoms","title":"726. Number of Atoms","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Stack, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/expression_parsing/#1106-parsing-a-boolean-expression","title":"1106. Parsing A Boolean Expression","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack, Recursion</p> </li> </ul>"},{"location":"EndlessCheng/expression_parsing/#591-tag-validator","title":"591. Tag Validator","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack</p> </li> </ul>"},{"location":"EndlessCheng/expression_parsing/#736-parse-lisp-expression","title":"736. Parse Lisp Expression","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Stack, Recursion</p> </li> </ul>"},{"location":"EndlessCheng/expression_parsing/#1096-brace-expansion-ii","title":"1096. Brace Expansion II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Backtracking, Stack, Breadth First Search</p> </li> </ul>"},{"location":"EndlessCheng/expression_parsing/#1896-minimum-cost-to-change-the-final-value-of-expression","title":"1896. Minimum Cost to Change the Final Value of Expression","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String, Dynamic Programming, Stack</p> </li> </ul>"},{"location":"EndlessCheng/expression_parsing/#770-basic-calculator-iv","title":"770. Basic Calculator IV","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Math, String, Stack, Recursion</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Stack\nclass Solution:\n    def __init__(self):\n        self.operators = set([\"+\", \"-\", \"*\"])\n\n    def basicCalculatorIV(\n        self, expression: str, evalvars: List[str], evalints: List[int]\n    ) -&gt; List[str]:\n        evalmap = dict(zip(evalvars, evalints))\n        tokens = self.parse_expression(expression)\n        result_terms = self.evaluate(tokens, evalmap)\n        return self.format_result(result_terms)\n\n    def parse_expression(self, expression):\n        tokens = []\n        i = 0\n        while i &lt; len(expression):\n            if expression[i].isalnum():  # Variable or digit\n                start = i\n                while i &lt; len(expression) and (\n                    expression[i].isalnum() or expression[i] == \"_\"\n                ):\n                    i += 1\n                tokens.append(expression[start:i])\n            elif expression[i] in self.operators or expression[i] in \"()\":\n                tokens.append(expression[i])\n                i += 1\n            elif expression[i] == \" \":\n                i += 1  # skip whitespace\n        return tokens\n\n    def evaluate(self, tokens, evalmap):\n        def apply_operator(op, b, a):\n            if op == \"+\":\n                return self.add_terms(a, b)\n            elif op == \"-\":\n                return self.add_terms(a, self.negate_terms(b))\n            elif op == \"*\":\n                return self.multiply_terms(a, b)\n\n        def process_token(token):\n            if token.isalnum():\n                if token in evalmap:\n                    stack.append({(): evalmap[token]})\n                elif token.isdigit():\n                    stack.append({(): int(token)})\n                else:\n                    stack.append({(token,): 1})\n            elif token == \"(\":\n                ops.append(token)\n            elif token == \")\":\n                while ops and ops[-1] != \"(\":\n                    operate()\n                ops.pop()\n            else:\n                while (\n                    ops\n                    and ops[-1] in precedence\n                    and precedence[ops[-1]] &gt;= precedence[token]\n                ):\n                    operate()\n                ops.append(token)\n\n        def operate():\n            if len(stack) &lt; 2 or not ops:\n                return\n            b = stack.pop()\n            a = stack.pop()\n            op = ops.pop()\n            stack.append(apply_operator(op, b, a))\n\n        stack = []\n        ops = []\n        precedence = {\"+\": 1, \"-\": 1, \"*\": 2}\n\n        for token in tokens:\n            process_token(token)\n\n        while ops:\n            operate()\n        return self.combine_terms(stack[-1])\n\n    def add_terms(self, a, b):\n        result = defaultdict(int, a)\n        for term, coef in b.items():\n            result[term] += coef\n        return dict(result)\n\n    def negate_terms(self, a):\n        return {term: -coef for term, coef in a.items()}\n\n    def multiply_terms(self, a, b):\n        result = defaultdict(int)\n        for term1, coef1 in a.items():\n            for term2, coef2 in b.items():\n                new_term = tuple(sorted(term1 + term2))\n                result[new_term] += coef1 * coef2\n        return dict(result)\n\n    def combine_terms(self, terms):\n        result = defaultdict(int)\n        for term, coef in terms.items():\n            if coef != 0:\n                result[term] = coef\n        return dict(result)\n\n    def format_result(self, result_terms):\n        result = []\n        for term in sorted(result_terms.keys(), key=lambda x: (-len(x), x)):\n            coef = result_terms[term]\n            if coef != 0:\n                term_str = \"*\".join(term)\n                if term_str:\n                    result.append(f\"{coef}*{term_str}\")\n                else:\n                    result.append(str(coef))\n        return result\n\n\ncalculator = Solution()\nexpression = \"e + 8 - a + 5\"\nevalvars = [\"e\"]\nevalints = [1]\nprint(calculator.basicCalculatorIV(expression, evalvars, evalints))\n# ['-1*a', '14']\n</code></pre>"},{"location":"EndlessCheng/expression_parsing/#439-ternary-expression-parser","title":"439. Ternary Expression Parser \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack, Recursion</p> </li> </ul> Python <pre><code># Stack\ndef parseTernary(expression: str) -&gt; str:\n    stack = []\n    i = len(expression) - 1\n\n    while i &gt;= 0:\n        c = expression[i]\n        if stack and stack[-1] == \"?\":\n            stack.pop()  # remove '?'\n            true_val = stack.pop()\n            stack.pop()  # remove ':'\n            false_val = stack.pop()\n            if c == \"T\":\n                stack.append(true_val)\n            else:\n                stack.append(false_val)\n        else:\n            stack.append(c)\n        i -= 1\n\n    return stack[-1]\n\n\nif __name__ == \"__main__\":\n    assert parseTernary(\"T?2:3\") == \"2\"\n    assert parseTernary(\"F?1:T?4:5\") == \"4\"\n    assert parseTernary(\"T?T?F:5:3\") == \"F\"\n</code></pre>"},{"location":"EndlessCheng/expression_parsing/#772-basic-calculator-iii","title":"772. Basic Calculator III \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String, Stack, Recursion</p> </li> </ul> Python <pre><code># Stack\ndef calculate(s: str) -&gt; int:\n    def helper(index):\n        stack = []\n        num = 0\n        sign = \"+\"\n\n        while index &lt; len(s):\n            char = s[index]\n            if char.isdigit():\n                num = num * 10 + int(char)\n            if char == \"(\":\n                num, index = helper(index + 1)\n            if char in \"+-*/)\" or index == len(s) - 1:\n                if sign == \"+\":\n                    stack.append(num)\n                elif sign == \"-\":\n                    stack.append(-num)\n                elif sign == \"*\":\n                    stack.append(stack.pop() * num)\n                elif sign == \"/\":\n                    stack.append(int(stack.pop() / num))  # \u5411\u96f6\u53d6\u6574\n                num = 0\n                sign = char\n            if char == \")\":\n                break\n            index += 1\n\n        return sum(stack), index\n\n    s = s.replace(\" \", \"\")\n    result, _ = helper(0)\n\n    return result\n\n\ns = \"2*(5+5*2)/3+(6/2+8)\"\nprint(calculate(s))  # 21\n</code></pre>"},{"location":"EndlessCheng/expression_parsing/#1087-brace-expansion","title":"1087. Brace Expansion \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Backtracking, Breadth First Search</p> </li> </ul>"},{"location":"EndlessCheng/expression_parsing/#1597-build-binary-expression-tree-from-infix-expression","title":"1597. Build Binary Expression Tree From Infix Expression \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack, Tree, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/expression_parsing/#1628-design-an-expression-tree-with-evaluate-function","title":"1628. Design an Expression Tree With Evaluate Function \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Stack, Tree, Design, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/factorial_decomposition/","title":"Factorial Decomposition","text":""},{"location":"EndlessCheng/factorial_decomposition/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 172. Factorial Trailing Zeroes (Medium)</li> <li> 793. Preimage Size of Factorial Zeroes Function (Hard)</li> </ul>"},{"location":"EndlessCheng/factorial_decomposition/#172-factorial-trailing-zeroes","title":"172. Factorial Trailing Zeroes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math</p> </li> </ul>"},{"location":"EndlessCheng/factorial_decomposition/#793-preimage-size-of-factorial-zeroes-function","title":"793. Preimage Size of Factorial Zeroes Function","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Binary Search</p> </li> </ul>"},{"location":"EndlessCheng/factors/","title":"Factors","text":""},{"location":"EndlessCheng/factors/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2427. Number of Common Factors (Easy)</li> <li> 1952. Three Divisors (Easy)</li> <li> 1492. The kth Factor of n (Medium)</li> <li> 507. Perfect Number (Easy)</li> <li> 1390. Four Divisors (Medium)</li> <li> 1362. Closest Divisors (Medium)</li> <li> 829. Consecutive Numbers Sum (Hard)</li> <li> 3447. Assign Elements to Groups with Constraints (Medium)</li> <li> 3164. Find the Number of Good Pairs II (Medium)</li> <li> 952. Largest Component Size by Common Factor (Hard)</li> <li> 1627. Graph Connectivity With Threshold (Hard)</li> <li> 2198. Number of Single Divisor Triplets (Medium) \ud83d\udc51</li> <li> 625. Minimum Factorization (Medium) \ud83d\udc51</li> <li> 2847. Smallest Number With Given Digit Product (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/factors/#2427-number-of-common-factors","title":"2427. Number of Common Factors","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Enumeration, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/factors/#1952-three-divisors","title":"1952. Three Divisors","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Enumeration, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/factors/#1492-the-kth-factor-of-n","title":"1492. The kth Factor of n","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/factors/#507-perfect-number","title":"507. Perfect Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math</p> </li> </ul>"},{"location":"EndlessCheng/factors/#1390-four-divisors","title":"1390. Four Divisors","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math</p> </li> </ul>"},{"location":"EndlessCheng/factors/#1362-closest-divisors","title":"1362. Closest Divisors","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math</p> </li> </ul>"},{"location":"EndlessCheng/factors/#829-consecutive-numbers-sum","title":"829. Consecutive Numbers Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/factors/#3447-assign-elements-to-groups-with-constraints","title":"3447. Assign Elements to Groups with Constraints","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table</p> </li> </ul>"},{"location":"EndlessCheng/factors/#3164-find-the-number-of-good-pairs-ii","title":"3164. Find the Number of Good Pairs II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table</p> </li> </ul>"},{"location":"EndlessCheng/factors/#952-largest-component-size-by-common-factor","title":"952. Largest Component Size by Common Factor","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Union Find, Number Theory</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef largestComponentSize(nums: List[int]) -&gt; int:\n    par = {i: i for i in nums}\n    rank = {i: 0 for i in nums}\n\n    def find(n):\n        p = par[n]\n        while par[p] != p:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            if rank[p1] &gt; rank[p2]:\n                par[p2] = p1\n            elif rank[p1] &lt; rank[p2]:\n                par[p1] = p2\n            else:\n                par[p2] = p1\n                rank[p1] += 1\n\n    def prime_factors(n):\n        \"\"\"Return the prime factors of n.\"\"\"\n        i = 2\n        factors = set()\n        while i * i &lt;= n:\n            while (n % i) == 0:\n                factors.add(i)\n                n //= i\n            i += 1\n        if n &gt; 1:\n            factors.add(n)\n        return factors\n\n    factor_map = defaultdict(list)  # factor -&gt; [nums]\n    for num in nums:\n        factors = prime_factors(num)\n        for factor in factors:\n            factor_map[factor].append(num)\n\n    for factor, group in factor_map.items():\n        for i in range(1, len(group)):\n            union(group[0], group[i])\n\n    sizes = defaultdict(int)  # component root -&gt; size\n    for num in nums:\n        root = find(num)\n        sizes[root] += 1\n\n    return max(sizes.values())\n\n\nnums = [20, 50, 9, 63]\nprint(largestComponentSize(nums))  # 2\n</code></pre>"},{"location":"EndlessCheng/factors/#1627-graph-connectivity-with-threshold","title":"1627. Graph Connectivity With Threshold","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Union Find, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/factors/#2198-number-of-single-divisor-triplets","title":"2198. Number of Single Divisor Triplets \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math</p> </li> </ul>"},{"location":"EndlessCheng/factors/#625-minimum-factorization","title":"625. Minimum Factorization \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/factors/#2847-smallest-number-with-given-digit-product","title":"2847. Smallest Number With Given Digit Product \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/fenwick_tree/","title":"Fenwick Tree","text":""},{"location":"EndlessCheng/fenwick_tree/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 307. Range Sum Query - Mutable (Medium)</li> <li> 3072. Distribute Elements Into Two Arrays II (Hard)</li> <li> 3187. Peaks in Array (Hard)</li> <li> 1649. Create Sorted Array through Instructions (Hard)</li> <li> 1626. Best Team With No Conflicts (Medium)</li> <li> 1409. Queries on a Permutation With Key (Medium)</li> <li> 2250. Count Number of Rectangles Containing Each Point (Medium)</li> <li> 2179. Count Good Triplets in an Array (Hard)</li> <li> 1395. Count Number of Teams (Medium)</li> <li> 2659. Make Array Empty (Hard)</li> <li> 2653. Sliding Subarray Beauty (Medium)</li> <li> 1505. Minimum Possible Integer After at Most K Adjacent Swaps On Digits (Hard)</li> <li> 2926. Maximum Balanced Subsequence Sum (Hard)</li> <li> 2736. Maximum Sum Queries (Hard)</li> <li> 3382. Maximum Area Rectangle With Point Constraints II (Hard)</li> <li> 3245. Alternating Groups III (Hard)</li> <li> 1756. Design Most Recently Used Queue (Medium) \ud83d\udc51</li> <li> 2519. Count the Number of K-Big Indices (Hard) \ud83d\udc51</li> <li> 2613. Beautiful Pairs (Hard) \ud83d\udc51</li> <li> 2921. Maximum Profitable Triplets With Increasing Prices II (Hard) \ud83d\udc51</li> <li> 308. Range Sum Query 2D - Mutable (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/fenwick_tree/#307-range-sum-query-mutable","title":"307. Range Sum Query - Mutable","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Design, Binary Indexed Tree, Segment Tree</p> </li> </ul>"},{"location":"EndlessCheng/fenwick_tree/#3072-distribute-elements-into-two-arrays-ii","title":"3072. Distribute Elements Into Two Arrays II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Indexed Tree, Segment Tree, Simulation</p> </li> </ul>"},{"location":"EndlessCheng/fenwick_tree/#3187-peaks-in-array","title":"3187. Peaks in Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Indexed Tree, Segment Tree</p> </li> </ul>"},{"location":"EndlessCheng/fenwick_tree/#1649-create-sorted-array-through-instructions","title":"1649. Create Sorted Array through Instructions","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Divide And Conquer, Binary Indexed Tree, Segment Tree, Merge Sort, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/fenwick_tree/#1626-best-team-with-no-conflicts","title":"1626. Best Team With No Conflicts","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Sorting</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP - LIS\ndef bestTeamScore(scores: List[int], ages: List[int]) -&gt; int:\n    n = len(scores)\n    pairs = sorted(zip(scores, ages))  # sort\n    dp = [0 for _ in range(n)]\n\n    # LIS\n    for i in range(n):\n        for j in range(i):\n            if pairs[i][1] &gt;= pairs[j][1]:\n                dp[i] = max(dp[i], dp[j])\n        dp[i] += pairs[i][0]\n\n    return max(dp)\n\n\nif __name__ == \"__main__\":\n    assert bestTeamScore([1, 3, 5, 10, 15], [1, 2, 3, 4, 5]) == 34\n    assert bestTeamScore([4, 5, 6, 5], [2, 1, 2, 1]) == 16\n</code></pre>"},{"location":"EndlessCheng/fenwick_tree/#1409-queries-on-a-permutation-with-key","title":"1409. Queries on a Permutation With Key","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Indexed Tree, Simulation</p> </li> </ul>"},{"location":"EndlessCheng/fenwick_tree/#2250-count-number-of-rectangles-containing-each-point","title":"2250. Count Number of Rectangles Containing Each Point","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Binary Indexed Tree, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/fenwick_tree/#2179-count-good-triplets-in-an-array","title":"2179. Count Good Triplets in an Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Divide And Conquer, Binary Indexed Tree, Segment Tree, Merge Sort, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/fenwick_tree/#1395-count-number-of-teams","title":"1395. Count Number of Teams","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Binary Indexed Tree, Segment Tree</p> </li> </ul>"},{"location":"EndlessCheng/fenwick_tree/#2659-make-array-empty","title":"2659. Make Array Empty","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Greedy, Binary Indexed Tree, Segment Tree, Sorting, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/fenwick_tree/#2653-sliding-subarray-beauty","title":"2653. Sliding Subarray Beauty","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/fenwick_tree/#1505-minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits","title":"1505. Minimum Possible Integer After at Most K Adjacent Swaps On Digits","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Greedy, Binary Indexed Tree, Segment Tree</p> </li> </ul>"},{"location":"EndlessCheng/fenwick_tree/#2926-maximum-balanced-subsequence-sum","title":"2926. Maximum Balanced Subsequence Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Dynamic Programming, Binary Indexed Tree, Segment Tree</p> </li> </ul>"},{"location":"EndlessCheng/fenwick_tree/#2736-maximum-sum-queries","title":"2736. Maximum Sum Queries","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Stack, Binary Indexed Tree, Segment Tree, Sorting, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/fenwick_tree/#3382-maximum-area-rectangle-with-point-constraints-ii","title":"3382. Maximum Area Rectangle With Point Constraints II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Binary Indexed Tree, Segment Tree, Geometry, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/fenwick_tree/#3245-alternating-groups-iii","title":"3245. Alternating Groups III","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Indexed Tree</p> </li> </ul>"},{"location":"EndlessCheng/fenwick_tree/#1756-design-most-recently-used-queue","title":"1756. Design Most Recently Used Queue \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Stack, Design, Binary Indexed Tree, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/fenwick_tree/#2519-count-the-number-of-k-big-indices","title":"2519. Count the Number of K-Big Indices \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Divide And Conquer, Binary Indexed Tree, Segment Tree, Merge Sort, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/fenwick_tree/#2613-beautiful-pairs","title":"2613. Beautiful Pairs \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Divide And Conquer, Geometry, Sorting, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/fenwick_tree/#2921-maximum-profitable-triplets-with-increasing-prices-ii","title":"2921. Maximum Profitable Triplets With Increasing Prices II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Indexed Tree, Segment Tree</p> </li> </ul>"},{"location":"EndlessCheng/fenwick_tree/#308-range-sum-query-2d-mutable","title":"308. Range Sum Query 2D - Mutable \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Design, Binary Indexed Tree, Segment Tree, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/from_special_to_general/","title":"From Special to General","text":""},{"location":"EndlessCheng/from_special_to_general/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2745. Construct the Longest New String (Medium)</li> <li> 2611. Mice and Cheese (Medium)</li> <li> 1029. Two City Scheduling (Medium)</li> <li> 2645. Minimum Additions to Make Valid String (Medium)</li> <li> 2202. Maximize the Topmost Element After K Moves (Medium)</li> <li> 2568. Minimum Impossible OR (Medium)</li> <li> 1702. Maximum Binary String After Change (Medium)</li> <li> 3012. Minimize Length of Array Using Operations (Medium)</li> <li> 1526. Minimum Number of Increments on Subarrays to Form a Target Array (Hard)</li> <li> 2350. Shortest Impossible Sequence of Rolls (Hard)</li> <li> 517. Super Washing Machines (Hard)</li> <li> 2499. Minimum Total Cost to Make Arrays Unequal (Hard)</li> <li> 3357. Minimize the Maximum Adjacent Element Difference (Hard)</li> </ul>"},{"location":"EndlessCheng/from_special_to_general/#2745-construct-the-longest-new-string","title":"2745. Construct the Longest New String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Greedy, Brainteaser</p> </li> </ul>"},{"location":"EndlessCheng/from_special_to_general/#2611-mice-and-cheese","title":"2611. Mice and Cheese","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/from_special_to_general/#1029-two-city-scheduling","title":"1029. Two City Scheduling","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/from_special_to_general/#2645-minimum-additions-to-make-valid-string","title":"2645. Minimum Additions to Make Valid String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Stack, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/from_special_to_general/#2202-maximize-the-topmost-element-after-k-moves","title":"2202. Maximize the Topmost Element After K Moves","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/from_special_to_general/#2568-minimum-impossible-or","title":"2568. Minimum Impossible OR","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation, Brainteaser</p> </li> </ul>"},{"location":"EndlessCheng/from_special_to_general/#1702-maximum-binary-string-after-change","title":"1702. Maximum Binary String After Change","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/from_special_to_general/#3012-minimize-length-of-array-using-operations","title":"3012. Minimize Length of Array Using Operations","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Greedy, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/from_special_to_general/#1526-minimum-number-of-increments-on-subarrays-to-form-a-target-array","title":"1526. Minimum Number of Increments on Subarrays to Form a Target Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Stack, Greedy, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/from_special_to_general/#2350-shortest-impossible-sequence-of-rolls","title":"2350. Shortest Impossible Sequence of Rolls","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/from_special_to_general/#517-super-washing-machines","title":"517. Super Washing Machines","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/from_special_to_general/#2499-minimum-total-cost-to-make-arrays-unequal","title":"2499. Minimum Total Cost to Make Arrays Unequal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Greedy, Counting</p> </li> </ul>"},{"location":"EndlessCheng/from_special_to_general/#3357-minimize-the-maximum-adjacent-element-difference","title":"3357. Minimize the Maximum Adjacent Element Difference","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/fundamental_cycle/","title":"Fundamental Cycle","text":""},{"location":"EndlessCheng/fundamental_cycle/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2359. Find Closest Node to Given Two Nodes (Medium)</li> <li> 2360. Longest Cycle in a Graph (Hard)</li> <li> 684. Redundant Connection (Medium)</li> <li> 685. Redundant Connection II (Hard)</li> <li> 2876. Count Visited Nodes in a Directed Graph (Hard)</li> <li> 2127. Maximum Employees to Be Invited to a Meeting (Hard)</li> <li> 2836. Maximize Value of Function in a Ball Passing Game (Hard)</li> <li> 2204. Distance to a Cycle in Undirected Graph (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/fundamental_cycle/#2359-find-closest-node-to-given-two-nodes","title":"2359. Find Closest Node to Given Two Nodes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Graph</p> </li> </ul>"},{"location":"EndlessCheng/fundamental_cycle/#2360-longest-cycle-in-a-graph","title":"2360. Longest Cycle in a Graph","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Graph, Topological Sort</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef longestCycle(edges: List[int]) -&gt; int:\n    n = len(edges)\n    res = -1\n    cur = 1\n    vis = [0 for _ in range(n)]\n\n    for i in range(n):\n        start = cur\n        while i != -1 and vis[i] == 0:\n            vis[i] = cur\n            cur += 1\n            i = edges[i]\n        if i != -1 and vis[i] &gt;= start:\n            res = max(res, cur - vis[i])\n\n    return res\n\n\nif __name__ == \"__main__\":\n    edges = [3, 3, 4, 2, 3]\n    print(longestCycle(edges))  # 3\n</code></pre>"},{"location":"EndlessCheng/fundamental_cycle/#684-redundant-connection","title":"684. Redundant Connection","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Union Find, Graph</p> </li> </ul> Python <pre><code>from typing import List\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(1, n + 1)}\n        self.rank = {i: 1 for i in range(1, n + 1)}\n\n    def find(self, n):\n        p = self.par[n]\n        while self.par[p] != p:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return False\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.par[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.par[p1] = p2\n        else:\n            self.par[p2] = p1\n            self.rank[p1] += 1\n\n        return True\n\n\n# Union Find\ndef findRedundantConnectionUF(edges: List[List[int]]) -&gt; List[int]:\n    n = len(edges)\n    uf = UnionFind(n)\n\n    for u, v in edges:\n        if not uf.union(u, v):\n            return (u, v)\n\n\n# DFS\ndef findRedundantConnectionDFS(edges: List[List[int]]) -&gt; List[int]:\n    graph, cycle = {}, {}\n    for a, b in edges:\n        graph.setdefault(a, []).append(b)\n        graph.setdefault(b, []).append(a)\n\n    def dfs(node, parent):\n        if node in cycle:\n            for k in list(cycle.keys()):\n                if k == node:\n                    return True\n                del cycle[k]\n\n        cycle[node] = None\n        for child in graph[node]:\n            if child != parent and dfs(child, node):\n                return True\n        del cycle[node]\n        return False\n\n    dfs(edges[0][0], -1)\n    for a, b in edges[::-1]:\n        if a in cycle and b in cycle:\n            return (a, b)\n\n\nedges = [[1, 2], [1, 3], [2, 3]]\nprint(findRedundantConnectionUF(edges))  # (2, 3)\nprint(findRedundantConnectionDFS(edges))  # (2, 3)\n</code></pre>"},{"location":"EndlessCheng/fundamental_cycle/#685-redundant-connection-ii","title":"685. Redundant Connection II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Union Find, Graph</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Union Find\ndef findRedundantDirectedConnectionUF(edges: List[List[int]]) -&gt; List[int]:\n    n = len(edges)\n    uf = UnionFind(n + 1)\n    parent = list(range(n + 1))\n    candidates = []\n\n    for u, v in edges:\n        if parent[v] != v:\n            candidates.append([parent[v], v])\n            candidates.append([u, v])\n        else:\n            parent[v] = u\n\n    if not candidates:\n        for u, v in edges:\n            if not uf.union(u, v):\n                return [u, v]\n\n    for u, v in edges:\n        if [u, v] == candidates[1]:\n            continue\n        if not uf.union(u, v):\n            return candidates[0]\n\n    return candidates[1]\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(1, n + 1)}\n\n    def find(self, n):\n        p = self.par[n]\n        while p != self.par[p]:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n        if p1 == p2:\n            return False\n        self.par[p1] = p2\n        return True\n\n\nedges = [[1, 2], [1, 3], [2, 3]]\nprint(findRedundantDirectedConnectionUF(edges))\n</code></pre>"},{"location":"EndlessCheng/fundamental_cycle/#2876-count-visited-nodes-in-a-directed-graph","title":"2876. Count Visited Nodes in a Directed Graph","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Graph, Memoization</p> </li> </ul>"},{"location":"EndlessCheng/fundamental_cycle/#2127-maximum-employees-to-be-invited-to-a-meeting","title":"2127. Maximum Employees to Be Invited to a Meeting","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Graph, Topological Sort</p> </li> </ul>"},{"location":"EndlessCheng/fundamental_cycle/#2836-maximize-value-of-function-in-a-ball-passing-game","title":"2836. Maximize Value of Function in a Ball Passing Game","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/fundamental_cycle/#2204-distance-to-a-cycle-in-undirected-graph","title":"2204. Distance to a Cycle in Undirected Graph \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Union Find, Graph</p> </li> </ul>"},{"location":"EndlessCheng/game_theory/","title":"Game Theory","text":""},{"location":"EndlessCheng/game_theory/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 292. Nim Game (Easy)</li> <li> 1025. Divisor Game (Easy)</li> <li> 3227. Vowels Game in a String (Medium)</li> <li> 2038. Remove Colored Pieces if Both Neighbors are the Same Color (Medium)</li> <li> 877. Stone Game (Medium)</li> <li> 1510. Stone Game IV (Hard)</li> <li> 486. Predict the Winner (Medium)</li> <li> 1690. Stone Game VII (Medium)</li> <li> 1686. Stone Game VI (Medium)</li> <li> 1927. Sum Game (Medium)</li> <li> 1406. Stone Game III (Hard)</li> <li> 1140. Stone Game II (Medium)</li> <li> 1563. Stone Game V (Hard)</li> <li> 464. Can I Win (Medium)</li> <li> 2029. Stone Game IX (Medium)</li> <li> 810. Chalkboard XOR Game (Hard)</li> <li> 1872. Stone Game VIII (Hard)</li> <li> 913. Cat and Mouse (Hard)</li> <li> 1728. Cat and Mouse II (Hard)</li> <li> 294. Flip Game II (Medium) \ud83d\udc51</li> <li> 1908. Game of Nim (Medium) \ud83d\udc51</li> <li> 2005. Subtree Removal Game with Fibonacci Tree (Hard) \ud83d\udc51</li> <li> 2868. The Wording Game (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/game_theory/#292-nim-game","title":"292. Nim Game","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Brainteaser, Game Theory</p> </li> </ul>"},{"location":"EndlessCheng/game_theory/#1025-divisor-game","title":"1025. Divisor Game","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Brainteaser, Game Theory</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return `True` if Alice wins the game, assuming both players play optimally.\n-   `dp[n]` stores the result of the game when the number is `n`.\n-   Initialize `dp[1] = False`.\n\"\"\"\n\n\n# DP\ndef divisorGameDP(n: int) -&gt; bool:\n    if n &lt;= 1:\n        return False\n\n    dp = [False for _ in range(n + 1)]\n\n    for i in range(2, n + 1):\n        for j in range(1, i):\n            if i % j == 0 and not dp[i - j]:\n                dp[i] = True\n                break\n\n    return dp[n]\n\n\n# Math\ndef divisorGameDPMath(n: int) -&gt; bool:\n    return n % 2 == 0\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |  DP         |      O(n^2)     |    O(n)      |\n# |  Math       |      O(1)       |    O(1)      |\n# |-------------|-----------------|--------------|\n\nn = 2\nprint(divisorGameDP(n))  # True\nprint(divisorGameDPMath(n))  # True\n</code></pre>"},{"location":"EndlessCheng/game_theory/#3227-vowels-game-in-a-string","title":"3227. Vowels Game in a String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String, Brainteaser, Game Theory</p> </li> </ul>"},{"location":"EndlessCheng/game_theory/#2038-remove-colored-pieces-if-both-neighbors-are-the-same-color","title":"2038. Remove Colored Pieces if Both Neighbors are the Same Color","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String, Greedy, Game Theory</p> </li> </ul>"},{"location":"EndlessCheng/game_theory/#877-stone-game","title":"877. Stone Game","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Game Theory</p> </li> </ul>"},{"location":"EndlessCheng/game_theory/#1510-stone-game-iv","title":"1510. Stone Game IV","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Game Theory</p> </li> </ul>"},{"location":"EndlessCheng/game_theory/#486-predict-the-winner","title":"486. Predict the Winner","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Recursion, Game Theory</p> </li> </ul>"},{"location":"EndlessCheng/game_theory/#1690-stone-game-vii","title":"1690. Stone Game VII","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Game Theory</p> </li> </ul>"},{"location":"EndlessCheng/game_theory/#1686-stone-game-vi","title":"1686. Stone Game VI","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Greedy, Sorting, Heap Priority Queue, Game Theory</p> </li> </ul>"},{"location":"EndlessCheng/game_theory/#1927-sum-game","title":"1927. Sum Game","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String, Greedy, Game Theory</p> </li> </ul>"},{"location":"EndlessCheng/game_theory/#1406-stone-game-iii","title":"1406. Stone Game III","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Game Theory</p> </li> </ul>"},{"location":"EndlessCheng/game_theory/#1140-stone-game-ii","title":"1140. Stone Game II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Prefix Sum, Game Theory</p> </li> </ul>"},{"location":"EndlessCheng/game_theory/#1563-stone-game-v","title":"1563. Stone Game V","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Game Theory</p> </li> </ul>"},{"location":"EndlessCheng/game_theory/#464-can-i-win","title":"464. Can I Win","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Bit Manipulation, Memoization, Game Theory, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/game_theory/#2029-stone-game-ix","title":"2029. Stone Game IX","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Greedy, Counting, Game Theory</p> </li> </ul>"},{"location":"EndlessCheng/game_theory/#810-chalkboard-xor-game","title":"810. Chalkboard XOR Game","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Bit Manipulation, Brainteaser, Game Theory</p> </li> </ul>"},{"location":"EndlessCheng/game_theory/#1872-stone-game-viii","title":"1872. Stone Game VIII","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Prefix Sum, Game Theory</p> </li> </ul>"},{"location":"EndlessCheng/game_theory/#913-cat-and-mouse","title":"913. Cat and Mouse","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Graph, Topological Sort, Memoization, Game Theory</p> </li> </ul>"},{"location":"EndlessCheng/game_theory/#1728-cat-and-mouse-ii","title":"1728. Cat and Mouse II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Graph, Topological Sort, Memoization, Matrix, Game Theory</p> </li> </ul>"},{"location":"EndlessCheng/game_theory/#294-flip-game-ii","title":"294. Flip Game II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Backtracking, Memoization, Game Theory</p> </li> </ul>"},{"location":"EndlessCheng/game_theory/#1908-game-of-nim","title":"1908. Game of Nim \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Bit Manipulation, Brainteaser, Game Theory</p> </li> </ul>"},{"location":"EndlessCheng/game_theory/#2005-subtree-removal-game-with-fibonacci-tree","title":"2005. Subtree Removal Game with Fibonacci Tree \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Tree, Binary Tree, Game Theory</p> </li> </ul>"},{"location":"EndlessCheng/game_theory/#2868-the-wording-game","title":"2868. The Wording Game \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Two Pointers, String, Greedy, Game Theory</p> </li> </ul>"},{"location":"EndlessCheng/gcd_union_find/","title":"GCD Union Find","text":""},{"location":"EndlessCheng/gcd_union_find/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2709. Greatest Common Divisor Traversal (Hard)</li> <li> 1627. Graph Connectivity With Threshold (Hard)</li> <li> 952. Largest Component Size by Common Factor (Hard)</li> <li> 1998. GCD Sort of an Array (Hard)</li> <li> 3378. Count Connected Components in LCM Graph (Hard)</li> </ul>"},{"location":"EndlessCheng/gcd_union_find/#2709-greatest-common-divisor-traversal","title":"2709. Greatest Common Divisor Traversal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Union Find, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/gcd_union_find/#1627-graph-connectivity-with-threshold","title":"1627. Graph Connectivity With Threshold","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Union Find, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/gcd_union_find/#952-largest-component-size-by-common-factor","title":"952. Largest Component Size by Common Factor","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Union Find, Number Theory</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef largestComponentSize(nums: List[int]) -&gt; int:\n    par = {i: i for i in nums}\n    rank = {i: 0 for i in nums}\n\n    def find(n):\n        p = par[n]\n        while par[p] != p:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            if rank[p1] &gt; rank[p2]:\n                par[p2] = p1\n            elif rank[p1] &lt; rank[p2]:\n                par[p1] = p2\n            else:\n                par[p2] = p1\n                rank[p1] += 1\n\n    def prime_factors(n):\n        \"\"\"Return the prime factors of n.\"\"\"\n        i = 2\n        factors = set()\n        while i * i &lt;= n:\n            while (n % i) == 0:\n                factors.add(i)\n                n //= i\n            i += 1\n        if n &gt; 1:\n            factors.add(n)\n        return factors\n\n    factor_map = defaultdict(list)  # factor -&gt; [nums]\n    for num in nums:\n        factors = prime_factors(num)\n        for factor in factors:\n            factor_map[factor].append(num)\n\n    for factor, group in factor_map.items():\n        for i in range(1, len(group)):\n            union(group[0], group[i])\n\n    sizes = defaultdict(int)  # component root -&gt; size\n    for num in nums:\n        root = find(num)\n        sizes[root] += 1\n\n    return max(sizes.values())\n\n\nnums = [20, 50, 9, 63]\nprint(largestComponentSize(nums))  # 2\n</code></pre>"},{"location":"EndlessCheng/gcd_union_find/#1998-gcd-sort-of-an-array","title":"1998. GCD Sort of an Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Union Find, Sorting, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/gcd_union_find/#3378-count-connected-components-in-lcm-graph","title":"3378. Count Connected Components in LCM Graph","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Union Find, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/general_tree_bottom-up_dfs/","title":"General Tree Bottom-Up DFS","text":""},{"location":"EndlessCheng/general_tree_bottom-up_dfs/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3249. Count the Number of Good Nodes (Medium)</li> <li> 1519. Number of Nodes in the Sub-Tree With the Same Label (Medium)</li> <li> 2872. Maximum Number of K-Divisible Components (Hard)</li> <li> 2477. Minimum Fuel Cost to Report to the Capital (Medium)</li> <li> 2973. Find Number of Coins to Place in Tree Nodes (Hard)</li> <li> 2440. Create Components With Same Value (Hard)</li> <li> 1273. Delete Tree Nodes (Medium) \ud83d\udc51</li> <li> 3004. Maximum Subtree of the Same Color (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/general_tree_bottom-up_dfs/#3249-count-the-number-of-good-nodes","title":"3249. Count the Number of Good Nodes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search</p> </li> </ul>"},{"location":"EndlessCheng/general_tree_bottom-up_dfs/#1519-number-of-nodes-in-the-sub-tree-with-the-same-label","title":"1519. Number of Nodes in the Sub-Tree With the Same Label","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Tree, Depth First Search, Breadth First Search, Counting</p> </li> </ul>"},{"location":"EndlessCheng/general_tree_bottom-up_dfs/#2872-maximum-number-of-k-divisible-components","title":"2872. Maximum Number of K-Divisible Components","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search</p> </li> </ul>"},{"location":"EndlessCheng/general_tree_bottom-up_dfs/#2477-minimum-fuel-cost-to-report-to-the-capital","title":"2477. Minimum Fuel Cost to Report to the Capital","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Graph</p> </li> </ul>"},{"location":"EndlessCheng/general_tree_bottom-up_dfs/#2973-find-number-of-coins-to-place-in-tree-nodes","title":"2973. Find Number of Coins to Place in Tree Nodes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Tree, Depth First Search, Sorting, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/general_tree_bottom-up_dfs/#2440-create-components-with-same-value","title":"2440. Create Components With Same Value","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Tree, Depth First Search, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/general_tree_bottom-up_dfs/#1273-delete-tree-nodes","title":"1273. Delete Tree Nodes \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Tree, Depth First Search, Breadth First Search</p> </li> </ul>"},{"location":"EndlessCheng/general_tree_bottom-up_dfs/#3004-maximum-subtree-of-the-same-color","title":"3004. Maximum Subtree of the Same Color \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Tree, Depth First Search</p> </li> </ul>"},{"location":"EndlessCheng/general_tree_dfs_timestamp/","title":"General Tree DFS Timestamp","text":""},{"location":"EndlessCheng/general_tree_dfs_timestamp/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2322. Minimum Score After Removals on a Tree (Hard)</li> <li> 3327. Check if DFS Strings Are Palindromes (Hard)</li> </ul>"},{"location":"EndlessCheng/general_tree_dfs_timestamp/#2322-minimum-score-after-removals-on-a-tree","title":"2322. Minimum Score After Removals on a Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation, Tree, Depth First Search</p> </li> </ul>"},{"location":"EndlessCheng/general_tree_dfs_timestamp/#3327-check-if-dfs-strings-are-palindromes","title":"3327. Check if DFS Strings Are Palindromes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Tree, Depth First Search, Hash Function</p> </li> </ul>"},{"location":"EndlessCheng/general_tree_diameter/","title":"General Tree Diameter","text":""},{"location":"EndlessCheng/general_tree_diameter/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2246. Longest Path With Different Adjacent Characters (Hard)</li> <li> 3203. Find Minimum Diameter After Merging Two Trees (Hard)</li> <li> 1617. Count Subtrees With Max Distance Between Cities (Hard)</li> <li> 2538. Difference Between Maximum and Minimum Price Sum (Hard)</li> <li> 1245. Tree Diameter (Medium) \ud83d\udc51</li> <li> 3313. Find the Last Marked Nodes in Tree (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/general_tree_diameter/#2246-longest-path-with-different-adjacent-characters","title":"2246. Longest Path With Different Adjacent Characters","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Tree, Depth First Search, Graph, Topological Sort</p> </li> </ul>"},{"location":"EndlessCheng/general_tree_diameter/#3203-find-minimum-diameter-after-merging-two-trees","title":"3203. Find Minimum Diameter After Merging Two Trees","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Graph</p> </li> </ul>"},{"location":"EndlessCheng/general_tree_diameter/#1617-count-subtrees-with-max-distance-between-cities","title":"1617. Count Subtrees With Max Distance Between Cities","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Bit Manipulation, Tree, Enumeration, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/general_tree_diameter/#2538-difference-between-maximum-and-minimum-price-sum","title":"2538. Difference Between Maximum and Minimum Price Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Tree, Depth First Search</p> </li> </ul>"},{"location":"EndlessCheng/general_tree_diameter/#1245-tree-diameter","title":"1245. Tree Diameter \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Graph, Topological Sort</p> </li> </ul> Python <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# Tree Diameter\ndef treeDiameter(edges: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = {0}\n    q = deque([0])\n    cur = 0\n\n    while q:\n        size = len(q)\n        for _ in range(size):\n            cur = q.popleft()\n            for nxt in graph[cur]:\n                if nxt not in visited:\n                    q.append(nxt)\n                    visited.add(nxt)\n\n    visited = {cur}\n    q = deque([cur])\n    res = -1\n\n    while q:\n        size = len(q)\n        for _ in range(size):\n            cur = q.popleft()\n            for nxt in graph[cur]:\n                if nxt not in visited:\n                    q.append(nxt)\n                    visited.add(nxt)\n        res += 1\n\n    return res\n\n\nedges = [[0, 1], [1, 2], [2, 3], [1, 4], [4, 5]]\nassert treeDiameter(edges) == 4\n</code></pre>"},{"location":"EndlessCheng/general_tree_diameter/#3313-find-the-last-marked-nodes-in-tree","title":"3313. Find the Last Marked Nodes in Tree \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search</p> </li> </ul>"},{"location":"EndlessCheng/general_tree_lowest_common_ancestor/","title":"General Tree Lowest Common Ancestor","text":""},{"location":"EndlessCheng/general_tree_lowest_common_ancestor/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1483. Kth Ancestor of a Tree Node (Hard)</li> <li> 2846. Minimum Edge Weight Equilibrium Queries in a Tree (Hard)</li> <li> 2277. Closest Node to Path in Tree (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/general_tree_lowest_common_ancestor/#1483-kth-ancestor-of-a-tree-node","title":"1483. Kth Ancestor of a Tree Node","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Binary Search, Dynamic Programming, Tree, Depth First Search, Breadth First Search, Design</p> </li> </ul>"},{"location":"EndlessCheng/general_tree_lowest_common_ancestor/#2846-minimum-edge-weight-equilibrium-queries-in-a-tree","title":"2846. Minimum Edge Weight Equilibrium Queries in a Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Tree, Graph, Strongly Connected Component</p> </li> </ul>"},{"location":"EndlessCheng/general_tree_lowest_common_ancestor/#2277-closest-node-to-path-in-tree","title":"2277. Closest Node to Path in Tree \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Tree, Depth First Search, Breadth First Search</p> </li> </ul>"},{"location":"EndlessCheng/general_tree_others/","title":"General Tree Others","text":""},{"location":"EndlessCheng/general_tree_others/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2003. Smallest Missing Genetic Value in Each Subtree (Hard)</li> <li> 2867. Count Valid Paths in a Tree (Hard)</li> <li> 2421. Number of Good Paths (Hard)</li> <li> 1719. Number Of Ways To Reconstruct A Tree (Hard)</li> <li> 2479. Maximum XOR of Two Non-Overlapping Subtrees (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/general_tree_others/#2003-smallest-missing-genetic-value-in-each-subtree","title":"2003. Smallest Missing Genetic Value in Each Subtree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Tree, Depth First Search, Union Find</p> </li> </ul>"},{"location":"EndlessCheng/general_tree_others/#2867-count-valid-paths-in-a-tree","title":"2867. Count Valid Paths in a Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Tree, Depth First Search, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/general_tree_others/#2421-number-of-good-paths","title":"2421. Number of Good Paths","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Tree, Union Find, Graph, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/general_tree_others/#1719-number-of-ways-to-reconstruct-a-tree","title":"1719. Number Of Ways To Reconstruct A Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Graph</p> </li> </ul>"},{"location":"EndlessCheng/general_tree_others/#2479-maximum-xor-of-two-non-overlapping-subtrees","title":"2479. Maximum XOR of Two Non-Overlapping Subtrees \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Graph, Trie</p> </li> </ul>"},{"location":"EndlessCheng/general_tree_recursion/","title":"General Tree Recursion","text":""},{"location":"EndlessCheng/general_tree_recursion/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3331. Find Subtree Sizes After Changes (Medium)</li> </ul>"},{"location":"EndlessCheng/general_tree_recursion/#3331-find-subtree-sizes-after-changes","title":"3331. Find Subtree Sizes After Changes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Tree, Depth First Search</p> </li> </ul>"},{"location":"EndlessCheng/general_tree_top-down_dfs/","title":"General Tree Top-Down DFS","text":""},{"location":"EndlessCheng/general_tree_top-down_dfs/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1376. Time Needed to Inform All Employees (Medium)</li> <li> 1443. Minimum Time to Collect All Apples in a Tree (Medium)</li> <li> 1377. Frog Position After T Seconds (Hard)</li> <li> 3067. Count Pairs of Connectable Servers in a Weighted Tree Network (Medium)</li> <li> 3372. Maximize the Number of Target Nodes After Connecting Trees I (Medium)</li> <li> 2467. Most Profitable Path in a Tree (Medium)</li> <li> 3373. Maximize the Number of Target Nodes After Connecting Trees II (Hard)</li> <li> 1766. Tree of Coprimes (Hard)</li> <li> 3425. Longest Special Path (Hard)</li> <li> 2791. Count Paths That Can Form a Palindrome in a Tree (Hard)</li> </ul>"},{"location":"EndlessCheng/general_tree_top-down_dfs/#1376-time-needed-to-inform-all-employees","title":"1376. Time Needed to Inform All Employees","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search</p> </li> </ul> Python <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# DFS\ndef numOfMinutesDFS(\n    n: int, headID: int, manager: List[int], informTime: List[int]\n) -&gt; int:\n    graph = defaultdict(list)\n    for i in range(n):\n        if manager[i] != -1:\n            graph[manager[i]].append(i)\n\n    def dfs(node):\n        time = 0\n        for sub in graph[node]:\n            time = max(time, dfs(sub))\n        return time + informTime[node]\n\n    return dfs(headID)\n\n\n# BFS\ndef numOfMinutesBFS(\n    n: int, headID: int, manager: List[int], informTime: List[int]\n) -&gt; int:\n    graph = defaultdict(list)\n    for i in range(n):\n        if manager[i] != -1:\n            graph[manager[i]].append(i)\n\n    q = deque([(headID, 0)])\n    max_time = 0\n\n    while q:\n        node, time = q.popleft()\n        max_time = max(max_time, time)\n        for sub in graph[node]:\n            q.append((sub, time + informTime[node]))\n\n    return max_time\n\n\nn = 6\nheadID = 2\nmanager = [2, 2, -1, 2, 2, 2]\ninformTime = [0, 0, 1, 0, 0, 0]\nprint(numOfMinutesDFS(n, headID, manager, informTime))  # 1\nprint(numOfMinutesBFS(n, headID, manager, informTime))  # 1\n</code></pre>"},{"location":"EndlessCheng/general_tree_top-down_dfs/#1443-minimum-time-to-collect-all-apples-in-a-tree","title":"1443. Minimum Time to Collect All Apples in a Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Tree, Depth First Search, Breadth First Search</p> </li> </ul>"},{"location":"EndlessCheng/general_tree_top-down_dfs/#1377-frog-position-after-t-seconds","title":"1377. Frog Position After T Seconds","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Graph</p> </li> </ul>"},{"location":"EndlessCheng/general_tree_top-down_dfs/#3067-count-pairs-of-connectable-servers-in-a-weighted-tree-network","title":"3067. Count Pairs of Connectable Servers in a Weighted Tree Network","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Tree, Depth First Search</p> </li> </ul>"},{"location":"EndlessCheng/general_tree_top-down_dfs/#3372-maximize-the-number-of-target-nodes-after-connecting-trees-i","title":"3372. Maximize the Number of Target Nodes After Connecting Trees I","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search</p> </li> </ul> Python <pre><code>from typing import Callable, List, Tuple\n\n\ndef maxTargetNodes(edges1: List[List[int]], edges2: List[List[int]], k: int) -&gt; List[int]:\n    n = len(edges1) + 1\n    m = len(edges2) + 1\n\n    def calc_tree(\n        edges: List[List[int]], k: int\n    ) -&gt; Tuple[int, Callable[[int, int, int], int]]:\n        g = [[] for _ in range(len(edges) + 1)]\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n\n        diameter = 0\n\n        def dfs_diameter(x: int, fa: int) -&gt; int:\n            nonlocal diameter\n            max_len = 0\n            for y in g[x]:\n                if y != fa:\n                    sub_len = dfs_diameter(y, x) + 1\n                    diameter = max(diameter, max_len + sub_len)\n                    max_len = max(max_len, sub_len)\n            return max_len\n\n        dfs_diameter(0, -1)\n\n        def dfs(x: int, fa: int, d: int) -&gt; int:\n            if d &gt; k:\n                return 0\n            cnt = 1\n            for y in g[x]:\n                if y != fa:\n                    cnt += dfs(y, x, d + 1)\n            return cnt\n\n        return diameter, dfs\n\n    max2 = 0\n    if k:\n        diameter, dfs = calc_tree(edges2, k - 1)\n        if diameter &lt; k:\n            max2 = m  # All nodes in the second tree are target nodes\n        else:\n            max2 = max(dfs(i, -1, 0) for i in range(m))\n\n    diameter, dfs = calc_tree(edges1, k)\n    if diameter &lt;= k:\n        return [n + max2] * n  # All nodes in the first tree are target nodes\n    return [dfs(i, -1, 0) + max2 for i in range(n)]\n</code></pre>"},{"location":"EndlessCheng/general_tree_top-down_dfs/#2467-most-profitable-path-in-a-tree","title":"2467. Most Profitable Path in a Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Tree, Depth First Search, Breadth First Search, Graph</p> </li> </ul>"},{"location":"EndlessCheng/general_tree_top-down_dfs/#3373-maximize-the-number-of-target-nodes-after-connecting-trees-ii","title":"3373. Maximize the Number of Target Nodes After Connecting Trees II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search</p> </li> </ul>"},{"location":"EndlessCheng/general_tree_top-down_dfs/#1766-tree-of-coprimes","title":"1766. Tree of Coprimes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Tree, Depth First Search, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/general_tree_top-down_dfs/#3425-longest-special-path","title":"3425. Longest Special Path","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Tree, Depth First Search, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/general_tree_top-down_dfs/#2791-count-paths-that-can-form-a-palindrome-in-a-tree","title":"2791. Count Paths That Can Form a Palindrome in a Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Bit Manipulation, Tree, Depth First Search, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/general_tree_topological_sort/","title":"General Tree Topological Sort","text":""},{"location":"EndlessCheng/general_tree_topological_sort/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 310. Minimum Height Trees (Medium)</li> <li> 2603. Collect Coins in a Tree (Hard)</li> </ul>"},{"location":"EndlessCheng/general_tree_topological_sort/#310-minimum-height-trees","title":"310. Minimum Height Trees","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Graph, Topological Sort</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\ndef findMinHeightTrees(n: int, edges: List[List[int]]) -&gt; List[int]:\n    if n == 1:\n        return [0]\n\n    graph = {i: set() for i in range(n)}\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    q = deque([i for i in range(n) if len(graph[i]) == 1])\n    remaining = n\n\n    while remaining &gt; 2:\n        size = len(q)\n        remaining -= size\n\n        for _ in range(size):\n            cur = q.popleft()\n            nei = graph[cur].pop()\n            graph[nei].remove(cur)\n\n            if len(graph[nei]) == 1:\n                q.append(nei)\n\n    return list(q)\n\n\nn = 6\nedges = [[3, 0], [3, 1], [3, 2], [3, 4], [5, 4]]\nprint(findMinHeightTrees(n, edges))  # [3, 4]\n</code></pre>"},{"location":"EndlessCheng/general_tree_topological_sort/#2603-collect-coins-in-a-tree","title":"2603. Collect Coins in a Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Tree, Graph, Topological Sort</p> </li> </ul>"},{"location":"EndlessCheng/general_tree_traversal/","title":"General Tree Traversal","text":""},{"location":"EndlessCheng/general_tree_traversal/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2368. Reachable Nodes With Restrictions (Medium)</li> <li> 1466. Reorder Routes to Make All Paths Lead to the City Zero (Medium)</li> <li> 582. Kill Process (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/general_tree_traversal/#2368-reachable-nodes-with-restrictions","title":"2368. Reachable Nodes With Restrictions","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Tree, Depth First Search, Breadth First Search, Union Find, Graph</p> </li> </ul>"},{"location":"EndlessCheng/general_tree_traversal/#1466-reorder-routes-to-make-all-paths-lead-to-the-city-zero","title":"1466. Reorder Routes to Make All Paths Lead to the City Zero","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Graph</p> </li> </ul> Python <pre><code>\"\"\"\n-   ![1466](https://assets.leetcode.com/uploads/2020/05/13/sample_1_1819.png)\n\"\"\"\n\nfrom collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef minReorderBFS(n: int, connections: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append((v, 1))  # go\n        graph[v].append((u, 0))  # come\n\n    changes = 0\n    q = deque([(0, -1)])\n\n    while q:\n        n1, d1 = q.popleft()\n\n        for n2, d2 in graph[n1]:\n            if n2 != d1:\n                changes += d2\n                q.append((n2, n1))\n\n    return changes\n\n\n# DFS\ndef minReorderDFS(n: int, connections: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append((v, 1))  # go\n        graph[v].append((u, 0))  # come\n\n    def dfs(n1, d1):\n        changes = 0\n        for n2, d2 in graph[n1]:\n            if n2 != d1:\n                changes += d2 + dfs(n2, n1)\n        return changes\n\n    return dfs(0, -1)\n\n\nn = 5\nconnections = [[1, 0], [1, 2], [3, 2], [3, 4]]\nprint(minReorderBFS(n, connections))  # 2\nprint(minReorderDFS(n, connections))  # 2\n</code></pre>"},{"location":"EndlessCheng/general_tree_traversal/#582-kill-process","title":"582. Kill Process \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Tree, Depth First Search, Breadth First Search</p> </li> </ul> Python <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef killProcess(pid: List[int], ppid: List[int], kill: int) -&gt; List[int]:\n    graph = defaultdict(list)\n\n    for u, v in zip(ppid, pid):\n        graph[u].append(v)\n\n    q = deque([kill])\n    res = []\n\n    while q:\n        cur = q.popleft()\n        res.append(cur)\n        for nxt in graph[cur]:\n            q.append(nxt)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    pid = [1, 3, 10, 5]\n    ppid = [3, 0, 5, 3]\n    kill = 5\n    assert killProcess(pid, ppid, kill) == [5, 10]\n</code></pre>"},{"location":"EndlessCheng/graph_others/","title":"Graph Others","text":""},{"location":"EndlessCheng/graph_others/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1042. Flower Planting With No Adjacent (Medium)</li> <li> 1761. Minimum Degree of a Connected Trio in a Graph (Hard)</li> <li> 2508. Add Edges to Make Degrees of All Nodes Even (Hard)</li> <li> 1579. Remove Max Number of Edges to Keep Graph Fully Traversable (Hard)</li> <li> 2065. Maximum Path Quality of a Graph (Hard)</li> <li> 1697. Checking Existence of Edge Length Limited Paths (Hard)</li> <li> 2242. Maximum Score of a Node Sequence (Hard)</li> <li> 2493. Divide Nodes Into the Maximum Number of Groups (Hard)</li> <li> 1782. Count Pairs Of Nodes (Hard)</li> <li> 3435. Frequencies of Shortest Supersequences (Hard)</li> <li> 277. Find the Celebrity (Medium) \ud83d\udc51</li> <li> 1724. Checking Existence of Edge Length Limited Paths II (Hard) \ud83d\udc51</li> <li> 2077. Paths in Maze That Lead to Same Room (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/graph_others/#1042-flower-planting-with-no-adjacent","title":"1042. Flower Planting With No Adjacent","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Graph</p> </li> </ul>"},{"location":"EndlessCheng/graph_others/#1761-minimum-degree-of-a-connected-trio-in-a-graph","title":"1761. Minimum Degree of a Connected Trio in a Graph","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Graph</p> </li> </ul>"},{"location":"EndlessCheng/graph_others/#2508-add-edges-to-make-degrees-of-all-nodes-even","title":"2508. Add Edges to Make Degrees of All Nodes Even","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Graph</p> </li> </ul>"},{"location":"EndlessCheng/graph_others/#1579-remove-max-number-of-edges-to-keep-graph-fully-traversable","title":"1579. Remove Max Number of Edges to Keep Graph Fully Traversable","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Union Find, Graph</p> </li> </ul> Python <pre><code>\"\"\"\n- Return the maximum number of edges you can remove so that the graph remains fully traversable.\n\n![1579](../../assets/1579.png){width=200px}\n\"\"\"\n\nfrom typing import List\n\n\n# Kruskal\ndef maxNumEdgesToRemove(n: int, edges: List[List[int]]) -&gt; int:\n    alice, bob = UnionFind(n), UnionFind(n)\n    visited = 0\n\n    for t, u, v in edges:\n        if t == 3:\n            if alice.union(u, v) | bob.union(u, v):\n                visited += 1\n\n    for t, u, v in edges:\n        if t == 1:\n            if alice.union(u, v):\n                visited += 1\n        elif t == 2:\n            if bob.union(u, v):\n                visited += 1\n\n    if alice.components &gt; 1 or bob.components &gt; 1:\n        return -1\n\n    return len(edges) - visited\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = {i: i for i in range(1, n + 1)}\n        self.rank = {i: 0 for i in range(1, n + 1)}\n        self.components = n\n\n    def find(self, n):\n        p = self.parent[n]\n        while self.parent[p] != p:\n            self.parent[p] = self.parent[self.parent[p]]\n            p = self.parent[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return False\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.parent[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.parent[p1] = p2\n        else:\n            self.parent[p2] = p1\n            self.rank[p1] += 1\n\n        self.components -= 1\n\n        return True\n\n\nn = 4\nedges = [[3, 1, 2], [3, 2, 3], [1, 1, 3], [1, 2, 4], [1, 1, 2], [2, 3, 4]]\nprint(maxNumEdgesToRemove(n, edges))  # 2\n</code></pre>"},{"location":"EndlessCheng/graph_others/#2065-maximum-path-quality-of-a-graph","title":"2065. Maximum Path Quality of a Graph","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking, Graph</p> </li> </ul>"},{"location":"EndlessCheng/graph_others/#1697-checking-existence-of-edge-length-limited-paths","title":"1697. Checking Existence of Edge Length Limited Paths","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Union Find, Graph, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/graph_others/#2242-maximum-score-of-a-node-sequence","title":"2242. Maximum Score of a Node Sequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Graph, Sorting, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/graph_others/#2493-divide-nodes-into-the-maximum-number-of-groups","title":"2493. Divide Nodes Into the Maximum Number of Groups","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Union Find, Graph</p> </li> </ul>"},{"location":"EndlessCheng/graph_others/#1782-count-pairs-of-nodes","title":"1782. Count Pairs Of Nodes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Graph, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/graph_others/#3435-frequencies-of-shortest-supersequences","title":"3435. Frequencies of Shortest Supersequences","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Bit Manipulation, Graph, Topological Sort, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/graph_others/#277-find-the-celebrity","title":"277. Find the Celebrity \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, Graph, Interactive</p> </li> </ul>"},{"location":"EndlessCheng/graph_others/#1724-checking-existence-of-edge-length-limited-paths-ii","title":"1724. Checking Existence of Edge Length Limited Paths II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Union Find, Graph, Minimum Spanning Tree</p> </li> </ul>"},{"location":"EndlessCheng/graph_others/#2077-paths-in-maze-that-lead-to-same-room","title":"2077. Paths in Maze That Lead to Same Room \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Graph</p> </li> </ul>"},{"location":"EndlessCheng/greatest_common_divisor/","title":"Greatest Common Divisor","text":""},{"location":"EndlessCheng/greatest_common_divisor/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1979. Find Greatest Common Divisor of Array (Easy)</li> <li> 2807. Insert Greatest Common Divisors in Linked List (Medium)</li> <li> 914. X of a Kind in a Deck of Cards (Easy)</li> <li> 1071. Greatest Common Divisor of Strings (Easy)</li> <li> 2344. Minimum Deletions to Make Array Divisible (Hard)</li> <li> 365. Water and Jug Problem (Medium)</li> <li> 858. Mirror Reflection (Medium)</li> <li> 2654. Minimum Number of Operations to Make All Array Elements Equal to 1 (Medium)</li> <li> 1250. Check If It Is a Good Array (Hard)</li> <li> 149. Max Points on a Line (Hard)</li> <li> 2607. Make K-Subarray Sums Equal (Medium)</li> <li> 2447. Number of Subarrays With GCD Equal to K (Medium)</li> <li> 2543. Check if Point Is Reachable (Hard)</li> <li> 2183. Count Array Pairs Divisible by K (Hard)</li> <li> 3312. Sorted GCD Pair Queries (Hard)</li> <li> 1819. Number of Different Subsequences GCDs (Hard)</li> <li> 2436. Minimum Split Into Subarrays With GCD Greater Than One (Medium) \ud83d\udc51</li> <li> 2464. Minimum Subarrays in a Valid Split (Medium) \ud83d\udc51</li> <li> 2941. Maximum GCD-Sum of a Subarray (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/greatest_common_divisor/#1979-find-greatest-common-divisor-of-array","title":"1979. Find Greatest Common Divisor of Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/greatest_common_divisor/#2807-insert-greatest-common-divisors-in-linked-list","title":"2807. Insert Greatest Common Divisors in Linked List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Math, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/greatest_common_divisor/#914-x-of-a-kind-in-a-deck-of-cards","title":"914. X of a Kind in a Deck of Cards","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Counting, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/greatest_common_divisor/#1071-greatest-common-divisor-of-strings","title":"1071. Greatest Common Divisor of Strings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String</p> </li> </ul>"},{"location":"EndlessCheng/greatest_common_divisor/#2344-minimum-deletions-to-make-array-divisible","title":"2344. Minimum Deletions to Make Array Divisible","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Sorting, Heap Priority Queue, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/greatest_common_divisor/#365-water-and-jug-problem","title":"365. Water and Jug Problem","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Depth First Search, Breadth First Search</p> </li> </ul>"},{"location":"EndlessCheng/greatest_common_divisor/#858-mirror-reflection","title":"858. Mirror Reflection","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Geometry, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/greatest_common_divisor/#2654-minimum-number-of-operations-to-make-all-array-elements-equal-to-1","title":"2654. Minimum Number of Operations to Make All Array Elements Equal to 1","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/greatest_common_divisor/#1250-check-if-it-is-a-good-array","title":"1250. Check If It Is a Good Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/greatest_common_divisor/#149-max-points-on-a-line","title":"149. Max Points on a Line","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Geometry</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\nclass Solution:\n    def maxPoints(self, points: List[List[int]]) -&gt; int:\n        # edge case\n        n = len(points)\n        if n &lt;= 2:\n            return n\n\n        res = 0\n\n        for i in range(n - 1):\n            x1, y1 = points[i]\n            cnt = defaultdict(int)\n\n            for j in range(i + 1, n):\n                x2, y2 = points[j]\n                g = \"inf\" if x1 == x2 else (y2 - y1) / (x2 - x1)\n                cnt[g] += 1\n\n            res = max(res, 1 + max(cnt.values()))\n\n        return res\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    points = [[1, 1], [3, 2], [5, 3], [4, 1], [2, 3], [1, 4]]\n    assert sol.maxPoints(points) == 4\n</code></pre>"},{"location":"EndlessCheng/greatest_common_divisor/#2607-make-k-subarray-sums-equal","title":"2607. Make K-Subarray Sums Equal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Greedy, Sorting, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/greatest_common_divisor/#2447-number-of-subarrays-with-gcd-equal-to-k","title":"2447. Number of Subarrays With GCD Equal to K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/greatest_common_divisor/#2543-check-if-point-is-reachable","title":"2543. Check if Point Is Reachable","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/greatest_common_divisor/#2183-count-array-pairs-divisible-by-k","title":"2183. Count Array Pairs Divisible by K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/greatest_common_divisor/#3312-sorted-gcd-pair-queries","title":"3312. Sorted GCD Pair Queries","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Binary Search, Combinatorics, Counting, Number Theory, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/greatest_common_divisor/#1819-number-of-different-subsequences-gcds","title":"1819. Number of Different Subsequences GCDs","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Counting, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/greatest_common_divisor/#2436-minimum-split-into-subarrays-with-gcd-greater-than-one","title":"2436. Minimum Split Into Subarrays With GCD Greater Than One \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Greedy, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/greatest_common_divisor/#2464-minimum-subarrays-in-a-valid-split","title":"2464. Minimum Subarrays in a Valid Split \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/greatest_common_divisor/#2941-maximum-gcd-sum-of-a-subarray","title":"2941. Maximum GCD-Sum of a Subarray \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Binary Search, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_left_right/","title":"Greedy from Left Right","text":""},{"location":"EndlessCheng/greedy_from_left_right/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3402. Minimum Operations to Make Columns Strictly Increasing (Easy)</li> <li> 3191. Minimum Operations to Make Binary Array Elements Equal to One I (Medium)</li> <li> 1827. Minimum Operations to Make the Array Increasing (Easy)</li> <li> 2027. Minimum Moves to Convert String (Easy)</li> <li> 605. Can Place Flowers (Easy)</li> <li> 3111. Minimum Rectangles to Cover Points (Medium)</li> <li> 2957. Remove Adjacent Almost-Equal Characters (Medium)</li> <li> 3192. Minimum Operations to Make Binary Array Elements Equal to One II (Medium)</li> <li> 2789. Largest Element in an Array after Merge Operations (Medium)</li> <li> 1529. Minimum Suffix Flips (Medium)</li> <li> 1144. Decrease Elements To Make Array Zigzag (Medium)</li> <li> 3228. Maximum Number of Operations to Move Ones to the End (Medium)</li> <li> 2086. Minimum Number of Food Buckets to Feed the Hamsters (Medium)</li> <li> 2571. Minimum Operations to Reduce an Integer to 0 (Medium)</li> <li> 2712. Minimum Cost to Make All Characters Equal (Medium)</li> <li> 3326. Minimum Division Operations to Make Array Non Decreasing (Medium)</li> <li> 1536. Minimum Swaps to Arrange a Binary Grid (Medium)</li> <li> 2673. Make Costs of Paths Equal in a Binary Tree (Medium)</li> <li> 861. Score After Flipping Matrix (Medium)</li> <li> 955. Delete Columns to Make Sorted II (Medium)</li> <li> 2366. Minimum Replacements to Sort the Array (Hard)</li> <li> 2193. Minimum Number of Moves to Make Palindrome (Hard)</li> <li> 2528. Maximize the Minimum Powered City (Hard)</li> <li> 3449. Maximize the Minimum Game Score (Hard)</li> <li> 2422. Merge Operations to Turn Array Into a Palindrome (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/greedy_from_left_right/#3402-minimum-operations-to-make-columns-strictly-increasing","title":"3402. Minimum Operations to Make Columns Strictly Increasing","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_left_right/#3191-minimum-operations-to-make-binary-array-elements-equal-to-one-i","title":"3191. Minimum Operations to Make Binary Array Elements Equal to One I","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation, Queue, Sliding Window, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_left_right/#1827-minimum-operations-to-make-the-array-increasing","title":"1827. Minimum Operations to Make the Array Increasing","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_left_right/#2027-minimum-moves-to-convert-string","title":"2027. Minimum Moves to Convert String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_left_right/#605-can-place-flowers","title":"605. Can Place Flowers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_left_right/#3111-minimum-rectangles-to-cover-points","title":"3111. Minimum Rectangles to Cover Points","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_left_right/#2957-remove-adjacent-almost-equal-characters","title":"2957. Remove Adjacent Almost-Equal Characters","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_left_right/#3192-minimum-operations-to-make-binary-array-elements-equal-to-one-ii","title":"3192. Minimum Operations to Make Binary Array Elements Equal to One II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_left_right/#2789-largest-element-in-an-array-after-merge-operations","title":"2789. Largest Element in an Array after Merge Operations","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_left_right/#1529-minimum-suffix-flips","title":"1529. Minimum Suffix Flips","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_left_right/#1144-decrease-elements-to-make-array-zigzag","title":"1144. Decrease Elements To Make Array Zigzag","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_left_right/#3228-maximum-number-of-operations-to-move-ones-to-the-end","title":"3228. Maximum Number of Operations to Move Ones to the End","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Greedy, Counting</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_left_right/#2086-minimum-number-of-food-buckets-to-feed-the-hamsters","title":"2086. Minimum Number of Food Buckets to Feed the Hamsters","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_left_right/#2571-minimum-operations-to-reduce-an-integer-to-0","title":"2571. Minimum Operations to Reduce an Integer to 0","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Greedy, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_left_right/#2712-minimum-cost-to-make-all-characters-equal","title":"2712. Minimum Cost to Make All Characters Equal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Greedy</p> </li> </ul> Python <pre><code>def minimumCost(s: str) -&gt; int:\n    n = len(s)\n    res = 0\n    for i in range(1, n):\n        if s[i - 1] != s[i]:\n            res += min(i, n - i)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    s = \"0011\"\n    print(minimumCost(s))  # 2\n</code></pre>"},{"location":"EndlessCheng/greedy_from_left_right/#3326-minimum-division-operations-to-make-array-non-decreasing","title":"3326. Minimum Division Operations to Make Array Non Decreasing","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Greedy, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_left_right/#1536-minimum-swaps-to-arrange-a-binary-grid","title":"1536. Minimum Swaps to Arrange a Binary Grid","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_left_right/#2673-make-costs-of-paths-equal-in-a-binary-tree","title":"2673. Make Costs of Paths Equal in a Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy, Tree, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_left_right/#861-score-after-flipping-matrix","title":"861. Score After Flipping Matrix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Bit Manipulation, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_left_right/#955-delete-columns-to-make-sorted-ii","title":"955. Delete Columns to Make Sorted II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_left_right/#2366-minimum-replacements-to-sort-the-array","title":"2366. Minimum Replacements to Sort the Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_left_right/#2193-minimum-number-of-moves-to-make-palindrome","title":"2193. Minimum Number of Moves to Make Palindrome","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Greedy, Binary Indexed Tree</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_left_right/#2528-maximize-the-minimum-powered-city","title":"2528. Maximize the Minimum Powered City","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Greedy, Queue, Sliding Window, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_left_right/#3449-maximize-the-minimum-game-score","title":"3449. Maximize the Minimum Game Score","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_left_right/#2422-merge-operations-to-turn-array-into-a-palindrome","title":"2422. Merge Operations to Turn Array Into a Palindrome \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_smallest_largest/","title":"Greedy from Smallest Largest","text":""},{"location":"EndlessCheng/greedy_from_smallest_largest/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3074. Apple Redistribution into Boxes (Easy)</li> <li> 2279. Maximum Bags With Full Capacity of Rocks (Medium)</li> <li> 1833. Maximum Ice Cream Bars (Medium)</li> <li> 1005. Maximize Sum Of Array After K Negations (Easy)</li> <li> 1481. Least Number of Unique Integers after K Removals (Medium)</li> <li> 1403. Minimum Subsequence in Non-Increasing Order (Easy)</li> <li> 3010. Divide an Array Into Subarrays With Minimum Cost I (Easy)</li> <li> 1338. Reduce Array Size to The Half (Medium)</li> <li> 1710. Maximum Units on a Truck (Easy)</li> <li> 3075. Maximize Happiness of Selected Children (Medium)</li> <li> 2554. Maximum Number of Integers to Choose From a Range I (Medium)</li> <li> 2126. Destroying Asteroids (Medium)</li> <li> 2587. Rearrange Array to Maximize Prefix Score (Medium)</li> <li> 976. Largest Perimeter Triangle (Easy)</li> <li> 1561. Maximum Number of Coins You Can Get (Medium)</li> <li> 3301. Maximize the Total Height of Unique Towers (Medium)</li> <li> 945. Minimum Increment to Make Array Unique (Medium)</li> <li> 1846. Maximum Element After Decreasing and Rearranging (Medium)</li> <li> 1647. Minimum Deletions to Make Character Frequencies Unique (Medium)</li> <li> 2971. Find Polygon With the Largest Perimeter (Medium)</li> <li> 2178. Maximum Split of Positive Even Integers (Medium)</li> <li> 2567. Minimum Score by Changing Two Elements (Medium)</li> <li> 1509. Minimum Difference Between Largest and Smallest Value in Three Moves (Medium)</li> <li> 3397. Maximum Number of Distinct Elements After Operations (Medium)</li> <li> 3457. Eat Pizzas! (Medium)</li> <li> 1262. Greatest Sum Divisible by Three (Medium)</li> <li> 948. Bag of Tokens (Medium)</li> <li> 1775. Equal Sum Arrays With Minimum Number of Operations (Medium)</li> <li> 2333. Minimum Sum of Squared Difference (Medium)</li> <li> 3440. Reschedule Meetings for Maximum Free Time II (Medium)</li> <li> 2141. Maximum Running Time of N Computers (Hard)</li> <li> 1196. How Many Apples Can You Put into the Basket (Easy) \ud83d\udc51</li> <li> 2214. Minimum Health to Beat Game (Medium) \ud83d\udc51</li> <li> 2098. Subsequence of Size K With the Largest Even Sum (Medium) \ud83d\udc51</li> <li> 2548. Maximum Price to Fill a Bag (Medium) \ud83d\udc51</li> <li> 3119. Maximum Number of Potholes That Can Be Fixed (Medium) \ud83d\udc51</li> <li> 2557. Maximum Number of Integers to Choose From a Range II (Medium) \ud83d\udc51</li> <li> 624. Maximum Distance in Arrays (Medium)</li> <li> 910. Smallest Range II (Medium)</li> <li> 2835. Minimum Operations to Form Subsequence With Target Sum (Hard)</li> <li> 3366. Minimum Array Sum (Medium)</li> </ul>"},{"location":"EndlessCheng/greedy_from_smallest_largest/#3074-apple-redistribution-into-boxes","title":"3074. Apple Redistribution into Boxes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\n# Greedy\ndef minimumBoxes(apple: List[int], capacity: List[int]) -&gt; int:\n    target = sum(apple)\n    capacity.sort(reverse=True)\n    res = 0\n\n    for box in capacity:\n        res += 1\n        target -= box\n        if target &lt;= 0:\n            break\n\n    return res\n\n\napple = [1, 3, 2]\ncapacity = [4, 3, 1, 5, 2]\nassert minimumBoxes(apple, capacity) == 2\n</code></pre> <pre><code>#include &lt;vector&gt;\n#include &lt;numeric&gt;\n#include &lt;algorithm&gt;\n#include &lt;functional&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int minimumBoxes(vector&lt;int&gt; &amp;apple, vector&lt;int&gt; &amp;capacity)\n    {\n        int s = accumulate(apple.begin(), apple.end(), 0);\n        sort(capacity.begin(), capacity.end(), greater&lt;int&gt;());\n\n        int i = 0;\n        while (s &gt; 0)\n        {\n            s -= capacity[i++];\n        }\n        return i;\n    }\n};\n\nint main()\n{\n    Solution s;\n    vector&lt;int&gt; apple = {1, 3, 2};\n    vector&lt;int&gt; capacity = {4, 3, 1, 5, 2};\n    cout &lt;&lt; s.minimumBoxes(apple, capacity) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/greedy_from_smallest_largest/#2279-maximum-bags-with-full-capacity-of-rocks","title":"2279. Maximum Bags With Full Capacity of Rocks","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_smallest_largest/#1833-maximum-ice-cream-bars","title":"1833. Maximum Ice Cream Bars","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting, Counting Sort</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_smallest_largest/#1005-maximize-sum-of-array-after-k-negations","title":"1005. Maximize Sum Of Array After K Negations","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the maximum sum of the array after changing at most `k` elements.\n\"\"\"\n\nfrom heapq import heapify, heapreplace\nfrom typing import List\n\n\n# Greedy\ndef largestSumAfterKNegationsGreedy(nums: List[int], k: int) -&gt; int:\n    nums.sort(key=abs, reverse=True)\n\n    for i in range(len(nums)):\n        if nums[i] &lt; 0 and k &gt; 0:\n            nums[i] *= -1\n            k -= 1\n\n    if k % 2:\n        nums[-1] *= -1\n\n    return sum(nums)\n\n\n# Heap\ndef largestSumAfterKNegationsHeap(nums: List[int], k: int) -&gt; int:\n    heapify(nums)\n\n    while k and nums[0] &lt; 0:\n        heapreplace(nums, -nums[0])\n        k -= 1\n\n    if k % 2:\n        heapreplace(nums, -nums[0])\n\n    return sum(nums)\n\n\nprint(largestSumAfterKNegationsGreedy([4, 2, 3], 1))  # 5\nprint(largestSumAfterKNegationsHeap([4, 2, 3], 1))\n</code></pre>"},{"location":"EndlessCheng/greedy_from_smallest_largest/#1481-least-number-of-unique-integers-after-k-removals","title":"1481. Least Number of Unique Integers after K Removals","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Greedy, Sorting, Counting</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_smallest_largest/#1403-minimum-subsequence-in-non-increasing-order","title":"1403. Minimum Subsequence in Non-Increasing Order","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_smallest_largest/#3010-divide-an-array-into-subarrays-with-minimum-cost-i","title":"3010. Divide an Array Into Subarrays With Minimum Cost I","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sorting, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_smallest_largest/#1338-reduce-array-size-to-the-half","title":"1338. Reduce Array Size to The Half","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Greedy, Sorting, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_smallest_largest/#1710-maximum-units-on-a-truck","title":"1710. Maximum Units on a Truck","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_smallest_largest/#3075-maximize-happiness-of-selected-children","title":"3075. Maximize Happiness of Selected Children","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul> Python <pre><code>from typing import List\n\n\nclass maximumHappinessSum:\n    @staticmethod\n    def greedy(happiness: List[int], k: int) -&gt; int:\n        happiness.sort(reverse=True)\n        res = 0\n        i = 0\n\n        while i &lt; k:\n            if happiness[i] &lt;= i:\n                break\n            res += happiness[i] - i\n            i += 1\n\n        return res\n\n\nif __name__ == \"__main__\":\n    assert maximumHappinessSum.greedy([1, 2, 3], 2) == 4\n    assert maximumHappinessSum.greedy([5, 1, 3, 7], 3) == 12\n</code></pre>"},{"location":"EndlessCheng/greedy_from_smallest_largest/#2554-maximum-number-of-integers-to-choose-from-a-range-i","title":"2554. Maximum Number of Integers to Choose From a Range I","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Binary Search, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_smallest_largest/#2126-destroying-asteroids","title":"2126. Destroying Asteroids","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_smallest_largest/#2587-rearrange-array-to-maximize-prefix-score","title":"2587. Rearrange Array to Maximize Prefix Score","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_smallest_largest/#976-largest-perimeter-triangle","title":"976. Largest Perimeter Triangle","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_smallest_largest/#1561-maximum-number-of-coins-you-can-get","title":"1561. Maximum Number of Coins You Can Get","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Greedy, Sorting, Game Theory</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_smallest_largest/#3301-maximize-the-total-height-of-unique-towers","title":"3301. Maximize the Total Height of Unique Towers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_smallest_largest/#945-minimum-increment-to-make-array-unique","title":"945. Minimum Increment to Make Array Unique","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting, Counting</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Greedy\ndef minIncrementForUnique(nums: List[int]) -&gt; int:\n    nums.sort()\n    moves = 0\n\n    for i in range(1, len(nums)):\n        if nums[i] &lt;= nums[i - 1]:\n            moves += nums[i - 1] + 1 - nums[i]\n            nums[i] = nums[i - 1] + 1\n\n    return moves\n\n\nnums = [1, 2, 2]\nprint(minIncrementForUnique(nums))  # 1\n</code></pre>"},{"location":"EndlessCheng/greedy_from_smallest_largest/#1846-maximum-element-after-decreasing-and-rearranging","title":"1846. Maximum Element After Decreasing and Rearranging","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_smallest_largest/#1647-minimum-deletions-to-make-character-frequencies-unique","title":"1647. Minimum Deletions to Make Character Frequencies Unique","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_smallest_largest/#2971-find-polygon-with-the-largest-perimeter","title":"2971. Find Polygon With the Largest Perimeter","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_smallest_largest/#2178-maximum-split-of-positive-even-integers","title":"2178. Maximum Split of Positive Even Integers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Backtracking, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_smallest_largest/#2567-minimum-score-by-changing-two-elements","title":"2567. Minimum Score by Changing Two Elements","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_smallest_largest/#1509-minimum-difference-between-largest-and-smallest-value-in-three-moves","title":"1509. Minimum Difference Between Largest and Smallest Value in Three Moves","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_smallest_largest/#3397-maximum-number-of-distinct-elements-after-operations","title":"3397. Maximum Number of Distinct Elements After Operations","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_smallest_largest/#3457-eat-pizzas","title":"3457. Eat Pizzas!","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_smallest_largest/#1262-greatest-sum-divisible-by-three","title":"1262. Greatest Sum Divisible by Three","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_smallest_largest/#948-bag-of-tokens","title":"948. Bag of Tokens","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_smallest_largest/#1775-equal-sum-arrays-with-minimum-number-of-operations","title":"1775. Equal Sum Arrays With Minimum Number of Operations","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Greedy, Counting</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_smallest_largest/#2333-minimum-sum-of-squared-difference","title":"2333. Minimum Sum of Squared Difference","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Greedy, Sorting, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_smallest_largest/#3440-reschedule-meetings-for-maximum-free-time-ii","title":"3440. Reschedule Meetings for Maximum Free Time II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_smallest_largest/#2141-maximum-running-time-of-n-computers","title":"2141. Maximum Running Time of N Computers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_smallest_largest/#1196-how-many-apples-can-you-put-into-the-basket","title":"1196. How Many Apples Can You Put into the Basket \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_smallest_largest/#2214-minimum-health-to-beat-game","title":"2214. Minimum Health to Beat Game \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_smallest_largest/#2098-subsequence-of-size-k-with-the-largest-even-sum","title":"2098. Subsequence of Size K With the Largest Even Sum \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_smallest_largest/#2548-maximum-price-to-fill-a-bag","title":"2548. Maximum Price to Fill a Bag \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_smallest_largest/#3119-maximum-number-of-potholes-that-can-be-fixed","title":"3119. Maximum Number of Potholes That Can Be Fixed \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_smallest_largest/#2557-maximum-number-of-integers-to-choose-from-a-range-ii","title":"2557. Maximum Number of Integers to Choose From a Range II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_smallest_largest/#624-maximum-distance-in-arrays","title":"624. Maximum Distance in Arrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Array\ndef maxDistance(arrays: List[List[int]]) -&gt; int:\n    mn, mx = float(\"inf\"), float(\"-inf\")\n    res = 0\n\n    for arr in arrays:\n        res = max(res, arr[-1] - mn, mx - arr[0])\n        mn = min(mn, arr[0])\n        mx = max(mx, arr[-1])\n\n    return res\n\n\narrays = [[1, 2, 3], [4, 5], [1, 2, 3]]\nprint(maxDistance(arrays))  # 4\n</code></pre>"},{"location":"EndlessCheng/greedy_from_smallest_largest/#910-smallest-range-ii","title":"910. Smallest Range II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_smallest_largest/#2835-minimum-operations-to-form-subsequence-with-target-sum","title":"2835. Minimum Operations to Form Subsequence With Target Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/greedy_from_smallest_largest/#3366-minimum-array-sum","title":"3366. Minimum Array Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/greedy_others/","title":"Greedy Others","text":""},{"location":"EndlessCheng/greedy_others/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2740. Find the Value of the Partition (Medium)</li> <li> 1033. Moving Stones Until Consecutive (Medium)</li> <li> 1864. Minimum Number of Swaps to Make the Binary String Alternating (Medium)</li> <li> 1899. Merge Triplets to Form Target Triplet (Medium)</li> <li> 2498. Frog Jump II (Medium)</li> <li> 134. Gas Station (Medium)</li> <li> 2311. Longest Binary Subsequence Less Than or Equal to K (Medium)</li> <li> 3443. Maximum Manhattan Distance After K Changes (Medium)</li> <li> 3002. Maximum Size of a Set After Removals (Medium)</li> <li> 2412. Minimum Money Required Before Transactions (Hard)</li> <li> 659. Split Array into Consecutive Subsequences (Medium)</li> <li> 2732. Find a Good Subset of the Matrix (Hard)</li> <li> 2790. Maximum Number of Groups With Increasing Length (Hard)</li> <li> 782. Transform to Chessboard (Hard)</li> <li> 420. Strong Password Checker (Hard)</li> <li> 2753. Count Houses in a Circular Street II (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/greedy_others/#2740-find-the-value-of-the-partition","title":"2740. Find the Value of the Partition","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/greedy_others/#1033-moving-stones-until-consecutive","title":"1033. Moving Stones Until Consecutive","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Brainteaser</p> </li> </ul>"},{"location":"EndlessCheng/greedy_others/#1864-minimum-number-of-swaps-to-make-the-binary-string-alternating","title":"1864. Minimum Number of Swaps to Make the Binary String Alternating","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/greedy_others/#1899-merge-triplets-to-form-target-triplet","title":"1899. Merge Triplets to Form Target Triplet","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef mergeTriplets(triplets: List[List[int]], target: List[int]) -&gt; bool:\n    can_form = [False, False, False]\n\n    for triplet in triplets:\n        if all(triplet[i] &lt;= target[i] for i in range(3)):\n            for i in range(3):\n                if triplet[i] == target[i]:\n                    can_form[i] = True\n\n    return all(can_form)\n\n\ntriplets = [[2, 5, 3], [1, 8, 4], [1, 7, 5]]\ntarget = [2, 7, 5]\nprint(mergeTriplets(triplets, target))  # True\n</code></pre>"},{"location":"EndlessCheng/greedy_others/#2498-frog-jump-ii","title":"2498. Frog Jump II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/greedy_others/#134-gas-station","title":"134. Gas Station","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\nclass canCompleteCircuit:\n    def greedy(self, gas: List[int], cost: List[int]) -&gt; int:\n        \"\"\"\n        Approach: Greedy\n        Time Complexity: O(n)\n        Space Complexity: O(1)\n        \"\"\"\n\n        # edge case\n        if sum(gas) &lt; sum(cost):\n            return -1\n\n        cur_sum = 0\n        start = 0\n\n        for i in range(len(gas)):\n            cur_sum += gas[i] - cost[i]\n\n            if cur_sum &lt; 0:\n                start = i + 1\n                cur_sum = 0\n\n        return start\n\n\nif __name__ == \"__main__\":\n    solution = canCompleteCircuit()\n    gas = [1, 2, 3, 4, 5]\n    cost = [3, 4, 5, 1, 2]\n    assert solution.greedy(gas, cost) == 3\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) {\n        int totalTank = 0, currTank = 0;\n        int start = 0;\n        int n = gas.size();\n\n        for (int i = 0; i &lt; n; i++) {\n            int diff = gas[i] - cost[i];\n            totalTank += diff;\n            currTank += diff;\n\n            if (currTank &lt; 0) {\n                start = i + 1;\n                currTank = 0;\n            }\n        }\n\n        return (totalTank &gt;= 0) ? start : -1;\n    }\n};\n\nint main() {\n    Solution obj;\n    vector&lt;int&gt; gas{1, 2, 3, 4, 5};\n    vector&lt;int&gt; cost{3, 4, 5, 1, 2};\n    int res = obj.canCompleteCircuit(gas, cost);\n    assert(res == 3);\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/greedy_others/#2311-longest-binary-subsequence-less-than-or-equal-to-k","title":"2311. Longest Binary Subsequence Less Than or Equal to K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Greedy, Memoization</p> </li> </ul>"},{"location":"EndlessCheng/greedy_others/#3443-maximum-manhattan-distance-after-k-changes","title":"3443. Maximum Manhattan Distance After K Changes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Math, String, Counting</p> </li> </ul>"},{"location":"EndlessCheng/greedy_others/#3002-maximum-size-of-a-set-after-removals","title":"3002. Maximum Size of a Set After Removals","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/greedy_others/#2412-minimum-money-required-before-transactions","title":"2412. Minimum Money Required Before Transactions","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/greedy_others/#659-split-array-into-consecutive-subsequences","title":"659. Split Array into Consecutive Subsequences","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Greedy, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/greedy_others/#2732-find-a-good-subset-of-the-matrix","title":"2732. Find a Good Subset of the Matrix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Bit Manipulation, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/greedy_others/#2790-maximum-number-of-groups-with-increasing-length","title":"2790. Maximum Number of Groups With Increasing Length","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Binary Search, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/greedy_others/#782-transform-to-chessboard","title":"782. Transform to Chessboard","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Bit Manipulation, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/greedy_others/#420-strong-password-checker","title":"420. Strong Password Checker","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Greedy, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/greedy_others/#2753-count-houses-in-a-circular-street-ii","title":"2753. Count Houses in a Circular Street II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: None</p> </li> </ul>"},{"location":"EndlessCheng/grid_01_bfs/","title":"Grid 01 BFS","text":""},{"location":"EndlessCheng/grid_01_bfs/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1368. Minimum Cost to Make at Least One Valid Path in a Grid (Hard)</li> <li> 2290. Minimum Obstacle Removal to Reach Corner (Hard)</li> <li> 3286. Find a Safe Walk Through a Grid (Medium)</li> <li> 1824. Minimum Sideway Jumps (Medium)</li> </ul>"},{"location":"EndlessCheng/grid_01_bfs/#1368-minimum-cost-to-make-at-least-one-valid-path-in-a-grid","title":"1368. Minimum Cost to Make at Least One Valid Path in a Grid","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Breadth First Search, Graph, Heap Priority Queue, Matrix, Shortest Path</p> </li> </ul>"},{"location":"EndlessCheng/grid_01_bfs/#2290-minimum-obstacle-removal-to-reach-corner","title":"2290. Minimum Obstacle Removal to Reach Corner","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Breadth First Search, Graph, Heap Priority Queue, Matrix, Shortest Path</p> </li> </ul>"},{"location":"EndlessCheng/grid_01_bfs/#3286-find-a-safe-walk-through-a-grid","title":"3286. Find a Safe Walk Through a Grid","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Breadth First Search, Graph, Heap Priority Queue, Matrix, Shortest Path</p> </li> </ul>"},{"location":"EndlessCheng/grid_01_bfs/#1824-minimum-sideway-jumps","title":"1824. Minimum Sideway Jumps","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/grid_applications/","title":"Grid Applications","text":""},{"location":"EndlessCheng/grid_applications/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1631. Path With Minimum Effort (Medium)</li> <li> 778. Swim in Rising Water (Hard)</li> <li> 329. Longest Increasing Path in a Matrix (Hard)</li> <li> 1036. Escape a Large Maze (Hard)</li> <li> 864. Shortest Path to Get All Keys (Hard)</li> <li> 1263. Minimum Moves to Move a Box to Their Target Location (Hard)</li> <li> 2258. Escape the Spreading Fire (Hard)</li> <li> 2556. Disconnect Path in a Binary Matrix by at Most One Flip (Medium)</li> <li> 2577. Minimum Time to Visit a Cell In a Grid (Hard)</li> <li> 2617. Minimum Number of Visited Cells in a Grid (Hard)</li> <li> 694. Number of Distinct Islands (Medium) \ud83d\udc51</li> <li> 711. Number of Distinct Islands II (Hard) \ud83d\udc51</li> <li> 1102. Path With Maximum Minimum Value (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/grid_applications/#1631-path-with-minimum-effort","title":"1631. Path With Minimum Effort","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Depth First Search, Breadth First Search, Union Find, Heap Priority Queue, Matrix</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the minimum effort required to travel from the top-left to the bottom-right corner.\n\"\"\"\n\nimport heapq\nfrom typing import List\n\n\n# Prim\ndef minimumEffortPath(heights: List[List[int]]) -&gt; int:\n    m, n = len(heights), len(heights[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * n for _ in range(m)]\n    heap = [(0, 0, 0)]  # (effort, row, col)\n\n    while heap:\n        effort, r, c = heapq.heappop(heap)\n\n        if visited[r][c]:\n            continue\n\n        if r == m - 1 and c == n - 1:\n            return effort\n\n        visited[r][c] = True\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and not visited[nr][nc]:\n                updated = max(effort, abs(heights[r][c] - heights[nr][nc]))\n                heapq.heappush(heap, (updated, nr, nc))\n\n    return -1\n\n\nheights = [[1, 2, 2], [3, 8, 2], [5, 3, 5]]\nprint(minimumEffortPath(heights))  # 2\n</code></pre>"},{"location":"EndlessCheng/grid_applications/#778-swim-in-rising-water","title":"778. Swim in Rising Water","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Depth First Search, Breadth First Search, Union Find, Heap Priority Queue, Matrix</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the minimum time when you can reach the target.\n\n![778](https://assets.leetcode.com/uploads/2021/06/29/swim2-grid-1.jpg)\n\"\"\"\n\nimport heapq\nfrom typing import List\n\n\n# Dijkstra's\ndef swimInWater(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    visited = set()\n    minHeap = [(grid[0][0], 0, 0)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    visited.add((0, 0))\n\n    while minHeap:\n        time, r, c = heapq.heappop(minHeap)\n\n        if r == n - 1 and c == n - 1:\n            return time\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if nr in range(n) and nc in range(n) and (nr, nc) not in visited:\n                visited.add((nr, nc))\n                heapq.heappush(minHeap, (max(time, grid[nr][nc]), nr, nc))\n\n\ngrid = [\n    [0, 1, 2, 3, 4],\n    [24, 23, 22, 21, 5],\n    [12, 13, 14, 15, 16],\n    [11, 17, 18, 19, 20],\n    [10, 9, 8, 7, 6],\n]\nprint(swimInWater(grid))  # 16\n</code></pre>"},{"location":"EndlessCheng/grid_applications/#329-longest-increasing-path-in-a-matrix","title":"329. Longest Increasing Path in a Matrix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Depth First Search, Breadth First Search, Graph, Topological Sort, Memoization, Matrix</p> </li> </ul> Python <pre><code>from collections import deque\nfrom functools import cache\nfrom typing import List\n\n\n# BFS - Topological Sort\ndef longestIncreasingPathBFS(matrix: List[List[int]]) -&gt; int:\n    if not matrix:\n        return 0\n\n    m, n = len(matrix), len(matrix[0])\n    dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    # Calculate indegrees and initialize queue in one pass\n    indegree = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            for dr, dc in dirs:\n                nr, nc = i + dr, j + dc\n                if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and matrix[nr][nc] &gt; matrix[i][j]:\n                    indegree[nr][nc] += 1\n\n    # Start with cells that have no smaller neighbors\n    queue = deque((i, j) for i in range(m) for j in range(n) if indegree[i][j] == 0)\n\n    res = 0\n    while queue:\n        res += 1\n        for _ in range(len(queue)):\n            r, c = queue.popleft()\n            for dr, dc in dirs:\n                nr, nc = r + dr, c + dc\n                if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and matrix[nr][nc] &gt; matrix[r][c]:\n                    indegree[nr][nc] -= 1\n                    if indegree[nr][nc] == 0:\n                        queue.append((nr, nc))\n\n    return res\n\n\n# DP - 2D\ndef longestIncreasingPath(matrix: List[List[int]]) -&gt; int:\n    if not matrix:\n        return 0\n\n    m, n = len(matrix), len(matrix[0])\n    dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    @cache\n    def dfs(r, c):\n        path = 1\n        for dr, dc in dirs:\n            nr, nc = r + dr, c + dc\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and matrix[nr][nc] &gt; matrix[r][c]:\n                path = max(path, dfs(nr, nc) + 1)\n        return path\n\n    res = 0\n    for i in range(m):\n        for j in range(n):\n            res = max(res, dfs(i, j))\n\n    return res\n\n\nif __name__ == \"__main__\":\n    matrix = [[9, 9, 4], [6, 6, 8], [2, 1, 1]]\n    assert longestIncreasingPath(matrix) == 4\n    assert longestIncreasingPathBFS(matrix) == 4\n</code></pre>"},{"location":"EndlessCheng/grid_applications/#1036-escape-a-large-maze","title":"1036. Escape a Large Maze","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Depth First Search, Breadth First Search</p> </li> </ul>"},{"location":"EndlessCheng/grid_applications/#864-shortest-path-to-get-all-keys","title":"864. Shortest Path to Get All Keys","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation, Breadth First Search, Matrix</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef shortestPathAllKeys(grid: List[str]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    q = deque()\n    visited = set()\n    total = 0\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"@\":\n                q.append((r, c, 0, 0))\n                visited.add((r, c, 0))\n            if grid[r][c].islower():\n                total += 1\n\n    while q:\n        r, c, keys, steps = q.popleft()\n\n        if keys == (1 &lt;&lt; total) - 1:\n            return steps\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n:\n                cell = grid[nr][nc]\n\n                if cell == \"#\":\n                    continue\n\n                new_keys = keys\n                if cell.islower():\n                    new_keys |= 1 &lt;&lt; (ord(cell) - ord(\"a\"))\n\n                if cell.isupper() and not (keys &amp; (1 &lt;&lt; (ord(cell) - ord(\"A\")))):\n                    continue\n\n                if (nr, nc, new_keys) not in visited:\n                    visited.add((nr, nc, new_keys))\n                    q.append((nr, nc, new_keys, steps + 1))\n\n    return -1\n\n\ngrid = [\"@.a..\", \"###.#\", \"b.A.B\"]\nprint(shortestPathAllKeys(grid))  # 8\n</code></pre>"},{"location":"EndlessCheng/grid_applications/#1263-minimum-moves-to-move-a-box-to-their-target-location","title":"1263. Minimum Moves to Move a Box to Their Target Location","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Breadth First Search, Heap Priority Queue, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/grid_applications/#2258-escape-the-spreading-fire","title":"2258. Escape the Spreading Fire","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Breadth First Search, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/grid_applications/#2556-disconnect-path-in-a-binary-matrix-by-at-most-one-flip","title":"2556. Disconnect Path in a Binary Matrix by at Most One Flip","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Depth First Search, Breadth First Search, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/grid_applications/#2577-minimum-time-to-visit-a-cell-in-a-grid","title":"2577. Minimum Time to Visit a Cell In a Grid","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Breadth First Search, Graph, Heap Priority Queue, Matrix, Shortest Path</p> </li> </ul>"},{"location":"EndlessCheng/grid_applications/#2617-minimum-number-of-visited-cells-in-a-grid","title":"2617. Minimum Number of Visited Cells in a Grid","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Stack, Breadth First Search, Union Find, Heap Priority Queue, Matrix, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/grid_applications/#694-number-of-distinct-islands","title":"694. Number of Distinct Islands \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Depth First Search, Breadth First Search, Union Find, Hash Function</p> </li> </ul> Python <pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# BFS\ndef numDistinctIslandsBFS(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    shapes = set()\n    dirs = [[1, 0], [0, 1], [0, -1], [-1, 0]]\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        shape = set()\n        grid[r][c] = 0\n\n        while q:\n            row, col = q.popleft()\n            shape.add((row - r, col - c))\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and grid[nr][nc] == 1:\n                    q.append((nr, nc))\n                    grid[nr][nc] = 0\n\n        return tuple(shape)\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                shapes.add(bfs(i, j))\n\n    return len(shapes)\n\n\n# DFS\ndef numDistinctIslandsDFS(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n\n    def dfs(r, c, org, shape):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] != 1:\n            return\n\n        grid[r][c] = 0\n        shape.add((r - org[0], c - org[1]))\n\n        dfs(r - 1, c, org, shape)\n        dfs(r + 1, c, org, shape)\n        dfs(r, c - 1, org, shape)\n        dfs(r, c + 1, org, shape)\n\n    shapes = set()\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                org = [i, j]\n                shape = set()\n                dfs(i, j, org, shape)\n                shapes.add(tuple(shape))\n\n    return len(shapes)\n\n\ngrid = [[1, 1, 0, 1, 1], [1, 0, 0, 0, 0], [0, 0, 0, 0, 1], [1, 1, 0, 1, 1]]\nprint(numDistinctIslandsBFS(deepcopy(grid)))  # 3\nprint(numDistinctIslandsDFS(deepcopy(grid)))  # 3\n</code></pre>"},{"location":"EndlessCheng/grid_applications/#711-number-of-distinct-islands-ii","title":"711. Number of Distinct Islands II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Depth First Search, Breadth First Search, Union Find, Hash Function</p> </li> </ul>"},{"location":"EndlessCheng/grid_applications/#1102-path-with-maximum-minimum-value","title":"1102. Path With Maximum Minimum Value \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Depth First Search, Breadth First Search, Union Find, Heap Priority Queue, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/grid_bfs/","title":"Grid BFS","text":""},{"location":"EndlessCheng/grid_bfs/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1926. Nearest Exit from Entrance in Maze (Medium)</li> <li> 1091. Shortest Path in Binary Matrix (Medium)</li> <li> 1162. As Far from Land as Possible (Medium)</li> <li> 542. 01 Matrix (Medium)</li> <li> 994. Rotting Oranges (Medium)</li> <li> 1765. Map of Highest Peak (Medium)</li> <li> 934. Shortest Bridge (Medium)</li> <li> 2146. K Highest Ranked Items Within a Price Range (Medium)</li> <li> 1293. Shortest Path in a Grid with Obstacles Elimination (Hard)</li> <li> 909. Snakes and Ladders (Medium)</li> <li> 1210. Minimum Moves to Reach Target with Rotations (Hard)</li> <li> 675. Cut Off Trees for Golf Event (Hard)</li> <li> 749. Contain Virus (Hard)</li> <li> 1730. Shortest Path to Get Food (Medium) \ud83d\udc51</li> <li> 286. Walls and Gates (Medium) \ud83d\udc51</li> <li> 490. The Maze (Medium) \ud83d\udc51</li> <li> 505. The Maze II (Medium) \ud83d\udc51</li> <li> 499. The Maze III (Hard) \ud83d\udc51</li> <li> 317. Shortest Distance from All Buildings (Hard) \ud83d\udc51</li> <li> 2814. Minimum Time Takes to Reach Destination Without Drowning (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/grid_bfs/#1926-nearest-exit-from-entrance-in-maze","title":"1926. Nearest Exit from Entrance in Maze","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Breadth First Search, Matrix</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef nearestExit(maze: List[List[str]], entrance: List[int]) -&gt; int:\n    m, n = len(maze), len(maze[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque([(entrance[0], entrance[1], 0)])\n    maze[entrance[0]][entrance[1]] = \"+\"\n\n    while q:\n        r, c, steps = q.popleft()\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and maze[nr][nc] == \".\":\n                if nr in [0, m - 1] or nc in [0, n - 1]:\n                    return steps + 1\n                q.append((nr, nc, steps + 1))\n                maze[nr][nc] = \"+\"\n\n    return -1\n\n\nmaze = [[\"+\", \"+\", \".\", \"+\"], [\".\", \".\", \".\", \"+\"], [\"+\", \"+\", \"+\", \".\"]]\nentrance = [1, 2]\nprint(nearestExit(maze, entrance))  # 1\n</code></pre>"},{"location":"EndlessCheng/grid_bfs/#1091-shortest-path-in-binary-matrix","title":"1091. Shortest Path in Binary Matrix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Breadth First Search, Matrix</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    if grid[0][0] == 1 or grid[n - 1][n - 1] == 1:\n        return -1\n    if n == 1:\n        return 1\n\n    directions = [\n        (0, 1),\n        (1, 0),\n        (0, -1),\n        (-1, 0),\n        (1, 1),\n        (-1, -1),\n        (1, -1),\n        (-1, 1),\n    ]\n    q = deque([(0, 0, 1)])  # (row, column, distance)\n    grid[0][0] = 1\n\n    while q:\n        r, c, d = q.popleft()\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 &lt;= nr &lt; n and 0 &lt;= nc &lt; n and grid[nr][nc] == 0:\n                if nr == nc == n - 1:\n                    return d + 1\n                q.append((nr, nc, d + 1))\n                grid[nr][nc] = 1\n\n    return -1\n\n\ngrid = [[0, 0, 0], [1, 1, 0], [1, 1, 0]]\nprint(shortestPathBinaryMatrix(grid))  # 4\n</code></pre>"},{"location":"EndlessCheng/grid_bfs/#1162-as-far-from-land-as-possible","title":"1162. As Far from Land as Possible","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Breadth First Search, Matrix</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef maxDistance(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    res = -1\n    dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]]\n\n    q = deque([[i, j] for i in range(n) for j in range(n) if grid[i][j] == 1])\n\n    if len(q) == (n**2):\n        return res\n\n    while q:\n        size = len(q)\n        for _ in range(size):\n            r, c = q.popleft()\n            for dr, dc in dirs:\n                nr, nc = dr + r, dc + c\n                if 0 &lt;= nr &lt; n and 0 &lt;= nc &lt; n and grid[nr][nc] == 0:\n                    grid[nr][nc] = 1\n                    q.append([nr, nc])\n        res += 1\n\n    return res\n\n\ngrid = [[1, 0, 0], [0, 0, 0], [0, 0, 0]]\nprint(maxDistance(grid))  # 4\n</code></pre>"},{"location":"EndlessCheng/grid_bfs/#542-01-matrix","title":"542. 01 Matrix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Breadth First Search, Matrix</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef updateMatrix(mat: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(mat), len(mat[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    q = deque()\n\n    for i in range(m):\n        for j in range(n):\n            if mat[i][j] == 0:\n                dist[i][j] = 0\n                q.append((i, j))\n\n    while q:\n        r, c = q.popleft()\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and dist[nr][nc] &gt; dist[r][c] + 1:\n                dist[nr][nc] = dist[r][c] + 1\n                q.append((nr, nc))\n\n    return dist\n\n\nmat = [[0, 0, 0], [0, 1, 0], [1, 1, 1]]\nprint(updateMatrix(mat))\n# [[0, 0, 0], [0, 1, 0], [1, 2, 1]]\n</code></pre>"},{"location":"EndlessCheng/grid_bfs/#994-rotting-oranges","title":"994. Rotting Oranges","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Breadth First Search, Matrix</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the minimum number of minutes that must elapse until no cell has a fresh orange.\n-   Hint: Multi-source BFS to count the level.\n\n![994](https://assets.leetcode.com/uploads/2019/02/16/oranges.png)\n\"\"\"\n\nfrom collections import deque\nfrom typing import List\n\n\n# BFS\ndef orangesRotting(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    fresh = 0\n    q = deque()\n    dirs = [[1, 0], [0, 1], [0, -1], [-1, 0]]\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 2:\n                q.append([i, j])\n            elif grid[i][j] == 1:\n                fresh += 1\n    res = 0\n\n    while q and fresh &gt; 0:\n        size = len(q)\n        for _ in range(size):\n            r, c = q.popleft()\n            for dr, dc in dirs:\n                nr, nc = dr + r, dc + c\n                if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and grid[nr][nc] == 1:\n                    q.append([nr, nc])\n                    grid[nr][nc] = 2\n                    fresh -= 1\n        res += 1\n\n    return res if fresh == 0 else -1\n\n\ngrid = [[2, 1, 1], [1, 1, 0], [0, 1, 1]]\nassert orangesRotting(grid) == 4\n</code></pre>"},{"location":"EndlessCheng/grid_bfs/#1765-map-of-highest-peak","title":"1765. Map of Highest Peak","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Breadth First Search, Matrix</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\nclass Solution:\n    def highestPeak(self, isWater: List[List[int]]) -&gt; List[List[int]]:\n        m, n = len(isWater), len(isWater[0])\n        dirs = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n        q = deque()\n\n        for i in range(m):\n            for j in range(n):\n                if isWater[i][j] == 1:\n                    q.append((i, j))\n                    isWater[i][j] = 0  # water\n                else:\n                    isWater[i][j] = -1  # unvisited land\n\n        height = 1\n        while q:\n            size = len(q)\n            for _ in range(size):\n                r, c = q.popleft()\n\n                for dr, dc in dirs:\n                    nr, nc = dr + r, dc + c\n                    if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and isWater[nr][nc] == -1:\n                        isWater[nr][nc] = height  # visited land height\n                        q.append((nr, nc))\n            height += 1\n\n        return isWater\n</code></pre>"},{"location":"EndlessCheng/grid_bfs/#934-shortest-bridge","title":"934. Shortest Bridge","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Matrix</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS + DFS; Coloring\ndef shortestBridge(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(r, c, queue):\n        grid[r][c] = 2\n        queue.append((r, c))\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if nr in range(n) and nc in range(n) and grid[nr][nc] == 1:\n                dfs(nr, nc, queue)\n\n    q = deque()\n    found = False\n    for r in range(n):\n        if found:\n            break\n        for c in range(n):\n            if grid[r][c] == 1:\n                dfs(r, c, q)\n                found = True\n                break\n\n    steps = 0\n    while q:\n        m = len(q)\n        for _ in range(m):\n            r, c = q.popleft()\n            for dr, dc in directions:\n                nr, nc = r + dr, c + dc\n                if nr in range(n) and nc in range(n):\n                    if grid[nr][nc] == 1:\n                        return steps\n                    elif grid[nr][nc] == 0:\n                        grid[nr][nc] = 2\n                        q.append((nr, nc))\n        steps += 1\n\n    return -1\n\n\ngrid = [\n    [1, 1, 1, 1, 1],\n    [1, 0, 0, 0, 1],\n    [1, 0, 1, 0, 1],\n    [1, 0, 0, 0, 1],\n    [1, 1, 1, 1, 1],\n]\nprint(shortestBridge(grid))  # 1\n</code></pre>"},{"location":"EndlessCheng/grid_bfs/#2146-k-highest-ranked-items-within-a-price-range","title":"2146. K Highest Ranked Items Within a Price Range","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Breadth First Search, Sorting, Heap Priority Queue, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/grid_bfs/#1293-shortest-path-in-a-grid-with-obstacles-elimination","title":"1293. Shortest Path in a Grid with Obstacles Elimination","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Breadth First Search, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/grid_bfs/#909-snakes-and-ladders","title":"909. Snakes and Ladders","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Breadth First Search, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/grid_bfs/#1210-minimum-moves-to-reach-target-with-rotations","title":"1210. Minimum Moves to Reach Target with Rotations","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Breadth First Search, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/grid_bfs/#675-cut-off-trees-for-golf-event","title":"675. Cut Off Trees for Golf Event","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Breadth First Search, Heap Priority Queue, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/grid_bfs/#749-contain-virus","title":"749. Contain Virus","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Matrix, Simulation</p> </li> </ul>"},{"location":"EndlessCheng/grid_bfs/#1730-shortest-path-to-get-food","title":"1730. Shortest Path to Get Food \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Breadth First Search, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/grid_bfs/#286-walls-and-gates","title":"286. Walls and Gates \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Breadth First Search, Matrix</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# Multi-Source BFS\ndef wallsAndGates(rooms: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify rooms in-place instead.\n    \"\"\"\n    m, n = len(rooms), len(rooms[0])\n    visited = set()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def addRoom(r, c):\n        if 0 &lt;= r &lt; m and 0 &lt;= c &lt; n and (r, c) not in visited and rooms[r][c] != -1:\n            q.append((r, c))\n            visited.add((r, c))\n\n    q = deque()\n    for r in range(m):\n        for c in range(n):\n            if rooms[r][c] == 0:\n                q.append((r, c))\n                visited.add((r, c))\n\n    dist = 0\n\n    while q:\n        for _ in range(len(q)):\n            r, c = q.popleft()\n            rooms[r][c] = dist\n\n            for dr, dc in directions:\n                addRoom(r + dr, c + dc)\n        dist += 1\n\n\nif __name__ == \"__main__\":\n    rooms = [\n        [2147483647, -1, 0, 2147483647],\n        [2147483647, 2147483647, 2147483647, -1],\n        [2147483647, -1, 2147483647, -1],\n        [0, -1, 2147483647, 2147483647],\n    ]\n    wallsAndGates(rooms)\n    assert rooms == [\n        [3, -1, 0, 1],\n        [2, 2, 1, -1],\n        [1, -1, 2, -1],\n        [0, -1, 3, 4],\n    ]\n</code></pre>"},{"location":"EndlessCheng/grid_bfs/#490-the-maze","title":"490. The Maze \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Matrix</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef hasPathBFS(maze: List[List[int]], start: List[int], destination: List[int]) -&gt; bool:\n    m, n = len(maze), len(maze[0])\n    dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]]\n    q = deque([start])\n    maze[start[0]][start[1]] = -1\n\n    while q:\n        r, c = q.popleft()\n        if [r, c] == destination:\n            return True\n\n        for dr, dc in dirs:\n            nr, nc = r, c\n\n            while 0 &lt;= nr + dr &lt; m and 0 &lt;= nc + dc &lt; n and maze[nr + dr][nc + dc] != 1:\n                nr += dr\n                nc += dc\n\n            if maze[nr][nc] != -1:\n                q.append([nr, nc])\n                maze[nr][nc] = -1\n\n    return False\n\n\nmaze = [\n    [0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0],\n    [0, 0, 0, 1, 0],\n    [1, 1, 0, 1, 1],\n    [0, 0, 0, 0, 0],\n]\nstart = [0, 4]\ndestination = [4, 4]\nprint(hasPathBFS(maze, start, destination))  # True\n</code></pre>"},{"location":"EndlessCheng/grid_bfs/#505-the-maze-ii","title":"505. The Maze II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Graph, Heap Priority Queue, Matrix, Shortest Path</p> </li> </ul> Python <pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra\ndef shortestDistance(\n    maze: List[List[int]], start: List[int], destination: List[int]\n) -&gt; int:\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    m, n = len(maze), len(maze[0])\n\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    dist[start[0]][start[1]] = 0\n\n    heap = [(0, start[0], start[1])]\n\n    while heap:\n        d, r, c = heapq.heappop(heap)\n\n        if [r, c] == destination:\n            return d\n\n        for dr, dc in directions:\n            nr, nc, nd = r, c, d\n\n            while 0 &lt;= nr + dr &lt; m and 0 &lt;= nc + dc &lt; n and maze[nr + dr][nc + dc] == 0:\n                nr += dr\n                nc += dc\n                nd += 1\n\n            if nd &lt; dist[nr][nc]:\n                dist[nr][nc] = nd\n                heapq.heappush(heap, (nd, nr, nc))\n\n    return -1\n\n\nmaze = [\n    [0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0],\n    [0, 0, 0, 1, 0],\n    [1, 1, 0, 1, 1],\n    [0, 0, 0, 0, 0],\n]\nstart = [0, 4]\ndestination = [4, 4]\nprint(shortestDistance(maze, start, destination))  # 12\n</code></pre>"},{"location":"EndlessCheng/grid_bfs/#499-the-maze-iii","title":"499. The Maze III \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Depth First Search, Breadth First Search, Graph, Heap Priority Queue, Matrix, Shortest Path</p> </li> </ul> Python <pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra\ndef findShortestWay(maze: List[List[int]], ball: List[int], hole: List[int]) -&gt; str:\n    directions = [(-1, 0, \"u\"), (1, 0, \"d\"), (0, -1, \"l\"), (0, 1, \"r\")]\n    m, n = len(maze), len(maze[0])\n\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    dist[ball[0]][ball[1]] = 0\n\n    paths = [[\"\"] * n for _ in range(m)]\n    paths[ball[0]][ball[1]] = \"\"\n\n    heap = [(0, \"\", ball[0], ball[1])]\n\n    while heap:\n        d, path, x, y = heapq.heappop(heap)\n\n        if [x, y] == hole:\n            return path\n\n        for dx, dy, direction in directions:\n            nx, ny, nd = x, y, d\n\n            while 0 &lt;= nx + dx &lt; m and 0 &lt;= ny + dy &lt; n and maze[nx + dx][ny + dy] == 0:\n                nx += dx\n                ny += dy\n                nd += 1\n\n                if [nx, ny] == hole:\n                    break\n\n            new_path = path + direction\n            if nd &lt; dist[nx][ny] or (nd == dist[nx][ny] and new_path &lt; paths[nx][ny]):\n                dist[nx][ny] = nd\n                paths[nx][ny] = new_path\n                heapq.heappush(heap, (nd, new_path, nx, ny))\n\n    return \"impossible\"\n\n\nmaze = [\n    [0, 0, 0, 0, 0],\n    [1, 1, 0, 0, 1],\n    [0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 1],\n    [0, 1, 0, 0, 0],\n]\nball = [4, 3]\nhole = [0, 1]\nprint(findShortestWay(maze, ball, hole))  # \"lul\"\n</code></pre>"},{"location":"EndlessCheng/grid_bfs/#317-shortest-distance-from-all-buildings","title":"317. Shortest Distance from All Buildings \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Breadth First Search, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/grid_bfs/#2814-minimum-time-takes-to-reach-destination-without-drowning","title":"2814. Minimum Time Takes to Reach Destination Without Drowning \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Breadth First Search, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/grid_dfs/","title":"Grid DFS","text":""},{"location":"EndlessCheng/grid_dfs/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 200. Number of Islands (Medium)</li> <li> 695. Max Area of Island (Medium)</li> <li> 463. Island Perimeter (Easy)</li> <li> 2658. Maximum Number of Fish in a Grid (Medium)</li> <li> 1034. Coloring A Border (Medium)</li> <li> 1020. Number of Enclaves (Medium)</li> <li> 2684. Maximum Number of Moves in a Grid (Medium)</li> <li> 1254. Number of Closed Islands (Medium)</li> <li> 130. Surrounded Regions (Medium)</li> <li> 1905. Count Sub Islands (Medium)</li> <li> 1391. Check if There is a Valid Path in a Grid (Medium)</li> <li> 417. Pacific Atlantic Water Flow (Medium)</li> <li> 529. Minesweeper (Medium)</li> <li> 1559. Detect Cycles in 2D Grid (Medium)</li> <li> 827. Making A Large Island (Hard)</li> <li> 305. Number of Islands II (Hard) \ud83d\udc51</li> <li> 2061. Number of Spaces Cleaning Robot Cleaned (Medium) \ud83d\udc51</li> <li> 2852. Sum of Remoteness of All Cells (Medium) \ud83d\udc51</li> <li> 489. Robot Room Cleaner (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/grid_dfs/#200-number-of-islands","title":"200. Number of Islands","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Union Find, Matrix</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Count the number of islands in a 2D grid.\n-   Method 1: DFS\n-   Method 2: BFS (use a queue to traverse the grid)\n\n-   How to keep track of visited cells?\n\n    1. Mark the visited cell as `0` (or any other value) to avoid revisiting it.\n    2. Use a set to store the visited cells.\n\n-   Steps:\n    1. Init: variables\n    2. DFS/BFS: starting from the cell with `1`, turn all the connected `1`s to `0`.\n    3. Traverse the grid, and if the cell is `1`, increment the count and call DFS/BFS.\n\n![0200](../../assets/0200.jpg)\n\"\"\"\n\nfrom collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef numIslandsDFS(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    res = 0\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] != \"1\":\n            return\n\n        grid[r][c] = \"2\"\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                dfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Set\ndef numIslandsBFS1(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == \"0\"\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\" and (r, c) not in visited:\n                visited.add((r, c))\n                bfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = dr + row, dc + col\n                if nr &lt; 0 or nr &gt;= m or nc &lt; 0 or nc &gt;= n or grid[nr][nc] != \"1\":\n                    continue\n                grid[nr][nc] = \"2\"\n                q.append((nr, nc))\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == \"1\":\n                grid[i][j] = \"2\"\n                bfs(i, j)\n                res += 1\n\n    return res\n\n\ngrid = [\n    [\"1\", \"1\", \"1\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"0\", \"0\", \"0\", \"0\", \"0\"],\n]\n\nprint(numIslandsDFS(deepcopy(grid)))  # 1\nprint(numIslandsBFS1(deepcopy(grid)))  # 1\nprint(numIslandsBFS2(deepcopy(grid)))  # 1\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    // dfs\n    int num_islands_dfs(vector&lt;vector&lt;char&gt;&gt; &amp;grid) {\n        int m = grid.size(), n = grid[0].size();\n        int res = 0;\n\n        // c++23 lambda recursion\n        auto dfs = [&amp;](this auto &amp;&amp;dfs, int r, int c) -&gt; void {\n            if (r &lt; 0 || r &gt;= m || c &lt; 0 || c &gt;= n || grid[r][c] != '1') {\n                return;\n            }\n            grid[r][c] = '0';\n            dfs(r + 1, c);\n            dfs(r - 1, c);\n            dfs(r, c + 1);\n            dfs(r, c - 1);\n        };\n\n        for (int i = 0; i &lt; m; i++) {\n            for (int j = 0; j &lt; n; j++) {\n                if (grid[i][j] == '1') {\n                    res++;\n                    dfs(i, j);\n                }\n            }\n        }\n        return res;\n    }\n\n    // bfs\n    int num_islands_bfs(vector&lt;vector&lt;char&gt;&gt; &amp;grid) {\n        int m = grid.size(), n = grid[0].size();\n        int res = 0;\n        vector&lt;pair&lt;int, int&gt;&gt; dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\n        auto bfs = [&amp;](int r, int c) {\n            queue&lt;pair&lt;int, int&gt;&gt; q;\n            q.push({r, c});\n            grid[r][c] = '0';\n            while (!q.empty()) {\n                auto [cr, cc] = q.front();\n                q.pop();\n                for (auto &amp;[dr, dc] : dirs) {\n                    int nr = cr + dr, nc = cc + dc;\n                    if (nr &gt;= 0 &amp;&amp; nr &lt; m &amp;&amp; nc &gt;= 0 &amp;&amp; nc &lt; n &amp;&amp;\n                        grid[nr][nc] == '1') {\n                        grid[nr][nc] = '0';\n                        q.push({nr, nc});\n                    }\n                }\n            }\n        };\n\n        for (int i = 0; i &lt; m; i++) {\n            for (int j = 0; j &lt; n; j++) {\n                if (grid[i][j] == '1') {\n                    res++;\n                    bfs(i, j);\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;vector&lt;char&gt;&gt; grid = {{'1', '1', '0', '0', '0'},\n                                 {'1', '1', '0', '0', '0'},\n                                 {'0', '0', '1', '0', '0'},\n                                 {'0', '0', '0', '1', '1'}};\n    assert(solution.num_islands_dfs(grid) == 3);\n    grid = {{'1', '1', '0', '0', '0'},\n            {'1', '1', '0', '0', '0'},\n            {'0', '0', '1', '0', '0'},\n            {'0', '0', '0', '1', '1'}};\n    assert(solution.num_islands_bfs(grid) == 3);\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/grid_dfs/#695-max-area-of-island","title":"695. Max Area of Island","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Union Find, Matrix</p> </li> </ul> PythonCPP <pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef maxAreaOfIslandDFS(grid: List[List[int]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] == 0:\n            return 0\n\n        grid[r][c] = 0\n\n        return 1 + dfs(r + 1, c) + dfs(r - 1, c) + dfs(r, c + 1) + dfs(r, c - 1)\n\n    res = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                res = max(res, dfs(i, j))\n    return res\n\n\n# BFS\ndef maxAreaOfIslandBFS1(grid: List[List[int]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        area = 0\n\n        while q:\n            row, col = q.popleft()\n            area += 1\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == 0\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n        return area\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1 and (r, c) not in visited:\n                visited.add((r, c))\n                res = max(res, bfs(r, c))\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        area = 0\n\n        while q:\n            row, col = q.popleft()\n            area += 1\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n\n                if nr &lt; 0 or nr &gt;= m or nc &lt; 0 or nc &gt;= n or grid[nr][nc] == 0:\n                    continue\n\n                q.append((nr, nc))\n                grid[nr][nc] = 0\n\n        return area\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                grid[r][c] = 0\n                res = max(res, bfs(r, c))\n\n    return res\n\n\ngrid = [\n    [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0],\n    [0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],\n]\nprint(maxAreaOfIslandDFS(grid))  # 6\nprint(maxAreaOfIslandBFS1(grid))  # 6\nprint(numIslandsBFS2(grid))  # 6\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int max_area_of_island(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {\n        int m = grid.size(), n = grid[0].size();\n        int res = 0;\n\n        auto dfs = [&amp;](this auto&amp;&amp; dfs, int r, int c) -&gt; int {\n            if (r &lt; 0 || r &gt;= m || c &lt; 0 || c &gt;= n || grid[r][c] != 1) {\n                return 0;\n            }\n            grid[r][c] = 0;\n\n            return 1 + dfs(r + 1, c) + dfs(r - 1, c) + dfs(r, c + 1) +\n                   dfs(r, c - 1);\n        };\n\n        for (int i = 0; i &lt; m; i++) {\n            for (int j = 0; j &lt; n; j++) {\n                if (grid[i][j] == 1) {\n                    int area = dfs(i, j);\n                    res = max(res, area);\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;vector&lt;int&gt;&gt; grid = {{0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},\n                                {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},\n                                {0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},\n                                {0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0},\n                                {0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0},\n                                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0},\n                                {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},\n                                {0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0}};\n    assert(solution.max_area_of_island(grid) == 6);\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/grid_dfs/#463-island-perimeter","title":"463. Island Perimeter","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Matrix</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DFS\ndef islandPerimeterDFS(grid: List[List[int]]) -&gt; int:\n    # TC: O(m * n)\n    # SC: O(m * n)\n\n    visited = set()\n    m, n = len(grid), len(grid[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def dfs(r, c):\n        if (r, c) in visited or grid[r][c] == 0:\n            return 0\n        visited.add((r, c))\n        perimeter = 0\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if nr not in range(m) or nc not in range(n) or grid[nr][nc] == 0:\n                perimeter += 1\n            else:\n                perimeter += dfs(nr, nc)\n\n        return perimeter\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                return dfs(r, c)\n    return 0\n\n\ndef islandPerimeter(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    perimeter = 0\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                perimeter += 4\n\n                if r &gt; 0 and grid[r - 1][c] == 1:\n                    perimeter -= 2\n\n                if c &gt; 0 and grid[r][c - 1] == 1:\n                    perimeter -= 2\n\n    return perimeter\n\n\ngrid = [[0, 1, 0, 0], [1, 1, 1, 0], [0, 1, 0, 0], [1, 1, 0, 0]]\nprint(islandPerimeterDFS(grid))  # 16\nprint(islandPerimeter(grid))  # 16\n</code></pre>"},{"location":"EndlessCheng/grid_dfs/#2658-maximum-number-of-fish-in-a-grid","title":"2658. Maximum Number of Fish in a Grid","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Union Find, Matrix</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Grid DFS\ndef findMaxFish(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    res = 0\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] == 0:\n            return 0\n        val = grid[r][c]\n        grid[r][c] = 0\n\n        return val + dfs(r - 1, c) + dfs(r + 1, c) + dfs(r, c - 1) + dfs(r, c + 1)\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                res = max(res, dfs(i, j))\n\n    return res\n\n\ngrid = [[0, 2, 1, 0], [4, 0, 0, 3], [1, 0, 0, 4], [0, 3, 2, 0]]\nprint(findMaxFish(grid))  # 7\n</code></pre>"},{"location":"EndlessCheng/grid_dfs/#1034-coloring-a-border","title":"1034. Coloring A Border","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Matrix</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Grid DFS\ndef colorBorder(grid: List[List[int]], row: int, col: int, color: int) -&gt; List[List[int]]:\n\n    dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]]\n    m, n = len(grid), len(grid[0])\n    org = grid[row][col]\n    visited = set()\n    borders = set()\n\n    def dfs(r, c):\n        if (r, c) in visited:\n            return\n\n        visited.add((r, c))\n\n        is_border = False\n        for dr, dc in dirs:\n            nr, nc = dr + r, dc + c\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n:\n                if grid[nr][nc] == org:\n                    dfs(nr, nc)\n                elif (nr, nc) not in visited:\n                    is_border = True\n            else:\n                is_border = True\n\n        if is_border:\n            borders.add((r, c))\n\n    dfs(row, col)\n\n    for r, c in borders:\n        grid[r][c] = color\n\n    return grid\n\n\ngrid = [[1, 2, 2], [2, 3, 2]]\nrow = 0\ncol = 1\ncolor = 3\nprint(colorBorder(grid, row, col, color))  # [[1, 3, 3], [2, 3, 3]]\n</code></pre>"},{"location":"EndlessCheng/grid_dfs/#1020-number-of-enclaves","title":"1020. Number of Enclaves","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Union Find, Matrix</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DFS\ndef numEnclaves(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    visited = set()\n\n    def dfs(r, c):\n        if r not in range(m) or c not in range(n) or grid[r][c] == 0 or (r, c) in visited:\n            return\n\n        grid[r][c] = 0\n        visited.add((r, c))\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if (\n                (r in [0, m - 1] or c in [0, n - 1])\n                and grid[r][c] == 1\n                and (r, c) not in visited\n            ):\n                dfs(r, c)\n\n    count = 0\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1 and (r, c) not in visited:\n                count += 1\n\n    return count\n\n\ngrid = [[0, 0, 0, 0], [1, 0, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0]]\nprint(numEnclaves(grid))  # 3\n</code></pre>"},{"location":"EndlessCheng/grid_dfs/#2684-maximum-number-of-moves-in-a-grid","title":"2684. Maximum Number of Moves in a Grid","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Matrix</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DFS\ndef maxMovesDFS(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    res = 0\n\n    def dfs(r, c):\n        nonlocal res\n        res = max(res, c)\n        if res == n - 1:\n            return\n\n        for k in r - 1, r, r + 1:\n            if 0 &lt;= k &lt; m and grid[k][c + 1] &gt; grid[r][c]:\n                dfs(k, c + 1)\n        grid[r][c] = 0\n\n    for i in range(m):\n        dfs(i, 0)\n\n    return res\n\n\ngrid = [[2, 4, 3, 5], [5, 4, 9, 3], [3, 4, 2, 11], [10, 9, 13, 15]]\nprint(maxMovesDFS(grid))  # 3\n</code></pre>"},{"location":"EndlessCheng/grid_dfs/#1254-number-of-closed-islands","title":"1254. Number of Closed Islands","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Union Find, Matrix</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DFS\ndef closedIsland(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    visited = set()\n\n    def dfs(r, c):\n        if r not in range(m) or c not in range(n) or grid[r][c] == 1 or (r, c) in visited:\n            return\n\n        grid[r][c] = 1\n        visited.add((r, c))\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if (\n                (r in [0, m - 1] or c in [0, n - 1])\n                and grid[r][c] == 0\n                and (r, c) not in visited\n            ):\n                dfs(r, c)\n\n    island = 0\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 0 and (r, c) not in visited:\n                island += 1\n                dfs(r, c)\n\n    return island\n\n\ngrid = [\n    [1, 1, 1, 1, 1, 1, 1, 0],\n    [1, 0, 0, 0, 0, 1, 1, 0],\n    [1, 0, 1, 0, 1, 1, 1, 0],\n    [1, 0, 0, 0, 0, 1, 0, 1],\n    [1, 1, 1, 1, 1, 1, 1, 0],\n]\nprint(closedIsland(grid))  # 2\n</code></pre>"},{"location":"EndlessCheng/grid_dfs/#130-surrounded-regions","title":"130. Surrounded Regions","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Union Find, Matrix</p> </li> </ul> Python <pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef solveDFS(board: List[List[str]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n    if not board and not board[0]:\n        return None\n\n    m, n = len(board), len(board[0])\n\n    def capture(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or board[r][c] != \"O\":\n            return None\n\n        board[r][c] = \"T\"\n        capture(r + 1, c)\n        capture(r - 1, c)\n        capture(r, c + 1)\n        capture(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\" and (r in [0, m - 1] or c in [0, n - 1]):\n                capture(r, c)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\":\n                board[r][c] = \"X\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"T\":\n                board[r][c] = \"O\"\n\n\n# BFS\ndef solveBFS(board: List[List[str]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n    if not board and not board[0]:\n        return None\n\n    m, n = len(board), len(board[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def capture(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr = row + dr\n                nc = col + dc\n                if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and board[nr][nc] == \"O\":\n                    board[nr][nc] = \"T\"\n                    q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\" and (r in [0, m - 1] or c in [0, n - 1]):\n                board[r][c] = \"T\"\n                capture(r, c)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\":\n                board[r][c] = \"X\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"T\":\n                board[r][c] = \"O\"\n\n\nif __name__ == \"__main__\":\n    board = [\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"O\", \"O\", \"X\"],\n        [\"X\", \"X\", \"O\", \"X\"],\n        [\"X\", \"O\", \"X\", \"X\"],\n    ]\n\n    b = deepcopy(board)\n    solveDFS(b)\n    assert b == [\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"O\", \"X\", \"X\"],\n    ]\n\n    b = deepcopy(board)\n    solveBFS(b)\n    assert b == [\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"O\", \"X\", \"X\"],\n    ]\n</code></pre>"},{"location":"EndlessCheng/grid_dfs/#1905-count-sub-islands","title":"1905. Count Sub Islands","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Union Find, Matrix</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DFS\ndef countSubIslandsDFS(grid1: List[List[int]], grid2: List[List[int]]) -&gt; int:\n    m, n = len(grid2), len(grid2[0])\n    dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n\n    def dfs(r, c, valid):\n        grid2[r][c] = 0\n        if grid1[r][c] == 0:\n            valid = False\n        for dr, dc in dirs:\n            nr, nc = dr + r, dc + c\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and grid2[nr][nc] == 1:\n                valid = dfs(nr, nc, valid)\n        return valid\n\n    res = 0\n\n    for i in range(m):\n        for j in range(n):\n            if grid2[i][j] == 1:\n                if dfs(i, j, True):\n                    res += 1\n\n    return res\n\n\ngrid1 = [\n    [1, 1, 1, 0, 0],\n    [0, 1, 1, 1, 1],\n    [0, 0, 0, 0, 0],\n    [1, 0, 0, 0, 0],\n    [1, 1, 0, 1, 1],\n]\ngrid2 = [\n    [1, 1, 1, 0, 0],\n    [0, 0, 1, 1, 1],\n    [0, 1, 0, 0, 0],\n    [1, 0, 1, 1, 0],\n    [0, 1, 0, 1, 0],\n]\nprint(countSubIslandsDFS(grid1, grid2))  # 3\n</code></pre>"},{"location":"EndlessCheng/grid_dfs/#1391-check-if-there-is-a-valid-path-in-a-grid","title":"1391. Check if There is a Valid Path in a Grid","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Union Find, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/grid_dfs/#417-pacific-atlantic-water-flow","title":"417. Pacific Atlantic Water Flow","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Matrix</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef pacificAtlanticDFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(r, c, visited, prev_height):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or heights[r][c] &lt; prev_height\n            or (r, c) in visited\n        ):\n            return None\n\n        visited.add((r, c))\n        height = heights[r][c]\n        for dr, dc in directions:\n            dfs(dr + r, dc + c, visited, height)\n\n    for c in range(n):\n        dfs(0, c, pac, heights[0][c])\n        dfs(m - 1, c, atl, heights[m - 1][c])\n\n    for r in range(m):\n        dfs(r, 0, pac, heights[r][0])\n        dfs(r, n - 1, atl, heights[r][n - 1])\n\n    return list(pac &amp; atl)\n\n\n# BFS\ndef pacificAtlanticBFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def bfs(r, c, visited):\n        q = deque([(r, c)])\n        visited.add((r, c))\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr in range(m)\n                    and nc in range(n)\n                    and heights[row][col] &lt;= heights[nr][nc]\n                    and (nr, nc) not in visited\n                ):\n                    q.append((nr, nc))\n                    visited.add((nr, nc))\n\n    for c in range(n):\n        bfs(0, c, pac)  # top\n        bfs(m - 1, c, atl)  # bottom\n\n    for r in range(m):\n        bfs(r, 0, pac)  # left\n        bfs(r, n - 1, atl)  # right\n\n    return list(pac &amp; atl)\n\n\nheights = [\n    [1, 2, 2, 3, 5],\n    [3, 2, 3, 4, 4],\n    [2, 4, 5, 3, 1],\n    [6, 7, 1, 4, 5],\n    [5, 1, 1, 2, 4],\n]\nprint(pacificAtlanticDFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\nprint(pacificAtlanticBFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\n</code></pre>"},{"location":"EndlessCheng/grid_dfs/#529-minesweeper","title":"529. Minesweeper","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/grid_dfs/#1559-detect-cycles-in-2d-grid","title":"1559. Detect Cycles in 2D Grid","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Union Find, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/grid_dfs/#827-making-a-large-island","title":"827. Making A Large Island","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Union Find, Matrix</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Flood Fill\ndef largestIsland(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    areas = defaultdict(int)  # {index: area}\n    index = 2\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(r, c, index):\n        area = 1\n        grid[r][c] = index\n        for dr, dc in dirs:\n            nr, nc = r + dr, c + dc\n            if 0 &lt;= nr &lt; n and 0 &lt;= nc &lt; n and grid[nr][nc] == 1:\n                area += dfs(nr, nc, index)\n        return area\n\n    for r in range(n):\n        for c in range(n):\n            if grid[r][c] == 1:\n                areas[index] = dfs(r, c, index)\n                index += 1\n\n    if not areas:\n        return 1\n\n    res = max(areas.values())\n\n    for r in range(n):\n        for c in range(n):\n            if grid[r][c] == 0:\n                connected = set()\n                area = 1\n                for dr, dc in dirs:\n                    nr, nc = r + dr, c + dc\n                    if 0 &lt;= nr &lt; n and 0 &lt;= nc &lt; n and grid[nr][nc] &gt; 1:\n                        connected.add(grid[nr][nc])\n\n                for island in connected:\n                    area += areas[island]\n                res = max(res, area)\n\n    return res\n\n\ngrid = [[1, 0], [0, 1]]\nprint(largestIsland(grid))  # 3\n</code></pre>"},{"location":"EndlessCheng/grid_dfs/#305-number-of-islands-ii","title":"305. Number of Islands II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Union Find</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef numIslands2(m: int, n: int, positions: List[List[int]]) -&gt; List[int]:\n    parent = defaultdict(tuple)\n    islands = 0\n    result = []\n    visited = set()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def find(node):\n        p = parent[node]\n        while parent[p] != p:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            parent[p1] = p2\n            return True\n        return False\n\n    for r, c in positions:\n        if (r, c) in visited:\n            result.append(islands)\n            continue\n\n        islands += 1\n        parent[(r, c)] = (r, c)\n        visited.add((r, c))\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if (nr, nc) in visited:\n                if union((r, c), (nr, nc)):\n                    islands -= 1\n\n        result.append(islands)\n\n    return result\n\n\nm = 3\nn = 3\npositions = [[0, 0], [0, 1], [1, 2], [2, 1]]\nprint(numIslands2(m, n, positions))  # [1, 1, 2, 3]\n</code></pre>"},{"location":"EndlessCheng/grid_dfs/#2061-number-of-spaces-cleaning-robot-cleaned","title":"2061. Number of Spaces Cleaning Robot Cleaned \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Matrix, Simulation</p> </li> </ul>"},{"location":"EndlessCheng/grid_dfs/#2852-sum-of-remoteness-of-all-cells","title":"2852. Sum of Remoteness of All Cells \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Depth First Search, Breadth First Search, Union Find, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/grid_dfs/#489-robot-room-cleaner","title":"489. Robot Room Cleaner \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Backtracking, Interactive</p> </li> </ul>"},{"location":"EndlessCheng/heap_advanced/","title":"Heap Advanced","text":""},{"location":"EndlessCheng/heap_advanced/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 23. Merge k Sorted Lists (Hard)</li> <li> 355. Design Twitter (Medium)</li> <li> 502. IPO (Hard)</li> <li> 1705. Maximum Number of Eaten Apples (Medium)</li> <li> 778. Swim in Rising Water (Hard)</li> <li> 1631. Path With Minimum Effort (Medium)</li> <li> 1354. Construct Target Array With Multiple Sums (Hard)</li> <li> 1353. Maximum Number of Events That Can Be Attended (Medium)</li> <li> 1235. Maximum Profit in Job Scheduling (Hard)</li> <li> 632. Smallest Range Covering Elements from K Lists (Hard)</li> <li> 2542. Maximum Subsequence Score (Medium)</li> <li> 1383. Maximum Performance of a Team (Hard)</li> <li> 2503. Maximum Number of Points From Grid Queries (Hard)</li> <li> 2163. Minimum Difference in Sums After Removal of Elements (Hard)</li> <li> 857. Minimum Cost to Hire K Workers (Hard)</li> <li> 1606. Find Servers That Handled Most Number of Requests (Hard)</li> <li> 1851. Minimum Interval to Include Each Query (Hard)</li> <li> 218. The Skyline Problem (Hard)</li> <li> 407. Trapping Rain Water II (Hard)</li> <li> 2940. Find Building Where Alice and Bob Can Meet (Hard)</li> <li> 3399. Smallest Substring With Identical Characters II (Hard)</li> <li> 2589. Minimum Time to Complete All Tasks (Hard)</li> <li> 3266. Final Array State After K Multiplication Operations II (Hard)</li> <li> 1675. Minimize Deviation in Array (Hard)</li> <li> 2617. Minimum Number of Visited Cells in a Grid (Hard)</li> <li> 2532. Time to Cross a Bridge (Hard)</li> <li> 1199. Minimum Time to Build Blocks (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/heap_advanced/#23-merge-k-sorted-lists","title":"23. Merge k Sorted Lists","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Divide And Conquer, Heap Priority Queue, Merge Sort</p> </li> </ul> Python <pre><code>\"\"\"\n-   Prerequisite: 21. Merge Two Sorted Lists\n-   Video explanation: [23. Merge K Sorted Lists - NeetCode](https://youtu.be/q5a5OiGbT6Q?si=SQ2dCvsYQ3LQctPh)\n\"\"\"\n\nimport copy\nimport heapq\nfrom typing import List, Optional\n\nfrom leetpattern.utils import ListNode, list_from_array, list_to_array\n\n\ndef merge_k_lists_divide_conquer(\n    lists: List[Optional[ListNode]],\n) -&gt; Optional[ListNode]:\n    if not lists or len(lists) == 0:\n        return None\n\n    def mergeTwo(l1, l2):\n        dummy = ListNode()\n        cur = dummy\n\n        while l1 and l2:\n            if l1.val &lt; l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n\n            cur = cur.next\n\n        cur.next = l1 if l1 else l2\n\n        return dummy.next\n\n    while len(lists) &gt; 1:\n        merged = []\n\n        for i in range(0, len(lists), 2):\n            l1 = lists[i]\n            l2 = lists[i + 1] if i + 1 &lt; len(lists) else None\n            merged.append(mergeTwo(l1, l2))\n\n        lists = merged\n\n    return lists[0]\n\n\ndef merge_k_lists_heap(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    min_heap = []  # (val, idx, node)\n\n    for idx, head in enumerate(lists):\n        if head:\n            heapq.heappush(min_heap, (head.val, idx, head))\n\n    while min_heap:\n        _, idx, node = heapq.heappop(min_heap)\n        cur.next = node\n        cur = cur.next\n\n        node = node.next\n        if node:\n            heapq.heappush(min_heap, (node.val, idx, node))\n\n    return dummy.next\n\n\ndef test_merge_k_lists() -&gt; None:\n    n1 = list_from_array([1, 4])\n    n2 = list_from_array([1, 3])\n    n3 = list_from_array([2, 6])\n    lists = [n1, n2, n3]\n    lists1 = copy.deepcopy(lists)\n    lists2 = copy.deepcopy(lists)\n    assert (list_to_array(merge_k_lists_divide_conquer(lists1))) == [\n        1,\n        1,\n        2,\n        3,\n        4,\n        6,\n    ]\n    assert (list_to_array(merge_k_lists_heap(lists2))) == [1, 1, 2, 3, 4, 6]\n</code></pre>"},{"location":"EndlessCheng/heap_advanced/#355-design-twitter","title":"355. Design Twitter","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Linked List, Design, Heap Priority Queue</p> </li> </ul> Python <pre><code>\"\"\"\n-   Similar question: [23. Merge K Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/) (Hard)\n\"\"\"\n\nimport heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Design\nclass Twitter:\n\n    def __init__(self):\n        self.tweets = defaultdict(list)\n        self.followees = defaultdict(set)\n        self.time = 0\n\n    def postTweet(self, userId: int, tweetId: int) -&gt; None:\n        self.tweets[userId].append((self.time, tweetId))\n        self.time += 1\n\n    def getNewsFeed(self, userId: int) -&gt; List[int]:\n        news_feed = []\n        news_feed.extend(self.tweets[userId])\n        for followee in self.followees[userId]:\n            news_feed.extend(self.tweets[followee])\n\n        return [tweet for _, tweet in heapq.nlargest(10, news_feed)]\n\n    def follow(self, followerId: int, followeeId: int) -&gt; None:\n        if followerId != followeeId:\n            self.followees[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -&gt; None:\n        if followerId != followeeId:\n            self.followees[followerId].discard(followeeId)\n\n\ntwitter = Twitter()\nprint(twitter.postTweet(1, 5))  # None\nprint(twitter.getNewsFeed(1))  # [5]\nprint(twitter.follow(1, 2))  # None\nprint(twitter.postTweet(2, 6))  # None\nprint(twitter.getNewsFeed(1))  # [6, 5]\nprint(twitter.unfollow(1, 2))  # None\nprint(twitter.getNewsFeed(1))  # [5]\n</code></pre>"},{"location":"EndlessCheng/heap_advanced/#502-ipo","title":"502. IPO","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting, Heap Priority Queue</p> </li> </ul> Python <pre><code>import heapq\nfrom typing import List\n\n\n# Heap - Two Heaps\ndef findMaximizedCapital(k: int, w: int, profits: List[int], capital: List[int]) -&gt; int:\n    \"\"\"\n    Time Complexity: O(k log N)\n    Space Complexity: O(N)\n    \"\"\"\n    if not profits or not capital:\n        return w\n\n    if w &gt;= max(capital) and k &gt;= len(capital):\n        return sum(profits) + w\n\n    max_profit = []\n    min_capital = [(c, p) for c, p in zip(capital, profits)]\n    heapq.heapify(min_capital)\n\n    for _ in range(k):\n        while min_capital and min_capital[0][0] &lt;= w:\n            _, pro = heapq.heappop(min_capital)\n            heapq.heappush(max_profit, -pro)\n\n        if max_profit:\n            w += -heapq.heappop(max_profit)\n\n    return w\n\n\nif __name__ == \"__main__\":\n    k = 2\n    w = 0\n    profits = [1, 2, 3]\n    capital = [0, 1, 1]\n    assert findMaximizedCapital(k, w, profits, capital) == 4\n</code></pre>"},{"location":"EndlessCheng/heap_advanced/#1705-maximum-number-of-eaten-apples","title":"1705. Maximum Number of Eaten Apples","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/heap_advanced/#778-swim-in-rising-water","title":"778. Swim in Rising Water","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Depth First Search, Breadth First Search, Union Find, Heap Priority Queue, Matrix</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the minimum time when you can reach the target.\n\n![778](https://assets.leetcode.com/uploads/2021/06/29/swim2-grid-1.jpg)\n\"\"\"\n\nimport heapq\nfrom typing import List\n\n\n# Dijkstra's\ndef swimInWater(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    visited = set()\n    minHeap = [(grid[0][0], 0, 0)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    visited.add((0, 0))\n\n    while minHeap:\n        time, r, c = heapq.heappop(minHeap)\n\n        if r == n - 1 and c == n - 1:\n            return time\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if nr in range(n) and nc in range(n) and (nr, nc) not in visited:\n                visited.add((nr, nc))\n                heapq.heappush(minHeap, (max(time, grid[nr][nc]), nr, nc))\n\n\ngrid = [\n    [0, 1, 2, 3, 4],\n    [24, 23, 22, 21, 5],\n    [12, 13, 14, 15, 16],\n    [11, 17, 18, 19, 20],\n    [10, 9, 8, 7, 6],\n]\nprint(swimInWater(grid))  # 16\n</code></pre>"},{"location":"EndlessCheng/heap_advanced/#1631-path-with-minimum-effort","title":"1631. Path With Minimum Effort","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Depth First Search, Breadth First Search, Union Find, Heap Priority Queue, Matrix</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the minimum effort required to travel from the top-left to the bottom-right corner.\n\"\"\"\n\nimport heapq\nfrom typing import List\n\n\n# Prim\ndef minimumEffortPath(heights: List[List[int]]) -&gt; int:\n    m, n = len(heights), len(heights[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * n for _ in range(m)]\n    heap = [(0, 0, 0)]  # (effort, row, col)\n\n    while heap:\n        effort, r, c = heapq.heappop(heap)\n\n        if visited[r][c]:\n            continue\n\n        if r == m - 1 and c == n - 1:\n            return effort\n\n        visited[r][c] = True\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and not visited[nr][nc]:\n                updated = max(effort, abs(heights[r][c] - heights[nr][nc]))\n                heapq.heappush(heap, (updated, nr, nc))\n\n    return -1\n\n\nheights = [[1, 2, 2], [3, 8, 2], [5, 3, 5]]\nprint(minimumEffortPath(heights))  # 2\n</code></pre>"},{"location":"EndlessCheng/heap_advanced/#1354-construct-target-array-with-multiple-sums","title":"1354. Construct Target Array With Multiple Sums","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/heap_advanced/#1353-maximum-number-of-events-that-can-be-attended","title":"1353. Maximum Number of Events That Can Be Attended","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/heap_advanced/#1235-maximum-profit-in-job-scheduling","title":"1235. Maximum Profit in Job Scheduling","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Dynamic Programming, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/heap_advanced/#632-smallest-range-covering-elements-from-k-lists","title":"632. Smallest Range Covering Elements from K Lists","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Greedy, Sliding Window, Sorting, Heap Priority Queue</p> </li> </ul> Python <pre><code>from heapq import heapify, heapreplace\nfrom math import inf\nfrom typing import List\n\n\n# Heap\ndef smallestRange(nums: List[List[int]]) -&gt; List[int]:\n    heap = [(arr[0], i, 0) for i, arr in enumerate(nums)]\n    heapify(heap)\n\n    res_l = heap[0][0]\n    res_r = right = max(arr[0] for arr in nums)\n\n    while heap[0][2] + 1 &lt; len(nums[heap[0][1]]):\n        _, i, j = heap[0]\n        x = nums[i][j + 1]\n        heapreplace(heap, (x, i, j + 1))\n        right = max(right, x)\n        left = heap[0][0]\n        if right - left &lt; res_r - res_l:\n            res_l, res_r = left, right\n\n    return [res_l, res_r]\n\n\n# Sliding Window Variable Min\ndef smallestRangeSliding(nums: List[List[int]]) -&gt; List[int]:\n    pairs = sorted((x, i) for (i, arr) in enumerate(nums) for x in arr)\n    res_l, res_r = -inf, inf\n    empty = len(nums)\n    cnt = [0] * empty\n    left = 0\n\n    for r, i in pairs:\n        if cnt[i] == 0:\n            empty -= 1\n        cnt[i] += 1\n        while empty == 0:\n            l, i = pairs[left]\n            if r - l &lt; res_r - res_l:\n                res_l, res_r = l, r\n            cnt[i] -= 1\n            if cnt[i] == 0:\n                empty += 1\n            left += 1\n\n    return [res_l, res_r]\n\n\nif __name__ == \"__main__\":\n    nums = [[4, 10, 15, 24, 26], [0, 9, 12, 20], [5, 18, 22, 30]]\n    assert smallestRange(nums) == [20, 24]\n    assert smallestRangeSliding(nums) == [20, 24]\n</code></pre>"},{"location":"EndlessCheng/heap_advanced/#2542-maximum-subsequence-score","title":"2542. Maximum Subsequence Score","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/heap_advanced/#1383-maximum-performance-of-a-team","title":"1383. Maximum Performance of a Team","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/heap_advanced/#2503-maximum-number-of-points-from-grid-queries","title":"2503. Maximum Number of Points From Grid Queries","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Breadth First Search, Union Find, Sorting, Heap Priority Queue, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/heap_advanced/#2163-minimum-difference-in-sums-after-removal-of-elements","title":"2163. Minimum Difference in Sums After Removal of Elements","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/heap_advanced/#857-minimum-cost-to-hire-k-workers","title":"857. Minimum Cost to Hire K Workers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/heap_advanced/#1606-find-servers-that-handled-most-number-of-requests","title":"1606. Find Servers That Handled Most Number of Requests","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Heap Priority Queue, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/heap_advanced/#1851-minimum-interval-to-include-each-query","title":"1851. Minimum Interval to Include Each Query","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Line Sweep, Sorting, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/heap_advanced/#218-the-skyline-problem","title":"218. The Skyline Problem","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Divide And Conquer, Binary Indexed Tree, Segment Tree, Line Sweep, Heap Priority Queue, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/heap_advanced/#407-trapping-rain-water-ii","title":"407. Trapping Rain Water II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Breadth First Search, Heap Priority Queue, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/heap_advanced/#2940-find-building-where-alice-and-bob-can-meet","title":"2940. Find Building Where Alice and Bob Can Meet","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Stack, Binary Indexed Tree, Segment Tree, Heap Priority Queue, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/heap_advanced/#3399-smallest-substring-with-identical-characters-ii","title":"3399. Smallest Substring With Identical Characters II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Binary Search</p> </li> </ul>"},{"location":"EndlessCheng/heap_advanced/#2589-minimum-time-to-complete-all-tasks","title":"2589. Minimum Time to Complete All Tasks","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Stack, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/heap_advanced/#3266-final-array-state-after-k-multiplication-operations-ii","title":"3266. Final Array State After K Multiplication Operations II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Heap Priority Queue, Simulation</p> </li> </ul>"},{"location":"EndlessCheng/heap_advanced/#1675-minimize-deviation-in-array","title":"1675. Minimize Deviation in Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Heap Priority Queue, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/heap_advanced/#2617-minimum-number-of-visited-cells-in-a-grid","title":"2617. Minimum Number of Visited Cells in a Grid","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Stack, Breadth First Search, Union Find, Heap Priority Queue, Matrix, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/heap_advanced/#2532-time-to-cross-a-bridge","title":"2532. Time to Cross a Bridge","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Heap Priority Queue, Simulation</p> </li> </ul>"},{"location":"EndlessCheng/heap_advanced/#1199-minimum-time-to-build-blocks","title":"1199. Minimum Time to Build Blocks \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Greedy, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/heap_basics/","title":"Heap Basics","text":""},{"location":"EndlessCheng/heap_basics/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1046. Last Stone Weight (Easy)</li> <li> 3264. Final Array State After K Multiplication Operations I (Easy)</li> <li> 2558. Take Gifts From the Richest Pile (Easy)</li> <li> 2336. Smallest Number in Infinite Set (Medium)</li> <li> 2530. Maximal Score After Applying K Operations (Medium)</li> <li> 3066. Minimum Operations to Exceed Threshold Value II (Medium)</li> <li> 1962. Remove Stones to Minimize the Total (Medium)</li> <li> 703. Kth Largest Element in a Stream (Easy)</li> <li> 3275. K-th Nearest Obstacle Queries (Medium)</li> <li> 2208. Minimum Operations to Halve Array Sum (Medium)</li> <li> 2233. Maximum Product After K Increments (Medium)</li> <li> 3296. Minimum Number of Seconds to Make Mountain Height Zero (Medium)</li> <li> 1942. The Number of the Smallest Unoccupied Chair (Medium)</li> <li> 1801. Number of Orders in the Backlog (Medium)</li> <li> 2406. Divide Intervals Into Minimum Number of Groups (Medium)</li> <li> 2462. Total Cost to Hire K Workers (Medium)</li> <li> 1834. Single-Threaded CPU (Medium)</li> <li> 3408. Design Task Manager (Medium)</li> <li> 1792. Maximum Average Pass Ratio (Medium)</li> <li> 2931. Maximum Spending After Buying Items (Hard)</li> <li> 1882. Process Tasks Using Servers (Medium)</li> <li> 2402. Meeting Rooms III (Hard)</li> <li> 253. Meeting Rooms II (Medium) \ud83d\udc51</li> <li> 1167. Minimum Cost to Connect Sticks (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/heap_basics/#1046-last-stone-weight","title":"1046. Last Stone Weight","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Heap Priority Queue</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Heap\n    - Time: O(n log n); Space: O(n)\n- 0/1 Knapsack\n    - Time: O(n); Space: O(n)\n\"\"\"\n\nfrom heapq import heapify, heappop, heappush\nfrom typing import List\n\n\n# Heap\ndef lastStoneWeightHeap(stones: List[int]) -&gt; int:\n    maxHeap = [-s for s in stones]\n    heapify(maxHeap)\n\n    while len(maxHeap) &gt; 1:\n        s1 = heappop(maxHeap)\n        s2 = heappop(maxHeap)\n\n        if s1 != s2:\n            heappush(maxHeap, s1 - s2)\n\n    return -maxHeap[0] if maxHeap else 0\n\n\n# 0/1 Knapsack\ndef lastStoneWeightKnapsack(stones: List[int]) -&gt; int:\n    total = sum(stones)\n    target = total // 2\n\n    dp = [0 for _ in range(target + 1)]\n\n    for i in stones:\n        for j in range(target, i - 1, -1):\n            dp[j] = max(dp[j], dp[j - i] + i)\n\n    return total - 2 * dp[target]\n\n\nif __name__ == \"__main__\":\n    stones = [2, 7, 4, 1, 8, 1]\n    assert lastStoneWeightHeap(stones) == 1\n    assert lastStoneWeightKnapsack(stones) == 1\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint lastStoneWeight(vector&lt;int&gt; &amp;stones) {\n    priority_queue&lt;int&gt; maxHeap(stones.begin(), stones.end());\n\n    // Only while there are at least two stones to smash\n    while (maxHeap.size() &gt; 1) {\n        int first = maxHeap.top();\n        maxHeap.pop();\n        int second = maxHeap.top();\n        maxHeap.pop();\n\n        if (first != second) {\n            maxHeap.push(first - second);\n        }\n    }\n\n    return maxHeap.empty() ? 0 : maxHeap.top();\n}\n\nint main() {\n    vector&lt;int&gt; stones = {2, 7, 4, 1, 8, 1};\n    cout &lt;&lt; lastStoneWeight(stones) &lt;&lt; endl;  // 1\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/heap_basics/#3264-final-array-state-after-k-multiplication-operations-i","title":"3264. Final Array State After K Multiplication Operations I","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Heap Priority Queue, Simulation</p> </li> </ul> Python <pre><code>import heapq\nfrom typing import List\n\n\n# Brute Force\ndef getFinalStateBF(nums: List[int], k: int, multiplier: int) -&gt; List[int]:\n    for _ in range(k):\n        minNum = min(nums)\n        idx = nums.index(minNum)\n        nums[idx] *= multiplier\n\n    return nums\n\n\n# Heap\ndef getFinalStateHeap(nums: List[int], k: int, multiplier: int) -&gt; List[int]:\n    minHeap = []\n    for idx, num in enumerate(nums):\n        heapq.heappush(minHeap, (num, idx))\n\n    for _ in range(k):\n        num, idx = heapq.heappop(minHeap)\n        nums[idx] = num * multiplier\n        heapq.heappush(minHeap, (nums[idx], idx))\n\n    return nums\n\n\nk = 5\nmultiplier = 2\nprint(getFinalStateBF([2, 1, 3, 5, 6], k, multiplier))  # [8, 4, 6, 5, 6]\nprint(getFinalStateHeap([2, 1, 3, 5, 6], k, multiplier))  # [8, 4, 6, 5, 6]\n</code></pre>"},{"location":"EndlessCheng/heap_basics/#2558-take-gifts-from-the-richest-pile","title":"2558. Take Gifts From the Richest Pile","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Heap Priority Queue, Simulation</p> </li> </ul> Python <pre><code>from heapq import heapify, heappop, heappush\nfrom math import isqrt\nfrom typing import List\n\n\n# Heap\ndef pickGifts(gifts: List[int], k: int) -&gt; int:\n    maxHeap = [-g for g in gifts]\n    heapify(maxHeap)\n\n    for _ in range(k):\n        cur = heappop(maxHeap)\n\n        if cur == -1:\n            heappush(maxHeap, cur)\n            break\n\n        heappush(maxHeap, -isqrt(-cur))\n\n    return sum(-i for i in maxHeap)\n\n\nif __name__ == \"__main__\":\n    assert pickGifts([25, 64, 9, 4, 100], 4) == 29\n    assert pickGifts([1, 1, 1, 1], 4) == 0\n</code></pre>"},{"location":"EndlessCheng/heap_basics/#2336-smallest-number-in-infinite-set","title":"2336. Smallest Number in Infinite Set","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Design, Heap Priority Queue, Ordered Set</p> </li> </ul> Python <pre><code>from heapq import heappop, heappush\n\n\n# Heap\nclass SmallestInfiniteSet:\n    def __init__(self):\n        self.cur_min = 1\n        self.added = set()\n        self.min_heap = []\n\n    def popSmallest(self) -&gt; int:\n        if self.min_heap:\n            res = heappop(self.min_heap)\n            self.added.remove(res)\n            return res\n\n        res = self.cur_min\n        self.cur_min += 1\n        return res\n\n    def addBack(self, num: int) -&gt; None:\n        if num &lt; self.cur_min and num not in self.added:\n            self.added.add(num)\n            heappush(self.min_heap, num)\n\n\nif __name__ == \"__main__\":\n    sis = SmallestInfiniteSet()\n    assert sis.popSmallest() == 1\n    sis.addBack(2)\n    assert sis.popSmallest() == 2\n    assert sis.popSmallest() == 3\n    sis.addBack(1)\n    assert sis.popSmallest() == 1\n    assert sis.popSmallest() == 4\n    sis.addBack(3)\n    assert sis.popSmallest() == 3\n</code></pre>"},{"location":"EndlessCheng/heap_basics/#2530-maximal-score-after-applying-k-operations","title":"2530. Maximal Score After Applying K Operations","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Heap Priority Queue</p> </li> </ul> Python <pre><code>from heapq import heapify, heappop, heappush\nfrom math import ceil\nfrom typing import List\n\n\n# Heap\ndef maxKelements(nums: List[int], k: int) -&gt; int:\n    res = 0\n    maxHeap = [-n for n in nums]\n    heapify(maxHeap)\n\n    while k &gt; 0:\n        cur = -heappop(maxHeap)\n        res += cur\n        heappush(maxHeap, -ceil(cur / 3))\n        k -= 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert maxKelements([10, 10, 10, 10, 10], 5) == 50\n    assert maxKelements([1, 10, 3, 3, 3], 3) == 17\n    assert maxKelements([1, 2, 3, 4, 5], 5) == 16\n</code></pre>"},{"location":"EndlessCheng/heap_basics/#3066-minimum-operations-to-exceed-threshold-value-ii","title":"3066. Minimum Operations to Exceed Threshold Value II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Heap Priority Queue, Simulation</p> </li> </ul> Python <pre><code>from heapq import heapify, heappop, heappush\nfrom typing import List\n\n\n# Heap\ndef minOperations(nums: List[int], k: int) -&gt; int:\n    heapify(nums)\n    res = 0\n\n    while nums[0] &lt; k:\n        x = heappop(nums)\n        y = heappop(nums)\n        heappush(nums, x * 2 + y)\n        res += 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert minOperations([2, 11, 10, 1, 3], 10) == 2\n    assert minOperations([1, 1, 2, 4, 9], 20) == 4\n</code></pre>"},{"location":"EndlessCheng/heap_basics/#1962-remove-stones-to-minimize-the-total","title":"1962. Remove Stones to Minimize the Total","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Heap Priority Queue</p> </li> </ul> Python <pre><code>from heapq import heapify, heapreplace\nfrom typing import List\n\n\n# Heap\ndef minStoneSum(piles: List[int], k: int) -&gt; int:\n    maxHeap = [-p for p in piles]\n    heapify(maxHeap)\n\n    for _ in range(k):\n        heapreplace(maxHeap, maxHeap[0] // 2)\n\n    return -sum(maxHeap)\n\n\nif __name__ == \"__main__\":\n    assert minStoneSum([5, 4, 9], 2) == 12\n    assert minStoneSum([4, 3, 6, 7], 3) == 12\n</code></pre>"},{"location":"EndlessCheng/heap_basics/#703-kth-largest-element-in-a-stream","title":"703. Kth Largest Element in a Stream","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Design, Binary Search Tree, Heap Priority Queue, Binary Tree, Data Stream</p> </li> </ul> Python <pre><code>import heapq\nfrom typing import List\n\n\n# Heap\nclass KthLargest:\n\n    def __init__(self, k: int, nums: List[int]):\n        self.k = k\n        self.heap = []\n        for num in nums:\n            self.add(num)\n\n    def add(self, val: int) -&gt; int:\n        heapq.heappush(self.heap, val)\n\n        if len(self.heap) &gt; self.k:\n            heapq.heappop(self.heap)\n\n        return self.heap[0]\n\n\nobj = KthLargest(3, [4, 5, 8, 2])\nprint(obj.add(3))  # 4\nprint(obj.add(5))  # 5\nprint(obj.add(10))  # 5\n</code></pre>"},{"location":"EndlessCheng/heap_basics/#3275-k-th-nearest-obstacle-queries","title":"3275. K-th Nearest Obstacle Queries","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Heap Priority Queue</p> </li> </ul> Python <pre><code>from heapq import heappop, heappush\nfrom typing import List\n\n\n# Heap\ndef resultsArray(queries: List[List[int]], k: int) -&gt; List[int]:\n    n = len(queries)\n    res = [-1 for _ in range(n)]\n    maxHeap = []\n\n    for i in range(n):\n        dist = abs(queries[i][0]) + abs(queries[i][1])\n        heappush(maxHeap, -dist)\n\n        if i &lt; k - 1:\n            continue\n\n        while len(maxHeap) &gt; k:\n            heappop(maxHeap)\n\n        res[i] = -maxHeap[0]\n\n    return res\n\n\nif __name__ == \"__main__\":\n    queries = [[1, 2], [3, 4], [2, 3], [-3, 0]]\n    k = 2\n    assert resultsArray(queries, k) == [-1, 7, 5, 3]\n</code></pre>"},{"location":"EndlessCheng/heap_basics/#2208-minimum-operations-to-halve-array-sum","title":"2208. Minimum Operations to Halve Array Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Heap Priority Queue</p> </li> </ul> Python <pre><code>import heapq\nfrom typing import List\n\n\ndef halveArray(nums: List[int]) -&gt; int:\n    if not nums:\n        return 0\n\n    res = 0\n    cur_sum = sum(nums)\n    target = cur_sum / 2\n\n    max_heap = [-num for num in nums]  # max heap\n    heapq.heapify(max_heap)\n\n    while cur_sum &gt; target:\n        mx = -heapq.heappop(max_heap)\n        new = mx / 2\n        heapq.heappush(max_heap, -new)\n        cur_sum -= new\n        res += 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert halveArray([5, 19, 8, 1]) == 3\n    assert halveArray([3, 8, 20]) == 3\n</code></pre>"},{"location":"EndlessCheng/heap_basics/#2233-maximum-product-after-k-increments","title":"2233. Maximum Product After K Increments","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/heap_basics/#3296-minimum-number-of-seconds-to-make-mountain-height-zero","title":"3296. Minimum Number of Seconds to Make Mountain Height Zero","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Binary Search, Greedy, Heap Priority Queue</p> </li> </ul> Python <pre><code>from bisect import bisect_left\nfrom heapq import heapify, heapreplace\nfrom math import isqrt\nfrom typing import List\n\n\n# Min Heap\ndef minNumberOfSecondsMinHeap(mountainHeight: int, workerTimes: List[int]) -&gt; int:\n    minHeap = [(t, t, t) for t in workerTimes]\n    heapify(minHeap)\n\n    for _ in range(mountainHeight):\n        nxt, delta, base = minHeap[0]\n        heapreplace(\n            minHeap,\n            (\n                nxt + delta + base,\n                delta + base,\n                base,\n            ),\n        )\n    return nxt\n\n\n# Binary Search Min Answer\ndef minNumberOfSecondsBinarySearchMin(mountainHeight: int, workerTimes: List[int]) -&gt; int:\n    def check(m: int) -&gt; bool:\n        left_h = mountainHeight\n        for t in workerTimes:\n            left_h -= (isqrt(m // t * 8 + 1) - 1) // 2\n            if left_h &lt;= 0:\n                return True\n        return False\n\n    max_t = max(workerTimes)\n    h = (mountainHeight - 1) // len(workerTimes) + 1\n    return bisect_left(range(max_t * h * (h + 1) // 2), True, 1, key=check)\n\n\nif __name__ == \"__main__\":\n    mountainHeight = 4\n    workerTimes = [2, 1, 1]\n    assert minNumberOfSecondsMinHeap(mountainHeight, workerTimes) == 3\n    assert minNumberOfSecondsBinarySearchMin(mountainHeight, workerTimes) == 3\n</code></pre>"},{"location":"EndlessCheng/heap_basics/#1942-the-number-of-the-smallest-unoccupied-chair","title":"1942. The Number of the Smallest Unoccupied Chair","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/heap_basics/#1801-number-of-orders-in-the-backlog","title":"1801. Number of Orders in the Backlog","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Heap Priority Queue, Simulation</p> </li> </ul>"},{"location":"EndlessCheng/heap_basics/#2406-divide-intervals-into-minimum-number-of-groups","title":"2406. Divide Intervals Into Minimum Number of Groups","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Greedy, Sorting, Heap Priority Queue, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/heap_basics/#2462-total-cost-to-hire-k-workers","title":"2462. Total Cost to Hire K Workers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Heap Priority Queue, Simulation</p> </li> </ul>"},{"location":"EndlessCheng/heap_basics/#1834-single-threaded-cpu","title":"1834. Single-Threaded CPU","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sorting, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/heap_basics/#3408-design-task-manager","title":"3408. Design Task Manager","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Design, Heap Priority Queue, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/heap_basics/#1792-maximum-average-pass-ratio","title":"1792. Maximum Average Pass Ratio","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/heap_basics/#2931-maximum-spending-after-buying-items","title":"2931. Maximum Spending After Buying Items","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting, Heap Priority Queue, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/heap_basics/#1882-process-tasks-using-servers","title":"1882. Process Tasks Using Servers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/heap_basics/#2402-meeting-rooms-iii","title":"2402. Meeting Rooms III","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Sorting, Heap Priority Queue, Simulation</p> </li> </ul>"},{"location":"EndlessCheng/heap_basics/#253-meeting-rooms-ii","title":"253. Meeting Rooms II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Greedy, Sorting, Heap Priority Queue, Prefix Sum</p> </li> </ul> Python <pre><code>\"\"\"\n- Given an array of meeting time `intervals` where `intervals[i] = [start_i, end_i]`, return the minimum number of conference rooms required.\n\"\"\"\n\nimport heapq\nfrom typing import List\n\n\n# Heap\ndef minMeetingRooms(intervals: List[List[int]]) -&gt; int:\n    if not intervals:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n    minHeap = [intervals[0][1]]\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &gt;= minHeap[0]:\n            heapq.heappop(minHeap)\n        heapq.heappush(minHeap, intervals[i][1])\n\n    return len(minHeap)\n\n\nif __name__ == \"__main__\":\n    intervals = [[0, 30], [5, 10], [15, 20]]\n    assert minMeetingRooms(intervals) == 2\n</code></pre>"},{"location":"EndlessCheng/heap_basics/#1167-minimum-cost-to-connect-sticks","title":"1167. Minimum Cost to Connect Sticks \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Heap Priority Queue</p> </li> </ul> Python <pre><code>from heapq import heapify, heappop, heappush\nfrom typing import List\n\n\n# Heap\ndef connectSticks(sticks: List[int]) -&gt; int:\n    n = len(sticks)\n    heapify(sticks)\n    res = 0\n\n    while n &gt; 1:\n        x = heappop(sticks)\n        y = heappop(sticks)\n        res += x + y\n        heappush(sticks, x + y)\n        n -= 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert connectSticks([2, 4, 3]) == 14\n    assert connectSticks([1, 8, 3, 5]) == 30\n    assert connectSticks([5]) == 0\n    assert connectSticks([1, 2, 3, 4, 5]) == 33\n    assert connectSticks([1, 1, 1]) == 5\n</code></pre>"},{"location":"EndlessCheng/heap_kth_smallest_largest/","title":"Heap Kth Smallest Largest","text":""},{"location":"EndlessCheng/heap_kth_smallest_largest/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 264. Ugly Number II (Medium)</li> <li> 378. Kth Smallest Element in a Sorted Matrix (Medium)</li> <li> 373. Find K Pairs with Smallest Sums (Medium)</li> <li> 1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows (Hard)</li> <li> 786. K-th Smallest Prime Fraction (Medium)</li> <li> 2386. Find the K-Sum of an Array (Hard)</li> </ul>"},{"location":"EndlessCheng/heap_kth_smallest_largest/#264-ugly-number-ii","title":"264. Ugly Number II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Math, Dynamic Programming, Heap Priority Queue</p> </li> </ul> Python <pre><code>import heapq\n\n\ndef nthUglyNumber(n: int) -&gt; int:\n    heap = [1]\n    seen = set(heap)\n\n    factors = [2, 3, 5]\n    current = 1\n\n    # Pop the smallest ugly number n times\n    for _ in range(n):\n        current = heapq.heappop(heap)  # Pop the smallest ugly number\n\n        for factor in factors:\n            new = current * factor\n            if new not in seen:\n                seen.add(new)\n                heapq.heappush(heap, new)\n\n    return current\n\n\nprint(nthUglyNumber(10))  # 12\n</code></pre>"},{"location":"EndlessCheng/heap_kth_smallest_largest/#378-kth-smallest-element-in-a-sorted-matrix","title":"378. Kth Smallest Element in a Sorted Matrix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Sorting, Heap Priority Queue, Matrix</p> </li> </ul> Python <pre><code>\"\"\"\n-   Given an `n x n` matrix where each of the rows and columns are sorted in ascending order, return the `k-th` smallest element in the matrix.\n\"\"\"\n\nfrom heapq import heapify, heappop, heappush\nfrom typing import List\n\n\n# Heap - Merge K Sorted\ndef kthSmallestHeap(matrix: List[List[int]], k: int) -&gt; int:\n    n = len(matrix)\n    heap = [(matrix[i][0], i, 0) for i in range(n)]\n    heapify(heap)\n\n    for _ in range(k - 1):\n        _, row, col = heappop(heap)\n\n        if col + 1 &lt; n:\n            heappush(heap, (matrix[row][col + 1], row, col + 1))\n\n    return heappop(heap)[0]\n\n\n# Binary Search\ndef kthSmallestBinarySearch(matrix: List[List[int]], k: int) -&gt; int:\n    n = len(matrix)\n\n    def check(mid):\n        i, j = n - 1, 0\n        num = 0\n\n        while i &gt;= 0 and j &lt; n:\n            if matrix[i][j] &lt;= mid:\n                num += i + 1\n                j += 1\n            else:\n                i -= 1\n\n        return num &gt;= k\n\n    left, right = matrix[0][0], matrix[-1][-1]\n\n    while left &lt; right:\n        mid = (left + right) // 2\n        if check(mid):\n            right = mid\n        else:\n            left = mid + 1\n\n    return left\n\n\nmatrix = [[1, 5, 9], [10, 11, 13], [12, 13, 15]]\nk = 8\n\nprint(kthSmallestHeap(matrix, k))  # 13\nprint(kthSmallestBinarySearch(matrix, k))  # 13\n</code></pre>"},{"location":"EndlessCheng/heap_kth_smallest_largest/#373-find-k-pairs-with-smallest-sums","title":"373. Find K Pairs with Smallest Sums","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Heap Priority Queue</p> </li> </ul> Python <pre><code>import heapq\nfrom typing import List\n\n\n# Heap - Merge K Sorted\ndef kSmallestPairs(nums1: List[int], nums2: List[int], k: int) -&gt; List[List[int]]:\n    if not nums1 or not nums2 or k &lt;= 0:\n        return []\n\n    res = []\n    min_heap = []\n\n    for j in range(min(k, len(nums2))):\n        heapq.heappush(min_heap, (nums1[0] + nums2[j], 0, j))\n\n    while k &gt; 0 and min_heap:\n        _, i, j = heapq.heappop(min_heap)\n        res.append([nums1[i], nums2[j]])\n        k -= 1\n\n        if i + 1 &lt; len(nums1):\n            heapq.heappush(min_heap, (nums1[i + 1] + nums2[j], i + 1, j))\n\n    return res\n\n\nif __name__ == \"__main__\":\n    nums1 = [1, 2, 4, 5, 6]\n    nums2 = [3, 5, 7, 9]\n    k = 3\n    assert kSmallestPairs(nums1, nums2, k) == [[1, 3], [2, 3], [1, 5]]\n</code></pre>"},{"location":"EndlessCheng/heap_kth_smallest_largest/#1439-find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows","title":"1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Heap Priority Queue, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/heap_kth_smallest_largest/#786-k-th-smallest-prime-fraction","title":"786. K-th Smallest Prime Fraction","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Sorting, Heap Priority Queue</p> </li> </ul> Python <pre><code>import heapq\nfrom typing import List\n\n\ndef kthSmallestPrimeFraction(arr: List[int], k: int) -&gt; List[int]:\n    max_heap = []\n\n    for j in range(1, len(arr)):\n        for i in range(j):\n            heapq.heappush(max_heap, (-arr[i] / arr[j], arr[i], arr[j]))\n\n            if len(max_heap) &gt; k:\n                heapq.heappop(max_heap)\n\n    return [max_heap[0][1], max_heap[0][2]]\n\n\narr = [1, 2, 3, 5]\nk = 3\nprint(kthSmallestPrimeFraction(arr, k))  # [2, 5]\n</code></pre>"},{"location":"EndlessCheng/heap_kth_smallest_largest/#2386-find-the-k-sum-of-an-array","title":"2386. Find the K-Sum of an Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sorting, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/heap_rearrange_elements/","title":"Heap Rearrange Elements","text":""},{"location":"EndlessCheng/heap_rearrange_elements/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 984. String Without AAA or BBB (Medium)</li> <li> 767. Reorganize String (Medium)</li> <li> 1054. Distant Barcodes (Medium)</li> <li> 1953. Maximum Number of Weeks for Which You Can Work (Medium)</li> <li> 1405. Longest Happy String (Medium)</li> <li> 3081. Replace Question Marks in String to Minimize Its Value (Medium)</li> <li> 621. Task Scheduler (Medium)</li> <li> 358. Rearrange String k Distance Apart (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/heap_rearrange_elements/#984-string-without-aaa-or-bbb","title":"984. String Without AAA or BBB","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/heap_rearrange_elements/#767-reorganize-string","title":"767. Reorganize String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Greedy, Sorting, Heap Priority Queue, Counting</p> </li> </ul> Python <pre><code>import heapq\nfrom collections import Counter\n\n\ndef reorganizeString(s: str) -&gt; str:\n    if not s:\n        return \"\"\n\n    heap = [(-freq, char) for char, freq in Counter(s).items()]  # max heap\n    heapq.heapify(heap)\n\n    result = []\n    prev_count, prev_char = 0, \"\"\n\n    while heap:\n        count, char = heapq.heappop(heap)  # pop the most frequent character\n        result.append(char)  # append the character to the result\n\n        if prev_count &lt; 0:  # if the previous character still has remaining count\n            heapq.heappush(heap, (prev_count, prev_char))\n\n        prev_count = count + 1  # update the current character's remaining count\n        prev_char = char  # update the current character\n\n    # check if there is any invalid result\n    if len(result) != len(s):\n        return \"\"\n\n    return \"\".join(result)\n\n\nprint(reorganizeString(\"aab\"))\n</code></pre>"},{"location":"EndlessCheng/heap_rearrange_elements/#1054-distant-barcodes","title":"1054. Distant Barcodes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Greedy, Sorting, Heap Priority Queue, Counting</p> </li> </ul>"},{"location":"EndlessCheng/heap_rearrange_elements/#1953-maximum-number-of-weeks-for-which-you-can-work","title":"1953. Maximum Number of Weeks for Which You Can Work","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/heap_rearrange_elements/#1405-longest-happy-string","title":"1405. Longest Happy String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Greedy, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/heap_rearrange_elements/#3081-replace-question-marks-in-string-to-minimize-its-value","title":"3081. Replace Question Marks in String to Minimize Its Value","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Greedy, Sorting, Heap Priority Queue, Counting</p> </li> </ul>"},{"location":"EndlessCheng/heap_rearrange_elements/#621-task-scheduler","title":"621. Task Scheduler","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Greedy, Sorting, Heap Priority Queue, Counting</p> </li> </ul> Python <pre><code>import heapq\nfrom collections import Counter, deque\nfrom typing import List\n\n\n# Heap\ndef leastInterval1(tasks: List[str], n: int) -&gt; int:\n    count = Counter(tasks)\n    heap = [-c for c in count.values()]\n    heapq.heapify(heap)\n\n    time = 0\n\n    q = deque()\n\n    while heap or q:\n        time += 1\n\n        if heap:\n            cnt = 1 + heapq.heappop(heap)\n            if cnt:\n                q.append((cnt, time + n))\n\n        if q and q[0][1] == time:\n            heapq.heappush(heap, q.popleft()[0])\n\n    return time\n\n\ndef leastInterval2(tasks: List[str], n: int) -&gt; int:\n    freq = Counter(tasks)\n\n    maxExec = max(freq.values())\n    maxCount = sum(1 for v in freq.values() if v == maxExec)\n\n    return max((maxExec - 1) * (n + 1) + maxCount, len(tasks))\n\n\ntasks = [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\"]\nn = 2\nprint(leastInterval1(tasks, n))  # 8\nprint(leastInterval2(tasks, n))  # 8\n</code></pre>"},{"location":"EndlessCheng/heap_rearrange_elements/#358-rearrange-string-k-distance-apart","title":"358. Rearrange String k Distance Apart \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Greedy, Sorting, Heap Priority Queue, Counting</p> </li> </ul>"},{"location":"EndlessCheng/inclusion_exclusion_principle/","title":"Inclusion Exclusion Principle","text":""},{"location":"EndlessCheng/inclusion_exclusion_principle/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2652. Sum Multiples (Easy)</li> <li> 878. Nth Magical Number (Hard)</li> <li> 1201. Ugly Number III (Medium)</li> <li> 2928. Distribute Candies Among Children I (Easy)</li> <li> 2929. Distribute Candies Among Children II (Medium)</li> <li> 2930. Number of Strings Which Can Be Rearranged to Contain Substring (Medium)</li> <li> 2513. Minimize the Maximum of Two Arrays (Medium)</li> <li> 3116. Kth Smallest Amount With Single Denomination Combination (Hard)</li> <li> 3130. Find All Possible Stable Binary Arrays II (Hard)</li> <li> 3336. Find the Number of Subsequences With Equal GCD (Hard)</li> <li> 2927. Distribute Candies Among Children III (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/inclusion_exclusion_principle/#2652-sum-multiples","title":"2652. Sum Multiples","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math</p> </li> </ul>"},{"location":"EndlessCheng/inclusion_exclusion_principle/#878-nth-magical-number","title":"878. Nth Magical Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Binary Search</p> </li> </ul>"},{"location":"EndlessCheng/inclusion_exclusion_principle/#1201-ugly-number-iii","title":"1201. Ugly Number III","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Binary Search, Combinatorics, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/inclusion_exclusion_principle/#2928-distribute-candies-among-children-i","title":"2928. Distribute Candies Among Children I","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Combinatorics, Enumeration</p> </li> </ul> Python <pre><code>def distributeCandies(n: int, limit: int) -&gt; int:\n    def c2(n: int) -&gt; int:\n        return n * (n - 1) // 2 if n &gt; 1 else 0\n\n    return (\n        c2(n + 2) - 3 * c2(n - limit + 1) + 3 * c2(n - 2 * limit) - c2(n - 3 * limit - 1)\n    )\n\n\nif __name__ == \"__main__\":\n    assert distributeCandies(5, 2) == 3\n    assert distributeCandies(3, 3) == 10\n</code></pre>"},{"location":"EndlessCheng/inclusion_exclusion_principle/#2929-distribute-candies-among-children-ii","title":"2929. Distribute Candies Among Children II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Combinatorics, Enumeration</p> </li> </ul> Python <pre><code>def distributeCandies(n: int, limit: int) -&gt; int:\n    def c2(n: int) -&gt; int:\n        return n * (n - 1) // 2 if n &gt; 1 else 0\n\n    return (\n        c2(n + 2) - 3 * c2(n - limit + 1) + 3 * c2(n - 2 * limit) - c2(n - 3 * limit - 1)\n    )\n\n\nif __name__ == \"__main__\":\n    assert distributeCandies(5, 2) == 3\n    assert distributeCandies(3, 3) == 10\n</code></pre>"},{"location":"EndlessCheng/inclusion_exclusion_principle/#2930-number-of-strings-which-can-be-rearranged-to-contain-substring","title":"2930. Number of Strings Which Can Be Rearranged to Contain Substring","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Combinatorics</p> </li> </ul>"},{"location":"EndlessCheng/inclusion_exclusion_principle/#2513-minimize-the-maximum-of-two-arrays","title":"2513. Minimize the Maximum of Two Arrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Binary Search, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/inclusion_exclusion_principle/#3116-kth-smallest-amount-with-single-denomination-combination","title":"3116. Kth Smallest Amount With Single Denomination Combination","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Binary Search, Bit Manipulation, Combinatorics, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/inclusion_exclusion_principle/#3130-find-all-possible-stable-binary-arrays-ii","title":"3130. Find All Possible Stable Binary Arrays II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/inclusion_exclusion_principle/#3336-find-the-number-of-subsequences-with-equal-gcd","title":"3336. Find the Number of Subsequences With Equal GCD","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/inclusion_exclusion_principle/#2927-distribute-candies-among-children-iii","title":"2927. Distribute Candies Among Children III \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Combinatorics</p> </li> </ul> Python <pre><code>def distributeCandies(n: int, limit: int) -&gt; int:\n    def c2(n: int) -&gt; int:\n        return n * (n - 1) // 2 if n &gt; 1 else 0\n\n    return (\n        c2(n + 2) - 3 * c2(n - limit + 1) + 3 * c2(n - 2 * limit) - c2(n - 3 * limit - 1)\n    )\n\n\nif __name__ == \"__main__\":\n    assert distributeCandies(5, 2) == 3\n    assert distributeCandies(3, 3) == 10\n</code></pre>"},{"location":"EndlessCheng/inductive_method/","title":"Inductive Method","text":""},{"location":"EndlessCheng/inductive_method/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2952. Minimum Number of Coins to be Added (Medium)</li> <li> 330. Patching Array (Hard)</li> <li> 1798. Maximum Number of Consecutive Values You Can Make (Medium)</li> </ul>"},{"location":"EndlessCheng/inductive_method/#2952-minimum-number-of-coins-to-be-added","title":"2952. Minimum Number of Coins to be Added","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/inductive_method/#330-patching-array","title":"330. Patching Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/inductive_method/#1798-maximum-number-of-consecutive-values-you-can-make","title":"1798. Maximum Number of Consecutive Values You Can Make","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/integer_partition/","title":"Integer Partition","text":""},{"location":"EndlessCheng/integer_partition/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 343. Integer Break (Medium)</li> <li> 1808. Maximize Number of Nice Divisors (Hard)</li> </ul>"},{"location":"EndlessCheng/integer_partition/#343-integer-break","title":"343. Integer Break","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the maximum product of the integer after breaking it into at least two positive integers.\n-   `dp[i]` stores the maximum product of the integer `i`.\n-   Formula: `dp[i] = max(dp[i - j] * j, (i - j) * j)`\n-   Time Complexity: O(n^2)\n-   Space Complexity: O(n)\n\n| dp        | 3       | 4       | 5       | 6       | 7        | 8        |\n|:---------:|:-------:|:-------:|:-------:|:-------:|:--------:|:--------:|\n| 2         | 2*1=2   | 2*2=4   | 2*3=6   | 2*4=8   | 2*5=10   | 2*6=12   |\n| dp[2]=1   | 1*1=1   | 1*2=2   | 1*3=3   | 1*4=4   | 1*5=5    | 1*6=6    |\n| 3         |         | 3*1=3   | 3*2=6   | 3*3=9   | 3*4=12   | 3*5=15   |\n| dp[3]=2   |         | 2*1=2   | 2*2=4   | 2*3=6   | 2*4=8    | 2*5=10   |\n| 4         |         |         | 4*1=4   | 4*2=8   | 4*3=12   | 4*4=16   |\n| dp[4]=4   |         |         | 4*1=4   | 4*2=8   | 4*3=12   | 4*4=16   |\n| 5         |         |         |         | 5*1=5   | 5*2=10   | 5*3=15   |\n| dp[5]=6   |         |         |         | 6*1=6   | 6*2=12   | 6*3=18   |\n| 6         |         |         |         |         | 6*1=6    | 6*2=12   |\n| dp[6]=9   |         |         |         |         | 9*1=9    | 9*2=18   |\n| 7         |         |         |         |         |          | 7*1=7    |\n| dp[7]=12  |         |         |         |         |          | 12*1=12  |\n| `dp[n]`   | 2       | 4       | 6       | 9       | 12       | 18       |\n\"\"\"\n\n\ndef integerBreak(n: int) -&gt; int:\n    dp = [0 for _ in range(n + 1)]\n    dp[2] = 1\n\n    for i in range(3, n + 1):\n        for j in range(2, i):\n            dp[i] = max(dp[i], dp[i - j] * j, (i - j) * j)\n\n    return dp[n]\n\n\nif __name__ == \"__main__\":\n    print(integerBreak(8))  # 18\n</code></pre>"},{"location":"EndlessCheng/integer_partition/#1808-maximize-number-of-nice-divisors","title":"1808. Maximize Number of Nice Divisors","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Recursion, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/interval_coverage/","title":"Interval Coverage","text":""},{"location":"EndlessCheng/interval_coverage/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 45. Jump Game II (Medium)</li> <li> 1024. Video Stitching (Medium)</li> <li> 1326. Minimum Number of Taps to Open to Water a Garden (Hard)</li> </ul>"},{"location":"EndlessCheng/interval_coverage/#45-jump-game-ii","title":"45. Jump Game II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy</p> </li> </ul> Python <pre><code>\"\"\"\n- Return the minimum number of jumps to reach the last index.\n\"\"\"\n\nfrom typing import List\n\n\n# Greedy - Interval\ndef jump(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n == 1:\n        return 0\n\n    reach = 0\n    left, right = 0, 0\n    res = 0\n\n    while right &lt; n - 1:\n        for i in range(left, right + 1):\n            reach = max(reach, i + nums[i])\n\n        left = right + 1\n        right = reach\n        res += 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert jump([2, 3, 1, 1, 4]) == 2\n    assert jump([2, 3, 0, 1, 4]) == 2\n</code></pre>"},{"location":"EndlessCheng/interval_coverage/#1024-video-stitching","title":"1024. Video Stitching","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/interval_coverage/#1326-minimum-number-of-taps-to-open-to-water-a-garden","title":"1326. Minimum Number of Taps to Open to Water a Garden","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/interval_grouping/","title":"Interval Grouping","text":""},{"location":"EndlessCheng/interval_grouping/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2406. Divide Intervals Into Minimum Number of Groups (Medium)</li> <li> 253. Meeting Rooms II (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/interval_grouping/#2406-divide-intervals-into-minimum-number-of-groups","title":"2406. Divide Intervals Into Minimum Number of Groups","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Greedy, Sorting, Heap Priority Queue, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/interval_grouping/#253-meeting-rooms-ii","title":"253. Meeting Rooms II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Greedy, Sorting, Heap Priority Queue, Prefix Sum</p> </li> </ul> Python <pre><code>\"\"\"\n- Given an array of meeting time `intervals` where `intervals[i] = [start_i, end_i]`, return the minimum number of conference rooms required.\n\"\"\"\n\nimport heapq\nfrom typing import List\n\n\n# Heap\ndef minMeetingRooms(intervals: List[List[int]]) -&gt; int:\n    if not intervals:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n    minHeap = [intervals[0][1]]\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &gt;= minHeap[0]:\n            heapq.heappop(minHeap)\n        heapq.heappush(minHeap, intervals[i][1])\n\n    return len(minHeap)\n\n\nif __name__ == \"__main__\":\n    intervals = [[0, 30], [5, 10], [15, 20]]\n    assert minMeetingRooms(intervals) == 2\n</code></pre>"},{"location":"EndlessCheng/interval_selection/","title":"Interval Selection","text":""},{"location":"EndlessCheng/interval_selection/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 452. Minimum Number of Arrows to Burst Balloons (Medium)</li> <li> 757. Set Intersection Size At Least Two (Hard)</li> </ul>"},{"location":"EndlessCheng/interval_selection/#452-minimum-number-of-arrows-to-burst-balloons","title":"452. Minimum Number of Arrows to Burst Balloons","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the minimum number of arrows.\n\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/lPmkKnvNPrw?si=P0rkcvTOxRGoFpkG\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen&gt;&lt;/iframe&gt;\n\n-   Differece between two versions\n    1. Start from 1: if there is no overlap, we add one more arrow.\n    2. Start from the number of balloons: if there is overlap, we need to reduce one arrow.\n\"\"\"\n\nfrom typing import List\n\nimport matplotlib.pyplot as plt\n\n\n# Greedy - Interval\ndef findMinArrowShotsGreedy1(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    if n &lt;= 1:\n        return n\n\n    res = 1\n    points.sort(key=lambda x: x[0])\n\n    for i in range(1, n):\n        if points[i][0] &gt; points[i - 1][1]:\n            res += 1\n        else:\n            points[i][1] = min(points[i][1], points[i - 1][1])\n    return res\n\n\n# Greedy - Interval (Neetcode's version)\ndef findMinArrowShotsGreedy2(points: List[List[int]]) -&gt; int:\n    res = len(points)\n    if res == 0:\n        return 0\n\n    points.sort()\n    prev = points[0]\n\n    for i in range(1, len(points)):\n        cur = points[i]\n        if cur[0] &lt;= prev[1]:\n            res -= 1\n            prev = [cur[0], min(prev[1], cur[1])]\n        else:\n            prev = cur\n\n    return res\n\n\n# Greedy - Interval\ndef findMinArrowShotsGreedy3(points: List[List[int]]) -&gt; int:\n    if not points:\n        return 0\n\n    points.sort(key=lambda x: x[1])\n\n    res = 1\n    cur_end = points[0][1]\n\n    for i in range(1, len(points)):\n        if points[i][0] &gt; cur_end:\n            res += 1\n            cur_end = points[i][1]\n\n    return res\n\n\n# Utility\ndef plot(points, i=None):\n    plt.figure(figsize=(8, 4))\n    for idx in range(len(points)):\n        color = \"b\" if idx == i else \"k\"\n        plt.plot(\n            [points[idx][0], points[idx][1]],\n            [idx + 1, idx + 1],\n            f\"{color}o-\",\n            label=f\"Line {idx + 1}\",\n        )\n\n    plt.title(\"Find Min Arrow Shots\")\n    plt.xlabel(\"X-axis\")\n    plt.xlim(0, 17)\n    plt.grid(True)\n    plt.savefig(f\"find_min_arrow_shots_{i}.png\")\n    plt.show()\n\n\n# |------------|-----------|---------|\n# |  Approach  |  Time     |  Space  |\n# |------------|-----------|---------|\n# |  Greedy    |  O(NlogN) |  O(1)   |\n# |------------|-----------|---------|\n\n\npoints = [[10, 16], [2, 8], [1, 6], [7, 12]]\nprint(findMinArrowShotsGreedy1(points))  # 2\nprint(findMinArrowShotsGreedy2(points))  # 2\n</code></pre>"},{"location":"EndlessCheng/interval_selection/#757-set-intersection-size-at-least-two","title":"757. Set Intersection Size At Least Two","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/inversion_count/","title":"Inversion Count","text":""},{"location":"EndlessCheng/inversion_count/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 315. Count of Smaller Numbers After Self (Hard)</li> <li> 493. Reverse Pairs (Hard)</li> <li> 327. Count of Range Sum (Hard)</li> <li> 2426. Number of Pairs Satisfying Inequality (Hard)</li> <li> 1850. Minimum Adjacent Swaps to Reach the Kth Smallest Number (Medium)</li> <li> 2193. Minimum Number of Moves to Make Palindrome (Hard)</li> <li> 1885. Count Pairs in Two Arrays (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/inversion_count/#315-count-of-smaller-numbers-after-self","title":"315. Count of Smaller Numbers After Self","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Divide And Conquer, Binary Indexed Tree, Segment Tree, Merge Sort, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/inversion_count/#493-reverse-pairs","title":"493. Reverse Pairs","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Divide And Conquer, Binary Indexed Tree, Segment Tree, Merge Sort, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/inversion_count/#327-count-of-range-sum","title":"327. Count of Range Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Divide And Conquer, Binary Indexed Tree, Segment Tree, Merge Sort, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/inversion_count/#2426-number-of-pairs-satisfying-inequality","title":"2426. Number of Pairs Satisfying Inequality","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Divide And Conquer, Binary Indexed Tree, Segment Tree, Merge Sort, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/inversion_count/#1850-minimum-adjacent-swaps-to-reach-the-kth-smallest-number","title":"1850. Minimum Adjacent Swaps to Reach the Kth Smallest Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/inversion_count/#2193-minimum-number-of-moves-to-make-palindrome","title":"2193. Minimum Number of Moves to Make Palindrome","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Greedy, Binary Indexed Tree</p> </li> </ul>"},{"location":"EndlessCheng/inversion_count/#1885-count-pairs-in-two-arrays","title":"1885. Count Pairs in Two Arrays \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/lazy_deletion_heap/","title":"Lazy Deletion Heap","text":""},{"location":"EndlessCheng/lazy_deletion_heap/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2349. Design a Number Container System (Medium)</li> <li> 2353. Design a Food Rating System (Medium)</li> <li> 3092. Most Frequent IDs (Medium)</li> <li> 2034. Stock Price Fluctuation  (Medium)</li> <li> 1172. Dinner Plate Stacks (Hard)</li> </ul>"},{"location":"EndlessCheng/lazy_deletion_heap/#2349-design-a-number-container-system","title":"2349. Design a Number Container System","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Design, Heap Priority Queue, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/lazy_deletion_heap/#2353-design-a-food-rating-system","title":"2353. Design a Food Rating System","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Design, Heap Priority Queue, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/lazy_deletion_heap/#3092-most-frequent-ids","title":"3092. Most Frequent IDs","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Heap Priority Queue, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/lazy_deletion_heap/#2034-stock-price-fluctuation","title":"2034. Stock Price Fluctuation","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Design, Heap Priority Queue, Data Stream, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/lazy_deletion_heap/#1172-dinner-plate-stacks","title":"1172. Dinner Plate Stacks","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Stack, Design, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/lazy_segment_tree/","title":"Lazy Segment Tree","text":""},{"location":"EndlessCheng/lazy_segment_tree/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2589. Minimum Time to Complete All Tasks (Hard)</li> <li> 2569. Handling Sum Queries After Update (Hard)</li> <li> 1622. Fancy Sequence (Hard)</li> <li> 850. Rectangle Area II (Hard)</li> <li> 3454. Separate Squares II (Hard)</li> <li> 2916. Subarrays Distinct Element Sum of Squares II (Hard)</li> </ul>"},{"location":"EndlessCheng/lazy_segment_tree/#2589-minimum-time-to-complete-all-tasks","title":"2589. Minimum Time to Complete All Tasks","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Stack, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/lazy_segment_tree/#2569-handling-sum-queries-after-update","title":"2569. Handling Sum Queries After Update","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Segment Tree</p> </li> </ul>"},{"location":"EndlessCheng/lazy_segment_tree/#1622-fancy-sequence","title":"1622. Fancy Sequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Design, Segment Tree</p> </li> </ul>"},{"location":"EndlessCheng/lazy_segment_tree/#850-rectangle-area-ii","title":"850. Rectangle Area II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Segment Tree, Line Sweep, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/lazy_segment_tree/#3454-separate-squares-ii","title":"3454. Separate Squares II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Segment Tree, Line Sweep</p> </li> </ul>"},{"location":"EndlessCheng/lazy_segment_tree/#2916-subarrays-distinct-element-sum-of-squares-ii","title":"2916. Subarrays Distinct Element Sum of Squares II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Binary Indexed Tree, Segment Tree</p> </li> </ul>"},{"location":"EndlessCheng/least_common_multiple/","title":"Least Common Multiple","text":""},{"location":"EndlessCheng/least_common_multiple/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2413. Smallest Even Multiple (Easy)</li> <li> 3334. Find the Maximum Factor Score of Array (Medium)</li> <li> 2197. Replace Non-Coprime Numbers in Array (Hard)</li> <li> 2470. Number of Subarrays With LCM Equal to K (Medium)</li> </ul>"},{"location":"EndlessCheng/least_common_multiple/#2413-smallest-even-multiple","title":"2413. Smallest Even Multiple","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/least_common_multiple/#3334-find-the-maximum-factor-score-of-array","title":"3334. Find the Maximum Factor Score of Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/least_common_multiple/#2197-replace-non-coprime-numbers-in-array","title":"2197. Replace Non-Coprime Numbers in Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Stack, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/least_common_multiple/#2470-number-of-subarrays-with-lcm-equal-to-k","title":"2470. Number of Subarrays With LCM Equal to K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/lexicographically_smallest/","title":"Lexicographically Smallest","text":""},{"location":"EndlessCheng/lexicographically_smallest/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 402. Remove K Digits (Medium)</li> <li> 1673. Find the Most Competitive Subsequence (Medium)</li> <li> 316. Remove Duplicate Letters (Medium)</li> <li> 1081. Smallest Subsequence of Distinct Characters (Medium)</li> <li> 321. Create Maximum Number (Hard)</li> <li> 2030. Smallest K-Length Subsequence With Occurrences of a Letter (Hard)</li> </ul>"},{"location":"EndlessCheng/lexicographically_smallest/#402-remove-k-digits","title":"402. Remove K Digits","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack, Greedy, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/lexicographically_smallest/#1673-find-the-most-competitive-subsequence","title":"1673. Find the Most Competitive Subsequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Stack, Greedy, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/lexicographically_smallest/#316-remove-duplicate-letters","title":"316. Remove Duplicate Letters","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack, Greedy, Monotonic Stack</p> </li> </ul> Python <pre><code># Monotonic Stack\ndef removeDuplicateLetters(s: str) -&gt; str:\n    stack = []\n    seen = set()\n    last = {c: i for i, c in enumerate(s)}\n\n    for i, c in enumerate(s):\n        if c not in seen:\n            while stack and c &lt; stack[-1] and i &lt; last[stack[-1]]:\n                seen.discard(stack.pop())\n            seen.add(c)\n            stack.append(c)\n\n    return \"\".join(stack)\n\n\ns = \"cbacdcbc\"\nprint(removeDuplicateLetters(s))  # acdb\n</code></pre>"},{"location":"EndlessCheng/lexicographically_smallest/#1081-smallest-subsequence-of-distinct-characters","title":"1081. Smallest Subsequence of Distinct Characters","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack, Greedy, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/lexicographically_smallest/#321-create-maximum-number","title":"321. Create Maximum Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Stack, Greedy, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/lexicographically_smallest/#2030-smallest-k-length-subsequence-with-occurrences-of-a-letter","title":"2030. Smallest K-Length Subsequence With Occurrences of a Letter","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack, Greedy, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/lexicographically_smallest_largest/","title":"Lexicographically Smallest Largest","text":""},{"location":"EndlessCheng/lexicographically_smallest_largest/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1323. Maximum 69 Number (Easy)</li> <li> 3216. Lexicographically Smallest String After a Swap (Easy)</li> <li> 2697. Lexicographically Smallest Palindrome (Easy)</li> <li> 1881. Maximum Value after Insertion (Medium)</li> <li> 2734. Lexicographically Smallest String After Substring Operation (Medium)</li> <li> 1946. Largest Number After Mutating Substring (Medium)</li> <li> 1663. Smallest String With A Given Numeric Value (Medium)</li> <li> 1328. Break a Palindrome (Medium)</li> <li> 2259. Remove Digit From Number to Maximize Result (Easy)</li> <li> 2566. Maximum Difference by Remapping a Digit (Easy)</li> <li> 670. Maximum Swap (Medium)</li> <li> 3106. Lexicographically Smallest String After Operations With Constraint (Medium)</li> <li> 1053. Previous Permutation With One Swap (Medium)</li> <li> 2375. Construct Smallest Number From DI String (Medium)</li> <li> 2182. Construct String With Repeat Limit (Medium)</li> <li> 738. Monotone Increasing Digits (Medium)</li> <li> 3403. Find the Lexicographically Largest String From the Box I (Medium)</li> <li> 3170. Lexicographically Minimum String After Removing Stars (Medium)</li> <li> 1363. Largest Multiple of Three (Hard)</li> <li> 1754. Largest Merge Of Two Strings (Medium)</li> <li> 1202. Smallest String With Swaps (Medium)</li> <li> 2434. Using a Robot to Print the Lexicographically Smallest String (Medium)</li> <li> 1625. Lexicographically Smallest String After Applying Operations (Medium)</li> <li> 2948. Make Lexicographically Smallest Array by Swapping Elements (Medium)</li> <li> 564. Find the Closest Palindrome (Hard)</li> <li> 1505. Minimum Possible Integer After at Most K Adjacent Swaps On Digits (Hard)</li> <li> 2663. Lexicographically Smallest Beautiful String (Hard)</li> <li> 3302. Find the Lexicographically Smallest Valid Sequence (Medium)</li> <li> 555. Split Concatenated Strings (Medium) \ud83d\udc51</li> <li> 3088. Make String Anti-palindrome (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/lexicographically_smallest_largest/#1323-maximum-69-number","title":"1323. Maximum 69 Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/lexicographically_smallest_largest/#3216-lexicographically-smallest-string-after-a-swap","title":"3216. Lexicographically Smallest String After a Swap","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/lexicographically_smallest_largest/#2697-lexicographically-smallest-palindrome","title":"2697. Lexicographically Smallest Palindrome","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Greedy</p> </li> </ul> Python <pre><code>def makeSmallestPalindrome(s: str) -&gt; str:\n    n = len(s)\n    s = list(s)\n    left, right = 0, n - 1\n\n    while left &lt; right:\n        if s[left] &lt; s[right]:\n            s[right] = s[left]\n        elif s[left] &gt; s[right]:\n            s[left] = s[right]\n        left += 1\n        right -= 1\n\n    return \"\".join(s)\n\n\ns = \"egcfe\"\nprint(makeSmallestPalindrome(s))  # \"efcfe\"\n</code></pre>"},{"location":"EndlessCheng/lexicographically_smallest_largest/#1881-maximum-value-after-insertion","title":"1881. Maximum Value after Insertion","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/lexicographically_smallest_largest/#2734-lexicographically-smallest-string-after-substring-operation","title":"2734. Lexicographically Smallest String After Substring Operation","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/lexicographically_smallest_largest/#1946-largest-number-after-mutating-substring","title":"1946. Largest Number After Mutating Substring","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/lexicographically_smallest_largest/#1663-smallest-string-with-a-given-numeric-value","title":"1663. Smallest String With A Given Numeric Value","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/lexicographically_smallest_largest/#1328-break-a-palindrome","title":"1328. Break a Palindrome","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Greedy</p> </li> </ul> Python <pre><code># Greedy\ndef breakPalindrome(palindrome: str) -&gt; str:\n    n = len(palindrome)\n    if n == 1:\n        return \"\"\n\n    for i in range(n // 2):\n        if palindrome[i] != \"a\":\n            return palindrome[:i] + \"a\" + palindrome[i + 1 :]\n\n    return palindrome[:-1] + \"b\"\n\n\npalindrome = \"abccba\"\nprint(breakPalindrome(palindrome))  # \"aaccba\"\n</code></pre>"},{"location":"EndlessCheng/lexicographically_smallest_largest/#2259-remove-digit-from-number-to-maximize-result","title":"2259. Remove Digit From Number to Maximize Result","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Greedy, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/lexicographically_smallest_largest/#2566-maximum-difference-by-remapping-a-digit","title":"2566. Maximum Difference by Remapping a Digit","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/lexicographically_smallest_largest/#670-maximum-swap","title":"670. Maximum Swap","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/lexicographically_smallest_largest/#3106-lexicographically-smallest-string-after-operations-with-constraint","title":"3106. Lexicographically Smallest String After Operations With Constraint","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/lexicographically_smallest_largest/#1053-previous-permutation-with-one-swap","title":"1053. Previous Permutation With One Swap","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/lexicographically_smallest_largest/#2375-construct-smallest-number-from-di-string","title":"2375. Construct Smallest Number From DI String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Backtracking, Stack, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/lexicographically_smallest_largest/#2182-construct-string-with-repeat-limit","title":"2182. Construct String With Repeat Limit","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Greedy, Heap Priority Queue, Counting</p> </li> </ul>"},{"location":"EndlessCheng/lexicographically_smallest_largest/#738-monotone-increasing-digits","title":"738. Monotone Increasing Digits","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Greedy</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the largest number that is less than or equal to `n` with monotone increasing digits.\n\"\"\"\n\n\n# Greedy\ndef monotoneIncreasingDigits(n: int) -&gt; int:\n    strNum = list(str(n))\n\n    for i in range(len(strNum) - 2, -1, -1):\n        if int(strNum[i]) &gt; int(strNum[i + 1]):\n            strNum[i] = str(int(strNum[i]) - 1)\n            strNum[i + 1 :] = [\"9\"] * (len(strNum) - (i + 1))\n\n    return int(\"\".join(strNum))\n\n\nn = 332\nprint(monotoneIncreasingDigits(n))  # 299\n</code></pre>"},{"location":"EndlessCheng/lexicographically_smallest_largest/#3403-find-the-lexicographically-largest-string-from-the-box-i","title":"3403. Find the Lexicographically Largest String From the Box I","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Enumeration</p> </li> </ul> Python <pre><code># Lexicographically Smallest/Largest\ndef answerString(word: str, numFriends: int) -&gt; str:\n    if numFriends == 1:\n        return word\n\n    n = len(word)\n    return max(word[i : i + n - numFriends + 1] for i in range(n))\n\n\nif __name__ == \"__main__\":\n    assert answerString(\"dbca\", 2) == \"dbc\"\n</code></pre>"},{"location":"EndlessCheng/lexicographically_smallest_largest/#3170-lexicographically-minimum-string-after-removing-stars","title":"3170. Lexicographically Minimum String After Removing Stars","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Stack, Greedy, Heap Priority Queue</p> </li> </ul> Python <pre><code>from itertools import chain\n\n\n# Stack\ndef clearStars(s: str) -&gt; str:\n    stacks = [[] for _ in range(26)]\n    for i, c in enumerate(s):\n        if c != \"*\":\n            stacks[ord(c) - ord(\"a\")].append(i)\n            continue\n\n        for st in stacks:\n            if st:\n                st.pop()\n                break\n    return \"\".join(s[i] for i in sorted(chain.from_iterable(stacks)))\n\n\nif __name__ == \"__main__\":\n    assert clearStars(\"aaba*\") == \"aab\"\n</code></pre>"},{"location":"EndlessCheng/lexicographically_smallest_largest/#1363-largest-multiple-of-three","title":"1363. Largest Multiple of Three","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/lexicographically_smallest_largest/#1754-largest-merge-of-two-strings","title":"1754. Largest Merge Of Two Strings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/lexicographically_smallest_largest/#1202-smallest-string-with-swaps","title":"1202. Smallest String With Swaps","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Depth First Search, Breadth First Search, Union Find, Sorting</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef smallestStringWithSwaps(s: str, pairs: List[List[int]]) -&gt; str:\n    n = len(s)\n    par = list(range(n))\n    components = defaultdict(list)\n\n    def find(node):\n        p = par[node]\n        while par[p] != p:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 != p2:\n            par[p1] = p2\n\n    for index, j in pairs:\n        union(index, j)\n\n    for index in range(n):\n        components[find(index)].append(index)\n\n    res = list(s)\n    for indices in components.values():\n        chars = sorted([s[index] for index in indices])\n        for index, char in zip(indices, chars):\n            res[index] = char\n\n    return \"\".join(res)\n\n\ns = \"dcab\"\npairs = [[0, 3], [1, 2]]\nprint(smallestStringWithSwaps(s, pairs))  # \"bacd\"\n</code></pre>"},{"location":"EndlessCheng/lexicographically_smallest_largest/#2434-using-a-robot-to-print-the-lexicographically-smallest-string","title":"2434. Using a Robot to Print the Lexicographically Smallest String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Stack, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/lexicographically_smallest_largest/#1625-lexicographically-smallest-string-after-applying-operations","title":"1625. Lexicographically Smallest String After Applying Operations","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Depth First Search, Breadth First Search, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/lexicographically_smallest_largest/#2948-make-lexicographically-smallest-array-by-swapping-elements","title":"2948. Make Lexicographically Smallest Array by Swapping Elements","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Union Find, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/lexicographically_smallest_largest/#564-find-the-closest-palindrome","title":"564. Find the Closest Palindrome","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String</p> </li> </ul>"},{"location":"EndlessCheng/lexicographically_smallest_largest/#1505-minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits","title":"1505. Minimum Possible Integer After at Most K Adjacent Swaps On Digits","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Greedy, Binary Indexed Tree, Segment Tree</p> </li> </ul>"},{"location":"EndlessCheng/lexicographically_smallest_largest/#2663-lexicographically-smallest-beautiful-string","title":"2663. Lexicographically Smallest Beautiful String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/lexicographically_smallest_largest/#3302-find-the-lexicographically-smallest-valid-sequence","title":"3302. Find the Lexicographically Smallest Valid Sequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Dynamic Programming, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/lexicographically_smallest_largest/#555-split-concatenated-strings","title":"555. Split Concatenated Strings \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/lexicographically_smallest_largest/#3088-make-string-anti-palindrome","title":"3088. Make String Anti-palindrome \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Greedy, Sorting, Counting Sort</p> </li> </ul>"},{"location":"EndlessCheng/linked_list_applications/","title":"Linked List Applications","text":""},{"location":"EndlessCheng/linked_list_applications/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1019. Next Greater Node In Linked List (Medium)</li> <li> 1171. Remove Zero Sum Consecutive Nodes from Linked List (Medium)</li> <li> 707. Design Linked List (Medium)</li> <li> 146. LRU Cache (Medium)</li> <li> 460. LFU Cache (Hard)</li> <li> 432. All O`one Data Structure (Hard)</li> <li> 1206. Design Skiplist (Hard)</li> </ul>"},{"location":"EndlessCheng/linked_list_applications/#1019-next-greater-node-in-linked-list","title":"1019. Next Greater Node In Linked List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Linked List, Stack, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/linked_list_applications/#1171-remove-zero-sum-consecutive-nodes-from-linked-list","title":"1171. Remove Zero Sum Consecutive Nodes from Linked List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Linked List</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom leetpattern.utils import ListNode\n\n\n# Prefix Sum\ndef removeZeroSumSublists(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    dummy = ListNode(0)\n    dummy.next = head\n    cur = head\n    prefix_sum = 0\n    seen = {0: dummy}\n\n    while cur:\n        prefix_sum += cur.val\n        if prefix_sum in seen:\n            node = seen[prefix_sum].next\n            temp_sum = prefix_sum\n            while node != cur:\n                temp_sum += node.val\n                del seen[temp_sum]\n                node = node.next\n            seen[prefix_sum].next = cur.next\n        else:\n            seen[prefix_sum] = cur\n        cur = cur.next\n\n    return dummy.next\n\n\nhead = ListNode().create([1, 2, -3, 3, 1])\nprint(removeZeroSumSublists(head))  # 3 -&gt; 1\n</code></pre>"},{"location":"EndlessCheng/linked_list_applications/#707-design-linked-list","title":"707. Design Linked List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Design</p> </li> </ul> Python <pre><code>\"\"\"\n-   Design your implementation of the linked list. You can choose to use a singly or doubly linked list.\n\"\"\"\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass MyLinkedList:\n\n    def __init__(self):\n        self.dummy = ListNode()\n        self.size = 0\n\n    def get(self, index: int) -&gt; int:\n        if index &lt; 0 or index &gt;= self.size:\n            return -1\n\n        current = self.dummy.next\n        for _ in range(index):\n            current = current.next\n\n        return current.val\n\n    def addAtHead(self, val: int) -&gt; None:\n        self.dummy.next = ListNode(val, self.dummy.next)\n        self.size += 1\n\n    def addAtTail(self, val: int) -&gt; None:\n        current = self.dummy\n        while current.next:\n            current = current.next\n        current.next = ListNode(val)\n        self.size += 1\n\n    def addAtIndex(self, index: int, val: int) -&gt; None:\n        if index &lt; 0 or index &gt; self.size:\n            return\n\n        current = self.dummy\n        for i in range(index):\n            current = current.next\n        current.next = ListNode(val, current.next)\n        self.size += 1\n\n    def deleteAtIndex(self, index: int) -&gt; None:\n        if index &lt; 0 or index &gt;= self.size:\n            return\n\n        current = self.dummy\n        for i in range(index):\n            current = current.next\n        current.next = current.next.next\n        self.size -= 1\n\n\nll = MyLinkedList()\nll.addAtHead(1)\nll.addAtTail(3)\nll.addAtIndex(1, 2)  # 1 -&gt; 2 -&gt; 3\nprint(ll.get(1))  # 2\n</code></pre>"},{"location":"EndlessCheng/linked_list_applications/#146-lru-cache","title":"146. LRU Cache","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Linked List, Design, Doubly Linked List</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Design and implement a data structure for **Least Recently Used (LRU) cache**. It should support the following operations: get and put.\n- [lru](https://media.geeksforgeeks.org/wp-content/uploads/20240909142802/Working-of-LRU-Cache-copy-2.webp)\n- ![146](https://miro.medium.com/v2/resize:fit:650/0*fOwBd3z0XtHh7WN1.png)\n\n| Data structure     | Description                   |\n| ------------------ | ----------------------------- |\n| Doubly Linked List | To store the key-value pairs. |\n| Hash Map           | To store the key-node pairs.  |\n\"\"\"\n\nfrom collections import OrderedDict\n\n\n# Doubly Linked List\nclass Node:\n    def __init__(self, key=0, val=0):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.cache = {}\n        self.head = Node()\n        self.tail = Node()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def add_to_last(self, node):\n        self.tail.prev.next = node\n        node.prev = self.tail.prev\n        node.next = self.tail\n        self.tail.prev = node\n\n    def move_to_last(self, node):\n        self.remove(node)\n        self.add_to_last(node)\n\n    def get(self, key: int) -&gt; int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self.move_to_last(node)\n        return node.val\n\n    def put(self, key: int, value: int) -&gt; None:\n        if key in self.cache:\n            node = self.cache[key]\n            node.val = value\n            self.move_to_last(node)\n            return None\n\n        if len(self.cache) == self.cap:\n            del self.cache[self.head.next.key]\n            self.remove(self.head.next)\n\n        node = Node(key=key, val=value)\n        self.cache[key] = node\n        self.add_to_last(node)\n\n\n# OrderedDict\nclass LRUCacheOrderedDict:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.cap = capacity\n\n    def get(self, key: int):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key, last=True)\n        return self.cache[key]\n\n    def put(self, key: int, value: int):\n        if key in self.cache:\n            self.cache.move_to_end(key, last=True)\n        elif len(self.cache) &gt;= self.cap:\n            self.cache.popitem(last=False)\n\n        self.cache[key] = value\n\n\ncache = LRUCache(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\n\ncache = LRUCacheOrderedDict(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\nprint(\"LRU Cache passed\")\nprint(\"LRU Cache Ordered Dict passed\")\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nclass Node {\n   public:\n    int key;\n    int val;\n    Node *prev;\n    Node *next;\n\n    Node(int k = 0, int v = 0) : key(k), val(v), prev(nullptr), next(nullptr) {}\n};\n\nclass LRUCache {\n   private:\n    int cap;\n    unordered_map&lt;int, Node *&gt; cache;\n    Node *head;\n    Node *tail;\n\n    void remove(Node *node) {\n        node-&gt;prev-&gt;next = node-&gt;next;\n        node-&gt;next-&gt;prev = node-&gt;prev;\n    }\n\n    void insert_to_last(Node *node) {\n        tail-&gt;prev-&gt;next = node;\n        node-&gt;prev = tail-&gt;prev;\n        tail-&gt;prev = node;\n        node-&gt;next = tail;\n    }\n\n    void move_to_last(Node *node) {\n        remove(node);\n        insert_to_last(node);\n    }\n\n   public:\n    LRUCache(int capacity) {\n        this-&gt;cap = capacity;\n        head = new Node();\n        tail = new Node();\n        head-&gt;next = tail;\n        tail-&gt;prev = head;\n    }\n\n    int get(int key) {\n        if (cache.find(key) != cache.end()) {\n            Node *node = cache[key];\n            move_to_last(node);\n            return node-&gt;val;\n        }\n        return -1;\n    }\n\n    void put(int key, int value) {\n        if (cache.find(key) != cache.end()) {\n            Node *node = cache[key];\n            node-&gt;val = value;\n            move_to_last(node);\n        } else {\n            Node *newNode = new Node(key, value);\n            cache[key] = newNode;\n            insert_to_last(newNode);\n\n            if ((int)cache.size() &gt; cap) {\n                Node *removed = head-&gt;next;\n                remove(removed);\n                cache.erase(removed-&gt;key);\n                delete removed;\n            }\n        }\n    }\n};\n\nint main() {\n    LRUCache lru(2);\n    lru.put(1, 1);\n    lru.put(2, 2);\n    assert(lru.get(1) == 1);   // returns 1\n    lru.put(3, 3);             // evicts key 2\n    assert(lru.get(2) == -1);  // returns -1 (not found)\n    lru.put(4, 4);             // evicts key 1\n    assert(lru.get(1) == -1);  // returns -1 (not found)\n    assert(lru.get(3) == 3);   // returns 3\n    assert(lru.get(4) == 4);   // returns 4\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/linked_list_applications/#460-lfu-cache","title":"460. LFU Cache","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Linked List, Design, Doubly Linked List</p> </li> </ul> Python <pre><code>from collections import OrderedDict, defaultdict\n\n\nclass LFUCache:\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        # key -&gt; [val, freq]\n        self.key_to_val_freq = {}\n        # freq -&gt; OrderedDict of keys\n        self.freq_to_keys = defaultdict(OrderedDict)\n        self.min_freq = 0\n\n    def remove_least_frequent(self):\n\n        lfu_key, _ = self.freq_to_keys[self.min_freq].popitem(last=False)\n        del self.key_to_val_freq[lfu_key]\n\n        # If the frequency list is empty after removal, delete it\n        if not self.freq_to_keys[self.min_freq]:\n            del self.freq_to_keys[self.min_freq]\n\n    def update_freq(self, key):\n        \"\"\"Updates the frequency of an existing key.\"\"\"\n        value, freq = self.key_to_val_freq[key]\n\n        # Remove key from current frequency group\n        del self.freq_to_keys[freq][key]\n        if not self.freq_to_keys[freq]:\n            del self.freq_to_keys[freq]\n            if self.min_freq == freq:\n                self.min_freq += 1\n\n        # Update key frequency\n        new_freq = freq + 1\n        self.key_to_val_freq[key] = [value, new_freq]\n        self.freq_to_keys[new_freq][key] = None\n\n    def add_new_key(self, key, value):\n        if len(self.key_to_val_freq) &gt;= self.cap:\n            self.remove_least_frequent()\n\n        # Insert the new key with frequency 1\n        self.key_to_val_freq[key] = [value, 1]\n        self.freq_to_keys[1][key] = None\n        self.min_freq = 1\n\n    def get(self, key: int) -&gt; int:\n        if key not in self.key_to_val_freq:\n            return -1\n        self.update_freq(key)\n        return self.key_to_val_freq[key][0]\n\n    def put(self, key: int, value: int) -&gt; None:\n        if self.cap == 0:\n            return\n\n        if key in self.key_to_val_freq:\n            self.key_to_val_freq[key][0] = value\n            self.update_freq(key)\n        else:\n            self.add_new_key(key, value)\n\n\nlfu = LFUCache(2)\nlfu.put(1, 1)\nlfu.put(2, 2)\nprint(lfu.get(1))  # 1\nlfu.put(3, 3)\nprint(lfu.get(2))  # -1\nprint(lfu.get(3))  # 3\nlfu.put(4, 4)\nprint(lfu.get(1))  # -1\nprint(lfu.get(3))  # 3\n</code></pre>"},{"location":"EndlessCheng/linked_list_applications/#432-all-oone-data-structure","title":"432. All O`one Data Structure","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Linked List, Design, Doubly Linked List</p> </li> </ul>"},{"location":"EndlessCheng/linked_list_applications/#1206-design-skiplist","title":"1206. Design Skiplist","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Design</p> </li> </ul>"},{"location":"EndlessCheng/linked_list_delete_nodes/","title":"Linked List Delete Nodes","text":""},{"location":"EndlessCheng/linked_list_delete_nodes/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 203. Remove Linked List Elements (Easy)</li> <li> 3217. Delete Nodes From Linked List Present in Array (Medium)</li> <li> 83. Remove Duplicates from Sorted List (Easy)</li> <li> 82. Remove Duplicates from Sorted List II (Medium)</li> <li> 237. Delete Node in a Linked List (Medium)</li> <li> 1669. Merge In Between Linked Lists (Medium)</li> <li> 2487. Remove Nodes From Linked List (Medium)</li> <li> 1836. Remove Duplicates From an Unsorted Linked List (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/linked_list_delete_nodes/#203-remove-linked-list-elements","title":"203. Remove Linked List Elements","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Recursion</p> </li> </ul> Python <pre><code>\"\"\"\n-   Remove all elements from a linked list of integers that have value `val`.\n\"\"\"\n\nfrom typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\n# Iterative\ndef removeElements(head: Optional[ListNode], val: int) -&gt; Optional[ListNode]:\n    dummy = ListNode(0)\n    dummy.next = head\n    cur = dummy\n\n    while cur.next:\n        if cur.next.val == val:\n            cur.next = cur.next.next\n        else:\n            cur = cur.next\n\n    return dummy.next\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |  Iterative  |      O(N)       |    O(1)      |\n# |-------------|-----------------|--------------|\n\n\ndef test_removeElements():\n    # Test case 1: Remove elements from middle and end\n    nums = [1, 2, 6, 3, 4, 5, 6]\n    val = 6\n    ll = LinkedList(nums)\n    assert ll.to_array() == [1, 2, 6, 3, 4, 5, 6]\n    result = removeElements(ll.head, val)\n    ll_result = LinkedList(result)\n    assert ll_result.to_array() == [1, 2, 3, 4, 5]\n\n    # Test case 2: Remove all elements\n    ll2 = LinkedList([7, 7, 7, 7])\n    result2 = removeElements(ll2.head, 7)\n    assert result2 is None\n\n    # Test case 3: Remove elements from beginning\n    ll3 = LinkedList([1, 1, 2, 3, 4])\n    result3 = removeElements(ll3.head, 1)\n    ll_result3 = LinkedList(result3)\n    assert ll_result3.to_array() == [2, 3, 4]\n\n    # Test case 4: No elements to remove\n    ll4 = LinkedList([1, 2, 3, 4])\n    result4 = removeElements(ll4.head, 5)\n    ll_result4 = LinkedList(result4)\n    assert ll_result4.to_array() == [1, 2, 3, 4]\n</code></pre>"},{"location":"EndlessCheng/linked_list_delete_nodes/#3217-delete-nodes-from-linked-list-present-in-array","title":"3217. Delete Nodes From Linked List Present in Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Linked List</p> </li> </ul> Python <pre><code>from typing import List, Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\ndef modified_list(nums: List[int], head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    num_set = set(nums)\n    dummy = ListNode(0, head)\n    cur = dummy\n\n    while cur.next:\n        if cur.next.val in num_set:\n            cur.next = cur.next.next\n        else:\n            cur = cur.next\n\n    return dummy.next\n\n\ndef test_modified_list():\n    ll = LinkedList([1, 2, 3, 4, 5])\n    ll = LinkedList(modified_list([2, 3], ll.head))\n    assert ll.to_array() == [1, 4, 5]\n</code></pre>"},{"location":"EndlessCheng/linked_list_delete_nodes/#83-remove-duplicates-from-sorted-list","title":"83. Remove Duplicates from Sorted List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom leetpattern.utils import ListNode\n\n\n# Linked List\ndef deleteDuplicates(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    if not head:\n        return None\n\n    cur = head\n    while cur.next:\n        if cur.next.val == cur.val:\n            cur.next = cur.next.next\n        else:\n            cur = cur.next\n\n    return head\n\n\nhead = ListNode().create([1, 1, 2, 3, 3])\nprint(deleteDuplicates(head))  # 1 -&gt; 2 -&gt; 3\n</code></pre>"},{"location":"EndlessCheng/linked_list_delete_nodes/#82-remove-duplicates-from-sorted-list-ii","title":"82. Remove Duplicates from Sorted List II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Two Pointers</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom leetpattern.utils import ListNode\n\n\n# Linked List\ndef deleteDuplicates(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    dummy = ListNode(0, head)\n    cur = dummy\n\n    while cur.next and cur.next.next:\n        val = cur.next.val\n        if cur.next.next.val == val:\n            while cur.next and cur.next.val == val:\n                cur.next = cur.next.next\n        else:\n            cur = cur.next\n\n    return dummy.next\n\n\nhead = ListNode().create([1, 1, 2, 3, 3, 4, 5])\nprint(deleteDuplicates(head))  # 2 -&gt; 4 -&gt; 5\n</code></pre>"},{"location":"EndlessCheng/linked_list_delete_nodes/#237-delete-node-in-a-linked-list","title":"237. Delete Node in a Linked List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List</p> </li> </ul> Python <pre><code>\"\"\"\n-   Delete a node in a singly linked list. You are given only the node to be deleted.\n\"\"\"\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\ndef deleteNode(node: ListNode) -&gt; None:\n    node.val = node.next.val\n    node.next = node.next.next\n\n\ndef test_deleteNode():\n    # Test case 1: Delete middle node\n    ll = LinkedList([4, 5, 1, 9])\n    assert ll.to_array() == [4, 5, 1, 9]\n    node = ll.head.next  # node with value 5\n    deleteNode(node)\n    assert ll.to_array() == [4, 1, 9]\n\n    # Test case 2: Delete another middle node\n    ll2 = LinkedList([4, 5, 1, 9])\n    node2 = ll2.head.next.next  # node with value 1\n    deleteNode(node2)\n    assert ll2.to_array() == [4, 5, 9]\n</code></pre>"},{"location":"EndlessCheng/linked_list_delete_nodes/#1669-merge-in-between-linked-lists","title":"1669. Merge In Between Linked Lists","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List</p> </li> </ul>"},{"location":"EndlessCheng/linked_list_delete_nodes/#2487-remove-nodes-from-linked-list","title":"2487. Remove Nodes From Linked List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Stack, Recursion, Monotonic Stack</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\ndef remove_nodes_recursive(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    if not head:\n        return None\n\n    head.next = remove_nodes_recursive(head.next)\n\n    if head.next and head.val &lt; head.next.val:\n        return head.next\n\n    return head\n\n\ndef remove_nodes_iterative(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    stack = []\n    cur = head\n\n    while cur:\n        while stack and cur.val &gt; stack[-1].val:\n            stack.pop()\n\n        stack.append(cur)\n        cur = cur.next\n\n    dummy = ListNode()\n    cur = dummy\n\n    for node in stack:\n        cur.next = node\n        cur = cur.next\n\n    return dummy.next\n\n\ndef test_remove_nodes() -&gt; None:\n    ll = LinkedList([5, 2, 13, 3, 8])\n    ll = LinkedList(remove_nodes_recursive(ll.head))\n    assert ll.to_array() == [13, 8]\n    ll = LinkedList([5, 2, 13, 3, 8])\n    ll = LinkedList(remove_nodes_iterative(ll.head))\n    assert ll.to_array() == [13, 8]\n</code></pre>"},{"location":"EndlessCheng/linked_list_delete_nodes/#1836-remove-duplicates-from-an-unsorted-linked-list","title":"1836. Remove Duplicates From an Unsorted Linked List \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Linked List</p> </li> </ul>"},{"location":"EndlessCheng/linked_list_divide_and_conquer/","title":"Linked List Divide and Conquer","text":""},{"location":"EndlessCheng/linked_list_divide_and_conquer/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 23. Merge k Sorted Lists (Hard)</li> <li> 148. Sort List (Medium)</li> </ul>"},{"location":"EndlessCheng/linked_list_divide_and_conquer/#23-merge-k-sorted-lists","title":"23. Merge k Sorted Lists","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Divide And Conquer, Heap Priority Queue, Merge Sort</p> </li> </ul> Python <pre><code>\"\"\"\n-   Prerequisite: 21. Merge Two Sorted Lists\n-   Video explanation: [23. Merge K Sorted Lists - NeetCode](https://youtu.be/q5a5OiGbT6Q?si=SQ2dCvsYQ3LQctPh)\n\"\"\"\n\nimport copy\nimport heapq\nfrom typing import List, Optional\n\nfrom leetpattern.utils import ListNode, list_from_array, list_to_array\n\n\ndef merge_k_lists_divide_conquer(\n    lists: List[Optional[ListNode]],\n) -&gt; Optional[ListNode]:\n    if not lists or len(lists) == 0:\n        return None\n\n    def mergeTwo(l1, l2):\n        dummy = ListNode()\n        cur = dummy\n\n        while l1 and l2:\n            if l1.val &lt; l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n\n            cur = cur.next\n\n        cur.next = l1 if l1 else l2\n\n        return dummy.next\n\n    while len(lists) &gt; 1:\n        merged = []\n\n        for i in range(0, len(lists), 2):\n            l1 = lists[i]\n            l2 = lists[i + 1] if i + 1 &lt; len(lists) else None\n            merged.append(mergeTwo(l1, l2))\n\n        lists = merged\n\n    return lists[0]\n\n\ndef merge_k_lists_heap(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    min_heap = []  # (val, idx, node)\n\n    for idx, head in enumerate(lists):\n        if head:\n            heapq.heappush(min_heap, (head.val, idx, head))\n\n    while min_heap:\n        _, idx, node = heapq.heappop(min_heap)\n        cur.next = node\n        cur = cur.next\n\n        node = node.next\n        if node:\n            heapq.heappush(min_heap, (node.val, idx, node))\n\n    return dummy.next\n\n\ndef test_merge_k_lists() -&gt; None:\n    n1 = list_from_array([1, 4])\n    n2 = list_from_array([1, 3])\n    n3 = list_from_array([2, 6])\n    lists = [n1, n2, n3]\n    lists1 = copy.deepcopy(lists)\n    lists2 = copy.deepcopy(lists)\n    assert (list_to_array(merge_k_lists_divide_conquer(lists1))) == [\n        1,\n        1,\n        2,\n        3,\n        4,\n        6,\n    ]\n    assert (list_to_array(merge_k_lists_heap(lists2))) == [1, 1, 2, 3, 4, 6]\n</code></pre>"},{"location":"EndlessCheng/linked_list_divide_and_conquer/#148-sort-list","title":"148. Sort List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Two Pointers, Divide And Conquer, Sorting, Merge Sort</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom leetpattern.utils import ListNode, list_from_array\n\n\n# Linked List\ndef sortListSort(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    nums = []\n\n    while head:\n        nums.append(head.val)\n        head = head.next\n\n    dummy = ListNode()\n    cur = dummy\n    nums.sort()\n\n    for num in nums:\n        cur.next = ListNode(val=num)\n        cur = cur.next\n\n    return dummy.next\n\n\n# Linked List\ndef sortListDivideConquer(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    def middle(node):\n        fast, slow = node, node\n        while fast and fast.next:\n            pre = slow\n            slow = slow.next\n            fast = fast.next.next\n        pre.next = None\n        return slow\n\n    def merge_two_lists(l1, l2):\n        dummy = ListNode()\n        cur = dummy\n        while l1 and l2:\n            if l1.val &lt; l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n            cur = cur.next\n\n        cur.next = l1 if l1 else l2\n        return dummy.next\n\n    if not head or not head.next:\n        return head\n\n    head2 = middle(head)\n    head = sortListDivideConquer(head)\n    head2 = sortListDivideConquer(head2)\n\n    return merge_two_lists(head, head2)\n\n\nhead = list_from_array([4, 2, 1, 3])\nprint(head)  # 4 -&gt; 2 -&gt; 1 -&gt; 3\nprint(sortListSort(head))  # 1 -&gt; 2 -&gt; 3 -&gt; 4\nprint(sortListDivideConquer(head))  # 1 -&gt; 2 -&gt; 3 -&gt; 4\n</code></pre>"},{"location":"EndlessCheng/linked_list_double_pointers/","title":"Linked List Double Pointers","text":""},{"location":"EndlessCheng/linked_list_double_pointers/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 328. Odd Even Linked List (Medium)</li> <li> 86. Partition List (Medium)</li> <li> 160. Intersection of Two Linked Lists (Easy)</li> </ul>"},{"location":"EndlessCheng/linked_list_double_pointers/#328-odd-even-linked-list","title":"328. Odd Even Linked List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List</p> </li> </ul>"},{"location":"EndlessCheng/linked_list_double_pointers/#86-partition-list","title":"86. Partition List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Two Pointers</p> </li> </ul>"},{"location":"EndlessCheng/linked_list_double_pointers/#160-intersection-of-two-linked-lists","title":"160. Intersection of Two Linked Lists","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Linked List, Two Pointers</p> </li> </ul> Python <pre><code>\"\"\"\n-   Find the node at which the intersection of two singly linked lists begins.\n\"\"\"\n\nfrom typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\n# Hash Set\ndef getIntersectionNodeHash(headA: ListNode, headB: ListNode) -&gt; Optional[ListNode]:\n    if not headA or not headB:\n        return None\n\n    visited = set()\n    cur = headA\n    while cur:\n        visited.add(cur)\n        cur = cur.next\n\n    cur = headB\n    while cur:\n        if cur in visited:\n            return cur\n        cur = cur.next\n\n    return None\n\n\n# Two Pointers\ndef getIntersectionNodeTP(headA: ListNode, headB: ListNode) -&gt; Optional[ListNode]:\n    if not headA or not headB:\n        return None\n\n    a, b = headA, headB\n\n    while a != b:\n        a = a.next if a else headB\n        b = b.next if b else headA\n\n    return a\n\n\ndef test_intersection():\n    # Test case 1: Lists with intersection\n    llA = LinkedList([4, 1, 8, 4, 5])\n    llB = LinkedList([5, 6, 1])\n\n    # Create intersection at node with value 8\n    nodeA = llA.head\n    while nodeA and nodeA.val != 8:\n        nodeA = nodeA.next\n\n    # Connect listB to the intersection point\n    llB.head.next.next.next = nodeA\n\n    assert llA.to_array() == [4, 1, 8, 4, 5]\n\n    intersection_hash = getIntersectionNodeHash(llA.head, llB.head)\n    intersection_tp = getIntersectionNodeTP(llA.head, llB.head)\n\n    assert intersection_hash is not None\n    assert intersection_tp is not None\n    assert intersection_hash.val == 8\n    assert intersection_tp.val == 8\n    assert intersection_hash == intersection_tp\n\n    # Test case 2: Lists without intersection\n    llC = LinkedList([2, 6, 4])\n    llD = LinkedList([1, 5])\n\n    intersection_hash = getIntersectionNodeHash(llC.head, llD.head)\n    intersection_tp = getIntersectionNodeTP(llC.head, llD.head)\n\n    assert intersection_hash is None\n    assert intersection_tp is None\n</code></pre>"},{"location":"EndlessCheng/linked_list_fast_slow_pointers/","title":"Linked List Fast Slow Pointers","text":""},{"location":"EndlessCheng/linked_list_fast_slow_pointers/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 876. Middle of the Linked List (Easy)</li> <li> 2095. Delete the Middle Node of a Linked List (Medium)</li> <li> 234. Palindrome Linked List (Easy)</li> <li> 2130. Maximum Twin Sum of a Linked List (Medium)</li> <li> 143. Reorder List (Medium)</li> <li> 141. Linked List Cycle (Easy)</li> <li> 142. Linked List Cycle II (Medium)</li> <li> 457. Circular Array Loop (Medium)</li> <li> 2674. Split a Circular Linked List (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/linked_list_fast_slow_pointers/#876-middle-of-the-linked-list","title":"876. Middle of the Linked List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Two Pointers</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\n# Linked List\ndef middleNode(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    fast, slow = head, head\n\n    while fast and fast.next:\n        fast = fast.next.next\n        slow = slow.next\n\n    return slow\n\n\ndef test_middleNode():\n    # Test case 1: Odd number of nodes\n    ll1 = LinkedList([1, 2, 3, 4, 5])\n    middle1 = middleNode(ll1.head)\n    result1 = LinkedList(middle1)\n    assert result1.to_array() == [3, 4, 5]\n\n    # Test case 2: Even number of nodes\n    ll2 = LinkedList([1, 2, 3, 4, 5, 6])\n    middle2 = middleNode(ll2.head)\n    result2 = LinkedList(middle2)\n    assert result2.to_array() == [4, 5, 6]\n\n    # Test case 3: Single node\n    ll3 = LinkedList([1])\n    middle3 = middleNode(ll3.head)\n    result3 = LinkedList(middle3)\n    assert result3.to_array() == [1]\n\n    # Test case 4: Two nodes\n    ll4 = LinkedList([1, 2])\n    middle4 = middleNode(ll4.head)\n    result4 = LinkedList(middle4)\n    assert result4.to_array() == [2]\n</code></pre>"},{"location":"EndlessCheng/linked_list_fast_slow_pointers/#2095-delete-the-middle-node-of-a-linked-list","title":"2095. Delete the Middle Node of a Linked List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Two Pointers</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\ndef deleteMiddle(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    fast, slow = head, head\n    dummy = ListNode(0, head)\n    cur = dummy\n\n    while fast and fast.next:\n        fast = fast.next.next\n        cur = cur.next\n        slow = slow.next\n\n    cur.next = slow.next\n\n    return dummy.next\n\n\ndef test_deleteMiddle():\n    ll = LinkedList([1, 3, 4, 7, 1, 2, 6])\n    ll = LinkedList(deleteMiddle(ll.head))\n    assert ll.to_array() == [1, 3, 4, 1, 2, 6]\n\n    ll = LinkedList([1, 2, 3, 4])\n    ll = LinkedList(deleteMiddle(ll.head))\n    assert ll.to_array() == [1, 2, 4]\n</code></pre>"},{"location":"EndlessCheng/linked_list_fast_slow_pointers/#234-palindrome-linked-list","title":"234. Palindrome Linked List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Two Pointers, Stack, Recursion</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom leetpattern.utils import ListNode\n\n\n# Linked List\ndef isPalindrome(head: Optional[ListNode]) -&gt; bool:\n    if not head or not head.next:\n        return True\n\n    def middle(node):\n        fast, slow = node, node\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n        return slow\n\n    def reverse(node):\n        cur, pre = node, None\n        while cur:\n            nxt = cur.next\n            cur.next = pre\n            pre = cur\n            cur = nxt\n        return pre\n\n    mid1 = head\n    mid2 = reverse(middle(head))\n\n    while mid2:\n        if mid1.val != mid2.val:\n            return False\n        mid1 = mid1.next\n        mid2 = mid2.next\n\n    return True\n\n\nhead = ListNode().create([1, 2, 2, 1])\nprint(isPalindrome(head))  # True\n</code></pre>"},{"location":"EndlessCheng/linked_list_fast_slow_pointers/#2130-maximum-twin-sum-of-a-linked-list","title":"2130. Maximum Twin Sum of a Linked List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Two Pointers, Stack</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom leetpattern.utils import ListNode\n\n\n# Linked List\ndef pairSum(head: Optional[ListNode]) -&gt; int:\n    def middle(node):\n        fast, slow = node, node\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n        return slow\n\n    def reverse(node):\n        cur, pre = node, None\n        while cur:\n            nxt = cur.next\n            cur.next = pre\n            pre = cur\n            cur = nxt\n        return pre\n\n    list1 = head\n    list2 = reverse(middle(head))\n    res = float(\"-inf\")\n\n    while list2:\n        res = max(res, list1.val + list2.val)\n        list1 = list1.next\n        list2 = list2.next\n\n    return res\n\n\nnode = ListNode().create([4, 2, 2, 3])\nprint(pairSum(node))  # 7\n</code></pre>"},{"location":"EndlessCheng/linked_list_fast_slow_pointers/#143-reorder-list","title":"143. Reorder List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Two Pointers, Stack, Recursion</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\n# Linked List\ndef reorderList(head: Optional[ListNode]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify head in-place instead.\n    \"\"\"\n    if not head or not head.next:\n        return\n\n    # Middle of the linked list\n    slow, fast = head, head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n    # Reverse the second half\n    pre, cur = None, slow\n    while cur:\n        temp = cur.next\n        cur.next = pre\n        pre = cur\n        cur = temp\n\n    # Merge two linked lists\n    first, second = head, pre\n    while second.next:\n        temp1, temp2 = first.next, second.next\n        first.next = second\n        second.next = temp1\n        first, second = temp1, temp2\n\n\ndef test_reorderList():\n    ll = LinkedList([1, 2, 3, 4, 5, 6])\n    assert ll.to_array() == [1, 2, 3, 4, 5, 6]\n    reorderList(ll.head)\n    assert ll.to_array() == [1, 6, 2, 5, 3, 4]\n\n    ll2 = LinkedList([1, 2, 3, 4, 5])\n    assert ll2.to_array() == [1, 2, 3, 4, 5]\n    reorderList(ll2.head)\n    assert ll2.to_array() == [1, 5, 2, 4, 3]\n</code></pre>"},{"location":"EndlessCheng/linked_list_fast_slow_pointers/#141-linked-list-cycle","title":"141. Linked List Cycle","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Linked List, Two Pointers</p> </li> </ul> PythonCPP <pre><code>from typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\ndef has_cycle(head: Optional[ListNode]) -&gt; bool:\n    slow, fast = head, head\n\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n        if slow == fast:\n            return True\n\n    return False\n\n\ndef test_has_cycle():\n    ll = LinkedList([3, 2, 0, -4])\n    ll.make_cycle(pos=1)\n    assert has_cycle(ll.head)\n\n    ll = LinkedList([1, 2])\n    ll.make_cycle(pos=0)\n    assert has_cycle(ll.head)\n\n    ll = LinkedList([1, 2, 3, 4, 5])\n    assert not has_cycle(ll.head)\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n\n#include \"include/lists.hpp\"\nusing namespace std;\n\nclass Solution {\n   public:\n    bool has_cycle(ListNode* head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while (fast &amp;&amp; fast-&gt;next) {\n            slow = slow-&gt;next;\n            fast = fast-&gt;next-&gt;next;\n\n            if (fast == slow) return true;\n        }\n        return false;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    ListNode* head = LinkedList::build({3, 2, 0, -4});\n    // create cycle\n    head = LinkedList::make_cycle(head, 1);\n    assert(solution.has_cycle(head) == true);\n    // no cycle\n    ListNode* head2 = LinkedList::build({1, 2});\n    assert(solution.has_cycle(head2) == false);\n    // no cycle\n    ListNode* head3 = LinkedList::build({1});\n    assert(solution.has_cycle(head3) == false);\n\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/linked_list_fast_slow_pointers/#142-linked-list-cycle-ii","title":"142. Linked List Cycle II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Linked List, Two Pointers</p> </li> </ul> PythonCPP <pre><code>from typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\ndef detectCycle(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    slow, fast = head, head\n\n    while fast and fast.next:\n        fast = fast.next.next\n        slow = slow.next\n\n        if slow == fast:\n            slow = head\n            while slow != fast:\n                slow = slow.next\n                fast = fast.next\n            return slow\n\n    return None\n\n\ndef test_detectCycle():\n    l1 = LinkedList([3, 2, 0, -4])\n    l1.make_cycle(1)\n    assert detectCycle(l1.head).val == 2\n    l2 = LinkedList([3, 2, 0, -4])\n    assert not detectCycle(l2.head)\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nclass Solution {\n   public:\n    ListNode* detectCycle(ListNode* head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while (fast &amp;&amp; fast-&gt;next) {\n            slow = slow-&gt;next;\n            fast = fast-&gt;next-&gt;next;\n\n            if (fast == slow) {\n                slow = head;\n                while (slow != fast) {\n                    slow = slow-&gt;next;\n                    fast = fast-&gt;next;\n                }\n                return slow;\n            }\n        }\n        return nullptr;\n    }\n};\n\nint main() {\n    Solution sol;\n\n    ListNode* head = new ListNode(3);\n    head-&gt;next = new ListNode(2);\n    head-&gt;next-&gt;next = new ListNode(0);\n    head-&gt;next-&gt;next-&gt;next = new ListNode(-4);\n    head-&gt;next-&gt;next-&gt;next-&gt;next = head-&gt;next;  // Create a cycle\n    assert(sol.detectCycle(head) == head-&gt;next);\n\n    ListNode* head2 = new ListNode(1);\n    head2-&gt;next = new ListNode(2);\n    head2-&gt;next-&gt;next = head2;  // Create a cycle\n    assert(sol.detectCycle(head2) == head2);\n\n    ListNode* head3 = new ListNode(1);\n    assert(sol.detectCycle(head3) == nullptr);\n\n    ListNode* head4 = nullptr;\n    assert(sol.detectCycle(head4) == nullptr);\n\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/linked_list_fast_slow_pointers/#457-circular-array-loop","title":"457. Circular Array Loop","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Two Pointers</p> </li> </ul>"},{"location":"EndlessCheng/linked_list_fast_slow_pointers/#2674-split-a-circular-linked-list","title":"2674. Split a Circular Linked List \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Two Pointers</p> </li> </ul>"},{"location":"EndlessCheng/linked_list_front_back_pointers/","title":"Linked List Front Back Pointers","text":""},{"location":"EndlessCheng/linked_list_front_back_pointers/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 19. Remove Nth Node From End of List (Medium)</li> <li> 61. Rotate List (Medium)</li> <li> 1721. Swapping Nodes in a Linked List (Medium)</li> <li> 1474. Delete N Nodes After M Nodes of a Linked List (Easy) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/linked_list_front_back_pointers/#19-remove-nth-node-from-end-of-list","title":"19. Remove Nth Node From End of List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Two Pointers</p> </li> </ul> Python <pre><code>\"\"\"\n-   Given the `head` of a linked list, remove the `n-th` node from the end of the list and return its head.\n\"\"\"\n\nfrom typing import Optional\n\nfrom leetpattern.utils import ListNode, list_from_array, list_to_array\n\n\n# Linked List\ndef removeNthFromEnd(head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:\n    dummy = ListNode(0, head)\n    fast, slow = dummy, dummy\n\n    for _ in range(n):\n        fast = fast.next\n\n    while fast.next:\n        fast = fast.next\n        slow = slow.next\n\n    slow.next = slow.next.next\n\n    return dummy.next\n\n\ndef test_removeNthFromEnd() -&gt; None:\n    head = list_from_array([1, 2, 3, 4, 5])\n    assert (list_to_array(removeNthFromEnd(head, 2))) == [1, 2, 3, 5]\n</code></pre>"},{"location":"EndlessCheng/linked_list_front_back_pointers/#61-rotate-list","title":"61. Rotate List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Two Pointers</p> </li> </ul>"},{"location":"EndlessCheng/linked_list_front_back_pointers/#1721-swapping-nodes-in-a-linked-list","title":"1721. Swapping Nodes in a Linked List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Two Pointers</p> </li> </ul>"},{"location":"EndlessCheng/linked_list_front_back_pointers/#1474-delete-n-nodes-after-m-nodes-of-a-linked-list","title":"1474. Delete N Nodes After M Nodes of a Linked List \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\ndef deleteNodes(head: Optional[ListNode], m: int, n: int) -&gt; Optional[ListNode]:\n    dummy = ListNode(0, head)\n    cur = dummy\n\n    while cur.next:\n        for _ in range(m):\n            if not cur.next:\n                break\n            cur = cur.next\n\n        for _ in range(n):\n            if not cur.next:\n                break\n            cur.next = cur.next.next\n\n    return dummy.next\n\n\ndef test_deleteMiddle():\n    ll = LinkedList(list(range(1, 14)))\n    assert ll.to_array() == list(range(1, 14))\n\n    ll = LinkedList(deleteNodes(ll.head, 2, 3))\n    assert ll.to_array() == [1, 2, 6, 7, 11, 12]\n</code></pre>"},{"location":"EndlessCheng/linked_list_insert_nodes/","title":"Linked List Insert Nodes","text":""},{"location":"EndlessCheng/linked_list_insert_nodes/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2807. Insert Greatest Common Divisors in Linked List (Medium)</li> <li> 147. Insertion Sort List (Medium)</li> <li> 708. Insert into a Sorted Circular Linked List (Medium) \ud83d\udc51</li> <li> 2046. Sort Linked List Already Sorted Using Absolute Values (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/linked_list_insert_nodes/#2807-insert-greatest-common-divisors-in-linked-list","title":"2807. Insert Greatest Common Divisors in Linked List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Math, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/linked_list_insert_nodes/#147-insertion-sort-list","title":"147. Insertion Sort List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/linked_list_insert_nodes/#708-insert-into-a-sorted-circular-linked-list","title":"708. Insert into a Sorted Circular Linked List \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List</p> </li> </ul>"},{"location":"EndlessCheng/linked_list_insert_nodes/#2046-sort-linked-list-already-sorted-using-absolute-values","title":"2046. Sort Linked List Already Sorted Using Absolute Values \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Two Pointers, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/linked_list_others/","title":"Linked List Others","text":""},{"location":"EndlessCheng/linked_list_others/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 138. Copy List with Random Pointer (Medium)</li> <li> 382. Linked List Random Node (Medium)</li> <li> 430. Flatten a Multilevel Doubly Linked List (Medium)</li> <li> 1265. Print Immutable Linked List in Reverse (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/linked_list_others/#138-copy-list-with-random-pointer","title":"138. Copy List with Random Pointer","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Linked List</p> </li> </ul> Python <pre><code>from typing import Optional\n\n\nclass Node:\n    def __init__(self, x: int, next: \"Node\" = None, random: \"Node\" = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\n\ndef copyRandomList(head: \"Optional[Node]\") -&gt; \"Optional[Node]\":\n    if not head:\n        return None\n\n    # Copy nodes and link them together\n    cur = head\n    while cur:\n        new_node = Node(cur.val)\n        new_node.next = cur.next\n        cur.next = new_node\n        cur = new_node.next\n\n    # Copy random pointers\n    cur = head\n    while cur:\n        cur.next.random = cur.random.next if cur.random else None\n        cur = cur.next.next\n\n    # Separate the original and copied lists\n    cur = head\n    new_head = head.next\n    while cur:\n        new_node = cur.next\n        cur.next = new_node.next\n        new_node.next = new_node.next.next if new_node.next else None\n        cur = cur.next\n\n    return new_head\n</code></pre>"},{"location":"EndlessCheng/linked_list_others/#382-linked-list-random-node","title":"382. Linked List Random Node","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Math, Reservoir Sampling, Randomized</p> </li> </ul>"},{"location":"EndlessCheng/linked_list_others/#430-flatten-a-multilevel-doubly-linked-list","title":"430. Flatten a Multilevel Doubly Linked List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Depth First Search, Doubly Linked List</p> </li> </ul>"},{"location":"EndlessCheng/linked_list_others/#1265-print-immutable-linked-list-in-reverse","title":"1265. Print Immutable Linked List in Reverse \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Two Pointers, Stack, Recursion</p> </li> </ul>"},{"location":"EndlessCheng/linked_list_reverse/","title":"Linked List Reverse","text":""},{"location":"EndlessCheng/linked_list_reverse/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 206. Reverse Linked List (Easy)</li> <li> 92. Reverse Linked List II (Medium)</li> <li> 24. Swap Nodes in Pairs (Medium)</li> <li> 25. Reverse Nodes in k-Group (Hard)</li> <li> 2074. Reverse Nodes in Even Length Groups (Medium)</li> </ul>"},{"location":"EndlessCheng/linked_list_reverse/#206-reverse-linked-list","title":"206. Reverse Linked List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Recursion</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\ndef reverse_list_iterative(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    cur = head\n    prev = None\n\n    while cur:\n        temp = cur.next\n        cur.next = prev\n\n        prev = cur\n        cur = temp\n\n    return prev\n\n\ndef reverse_list_recursive(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    def reverse(cur, prev):\n        if not cur:\n            return prev\n\n        temp = cur.next\n        cur.next = prev\n        return reverse(temp, cur)\n\n    return reverse(head, None)\n\n\ndef test_reverse_list():\n    ll = LinkedList([1, 2, 3, 4, 5])\n    ll.head = reverse_list_iterative(ll.head)\n    assert ll.to_array() == [5, 4, 3, 2, 1]\n\n    ll = LinkedList([1, 2, 3, 4, 5])\n    ll.head = reverse_list_recursive(ll.head)\n    assert ll.to_array() == [5, 4, 3, 2, 1]\n</code></pre>"},{"location":"EndlessCheng/linked_list_reverse/#92-reverse-linked-list-ii","title":"92. Reverse Linked List II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Reverse a linked list from position left to position right. Return the linked list after reversing.\n\"\"\"\n\nfrom typing import Optional\n\nfrom leetpattern.utils import ListNode, list_from_array, list_to_array\n\n\ndef reverseBetween(head: Optional[ListNode], left: int, right: int) -&gt; Optional[ListNode]:\n    dummy = ListNode(next=head)\n    p0 = dummy\n    for _ in range(left - 1):\n        if p0.next is None:\n            break\n        p0 = p0.next\n\n    pre = None\n    cur = p0.next\n    for _ in range(right - left + 1):\n        if not cur:\n            break\n        nxt = cur.next\n        cur.next = pre\n        pre = cur\n        cur = nxt\n\n    if p0.next:\n        p0.next.next = cur\n    p0.next = pre\n\n    return dummy.next\n\n\ndef test_reverse_between():\n    head = list_from_array([1, 2, 3, 4, 5])\n    left = 2\n    right = 4\n    result = reverseBetween(head, left, right)\n    assert list_to_array(result) == [1, 4, 3, 2, 5]\n\n    head = list_from_array([5])\n    left = 1\n    right = 1\n    result = reverseBetween(head, left, right)\n    assert list_to_array(result) == [5]\n\n    head = list_from_array([3, 5])\n    left = 1\n    right = 2\n    result = reverseBetween(head, left, right)\n    assert list_to_array(result) == [5, 3]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode* next) : val(x), next(next) {}\n};\n\nclass Solution {\n   public:\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\n        if (!head || left == right) return head;\n\n        ListNode dummy(0);\n        dummy.next = head;\n        ListNode* p0 = &amp;dummy;\n\n        for (int i = 0; i &lt; left - 1; ++i) {\n            p0 = p0-&gt;next;\n        }\n\n        ListNode* pre = nullptr;\n        ListNode* cur = p0-&gt;next;\n        int count = right - left + 1;\n\n        while (count--) {\n            ListNode* next = cur-&gt;next;\n            cur-&gt;next = pre;\n            pre = cur;\n            cur = next;\n        }\n\n        p0-&gt;next-&gt;next = cur;\n        p0-&gt;next = pre;\n\n        return dummy.next;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    ListNode* head1 = new ListNode(\n        1, new ListNode(2, new ListNode(3, new ListNode(4, new ListNode(5)))));\n    int left1 = 2, right1 = 4;\n    ListNode* result1 = solution.reverseBetween(head1, left1, right1);\n    ListNode* expected1 = new ListNode(\n        1, new ListNode(4, new ListNode(3, new ListNode(2, new ListNode(5)))));\n    for (ListNode *p = result1, *q = expected1; p != nullptr &amp;&amp; q != nullptr;\n         p = p-&gt;next, q = q-&gt;next) {\n        assert(p-&gt;val == q-&gt;val);\n    }\n\n    ListNode* head2 = new ListNode(5);\n    int left2 = 1, right2 = 1;\n    ListNode* result2 = solution.reverseBetween(head2, left2, right2);\n    ListNode* expected2 = new ListNode(5);\n    for (ListNode *p = result2, *q = expected2; p != nullptr &amp;&amp; q != nullptr;\n         p = p-&gt;next, q = q-&gt;next) {\n        assert(p-&gt;val == q-&gt;val);\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/linked_list_reverse/#24-swap-nodes-in-pairs","title":"24. Swap Nodes in Pairs","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Recursion</p> </li> </ul> Python <pre><code>\"\"\"\n-   Given a linked list, swap every two adjacent nodes and return its head.\n\"\"\"\n\nfrom typing import Optional\n\nfrom leetpattern.utils import ListNode, list_from_array, list_to_array\n\n\ndef swap_pairs(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    dummy = ListNode(0, head)\n    n0 = dummy\n    n1 = dummy.next\n\n    while n1 and n1.next:\n        n2 = n1.next\n        n3 = n2.next\n\n        n0.next = n2\n        n2.next = n1\n        n1.next = n3\n\n        n0 = n1\n        n1 = n3\n\n    return dummy.next\n\n\ndef test_swap_pairs():\n    head = list_from_array([1, 2, 3, 4, 5])\n    assert list_to_array(swap_pairs(head)) == [2, 1, 4, 3, 5]\n</code></pre>"},{"location":"EndlessCheng/linked_list_reverse/#25-reverse-nodes-in-k-group","title":"25. Reverse Nodes in k-Group","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Recursion</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom leetpattern.utils import ListNode, list_from_array, list_to_array\n\n\n# Linked List\ndef reverse_k_group(head: Optional[ListNode], k: int) -&gt; Optional[ListNode]:\n    n = 0\n    cur = head\n    while cur:\n        n += 1\n        cur = cur.next\n\n    p0 = dummy = ListNode(next=head)\n    pre = None\n    cur = head\n\n    while n &gt;= k:\n        n -= k\n        for _ in range(k):\n            nxt = cur.next\n            cur.next = pre\n            pre = cur\n            cur = nxt\n\n        nxt = p0.next\n        nxt.next = cur\n        p0.next = pre\n        p0 = nxt\n\n    return dummy.next\n\n\ndef test_reverse_k_group():\n    head = list_from_array([1, 2, 3, 4, 5])\n    assert list_to_array(reverse_k_group(head, 2)) == [2, 1, 4, 3, 5]\n</code></pre>"},{"location":"EndlessCheng/linked_list_reverse/#2074-reverse-nodes-in-even-length-groups","title":"2074. Reverse Nodes in Even Length Groups","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List</p> </li> </ul>"},{"location":"EndlessCheng/linked_list_traversal/","title":"Linked List Traversal","text":""},{"location":"EndlessCheng/linked_list_traversal/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1290. Convert Binary Number in a Linked List to Integer (Easy)</li> <li> 2058. Find the Minimum and Maximum Number of Nodes Between Critical Points (Medium)</li> <li> 2181. Merge Nodes in Between Zeros (Medium)</li> <li> 725. Split Linked List in Parts (Medium)</li> <li> 817. Linked List Components (Medium)</li> <li> 3062. Winner of the Linked List Game (Easy) \ud83d\udc51</li> <li> 3063. Linked List Frequency (Easy) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/linked_list_traversal/#1290-convert-binary-number-in-a-linked-list-to-integer","title":"1290. Convert Binary Number in a Linked List to Integer","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Math</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom leetpattern.utils import ListNode\n\n\n# Linked List\ndef getDecimalValue(head: Optional[ListNode]) -&gt; int:\n    res = 0\n\n    while head:\n        res = res * 2 + head.val\n        head = head.next\n\n    return res\n\n\nnode = ListNode().create([1, 0, 1])\nprint(node)  # 1 -&gt; 0 -&gt; 1\nprint(getDecimalValue(node))  # 5\n</code></pre>"},{"location":"EndlessCheng/linked_list_traversal/#2058-find-the-minimum-and-maximum-number-of-nodes-between-critical-points","title":"2058. Find the Minimum and Maximum Number of Nodes Between Critical Points","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List</p> </li> </ul> Python <pre><code>from typing import List, Optional\n\nfrom leetpattern.utils import ListNode\n\n\n# Linked List\ndef nodesBetweenCriticalPoints(head: Optional[ListNode]) -&gt; List[int]:\n    pre = head.val\n    cur = head.next\n    idx = 0\n    count = 0\n    res = []\n    mn = float(\"inf\")\n\n    while cur.next:\n        idx += 1\n        val = cur.val\n        if pre &gt; val and val &lt; cur.next.val:\n            res.append(idx)\n            count += 1\n        elif pre &lt; val and val &gt; cur.next.val:\n            res.append(idx)\n            count += 1\n\n        if count &gt;= 2:\n            mn = min(mn, res[-1] - res[-2])\n        pre = val\n        cur = cur.next\n\n    if count &gt;= 2:\n        return [mn, res[-1] - res[0]]\n    else:\n        return [-1, -1]\n\n\nnode = ListNode().create([5, 3, 1, 2, 5, 1, 2])\nprint(nodesBetweenCriticalPoints(node))  # [1, 3]\n</code></pre>"},{"location":"EndlessCheng/linked_list_traversal/#2181-merge-nodes-in-between-zeros","title":"2181. Merge Nodes in Between Zeros","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Simulation</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\ndef merge_nodes(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    if not head or not head.next:\n        return head\n\n    dummy = ListNode()\n    cur = dummy\n\n    head = head.next\n    temp = 0\n\n    while head.next:\n        if head.val == 0:\n            cur.next = ListNode(temp)\n            cur = cur.next\n            temp = 0\n        else:\n            temp += head.val\n\n        head = head.next\n\n    if temp != 0:\n        cur.next = ListNode(temp)\n\n    return dummy.next\n\n\ndef test_merge_nodes():\n    root = LinkedList([0, 3, 1, 0, 4, 5, 2, 0])\n    res = merge_nodes(root.head)\n    assert LinkedList(res).to_array() == [4, 11]\n</code></pre>"},{"location":"EndlessCheng/linked_list_traversal/#725-split-linked-list-in-parts","title":"725. Split Linked List in Parts","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List</p> </li> </ul>"},{"location":"EndlessCheng/linked_list_traversal/#817-linked-list-components","title":"817. Linked List Components","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Linked List</p> </li> </ul> Python <pre><code>from typing import List, Optional\n\nfrom leetpattern.utils import ListNode\n\n\n# Linked List\ndef numComponents(head: Optional[ListNode], nums: List[int]) -&gt; int:\n    numSet = set(nums)\n    res = 0\n\n    while head:\n        if head.val in numSet:\n            while head and head.val in numSet:\n                head = head.next\n            res += 1\n        else:\n            head = head.next\n\n    return res\n\n\nhead = ListNode().create([0, 1, 2, 3, 4])\nnums = [0, 3, 1, 4]\nprint(numComponents(head, nums))  # 2\n</code></pre>"},{"location":"EndlessCheng/linked_list_traversal/#3062-winner-of-the-linked-list-game","title":"3062. Winner of the Linked List Game \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List</p> </li> </ul>"},{"location":"EndlessCheng/linked_list_traversal/#3063-linked-list-frequency","title":"3063. Linked List Frequency \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Linked List, Counting</p> </li> </ul>"},{"location":"EndlessCheng/linked_lists_merge/","title":"Linked Lists Merge","text":""},{"location":"EndlessCheng/linked_lists_merge/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2. Add Two Numbers (Medium)</li> <li> 445. Add Two Numbers II (Medium)</li> <li> 2816. Double a Number Represented as a Linked List (Medium)</li> <li> 21. Merge Two Sorted Lists (Easy)</li> <li> 369. Plus One Linked List (Medium) \ud83d\udc51</li> <li> 1634. Add Two Polynomials Represented as Linked Lists (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/linked_lists_merge/#2-add-two-numbers","title":"2. Add Two Numbers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Math, Recursion</p> </li> </ul> PythonCPP <pre><code>from typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\ndef add_two_numbers(l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]:\n    \"\"\"Add two numbers represented by linked lists.\"\"\"\n    dummy = ListNode()\n    cur = dummy\n    carry = 0\n\n    while l1 or l2:\n        v1 = l1.val if l1 else 0\n        v2 = l2.val if l2 else 0\n\n        carry, val = divmod(v1 + v2 + carry, 10)\n        cur.next = ListNode(val)\n        cur = cur.next\n\n        if l1:\n            l1 = l1.next\n        if l2:\n            l2 = l2.next\n\n    if carry:\n        cur.next = ListNode(val=carry)\n\n    return dummy.next\n\n\ndef test_add_two_numbers():\n    l1 = LinkedList([2, 4, 3]).head\n    l2 = LinkedList([5, 6, 4]).head\n    added = add_two_numbers(l1, l2)\n    assert LinkedList(added).to_array() == [7, 0, 8]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode* next) : val(x), next(next) {}\n};\n\nclass Solution {\n   public:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode dummy;\n        ListNode* cur = &amp;dummy;\n        int carry = 0;\n\n        while (l1 || l2 || carry) {\n            if (l1) {\n                carry += l1-&gt;val;\n                l1 = l1-&gt;next;\n            }\n            if (l2) {\n                carry += l2-&gt;val;\n                l2 = l2-&gt;next;\n            }\n            cur-&gt;next = new ListNode(carry % 10);\n            cur = cur-&gt;next;\n            carry /= 10;\n        }\n        return dummy.next;\n    }\n};\n\nint main() {\n    Solution sol;\n\n    ListNode* l1 = new ListNode(2, new ListNode(4, new ListNode(3)));\n    ListNode* l2 = new ListNode(5, new ListNode(6, new ListNode(4)));\n    ListNode* result = sol.addTwoNumbers(l1, l2);\n\n    vector&lt;int&gt; expected = {7, 0, 8};\n    for (int val : expected) {\n        assert(result != nullptr &amp;&amp; result-&gt;val == val);\n        result = result-&gt;next;\n    }\n    assert(result == nullptr);  // End of list\n\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/linked_lists_merge/#445-add-two-numbers-ii","title":"445. Add Two Numbers II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Math, Stack</p> </li> </ul>"},{"location":"EndlessCheng/linked_lists_merge/#2816-double-a-number-represented-as-a-linked-list","title":"2816. Double a Number Represented as a Linked List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Math, Stack</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\ndef doubleIt(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n\n    def twice(node):\n        if not node:\n            return 0\n        doubled = node.val * 2 + twice(node.next)\n        node.val = doubled % 10\n        return doubled // 10\n\n    carry = twice(head)\n\n    if carry:\n        head = ListNode(val=carry, next=head)\n\n    return head\n\n\ndef test_doubleIt() -&gt; None:\n    ll = LinkedList([9, 9, 9])\n    ll = LinkedList(doubleIt(ll.head))\n    assert ll.to_array() == [1, 9, 9, 8]\n</code></pre>"},{"location":"EndlessCheng/linked_lists_merge/#21-merge-two-sorted-lists","title":"21. Merge Two Sorted Lists","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Recursion</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Task: Merge the two linked lists into one sorted list.\n\"\"\"\n\nfrom typing import Optional\n\nfrom leetpattern.utils import ListNode\n\n\n# Linked List\ndef merge_two_lists(\n    list1: Optional[ListNode], list2: Optional[ListNode]\n) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    while list1 and list2:\n        if list1.val &lt; list2.val:\n            cur.next = list1\n            list1 = list1.next\n        else:\n            cur.next = list2\n            list2 = list2.next\n        cur = cur.next\n\n    if list1:\n        cur.next = list1\n    elif list2:\n        cur.next = list2\n\n    return dummy.next\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode* next) : val(x), next(next) {}\n};\n\nclass Solution {\n   public:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        ListNode dummy;\n        ListNode* cur = &amp;dummy;\n\n        while (list1 &amp;&amp; list2) {\n            if (list1-&gt;val &lt; list2-&gt;val) {\n                cur-&gt;next = list1;\n                list1 = list1-&gt;next;\n            } else {\n                cur-&gt;next = list2;\n                list2 = list2-&gt;next;\n            }\n            cur = cur-&gt;next;\n        }\n\n        cur-&gt;next = list1 ? list1 : list2;\n\n        return dummy.next;\n    }\n};\n\nint main() {\n    Solution sol;\n    ListNode* list1 = new ListNode(1, new ListNode(2, new ListNode(4)));\n    ListNode* list2 = new ListNode(1, new ListNode(3, new ListNode(4)));\n    ListNode* merged = sol.mergeTwoLists(list1, list2);\n    vector&lt;int&gt; res;\n    while (merged) {\n        res.push_back(merged-&gt;val);\n        merged = merged-&gt;next;\n    }\n    assert(res == std::vector&lt;int&gt;({1, 1, 2, 3, 4, 4}));\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/linked_lists_merge/#369-plus-one-linked-list","title":"369. Plus One Linked List \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Math</p> </li> </ul>"},{"location":"EndlessCheng/linked_lists_merge/#1634-add-two-polynomials-represented-as-linked-lists","title":"1634. Add Two Polynomials Represented as Linked Lists \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Math, Two Pointers</p> </li> </ul>"},{"location":"EndlessCheng/manhattan_distance/","title":"Manhattan Distance","text":""},{"location":"EndlessCheng/manhattan_distance/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3443. Maximum Manhattan Distance After K Changes (Medium)</li> <li> 1131. Maximum of Absolute Value Expression (Medium)</li> <li> 3102. Minimize Manhattan Distances (Hard)</li> <li> 1330. Reverse Subarray To Maximize Array Value (Hard)</li> <li> 1956. Minimum Time For K Virus Variants to Spread (Hard) \ud83d\udc51</li> <li> 2613. Beautiful Pairs (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/manhattan_distance/#3443-maximum-manhattan-distance-after-k-changes","title":"3443. Maximum Manhattan Distance After K Changes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Math, String, Counting</p> </li> </ul>"},{"location":"EndlessCheng/manhattan_distance/#1131-maximum-of-absolute-value-expression","title":"1131. Maximum of Absolute Value Expression","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math</p> </li> </ul>"},{"location":"EndlessCheng/manhattan_distance/#3102-minimize-manhattan-distances","title":"3102. Minimize Manhattan Distances","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Geometry, Sorting, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/manhattan_distance/#1330-reverse-subarray-to-maximize-array-value","title":"1330. Reverse Subarray To Maximize Array Value","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/manhattan_distance/#1956-minimum-time-for-k-virus-variants-to-spread","title":"1956. Minimum Time For K Virus Variants to Spread \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Binary Search, Geometry, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/manhattan_distance/#2613-beautiful-pairs","title":"2613. Beautiful Pairs \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Divide And Conquer, Geometry, Sorting, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/math_greedy_basics/","title":"Math Greedy Basics","text":""},{"location":"EndlessCheng/math_greedy_basics/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2160. Minimum Sum of Four Digit Number After Splitting Digits (Easy)</li> <li> 2578. Split With Minimum Sum (Easy)</li> <li> 2244. Minimum Rounds to Complete All Tasks (Medium)</li> <li> 2870. Minimum Number of Operations to Make Array Empty (Medium)</li> <li> 1217. Minimum Cost to Move Chips to The Same Position (Easy)</li> <li> 3091. Apply Operations to Make Sum of Array Greater Than or Equal to k (Medium)</li> <li> 397. Integer Replacement (Medium)</li> </ul>"},{"location":"EndlessCheng/math_greedy_basics/#2160-minimum-sum-of-four-digit-number-after-splitting-digits","title":"2160. Minimum Sum of Four Digit Number After Splitting Digits","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/math_greedy_basics/#2578-split-with-minimum-sum","title":"2578. Split With Minimum Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/math_greedy_basics/#2244-minimum-rounds-to-complete-all-tasks","title":"2244. Minimum Rounds to Complete All Tasks","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Greedy, Counting</p> </li> </ul>"},{"location":"EndlessCheng/math_greedy_basics/#2870-minimum-number-of-operations-to-make-array-empty","title":"2870. Minimum Number of Operations to Make Array Empty","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Greedy, Counting</p> </li> </ul>"},{"location":"EndlessCheng/math_greedy_basics/#1217-minimum-cost-to-move-chips-to-the-same-position","title":"1217. Minimum Cost to Move Chips to The Same Position","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/math_greedy_basics/#3091-apply-operations-to-make-sum-of-array-greater-than-or-equal-to-k","title":"3091. Apply Operations to Make Sum of Array Greater Than or Equal to k","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Greedy, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/math_greedy_basics/#397-integer-replacement","title":"397. Integer Replacement","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Greedy, Bit Manipulation, Memoization</p> </li> </ul>"},{"location":"EndlessCheng/math_others/","title":"Math Others","text":""},{"location":"EndlessCheng/math_others/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1523. Count Odd Numbers in an Interval Range (Easy)</li> <li> 2829. Determine the Minimum Sum of a k-avoiding Array (Medium)</li> <li> 2579. Count Total Number of Colored Cells (Medium)</li> <li> 2834. Find the Minimum Possible Sum of a Beautiful Array (Medium)</li> <li> 1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K (Medium)</li> <li> 319. Bulb Switcher (Medium)</li> <li> 1780. Check if Number is a Sum of Powers of Three (Medium)</li> <li> 3091. Apply Operations to Make Sum of Array Greater Than or Equal to k (Medium)</li> <li> 2310. Sum of Numbers With Units Digit K (Medium)</li> <li> 2844. Minimum Operations to Make a Special Number (Medium)</li> <li> 2541. Minimum Operations to Make Array Equal II (Medium)</li> <li> 2195. Append K Integers With Minimal Sum (Medium)</li> <li> 2457. Minimum Addition to Make Integer Beautiful (Medium)</li> <li> 1017. Convert to Base -2 (Medium)</li> <li> 1954. Minimum Garden Perimeter to Collect Enough Apples (Medium)</li> <li> 1073. Adding Two Negabinary Numbers (Medium)</li> <li> 1823. Find the Winner of the Circular Game (Medium)</li> <li> 166. Fraction to Recurring Decimal (Medium)</li> <li> 3012. Minimize Length of Array Using Operations (Medium)</li> <li> 483. Smallest Good Base (Hard)</li> <li> 972. Equal Rational Numbers (Hard)</li> <li> 1862. Sum of Floored Pairs (Hard)</li> <li> 1739. Building Boxes (Hard)</li> <li> 2443. Sum of Number and Its Reverse (Medium)</li> <li> 1806. Minimum Number of Operations to Reinitialize a Permutation (Medium)</li> <li> 458. Poor Pigs (Hard)</li> <li> 60. Permutation Sequence (Hard)</li> <li> 2117. Abbreviating the Product of a Range (Hard)</li> <li> 660. Remove 9 (Hard) \ud83d\udc51</li> <li> 2979. Most Expensive Item That Can Not Be Bought (Medium) \ud83d\udc51</li> <li> 2647. Color the Triangle Red (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/math_others/#1523-count-odd-numbers-in-an-interval-range","title":"1523. Count Odd Numbers in an Interval Range","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math</p> </li> </ul>"},{"location":"EndlessCheng/math_others/#2829-determine-the-minimum-sum-of-a-k-avoiding-array","title":"2829. Determine the Minimum Sum of a k-avoiding Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Greedy</p> </li> </ul> Python <pre><code>def minimumSum(n: int, k: int) -&gt; int:\n    m = min(k // 2, n)\n    return (m * (m + 1) + (k * 2 + n - m - 1) * (n - m)) // 2\n\n\nif __name__ == \"__main__\":\n    n = 5\n    k = 4\n    print(minimumSum(n, k))  # 18\n</code></pre>"},{"location":"EndlessCheng/math_others/#2579-count-total-number-of-colored-cells","title":"2579. Count Total Number of Colored Cells","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math</p> </li> </ul>"},{"location":"EndlessCheng/math_others/#2834-find-the-minimum-possible-sum-of-a-beautiful-array","title":"2834. Find the Minimum Possible Sum of a Beautiful Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/math_others/#1414-find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k","title":"1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/math_others/#319-bulb-switcher","title":"319. Bulb Switcher","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Brainteaser</p> </li> </ul>"},{"location":"EndlessCheng/math_others/#1780-check-if-number-is-a-sum-of-powers-of-three","title":"1780. Check if Number is a Sum of Powers of Three","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math</p> </li> </ul>"},{"location":"EndlessCheng/math_others/#3091-apply-operations-to-make-sum-of-array-greater-than-or-equal-to-k","title":"3091. Apply Operations to Make Sum of Array Greater Than or Equal to k","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Greedy, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/math_others/#2310-sum-of-numbers-with-units-digit-k","title":"2310. Sum of Numbers With Units Digit K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Greedy, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/math_others/#2844-minimum-operations-to-make-a-special-number","title":"2844. Minimum Operations to Make a Special Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String, Greedy, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/math_others/#2541-minimum-operations-to-make-array-equal-ii","title":"2541. Minimum Operations to Make Array Equal II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/math_others/#2195-append-k-integers-with-minimal-sum","title":"2195. Append K Integers With Minimal Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/math_others/#2457-minimum-addition-to-make-integer-beautiful","title":"2457. Minimum Addition to Make Integer Beautiful","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/math_others/#1017-convert-to-base-2","title":"1017. Convert to Base -2","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math</p> </li> </ul>"},{"location":"EndlessCheng/math_others/#1954-minimum-garden-perimeter-to-collect-enough-apples","title":"1954. Minimum Garden Perimeter to Collect Enough Apples","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Binary Search</p> </li> </ul>"},{"location":"EndlessCheng/math_others/#1073-adding-two-negabinary-numbers","title":"1073. Adding Two Negabinary Numbers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math</p> </li> </ul>"},{"location":"EndlessCheng/math_others/#1823-find-the-winner-of-the-circular-game","title":"1823. Find the Winner of the Circular Game","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Recursion, Queue, Simulation</p> </li> </ul>"},{"location":"EndlessCheng/math_others/#166-fraction-to-recurring-decimal","title":"166. Fraction to Recurring Decimal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Math, String</p> </li> </ul> Python <pre><code># Math\ndef fractionToDecimal(numerator: int, denominator: int) -&gt; str:\n    if numerator == 0:\n        return \"0\"\n\n    res = []\n\n    if (numerator &lt; 0) ^ (denominator &lt; 0):\n        res.append(\"-\")\n\n    numerator, denominator = abs(numerator), abs(denominator)\n\n    # Integer part\n    res.append(str(numerator // denominator))\n    remainder = numerator % denominator\n\n    if remainder == 0:\n        return \"\".join(res)\n\n    res.append(\".\")\n\n    # Dictionary to store remainders and their corresponding indices\n    remainder_map = {}\n\n    while remainder != 0:\n        if remainder in remainder_map:\n            res.insert(remainder_map[remainder], \"(\")\n            res.append(\")\")\n            break\n\n        remainder_map[remainder] = len(res)\n        remainder *= 10\n        res.append(str(remainder // denominator))\n        remainder %= denominator\n\n    return \"\".join(res)\n\n\nnumerator = 4\ndenominator = 333\nprint(fractionToDecimal(numerator, denominator))  # 0.(012)\n</code></pre>"},{"location":"EndlessCheng/math_others/#3012-minimize-length-of-array-using-operations","title":"3012. Minimize Length of Array Using Operations","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Greedy, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/math_others/#483-smallest-good-base","title":"483. Smallest Good Base","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Binary Search</p> </li> </ul>"},{"location":"EndlessCheng/math_others/#972-equal-rational-numbers","title":"972. Equal Rational Numbers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String</p> </li> </ul>"},{"location":"EndlessCheng/math_others/#1862-sum-of-floored-pairs","title":"1862. Sum of Floored Pairs","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Binary Search, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/math_others/#1739-building-boxes","title":"1739. Building Boxes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Binary Search, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/math_others/#2443-sum-of-number-and-its-reverse","title":"2443. Sum of Number and Its Reverse","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/math_others/#1806-minimum-number-of-operations-to-reinitialize-a-permutation","title":"1806. Minimum Number of Operations to Reinitialize a Permutation","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Simulation</p> </li> </ul>"},{"location":"EndlessCheng/math_others/#458-poor-pigs","title":"458. Poor Pigs","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Combinatorics</p> </li> </ul>"},{"location":"EndlessCheng/math_others/#60-permutation-sequence","title":"60. Permutation Sequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Recursion</p> </li> </ul>"},{"location":"EndlessCheng/math_others/#2117-abbreviating-the-product-of-a-range","title":"2117. Abbreviating the Product of a Range","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math</p> </li> </ul>"},{"location":"EndlessCheng/math_others/#660-remove-9","title":"660. Remove 9 \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math</p> </li> </ul>"},{"location":"EndlessCheng/math_others/#2979-most-expensive-item-that-can-not-be-bought","title":"2979. Most Expensive Item That Can Not Be Bought \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/math_others/#2647-color-the-triangle-red","title":"2647. Color the Triangle Red \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math</p> </li> </ul>"},{"location":"EndlessCheng/median_greedy/","title":"Median Greedy","text":""},{"location":"EndlessCheng/median_greedy/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 462. Minimum Moves to Equal Array Elements II (Medium)</li> <li> 2033. Minimum Operations to Make a Uni-Value Grid (Medium)</li> <li> 2448. Minimum Cost to Make Array Equal (Hard)</li> <li> 2607. Make K-Subarray Sums Equal (Medium)</li> <li> 2967. Minimum Cost to Make Array Equalindromic (Medium)</li> <li> 1478. Allocate Mailboxes (Hard)</li> <li> 2968. Apply Operations to Maximize Frequency Score (Hard)</li> <li> 1703. Minimum Adjacent Swaps for K Consecutive Ones (Hard)</li> <li> 3086. Minimum Moves to Pick K Ones (Hard)</li> <li> 3441. Minimum Cost Good Caption (Hard)</li> <li> 296. Best Meeting Point (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/median_greedy/#462-minimum-moves-to-equal-array-elements-ii","title":"462. Minimum Moves to Equal Array Elements II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/median_greedy/#2033-minimum-operations-to-make-a-uni-value-grid","title":"2033. Minimum Operations to Make a Uni-Value Grid","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Sorting, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/median_greedy/#2448-minimum-cost-to-make-array-equal","title":"2448. Minimum Cost to Make Array Equal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Greedy, Sorting, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/median_greedy/#2607-make-k-subarray-sums-equal","title":"2607. Make K-Subarray Sums Equal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Greedy, Sorting, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/median_greedy/#2967-minimum-cost-to-make-array-equalindromic","title":"2967. Minimum Cost to Make Array Equalindromic","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Binary Search, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/median_greedy/#1478-allocate-mailboxes","title":"1478. Allocate Mailboxes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/median_greedy/#2968-apply-operations-to-maximize-frequency-score","title":"2968. Apply Operations to Maximize Frequency Score","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Sliding Window, Sorting, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/median_greedy/#1703-minimum-adjacent-swaps-for-k-consecutive-ones","title":"1703. Minimum Adjacent Swaps for K Consecutive Ones","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sliding Window, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/median_greedy/#3086-minimum-moves-to-pick-k-ones","title":"3086. Minimum Moves to Pick K Ones","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sliding Window, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/median_greedy/#3441-minimum-cost-good-caption","title":"3441. Minimum Cost Good Caption","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/median_greedy/#296-best-meeting-point","title":"296. Best Meeting Point \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Sorting, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/merge_intervals/","title":"Merge Intervals","text":""},{"location":"EndlessCheng/merge_intervals/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 56. Merge Intervals (Medium)</li> <li> 57. Insert Interval (Medium)</li> <li> 55. Jump Game (Medium)</li> <li> 763. Partition Labels (Medium)</li> <li> 3169. Count Days Without Meetings (Medium)</li> <li> 2580. Count Ways to Group Overlapping Ranges (Medium)</li> <li> 3394. Check if Grid can be Cut into Sections (Medium)</li> <li> 2963. Count the Number of Good Partitions (Hard)</li> <li> 2584. Split the Array to Make Coprime Products (Hard)</li> <li> 616. Add Bold Tag in String (Medium) \ud83d\udc51</li> <li> 758. Bold Words in String (Medium) \ud83d\udc51</li> <li> 3323. Minimize Connected Groups by Inserting Interval (Medium) \ud83d\udc51</li> <li> 759. Employee Free Time (Hard) \ud83d\udc51</li> <li> 2655. Find Maximal Uncovered Ranges (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/merge_intervals/#56-merge-intervals","title":"56. Merge Intervals","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sorting</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Merge all overlapping intervals.\n\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/44H3cEC2fFM?si=J-Jr_Fg2eDse3-de\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen&gt;&lt;/iframe&gt;\n\"\"\"\n\nfrom typing import List\n\n\n# Intervals\ndef merge(intervals: List[List[int]]) -&gt; List[List[int]]:\n    n = len(intervals)\n    if n &lt;= 1:\n        return intervals\n\n    intervals.sort(key=lambda x: x[0])\n    res = [intervals[0]]\n\n    for i in range(1, n):\n        if intervals[i][0] &lt;= res[-1][1]:\n            res[-1][1] = max(res[-1][1], intervals[i][1])\n        else:\n            res.append(intervals[i])\n\n    return res\n\n\nprint(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))\n# [[1, 6], [8, 10], [15, 18]]\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// Interval\nvector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {\n    sort(intervals.begin(), intervals.end());\n    vector&lt;vector&lt;int&gt;&gt; res;\n\n    for (auto&amp; range : intervals) {\n        if (!res.empty() &amp;&amp; range[0] &lt;= res.back()[1]) {\n            res.back()[1] = max(res.back()[1], range[1]);\n        } else {\n            res.emplace_back(range);\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;vector&lt;int&gt;&gt; intervals = {{1, 3}, {2, 6}, {8, 10}, {15, 18}};\n    vector&lt;vector&lt;int&gt;&gt; res = merge(intervals);\n    for (auto&amp; range : res) {\n        cout &lt;&lt; range[0] &lt;&lt; \", \" &lt;&lt; range[1] &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/merge_intervals/#57-insert-interval","title":"57. Insert Interval","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Interval\ndef insert(intervals: List[List[int]], newInterval: List[int]) -&gt; List[List[int]]:\n    n = len(intervals)\n\n    if n == 0:\n        return [newInterval]\n\n    if newInterval[1] &lt; intervals[0][0]:\n        return [newInterval] + intervals\n\n    if newInterval[0] &gt; intervals[-1][1]:\n        return intervals + [newInterval]\n\n    i = 0\n    result = []\n\n    while i &lt; n and intervals[i][1] &lt; newInterval[0]:\n        result.append(intervals[i])\n        i += 1\n\n    while i &lt; n and intervals[i][0] &lt;= newInterval[1]:\n        newInterval[0] = min(newInterval[0], intervals[i][0])\n        newInterval[1] = max(newInterval[1], intervals[i][1])\n        i += 1\n\n    result.append(newInterval)\n\n    while i &lt; n:\n        result.append(intervals[i])\n        i += 1\n\n    return result\n\n\nintervals = [[1, 3], [6, 9]]\nnewInterval = [2, 5]\nprint(insert(intervals, newInterval))  # [[1, 5], [6, 9]]\n</code></pre>"},{"location":"EndlessCheng/merge_intervals/#55-jump-game","title":"55. Jump Game","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return `True` if you can reach the last index, otherwise `False`.\n\"\"\"\n\nfrom typing import List\n\n\n# Greedy - Interval\ndef canJump(nums: List[int]) -&gt; bool:\n    n = len(nums)\n    reach = 0\n    i = 0\n\n    while reach &gt;= i:\n        if reach &gt;= n - 1:\n            return True\n        reach = max(reach, i + nums[i])\n        i += 1\n\n    return False\n\n\nif __name__ == \"__main__\":\n    assert canJump([2, 3, 1, 1, 4]) is True\n    assert canJump([3, 2, 1, 0, 4]) is False\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool canJump(vector&lt;int&gt;&amp; nums) {\n        int canReach = 0;\n        int n = nums.size();\n\n        for (int i = 0; i &lt; n; i++) {\n            if (i &gt; canReach) return false;\n            canReach = max(canReach, i + nums[i]);\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution obj;\n    vector&lt;int&gt; nums = {2, 3, 1, 1, 4};\n    cout &lt;&lt; obj.canJump(nums) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/merge_intervals/#763-partition-labels","title":"763. Partition Labels","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Two Pointers, String, Greedy</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# 1. Hashmap\ndef partitionLabels1(s: str) -&gt; List[int]:\n    hashmap = {}\n\n    for i, j in enumerate(s):\n        if j not in hashmap:\n            hashmap[j] = [i, i]\n        else:\n            hashmap[j][1] = i\n\n    intervals = list(hashmap.values())\n    intervals.sort(key=lambda x: x[0])\n\n    if len(intervals) &lt; 2:\n        return len(intervals)\n\n    res = []\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &lt; intervals[i - 1][1]:\n            intervals[i][1] = max(intervals[i][1], intervals[i - 1][1])\n        else:\n            res.append(intervals[i][0])\n\n    res.append(intervals[-1][1] + 1)\n\n    if len(res) == 1:\n        return res\n    else:\n        for i in range(len(res) - 1, 0, -1):\n            res[i] -= res[i - 1]\n        return res\n\n\n# Single Pass Partitioning\ndef partitionLabels2(s: str) -&gt; List[int]:\n    last = {c: i for i, c in enumerate(s)}\n    res = []\n    start, end = 0, 0\n\n    for i, c in enumerate(s):\n        end = max(end, last[c])\n        if end == i:\n            res.append(end - start + 1)\n            start = i + 1\n\n    return res\n\n\nprint(partitionLabels1(\"abaccd\"))  # [3, 2, 1]\nprint(partitionLabels2(\"abaccd\"))  # [3, 2, 1]\n</code></pre>"},{"location":"EndlessCheng/merge_intervals/#3169-count-days-without-meetings","title":"3169. Count Days Without Meetings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/merge_intervals/#2580-count-ways-to-group-overlapping-ranges","title":"2580. Count Ways to Group Overlapping Ranges","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/merge_intervals/#3394-check-if-grid-can-be-cut-into-sections","title":"3394. Check if Grid can be Cut into Sections","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/merge_intervals/#2963-count-the-number-of-good-partitions","title":"2963. Count the Number of Good Partitions","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Combinatorics</p> </li> </ul>"},{"location":"EndlessCheng/merge_intervals/#2584-split-the-array-to-make-coprime-products","title":"2584. Split the Array to Make Coprime Products","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/merge_intervals/#616-add-bold-tag-in-string","title":"616. Add Bold Tag in String \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Trie, String Matching</p> </li> </ul>"},{"location":"EndlessCheng/merge_intervals/#758-bold-words-in-string","title":"758. Bold Words in String \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Trie, String Matching</p> </li> </ul>"},{"location":"EndlessCheng/merge_intervals/#3323-minimize-connected-groups-by-inserting-interval","title":"3323. Minimize Connected Groups by Inserting Interval \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Sliding Window, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/merge_intervals/#759-employee-free-time","title":"759. Employee Free Time \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sorting, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/merge_intervals/#2655-find-maximal-uncovered-ranges","title":"2655. Find Maximal Uncovered Ranges \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/minimum_spanning_tree/","title":"Minimum Spanning Tree","text":""},{"location":"EndlessCheng/minimum_spanning_tree/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1584. Min Cost to Connect All Points (Medium)</li> <li> 1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree (Hard)</li> <li> 1135. Connecting Cities With Minimum Cost (Medium) \ud83d\udc51</li> <li> 1168. Optimize Water Distribution in a Village (Hard) \ud83d\udc51</li> <li> 3219. Minimum Cost for Cutting Cake II (Hard)</li> </ul>"},{"location":"EndlessCheng/minimum_spanning_tree/#1584-min-cost-to-connect-all-points","title":"1584. Min Cost to Connect All Points","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Union Find, Graph, Minimum Spanning Tree</p> </li> </ul> Python <pre><code>\"\"\"\n- Tree: a connected acyclic graph\n- Spanning Tree: a subgraph that is a tree and connects all the vertices together\n- Minimum Spanning Tree (MST): a spanning tree with the minimum possible sum of edge weights\n- Prim's Algorithm\n  - Data Structure: Heap\n  - Time Complexity: O(E * logV)\n  - Space Complexity: O(V + E)\n- Kruskal's Algorithm\n  - Union Find\n  - Time Complexity: O(E * logV)\n  - Space Complexity: O(V + E)\n\"\"\"\n\nimport heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minCostConnectPointsPrim(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    graph = defaultdict(list)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            dist = abs(x1 - x2) + abs(y1 - y2)\n            graph[i].append((dist, j))\n            graph[j].append((dist, i))\n\n    cost = 0\n    heap = [(0, 0)]  # (cost, node)\n    visited = set()\n\n    while heap:\n        d1, n1 = heapq.heappop(heap)\n        if n1 in visited:\n            continue\n        visited.add(n1)\n        cost += d1\n\n        for d2, n2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (d2, n2))\n\n    return cost\n\n\n# Kruskal\ndef minCostConnectPointsKruskal(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    par = {i: i for i in range(n)}\n    rank = {i: 0 for i in range(n)}\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 == p2:\n            return False\n\n        if rank[p1] &gt; rank[p2]:\n            par[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n        else:\n            par[p2] = p1\n            rank[p1] += 1\n\n        return True\n\n    heap = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            dist = abs(x1 - x2) + abs(y1 - y2)\n            heapq.heappush(heap, (dist, i, j))\n\n    cost = 0\n    while heap:\n        d, n1, n2 = heapq.heappop(heap)\n        if union(n1, n2):\n            cost += d\n\n    return cost\n\n\nif __name__ == \"__main__\":\n    points = [[0, 0], [2, 2], [3, 10], [5, 2], [7, 0]]\n    print(minCostConnectPointsPrim(points))  # 20\n    print(minCostConnectPointsKruskal(points))  # 20\n</code></pre>"},{"location":"EndlessCheng/minimum_spanning_tree/#1489-find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree","title":"1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Union Find, Graph, Sorting, Minimum Spanning Tree, Strongly Connected Component</p> </li> </ul> Python <pre><code>from typing import List\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [1 for _ in range(n)]\n        self.part = n\n\n    def find(self, n):\n        p = self.parent[n]\n        while p != self.parent[p]:\n            self.parent[p] = self.parent[self.parent[p]]\n            p = self.parent[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return False\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.parent[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.parent[p1] = p2\n        else:\n            self.parent[p2] = p1\n            self.rank[p1] += 1\n\n        self.part -= 1\n        return True\n\n\n# Kruskal\ndef findCriticalAndPseudoCriticalEdges(n: int, edges: List[List[int]]) -&gt; List[List[int]]:\n    m = len(edges)\n\n    # Add index to edges\n    lst = list(range(m))\n    lst.sort(key=lambda x: edges[x][2])\n\n    # Calculate minimum cost\n    min_cost = 0\n    uf = UnionFind(n)\n    for i in lst:\n        x, y, cost = edges[i]\n        if uf.union(x, y):\n            min_cost += cost\n\n    # Calculate key edges\n    key = set()\n    for i in lst:\n        cur_cost = 0\n        uf = UnionFind(n)\n        for j in lst:\n            if j != i:\n                x, y, cost = edges[j]\n                if uf.union(x, y):\n                    cur_cost += cost\n        if cur_cost &gt; min_cost or uf.part != 1:\n            key.add(i)\n\n    # Calculate fake edges\n    fake = set()\n    for i in lst:\n        if i not in key:\n            cur_cost = edges[i][2]\n            uf = UnionFind(n)\n            uf.union(edges[i][0], edges[i][1])\n            for j in lst:\n                x, y, cost = edges[j]\n                if uf.union(x, y):\n                    cur_cost += cost\n            if cur_cost == min_cost and uf.part == 1:\n                fake.add(i)\n\n    return [sorted(list(key)), sorted(list(fake))]\n\n\nn = 5\nedges = [\n    [0, 1, 1],\n    [1, 2, 1],\n    [2, 3, 2],\n    [0, 3, 2],\n    [0, 4, 3],\n    [3, 4, 3],\n    [1, 4, 6],\n]\nprint(findCriticalAndPseudoCriticalEdges(n, edges))\n</code></pre>"},{"location":"EndlessCheng/minimum_spanning_tree/#1135-connecting-cities-with-minimum-cost","title":"1135. Connecting Cities With Minimum Cost \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Union Find, Graph, Heap Priority Queue, Minimum Spanning Tree</p> </li> </ul> Python <pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minimumCost(n: int, connections: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, c in connections:\n        graph[u].append((c, v))\n        graph[v].append((c, u))\n\n    cost = 0\n    heap = [(0, 1)]  # (cost, node)\n    visited = set()\n\n    while heap:\n        c1, n1 = heapq.heappop(heap)\n\n        if n1 in visited:\n            continue\n\n        visited.add(n1)\n\n        cost += c1\n\n        for c2, n2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (c2, n2))\n\n    return cost if len(visited) == n else -1\n\n\nn = 3\nconnections = [[1, 2, 5], [1, 3, 6], [2, 3, 1]]\nprint(minimumCost(n, connections))  # 6\n</code></pre>"},{"location":"EndlessCheng/minimum_spanning_tree/#1168-optimize-water-distribution-in-a-village","title":"1168. Optimize Water Distribution in a Village \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Union Find, Graph, Heap Priority Queue, Minimum Spanning Tree</p> </li> </ul> Python <pre><code>\"\"\"\n- ![1168_0](../../assets/1168_0.png)\n\n- ![1168_1](../../assets/1168_1.png)\n\"\"\"\n\nimport heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minCostToSupplyWater1(n: int, wells: List[int], pipes: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n\n    for h1, h2, cost in pipes:\n        graph[h1].append((h2, cost))\n        graph[h2].append((h1, cost))\n\n    # Add the cost of the wells to the graph (house 0)\n    for i in range(n):\n        graph[0].append((i + 1, wells[i]))\n        graph[i + 1].append((0, wells[i]))\n\n    visited = set([0])\n    heap = [(cost, dest) for dest, cost in graph[0]]\n    heapq.heapify(heap)\n\n    cost = 0\n\n    while heap:\n        c1, n1 = heapq.heappop(heap)\n        if n1 in visited:\n            continue\n        visited.add(n1)\n        cost += c1\n\n        for n2, c2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (c2, n2))\n\n    return cost\n\n\n# Kruskal\ndef minCostToSupplyWater2(n: int, wells: List[int], pipes: List[List[int]]) -&gt; int:\n    par = list(range(n + 1))\n    rank = [0] * (n + 1)\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            if rank[p1] &lt; rank[p2]:\n                par[p1] = p2\n            elif rank[p1] &gt; rank[p2]:\n                par[p2] = p1\n            else:\n                par[p1] = p2\n                rank[p2] += 1\n            return True\n        return False\n\n    graph = [(c, 0, i + 1) for i, c in enumerate(wells)]\n    for h1, h2, c in pipes:\n        graph.append((c, h1, h2))\n\n    graph.sort()\n\n    cost = 0\n\n    for c, h1, h2 in graph:\n        if union(h1, h2):\n            cost += c\n\n    return cost\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |    Prim    | O((V + E) log V) | O(V + E)|\n# |  Kruskal   |     O(E log E)   | O(V + E)|\n# |------------|------------------|---------|\n\n\nn = 3\nwells = [1, 2, 2]\npipes = [[1, 2, 1], [2, 3, 1]]\nprint(minCostToSupplyWater1(n, wells, pipes))  # 3\nprint(minCostToSupplyWater2(n, wells, pipes))  # 3\n</code></pre>"},{"location":"EndlessCheng/minimum_spanning_tree/#3219-minimum-cost-for-cutting-cake-ii","title":"3219. Minimum Cost for Cutting Cake II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/modular_arithmetic/","title":"Modular Arithmetic","text":""},{"location":"EndlessCheng/modular_arithmetic/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2453. Destroy Sequential Targets (Medium)</li> <li> 2598. Smallest Missing Non-negative Integer After Operations (Medium)</li> <li> 1590. Make Sum Divisible by P (Medium)</li> </ul>"},{"location":"EndlessCheng/modular_arithmetic/#2453-destroy-sequential-targets","title":"2453. Destroy Sequential Targets","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Counting</p> </li> </ul>"},{"location":"EndlessCheng/modular_arithmetic/#2598-smallest-missing-non-negative-integer-after-operations","title":"2598. Smallest Missing Non-negative Integer After Operations","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/modular_arithmetic/#1590-make-sum-divisible-by-p","title":"1590. Make Sum Divisible by P","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/monotonic_queue/","title":"Monotonic Queue","text":""},{"location":"EndlessCheng/monotonic_queue/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 239. Sliding Window Maximum (Hard)</li> <li> 1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit (Medium)</li> <li> 2762. Continuous Subarrays (Medium)</li> <li> 2398. Maximum Number of Robots Within Budget (Hard)</li> <li> 862. Shortest Subarray with Sum at Least K (Hard)</li> <li> 1499. Max Value of Equation (Hard)</li> <li> 2071. Maximum Number of Tasks You Can Assign (Hard)</li> </ul>"},{"location":"EndlessCheng/monotonic_queue/#239-sliding-window-maximum","title":"239. Sliding Window Maximum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Queue, Sliding Window, Heap Priority Queue, Monotonic Queue</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# Monotonic Queue\ndef maxSlidingWindow(nums: List[int], k: int) -&gt; List[int]:\n    q = deque()\n    res = []\n\n    for i, num in enumerate(nums):\n        if q and q[0] &lt; i - k + 1:\n            q.popleft()\n\n        while q and nums[q[-1]] &lt; num:\n            q.pop()\n\n        q.append(i)\n\n        if i &gt;= k - 1:\n            res.append(nums[q[0]])\n\n    return res\n\n\nnums = [1, 3, -1, -3, 5, 3, 6, 7]\nk = 3\nprint(maxSlidingWindow(nums, k))  # [3, 3, 5, 5, 6, 7]\n</code></pre>"},{"location":"EndlessCheng/monotonic_queue/#1438-longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit","title":"1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Queue, Sliding Window, Heap Priority Queue, Ordered Set, Monotonic Queue</p> </li> </ul>"},{"location":"EndlessCheng/monotonic_queue/#2762-continuous-subarrays","title":"2762. Continuous Subarrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Queue, Sliding Window, Heap Priority Queue, Ordered Set, Monotonic Queue</p> </li> </ul>"},{"location":"EndlessCheng/monotonic_queue/#2398-maximum-number-of-robots-within-budget","title":"2398. Maximum Number of Robots Within Budget","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Queue, Sliding Window, Heap Priority Queue, Prefix Sum, Monotonic Queue</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# Monotonic Queue\ndef maximumRobots(chargeTimes: List[int], runningCosts: List[int], budget: int) -&gt; int:\n    ans = sum_cost = left = 0\n    q = deque()\n\n    for right, (time, cost) in enumerate(zip(chargeTimes, runningCosts)):\n        # 1. Add\n        while q and time &gt;= chargeTimes[q[-1]]:\n            q.pop()\n        q.append(right)\n        sum_cost += cost\n\n        # 2. Remove\n        while q and chargeTimes[q[0]] + (right - left + 1) * sum_cost &gt; budget:\n            if q[0] == left:\n                q.popleft()\n            sum_cost -= runningCosts[left]\n            left += 1\n\n        # 3. Update\n        ans = max(ans, right - left + 1)\n    return ans\n\n\nchargeTimes = [3, 6, 1, 3, 4]\nrunningCosts = [2, 1, 3, 4, 5]\nbudget = 25\nprint(maximumRobots(chargeTimes, runningCosts, budget))  # 3\n</code></pre>"},{"location":"EndlessCheng/monotonic_queue/#862-shortest-subarray-with-sum-at-least-k","title":"862. Shortest Subarray with Sum at Least K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Queue, Sliding Window, Heap Priority Queue, Prefix Sum, Monotonic Queue</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# Prefix Sum + Monotonic Queue\ndef shortestSubarray(nums: List[int], k: int) -&gt; int:\n    n = len(nums)\n    ps = [0 for _ in range(n + 1)]\n\n    for i in range(n):\n        ps[i + 1] = ps[i] + nums[i]\n\n    res = float(\"inf\")\n    q = deque()\n\n    for i in range(n + 1):\n        while q and ps[i] - ps[q[0]] &gt;= k:\n            res = min(res, i - q.popleft())\n        while q and ps[i] &lt;= ps[q[-1]]:\n            q.pop()\n        q.append(i)\n\n    return res if res != float(\"inf\") else -1\n\n\nnums = [2, -1, 2]\nk = 3\nprint(shortestSubarray(nums, k))  # 3\n</code></pre>"},{"location":"EndlessCheng/monotonic_queue/#1499-max-value-of-equation","title":"1499. Max Value of Equation","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Queue, Sliding Window, Heap Priority Queue, Monotonic Queue</p> </li> </ul>"},{"location":"EndlessCheng/monotonic_queue/#2071-maximum-number-of-tasks-you-can-assign","title":"2071. Maximum Number of Tasks You Can Assign","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Greedy, Queue, Sorting, Monotonic Queue</p> </li> </ul>"},{"location":"EndlessCheng/monotonic_queue_optimized_dp/","title":"Monotonic Queue Optimized DP","text":""},{"location":"EndlessCheng/monotonic_queue_optimized_dp/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2944. Minimum Number of Coins for Fruits (Medium)</li> <li> 1696. Jump Game VI (Medium)</li> <li> 1425. Constrained Subsequence Sum (Hard)</li> <li> 375. Guess Number Higher or Lower II (Medium)</li> <li> 1687. Delivering Boxes from Storage to Ports (Hard)</li> <li> 3117. Minimum Sum of Values by Dividing Array (Hard)</li> <li> 2945. Find Maximum Non-decreasing Array Length (Hard)</li> <li> 2969. Minimum Number of Coins for Fruits II (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/monotonic_queue_optimized_dp/#2944-minimum-number-of-coins-for-fruits","title":"2944. Minimum Number of Coins for Fruits","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Queue, Heap Priority Queue, Monotonic Queue</p> </li> </ul>"},{"location":"EndlessCheng/monotonic_queue_optimized_dp/#1696-jump-game-vi","title":"1696. Jump Game VI","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Queue, Heap Priority Queue, Monotonic Queue</p> </li> </ul>"},{"location":"EndlessCheng/monotonic_queue_optimized_dp/#1425-constrained-subsequence-sum","title":"1425. Constrained Subsequence Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Queue, Sliding Window, Heap Priority Queue, Monotonic Queue</p> </li> </ul>"},{"location":"EndlessCheng/monotonic_queue_optimized_dp/#375-guess-number-higher-or-lower-ii","title":"375. Guess Number Higher or Lower II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Game Theory</p> </li> </ul>"},{"location":"EndlessCheng/monotonic_queue_optimized_dp/#1687-delivering-boxes-from-storage-to-ports","title":"1687. Delivering Boxes from Storage to Ports","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Segment Tree, Queue, Heap Priority Queue, Prefix Sum, Monotonic Queue</p> </li> </ul>"},{"location":"EndlessCheng/monotonic_queue_optimized_dp/#3117-minimum-sum-of-values-by-dividing-array","title":"3117. Minimum Sum of Values by Dividing Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Dynamic Programming, Bit Manipulation, Segment Tree, Queue</p> </li> </ul>"},{"location":"EndlessCheng/monotonic_queue_optimized_dp/#2945-find-maximum-non-decreasing-array-length","title":"2945. Find Maximum Non-decreasing Array Length","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Dynamic Programming, Stack, Queue, Monotonic Stack, Monotonic Queue</p> </li> </ul>"},{"location":"EndlessCheng/monotonic_queue_optimized_dp/#2969-minimum-number-of-coins-for-fruits-ii","title":"2969. Minimum Number of Coins for Fruits II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Queue, Heap Priority Queue, Monotonic Queue</p> </li> </ul>"},{"location":"EndlessCheng/monotonic_stack/","title":"Monotonic Stack","text":""},{"location":"EndlessCheng/monotonic_stack/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 739. Daily Temperatures (Medium)</li> <li> 1475. Final Prices With a Special Discount in a Shop (Easy)</li> <li> 496. Next Greater Element I (Easy)</li> <li> 503. Next Greater Element II (Medium)</li> <li> 1019. Next Greater Node In Linked List (Medium)</li> <li> 962. Maximum Width Ramp (Medium)</li> <li> 853. Car Fleet (Medium)</li> <li> 901. Online Stock Span (Medium)</li> <li> 1124. Longest Well-Performing Interval (Medium)</li> <li> 1793. Maximum Score of a Good Subarray (Hard)</li> <li> 456. 132 Pattern (Medium)</li> <li> 3113. Find the Number of Subarrays Where Boundary Elements Are Maximum (Hard)</li> <li> 2866. Beautiful Towers II (Medium)</li> <li> 1944. Number of Visible People in a Queue (Hard)</li> <li> 2454. Next Greater Element IV (Hard)</li> <li> 1130. Minimum Cost Tree From Leaf Values (Medium)</li> <li> 2289. Steps to Make Array Non-decreasing (Medium)</li> <li> 1776. Car Fleet II (Hard)</li> <li> 3221. Maximum Array Hopping Score II (Medium) \ud83d\udc51</li> <li> 1966. Binary Searchable Numbers in an Unsorted Array (Medium) \ud83d\udc51</li> <li> 2832. Maximal Range That Each Element Is Maximum in It (Medium) \ud83d\udc51</li> <li> 2282. Number of People That Can Be Seen in a Grid (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/monotonic_stack/#739-daily-temperatures","title":"739. Daily Temperatures","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Stack, Monotonic Stack</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return an array `res` such that `res[i]` is the number of days you have to wait after the `ith` day to get a warmer temperature.\n\n| Index | Temp | &gt; stack last | stack                           | result    |\n| ----- | ---- | ------------ | ------------------------------- | --------- |\n| 0     | 73   | False        | `[ [73, 0] ]`                   | 1 - 0 = 1 |\n| 1     | 74   | True         | `[ [74, 1] ]`                   | 2 - 1 = 1 |\n| 2     | 75   | True         | `[ [75, 2] ]`                   | 6 - 2 = 4 |\n| 3     | 71   | False        | `[ [75, 2], [71, 3] ]`          | 5 - 3 = 2 |\n| 4     | 69   | False        | `[ [75, 2], [71, 3], [69, 4] ]` | 5 - 4 = 1 |\n| 5     | 72   | True         | `[ [75, 2], [72, 5] ]`          | 6 - 5 = 1 |\n| 6     | 76   | True         | `[ [76, 6] ]`                   | 0         |\n| 7     | 73   | False        | `[[76, 6], [73, 7]]`            | 0         |\n\"\"\"\n\nfrom typing import List\n\n\n# Monotonic Stack\ndef dailyTemperatures(temperatures: List[int]) -&gt; List[int]:\n    res = [0 for _ in range(len(temperatures))]\n    stack = []  # [temp, index]\n\n    for i, temp in enumerate(temperatures):\n        while stack and temp &gt; stack[-1][0]:\n            _, idx = stack.pop()\n            res[idx] = i - idx\n\n        stack.append([temp, i])\n\n    return res\n\n\nprint(dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73]))\n# [1, 1, 4, 2, 1, 1, 0, 0]\n</code></pre>"},{"location":"EndlessCheng/monotonic_stack/#1475-final-prices-with-a-special-discount-in-a-shop","title":"1475. Final Prices With a Special Discount in a Shop","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Stack, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/monotonic_stack/#496-next-greater-element-i","title":"496. Next Greater Element I","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Stack, Monotonic Stack</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Monotonic Stack\ndef nextGreaterElement(nums1: List[int], nums2: List[int]) -&gt; List[int]:\n    next_greater = {}\n    stack = []\n    result = []\n\n    for num in nums2:\n        while stack and num &gt; stack[-1]:\n            next_greater[stack.pop()] = num\n        stack.append(num)\n\n    for num in nums1:\n        result.append(next_greater.get(num, -1))\n\n    return result\n\n\nnums1 = [4, 1, 2]\nnums2 = [1, 3, 4, 2]\nprint(nextGreaterElement(nums1, nums2))  # [3, -1, -1]\n</code></pre>"},{"location":"EndlessCheng/monotonic_stack/#503-next-greater-element-ii","title":"503. Next Greater Element II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Stack, Monotonic Stack</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Monotonic Stack\ndef nextGreaterElements(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    result = [-1] * n\n    stack = []\n\n    for i in range(2 * n):\n        while stack and nums[stack[-1]] &lt; nums[i % n]:\n            result[stack.pop()] = nums[i % n]\n        if i &lt; n:\n            stack.append(i)\n\n    return result\n\n\nnums = [1, 2, 1]\nprint(nextGreaterElements(nums))  # [2, -1, 2]\n</code></pre>"},{"location":"EndlessCheng/monotonic_stack/#1019-next-greater-node-in-linked-list","title":"1019. Next Greater Node In Linked List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Linked List, Stack, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/monotonic_stack/#962-maximum-width-ramp","title":"962. Maximum Width Ramp","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Stack, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/monotonic_stack/#853-car-fleet","title":"853. Car Fleet","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Stack, Sorting, Monotonic Stack</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Stack\ndef carFleet(target: int, position: List[int], speed: List[int]) -&gt; int:\n    cars = sorted(zip(position, speed), reverse=True)\n    stack = []\n\n    for p, s in cars:\n        time = (target - p) / s\n\n        if not stack or time &gt; stack[-1]:\n            stack.append(time)\n\n    return len(stack)\n\n\nprint(carFleet(12, [10, 8, 0, 5, 3], [2, 4, 1, 1, 3]))  # 3\n</code></pre>"},{"location":"EndlessCheng/monotonic_stack/#901-online-stock-span","title":"901. Online Stock Span","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Stack, Design, Monotonic Stack, Data Stream</p> </li> </ul> Python <pre><code>\"\"\"\n-   Design a class `StockSpanner` to return the number of consecutive days (including the current day) the price of the stock has been less than or equal to the current price.\n\"\"\"\n\nfrom typing import List\n\n\n# Monotonic Stack\nclass StockSpanner:\n\n    def __init__(self):\n        self.stack = [(-1, float(\"inf\"))]\n        self.cur_day = -1\n\n    def next(self, price: int) -&gt; int:\n        while price &gt;= self.stack[-1][1]:\n            self.stack.pop()\n        self.cur_day += 1\n        self.stack.append((self.cur_day, price))\n        return self.cur_day - self.stack[-2][0]\n\n\nif __name__ == \"__main__\":\n    ss = StockSpanner()\n    prices = [100, 80, 60, 70, 60, 75, 85]\n    print([ss.next(price) for price in prices])  # [1, 1, 1, 2, 1, 4, 6]\n</code></pre>"},{"location":"EndlessCheng/monotonic_stack/#1124-longest-well-performing-interval","title":"1124. Longest Well-Performing Interval","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Stack, Monotonic Stack, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/monotonic_stack/#1793-maximum-score-of-a-good-subarray","title":"1793. Maximum Score of a Good Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Stack, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/monotonic_stack/#456-132-pattern","title":"456. 132 Pattern","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Stack, Monotonic Stack, Ordered Set</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Monotonic Stack\ndef find132pattern(nums: List[int]) -&gt; bool:\n    n = len(nums)\n    if n &lt; 3:\n        return False\n\n    stack = []\n    second_max = float(\"-inf\")\n\n    for i in range(n - 1, -1, -1):\n        if nums[i] &lt; second_max:\n            return True\n\n        while stack and stack[-1] &lt; nums[i]:\n            second_max = stack.pop()\n\n        stack.append(nums[i])\n\n    return False\n\n\nnums = [-1, 3, 2, 0]\nprint(find132pattern(nums))  # True\n</code></pre>"},{"location":"EndlessCheng/monotonic_stack/#3113-find-the-number-of-subarrays-where-boundary-elements-are-maximum","title":"3113. Find the Number of Subarrays Where Boundary Elements Are Maximum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Stack, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/monotonic_stack/#2866-beautiful-towers-ii","title":"2866. Beautiful Towers II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Stack, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/monotonic_stack/#1944-number-of-visible-people-in-a-queue","title":"1944. Number of Visible People in a Queue","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Stack, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/monotonic_stack/#2454-next-greater-element-iv","title":"2454. Next Greater Element IV","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Stack, Sorting, Heap Priority Queue, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/monotonic_stack/#1130-minimum-cost-tree-from-leaf-values","title":"1130. Minimum Cost Tree From Leaf Values","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Stack, Greedy, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/monotonic_stack/#2289-steps-to-make-array-non-decreasing","title":"2289. Steps to Make Array Non-decreasing","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Linked List, Stack, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/monotonic_stack/#1776-car-fleet-ii","title":"1776. Car Fleet II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Stack, Heap Priority Queue, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/monotonic_stack/#3221-maximum-array-hopping-score-ii","title":"3221. Maximum Array Hopping Score II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Stack, Greedy, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/monotonic_stack/#1966-binary-searchable-numbers-in-an-unsorted-array","title":"1966. Binary Searchable Numbers in an Unsorted Array \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul>"},{"location":"EndlessCheng/monotonic_stack/#2832-maximal-range-that-each-element-is-maximum-in-it","title":"2832. Maximal Range That Each Element Is Maximum in It \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Stack, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/monotonic_stack/#2282-number-of-people-that-can-be-seen-in-a-grid","title":"2282. Number of People That Can Be Seen in a Grid \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Stack, Matrix, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/multiplication_principle/","title":"Multiplication Principle","text":""},{"location":"EndlessCheng/multiplication_principle/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2125. Number of Laser Beams in a Bank (Medium)</li> <li> 3128. Right Triangles (Medium)</li> <li> 1573. Number of Ways to Split a String (Medium)</li> <li> 2750. Ways to Split Array Into Good Subarrays (Medium)</li> <li> 2550. Count Collisions of Monkeys on a Polygon (Medium)</li> <li> 1922. Count Good Numbers (Medium)</li> <li> 3067. Count Pairs of Connectable Servers in a Weighted Tree Network (Medium)</li> <li> 2147. Number of Ways to Divide a Long Corridor (Hard)</li> <li> 2963. Count the Number of Good Partitions (Hard)</li> <li> 2306. Naming a Company (Hard)</li> <li> 2867. Count Valid Paths in a Tree (Hard)</li> <li> 2450. Number of Distinct Binary Strings After Applying Operations (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/multiplication_principle/#2125-number-of-laser-beams-in-a-bank","title":"2125. Number of Laser Beams in a Bank","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, String, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/multiplication_principle/#3128-right-triangles","title":"3128. Right Triangles","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Combinatorics, Counting</p> </li> </ul>"},{"location":"EndlessCheng/multiplication_principle/#1573-number-of-ways-to-split-a-string","title":"1573. Number of Ways to Split a String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String</p> </li> </ul>"},{"location":"EndlessCheng/multiplication_principle/#2750-ways-to-split-array-into-good-subarrays","title":"2750. Ways to Split Array Into Good Subarrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/multiplication_principle/#2550-count-collisions-of-monkeys-on-a-polygon","title":"2550. Count Collisions of Monkeys on a Polygon","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Recursion</p> </li> </ul>"},{"location":"EndlessCheng/multiplication_principle/#1922-count-good-numbers","title":"1922. Count Good Numbers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Recursion</p> </li> </ul>"},{"location":"EndlessCheng/multiplication_principle/#3067-count-pairs-of-connectable-servers-in-a-weighted-tree-network","title":"3067. Count Pairs of Connectable Servers in a Weighted Tree Network","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Tree, Depth First Search</p> </li> </ul>"},{"location":"EndlessCheng/multiplication_principle/#2147-number-of-ways-to-divide-a-long-corridor","title":"2147. Number of Ways to Divide a Long Corridor","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/multiplication_principle/#2963-count-the-number-of-good-partitions","title":"2963. Count the Number of Good Partitions","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Combinatorics</p> </li> </ul>"},{"location":"EndlessCheng/multiplication_principle/#2306-naming-a-company","title":"2306. Naming a Company","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Bit Manipulation, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/multiplication_principle/#2867-count-valid-paths-in-a-tree","title":"2867. Count Valid Paths in a Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Tree, Depth First Search, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/multiplication_principle/#2450-number-of-distinct-binary-strings-after-applying-operations","title":"2450. Number of Distinct Binary Strings After Applying Operations \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String</p> </li> </ul>"},{"location":"EndlessCheng/n-ary_tree/","title":"N-ary Tree","text":""},{"location":"EndlessCheng/n-ary_tree/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 589. N-ary Tree Preorder Traversal (Easy)</li> <li> 590. N-ary Tree Postorder Traversal (Easy)</li> <li> 559. Maximum Depth of N-ary Tree (Easy)</li> <li> 429. N-ary Tree Level Order Traversal (Medium)</li> <li> 427. Construct Quad Tree (Medium)</li> <li> 558. Logical OR of Two Binary Grids Represented as Quad-Trees (Medium)</li> <li> 428. Serialize and Deserialize N-ary Tree (Hard) \ud83d\udc51</li> <li> 1490. Clone N-ary Tree (Medium) \ud83d\udc51</li> <li> 1506. Find Root of N-Ary Tree (Medium) \ud83d\udc51</li> <li> 1522. Diameter of N-Ary Tree (Medium) \ud83d\udc51</li> <li> 1516. Move Sub-Tree of N-Ary Tree (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/n-ary_tree/#589-n-ary-tree-preorder-traversal","title":"589. N-ary Tree Preorder Traversal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Stack, Tree, Depth First Search</p> </li> </ul>"},{"location":"EndlessCheng/n-ary_tree/#590-n-ary-tree-postorder-traversal","title":"590. N-ary Tree Postorder Traversal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Stack, Tree, Depth First Search</p> </li> </ul>"},{"location":"EndlessCheng/n-ary_tree/#559-maximum-depth-of-n-ary-tree","title":"559. Maximum Depth of N-ary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search</p> </li> </ul>"},{"location":"EndlessCheng/n-ary_tree/#429-n-ary-tree-level-order-traversal","title":"429. N-ary Tree Level Order Traversal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Breadth First Search</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List, Optional\n\n\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\n\ndef levelOrder(root: Optional[Node]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    queue = deque([root])\n    result = []\n\n    while queue:\n        level = []\n        size = len(queue)\n\n        for _ in range(size):\n            node = queue.popleft()\n            level.append(node.val)\n\n            for child in node.children:\n                queue.append(child)\n\n        result.append(level)\n\n    return result\n\n\nroot = Node(\n    1,\n    [\n        Node(\n            3,\n            [\n                Node(5, []),\n                Node(6, []),\n            ],\n        ),\n        Node(2, []),\n        Node(4, []),\n    ],\n)\nprint(levelOrder(root))  # [[1], [3, 2, 4], [5, 6]]\n</code></pre>"},{"location":"EndlessCheng/n-ary_tree/#427-construct-quad-tree","title":"427. Construct Quad Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Divide And Conquer, Tree, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/n-ary_tree/#558-logical-or-of-two-binary-grids-represented-as-quad-trees","title":"558. Logical OR of Two Binary Grids Represented as Quad-Trees","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Divide And Conquer, Tree</p> </li> </ul>"},{"location":"EndlessCheng/n-ary_tree/#428-serialize-and-deserialize-n-ary-tree","title":"428. Serialize and Deserialize N-ary Tree \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Tree, Depth First Search, Breadth First Search</p> </li> </ul> Python <pre><code>from typing import List, Optional\n\n\nclass Node(object):\n    def __init__(\n        self,\n        val: Optional[int] = None,\n        children: Optional[List[\"Node\"]] = None,\n    ):\n        if children is None:\n            children = []\n        self.val = val\n        self.children = children\n\n\n# DFS\nclass CodecDFS:\n    def serialize(self, root: \"Node\") -&gt; str:\n        \"\"\"Encodes a tree to a single string.\n\n        :type root: Node\n        :rtype: str\n        \"\"\"\n        if not root:\n            return \"*\"\n\n        data = \"\"\n        data += str(root.val) + \"|\" + str(len(root.children))\n        for child in root.children:\n            data += \"|\" + self.serialize(child)\n        return data\n\n    def deserialize(self, data: str) -&gt; \"Node\":\n        \"\"\"Decodes your encoded data to tree.\n\n        :type data: str\n        :rtype: Node\n        \"\"\"\n        if data == \"*\":\n            return None\n\n        data = data.split(\"|\")[::-1]\n\n        def dfs(data):\n            root = Node(int(data.pop()))\n            size = int(data.pop())\n            for i in range(size):\n                root.children.append(dfs(data))\n            return root\n\n        return dfs(data)\n\n\nif __name__ == \"__main__\":\n    obj = CodecDFS()\n    root = Node(1, [Node(3, [Node(5), Node(6)]), Node(2), Node(4)])\n    data = obj.serialize(root)\n    print(data)  # 1|3|3|2|5|0|6|0|2|0|4|0\n    root = obj.deserialize(data)\n    print(root.val)  # 1\n    print(root.children[0].val)  # 3\n    print(root.children[1].val)  # 2\n    print(root.children[2].val)  # 4\n    print(root.children[0].children[0].val)  # 5\n</code></pre>"},{"location":"EndlessCheng/n-ary_tree/#1490-clone-n-ary-tree","title":"1490. Clone N-ary Tree \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Tree, Depth First Search, Breadth First Search</p> </li> </ul>"},{"location":"EndlessCheng/n-ary_tree/#1506-find-root-of-n-ary-tree","title":"1506. Find Root of N-Ary Tree \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Bit Manipulation, Tree, Depth First Search</p> </li> </ul>"},{"location":"EndlessCheng/n-ary_tree/#1522-diameter-of-n-ary-tree","title":"1522. Diameter of N-Ary Tree \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search</p> </li> </ul> Python <pre><code>from typing import List, Optional\n\n\nclass Node:\n    def __init__(\n        self,\n        val: Optional[int] = None,\n        children: Optional[List[\"Node\"]] = None,\n    ):\n        self.val = val\n        self.children = children if children is not None else []\n\n\ndef diameter(root: \"Node\") -&gt; int:\n\n    def dfs(node):\n        if not node.children:\n            return 1, 1\n        mx0, mx1 = 0, 0\n        mxf = 0\n        for child in node.children:\n            hl, fl = dfs(child)\n            mxf = max(mxf, fl)\n            if hl &gt; mx1:\n                if hl &lt; mx0:\n                    mx1 = hl\n                else:\n                    mx0, mx1 = hl, mx0\n        return mx0 + 1, max(mxf, mx0 + mx1 + 1)\n\n    return dfs(root)[1] - 1\n\n\nroot = [1, None, 2, None, 3, 4, None, 5, None, 6]\nroot = Node(1)\nroot.children = [Node(2)]\nroot.children[0].children = [Node(3), Node(4)]\nroot.children[0].children[0].children = [Node(5)]\nroot.children[0].children[1].children = [Node(6)]\nprint(diameter(root))  # 4\n</code></pre>"},{"location":"EndlessCheng/n-ary_tree/#1516-move-sub-tree-of-n-ary-tree","title":"1516. Move Sub-Tree of N-Ary Tree \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search</p> </li> </ul>"},{"location":"EndlessCheng/network_flow/","title":"Network Flow","text":""},{"location":"EndlessCheng/network_flow/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3376. Minimum Time to Break Locks I (Medium)</li> <li> 1947. Maximum Compatibility Score Sum (Medium)</li> <li> 2850. Minimum Moves to Spread Stones Over Grid (Medium)</li> <li> 1879. Minimum XOR Sum of Two Arrays (Hard)</li> <li> 1349. Maximum Students Taking Exam (Hard)</li> <li> 2172. Maximum AND Sum of Array (Hard)</li> <li> 3276. Select Cells in Grid With Maximum Score (Hard)</li> <li> 1595. Minimum Cost to Connect Two Groups of Points (Hard)</li> <li> 3257. Maximum Value Sum by Placing Three Rooks II (Hard)</li> <li> 1820. Maximum Number of Accepted Invitations (Medium) \ud83d\udc51</li> <li> 2403. Minimum Time to Kill All Monsters (Hard) \ud83d\udc51</li> <li> 3385. Minimum Time to Break Locks II (Hard) \ud83d\udc51</li> <li> 1066. Campus Bikes II (Medium) \ud83d\udc51</li> <li> 2123. Minimum Operations to Remove Adjacent Ones in Matrix (Hard) \ud83d\udc51</li> <li> 2463. Minimum Total Distance Traveled (Hard)</li> </ul>"},{"location":"EndlessCheng/network_flow/#3376-minimum-time-to-break-locks-i","title":"3376. Minimum Time to Break Locks I","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Backtracking, Bit Manipulation, Depth First Search, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/network_flow/#1947-maximum-compatibility-score-sum","title":"1947. Maximum Compatibility Score Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Backtracking, Bit Manipulation, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/network_flow/#2850-minimum-moves-to-spread-stones-over-grid","title":"2850. Minimum Moves to Spread Stones Over Grid","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Breadth First Search, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/network_flow/#1879-minimum-xor-sum-of-two-arrays","title":"1879. Minimum XOR Sum of Two Arrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Bit Manipulation, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/network_flow/#1349-maximum-students-taking-exam","title":"1349. Maximum Students Taking Exam","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Bit Manipulation, Matrix, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/network_flow/#2172-maximum-and-sum-of-array","title":"2172. Maximum AND Sum of Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Bit Manipulation, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/network_flow/#3276-select-cells-in-grid-with-maximum-score","title":"3276. Select Cells in Grid With Maximum Score","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Bit Manipulation, Matrix, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/network_flow/#1595-minimum-cost-to-connect-two-groups-of-points","title":"1595. Minimum Cost to Connect Two Groups of Points","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Bit Manipulation, Matrix, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/network_flow/#3257-maximum-value-sum-by-placing-three-rooks-ii","title":"3257. Maximum Value Sum by Placing Three Rooks II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Matrix, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/network_flow/#1820-maximum-number-of-accepted-invitations","title":"1820. Maximum Number of Accepted Invitations \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Graph, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/network_flow/#2403-minimum-time-to-kill-all-monsters","title":"2403. Minimum Time to Kill All Monsters \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Bit Manipulation, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/network_flow/#3385-minimum-time-to-break-locks-ii","title":"3385. Minimum Time to Break Locks II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Graph</p> </li> </ul>"},{"location":"EndlessCheng/network_flow/#1066-campus-bikes-ii","title":"1066. Campus Bikes II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Backtracking, Bit Manipulation, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/network_flow/#2123-minimum-operations-to-remove-adjacent-ones-in-matrix","title":"2123. Minimum Operations to Remove Adjacent Ones in Matrix \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Graph, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/network_flow/#2463-minimum-total-distance-traveled","title":"2463. Minimum Total Distance Traveled","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/non-overlapping_intervals/","title":"Non-Overlapping Intervals","text":""},{"location":"EndlessCheng/non-overlapping_intervals/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 435. Non-overlapping Intervals (Medium)</li> <li> 646. Maximum Length of Pair Chain (Medium)</li> <li> 1520. Maximum Number of Non-Overlapping Substrings (Hard)</li> <li> 3458. Select K Disjoint Special Substrings (Medium)</li> </ul>"},{"location":"EndlessCheng/non-overlapping_intervals/#435-non-overlapping-intervals","title":"435. Non-overlapping Intervals","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy, Sorting</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef eraseOverlapIntervals(intervals: List[List[int]]) -&gt; int:\n    if len(intervals) &lt;= 1:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n    result = 0\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &gt;= intervals[i - 1][1]:\n            continue\n        else:\n            result += 1\n            intervals[i][1] = min(intervals[i][1], intervals[i - 1][1])\n\n    return result\n\n\nprint(eraseOverlapIntervals([[1, 2], [2, 3], [3, 4], [1, 3]]))  # 1\n</code></pre>"},{"location":"EndlessCheng/non-overlapping_intervals/#646-maximum-length-of-pair-chain","title":"646. Maximum Length of Pair Chain","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/non-overlapping_intervals/#1520-maximum-number-of-non-overlapping-substrings","title":"1520. Maximum Number of Non-Overlapping Substrings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/non-overlapping_intervals/#3458-select-k-disjoint-special-substrings","title":"3458. Select K Disjoint Special Substrings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Dynamic Programming, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/number_theory_others/","title":"Number Theory Others","text":""},{"location":"EndlessCheng/number_theory_others/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 326. Power of Three (Easy)</li> <li> 633. Sum of Square Numbers (Medium)</li> <li> 279. Perfect Squares (Medium)</li> <li> 1015. Smallest Integer Divisible by K (Medium)</li> <li> 2240. Number of Ways to Buy Pens and Pencils (Medium)</li> <li> 2221. Find Triangular Sum of an Array (Medium)</li> </ul>"},{"location":"EndlessCheng/number_theory_others/#326-power-of-three","title":"326. Power of Three","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Recursion</p> </li> </ul>"},{"location":"EndlessCheng/number_theory_others/#633-sum-of-square-numbers","title":"633. Sum of Square Numbers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Two Pointers, Binary Search</p> </li> </ul>"},{"location":"EndlessCheng/number_theory_others/#279-perfect-squares","title":"279. Perfect Squares","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Breadth First Search</p> </li> </ul> Python <pre><code>import math\n\n\n# DP - Knapsack Unbounded\ndef numSquares(n: int) -&gt; int:\n    dp = [float(\"inf\") for _ in range(n + 1)]\n    dp[0] = 0\n\n    for i in range(1, n + 1):\n        for j in range(1, int(math.sqrt(n)) + 1):\n            dp[i] = min(dp[i], dp[i - j**2] + 1)\n\n    return dp[n]\n\n\nn = 12\nprint(numSquares(n))  # 3\n</code></pre>"},{"location":"EndlessCheng/number_theory_others/#1015-smallest-integer-divisible-by-k","title":"1015. Smallest Integer Divisible by K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Math</p> </li> </ul>"},{"location":"EndlessCheng/number_theory_others/#2240-number-of-ways-to-buy-pens-and-pencils","title":"2240. Number of Ways to Buy Pens and Pencils","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/number_theory_others/#2221-find-triangular-sum-of-an-array","title":"2221. Find Triangular Sum of an Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Simulation, Combinatorics</p> </li> </ul>"},{"location":"EndlessCheng/offline_algorithm/","title":"Offline Algorithm","text":""},{"location":"EndlessCheng/offline_algorithm/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2343. Query Kth Smallest Trimmed Number (Medium)</li> <li> 2070. Most Beautiful Item for Each Query (Medium)</li> <li> 1847. Closest Room (Hard)</li> <li> 2503. Maximum Number of Points From Grid Queries (Hard)</li> <li> 1851. Minimum Interval to Include Each Query (Hard)</li> <li> 1697. Checking Existence of Edge Length Limited Paths (Hard)</li> <li> 2940. Find Building Where Alice and Bob Can Meet (Hard)</li> <li> 2747. Count Zero Request Servers (Medium)</li> <li> 1938. Maximum Genetic Difference Query (Hard)</li> <li> 2736. Maximum Sum Queries (Hard)</li> <li> 3382. Maximum Area Rectangle With Point Constraints II (Hard)</li> </ul>"},{"location":"EndlessCheng/offline_algorithm/#2343-query-kth-smallest-trimmed-number","title":"2343. Query Kth Smallest Trimmed Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Divide And Conquer, Sorting, Heap Priority Queue, Radix Sort, Quickselect</p> </li> </ul>"},{"location":"EndlessCheng/offline_algorithm/#2070-most-beautiful-item-for-each-query","title":"2070. Most Beautiful Item for Each Query","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Sorting</p> </li> </ul> CPP <pre><code>#include &lt;algorithm&gt;\n#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;numeric&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;int&gt; maximumBeauty(vector&lt;vector&lt;int&gt;&gt;&amp; items, vector&lt;int&gt;&amp; queries) {\n    std::sort(items.begin(), items.end(),\n              [](const auto&amp; a, const auto&amp; b) { return a[0] &lt; b[0]; });\n    vector&lt;int&gt; idx(queries.size());\n    iota(idx.begin(), idx.end(), 0);\n    std::sort(idx.begin(), idx.end(),\n              [&amp;](int i, int j) { return queries[i] &lt; queries[j]; });\n\n    vector&lt;int&gt; res(queries.size());\n    int max_beauty = 0;\n    size_t j = 0;\n    for (int i : idx) {\n        int q = queries[i];\n        while (j &lt; items.size() &amp;&amp; items[j][0] &lt;= q) {\n            max_beauty = max(max_beauty, items[j][1]);\n            j++;\n        }\n        res[i] = max_beauty;\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;vector&lt;int&gt;&gt; items = {{1, 2}, {2, 4}, {3, 2}, {5, 6}, {3, 5}};\n    vector&lt;int&gt; queries = {1, 2, 3, 4, 5, 6};\n    vector&lt;int&gt; res = maximumBeauty(items, queries);\n    assert((res == vector&lt;int&gt;{2, 4, 5, 5, 6, 6}));\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/offline_algorithm/#1847-closest-room","title":"1847. Closest Room","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Sorting, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/offline_algorithm/#2503-maximum-number-of-points-from-grid-queries","title":"2503. Maximum Number of Points From Grid Queries","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Breadth First Search, Union Find, Sorting, Heap Priority Queue, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/offline_algorithm/#1851-minimum-interval-to-include-each-query","title":"1851. Minimum Interval to Include Each Query","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Line Sweep, Sorting, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/offline_algorithm/#1697-checking-existence-of-edge-length-limited-paths","title":"1697. Checking Existence of Edge Length Limited Paths","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Union Find, Graph, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/offline_algorithm/#2940-find-building-where-alice-and-bob-can-meet","title":"2940. Find Building Where Alice and Bob Can Meet","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Stack, Binary Indexed Tree, Segment Tree, Heap Priority Queue, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/offline_algorithm/#2747-count-zero-request-servers","title":"2747. Count Zero Request Servers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Sliding Window, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/offline_algorithm/#1938-maximum-genetic-difference-query","title":"1938. Maximum Genetic Difference Query","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Bit Manipulation, Depth First Search, Trie</p> </li> </ul>"},{"location":"EndlessCheng/offline_algorithm/#2736-maximum-sum-queries","title":"2736. Maximum Sum Queries","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Stack, Binary Indexed Tree, Segment Tree, Sorting, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/offline_algorithm/#3382-maximum-area-rectangle-with-point-constraints-ii","title":"3382. Maximum Area Rectangle With Point Constraints II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Binary Indexed Tree, Segment Tree, Geometry, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/other_interval_greedy/","title":"Other Interval Greedy","text":""},{"location":"EndlessCheng/other_interval_greedy/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1288. Remove Covered Intervals (Medium)</li> <li> 2054. Two Best Non-Overlapping Events (Medium)</li> <li> 1705. Maximum Number of Eaten Apples (Medium)</li> <li> 1353. Maximum Number of Events That Can Be Attended (Medium)</li> <li> 2589. Minimum Time to Complete All Tasks (Hard)</li> </ul>"},{"location":"EndlessCheng/other_interval_greedy/#1288-remove-covered-intervals","title":"1288. Remove Covered Intervals","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/other_interval_greedy/#2054-two-best-non-overlapping-events","title":"2054. Two Best Non-Overlapping Events","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Dynamic Programming, Sorting, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/other_interval_greedy/#1705-maximum-number-of-eaten-apples","title":"1705. Maximum Number of Eaten Apples","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/other_interval_greedy/#1353-maximum-number-of-events-that-can-be-attended","title":"1353. Maximum Number of Events That Can Be Attended","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/other_interval_greedy/#2589-minimum-time-to-complete-all-tasks","title":"2589. Minimum Time to Complete All Tasks","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Stack, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/other_math_greedy/","title":"Other Math Greedy","text":""},{"location":"EndlessCheng/other_math_greedy/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K (Medium)</li> <li> 3107. Minimum Operations to Make Median of Array Equal to K (Medium)</li> <li> 754. Reach a Number (Medium)</li> <li> 1058. Minimize Rounding Error to Meet Target (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/other_math_greedy/#1414-find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k","title":"1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/other_math_greedy/#3107-minimum-operations-to-make-median-of-array-equal-to-k","title":"3107. Minimum Operations to Make Median of Array Equal to K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/other_math_greedy/#754-reach-a-number","title":"754. Reach a Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Binary Search</p> </li> </ul>"},{"location":"EndlessCheng/other_math_greedy/#1058-minimize-rounding-error-to-meet-target","title":"1058. Minimize Rounding Error to Meet Target \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, String, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/palindrome_greedy/","title":"Palindrome Greedy","text":""},{"location":"EndlessCheng/palindrome_greedy/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 409. Longest Palindrome (Easy)</li> <li> 2697. Lexicographically Smallest Palindrome (Easy)</li> <li> 680. Valid Palindrome II (Easy)</li> <li> 1328. Break a Palindrome (Medium)</li> <li> 1400. Construct K Palindrome Strings (Medium)</li> <li> 2131. Longest Palindrome by Concatenating Two Letter Words (Medium)</li> <li> 2384. Largest Palindromic Number (Medium)</li> <li> 3035. Maximum Palindromes After Operations (Medium)</li> <li> 1616. Split Two Strings to Make Palindrome (Medium)</li> <li> 1147. Longest Chunked Palindrome Decomposition (Hard)</li> <li> 2193. Minimum Number of Moves to Make Palindrome (Hard)</li> <li> 564. Find the Closest Palindrome (Hard)</li> <li> 266. Palindrome Permutation (Easy) \ud83d\udc51</li> <li> 2422. Merge Operations to Turn Array Into a Palindrome (Medium) \ud83d\udc51</li> <li> 1842. Next Palindrome Using Same Digits (Hard) \ud83d\udc51</li> <li> 3088. Make String Anti-palindrome (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/palindrome_greedy/#409-longest-palindrome","title":"409. Longest Palindrome","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Greedy</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the length of the longest palindrome that can be built with the characters in the string.\n\"\"\"\n\n\ndef longestPalindrome(s: str) -&gt; int:\n    hashmap = dict()\n    result = 0\n\n    for char in s:\n        if char not in hashmap or hashmap[char] == 0:\n            hashmap[char] = 1\n        else:\n            result += 2\n            hashmap[char] = 0\n\n    if any(hashmap.values()):\n        result += 1\n\n    return result\n\n\nprint(longestPalindrome(\"abccccdd\"))  # 7\n</code></pre>"},{"location":"EndlessCheng/palindrome_greedy/#2697-lexicographically-smallest-palindrome","title":"2697. Lexicographically Smallest Palindrome","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Greedy</p> </li> </ul> Python <pre><code>def makeSmallestPalindrome(s: str) -&gt; str:\n    n = len(s)\n    s = list(s)\n    left, right = 0, n - 1\n\n    while left &lt; right:\n        if s[left] &lt; s[right]:\n            s[right] = s[left]\n        elif s[left] &gt; s[right]:\n            s[left] = s[right]\n        left += 1\n        right -= 1\n\n    return \"\".join(s)\n\n\ns = \"egcfe\"\nprint(makeSmallestPalindrome(s))  # \"efcfe\"\n</code></pre>"},{"location":"EndlessCheng/palindrome_greedy/#680-valid-palindrome-ii","title":"680. Valid Palindrome II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/palindrome_greedy/#1328-break-a-palindrome","title":"1328. Break a Palindrome","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Greedy</p> </li> </ul> Python <pre><code># Greedy\ndef breakPalindrome(palindrome: str) -&gt; str:\n    n = len(palindrome)\n    if n == 1:\n        return \"\"\n\n    for i in range(n // 2):\n        if palindrome[i] != \"a\":\n            return palindrome[:i] + \"a\" + palindrome[i + 1 :]\n\n    return palindrome[:-1] + \"b\"\n\n\npalindrome = \"abccba\"\nprint(breakPalindrome(palindrome))  # \"aaccba\"\n</code></pre>"},{"location":"EndlessCheng/palindrome_greedy/#1400-construct-k-palindrome-strings","title":"1400. Construct K Palindrome Strings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Greedy, Counting</p> </li> </ul> Python <pre><code>from collections import Counter\n\n\ndef canConstructCounter(s: str, k: int) -&gt; bool:\n    if len(s) &lt; k:\n        return False\n\n    counts = Counter(s)\n    odd = 0\n\n    for c in counts.values():\n        odd += c % 2\n\n    return odd &lt;= k\n\n\ndef canConstructHash(s: str, k: int) -&gt; bool:\n    if len(s) &lt; k:\n        return False\n\n    counts = [0 for _ in range(26)]\n\n    for ch in s:\n        idx = ord(ch) - ord(\"a\")\n        if counts[idx] == 0:\n            counts[idx] += 1\n        else:\n            counts[idx] -= 1\n\n    return sum(counts) &lt;= k\n\n\ns = \"annabelle\"\nk = 2\nprint(canConstructCounter(s, k))  # True\nprint(canConstructHash(s, k))  # True\n</code></pre>"},{"location":"EndlessCheng/palindrome_greedy/#2131-longest-palindrome-by-concatenating-two-letter-words","title":"2131. Longest Palindrome by Concatenating Two Letter Words","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Greedy, Counting</p> </li> </ul>"},{"location":"EndlessCheng/palindrome_greedy/#2384-largest-palindromic-number","title":"2384. Largest Palindromic Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Greedy, Counting</p> </li> </ul>"},{"location":"EndlessCheng/palindrome_greedy/#3035-maximum-palindromes-after-operations","title":"3035. Maximum Palindromes After Operations","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Greedy, Sorting, Counting</p> </li> </ul>"},{"location":"EndlessCheng/palindrome_greedy/#1616-split-two-strings-to-make-palindrome","title":"1616. Split Two Strings to Make Palindrome","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String</p> </li> </ul>"},{"location":"EndlessCheng/palindrome_greedy/#1147-longest-chunked-palindrome-decomposition","title":"1147. Longest Chunked Palindrome Decomposition","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Dynamic Programming, Greedy, Rolling Hash, Hash Function</p> </li> </ul>"},{"location":"EndlessCheng/palindrome_greedy/#2193-minimum-number-of-moves-to-make-palindrome","title":"2193. Minimum Number of Moves to Make Palindrome","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Greedy, Binary Indexed Tree</p> </li> </ul>"},{"location":"EndlessCheng/palindrome_greedy/#564-find-the-closest-palindrome","title":"564. Find the Closest Palindrome","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String</p> </li> </ul>"},{"location":"EndlessCheng/palindrome_greedy/#266-palindrome-permutation","title":"266. Palindrome Permutation \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Bit Manipulation</p> </li> </ul> Python <pre><code>from collections import defaultdict\n\n\n# Hash\ndef canPermutePalindromeDict(s: str) -&gt; bool:\n    if len(s) == 1:\n        return True\n\n    count = defaultdict(int)\n\n    for ch in s:\n        if count[ch] == 1:\n            count[ch] = 0\n            continue\n        count[ch] = 1\n\n    return sum(count.values()) &lt;= 1\n\n\n# Set\ndef canPermutePalindromeSet(s: str) -&gt; bool:\n    if len(s) == 1:\n        return True\n\n    seen = set()\n\n    for ch in s:\n        if ch in seen:\n            seen.remove(ch)\n        else:\n            seen.add(ch)\n\n    return len(seen) &lt;= 1\n\n\nassert canPermutePalindromeDict(\"carerac\") is True\nassert canPermutePalindromeSet(\"carerac\") is True\n</code></pre>"},{"location":"EndlessCheng/palindrome_greedy/#2422-merge-operations-to-turn-array-into-a-palindrome","title":"2422. Merge Operations to Turn Array Into a Palindrome \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/palindrome_greedy/#1842-next-palindrome-using-same-digits","title":"1842. Next Palindrome Using Same Digits \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String</p> </li> </ul>"},{"location":"EndlessCheng/palindrome_greedy/#3088-make-string-anti-palindrome","title":"3088. Make String Anti-palindrome \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Greedy, Sorting, Counting Sort</p> </li> </ul>"},{"location":"EndlessCheng/palindromic_numbers/","title":"Palindromic Numbers","text":""},{"location":"EndlessCheng/palindromic_numbers/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 9. Palindrome Number (Easy)</li> <li> 2396. Strictly Palindromic Number (Medium)</li> <li> 2217. Find Palindrome With Fixed Length (Medium)</li> <li> 866. Prime Palindrome (Medium)</li> <li> 2967. Minimum Cost to Make Array Equalindromic (Medium)</li> <li> 906. Super Palindromes (Hard)</li> <li> 2081. Sum of k-Mirror Numbers (Hard)</li> <li> 3260. Find the Largest Palindrome Divisible by K (Hard)</li> <li> 3272. Find the Count of Good Integers (Hard)</li> <li> 564. Find the Closest Palindrome (Hard)</li> <li> 479. Largest Palindrome Product (Hard)</li> </ul>"},{"location":"EndlessCheng/palindromic_numbers/#9-palindrome-number","title":"9. Palindrome Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return true if the given number is a palindrome. Otherwise, return false.\n\"\"\"\n\n\n# Reverse\ndef isPalindromeReverse(x: int) -&gt; bool:\n    if x &lt; 0:\n        return False\n\n    return str(x) == str(x)[::-1]\n\n\n# Left Right Pointers\ndef isPalindromeLR(x: int) -&gt; bool:\n    if x &lt; 0:\n        return False\n\n    x = list(str(x))  # 121 -&gt; ['1', '2', '1']\n\n    left, right = 0, len(x) - 1\n\n    while left &lt; right:\n        if x[left] != x[right]:\n            return False\n        left += 1\n        right -= 1\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |  Reverse   |  O(N)  |   O(N)  |\n# | Left Right |  O(N)  |   O(1)  |\n# |------------|--------|---------|\n\n\nx = 121\nprint(isPalindromeReverse(x))  # True\nprint(isPalindromeLR(x))  # True\n</code></pre>"},{"location":"EndlessCheng/palindromic_numbers/#2396-strictly-palindromic-number","title":"2396. Strictly Palindromic Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Two Pointers, Brainteaser</p> </li> </ul>"},{"location":"EndlessCheng/palindromic_numbers/#2217-find-palindrome-with-fixed-length","title":"2217. Find Palindrome With Fixed Length","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math</p> </li> </ul>"},{"location":"EndlessCheng/palindromic_numbers/#866-prime-palindrome","title":"866. Prime Palindrome","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/palindromic_numbers/#2967-minimum-cost-to-make-array-equalindromic","title":"2967. Minimum Cost to Make Array Equalindromic","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Binary Search, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/palindromic_numbers/#906-super-palindromes","title":"906. Super Palindromes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/palindromic_numbers/#2081-sum-of-k-mirror-numbers","title":"2081. Sum of k-Mirror Numbers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/palindromic_numbers/#3260-find-the-largest-palindrome-divisible-by-k","title":"3260. Find the Largest Palindrome Divisible by K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String, Dynamic Programming, Greedy, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/palindromic_numbers/#3272-find-the-count-of-good-integers","title":"3272. Find the Count of Good Integers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Math, Combinatorics, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/palindromic_numbers/#564-find-the-closest-palindrome","title":"564. Find the Closest Palindrome","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String</p> </li> </ul>"},{"location":"EndlessCheng/palindromic_numbers/#479-largest-palindrome-product","title":"479. Largest Palindrome Product","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/partitioning_greedy/","title":"Partitioning Greedy","text":""},{"location":"EndlessCheng/partitioning_greedy/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1221. Split a String in Balanced Strings (Easy)</li> <li> 2405. Optimal Partition of String (Medium)</li> <li> 2294. Partition Array Such That Maximum Difference Is K (Medium)</li> <li> 2358. Maximum Number of Groups Entering a Competition (Medium)</li> <li> 2522. Partition String Into Substrings With Values at Most K (Medium)</li> <li> 1546. Maximum Number of Non-Overlapping Subarrays With Sum Equals Target (Medium)</li> <li> 2436. Minimum Split Into Subarrays With GCD Greater Than One (Medium) \ud83d\udc51</li> <li> 2892. Minimizing Array After Replacing Pairs With Their Product (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/partitioning_greedy/#1221-split-a-string-in-balanced-strings","title":"1221. Split a String in Balanced Strings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Greedy, Counting</p> </li> </ul>"},{"location":"EndlessCheng/partitioning_greedy/#2405-optimal-partition-of-string","title":"2405. Optimal Partition of String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/partitioning_greedy/#2294-partition-array-such-that-maximum-difference-is-k","title":"2294. Partition Array Such That Maximum Difference Is K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef partitionArray(nums: List[int], k: int) -&gt; int:\n    nums.sort()\n    mn = float(\"-inf\")\n    res = 0\n\n    for num in nums:\n        if num - mn &gt; k:\n            res += 1\n            mn = num\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert partitionArray([3, 6, 1, 2, 5], 2) == 2\n</code></pre>"},{"location":"EndlessCheng/partitioning_greedy/#2358-maximum-number-of-groups-entering-a-competition","title":"2358. Maximum Number of Groups Entering a Competition","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Binary Search, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/partitioning_greedy/#2522-partition-string-into-substrings-with-values-at-most-k","title":"2522. Partition String Into Substrings With Values at Most K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/partitioning_greedy/#1546-maximum-number-of-non-overlapping-subarrays-with-sum-equals-target","title":"1546. Maximum Number of Non-Overlapping Subarrays With Sum Equals Target","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Greedy, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/partitioning_greedy/#2436-minimum-split-into-subarrays-with-gcd-greater-than-one","title":"2436. Minimum Split Into Subarrays With GCD Greater Than One \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Greedy, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/partitioning_greedy/#2892-minimizing-array-after-replacing-pairs-with-their-product","title":"2892. Minimizing Array After Replacing Pairs With Their Product \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/points_and_lines/","title":"Points and Lines","text":""},{"location":"EndlessCheng/points_and_lines/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1232. Check If It Is a Straight Line (Easy)</li> <li> 2280. Minimum Lines to Represent a Line Chart (Medium)</li> <li> 1610. Maximum Number of Visible Points (Hard)</li> <li> 2152. Minimum Number of Lines to Cover Points (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/points_and_lines/#1232-check-if-it-is-a-straight-line","title":"1232. Check If It Is a Straight Line","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Geometry</p> </li> </ul>"},{"location":"EndlessCheng/points_and_lines/#2280-minimum-lines-to-represent-a-line-chart","title":"2280. Minimum Lines to Represent a Line Chart","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Geometry, Sorting, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/points_and_lines/#1610-maximum-number-of-visible-points","title":"1610. Maximum Number of Visible Points","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Geometry, Sliding Window, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/points_and_lines/#2152-minimum-number-of-lines-to-cover-points","title":"2152. Minimum Number of Lines to Cover Points \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Dynamic Programming, Backtracking, Bit Manipulation, Geometry, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/polynomial_convolution/","title":"Polynomial Convolution","text":""},{"location":"EndlessCheng/polynomial_convolution/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3400. Maximum Number of Matching Indices After Right Shifts (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/polynomial_convolution/#3400-maximum-number-of-matching-indices-after-right-shifts","title":"3400. Maximum Number of Matching Indices After Right Shifts \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Simulation</p> </li> </ul>"},{"location":"EndlessCheng/prefix_sum_basics/","title":"Prefix Sum Basics","text":""},{"location":"EndlessCheng/prefix_sum_basics/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 303. Range Sum Query - Immutable (Easy)</li> <li> 3427. Sum of Variable Length Subarrays (Easy)</li> <li> 2559. Count Vowel Strings in Ranges (Medium)</li> <li> 3152. Special Array II (Medium)</li> <li> 1749. Maximum Absolute Sum of Any Subarray (Medium)</li> <li> 2389. Longest Subsequence With Limited Sum (Easy)</li> <li> 3361. Shift Distance Between Two Strings (Medium)</li> <li> 2055. Plates Between Candles (Medium)</li> <li> 1744. Can You Eat Your Favorite Candy on Your Favorite Day? (Medium)</li> <li> 53. Maximum Subarray (Medium)</li> <li> 1523. Count Odd Numbers in an Interval Range (Easy)</li> </ul>"},{"location":"EndlessCheng/prefix_sum_basics/#303-range-sum-query-immutable","title":"303. Range Sum Query - Immutable","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Design, Prefix Sum</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Prefix Sum\nclass NumArray:\n\n    def __init__(self, nums: List[int]):\n        n = len(nums)\n        self.ps = [0 for _ in range(n + 1)]  # prefix sum\n        for i in range(1, n + 1):\n            self.ps[i] = self.ps[i - 1] + nums[i - 1]\n\n    def sumRange(self, left: int, right: int) -&gt; int:\n        return self.ps[right + 1] - self.ps[left]\n\n\nnums = [-2, 0, 3, -5, 2, -1]\nobj = NumArray(nums)\nassert obj.sumRange(0, 2) == 1\nassert obj.sumRange(2, 5) == -1\nassert obj.sumRange(0, 5) == -3\nprint(\"PASSED\")\n</code></pre>"},{"location":"EndlessCheng/prefix_sum_basics/#3427-sum-of-variable-length-subarrays","title":"3427. Sum of Variable Length Subarrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/prefix_sum_basics/#2559-count-vowel-strings-in-ranges","title":"2559. Count Vowel Strings in Ranges","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/prefix_sum_basics/#3152-special-array-ii","title":"3152. Special Array II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/prefix_sum_basics/#1749-maximum-absolute-sum-of-any-subarray","title":"1749. Maximum Absolute Sum of Any Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/prefix_sum_basics/#2389-longest-subsequence-with-limited-sum","title":"2389. Longest Subsequence With Limited Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Greedy, Sorting, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/prefix_sum_basics/#3361-shift-distance-between-two-strings","title":"3361. Shift Distance Between Two Strings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/prefix_sum_basics/#2055-plates-between-candles","title":"2055. Plates Between Candles","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Binary Search, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/prefix_sum_basics/#1744-can-you-eat-your-favorite-candy-on-your-favorite-day","title":"1744. Can You Eat Your Favorite Candy on Your Favorite Day?","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/prefix_sum_basics/#53-maximum-subarray","title":"53. Maximum Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Divide And Conquer, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP Kadane\ndef maxSubArrayDP(nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n\n    dp[0] = nums[0]\n    maxSum = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(\n            dp[i - 1] + nums[i],  # continue the previous subarray\n            nums[i],  # start a new subarray\n        )\n        maxSum = max(maxSum, dp[i])\n\n    return maxSum\n\n\n# Greedy\ndef maxSubArrayGreedy(nums: List[int]) -&gt; int:\n    max_sum = nums[0]\n    cur_sum = 0\n\n    for num in nums:\n        cur_sum = max(cur_sum + num, num)\n        max_sum = max(max_sum, cur_sum)\n\n    return max_sum\n\n\n# Prefix Sum\ndef maxSubArrayPrefixSum(nums: List[int]) -&gt; int:\n    prefix_sum = 0\n    prefix_sum_min = 0\n    res = float(\"-inf\")\n\n    for num in nums:\n        prefix_sum += num\n        res = max(res, prefix_sum - prefix_sum_min)\n        prefix_sum_min = min(prefix_sum_min, prefix_sum)\n\n    return res\n\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArrayDP(nums))  # 6\nprint(maxSubArrayGreedy(nums))  # 6\nprint(maxSubArrayPrefixSum(nums))  # 6\n</code></pre>"},{"location":"EndlessCheng/prefix_sum_basics/#1523-count-odd-numbers-in-an-interval-range","title":"1523. Count Odd Numbers in an Interval Range","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math</p> </li> </ul>"},{"location":"EndlessCheng/prefix_sum_with_hash_table/","title":"Prefix Sum with Hash Table","text":""},{"location":"EndlessCheng/prefix_sum_with_hash_table/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 930. Binary Subarrays With Sum (Medium)</li> <li> 560. Subarray Sum Equals K (Medium)</li> <li> 1524. Number of Sub-arrays With Odd Sum (Medium)</li> <li> 974. Subarray Sums Divisible by K (Medium)</li> <li> 523. Continuous Subarray Sum (Medium)</li> <li> 437. Path Sum III (Medium)</li> <li> 2588. Count the Number of Beautiful Subarrays (Medium)</li> <li> 525. Contiguous Array (Medium)</li> <li> 3026. Maximum Good Subarray Sum (Medium)</li> <li> 1477. Find Two Non-overlapping Sub-arrays Each With Target Sum (Medium)</li> <li> 1546. Maximum Number of Non-Overlapping Subarrays With Sum Equals Target (Medium)</li> <li> 1124. Longest Well-Performing Interval (Medium)</li> <li> 3381. Maximum Subarray Sum With Length Divisible by K (Medium)</li> <li> 2488. Count Subarrays With Median K (Hard)</li> <li> 1590. Make Sum Divisible by P (Medium)</li> <li> 2845. Count of Interesting Subarrays (Medium)</li> <li> 1442. Count Triplets That Can Form Two Arrays of Equal XOR (Medium)</li> <li> 2949. Count Beautiful Substrings II (Hard)</li> <li> 325. Maximum Size Subarray Sum Equals k (Medium) \ud83d\udc51</li> <li> 548. Split Array with Equal Sum (Hard) \ud83d\udc51</li> <li> 1983. Widest Pair of Indices With Equal Range Sum (Medium) \ud83d\udc51</li> <li> 2489. Number of Substrings With Fixed Ratio (Medium) \ud83d\udc51</li> <li> 2950. Number of Divisible Substrings (Medium) \ud83d\udc51</li> <li> 3364. Minimum Positive Sum Subarray  (Easy)</li> <li> 2025. Maximum Number of Ways to Partition an Array (Hard)</li> </ul>"},{"location":"EndlessCheng/prefix_sum_with_hash_table/#930-binary-subarrays-with-sum","title":"930. Binary Subarrays With Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Sliding Window, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/prefix_sum_with_hash_table/#560-subarray-sum-equals-k","title":"560. Subarray Sum Equals K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Prefix Sum</p> </li> </ul> PythonCPP <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Prefix Sum\ndef subarraySum(nums: List[int], k: int) -&gt; int:\n    preSums = defaultdict(int)\n    preSums[0] = 1\n    curSum = 0\n    res = 0\n\n    for num in nums:\n        curSum += num\n        res += preSums[curSum - k]\n        preSums[curSum] += 1\n\n    return res\n\n\nnums = [1, 1, 1]\nk = 2\nprint(subarraySum(nums, k))  # 2\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint subarraySum(vector&lt;int&gt;&amp; nums, int k) {\n    int n = nums.size();\n    vector&lt;int&gt; prefixSum(n + 1);\n    for (int i = 0; i &lt; n; i++) {\n        prefixSum[i + 1] = prefixSum[i] + nums[i];\n    }\n\n    int res = 0;\n    unordered_map&lt;int, int&gt; cnt;\n\n    for (int ps : prefixSum) {\n        if (cnt.find(ps - k) != cnt.end()) res += cnt[ps - k];\n        cnt[ps]++;\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {1, 1, 1};\n    int k = 2;\n    cout &lt;&lt; subarraySum(nums, k) &lt;&lt; endl;  // 2\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/prefix_sum_with_hash_table/#1524-number-of-sub-arrays-with-odd-sum","title":"1524. Number of Sub-arrays With Odd Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/prefix_sum_with_hash_table/#974-subarray-sums-divisible-by-k","title":"974. Subarray Sums Divisible by K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Prefix Sum</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef subarraysDivByK_1(nums: List[int], k: int) -&gt; int:\n    mods = {0: 1}\n    prefixSum, result = 0, 0\n\n    for num in nums:\n        prefixSum += num\n        mod = prefixSum % k\n\n        if mod &lt; 0:\n            mod += k\n\n        if mod in mods:\n            result += mods[mod]\n\n        if mod in mods:\n            mods[mod] += 1\n        else:\n            mods[mod] = 1\n\n    return result\n\n\ndef subarraysDivByK_2(nums: List[int], k: int) -&gt; int:\n    mods = {0: 1}\n    prefixSum, result = 0, 0\n\n    for num in nums:\n        prefixSum += num\n        mod = prefixSum % k\n        result += mods.get(mod, 0)\n        mods[mod] = mods.get(mod, 0) + 1\n\n    return result\n\n\nnums = [4, 5, 0, -2, -3, 1]\nk = 5\nprint(subarraysDivByK_1(nums, k))  # 7\nprint(subarraysDivByK_2(nums, k))  # 7\n</code></pre>"},{"location":"EndlessCheng/prefix_sum_with_hash_table/#523-continuous-subarray-sum","title":"523. Continuous Subarray Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Prefix Sum</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Prefix Sum\ndef checkSubarraySum(nums: List[int], k: int) -&gt; bool:\n    if k == 0:\n        for i in range(1, len(nums)):\n            if nums[i - 1] == 0 and nums[i] == 0:\n                return True\n\n    prefix_sum = 0\n    mod_dict = {0: -1}\n\n    for i, num in enumerate(nums):\n        prefix_sum += num\n        mod = prefix_sum % k\n\n        if mod in mod_dict:\n            if i - mod_dict[mod] &gt; 1:\n                return True\n        else:\n            mod_dict[mod] = i\n\n    return False\n\n\nnums = [23, 2, 4, 6, 7]\nk = 6\nprint(checkSubarraySum(nums, k))  # True\n</code></pre>"},{"location":"EndlessCheng/prefix_sum_with_hash_table/#437-path-sum-iii","title":"437. Path Sum III","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul> CPP <pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   public:\n    int pathSum(TreeNode *root, int targetSum) {\n        int res = 0;\n        unordered_map&lt;long long, int&gt; cnt{{0, 1}};\n\n        auto dfs = [&amp;](auto &amp;&amp;self, TreeNode *node, long long cur) {\n            if (!node) return;\n            cur += node-&gt;val;\n\n            if (cnt.find(cur - targetSum) != cnt.end())\n                res += cnt[cur - targetSum];\n\n            cnt[cur]++;\n            self(self, node-&gt;left, cur);\n            self(self, node-&gt;right, cur);\n            cnt[cur]--;\n        };\n\n        dfs(dfs, root, 0);\n        return res;\n    }\n};\n\nint main() {\n    Solution s;\n    {\n        TreeNode *root = new TreeNode(10);\n        root-&gt;left = new TreeNode(5);\n        root-&gt;right = new TreeNode(-3);\n        root-&gt;left-&gt;left = new TreeNode(3);\n        root-&gt;left-&gt;right = new TreeNode(2);\n        root-&gt;right-&gt;right = new TreeNode(11);\n        root-&gt;left-&gt;left-&gt;left = new TreeNode(3);\n        root-&gt;left-&gt;left-&gt;right = new TreeNode(-2);\n        root-&gt;left-&gt;right-&gt;right = new TreeNode(1);\n        cout &lt;&lt; s.pathSum(root, 8) &lt;&lt; endl;  // 3\n    }\n    {\n        TreeNode *root = new TreeNode(5);\n        root-&gt;left = new TreeNode(4);\n        root-&gt;right = new TreeNode(8);\n        root-&gt;left-&gt;left = new TreeNode(11);\n        root-&gt;right-&gt;left = new TreeNode(13);\n        root-&gt;right-&gt;right = new TreeNode(4);\n        root-&gt;left-&gt;left-&gt;left = new TreeNode(7);\n        root-&gt;left-&gt;left-&gt;right = new TreeNode(2);\n        root-&gt;right-&gt;right-&gt;left = new TreeNode(5);\n        root-&gt;right-&gt;right-&gt;right = new TreeNode(1);\n        cout &lt;&lt; s.pathSum(root, 22) &lt;&lt; endl;  // 3\n    }\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/prefix_sum_with_hash_table/#2588-count-the-number-of-beautiful-subarrays","title":"2588. Count the Number of Beautiful Subarrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Bit Manipulation, Prefix Sum</p> </li> </ul> Python <p><pre><code>\"\"\"\n- `nums = [4, 3, 1, 2, 4]`\n- In bianry\n</code></pre> 4 -&gt; 100 3 -&gt; 011 1 -&gt; 001 2 -&gt; 010 4 -&gt; 100 <pre><code>\"\"\"\n\nfrom collections import defaultdict\nfrom typing import List\n\n\ndef beautifulSubarrays(nums: List[int]) -&gt; int:\n    res, s = 0, 0\n    cnt = defaultdict(int)\n    cnt[0] = 1\n\n    for x in nums:\n        s ^= x\n        res += cnt[s]\n        cnt[s] += 1\n\n    return res\n\n\nnums = [4, 3, 1, 2, 4]\nprint(beautifulSubarrays(nums))  # 2\n</code></pre></p>"},{"location":"EndlessCheng/prefix_sum_with_hash_table/#525-contiguous-array","title":"525. Contiguous Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/prefix_sum_with_hash_table/#3026-maximum-good-subarray-sum","title":"3026. Maximum Good Subarray Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/prefix_sum_with_hash_table/#1477-find-two-non-overlapping-sub-arrays-each-with-target-sum","title":"1477. Find Two Non-overlapping Sub-arrays Each With Target Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Binary Search, Dynamic Programming, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/prefix_sum_with_hash_table/#1546-maximum-number-of-non-overlapping-subarrays-with-sum-equals-target","title":"1546. Maximum Number of Non-Overlapping Subarrays With Sum Equals Target","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Greedy, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/prefix_sum_with_hash_table/#1124-longest-well-performing-interval","title":"1124. Longest Well-Performing Interval","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Stack, Monotonic Stack, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/prefix_sum_with_hash_table/#3381-maximum-subarray-sum-with-length-divisible-by-k","title":"3381. Maximum Subarray Sum With Length Divisible by K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/prefix_sum_with_hash_table/#2488-count-subarrays-with-median-k","title":"2488. Count Subarrays With Median K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/prefix_sum_with_hash_table/#1590-make-sum-divisible-by-p","title":"1590. Make Sum Divisible by P","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/prefix_sum_with_hash_table/#2845-count-of-interesting-subarrays","title":"2845. Count of Interesting Subarrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/prefix_sum_with_hash_table/#1442-count-triplets-that-can-form-two-arrays-of-equal-xor","title":"1442. Count Triplets That Can Form Two Arrays of Equal XOR","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Bit Manipulation, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/prefix_sum_with_hash_table/#2949-count-beautiful-substrings-ii","title":"2949. Count Beautiful Substrings II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Math, String, Number Theory, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/prefix_sum_with_hash_table/#325-maximum-size-subarray-sum-equals-k","title":"325. Maximum Size Subarray Sum Equals k \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Prefix Sum</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Prefix Sum\ndef maxSubArrayLen(nums: List[int], k: int) -&gt; int:\n    res = 0\n    prefix = 0\n    sumMap = {0: -1}  # sum -&gt; index\n\n    for i, num in enumerate(nums):\n        prefix += num\n        if prefix - k in sumMap:\n            res = max(res, i - sumMap[prefix - k])\n        if prefix not in sumMap:\n            sumMap[prefix] = i\n\n    return res\n\n\nnums = [1, -1, 5, -2, 3]\nk = 3\nprint(maxSubArrayLen(nums, k))  # 4\n</code></pre>"},{"location":"EndlessCheng/prefix_sum_with_hash_table/#548-split-array-with-equal-sum","title":"548. Split Array with Equal Sum \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/prefix_sum_with_hash_table/#1983-widest-pair-of-indices-with-equal-range-sum","title":"1983. Widest Pair of Indices With Equal Range Sum \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/prefix_sum_with_hash_table/#2489-number-of-substrings-with-fixed-ratio","title":"2489. Number of Substrings With Fixed Ratio \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Math, String, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/prefix_sum_with_hash_table/#2950-number-of-divisible-substrings","title":"2950. Number of Divisible Substrings \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Counting, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/prefix_sum_with_hash_table/#3364-minimum-positive-sum-subarray","title":"3364. Minimum Positive Sum Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sliding Window, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/prefix_sum_with_hash_table/#2025-maximum-number-of-ways-to-partition-an-array","title":"2025. Maximum Number of Ways to Partition an Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Counting, Enumeration, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/prefix_xor_sum/","title":"Prefix XOR Sum","text":""},{"location":"EndlessCheng/prefix_xor_sum/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1177. Can Make Palindrome from Substring (Medium)</li> <li> 1371. Find the Longest Substring Containing Vowels in Even Counts (Medium)</li> <li> 1542. Find Longest Awesome Substring (Hard)</li> <li> 1915. Number of Wonderful Substrings (Medium)</li> <li> 2791. Count Paths That Can Form a Palindrome in a Tree (Hard)</li> </ul>"},{"location":"EndlessCheng/prefix_xor_sum/#1177-can-make-palindrome-from-substring","title":"1177. Can Make Palindrome from Substring","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Bit Manipulation, Prefix Sum</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Prefix XOR Sum\ndef canMakePaliQueries(s: str, queries: List[List[int]]) -&gt; List[bool]:\n    sum = [[0] * 26]\n    for c in s:\n        sum.append(sum[-1].copy())\n        sum[-1][ord(c) - ord(\"a\")] ^= 1  # \u5947\u6570\u53d8\u5076\u6570\uff0c\u5076\u6570\u53d8\u5947\u6570\n\n    ans = []\n    for left, right, k in queries:\n        m = 0\n        for sl, sr in zip(sum[left], sum[right + 1]):\n            m += sr ^ sl\n        ans.append(m // 2 &lt;= k)\n    return ans\n\n\nif __name__ == \"__main__\":\n    s = \"abcda\"\n    queries = [[3, 3, 0], [1, 2, 0], [0, 3, 1], [0, 3, 2], [0, 4, 1]]\n    assert canMakePaliQueries(s, queries) == [True, False, False, True, True]\n</code></pre>"},{"location":"EndlessCheng/prefix_xor_sum/#1371-find-the-longest-substring-containing-vowels-in-even-counts","title":"1371. Find the Longest Substring Containing Vowels in Even Counts","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Bit Manipulation, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/prefix_xor_sum/#1542-find-longest-awesome-substring","title":"1542. Find Longest Awesome Substring","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/prefix_xor_sum/#1915-number-of-wonderful-substrings","title":"1915. Number of Wonderful Substrings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Bit Manipulation, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/prefix_xor_sum/#2791-count-paths-that-can-form-a-palindrome-in-a-tree","title":"2791. Count Paths That Can Form a Palindrome in a Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Bit Manipulation, Tree, Depth First Search, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/prime_check/","title":"Prime Check","text":""},{"location":"EndlessCheng/prime_check/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3115. Maximum Prime Difference (Medium)</li> <li> 2614. Prime In Diagonal (Easy)</li> <li> 762. Prime Number of Set Bits in Binary Representation (Easy)</li> <li> 3044. Most Frequent Prime (Medium)</li> <li> 866. Prime Palindrome (Medium)</li> </ul>"},{"location":"EndlessCheng/prime_check/#3115-maximum-prime-difference","title":"3115. Maximum Prime Difference","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/prime_check/#2614-prime-in-diagonal","title":"2614. Prime In Diagonal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Matrix, Number Theory</p> </li> </ul> Python <pre><code>from math import isqrt\nfrom typing import List\n\n\n# Prime\ndef diagonalPrime(nums: List[List[int]]) -&gt; int:\n    def is_prime(n):\n        if n &lt;= 1:\n            return False\n\n        for i in range(2, isqrt(n) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    res = 0\n    for i, row in enumerate(nums):\n        for x in row[i], row[-1 - i]:\n            if x &gt; res and is_prime(x):\n                res = x\n\n    return res\n\n\nif __name__ == \"__main__\":\n    nums = [[1, 2, 3], [5, 6, 7], [9, 10, 11]]\n    print(diagonalPrime(nums))  # 11\n</code></pre>"},{"location":"EndlessCheng/prime_check/#762-prime-number-of-set-bits-in-binary-representation","title":"762. Prime Number of Set Bits in Binary Representation","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/prime_check/#3044-most-frequent-prime","title":"3044. Most Frequent Prime","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Matrix, Counting, Enumeration, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/prime_check/#866-prime-palindrome","title":"866. Prime Palindrome","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/prime_factorization/","title":"Prime Factorization","text":""},{"location":"EndlessCheng/prime_factorization/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2521. Distinct Prime Factors of Product of Array (Medium)</li> <li> 2507. Smallest Value After Replacing With Sum of Prime Factors (Medium)</li> <li> 3326. Minimum Division Operations to Make Array Non Decreasing (Medium)</li> <li> 2584. Split the Array to Make Coprime Products (Hard)</li> <li> 2709. Greatest Common Divisor Traversal (Hard)</li> <li> 2862. Maximum Element-Sum of a Complete Subset of Indices (Hard)</li> <li> 2818. Apply Operations to Maximize Score (Hard)</li> <li> 1998. GCD Sort of an Array (Hard)</li> <li> 1735. Count Ways to Make Array With Product (Hard)</li> <li> 2338. Count the Number of Ideal Arrays (Hard)</li> </ul>"},{"location":"EndlessCheng/prime_factorization/#2521-distinct-prime-factors-of-product-of-array","title":"2521. Distinct Prime Factors of Product of Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/prime_factorization/#2507-smallest-value-after-replacing-with-sum-of-prime-factors","title":"2507. Smallest Value After Replacing With Sum of Prime Factors","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Simulation, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/prime_factorization/#3326-minimum-division-operations-to-make-array-non-decreasing","title":"3326. Minimum Division Operations to Make Array Non Decreasing","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Greedy, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/prime_factorization/#2584-split-the-array-to-make-coprime-products","title":"2584. Split the Array to Make Coprime Products","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/prime_factorization/#2709-greatest-common-divisor-traversal","title":"2709. Greatest Common Divisor Traversal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Union Find, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/prime_factorization/#2862-maximum-element-sum-of-a-complete-subset-of-indices","title":"2862. Maximum Element-Sum of a Complete Subset of Indices","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/prime_factorization/#2818-apply-operations-to-maximize-score","title":"2818. Apply Operations to Maximize Score","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Stack, Greedy, Sorting, Monotonic Stack, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/prime_factorization/#1998-gcd-sort-of-an-array","title":"1998. GCD Sort of an Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Union Find, Sorting, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/prime_factorization/#1735-count-ways-to-make-array-with-product","title":"1735. Count Ways to Make Array With Product","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Combinatorics, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/prime_factorization/#2338-count-the-number-of-ideal-arrays","title":"2338. Count the Number of Ideal Arrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Combinatorics, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/prime_preprocessing/","title":"Prime Preprocessing","text":""},{"location":"EndlessCheng/prime_preprocessing/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 204. Count Primes (Medium)</li> <li> 2761. Prime Pairs With Target Sum (Medium)</li> <li> 3233. Find the Count of Numbers Which Are Not Special (Medium)</li> <li> 2523. Closest Prime Numbers in Range (Medium)</li> <li> 2601. Prime Subtraction Operation (Medium)</li> </ul>"},{"location":"EndlessCheng/prime_preprocessing/#204-count-primes","title":"204. Count Primes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Enumeration, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/prime_preprocessing/#2761-prime-pairs-with-target-sum","title":"2761. Prime Pairs With Target Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Enumeration, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/prime_preprocessing/#3233-find-the-count-of-numbers-which-are-not-special","title":"3233. Find the Count of Numbers Which Are Not Special","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/prime_preprocessing/#2523-closest-prime-numbers-in-range","title":"2523. Closest Prime Numbers in Range","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/prime_preprocessing/#2601-prime-subtraction-operation","title":"2601. Prime Subtraction Operation","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Binary Search, Greedy, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/probability_and_expectation/","title":"Probability and Expectation","text":""},{"location":"EndlessCheng/probability_and_expectation/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1227. Airplane Seat Assignment Probability (Medium)</li> <li> 688. Knight Probability in Chessboard (Medium)</li> <li> 837. New 21 Game (Medium)</li> <li> 1467. Probability of a Two Boxes Having The Same Number of Distinct Balls (Hard)</li> <li> 808. Soup Servings (Medium)</li> <li> 1230. Toss Strange Coins (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/probability_and_expectation/#1227-airplane-seat-assignment-probability","title":"1227. Airplane Seat Assignment Probability","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Brainteaser, Probability And Statistics</p> </li> </ul>"},{"location":"EndlessCheng/probability_and_expectation/#688-knight-probability-in-chessboard","title":"688. Knight Probability in Chessboard","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/probability_and_expectation/#837-new-21-game","title":"837. New 21 Game","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Sliding Window, Probability And Statistics</p> </li> </ul>"},{"location":"EndlessCheng/probability_and_expectation/#1467-probability-of-a-two-boxes-having-the-same-number-of-distinct-balls","title":"1467. Probability of a Two Boxes Having The Same Number of Distinct Balls","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Backtracking, Combinatorics, Probability And Statistics</p> </li> </ul>"},{"location":"EndlessCheng/probability_and_expectation/#808-soup-servings","title":"808. Soup Servings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Probability And Statistics</p> </li> </ul>"},{"location":"EndlessCheng/probability_and_expectation/#1230-toss-strange-coins","title":"1230. Toss Strange Coins \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Probability And Statistics</p> </li> </ul>"},{"location":"EndlessCheng/product_greedy/","title":"Product Greedy","text":""},{"location":"EndlessCheng/product_greedy/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 628. Maximum Product of Three Numbers (Easy)</li> <li> 1567. Maximum Length of Subarray With Positive Product (Medium)</li> </ul>"},{"location":"EndlessCheng/product_greedy/#628-maximum-product-of-three-numbers","title":"628. Maximum Product of Three Numbers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/product_greedy/#1567-maximum-length-of-subarray-with-positive-product","title":"1567. Maximum Length of Subarray With Positive Product","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/queue_basics/","title":"Queue Basics","text":""},{"location":"EndlessCheng/queue_basics/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 933. Number of Recent Calls (Easy)</li> <li> 950. Reveal Cards In Increasing Order (Medium)</li> <li> 649. Dota2 Senate (Medium)</li> <li> 346. Moving Average from Data Stream (Easy) \ud83d\udc51</li> <li> 362. Design Hit Counter (Medium) \ud83d\udc51</li> <li> 379. Design Phone Directory (Medium) \ud83d\udc51</li> <li> 1429. First Unique Number (Medium) \ud83d\udc51</li> <li> 2534. Time Taken to Cross the Door (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/queue_basics/#933-number-of-recent-calls","title":"933. Number of Recent Calls","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Design, Queue, Data Stream</p> </li> </ul>"},{"location":"EndlessCheng/queue_basics/#950-reveal-cards-in-increasing-order","title":"950. Reveal Cards In Increasing Order","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Queue, Sorting, Simulation</p> </li> </ul>"},{"location":"EndlessCheng/queue_basics/#649-dota2-senate","title":"649. Dota2 Senate","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Greedy, Queue</p> </li> </ul>"},{"location":"EndlessCheng/queue_basics/#346-moving-average-from-data-stream","title":"346. Moving Average from Data Stream \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Design, Queue, Data Stream</p> </li> </ul> Python <pre><code>from collections import deque\n\n\n# Deque\nclass MovingAverage:\n    def __init__(self, size: int):\n        self.q = deque()\n        self.cur = 0\n        self.sum = 0\n        self.size = size\n\n    def next(self, val: int) -&gt; float:\n        if self.cur &gt;= self.size:\n            self.sum -= self.q.popleft()\n            self.cur -= 1\n\n        self.q.append(val)\n        self.sum += val\n        self.cur += 1\n\n        return self.sum / self.cur\n\n\nif __name__ == \"__main__\":\n    ma = MovingAverage(3)\n    assert ma.next(1) == 1.0\n    assert ma.next(10) == 5.5\n    assert ma.next(3) == 4.666666666666667\n    assert ma.next(5) == 6.0\n</code></pre>"},{"location":"EndlessCheng/queue_basics/#362-design-hit-counter","title":"362. Design Hit Counter \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Design, Queue, Data Stream</p> </li> </ul> Python <pre><code>from collections import deque\n\n\nclass HitCounter:\n\n    def __init__(self):\n        self.hits = deque()\n\n    def hit(self, timestamp: int) -&gt; None:\n        self.hits.append(timestamp)\n\n    def getHits(self, timestamp: int) -&gt; int:\n        # Remove hits that are older than 5 minutes (300 seconds)\n        while self.hits and self.hits[0] &lt;= timestamp - 300:\n            self.hits.popleft()\n        return len(self.hits)\n\n\nobj = HitCounter()\nobj.hit(1)\nobj.hit(2)\nobj.hit(3)\nprint(obj.getHits(4))  # 3\nobj.hit(300)\nprint(obj.getHits(300))  # 4\nprint(obj.getHits(301))  # 3\n</code></pre>"},{"location":"EndlessCheng/queue_basics/#379-design-phone-directory","title":"379. Design Phone Directory \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Linked List, Design, Queue</p> </li> </ul>"},{"location":"EndlessCheng/queue_basics/#1429-first-unique-number","title":"1429. First Unique Number \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Design, Queue, Data Stream</p> </li> </ul> Python <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# Deque\nclass FirstUnique:\n\n    def __init__(self, nums: List[int]):\n        self.all = set()\n        self.multi = set()\n\n        for num in nums:\n            if num in self.all:\n                self.multi.add(num)\n            self.all.add(num)\n\n        self.q = deque([i for i in nums if i not in self.multi])\n\n    def showFirstUnique(self) -&gt; int:\n        while self.q and self.q[0] in self.multi:\n            self.q.popleft()\n        return self.q[0] if self.q else -1\n\n    def add(self, value: int) -&gt; None:\n        if value not in self.all:\n            self.all.add(value)\n            self.q.append(value)\n        elif value not in self.multi:\n            self.multi.add(value)\n\n\nif __name__ == \"__main__\":\n    nums = [2, 3, 5]\n    firstUnique = FirstUnique(nums)\n    assert firstUnique.showFirstUnique() == 2\n    firstUnique.add(5)\n    assert firstUnique.showFirstUnique() == 2\n    firstUnique.add(2)\n    assert firstUnique.showFirstUnique() == 3\n    firstUnique.add(3)\n    assert firstUnique.showFirstUnique() == -1\n</code></pre>"},{"location":"EndlessCheng/queue_basics/#2534-time-taken-to-cross-the-door","title":"2534. Time Taken to Cross the Door \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Queue, Simulation</p> </li> </ul>"},{"location":"EndlessCheng/queue_design/","title":"Queue Design","text":""},{"location":"EndlessCheng/queue_design/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 225. Implement Stack using Queues (Easy)</li> <li> 232. Implement Queue using Stacks (Easy)</li> <li> 622. Design Circular Queue (Medium)</li> <li> 641. Design Circular Deque (Medium)</li> <li> 1670. Design Front Middle Back Queue (Medium)</li> </ul>"},{"location":"EndlessCheng/queue_design/#225-implement-stack-using-queues","title":"225. Implement Stack using Queues","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Stack, Design, Queue</p> </li> </ul> Python <pre><code>from collections import deque\n\n\n# Queue\nclass MyStack:\n\n    def __init__(self):\n        self.q1 = deque()  # main queue\n        self.q2 = deque()  # auxiliary queue\n\n    def push(self, x: int) -&gt; None:\n        self.q1.append(x)\n\n    def pop(self) -&gt; int:\n        while len(self.q1) &gt; 1:\n            self.q2.append(self.q1.popleft())\n        res = self.q1.popleft()\n        self.q1, self.q2 = self.q2, self.q1\n        return res\n\n    def top(self) -&gt; int:\n        while len(self.q1) &gt; 1:\n            self.q2.append(self.q1.popleft())\n        res = self.q1[0]\n        self.q2.append(self.q1.popleft())\n        self.q1, self.q2 = self.q2, self.q1\n        return res\n\n    def empty(self) -&gt; bool:\n        return not self.q1\n\n\nobj = MyStack()\nobj.push(1)\nobj.push(2)\nobj.push(3)\nobj.push(4)\nprint(obj.pop())  # 4\nprint(obj.top())  # 3\nprint(obj.empty())  # False\nprint(obj.pop())  # 3\n</code></pre>"},{"location":"EndlessCheng/queue_design/#232-implement-queue-using-stacks","title":"232. Implement Queue using Stacks","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Stack, Design, Queue</p> </li> </ul> Python <pre><code>\"\"\"\n-   Implement the following operations of a queue using stacks.\n    -   `push(x)` - Push element x to the back of queue.\n    -   `pop()` - Removes the element from in front of queue.\n    -   `peek()` - Get the front element.\n    -   `empty()` - Return whether the queue is empty.\n\"\"\"\n\n\nclass MyQueue:\n    def __init__(self):\n        self.stack_in = []\n        self.stack_out = []\n\n    def push(self, x: int) -&gt; None:\n        self.stack_in.append(x)\n\n    def pop(self) -&gt; int:\n        if self.empty():\n            return None\n\n        if self.stack_out:\n            return self.stack_out.pop()\n        else:\n            for _ in range(len(self.stack_in)):\n                self.stack_out.append(self.stack_in.pop())\n            return self.stack_out.pop()\n\n    def peek(self) -&gt; int:\n        answer = self.pop()\n        self.stack_out.append(answer)\n        return answer\n\n    def empty(self) -&gt; bool:\n        return not (self.stack_in or self.stack_out)\n\n\nobj = MyQueue()\nobj.push(1)\nprint(obj.pop())  # 1\nprint(obj.peek())  # None\nprint(obj.empty())  # False\n</code></pre>"},{"location":"EndlessCheng/queue_design/#622-design-circular-queue","title":"622. Design Circular Queue","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Linked List, Design, Queue</p> </li> </ul> Python <pre><code># Design\nclass MyCircularQueue:\n\n    def __init__(self, k: int):\n        self.queue = [0] * k\n        self.head = 0\n        self.tail = -1\n        self.size = 0\n        self.capacity = k\n\n    def enQueue(self, value: int) -&gt; bool:\n        if self.isFull():\n            return False\n        self.tail = (self.tail + 1) % self.capacity\n        self.queue[self.tail] = value\n        self.size += 1\n        return True\n\n    def deQueue(self) -&gt; bool:\n        if self.isEmpty():\n            return False\n        self.head = (self.head + 1) % self.capacity\n        self.size -= 1\n        return True\n\n    def Front(self) -&gt; int:\n        if self.isEmpty():\n            return -1\n        return self.queue[self.head]\n\n    def Rear(self) -&gt; int:\n        if self.isEmpty():\n            return -1\n        return self.queue[self.tail]\n\n    def isEmpty(self) -&gt; bool:\n        return self.size == 0\n\n    def isFull(self) -&gt; bool:\n        return self.size == self.capacity\n\n\nobj = MyCircularQueue(3)\nprint(obj.enQueue(1))  # True\nprint(obj.enQueue(2))  # True\nprint(obj.enQueue(3))  # True\nprint(obj.enQueue(4))  # False\nprint(obj.Rear())  # 3\nprint(obj.isFull())  # True\nprint(obj.deQueue())  # True\n</code></pre>"},{"location":"EndlessCheng/queue_design/#641-design-circular-deque","title":"641. Design Circular Deque","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Linked List, Design, Queue</p> </li> </ul>"},{"location":"EndlessCheng/queue_design/#1670-design-front-middle-back-queue","title":"1670. Design Front Middle Back Queue","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Linked List, Design, Queue, Data Stream</p> </li> </ul>"},{"location":"EndlessCheng/randomized_algorithms/","title":"Randomized Algorithms","text":""},{"location":"EndlessCheng/randomized_algorithms/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 398. Random Pick Index (Medium)</li> <li> 382. Linked List Random Node (Medium)</li> <li> 384. Shuffle an Array (Medium)</li> <li> 470. Implement Rand10() Using Rand7() (Medium)</li> <li> 528. Random Pick with Weight (Medium)</li> <li> 710. Random Pick with Blacklist (Hard)</li> <li> 478. Generate Random Point in a Circle (Medium)</li> <li> 497. Random Point in Non-overlapping Rectangles (Medium)</li> <li> 519. Random Flip Matrix (Medium)</li> <li> 380. Insert Delete GetRandom O(1) (Medium)</li> <li> 381. Insert Delete GetRandom O(1) - Duplicates allowed (Hard)</li> <li> 1515. Best Position for a Service Centre (Hard)</li> <li> 1968. Array With Elements Not Equal to Average of Neighbors (Medium)</li> </ul>"},{"location":"EndlessCheng/randomized_algorithms/#398-random-pick-index","title":"398. Random Pick Index","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Math, Reservoir Sampling, Randomized</p> </li> </ul>"},{"location":"EndlessCheng/randomized_algorithms/#382-linked-list-random-node","title":"382. Linked List Random Node","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Math, Reservoir Sampling, Randomized</p> </li> </ul>"},{"location":"EndlessCheng/randomized_algorithms/#384-shuffle-an-array","title":"384. Shuffle an Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Design, Randomized</p> </li> </ul>"},{"location":"EndlessCheng/randomized_algorithms/#470-implement-rand10-using-rand7","title":"470. Implement Rand10() Using Rand7()","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Rejection Sampling, Randomized, Probability And Statistics</p> </li> </ul>"},{"location":"EndlessCheng/randomized_algorithms/#528-random-pick-with-weight","title":"528. Random Pick with Weight","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Binary Search, Prefix Sum, Randomized</p> </li> </ul>"},{"location":"EndlessCheng/randomized_algorithms/#710-random-pick-with-blacklist","title":"710. Random Pick with Blacklist","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Binary Search, Sorting, Randomized</p> </li> </ul>"},{"location":"EndlessCheng/randomized_algorithms/#478-generate-random-point-in-a-circle","title":"478. Generate Random Point in a Circle","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Geometry, Rejection Sampling, Randomized</p> </li> </ul>"},{"location":"EndlessCheng/randomized_algorithms/#497-random-point-in-non-overlapping-rectangles","title":"497. Random Point in Non-overlapping Rectangles","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Binary Search, Reservoir Sampling, Prefix Sum, Ordered Set, Randomized</p> </li> </ul>"},{"location":"EndlessCheng/randomized_algorithms/#519-random-flip-matrix","title":"519. Random Flip Matrix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Math, Reservoir Sampling, Randomized</p> </li> </ul>"},{"location":"EndlessCheng/randomized_algorithms/#380-insert-delete-getrandom-o1","title":"380. Insert Delete GetRandom O(1)","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Design, Randomized</p> </li> </ul> Python <pre><code>import random\n\n\nclass RandomizedSet:\n    def __init__(self):\n        self.nums = []\n        self.pos = {}  # num: idx\n\n    def insert(self, val: int) -&gt; bool:\n        if val in self.pos:\n            return False\n        self.pos[val] = len(self.nums)\n        self.nums.append(val)\n        return True\n\n    def remove(self, val: int) -&gt; bool:\n        if val not in self.pos:\n            return False\n\n        idx = self.pos[val]\n        last_val = self.nums[-1]\n        self.nums[idx] = last_val\n        self.pos[last_val] = idx\n\n        self.nums.pop()\n        del self.pos[val]\n        return True\n\n    def getRandom(self) -&gt; int:\n        return random.choice(self.nums)\n\n\ndef test_RandomizedSet():\n    obj = RandomizedSet()\n    assert obj.insert(1)\n    assert not obj.remove(2)\n    assert obj.insert(2)\n    assert obj.getRandom() in [1, 2]\n    assert obj.remove(1)\n    assert not obj.insert(2)\n    assert obj.getRandom() == 2\n</code></pre>"},{"location":"EndlessCheng/randomized_algorithms/#381-insert-delete-getrandom-o1-duplicates-allowed","title":"381. Insert Delete GetRandom O(1) - Duplicates allowed","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Design, Randomized</p> </li> </ul>"},{"location":"EndlessCheng/randomized_algorithms/#1515-best-position-for-a-service-centre","title":"1515. Best Position for a Service Centre","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Geometry, Randomized</p> </li> </ul>"},{"location":"EndlessCheng/randomized_algorithms/#1968-array-with-elements-not-equal-to-average-of-neighbors","title":"1968. Array With Elements Not Equal to Average of Neighbors","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/rectangle/","title":"Rectangle","text":""},{"location":"EndlessCheng/rectangle/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 84. Largest Rectangle in Histogram (Hard)</li> <li> 1793. Maximum Score of a Good Subarray (Hard)</li> <li> 85. Maximal Rectangle (Hard)</li> <li> 1504. Count Submatrices With All Ones (Medium)</li> <li> 42. Trapping Rain Water (Hard)</li> <li> 755. Pour Water (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/rectangle/#84-largest-rectangle-in-histogram","title":"84. Largest Rectangle in Histogram","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Stack, Monotonic Stack</p> </li> </ul> Python <pre><code>from typing import List\n\n\nclass LargestRectangleArea:\n    def monotonic_stack(self, heights: List[int]) -&gt; int:\n        stack = []\n        res = 0\n        n = len(heights)\n\n        for i in range(n + 1):\n            h = heights[i] if i &lt; n else 0\n\n            while stack and h &lt; heights[stack[-1]]:\n                height = heights[stack.pop()]\n                width = i if not stack else i - stack[-1] - 1\n                res = max(res, height * width)\n\n            stack.append(i)\n\n        return res\n\n\nif __name__ == \"__main__\":\n    sol = LargestRectangleArea()\n    assert sol.monotonic_stack([2, 1, 5, 6, 2, 3]) == 10\n    assert sol.monotonic_stack([2, 4]) == 4\n</code></pre>"},{"location":"EndlessCheng/rectangle/#1793-maximum-score-of-a-good-subarray","title":"1793. Maximum Score of a Good Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Stack, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/rectangle/#85-maximal-rectangle","title":"85. Maximal Rectangle","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Stack, Matrix, Monotonic Stack</p> </li> </ul> Python <pre><code>from typing import List\n\n\nclass maximalRectangle:\n    \"\"\"\n    prerequisite: 84. Largest Rectangle in Histogram\n    \"\"\"\n\n    def monotonic_stack(self, matrix: List[List[str]]) -&gt; int:\n        if not matrix or not matrix[0]:\n            return 0\n\n        n = len(matrix[0])\n        heights = [0] * (n + 1)\n        res = 0\n\n        for row in matrix:\n            for i in range(n):\n                if row[i] == \"1\":\n                    heights[i] += 1\n                else:\n                    heights[i] = 0\n\n            stack = [-1]\n            for i in range(n + 1):\n                while heights[i] &lt; heights[stack[-1]]:\n                    h = heights[stack.pop()]\n                    w = i - stack[-1] - 1\n                    res = max(res, h * w)\n                stack.append(i)\n\n        return res\n\n\nif __name__ == \"__main__\":\n    sol = maximalRectangle()\n    matrix = [\n        [\"1\", \"0\", \"1\", \"0\", \"0\"],\n        [\"1\", \"0\", \"1\", \"1\", \"1\"],\n        [\"1\", \"1\", \"1\", \"1\", \"1\"],\n        [\"1\", \"0\", \"0\", \"1\", \"0\"],\n    ]\n    assert sol.monotonic_stack(matrix) == 6\n</code></pre>"},{"location":"EndlessCheng/rectangle/#1504-count-submatrices-with-all-ones","title":"1504. Count Submatrices With All Ones","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Stack, Matrix, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/rectangle/#42-trapping-rain-water","title":"42. Trapping Rain Water","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Dynamic Programming, Stack, Monotonic Stack</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- ![42](../../assets/0042.png)\n\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/ZI2z5pq0TqA?si=OEYg01dbmzvmtIwZ\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen&gt;&lt;/iframe&gt;\n\n| Approach   | Time | Space |\n| ---------- | ---- | ----- |\n| DP         | O(N) | O(N)  |\n| Left Right | O(N) | O(1)  |\n| Monotonic  | O(N) | O(N)  |\n\"\"\"\n\nfrom typing import List\n\n\n# DP\ndef trapDP(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    n = len(height)\n    maxLeft, maxRight = [0 for _ in range(n)], [0 for _ in range(n)]\n\n    for i in range(1, n):\n        maxLeft[i] = max(maxLeft[i - 1], height[i - 1])\n\n    for i in range(n - 2, -1, -1):\n        maxRight[i] = max(maxRight[i + 1], height[i + 1])\n\n    res = 0\n    for i in range(n):\n        res += max(0, min(maxLeft[i], maxRight[i]) - height[i])\n\n    return res\n\n\n# Left Right Pointers\ndef trapLR(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    left, right = 0, len(height) - 1\n    maxL, maxR = height[left], height[right]\n    res = 0\n\n    while left &lt; right:\n        if maxL &lt; maxR:\n            left += 1\n            maxL = max(maxL, height[left])\n            res += maxL - height[left]\n        else:\n            right -= 1\n            maxR = max(maxR, height[right])\n            res += maxR - height[right]\n\n    return res\n\n\n# Monotonic Stack\ndef trapStack(height: List[int]) -&gt; int:\n    stack = []\n    total = 0\n\n    for i in range(len(height)):\n        while stack and height[i] &gt; height[stack[-1]]:\n            top = stack.pop()\n            if not stack:\n                break\n            distance = i - stack[-1] - 1\n            bounded_height = min(height[i], height[stack[-1]]) - height[top]\n            total += distance * bounded_height\n        stack.append(i)\n\n    return total\n\n\nheight = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\nprint(trapDP(height))  # 6\nprint(trapLR(height))  # 6\nprint(trapStack(height))  # 6\n</code></pre> <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int trap(vector&lt;int&gt; &amp;height)\n    {\n        if (height.empty())\n            return 0;\n\n        int res = 0;\n        int left = 0, right = height.size() - 1;\n        int maxL = height[left], maxR = height[right];\n\n        while (left &lt; right)\n        {\n            if (maxL &lt; maxR)\n            {\n                left++;\n                maxL = max(maxL, height[left]);\n                res += maxL - height[left];\n            }\n            else\n            {\n                right--;\n                maxR = max(maxR, height[right]);\n                res += maxR - height[right];\n            }\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    vector&lt;int&gt; height = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};\n    Solution solution;\n    cout &lt;&lt; solution.trap(height) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/rectangle/#755-pour-water","title":"755. Pour Water \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Simulation</p> </li> </ul>"},{"location":"EndlessCheng/rectangles_and_polygons/","title":"Rectangles and Polygons","text":""},{"location":"EndlessCheng/rectangles_and_polygons/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 836. Rectangle Overlap (Easy)</li> <li> 223. Rectangle Area (Medium)</li> <li> 593. Valid Square (Medium)</li> <li> 939. Minimum Area Rectangle (Medium)</li> <li> 963. Minimum Area Rectangle II (Medium)</li> <li> 469. Convex Polygon (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/rectangles_and_polygons/#836-rectangle-overlap","title":"836. Rectangle Overlap","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Geometry</p> </li> </ul>"},{"location":"EndlessCheng/rectangles_and_polygons/#223-rectangle-area","title":"223. Rectangle Area","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Geometry</p> </li> </ul>"},{"location":"EndlessCheng/rectangles_and_polygons/#593-valid-square","title":"593. Valid Square","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Geometry</p> </li> </ul>"},{"location":"EndlessCheng/rectangles_and_polygons/#939-minimum-area-rectangle","title":"939. Minimum Area Rectangle","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Geometry, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/rectangles_and_polygons/#963-minimum-area-rectangle-ii","title":"963. Minimum Area Rectangle II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Geometry</p> </li> </ul>"},{"location":"EndlessCheng/rectangles_and_polygons/#469-convex-polygon","title":"469. Convex Polygon \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Geometry</p> </li> </ul>"},{"location":"EndlessCheng/regret_greedy/","title":"Regret Greedy","text":""},{"location":"EndlessCheng/regret_greedy/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1642. Furthest Building You Can Reach (Medium)</li> <li> 630. Course Schedule III (Hard)</li> <li> 871. Minimum Number of Refueling Stops (Hard)</li> <li> 3362. Zero Array Transformation III (Medium)</li> <li> 2813. Maximum Elegance of a K-Length Subsequence (Hard)</li> <li> 3049. Earliest Second to Mark Indices II (Hard)</li> <li> 2599. Make the Prefix Sum Non-negative (Medium) \ud83d\udc51</li> <li> 2463. Minimum Total Distance Traveled (Hard)</li> </ul>"},{"location":"EndlessCheng/regret_greedy/#1642-furthest-building-you-can-reach","title":"1642. Furthest Building You Can Reach","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/regret_greedy/#630-course-schedule-iii","title":"630. Course Schedule III","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/regret_greedy/#871-minimum-number-of-refueling-stops","title":"871. Minimum Number of Refueling Stops","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/regret_greedy/#3362-zero-array-transformation-iii","title":"3362. Zero Array Transformation III","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting, Heap Priority Queue, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/regret_greedy/#2813-maximum-elegance-of-a-k-length-subsequence","title":"2813. Maximum Elegance of a K-Length Subsequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Stack, Greedy, Sorting, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/regret_greedy/#3049-earliest-second-to-mark-indices-ii","title":"3049. Earliest Second to Mark Indices II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Greedy, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/regret_greedy/#2599-make-the-prefix-sum-non-negative","title":"2599. Make the Prefix Sum Non-negative \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/regret_greedy/#2463-minimum-total-distance-traveled","title":"2463. Minimum Total Distance Traveled","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/regret_heap/","title":"Regret Heap","text":""},{"location":"EndlessCheng/regret_heap/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1642. Furthest Building You Can Reach (Medium)</li> <li> 630. Course Schedule III (Hard)</li> <li> 871. Minimum Number of Refueling Stops (Hard)</li> <li> 3362. Zero Array Transformation III (Medium)</li> <li> 2813. Maximum Elegance of a K-Length Subsequence (Hard)</li> <li> 3049. Earliest Second to Mark Indices II (Hard)</li> <li> 2599. Make the Prefix Sum Non-negative (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/regret_heap/#1642-furthest-building-you-can-reach","title":"1642. Furthest Building You Can Reach","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/regret_heap/#630-course-schedule-iii","title":"630. Course Schedule III","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/regret_heap/#871-minimum-number-of-refueling-stops","title":"871. Minimum Number of Refueling Stops","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/regret_heap/#3362-zero-array-transformation-iii","title":"3362. Zero Array Transformation III","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting, Heap Priority Queue, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/regret_heap/#2813-maximum-elegance-of-a-k-length-subsequence","title":"2813. Maximum Elegance of a K-Length Subsequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Stack, Greedy, Sorting, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/regret_heap/#3049-earliest-second-to-mark-indices-ii","title":"3049. Earliest Second to Mark Indices II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Greedy, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/regret_heap/#2599-make-the-prefix-sum-non-negative","title":"2599. Make the Prefix Sum Non-negative \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/reverse_thinking/","title":"Reverse Thinking","text":""},{"location":"EndlessCheng/reverse_thinking/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2139. Minimum Moves to Reach Target Score (Medium)</li> <li> 1558. Minimum Numbers of Function Calls to Make Target Array (Medium)</li> <li> 554. Brick Wall (Medium)</li> <li> 2718. Sum of Matrix After Queries (Medium)</li> <li> 417. Pacific Atlantic Water Flow (Medium)</li> <li> 991. Broken Calculator (Medium)</li> <li> 2227. Encrypt and Decrypt Strings (Hard)</li> <li> 3419. Minimize the Maximum Edge Weight of Graph (Medium)</li> <li> 936. Stamping The Sequence (Hard)</li> </ul>"},{"location":"EndlessCheng/reverse_thinking/#2139-minimum-moves-to-reach-target-score","title":"2139. Minimum Moves to Reach Target Score","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/reverse_thinking/#1558-minimum-numbers-of-function-calls-to-make-target-array","title":"1558. Minimum Numbers of Function Calls to Make Target Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/reverse_thinking/#554-brick-wall","title":"554. Brick Wall","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table</p> </li> </ul>"},{"location":"EndlessCheng/reverse_thinking/#2718-sum-of-matrix-after-queries","title":"2718. Sum of Matrix After Queries","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table</p> </li> </ul>"},{"location":"EndlessCheng/reverse_thinking/#417-pacific-atlantic-water-flow","title":"417. Pacific Atlantic Water Flow","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Matrix</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef pacificAtlanticDFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(r, c, visited, prev_height):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or heights[r][c] &lt; prev_height\n            or (r, c) in visited\n        ):\n            return None\n\n        visited.add((r, c))\n        height = heights[r][c]\n        for dr, dc in directions:\n            dfs(dr + r, dc + c, visited, height)\n\n    for c in range(n):\n        dfs(0, c, pac, heights[0][c])\n        dfs(m - 1, c, atl, heights[m - 1][c])\n\n    for r in range(m):\n        dfs(r, 0, pac, heights[r][0])\n        dfs(r, n - 1, atl, heights[r][n - 1])\n\n    return list(pac &amp; atl)\n\n\n# BFS\ndef pacificAtlanticBFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def bfs(r, c, visited):\n        q = deque([(r, c)])\n        visited.add((r, c))\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr in range(m)\n                    and nc in range(n)\n                    and heights[row][col] &lt;= heights[nr][nc]\n                    and (nr, nc) not in visited\n                ):\n                    q.append((nr, nc))\n                    visited.add((nr, nc))\n\n    for c in range(n):\n        bfs(0, c, pac)  # top\n        bfs(m - 1, c, atl)  # bottom\n\n    for r in range(m):\n        bfs(r, 0, pac)  # left\n        bfs(r, n - 1, atl)  # right\n\n    return list(pac &amp; atl)\n\n\nheights = [\n    [1, 2, 2, 3, 5],\n    [3, 2, 3, 4, 4],\n    [2, 4, 5, 3, 1],\n    [6, 7, 1, 4, 5],\n    [5, 1, 1, 2, 4],\n]\nprint(pacificAtlanticDFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\nprint(pacificAtlanticBFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\n</code></pre>"},{"location":"EndlessCheng/reverse_thinking/#991-broken-calculator","title":"991. Broken Calculator","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/reverse_thinking/#2227-encrypt-and-decrypt-strings","title":"2227. Encrypt and Decrypt Strings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Design, Trie</p> </li> </ul>"},{"location":"EndlessCheng/reverse_thinking/#3419-minimize-the-maximum-edge-weight-of-graph","title":"3419. Minimize the Maximum Edge Weight of Graph","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Binary Search, Depth First Search, Breadth First Search, Graph, Shortest Path</p> </li> </ul>"},{"location":"EndlessCheng/reverse_thinking/#936-stamping-the-sequence","title":"936. Stamping The Sequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack, Greedy, Queue</p> </li> </ul>"},{"location":"EndlessCheng/segment_tree/","title":"Segment Tree","text":""},{"location":"EndlessCheng/segment_tree/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1157. Online Majority Element In Subarray (Hard)</li> <li> 2407. Longest Increasing Subsequence II (Hard)</li> <li> 2940. Find Building Where Alice and Bob Can Meet (Hard)</li> <li> 2286. Booking Concert Tickets in Groups (Hard)</li> <li> 3161. Block Placement Queries (Hard)</li> <li> 2213. Longest Substring of One Repeating Character (Hard)</li> <li> 3165. Maximum Sum of Subsequence With Non-adjacent Elements (Hard)</li> </ul>"},{"location":"EndlessCheng/segment_tree/#1157-online-majority-element-in-subarray","title":"1157. Online Majority Element In Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Design, Binary Indexed Tree, Segment Tree</p> </li> </ul>"},{"location":"EndlessCheng/segment_tree/#2407-longest-increasing-subsequence-ii","title":"2407. Longest Increasing Subsequence II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Divide And Conquer, Dynamic Programming, Binary Indexed Tree, Segment Tree, Queue, Monotonic Queue</p> </li> </ul>"},{"location":"EndlessCheng/segment_tree/#2940-find-building-where-alice-and-bob-can-meet","title":"2940. Find Building Where Alice and Bob Can Meet","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Stack, Binary Indexed Tree, Segment Tree, Heap Priority Queue, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/segment_tree/#2286-booking-concert-tickets-in-groups","title":"2286. Booking Concert Tickets in Groups","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Binary Search, Design, Binary Indexed Tree, Segment Tree</p> </li> </ul>"},{"location":"EndlessCheng/segment_tree/#3161-block-placement-queries","title":"3161. Block Placement Queries","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Binary Indexed Tree, Segment Tree</p> </li> </ul>"},{"location":"EndlessCheng/segment_tree/#2213-longest-substring-of-one-repeating-character","title":"2213. Longest Substring of One Repeating Character","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Segment Tree, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/segment_tree/#3165-maximum-sum-of-subsequence-with-non-adjacent-elements","title":"3165. Maximum Sum of Subsequence With Non-adjacent Elements","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Divide And Conquer, Dynamic Programming, Segment Tree</p> </li> </ul>"},{"location":"EndlessCheng/shortest_path_all_pairs_floyd/","title":"Shortest Path All Pairs Floyd","text":""},{"location":"EndlessCheng/shortest_path_all_pairs_floyd/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2642. Design Graph With Shortest Path Calculator (Hard)</li> <li> 1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance (Medium)</li> <li> 2976. Minimum Cost to Convert String I (Medium)</li> <li> 2959. Number of Possible Sets of Closing Branches (Hard)</li> <li> 2977. Minimum Cost to Convert String II (Hard)</li> <li> 2101. Detonate the Maximum Bombs (Medium)</li> </ul>"},{"location":"EndlessCheng/shortest_path_all_pairs_floyd/#2642-design-graph-with-shortest-path-calculator","title":"2642. Design Graph With Shortest Path Calculator","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Graph, Design, Heap Priority Queue, Shortest Path</p> </li> </ul>"},{"location":"EndlessCheng/shortest_path_all_pairs_floyd/#1334-find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance","title":"1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Graph, Shortest Path</p> </li> </ul>"},{"location":"EndlessCheng/shortest_path_all_pairs_floyd/#2976-minimum-cost-to-convert-string-i","title":"2976. Minimum Cost to Convert String I","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Graph, Shortest Path</p> </li> </ul>"},{"location":"EndlessCheng/shortest_path_all_pairs_floyd/#2959-number-of-possible-sets-of-closing-branches","title":"2959. Number of Possible Sets of Closing Branches","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Bit Manipulation, Graph, Heap Priority Queue, Enumeration, Shortest Path</p> </li> </ul>"},{"location":"EndlessCheng/shortest_path_all_pairs_floyd/#2977-minimum-cost-to-convert-string-ii","title":"2977. Minimum Cost to Convert String II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Dynamic Programming, Graph, Trie, Shortest Path</p> </li> </ul>"},{"location":"EndlessCheng/shortest_path_all_pairs_floyd/#2101-detonate-the-maximum-bombs","title":"2101. Detonate the Maximum Bombs","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Depth First Search, Breadth First Search, Graph, Geometry</p> </li> </ul>"},{"location":"EndlessCheng/shortest_path_single_source_dijkstra/","title":"Shortest Path Single Source Dijkstra","text":""},{"location":"EndlessCheng/shortest_path_single_source_dijkstra/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 743. Network Delay Time (Medium)</li> <li> 3341. Find Minimum Time to Reach Last Room I (Medium)</li> <li> 3112. Minimum Time to Visit Disappearing Nodes (Medium)</li> <li> 2642. Design Graph With Shortest Path Calculator (Hard)</li> <li> 1514. Path with Maximum Probability (Medium)</li> <li> 3342. Find Minimum Time to Reach Last Room II (Medium)</li> <li> 1631. Path With Minimum Effort (Medium)</li> <li> 1786. Number of Restricted Paths From First to Last Node (Medium)</li> <li> 3123. Find Edges in Shortest Paths (Hard)</li> <li> 1976. Number of Ways to Arrive at Destination (Medium)</li> <li> 778. Swim in Rising Water (Hard)</li> <li> 2662. Minimum Cost of a Path With Special Roads (Medium)</li> <li> 3377. Digit Operations to Make Two Integers Equal (Medium)</li> <li> 2045. Second Minimum Time to Reach Destination (Hard)</li> <li> 3419. Minimize the Maximum Edge Weight of Graph (Medium)</li> <li> 882. Reachable Nodes In Subdivided Graph (Hard)</li> <li> 2203. Minimum Weighted Subgraph With the Required Paths (Hard)</li> <li> 2577. Minimum Time to Visit a Cell In a Grid (Hard)</li> <li> 1928. Minimum Cost to Reach Destination in Time (Hard)</li> <li> 787. Cheapest Flights Within K Stops (Medium)</li> <li> 2699. Modify Graph Edge Weights (Hard)</li> <li> 1810. Minimum Path Cost in a Hidden Grid (Medium) \ud83d\udc51</li> <li> 2093. Minimum Cost to Reach City With Discounts (Medium) \ud83d\udc51</li> <li> 2473. Minimum Cost to Buy Apples (Medium) \ud83d\udc51</li> <li> 2714. Find Shortest Path with K Hops (Hard) \ud83d\udc51</li> <li> 2737. Find the Closest Marked Node (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/shortest_path_single_source_dijkstra/#743-network-delay-time","title":"743. Network Delay Time","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Graph, Heap Priority Queue, Shortest Path</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return the minimum time taken to reach all nodes in a network.\n-   Shortest Path Problem: Find the shortest path between two vertices in a graph.\n-   Dijkstra's Algorithm\n    -   Shortest path algorithm\n    -   Weighted graph (non-negative weights)\n    -   Data Structure: Heap; Hash Set\n    -   Time Complexity: O(E * logV)\n    -   Space Complexity: O(V)\n\"\"\"\n\nimport heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Dijkstra - Set\ndef networkDelayTime1(times: List[List[int]], n: int, k: int) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    heap = [(0, k)]\n    visit = set()\n    t = 0\n\n    while heap:\n        w1, n1 = heapq.heappop(heap)\n        if n1 in visit:\n            continue\n\n        visit.add(n1)\n        t = w1\n\n        for n2, w2 in graph[n1]:\n            heapq.heappush(heap, (w1 + w2, n2))\n\n    return t if len(visit) == n else -1\n\n\n# Dijkstra - Dict\ndef networkDelayTime2(times: List[List[int]], n: int, k: int) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    heap = [(0, k)]\n    dist = defaultdict(int)\n\n    while heap:\n        w1, n1 = heapq.heappop(heap)\n        if n1 in dist:\n            continue\n\n        dist[n1] = w1\n\n        for n2, w2 in graph[n1]:\n            heapq.heappush(heap, (w1 + w2, n2))\n\n    return max(dist.values()) if len(dist) == n else -1\n\n\n# Bellman-Ford\ndef networkDelayTimeBF(times: List[List[int]], n: int, k: int) -&gt; int:\n    delay = {i: float(\"inf\") for i in range(1, n + 1)}\n    delay[k] = 0\n\n    for _ in range(n - 1):\n        for u, v, t in times:\n            delay[v] = min(delay[v], delay[u] + t)\n\n    max_delay = max(delay.values())\n    return max_delay if max_delay &lt; float(\"inf\") else -1\n\n\n# |--------------|-----------|--------|\n# | Approach     | Time      | Space  |\n# |--------------|-----------|--------|\n# | Dijkstra     | O(E*logV) | O(V+E) |\n# | Bellman-Ford | O(E*V)    | O(V)   |\n# |--------------|-----------|--------|\n\nif __name__ == \"__main__\":\n    times = [[2, 1, 1], [2, 3, 1], [3, 4, 1]]\n    n = 4\n    k = 2\n    print(networkDelayTime1(times, n, k))  # 2\n    print(networkDelayTime2(times, n, k))  # 2\n    print(networkDelayTimeBF(times, n, k))  # 2\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;cassert&gt;\n#include &lt;climits&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass NetworkDelayTime {\n   public:\n    // single-source, non-negative weight -&gt; Dijkstra's\n    // https://leetcode.cn/problems/network-delay-time/solutions/2668220/liang-chong-dijkstra-xie-fa-fu-ti-dan-py-ooe8/\n    int dijkstra(vector&lt;vector&lt;int&gt;&gt;&amp; times, int n, int k) {\n        vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; graph(n + 1);\n        for (auto&amp; t : times) {\n            graph[t[0]].push_back({t[1], t[2]});\n        }\n\n        vector&lt;int&gt; dist(n + 1, INT_MAX);\n        // min heap\n        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;,\n                       greater&lt;pair&lt;int, int&gt;&gt;&gt;\n            min_heap;\n\n        dist[k] = 0;\n        min_heap.push({0, k});  // [dist, node]\n\n        while (!min_heap.empty()) {\n            auto [d, u] = min_heap.top();\n            min_heap.pop();\n\n            if (d &gt; dist[u]) continue;  // found the shortest\n\n            for (auto&amp; [v, w] : graph[u]) {\n                if (dist[u] + w &lt; dist[v]) {\n                    dist[v] = dist[u] + w;\n                    min_heap.push({dist[v], v});\n                }\n            }\n        }\n\n        int res = 0;\n        for (int i = 1; i &lt;= n; ++i) {\n            if (dist[i] == INT_MAX) return -1;\n            res = max(res, dist[i]);\n        }\n        return res;\n    }\n\n    // single source -&gt; Bellman-Ford\n    int bellman_ford(vector&lt;vector&lt;int&gt;&gt;&amp; times, int n, int k) {\n        vector&lt;int&gt; dist(n + 1, INT_MAX);\n        dist[k] = 0;\n\n        for (int i = 1; i &lt;= n - 1; i++) {\n            for (auto&amp; edge : times) {\n                int u = edge[0], v = edge[1], t = edge[2];\n                if (dist[u] != INT_MAX &amp;&amp; dist[v] &gt; dist[u] + t) {\n                    dist[v] = dist[u] + t;\n                }\n            }\n        }\n\n        int res = 0;\n        for (int i = 1; i &lt;= n; i++) {\n            if (dist[i] == INT_MAX) return -1;\n            res = max(res, dist[i]);\n        }\n        return res;\n    }\n};\n\nint main() {\n    NetworkDelayTime solution;\n    vector&lt;vector&lt;int&gt;&gt; times = {{2, 1, 1}, {2, 3, 1}, {3, 4, 1}};\n    assert(solution.dijkstra(times, 4, 2) == 2);\n    assert(solution.bellman_ford(times, 4, 2) == 2);\n\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/shortest_path_single_source_dijkstra/#3341-find-minimum-time-to-reach-last-room-i","title":"3341. Find Minimum Time to Reach Last Room I","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Graph, Heap Priority Queue, Matrix, Shortest Path</p> </li> </ul>"},{"location":"EndlessCheng/shortest_path_single_source_dijkstra/#3112-minimum-time-to-visit-disappearing-nodes","title":"3112. Minimum Time to Visit Disappearing Nodes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Graph, Heap Priority Queue, Shortest Path</p> </li> </ul>"},{"location":"EndlessCheng/shortest_path_single_source_dijkstra/#2642-design-graph-with-shortest-path-calculator","title":"2642. Design Graph With Shortest Path Calculator","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Graph, Design, Heap Priority Queue, Shortest Path</p> </li> </ul>"},{"location":"EndlessCheng/shortest_path_single_source_dijkstra/#1514-path-with-maximum-probability","title":"1514. Path with Maximum Probability","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Graph, Heap Priority Queue, Shortest Path</p> </li> </ul> Python <pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Dijkstra - Dict\ndef maxProbability1(\n    n: int,\n    edges: List[List[int]],\n    succProb: List[float],\n    start_node: int,\n    end_node: int,\n) -&gt; float:\n    graph = defaultdict(list)\n    for i, (u, v) in enumerate(edges):\n        graph[u].append((v, succProb[i]))\n        graph[v].append((u, succProb[i]))\n\n    heap = [(-1, start_node)]\n    max_prob = {i: 0.0 for i in range(n)}\n    max_prob[start_node] = 1.0\n\n    while heap:\n        p1, n1 = heapq.heappop(heap)\n\n        if n1 == end_node:\n            return -p1\n\n        for n2, p2 in graph[n1]:\n            p2 *= -p1\n            if p2 &gt; max_prob[n2]:\n                max_prob[n2] = p2\n                heapq.heappush(heap, (-p2, n2))\n\n    return 0.0\n\n\n# Dijkstra - Set\ndef maxProbability2(\n    n: int,\n    edges: List[List[int]],\n    succProb: List[float],\n    start_node: int,\n    end_node: int,\n) -&gt; float:\n    graph = defaultdict(list)\n    for i, (u, v) in enumerate(edges):\n        graph[u].append((v, succProb[i]))\n        graph[v].append((u, succProb[i]))\n\n    heap = [(-1, start_node)]\n    visited = set()\n\n    while heap:\n        p1, n1 = heapq.heappop(heap)\n        visited.add(n1)\n\n        if n1 == end_node:\n            return -p1\n\n        for n2, p2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (p1 * p2, n2))\n\n    return 0.0\n\n\n# |------------|-----------|-----------|\n# |  Approach  |    Time   |   Space   |\n# |------------|-----------|-----------|\n# |  Dijkstra  | O(E log V)|   O(E)    |\n# |------------|-----------|-----------|\n\n\nn = 3\nedges = [[0, 1], [1, 2], [0, 2]]\nsuccProb = [0.5, 0.5, 0.2]\nstart = 0\nend = 2\n\nprint(maxProbability1(n, edges, succProb, start, end))  # 0.25\nprint(maxProbability2(n, edges, succProb, start, end))  # 0.25\n</code></pre>"},{"location":"EndlessCheng/shortest_path_single_source_dijkstra/#3342-find-minimum-time-to-reach-last-room-ii","title":"3342. Find Minimum Time to Reach Last Room II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Graph, Heap Priority Queue, Matrix, Shortest Path</p> </li> </ul>"},{"location":"EndlessCheng/shortest_path_single_source_dijkstra/#1631-path-with-minimum-effort","title":"1631. Path With Minimum Effort","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Depth First Search, Breadth First Search, Union Find, Heap Priority Queue, Matrix</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the minimum effort required to travel from the top-left to the bottom-right corner.\n\"\"\"\n\nimport heapq\nfrom typing import List\n\n\n# Prim\ndef minimumEffortPath(heights: List[List[int]]) -&gt; int:\n    m, n = len(heights), len(heights[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * n for _ in range(m)]\n    heap = [(0, 0, 0)]  # (effort, row, col)\n\n    while heap:\n        effort, r, c = heapq.heappop(heap)\n\n        if visited[r][c]:\n            continue\n\n        if r == m - 1 and c == n - 1:\n            return effort\n\n        visited[r][c] = True\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and not visited[nr][nc]:\n                updated = max(effort, abs(heights[r][c] - heights[nr][nc]))\n                heapq.heappush(heap, (updated, nr, nc))\n\n    return -1\n\n\nheights = [[1, 2, 2], [3, 8, 2], [5, 3, 5]]\nprint(minimumEffortPath(heights))  # 2\n</code></pre>"},{"location":"EndlessCheng/shortest_path_single_source_dijkstra/#1786-number-of-restricted-paths-from-first-to-last-node","title":"1786. Number of Restricted Paths From First to Last Node","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Graph, Topological Sort, Heap Priority Queue, Shortest Path</p> </li> </ul>"},{"location":"EndlessCheng/shortest_path_single_source_dijkstra/#3123-find-edges-in-shortest-paths","title":"3123. Find Edges in Shortest Paths","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Graph, Heap Priority Queue, Shortest Path</p> </li> </ul>"},{"location":"EndlessCheng/shortest_path_single_source_dijkstra/#1976-number-of-ways-to-arrive-at-destination","title":"1976. Number of Ways to Arrive at Destination","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Graph, Topological Sort, Shortest Path</p> </li> </ul> Python <pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra\ndef countPaths(n: int, roads: List[List[int]]) -&gt; int:\n    mod = 10**9 + 7\n    graph = [[] for _ in range(n)]\n    for u, v, w in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n\n    dist = [float(\"inf\") for _ in range(n)]\n    dist[0] = 0\n    count = [0 for _ in range(n)]\n    count[0] = 1\n\n    heap = [(0, 0)]\n\n    while heap:\n        d, u = heapq.heappop(heap)\n        if d &gt; dist[u]:\n            continue\n\n        for v, w in graph[u]:\n            if dist[u] + w &lt; dist[v]:\n                dist[v] = dist[u] + w\n                count[v] = count[u]\n                heapq.heappush(heap, (dist[v], v))\n            elif dist[u] + w == dist[v]:\n                count[v] += count[u]\n                count[v] %= mod\n\n    return count[-1]\n\n\nn = 7\nroads = [\n    [0, 6, 7],\n    [0, 1, 2],\n    [1, 2, 3],\n    [1, 3, 3],\n    [6, 3, 3],\n    [3, 5, 1],\n    [6, 5, 1],\n    [2, 5, 1],\n    [0, 4, 5],\n    [4, 6, 2],\n]\nprint(countPaths(n, roads))  # 4\n</code></pre>"},{"location":"EndlessCheng/shortest_path_single_source_dijkstra/#778-swim-in-rising-water","title":"778. Swim in Rising Water","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Depth First Search, Breadth First Search, Union Find, Heap Priority Queue, Matrix</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the minimum time when you can reach the target.\n\n![778](https://assets.leetcode.com/uploads/2021/06/29/swim2-grid-1.jpg)\n\"\"\"\n\nimport heapq\nfrom typing import List\n\n\n# Dijkstra's\ndef swimInWater(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    visited = set()\n    minHeap = [(grid[0][0], 0, 0)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    visited.add((0, 0))\n\n    while minHeap:\n        time, r, c = heapq.heappop(minHeap)\n\n        if r == n - 1 and c == n - 1:\n            return time\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if nr in range(n) and nc in range(n) and (nr, nc) not in visited:\n                visited.add((nr, nc))\n                heapq.heappush(minHeap, (max(time, grid[nr][nc]), nr, nc))\n\n\ngrid = [\n    [0, 1, 2, 3, 4],\n    [24, 23, 22, 21, 5],\n    [12, 13, 14, 15, 16],\n    [11, 17, 18, 19, 20],\n    [10, 9, 8, 7, 6],\n]\nprint(swimInWater(grid))  # 16\n</code></pre>"},{"location":"EndlessCheng/shortest_path_single_source_dijkstra/#2662-minimum-cost-of-a-path-with-special-roads","title":"2662. Minimum Cost of a Path With Special Roads","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Graph, Heap Priority Queue, Shortest Path</p> </li> </ul>"},{"location":"EndlessCheng/shortest_path_single_source_dijkstra/#3377-digit-operations-to-make-two-integers-equal","title":"3377. Digit Operations to Make Two Integers Equal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Graph, Heap Priority Queue, Number Theory, Shortest Path</p> </li> </ul>"},{"location":"EndlessCheng/shortest_path_single_source_dijkstra/#2045-second-minimum-time-to-reach-destination","title":"2045. Second Minimum Time to Reach Destination","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Breadth First Search, Graph, Shortest Path</p> </li> </ul>"},{"location":"EndlessCheng/shortest_path_single_source_dijkstra/#3419-minimize-the-maximum-edge-weight-of-graph","title":"3419. Minimize the Maximum Edge Weight of Graph","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Binary Search, Depth First Search, Breadth First Search, Graph, Shortest Path</p> </li> </ul>"},{"location":"EndlessCheng/shortest_path_single_source_dijkstra/#882-reachable-nodes-in-subdivided-graph","title":"882. Reachable Nodes In Subdivided Graph","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Graph, Heap Priority Queue, Shortest Path</p> </li> </ul> Python <pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra's\ndef reachableNodes(self, edges: List[List[int]], maxMoves: int, n: int) -&gt; int:\n    graph = {i: {} for i in range(n)}\n    for u, v, cnt in edges:\n        graph[u][v] = cnt\n        graph[v][u] = cnt\n\n    heap = [(-maxMoves, 0)]\n    seen = {}\n\n    while heap:\n        moves, node = heapq.heappop(heap)\n        if node in seen:\n            continue\n        seen[node] = -moves\n        for nxt, cnt in graph[node].items():\n            movesLeft = -moves - cnt - 1\n            if nxt not in seen and movesLeft &gt;= 0:\n                heapq.heappush(heap, (-movesLeft, nxt))\n\n    res = len(seen)\n    for u, v, cnt in edges:\n        res += min(seen.get(u, 0) + seen.get(v, 0), cnt)\n\n    return res\n\n\nedges = [[0, 1, 10], [0, 2, 1], [1, 2, 2]]\nmaxMoves = 6\nn = 3\nprint(reachableNodes(None, edges, maxMoves, n))  # 13\n</code></pre>"},{"location":"EndlessCheng/shortest_path_single_source_dijkstra/#2203-minimum-weighted-subgraph-with-the-required-paths","title":"2203. Minimum Weighted Subgraph With the Required Paths","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Graph, Shortest Path</p> </li> </ul>"},{"location":"EndlessCheng/shortest_path_single_source_dijkstra/#2577-minimum-time-to-visit-a-cell-in-a-grid","title":"2577. Minimum Time to Visit a Cell In a Grid","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Breadth First Search, Graph, Heap Priority Queue, Matrix, Shortest Path</p> </li> </ul>"},{"location":"EndlessCheng/shortest_path_single_source_dijkstra/#1928-minimum-cost-to-reach-destination-in-time","title":"1928. Minimum Cost to Reach Destination in Time","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Graph</p> </li> </ul>"},{"location":"EndlessCheng/shortest_path_single_source_dijkstra/#787-cheapest-flights-within-k-stops","title":"787. Cheapest Flights Within K Stops","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Depth First Search, Breadth First Search, Graph, Heap Priority Queue, Shortest Path</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return the cheapest price from `src` to `dst` with at most `K` stops.\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/5eIK3zUdYmE?si=aBR0VbHXTgNuVlGz\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen&gt;&lt;/iframe&gt;\n\"\"\"\n\nimport heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Bellman-Ford\ndef findCheapestPriceBF(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    prices = [float(\"inf\") for _ in range(n)]\n    prices[src] = 0\n\n    for _ in range(k + 1):\n        temp = prices[:]\n        for u, v, w in flights:\n            temp[v] = min(temp[v], prices[u] + w)\n        prices = temp\n\n    return prices[dst] if prices[dst] != float(\"inf\") else -1\n\n\n# Dijkstra\ndef findCheapestPriceDijkstra(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in flights:\n        graph[u].append((v, w))\n\n    heap = [(0, src, 0)]  # (price, city, stops)\n    visited = defaultdict(int)  # {city: stops}\n\n    while heap:\n        price, city, stops = heapq.heappop(heap)\n\n        if city == dst:\n            return price\n\n        if stops &gt; k:\n            continue\n\n        if city in visited and visited[city] &lt;= stops:\n            continue\n\n        visited[city] = stops\n\n        for neighbor, cost in graph[city]:\n            heapq.heappush(heap, (price + cost, neighbor, stops + 1))\n\n    return -1\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |Bellman-Ford|    O(k * E)      |  O(n)   |\n# | Dijkstra   | O(E * log(V))    |  O(n)   |\n# |------------|------------------|---------|\n\n\nn = 4\nflights = [[0, 1, 100], [1, 2, 100], [2, 0, 100], [1, 3, 600], [2, 3, 200]]\nsrc = 0\ndst = 3\nk = 1\nprint(findCheapestPriceBF(n, flights, src, dst, k))  # 700\nprint(findCheapestPriceDijkstra(n, flights, src, dst, k))  # 700\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;climits&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass FindCheapestPrice {\n   public:\n    int bellman_ford(int n, vector&lt;vector&lt;int&gt;&gt;&amp; flights, int src, int dst,\n                     int k) {\n        vector&lt;int&gt; dist(n, INT_MAX);\n        dist[src] = 0;\n\n        for (int i = 0; i &lt;= k; ++i) {\n            vector&lt;int&gt; temp(dist);\n            for (auto&amp; flight : flights) {\n                int u = flight[0], v = flight[1], w = flight[2];\n                if (dist[u] != INT_MAX &amp;&amp; dist[u] + w &lt; temp[v]) {\n                    temp[v] = dist[u] + w;\n                }\n            }\n            dist = temp;\n        }\n        return dist[dst] == INT_MAX ? -1 : dist[dst];\n    }\n\n    int dijkstra(int n, vector&lt;vector&lt;int&gt;&gt;&amp; flights, int src, int dst, int k) {\n        vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; graph(n);\n        for (auto&amp; flight : flights) {\n            graph[flight[0]].push_back({flight[1], flight[2]});\n        }\n        priority_queue&lt;array&lt;int, 3&gt;, vector&lt;array&lt;int, 3&gt;&gt;,\n                       greater&lt;array&lt;int, 3&gt;&gt;&gt;\n            min_heap;\n        min_heap.push({0, src, k + 1});\n\n        while (!min_heap.empty()) {\n            auto [cost, u, stops] = min_heap.top();\n            min_heap.pop();\n            if (u == dst) {\n                return cost;\n            }\n            if (stops &gt; 0) {\n                for (auto&amp; [v, w] : graph[u]) {\n                    min_heap.push({cost + w, v, stops - 1});\n                }\n            }\n        }\n\n        return -1;\n    }\n};\n\nint main() {\n    FindCheapestPrice solution;\n    int n = 4;\n    vector&lt;vector&lt;int&gt;&gt; flights = {\n        {0, 1, 100}, {1, 2, 100}, {2, 0, 100}, {1, 3, 600}, {2, 3, 200}};\n    int src = 0, dst = 3, k = 1;\n    assert(solution.bellman_ford(n, flights, src, dst, k) == 700);\n    assert(solution.dijkstra(n, flights, src, dst, k) == 700);\n\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/shortest_path_single_source_dijkstra/#2699-modify-graph-edge-weights","title":"2699. Modify Graph Edge Weights","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Graph, Heap Priority Queue, Shortest Path</p> </li> </ul>"},{"location":"EndlessCheng/shortest_path_single_source_dijkstra/#1810-minimum-path-cost-in-a-hidden-grid","title":"1810. Minimum Path Cost in a Hidden Grid \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Graph, Heap Priority Queue, Interactive</p> </li> </ul>"},{"location":"EndlessCheng/shortest_path_single_source_dijkstra/#2093-minimum-cost-to-reach-city-with-discounts","title":"2093. Minimum Cost to Reach City With Discounts \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Graph, Heap Priority Queue, Shortest Path</p> </li> </ul>"},{"location":"EndlessCheng/shortest_path_single_source_dijkstra/#2473-minimum-cost-to-buy-apples","title":"2473. Minimum Cost to Buy Apples \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Graph, Heap Priority Queue, Shortest Path</p> </li> </ul>"},{"location":"EndlessCheng/shortest_path_single_source_dijkstra/#2714-find-shortest-path-with-k-hops","title":"2714. Find Shortest Path with K Hops \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Graph, Heap Priority Queue, Shortest Path</p> </li> </ul>"},{"location":"EndlessCheng/shortest_path_single_source_dijkstra/#2737-find-the-closest-marked-node","title":"2737. Find the Closest Marked Node \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Graph, Heap Priority Queue, Shortest Path</p> </li> </ul>"},{"location":"EndlessCheng/single_sequence_pairing/","title":"Single Sequence Pairing","text":""},{"location":"EndlessCheng/single_sequence_pairing/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2144. Minimum Cost of Buying Candies With Discount (Easy)</li> <li> 561. Array Partition (Easy)</li> <li> 1877. Minimize Maximum Pair Sum in Array (Medium)</li> <li> 881. Boats to Save People (Medium)</li> <li> 2592. Maximize Greatness of an Array (Medium)</li> <li> 2576. Find the Maximum Number of Marked Indices (Medium)</li> </ul>"},{"location":"EndlessCheng/single_sequence_pairing/#2144-minimum-cost-of-buying-candies-with-discount","title":"2144. Minimum Cost of Buying Candies With Discount","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/single_sequence_pairing/#561-array-partition","title":"561. Array Partition","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting, Counting Sort</p> </li> </ul>"},{"location":"EndlessCheng/single_sequence_pairing/#1877-minimize-maximum-pair-sum-in-array","title":"1877. Minimize Maximum Pair Sum in Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/single_sequence_pairing/#881-boats-to-save-people","title":"881. Boats to Save People","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Greedy, Sorting</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef numRescueBoats(people: List[int], limit: int) -&gt; int:\n    \"\"\"Returns the minimum number of boats to rescue people.\"\"\"\n    people.sort()\n    left, right = 0, len(people) - 1\n    boats = 0\n\n    while left &lt;= right:\n        if people[left] + people[right] &lt;= limit:\n            left += 1\n        right -= 1\n        boats += 1\n\n    return boats\n\n\npeople = [3, 2, 2, 1]\nlimit = 3\nprint(numRescueBoats(people, limit))  # 3\n</code></pre>"},{"location":"EndlessCheng/single_sequence_pairing/#2592-maximize-greatness-of-an-array","title":"2592. Maximize Greatness of an Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/single_sequence_pairing/#2576-find-the-maximum-number-of-marked-indices","title":"2576. Find the Maximum Number of Marked Indices","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Greedy, Sorting</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Fast Slow Pointers\ndef maxNumOfMarkedIndices(nums: List[int]) -&gt; int:\n    nums.sort()\n    n = len(nums)\n    slow, fast = 0, n // 2\n    count = 0\n\n    while slow &lt; n // 2 and fast &lt; n:\n        if nums[fast] &gt;= 2 * nums[slow]:\n            count += 2\n            slow += 1\n        fast += 1\n\n    return count\n\n\nnums = [3, 5, 2, 4]\nprint(maxNumOfMarkedIndices(nums))  # 2\n</code></pre>"},{"location":"EndlessCheng/sorting_inequality/","title":"Sorting Inequality","text":""},{"location":"EndlessCheng/sorting_inequality/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2285. Maximum Total Importance of Roads (Medium)</li> <li> 3016. Minimum Number of Pushes to Type Word II (Medium)</li> <li> 1402. Reducing Dishes (Hard)</li> <li> 2931. Maximum Spending After Buying Items (Hard)</li> <li> 1589. Maximum Sum Obtained of Any Permutation (Medium)</li> <li> 1874. Minimize Product Sum of Two Arrays (Medium) \ud83d\udc51</li> <li> 2268. Minimum Number of Keypresses (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/sorting_inequality/#2285-maximum-total-importance-of-roads","title":"2285. Maximum Total Importance of Roads","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Greedy, Graph, Sorting, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/sorting_inequality/#3016-minimum-number-of-pushes-to-type-word-ii","title":"3016. Minimum Number of Pushes to Type Word II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Greedy, Sorting, Counting</p> </li> </ul>"},{"location":"EndlessCheng/sorting_inequality/#1402-reducing-dishes","title":"1402. Reducing Dishes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/sorting_inequality/#2931-maximum-spending-after-buying-items","title":"2931. Maximum Spending After Buying Items","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting, Heap Priority Queue, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/sorting_inequality/#1589-maximum-sum-obtained-of-any-permutation","title":"1589. Maximum Sum Obtained of Any Permutation","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting, Prefix Sum</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Greedy\ndef maxSumRangeQuery(nums: List[int], requests: List[List[int]]) -&gt; int:\n    n = len(nums)\n    freq = [0 for _ in range(n + 1)]\n\n    for start, end in requests:\n        freq[start] += 1\n        if end + 1 &lt; n:\n            freq[end + 1] -= 1\n\n    for i in range(1, n):\n        freq[i] += freq[i - 1]\n\n    freq.pop()\n\n    freq.sort(reverse=True)\n    nums.sort(reverse=True)\n\n    max_sum = 0\n    mod = 10**9 + 7\n\n    for i, j in zip(nums, freq):\n        max_sum += i * j\n        max_sum %= mod\n\n    return max_sum\n\n\nnums = [1, 2, 3, 4, 5]\nrequests = [[1, 3], [0, 1]]\nprint(maxSumRangeQuery(nums, requests))  # 19\n</code></pre>"},{"location":"EndlessCheng/sorting_inequality/#1874-minimize-product-sum-of-two-arrays","title":"1874. Minimize Product Sum of Two Arrays \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/sorting_inequality/#2268-minimum-number-of-keypresses","title":"2268. Minimum Number of Keypresses \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Greedy, Sorting, Counting</p> </li> </ul>"},{"location":"EndlessCheng/stack_advanced/","title":"Stack Advanced","text":""},{"location":"EndlessCheng/stack_advanced/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3170. Lexicographically Minimum String After Removing Stars (Medium)</li> <li> 155. Min Stack (Medium)</li> <li> 1381. Design a Stack With Increment Operation (Medium)</li> <li> 636. Exclusive Time of Functions (Medium)</li> <li> 2434. Using a Robot to Print the Lexicographically Smallest String (Medium)</li> <li> 895. Maximum Frequency Stack (Hard)</li> <li> 1172. Dinner Plate Stacks (Hard)</li> <li> 2589. Minimum Time to Complete All Tasks (Hard)</li> <li> 716. Max Stack (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/stack_advanced/#3170-lexicographically-minimum-string-after-removing-stars","title":"3170. Lexicographically Minimum String After Removing Stars","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Stack, Greedy, Heap Priority Queue</p> </li> </ul> Python <pre><code>from itertools import chain\n\n\n# Stack\ndef clearStars(s: str) -&gt; str:\n    stacks = [[] for _ in range(26)]\n    for i, c in enumerate(s):\n        if c != \"*\":\n            stacks[ord(c) - ord(\"a\")].append(i)\n            continue\n\n        for st in stacks:\n            if st:\n                st.pop()\n                break\n    return \"\".join(s[i] for i in sorted(chain.from_iterable(stacks)))\n\n\nif __name__ == \"__main__\":\n    assert clearStars(\"aaba*\") == \"aab\"\n</code></pre>"},{"location":"EndlessCheng/stack_advanced/#155-min-stack","title":"155. Min Stack","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Stack, Design</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Implement a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\"\"\"\n\n\n# Stack\nclass MinStack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, val: int) -&gt; None:\n        if self.stack:\n            self.stack.append((val, min(val, self.getMin())))\n        else:\n            self.stack.append((val, val))\n\n    def pop(self) -&gt; None:\n        self.stack.pop()\n\n    def top(self) -&gt; int:\n        return self.stack[-1][0]\n\n    def getMin(self) -&gt; int:\n        return self.stack[-1][1]\n\n\nobj = MinStack()\nobj.push(3)\nobj.push(2)\nobj.pop()\nprint(obj.top())  # 3\nprint(obj.getMin())  # 3\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;climits&gt;\n#include &lt;iostream&gt;\n#include &lt;stack&gt;\n#include &lt;utility&gt;\nusing namespace std;\n\nclass MinStack {\n    stack&lt;pair&lt;int, int&gt;&gt; st;\n\n   public:\n    MinStack() { st.emplace(0, INT_MAX); }\n\n    void push(int val) { st.emplace(val, min(getMin(), val)); }\n\n    void pop() { st.pop(); }\n\n    int top() { return st.top().first; }\n\n    int getMin() { return st.top().second; }\n};\n\nint main() {\n    MinStack minStack;\n    minStack.push(-2);\n    minStack.push(0);\n    minStack.push(-3);\n    cout &lt;&lt; minStack.getMin() &lt;&lt; endl;  // -3\n    minStack.pop();\n    cout &lt;&lt; minStack.top() &lt;&lt; endl;     // 0\n    cout &lt;&lt; minStack.getMin() &lt;&lt; endl;  // -2\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/stack_advanced/#1381-design-a-stack-with-increment-operation","title":"1381. Design a Stack With Increment Operation","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Stack, Design</p> </li> </ul>"},{"location":"EndlessCheng/stack_advanced/#636-exclusive-time-of-functions","title":"636. Exclusive Time of Functions","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Stack</p> </li> </ul>"},{"location":"EndlessCheng/stack_advanced/#2434-using-a-robot-to-print-the-lexicographically-smallest-string","title":"2434. Using a Robot to Print the Lexicographically Smallest String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Stack, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/stack_advanced/#895-maximum-frequency-stack","title":"895. Maximum Frequency Stack","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Stack, Design, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/stack_advanced/#1172-dinner-plate-stacks","title":"1172. Dinner Plate Stacks","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Stack, Design, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/stack_advanced/#2589-minimum-time-to-complete-all-tasks","title":"2589. Minimum Time to Complete All Tasks","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Stack, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/stack_advanced/#716-max-stack","title":"716. Max Stack \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Stack, Design, Doubly Linked List, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/stack_basics/","title":"Stack Basics","text":""},{"location":"EndlessCheng/stack_basics/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1441. Build an Array With Stack Operations (Medium)</li> <li> 844. Backspace String Compare (Easy)</li> <li> 682. Baseball Game (Easy)</li> <li> 2390. Removing Stars From a String (Medium)</li> <li> 1472. Design Browser History (Medium)</li> <li> 946. Validate Stack Sequences (Medium)</li> <li> 3412. Find Mirror Score of a String (Medium)</li> <li> 71. Simplify Path (Medium)</li> </ul>"},{"location":"EndlessCheng/stack_basics/#1441-build-an-array-with-stack-operations","title":"1441. Build an Array With Stack Operations","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Stack, Simulation</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Stack\ndef buildArray(target: List[int], n: int) -&gt; List[str]:\n    res = []\n    m, i, j = len(target), 1, 0\n\n    while i &lt;= n and j &lt; m:\n        res.append(\"Push\")\n        if target[j] != i:\n            res.append(\"Pop\")\n        else:\n            j += 1\n        i += 1\n\n    return res\n\n\ntarget = [1, 3, 4]\nn = 4\nprint(buildArray(target, n))\n# ['Push', 'Push', 'Pop', 'Push', 'Push']\n</code></pre>"},{"location":"EndlessCheng/stack_basics/#844-backspace-string-compare","title":"844. Backspace String Compare","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Stack, Simulation</p> </li> </ul> Python <pre><code>def backspaceCompare(s: str, t: str) -&gt; bool:\n\n    def build(text):\n        stack = []\n\n        for char in text:\n            if char != \"#\":\n                stack.append(char)\n            elif stack:\n                stack.pop()\n\n        return \"\".join(stack)\n\n    return build(s) == build(t)\n\n\nprint(backspaceCompare(\"ab#c\", \"ad#c\"))  # True\n</code></pre>"},{"location":"EndlessCheng/stack_basics/#682-baseball-game","title":"682. Baseball Game","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Stack, Simulation</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Stack\ndef calPoints(operations: List[str]) -&gt; int:\n    stack = []\n\n    for op in operations:\n        if op == \"+\":\n            stack.append(stack[-2] + stack[-1])\n        elif op == \"D\":\n            stack.append(2 * stack[-1])\n        elif op == \"C\":\n            stack.pop()\n        else:\n            stack.append(int(op))\n\n    return sum(stack)\n\n\nops = [\"5\", \"2\", \"C\", \"D\", \"+\"]\nprint(calPoints(ops))  # 30\n</code></pre>"},{"location":"EndlessCheng/stack_basics/#2390-removing-stars-from-a-string","title":"2390. Removing Stars From a String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack, Simulation</p> </li> </ul> Python <pre><code>\"\"\"\n-   Remove all `*` characters and their adjacent characters from the string.\n-   Steps for the string `leet**cod*e`:\n\n| char | action | stack   |\n| ---- | ------ | ------- |\n| l    | push   | \"l\"     |\n| e    | push   | \"le\"    |\n| e    | push   | \"lee\"   |\n| t    | push   | \"leet\"  |\n| *    | pop    | \"lee\"   |\n| *    | pop    | \"le\"    |\n| c    | push   | \"lec\"   |\n| o    | push   | \"leco\"  |\n| d    | push   | \"lecod\" |\n| *    | pop    | \"leco\"  |\n| e    | push   | \"lecoe\" |\n\"\"\"\n\n\n# Stack\ndef removeStars(s: str) -&gt; str:\n    stack = []\n\n    for char in s:\n        if char == \"*\":\n            stack.pop()\n        else:\n            stack.append(char)\n\n    return \"\".join(stack)\n\n\ns = \"leet**cod*e\"\nprint(removeStars(s))  # \"lecoe\"\n</code></pre>"},{"location":"EndlessCheng/stack_basics/#1472-design-browser-history","title":"1472. Design Browser History","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Linked List, Stack, Design, Doubly Linked List, Data Stream</p> </li> </ul> Python <pre><code>class BrowserHistory:\n\n    def __init__(self, homepage: str):\n        self.hist = [homepage]\n        self.cur = 0\n\n    def visit(self, url: str) -&gt; None:\n        self.cur += 1\n        del self.hist[self.cur :]\n        self.hist.append(url)\n\n    def back(self, steps: int) -&gt; str:\n        self.cur = max(self.cur - steps, 0)\n        return self.hist[self.cur]\n\n    def forward(self, steps: int) -&gt; str:\n        self.cur = min(self.cur + steps, len(self.hist) - 1)\n        return self.hist[self.cur]\n\n\nif __name__ == \"__main__\":\n    obj = BrowserHistory(\"leetcode.com\")\n    obj.visit(\"google.com\")\n    obj.visit(\"facebook.com\")\n    obj.visit(\"youtube.com\")\n    assert obj.back(1) == \"facebook.com\"\n    assert obj.back(1) == \"google.com\"\n    assert obj.forward(1) == \"facebook.com\"\n    obj.visit(\"linkedin.com\")\n    assert obj.forward(2) == \"linkedin.com\"\n    assert obj.back(2) == \"google.com\"\n    assert obj.back(7) == \"leetcode.com\"\n</code></pre>"},{"location":"EndlessCheng/stack_basics/#946-validate-stack-sequences","title":"946. Validate Stack Sequences","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Stack, Simulation</p> </li> </ul>"},{"location":"EndlessCheng/stack_basics/#3412-find-mirror-score-of-a-string","title":"3412. Find Mirror Score of a String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Stack, Simulation</p> </li> </ul>"},{"location":"EndlessCheng/stack_basics/#71-simplify-path","title":"71. Simplify Path","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack</p> </li> </ul> Python <pre><code>def simplify_path_stack(path: str) -&gt; str:\n    if not path:\n        return \"/\"\n\n    stack = []\n\n    for p in path.split(\"/\"):\n        if p == \"\" or p == \".\":\n            continue\n        if p != \"..\":\n            stack.append(p)\n        elif stack:\n            stack.pop()\n    return \"/\" + \"/\".join(stack)\n\n\ndef test_simplify_path_stack():\n    assert simplify_path_stack(\"/home/\") == \"/home\"\n    assert simplify_path_stack(\"/../\") == \"/\"\n    assert simplify_path_stack(\"/home//foo/\") == \"/home/foo\"\n    assert simplify_path_stack(\"/a/./b/../../c/\") == \"/c\"\n</code></pre>"},{"location":"EndlessCheng/string_ac_automaton/","title":"String AC Automaton","text":""},{"location":"EndlessCheng/string_ac_automaton/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1032. Stream of Characters (Hard)</li> <li> 1408. String Matching in an Array (Easy)</li> <li> 3213. Construct String with Minimum Cost (Hard)</li> <li> 3292. Minimum Number of Valid Strings to Form Target II (Hard)</li> </ul>"},{"location":"EndlessCheng/string_ac_automaton/#1032-stream-of-characters","title":"1032. Stream of Characters","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Design, Trie, Data Stream</p> </li> </ul>"},{"location":"EndlessCheng/string_ac_automaton/#1408-string-matching-in-an-array","title":"1408. String Matching in an Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, String Matching</p> </li> </ul>"},{"location":"EndlessCheng/string_ac_automaton/#3213-construct-string-with-minimum-cost","title":"3213. Construct String with Minimum Cost","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Dynamic Programming, Suffix Array</p> </li> </ul>"},{"location":"EndlessCheng/string_ac_automaton/#3292-minimum-number-of-valid-strings-to-form-target-ii","title":"3292. Minimum Number of Valid Strings to Form Target II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Binary Search, Dynamic Programming, Segment Tree, Rolling Hash, String Matching, Hash Function</p> </li> </ul>"},{"location":"EndlessCheng/string_hashing/","title":"String Hashing","text":""},{"location":"EndlessCheng/string_hashing/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 28. Find the Index of the First Occurrence in a String (Easy)</li> <li> 187. Repeated DNA Sequences (Medium)</li> <li> 1316. Distinct Echo Substrings (Hard)</li> <li> 1297. Maximum Number of Occurrences of a Substring (Medium)</li> <li> 2261. K Divisible Elements Subarrays (Medium)</li> <li> 3213. Construct String with Minimum Cost (Hard)</li> <li> 1367. Linked List in Binary Tree (Medium)</li> <li> 1044. Longest Duplicate Substring (Hard)</li> <li> 718. Maximum Length of Repeated Subarray (Medium)</li> <li> 1923. Longest Common Subpath (Hard)</li> <li> 3292. Minimum Number of Valid Strings to Form Target II (Hard)</li> <li> 2168. Unique Substrings With Equal Digit Frequency (Medium) \ud83d\udc51</li> <li> 1554. Strings Differ by One Character (Medium) \ud83d\udc51</li> <li> 1062. Longest Repeating Substring (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/string_hashing/#28-find-the-index-of-the-first-occurrence-in-a-string","title":"28. Find the Index of the First Occurrence in a String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, String Matching</p> </li> </ul> Python <pre><code>from leetpattern.utils import LPS\n\n\n# Brute Force\ndef strStrBF(haystack: str, needle: str) -&gt; int:\n    m, n = len(haystack), len(needle)\n    for i in range(m - n + 1):\n        if haystack[i : i + n] == needle:\n            return i\n    return -1\n\n\n# KMP\ndef strStrKMP(haystack: str, needle: str) -&gt; int:\n    lps = LPS(needle)\n    m, n = len(haystack), len(needle)\n    j = 0\n\n    for i in range(m):\n        while j &gt; 0 and haystack[i] != needle[j]:\n            j = lps[j - 1]\n        if haystack[i] == needle[j]:\n            j += 1\n        if j == n:\n            return i - n + 1\n    return -1\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# | Brute Force| O((m - n) * n)   | O(1)    |\n# | KMP        | O(m + n)         | O(n)    |\n# |------------|------------------|---------|\n\n\nhaystack = \"hello\"\nneedle = \"ll\"\nprint(strStrBF(haystack, needle))  # 2\nprint(strStrKMP(haystack, needle))  # 2\n</code></pre>"},{"location":"EndlessCheng/string_hashing/#187-repeated-dna-sequences","title":"187. Repeated DNA Sequences","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Bit Manipulation, Sliding Window, Rolling Hash, Hash Function</p> </li> </ul>"},{"location":"EndlessCheng/string_hashing/#1316-distinct-echo-substrings","title":"1316. Distinct Echo Substrings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Trie, Rolling Hash, Hash Function</p> </li> </ul>"},{"location":"EndlessCheng/string_hashing/#1297-maximum-number-of-occurrences-of-a-substring","title":"1297. Maximum Number of Occurrences of a Substring","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/string_hashing/#2261-k-divisible-elements-subarrays","title":"2261. K Divisible Elements Subarrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Trie, Rolling Hash, Hash Function, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/string_hashing/#3213-construct-string-with-minimum-cost","title":"3213. Construct String with Minimum Cost","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Dynamic Programming, Suffix Array</p> </li> </ul>"},{"location":"EndlessCheng/string_hashing/#1367-linked-list-in-binary-tree","title":"1367. Linked List in Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/string_hashing/#1044-longest-duplicate-substring","title":"1044. Longest Duplicate Substring","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Binary Search, Sliding Window, Rolling Hash, Suffix Array, Hash Function</p> </li> </ul>"},{"location":"EndlessCheng/string_hashing/#718-maximum-length-of-repeated-subarray","title":"718. Maximum Length of Repeated Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Dynamic Programming, Sliding Window, Rolling Hash, Hash Function</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef findLength(nums1: List[int], nums2: List[int]) -&gt; int:\n    m = len(nums1)\n    n = len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    length = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if nums1[i - 1] == nums2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            if length &lt; dp[i][j]:\n                length = dp[i][j]\n\n    return length\n\n\nprint(findLength([1, 2, 3, 2, 1], [3, 2, 1, 4, 7]))  # 3\n</code></pre>"},{"location":"EndlessCheng/string_hashing/#1923-longest-common-subpath","title":"1923. Longest Common Subpath","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Rolling Hash, Suffix Array, Hash Function</p> </li> </ul>"},{"location":"EndlessCheng/string_hashing/#3292-minimum-number-of-valid-strings-to-form-target-ii","title":"3292. Minimum Number of Valid Strings to Form Target II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Binary Search, Dynamic Programming, Segment Tree, Rolling Hash, String Matching, Hash Function</p> </li> </ul>"},{"location":"EndlessCheng/string_hashing/#2168-unique-substrings-with-equal-digit-frequency","title":"2168. Unique Substrings With Equal Digit Frequency \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Rolling Hash, Counting, Hash Function</p> </li> </ul>"},{"location":"EndlessCheng/string_hashing/#1554-strings-differ-by-one-character","title":"1554. Strings Differ by One Character \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Rolling Hash, Hash Function</p> </li> </ul>"},{"location":"EndlessCheng/string_hashing/#1062-longest-repeating-substring","title":"1062. Longest Repeating Substring \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Binary Search, Dynamic Programming, Rolling Hash, Suffix Array, Hash Function</p> </li> </ul>"},{"location":"EndlessCheng/string_kmp/","title":"String KMP","text":""},{"location":"EndlessCheng/string_kmp/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 28. Find the Index of the First Occurrence in a String (Easy)</li> <li> 796. Rotate String (Easy)</li> <li> 1392. Longest Happy Prefix (Hard)</li> <li> 3036. Number of Subarrays That Match a Pattern II (Hard)</li> <li> 1764. Form Array by Concatenating Subarrays of Another Array (Medium)</li> <li> 1668. Maximum Repeating Substring (Easy)</li> <li> 459. Repeated Substring Pattern (Easy)</li> <li> 3008. Find Beautiful Indices in the Given Array II (Hard)</li> <li> 214. Shortest Palindrome (Hard)</li> <li> 686. Repeated String Match (Medium)</li> <li> 1397. Find All Good Strings (Hard)</li> <li> 3037. Find Pattern in Infinite Stream II (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/string_kmp/#28-find-the-index-of-the-first-occurrence-in-a-string","title":"28. Find the Index of the First Occurrence in a String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, String Matching</p> </li> </ul> Python <pre><code>from leetpattern.utils import LPS\n\n\n# Brute Force\ndef strStrBF(haystack: str, needle: str) -&gt; int:\n    m, n = len(haystack), len(needle)\n    for i in range(m - n + 1):\n        if haystack[i : i + n] == needle:\n            return i\n    return -1\n\n\n# KMP\ndef strStrKMP(haystack: str, needle: str) -&gt; int:\n    lps = LPS(needle)\n    m, n = len(haystack), len(needle)\n    j = 0\n\n    for i in range(m):\n        while j &gt; 0 and haystack[i] != needle[j]:\n            j = lps[j - 1]\n        if haystack[i] == needle[j]:\n            j += 1\n        if j == n:\n            return i - n + 1\n    return -1\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# | Brute Force| O((m - n) * n)   | O(1)    |\n# | KMP        | O(m + n)         | O(n)    |\n# |------------|------------------|---------|\n\n\nhaystack = \"hello\"\nneedle = \"ll\"\nprint(strStrBF(haystack, needle))  # 2\nprint(strStrKMP(haystack, needle))  # 2\n</code></pre>"},{"location":"EndlessCheng/string_kmp/#796-rotate-string","title":"796. Rotate String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, String Matching</p> </li> </ul> Python <pre><code># String\ndef rotateString(s: str, goal: str) -&gt; bool:\n    n = len(s)\n    s += s\n\n    for i in range(n):\n        if s[i : i + n] == goal:\n            return True\n\n    return False\n\n\ns = \"abcde\"\ngoal = \"cdeab\"\nprint(rotateString(s, goal))  # True\n</code></pre>"},{"location":"EndlessCheng/string_kmp/#1392-longest-happy-prefix","title":"1392. Longest Happy Prefix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Rolling Hash, String Matching, Hash Function</p> </li> </ul> Python <pre><code>from leetpattern.utils import LPS\n\n\n# KMP\ndef longestPrefix(s: str) -&gt; str:\n    if len(s) &lt;= 1:\n        return \"\"\n\n    lps = LPS(s)\n\n    return s[: lps[-1]]\n\n\nprint(longestPrefix(\"ababab\"))  # abab\n</code></pre>"},{"location":"EndlessCheng/string_kmp/#3036-number-of-subarrays-that-match-a-pattern-ii","title":"3036. Number of Subarrays That Match a Pattern II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Rolling Hash, String Matching, Hash Function</p> </li> </ul>"},{"location":"EndlessCheng/string_kmp/#1764-form-array-by-concatenating-subarrays-of-another-array","title":"1764. Form Array by Concatenating Subarrays of Another Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Greedy, String Matching</p> </li> </ul>"},{"location":"EndlessCheng/string_kmp/#1668-maximum-repeating-substring","title":"1668. Maximum Repeating Substring","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, String Matching</p> </li> </ul>"},{"location":"EndlessCheng/string_kmp/#459-repeated-substring-pattern","title":"459. Repeated Substring Pattern","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, String Matching</p> </li> </ul> Python <pre><code>from leetpattern.utils import LPS\n\n\n# KMP\ndef repeatedSubstringPattern(s: str) -&gt; bool:\n    lps = LPS(s)\n    length = len(s)\n\n    if lps[-1] != 0 and length % (length - lps[-1]) == 0:\n        return True\n\n    return False\n\n\ns = \"abab\"\nprint(repeatedSubstringPattern(s))  # True\n</code></pre>"},{"location":"EndlessCheng/string_kmp/#3008-find-beautiful-indices-in-the-given-array-ii","title":"3008. Find Beautiful Indices in the Given Array II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Binary Search, Rolling Hash, String Matching, Hash Function</p> </li> </ul>"},{"location":"EndlessCheng/string_kmp/#214-shortest-palindrome","title":"214. Shortest Palindrome","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Rolling Hash, String Matching, Hash Function</p> </li> </ul> Python <pre><code>from leetpattern.utils import LPS\n\n\n# KMP\ndef shortestPalindrome(s: str) -&gt; str:\n    if not s:\n        return s\n\n    new = s + \"#\" + s[::-1]\n    lps = LPS(new)\n\n    add_len = len(s) - lps[-1]\n\n    return s[::-1][:add_len] + s\n\n\nprint(shortestPalindrome(\"aacecaaa\"))  # aaacecaaa\n</code></pre>"},{"location":"EndlessCheng/string_kmp/#686-repeated-string-match","title":"686. Repeated String Match","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, String Matching</p> </li> </ul> Python <pre><code>import math\n\nfrom leetpattern.utils import LPS\n\n\n# KMP\ndef repeatedStringMatch(a: str, b: str) -&gt; int:\n    min_repeat = math.ceil(len(b) / len(a))\n\n    def kmp(text, pattern):\n        n, m = len(text), len(pattern)\n        lps = LPS(pattern)\n        j = 0\n\n        for i in range(n):\n            while j &gt; 0 and text[i] != pattern[j]:\n                j = lps[j - 1]\n            if text[i] == pattern[j]:\n                j += 1\n            if j == m:\n                return i - j + 1\n        return -1\n\n    for i in range(min_repeat, min_repeat + 2):\n        if kmp(a * i, b) != -1:\n            return i\n    return -1\n\n\nprint(repeatedStringMatch(\"abcd\", \"cdabcdab\"))  # 3\n</code></pre>"},{"location":"EndlessCheng/string_kmp/#1397-find-all-good-strings","title":"1397. Find All Good Strings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, String Matching</p> </li> </ul>"},{"location":"EndlessCheng/string_kmp/#3037-find-pattern-in-infinite-stream-ii","title":"3037. Find Pattern in Infinite Stream II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sliding Window, Rolling Hash, String Matching, Hash Function</p> </li> </ul>"},{"location":"EndlessCheng/string_manacher_algorithm/","title":"String Manacher Algorithm","text":""},{"location":"EndlessCheng/string_manacher_algorithm/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 5. Longest Palindromic Substring (Medium)</li> <li> 647. Palindromic Substrings (Medium)</li> <li> 214. Shortest Palindrome (Hard)</li> <li> 3327. Check if DFS Strings Are Palindromes (Hard)</li> <li> 1745. Palindrome Partitioning IV (Hard)</li> <li> 1960. Maximum Product of the Length of Two Palindromic Substrings (Hard)</li> </ul>"},{"location":"EndlessCheng/string_manacher_algorithm/#5-longest-palindromic-substring","title":"5. Longest Palindromic Substring","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Dynamic Programming</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the longest palindromic substring in `s`.\n\"\"\"\n\n\n# DP - Interval\ndef longestPalindromeDP(s: str) -&gt; str:\n    n = len(s)\n    if n &lt;= 1:\n        return s\n\n    start, maxLen = 0, 1\n\n    # Init\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for j in range(1, n):\n        for i in range(j):\n            if s[i] == s[j]:\n                if j - i &lt;= 2:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1]\n\n                if dp[i][j] and j - i + 1 &gt; maxLen:\n                    maxLen = j - i + 1\n                    start = i\n\n    return s[start : start + maxLen]\n\n\n# Expand Around Center\ndef longestPalindromeCenter(s: str) -&gt; str:\n    def expand_around_center(left, right):\n        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n\n    if len(s) &lt;= 1:\n        return s\n\n    start, end = 0, 0\n    for i in range(len(s)):\n        len1 = expand_around_center(i, i)  # odd\n        len2 = expand_around_center(i, i + 1)  # even\n\n        maxLen = max(len1, len2)\n        if maxLen &gt; end - start:\n            start = i - (maxLen - 1) // 2\n            end = i + maxLen // 2\n\n    return s[start : end + 1]\n\n\ns = \"babad\"\nprint(longestPalindromeDP(s))  # \"bab\"\nprint(longestPalindromeCenter(s))  # \"aba\"\n</code></pre>"},{"location":"EndlessCheng/string_manacher_algorithm/#647-palindromic-substrings","title":"647. Palindromic Substrings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Dynamic Programming</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the number of palindromic substrings in `s`.\n-   Bottom-up DP table\n\n|  dp   |  a  |  b  |  b  |  a  |  e  |\n| :---: | :-: | :-: | :-: | :-: | :-: |\n| **a** |  1  |  0  |  0  |  1  |  0  |\n| **b** |  0  |  1  |  1  |  0  |  0  |\n| **b** |  0  |  0  |  1  |  0  |  0  |\n| **a** |  0  |  0  |  0  |  1  |  0  |\n| **e** |  0  |  0  |  0  |  0  |  1  |\n\"\"\"\n\n\ndef countSubstrings(s: str) -&gt; int:\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    res = 0\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i, n):\n            if s[i] == s[j]:\n                if j - i &lt;= 1:\n                    dp[i][j] = 1\n                    res += 1\n                elif dp[i + 1][j - 1]:\n                    dp[i][j] = 1\n                    res += 1\n\n    return res\n\n\nprint(countSubstrings(\"abbae\"))  # 7\n</code></pre>"},{"location":"EndlessCheng/string_manacher_algorithm/#214-shortest-palindrome","title":"214. Shortest Palindrome","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Rolling Hash, String Matching, Hash Function</p> </li> </ul> Python <pre><code>from leetpattern.utils import LPS\n\n\n# KMP\ndef shortestPalindrome(s: str) -&gt; str:\n    if not s:\n        return s\n\n    new = s + \"#\" + s[::-1]\n    lps = LPS(new)\n\n    add_len = len(s) - lps[-1]\n\n    return s[::-1][:add_len] + s\n\n\nprint(shortestPalindrome(\"aacecaaa\"))  # aaacecaaa\n</code></pre>"},{"location":"EndlessCheng/string_manacher_algorithm/#3327-check-if-dfs-strings-are-palindromes","title":"3327. Check if DFS Strings Are Palindromes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Tree, Depth First Search, Hash Function</p> </li> </ul>"},{"location":"EndlessCheng/string_manacher_algorithm/#1745-palindrome-partitioning-iv","title":"1745. Palindrome Partitioning IV","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul> Python <pre><code># DP\ndef checkPartitioning(s: str) -&gt; bool:\n    def palidrome_partition(s, k):\n        n = len(s)\n        min_change = [[0] * n for _ in range(n)]\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 1, n):\n                min_change[i][j] = min_change[i + 1][j - 1] + (1 if s[i] != s[j] else 0)\n\n        dp = min_change[0]\n\n        for i in range(1, k):\n            for right in range(n - k + i, i - 1, -1):\n                dp[right] = min(\n                    dp[left - 1] + min_change[left][right] for left in range(i, right + 1)\n                )\n\n        return dp[-1]\n\n    return palidrome_partition(s, 3) == 0\n\n\ns = \"abcbdd\"\nprint(checkPartitioning(s))  # True\n</code></pre>"},{"location":"EndlessCheng/string_manacher_algorithm/#1960-maximum-product-of-the-length-of-two-palindromic-substrings","title":"1960. Maximum Product of the Length of Two Palindromic Substrings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Rolling Hash, Hash Function</p> </li> </ul>"},{"location":"EndlessCheng/string_minimal_representation/","title":"String Minimal Representation","text":""},{"location":"EndlessCheng/string_minimal_representation/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1163. Last Substring in Lexicographical Order (Hard)</li> <li> 899. Orderly Queue (Hard)</li> <li> 3403. Find the Lexicographically Largest String From the Box I (Medium)</li> </ul>"},{"location":"EndlessCheng/string_minimal_representation/#1163-last-substring-in-lexicographical-order","title":"1163. Last Substring in Lexicographical Order","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String</p> </li> </ul>"},{"location":"EndlessCheng/string_minimal_representation/#899-orderly-queue","title":"899. Orderly Queue","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/string_minimal_representation/#3403-find-the-lexicographically-largest-string-from-the-box-i","title":"3403. Find the Lexicographically Largest String From the Box I","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Enumeration</p> </li> </ul> Python <pre><code># Lexicographically Smallest/Largest\ndef answerString(word: str, numFriends: int) -&gt; str:\n    if numFriends == 1:\n        return word\n\n    n = len(word)\n    return max(word[i : i + n - numFriends + 1] for i in range(n))\n\n\nif __name__ == \"__main__\":\n    assert answerString(\"dbca\", 2) == \"dbc\"\n</code></pre>"},{"location":"EndlessCheng/string_subsequence_automaton/","title":"String Subsequence Automaton","text":""},{"location":"EndlessCheng/string_subsequence_automaton/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 792. Number of Matching Subsequences (Medium)</li> <li> 514. Freedom Trail (Hard)</li> <li> 2014. Longest Subsequence Repeated k Times (Hard)</li> <li> 1055. Shortest Way to Form String (Medium) \ud83d\udc51</li> <li> 727. Minimum Window Subsequence (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/string_subsequence_automaton/#792-number-of-matching-subsequences","title":"792. Number of Matching Subsequences","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Binary Search, Dynamic Programming, Trie, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/string_subsequence_automaton/#514-freedom-trail","title":"514. Freedom Trail","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Depth First Search, Breadth First Search</p> </li> </ul>"},{"location":"EndlessCheng/string_subsequence_automaton/#2014-longest-subsequence-repeated-k-times","title":"2014. Longest Subsequence Repeated k Times","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Backtracking, Greedy, Counting, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/string_subsequence_automaton/#1055-shortest-way-to-form-string","title":"1055. Shortest Way to Form String \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Binary Search, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/string_subsequence_automaton/#727-minimum-window-subsequence","title":"727. Minimum Window Subsequence \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/string_suffix_array/","title":"String Suffix Array","text":""},{"location":"EndlessCheng/string_suffix_array/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1163. Last Substring in Lexicographical Order (Hard)</li> <li> 1754. Largest Merge Of Two Strings (Medium)</li> <li> 2904. Shortest and Lexicographically Smallest Beautiful String (Medium)</li> <li> 3213. Construct String with Minimum Cost (Hard)</li> <li> 1044. Longest Duplicate Substring (Hard)</li> <li> 718. Maximum Length of Repeated Subarray (Medium)</li> <li> 1923. Longest Common Subpath (Hard)</li> <li> 1408. String Matching in an Array (Easy)</li> <li> 3076. Shortest Uncommon Substring in an Array (Medium)</li> <li> 1316. Distinct Echo Substrings (Hard)</li> <li> 3388. Count Beautiful Splits in an Array (Medium)</li> <li> 2564. Substring XOR Queries (Medium)</li> <li> 1698. Number of Distinct Substrings in a String (Medium) \ud83d\udc51</li> <li> 1062. Longest Repeating Substring (Medium) \ud83d\udc51</li> <li> 3135. Equalize Strings by Adding or Removing Characters at Ends (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/string_suffix_array/#1163-last-substring-in-lexicographical-order","title":"1163. Last Substring in Lexicographical Order","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String</p> </li> </ul>"},{"location":"EndlessCheng/string_suffix_array/#1754-largest-merge-of-two-strings","title":"1754. Largest Merge Of Two Strings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/string_suffix_array/#2904-shortest-and-lexicographically-smallest-beautiful-string","title":"2904. Shortest and Lexicographically Smallest Beautiful String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Sliding Window</p> </li> </ul> Python <pre><code># Sliding Window Variable Size\ndef shortestBeautifulSubstring(s: str, k: int) -&gt; str:\n    n = len(s)\n    left = 0\n    oneCount = 0\n    minLen = float(\"inf\")\n    res = \"\"\n\n    for right in range(n):\n        if s[right] == \"1\":\n            oneCount += 1\n\n        while oneCount == k:\n            size = right - left + 1\n\n            if size &lt; minLen:\n                minLen = size\n                res = s[left : right + 1]\n            elif size == minLen:\n                res = min(res, s[left : right + 1])\n\n            if s[left] == \"1\":\n                oneCount -= 1\n            left += 1\n\n    return res\n\n\ns = \"100011001\"\nk = 3\nprint(shortestBeautifulSubstring(s, k))  # 11001\n</code></pre>"},{"location":"EndlessCheng/string_suffix_array/#3213-construct-string-with-minimum-cost","title":"3213. Construct String with Minimum Cost","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Dynamic Programming, Suffix Array</p> </li> </ul>"},{"location":"EndlessCheng/string_suffix_array/#1044-longest-duplicate-substring","title":"1044. Longest Duplicate Substring","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Binary Search, Sliding Window, Rolling Hash, Suffix Array, Hash Function</p> </li> </ul>"},{"location":"EndlessCheng/string_suffix_array/#718-maximum-length-of-repeated-subarray","title":"718. Maximum Length of Repeated Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Dynamic Programming, Sliding Window, Rolling Hash, Hash Function</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef findLength(nums1: List[int], nums2: List[int]) -&gt; int:\n    m = len(nums1)\n    n = len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    length = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if nums1[i - 1] == nums2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            if length &lt; dp[i][j]:\n                length = dp[i][j]\n\n    return length\n\n\nprint(findLength([1, 2, 3, 2, 1], [3, 2, 1, 4, 7]))  # 3\n</code></pre>"},{"location":"EndlessCheng/string_suffix_array/#1923-longest-common-subpath","title":"1923. Longest Common Subpath","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Rolling Hash, Suffix Array, Hash Function</p> </li> </ul>"},{"location":"EndlessCheng/string_suffix_array/#1408-string-matching-in-an-array","title":"1408. String Matching in an Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, String Matching</p> </li> </ul>"},{"location":"EndlessCheng/string_suffix_array/#3076-shortest-uncommon-substring-in-an-array","title":"3076. Shortest Uncommon Substring in an Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Trie</p> </li> </ul>"},{"location":"EndlessCheng/string_suffix_array/#1316-distinct-echo-substrings","title":"1316. Distinct Echo Substrings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Trie, Rolling Hash, Hash Function</p> </li> </ul>"},{"location":"EndlessCheng/string_suffix_array/#3388-count-beautiful-splits-in-an-array","title":"3388. Count Beautiful Splits in an Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/string_suffix_array/#2564-substring-xor-queries","title":"2564. Substring XOR Queries","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Bit Manipulation</p> </li> </ul>"},{"location":"EndlessCheng/string_suffix_array/#1698-number-of-distinct-substrings-in-a-string","title":"1698. Number of Distinct Substrings in a String \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Trie, Rolling Hash, Suffix Array, Hash Function</p> </li> </ul>"},{"location":"EndlessCheng/string_suffix_array/#1062-longest-repeating-substring","title":"1062. Longest Repeating Substring \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Binary Search, Dynamic Programming, Rolling Hash, Suffix Array, Hash Function</p> </li> </ul>"},{"location":"EndlessCheng/string_suffix_array/#3135-equalize-strings-by-adding-or-removing-characters-at-ends","title":"3135. Equalize Strings by Adding or Removing Characters at Ends \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Binary Search, Dynamic Programming, Sliding Window, Hash Function</p> </li> </ul>"},{"location":"EndlessCheng/string_z_function/","title":"String Z Function","text":""},{"location":"EndlessCheng/string_z_function/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2223. Sum of Scores of Built Strings (Hard)</li> <li> 3031. Minimum Time to Revert Word to Initial State II (Hard)</li> <li> 3045. Count Prefix and Suffix Pairs II (Hard)</li> <li> 3303. Find the Occurrence of First Almost Equal Substring (Hard)</li> <li> 3292. Minimum Number of Valid Strings to Form Target II (Hard)</li> <li> 2430. Maximum Deletions on a String (Hard)</li> <li> 3388. Count Beautiful Splits in an Array (Medium)</li> <li> 1977. Number of Ways to Separate Numbers (Hard)</li> </ul>"},{"location":"EndlessCheng/string_z_function/#2223-sum-of-scores-of-built-strings","title":"2223. Sum of Scores of Built Strings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Binary Search, Rolling Hash, Suffix Array, String Matching, Hash Function</p> </li> </ul>"},{"location":"EndlessCheng/string_z_function/#3031-minimum-time-to-revert-word-to-initial-state-ii","title":"3031. Minimum Time to Revert Word to Initial State II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Rolling Hash, String Matching, Hash Function</p> </li> </ul>"},{"location":"EndlessCheng/string_z_function/#3045-count-prefix-and-suffix-pairs-ii","title":"3045. Count Prefix and Suffix Pairs II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Trie, Rolling Hash, String Matching, Hash Function</p> </li> </ul>"},{"location":"EndlessCheng/string_z_function/#3303-find-the-occurrence-of-first-almost-equal-substring","title":"3303. Find the Occurrence of First Almost Equal Substring","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, String Matching</p> </li> </ul>"},{"location":"EndlessCheng/string_z_function/#3292-minimum-number-of-valid-strings-to-form-target-ii","title":"3292. Minimum Number of Valid Strings to Form Target II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Binary Search, Dynamic Programming, Segment Tree, Rolling Hash, String Matching, Hash Function</p> </li> </ul>"},{"location":"EndlessCheng/string_z_function/#2430-maximum-deletions-on-a-string","title":"2430. Maximum Deletions on a String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Rolling Hash, String Matching, Hash Function</p> </li> </ul>"},{"location":"EndlessCheng/string_z_function/#3388-count-beautiful-splits-in-an-array","title":"3388. Count Beautiful Splits in an Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/string_z_function/#1977-number-of-ways-to-separate-numbers","title":"1977. Number of Ways to Separate Numbers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Suffix Array</p> </li> </ul>"},{"location":"EndlessCheng/strongly_and_biconnected_components/","title":"Strongly and Biconnected Components","text":""},{"location":"EndlessCheng/strongly_and_biconnected_components/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1192. Critical Connections in a Network (Hard)</li> <li> 1568. Minimum Number of Days to Disconnect Island (Hard)</li> <li> 3383. Minimum Runes to Add to Cast Spell (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/strongly_and_biconnected_components/#1192-critical-connections-in-a-network","title":"1192. Critical Connections in a Network","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Graph, Biconnected Component</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Tarjan\ndef criticalConnections(n: int, connections: List[List[int]]) -&gt; List[List[int]]:\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    disc = [-1] * n\n    low = [-1] * n\n    bridges = []\n    time = 0\n\n    def dfs(n1, prev):\n        nonlocal time\n        disc[n1], low[n1] = time, time\n        time += 1\n\n        for n2 in graph[n1]:\n            if n2 == prev:\n                continue\n            if disc[n2] == -1:\n                dfs(n2, n1)\n                low[n1] = min(low[n1], low[n2])\n\n                if low[n2] &gt; disc[n1]:\n                    bridges.append([n1, n2])\n            else:\n                low[n1] = min(low[n1], disc[n2])\n\n    for i in range(n):\n        if disc[i] == -1:\n            dfs(i, -1)\n\n    return bridges\n\n\nn = 4\nconnections = [[0, 1], [1, 2], [2, 0], [1, 3]]\nprint(criticalConnections(n, connections))  # [[1, 3]]\n</code></pre>"},{"location":"EndlessCheng/strongly_and_biconnected_components/#1568-minimum-number-of-days-to-disconnect-island","title":"1568. Minimum Number of Days to Disconnect Island","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Matrix, Strongly Connected Component</p> </li> </ul>"},{"location":"EndlessCheng/strongly_and_biconnected_components/#3383-minimum-runes-to-add-to-cast-spell","title":"3383. Minimum Runes to Add to Cast Spell \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Union Find, Graph, Topological Sort</p> </li> </ul>"},{"location":"EndlessCheng/topological_order_dp/","title":"Topological Order DP","text":""},{"location":"EndlessCheng/topological_order_dp/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2050. Parallel Courses III (Hard)</li> <li> 1857. Largest Color Value in a Directed Graph (Hard)</li> </ul>"},{"location":"EndlessCheng/topological_order_dp/#2050-parallel-courses-iii","title":"2050. Parallel Courses III","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Graph, Topological Sort</p> </li> </ul>"},{"location":"EndlessCheng/topological_order_dp/#1857-largest-color-value-in-a-directed-graph","title":"1857. Largest Color Value in a Directed Graph","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Dynamic Programming, Graph, Topological Sort, Memoization, Counting</p> </li> </ul> Python <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# Topological Sort\ndef largestPathValue(colors: str, edges: List[List[int]]) -&gt; int:\n    n = len(colors)\n    graph = defaultdict(list)\n    indegree = [0 for _ in range(n)]\n\n    for u, v in edges:\n        graph[u].append(v)\n        indegree[v] += 1\n\n    q = deque([i for i in range(n) if indegree[i] == 0])\n\n    dp = [[0] * 26 for _ in range(n)]\n\n    for i in range(n):\n        dp[i][ord(colors[i]) - ord(\"a\")] = 1\n\n    processed, max_color = 0, 0\n\n    while q:\n        n1 = q.popleft()\n        processed += 1\n        max_color = max(max_color, max(dp[n1]))\n\n        for n2 in graph[n1]:\n            indegree[n2] -= 1\n            for i in range(26):\n                dp[n2][i] = max(\n                    dp[n2][i],\n                    dp[n1][i] + (1 if i == ord(colors[n2]) - ord(\"a\") else 0),\n                )\n            if indegree[n2] == 0:\n                q.append(n2)\n\n    return max_color if processed == n else -1\n\n\ncolors = \"abaca\"\nedges = [[0, 1], [0, 2], [2, 3], [3, 4]]\nprint(largestPathValue(colors, edges))  # 3\n</code></pre>"},{"location":"EndlessCheng/topological_sorting/","title":"Topological Sorting","text":""},{"location":"EndlessCheng/topological_sorting/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1557. Minimum Number of Vertices to Reach All Nodes (Medium)</li> <li> 210. Course Schedule II (Medium)</li> <li> 1462. Course Schedule IV (Medium)</li> <li> 2115. Find All Possible Recipes from Given Supplies (Medium)</li> <li> 851. Loud and Rich (Medium)</li> <li> 310. Minimum Height Trees (Medium)</li> <li> 2392. Build a Matrix With Conditions (Hard)</li> <li> 802. Find Eventual Safe States (Medium)</li> <li> 1591. Strange Printer II (Hard)</li> <li> 1203. Sort Items by Groups Respecting Dependencies (Hard)</li> <li> 2603. Collect Coins in a Tree (Hard)</li> <li> 269. Alien Dictionary (Hard) \ud83d\udc51</li> <li> 444. Sequence Reconstruction (Medium) \ud83d\udc51</li> <li> 1059. All Paths from Source Lead to Destination (Medium) \ud83d\udc51</li> <li> 1136. Parallel Courses (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/topological_sorting/#1557-minimum-number-of-vertices-to-reach-all-nodes","title":"1557. Minimum Number of Vertices to Reach All Nodes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Graph</p> </li> </ul> Python <pre><code>\"\"\"\n- Return a list of integers representing the minimum number of vertices needed to traverse all the nodes.\n- Hint: Return the vertices with indegree 0.\n\"\"\"\n\nfrom typing import List\n\n\n# Graph\ndef findSmallestSetOfVertices(n: int, edges: List[List[int]]) -&gt; List[int]:\n    indegree = {i: 0 for i in range(n)}\n\n    for _, end in edges:\n        indegree[end] += 1\n\n    return [i for i in range(n) if indegree[i] == 0]\n\n\nif __name__ == \"__main__\":\n    n = 6\n    edges = [[0, 1], [0, 2], [2, 5], [3, 4], [4, 2]]\n    assert findSmallestSetOfVertices(n, edges) == [0, 3]\n</code></pre>"},{"location":"EndlessCheng/topological_sorting/#210-course-schedule-ii","title":"210. Course Schedule II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Graph, Topological Sort</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return the ordering of courses you should take to finish all courses. If there are multiple valid answers, return any of them.\n\n![0207](../../assets/0207.png)\n\"\"\"\n\nfrom collections import defaultdict, deque\nfrom typing import List\n\n\n# 1. BFS - Kahn's Algorithm\ndef findOrderBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    order = []\n\n    while q:\n        pre = q.popleft()\n        order.append(pre)\n\n        for crs in graph[pre]:\n            indegree[crs] -= 1\n            if indegree[crs] == 0:\n                q.append(crs)\n\n    return order if len(order) == numCourses else []\n\n\n# 2. DFS + Set\ndef findOrderDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]:\n    adj = defaultdict(list)\n    for crs, pre in prerequisites:\n        adj[crs].append(pre)\n\n    visit, cycle = set(), set()\n    order = []\n\n    def dfs(crs):\n        if crs in cycle:\n            return False\n        if crs in visit:\n            return True\n\n        cycle.add(crs)\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        cycle.remove(crs)\n        visit.add(crs)\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order\n\n\n# 3. DFS + List\ndef findOrderDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]:\n    adj = defaultdict(list)\n    for pre, crs in prerequisites:\n        adj[crs].append(pre)\n\n    # 0: not visited, 1: visiting, 2: visited\n    state = [0] * numCourses\n    order = []\n\n    def dfs(crs):\n        if state[crs] == 1:\n            return False\n        if state[crs] == 2:\n            return True\n\n        state[crs] = 1\n\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        state[crs] = 2\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order[::-1]\n\n\nnumCourses = 5\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(findOrderBFS(numCourses, prerequisites))  # [2, 4, 3, 1, 0]\nprint(findOrderDFS1(numCourses, prerequisites))  # [4, 3, 1, 2, 0]\nprint(findOrderDFS2(numCourses, prerequisites))  # [4, 3, 2, 1, 0]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    // BFS\n    vector&lt;int&gt; findOrderBFS(int numCourses,\n                             vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        vector&lt;int&gt; in_degree(numCourses, 0);\n        vector&lt;int&gt; res;\n\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n            in_degree[pre[0]]++;\n        }\n\n        queue&lt;int&gt; q;\n        for (int i = 0; i &lt; numCourses; i++)\n            if (in_degree[i] == 0) q.push(i);\n\n        while (!q.empty()) {\n            int cur = q.front();\n            q.pop();\n            res.push_back(cur);\n\n            for (int next : graph[cur]) {\n                in_degree[next]--;\n                if (in_degree[next] == 0) q.push(next);\n            }\n        }\n\n        return (int)res.size() == numCourses ? res : vector&lt;int&gt;{};\n    }\n};\n\nint main() {\n    Solution obj;\n    vector&lt;vector&lt;int&gt;&gt; prerequisites{{1, 0}, {2, 0}, {3, 1}, {3, 2}};\n    vector&lt;int&gt; res = obj.findOrderBFS(4, prerequisites);\n    assert((res == vector&lt;int&gt;{0, 1, 2, 3} || res == vector&lt;int&gt;{0, 2, 1, 3}));\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/topological_sorting/#1462-course-schedule-iv","title":"1462. Course Schedule IV","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Graph, Topological Sort</p> </li> </ul> Python <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# Topological Sort\ndef checkIfPrerequisite(\n    numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]\n) -&gt; List[bool]:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n    record = defaultdict(set)  # store all prerequisites for each course\n\n    for a, b in prerequisites:\n        graph[a].append(b)\n        indegree[b] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n\n    while q:\n        cur = q.popleft()\n        for nxt in graph[cur]:\n            record[nxt].add(cur)\n            record[nxt].update(record[cur])\n\n            indegree[nxt] -= 1\n            if indegree[nxt] == 0:\n                q.append(nxt)\n\n    res = []\n    for u, v in queries:\n        res.append(u in record[v])\n    return res\n\n\nif __name__ == \"__main__\":\n    numCourses = 2\n    prerequisites = [[1, 0]]\n    queries = [[0, 1], [1, 0]]\n    assert checkIfPrerequisite(numCourses, prerequisites, queries) == [\n        False,\n        True,\n    ]\n    numCourses = 3\n    prerequisites = [[1, 2], [1, 0], [2, 0]]\n    queries = [[1, 0], [1, 2]]\n    assert checkIfPrerequisite(numCourses, prerequisites, queries) == [\n        True,\n        True,\n    ]\n</code></pre>"},{"location":"EndlessCheng/topological_sorting/#2115-find-all-possible-recipes-from-given-supplies","title":"2115. Find All Possible Recipes from Given Supplies","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Graph, Topological Sort</p> </li> </ul> Python <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# Topological Sort\ndef findAllRecipes(\n    recipes: List[str], ingredients: List[List[str]], supplies: List[str]\n) -&gt; List[str]:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for a, b in zip(recipes, ingredients):\n        for i in b:\n            graph[i].append(a)\n        indegree[a] = len(b)\n\n    res = []\n    q = deque(supplies)\n\n    while q:\n        cur = q.popleft()\n        for nxt in graph[cur]:\n            indegree[nxt] -= 1\n            if indegree[nxt] == 0:\n                q.append(nxt)\n                res.append(nxt)\n    return res\n\n\nif __name__ == \"__main__\":\n    recipes = [\"bread\"]\n    ingredients = [[\"yeast\", \"flour\"]]\n    supplies = [\"yeast\", \"flour\", \"corn\"]\n    assert findAllRecipes(recipes, ingredients, supplies) == [\"bread\"]\n</code></pre>"},{"location":"EndlessCheng/topological_sorting/#851-loud-and-rich","title":"851. Loud and Rich","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Graph, Topological Sort</p> </li> </ul>"},{"location":"EndlessCheng/topological_sorting/#310-minimum-height-trees","title":"310. Minimum Height Trees","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Graph, Topological Sort</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\ndef findMinHeightTrees(n: int, edges: List[List[int]]) -&gt; List[int]:\n    if n == 1:\n        return [0]\n\n    graph = {i: set() for i in range(n)}\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    q = deque([i for i in range(n) if len(graph[i]) == 1])\n    remaining = n\n\n    while remaining &gt; 2:\n        size = len(q)\n        remaining -= size\n\n        for _ in range(size):\n            cur = q.popleft()\n            nei = graph[cur].pop()\n            graph[nei].remove(cur)\n\n            if len(graph[nei]) == 1:\n                q.append(nei)\n\n    return list(q)\n\n\nn = 6\nedges = [[3, 0], [3, 1], [3, 2], [3, 4], [5, 4]]\nprint(findMinHeightTrees(n, edges))  # [3, 4]\n</code></pre>"},{"location":"EndlessCheng/topological_sorting/#2392-build-a-matrix-with-conditions","title":"2392. Build a Matrix With Conditions","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Graph, Topological Sort, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/topological_sorting/#802-find-eventual-safe-states","title":"802. Find Eventual Safe States","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Graph, Topological Sort</p> </li> </ul> Python <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# Topological Sort\ndef eventualSafeNodesTS(graph: List[List[int]]) -&gt; List[int]:\n    n = len(graph)\n    reverse_graph = defaultdict(list)\n    indegree = [0 for _ in range(n)]\n    safe = [False for _ in range(n)]\n\n    for u in range(n):\n        for v in graph[u]:\n            reverse_graph[v].append(u)\n        indegree[u] = len(graph[u])\n\n    q = deque([i for i in range(n) if indegree[i] == 0])\n\n    while q:\n        node = q.popleft()\n        safe[node] = True\n\n        for neighbor in reverse_graph[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n\n    return [i for i in range(n) if safe[i]]\n\n\n# DFS\ndef eventualSafeNodesDFS(graph: List[List[int]]) -&gt; List[int]:\n    n = len(graph)\n    state = [0 for _ in range(n)]  # 0: unvisited, 1: visiting, 2: visited\n\n    def dfs(node):\n        if state[node] &gt; 0:\n            return state[node] == 2\n        state[node] = 1\n        for neighbor in graph[node]:\n            if state[neighbor] == 1 or not dfs(neighbor):\n                return False\n        state[node] = 2\n        return True\n\n    return [i for i in range(n) if dfs(i)]\n\n\ngraph = [[1, 2], [2, 3], [5], [0], [5], [], []]\nprint(eventualSafeNodesTS(graph))  # [2, 4, 5, 6]\nprint(eventualSafeNodesDFS(graph))  # [2, 4, 5, 6]\n</code></pre>"},{"location":"EndlessCheng/topological_sorting/#1591-strange-printer-ii","title":"1591. Strange Printer II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Graph, Topological Sort, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/topological_sorting/#1203-sort-items-by-groups-respecting-dependencies","title":"1203. Sort Items by Groups Respecting Dependencies","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Graph, Topological Sort</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return any permutation of the items that satisfies the requirements.\n\"\"\"\n\nfrom collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS - Kahn's algorithm (Topological Sort)\ndef sortItems(\n    n: int, m: int, group: List[int], beforeItems: List[List[int]]\n) -&gt; List[int]:\n    def topological_sort(graph, indegree, nodes):\n        q = deque([node for node in nodes if indegree[node] == 0])\n        result = []\n\n        while q:\n            node = q.popleft()\n            result.append(node)\n\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    q.append(neighbor)\n\n        return result if len(result) == len(nodes) else []\n\n    groupItems = defaultdict(list)\n    groupGraph = defaultdict(set)\n    groupIndegree = defaultdict(int)\n    itemGraph = defaultdict(set)\n    itemIndegree = defaultdict(int)\n\n    for i in range(n):\n        if group[i] == -1:\n            group[i] = m\n            m += 1\n        groupItems[group[i]].append(i)\n\n    for i, beforeItem in enumerate(beforeItems):\n        for before in beforeItem:\n            if group[before] != group[i]:\n                if group[i] not in groupGraph[group[before]]:\n                    groupGraph[group[before]].add(group[i])\n                    groupIndegree[group[i]] += 1\n            else:\n                itemGraph[before].add(i)\n                itemIndegree[i] += 1\n\n    allGroups = list(set(group))\n    groupOrder = topological_sort(groupGraph, groupIndegree, allGroups)\n    if not groupOrder:\n        return []\n\n    result = []\n    for g in groupOrder:\n        items = groupItems[g]\n        itemOrder = topological_sort(itemGraph, itemIndegree, items)\n        if not itemOrder:\n            return []\n        result.extend(itemOrder)\n\n    return result\n\n\nn = 8\nm = 2\ngroup = [-1, -1, 1, 0, 0, 1, 0, -1]\nbeforeItems = [[], [6], [5], [6], [3, 6], [], [], []]\nprint(sortItems(n, m, group, beforeItems))\n</code></pre>"},{"location":"EndlessCheng/topological_sorting/#2603-collect-coins-in-a-tree","title":"2603. Collect Coins in a Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Tree, Graph, Topological Sort</p> </li> </ul>"},{"location":"EndlessCheng/topological_sorting/#269-alien-dictionary","title":"269. Alien Dictionary \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Depth First Search, Breadth First Search, Graph, Topological Sort</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the correct order of characters in the alien language.\n\"\"\"\n\nfrom collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS - Kahn's algorithm (Topological Sort)\ndef alienOrderBFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    indegree = {c: 0 for word in words for c in word}\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                    indegree[w2[j]] += 1\n                break\n\n    q = deque([c for c in indegree if indegree[c] == 0])\n    result = []\n\n    while q:\n        char = q.popleft()\n        result.append(char)\n\n        for neighbor in graph[char]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n\n    return \"\".join(result) if len(result) == len(indegree) else \"\"\n\n\n# DFS - Topological Sort\ndef alienOrderDFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    visited = {}\n    result = []\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                break\n\n    def dfs(c):\n        if c in visited:\n            return visited[c]\n\n        visited[c] = False\n        for neighbor in graph[c]:\n            if not dfs(neighbor):\n                return False\n\n        visited[c] = True\n        result.append(c)\n        return True\n\n    for c in list(graph.keys()):\n        if not dfs(c):\n            return \"\"\n\n    return \"\".join(result[::-1])\n\n\nwords = [\"wrt\", \"wrf\", \"er\", \"ett\", \"rftt\"]\nprint(alienOrderBFS(words))  # wertf\nprint(alienOrderDFS(words))  # wertf\n</code></pre>"},{"location":"EndlessCheng/topological_sorting/#444-sequence-reconstruction","title":"444. Sequence Reconstruction \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Graph, Topological Sort</p> </li> </ul>"},{"location":"EndlessCheng/topological_sorting/#1059-all-paths-from-source-lead-to-destination","title":"1059. All Paths from Source Lead to Destination \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Graph, Topological Sort</p> </li> </ul>"},{"location":"EndlessCheng/topological_sorting/#1136-parallel-courses","title":"1136. Parallel Courses \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Graph, Topological Sort</p> </li> </ul> Python <pre><code>\"\"\"\n- Return the minimum number of semesters needed to take all courses.\n\n![1136](../../assets/1136.png)\n\"\"\"\n\nfrom collections import deque\nfrom typing import List\n\n\n# Topological Sort\ndef minimumSemesters(n: int, relations: List[List[int]]) -&gt; int:\n    graph = {i: [] for i in range(1, n + 1)}\n    indegree = {i: 0 for i in range(1, n + 1)}\n\n    for pre, nxt in relations:\n        graph[pre].append(nxt)\n        indegree[nxt] += 1\n\n    q = deque([i for i in range(1, n + 1) if indegree[i] == 0])\n    semester = 0\n    done = 0\n\n    while q:\n        semester += 1\n        size = len(q)\n\n        for _ in range(size):\n            pre = q.popleft()\n            done += 1\n\n            for nxt in graph[pre]:\n                indegree[nxt] -= 1\n                if indegree[nxt] == 0:\n                    q.append(nxt)\n\n    return semester if done == n else -1\n\n\nn = 3\nrelations = [[1, 3], [2, 3]]\nprint(minimumSemesters(n, relations))  # 2\n</code></pre>"},{"location":"EndlessCheng/tree_dp/","title":"Tree DP","text":""},{"location":"EndlessCheng/tree_dp/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 337. House Robber III (Medium)</li> <li> 968. Binary Tree Cameras (Hard)</li> <li> 2313. Minimum Flips in Binary Tree to Get Result (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/tree_dp/#337-house-robber-iii","title":"337. House Robber III","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/tree_dp/#968-binary-tree-cameras","title":"968. Binary Tree Cameras","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Tree, Depth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef minCameraCover(root: Optional[TreeNode]) -&gt; int:\n    res = 0\n\n    def dfs(node, hasParent):\n        if not node:\n            return -1\n\n        nonlocal res\n        left, right = dfs(node.left, True), dfs(node.right, True)\n\n        if left == -1 and right == -1:\n            if hasParent:\n                return 0\n            res += 1\n            return 2\n        if left == 0 or right == 0:\n            res += 1\n            return 2\n        if left == 2 or right == 2:\n            return 1\n        if hasParent:\n            return 0\n        res += 1\n        return 2\n\n    dfs(root, False)\n\n    return res\n\n\nroot = build([0, 0, None, 0, 0])\nprint(root)\nprint(minCameraCover(root))  # 1\n</code></pre>"},{"location":"EndlessCheng/tree_dp/#2313-minimum-flips-in-binary-tree-to-get-result","title":"2313. Minimum Flips in Binary Tree to Get Result \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/tree_dp_maximum_independent_set/","title":"Tree DP Maximum Independent Set","text":""},{"location":"EndlessCheng/tree_dp_maximum_independent_set/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 337. House Robber III (Medium)</li> <li> 2646. Minimize the Total Price of the Trips (Hard)</li> <li> 2378. Choose Edges to Maximize Score in a Tree (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/tree_dp_maximum_independent_set/#337-house-robber-iii","title":"337. House Robber III","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/tree_dp_maximum_independent_set/#2646-minimize-the-total-price-of-the-trips","title":"2646. Minimize the Total Price of the Trips","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Tree, Depth First Search, Graph</p> </li> </ul>"},{"location":"EndlessCheng/tree_dp_maximum_independent_set/#2378-choose-edges-to-maximize-score-in-a-tree","title":"2378. Choose Edges to Maximize Score in a Tree \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Tree, Depth First Search</p> </li> </ul>"},{"location":"EndlessCheng/tree_dp_minimum_dominating_set/","title":"Tree DP Minimum Dominating Set","text":""},{"location":"EndlessCheng/tree_dp_minimum_dominating_set/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 968. Binary Tree Cameras (Hard)</li> </ul>"},{"location":"EndlessCheng/tree_dp_minimum_dominating_set/#968-binary-tree-cameras","title":"968. Binary Tree Cameras","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Tree, Depth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef minCameraCover(root: Optional[TreeNode]) -&gt; int:\n    res = 0\n\n    def dfs(node, hasParent):\n        if not node:\n            return -1\n\n        nonlocal res\n        left, right = dfs(node.left, True), dfs(node.right, True)\n\n        if left == -1 and right == -1:\n            if hasParent:\n                return 0\n            res += 1\n            return 2\n        if left == 0 or right == 0:\n            res += 1\n            return 2\n        if left == 2 or right == 2:\n            return 1\n        if hasParent:\n            return 0\n        res += 1\n        return 2\n\n    dfs(root, False)\n\n    return res\n\n\nroot = build([0, 0, None, 0, 0])\nprint(root)\nprint(minCameraCover(root))  # 1\n</code></pre>"},{"location":"EndlessCheng/tree_dp_other/","title":"Tree DP Other","text":""},{"location":"EndlessCheng/tree_dp_other/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2925. Maximum Score After Applying Operations on a Tree (Medium)</li> <li> 3068. Find the Maximum Sum of Node Values (Hard)</li> <li> 2920. Maximum Points After Collecting Coins From All Nodes (Hard)</li> <li> 1916. Count Ways to Build Rooms in an Ant Colony (Hard)</li> <li> 3367. Maximize Sum of Weights after Edge Removals (Hard)</li> <li> 2313. Minimum Flips in Binary Tree to Get Result (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/tree_dp_other/#2925-maximum-score-after-applying-operations-on-a-tree","title":"2925. Maximum Score After Applying Operations on a Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Tree, Depth First Search</p> </li> </ul>"},{"location":"EndlessCheng/tree_dp_other/#3068-find-the-maximum-sum-of-node-values","title":"3068. Find the Maximum Sum of Node Values","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy, Bit Manipulation, Tree, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/tree_dp_other/#2920-maximum-points-after-collecting-coins-from-all-nodes","title":"2920. Maximum Points After Collecting Coins From All Nodes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Bit Manipulation, Tree, Depth First Search, Memoization</p> </li> </ul>"},{"location":"EndlessCheng/tree_dp_other/#1916-count-ways-to-build-rooms-in-an-ant-colony","title":"1916. Count Ways to Build Rooms in an Ant Colony","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Tree, Graph, Topological Sort, Combinatorics</p> </li> </ul>"},{"location":"EndlessCheng/tree_dp_other/#3367-maximize-sum-of-weights-after-edge-removals","title":"3367. Maximize Sum of Weights after Edge Removals","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Tree, Depth First Search</p> </li> </ul>"},{"location":"EndlessCheng/tree_dp_other/#2313-minimum-flips-in-binary-tree-to-get-result","title":"2313. Minimum Flips in Binary Tree to Get Result \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/tree_dp_rerooting_dp/","title":"Tree DP Rerooting DP","text":""},{"location":"EndlessCheng/tree_dp_rerooting_dp/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 834. Sum of Distances in Tree (Hard)</li> <li> 2581. Count Number of Possible Root Nodes (Hard)</li> <li> 2858. Minimum Edge Reversals So Every Node Is Reachable (Hard)</li> <li> 310. Minimum Height Trees (Medium)</li> <li> 3241. Time Taken to Mark All Nodes (Hard)</li> </ul>"},{"location":"EndlessCheng/tree_dp_rerooting_dp/#834-sum-of-distances-in-tree","title":"834. Sum of Distances in Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Tree, Depth First Search, Graph</p> </li> </ul>"},{"location":"EndlessCheng/tree_dp_rerooting_dp/#2581-count-number-of-possible-root-nodes","title":"2581. Count Number of Possible Root Nodes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Dynamic Programming, Tree, Depth First Search</p> </li> </ul>"},{"location":"EndlessCheng/tree_dp_rerooting_dp/#2858-minimum-edge-reversals-so-every-node-is-reachable","title":"2858. Minimum Edge Reversals So Every Node Is Reachable","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Depth First Search, Breadth First Search, Graph</p> </li> </ul>"},{"location":"EndlessCheng/tree_dp_rerooting_dp/#310-minimum-height-trees","title":"310. Minimum Height Trees","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Graph, Topological Sort</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\ndef findMinHeightTrees(n: int, edges: List[List[int]]) -&gt; List[int]:\n    if n == 1:\n        return [0]\n\n    graph = {i: set() for i in range(n)}\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    q = deque([i for i in range(n) if len(graph[i]) == 1])\n    remaining = n\n\n    while remaining &gt; 2:\n        size = len(q)\n        remaining -= size\n\n        for _ in range(size):\n            cur = q.popleft()\n            nei = graph[cur].pop()\n            graph[nei].remove(cur)\n\n            if len(graph[nei]) == 1:\n                q.append(nei)\n\n    return list(q)\n\n\nn = 6\nedges = [[3, 0], [3, 1], [3, 2], [3, 4], [5, 4]]\nprint(findMinHeightTrees(n, edges))  # [3, 4]\n</code></pre>"},{"location":"EndlessCheng/tree_dp_rerooting_dp/#3241-time-taken-to-mark-all-nodes","title":"3241. Time Taken to Mark All Nodes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Tree, Depth First Search, Graph</p> </li> </ul>"},{"location":"EndlessCheng/tree_dp_tree_diameter/","title":"Tree DP Tree Diameter","text":""},{"location":"EndlessCheng/tree_dp_tree_diameter/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 543. Diameter of Binary Tree (Easy)</li> <li> 687. Longest Univalue Path (Medium)</li> <li> 124. Binary Tree Maximum Path Sum (Hard)</li> <li> 2385. Amount of Time for Binary Tree to Be Infected (Medium)</li> <li> 2246. Longest Path With Different Adjacent Characters (Hard)</li> <li> 3203. Find Minimum Diameter After Merging Two Trees (Hard)</li> <li> 1617. Count Subtrees With Max Distance Between Cities (Hard)</li> <li> 2538. Difference Between Maximum and Minimum Price Sum (Hard)</li> <li> 1522. Diameter of N-Ary Tree (Medium) \ud83d\udc51</li> <li> 1245. Tree Diameter (Medium) \ud83d\udc51</li> <li> 549. Binary Tree Longest Consecutive Sequence II (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/tree_dp_tree_diameter/#543-diameter-of-binary-tree","title":"543. Diameter of Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul> PythonCPP <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Tree DFS\nclass Solution:\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -&gt; int:\n        self.diameter = 0\n\n        def dfs(node):\n            if not node:\n                return 0\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n            self.diameter = max(self.diameter, left + right)\n\n            return 1 + max(left, right)\n\n        dfs(root)\n\n        return self.diameter\n\n\nroot = build([1, 2, 3, 4, 5])\nprint(root)\n#     __1\n#    /   \\\n#   2     3\n#  / \\\n# 4   5\nobj = Solution()\nprint(obj.diameterOfBinaryTree(root))  # 3\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nint diameterOfBinaryTree(TreeNode* root) {\n    int diameter = 0;\n\n    auto dfs = [&amp;](auto&amp;&amp; self, TreeNode* node) -&gt; int {\n        if (!node) return 0;\n        int left = self(self, node-&gt;left);\n        int right = self(self, node-&gt;right);\n\n        diameter = max(diameter, left + right);\n\n        return 1 + max(left, right);\n    };\n\n    dfs(dfs, root);\n    return diameter;\n}\n\nint main() {\n    // [1, 2, 3, 4, 5]\n    TreeNode* root = new TreeNode(1);\n    root-&gt;left = new TreeNode(2);\n    root-&gt;right = new TreeNode(3);\n    root-&gt;left-&gt;left = new TreeNode(4);\n    root-&gt;left-&gt;right = new TreeNode(5);\n    cout &lt;&lt; diameterOfBinaryTree(root) &lt;&lt; endl;  // 3\n\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/tree_dp_tree_diameter/#687-longest-univalue-path","title":"687. Longest Univalue Path","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/tree_dp_tree_diameter/#124-binary-tree-maximum-path-sum","title":"124. Binary Tree Maximum Path Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Tree, Depth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef maxPathSum(root: Optional[TreeNode]) -&gt; int:\n    res = float(\"-inf\")\n\n    def dfs(node):\n        if not node:\n            return 0\n\n        leftMax = max(dfs(node.left), 0)\n        rightMax = max(dfs(node.right), 0)\n\n        cur = node.val + leftMax + rightMax\n        nonlocal res\n        res = max(res, cur)\n\n        return node.val + max(leftMax, rightMax)\n\n    dfs(root)\n\n    return res\n\n\nroot = build([-10, 9, 20, None, None, 15, 7])\nprint(root)\n#   -10___\n#  /      \\\n# 9       _20\n#        /   \\\n#       15    7\nprint(maxPathSum(root))  # 42\n</code></pre>"},{"location":"EndlessCheng/tree_dp_tree_diameter/#2385-amount-of-time-for-binary-tree-to-be-infected","title":"2385. Amount of Time for Binary Tree to Be Infected","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/tree_dp_tree_diameter/#2246-longest-path-with-different-adjacent-characters","title":"2246. Longest Path With Different Adjacent Characters","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Tree, Depth First Search, Graph, Topological Sort</p> </li> </ul>"},{"location":"EndlessCheng/tree_dp_tree_diameter/#3203-find-minimum-diameter-after-merging-two-trees","title":"3203. Find Minimum Diameter After Merging Two Trees","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Graph</p> </li> </ul>"},{"location":"EndlessCheng/tree_dp_tree_diameter/#1617-count-subtrees-with-max-distance-between-cities","title":"1617. Count Subtrees With Max Distance Between Cities","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Bit Manipulation, Tree, Enumeration, Bitmask</p> </li> </ul>"},{"location":"EndlessCheng/tree_dp_tree_diameter/#2538-difference-between-maximum-and-minimum-price-sum","title":"2538. Difference Between Maximum and Minimum Price Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Tree, Depth First Search</p> </li> </ul>"},{"location":"EndlessCheng/tree_dp_tree_diameter/#1522-diameter-of-n-ary-tree","title":"1522. Diameter of N-Ary Tree \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search</p> </li> </ul> Python <pre><code>from typing import List, Optional\n\n\nclass Node:\n    def __init__(\n        self,\n        val: Optional[int] = None,\n        children: Optional[List[\"Node\"]] = None,\n    ):\n        self.val = val\n        self.children = children if children is not None else []\n\n\ndef diameter(root: \"Node\") -&gt; int:\n\n    def dfs(node):\n        if not node.children:\n            return 1, 1\n        mx0, mx1 = 0, 0\n        mxf = 0\n        for child in node.children:\n            hl, fl = dfs(child)\n            mxf = max(mxf, fl)\n            if hl &gt; mx1:\n                if hl &lt; mx0:\n                    mx1 = hl\n                else:\n                    mx0, mx1 = hl, mx0\n        return mx0 + 1, max(mxf, mx0 + mx1 + 1)\n\n    return dfs(root)[1] - 1\n\n\nroot = [1, None, 2, None, 3, 4, None, 5, None, 6]\nroot = Node(1)\nroot.children = [Node(2)]\nroot.children[0].children = [Node(3), Node(4)]\nroot.children[0].children[0].children = [Node(5)]\nroot.children[0].children[1].children = [Node(6)]\nprint(diameter(root))  # 4\n</code></pre>"},{"location":"EndlessCheng/tree_dp_tree_diameter/#1245-tree-diameter","title":"1245. Tree Diameter \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Graph, Topological Sort</p> </li> </ul> Python <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# Tree Diameter\ndef treeDiameter(edges: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = {0}\n    q = deque([0])\n    cur = 0\n\n    while q:\n        size = len(q)\n        for _ in range(size):\n            cur = q.popleft()\n            for nxt in graph[cur]:\n                if nxt not in visited:\n                    q.append(nxt)\n                    visited.add(nxt)\n\n    visited = {cur}\n    q = deque([cur])\n    res = -1\n\n    while q:\n        size = len(q)\n        for _ in range(size):\n            cur = q.popleft()\n            for nxt in graph[cur]:\n                if nxt not in visited:\n                    q.append(nxt)\n                    visited.add(nxt)\n        res += 1\n\n    return res\n\n\nedges = [[0, 1], [1, 2], [2, 3], [1, 4], [4, 5]]\nassert treeDiameter(edges) == 4\n</code></pre>"},{"location":"EndlessCheng/tree_dp_tree_diameter/#549-binary-tree-longest-consecutive-sequence-ii","title":"549. Binary Tree Longest Consecutive Sequence II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/trie_advanced/","title":"Trie Advanced","text":""},{"location":"EndlessCheng/trie_advanced/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 676. Implement Magic Dictionary (Medium)</li> <li> 212. Word Search II (Hard)</li> <li> 3093. Longest Common Suffix Queries (Hard)</li> <li> 745. Prefix and Suffix Search (Hard)</li> <li> 3045. Count Prefix and Suffix Pairs II (Hard)</li> <li> 336. Palindrome Pairs (Hard)</li> <li> 1948. Delete Duplicate Folders in System (Hard)</li> <li> 425. Word Squares (Hard) \ud83d\udc51</li> <li> 527. Word Abbreviation (Hard) \ud83d\udc51</li> <li> 588. Design In-Memory File System (Hard) \ud83d\udc51</li> <li> 616. Add Bold Tag in String (Medium) \ud83d\udc51</li> <li> 758. Bold Words in String (Medium) \ud83d\udc51</li> <li> 642. Design Search Autocomplete System (Hard) \ud83d\udc51</li> <li> 1065. Index Pairs of a String (Easy) \ud83d\udc51</li> <li> 1166. Design File System (Medium) \ud83d\udc51</li> <li> 1858. Longest Word With All Prefixes (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/trie_advanced/#676-implement-magic-dictionary","title":"676. Implement Magic Dictionary","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Depth First Search, Design, Trie</p> </li> </ul>"},{"location":"EndlessCheng/trie_advanced/#212-word-search-ii","title":"212. Word Search II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Backtracking, Trie, Matrix</p> </li> </ul> Python <pre><code>from typing import List\n\nfrom leetpattern.utils import Trie\n\n\n# Backtracking + Trie\ndef findWords(board: List[List[str]], words: List[str]) -&gt; List[str]:\n    trie = Trie()\n    for word in words:\n        trie.add_word(word)\n\n    m, n = len(board), len(board[0])\n    result, visit = set(), set()\n\n    def dfs(r, c, node, word):\n        if (\n            r &lt; 0\n            or r &gt;= m\n            or c &lt; 0\n            or c &gt;= n\n            or (r, c) in visit\n            or board[r][c] not in node.children\n        ):\n            return None\n\n        visit.add((r, c))\n\n        node = node.children[board[r][c]]\n        word += board[r][c]\n        if node.is_word:\n            result.add(word)\n\n        dfs(r - 1, c, node, word)\n        dfs(r + 1, c, node, word)\n        dfs(r, c - 1, node, word)\n        dfs(r, c + 1, node, word)\n\n        visit.remove((r, c))\n\n    for r in range(m):\n        for c in range(n):\n            dfs(r, c, trie.root, \"\")\n\n    return list(result)\n\n\ndef test_find_words():\n    board = [\n        [\"o\", \"a\", \"a\", \"n\"],\n        [\"e\", \"t\", \"a\", \"e\"],\n        [\"i\", \"h\", \"k\", \"r\"],\n        [\"i\", \"f\", \"l\", \"v\"],\n    ]\n    words = [\"oath\", \"pea\", \"eat\", \"rain\"]\n    result = findWords(board, words)\n    assert sorted(result) == [\"eat\", \"oath\"]\n</code></pre>"},{"location":"EndlessCheng/trie_advanced/#3093-longest-common-suffix-queries","title":"3093. Longest Common Suffix Queries","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Trie</p> </li> </ul>"},{"location":"EndlessCheng/trie_advanced/#745-prefix-and-suffix-search","title":"745. Prefix and Suffix Search","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Design, Trie</p> </li> </ul>"},{"location":"EndlessCheng/trie_advanced/#3045-count-prefix-and-suffix-pairs-ii","title":"3045. Count Prefix and Suffix Pairs II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Trie, Rolling Hash, String Matching, Hash Function</p> </li> </ul>"},{"location":"EndlessCheng/trie_advanced/#336-palindrome-pairs","title":"336. Palindrome Pairs","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Trie</p> </li> </ul>"},{"location":"EndlessCheng/trie_advanced/#1948-delete-duplicate-folders-in-system","title":"1948. Delete Duplicate Folders in System","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Trie, Hash Function</p> </li> </ul>"},{"location":"EndlessCheng/trie_advanced/#425-word-squares","title":"425. Word Squares \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Backtracking, Trie</p> </li> </ul>"},{"location":"EndlessCheng/trie_advanced/#527-word-abbreviation","title":"527. Word Abbreviation \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Greedy, Trie, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/trie_advanced/#588-design-in-memory-file-system","title":"588. Design In-Memory File System \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Design, Trie, Sorting</p> </li> </ul> Python <pre><code>from collections import defaultdict\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children = defaultdict(TrieNode)\n        self.content = \"\"\n\n\n# Trie\nclass FileSystem:\n\n    def __init__(self):\n        self.root = TrieNode()\n\n    def ls(self, path: str) -&gt; list:\n        cur = self.root\n\n        if path != \"/\":\n            paths = path.split(\"/\")[1:]\n            for p in paths:\n                cur = cur.children[p]\n        if cur.content:\n            return [path.split(\"/\")[-1]]\n\n        return sorted(cur.children.keys())\n\n    def mkdir(self, path: str) -&gt; None:\n        cur = self.root\n        paths = path.split(\"/\")[1:]\n        for p in paths:\n            cur = cur.children[p]\n\n    def addContentToFile(self, filePath: str, content: str) -&gt; None:\n        cur = self.root\n        paths = filePath.split(\"/\")[1:]\n        for p in paths:\n            cur = cur.children[p]\n        cur.content += content\n\n    def readContentFromFile(self, filePath: str) -&gt; str:\n        cur = self.root\n        paths = filePath.split(\"/\")[1:]\n        for p in paths:\n            cur = cur.children[p]\n        return cur.content\n\n\nobj = FileSystem()\nobj.mkdir(\"/a/b/c\")\nobj.addContentToFile(\"/a/b/c/d\", \"hello\")\nprint(obj.ls(\"/\"))  # [\"a\"]\nprint(obj.readContentFromFile(\"/a/b/c/d\"))  # \"hello\"\n</code></pre>"},{"location":"EndlessCheng/trie_advanced/#616-add-bold-tag-in-string","title":"616. Add Bold Tag in String \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Trie, String Matching</p> </li> </ul>"},{"location":"EndlessCheng/trie_advanced/#758-bold-words-in-string","title":"758. Bold Words in String \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Trie, String Matching</p> </li> </ul>"},{"location":"EndlessCheng/trie_advanced/#642-design-search-autocomplete-system","title":"642. Design Search Autocomplete System \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Depth First Search, Design, Trie, Sorting, Heap Priority Queue, Data Stream</p> </li> </ul>"},{"location":"EndlessCheng/trie_advanced/#1065-index-pairs-of-a-string","title":"1065. Index Pairs of a String \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Trie, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/trie_advanced/#1166-design-file-system","title":"1166. Design File System \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Design, Trie</p> </li> </ul> Python <pre><code>from collections import defaultdict\n\n\nclass TrieNode:\n    def __init__(self, name):\n        self.name = name\n        self.children = defaultdict(TrieNode)\n        self.value = -1\n\n\n# Trie\nclass FileSystem:\n    def __init__(self):\n        self.root = TrieNode(\"\")\n\n    def createPath(self, path: str, value: int) -&gt; bool:\n        paths = path.split(\"/\")[1:]\n        cur = self.root\n\n        for idx, path in enumerate(paths):\n            if path not in cur.children:\n                if idx == len(paths) - 1:\n                    cur.children[path] = TrieNode(path)\n                else:\n                    return False\n            cur = cur.children[path]\n\n        if cur.value != -1:\n            return False\n        cur.value = value\n        return True\n\n    def get(self, path: str) -&gt; int:\n        cur = self.root\n        paths = path.split(\"/\")[1:]\n\n        for path in paths:\n            if path not in cur.children:\n                return -1\n            cur = cur.children[path]\n\n        return cur.value\n\n\n# Your FileSystem object will be instantiated and called as such:\npath = \"/a\"\nvalue = 1\nobj = FileSystem()\nprint(obj.createPath(path, value))  # False\nprint(obj.get(path))  # 1\n</code></pre>"},{"location":"EndlessCheng/trie_advanced/#1858-longest-word-with-all-prefixes","title":"1858. Longest Word With All Prefixes \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Trie</p> </li> </ul>"},{"location":"EndlessCheng/trie_basics/","title":"Trie Basics","text":""},{"location":"EndlessCheng/trie_basics/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 208. Implement Trie (Prefix Tree) (Medium)</li> <li> 211. Design Add and Search Words Data Structure (Medium)</li> <li> 14. Longest Common Prefix (Easy)</li> <li> 648. Replace Words (Medium)</li> <li> 677. Map Sum Pairs (Medium)</li> <li> 720. Longest Word in Dictionary (Medium)</li> <li> 1268. Search Suggestions System (Medium)</li> <li> 1233. Remove Sub-Folders from the Filesystem (Medium)</li> <li> 820. Short Encoding of Words (Medium)</li> <li> 2416. Sum of Prefix Scores of Strings (Hard)</li> <li> 2261. K Divisible Elements Subarrays (Medium)</li> <li> 1804. Implement Trie II (Prefix Tree) (Medium) \ud83d\udc51</li> <li> 2168. Unique Substrings With Equal Digit Frequency (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/trie_basics/#208-implement-trie-prefix-tree","title":"208. Implement Trie (Prefix Tree)","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Design, Trie</p> </li> </ul> Python <pre><code>\"\"\"\n### Trie\n\n- A trie is a tree-like data structure whose nodes store the letters of an alphabet.\n\"\"\"\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.endOfWord = None\n\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.endOfWord = True\n\n    def search(self, word: str) -&gt; bool:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return node.endOfWord\n\n    def startsWith(self, prefix: str) -&gt; bool:\n        node = self.root\n\n        for c in prefix:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return True\n\n\n# Your Trie object will be instantiated and called as such:\nobj = Trie()\nobj.insert(\"apple\")\nprint(obj.search(\"word\"))  # False\nprint(obj.startsWith(\"app\"))  # True\n</code></pre>"},{"location":"EndlessCheng/trie_basics/#211-design-add-and-search-words-data-structure","title":"211. Design Add and Search Words Data Structure","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Depth First Search, Design, Trie</p> </li> </ul> Python <pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.word = False\n\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.word = True\n\n    def search(self, word: str) -&gt; bool:\n\n        def dfs(j, root):\n            node = root\n\n            for i in range(j, len(word)):\n                c = word[i]\n\n                if c == \".\":\n                    for child in node.children.values():\n                        if dfs(i + 1, child):\n                            return True\n                    return False\n                else:\n                    if c not in node.children:\n                        return False\n                    node = node.children[c]\n            return node.word\n\n        return dfs(0, self.root)\n\n\n# Your WordDictionary object will be instantiated and called as such:\nobj = WordDictionary()\nobj.addWord(\"word\")\nprint(obj.search(\"word\"))\nprint(obj.search(\"w.rd\"))\n</code></pre>"},{"location":"EndlessCheng/trie_basics/#14-longest-common-prefix","title":"14. Longest Common Prefix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Trie</p> </li> </ul> Python <pre><code>from typing import List\n\n\nclass longestCommonPrefix:\n    def horizontal_scan(self, strs: List[str]) -&gt; str:\n        if not strs:\n            return \"\"\n\n        prefix = strs[0]\n        for i in range(1, len(strs)):\n            while not strs[i].startswith(prefix):\n                prefix = prefix[:-1]\n                if not prefix:\n                    return \"\"\n\n        return prefix\n\n    def vertical_scan(self, strs: List[str]) -&gt; str:\n        if not strs:\n            return \"\"\n\n        for i in range(len(strs[0])):\n            char = strs[0][i]\n            for j in range(1, len(strs)):\n                if i &gt;= len(strs[j]) or strs[j][i] != char:\n                    return strs[0][:i]\n\n        return strs[0]\n\n    def divide_conquer(self, strs: List[str]) -&gt; str:\n        if not strs:\n            return \"\"\n\n        def merge(left, right):\n            n = min(len(left), len(right))\n            for i in range(n):\n                if left[i] != right[i]:\n                    return left[:i]\n            return left[:n]\n\n        def find(strs, start, end):\n            if start == end:\n                return strs[start]\n            mid = start + (end - start) // 2\n            left = find(strs, start, mid)\n            right = find(strs, mid + 1, end)\n            return merge(left, right)\n\n        return find(strs, 0, len(strs) - 1)\n\n    def binary_search(self, strs: List[str]) -&gt; str:\n        if not strs:\n            return \"\"\n\n        def isCommonPrefix(strs, length):\n            prefix = strs[0][:length]\n            return all(s.startswith(prefix) for s in strs)\n\n        minLen = min(len(s) for s in strs)\n        low, high = 0, minLen\n        while low &lt; high:\n            mid = low + (high - low) // 2\n            if isCommonPrefix(strs, mid + 1):\n                low = mid + 1\n            else:\n                high = mid\n\n        return strs[0][:low]\n\n\nif __name__ == \"__main__\":\n    solution = longestCommonPrefix()\n    strs = [\"flower\", \"flow\", \"flight\"]\n    assert solution.horizontal_scan(strs) == \"fl\"\n    assert solution.vertical_scan(strs) == \"fl\"\n    assert solution.divide_conquer(strs) == \"fl\"\n    assert solution.binary_search(strs) == \"fl\"\n</code></pre>"},{"location":"EndlessCheng/trie_basics/#648-replace-words","title":"648. Replace Words","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Trie</p> </li> </ul>"},{"location":"EndlessCheng/trie_basics/#677-map-sum-pairs","title":"677. Map Sum Pairs","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Design, Trie</p> </li> </ul>"},{"location":"EndlessCheng/trie_basics/#720-longest-word-in-dictionary","title":"720. Longest Word in Dictionary","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Trie, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/trie_basics/#1268-search-suggestions-system","title":"1268. Search Suggestions System","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Binary Search, Trie, Sorting, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/trie_basics/#1233-remove-sub-folders-from-the-filesystem","title":"1233. Remove Sub-Folders from the Filesystem","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Depth First Search, Trie</p> </li> </ul>"},{"location":"EndlessCheng/trie_basics/#820-short-encoding-of-words","title":"820. Short Encoding of Words","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Trie</p> </li> </ul>"},{"location":"EndlessCheng/trie_basics/#2416-sum-of-prefix-scores-of-strings","title":"2416. Sum of Prefix Scores of Strings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Trie, Counting</p> </li> </ul>"},{"location":"EndlessCheng/trie_basics/#2261-k-divisible-elements-subarrays","title":"2261. K Divisible Elements Subarrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Trie, Rolling Hash, Hash Function, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/trie_basics/#1804-implement-trie-ii-prefix-tree","title":"1804. Implement Trie II (Prefix Tree) \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Design, Trie</p> </li> </ul>"},{"location":"EndlessCheng/trie_basics/#2168-unique-substrings-with-equal-digit-frequency","title":"2168. Unique Substrings With Equal Digit Frequency \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Rolling Hash, Counting, Hash Function</p> </li> </ul>"},{"location":"EndlessCheng/trie_optimized_dp/","title":"Trie Optimized DP","text":""},{"location":"EndlessCheng/trie_optimized_dp/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 139. Word Break (Medium)</li> <li> 140. Word Break II (Hard)</li> <li> 472. Concatenated Words (Hard)</li> <li> 2977. Minimum Cost to Convert String II (Hard)</li> </ul>"},{"location":"EndlessCheng/trie_optimized_dp/#139-word-break","title":"139. Word Break","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Dynamic Programming, Trie, Memoization</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\n# DP (Unbounded Knapsack)\ndef wordBreak(s: str, wordDict: List[str]) -&gt; bool:\n    n = len(s)\n    dp = [False for _ in range(n + 1)]\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for word in wordDict:\n            m = len(word)\n            if s[i - m : i] == word and dp[i - m]:\n                dp[i] = True\n    return dp[-1]\n\n\ns = \"leetcode\"\nwordDict = [\"leet\", \"code\"]\nprint(wordBreak(s, wordDict))  # True\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;cassert&gt;\n#include &lt;ranges&gt;\n#include &lt;string&gt;\n#include &lt;unordered_set&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) {\n        int max_len = ranges::max(wordDict, {}, &amp;string::length).length();\n        unordered_set&lt;string&gt; words(wordDict.begin(), wordDict.end());\n\n        int n = s.length();\n        vector&lt;int&gt; f(n + 1);\n        f[0] = true;\n        for (int i = 1; i &lt;= n; i++) {\n            for (int j = i - 1; j &gt;= max(i - max_len, 0); j--) {\n                if (f[j] &amp;&amp; words.count(s.substr(j, i - j))) {\n                    f[i] = true;\n                    break;\n                }\n            }\n        }\n        return f[n];\n    }\n};\n\nint main() {\n    Solution solution;\n    string s = \"leetcode\";\n    vector&lt;string&gt; wordDict = {\"leet\", \"code\"};\n    assert(solution.wordBreak(s, wordDict) == true);\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/trie_optimized_dp/#140-word-break-ii","title":"140. Word Break II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Dynamic Programming, Backtracking, Trie, Memoization</p> </li> </ul>"},{"location":"EndlessCheng/trie_optimized_dp/#472-concatenated-words","title":"472. Concatenated Words","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Dynamic Programming, Depth First Search, Trie</p> </li> </ul>"},{"location":"EndlessCheng/trie_optimized_dp/#2977-minimum-cost-to-convert-string-ii","title":"2977. Minimum Cost to Convert String II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Dynamic Programming, Graph, Trie, Shortest Path</p> </li> </ul>"},{"location":"EndlessCheng/union_find_advanced/","title":"Union Find Advanced","text":""},{"location":"EndlessCheng/union_find_advanced/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1202. Smallest String With Swaps (Medium)</li> <li> 1061. Lexicographically Smallest Equivalent String (Medium)</li> <li> 1722. Minimize Hamming Distance After Swap Operations (Medium)</li> <li> 765. Couples Holding Hands (Hard)</li> <li> 684. Redundant Connection (Medium)</li> <li> 685. Redundant Connection II (Hard)</li> <li> 947. Most Stones Removed with Same Row or Column (Medium)</li> <li> 839. Similar String Groups (Hard)</li> <li> 1970. Last Day Where You Can Still Cross (Hard)</li> <li> 2076. Process Restricted Friend Requests (Hard)</li> <li> 1579. Remove Max Number of Edges to Keep Graph Fully Traversable (Hard)</li> <li> 959. Regions Cut By Slashes (Medium)</li> <li> 2812. Find the Safest Path in a Grid (Medium)</li> <li> 2503. Maximum Number of Points From Grid Queries (Hard)</li> <li> 2867. Count Valid Paths in a Tree (Hard)</li> <li> 2421. Number of Good Paths (Hard)</li> <li> 2157. Groups of Strings (Hard)</li> <li> 1632. Rank Transform of a Matrix (Hard)</li> <li> 803. Bricks Falling When Hit (Hard)</li> <li> 1569. Number of Ways to Reorder Array to Get Same BST (Hard)</li> <li> 3235. Check if the Rectangle Corner Is Reachable (Hard)</li> <li> 2371. Minimize Maximum Value in a Grid (Hard) \ud83d\udc51</li> <li> 2459. Sort Array by Moving Items to Empty Space (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/union_find_advanced/#1202-smallest-string-with-swaps","title":"1202. Smallest String With Swaps","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Depth First Search, Breadth First Search, Union Find, Sorting</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef smallestStringWithSwaps(s: str, pairs: List[List[int]]) -&gt; str:\n    n = len(s)\n    par = list(range(n))\n    components = defaultdict(list)\n\n    def find(node):\n        p = par[node]\n        while par[p] != p:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 != p2:\n            par[p1] = p2\n\n    for index, j in pairs:\n        union(index, j)\n\n    for index in range(n):\n        components[find(index)].append(index)\n\n    res = list(s)\n    for indices in components.values():\n        chars = sorted([s[index] for index in indices])\n        for index, char in zip(indices, chars):\n            res[index] = char\n\n    return \"\".join(res)\n\n\ns = \"dcab\"\npairs = [[0, 3], [1, 2]]\nprint(smallestStringWithSwaps(s, pairs))  # \"bacd\"\n</code></pre>"},{"location":"EndlessCheng/union_find_advanced/#1061-lexicographically-smallest-equivalent-string","title":"1061. Lexicographically Smallest Equivalent String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Union Find</p> </li> </ul> Python <pre><code># Union Find\ndef smallestEquivalentString(s1: str, s2: str, baseStr: str) -&gt; str:\n    parent = {chr(i): chr(i) for i in range(ord(\"a\"), ord(\"z\") + 1)}\n\n    def find(n):\n        p = parent[n]\n        while parent[p] != p:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            if p1 &lt; p2:\n                parent[p2] = p1\n            else:\n                parent[p1] = p2\n\n    for i in range(len(s1)):\n        union(s1[i], s2[i])\n\n    result = []\n    for c in baseStr:\n        result.append(find(c))\n\n    return \"\".join(result)\n\n\nif __name__ == \"__main__\":\n    s1 = \"parker\"\n    s2 = \"morris\"\n    baseStr = \"parser\"\n    assert smallestEquivalentString(s1, s2, baseStr) == \"makkek\"\n</code></pre>"},{"location":"EndlessCheng/union_find_advanced/#1722-minimize-hamming-distance-after-swap-operations","title":"1722. Minimize Hamming Distance After Swap Operations","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Union Find</p> </li> </ul>"},{"location":"EndlessCheng/union_find_advanced/#765-couples-holding-hands","title":"765. Couples Holding Hands","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Greedy, Depth First Search, Breadth First Search, Union Find, Graph</p> </li> </ul>"},{"location":"EndlessCheng/union_find_advanced/#684-redundant-connection","title":"684. Redundant Connection","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Union Find, Graph</p> </li> </ul> Python <pre><code>from typing import List\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(1, n + 1)}\n        self.rank = {i: 1 for i in range(1, n + 1)}\n\n    def find(self, n):\n        p = self.par[n]\n        while self.par[p] != p:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return False\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.par[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.par[p1] = p2\n        else:\n            self.par[p2] = p1\n            self.rank[p1] += 1\n\n        return True\n\n\n# Union Find\ndef findRedundantConnectionUF(edges: List[List[int]]) -&gt; List[int]:\n    n = len(edges)\n    uf = UnionFind(n)\n\n    for u, v in edges:\n        if not uf.union(u, v):\n            return (u, v)\n\n\n# DFS\ndef findRedundantConnectionDFS(edges: List[List[int]]) -&gt; List[int]:\n    graph, cycle = {}, {}\n    for a, b in edges:\n        graph.setdefault(a, []).append(b)\n        graph.setdefault(b, []).append(a)\n\n    def dfs(node, parent):\n        if node in cycle:\n            for k in list(cycle.keys()):\n                if k == node:\n                    return True\n                del cycle[k]\n\n        cycle[node] = None\n        for child in graph[node]:\n            if child != parent and dfs(child, node):\n                return True\n        del cycle[node]\n        return False\n\n    dfs(edges[0][0], -1)\n    for a, b in edges[::-1]:\n        if a in cycle and b in cycle:\n            return (a, b)\n\n\nedges = [[1, 2], [1, 3], [2, 3]]\nprint(findRedundantConnectionUF(edges))  # (2, 3)\nprint(findRedundantConnectionDFS(edges))  # (2, 3)\n</code></pre>"},{"location":"EndlessCheng/union_find_advanced/#685-redundant-connection-ii","title":"685. Redundant Connection II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Union Find, Graph</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Union Find\ndef findRedundantDirectedConnectionUF(edges: List[List[int]]) -&gt; List[int]:\n    n = len(edges)\n    uf = UnionFind(n + 1)\n    parent = list(range(n + 1))\n    candidates = []\n\n    for u, v in edges:\n        if parent[v] != v:\n            candidates.append([parent[v], v])\n            candidates.append([u, v])\n        else:\n            parent[v] = u\n\n    if not candidates:\n        for u, v in edges:\n            if not uf.union(u, v):\n                return [u, v]\n\n    for u, v in edges:\n        if [u, v] == candidates[1]:\n            continue\n        if not uf.union(u, v):\n            return candidates[0]\n\n    return candidates[1]\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(1, n + 1)}\n\n    def find(self, n):\n        p = self.par[n]\n        while p != self.par[p]:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n        if p1 == p2:\n            return False\n        self.par[p1] = p2\n        return True\n\n\nedges = [[1, 2], [1, 3], [2, 3]]\nprint(findRedundantDirectedConnectionUF(edges))\n</code></pre>"},{"location":"EndlessCheng/union_find_advanced/#947-most-stones-removed-with-same-row-or-column","title":"947. Most Stones Removed with Same Row or Column","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Depth First Search, Union Find, Graph</p> </li> </ul>"},{"location":"EndlessCheng/union_find_advanced/#839-similar-string-groups","title":"839. Similar String Groups","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Depth First Search, Breadth First Search, Union Find</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef numSimilarGroups(strs: List[str]) -&gt; int:\n    n = len(strs)\n    parent = list(range(n))\n    rank = [0 for _ in range(n)]\n\n    def find(n):\n        p = parent[n]\n        while parent[p] != p:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    def is_similar(s1, s2):\n        diff = 0\n        for c1, c2 in zip(s1, s2):\n            if c1 != c2:\n                diff += 1\n            if diff &gt; 2:\n                return False\n        return True\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_similar(strs[i], strs[j]):\n                union(i, j)\n\n    return sum(find(i) == i for i in range(n))\n\n\nstrs = [\"tars\", \"rats\", \"arts\", \"star\"]\nprint(numSimilarGroups(strs))  # 2\n</code></pre>"},{"location":"EndlessCheng/union_find_advanced/#1970-last-day-where-you-can-still-cross","title":"1970. Last Day Where You Can Still Cross","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Depth First Search, Breadth First Search, Union Find, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/union_find_advanced/#2076-process-restricted-friend-requests","title":"2076. Process Restricted Friend Requests","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Union Find, Graph</p> </li> </ul>"},{"location":"EndlessCheng/union_find_advanced/#1579-remove-max-number-of-edges-to-keep-graph-fully-traversable","title":"1579. Remove Max Number of Edges to Keep Graph Fully Traversable","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Union Find, Graph</p> </li> </ul> Python <pre><code>\"\"\"\n- Return the maximum number of edges you can remove so that the graph remains fully traversable.\n\n![1579](../../assets/1579.png){width=200px}\n\"\"\"\n\nfrom typing import List\n\n\n# Kruskal\ndef maxNumEdgesToRemove(n: int, edges: List[List[int]]) -&gt; int:\n    alice, bob = UnionFind(n), UnionFind(n)\n    visited = 0\n\n    for t, u, v in edges:\n        if t == 3:\n            if alice.union(u, v) | bob.union(u, v):\n                visited += 1\n\n    for t, u, v in edges:\n        if t == 1:\n            if alice.union(u, v):\n                visited += 1\n        elif t == 2:\n            if bob.union(u, v):\n                visited += 1\n\n    if alice.components &gt; 1 or bob.components &gt; 1:\n        return -1\n\n    return len(edges) - visited\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = {i: i for i in range(1, n + 1)}\n        self.rank = {i: 0 for i in range(1, n + 1)}\n        self.components = n\n\n    def find(self, n):\n        p = self.parent[n]\n        while self.parent[p] != p:\n            self.parent[p] = self.parent[self.parent[p]]\n            p = self.parent[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return False\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.parent[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.parent[p1] = p2\n        else:\n            self.parent[p2] = p1\n            self.rank[p1] += 1\n\n        self.components -= 1\n\n        return True\n\n\nn = 4\nedges = [[3, 1, 2], [3, 2, 3], [1, 1, 3], [1, 2, 4], [1, 1, 2], [2, 3, 4]]\nprint(maxNumEdgesToRemove(n, edges))  # 2\n</code></pre>"},{"location":"EndlessCheng/union_find_advanced/#959-regions-cut-by-slashes","title":"959. Regions Cut By Slashes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Depth First Search, Breadth First Search, Union Find, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/union_find_advanced/#2812-find-the-safest-path-in-a-grid","title":"2812. Find the Safest Path in a Grid","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Breadth First Search, Union Find, Heap Priority Queue, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/union_find_advanced/#2503-maximum-number-of-points-from-grid-queries","title":"2503. Maximum Number of Points From Grid Queries","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Breadth First Search, Union Find, Sorting, Heap Priority Queue, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/union_find_advanced/#2867-count-valid-paths-in-a-tree","title":"2867. Count Valid Paths in a Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Tree, Depth First Search, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/union_find_advanced/#2421-number-of-good-paths","title":"2421. Number of Good Paths","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Tree, Union Find, Graph, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/union_find_advanced/#2157-groups-of-strings","title":"2157. Groups of Strings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Bit Manipulation, Union Find</p> </li> </ul>"},{"location":"EndlessCheng/union_find_advanced/#1632-rank-transform-of-a-matrix","title":"1632. Rank Transform of a Matrix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Union Find, Graph, Topological Sort, Sorting, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/union_find_advanced/#803-bricks-falling-when-hit","title":"803. Bricks Falling When Hit","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Union Find, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/union_find_advanced/#1569-number-of-ways-to-reorder-array-to-get-same-bst","title":"1569. Number of Ways to Reorder Array to Get Same BST","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Divide And Conquer, Dynamic Programming, Tree, Union Find, Binary Search Tree, Memoization, Combinatorics, Binary Tree</p> </li> </ul>"},{"location":"EndlessCheng/union_find_advanced/#3235-check-if-the-rectangle-corner-is-reachable","title":"3235. Check if the Rectangle Corner Is Reachable","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Depth First Search, Breadth First Search, Union Find, Geometry</p> </li> </ul>"},{"location":"EndlessCheng/union_find_advanced/#2371-minimize-maximum-value-in-a-grid","title":"2371. Minimize Maximum Value in a Grid \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Union Find, Graph, Topological Sort, Sorting, Matrix</p> </li> </ul>"},{"location":"EndlessCheng/union_find_advanced/#2459-sort-array-by-moving-items-to-empty-space","title":"2459. Sort Array by Moving Items to Empty Space \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/union_find_basics/","title":"Union Find Basics","text":""},{"location":"EndlessCheng/union_find_basics/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 990. Satisfiability of Equality Equations (Medium)</li> <li> 721. Accounts Merge (Medium)</li> <li> 737. Sentence Similarity II (Medium) \ud83d\udc51</li> <li> 1101. The Earliest Moment When Everyone Become Friends (Medium) \ud83d\udc51</li> <li> 1258. Synonymous Sentences (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/union_find_basics/#990-satisfiability-of-equality-equations","title":"990. Satisfiability of Equality Equations","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Union Find, Graph</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef equationsPossible(equations: List[str]) -&gt; bool:\n    parent = defaultdict(str)\n    rank = defaultdict(int)\n\n    def find(n):\n        p = parent[n]\n        while p != parent[p]:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    for equation in equations:\n        if equation[0] not in parent:\n            parent[equation[0]] = equation[0]\n            rank[equation[0]] = 1\n        if equation[3] not in parent:\n            parent[equation[3]] = equation[3]\n            rank[equation[3]] = 1\n\n    for equation in equations:\n        if equation[1] == \"=\":\n            union(equation[0], equation[3])\n\n    for equation in equations:\n        if equation[1] == \"!\":\n            if find(equation[0]) == find(equation[3]):\n                return False\n\n    return True\n\n\nequations = [\"a==b\", \"b!=a\"]\nprint(equationsPossible(equations))  # False\n</code></pre>"},{"location":"EndlessCheng/union_find_basics/#721-accounts-merge","title":"721. Accounts Merge","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Depth First Search, Breadth First Search, Union Find, Sorting</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef accountsMerge(accounts: List[List[str]]) -&gt; List[List[str]]:\n    parent = defaultdict(str)\n    rank = defaultdict(int)\n    email_to_name = defaultdict(str)\n    merged_accounts = defaultdict(list)\n\n    def find(n):\n        p = parent[n]\n        while p != parent[p]:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    for account in accounts:\n        name = account[0]\n        first_email = account[1]\n\n        for email in account[1:]:\n            if email not in parent:\n                parent[email] = email\n                rank[email] = 1\n            email_to_name[email] = name\n            union(first_email, email)\n\n    for email in parent:\n        root_email = find(email)\n        merged_accounts[root_email].append(email)\n\n    result = []\n    for root_email, emails in merged_accounts.items():\n        result.append([email_to_name[root_email]] + sorted(emails))\n\n    return result\n\n\naccounts = [\n    [\"John\", \"johnsmith@mail.com\", \"john_newyork@mail.com\"],\n    [\"John\", \"johnsmith@mail.com\", \"john00@mail.com\"],\n    [\"Mary\", \"mary@mail.com\"],\n    [\"John\", \"johnnybravo@mail.com\"],\n]\nprint(accountsMerge(accounts))\n# [['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],\n# ['Mary', 'mary@mail.com'],\n# ['John', 'johnnybravo@mail.com']]\n</code></pre>"},{"location":"EndlessCheng/union_find_basics/#737-sentence-similarity-ii","title":"737. Sentence Similarity II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Depth First Search, Breadth First Search, Union Find</p> </li> </ul>"},{"location":"EndlessCheng/union_find_basics/#1101-the-earliest-moment-when-everyone-become-friends","title":"1101. The Earliest Moment When Everyone Become Friends \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Union Find, Sorting</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Union Find\ndef earliestAcq(logs: List[List[int]], n: int) -&gt; int:\n    logs.sort()\n    par = {i: i for i in range(n)}\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    for time, a, b in logs:\n        pa, pb = find(a), find(b)\n        if pa != pb:\n            par[pa] = pb\n            n -= 1\n        if n == 1:\n            return time\n    return -1\n\n\nlogs = [[0, 2, 0], [1, 0, 1], [3, 0, 3], [4, 1, 2], [7, 3, 1]]\nn = 4\nprint(earliestAcq(logs, n))  # 3\n</code></pre>"},{"location":"EndlessCheng/union_find_basics/#1258-synonymous-sentences","title":"1258. Synonymous Sentences \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Backtracking, Union Find</p> </li> </ul>"},{"location":"EndlessCheng/union_find_interval/","title":"Union Find Interval","text":""},{"location":"EndlessCheng/union_find_interval/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1851. Minimum Interval to Include Each Query (Hard)</li> <li> 3244. Shortest Distance After Road Addition Queries II (Hard)</li> <li> 2158. Amount of New Area Painted Each Day (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/union_find_interval/#1851-minimum-interval-to-include-each-query","title":"1851. Minimum Interval to Include Each Query","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Line Sweep, Sorting, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/union_find_interval/#3244-shortest-distance-after-road-addition-queries-ii","title":"3244. Shortest Distance After Road Addition Queries II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Graph, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/union_find_interval/#2158-amount-of-new-area-painted-each-day","title":"2158. Amount of New Area Painted Each Day \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Segment Tree, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/union_find_on_arrays/","title":"Union Find on Arrays","text":""},{"location":"EndlessCheng/union_find_on_arrays/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1562. Find Latest Group of Size M (Medium)</li> <li> 1488. Avoid Flood in The City (Medium)</li> <li> 2382. Maximum Segment Sum After Removals (Hard)</li> <li> 2334. Subarray With Elements Greater Than Varying Threshold (Hard)</li> </ul>"},{"location":"EndlessCheng/union_find_on_arrays/#1562-find-latest-group-of-size-m","title":"1562. Find Latest Group of Size M","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Binary Search, Simulation</p> </li> </ul>"},{"location":"EndlessCheng/union_find_on_arrays/#1488-avoid-flood-in-the-city","title":"1488. Avoid Flood in The City","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Binary Search, Greedy, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/union_find_on_arrays/#2382-maximum-segment-sum-after-removals","title":"2382. Maximum Segment Sum After Removals","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Union Find, Prefix Sum, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/union_find_on_arrays/#2334-subarray-with-elements-greater-than-varying-threshold","title":"2334. Subarray With Elements Greater Than Varying Threshold","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Stack, Union Find, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/valid_parentheses_strings/","title":"Valid Parentheses Strings","text":""},{"location":"EndlessCheng/valid_parentheses_strings/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 20. Valid Parentheses (Easy)</li> <li> 921. Minimum Add to Make Parentheses Valid (Medium)</li> <li> 1021. Remove Outermost Parentheses (Easy)</li> <li> 1614. Maximum Nesting Depth of the Parentheses (Easy)</li> <li> 1190. Reverse Substrings Between Each Pair of Parentheses (Medium)</li> <li> 856. Score of Parentheses (Medium)</li> <li> 1249. Minimum Remove to Make Valid Parentheses (Medium)</li> <li> 1963. Minimum Number of Swaps to Make the String Balanced (Medium)</li> <li> 678. Valid Parenthesis String (Medium)</li> <li> 1111. Maximum Nesting Depth of Two Valid Parentheses Strings (Medium)</li> <li> 1541. Minimum Insertions to Balance a Parentheses String (Medium)</li> <li> 2116. Check if a Parentheses String Can Be Valid (Medium)</li> <li> 32. Longest Valid Parentheses (Hard)</li> </ul>"},{"location":"EndlessCheng/valid_parentheses_strings/#20-valid-parentheses","title":"20. Valid Parentheses","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack</p> </li> </ul> PythonCPP <pre><code># Stack\ndef is_valid(s: str) -&gt; bool:\n    if len(s) % 2:\n        return False\n\n    pairs = {\n        \"(\": \")\",\n        \"{\": \"}\",\n        \"[\": \"]\",\n    }\n    stack = []\n    for ch in s:\n        if ch in pairs:\n            stack.append(ch)\n        elif not stack or ch != pairs[stack.pop()]:\n            return False\n\n    return True if not stack else False\n\n\ndef test_is_valid():\n    assert is_valid(\"()[]{}\")\n    assert not is_valid(\"(]\")\n    assert not is_valid(\"([)]\")\n    assert is_valid(\"{[]}\")\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;stack&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool isValid(string s) {\n        unordered_map&lt;char, char&gt; map{{')', '('}, {'}', '{'}, {']', '['}};\n        stack&lt;char&gt; stack;\n        if (s.length() % 2 == 1) return false;\n\n        for (char&amp; ch : s) {\n            if (stack.empty() || map.find(ch) == map.end()) {\n                stack.push(ch);\n            } else {\n                if (map[ch] != stack.top()) {\n                    return false;\n                }\n                stack.pop();\n            }\n        }\n        return stack.empty();\n    }\n};\n\nint main() {\n    Solution s;\n    assert(s.isValid(\"()\") == true);\n    assert(s.isValid(\"()[]{}\") == true);\n    assert(s.isValid(\"(]\") == false);\n    assert(s.isValid(\"([)]\") == false);\n    assert(s.isValid(\"{[]}\") == true);\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/valid_parentheses_strings/#921-minimum-add-to-make-parentheses-valid","title":"921. Minimum Add to Make Parentheses Valid","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/valid_parentheses_strings/#1021-remove-outermost-parentheses","title":"1021. Remove Outermost Parentheses","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack</p> </li> </ul>"},{"location":"EndlessCheng/valid_parentheses_strings/#1614-maximum-nesting-depth-of-the-parentheses","title":"1614. Maximum Nesting Depth of the Parentheses","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack</p> </li> </ul>"},{"location":"EndlessCheng/valid_parentheses_strings/#1190-reverse-substrings-between-each-pair-of-parentheses","title":"1190. Reverse Substrings Between Each Pair of Parentheses","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack</p> </li> </ul>"},{"location":"EndlessCheng/valid_parentheses_strings/#856-score-of-parentheses","title":"856. Score of Parentheses","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack</p> </li> </ul>"},{"location":"EndlessCheng/valid_parentheses_strings/#1249-minimum-remove-to-make-valid-parentheses","title":"1249. Minimum Remove to Make Valid Parentheses","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack</p> </li> </ul>"},{"location":"EndlessCheng/valid_parentheses_strings/#1963-minimum-number-of-swaps-to-make-the-string-balanced","title":"1963. Minimum Number of Swaps to Make the String Balanced","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Stack, Greedy</p> </li> </ul> Python <pre><code>def minSwaps(s: str) -&gt; int:\n    res, balance = 0, 0\n\n    for char in s:\n        if char == \"[\":\n            balance += 1\n        elif balance &gt; 0:\n            balance -= 1\n        else:\n            res += 1\n            balance += 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(minSwaps(\"][][\"))  # 1\n    print(minSwaps(\"]]][[[\"))  # 2\n</code></pre>"},{"location":"EndlessCheng/valid_parentheses_strings/#678-valid-parenthesis-string","title":"678. Valid Parenthesis String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Stack, Greedy</p> </li> </ul> Python <pre><code># Greedy\ndef checkValidString(s: str) -&gt; bool:\n    min_open, max_open = 0, 0\n\n    for char in s:\n        if char == \"(\":\n            min_open += 1\n            max_open += 1\n        elif char == \")\":\n            min_open = max(min_open - 1, 0)\n            max_open -= 1\n        elif char == \"*\":\n            min_open = max(min_open - 1, 0)\n            max_open += 1\n\n        if max_open &lt; 0:\n            return False\n\n    return min_open == 0\n\n\ns = \"(*))\"\nprint(checkValidString(s))  # True\n</code></pre>"},{"location":"EndlessCheng/valid_parentheses_strings/#1111-maximum-nesting-depth-of-two-valid-parentheses-strings","title":"1111. Maximum Nesting Depth of Two Valid Parentheses Strings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack</p> </li> </ul>"},{"location":"EndlessCheng/valid_parentheses_strings/#1541-minimum-insertions-to-balance-a-parentheses-string","title":"1541. Minimum Insertions to Balance a Parentheses String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/valid_parentheses_strings/#2116-check-if-a-parentheses-string-can-be-valid","title":"2116. Check if a Parentheses String Can Be Valid","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack, Greedy</p> </li> </ul> PythonCPP <pre><code># Valid Parentheses Strings\ndef canBeValid(s: str, locked: str) -&gt; bool:\n    if len(s) % 2:\n        return False\n\n    mx, mn = 0, 0\n    for ch, lock in zip(s, locked):\n        if lock == \"1\":\n            d = 1 if ch == \"(\" else -1\n            mx += d\n            if mx &lt; 0:\n                return False\n            mn += d\n        else:\n            mx += 1\n            mn -= 1\n\n        if mn &lt; 0:\n            mn = 1\n\n    return mn == 0\n\n\nif __name__ == \"__main__\":\n    s = \"))()))\"\n    locked = \"010100\"\n    print(canBeValid(s, locked))  # True\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\n// Valid Parentheses Strings\nbool canBeValid(string s, string locked) {\n    if (s.length() % 2 != 0) {\n        return false;\n    }\n\n    int mx = 0, mn = 0;\n    for (size_t i = 0; i &lt; s.length(); ++i) {\n        char ch = s[i];\n        char lock = locked[i];\n\n        if (lock == '1') {\n            int d = (ch == '(') ? 1 : -1;\n            mx += d;\n            if (mx &lt; 0) {\n                return false;\n            }\n            mn += d;\n        } else {\n            mx += 1;\n            mn -= 1;\n        }\n\n        if (mn &lt; 0) {\n            mn = 1;\n        }\n    }\n\n    return mn == 0;\n}\n\nint main() {\n    string s = \"))()))\";\n    string locked = \"010100\";\n    cout &lt;&lt; (canBeValid(s, locked) ? \"true\" : \"false\") &lt;&lt; endl;  // true\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/valid_parentheses_strings/#32-longest-valid-parentheses","title":"32. Longest Valid Parentheses","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Stack</p> </li> </ul> Python <pre><code># Stack\ndef longestValidParentheses(s: str) -&gt; int:\n    stack = [-1]\n    res = 0\n\n    for i, ch in enumerate(s):\n        if ch == \"(\":\n            stack.append(i)\n        elif ch == \")\":\n            stack.pop()\n            if stack:\n                res = max(res, i - stack[-1])\n            else:\n                stack.append(i)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(longestValidParentheses(\"(()\"))  # 2\n    print(longestValidParentheses(\")()())\"))  # 4\n</code></pre>"},{"location":"EndlessCheng/xor_trie/","title":"XOR Trie","text":""},{"location":"EndlessCheng/xor_trie/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 421. Maximum XOR of Two Numbers in an Array (Medium)</li> <li> 2935. Maximum Strong Pair XOR II (Hard)</li> <li> 1707. Maximum XOR With an Element From Array (Hard)</li> <li> 1803. Count Pairs With XOR in a Range (Hard)</li> <li> 1938. Maximum Genetic Difference Query (Hard)</li> <li> 2479. Maximum XOR of Two Non-Overlapping Subtrees (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/xor_trie/#421-maximum-xor-of-two-numbers-in-an-array","title":"421. Maximum XOR of Two Numbers in an Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Bit Manipulation, Trie</p> </li> </ul>"},{"location":"EndlessCheng/xor_trie/#2935-maximum-strong-pair-xor-ii","title":"2935. Maximum Strong Pair XOR II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Bit Manipulation, Trie, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/xor_trie/#1707-maximum-xor-with-an-element-from-array","title":"1707. Maximum XOR With an Element From Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation, Trie</p> </li> </ul>"},{"location":"EndlessCheng/xor_trie/#1803-count-pairs-with-xor-in-a-range","title":"1803. Count Pairs With XOR in a Range","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation, Trie</p> </li> </ul>"},{"location":"EndlessCheng/xor_trie/#1938-maximum-genetic-difference-query","title":"1938. Maximum Genetic Difference Query","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Bit Manipulation, Depth First Search, Trie</p> </li> </ul>"},{"location":"EndlessCheng/xor_trie/#2479-maximum-xor-of-two-non-overlapping-subtrees","title":"2479. Maximum XOR of Two Non-Overlapping Subtrees \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Graph, Trie</p> </li> </ul>"},{"location":"EndlessCheng/%E4%B8%89%E6%8C%87%E9%92%88_three_pointers/","title":"\u4e09\u6307\u9488 Three Pointers","text":""},{"location":"EndlessCheng/%E4%B8%89%E6%8C%87%E9%92%88_three_pointers/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2367. Number of Arithmetic Triplets (Easy)</li> <li> 2563. Count the Number of Fair Pairs (Medium)</li> <li> 795. Number of Subarrays with Bounded Maximum (Medium)</li> <li> 2444. Count Subarrays With Fixed Bounds (Hard)</li> <li> 3347. Maximum Frequency of an Element After Performing Operations II (Hard)</li> <li> 1213. Intersection of Three Sorted Arrays (Easy) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/%E4%B8%89%E6%8C%87%E9%92%88_three_pointers/#2367-number-of-arithmetic-triplets","title":"2367. Number of Arithmetic Triplets","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Two Pointers, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/%E4%B8%89%E6%8C%87%E9%92%88_three_pointers/#2563-count-the-number-of-fair-pairs","title":"2563. Count the Number of Fair Pairs","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/%E4%B8%89%E6%8C%87%E9%92%88_three_pointers/#795-number-of-subarrays-with-bounded-maximum","title":"795. Number of Subarrays with Bounded Maximum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers</p> </li> </ul>"},{"location":"EndlessCheng/%E4%B8%89%E6%8C%87%E9%92%88_three_pointers/#2444-count-subarrays-with-fixed-bounds","title":"2444. Count Subarrays With Fixed Bounds","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Queue, Sliding Window, Monotonic Queue</p> </li> </ul>"},{"location":"EndlessCheng/%E4%B8%89%E6%8C%87%E9%92%88_three_pointers/#3347-maximum-frequency-of-an-element-after-performing-operations-ii","title":"3347. Maximum Frequency of an Element After Performing Operations II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Sliding Window, Sorting, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/%E4%B8%89%E6%8C%87%E9%92%88_three_pointers/#1213-intersection-of-three-sorted-arrays","title":"1213. Intersection of Three Sorted Arrays \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Binary Search, Counting</p> </li> </ul>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%85%B6%E4%BB%96_variable_sliding_window_others/","title":"\u4e0d\u5b9a\u957f\u6ed1\u52a8\u7a97\u53e3\u5176\u4ed6 Variable Sliding Window Others","text":""},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%85%B6%E4%BB%96_variable_sliding_window_others/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 825. Friends Of Appropriate Ages (Medium)</li> <li> 2401. Longest Nice Subarray (Medium)</li> <li> 1156. Swap For Longest Repeated Character Substring (Medium)</li> <li> 424. Longest Repeating Character Replacement (Medium)</li> <li> 438. Find All Anagrams in a String (Medium)</li> <li> 1712. Ways to Split Array Into Three Subarrays (Medium)</li> <li> 1918. Kth Smallest Subarray Sum (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%85%B6%E4%BB%96_variable_sliding_window_others/#825-friends-of-appropriate-ages","title":"825. Friends Of Appropriate Ages","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%85%B6%E4%BB%96_variable_sliding_window_others/#2401-longest-nice-subarray","title":"2401. Longest Nice Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%85%B6%E4%BB%96_variable_sliding_window_others/#1156-swap-for-longest-repeated-character-substring","title":"1156. Swap For Longest Repeated Character Substring","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%85%B6%E4%BB%96_variable_sliding_window_others/#424-longest-repeating-character-replacement","title":"424. Longest Repeating Character Replacement","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> Python <pre><code>from collections import defaultdict\n\n\n# Sliding Window - Variable\ndef characterReplacement(s: str, k: int) -&gt; int:\n    left = 0\n    maxCount = 0\n    counts = defaultdict(int)\n    maxLen = 0\n\n    for right in range(len(s)):\n        counts[s[right]] += 1\n        maxCount = max(maxCount, counts[s[right]])\n\n        while right - left + 1 - maxCount &gt; k:\n            counts[s[left]] -= 1\n            left += 1\n\n        maxLen = max(maxLen, right - left + 1)\n\n    return maxLen\n\n\ns = \"ABAB\"\nk = 2\nprint(characterReplacement(s, k))  # 4\n</code></pre>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%85%B6%E4%BB%96_variable_sliding_window_others/#438-find-all-anagrams-in-a-string","title":"438. Find All Anagrams in a String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Sliding Window Fixed Size\ndef findAnagrams(s: str, p: str) -&gt; List[int]:\n    n, k = len(s), len(p)\n    target = [0 for _ in range(26)]\n    for ch in p:\n        target[ord(ch) - ord(\"a\")] += 1\n\n    count = [0 for _ in range(26)]\n    left = 0\n    res = []\n\n    for right in range(n):\n        count[ord(s[right]) - ord(\"a\")] += 1\n        if right &lt; k - 1:\n            continue\n\n        if count == target:\n            res.append(left)\n\n        count[ord(s[left]) - ord(\"a\")] -= 1\n        left += 1\n\n    return res\n\n\ns = \"cbaebabacd\"\np = \"abc\"\nprint(findAnagrams(s, p))  # [0, 6]\n</code></pre>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%85%B6%E4%BB%96_variable_sliding_window_others/#1712-ways-to-split-array-into-three-subarrays","title":"1712. Ways to Split Array Into Three Subarrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%85%B6%E4%BB%96_variable_sliding_window_others/#1918-kth-smallest-subarray-sum","title":"1918. Kth Smallest Subarray Sum \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%A4%A7%E5%9F%BA%E7%A1%80_variable_sliding_window_max_basics/","title":"\u4e0d\u5b9a\u957f\u6ed1\u52a8\u7a97\u53e3\u6c42\u5927\u57fa\u7840 Variable Sliding Window Max Basics","text":""},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%A4%A7%E5%9F%BA%E7%A1%80_variable_sliding_window_max_basics/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3. Longest Substring Without Repeating Characters (Medium)</li> <li> 3090. Maximum Length Substring With Two Occurrences (Easy)</li> <li> 1493. Longest Subarray of 1's After Deleting One Element (Medium)</li> <li> 1208. Get Equal Substrings Within Budget (Medium)</li> <li> 904. Fruit Into Baskets (Medium)</li> <li> 1695. Maximum Erasure Value (Medium)</li> <li> 2958. Length of Longest Subarray With at Most K Frequency (Medium)</li> <li> 2024. Maximize the Confusion of an Exam (Medium)</li> <li> 1004. Max Consecutive Ones III (Medium)</li> <li> 1658. Minimum Operations to Reduce X to Zero (Medium)</li> </ul>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%A4%A7%E5%9F%BA%E7%A1%80_variable_sliding_window_max_basics/#3-longest-substring-without-repeating-characters","title":"3. Longest Substring Without Repeating Characters","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Classic variable sliding window problem. Use a set to keep track of the characters in the current window.\n- Return the length of the longest substring without repeating characters.\n- [Template tutorial by \u7075\u5c71\u8336\u827e\u5e9c](https://leetcode.cn/problems/longest-substring-without-repeating-characters/solutions/1959540/xia-biao-zong-suan-cuo-qing-kan-zhe-by-e-iaks)\n\"\"\"\n\nfrom collections import defaultdict\n\n\n# Sliding Window Variable Max - HashMap\ndef lengthOfLongestSubstringHash(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    left = 0\n    cnt = defaultdict(int)\n    res = 0\n\n    for right in range(n):\n        cnt[s[right]] += 1\n\n        while cnt[s[right]] &gt; 1:\n            cnt[s[left]] -= 1\n            left += 1\n\n        res = max(res, right - left + 1)\n\n    return res\n\n\n# Sliding Window Variable Max - Set\ndef lengthOfLongestSubstringSet(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    left = 0\n    res = 0\n    window = set()\n\n    for right in range(n):\n        while left &lt; right and s[right] in window:\n            window.remove(s[left])\n            left += 1\n        window.add(s[right])\n        res = max(res, right - left + 1)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    s = \"abcabcbb\"\n    assert lengthOfLongestSubstringHash(s) == 3\n    assert lengthOfLongestSubstringSet(s) == 3\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;unordered_set&gt;\nusing namespace std;\n\nint lengthOfLongestSubstring(string s) {\n    int n = s.length();\n    int res = 0;\n    int left = 0;\n    unordered_set&lt;char&gt; window;\n\n    for (int right = 0; right &lt; n; right++) {\n        char ch = s[right];\n\n        while (window.find(ch) != window.end()) {\n            window.erase(s[left]);\n            left++;\n        }\n\n        window.insert(ch);\n        res = max(res, right - left + 1);\n    }\n    return (int)res;\n}\n\nint main() {\n    string s = \"abcabcbb\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 3\n    s = \"bbbbb\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 1\n    s = \"pwwkew\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 3\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%A4%A7%E5%9F%BA%E7%A1%80_variable_sliding_window_max_basics/#3090-maximum-length-substring-with-two-occurrences","title":"3090. Maximum Length Substring With Two Occurrences","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> Python <pre><code>from collections import defaultdict\n\n\n# Sliding Window Variable Max\ndef maximumLengthSubstring(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 2:\n        return n\n\n    counts = defaultdict(int)\n    left = 0\n    res = 0\n\n    for right in range(n):\n        while left &lt; right and counts[s[right]] == 2:\n            counts[s[left]] -= 1\n            if counts[s[left]] == 0:\n                del counts[s[left]]\n            left += 1\n\n        res = max(res, right - left + 1)\n        counts[s[right]] += 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    s = \"bcbbbcba\"\n    assert maximumLengthSubstring(s) == 4\n</code></pre>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%A4%A7%E5%9F%BA%E7%A1%80_variable_sliding_window_max_basics/#1493-longest-subarray-of-1s-after-deleting-one-element","title":"1493. Longest Subarray of 1's After Deleting One Element","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Sliding Window</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Sliding Window Variable Max\ndef longestSubarray(nums: List[int]) -&gt; int:\n    zeroCount = 0\n    res = 0\n    left = 0\n\n    for right in range(len(nums)):\n        if nums[right] == 0:\n            zeroCount += 1\n\n        while zeroCount &gt; 1:\n            if nums[left] == 0:\n                zeroCount -= 1\n            left += 1\n\n        res = max(res, right - left)\n\n    return res\n\n\nnums = [1, 1, 0, 1]\nprint(longestSubarray(nums))  # 3\n</code></pre>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%A4%A7%E5%9F%BA%E7%A1%80_variable_sliding_window_max_basics/#1208-get-equal-substrings-within-budget","title":"1208. Get Equal Substrings Within Budget","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Binary Search, Sliding Window, Prefix Sum</p> </li> </ul> Python <pre><code># Sliding Window - Variable\ndef equalSubstring(s: str, t: str, maxCost: int) -&gt; int:\n    left = 0\n    maxLen = 0\n    currentCost = 0\n\n    for right in range(len(s)):\n        currentCost += abs(ord(s[right]) - ord(t[right]))\n\n        while currentCost &gt; maxCost:\n            currentCost -= abs(ord(s[left]) - ord(t[left]))\n            left += 1\n\n        maxLen = max(maxLen, right - left + 1)\n\n    return maxLen\n\n\ns = \"abcd\"\nt = \"bcdf\"\nmaxCost = 3\nprint(equalSubstring(s, t, maxCost))  # 3\n</code></pre>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%A4%A7%E5%9F%BA%E7%A1%80_variable_sliding_window_max_basics/#904-fruit-into-baskets","title":"904. Fruit Into Baskets","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Sliding Window</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Sliding Window Variable Size\ndef totalFruit(fruits: List[int]) -&gt; int:\n    n = len(fruits)\n    if n &lt;= 2:\n        return n\n\n    baskets = defaultdict(int)\n    res, left = 0, 0\n\n    for right in range(n):\n        baskets[fruits[right]] += 1\n\n        while len(baskets) &gt; 2:\n            baskets[fruits[left]] -= 1\n            if baskets[fruits[left]] == 0:\n                del baskets[fruits[left]]\n            left += 1\n\n        res = max(res, right - left + 1)\n\n    return res\n\n\nfruits = [1, 2, 3, 2, 2]\nprint(totalFruit(fruits))  # 4\n</code></pre>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%A4%A7%E5%9F%BA%E7%A1%80_variable_sliding_window_max_basics/#1695-maximum-erasure-value","title":"1695. Maximum Erasure Value","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Sliding Window</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Sliding Window Variable Size\ndef maximumUniqueSubarray(nums: List[int]) -&gt; int:\n    n = len(nums)\n    left = 0\n    cur, res = 0, 0\n    sub = set()\n\n    for right in range(n):\n        while left &lt; right and nums[right] in sub:\n            sub.remove(nums[left])\n            cur -= nums[left]\n            left += 1\n\n        sub.add(nums[right])\n        cur += nums[right]\n        res = max(res, cur)\n\n    return res\n\n\nnums = [4, 2, 4, 5, 6]\nprint(maximumUniqueSubarray(nums))  # 17\n</code></pre>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%A4%A7%E5%9F%BA%E7%A1%80_variable_sliding_window_max_basics/#2958-length-of-longest-subarray-with-at-most-k-frequency","title":"2958. Length of Longest Subarray With at Most K Frequency","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Sliding Window</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Sliding Window Variable Size\ndef maxSubarrayLength(nums: List[int], k: int) -&gt; int:\n    n = len(nums)\n    freqs = defaultdict(int)  # num -&gt; freq\n    left = 0\n    res = 0\n\n    for right in range(n):\n        freqs[nums[right]] += 1\n\n        while freqs[nums[right]] &gt; k:\n            freqs[nums[left]] -= 1\n            left += 1\n\n        res = max(res, right - left + 1)\n\n    return res\n\n\nnums = [1, 2, 1, 2, 1, 2, 1, 2]\nk = 2\nprint(maxSubarrayLength(nums, k))  # 4\n</code></pre>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%A4%A7%E5%9F%BA%E7%A1%80_variable_sliding_window_max_basics/#2024-maximize-the-confusion-of-an-exam","title":"2024. Maximize the Confusion of an Exam","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Binary Search, Sliding Window, Prefix Sum</p> </li> </ul> Python <pre><code># Sliding Window - Variable\ndef maxConsecutiveAnswers1(answerKey: str, k: int) -&gt; int:\n    def maxConsecutiveChar(s: str, k: int, char: str) -&gt; int:\n        max_len = 0\n        left = 0\n        count = 0  # num of str != char\n\n        for right in range(len(s)):\n            if s[right] != char:\n                count += 1\n\n            while count &gt; k:\n                if s[left] != char:\n                    count -= 1\n                left += 1\n\n            max_len = max(max_len, right - left + 1)\n\n        return max_len\n\n    max_t = maxConsecutiveChar(answerKey, k, \"T\")\n    max_f = maxConsecutiveChar(answerKey, k, \"F\")\n\n    return max(max_t, max_f)\n\n\n# Sliding Window - Variable\ndef maxConsecutiveAnswers2(answerKey: str, k: int) -&gt; int:\n    def maxConsecutiveChar(s: str, k: int, char: str) -&gt; int:\n        max_len = 0\n        left, right = 0, 0\n\n        while right &lt; len(s):\n            if s[right] != char:\n                k -= 1\n\n            while k &lt; 0:\n                if s[left] != char:\n                    k += 1\n                left += 1\n\n            max_len = max(max_len, right - left + 1)\n            right += 1\n\n        return max_len\n\n    max_t = maxConsecutiveChar(answerKey, k, \"T\")\n    max_f = maxConsecutiveChar(answerKey, k, \"F\")\n\n    return max(max_t, max_f)\n\n\n# |-----------------|---------|------------|\n# |  Approach       |  Time   |  Space     |\n# |-----------------|---------|------------|\n# | Sliding Window  |  O(N)   |  O(1)      |\n# |-----------------|---------|------------|\n\n\nanswerKey = \"TTFF\"\nk = 2\nprint(maxConsecutiveAnswers1(answerKey, k))  # 4\nprint(maxConsecutiveAnswers2(answerKey, k))  # 4\n</code></pre>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%A4%A7%E5%9F%BA%E7%A1%80_variable_sliding_window_max_basics/#1004-max-consecutive-ones-iii","title":"1004. Max Consecutive Ones III","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Sliding Window, Prefix Sum</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Sliding Window - Variable\ndef longestOnes(nums: List[int], k: int) -&gt; int:\n    left = 0\n    maxLen = 0\n    zero_count = 0\n\n    for right in range(len(nums)):\n        if nums[right] == 0:\n            zero_count += 1\n\n        while zero_count &gt; k:\n            if nums[left] == 0:\n                zero_count -= 1\n            left += 1\n\n        maxLen = max(maxLen, right - left + 1)\n\n    return maxLen\n\n\nnums = [1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0]\nk = 2\nprint(longestOnes(nums, k))  # 6\n</code></pre>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%A4%A7%E5%9F%BA%E7%A1%80_variable_sliding_window_max_basics/#1658-minimum-operations-to-reduce-x-to-zero","title":"1658. Minimum Operations to Reduce X to Zero","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Binary Search, Sliding Window, Prefix Sum</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Sliding Window Variable Max\ndef minOperations(nums: List[int], x: int) -&gt; int:\n    window = 0\n    total = sum(nums)\n    target = total - x\n    n = len(nums)\n    left = 0\n    maxLen = 0\n\n    if target &lt; 0:\n        return -1\n    if target == 0:\n        return n\n\n    for right in range(n):\n        window += nums[right]\n\n        while left &lt;= right and window &gt; target:\n            window -= nums[left]\n            left += 1\n\n        if window == target:\n            maxLen = max(maxLen, right - left + 1)\n\n    return -1 if not maxLen else n - maxLen\n\n\nif __name__ == \"__main__\":\n    nums = [1, 1, 4, 2, 3]\n    x = 5\n    assert minOperations(nums, x) == 2\n</code></pre>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%A4%A7%E8%BF%9B%E9%98%B6_variable_sliding_window_max_advanced/","title":"\u4e0d\u5b9a\u957f\u6ed1\u52a8\u7a97\u53e3\u6c42\u5927\u8fdb\u9636 Variable Sliding Window Max Advanced","text":""},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%A4%A7%E8%BF%9B%E9%98%B6_variable_sliding_window_max_advanced/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2730. Find the Longest Semi-Repetitive Substring (Medium)</li> <li> 2779. Maximum Beauty of an Array After Applying Operation (Medium)</li> <li> 1838. Frequency of the Most Frequent Element (Medium)</li> <li> 2516. Take K of Each Character From Left and Right (Medium)</li> <li> 2831. Find the Longest Equal Subarray (Medium)</li> <li> 2271. Maximum White Tiles Covered by a Carpet (Medium)</li> <li> 2106. Maximum Fruits Harvested After at Most K Steps (Hard)</li> <li> 2555. Maximize Win From Two Segments (Medium)</li> <li> 2009. Minimum Number of Operations to Make Array Continuous (Hard)</li> <li> 1610. Maximum Number of Visible Points (Hard)</li> <li> 2781. Length of the Longest Valid Substring (Hard)</li> <li> 3411. Maximum Subarray With Equal Products (Easy)</li> <li> 2968. Apply Operations to Maximize Frequency Score (Hard)</li> <li> 1040. Moving Stones Until Consecutive II (Medium)</li> <li> 3413. Maximum Coins From K Consecutive Bags (Medium)</li> <li> 395. Longest Substring with At Least K Repeating Characters (Medium)</li> <li> 1763. Longest Nice Substring (Easy)</li> <li> 487. Max Consecutive Ones II (Medium) \ud83d\udc51</li> <li> 159. Longest Substring with At Most Two Distinct Characters (Medium) \ud83d\udc51</li> <li> 340. Longest Substring with At Most K Distinct Characters (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%A4%A7%E8%BF%9B%E9%98%B6_variable_sliding_window_max_advanced/#2730-find-the-longest-semi-repetitive-substring","title":"2730. Find the Longest Semi-Repetitive Substring","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Sliding Window</p> </li> </ul> Python <pre><code># Sliding Window Variable Max\ndef longestSemiRepetitiveSubstring(s: str) -&gt; int:\n    n = len(s)\n    left = 0\n    repeat = 0\n    res = 1\n\n    for right in range(1, n):\n        if s[right] == s[right - 1]:\n            repeat += 1\n\n        while repeat &gt; 1:\n            if s[left] == s[left + 1]:\n                repeat -= 1\n            left += 1\n\n        res = max(res, right - left + 1)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert longestSemiRepetitiveSubstring(\"abacaba\") == 7\n    assert longestSemiRepetitiveSubstring(\"aa\") == 2\n    assert longestSemiRepetitiveSubstring(\"a\") == 1\n    assert longestSemiRepetitiveSubstring(\"abcde\") == 5\n</code></pre>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%A4%A7%E8%BF%9B%E9%98%B6_variable_sliding_window_max_advanced/#2779-maximum-beauty-of-an-array-after-applying-operation","title":"2779. Maximum Beauty of an Array After Applying Operation","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Sliding Window, Sorting</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Sliding Window Variable Max\ndef maximumBeauty(nums: List[int], k: int) -&gt; int:\n    nums.sort()\n    res, left = 0, 0\n\n    for right, x in enumerate(nums):\n        while x - nums[left] &gt; k * 2:\n            left += 1\n        res = max(res, right - left + 1)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert maximumBeauty([4, 6, 1, 2], 2) == 3\n</code></pre>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%A4%A7%E8%BF%9B%E9%98%B6_variable_sliding_window_max_advanced/#1838-frequency-of-the-most-frequent-element","title":"1838. Frequency of the Most Frequent Element","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Greedy, Sliding Window, Sorting, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%A4%A7%E8%BF%9B%E9%98%B6_variable_sliding_window_max_advanced/#2516-take-k-of-each-character-from-left-and-right","title":"2516. Take K of Each Character From Left and Right","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%A4%A7%E8%BF%9B%E9%98%B6_variable_sliding_window_max_advanced/#2831-find-the-longest-equal-subarray","title":"2831. Find the Longest Equal Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Binary Search, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%A4%A7%E8%BF%9B%E9%98%B6_variable_sliding_window_max_advanced/#2271-maximum-white-tiles-covered-by-a-carpet","title":"2271. Maximum White Tiles Covered by a Carpet","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Greedy, Sliding Window, Sorting, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%A4%A7%E8%BF%9B%E9%98%B6_variable_sliding_window_max_advanced/#2106-maximum-fruits-harvested-after-at-most-k-steps","title":"2106. Maximum Fruits Harvested After at Most K Steps","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Sliding Window, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%A4%A7%E8%BF%9B%E9%98%B6_variable_sliding_window_max_advanced/#2555-maximize-win-from-two-segments","title":"2555. Maximize Win From Two Segments","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Sliding Window</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Sliding Window - Variable\ndef maximizeWin(prizePositions: List[int], k: int) -&gt; int:\n    n = len(prizePositions)\n\n    if 2 * k &gt;= prizePositions[-1] - prizePositions[0]:\n        return n\n\n    ans = left = 0\n    mx = [0] * (n + 1)\n\n    for right, p in enumerate(prizePositions):\n        while p - prizePositions[left] &gt; k:\n            left += 1\n        ans = max(ans, mx[left] + right - left + 1)\n        mx[right + 1] = max(mx[right], right - left + 1)\n\n    return ans\n\n\nprizePositions = [1, 1, 2, 2, 3, 3, 5]\nk = 2\nprint(maximizeWin(prizePositions, k))  # 7\n</code></pre>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%A4%A7%E8%BF%9B%E9%98%B6_variable_sliding_window_max_advanced/#2009-minimum-number-of-operations-to-make-array-continuous","title":"2009. Minimum Number of Operations to Make Array Continuous","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Binary Search, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%A4%A7%E8%BF%9B%E9%98%B6_variable_sliding_window_max_advanced/#1610-maximum-number-of-visible-points","title":"1610. Maximum Number of Visible Points","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Geometry, Sliding Window, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%A4%A7%E8%BF%9B%E9%98%B6_variable_sliding_window_max_advanced/#2781-length-of-the-longest-valid-substring","title":"2781. Length of the Longest Valid Substring","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%A4%A7%E8%BF%9B%E9%98%B6_variable_sliding_window_max_advanced/#3411-maximum-subarray-with-equal-products","title":"3411. Maximum Subarray With Equal Products","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Sliding Window, Enumeration, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%A4%A7%E8%BF%9B%E9%98%B6_variable_sliding_window_max_advanced/#2968-apply-operations-to-maximize-frequency-score","title":"2968. Apply Operations to Maximize Frequency Score","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Sliding Window, Sorting, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%A4%A7%E8%BF%9B%E9%98%B6_variable_sliding_window_max_advanced/#1040-moving-stones-until-consecutive-ii","title":"1040. Moving Stones Until Consecutive II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Two Pointers, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%A4%A7%E8%BF%9B%E9%98%B6_variable_sliding_window_max_advanced/#3413-maximum-coins-from-k-consecutive-bags","title":"3413. Maximum Coins From K Consecutive Bags","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Greedy, Sliding Window, Sorting, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%A4%A7%E8%BF%9B%E9%98%B6_variable_sliding_window_max_advanced/#395-longest-substring-with-at-least-k-repeating-characters","title":"395. Longest Substring with At Least K Repeating Characters","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Divide And Conquer, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%A4%A7%E8%BF%9B%E9%98%B6_variable_sliding_window_max_advanced/#1763-longest-nice-substring","title":"1763. Longest Nice Substring","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Divide And Conquer, Bit Manipulation, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%A4%A7%E8%BF%9B%E9%98%B6_variable_sliding_window_max_advanced/#487-max-consecutive-ones-ii","title":"487. Max Consecutive Ones II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%A4%A7%E8%BF%9B%E9%98%B6_variable_sliding_window_max_advanced/#159-longest-substring-with-at-most-two-distinct-characters","title":"159. Longest Substring with At Most Two Distinct Characters \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> Python <pre><code>\"\"\"\n-   Prerequisite: 3. Longest Substring Without Repeating Characters\n\"\"\"\n\nfrom collections import defaultdict\n\n\n# Sliding Window - Variable\ndef lengthOfLongestSubstringTwoDistinct(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 2:\n        return n\n\n    window = defaultdict(int)\n    left, res = 0, 0\n\n    for right in range(n):\n        window[s[right]] += 1\n\n        while len(window) &gt; 2:\n            window[s[left]] -= 1\n            if window[s[left]] == 0:\n                del window[s[left]]\n            left += 1\n\n        res = max(res, right - left + 1)\n\n    return res\n\n\ns = \"ccaabbb\"\nassert lengthOfLongestSubstringTwoDistinct(s) == 5\n</code></pre>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%A4%A7%E8%BF%9B%E9%98%B6_variable_sliding_window_max_advanced/#340-longest-substring-with-at-most-k-distinct-characters","title":"340. Longest Substring with At Most K Distinct Characters \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> Python <pre><code>from collections import defaultdict\n\n\n# Sliding Window Variable\ndef lengthOfLongestSubstringKDistinct(s: str, k: int) -&gt; int:\n    n = len(s)\n    if n &lt;= k:\n        return n\n\n    window = defaultdict(int)\n    left, res = 0, 0\n\n    for right in range(n):\n        window[s[right]] += 1\n        while len(window) &gt; k:\n            window[s[left]] -= 1\n            if window[s[left]] == 0:\n                del window[s[left]]\n            left += 1\n        res = max(res, right - left + 1)\n\n    return res\n\n\ns = \"eceba\"\nk = 2\nassert lengthOfLongestSubstringKDistinct(s, k) == 3\n</code></pre>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%B0%8F_variable_sliding_window_min/","title":"\u4e0d\u5b9a\u957f\u6ed1\u52a8\u7a97\u53e3\u6c42\u5c0f Variable Sliding Window Min","text":""},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%B0%8F_variable_sliding_window_min/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 209. Minimum Size Subarray Sum (Medium)</li> <li> 2904. Shortest and Lexicographically Smallest Beautiful String (Medium)</li> <li> 1234. Replace the Substring for Balanced String (Medium)</li> <li> 2875. Minimum Size Subarray in Infinite Array (Medium)</li> <li> 76. Minimum Window Substring (Hard)</li> <li> 632. Smallest Range Covering Elements from K Lists (Hard)</li> </ul>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%B0%8F_variable_sliding_window_min/#209-minimum-size-subarray-sum","title":"209. Minimum Size Subarray Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Sliding Window, Prefix Sum</p> </li> </ul> Python <pre><code>import bisect\nfrom typing import List\n\n\n# Prefix Sum\ndef minSubArrayLenPS(target: int, nums: List[int]) -&gt; int:\n    n = len(nums)\n    prefix_sums = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        prefix_sums[i] = prefix_sums[i - 1] + nums[i - 1]\n\n    minLen = float(\"inf\")\n\n    for i in range(n + 1):\n        new_target = target + prefix_sums[i]\n        bound = bisect.bisect_left(prefix_sums, new_target)\n        if bound != len(prefix_sums):\n            minLen = min(minLen, bound - i)\n\n    return 0 if minLen == float(\"inf\") else minLen\n\n\n# Sliding Window Variable Size\ndef minSubArrayLenSW(target: int, nums: List[int]) -&gt; int:\n    res, cur = float(\"inf\"), 0\n    left = 0\n\n    for right in range(len(nums)):\n        cur += nums[right]\n\n        while cur &gt;= target:\n            res = min(res, right - left + 1)\n            cur -= nums[left]\n            left += 1\n\n    return res if res != float(\"inf\") else 0\n\n\ntarget = 7\nnums = [2, 3, 1, 2, 4, 3]\nprint(minSubArrayLenPS(target, nums))  # 2\nprint(minSubArrayLenSW(target, nums))  # 2\n</code></pre>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%B0%8F_variable_sliding_window_min/#2904-shortest-and-lexicographically-smallest-beautiful-string","title":"2904. Shortest and Lexicographically Smallest Beautiful String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Sliding Window</p> </li> </ul> Python <pre><code># Sliding Window Variable Size\ndef shortestBeautifulSubstring(s: str, k: int) -&gt; str:\n    n = len(s)\n    left = 0\n    oneCount = 0\n    minLen = float(\"inf\")\n    res = \"\"\n\n    for right in range(n):\n        if s[right] == \"1\":\n            oneCount += 1\n\n        while oneCount == k:\n            size = right - left + 1\n\n            if size &lt; minLen:\n                minLen = size\n                res = s[left : right + 1]\n            elif size == minLen:\n                res = min(res, s[left : right + 1])\n\n            if s[left] == \"1\":\n                oneCount -= 1\n            left += 1\n\n    return res\n\n\ns = \"100011001\"\nk = 3\nprint(shortestBeautifulSubstring(s, k))  # 11001\n</code></pre>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%B0%8F_variable_sliding_window_min/#1234-replace-the-substring-for-balanced-string","title":"1234. Replace the Substring for Balanced String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Sliding Window</p> </li> </ul> Python <pre><code>from collections import Counter\n\n\n# Sliding Window Variable Min\ndef balancedString(s: str) -&gt; int:\n    n = len(s)\n    m = n // 4\n    counts = Counter(s)\n\n    if len(counts) == 4 and min(counts.values()) == m:\n        return 0\n\n    left = 0\n    res = float(\"inf\")\n\n    for right in range(n):\n        counts[s[right]] -= 1\n\n        while max(counts.values()) &lt;= m:\n            res = min(res, right - left + 1)\n            counts[s[left]] += 1\n            left += 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert balancedString(\"QWER\") == 0\n    assert balancedString(\"QQWE\") == 1\n    assert balancedString(\"QQQW\") == 2\n    assert balancedString(\"QQQQ\") == 3\n</code></pre>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%B0%8F_variable_sliding_window_min/#2875-minimum-size-subarray-in-infinite-array","title":"2875. Minimum Size Subarray in Infinite Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Sliding Window, Prefix Sum</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Sliding Window Variable Min\ndef minSizeSubarray(nums: List[int], target: int) -&gt; int:\n    total = sum(nums)\n    n = len(nums)\n    div, mod = divmod(target, total)\n    left, cur, res = 0, 0, float(\"inf\")\n\n    for right in range(n * 2):\n        cur += nums[right % n]\n\n        while cur &gt; mod:\n            cur -= nums[left % n]\n            left += 1\n\n        if cur == mod:\n            res = min(res, right - left + 1)\n\n    return res + div * n if res != float(\"inf\") else -1\n\n\nif __name__ == \"__main__\":\n    assert minSizeSubarray([1, 2, 3], 5) == 2\n    assert minSizeSubarray([1, 1, 1, 2, 3], 4) == 2\n    assert minSizeSubarray([2, 4, 6, 8], 3) == -1\n</code></pre>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%B0%8F_variable_sliding_window_min/#76-minimum-window-substring","title":"76. Minimum Window Substring","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> Python <pre><code>from collections import Counter\n\n\ndef minWindow(s: str, t: str) -&gt; str:\n    if not t or not s:\n        return \"\"\n\n    counts = Counter(t)\n    required = len(counts)\n\n    left, right = 0, 0\n    formed = 0\n    window_counts = dict()\n\n    result = float(\"inf\"), None, None\n\n    while right &lt; len(s):\n        char = s[right]\n        window_counts[char] = window_counts.get(char, 0) + 1\n        if char in counts and window_counts[char] == counts[char]:\n            formed += 1\n\n        while left &lt;= right and formed == required:\n            char = s[left]\n            if right - left + 1 &lt; result[0]:\n                result = (right - left + 1, left, right)\n            window_counts[char] -= 1\n            if char in counts and window_counts[char] &lt; counts[char]:\n                formed -= 1\n            left += 1\n\n        right += 1\n\n    return \"\" if result[0] == float(\"inf\") else s[result[1] : result[2] + 1]\n\n\ns = \"ADOBECODEBANC\"\nt = \"ABC\"\nprint(minWindow(s, t))  # BANC\n</code></pre>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E5%B0%8F_variable_sliding_window_min/#632-smallest-range-covering-elements-from-k-lists","title":"632. Smallest Range Covering Elements from K Lists","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Greedy, Sliding Window, Sorting, Heap Priority Queue</p> </li> </ul> Python <pre><code>from heapq import heapify, heapreplace\nfrom math import inf\nfrom typing import List\n\n\n# Heap\ndef smallestRange(nums: List[List[int]]) -&gt; List[int]:\n    heap = [(arr[0], i, 0) for i, arr in enumerate(nums)]\n    heapify(heap)\n\n    res_l = heap[0][0]\n    res_r = right = max(arr[0] for arr in nums)\n\n    while heap[0][2] + 1 &lt; len(nums[heap[0][1]]):\n        _, i, j = heap[0]\n        x = nums[i][j + 1]\n        heapreplace(heap, (x, i, j + 1))\n        right = max(right, x)\n        left = heap[0][0]\n        if right - left &lt; res_r - res_l:\n            res_l, res_r = left, right\n\n    return [res_l, res_r]\n\n\n# Sliding Window Variable Min\ndef smallestRangeSliding(nums: List[List[int]]) -&gt; List[int]:\n    pairs = sorted((x, i) for (i, arr) in enumerate(nums) for x in arr)\n    res_l, res_r = -inf, inf\n    empty = len(nums)\n    cnt = [0] * empty\n    left = 0\n\n    for r, i in pairs:\n        if cnt[i] == 0:\n            empty -= 1\n        cnt[i] += 1\n        while empty == 0:\n            l, i = pairs[left]\n            if r - l &lt; res_r - res_l:\n                res_l, res_r = l, r\n            cnt[i] -= 1\n            if cnt[i] == 0:\n                empty += 1\n            left += 1\n\n    return [res_l, res_r]\n\n\nif __name__ == \"__main__\":\n    nums = [[4, 10, 15, 24, 26], [0, 9, 12, 20], [5, 18, 22, 30]]\n    assert smallestRange(nums) == [20, 24]\n    assert smallestRangeSliding(nums) == [20, 24]\n</code></pre>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E7%9F%AD_variable_sliding_window_subarrays_shorter/","title":"\u4e0d\u5b9a\u957f\u6ed1\u52a8\u7a97\u53e3\u6c42\u77ed Variable Sliding Window Subarrays Shorter","text":""},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E7%9F%AD_variable_sliding_window_subarrays_shorter/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 713. Subarray Product Less Than K (Medium)</li> <li> 3258. Count Substrings That Satisfy K-Constraint I (Easy)</li> <li> 2302. Count Subarrays With Score Less Than K (Hard)</li> <li> 2762. Continuous Subarrays (Medium)</li> <li> 3134. Find the Median of the Uniqueness Array (Hard)</li> <li> 3261. Count Substrings That Satisfy K-Constraint II (Hard)</li> <li> 2743. Count Substrings Without Repeating Character (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E7%9F%AD_variable_sliding_window_subarrays_shorter/#713-subarray-product-less-than-k","title":"713. Subarray Product Less Than K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Sliding Window, Prefix Sum</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Sliding Window Variable Subarrays Shorter\ndef numSubarrayProductLessThanK(nums: List[int], k: int) -&gt; int:\n    if k &lt;= 1:\n        return 0\n\n    left = 0\n    prod = 1\n    res = 0\n\n    for right in range(len(nums)):\n        prod *= nums[right]\n\n        while prod &gt;= k:\n            prod //= nums[left]\n            left += 1\n\n        res += right - left + 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert numSubarrayProductLessThanK([10, 5, 2, 6], 100) == 8\n    assert numSubarrayProductLessThanK([1, 2, 3], 0) == 0\n    assert numSubarrayProductLessThanK([1, 2, 3], 1) == 0\n    assert numSubarrayProductLessThanK([1, 2, 3], 2) == 1\n    assert numSubarrayProductLessThanK([1, 2, 3], 3) == 3\n</code></pre>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E7%9F%AD_variable_sliding_window_subarrays_shorter/#3258-count-substrings-that-satisfy-k-constraint-i","title":"3258. Count Substrings That Satisfy K-Constraint I","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E7%9F%AD_variable_sliding_window_subarrays_shorter/#2302-count-subarrays-with-score-less-than-k","title":"2302. Count Subarrays With Score Less Than K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Sliding Window, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E7%9F%AD_variable_sliding_window_subarrays_shorter/#2762-continuous-subarrays","title":"2762. Continuous Subarrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Queue, Sliding Window, Heap Priority Queue, Ordered Set, Monotonic Queue</p> </li> </ul>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E7%9F%AD_variable_sliding_window_subarrays_shorter/#3134-find-the-median-of-the-uniqueness-array","title":"3134. Find the Median of the Uniqueness Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Binary Search, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E7%9F%AD_variable_sliding_window_subarrays_shorter/#3261-count-substrings-that-satisfy-k-constraint-ii","title":"3261. Count Substrings That Satisfy K-Constraint II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Binary Search, Sliding Window, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E7%9F%AD_variable_sliding_window_subarrays_shorter/#2743-count-substrings-without-repeating-character","title":"2743. Count Substrings Without Repeating Character \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E7%B2%BE_variable_sliding_window_subarrays_exact/","title":"\u4e0d\u5b9a\u957f\u6ed1\u52a8\u7a97\u53e3\u6c42\u7cbe Variable Sliding Window Subarrays Exact","text":""},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E7%B2%BE_variable_sliding_window_subarrays_exact/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 930. Binary Subarrays With Sum (Medium)</li> <li> 1248. Count Number of Nice Subarrays (Medium)</li> <li> 3305. Count of Substrings Containing Every Vowel and K Consonants I (Medium)</li> <li> 3306. Count of Substrings Containing Every Vowel and K Consonants II (Medium)</li> <li> 992. Subarrays with K Different Integers (Hard)</li> </ul>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E7%B2%BE_variable_sliding_window_subarrays_exact/#930-binary-subarrays-with-sum","title":"930. Binary Subarrays With Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Sliding Window, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E7%B2%BE_variable_sliding_window_subarrays_exact/#1248-count-number-of-nice-subarrays","title":"1248. Count Number of Nice Subarrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Sliding Window, Prefix Sum</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Prefix Sum\ndef numberOfSubarrays(nums: List[int], k: int) -&gt; int:\n    count = 0\n    odd_counts = {0: 1}  # odd_count -&gt; count\n    odd_count = 0\n\n    for num in nums:\n        if num % 2 == 1:\n            odd_count += 1\n        if odd_count - k in odd_counts:\n            count += odd_counts[odd_count - k]\n        if odd_count in odd_counts:\n            odd_counts[odd_count] += 1\n        else:\n            odd_counts[odd_count] = 1\n\n    return count\n\n\nnums = [1, 1, 2, 1, 1]\nk = 3\nprint(numberOfSubarrays(nums, k))  # 2\n</code></pre>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E7%B2%BE_variable_sliding_window_subarrays_exact/#3305-count-of-substrings-containing-every-vowel-and-k-consonants-i","title":"3305. Count of Substrings Containing Every Vowel and K Consonants I","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> Python <pre><code>from collections import defaultdict\n\n\n# Sliding Window Variable Subarrays Exact\ndef countOfSubstrings(word: str, k: int) -&gt; int:\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\"}\n    n = len(word)\n\n    def count(m: int) -&gt; int:\n        occur = defaultdict(int)\n        valid_vow_cnt, con_cnt = 0, 0\n        left = 0\n        res = 0\n\n        for right in range(n):\n            while left &lt; n and (con_cnt &lt; m or valid_vow_cnt &lt; 5):\n                if word[left] in vowels:\n                    if occur[word[left]] == 0:\n                        valid_vow_cnt += 1\n                    occur[word[left]] += 1\n                else:\n                    con_cnt += 1\n                left += 1\n\n            if con_cnt &gt;= m and valid_vow_cnt == 5:\n                res += n - left + 1\n\n            if word[right] in vowels:\n                occur[word[right]] -= 1\n                if occur[word[right]] == 0:\n                    valid_vow_cnt -= 1\n            else:\n                con_cnt -= 1\n\n        return res\n\n    return count(k) - count(k + 1)\n\n\nword = \"ieaouqqieaouqq\"\nk = 1\nprint(countOfSubstrings(word, k))  # 3\n</code></pre>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E7%B2%BE_variable_sliding_window_subarrays_exact/#3306-count-of-substrings-containing-every-vowel-and-k-consonants-ii","title":"3306. Count of Substrings Containing Every Vowel and K Consonants II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> Python <pre><code>from collections import defaultdict\n\n\n# Sliding Window Variable Subarrays Exact\ndef countOfSubstrings(word: str, k: int) -&gt; int:\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\"}\n    n = len(word)\n\n    def count(m: int) -&gt; int:\n        occur = defaultdict(int)\n        valid_vow_cnt, con_cnt = 0, 0\n        left = 0\n        res = 0\n\n        for right in range(n):\n            while left &lt; n and (con_cnt &lt; m or valid_vow_cnt &lt; 5):\n                if word[left] in vowels:\n                    if occur[word[left]] == 0:\n                        valid_vow_cnt += 1\n                    occur[word[left]] += 1\n                else:\n                    con_cnt += 1\n                left += 1\n\n            if con_cnt &gt;= m and valid_vow_cnt == 5:\n                res += n - left + 1\n\n            if word[right] in vowels:\n                occur[word[right]] -= 1\n                if occur[word[right]] == 0:\n                    valid_vow_cnt -= 1\n            else:\n                con_cnt -= 1\n\n        return res\n\n    return count(k) - count(k + 1)\n\n\nword = \"ieaouqqieaouqq\"\nk = 1\nprint(countOfSubstrings(word, k))  # 3\n</code></pre>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E7%B2%BE_variable_sliding_window_subarrays_exact/#992-subarrays-with-k-different-integers","title":"992. Subarrays with K Different Integers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Sliding Window, Counting</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Sliding Window - Variable\ndef subarraysWithKDistinct(nums: List[int], k: int) -&gt; int:\n    def atMost(k: int) -&gt; int:\n        count = 0\n        left = 0\n        freq = {}\n\n        for right in range(len(nums)):\n            if nums[right] not in freq:\n                freq[nums[right]] = 0\n            freq[nums[right]] += 1\n\n            while len(freq) &gt; k:\n                freq[nums[left]] -= 1\n                if freq[nums[left]] == 0:\n                    del freq[nums[left]]\n                left += 1\n\n            count += right - left + 1\n\n        return count\n\n    return atMost(k) - atMost(k - 1)\n\n\nnums = [1, 2, 1, 2, 3]\nk = 2\nprint(subarraysWithKDistinct(nums, k))  # 7\n</code></pre>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E9%95%BF_variable_sliding_window_subarrays_longer/","title":"\u4e0d\u5b9a\u957f\u6ed1\u52a8\u7a97\u53e3\u6c42\u957f Variable Sliding Window Subarrays Longer","text":""},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E9%95%BF_variable_sliding_window_subarrays_longer/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1358. Number of Substrings Containing All Three Characters (Medium)</li> <li> 2962. Count Subarrays Where Max Element Appears at Least K Times (Medium)</li> <li> 3325. Count Substrings With K-Frequency Characters I (Medium)</li> <li> 2799. Count Complete Subarrays in an Array (Medium)</li> <li> 2537. Count the Number of Good Subarrays (Medium)</li> <li> 3298. Count Substrings That Can Be Rearranged to Contain a String II (Hard)</li> <li> 2495. Number of Subarrays Having Even Product (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E9%95%BF_variable_sliding_window_subarrays_longer/#1358-number-of-substrings-containing-all-three-characters","title":"1358. Number of Substrings Containing All Three Characters","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> Python <pre><code>from collections import defaultdict\n\n\n# Sliding Window Variable Size\ndef numberOfSubstrings(s: str) -&gt; int:\n    freqs = defaultdict(int)\n    res = 0\n    left = 0\n\n    for right in range(len(s)):\n        freqs[s[right]] += 1\n\n        while len(freqs) == 3:\n            freqs[s[left]] -= 1\n            if freqs[s[left]] == 0:\n                del freqs[s[left]]\n            left += 1\n\n        res += left\n\n    return res\n\n\ns = \"abcabc\"\nprint(numberOfSubstrings(s))  # 10\n</code></pre>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E9%95%BF_variable_sliding_window_subarrays_longer/#2962-count-subarrays-where-max-element-appears-at-least-k-times","title":"2962. Count Subarrays Where Max Element Appears at Least K Times","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E9%95%BF_variable_sliding_window_subarrays_longer/#3325-count-substrings-with-k-frequency-characters-i","title":"3325. Count Substrings With K-Frequency Characters I","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E9%95%BF_variable_sliding_window_subarrays_longer/#2799-count-complete-subarrays-in-an-array","title":"2799. Count Complete Subarrays in an Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E9%95%BF_variable_sliding_window_subarrays_longer/#2537-count-the-number-of-good-subarrays","title":"2537. Count the Number of Good Subarrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E9%95%BF_variable_sliding_window_subarrays_longer/#3298-count-substrings-that-can-be-rearranged-to-contain-a-string-ii","title":"3298. Count Substrings That Can Be Rearranged to Contain a String II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B1%82%E9%95%BF_variable_sliding_window_subarrays_longer/#2495-number-of-subarrays-having-even-product","title":"2495. Number of Subarrays Having Even Product \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/%E5%88%86%E7%BB%84%E5%BE%AA%E7%8E%AF_grouped_loop/","title":"\u5206\u7ec4\u5faa\u73af Grouped Loop","text":""},{"location":"EndlessCheng/%E5%88%86%E7%BB%84%E5%BE%AA%E7%8E%AF_grouped_loop/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 485. Max Consecutive Ones (Easy)</li> <li> 1446. Consecutive Characters (Easy)</li> <li> 1869. Longer Contiguous Segments of Ones than Zeros (Easy)</li> <li> 2414. Length of the Longest Alphabetical Continuous Substring (Medium)</li> <li> 3456. Find Special Substring of Length K (Easy)</li> <li> 2273. Find Resultant Array After Removing Anagrams (Easy)</li> <li> 2348. Number of Zero-Filled Subarrays (Medium)</li> <li> 1513. Number of Substrings With Only 1s (Medium)</li> <li> 1957. Delete Characters to Make Fancy String (Easy)</li> <li> 674. Longest Continuous Increasing Subsequence (Easy)</li> <li> 696. Count Binary Substrings (Easy)</li> <li> 978. Longest Turbulent Subarray (Medium)</li> <li> 2110. Number of Smooth Descent Periods of a Stock (Medium)</li> <li> 228. Summary Ranges (Easy)</li> <li> 2760. Longest Even Odd Subarray With Threshold (Easy)</li> <li> 1887. Reduction Operations to Make the Array Elements Equal (Medium)</li> <li> 845. Longest Mountain in Array (Medium)</li> <li> 2038. Remove Colored Pieces if Both Neighbors are the Same Color (Medium)</li> <li> 2900. Longest Unequal Adjacent Groups Subsequence I (Easy)</li> <li> 1759. Count Number of Homogenous Substrings (Medium)</li> <li> 3011. Find if Array Can Be Sorted (Medium)</li> <li> 1578. Minimum Time to Make Rope Colorful (Medium)</li> <li> 1839. Longest Substring Of All Vowels in Order (Medium)</li> <li> 2765. Longest Alternating Subarray (Easy)</li> <li> 3255. Find the Power of K-Size Subarrays II (Medium)</li> <li> 3350. Adjacent Increasing Subarrays Detection II (Medium)</li> <li> 3105. Longest Strictly Increasing or Strictly Decreasing Subarray (Easy)</li> <li> 838. Push Dominoes (Medium)</li> <li> 467. Unique Substrings in Wraparound String (Medium)</li> <li> 413. Arithmetic Slices (Medium)</li> <li> 68. Text Justification (Hard)</li> <li> 135. Candy (Hard)</li> <li> 2948. Make Lexicographically Smallest Array by Swapping Elements (Medium)</li> <li> 2593. Find Score of an Array After Marking All Elements (Medium)</li> <li> 2393. Count Strictly Increasing Subarrays (Medium) \ud83d\udc51</li> <li> 2436. Minimum Split Into Subarrays With GCD Greater Than One (Medium) \ud83d\udc51</li> <li> 2495. Number of Subarrays Having Even Product (Medium) \ud83d\udc51</li> <li> 3063. Linked List Frequency (Easy) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/%E5%88%86%E7%BB%84%E5%BE%AA%E7%8E%AF_grouped_loop/#485-max-consecutive-ones","title":"485. Max Consecutive Ones","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array</p> </li> </ul>"},{"location":"EndlessCheng/%E5%88%86%E7%BB%84%E5%BE%AA%E7%8E%AF_grouped_loop/#1446-consecutive-characters","title":"1446. Consecutive Characters","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String</p> </li> </ul>"},{"location":"EndlessCheng/%E5%88%86%E7%BB%84%E5%BE%AA%E7%8E%AF_grouped_loop/#1869-longer-contiguous-segments-of-ones-than-zeros","title":"1869. Longer Contiguous Segments of Ones than Zeros","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String</p> </li> </ul>"},{"location":"EndlessCheng/%E5%88%86%E7%BB%84%E5%BE%AA%E7%8E%AF_grouped_loop/#2414-length-of-the-longest-alphabetical-continuous-substring","title":"2414. Length of the Longest Alphabetical Continuous Substring","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String</p> </li> </ul>"},{"location":"EndlessCheng/%E5%88%86%E7%BB%84%E5%BE%AA%E7%8E%AF_grouped_loop/#3456-find-special-substring-of-length-k","title":"3456. Find Special Substring of Length K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String</p> </li> </ul>"},{"location":"EndlessCheng/%E5%88%86%E7%BB%84%E5%BE%AA%E7%8E%AF_grouped_loop/#2273-find-resultant-array-after-removing-anagrams","title":"2273. Find Resultant Array After Removing Anagrams","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/%E5%88%86%E7%BB%84%E5%BE%AA%E7%8E%AF_grouped_loop/#2348-number-of-zero-filled-subarrays","title":"2348. Number of Zero-Filled Subarrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math</p> </li> </ul>"},{"location":"EndlessCheng/%E5%88%86%E7%BB%84%E5%BE%AA%E7%8E%AF_grouped_loop/#1513-number-of-substrings-with-only-1s","title":"1513. Number of Substrings With Only 1s","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String</p> </li> </ul>"},{"location":"EndlessCheng/%E5%88%86%E7%BB%84%E5%BE%AA%E7%8E%AF_grouped_loop/#1957-delete-characters-to-make-fancy-string","title":"1957. Delete Characters to Make Fancy String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String</p> </li> </ul>"},{"location":"EndlessCheng/%E5%88%86%E7%BB%84%E5%BE%AA%E7%8E%AF_grouped_loop/#674-longest-continuous-increasing-subsequence","title":"674. Longest Continuous Increasing Subsequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef findLengthOfLCIS(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return n\n\n    dp = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        if nums[i] &gt; nums[i - 1]:\n            dp[i] = dp[i - 1] + 1\n\n    return max(dp)\n\n\nprint(findLengthOfLCIS([1, 3, 5, 4, 7]))  # 3\n</code></pre>"},{"location":"EndlessCheng/%E5%88%86%E7%BB%84%E5%BE%AA%E7%8E%AF_grouped_loop/#696-count-binary-substrings","title":"696. Count Binary Substrings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String</p> </li> </ul>"},{"location":"EndlessCheng/%E5%88%86%E7%BB%84%E5%BE%AA%E7%8E%AF_grouped_loop/#978-longest-turbulent-subarray","title":"978. Longest Turbulent Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Sliding Window</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxTurbulenceSize(arr: List[int]) -&gt; int:\n    n = len(arr)\n    up = [1 for _ in range(n)]\n    down = [1 for _ in range(n)]\n    maxLen = 1\n\n    for i in range(1, n):\n        if arr[i - 1] &lt; arr[i]:\n            up[i] = down[i - 1] + 1\n            down[i] = 1\n        elif arr[i - 1] &gt; arr[i]:\n            down[i] = up[i - 1] + 1\n            up[i] = 1\n        else:\n            up[i] = 1\n            down[i] = 1\n\n        maxLen = max(maxLen, up[i], down[i])\n\n    return maxLen\n\n\narr = [9, 4, 2, 10, 7, 8, 8, 1, 9]\nprint(maxTurbulenceSize(arr))  # 5\n</code></pre>"},{"location":"EndlessCheng/%E5%88%86%E7%BB%84%E5%BE%AA%E7%8E%AF_grouped_loop/#2110-number-of-smooth-descent-periods-of-a-stock","title":"2110. Number of Smooth Descent Periods of a Stock","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/%E5%88%86%E7%BB%84%E5%BE%AA%E7%8E%AF_grouped_loop/#228-summary-ranges","title":"228. Summary Ranges","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Variable Sliding Window\ndef summaryRanges(nums: List[int]) -&gt; List[str]:\n    left, right = 0, 0\n    n = len(nums)\n    res = []\n\n    while left &lt; n:\n        while right + 1 &lt; n and nums[right] + 1 == nums[right + 1]:\n            right += 1\n\n        if left == right:\n            res.append(f\"{nums[left]}\")\n        else:\n            res.append(f\"{nums[left]}-&gt;{nums[right]}\")\n\n        right += 1\n        left = right\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(summaryRanges([0, 1, 2, 4, 5, 7]))\n    # [\"0-&gt;2\", \"4-&gt;5\", \"7\"]\n    print(summaryRanges([0, 2, 3, 4, 6, 8, 9]))\n    # [\"0\", \"2-&gt;4\", \"6\", \"8-&gt;9\"]\n</code></pre>"},{"location":"EndlessCheng/%E5%88%86%E7%BB%84%E5%BE%AA%E7%8E%AF_grouped_loop/#2760-longest-even-odd-subarray-with-threshold","title":"2760. Longest Even Odd Subarray With Threshold","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/%E5%88%86%E7%BB%84%E5%BE%AA%E7%8E%AF_grouped_loop/#1887-reduction-operations-to-make-the-array-elements-equal","title":"1887. Reduction Operations to Make the Array Elements Equal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/%E5%88%86%E7%BB%84%E5%BE%AA%E7%8E%AF_grouped_loop/#845-longest-mountain-in-array","title":"845. Longest Mountain in Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Dynamic Programming, Enumeration</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef longestMountain(arr: List[int]) -&gt; int:\n    n = len(arr)\n    res = 0\n    left = 0\n\n    while left &lt; n:\n        right = left\n\n        if right &lt; n - 1 and arr[right] &lt; arr[right + 1]:\n            while right &lt; n - 1 and arr[right] &lt; arr[right + 1]:\n                right += 1\n\n            if right &lt; n - 1 and arr[right] &gt; arr[right + 1]:\n                while right &lt; n - 1 and arr[right] &gt; arr[right + 1]:\n                    right += 1\n                res = max(res, right - left + 1)\n\n        left = max(right, left + 1)\n\n    return res\n\n\narr = [2, 1, 4, 7, 3, 2, 5]\nprint(longestMountain(arr))  # 5\n</code></pre>"},{"location":"EndlessCheng/%E5%88%86%E7%BB%84%E5%BE%AA%E7%8E%AF_grouped_loop/#2038-remove-colored-pieces-if-both-neighbors-are-the-same-color","title":"2038. Remove Colored Pieces if Both Neighbors are the Same Color","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String, Greedy, Game Theory</p> </li> </ul>"},{"location":"EndlessCheng/%E5%88%86%E7%BB%84%E5%BE%AA%E7%8E%AF_grouped_loop/#2900-longest-unequal-adjacent-groups-subsequence-i","title":"2900. Longest Unequal Adjacent Groups Subsequence I","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Dynamic Programming, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/%E5%88%86%E7%BB%84%E5%BE%AA%E7%8E%AF_grouped_loop/#1759-count-number-of-homogenous-substrings","title":"1759. Count Number of Homogenous Substrings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String</p> </li> </ul>"},{"location":"EndlessCheng/%E5%88%86%E7%BB%84%E5%BE%AA%E7%8E%AF_grouped_loop/#3011-find-if-array-can-be-sorted","title":"3011. Find if Array Can Be Sorted","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/%E5%88%86%E7%BB%84%E5%BE%AA%E7%8E%AF_grouped_loop/#1578-minimum-time-to-make-rope-colorful","title":"1578. Minimum Time to Make Rope Colorful","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Dynamic Programming, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/%E5%88%86%E7%BB%84%E5%BE%AA%E7%8E%AF_grouped_loop/#1839-longest-substring-of-all-vowels-in-order","title":"1839. Longest Substring Of All Vowels in Order","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/%E5%88%86%E7%BB%84%E5%BE%AA%E7%8E%AF_grouped_loop/#2765-longest-alternating-subarray","title":"2765. Longest Alternating Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/%E5%88%86%E7%BB%84%E5%BE%AA%E7%8E%AF_grouped_loop/#3255-find-the-power-of-k-size-subarrays-ii","title":"3255. Find the Power of K-Size Subarrays II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/%E5%88%86%E7%BB%84%E5%BE%AA%E7%8E%AF_grouped_loop/#3350-adjacent-increasing-subarrays-detection-ii","title":"3350. Adjacent Increasing Subarrays Detection II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul>"},{"location":"EndlessCheng/%E5%88%86%E7%BB%84%E5%BE%AA%E7%8E%AF_grouped_loop/#3105-longest-strictly-increasing-or-strictly-decreasing-subarray","title":"3105. Longest Strictly Increasing or Strictly Decreasing Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array</p> </li> </ul>"},{"location":"EndlessCheng/%E5%88%86%E7%BB%84%E5%BE%AA%E7%8E%AF_grouped_loop/#838-push-dominoes","title":"838. Push Dominoes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/%E5%88%86%E7%BB%84%E5%BE%AA%E7%8E%AF_grouped_loop/#467-unique-substrings-in-wraparound-string","title":"467. Unique Substrings in Wraparound String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/%E5%88%86%E7%BB%84%E5%BE%AA%E7%8E%AF_grouped_loop/#413-arithmetic-slices","title":"413. Arithmetic Slices","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/%E5%88%86%E7%BB%84%E5%BE%AA%E7%8E%AF_grouped_loop/#68-text-justification","title":"68. Text Justification","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Simulation</p> </li> </ul>"},{"location":"EndlessCheng/%E5%88%86%E7%BB%84%E5%BE%AA%E7%8E%AF_grouped_loop/#135-candy","title":"135. Candy","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the minimum number of candies you must give.\n\"\"\"\n\nfrom typing import List\n\n\n# Greedy\ndef candy(ratings: List[int]) -&gt; int:\n    # TC: O(n)\n    # SC: O(n)\n    n = len(ratings)\n\n    if n &lt;= 1:\n        return n\n\n    candy = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        if ratings[i] &gt; ratings[i - 1]:\n            candy[i] = candy[i - 1] + 1\n\n    for j in range(n - 2, -1, -1):\n        if ratings[j] &gt; ratings[j + 1]:\n            candy[j] = max(candy[j], candy[j + 1] + 1)\n\n    return sum(candy)\n\n\nratings = [1, 0, 2]\nprint(candy(ratings))  # 5\n</code></pre>"},{"location":"EndlessCheng/%E5%88%86%E7%BB%84%E5%BE%AA%E7%8E%AF_grouped_loop/#2948-make-lexicographically-smallest-array-by-swapping-elements","title":"2948. Make Lexicographically Smallest Array by Swapping Elements","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Union Find, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/%E5%88%86%E7%BB%84%E5%BE%AA%E7%8E%AF_grouped_loop/#2593-find-score-of-an-array-after-marking-all-elements","title":"2593. Find Score of an Array After Marking All Elements","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Sorting, Heap Priority Queue, Simulation</p> </li> </ul>"},{"location":"EndlessCheng/%E5%88%86%E7%BB%84%E5%BE%AA%E7%8E%AF_grouped_loop/#2393-count-strictly-increasing-subarrays","title":"2393. Count Strictly Increasing Subarrays \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/%E5%88%86%E7%BB%84%E5%BE%AA%E7%8E%AF_grouped_loop/#2436-minimum-split-into-subarrays-with-gcd-greater-than-one","title":"2436. Minimum Split Into Subarrays With GCD Greater Than One \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming, Greedy, Number Theory</p> </li> </ul>"},{"location":"EndlessCheng/%E5%88%86%E7%BB%84%E5%BE%AA%E7%8E%AF_grouped_loop/#2495-number-of-subarrays-having-even-product","title":"2495. Number of Subarrays Having Even Product \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Dynamic Programming</p> </li> </ul>"},{"location":"EndlessCheng/%E5%88%86%E7%BB%84%E5%BE%AA%E7%8E%AF_grouped_loop/#3063-linked-list-frequency","title":"3063. Linked List Frequency \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Linked List, Counting</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E5%8E%9F%E5%9C%B0%E4%BF%AE%E6%94%B9_one_sequence_two_pointers_in-place_modification/","title":"\u5355\u5e8f\u5217\u539f\u5730\u4fee\u6539 One Sequence Two Pointers In-Place Modification","text":""},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E5%8E%9F%E5%9C%B0%E4%BF%AE%E6%94%B9_one_sequence_two_pointers_in-place_modification/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 27. Remove Element (Easy)</li> <li> 26. Remove Duplicates from Sorted Array (Easy)</li> <li> 80. Remove Duplicates from Sorted Array II (Medium)</li> <li> 2273. Find Resultant Array After Removing Anagrams (Easy)</li> <li> 283. Move Zeroes (Easy)</li> <li> 905. Sort Array By Parity (Easy)</li> <li> 922. Sort Array By Parity II (Easy)</li> <li> 2460. Apply Operations to an Array (Easy)</li> <li> 1089. Duplicate Zeros (Easy)</li> <li> 75. Sort Colors (Medium)</li> </ul>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E5%8E%9F%E5%9C%B0%E4%BF%AE%E6%94%B9_one_sequence_two_pointers_in-place_modification/#27-remove-element","title":"27. Remove Element","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Remove all instances of a given value in-place.\n\"\"\"\n\nfrom typing import List\n\n\n# Fast Slow Pointers\ndef removeElement(nums: List[int], val: int) -&gt; int:\n    fast, slow = 0, 0\n\n    while fast &lt; len(nums):\n        if nums[fast] != val:\n            nums[slow] = nums[fast]\n            slow += 1\n        fast += 1\n\n    return slow\n\n\nnums = [0, 1, 2, 2, 3, 0, 4, 2]\nval = 2\nprint(removeElement(nums, val))  # 5\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// Fast Slow Pointers\nint removeElement(vector&lt;int&gt;&amp; nums, int val) {\n    size_t n = nums.size();\n    size_t slow = 0, fast = 0;\n\n    while (fast &lt; n) {\n        if (nums[fast] != val) {\n            nums[slow] = nums[fast];\n            slow++;\n        }\n        fast++;\n    }\n    return (int)slow;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {3, 2, 2, 3};\n    int val = 3;\n    cout &lt;&lt; removeElement(nums, val) &lt;&lt; endl;  // 2\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E5%8E%9F%E5%9C%B0%E4%BF%AE%E6%94%B9_one_sequence_two_pointers_in-place_modification/#26-remove-duplicates-from-sorted-array","title":"26. Remove Duplicates from Sorted Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Remove duplicates in-place.\n\"\"\"\n\nfrom typing import List\n\n\ndef removeDuplicates(nums: List[int]) -&gt; int:\n    fast, slow = 1, 1\n\n    while fast &lt; len(nums):\n        if nums[fast] != nums[fast - 1]:\n            nums[slow] = nums[fast]\n            slow += 1\n        fast += 1\n\n    return slow\n\n\nnums = [1, 1, 2]\nprint(removeDuplicates(nums))  # 2\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int removeDuplicates(vector&lt;int&gt;&amp; nums) {\n        int fast = 1, slow = 1;\n        int n = nums.size();\n\n        while (fast &lt; n) {\n            if (nums[fast] != nums[fast - 1]) {\n                nums[slow] = nums[fast];\n                slow++;\n            }\n            fast++;\n        }\n        return slow;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; nums = {0, 0, 1, 1, 1, 2, 2, 3, 3, 4};\n    assert(solution.removeDuplicates(nums) == 5);\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E5%8E%9F%E5%9C%B0%E4%BF%AE%E6%94%B9_one_sequence_two_pointers_in-place_modification/#80-remove-duplicates-from-sorted-array-ii","title":"80. Remove Duplicates from Sorted Array II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Allow at most two duplicates.\n-   fast pointer: explore the array\n-   slow pointer: point to the position to be replaced\n\"\"\"\n\nfrom typing import List\n\n\ndef removeDuplicates(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 2:\n        return len(nums)\n\n    fast, slow = 2, 2\n\n    while fast &lt; len(nums):\n        if nums[fast] != nums[slow - 2]:\n            nums[slow] = nums[fast]\n            slow += 1\n        fast += 1\n\n    return slow\n\n\nnums = [1, 1, 1, 2, 2, 3]\nprint(removeDuplicates(nums))\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int removeDuplicates(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n        if (n &lt;= 2) return n;\n\n        int fast = 2, slow = 2;\n\n        while (fast &lt; n) {\n            if (nums[fast] != nums[slow - 2]) {\n                nums[slow] = nums[fast];\n                slow++;\n            }\n            fast++;\n        }\n        return slow;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; nums = {0, 0, 1, 1, 1, 1, 2, 2, 3, 3, 4};\n    assert(solution.removeDuplicates(nums) == 9);\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E5%8E%9F%E5%9C%B0%E4%BF%AE%E6%94%B9_one_sequence_two_pointers_in-place_modification/#2273-find-resultant-array-after-removing-anagrams","title":"2273. Find Resultant Array After Removing Anagrams","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E5%8E%9F%E5%9C%B0%E4%BF%AE%E6%94%B9_one_sequence_two_pointers_in-place_modification/#283-move-zeroes","title":"283. Move Zeroes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Move all zeroes to the end of the array while maintaining the relative order of the non-zero elements.\n\"\"\"\n\nfrom typing import List\n\n\ndef moveZeroes(nums: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    fast, slow = 0, 0\n\n    while fast &lt; len(nums):\n        if nums[fast] != 0:\n            nums[slow], nums[fast] = nums[fast], nums[slow]\n            slow += 1\n        fast += 1\n\n\nnums = [0, 1, 0, 3, 12]\nmoveZeroes(nums)\nprint(nums)  # [1, 3, 12, 0, 0]\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvoid moveZeroes(vector&lt;int&gt;&amp; nums) {\n    size_t n = nums.size();\n    size_t fast = 0, slow = 0;\n\n    while (fast &lt; n) {\n        if (nums[fast] != 0) {\n            swap(nums[slow], nums[fast]);\n            slow++;\n        }\n        fast++;\n    }\n}\n\nint main() {\n    vector&lt;int&gt; nums = {0, 1, 0, 3, 12};\n    moveZeroes(nums);\n    // [1, 3, 12, 0, 0]\n    for (size_t i = 0; i &lt; nums.size(); i++) {\n        cout &lt;&lt; nums[i] &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E5%8E%9F%E5%9C%B0%E4%BF%AE%E6%94%B9_one_sequence_two_pointers_in-place_modification/#905-sort-array-by-parity","title":"905. Sort Array By Parity","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Sorting</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef sortArrayByParityLR(nums: List[int]) -&gt; List[int]:\n    left, right = 0, len(nums) - 1\n\n    while left &lt; right:\n        if not nums[left] % 2:\n            left += 1\n        else:\n            while left &lt; right and nums[right] % 2:\n                right -= 1\n            nums[left], nums[right] = nums[right], nums[left]\n\n    return nums\n\n\n# Fast Slow Pointers\ndef sortArrayByParityFS(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    fast, slow = 0, 0\n\n    while fast &lt; n:\n        if not nums[fast] % 2:\n            nums[slow], nums[fast] = nums[fast], nums[slow]\n            slow += 1\n        fast += 1\n\n    return nums\n\n\nnums = [3, 1, 2, 4]\nprint(sortArrayByParityLR(nums))  # [4, 2, 1, 3]\nprint(sortArrayByParityFS(nums))  # [4, 2, 1, 3]\n</code></pre>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E5%8E%9F%E5%9C%B0%E4%BF%AE%E6%94%B9_one_sequence_two_pointers_in-place_modification/#922-sort-array-by-parity-ii","title":"922. Sort Array By Parity II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E5%8E%9F%E5%9C%B0%E4%BF%AE%E6%94%B9_one_sequence_two_pointers_in-place_modification/#2460-apply-operations-to-an-array","title":"2460. Apply Operations to an Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Simulation</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E5%8E%9F%E5%9C%B0%E4%BF%AE%E6%94%B9_one_sequence_two_pointers_in-place_modification/#1089-duplicate-zeros","title":"1089. Duplicate Zeros","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers</p> </li> </ul> Python <pre><code>\"\"\"\n-   Duplicate each occurrence of zero, shifting the remaining elements to the right.\n\"\"\"\n\nfrom typing import List\n\n\ndef duplicateZeros(arr: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify arr in-place instead.\n    \"\"\"\n    n = len(arr)\n    fast, slow = 0, 0\n\n    # First pass: find the position\n    # where the last element would be in the expanded array\n    while fast &lt; n:\n        if arr[slow] == 0:\n            fast += 1\n        slow += 1\n        fast += 1\n\n    slow -= 1\n    fast -= 1\n\n    # Second pass: move elements backwards\n    while slow &gt;= 0:\n        if fast &lt; n:\n            arr[fast] = arr[slow]\n\n        if arr[slow] == 0:\n            fast -= 1\n            if fast &lt; n:\n                arr[fast] = 0\n\n        slow -= 1\n        fast -= 1\n\n\narr = [1, 0, 2, 3, 0, 4, 5, 0]\nduplicateZeros(arr)\nprint(arr)  # [1, 0, 0, 2, 3, 0, 0, 4]\n</code></pre>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E5%8E%9F%E5%9C%B0%E4%BF%AE%E6%94%B9_one_sequence_two_pointers_in-place_modification/#75-sort-colors","title":"75. Sort Colors","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Sorting</p> </li> </ul> Python <pre><code>from copy import deepcopy\nfrom typing import List\n\n\n# Left Right Pointers\ndef sort_colors_lr_pointers(nums: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    n = len(nums)\n    left = 0\n    for right in range(n):\n        if nums[right] == 0:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n\n    for right in range(left, n):\n        if nums[right] == 1:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n\n\n# Three Pointers\ndef sort_colors_three_pointers(nums: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    cur = 0\n\n    while cur &lt;= right:\n        if nums[cur] == 0:\n            nums[left], nums[cur] = nums[cur], nums[left]\n            left += 1\n            cur += 1\n        elif nums[cur] == 2:\n            nums[right], nums[cur] = nums[cur], nums[right]\n            right -= 1\n        else:\n            cur += 1\n\n\nnums = [2, 0, 2, 1, 1, 0]\nnums1, nums2 = deepcopy(nums), deepcopy(nums)\nsort_colors_lr_pointers(nums1)\nprint(nums1)  # [0, 0, 1, 1, 2, 2]\nsort_colors_three_pointers(nums2)\nprint(nums2)  # [0, 0, 1, 1, 2, 2]\n</code></pre>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E5%90%8C%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_same_direction/","title":"\u5355\u5e8f\u5217\u540c\u5411\u53cc\u6307\u9488 One Sequence Two Pointers Same Direction","text":""},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E5%90%8C%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_same_direction/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 611. Valid Triangle Number (Medium)</li> <li> 1574. Shortest Subarray to be Removed to Make Array Sorted (Medium)</li> <li> 2972. Count the Number of Incremovable Subarrays II (Hard)</li> <li> 2122. Recover the Original Array (Hard)</li> <li> 2234. Maximum Total Beauty of the Gardens (Hard)</li> <li> 1989. Maximum Number of People That Can Be Caught in Tag (Medium) \ud83d\udc51</li> <li> 3323. Minimize Connected Groups by Inserting Interval (Medium) \ud83d\udc51</li> <li> 581. Shortest Unsorted Continuous Subarray (Medium)</li> </ul>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E5%90%8C%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_same_direction/#611-valid-triangle-number","title":"611. Valid Triangle Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E5%90%8C%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_same_direction/#1574-shortest-subarray-to-be-removed-to-make-array-sorted","title":"1574. Shortest Subarray to be Removed to Make Array Sorted","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Stack, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E5%90%8C%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_same_direction/#2972-count-the-number-of-incremovable-subarrays-ii","title":"2972. Count the Number of Incremovable Subarrays II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E5%90%8C%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_same_direction/#2122-recover-the-original-array","title":"2122. Recover the Original Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Two Pointers, Sorting, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E5%90%8C%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_same_direction/#2234-maximum-total-beauty-of-the-gardens","title":"2234. Maximum Total Beauty of the Gardens","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Greedy, Sorting</p> </li> </ul> CPP <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nlong long maximumBeauty(vector&lt;int&gt;&amp; flowers, long long newFlowers, int target,\n                        int full, int partial) {\n    int n = flowers.size();\n\n    long long left = newFlowers - 1LL * target * n;\n    for (int&amp; flower : flowers) {\n        flower = min(flower, target);\n        left += flower;\n    }\n\n    if (left == newFlowers) return 1LL * full * n;\n\n    if (left &gt;= 0) {\n        return max(1LL * (target - 1) * partial + 1LL * (n - 1) * full,\n                   1LL * n * full);\n    }\n\n    sort(flowers.begin(), flowers.end());\n    long long res = 0, pre_sum = 0;\n\n    int j = 0;\n    for (int i = 1; i &lt;= n; i++) {\n        left += target - flowers[i - 1];\n        if (left &lt; 0) {\n            continue;\n        }\n\n        while (j &lt; i &amp;&amp; 1LL * flowers[j] * j &lt;= pre_sum + left) {\n            pre_sum += flowers[j];\n            j++;\n        }\n\n        long long avg = (left + pre_sum) / j;\n        long long total_beauty = avg * partial + 1LL * (n - i) * full;\n        res = max(res, total_beauty);\n    }\n\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; flowers = {1, 3, 1, 1};\n    long long newFlowers = 7;\n    int target = 6;\n    int full = 12;\n    int partial = 1;\n    long long res = maximumBeauty(flowers, newFlowers, target, full, partial);\n    cout &lt;&lt; res &lt;&lt; endl;  // 14\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E5%90%8C%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_same_direction/#1989-maximum-number-of-people-that-can-be-caught-in-tag","title":"1989. Maximum Number of People That Can Be Caught in Tag \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E5%90%8C%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_same_direction/#3323-minimize-connected-groups-by-inserting-interval","title":"3323. Minimize Connected Groups by Inserting Interval \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Sliding Window, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E5%90%8C%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_same_direction/#581-shortest-unsorted-continuous-subarray","title":"581. Shortest Unsorted Continuous Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Stack, Greedy, Sorting, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_opposite_direction/","title":"\u5355\u5e8f\u5217\u76f8\u5411\u53cc\u6307\u9488 One Sequence Two Pointers Opposite Direction","text":""},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_opposite_direction/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 344. Reverse String (Easy)</li> <li> 541. Reverse String II (Easy)</li> <li> 557. Reverse Words in a String III (Easy)</li> <li> 345. Reverse Vowels of a String (Easy)</li> <li> 917. Reverse Only Letters (Easy)</li> <li> 125. Valid Palindrome (Easy)</li> <li> 1750. Minimum Length of String After Deleting Similar Ends (Medium)</li> <li> 2105. Watering Plants II (Medium)</li> <li> 977. Squares of a Sorted Array (Easy)</li> <li> 658. Find K Closest Elements (Medium)</li> <li> 1471. The k Strongest Values in an Array (Medium)</li> <li> 167. Two Sum II - Input Array Is Sorted (Medium)</li> <li> 633. Sum of Square Numbers (Medium)</li> <li> 2824. Count Pairs Whose Sum is Less than Target (Easy)</li> <li> 2563. Count the Number of Fair Pairs (Medium)</li> <li> 15. 3Sum (Medium)</li> <li> 16. 3Sum Closest (Medium)</li> <li> 18. 4Sum (Medium)</li> <li> 611. Valid Triangle Number (Medium)</li> <li> 1577. Number of Ways Where Square of Number Is Equal to Product of Two Numbers (Medium)</li> <li> 923. 3Sum With Multiplicity (Medium)</li> <li> 948. Bag of Tokens (Medium)</li> <li> 11. Container With Most Water (Medium)</li> <li> 42. Trapping Rain Water (Hard)</li> <li> 1616. Split Two Strings to Make Palindrome (Medium)</li> <li> 1498. Number of Subsequences That Satisfy the Given Sum Condition (Medium)</li> <li> 1782. Count Pairs Of Nodes (Hard)</li> <li> 1099. Two Sum Less Than K (Easy) \ud83d\udc51</li> <li> 360. Sort Transformed Array (Medium) \ud83d\udc51</li> <li> 2422. Merge Operations to Turn Array Into a Palindrome (Medium) \ud83d\udc51</li> <li> 259. 3Sum Smaller (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_opposite_direction/#344-reverse-string","title":"344. Reverse String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\ndef reverseString(s: List[str]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify s in-place instead.\n    \"\"\"\n    left, right = 0, len(s) - 1\n\n    while left &lt; right:\n        s[left], s[right] = s[right], s[left]\n        left += 1\n        right -= 1\n\n\ns = [\"h\", \"e\", \"l\", \"l\", \"o\"]\nreverseString(s)\nprint(s)  # ['o', 'l', 'l', 'e', 'h']\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    void reverseString(vector&lt;char&gt;&amp; s) {\n        int left = 0, right = s.size() - 1;\n        while (left &lt; right) {\n            swap(s[left], s[right]);\n\n            left++;\n            right--;\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;char&gt; s = {'h', 'e', 'l', 'l', 'o'};\n    solution.reverseString(s);\n    assert(s == vector&lt;char&gt;({'o', 'l', 'l', 'e', 'h'}));\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_opposite_direction/#541-reverse-string-ii","title":"541. Reverse String II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String</p> </li> </ul> Python <pre><code>def reverseStr(s: str, k: int) -&gt; str:\n    def reverse_substring(text):\n        left, right = 0, len(text) - 1\n        while left &lt; right:\n            text[left], text[right] = text[right], text[left]\n            left += 1\n            right -= 1\n        return text\n\n    result = list(s)\n\n    for i in range(0, len(s), 2 * k):\n        result[i : i + k] = reverse_substring(result[i : i + k])\n\n    return \"\".join(result)\n\n\ns = \"abcdefg\"\nk = 2\nprint(reverseStr(s, k))  # \"bacdfeg\"\n</code></pre>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_opposite_direction/#557-reverse-words-in-a-string-iii","title":"557. Reverse Words in a String III","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_opposite_direction/#345-reverse-vowels-of-a-string","title":"345. Reverse Vowels of a String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_opposite_direction/#917-reverse-only-letters","title":"917. Reverse Only Letters","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_opposite_direction/#125-valid-palindrome","title":"125. Valid Palindrome","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String</p> </li> </ul> Python <pre><code># List Comprehension\ndef isPalindrome(s: str) -&gt; bool:\n    s = [char.lower() for char in s if char.isalnum()]\n    return s == s[::-1]\n\n\n# Left Right Pointers\ndef isPalindromeLR(s: str) -&gt; bool:\n    left, right = 0, len(s) - 1\n\n    while left &lt; right:\n        while left &lt; right and not s[left].isalnum():\n            left += 1\n        while left &lt; right and not s[right].isalnum():\n            right -= 1\n\n        if s[left].lower() != s[right].lower():\n            return False\n\n        left += 1\n        right -= 1\n\n    return True\n\n\ns = \"A man, a plan, a canal: Panama\"\nprint(isPalindrome(s))  # True\nprint(isPalindromeLR(s))  # True\n</code></pre>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_opposite_direction/#1750-minimum-length-of-string-after-deleting-similar-ends","title":"1750. Minimum Length of String After Deleting Similar Ends","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String</p> </li> </ul> Python <pre><code># Sliding Window Variable Size\ndef minimumLength(s: str) -&gt; int:\n    left, right = 0, len(s) - 1\n\n    while left &lt; right and s[left] == s[right]:\n        val = s[left]\n\n        while left &lt;= right and s[left] == val:\n            left += 1\n        while left &lt;= right and s[right] == val:\n            right -= 1\n\n    return right - left + 1\n\n\nprint(minimumLength(\"cabaabac\"))  # 0\nprint(minimumLength(\"aabccabba\"))  # 3\n</code></pre>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_opposite_direction/#2105-watering-plants-ii","title":"2105. Watering Plants II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Simulation</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Right Left Pointers\ndef minimumRefill(plants: List[int], capacityA: int, capacityB: int) -&gt; int:\n    i, j = 0, len(plants) - 1\n    a, b = capacityA, capacityB\n    res = 0\n\n    while i &lt; j:\n        if a &lt; plants[i]:\n            res += 1\n            a = capacityA\n        if b &lt; plants[j]:\n            res += 1\n            b = capacityB\n\n        a -= plants[i]\n        b -= plants[j]\n        i += 1\n        j -= 1\n\n    if i == j and max(a, b) &lt; plants[i]:\n        res += 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert minimumRefill([2, 2, 3, 3], 5, 5) == 1\n    assert minimumRefill([2, 2, 3, 3], 3, 4) == 2\n    assert minimumRefill([5, 5], 10, 10) == 0\n    assert minimumRefill([1, 2, 4, 4], 4, 4) == 1\n    assert minimumRefill([1, 1, 1], 2, 2) == 0\n</code></pre>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_opposite_direction/#977-squares-of-a-sorted-array","title":"977. Squares of a Sorted Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Sorting</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef sortedSquares(nums: List[int]) -&gt; List[int]:\n    \"\"\"Returns the squares of the sorted array.\"\"\"\n    n = len(nums)\n    result = [0 for _ in range(n)]\n\n    left, right, tail = 0, n - 1, n - 1\n\n    while left &lt;= right:\n        if abs(nums[left]) &gt;= abs(nums[right]):\n            result[tail] = nums[left] ** 2\n            left += 1\n        else:\n            result[tail] = nums[right] ** 2\n            right -= 1\n        tail -= 1\n\n    return result\n\n\n# |---------------------|------|-------|\n# | Approach            | Time | Space |\n# |---------------------|------|-------|\n# | Left Right Pointers | O(n) | O(n)  |\n# |---------------------|------|-------|\n\n\nnums = [-4, -1, 0, 3, 10]\nprint(sortedSquares(nums))  # [0, 1, 9, 16, 100]\n</code></pre>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_opposite_direction/#658-find-k-closest-elements","title":"658. Find K Closest Elements","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Sliding Window, Sorting, Heap Priority Queue</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_opposite_direction/#1471-the-k-strongest-values-in-an-array","title":"1471. The k Strongest Values in an Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_opposite_direction/#167-two-sum-ii-input-array-is-sorted","title":"167. Two Sum II - Input Array Is Sorted","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef twoSum(numbers: List[int], target: int) -&gt; List[int]:\n    left, right = 0, len(numbers) - 1\n\n    while left &lt; right:\n        total = numbers[left] + numbers[right]\n\n        if total &gt; target:\n            right -= 1\n        elif total &lt; target:\n            left += 1\n        else:\n            return [left + 1, right + 1]\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nnumbers = [2, 7, 11, 15]\ntarget = 9\nprint(twoSum(numbers, target))  # [1, 2]\n</code></pre>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_opposite_direction/#633-sum-of-square-numbers","title":"633. Sum of Square Numbers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Two Pointers, Binary Search</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_opposite_direction/#2824-count-pairs-whose-sum-is-less-than-target","title":"2824. Count Pairs Whose Sum is Less than Target","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_opposite_direction/#2563-count-the-number-of-fair-pairs","title":"2563. Count the Number of Fair Pairs","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_opposite_direction/#15-3sum","title":"15. 3Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Sorting</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef threeSum(nums: List[int]) -&gt; List[List[int]]:\n    nums.sort()\n    res = []\n    n = len(nums)\n\n    for i in range(n - 2):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        left, right = i + 1, n - 1\n\n        while left &lt; right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total &gt; 0:\n                right -= 1\n            elif total &lt; 0:\n                left += 1\n            else:\n                res.append([nums[i], nums[left], nums[right]])\n\n                while left &lt; right and nums[left] == nums[left + 1]:\n                    left += 1\n\n                while left &lt; right and nums[right] == nums[right - 1]:\n                    right -= 1\n\n                left += 1\n                right -= 1\n\n    return res\n\n\nnums = [-1, 0, 1, 2, -1, -4]\nassert threeSum(nums) == [[-1, -1, 2], [-1, 0, 1]]\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {\n    sort(nums.begin(), nums.end());\n    vector&lt;vector&lt;int&gt;&gt; res;\n    int n = nums.size();\n\n    for (int i = 0; i &lt; n - 2; i++) {\n        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) {\n            continue;\n        }\n\n        int left = i + 1, right = n - 1;\n\n        while (left &lt; right) {\n            int total = nums[i] + nums[left] + nums[right];\n\n            if (total &gt; 0)\n                right--;\n            else if (total &lt; 0)\n                left++;\n            else {\n                res.push_back({nums[i], nums[left], nums[right]});\n                while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++;\n                while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--;\n                left++;\n                right--;\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {-1, 0, 1, 2, -1, -4};\n    vector&lt;vector&lt;int&gt;&gt; res = threeSum(nums);\n    for (auto&amp; v : res) {\n        for (int i : v) {\n            cout &lt;&lt; i &lt;&lt; \" \";\n        }\n        cout &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_opposite_direction/#16-3sum-closest","title":"16. 3Sum Closest","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Sorting</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef threeSumClosest(nums: List[int], target: int) -&gt; int:\n    nums.sort()\n    n = len(nums)\n    res = 0\n    minDiff = float(\"inf\")\n\n    for i in range(n - 2):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        left, right = i + 1, n - 1\n\n        while left &lt; right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total &gt; target:\n                if total - target &lt; minDiff:\n                    minDiff = total - target\n                    res = total\n                right -= 1\n\n            elif total &lt; target:\n                if target - total &lt; minDiff:\n                    minDiff = target - total\n                    res = total\n                left += 1\n\n            else:\n                return total\n\n    return res\n\n\nnums = [-1, 2, 1, -4]\ntarget = 1\nassert threeSumClosest(nums, target) == 2\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;climits&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint threeSumClosest(vector&lt;int&gt;&amp; nums, int target) {\n    sort(nums.begin(), nums.end());\n    int n = nums.size();\n    int res = 0;\n    int minDiff = INT_MAX;\n\n    for (int i = 0; i &lt; n - 2; i++) {\n        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;\n\n        int left = i + 1, right = n - 1;\n        while (left &lt; right) {\n            int total = nums[i] + nums[left] + nums[right];\n\n            int diff = abs(total - target);\n            if (diff &lt; minDiff) {\n                minDiff = diff;\n                res = total;\n            }\n\n            if (total &gt; target)\n                right--;\n            else if (total &lt; target)\n                left++;\n            else\n                return total;\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {-1, 2, 1, -4};\n    int target = 1;\n    cout &lt;&lt; threeSumClosest(nums, target) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_opposite_direction/#18-4sum","title":"18. 4Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Sorting</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef fourSum(nums: List[int], target: int) -&gt; List[List[int]]:\n    \"\"\"Returns all unique quadruplets that sum up to the target.\"\"\"\n    nums.sort()\n    result = []\n\n    for i in range(len(nums) - 3):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        for j in range(i + 1, len(nums) - 2):\n            if j &gt; i + 1 and nums[j] == nums[j - 1]:\n                continue\n\n            left = j + 1\n            right = len(nums) - 1\n\n            while left &lt; right:\n                total = nums[i] + nums[j] + nums[left] + nums[right]\n\n                if total &gt; target:\n                    right -= 1\n                elif total &lt; target:\n                    left += 1\n                else:\n                    result.append([nums[i], nums[j], nums[left], nums[right]])\n                    while left &lt; right and nums[left] == nums[left + 1]:\n                        left += 1\n                    while left &lt; right and nums[right] == nums[right - 1]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n\n    return result\n\n\nnums = [1, 0, -1, 0, -2, 2]\ntarget = 0\nprint(fourSum(nums, target))\n# [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]\n</code></pre>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_opposite_direction/#611-valid-triangle-number","title":"611. Valid Triangle Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_opposite_direction/#1577-number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers","title":"1577. Number of Ways Where Square of Number Is Equal to Product of Two Numbers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Two Pointers</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_opposite_direction/#923-3sum-with-multiplicity","title":"923. 3Sum With Multiplicity","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Two Pointers, Sorting, Counting</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_opposite_direction/#948-bag-of-tokens","title":"948. Bag of Tokens","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_opposite_direction/#11-container-with-most-water","title":"11. Container With Most Water","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Greedy</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return the maximum area of water that can be trapped between the vertical lines.\n\n![11](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)\n\"\"\"\n\nfrom typing import List\n\n\n# Brute Force\ndef maxAreaBF(height: List[int]) -&gt; int:\n    max_area = 0\n\n    for i in range(len(height)):\n        for j in range(i + 1, len(height)):\n            h = min(height[i], height[j])\n            w = j - i\n            max_area = max(max_area, h * w)\n\n    return max_area\n\n\n# Left Right Pointers\ndef maxAreaLR(height: List[int]) -&gt; int:\n    left, right = 0, len(height) - 1\n    res = 0\n\n    while left &lt; right:\n        h = min(height[left], height[right])\n        w = right - left\n        res = max(res, h * w)\n\n        if height[left] &lt; height[right]:\n            left += 1\n        else:\n            right -= 1\n\n    return res\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force| O(n^2) |  O(1)   |\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nheight = [1, 8, 6, 2, 5, 4, 8, 3, 7]\nprint(maxAreaBF(height))  # 49\nprint(maxAreaLR(height))  # 49\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint maxArea(vector&lt;int&gt;&amp; height) {\n    int left = 0, right = height.size() - 1;\n    int res = 0;\n\n    while (left &lt; right) {\n        int h = min(height[left], height[right]);\n        int w = right - left;\n        res = max(res, h * w);\n\n        if (height[left] &lt; height[right])\n            left++;\n        else\n            right--;\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; height = {1, 8, 6, 2, 5, 4, 8, 3, 7};\n    cout &lt;&lt; maxArea(height) &lt;&lt; endl;  // 49\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_opposite_direction/#42-trapping-rain-water","title":"42. Trapping Rain Water","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Dynamic Programming, Stack, Monotonic Stack</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- ![42](../../assets/0042.png)\n\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/ZI2z5pq0TqA?si=OEYg01dbmzvmtIwZ\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen&gt;&lt;/iframe&gt;\n\n| Approach   | Time | Space |\n| ---------- | ---- | ----- |\n| DP         | O(N) | O(N)  |\n| Left Right | O(N) | O(1)  |\n| Monotonic  | O(N) | O(N)  |\n\"\"\"\n\nfrom typing import List\n\n\n# DP\ndef trapDP(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    n = len(height)\n    maxLeft, maxRight = [0 for _ in range(n)], [0 for _ in range(n)]\n\n    for i in range(1, n):\n        maxLeft[i] = max(maxLeft[i - 1], height[i - 1])\n\n    for i in range(n - 2, -1, -1):\n        maxRight[i] = max(maxRight[i + 1], height[i + 1])\n\n    res = 0\n    for i in range(n):\n        res += max(0, min(maxLeft[i], maxRight[i]) - height[i])\n\n    return res\n\n\n# Left Right Pointers\ndef trapLR(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    left, right = 0, len(height) - 1\n    maxL, maxR = height[left], height[right]\n    res = 0\n\n    while left &lt; right:\n        if maxL &lt; maxR:\n            left += 1\n            maxL = max(maxL, height[left])\n            res += maxL - height[left]\n        else:\n            right -= 1\n            maxR = max(maxR, height[right])\n            res += maxR - height[right]\n\n    return res\n\n\n# Monotonic Stack\ndef trapStack(height: List[int]) -&gt; int:\n    stack = []\n    total = 0\n\n    for i in range(len(height)):\n        while stack and height[i] &gt; height[stack[-1]]:\n            top = stack.pop()\n            if not stack:\n                break\n            distance = i - stack[-1] - 1\n            bounded_height = min(height[i], height[stack[-1]]) - height[top]\n            total += distance * bounded_height\n        stack.append(i)\n\n    return total\n\n\nheight = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\nprint(trapDP(height))  # 6\nprint(trapLR(height))  # 6\nprint(trapStack(height))  # 6\n</code></pre> <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int trap(vector&lt;int&gt; &amp;height)\n    {\n        if (height.empty())\n            return 0;\n\n        int res = 0;\n        int left = 0, right = height.size() - 1;\n        int maxL = height[left], maxR = height[right];\n\n        while (left &lt; right)\n        {\n            if (maxL &lt; maxR)\n            {\n                left++;\n                maxL = max(maxL, height[left]);\n                res += maxL - height[left];\n            }\n            else\n            {\n                right--;\n                maxR = max(maxR, height[right]);\n                res += maxR - height[right];\n            }\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    vector&lt;int&gt; height = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};\n    Solution solution;\n    cout &lt;&lt; solution.trap(height) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_opposite_direction/#1616-split-two-strings-to-make-palindrome","title":"1616. Split Two Strings to Make Palindrome","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_opposite_direction/#1498-number-of-subsequences-that-satisfy-the-given-sum-condition","title":"1498. Number of Subsequences That Satisfy the Given Sum Condition","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_opposite_direction/#1782-count-pairs-of-nodes","title":"1782. Count Pairs Of Nodes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Graph, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_opposite_direction/#1099-two-sum-less-than-k","title":"1099. Two Sum Less Than K \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Sorting</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef twoSumLessThanK(nums: List[int], k: int) -&gt; int:\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    res = float(\"-inf\")\n\n    while left &lt; right:\n        total = nums[left] + nums[right]\n\n        if total &gt;= k:\n            right -= 1\n        else:\n            res = max(res, total)\n            left += 1\n\n    return res if res != float(\"-inf\") else -1\n\n\nnums = [34, 23, 1, 24, 75, 33, 54, 8]\nk = 60\nprint(twoSumLessThanK(nums, k))  # 58\n</code></pre>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_opposite_direction/#360-sort-transformed-array","title":"360. Sort Transformed Array \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Two Pointers, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_opposite_direction/#2422-merge-operations-to-turn-array-into-a-palindrome","title":"2422. Merge Operations to Turn Array Into a Palindrome \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E7%9B%B8%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_opposite_direction/#259-3sum-smaller","title":"259. 3Sum Smaller \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E8%83%8C%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_backward/","title":"\u5355\u5e8f\u5217\u80cc\u5411\u53cc\u6307\u9488 One Sequence Two Pointers Backward","text":""},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E8%83%8C%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_backward/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1793. Maximum Score of a Good Subarray (Hard)</li> <li> 976. Largest Perimeter Triangle (Easy)</li> </ul>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E8%83%8C%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_backward/#1793-maximum-score-of-a-good-subarray","title":"1793. Maximum Score of a Good Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Stack, Monotonic Stack</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8D%95%E5%BA%8F%E5%88%97%E8%83%8C%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88_one_sequence_two_pointers_backward/#976-largest-perimeter-triangle","title":"976. Largest Perimeter Triangle","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Greedy, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8F%8C%E5%BA%8F%E5%88%97%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97_two_sequences_subsequence_check/","title":"\u53cc\u5e8f\u5217\u5224\u65ad\u5b50\u5e8f\u5217 Two Sequences Subsequence Check","text":""},{"location":"EndlessCheng/%E5%8F%8C%E5%BA%8F%E5%88%97%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97_two_sequences_subsequence_check/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 392. Is Subsequence (Easy)</li> <li> 524. Longest Word in Dictionary through Deleting (Medium)</li> <li> 2486. Append Characters to String to Make Subsequence (Medium)</li> <li> 2825. Make String a Subsequence Using Cyclic Increments (Medium)</li> <li> 1023. Camelcase Matching (Medium)</li> <li> 3132. Find the Integer Added to Array II (Medium)</li> <li> 522. Longest Uncommon Subsequence II (Medium)</li> <li> 1898. Maximum Number of Removable Characters (Medium)</li> <li> 2565. Subsequence With the Minimum Score (Hard)</li> <li> 3302. Find the Lexicographically Smallest Valid Sequence (Medium)</li> </ul>"},{"location":"EndlessCheng/%E5%8F%8C%E5%BA%8F%E5%88%97%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97_two_sequences_subsequence_check/#392-is-subsequence","title":"392. Is Subsequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Dynamic Programming</p> </li> </ul> Python <pre><code># DP - LCS\ndef isSubsequenceLCS(s: str, t: str) -&gt; bool:\n    m = len(s)\n    n = len(t)\n\n    if m &gt; n:\n        return False\n\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    length = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = dp[i][j - 1]  # only delete t string\n\n            if length &lt; dp[i][j]:\n                length = dp[i][j]\n\n    return length == m\n\n\n# Two Pointers\ndef isSubsequenceTP(s: str, t: str) -&gt; bool:\n    i, j = 0, 0\n\n    while i &lt; len(s) and j &lt; len(t):\n        if s[i] == t[j]:\n            i += 1\n        j += 1\n\n    return i == len(s)\n\n\ns = \"abc\"\nt = \"ahbgdc\"\nprint(isSubsequenceLCS(s, t))  # True\nprint(isSubsequenceTP(s, t))  # True\n</code></pre>"},{"location":"EndlessCheng/%E5%8F%8C%E5%BA%8F%E5%88%97%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97_two_sequences_subsequence_check/#524-longest-word-in-dictionary-through-deleting","title":"524. Longest Word in Dictionary through Deleting","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, String, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8F%8C%E5%BA%8F%E5%88%97%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97_two_sequences_subsequence_check/#2486-append-characters-to-string-to-make-subsequence","title":"2486. Append Characters to String to Make Subsequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8F%8C%E5%BA%8F%E5%88%97%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97_two_sequences_subsequence_check/#2825-make-string-a-subsequence-using-cyclic-increments","title":"2825. Make String a Subsequence Using Cyclic Increments","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8F%8C%E5%BA%8F%E5%88%97%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97_two_sequences_subsequence_check/#1023-camelcase-matching","title":"1023. Camelcase Matching","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, String, Trie, String Matching</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8F%8C%E5%BA%8F%E5%88%97%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97_two_sequences_subsequence_check/#3132-find-the-integer-added-to-array-ii","title":"3132. Find the Integer Added to Array II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Sorting, Enumeration</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8F%8C%E5%BA%8F%E5%88%97%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97_two_sequences_subsequence_check/#522-longest-uncommon-subsequence-ii","title":"522. Longest Uncommon Subsequence II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Two Pointers, String, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8F%8C%E5%BA%8F%E5%88%97%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97_two_sequences_subsequence_check/#1898-maximum-number-of-removable-characters","title":"1898. Maximum Number of Removable Characters","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, String, Binary Search</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8F%8C%E5%BA%8F%E5%88%97%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97_two_sequences_subsequence_check/#2565-subsequence-with-the-minimum-score","title":"2565. Subsequence With the Minimum Score","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Binary Search</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8F%8C%E5%BA%8F%E5%88%97%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97_two_sequences_subsequence_check/#3302-find-the-lexicographically-smallest-valid-sequence","title":"3302. Find the Lexicographically Smallest Valid Sequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Dynamic Programming, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8F%8C%E5%BA%8F%E5%88%97%E5%8F%8C%E6%8C%87%E9%92%88_two_sequences_two_pointers/","title":"\u53cc\u5e8f\u5217\u53cc\u6307\u9488 Two Sequences Two Pointers","text":""},{"location":"EndlessCheng/%E5%8F%8C%E5%BA%8F%E5%88%97%E5%8F%8C%E6%8C%87%E9%92%88_two_sequences_two_pointers/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2109. Adding Spaces to a String (Medium)</li> <li> 2540. Minimum Common Value (Easy)</li> <li> 88. Merge Sorted Array (Easy)</li> <li> 2570. Merge Two 2D Arrays by Summing Values (Easy)</li> <li> 350. Intersection of Two Arrays II (Easy)</li> <li> 1855. Maximum Distance Between a Pair of Values (Medium)</li> <li> 1385. Find the Distance Value Between Two Arrays (Easy)</li> <li> 925. Long Pressed Name (Easy)</li> <li> 809. Expressive Words (Medium)</li> <li> 2337. Move Pieces to Obtain a String (Medium)</li> <li> 777. Swap Adjacent in LR String (Medium)</li> <li> 844. Backspace String Compare (Easy)</li> <li> 986. Interval List Intersections (Medium)</li> <li> 1537. Get the Maximum Score (Hard)</li> <li> 244. Shortest Word Distance II (Medium) \ud83d\udc51</li> <li> 2838. Maximum Coins Heroes Can Collect (Medium) \ud83d\udc51</li> <li> 1229. Meeting Scheduler (Medium) \ud83d\udc51</li> <li> 1570. Dot Product of Two Sparse Vectors (Medium) \ud83d\udc51</li> <li> 1868. Product of Two Run-Length Encoded Arrays (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/%E5%8F%8C%E5%BA%8F%E5%88%97%E5%8F%8C%E6%8C%87%E9%92%88_two_sequences_two_pointers/#2109-adding-spaces-to-a-string","title":"2109. Adding Spaces to a String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, String, Simulation</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef addSpaces(s: str, spaces: List[int]) -&gt; str:\n    res = []\n    spaces.sort()\n    n = len(spaces)\n    j = 0\n\n    for i, ch in enumerate(s):\n        if j &lt; n and i == spaces[j]:\n            res.append(\" \")\n            j += 1\n        res.append(ch)\n\n    return \"\".join(res)\n\n\nif __name__ == \"__main__\":\n    s = \"LeetcodeHelpsMeLearn\"\n    spaces = [8, 13, 15]\n    print(addSpaces(s, spaces))  # Leetcode Helps Me Learn\n</code></pre>"},{"location":"EndlessCheng/%E5%8F%8C%E5%BA%8F%E5%88%97%E5%8F%8C%E6%8C%87%E9%92%88_two_sequences_two_pointers/#2540-minimum-common-value","title":"2540. Minimum Common Value","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Two Pointers, Binary Search</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8F%8C%E5%BA%8F%E5%88%97%E5%8F%8C%E6%8C%87%E9%92%88_two_sequences_two_pointers/#88-merge-sorted-array","title":"88. Merge Sorted Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Sorting</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\nclass merge:\n    @staticmethod\n    def lr(nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None:\n        \"\"\"\n        Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        p1, p2, t = m - 1, n - 1, m + n - 1\n\n        while p1 &gt;= 0 or p2 &gt;= 0:\n            if p1 == -1:\n                nums1[t] = nums2[p2]\n                p2 -= 1\n            elif p2 == -1:\n                nums1[t] = nums1[p1]\n                p1 -= 1\n            elif nums1[p1] &gt; nums2[p2]:\n                nums1[t] = nums1[p1]\n                p1 -= 1\n            else:\n                nums1[t] = nums2[p2]\n                p2 -= 1\n\n            t -= 1\n\n\nif __name__ == \"__main__\":\n    nums1 = [1, 2, 3, 0, 0, 0]\n    m = 3\n    nums2 = [2, 5, 6]\n    n = 3\n    merge.lr(nums1, m, nums2, n)\n    assert nums1 == [1, 2, 2, 3, 5, 6]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {\n        int p1 = m - 1, p2 = n - 1, t = m + n - 1;\n\n        while (p1 &gt;= 0 || p2 &gt;= 0) {\n            if (p1 == -1) {\n                nums1[t] = nums2[p2];\n                p2--;\n            } else if (p2 == -1) {\n                nums1[t] = nums1[p1];\n                p1--;\n            } else if (nums1[p1] &gt; nums2[p2]) {\n                nums1[t] = nums1[p1];\n                p1--;\n            } else {\n                nums1[t] = nums2[p2];\n                p2--;\n            }\n            t--;\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; nums1 = {1, 3, 6, 0, 0, 0};\n    vector&lt;int&gt; nums2 = {2, 5, 6};\n    vector&lt;int&gt; output = {1, 2, 3, 5, 6, 6};\n    solution.merge(nums1, 3, nums2, 3);\n    assert(nums1 == output);\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/%E5%8F%8C%E5%BA%8F%E5%88%97%E5%8F%8C%E6%8C%87%E9%92%88_two_sequences_two_pointers/#2570-merge-two-2d-arrays-by-summing-values","title":"2570. Merge Two 2D Arrays by Summing Values","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Two Pointers</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8F%8C%E5%BA%8F%E5%88%97%E5%8F%8C%E6%8C%87%E9%92%88_two_sequences_two_pointers/#350-intersection-of-two-arrays-ii","title":"350. Intersection of Two Arrays II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Two Pointers, Binary Search, Sorting</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the intersection of two arrays.\n\"\"\"\n\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Hashmap\ndef intersect(nums1: List[int], nums2: List[int]) -&gt; List[int]:\n    hashmap = defaultdict(int)  # {num: count}\n    result = []\n\n    for i in nums1:\n        hashmap[i] += 1\n\n    for i in nums2:\n        if hashmap[i] &gt; 0:\n            result.append(i)\n            hashmap[i] -= 1\n\n    return result\n\n\n# |-------------|-------------|--------------|\n# |   Approach  |    Time     |    Space     |\n# |-------------|-------------|--------------|\n# |   Hashmap   |   O(n + m)  | O(min(n, m)) |\n# |-------------|-------------|--------------|\n\nnums1 = [1, 2, 2, 1]\nnums2 = [2, 2]\nprint(intersect(nums1, nums2))  # [2, 2]\n</code></pre>"},{"location":"EndlessCheng/%E5%8F%8C%E5%BA%8F%E5%88%97%E5%8F%8C%E6%8C%87%E9%92%88_two_sequences_two_pointers/#1855-maximum-distance-between-a-pair-of-values","title":"1855. Maximum Distance Between a Pair of Values","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8F%8C%E5%BA%8F%E5%88%97%E5%8F%8C%E6%8C%87%E9%92%88_two_sequences_two_pointers/#1385-find-the-distance-value-between-two-arrays","title":"1385. Find the Distance Value Between Two Arrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Sorting</p> </li> </ul> Python <pre><code>from bisect import bisect_left\nfrom typing import List\n\n\n# Binary Search\ndef findTheDistanceValue(arr1: List[int], arr2: List[int], d: int) -&gt; int:\n    arr2.sort()\n    res = 0\n\n    for x in arr1:\n        i = bisect_left(arr2, x - d)\n        if i == len(arr2) or arr2[i] &gt; x + d:\n            res += 1\n\n    return res\n\n\narr1 = [4, 5, 8]\narr2 = [10, 9, 1, 8]\nd = 2\nprint(findTheDistanceValue(arr1, arr2, d))  # 2\n</code></pre>"},{"location":"EndlessCheng/%E5%8F%8C%E5%BA%8F%E5%88%97%E5%8F%8C%E6%8C%87%E9%92%88_two_sequences_two_pointers/#925-long-pressed-name","title":"925. Long Pressed Name","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8F%8C%E5%BA%8F%E5%88%97%E5%8F%8C%E6%8C%87%E9%92%88_two_sequences_two_pointers/#809-expressive-words","title":"809. Expressive Words","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, String</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8F%8C%E5%BA%8F%E5%88%97%E5%8F%8C%E6%8C%87%E9%92%88_two_sequences_two_pointers/#2337-move-pieces-to-obtain-a-string","title":"2337. Move Pieces to Obtain a String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8F%8C%E5%BA%8F%E5%88%97%E5%8F%8C%E6%8C%87%E9%92%88_two_sequences_two_pointers/#777-swap-adjacent-in-lr-string","title":"777. Swap Adjacent in LR String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8F%8C%E5%BA%8F%E5%88%97%E5%8F%8C%E6%8C%87%E9%92%88_two_sequences_two_pointers/#844-backspace-string-compare","title":"844. Backspace String Compare","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Stack, Simulation</p> </li> </ul> Python <pre><code>def backspaceCompare(s: str, t: str) -&gt; bool:\n\n    def build(text):\n        stack = []\n\n        for char in text:\n            if char != \"#\":\n                stack.append(char)\n            elif stack:\n                stack.pop()\n\n        return \"\".join(stack)\n\n    return build(s) == build(t)\n\n\nprint(backspaceCompare(\"ab#c\", \"ad#c\"))  # True\n</code></pre>"},{"location":"EndlessCheng/%E5%8F%8C%E5%BA%8F%E5%88%97%E5%8F%8C%E6%8C%87%E9%92%88_two_sequences_two_pointers/#986-interval-list-intersections","title":"986. Interval List Intersections","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Line Sweep</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8F%8C%E5%BA%8F%E5%88%97%E5%8F%8C%E6%8C%87%E9%92%88_two_sequences_two_pointers/#1537-get-the-maximum-score","title":"1537. Get the Maximum Score","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Dynamic Programming, Greedy</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8F%8C%E5%BA%8F%E5%88%97%E5%8F%8C%E6%8C%87%E9%92%88_two_sequences_two_pointers/#244-shortest-word-distance-ii","title":"244. Shortest Word Distance II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Two Pointers, String, Design</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8F%8C%E5%BA%8F%E5%88%97%E5%8F%8C%E6%8C%87%E9%92%88_two_sequences_two_pointers/#2838-maximum-coins-heroes-can-collect","title":"2838. Maximum Coins Heroes Can Collect \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Sorting, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8F%8C%E5%BA%8F%E5%88%97%E5%8F%8C%E6%8C%87%E9%92%88_two_sequences_two_pointers/#1229-meeting-scheduler","title":"1229. Meeting Scheduler \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8F%8C%E5%BA%8F%E5%88%97%E5%8F%8C%E6%8C%87%E9%92%88_two_sequences_two_pointers/#1570-dot-product-of-two-sparse-vectors","title":"1570. Dot Product of Two Sparse Vectors \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Two Pointers, Design</p> </li> </ul>"},{"location":"EndlessCheng/%E5%8F%8C%E5%BA%8F%E5%88%97%E5%8F%8C%E6%8C%87%E9%92%88_two_sequences_two_pointers/#1868-product-of-two-run-length-encoded-arrays","title":"1868. Product of Two Run-Length Encoded Arrays \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers</p> </li> </ul>"},{"location":"EndlessCheng/%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%85%B6%E4%BB%96_fixed_sliding_window_others/","title":"\u5b9a\u957f\u6ed1\u52a8\u7a97\u53e3\u5176\u4ed6 Fixed Sliding Window Others","text":""},{"location":"EndlessCheng/%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%85%B6%E4%BB%96_fixed_sliding_window_others/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2269. Find the K-Beauty of a Number (Easy)</li> <li> 1984. Minimum Difference Between Highest and Lowest of K Scores (Easy)</li> <li> 220. Contains Duplicate III (Hard)</li> </ul>"},{"location":"EndlessCheng/%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%85%B6%E4%BB%96_fixed_sliding_window_others/#2269-find-the-k-beauty-of-a-number","title":"2269. Find the K-Beauty of a Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String, Sliding Window</p> </li> </ul> Python <pre><code>def divisorSubstrings(num: int, k: int) -&gt; int:\n    numStr = str(num)\n    n = len(numStr)\n    res = 0\n\n    for i in range(n - k + 1):\n        x = int(numStr[i : i + k])\n        if x &gt; 0 and num % x == 0:\n            res += 1\n\n    return res\n\n\nnum = 240\nk = 2\nprint(divisorSubstrings(num, k))  # 2\n</code></pre>"},{"location":"EndlessCheng/%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%85%B6%E4%BB%96_fixed_sliding_window_others/#1984-minimum-difference-between-highest-and-lowest-of-k-scores","title":"1984. Minimum Difference Between Highest and Lowest of K Scores","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sliding Window, Sorting</p> </li> </ul>"},{"location":"EndlessCheng/%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%85%B6%E4%BB%96_fixed_sliding_window_others/#220-contains-duplicate-iii","title":"220. Contains Duplicate III","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sliding Window, Sorting, Bucket Sort, Ordered Set</p> </li> </ul>"},{"location":"EndlessCheng/%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%9F%BA%E7%A1%80_fixed_sliding_window_basics/","title":"\u5b9a\u957f\u6ed1\u52a8\u7a97\u53e3\u57fa\u7840 Fixed Sliding Window Basics","text":""},{"location":"EndlessCheng/%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%9F%BA%E7%A1%80_fixed_sliding_window_basics/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1456. Maximum Number of Vowels in a Substring of Given Length (Medium)</li> <li> 643. Maximum Average Subarray I (Easy)</li> <li> 1343. Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold (Medium)</li> <li> 2090. K Radius Subarray Averages (Medium)</li> <li> 2379. Minimum Recolors to Get K Consecutive Black Blocks (Easy)</li> <li> 2841. Maximum Sum of Almost Unique Subarray (Medium)</li> <li> 2461. Maximum Sum of Distinct Subarrays With Length K (Medium)</li> <li> 1423. Maximum Points You Can Obtain from Cards (Medium)</li> <li> 1052. Grumpy Bookstore Owner (Medium)</li> <li> 1652. Defuse the Bomb (Easy)</li> <li> 1176. Diet Plan Performance (Easy) \ud83d\udc51</li> <li> 1100. Find K-Length Substrings With No Repeated Characters (Medium) \ud83d\udc51</li> <li> 1852. Distinct Numbers in Each Subarray (Medium) \ud83d\udc51</li> <li> 1151. Minimum Swaps to Group All 1's Together (Medium) \ud83d\udc51</li> <li> 2107. Number of Unique Flavors After Sharing K Candies (Medium) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%9F%BA%E7%A1%80_fixed_sliding_window_basics/#1456-maximum-number-of-vowels-in-a-substring-of-given-length","title":"1456. Maximum Number of Vowels in a Substring of Given Length","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Sliding Window</p> </li> </ul> PythonCPP <pre><code>class maxVowels:\n    \"\"\"\n    Template problem for Fixed Size Sliding Window.\n    Technique: add-update-remove (\u5165-\u66f4\u65b0-\u51fa)\n    \"\"\"\n\n    @staticmethod\n    def fixed_sliding_window(s: str, k: int) -&gt; int:\n        res, cnt = 0, 0\n\n        for idx, ch in enumerate(s):\n            # ADD\n            if ch in \"aeiou\":\n                cnt += 1\n\n            # FORM\n            if idx &lt; k - 1:\n                continue\n\n            # UPDATE\n            res = max(res, cnt)\n\n            # REMOVE\n            if s[idx - k + 1] in \"aeiou\":\n                cnt -= 1\n\n        return res\n\n    @staticmethod\n    def fixed_sliding_window_substring(s: str, k: int) -&gt; int:\n        \"\"\"Sliding Window on Substring\"\"\"\n\n        vowels = set(\"aeiou\")\n        n = len(s)\n        cnt, res = 0, 0\n\n        # init\n        for i in range(k):\n            if s[i] in vowels:\n                cnt += 1\n\n        res = cnt\n\n        # slide\n        for i in range(k, n):\n            if s[i] in vowels:\n                cnt += 1\n            if s[i - k] in vowels:\n                cnt -= 1\n            res = max(res, cnt)\n\n        return res\n\n\nif __name__ == \"__main__\":\n    s = \"abciiidef\"\n    k = 3\n    assert maxVowels.fixed_sliding_window(s, k) == 3\n    assert maxVowels.fixed_sliding_window_substring(s, k) == 3\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;string&gt;\n#include &lt;unordered_set&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int maxVowels(string s, int k) {\n        int n = s.size();\n        int res = 0, cnt = 0;\n        unordered_set&lt;char&gt; vowels = {'a', 'e', 'i', 'o', 'u'};\n\n        for (int right = 0; right &lt; n; right++) {\n            if (vowels.count(s[right])) cnt++;\n\n            int left = right - k + 1;\n            if (left &lt; 0) continue;\n\n            res = max(res, cnt);\n            if (vowels.count(s[left])) cnt--;\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    assert(solution.maxVowels(\"abciiidef\", 3) == 3);\n    assert(solution.maxVowels(\"aeiou\", 2) == 2);\n    return 0;\n}\n</code></pre>"},{"location":"EndlessCheng/%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%9F%BA%E7%A1%80_fixed_sliding_window_basics/#643-maximum-average-subarray-i","title":"643. Maximum Average Subarray I","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sliding Window</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Sliding Window Fixed Size\ndef findMaxAverage1(nums: List[int], k: int) -&gt; float:\n    maxSum = float(\"-inf\")\n    cur = 0\n\n    for idx, num in enumerate(nums):\n        cur += num\n\n        if idx &lt; k - 1:\n            continue\n\n        maxSum = max(maxSum, cur)\n        cur -= nums[idx - k + 1]\n\n    return maxSum / k\n\n\n# Sliding Window Fixed Size\ndef findMaxAverage2(nums: List[int], k: int) -&gt; float:\n    n = len(nums)\n    if n == 1:\n        return float(nums[0])\n\n    cur = sum(nums[:k])\n\n    maxSum = cur\n    for i in range(k, n):\n        cur += nums[i] - nums[i - k]\n        maxSum = max(maxSum, cur)\n\n    return maxSum / k\n\n\nnums = [1, 12, -5, -6, 50, 3]\nk = 4\nprint(findMaxAverage1(nums, k))  # 12.75\nprint(findMaxAverage2(nums, k))  # 12.75\n</code></pre>"},{"location":"EndlessCheng/%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%9F%BA%E7%A1%80_fixed_sliding_window_basics/#1343-number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold","title":"1343. Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sliding Window</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Sliding Window Fixed Size\ndef numOfSubarrays(arr: List[int], k: int, threshold: int) -&gt; int:\n    target = k * threshold\n    res, cur = 0, 0\n\n    for idx, num in enumerate(arr):\n        cur += num\n\n        if idx &lt; k - 1:\n            continue\n\n        if cur &gt;= target:\n            res += 1\n\n        cur -= arr[idx - k + 1]\n\n    return res\n\n\narr = [2, 2, 2, 2, 5, 5, 5, 8]\nk = 3\nthreshold = 4\nprint(numOfSubarrays(arr, k, threshold))  # 3\n</code></pre>"},{"location":"EndlessCheng/%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%9F%BA%E7%A1%80_fixed_sliding_window_basics/#2090-k-radius-subarray-averages","title":"2090. K Radius Subarray Averages","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sliding Window</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Sliding Window Fixed Size\ndef getAverages(nums: List[int], k: int) -&gt; List[int]:\n    n = len(nums)\n    res = [-1 for _ in range(n)]\n    size = 2 * k + 1\n\n    if size &gt; n:\n        return res\n    if k == 0:\n        return nums\n\n    cur = 0\n    for idx, num in enumerate(nums):\n        cur += num\n\n        if idx &lt; 2 * k:\n            continue\n\n        res[idx - k] = cur // size\n        cur -= nums[idx - 2 * k]\n\n    return res\n\n\nnums = [7, 4, 3, 9, 1, 8, 5, 2, 6]\nk = 3\nprint(getAverages(nums, k))\n# [-1, -1, -1, 5, 4, 4, -1, -1, -1]\n</code></pre>"},{"location":"EndlessCheng/%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%9F%BA%E7%A1%80_fixed_sliding_window_basics/#2379-minimum-recolors-to-get-k-consecutive-black-blocks","title":"2379. Minimum Recolors to Get K Consecutive Black Blocks","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Sliding Window</p> </li> </ul> Python <pre><code># Sliding Window Fixed Size\ndef minimumRecolors(blocks: str, k: int) -&gt; int:\n    cnt, res = 0, float(\"inf\")\n\n    for idx, block in enumerate(blocks):\n        if block == \"W\":\n            cnt += 1\n\n        if idx &lt; k - 1:\n            continue\n\n        res = min(res, cnt)\n\n        if blocks[idx - k + 1] == \"W\":\n            cnt -= 1\n\n    return res\n\n\nblocks = \"WBBWWBBWBW\"\nk = 7\nprint(minimumRecolors(blocks, k))  # 3\n</code></pre>"},{"location":"EndlessCheng/%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%9F%BA%E7%A1%80_fixed_sliding_window_basics/#2841-maximum-sum-of-almost-unique-subarray","title":"2841. Maximum Sum of Almost Unique Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Sliding Window</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Sliding Window Fixed Size\ndef maxSum(nums: List[int], m: int, k: int) -&gt; int:\n    counts = defaultdict(int)\n    cur, res = 0, 0\n\n    for idx, num in enumerate(nums):\n        counts[num] += 1\n        cur += num\n\n        if idx &lt; k - 1:\n            continue\n\n        if len(counts) &gt;= m:\n            res = max(res, cur)\n\n        first = idx - k + 1\n        cur -= nums[first]\n        counts[nums[first]] -= 1\n        if counts[nums[first]] == 0:\n            del counts[nums[first]]\n\n    return res\n\n\nnums = [2, 6, 7, 3, 1, 7]\nm = 3\nk = 4\nprint(maxSum(nums, m, k))  # 18\n</code></pre>"},{"location":"EndlessCheng/%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%9F%BA%E7%A1%80_fixed_sliding_window_basics/#2461-maximum-sum-of-distinct-subarrays-with-length-k","title":"2461. Maximum Sum of Distinct Subarrays With Length K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Sliding Window</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Sliding Window Fixed Size\ndef maximumSubarraySum(nums: List[int], k: int) -&gt; int:\n    counts = defaultdict(int)\n    res = 0\n    cur = 0\n\n    for idx, num in enumerate(nums):\n        counts[num] += 1\n        cur += num\n\n        if idx &lt; k - 1:\n            continue\n\n        if len(counts) == k:\n            res = max(res, cur)\n\n        first = idx - k + 1\n        cur -= nums[first]\n        counts[nums[first]] -= 1\n        if counts[nums[first]] == 0:\n            del counts[nums[first]]\n\n    return res\n\n\nnums = [1, 5, 4, 2, 9, 9, 9]\nk = 3\nprint(maximumSubarraySum(nums, k))  # 15\n</code></pre>"},{"location":"EndlessCheng/%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%9F%BA%E7%A1%80_fixed_sliding_window_basics/#1423-maximum-points-you-can-obtain-from-cards","title":"1423. Maximum Points You Can Obtain from Cards","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sliding Window, Prefix Sum</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Sliding Window Fixed Size\ndef maxScore(cardPoints: List[int], k: int) -&gt; int:\n    n = len(cardPoints)\n    j = n - k\n    total = sum(cardPoints)\n\n    if j == 0:\n        return total\n\n    curSum, minSum = 0, float(\"inf\")\n\n    for idx, point in enumerate(cardPoints):\n        curSum += point\n\n        if idx &lt; j - 1:\n            continue\n\n        minSum = min(minSum, curSum)\n        curSum -= cardPoints[idx - j + 1]\n\n    return total - minSum\n\n\ncardPoints = [1, 2, 3, 4, 5, 6, 1]\nk = 3\nprint(maxScore(cardPoints, k))  # 12\n</code></pre>"},{"location":"EndlessCheng/%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%9F%BA%E7%A1%80_fixed_sliding_window_basics/#1052-grumpy-bookstore-owner","title":"1052. Grumpy Bookstore Owner","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sliding Window</p> </li> </ul> Python <pre><code>\"\"\"\n-   Hint: Maximize the number of _unsatisfied customers_ in the fixed window of `minutes`.\n\"\"\"\n\nfrom typing import List\n\n\n# Sliding Window Fixed Size\ndef maxSatisfied(customers: List[int], grumpy: List[int], minutes: int) -&gt; int:\n    n = len(customers)\n    k = minutes\n    if k &gt;= n:\n        return sum(customers)\n\n    total_satisfied = sum(customers[i] for i in range(n) if not grumpy[i])\n\n    cur, maxGrumpy = 0, 0\n\n    for idx, customer in enumerate(customers):\n        cur += customer if grumpy[idx] else 0\n\n        if idx &lt; k - 1:\n            continue\n\n        maxGrumpy = max(maxGrumpy, cur)\n\n        cur -= customers[idx - k + 1] if grumpy[idx - k + 1] else 0\n\n    return total_satisfied + maxGrumpy\n\n\ncustomers = [1, 0, 1, 2, 1, 1, 7, 5]\ngrumpy = [0, 1, 0, 1, 0, 1, 0, 1]\nminutes = 3\nprint(maxSatisfied(customers, grumpy, minutes))  # 16\n</code></pre>"},{"location":"EndlessCheng/%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%9F%BA%E7%A1%80_fixed_sliding_window_basics/#1652-defuse-the-bomb","title":"1652. Defuse the Bomb","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sliding Window</p> </li> </ul> Python <pre><code>\"\"\"\n-   How to deal with the _circular array_?\n    -   Trick: mod (index % length)\n\"\"\"\n\nfrom typing import List\n\n\n# Sliding Window Fixed Size\ndef decrypt(code: List[int], k: int) -&gt; List[int]:\n    n = len(code)\n    res = [0 for _ in range(n)]\n    if k == 0:\n        return res\n\n    left, right = (1, k) if k &gt; 0 else (n + k, n - 1)\n\n    curSum = 0\n    for i in range(left, right + 1):\n        curSum += code[i % n]\n\n    for i in range(n):\n        res[i] = curSum\n\n        curSum -= code[left % n]\n        left += 1\n        right += 1\n        curSum += code[right % n]\n\n    return res\n\n\ncode = [2, 4, 9, 3]\nk = -2\nprint(decrypt(code, k))  # [12, 5, 6, 13]\n</code></pre>"},{"location":"EndlessCheng/%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%9F%BA%E7%A1%80_fixed_sliding_window_basics/#1176-diet-plan-performance","title":"1176. Diet Plan Performance \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sliding Window</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Sliding Window Fixed Size\ndef dietPlanPerformance(calories: List[int], k: int, lower: int, upper: int) -&gt; int:\n    res, T = 0, 0\n\n    for i in range(len(calories)):\n        T += calories[i]\n\n        if i &lt; k - 1:\n            continue\n\n        if T &lt; lower:\n            res -= 1\n        elif T &gt; upper:\n            res += 1\n\n        T -= calories[i - k + 1]\n\n    return res\n\n\nif __name__ == \"__main__\":\n    calories = [1, 2, 3, 4, 5]\n    k = 1\n    lower = 3\n    upper = 3\n\n    assert dietPlanPerformance(calories, k, lower, upper) == 0\n</code></pre>"},{"location":"EndlessCheng/%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%9F%BA%E7%A1%80_fixed_sliding_window_basics/#1100-find-k-length-substrings-with-no-repeated-characters","title":"1100. Find K-Length Substrings With No Repeated Characters \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> Python <pre><code>from collections import defaultdict\n\n\n# Sliding Window Fixed Size\ndef numKLenSubstrNoRepeats(s: str, k: int) -&gt; int:\n    n = len(s)\n    if k &gt; n:\n        return 0\n\n    counts = defaultdict(int)\n    res = 0\n\n    for i, ch in enumerate(s):\n        # add to the window\n        counts[ch] += 1\n\n        # form a valid window\n        if i &lt; k - 1:\n            continue\n\n        # update\n        res += 1 if len(counts) == k else 0\n\n        # remove from the window\n        first = i - k + 1\n        counts[s[first]] -= 1\n        if counts[s[first]] == 0:\n            del counts[s[first]]\n\n    return res\n\n\nif __name__ == \"__main__\":\n    s = \"havefunonleetcode\"\n    k = 5\n\n    assert numKLenSubstrNoRepeats(s, k) == 6\n</code></pre>"},{"location":"EndlessCheng/%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%9F%BA%E7%A1%80_fixed_sliding_window_basics/#1852-distinct-numbers-in-each-subarray","title":"1852. Distinct Numbers in Each Subarray \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Sliding Window</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Sliding Window Fixed Size\ndef distinctNumbers(nums: List[int], k: int) -&gt; List[int]:\n    res = []\n    counts = defaultdict(int)\n\n    for right in range(len(nums)):\n        counts[nums[right]] += 1  # add\n\n        if right &lt; k - 1:  # form\n            continue\n\n        res.append(len(counts))  # update\n\n        left = right - k + 1  # remove\n        counts[nums[left]] -= 1\n        if counts[nums[left]] == 0:\n            del counts[nums[left]]\n\n    return res\n\n\nif __name__ == \"__main__\":\n    nums = [1, 2, 3, 2, 2, 1, 3]\n    k = 3\n    assert distinctNumbers(nums, k) == [3, 2, 2, 2, 3]\n</code></pre>"},{"location":"EndlessCheng/%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%9F%BA%E7%A1%80_fixed_sliding_window_basics/#1151-minimum-swaps-to-group-all-1s-together","title":"1151. Minimum Swaps to Group All 1's Together \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sliding Window</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef minSwaps(data: List[int]) -&gt; int:\n    n = len(data)\n    total = sum(data)\n\n    if total == 0 or total == 1 or total == n:\n        return 0\n\n    max_count = 0\n    cur = 0\n    left = 0\n\n    for right in range(n):\n        cur += data[right]\n\n        if right - left + 1 &gt; total:\n            cur -= data[left]\n            left += 1\n\n        max_count = max(max_count, cur)\n\n    return total - max_count\n\n\ndata = [1, 0, 1, 0, 1]\nprint(minSwaps(data))  # 1\n</code></pre>"},{"location":"EndlessCheng/%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%9F%BA%E7%A1%80_fixed_sliding_window_basics/#2107-number-of-unique-flavors-after-sharing-k-candies","title":"2107. Number of Unique Flavors After Sharing K Candies \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Sliding Window</p> </li> </ul> Python <pre><code>from collections import Counter\nfrom typing import List\n\n\n# Sliding Window Fixed Size\ndef shareCandies(candies: List[int], k: int) -&gt; int:\n    res = 0\n    n = len(candies)\n    counts = Counter(candies)\n\n    if k &gt;= n:\n        return 0\n    if k == 0:\n        return len(counts)\n\n    for right in range(n):\n        counts[candies[right]] -= 1  # remove\n        if counts[candies[right]] == 0:\n            del counts[candies[right]]\n\n        if right &lt; k - 1:  # form the window\n            continue\n\n        res = max(res, len(counts))  # update\n\n        left = right - k + 1  # add\n        counts[candies[left]] += 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    candies = [1, 2, 2, 3, 4, 3]\n    k = 3\n    assert shareCandies(candies, k) == 3\n</code></pre>"},{"location":"EndlessCheng/%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E8%BF%9B%E9%98%B6_fixed_sliding_window_size_advanced/","title":"\u5b9a\u957f\u6ed1\u52a8\u7a97\u53e3\u8fdb\u9636 Fixed Sliding Window Size Advanced","text":""},{"location":"EndlessCheng/%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E8%BF%9B%E9%98%B6_fixed_sliding_window_size_advanced/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1461. Check If a String Contains All Binary Codes of Size K (Medium)</li> <li> 2134. Minimum Swaps to Group All 1's Together II (Medium)</li> <li> 1297. Maximum Number of Occurrences of a Substring (Medium)</li> <li> 2653. Sliding Subarray Beauty (Medium)</li> <li> 3439. Reschedule Meetings for Maximum Free Time I (Medium)</li> <li> 1888. Minimum Number of Flips to Make the Binary String Alternating (Medium)</li> <li> 567. Permutation in String (Medium)</li> <li> 438. Find All Anagrams in a String (Medium)</li> <li> 30. Substring with Concatenation of All Words (Hard)</li> <li> 2156. Find Substring With Given Hash Value (Hard)</li> <li> 2953. Count Complete Substrings (Hard)</li> <li> 1016. Binary String With Substrings Representing 1 To N (Medium)</li> <li> 683. K Empty Slots (Hard) \ud83d\udc51</li> <li> 2067. Number of Equal Count Substrings (Medium) \ud83d\udc51</li> <li> 2524. Maximum Frequency Score of a Subarray (Hard) \ud83d\udc51</li> </ul>"},{"location":"EndlessCheng/%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E8%BF%9B%E9%98%B6_fixed_sliding_window_size_advanced/#1461-check-if-a-string-contains-all-binary-codes-of-size-k","title":"1461. Check If a String Contains All Binary Codes of Size K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Bit Manipulation, Rolling Hash, Hash Function</p> </li> </ul>"},{"location":"EndlessCheng/%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E8%BF%9B%E9%98%B6_fixed_sliding_window_size_advanced/#2134-minimum-swaps-to-group-all-1s-together-ii","title":"2134. Minimum Swaps to Group All 1's Together II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E8%BF%9B%E9%98%B6_fixed_sliding_window_size_advanced/#1297-maximum-number-of-occurrences-of-a-substring","title":"1297. Maximum Number of Occurrences of a Substring","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E8%BF%9B%E9%98%B6_fixed_sliding_window_size_advanced/#2653-sliding-subarray-beauty","title":"2653. Sliding Subarray Beauty","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E8%BF%9B%E9%98%B6_fixed_sliding_window_size_advanced/#3439-reschedule-meetings-for-maximum-free-time-i","title":"3439. Reschedule Meetings for Maximum Free Time I","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E8%BF%9B%E9%98%B6_fixed_sliding_window_size_advanced/#1888-minimum-number-of-flips-to-make-the-binary-string-alternating","title":"1888. Minimum Number of Flips to Make the Binary String Alternating","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Greedy, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E8%BF%9B%E9%98%B6_fixed_sliding_window_size_advanced/#567-permutation-in-string","title":"567. Permutation in String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Two Pointers, String, Sliding Window</p> </li> </ul> Python <pre><code>def checkInclusion(s1: str, s2: str) -&gt; bool:\n    if len(s1) &gt; len(s2):\n        return False\n\n    count1 = [0] * 26\n    count2 = [0] * 26\n\n    for i in range(len(s1)):\n        count1[ord(s1[i]) - ord(\"a\")] += 1\n        count2[ord(s2[i]) - ord(\"a\")] += 1\n\n    matches = 0\n    for i in range(26):\n        if count1[i] == count2[i]:\n            matches += 1\n\n    l = 0\n    for r in range(len(s1), len(s2)):\n        if matches == 26:\n            return True\n\n        index = ord(s2[r]) - ord(\"a\")\n        count2[index] += 1\n        if count1[index] == count2[index]:\n            matches += 1\n        elif count1[index] + 1 == count2[index]:\n            matches -= 1\n\n        index = ord(s2[l]) - ord(\"a\")\n        count2[index] -= 1\n        if count1[index] == count2[index]:\n            matches += 1\n        elif count1[index] - 1 == count2[index]:\n            matches -= 1\n\n        l += 1\n\n    return matches == 26\n\n\ns1 = \"ab\"\ns2 = \"eidba\"\nprint(checkInclusion(s1, s2))  # True\n</code></pre>"},{"location":"EndlessCheng/%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E8%BF%9B%E9%98%B6_fixed_sliding_window_size_advanced/#438-find-all-anagrams-in-a-string","title":"438. Find All Anagrams in a String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Sliding Window Fixed Size\ndef findAnagrams(s: str, p: str) -&gt; List[int]:\n    n, k = len(s), len(p)\n    target = [0 for _ in range(26)]\n    for ch in p:\n        target[ord(ch) - ord(\"a\")] += 1\n\n    count = [0 for _ in range(26)]\n    left = 0\n    res = []\n\n    for right in range(n):\n        count[ord(s[right]) - ord(\"a\")] += 1\n        if right &lt; k - 1:\n            continue\n\n        if count == target:\n            res.append(left)\n\n        count[ord(s[left]) - ord(\"a\")] -= 1\n        left += 1\n\n    return res\n\n\ns = \"cbaebabacd\"\np = \"abc\"\nprint(findAnagrams(s, p))  # [0, 6]\n</code></pre>"},{"location":"EndlessCheng/%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E8%BF%9B%E9%98%B6_fixed_sliding_window_size_advanced/#30-substring-with-concatenation-of-all-words","title":"30. Substring with Concatenation of All Words","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E8%BF%9B%E9%98%B6_fixed_sliding_window_size_advanced/#2156-find-substring-with-given-hash-value","title":"2156. Find Substring With Given Hash Value","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Sliding Window, Rolling Hash, Hash Function</p> </li> </ul>"},{"location":"EndlessCheng/%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E8%BF%9B%E9%98%B6_fixed_sliding_window_size_advanced/#2953-count-complete-substrings","title":"2953. Count Complete Substrings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul>"},{"location":"EndlessCheng/%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E8%BF%9B%E9%98%B6_fixed_sliding_window_size_advanced/#1016-binary-string-with-substrings-representing-1-to-n","title":"1016. Binary String With Substrings Representing 1 To N","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String</p> </li> </ul>"},{"location":"EndlessCheng/%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E8%BF%9B%E9%98%B6_fixed_sliding_window_size_advanced/#683-k-empty-slots","title":"683. K Empty Slots \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Indexed Tree, Segment Tree, Queue, Sliding Window, Heap Priority Queue, Ordered Set, Monotonic Queue</p> </li> </ul>"},{"location":"EndlessCheng/%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E8%BF%9B%E9%98%B6_fixed_sliding_window_size_advanced/#2067-number-of-equal-count-substrings","title":"2067. Number of Equal Count Substrings \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Counting, Prefix Sum</p> </li> </ul>"},{"location":"EndlessCheng/%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E8%BF%9B%E9%98%B6_fixed_sliding_window_size_advanced/#2524-maximum-frequency-score-of-a-subarray","title":"2524. Maximum Frequency Score of a Subarray \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Stack, Sliding Window</p> </li> </ul>"},{"location":"LeetPattern/array/","title":"Array","text":""},{"location":"LeetPattern/array/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 414. Third Maximum Number (Easy)</li> <li> 169. Majority Element (Easy)</li> <li> 2022. Convert 1D Array Into 2D Array (Easy)</li> <li> 54. Spiral Matrix (Medium)</li> <li> 59. Spiral Matrix II (Medium)</li> </ul>"},{"location":"LeetPattern/array/#414-third-maximum-number","title":"414. Third Maximum Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sorting</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the third maximum number in an array. If the third maximum does not exist, return the maximum number.\n\"\"\"\n\nfrom typing import List\n\n\n# Sort\ndef thirdMaxSort(nums: List[int]) -&gt; int:\n    nums = list(set(nums))\n    nums.sort(reverse=True)\n\n    return nums[2] if len(nums) &gt;= 3 else nums[0]\n\n\n# Compare\ndef thirdMaxCompare(nums: List[int]) -&gt; int:\n    first, second, third = float(\"-inf\"), float(\"-inf\"), float(\"-inf\")\n\n    for num in nums:\n        if num &gt; first:\n            first, second, third = num, first, second\n        elif first &gt; num &gt; second:\n            second, third = num, second\n        elif second &gt; num &gt; third:\n            third = num\n\n    return third if third != float(\"-inf\") else first\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Sort     |    O(NlogN)     |     O(N)     |\n# |  Compare    |       O(N)      |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\nprint(thirdMaxSort([3, 2, 1]))  # 1\nprint(thirdMaxCompare([3, 2, 1]))  # 1\n</code></pre>"},{"location":"LeetPattern/array/#169-majority-element","title":"169. Majority Element","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Divide And Conquer, Sorting, Counting</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the majority element in an array. The majority element is the element that appears more than `n // 2` times.\n\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/7pnhv842keE?si=fBYlNfKzdkiLgkF1\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen&gt;&lt;/iframe&gt;\n\n| `num` | `count` | `res` |\n| ----- | ------- | ----- |\n| 2     | 1       | 2     |\n| 2     | 2       | 2     |\n| 1     | 1       | 2     |\n| 1     | 0       | 2     |\n| 1     | 1       | 1     |\n| 2     | 0       | 1     |\n| 2     | 1       | 2     |\n\"\"\"\n\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Hash Map\ndef majorityElementHashMap(nums: List[int]) -&gt; int:\n    n = len(nums)\n    freq = defaultdict(int)\n\n    for num in nums:\n        freq[num] += 1\n        if freq[num] &gt; n // 2:\n            return num\n\n\n# Array - Boyer-Moore Voting Algorithm\ndef majorityElementArray(nums: List[int]) -&gt; int:\n    res = None\n    count = 0\n\n    for num in nums:\n        if count == 0:\n            res = num\n        count += 1 if num == res else -1\n\n    return res\n\n\n# | Algorithm | Time Complexity | Space Complexity |\n# |-----------|-----------------|------------------|\n# | HashMap   | O(N)            | O(N)             |\n# | Array     | O(N)            | O(1)             |\n# |-----------|-----------------|------------------|\n\n\nnums = [2, 2, 1, 1, 1, 2, 2]\nprint(majorityElementArray(nums))  # 2\nprint(majorityElementHashMap(nums))  # 2\n</code></pre>"},{"location":"LeetPattern/array/#2022-convert-1d-array-into-2d-array","title":"2022. Convert 1D Array Into 2D Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Matrix, Simulation</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Brute Force\ndef construct2DArray(original: List[int], m: int, n: int) -&gt; List[List[int]]:\n    if len(original) != m * n:\n        return []\n    array = []\n\n    for i in range(m):\n        row = original[n * i : n * (i + 1)]\n        array.append(row)\n\n    return array\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |  Brute     |  O(m)  |  O(1)   |\n# |------------|--------|---------|\n\n\noriginal = [1, 2, 3, 4]\nm = 2\nn = 2\n\nprint(construct2DArray(original, m, n))  # [[1, 2], [3, 4]]\n</code></pre>"},{"location":"LeetPattern/array/#54-spiral-matrix","title":"54. Spiral Matrix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Matrix, Simulation</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return all elements of the matrix in spiral order.\n\"\"\"\n\nfrom typing import List\n\n\n# Array\ndef spiralOrder(matrix: List[List[int]]) -&gt; List[int]:\n    if not matrix or not matrix[0]:\n        return []\n\n    res = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n\n    while top &lt;= bottom and left &lt;= right:\n\n        for i in range(left, right + 1):\n            res.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            res.append(matrix[i][right])\n        right -= 1\n\n        if top &lt;= bottom:\n\n            for i in range(right, left - 1, -1):\n                res.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left &lt;= right:\n\n            for i in range(bottom, top - 1, -1):\n                res.append(matrix[i][left])\n            left += 1\n\n    return res\n\n\n# Math\ndef spiralOrderMath(matrix: List[List[int]]) -&gt; List[int]:\n    dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]]  # Right Down Left Up\n    m, n = len(matrix), len(matrix[0])\n    size = m * n\n    res = []\n    i, j, di = 0, -1, 0\n\n    while len(res) &lt; size:\n        dx, dy = dirs[di]\n        for _ in range(n):\n            i += dx\n            j += dy\n            res.append(matrix[i][j])\n        di = (di + 1) % 4\n        n, m = m - 1, n\n\n    return res\n\n\nprint(spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n# [1, 2, 3, 6, 9, 8, 7, 4, 5]\nprint(spiralOrderMath([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]))\n# [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]\n</code></pre>"},{"location":"LeetPattern/array/#59-spiral-matrix-ii","title":"59. Spiral Matrix II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Matrix, Simulation</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return a square matrix filled with elements from 1 to n^2 in spiral order.\n\"\"\"\n\nfrom pprint import pprint\nfrom typing import List\n\n\n# Array\ndef generateMatrix(n: int) -&gt; List[List[int]]:\n    matrix = [[0] * n for _ in range(n)]\n    num = 1\n\n    for layer in range((n + 1) // 2):\n        for i in range(layer, n - layer):\n            matrix[layer][i] = num\n            num += 1\n        for j in range(layer + 1, n - layer):\n            matrix[j][n - 1 - layer] = num\n            num += 1\n        for i in range(n - 2 - layer, layer - 1, -1):\n            matrix[n - 1 - layer][i] = num\n            num += 1\n        for j in range(n - 2 - layer, layer, -1):\n            matrix[j][layer] = num\n            num += 1\n\n    return matrix\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |   Layer     |      O(N^2)     |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\npprint(generateMatrix(5))\n# [[ 1,  2,  3,  4, 5],\n#  [16, 17, 18, 19, 6],\n#  [15, 24, 25, 20, 7],\n#  [14, 23, 22, 21, 8],\n#  [13, 12, 11, 10, 9]]\n</code></pre>"},{"location":"LeetPattern/backtracking/","title":"Backtracking","text":""},{"location":"LeetPattern/backtracking/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 77. Combinations (Medium)</li> <li> 17. Letter Combinations of a Phone Number (Medium)</li> <li> 39. Combination Sum (Medium)</li> <li> 40. Combination Sum II (Medium)</li> <li> 216. Combination Sum III (Medium)</li> <li> 131. Palindrome Partitioning (Medium)</li> <li> 93. Restore IP Addresses (Medium)</li> <li> 78. Subsets (Medium)</li> <li> 90. Subsets II (Medium)</li> <li> 491. Non-decreasing Subsequences (Medium)</li> <li> 46. Permutations (Medium)</li> <li> 47. Permutations II (Medium)</li> <li> 51. N-Queens (Hard)</li> <li> 37. Sudoku Solver (Hard)</li> <li> 79. Word Search (Medium)</li> <li> 212. Word Search II (Hard)</li> </ul>"},{"location":"LeetPattern/backtracking/#77-combinations","title":"77. Combinations","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Backtracking</p> </li> </ul> Python <pre><code>import itertools\nfrom typing import List\n\n\n# Backtracking\ndef combine(n: int, k: int) -&gt; List[List[int]]:\n    res = []\n\n    def backtrack(start, path):\n        if len(path) == k:\n            res.append(path[:])\n            return None\n\n        for i in range(start, n + 1):\n            path.append(i)\n            backtrack(i + 1, path)\n            path.pop()\n\n    backtrack(1, [])\n\n    return res\n\n\n# itertools\ndef combineItertools(n: int, k: int) -&gt; List[List[int]]:\n    path = itertools.combinations(range(1, n + 1), k)\n    return path\n\n\nprint(combine(4, 2))\n# [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\nprint(list(combineItertools(4, 2)))\n# [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]\n</code></pre>"},{"location":"LeetPattern/backtracking/#17-letter-combinations-of-a-phone-number","title":"17. Letter Combinations of a Phone Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Backtracking</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return all possible letter combinations that the number could represent.\n\n![17](https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png)\n\"\"\"\n\nfrom typing import List\n\n\n# Backtracking\ndef letterCombinations(digits: str) -&gt; List[str]:\n    letter_map = {\n        \"2\": \"abc\",\n        \"3\": \"def\",\n        \"4\": \"ghi\",\n        \"5\": \"jkl\",\n        \"6\": \"mno\",\n        \"7\": \"pqrs\",\n        \"8\": \"tuv\",\n        \"9\": \"wxyz\",\n    }\n\n    n = len(digits)\n    if n == 0:\n        return []\n\n    res = []\n\n    def dfs(idx, path):\n        if idx == n:\n            res.append(path)\n            return None\n\n        letters = letter_map[digits[idx]]\n\n        for i in range(len(letters)):\n            dfs(idx + 1, path + letters[i])\n\n    dfs(0, \"\")\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert letterCombinations(\"23\") == [\n        \"ad\",\n        \"ae\",\n        \"af\",\n        \"bd\",\n        \"be\",\n        \"bf\",\n        \"cd\",\n        \"ce\",\n        \"cf\",\n    ]\n</code></pre>"},{"location":"LeetPattern/backtracking/#39-combination-sum","title":"39. Combination Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef combinationSum(candidates: List[int], target: int) -&gt; List[List[int]]:\n    n = len(candidates)\n    res, path = [], []\n\n    def dfs(total, start):\n        if total &gt; target:\n            return\n        if total == target:\n            res.append(path.copy())\n            return\n\n        for i in range(start, n):\n            total += candidates[i]\n            path.append(candidates[i])\n            dfs(total, i)\n            total -= candidates[i]\n            path.pop()\n\n    dfs(0, 0)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(combinationSum([2, 3, 5], 8))\n    # [[2, 2, 2, 2], [2, 3, 3], [3, 5]]\n    print(combinationSum([2, 3, 6, 7], 7))\n    # [[2, 2, 3], [7]]\n</code></pre>"},{"location":"LeetPattern/backtracking/#40-combination-sum-ii","title":"40. Combination Sum II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef combinationSum2(candidates: List[int], target: int) -&gt; List[List[int]]:\n    result, path = [], []\n    candidates.sort()\n\n    def backtracking(total, start):\n        if total == target:\n            result.append(path[:])\n            return None\n\n        for i in range(start, len(candidates)):\n\n            if i &gt; start and candidates[i] == candidates[i - 1]:\n                continue\n\n            if total + candidates[i] &gt; target:\n                break\n\n            total += candidates[i]\n            path.append(candidates[i])\n            backtracking(total, i + 1)\n            total -= candidates[i]\n            path.pop()\n\n    backtracking(0, 0)\n\n    return result\n\n\nprint(combinationSum2([10, 1, 2, 7, 6, 1, 5], 8))\n# [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n</code></pre>"},{"location":"LeetPattern/backtracking/#216-combination-sum-iii","title":"216. Combination Sum III","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking</p> </li> </ul> Python <pre><code>import itertools\nfrom typing import List\n\n\n# 1. Backtracking\ndef combinationSum3(k: int, n: int) -&gt; List[List[int]]:\n    path, result = [], []\n\n    def backtracking(start):\n        if len(path) == k and sum(path) == n:\n            result.append(path[:])\n            return\n\n        for i in range(start, 10):\n            path.append(i)\n            backtracking(i + 1)\n            path.pop()\n\n    backtracking(1)\n\n    return result\n\n\n# 2. Itertools\ndef combinationSum3Itertools(k: int, n: int) -&gt; List[List[int]]:\n    combinations = itertools.combinations(range(1, 10), k)\n    result = []\n\n    for i in combinations:\n        if sum(i) == n:\n            result.append(i)\n\n    return result\n\n\nprint(combinationSum3(3, 7))  # [[1, 2, 4]]\nprint(combinationSum3Itertools(3, 7))  # [(1, 2, 4)]\n</code></pre>"},{"location":"LeetPattern/backtracking/#131-palindrome-partitioning","title":"131. Palindrome Partitioning","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Backtracking</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Backtracking\ndef partition(s: str) -&gt; List[List[str]]:\n    n = len(s)\n    res, path = [], []\n\n    def dfs(start):\n        if start == n:\n            res.append(path.copy())\n            return\n\n        for end in range(start, n):\n            cur = s[start : end + 1]\n            if cur == cur[::-1]:\n                path.append(cur)\n                dfs(end + 1)\n                path.pop()\n\n    dfs(0)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(partition(\"aab\"))\n    # [['a', 'a', 'b'], ['aa', 'b']]\n</code></pre>"},{"location":"LeetPattern/backtracking/#93-restore-ip-addresses","title":"93. Restore IP Addresses","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Backtracking</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef restoreIpAddresses(s: str) -&gt; List[str]:\n    result = []\n\n    def backtracking(start_index, point_num, current, result):\n        # stop condition\n        if point_num == 3:\n            if is_valid(s, start_index, len(s) - 1):\n                current += s[start_index:]\n                result.append(current)\n            return\n\n        for i in range(start_index, len(s)):\n            if is_valid(s, start_index, i):\n                sub = s[start_index : i + 1]\n                backtracking(i + 1, point_num + 1, current + sub + \".\", result)\n            else:\n                break\n\n    def is_valid(s, start, end):\n        if start &gt; end:\n            return False\n\n        if s[start] == \"0\" and start != end:\n            return False\n\n        num = 0\n        for i in range(start, end + 1):\n            if not s[i].isdigit():\n                return False\n            num = num * 10 + int(s[i])\n            if num &gt; 255:\n                return False\n        return True\n\n    backtracking(0, 0, \"\", result)\n\n    return result\n\n\nprint(restoreIpAddresses(\"25525511135\"))\n# ['255.255.11.135', '255.255.111.35']\n</code></pre>"},{"location":"LeetPattern/backtracking/#78-subsets","title":"78. Subsets","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking, Bit Manipulation</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Iterative Inclusion Backtracking\ndef subsets_iterative_inclusion(nums: List[int]) -&gt; List[List[int]]:\n    n = len(nums)\n    res, path = [], []\n\n    def dfs(i):\n        res.append(path.copy())\n\n        for j in range(i, n):\n            path.append(nums[j])\n            dfs(j + 1)\n            path.pop()\n\n    dfs(0)\n\n    return res\n\n\n# Binary Decision Backtracking\ndef subsets_binary_decision(nums: List[int]) -&gt; List[List[int]]:\n    n = len(nums)\n    res, path = [], []\n\n    def dfs(i):\n        if i == n:\n            res.append(path.copy())\n            return\n\n        # Exclude\n        dfs(i + 1)\n\n        # Include\n        path.append(nums[i])\n        dfs(i + 1)\n        path.pop()\n\n    dfs(0)\n\n    return res\n\n\nprint(subsets_iterative_inclusion([1, 2, 3]))\n# [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]\nprint(subsets_binary_decision([1, 2, 3]))\n# [[], [3], [2], [2, 3], [1], [1, 3], [1, 2], [1, 2, 3]]\n</code></pre>"},{"location":"LeetPattern/backtracking/#90-subsets-ii","title":"90. Subsets II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking, Bit Manipulation</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef subsetsWithDup(nums: List[int]) -&gt; List[List[int]]:\n    path, result = [], []\n    nums.sort()\n\n    def backtracking(startIndex):\n        if path not in result:\n            result.append(path[:])\n\n        for i in range(startIndex, len(nums)):\n            path.append(nums[i])\n            backtracking(i + 1)\n            path.pop()\n\n    backtracking(startIndex=0)\n\n    return result\n\n\nprint(subsetsWithDup([1, 2, 2]))\n# [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]\n</code></pre>"},{"location":"LeetPattern/backtracking/#491-non-decreasing-subsequences","title":"491. Non-decreasing Subsequences","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Backtracking, Bit Manipulation</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef findSubsequences(nums: List[int]) -&gt; List[List[int]]:\n    path, result = [], []\n\n    def backtracking(startIndex):\n        if len(path) &gt; 1:\n            result.append(path[:])\n\n        used = set()\n        for i in range(startIndex, len(nums)):\n\n            if (path and nums[i] &lt; path[-1]) or nums[i] in used:\n                continue\n\n            used.add(nums[i])\n            path.append(nums[i])\n            backtracking(i + 1)\n            path.pop()\n\n    backtracking(0)\n\n    return result\n\n\nprint(findSubsequences([4, 6, 7, 7]))\n# [[4, 6], [4, 6, 7], [4, 6, 7, 7], [4, 7], [4, 7, 7], [6, 7], [6, 7, 7], [7, 7]]\n</code></pre>"},{"location":"LeetPattern/backtracking/#46-permutations","title":"46. Permutations","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Backtracking\ndef permute(nums: List[int]) -&gt; List[List[int]]:\n    n = len(nums)\n    path, res = [], []\n    used = [False for _ in range(n)]\n\n    def dfs(x: int):\n        if x == n:\n            res.append(path[:])\n            return\n\n        for i in range(n):\n            if used[i]:\n                continue\n            used[i] = True\n            path.append(nums[i])\n            dfs(x + 1)\n            path.pop()\n            used[i] = False\n\n    dfs(0)\n\n    return res\n\n\nprint(permute([1, 2, 3]))\n# [[1, 2, 3], [1, 3, 2], [2, 1, 3],\n#  [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n</code></pre>"},{"location":"LeetPattern/backtracking/#47-permutations-ii","title":"47. Permutations II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking, Sorting</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef permuteUnique(nums: List[int]) -&gt; List[List[int]]:\n    nums.sort()\n    path, result = [], []\n    used = [False for _ in range(len(nums))]\n\n    def backtracking():\n        if len(path) == len(nums):\n            result.append(path[:])\n\n        for i in range(len(nums)):\n            if used[i]:\n                continue\n            if i &gt; 0 and nums[i] == nums[i - 1] and not used[i - 1]:\n                continue\n\n            used[i] = True\n            path.append(nums[i])\n            backtracking()\n            path.pop()\n            used[i] = False\n\n    backtracking()\n\n    return result\n\n\nprint(permuteUnique([1, 1, 2]))\n# [[1, 1, 2], [1, 2, 1], [2, 1, 1]]\n</code></pre>"},{"location":"LeetPattern/backtracking/#51-n-queens","title":"51. N-Queens","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking</p> </li> </ul> Python <pre><code>\"\"\"\n- Hard\n- [N-Queens](https://leetcode.com/problems/n-queens/)\n- [N \u7687\u540e](https://leetcode.cn/problems/n-queens/)\n\"\"\"\n\nfrom typing import List\n\n\n# Backtracking\ndef solveNQueens(n: int) -&gt; List[List[str]]:\n    res = []\n    board = [\".\" * n for _ in range(n)]\n\n    def dfs(row):\n        if row == n:\n            res.append(board[:])\n            return None\n        for col in range(n):\n            if is_valid(row, col, board):\n                board[row] = board[row][:col] + \"Q\" + board[row][col + 1 :]\n                dfs(row + 1)\n                board[row] = board[row][:col] + \".\" + board[row][col + 1 :]\n\n    def is_valid(row, col, chessboard):\n        for i in range(row):\n            if chessboard[i][col] == \"Q\":\n                return False\n\n        i, j = row - 1, col - 1\n        while i &gt;= 0 and j &gt;= 0:\n            if chessboard[i][j] == \"Q\":\n                return False\n            i -= 1\n            j -= 1\n\n        i, j = row - 1, col + 1\n        while i &gt;= 0 and j &lt; len(chessboard):\n            if chessboard[i][j] == \"Q\":\n                return False\n            i -= 1\n            j += 1\n\n        return True\n\n    dfs(0)\n\n    return [[\"\".join(row) for row in i] for i in res]\n\n\n# Backtracking\ndef solveNQueens2(n: int) -&gt; List[List[str]]:\n    res = []\n    queens = [0] * n\n    col = [False] * n\n    diag1 = [False] * (n * 2 - 1)\n    diag2 = [False] * (n * 2 - 1)\n\n    def dfs(r: int) -&gt; None:\n        if r == n:\n            res.append([\".\" * c + \"Q\" + \".\" * (n - 1 - c) for c in queens])\n            return\n\n        for c, ok in enumerate(col):\n            if not ok and not diag1[r + c] and not diag2[r - c]:\n                queens[r] = c\n                col[c] = diag1[r + c] = diag2[r - c] = True\n                dfs(r + 1)\n                col[c] = diag1[r + c] = diag2[r - c] = False\n\n    dfs(0)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(solveNQueens(4))\n    # [['.Q..', '...Q', 'Q...', '..Q.'],\n    #  ['..Q.', 'Q...', '...Q', '.Q..']]\n    print(solveNQueens(1))\n    # [['Q']]\n    print(solveNQueens2(4))\n    # [['.Q..', '...Q', 'Q...', '..Q.'],\n    #  ['..Q.', 'Q...', '...Q', '.Q..']]\n    print(solveNQueens2(1))\n    # [['Q']]\n</code></pre>"},{"location":"LeetPattern/backtracking/#37-sudoku-solver","title":"37. Sudoku Solver","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Backtracking, Matrix</p> </li> </ul> Python <pre><code>\"\"\"\n- [Sudoku Solver](https://leetcode.com/problems/sudoku-solver/)\n- [\u89e3\u6570\u72ec](https://leetcode.cn/problems/sudoku-solver/)\n- Hard\n\"\"\"\n\nfrom pprint import pprint\nfrom typing import List\n\n\n# Backtracking - Board\ndef solveSudoku(board: List[List[str]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n\n    def backtracking(board: List[List[str]]) -&gt; bool:\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] != \".\":\n                    continue\n                for k in range(1, 10):\n                    if is_valid(i, j, k, board):\n                        board[i][j] = str(k)\n                        if backtracking(board):\n                            return True\n                        board[i][j] = \".\"\n                return False\n        return True\n\n    def is_valid(row: int, col: int, val: int, board: List[List[str]]) -&gt; bool:\n        for i in range(9):\n            if board[row][i] == str(val):\n                return False\n        for j in range(9):\n            if board[j][col] == str(val):\n                return False\n        start_row = (row // 3) * 3\n        start_col = (col // 3) * 3\n        for i in range(start_row, start_row + 3):\n            for j in range(start_col, start_col + 3):\n                if board[i][j] == str(val):\n                    return False\n        return True\n\n    backtracking(board)\n\n\nboard = [\n    [\"5\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],\n    [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n    [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n    [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n    [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n    [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n    [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"],\n    [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n    [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"],\n]\n\nsolveSudoku(board)\npprint(board)\n# [['5', '3', '4', '6', '7', '8', '9', '1', '2'],\n#  ['6', '7', '2', '1', '9', '5', '3', '4', '8'],\n#  ['1', '9', '8', '3', '4', '2', '5', '6', '7'],\n#  ['8', '5', '9', '7', '6', '1', '4', '2', '3'],\n#  ['4', '2', '6', '8', '5', '3', '7', '9', '1'],\n#  ['7', '1', '3', '9', '2', '4', '8', '5', '6'],\n#  ['9', '6', '1', '5', '3', '7', '2', '8', '4'],\n#  ['2', '8', '7', '4', '1', '9', '6', '3', '5'],\n#  ['3', '4', '5', '2', '8', '6', '1', '7', '9']]\n</code></pre>"},{"location":"LeetPattern/backtracking/#79-word-search","title":"79. Word Search","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Backtracking, Depth First Search, Matrix</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef exist(board: List[List[str]], word: str) -&gt; bool:\n    m, n = len(board), len(board[0])\n    path = set()\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n\n    def dfs(r, c, i):\n        if i == len(word):\n            return True\n\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or board[r][c] != word[i] or (r, c) in path:\n            return False\n\n        path.add((r, c))\n\n        for dr, dc in dirs:\n            if dfs(r + dr, c + dc, i + 1):\n                return True\n\n        path.remove((r, c))\n        return False\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, 0):\n                return True\n\n    return False\n\n\nboard = [\n    [\"A\", \"B\", \"C\", \"E\"],\n    [\"S\", \"F\", \"C\", \"S\"],\n    [\"A\", \"D\", \"E\", \"E\"],\n]\nword = \"ABCCED\"\nprint(exist(board, word))  # True\n</code></pre>"},{"location":"LeetPattern/backtracking/#212-word-search-ii","title":"212. Word Search II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Backtracking, Trie, Matrix</p> </li> </ul> Python <pre><code>from typing import List\n\nfrom leetpattern.utils import Trie\n\n\n# Backtracking + Trie\ndef findWords(board: List[List[str]], words: List[str]) -&gt; List[str]:\n    trie = Trie()\n    for word in words:\n        trie.add_word(word)\n\n    m, n = len(board), len(board[0])\n    result, visit = set(), set()\n\n    def dfs(r, c, node, word):\n        if (\n            r &lt; 0\n            or r &gt;= m\n            or c &lt; 0\n            or c &gt;= n\n            or (r, c) in visit\n            or board[r][c] not in node.children\n        ):\n            return None\n\n        visit.add((r, c))\n\n        node = node.children[board[r][c]]\n        word += board[r][c]\n        if node.is_word:\n            result.add(word)\n\n        dfs(r - 1, c, node, word)\n        dfs(r + 1, c, node, word)\n        dfs(r, c - 1, node, word)\n        dfs(r, c + 1, node, word)\n\n        visit.remove((r, c))\n\n    for r in range(m):\n        for c in range(n):\n            dfs(r, c, trie.root, \"\")\n\n    return list(result)\n\n\ndef test_find_words():\n    board = [\n        [\"o\", \"a\", \"a\", \"n\"],\n        [\"e\", \"t\", \"a\", \"e\"],\n        [\"i\", \"h\", \"k\", \"r\"],\n        [\"i\", \"f\", \"l\", \"v\"],\n    ]\n    words = [\"oath\", \"pea\", \"eat\", \"rain\"]\n    result = findWords(board, words)\n    assert sorted(result) == [\"eat\", \"oath\"]\n</code></pre>"},{"location":"LeetPattern/binary_search/","title":"Binary Search","text":""},{"location":"LeetPattern/binary_search/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 704. Binary Search (Easy)</li> <li> 35. Search Insert Position (Easy)</li> <li> 278. First Bad Version (Easy)</li> <li> 34. Find First and Last Position of Element in Sorted Array (Medium)</li> <li> 367. Valid Perfect Square (Easy)</li> <li> 875. Koko Eating Bananas (Medium)</li> <li> 1011. Capacity To Ship Packages Within D Days (Medium)</li> <li> 378. Kth Smallest Element in a Sorted Matrix (Medium)</li> </ul>"},{"location":"LeetPattern/binary_search/#704-binary-search","title":"704. Binary Search","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> Python <pre><code>\"\"\"\n- Implement binary search algorithm.\n\"\"\"\n\nfrom typing import List\n\n\n# Binary Search [left, right]\ndef search(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] &lt; target:\n            left = mid + 1\n        elif nums[mid] &gt; target:\n            right = mid - 1\n        else:\n            return mid\n\n    return -1\n\n\n# Binary Search [left, right)\ndef search_half_open(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums)\n\n    while left &lt; right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] &lt; target:\n            left = mid + 1\n        elif nums[mid] &gt; target:\n            right = mid\n        else:\n            return mid\n\n    return -1\n\n\n# Binary Search (left, right)\ndef search_open_interval(nums: List[int], target: int) -&gt; int:\n    left, right = -1, len(nums)\n\n    while left + 1 &lt; right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] &lt; target:\n            left = mid\n        elif nums[mid] &gt; target:\n            right = mid\n        else:\n            return mid\n\n    return -1\n\n\nif __name__ == \"__main__\":\n    nums = [-1, 0, 3, 5, 9, 12]\n    target = 9\n    assert search(nums, target) == 4\n    assert search_half_open(nums, target) == 4\n    assert search_open_interval(nums, target) == 4\n</code></pre>"},{"location":"LeetPattern/binary_search/#35-search-insert-position","title":"35. Search Insert Position","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return the index of the target if it is found. If not, return the index where it would be if it were inserted in order.\n\"\"\"\n\nfrom typing import List\n\n\n# Binary Search\ndef searchInsert(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        if nums[mid] &lt; target:\n            left = mid + 1\n        elif nums[mid] &gt; target:\n            right = mid - 1\n        else:\n            return mid\n\n    return left\n\n\nnums = [1, 3, 5, 6]\ntarget = 5\nprint(searchInsert(nums, target))  # 2\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int searchInsert(vector&lt;int&gt;&amp; nums, int target) {\n        int left = 0, right = nums.size() - 1;\n\n        while (left &lt;= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] &lt; target)\n                left = mid + 1;\n            else\n                right = mid - 1;\n        }\n        return left;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; nums = {1, 3, 5, 6};\n    assert(solution.searchInsert(nums, 5) == 2);\n    assert(solution.searchInsert(nums, 2) == 1);\n    assert(solution.searchInsert(nums, 7) == 4);\n    assert(solution.searchInsert(nums, 0) == 0);\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/binary_search/#278-first-bad-version","title":"278. First Bad Version","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Binary Search, Interactive</p> </li> </ul> Python <pre><code>\"\"\"\n-   Find the first bad version given a function `isBadVersion`.\n\"\"\"\n\n\n# Binary Search\ndef firstBadVersion(n: int) -&gt; int:\n    left, right = 1, n\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if isBadVersion(mid):\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return left\n\n\ndef isBadVersion(version: int) -&gt; bool:\n    pass\n</code></pre>"},{"location":"LeetPattern/binary_search/#34-find-first-and-last-position-of-element-in-sorted-array","title":"34. Find First and Last Position of Element in Sorted Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> PythonCPP <pre><code>from bisect import bisect_left\nfrom typing import List\n\n\nclass searchRange:\n    \"\"\"\n    \u627e lower bound \u548c upper bound\n    \u770b\u7075\u795e\u5bf9\u8fd9\u9053\u9898\u7684\u9898\u89e3\uff0c\u5206\u7c7b\u8ba8\u8bba\u533a\u95f4\u7684\u5199\u6cd5\n    target \u7684 upper bound \u662f target + 1 \u7684 lower bound - 1\n    \u8fd9\u6837\u5c31\u80fd\u7edf\u4e00\u7528 lower bound \u7684\u5199\u6cd5\n    \"\"\"\n\n    # [left, right]\n    def bisect_left_closed(self, nums, target):\n        \"\"\"\n        \u95ed\u533a\u95f4\u5199\u6cd5\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left &lt;= right:\n            mid = left + (right - left) // 2\n            if nums[mid] &lt; target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n\n    # [left, right)\n    def bisect_left_right_open(self, nums, target):\n        \"\"\"\n        \u5de6\u95ed\u53f3\u5f00\u533a\u95f4\u5199\u6cd5\n        \"\"\"\n        left, right = 0, len(nums)\n        while left &lt; right:\n            mid = left + (right - left) // 2\n            if nums[mid] &gt;= target:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\n    # (left, right)\n    def bisect_left_open(self, nums, target):\n        \"\"\"\n        \u63a8\u8350\u5f00\u533a\u95f4\u5199\u6cd5\n        \"\"\"\n        left, right = -1, len(nums)\n        while left + 1 &lt; right:\n            mid = left + (right - left) // 2\n            if nums[mid] &lt; target:\n                left = mid\n            else:\n                right = mid\n        return right\n\n    def search_range(self, nums: List[int], target: int) -&gt; List[int]:\n        # edge case\n        if not nums:\n            return [-1, -1]\n\n        lower = self.bisect_left_closed(nums, target)\n        upper = self.bisect_left_closed(nums, target + 1) - 1\n\n        return [lower, upper] if lower &lt;= upper else [-1, -1]\n\n    def search_range_bisect(self, nums: List[int], target: int) -&gt; List[int]:\n        \"\"\"\u7528 python bisect \u5e93\u51fd\u6570\"\"\"\n        # edge case\n        if not nums:\n            return [-1, -1]\n\n        lower = bisect_left(nums, target)\n        upper = bisect_left(nums, target + 1) - 1\n\n        return [lower, upper] if lower &lt;= upper else [-1, -1]\n\n\nif __name__ == \"__main__\":\n    nums = [5, 7, 7, 8, 8, 10]\n    target = 8\n    sol = searchRange()\n    assert sol.search_range(nums, target) == [3, 4]\n    assert sol.search_range_bisect(nums, target) == [3, 4]\n</code></pre> <pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\n  int bisect_left(vector&lt;int&gt; &amp;nums, int target)\n  {\n    int left = 0, right = (int)nums.size() - 1;\n\n    while (left &lt;= right)\n    {\n      int mid = left + (right - left) / 2;\n      if (nums[mid] &lt; target)\n      {\n        left = mid + 1;\n      }\n      else\n      {\n        right = mid - 1;\n      }\n    }\n    return left;\n  }\n\npublic:\n  vector&lt;int&gt; searchRange(vector&lt;int&gt; &amp;nums, int target)\n  {\n    int left = bisect_left(nums, target);\n    if (left == (int)nums.size() || nums[left] != target)\n    {\n      return {-1, -1};\n    }\n    int right = bisect_left(nums, target + 1) - 1;\n    return {left, right};\n  }\n};\n\nint main()\n{\n  vector&lt;int&gt; nums = {5, 7, 7, 8, 8, 10};\n  int target = 8;\n  Solution s;\n  vector&lt;int&gt; res = s.searchRange(nums, target);\n  cout &lt;&lt; res[0] &lt;&lt; \", \" &lt;&lt; res[1] &lt;&lt; endl;\n  return 0;\n}\n</code></pre>"},{"location":"LeetPattern/binary_search/#367-valid-perfect-square","title":"367. Valid Perfect Square","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Binary Search</p> </li> </ul> Python <pre><code>\"\"\"\n-   Determine if a positive integer is a perfect square without using any built-in library function.\n\"\"\"\n\n\n# Binary Search\ndef isPerfectSquare(num: int) -&gt; bool:\n    if num &lt; 2:\n        return True\n\n    left, right = 0, num // 2\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if mid * mid == num:\n            return True\n        elif mid * mid &lt; num:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\n\nnum = 16\nprint(isPerfectSquare(num))  # True\n</code></pre>"},{"location":"LeetPattern/binary_search/#875-koko-eating-bananas","title":"875. Koko Eating Bananas","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> Python <pre><code>from typing import List\n\n\nclass minEatingSpeed:\n    def minEatingSpeed(self, piles: List[int], h: int) -&gt; int:\n        def canEat(piles, k, h):\n            hours = 0\n            for pile in piles:\n                hours += (pile + k - 1) // k\n            return hours &lt;= h\n\n        left, right = 1, max(piles) - 1\n\n        while left &lt;= right:\n            mid = left + (right - left) // 2\n\n            if canEat(piles, mid, h):\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        return left\n\n\nif __name__ == \"__main__\":\n    piles = [3, 6, 7, 11]\n    h = 8\n    sol = minEatingSpeed()\n    assert sol.minEatingSpeed(piles, h) == 4\n</code></pre>"},{"location":"LeetPattern/binary_search/#1011-capacity-to-ship-packages-within-d-days","title":"1011. Capacity To Ship Packages Within D Days","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> Python <pre><code>\"\"\"\n-   A conveyor belt has packages that must be shipped from one port to another within `D` days. The `i-th` package has a weight of `weights[i]`. Each day, we load the ship with packages on the conveyor belt. The ship will be loaded with packages up to its capacity. The ship will not be loaded beyond its capacity. Return the least weight capacity of the ship.\n\"\"\"\n\nfrom typing import List\n\n\n# Binary Search\ndef shipWithinDays(weights: List[int], days: int) -&gt; int:\n\n    def canShip(weights, D, capacity):\n        days = 1\n        current_weight = 0\n\n        for weight in weights:\n            if current_weight + weight &gt; capacity:\n                days += 1\n                current_weight = 0\n            current_weight += weight\n\n        return days &lt;= D\n\n    left, right = max(weights), sum(weights)\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if canShip(weights, days, mid):\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return left\n\n\nweights = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\ndays = 5\nprint(shipWithinDays(weights, days))  # 15\n</code></pre>"},{"location":"LeetPattern/binary_search/#378-kth-smallest-element-in-a-sorted-matrix","title":"378. Kth Smallest Element in a Sorted Matrix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Sorting, Heap Priority Queue, Matrix</p> </li> </ul> Python <pre><code>\"\"\"\n-   Given an `n x n` matrix where each of the rows and columns are sorted in ascending order, return the `k-th` smallest element in the matrix.\n\"\"\"\n\nfrom heapq import heapify, heappop, heappush\nfrom typing import List\n\n\n# Heap - Merge K Sorted\ndef kthSmallestHeap(matrix: List[List[int]], k: int) -&gt; int:\n    n = len(matrix)\n    heap = [(matrix[i][0], i, 0) for i in range(n)]\n    heapify(heap)\n\n    for _ in range(k - 1):\n        _, row, col = heappop(heap)\n\n        if col + 1 &lt; n:\n            heappush(heap, (matrix[row][col + 1], row, col + 1))\n\n    return heappop(heap)[0]\n\n\n# Binary Search\ndef kthSmallestBinarySearch(matrix: List[List[int]], k: int) -&gt; int:\n    n = len(matrix)\n\n    def check(mid):\n        i, j = n - 1, 0\n        num = 0\n\n        while i &gt;= 0 and j &lt; n:\n            if matrix[i][j] &lt;= mid:\n                num += i + 1\n                j += 1\n            else:\n                i -= 1\n\n        return num &gt;= k\n\n    left, right = matrix[0][0], matrix[-1][-1]\n\n    while left &lt; right:\n        mid = (left + right) // 2\n        if check(mid):\n            right = mid\n        else:\n            left = mid + 1\n\n    return left\n\n\nmatrix = [[1, 5, 9], [10, 11, 13], [12, 13, 15]]\nk = 8\n\nprint(kthSmallestHeap(matrix, k))  # 13\nprint(kthSmallestBinarySearch(matrix, k))  # 13\n</code></pre>"},{"location":"LeetPattern/bit_manipulation/","title":"Bit Manipulation","text":""},{"location":"LeetPattern/bit_manipulation/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2595. Number of Even and Odd Bits (Easy)</li> </ul>"},{"location":"LeetPattern/bit_manipulation/#2595-number-of-even-and-odd-bits","title":"2595. Number of Even and Odd Bits","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Bit Manipulation</p> </li> </ul> Python <pre><code>\"\"\"\n-   Topic: Bit Manipulation\n-   Difficulty: Easy\n\n&gt; You are given a positive integer n.\n&gt; Let even denote the number of even indices in the binary representation of n with value 1.\n&gt; Let odd denote the number of odd indices in the binary representation of n with value 1.\n&gt; Note that bits are indexed from right to left in the binary representation of a number.\n&gt; Return the array [even, odd].\n\"\"\"\n</code></pre>"},{"location":"LeetPattern/boyer_moore/","title":"Boyer Moore","text":""},{"location":"LeetPattern/boyer_moore/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 169. Majority Element (Easy)</li> <li> 229. Majority Element II (Medium)</li> <li> 287. Find the Duplicate Number (Medium)</li> <li> 1150. Check If a Number Is Majority Element in a Sorted Array (Easy) \ud83d\udc51</li> <li> 1157. Online Majority Element In Subarray (Hard)</li> <li> 495. Teemo Attacking (Easy)</li> </ul>"},{"location":"LeetPattern/boyer_moore/#169-majority-element","title":"169. Majority Element","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Divide And Conquer, Sorting, Counting</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the majority element in an array. The majority element is the element that appears more than `n // 2` times.\n\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/7pnhv842keE?si=fBYlNfKzdkiLgkF1\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen&gt;&lt;/iframe&gt;\n\n| `num` | `count` | `res` |\n| ----- | ------- | ----- |\n| 2     | 1       | 2     |\n| 2     | 2       | 2     |\n| 1     | 1       | 2     |\n| 1     | 0       | 2     |\n| 1     | 1       | 1     |\n| 2     | 0       | 1     |\n| 2     | 1       | 2     |\n\"\"\"\n\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Hash Map\ndef majorityElementHashMap(nums: List[int]) -&gt; int:\n    n = len(nums)\n    freq = defaultdict(int)\n\n    for num in nums:\n        freq[num] += 1\n        if freq[num] &gt; n // 2:\n            return num\n\n\n# Array - Boyer-Moore Voting Algorithm\ndef majorityElementArray(nums: List[int]) -&gt; int:\n    res = None\n    count = 0\n\n    for num in nums:\n        if count == 0:\n            res = num\n        count += 1 if num == res else -1\n\n    return res\n\n\n# | Algorithm | Time Complexity | Space Complexity |\n# |-----------|-----------------|------------------|\n# | HashMap   | O(N)            | O(N)             |\n# | Array     | O(N)            | O(1)             |\n# |-----------|-----------------|------------------|\n\n\nnums = [2, 2, 1, 1, 1, 2, 2]\nprint(majorityElementArray(nums))  # 2\nprint(majorityElementHashMap(nums))  # 2\n</code></pre>"},{"location":"LeetPattern/boyer_moore/#229-majority-element-ii","title":"229. Majority Element II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Sorting, Counting</p> </li> </ul> Python <pre><code>from collections import Counter\nfrom typing import List\n\n\n# Hash Map\ndef majorityElementHash(nums: List[int]) -&gt; List[int]:\n    counts = Counter(nums)\n    target = len(nums) // 3\n    res = []\n\n    for num in nums:\n        if counts[num] &gt; target and num not in res:\n            res.append(num)\n\n    return res\n\n\n# Boyer-Moore\ndef majorityElementMoore(nums: List[int]) -&gt; List[int]:\n    if not nums:\n        return []\n\n    cdt1, cnt1 = None, 0\n    cdt2, cnt2 = None, 0\n\n    for num in nums:\n        if num == cdt1:\n            cnt1 += 1\n        elif num == cdt2:\n            cnt2 += 1\n        elif cnt1 == 0:\n            cdt1, cnt1 = num, 1\n        elif cnt2 == 0:\n            cdt2, cnt2 = num, 1\n        else:\n            cnt1 -= 1\n            cnt2 -= 1\n\n    return [n for n in (cdt1, cdt2) if nums.count(n) &gt; len(nums) // 3]\n\n\nnums = [3, 2, 3]\nprint(majorityElementHash(nums))  # [3]\nprint(majorityElementMoore(nums))  # [3]\n</code></pre>"},{"location":"LeetPattern/boyer_moore/#287-find-the-duplicate-number","title":"287. Find the Duplicate Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Bit Manipulation</p> </li> </ul> Python <pre><code>\"\"\"\n-   Find the duplicate number in an array containing `n + 1` integers where each integer is between `1` and `n` inclusive.\n-   Floyd's Tortoise and Hare (Cycle Detection)\n    -   141. Linked List Cycle\n    -   142. Linked List Cycle II\n-   Time Complexity: O(n)\n-   Space Complexity: O(1)\n\nExample: `nums = [1, 3, 4, 2, 2]`\n\n|  0   |  1   |  2   |  3   |  4   |\n| :--: | :--: | :--: | :--: | :--: |\n|  1   |  3   |  4   |  2   |  2   |\n\n\n\"\"\"\n\nfrom typing import List\n\n\n# Floyd Cycle Detection Algorithm\ndef findDuplicate(nums: List[int]) -&gt; int:\n    fast, slow = nums[0], nums[0]\n\n    while True:\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n        if slow == fast:\n            break\n\n    slow = nums[0]\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[fast]\n\n    return slow\n\n\nnums = [1, 3, 4, 2, 2]\nprint(findDuplicate(nums))  # 2\n</code></pre>"},{"location":"LeetPattern/boyer_moore/#1150-check-if-a-number-is-majority-element-in-a-sorted-array","title":"1150. Check If a Number Is Majority Element in a Sorted Array \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul>"},{"location":"LeetPattern/boyer_moore/#1157-online-majority-element-in-subarray","title":"1157. Online Majority Element In Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Design, Binary Indexed Tree, Segment Tree</p> </li> </ul>"},{"location":"LeetPattern/boyer_moore/#495-teemo-attacking","title":"495. Teemo Attacking","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Simulation</p> </li> </ul>"},{"location":"LeetPattern/bst/","title":"BST","text":""},{"location":"LeetPattern/bst/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 700. Search in a Binary Search Tree (Easy)</li> <li> 98. Validate Binary Search Tree (Medium)</li> <li> 530. Minimum Absolute Difference in BST (Easy)</li> <li> 501. Find Mode in Binary Search Tree (Easy)</li> <li> 235. Lowest Common Ancestor of a Binary Search Tree (Medium)</li> <li> 701. Insert into a Binary Search Tree (Medium)</li> <li> 450. Delete Node in a BST (Medium)</li> <li> 669. Trim a Binary Search Tree (Medium)</li> <li> 108. Convert Sorted Array to Binary Search Tree (Easy)</li> <li> 109. Convert Sorted List to Binary Search Tree (Medium)</li> <li> 538. Convert BST to Greater Tree (Medium)</li> <li> 230. Kth Smallest Element in a BST (Medium)</li> <li> 173. Binary Search Tree Iterator (Medium)</li> <li> 1586. Binary Search Tree Iterator II (Medium) \ud83d\udc51</li> </ul>"},{"location":"LeetPattern/bst/#700-search-in-a-binary-search-tree","title":"700. Search in a Binary Search Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Binary Search Tree, Binary Tree</p> </li> </ul> Python <pre><code>\"\"\"\n### Binary Search Tree\n\n1. Binary Tree\n2. Left subtree of a node contains only nodes with keys less than the node's key\n3. Right subtree of a node contains only nodes with keys greater than the node's key\n4. The left and right subtree each must also be a binary search tree\n5. There must be no duplicate nodes\n6. Inorder traversal of a BST gives a sorted list of keys\n\"\"\"\n\nfrom typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# 1. Recursive\ndef searchBSTRecursive(root: Optional[TreeNode], val: int) -&gt; Optional[TreeNode]:\n    if not root:\n        return None\n\n    if root.val &gt; val:\n        return searchBSTRecursive(root.left, val)\n\n    elif root.val &lt; val:\n        return searchBSTRecursive(root.right, val)\n\n    else:\n        return root\n\n\n# 2. Iterative\ndef searchBSTIterative(root: Optional[TreeNode], val: int) -&gt; Optional[TreeNode]:\n    while root:\n        if root.val &gt; val:\n            root = root.left\n        elif root.val &lt; val:\n            root = root.right\n        else:\n            return root\n    return None\n\n\nroot = [4, 2, 7, 1, 3]\nval = 2\nroot = build(root)\nprint(root)\n#     __4\n#    /   \\\n#   2     7\n#  / \\\n# 1   3\nprint(searchBSTRecursive(root, val))\n#   2\n#  / \\\n# 1   3\nprint(searchBSTIterative(root, val))\n#   2\n#  / \\\n# 1   3\n</code></pre>"},{"location":"LeetPattern/bst/#98-validate-binary-search-tree","title":"98. Validate Binary Search Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Search Tree, Binary Tree</p> </li> </ul> PythonCPP <pre><code>from itertools import pairwise\nfrom math import inf\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef isValidBST1(root: Optional[TreeNode]) -&gt; bool:\n    inorder = []  # inorder traversal\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    for a, b in pairwise(inorder):\n        if a &gt;= b:\n            return False\n\n    return True\n\n\ndef isValidBST2(root: Optional[TreeNode]) -&gt; bool:\n    if not root:\n        return True\n    pre = -inf\n\n    def dfs(node):\n        if not node:\n            return True\n        if not dfs(node.left):\n            return False\n\n        nonlocal pre\n        if node.val &lt;= pre:\n            return False\n        pre = node.val\n\n        return dfs(node.right)\n\n    return dfs(root)\n\n\nif __name__ == \"__main__\":\n    root = [5, 1, 4, None, None, 3, 6]\n    root = build(root)\n    print(root)\n    #   5__\n    #  /   \\\n    # 1     4\n    #      / \\\n    #     3   6\n    assert not isValidBST1(root)  # [1, 5, 3, 4, 6]\n    assert not isValidBST2(root)  # [1, 5, 3, 4, 6]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   private:\n    vector&lt;int&gt; inorder;\n    bool check(vector&lt;int&gt; inorder) {\n        int n = inorder.size();\n        if (n &lt;= 1) return true;\n        for (int i = 1; i &lt; n; i++) {\n            if (inorder[i] &lt;= inorder[i - 1]) return false;\n        }\n        return true;\n    }\n\n   public:\n    bool isValidBST(TreeNode *root) {\n        auto dfs = [&amp;](auto &amp;&amp;self, TreeNode *node) -&gt; void {\n            if (!node) return;\n\n            self(self, node-&gt;left);\n            inorder.push_back(node-&gt;val);\n            self(self, node-&gt;right);\n        };\n\n        dfs(dfs, root);\n\n        return check(inorder);\n    }\n};\n\nint main() {\n    Solution s;\n    TreeNode *root = new TreeNode(2);\n    root-&gt;left = new TreeNode(1);\n    root-&gt;right = new TreeNode(3);\n    assert(s.isValidBST(root) == true);\n\n    root = new TreeNode(5);\n    root-&gt;left = new TreeNode(1);\n    root-&gt;right = new TreeNode(4);\n    root-&gt;right-&gt;left = new TreeNode(3);\n    root-&gt;right-&gt;right = new TreeNode(6);\n    assert(s.isValidBST(root) == false);\n\n    root = new TreeNode(5);\n    root-&gt;left = new TreeNode(4);\n    root-&gt;right = new TreeNode(6);\n    root-&gt;right-&gt;left = new TreeNode(3);\n    root-&gt;right-&gt;right = new TreeNode(7);\n    assert(s.isValidBST(root) == false);\n\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/bst/#530-minimum-absolute-difference-in-bst","title":"530. Minimum Absolute Difference in BST","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Search Tree, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef getMinimumDifference(root: Optional[TreeNode]) -&gt; int:\n    res = float(\"inf\")\n    pre = float(\"-inf\")\n\n    def dfs(node):  # inorder traversal\n        if not node:\n            return\n\n        dfs(node.left)\n\n        nonlocal res, pre\n        res = min(res, node.val - pre)\n        pre = node.val\n\n        if res == 1:  # the minimum possible difference\n            return\n\n        dfs(node.right)\n\n    dfs(root)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    root = [4, 2, 6, 1, 3]\n    root = build(root)\n    print(root)\n    #     __4\n    #    /   \\\n    #   2     6\n    #  / \\\n    # 1   3\n    assert getMinimumDifference(root) == 1\n</code></pre>"},{"location":"LeetPattern/bst/#501-find-mode-in-binary-search-tree","title":"501. Find Mode in Binary Search Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Search Tree, Binary Tree</p> </li> </ul> Python <pre><code>from typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef findMode(root: Optional[TreeNode]) -&gt; List[int]:\n    hashmap = dict()\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        if node.val not in hashmap:\n            hashmap[node.val] = 1\n        else:\n            hashmap[node.val] += 1\n        dfs(node.right)\n\n    dfs(root)\n    max_counts = max(hashmap.values())\n    result = []\n\n    for key, value in hashmap.items():\n        if value == max_counts:\n            result.append(key)\n\n    return result\n\n\nroot = [1, None, 2, None, None, 2]\nroot = build(root)\nprint(root)\n# 1__\n#    \\\n#     2\n#    /\n#   2\nprint(findMode(root))  # [2]\n</code></pre>"},{"location":"LeetPattern/bst/#235-lowest-common-ancestor-of-a-binary-search-tree","title":"235. Lowest Common Ancestor of a Binary Search Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Search Tree, Binary Tree</p> </li> </ul> Python <pre><code>from binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef lowestCommonAncestor(root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\") -&gt; \"TreeNode\":\n    while root:\n        if root.val &gt; p.val and root.val &gt; q.val:\n            root = root.left\n        elif root.val &lt; p.val and root.val &lt; q.val:\n            root = root.right\n        else:\n            return root\n\n\nroot = [6, 2, 8, 0, 4, 7, 9, None, None, 3, 5]\nroot = build(root)\np = root.left\nq = root.right\nprint(root)\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\nprint(lowestCommonAncestor(root, p, q))\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\n</code></pre>"},{"location":"LeetPattern/bst/#701-insert-into-a-binary-search-tree","title":"701. Insert into a Binary Search Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Binary Search Tree, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef insertIntoBST(root: Optional[TreeNode], val: int) -&gt; Optional[TreeNode]:\n    if root is None:\n        return TreeNode(val)\n\n    if root.val &gt; val:\n        root.left = insertIntoBST(root.left, val)\n    if root.val &lt; val:\n        root.right = insertIntoBST(root.right, val)\n\n    return root\n\n\nroot = TreeNode(4)\nroot.left = TreeNode(2)\nroot.right = TreeNode(6)\nroot.left.left = TreeNode(1)\nroot.left.right = TreeNode(3)\n#     __4\n#    /   \\\n#   2     6\n#  / \\\n# 1   3\n\ninsertIntoBST(root, 5)\n#     __4\n#    /   \\\n#   2     6\n#  / \\   /\n# 1   3 5\n</code></pre>"},{"location":"LeetPattern/bst/#450-delete-node-in-a-bst","title":"450. Delete Node in a BST","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Binary Search Tree, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef deleteNode(root: Optional[TreeNode], key: int) -&gt; Optional[TreeNode]:\n    if root is None:\n        return root\n\n    if root.val == key:\n        if root.left is None and root.right is None:\n            return None\n        elif root.left is None:\n            return root.right\n        elif root.right is None:\n            return root.left\n        else:\n            cur = root.right\n            while cur.left is not None:\n                cur = cur.left\n            cur.left = root.left\n            return root.right\n\n    if root.val &gt; key:\n        root.left = deleteNode(root.left, key)\n    if root.val &lt; key:\n        root.right = deleteNode(root.right, key)\n\n    return root\n\n\nroot = TreeNode(5)\nroot.left = TreeNode(3)\nroot.right = TreeNode(6)\nroot.left.left = TreeNode(2)\nroot.left.right = TreeNode(4)\nroot.right.right = TreeNode(7)\n#     __5\n#    /   \\\n#   3     6\n#  / \\     \\\n# 2   4     7\n\ndeleteNode(root, 3)\n#     __5\n#    /   \\\n#   4     6\n#  /       \\\n# 2         7\n</code></pre>"},{"location":"LeetPattern/bst/#669-trim-a-binary-search-tree","title":"669. Trim a Binary Search Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Search Tree, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef trimBST(root: Optional[TreeNode], low: int, high: int) -&gt; Optional[TreeNode]:\n    if root is None:\n        return None\n\n    if root.val &lt; low:\n        return trimBST(root.right, low, high)\n    if root.val &gt; high:\n        return trimBST(root.left, low, high)\n\n    root.left = trimBST(root.left, low, high)\n    root.right = trimBST(root.right, low, high)\n\n    return root\n\n\nroot = TreeNode(3)\nroot.left = TreeNode(0)\nroot.right = TreeNode(4)\nroot.left.right = TreeNode(2)\nroot.left.right.left = TreeNode(1)\n#     __3\n#    /   \\\n#   0     4\n#    \\\n#     2\n#    /\n#   1\n\ntrimBST(root, 1, 3)\n#     __3\n#    /\n#   2\n#  /\n# 1\n</code></pre>"},{"location":"LeetPattern/bst/#108-convert-sorted-array-to-binary-search-tree","title":"108. Convert Sorted Array to Binary Search Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Divide And Conquer, Tree, Binary Search Tree, Binary Tree</p> </li> </ul> PythonCPP <pre><code>from typing import List, Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef sortedArrayToBST(nums: List[int]) -&gt; Optional[TreeNode]:\n    if len(nums) == 0:\n        return None\n\n    mid = len(nums) // 2\n    root = TreeNode(nums[mid])\n\n    root.left = sortedArrayToBST(nums[:mid])\n    root.right = sortedArrayToBST(nums[mid + 1 :])\n\n    return root\n\n\nnums = [-10, -3, 0, 5, 9]\nroot = sortedArrayToBST(nums)\n#      0\n#     / \\\n#   -3   9\n#   /   /\n# -10  5\n</code></pre> <pre><code>#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   public:\n    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) {\n        if (nums.size() == 0) return nullptr;\n\n        int mid = nums.size() / 2;\n        TreeNode* root = new TreeNode(nums[mid]);\n\n        vector&lt;int&gt; left(nums.begin(), nums.begin() + mid);\n        vector&lt;int&gt; right(nums.begin() + mid + 1, nums.end());\n\n        root-&gt;left = sortedArrayToBST(left);\n        root-&gt;right = sortedArrayToBST(right);\n\n        return root;\n    }\n};\n\nint main() { return 0; }\n</code></pre>"},{"location":"LeetPattern/bst/#109-convert-sorted-list-to-binary-search-tree","title":"109. Convert Sorted List to Binary Search Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Divide And Conquer, Tree, Binary Search Tree, Binary Tree</p> </li> </ul> Python <pre><code>\"\"\"\n![109](https://assets.leetcode.com/uploads/2020/08/17/linked.jpg)\n\"\"\"\n\nfrom typing import Optional\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef sortedListToBST(head: Optional[ListNode]) -&gt; Optional[TreeNode]:\n    if not head:\n        return None\n\n    def find_mid(head: ListNode) -&gt; ListNode:\n        prev = None\n        slow = head\n        fast = head\n\n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n\n        if prev:\n            prev.next = None\n\n        return slow\n\n    mid = find_mid(head)\n\n    node = TreeNode(mid.val)\n\n    if head == mid:\n        return node\n\n    node.left = sortedListToBST(head)\n    node.right = sortedListToBST(mid.next)\n\n    return node\n\n\nhead = ListNode(-10)\nhead.next = ListNode(-3)\nhead.next.next = ListNode(0)\nhead.next.next.next = ListNode(5)\nhead.next.next.next.next = ListNode(9)\n\nroot = sortedListToBST(head)\nassert root.val == 0\nassert root.left.val == -3\nassert root.left.left.val == -10\nassert root.right.val == 9\nassert root.right.left.val == 5\nprint(\"All passed\")\n\n#      0\n#     / \\\n#   -3   9\n#   /   /\n# -10  5\n</code></pre>"},{"location":"LeetPattern/bst/#538-convert-bst-to-greater-tree","title":"538. Convert BST to Greater Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Search Tree, Binary Tree</p> </li> </ul> Python <pre><code>\"\"\"\n![538](https://assets.leetcode.com/uploads/2019/05/02/tree.png)\n\"\"\"\n\nfrom typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef convertBST(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    prev = 0\n\n    def dfs(node):\n        if not node:\n            return None\n        nonlocal prev\n\n        dfs(node.right)\n\n        node.val += prev\n        prev = node.val\n\n        dfs(node.left)\n\n    dfs(root)\n\n    return root\n\n\nroot = [4, 1, 6, 0, 2, 5, 7, None, None, None, 3, None, None, None, 8]\nroot = build(root)\nprint(root)\n#     ____4__\n#    /       \\\n#   1         6\n#  / \\       / \\\n# 0   2     5   7\n#      \\         \\\n#       3         8\ngreater_tree = convertBST(root)\nprint(greater_tree)\n#      _______30___\n#     /            \\\n#   _36            _21\n#  /   \\          /   \\\n# 36    35       26    15\n#         \\              \\\n#          33             8\n</code></pre>"},{"location":"LeetPattern/bst/#230-kth-smallest-element-in-a-bst","title":"230. Kth Smallest Element in a BST","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Search Tree, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef kthSmallestRecursive(root: Optional[TreeNode], k: int) -&gt; int:\n    inorder = []\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n    return inorder[k - 1]\n\n\n# Iteratve\ndef kthSmallestIteratve(root: Optional[TreeNode], k: int) -&gt; int:\n    stack = []\n    while True:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        k -= 1\n        if not k:\n            return root.val\n        root = root.right\n\n\nif __name__ == \"__main__\":\n    root = build([3, 1, 4, None, 2])\n    k = 1\n    assert kthSmallestRecursive(root, k) == 1\n    assert kthSmallestIteratve(root, k) == 1\n</code></pre>"},{"location":"LeetPattern/bst/#173-binary-search-tree-iterator","title":"173. Binary Search Tree Iterator","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Stack, Tree, Design, Binary Search Tree, Binary Tree, Iterator</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BST\nclass BSTIterator:\n\n    def __init__(self, root: Optional[TreeNode]):\n        self.stack = []\n        self._leftmost_inorder(root)\n\n    def _leftmost_inorder(self, root):\n        while root:\n            self.stack.append(root)\n            root = root.left\n\n    def next(self) -&gt; int:\n        topmost_node = self.stack.pop()\n\n        if topmost_node.right:\n            self._leftmost_inorder(topmost_node.right)\n\n        return topmost_node.val\n\n    def hasNext(self) -&gt; bool:\n        return len(self.stack) &gt; 0\n\n\nroot = build([7, 3, 15, None, None, 9, 20])\nprint(root)\n#   7__\n#  /   \\\n# 3     15\n#      /  \\\n#     9    20\nobj = BSTIterator(root)\nprint(obj.next())  # 3\nprint(obj.next())  # 7\nprint(obj.hasNext())  # True\n</code></pre>"},{"location":"LeetPattern/bst/#1586-binary-search-tree-iterator-ii","title":"1586. Binary Search Tree Iterator II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Stack, Tree, Design, Binary Search Tree, Binary Tree, Iterator</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BST\nclass BSTIterator:\n    def __init__(self, root: Optional[TreeNode]):\n        self.nodes = self._inorder(root)\n        self.index = -1\n        self.size = len(self.nodes)\n\n    def _inorder(self, node):\n        if not node:\n            return []\n        return self._inorder(node.left) + [node.val] + self._inorder(node.right)\n\n    def hasNext(self) -&gt; bool:\n        return self.index &lt; self.size - 1\n\n    def next(self) -&gt; int:\n        self.index += 1\n        return self.nodes[min(self.index, self.size - 1)]\n\n    def hasPrev(self) -&gt; bool:\n        return self.index &gt; 0\n\n    def prev(self) -&gt; int:\n        self.index -= 1\n        return self.nodes[max(self.index, 0)]\n\n\nroot = build([7, 3, 15, None, None, 9, 20])\nprint(root)\n#   7__\n#  /   \\\n# 3     15\n#      /  \\\n#     9    20\nobj = BSTIterator(root)\nprint(obj.next())  # 3\nprint(obj.next())  # 7\nprint(obj.hasNext())  # True\nprint(obj.prev())  # 3\nprint(obj.prev())  # None\n</code></pre>"},{"location":"LeetPattern/design/","title":"Design","text":""},{"location":"LeetPattern/design/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 146. LRU Cache (Medium)</li> <li> 355. Design Twitter (Medium)</li> <li> 588. Design In-Memory File System (Hard) \ud83d\udc51</li> <li> 460. LFU Cache (Hard)</li> <li> 1166. Design File System (Medium) \ud83d\udc51</li> <li> 380. Insert Delete GetRandom O(1) (Medium)</li> <li> 362. Design Hit Counter (Medium) \ud83d\udc51</li> <li> 297. Serialize and Deserialize Binary Tree (Hard)</li> <li> 622. Design Circular Queue (Medium)</li> <li> 353. Design Snake Game (Medium) \ud83d\udc51</li> <li> 1244. Design A Leaderboard (Medium) \ud83d\udc51</li> </ul>"},{"location":"LeetPattern/design/#146-lru-cache","title":"146. LRU Cache","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Linked List, Design, Doubly Linked List</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Design and implement a data structure for **Least Recently Used (LRU) cache**. It should support the following operations: get and put.\n- [lru](https://media.geeksforgeeks.org/wp-content/uploads/20240909142802/Working-of-LRU-Cache-copy-2.webp)\n- ![146](https://miro.medium.com/v2/resize:fit:650/0*fOwBd3z0XtHh7WN1.png)\n\n| Data structure     | Description                   |\n| ------------------ | ----------------------------- |\n| Doubly Linked List | To store the key-value pairs. |\n| Hash Map           | To store the key-node pairs.  |\n\"\"\"\n\nfrom collections import OrderedDict\n\n\n# Doubly Linked List\nclass Node:\n    def __init__(self, key=0, val=0):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.cache = {}\n        self.head = Node()\n        self.tail = Node()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def add_to_last(self, node):\n        self.tail.prev.next = node\n        node.prev = self.tail.prev\n        node.next = self.tail\n        self.tail.prev = node\n\n    def move_to_last(self, node):\n        self.remove(node)\n        self.add_to_last(node)\n\n    def get(self, key: int) -&gt; int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self.move_to_last(node)\n        return node.val\n\n    def put(self, key: int, value: int) -&gt; None:\n        if key in self.cache:\n            node = self.cache[key]\n            node.val = value\n            self.move_to_last(node)\n            return None\n\n        if len(self.cache) == self.cap:\n            del self.cache[self.head.next.key]\n            self.remove(self.head.next)\n\n        node = Node(key=key, val=value)\n        self.cache[key] = node\n        self.add_to_last(node)\n\n\n# OrderedDict\nclass LRUCacheOrderedDict:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.cap = capacity\n\n    def get(self, key: int):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key, last=True)\n        return self.cache[key]\n\n    def put(self, key: int, value: int):\n        if key in self.cache:\n            self.cache.move_to_end(key, last=True)\n        elif len(self.cache) &gt;= self.cap:\n            self.cache.popitem(last=False)\n\n        self.cache[key] = value\n\n\ncache = LRUCache(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\n\ncache = LRUCacheOrderedDict(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\nprint(\"LRU Cache passed\")\nprint(\"LRU Cache Ordered Dict passed\")\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nclass Node {\n   public:\n    int key;\n    int val;\n    Node *prev;\n    Node *next;\n\n    Node(int k = 0, int v = 0) : key(k), val(v), prev(nullptr), next(nullptr) {}\n};\n\nclass LRUCache {\n   private:\n    int cap;\n    unordered_map&lt;int, Node *&gt; cache;\n    Node *head;\n    Node *tail;\n\n    void remove(Node *node) {\n        node-&gt;prev-&gt;next = node-&gt;next;\n        node-&gt;next-&gt;prev = node-&gt;prev;\n    }\n\n    void insert_to_last(Node *node) {\n        tail-&gt;prev-&gt;next = node;\n        node-&gt;prev = tail-&gt;prev;\n        tail-&gt;prev = node;\n        node-&gt;next = tail;\n    }\n\n    void move_to_last(Node *node) {\n        remove(node);\n        insert_to_last(node);\n    }\n\n   public:\n    LRUCache(int capacity) {\n        this-&gt;cap = capacity;\n        head = new Node();\n        tail = new Node();\n        head-&gt;next = tail;\n        tail-&gt;prev = head;\n    }\n\n    int get(int key) {\n        if (cache.find(key) != cache.end()) {\n            Node *node = cache[key];\n            move_to_last(node);\n            return node-&gt;val;\n        }\n        return -1;\n    }\n\n    void put(int key, int value) {\n        if (cache.find(key) != cache.end()) {\n            Node *node = cache[key];\n            node-&gt;val = value;\n            move_to_last(node);\n        } else {\n            Node *newNode = new Node(key, value);\n            cache[key] = newNode;\n            insert_to_last(newNode);\n\n            if ((int)cache.size() &gt; cap) {\n                Node *removed = head-&gt;next;\n                remove(removed);\n                cache.erase(removed-&gt;key);\n                delete removed;\n            }\n        }\n    }\n};\n\nint main() {\n    LRUCache lru(2);\n    lru.put(1, 1);\n    lru.put(2, 2);\n    assert(lru.get(1) == 1);   // returns 1\n    lru.put(3, 3);             // evicts key 2\n    assert(lru.get(2) == -1);  // returns -1 (not found)\n    lru.put(4, 4);             // evicts key 1\n    assert(lru.get(1) == -1);  // returns -1 (not found)\n    assert(lru.get(3) == 3);   // returns 3\n    assert(lru.get(4) == 4);   // returns 4\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/design/#355-design-twitter","title":"355. Design Twitter","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Linked List, Design, Heap Priority Queue</p> </li> </ul> Python <pre><code>\"\"\"\n-   Similar question: [23. Merge K Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/) (Hard)\n\"\"\"\n\nimport heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Design\nclass Twitter:\n\n    def __init__(self):\n        self.tweets = defaultdict(list)\n        self.followees = defaultdict(set)\n        self.time = 0\n\n    def postTweet(self, userId: int, tweetId: int) -&gt; None:\n        self.tweets[userId].append((self.time, tweetId))\n        self.time += 1\n\n    def getNewsFeed(self, userId: int) -&gt; List[int]:\n        news_feed = []\n        news_feed.extend(self.tweets[userId])\n        for followee in self.followees[userId]:\n            news_feed.extend(self.tweets[followee])\n\n        return [tweet for _, tweet in heapq.nlargest(10, news_feed)]\n\n    def follow(self, followerId: int, followeeId: int) -&gt; None:\n        if followerId != followeeId:\n            self.followees[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -&gt; None:\n        if followerId != followeeId:\n            self.followees[followerId].discard(followeeId)\n\n\ntwitter = Twitter()\nprint(twitter.postTweet(1, 5))  # None\nprint(twitter.getNewsFeed(1))  # [5]\nprint(twitter.follow(1, 2))  # None\nprint(twitter.postTweet(2, 6))  # None\nprint(twitter.getNewsFeed(1))  # [6, 5]\nprint(twitter.unfollow(1, 2))  # None\nprint(twitter.getNewsFeed(1))  # [5]\n</code></pre>"},{"location":"LeetPattern/design/#588-design-in-memory-file-system","title":"588. Design In-Memory File System \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Design, Trie, Sorting</p> </li> </ul> Python <pre><code>from collections import defaultdict\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children = defaultdict(TrieNode)\n        self.content = \"\"\n\n\n# Trie\nclass FileSystem:\n\n    def __init__(self):\n        self.root = TrieNode()\n\n    def ls(self, path: str) -&gt; list:\n        cur = self.root\n\n        if path != \"/\":\n            paths = path.split(\"/\")[1:]\n            for p in paths:\n                cur = cur.children[p]\n        if cur.content:\n            return [path.split(\"/\")[-1]]\n\n        return sorted(cur.children.keys())\n\n    def mkdir(self, path: str) -&gt; None:\n        cur = self.root\n        paths = path.split(\"/\")[1:]\n        for p in paths:\n            cur = cur.children[p]\n\n    def addContentToFile(self, filePath: str, content: str) -&gt; None:\n        cur = self.root\n        paths = filePath.split(\"/\")[1:]\n        for p in paths:\n            cur = cur.children[p]\n        cur.content += content\n\n    def readContentFromFile(self, filePath: str) -&gt; str:\n        cur = self.root\n        paths = filePath.split(\"/\")[1:]\n        for p in paths:\n            cur = cur.children[p]\n        return cur.content\n\n\nobj = FileSystem()\nobj.mkdir(\"/a/b/c\")\nobj.addContentToFile(\"/a/b/c/d\", \"hello\")\nprint(obj.ls(\"/\"))  # [\"a\"]\nprint(obj.readContentFromFile(\"/a/b/c/d\"))  # \"hello\"\n</code></pre>"},{"location":"LeetPattern/design/#460-lfu-cache","title":"460. LFU Cache","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Linked List, Design, Doubly Linked List</p> </li> </ul> Python <pre><code>from collections import OrderedDict, defaultdict\n\n\nclass LFUCache:\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        # key -&gt; [val, freq]\n        self.key_to_val_freq = {}\n        # freq -&gt; OrderedDict of keys\n        self.freq_to_keys = defaultdict(OrderedDict)\n        self.min_freq = 0\n\n    def remove_least_frequent(self):\n\n        lfu_key, _ = self.freq_to_keys[self.min_freq].popitem(last=False)\n        del self.key_to_val_freq[lfu_key]\n\n        # If the frequency list is empty after removal, delete it\n        if not self.freq_to_keys[self.min_freq]:\n            del self.freq_to_keys[self.min_freq]\n\n    def update_freq(self, key):\n        \"\"\"Updates the frequency of an existing key.\"\"\"\n        value, freq = self.key_to_val_freq[key]\n\n        # Remove key from current frequency group\n        del self.freq_to_keys[freq][key]\n        if not self.freq_to_keys[freq]:\n            del self.freq_to_keys[freq]\n            if self.min_freq == freq:\n                self.min_freq += 1\n\n        # Update key frequency\n        new_freq = freq + 1\n        self.key_to_val_freq[key] = [value, new_freq]\n        self.freq_to_keys[new_freq][key] = None\n\n    def add_new_key(self, key, value):\n        if len(self.key_to_val_freq) &gt;= self.cap:\n            self.remove_least_frequent()\n\n        # Insert the new key with frequency 1\n        self.key_to_val_freq[key] = [value, 1]\n        self.freq_to_keys[1][key] = None\n        self.min_freq = 1\n\n    def get(self, key: int) -&gt; int:\n        if key not in self.key_to_val_freq:\n            return -1\n        self.update_freq(key)\n        return self.key_to_val_freq[key][0]\n\n    def put(self, key: int, value: int) -&gt; None:\n        if self.cap == 0:\n            return\n\n        if key in self.key_to_val_freq:\n            self.key_to_val_freq[key][0] = value\n            self.update_freq(key)\n        else:\n            self.add_new_key(key, value)\n\n\nlfu = LFUCache(2)\nlfu.put(1, 1)\nlfu.put(2, 2)\nprint(lfu.get(1))  # 1\nlfu.put(3, 3)\nprint(lfu.get(2))  # -1\nprint(lfu.get(3))  # 3\nlfu.put(4, 4)\nprint(lfu.get(1))  # -1\nprint(lfu.get(3))  # 3\n</code></pre>"},{"location":"LeetPattern/design/#1166-design-file-system","title":"1166. Design File System \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Design, Trie</p> </li> </ul> Python <pre><code>from collections import defaultdict\n\n\nclass TrieNode:\n    def __init__(self, name):\n        self.name = name\n        self.children = defaultdict(TrieNode)\n        self.value = -1\n\n\n# Trie\nclass FileSystem:\n    def __init__(self):\n        self.root = TrieNode(\"\")\n\n    def createPath(self, path: str, value: int) -&gt; bool:\n        paths = path.split(\"/\")[1:]\n        cur = self.root\n\n        for idx, path in enumerate(paths):\n            if path not in cur.children:\n                if idx == len(paths) - 1:\n                    cur.children[path] = TrieNode(path)\n                else:\n                    return False\n            cur = cur.children[path]\n\n        if cur.value != -1:\n            return False\n        cur.value = value\n        return True\n\n    def get(self, path: str) -&gt; int:\n        cur = self.root\n        paths = path.split(\"/\")[1:]\n\n        for path in paths:\n            if path not in cur.children:\n                return -1\n            cur = cur.children[path]\n\n        return cur.value\n\n\n# Your FileSystem object will be instantiated and called as such:\npath = \"/a\"\nvalue = 1\nobj = FileSystem()\nprint(obj.createPath(path, value))  # False\nprint(obj.get(path))  # 1\n</code></pre>"},{"location":"LeetPattern/design/#380-insert-delete-getrandom-o1","title":"380. Insert Delete GetRandom O(1)","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Design, Randomized</p> </li> </ul> Python <pre><code>import random\n\n\nclass RandomizedSet:\n    def __init__(self):\n        self.nums = []\n        self.pos = {}  # num: idx\n\n    def insert(self, val: int) -&gt; bool:\n        if val in self.pos:\n            return False\n        self.pos[val] = len(self.nums)\n        self.nums.append(val)\n        return True\n\n    def remove(self, val: int) -&gt; bool:\n        if val not in self.pos:\n            return False\n\n        idx = self.pos[val]\n        last_val = self.nums[-1]\n        self.nums[idx] = last_val\n        self.pos[last_val] = idx\n\n        self.nums.pop()\n        del self.pos[val]\n        return True\n\n    def getRandom(self) -&gt; int:\n        return random.choice(self.nums)\n\n\ndef test_RandomizedSet():\n    obj = RandomizedSet()\n    assert obj.insert(1)\n    assert not obj.remove(2)\n    assert obj.insert(2)\n    assert obj.getRandom() in [1, 2]\n    assert obj.remove(1)\n    assert not obj.insert(2)\n    assert obj.getRandom() == 2\n</code></pre>"},{"location":"LeetPattern/design/#362-design-hit-counter","title":"362. Design Hit Counter \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Design, Queue, Data Stream</p> </li> </ul> Python <pre><code>from collections import deque\n\n\nclass HitCounter:\n\n    def __init__(self):\n        self.hits = deque()\n\n    def hit(self, timestamp: int) -&gt; None:\n        self.hits.append(timestamp)\n\n    def getHits(self, timestamp: int) -&gt; int:\n        # Remove hits that are older than 5 minutes (300 seconds)\n        while self.hits and self.hits[0] &lt;= timestamp - 300:\n            self.hits.popleft()\n        return len(self.hits)\n\n\nobj = HitCounter()\nobj.hit(1)\nobj.hit(2)\nobj.hit(3)\nprint(obj.getHits(4))  # 3\nobj.hit(300)\nprint(obj.getHits(300))  # 4\nprint(obj.getHits(301))  # 3\n</code></pre>"},{"location":"LeetPattern/design/#297-serialize-and-deserialize-binary-tree","title":"297. Serialize and Deserialize Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Tree, Depth First Search, Breadth First Search, Design, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BFS\nclass BFS:\n    def serialize(self, root: Optional[TreeNode]) -&gt; str:\n        if not root:\n            return \"\"\n\n        res = []\n        q = deque([root])\n\n        while q:\n            node = q.popleft()\n\n            if node:\n                res.append(str(node.val))\n                q.append(node.left)\n                q.append(node.right)\n            else:\n                res.append(\"null\")\n\n        return \",\".join(res)\n\n    def deserialize(self, data: str) -&gt; Optional[TreeNode]:\n        if not data:\n            return None\n\n        nodes = data.split(\",\")\n        root = TreeNode(int(nodes[0]))\n        q = deque([root])\n        index = 1\n\n        while q:\n            node = q.popleft()\n\n            if nodes[index] != \"null\":\n                node.left = TreeNode(int(nodes[index]))\n                q.append(node.left)\n            index += 1\n\n            if nodes[index] != \"null\":\n                node.right = TreeNode(int(nodes[index]))\n                q.append(node.right)\n            index += 1\n\n        return root\n\n\n# DFS\nclass DFS:\n    def serialize(self, root: Optional[TreeNode]) -&gt; str:\n        def dfs(node):\n            if not node:\n                return [\"null\"]\n            return [str(node.val)] + dfs(node.left) + dfs(node.right)\n\n        return \",\".join(dfs(root))\n\n    def deserialize(self, data: str) -&gt; Optional[TreeNode]:\n        nodes = data.split(\",\")\n        self.index = 0\n\n        def dfs():\n            if nodes[self.index] == \"null\":\n                self.index += 1\n                return None\n\n            node = TreeNode(int(nodes[self.index]))\n            self.index += 1\n\n            node.left = dfs()\n            node.right = dfs()\n\n            return node\n\n        root = dfs()\n        return root\n\n\nroot = build([1, 2, 3, None, None, 4, 5])\nprint(root)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n\nbfs = BFS()\ndata1 = bfs.serialize(root)\nprint(data1)  # \"1,2,3,null,null,4,5,null,null,null,null\"\nroot1 = bfs.deserialize(data1)\nprint(root1)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n\ndfs = DFS()\ndata2 = dfs.serialize(root)\nprint(data2)  # \"1,2,null,null,3,4,null,null,5,null,null\"\nroot2 = dfs.deserialize(data2)\nprint(root2)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n</code></pre>"},{"location":"LeetPattern/design/#622-design-circular-queue","title":"622. Design Circular Queue","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Linked List, Design, Queue</p> </li> </ul> Python <pre><code># Design\nclass MyCircularQueue:\n\n    def __init__(self, k: int):\n        self.queue = [0] * k\n        self.head = 0\n        self.tail = -1\n        self.size = 0\n        self.capacity = k\n\n    def enQueue(self, value: int) -&gt; bool:\n        if self.isFull():\n            return False\n        self.tail = (self.tail + 1) % self.capacity\n        self.queue[self.tail] = value\n        self.size += 1\n        return True\n\n    def deQueue(self) -&gt; bool:\n        if self.isEmpty():\n            return False\n        self.head = (self.head + 1) % self.capacity\n        self.size -= 1\n        return True\n\n    def Front(self) -&gt; int:\n        if self.isEmpty():\n            return -1\n        return self.queue[self.head]\n\n    def Rear(self) -&gt; int:\n        if self.isEmpty():\n            return -1\n        return self.queue[self.tail]\n\n    def isEmpty(self) -&gt; bool:\n        return self.size == 0\n\n    def isFull(self) -&gt; bool:\n        return self.size == self.capacity\n\n\nobj = MyCircularQueue(3)\nprint(obj.enQueue(1))  # True\nprint(obj.enQueue(2))  # True\nprint(obj.enQueue(3))  # True\nprint(obj.enQueue(4))  # False\nprint(obj.Rear())  # 3\nprint(obj.isFull())  # True\nprint(obj.deQueue())  # True\n</code></pre>"},{"location":"LeetPattern/design/#353-design-snake-game","title":"353. Design Snake Game \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Design, Queue, Simulation</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\nclass SnakeGame:\n\n    def __init__(self, width: int, height: int, food: List[List[int]]):\n        self.width = width\n        self.height = height\n        self.food = deque(food)\n        self.snake = deque([(0, 0)])  # Snake starts at the top-left corner\n        self.snake_body = set([(0, 0)])  # To quickly check for collisions\n        self.score = 0\n        self.dirs = {\"U\": (-1, 0), \"L\": (0, -1), \"R\": (0, 1), \"D\": (1, 0)}\n\n    def move(self, direction: str) -&gt; int:\n        head = self.snake[0]\n        dx, dy = self.dirs[direction]\n        new_head = (head[0] + dx, head[1] + dy)\n\n        # Check if the new head is out of bounds\n        if not (0 &lt;= new_head[0] &lt; self.height and 0 &lt;= new_head[1] &lt; self.width):\n            return -1\n\n        # Check if the new head collides with the snake body (excluding the tail)\n        if new_head in self.snake_body and new_head != self.snake[-1]:\n            return -1\n\n        # Check if the new head is on a food cell\n        if self.food and self.food[0] == list(new_head):\n            self.food.popleft()\n            self.score += 1\n        else:\n            tail = self.snake.pop()\n            self.snake_body.remove(tail)\n\n        # Add the new head to the snake\n        self.snake.appendleft(new_head)\n        self.snake_body.add(new_head)\n\n        return self.score\n\n\nsnake = SnakeGame(3, 2, [[1, 2], [0, 1]])\nprint(snake.move(\"R\"))  # 0\nprint(snake.move(\"D\"))  # 0\nprint(snake.move(\"R\"))  # 1\nprint(snake.move(\"U\"))  # 1\nprint(snake.move(\"L\"))  # 2\nprint(snake.move(\"U\"))  # -1\n</code></pre>"},{"location":"LeetPattern/design/#1244-design-a-leaderboard","title":"1244. Design A Leaderboard \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Design, Sorting</p> </li> </ul> Python <pre><code>class Leaderboard:\n\n    def __init__(self):\n        self.scores = {}\n\n    def addScore(self, playerId: int, score: int) -&gt; None:\n        if playerId in self.scores:\n            self.scores[playerId] += score\n        else:\n            self.scores[playerId] = score\n\n    def top(self, K: int) -&gt; int:\n        topK = sorted(self.scores.values(), reverse=True)[:K]\n        return sum(topK)\n\n    def reset(self, playerId: int) -&gt; None:\n        if playerId in self.scores:\n            self.scores[playerId] = 0\n\n\nboard = Leaderboard()\nboard.addScore(1, 73)\nboard.addScore(2, 56)\nboard.addScore(3, 39)\nboard.addScore(4, 51)\nprint(board.top(1))  # 73\nboard.reset(1)\nboard.reset(2)\nprint(board.top(2))  # 90\n</code></pre>"},{"location":"LeetPattern/difference_array/","title":"Difference Array","text":""},{"location":"LeetPattern/difference_array/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1094. Car Pooling (Medium)</li> <li> 370. Range Addition (Medium) \ud83d\udc51</li> <li> 1109. Corporate Flight Bookings (Medium)</li> <li> 2848. Points That Intersect With Cars (Easy)</li> </ul>"},{"location":"LeetPattern/difference_array/#1094-car-pooling","title":"1094. Car Pooling","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sorting, Heap Priority Queue, Simulation, Prefix Sum</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return `False` if the total number of passengers at any point is greater than `capacity`. Otherwise, return `True`.\n\"\"\"\n\nfrom itertools import accumulate\nfrom typing import List\n\n\n# Difference Array\ndef carPooling1(trips: List[List[int]], capacity: int) -&gt; bool:\n    max_location = 0\n    for trip in trips:\n        max_location = max(max_location, trip[2])\n\n    diff = [0] * (max_location + 1)\n    n = len(diff)\n\n    for num, start, end in trips:\n        diff[start] += num\n        if end &lt; n:\n            diff[end] -= num\n\n    cur = 0\n    for i in range(n):\n        cur += diff[i]\n        if cur &gt; capacity:\n            return False\n\n    return True\n\n\n# Difference Array\ndef carPooling2(trips: List[List[int]], capacity: int) -&gt; bool:\n    diff = [0] * 1001\n\n    for num, start, end in trips:\n        diff[start] += num\n        diff[end] -= num\n\n    return all(s &lt;= capacity for s in accumulate(diff))\n\n\ntrips = [[2, 1, 5], [3, 3, 7]]\ncapacity = 4\nprint(carPooling1(trips, capacity))  # False\nprint(carPooling2(trips, capacity))  # False\n</code></pre>"},{"location":"LeetPattern/difference_array/#370-range-addition","title":"370. Range Addition \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Prefix Sum</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef getModifiedArray(length: int, updates: List[List[int]]) -&gt; List[int]:\n    \"\"\"\n    Return the final array after applying all the Adition operations.\n    method: difference array\n    \"\"\"\n\n    res = [0 for _ in range(length)]\n\n    for start, end, inc in updates:\n        res[start] += inc\n\n        if end + 1 &lt; length:\n            res[end + 1] -= inc\n\n    for i in range(1, length):\n        res[i] += res[i - 1]\n\n    return res\n\n\nif __name__ == \"__main__\":\n    length = 5\n    updates = [[1, 3, 2], [2, 4, 3], [0, 2, -2]]\n    assert getModifiedArray(length, updates) == [-2, 0, 3, 5, 3]\n</code></pre>"},{"location":"LeetPattern/difference_array/#1109-corporate-flight-bookings","title":"1109. Corporate Flight Bookings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Prefix Sum</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the number of seats booked on each flight.\n\"\"\"\n\nfrom typing import List\n\n\n# Difference Array\ndef corpFlightBookings(bookings: List[List[int]], n: int) -&gt; List[int]:\n    \"\"\"Return the number of seats booked for each flight.\"\"\"\n    res = [0 for _ in range(n)]\n\n    for i, j, k in bookings:\n        res[i - 1] += k\n        if j &lt; n:\n            res[j] -= k\n\n    for i in range(1, n):\n        res[i] += res[i - 1]\n\n    return res\n\n\nbookings = [[1, 2, 10], [2, 3, 20], [2, 5, 25]]\nn = 5\nprint(corpFlightBookings(bookings, n))  # [10, 55, 45, 25, 25]\n</code></pre>"},{"location":"LeetPattern/difference_array/#2848-points-that-intersect-with-cars","title":"2848. Points That Intersect With Cars","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Prefix Sum</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the number of points that intersect with cars.\n\"\"\"\n\nfrom itertools import accumulate\nfrom typing import List\n\n\n# Differnce Array\ndef numberOfPoints(nums: List[List[int]]) -&gt; int:\n    max_end = max(end for _, end in nums)\n\n    diff = [0] * (max_end + 2)\n\n    for start, end in nums:\n        diff[start] += 1\n        diff[end + 1] -= 1\n\n    return sum(s &gt; 0 for s in accumulate(diff))\n\n\nnums = [[3, 6], [1, 5], [4, 7]]\nprint(numberOfPoints(nums))  # 7\n</code></pre>"},{"location":"LeetPattern/dp_01_knapsack/","title":"DP 01 Knapsack","text":""},{"location":"LeetPattern/dp_01_knapsack/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 416. Partition Equal Subset Sum (Medium)</li> <li> 474. Ones and Zeroes (Medium)</li> <li> 494. Target Sum (Medium)</li> <li> 1046. Last Stone Weight (Easy)</li> <li> 1049. Last Stone Weight II (Medium)</li> </ul>"},{"location":"LeetPattern/dp_01_knapsack/#416-partition-equal-subset-sum","title":"416. Partition Equal Subset Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>from functools import cache\nfrom typing import List\n\nfrom leetpattern.utils import knapsack01\n\n\n# Memoization\ndef canPartitionMemoization(nums: List[int]) -&gt; bool:\n    total = sum(nums)\n    n = len(nums)\n\n    if total % 2 == 1 or n &lt;= 1:\n        return False\n\n    @cache\n    def dfs(i, j):\n        if i &lt; 0:\n            return j == 0\n        return j &gt;= nums[i] and dfs(i - 1, j - nums[i]) or dfs(i - 1, j)\n\n    return dfs(n - 1, total // 2)\n\n\n# DP - Knapsack 01\ndef canPartitionTemplate(nums: List[int]) -&gt; bool:\n    total = sum(nums)\n\n    if total % 2 == 1 or len(nums) &lt; 2:\n        return False\n\n    target = total // 2\n\n    return knapsack01(nums, nums, target) == target\n\n\n# DP - Knapsack 01\ndef canPartition(nums: List[int]) -&gt; bool:\n    total = sum(nums)\n\n    if total % 2 == 1 or len(nums) &lt; 2:\n        return False\n\n    target = total // 2\n\n    dp = [0 for _ in range(target + 1)]\n\n    for i in range(len(nums)):\n        for j in range(target, nums[i] - 1, -1):\n            dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])\n\n    return dp[target] == target\n\n\nif __name__ == \"__main__\":\n    nums = [1, 5, 11, 5]\n    print(canPartitionTemplate(nums))  # True\n    print(canPartition(nums))  # True\n    print(canPartitionMemoization(nums))  # True\n</code></pre>"},{"location":"LeetPattern/dp_01_knapsack/#474-ones-and-zeroes","title":"474. Ones and Zeroes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef findMaxForm(strs: List[str], m: int, n: int) -&gt; int:\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for s in strs:\n        zerosNum = s.count(\"0\")\n        onesNum = len(s) - zerosNum\n\n        for i in range(m, zerosNum - 1, -1):\n            for j in range(n, onesNum - 1, -1):\n                dp[i][j] = max(dp[i][j], dp[i - zerosNum][j - onesNum] + 1)\n\n    return dp[m][n]\n\n\nstrs = [\"10\", \"0001\", \"111001\", \"1\", \"0\"]\nm = 5\nn = 3\nprint(findMaxForm(strs, m, n))  # 4\n</code></pre>"},{"location":"LeetPattern/dp_01_knapsack/#494-target-sum","title":"494. Target Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Backtracking</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef findTargetSumWays(nums: List[int], target: int) -&gt; int:\n\n    totalSum = sum(nums)\n\n    if abs(target) &gt; totalSum:\n        return 0\n    if (target + totalSum) % 2 == 1:\n        return 0\n\n    targetSum = (target + totalSum) // 2\n    dp = [0] * (targetSum + 1)\n    dp[0] = 1\n\n    for i in range(len(nums)):\n        for j in range(targetSum, nums[i] - 1, -1):\n            dp[j] += dp[j - nums[i]]\n\n    return dp[targetSum]\n\n\nnums = [1, 1, 1, 1, 1]\ntarget = 3\nprint(findTargetSumWays(nums, target))  # 5\n</code></pre>"},{"location":"LeetPattern/dp_01_knapsack/#1046-last-stone-weight","title":"1046. Last Stone Weight","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Heap Priority Queue</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Heap\n    - Time: O(n log n); Space: O(n)\n- 0/1 Knapsack\n    - Time: O(n); Space: O(n)\n\"\"\"\n\nfrom heapq import heapify, heappop, heappush\nfrom typing import List\n\n\n# Heap\ndef lastStoneWeightHeap(stones: List[int]) -&gt; int:\n    maxHeap = [-s for s in stones]\n    heapify(maxHeap)\n\n    while len(maxHeap) &gt; 1:\n        s1 = heappop(maxHeap)\n        s2 = heappop(maxHeap)\n\n        if s1 != s2:\n            heappush(maxHeap, s1 - s2)\n\n    return -maxHeap[0] if maxHeap else 0\n\n\n# 0/1 Knapsack\ndef lastStoneWeightKnapsack(stones: List[int]) -&gt; int:\n    total = sum(stones)\n    target = total // 2\n\n    dp = [0 for _ in range(target + 1)]\n\n    for i in stones:\n        for j in range(target, i - 1, -1):\n            dp[j] = max(dp[j], dp[j - i] + i)\n\n    return total - 2 * dp[target]\n\n\nif __name__ == \"__main__\":\n    stones = [2, 7, 4, 1, 8, 1]\n    assert lastStoneWeightHeap(stones) == 1\n    assert lastStoneWeightKnapsack(stones) == 1\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint lastStoneWeight(vector&lt;int&gt; &amp;stones) {\n    priority_queue&lt;int&gt; maxHeap(stones.begin(), stones.end());\n\n    // Only while there are at least two stones to smash\n    while (maxHeap.size() &gt; 1) {\n        int first = maxHeap.top();\n        maxHeap.pop();\n        int second = maxHeap.top();\n        maxHeap.pop();\n\n        if (first != second) {\n            maxHeap.push(first - second);\n        }\n    }\n\n    return maxHeap.empty() ? 0 : maxHeap.top();\n}\n\nint main() {\n    vector&lt;int&gt; stones = {2, 7, 4, 1, 8, 1};\n    cout &lt;&lt; lastStoneWeight(stones) &lt;&lt; endl;  // 1\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/dp_01_knapsack/#1049-last-stone-weight-ii","title":"1049. Last Stone Weight II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef lastStoneWeightII(stones: List[int]) -&gt; int:\n    target = sum(stones) // 2\n\n    dp = [0 for _ in range(target + 1)]\n\n    for i in range(len(stones)):\n        for j in range(target, stones[i] - 1, -1):\n            dp[j] = max(dp[j], dp[j - stones[i]] + stones[i])\n\n    result = (sum(stones) - dp[target]) - dp[target]\n\n    return result\n\n\nstones = [2, 7, 4, 1, 8, 1]\nprint(lastStoneWeightII(stones))  # 1\n</code></pre>"},{"location":"LeetPattern/dp_2d/","title":"DP 2D","text":""},{"location":"LeetPattern/dp_2d/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 118. Pascal's Triangle (Easy)</li> <li> 119. Pascal's Triangle II (Easy)</li> <li> 62. Unique Paths (Medium)</li> <li> 63. Unique Paths II (Medium)</li> </ul>"},{"location":"LeetPattern/dp_2d/#118-pascals-triangle","title":"118. Pascal's Triangle","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <p><pre><code>\"\"\"\n-   Generate the first `numRows` of Pascal's triangle.\n\n```plaintext\n                 numRows\n     1              1\n    1 1             2\n   1 2 1            3\n  1 3 3 1           4\n 1 4 6 4 1          5\n</code></pre> \"\"\"</p> <p>from typing import List</p> <p>def generate(numRows: int) -&gt; List[List[int]]:     dp = [[1] * i for i in range(1, numRows + 1)]</p> <pre><code>if numRows &lt;= 2:\n    return dp\n\nfor i in range(2, numRows):\n    for j in range(1, i):\n        dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n\nreturn dp\n</code></pre> <p>if name == \"main\":     print(generate(numRows=5))     # [[1],     #  [1, 1],     #  [1, 2, 1],     #  [1, 3, 3, 1],     #  [1, 4, 6, 4, 1]]</p> <p>```</p>"},{"location":"LeetPattern/dp_2d/#119-pascals-triangle-ii","title":"119. Pascal's Triangle II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the `rowIndex`th row of Pascal's triangle.\n\"\"\"\n\nfrom typing import List\n\n\ndef getRow(rowIndex: int) -&gt; List[int]:\n    dp = [[1] * (i + 1) for i in range(rowIndex + 1)]\n\n    if rowIndex &lt;= 1:\n        return dp[rowIndex]\n\n    for i in range(2, rowIndex + 1):\n        for j in range(1, i):\n            dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n\n    return dp[-1]\n\n\nprint(getRow(rowIndex=3))  # [1, 3, 3, 1]\n</code></pre>"},{"location":"LeetPattern/dp_2d/#62-unique-paths","title":"62. Unique Paths","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Combinatorics</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Count the number of unique paths to reach the bottom-right corner of a `m x n` grid.\n\n![62](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)\n\"\"\"\n\n\n# DP - 2D\ndef uniquePaths(m: int, n: int) -&gt; int:\n    if m == 1 or n == 1:\n        return 1\n\n    dp = [[1] * n for _ in range(m)]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]\n\n\nprint(uniquePaths(m=3, n=7))  # 28\n# [[1, 1, 1,  1,  1,  1,  1],\n#  [1, 2, 3,  4,  5,  6,  7],\n#  [1, 3, 6, 10, 15, 21, 28]]\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint uniquePaths(int m, int n) {\n    vector dp(m, vector&lt;int&gt;(n, 1));\n\n    for (int i = 1; i &lt; m; i++) {\n        for (int j = 1; j &lt; n; j++) {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n\n    return dp[m - 1][n - 1];\n}\n\nint main() {\n    int m = 3, n = 7;\n    cout &lt;&lt; uniquePaths(m, n) &lt;&lt; endl;  // 28\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/dp_2d/#63-unique-paths-ii","title":"63. Unique Paths II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Matrix</p> </li> </ul> Python <pre><code>from functools import cache\nfrom typing import List\n\n\nclass UniquePathsWithObstacles:\n    def memoization(self, obstacleGrid: List[List[int]]) -&gt; int:\n        \"\"\"\n        Approach: DFS with Memoization\n        Time complexity: O(mn).\n        Space complexity: O(mn).\n        \"\"\"\n\n        @cache\n        def dfs(i: int, j: int) -&gt; int:\n            if i &lt; 0 or j &lt; 0 or obstacleGrid[i][j]:\n                return 0\n            if i == 0 and j == 0:\n                return 1\n            return dfs(i - 1, j) + dfs(i, j - 1)\n\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\n        return dfs(m - 1, n - 1)\n\n    def dp_2d(self, obstacleGrid: List[List[int]]) -&gt; int:\n        \"\"\"\n        Approach: 2D Dynamic Programming\n        Time complexity: O(mn).\n        Space complexity: O(mn).\n        \"\"\"\n        # edge cases\n        if obstacleGrid[0][0] == 1 or obstacleGrid[-1][-1] == 1:\n            return 0\n\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\n\n        # init dp\n        dp = [[0] * n for _ in range(m)]\n\n        for i in range(m):\n            if obstacleGrid[i][0] == 0:\n                dp[i][0] = 1\n            else:\n                break\n\n        for j in range(n):\n            if obstacleGrid[0][j] == 0:\n                dp[0][j] = 1\n            else:\n                break\n\n        # update dp\n        for i in range(1, m):\n            for j in range(1, n):\n                if obstacleGrid[i][j] == 1:\n                    continue\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n        return dp[-1][-1]\n\n    def dp_1d(self, obstacleGrid: List[List[int]]) -&gt; int:\n        \"\"\"\n        Approach: 1D Dynamic Programming\n        Time complexity: O(mn).\n        Space complexity: O(n).\n        \"\"\"\n        n = len(obstacleGrid[0])\n        dp = [0] * (n + 1)\n        dp[1] = 1\n\n        for row in obstacleGrid:\n            for j, x in enumerate(row):\n                if x == 0:\n                    dp[j + 1] += dp[j]\n                else:\n                    dp[j + 1] = 0\n        return dp[n]\n\n\nif __name__ == \"__main__\":\n    solution = UniquePathsWithObstacles()\n    obstacleGrid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n    assert solution.dp_2d(obstacleGrid) == 2\n    assert solution.memoization(obstacleGrid) == 2\n    assert solution.dp_1d(obstacleGrid) == 2\n</code></pre>"},{"location":"LeetPattern/dp_basic/","title":"DP Basic","text":""},{"location":"LeetPattern/dp_basic/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 509. Fibonacci Number (Easy)</li> <li> 70. Climbing Stairs (Easy)</li> <li> 746. Min Cost Climbing Stairs (Easy)</li> <li> 198. House Robber (Medium)</li> <li> 213. House Robber II (Medium)</li> <li> 376. Wiggle Subsequence (Medium)</li> <li> 343. Integer Break (Medium)</li> <li> 1025. Divisor Game (Easy)</li> </ul>"},{"location":"LeetPattern/dp_basic/#509-fibonacci-number","title":"509. Fibonacci Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Recursion, Memoization</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the `n-th` Fibonacci number.\n-   `dp[n]` stores the `n-th` Fibonacci number.\n-   Formula: `dp[n] = dp[n - 1] + dp[n - 2]`.\n-   Initialize `dp[0] = 0` and `dp[1] = 1`.\n\n|  n  | `dp[n-2]` | `dp[n-1]` | `dp[n]` |\n| :-: | :-------: | :-------: | :-----: |\n|  0  |     -     |     -     |    0    |\n|  1  |     -     |     0     |    1    |\n|  2  |     0     |     1     |    1    |\n|  3  |     1     |     1     |    2    |\n|  4  |     1     |     2     |    3    |\n|  5  |     2     |     3     |    5    |\n|  6  |     3     |     5     |    8    |\n|  7  |     5     |     8     |   13    |\n|  8  |     8     |    13     |   21    |\n|  9  |    13     |    21     |   34    |\n| 10  |    21     |    34     |   55    |\n\"\"\"\n\nfrom functools import cache\n\n\n# DP\ndef fibDP(n: int) -&gt; int:\n    if n &lt;= 1:\n        return n\n\n    dp = [i for i in range(n + 1)]\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\n# DP (Optimized)\ndef fibDPOptimized(n: int) -&gt; int:\n    if n &lt;= 1:\n        return n\n\n    n1, n2 = 0, 1\n    for _ in range(2, n + 1):\n        n1, n2 = n2, n1 + n2\n\n    return n2\n\n\n# Recursive\n@cache\ndef fibRecursive(n: int) -&gt; int:\n    if n &lt;= 1:\n        return n\n\n    return fibRecursive(n - 1) + fibRecursive(n - 2)\n\n\nn = 10\nprint(fibDP(n))  # 55\nprint(fibDPOptimized(n))  # 55\nprint(fibRecursive(n))  # 55\n</code></pre>"},{"location":"LeetPattern/dp_basic/#70-climbing-stairs","title":"70. Climbing Stairs","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Memoization</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return the number of distinct ways to reach the top of the stairs.\n- `dp[n]` stores the number of distinct ways to reach the `n-th` stair.\n- Formula: `dp[n] = dp[n - 1] + dp[n - 2]`.\n- Initialize `dp[0] = 0`, `dp[1] = 1`, and `dp[2] = 2`.\n\"\"\"\n\nfrom functools import cache\n\n\n# DP\ndef climbStairsDP(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    dp = [i for i in range(n + 1)]\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\n# DP (Optimized)\ndef climbStairsDPOptimized(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    first, second = 1, 2\n\n    for _ in range(3, n + 1):\n        first, second = second, first + second\n\n    return second\n\n\n# Recursion\ndef climbStairsRecursion(n: int) -&gt; int:\n    @cache\n    def dfs(i: int) -&gt; int:\n        if i &lt;= 1:\n            return 1\n        return dfs(i - 1) + dfs(i - 2)\n\n    return dfs(n)\n\n\n# Greedy\ndef climbStairsGreedy(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    p1, p2 = 1, 2\n\n    for _ in range(3, n + 1):\n        p1, p2 = p2, p1 + p2\n\n    return p2\n\n\nif __name__ == \"__main__\":\n    assert climbStairsDP(10) == 89\n    assert climbStairsDPOptimized(10) == 89\n    assert climbStairsRecursion(10) == 89\n    assert climbStairsGreedy(10) == 89\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nint climbStairs(int n) {\n    if (n &lt;= 2) return n;\n    int f1 = 1, f2 = 2;\n    int res;\n\n    int i = 3;\n    while (i &lt;= n) {\n        res = f1 + f2;\n        f1 = f2;\n        f2 = res;\n        i++;\n    }\n    return res;\n}\n\nint main() {\n    assert(climbStairs(2) == 2);\n    assert(climbStairs(5) == 8);\n    assert(climbStairs(10) == 89);\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/dp_basic/#746-min-cost-climbing-stairs","title":"746. Min Cost Climbing Stairs","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the minimum cost to reach the top of the stairs.\n\n-   `dp[n]` stores the &lt;u&gt;minimum cost&lt;/u&gt; to reach the `n-th` stair.\n-   Formula: `dp[n] = cost[n] + min(dp[n - 1], dp[n - 2])`.\n-   Initialize `dp[0] = cost[0]` and `dp[1] = cost[1]`.\n-   Return `min(dp[-1], dp[-2])`.\n\n-   Example: `cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]`\n\n|  n  | `cost[n]` | `dp[n-2]` | `dp[n-1]` | `dp[n]` |\n| :-: | :-------: | :-------: | :-------: | :-----: |\n|  0  |     1     |     -     |     -     |    1    |\n|  1  |    100    |     -     |     1     |   100   |\n|  2  |     1     |     1     |    100    |    2    |\n|  3  |     1     |    100    |     2     |    3    |\n|  4  |     1     |     2     |     3     |    3    |\n|  5  |    100    |     3     |     3     |   103   |\n|  6  |     1     |     3     |    103    |    4    |\n|  7  |     1     |    103    |     4     |    5    |\n|  8  |    100    |     4     |     5     |   104   |\n|  9  |     1     |     5     |    104    |    6    |\n\"\"\"\n\nfrom typing import List\n\n\ndef minCostClimbingStairs(cost: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(cost))]\n\n    dp[0], dp[1] = cost[0], cost[1]\n\n    for i in range(2, len(cost)):\n        dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]\n    print(dp)\n    return min(dp[-1], dp[-2])\n\n\ncost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]\nprint(minCostClimbingStairs(cost))  # 6\n</code></pre>"},{"location":"LeetPattern/dp_basic/#198-house-robber","title":"198. House Robber","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> PythonCPP <pre><code>from functools import cache\nfrom typing import List\n\n\nclass Rob:\n    \"\"\"\n    dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n    \"\"\"\n\n    def incursive(self, nums: List[int]) -&gt; int:\n        \"\"\"\n        time complexity: O(n)\n        space complexity: O(n)\n        \"\"\"\n        n = len(nums)\n        if n &lt;= 2:\n            return max(nums)\n\n        # init\n        dp = [0 for _ in range(n)]\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n        # update\n        for i in range(2, n):\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n        return dp[-1]\n\n    def incursive_optimized(self, nums: List[int]) -&gt; int:\n        \"\"\"\n        time complexity: O(n)\n        space complexity: O(1)\n        \"\"\"\n        f0, f1 = 0, 0\n\n        for num in nums:\n            f0, f1 = f1, max(f1, f0 + num)\n\n        return f1\n\n    def memoization(self, nums: List[int]) -&gt; int:\n        \"\"\"\n        time complexity: O(n)\n        space complexity: O(n)\n        \"\"\"\n        n = len(nums)\n\n        @cache\n        def dp(i: int) -&gt; int:\n            if i &lt; 0:\n                return 0\n            return max(dp(i - 1), dp(i - 2) + nums[i])\n\n        return dp(n - 1)\n\n\nif __name__ == \"__main__\":\n    nums = [2, 7, 9, 3, 1]\n    rob = Rob()\n    assert rob.incursive(nums) == 12\n    assert rob.incursive_optimized(nums) == 12\n    assert rob.memoization(nums) == 12\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint rob(vector&lt;int&gt; &amp;nums) {\n    int prev = 0, cur = 0, temp = 0;\n\n    for (int num : nums) {\n        temp = cur;\n        cur = max(cur, prev + num);\n        prev = temp;\n    }\n    return cur;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {2, 7, 9, 3, 1};\n    cout &lt;&lt; rob(nums) &lt;&lt; endl;  // 12\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/dp_basic/#213-house-robber-ii","title":"213. House Robber II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return the maximum amount of money that can be robbed from the houses arranged in a circle.\n-   Circular \u2192 Linear: `nums[0]` and `nums[-1]` cannot be robbed together.\n-   Rob from `0` to `n - 2`\n\n|  n  | `nums[n]` | `dp[n-2]` | `dp[n-1]` | `dp[n-2] + nums[n]` | `dp[n]` |\n| :-: | :-------: | :-------: | :-------: | :-----------------: | :-----: |\n|  0  |     2     |     -     |     2     |          -          |    2    |\n|  1  |     7     |     -     |     7     |          -          |    7    |\n|  2  |     9     |     2     |     7     |         11          |   11    |\n|  3  |     3     |     7     |    11     |         10          |   11    |\n\n-   Rob from `1` to `n - 1`\n\n|  n  | `nums[n]` | `dp[n-2]` | `dp[n-1]` | `dp[n-2] + nums[n]` | `dp[n]` |\n| :-: | :-------: | :-------: | :-------: | :-----------------: | :-----: |\n|  1  |     7     |     -     |     -     |          -          |    7    |\n|  2  |     9     |     -     |     7     |          -          |    9    |\n|  3  |     3     |     7     |     9     |         10          |   10    |\n|  4  |     1     |     9     |    10     |         10          |   10    |\n\"\"\"\n\nfrom typing import List\n\n\n# DP\ndef rob(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 3:\n        return max(nums)\n\n    def robLinear(nums: List[int]) -&gt; int:\n        dp = [0 for _ in range(len(nums))]\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n        return dp[-1]\n\n    # circle -&gt; linear\n    a = robLinear(nums[1:])  # 2nd house to the last house\n    b = robLinear(nums[:-1])  # 1st house to the 2nd last house\n\n    return max(a, b)\n\n\nnums = [2, 7, 9, 3, 1]\nprint(rob(nums))  # 11\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// DP\nint robDP(vector&lt;int&gt;&amp; nums) {\n    int n = nums.size();\n    if (n &lt;= 3) return *max_element(nums.begin(), nums.end());\n\n    vector&lt;int&gt; dp1(n, 0), dp2(n, 0);\n\n    dp1[0] = nums[0];\n    dp2[1] = max(nums[0], nums[1]);\n    for (int i = 2; i &lt; n - 1; i++) {\n        dp1[i] = max(dp1[i - 1], dp1[i - 2] + nums[i]);\n    }\n\n    dp2[1] = nums[1];\n    dp2[2] = max(nums[1], nums[2]);\n    for (int i = 3; i &lt; n; i++) {\n        dp1[i] = max(dp1[i - 1], dp1[i - 2] + nums[i]);\n    }\n\n    return max(dp1[n - 2], dp2[n - 1]);\n}\n\n// DP (Space Optimized)\nint robDPOptimized(vector&lt;int&gt;&amp; nums) {\n    int n = nums.size();\n    if (n &lt;= 3) return *max_element(nums.begin(), nums.end());\n\n    int f1 = nums[0];\n    int f2 = max(nums[0], nums[1]);\n    int res1;\n    for (int i = 2; i &lt; n - 1; i++) {\n        res1 = max(f2, f1 + nums[i]);\n        f1 = f2;\n        f2 = res1;\n    }\n\n    f1 = nums[1];\n    f2 = max(nums[1], nums[2]);\n    int res2;\n    for (int i = 3; i &lt; n; i++) {\n        res2 = max(f2, f1 + nums[i]);\n        f1 = f2;\n        f2 = res2;\n    }\n\n    return max(res1, res2);\n}\n\nint main() {\n    vector&lt;int&gt; nums = {2, 3, 2};\n    cout &lt;&lt; robDP(nums) &lt;&lt; endl;           // 3\n    cout &lt;&lt; robDPOptimized(nums) &lt;&lt; endl;  // 3\n\n    nums = {1, 2, 3, 1};\n    cout &lt;&lt; robDP(nums) &lt;&lt; endl;           // 4\n    cout &lt;&lt; robDPOptimized(nums) &lt;&lt; endl;  // 4\n\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/dp_basic/#376-wiggle-subsequence","title":"376. Wiggle Subsequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the length of the longest wiggle subsequence.\n-   `up[n]` stores the length of the longest wiggle subsequence ending at `n` with a rising wiggle.\n-   `down[n]` stores the length of the longest wiggle subsequence ending at `n` with a falling wiggle.\n-   Initialize `up[0] = 1` and `down[0] = 1`.\n-   Example: `nums = [1, 7, 4, 9, 2, 5]`\n\n| `nums[n]` | `nums[n-1]` | `up[n-1]` | `down[n-1]` | `up[n]` | `down[n]` |\n| :-------: | :---------: | :-------: | :---------: | :-----: | :-------: |\n|     1     |      -      |     -     |      -      |    1    |     1     |\n|     7     |      1      |     1     |      1      |    2    |     1     |\n|     4     |      7      |     2     |      1      |    2    |     3     |\n|     9     |      4      |     2     |      3      |    4    |     3     |\n|     2     |      9      |     4     |      3      |    4    |     5     |\n|     5     |      2      |     4     |      5      |    6    |     5     |\n\"\"\"\n\nfrom typing import List\n\n\n# DP\ndef wiggleMaxLengthDP(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 1:\n        return len(nums)\n\n    up = [0 for _ in range(len(nums))]\n    down = [0 for _ in range(len(nums))]\n\n    up[0], down[0] = 1, 1\n\n    for i in range(1, len(nums)):\n        if nums[i] &gt; nums[i - 1]:\n            up[i] = down[i - 1] + 1\n            down[i] = down[i - 1]\n        elif nums[i] &lt; nums[i - 1]:\n            down[i] = up[i - 1] + 1\n            up[i] = up[i - 1]\n        else:\n            up[i] = up[i - 1]\n            down[i] = down[i - 1]\n\n    return max(up[-1], down[-1])\n\n\n# Greedy\ndef wiggleMaxLengthGreedy(nums: List[int]) -&gt; int:\n    if len(nums) &lt; 2:\n        return len(nums)\n\n    prev_diff = nums[1] - nums[0]\n    count = 2 if prev_diff != 0 else 1\n\n    for i in range(2, len(nums)):\n        diff = nums[i] - nums[i - 1]\n        if (diff &gt; 0 and prev_diff &lt;= 0) or (diff &lt; 0 and prev_diff &gt;= 0):\n            count += 1\n            prev_diff = diff\n\n    return count\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    DP       |      O(n)       |     O(n)     |\n# |  Greedy     |      O(n)       |     O(1)     |\n# |-------------|-----------------|--------------|\n\nnums = [1, 7, 4, 9, 2, 5]\nprint(wiggleMaxLengthDP(nums))  # 6\nprint(wiggleMaxLengthGreedy(nums))  # 6\n</code></pre>"},{"location":"LeetPattern/dp_basic/#343-integer-break","title":"343. Integer Break","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the maximum product of the integer after breaking it into at least two positive integers.\n-   `dp[i]` stores the maximum product of the integer `i`.\n-   Formula: `dp[i] = max(dp[i - j] * j, (i - j) * j)`\n-   Time Complexity: O(n^2)\n-   Space Complexity: O(n)\n\n| dp        | 3       | 4       | 5       | 6       | 7        | 8        |\n|:---------:|:-------:|:-------:|:-------:|:-------:|:--------:|:--------:|\n| 2         | 2*1=2   | 2*2=4   | 2*3=6   | 2*4=8   | 2*5=10   | 2*6=12   |\n| dp[2]=1   | 1*1=1   | 1*2=2   | 1*3=3   | 1*4=4   | 1*5=5    | 1*6=6    |\n| 3         |         | 3*1=3   | 3*2=6   | 3*3=9   | 3*4=12   | 3*5=15   |\n| dp[3]=2   |         | 2*1=2   | 2*2=4   | 2*3=6   | 2*4=8    | 2*5=10   |\n| 4         |         |         | 4*1=4   | 4*2=8   | 4*3=12   | 4*4=16   |\n| dp[4]=4   |         |         | 4*1=4   | 4*2=8   | 4*3=12   | 4*4=16   |\n| 5         |         |         |         | 5*1=5   | 5*2=10   | 5*3=15   |\n| dp[5]=6   |         |         |         | 6*1=6   | 6*2=12   | 6*3=18   |\n| 6         |         |         |         |         | 6*1=6    | 6*2=12   |\n| dp[6]=9   |         |         |         |         | 9*1=9    | 9*2=18   |\n| 7         |         |         |         |         |          | 7*1=7    |\n| dp[7]=12  |         |         |         |         |          | 12*1=12  |\n| `dp[n]`   | 2       | 4       | 6       | 9       | 12       | 18       |\n\"\"\"\n\n\ndef integerBreak(n: int) -&gt; int:\n    dp = [0 for _ in range(n + 1)]\n    dp[2] = 1\n\n    for i in range(3, n + 1):\n        for j in range(2, i):\n            dp[i] = max(dp[i], dp[i - j] * j, (i - j) * j)\n\n    return dp[n]\n\n\nif __name__ == \"__main__\":\n    print(integerBreak(8))  # 18\n</code></pre>"},{"location":"LeetPattern/dp_basic/#1025-divisor-game","title":"1025. Divisor Game","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Brainteaser, Game Theory</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return `True` if Alice wins the game, assuming both players play optimally.\n-   `dp[n]` stores the result of the game when the number is `n`.\n-   Initialize `dp[1] = False`.\n\"\"\"\n\n\n# DP\ndef divisorGameDP(n: int) -&gt; bool:\n    if n &lt;= 1:\n        return False\n\n    dp = [False for _ in range(n + 1)]\n\n    for i in range(2, n + 1):\n        for j in range(1, i):\n            if i % j == 0 and not dp[i - j]:\n                dp[i] = True\n                break\n\n    return dp[n]\n\n\n# Math\ndef divisorGameDPMath(n: int) -&gt; bool:\n    return n % 2 == 0\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |  DP         |      O(n^2)     |    O(n)      |\n# |  Math       |      O(1)       |    O(1)      |\n# |-------------|-----------------|--------------|\n\nn = 2\nprint(divisorGameDP(n))  # True\nprint(divisorGameDPMath(n))  # True\n</code></pre>"},{"location":"LeetPattern/dp_interval/","title":"DP Interval","text":""},{"location":"LeetPattern/dp_interval/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 516. Longest Palindromic Subsequence (Medium)</li> <li> 647. Palindromic Substrings (Medium)</li> <li> 5. Longest Palindromic Substring (Medium)</li> </ul>"},{"location":"LeetPattern/dp_interval/#516-longest-palindromic-subsequence","title":"516. Longest Palindromic Subsequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the length of the longest palindromic subsequence in `s`.\n-   Bottom-up DP table\n\n| dp  |  b  |  b  |  b  |        a         |      b       |\n| :-: | :-: | :-: | :-: | :--------------: | :----------: |\n|  b  |  1  |  2  |  3  |        3         |      4       |\n|  b  |  0  |  1  |  2  |        2         | 3 `dp[i][j]` |\n|  b  |  0  |  0  |  1  | 1 `dp[i+1][j-1]` |      2       |\n|  a  |  0  |  0  |  0  |        1         |      1       |\n|  b  |  0  |  0  |  0  |        0         |      1       |\n\"\"\"\n\n\ndef longestPalindromeSubseq(s: str) -&gt; int:\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            if s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])\n\n    return dp[0][-1]\n\n\nprint(longestPalindromeSubseq(\"bbbab\"))  # 4\n</code></pre>"},{"location":"LeetPattern/dp_interval/#647-palindromic-substrings","title":"647. Palindromic Substrings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Dynamic Programming</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the number of palindromic substrings in `s`.\n-   Bottom-up DP table\n\n|  dp   |  a  |  b  |  b  |  a  |  e  |\n| :---: | :-: | :-: | :-: | :-: | :-: |\n| **a** |  1  |  0  |  0  |  1  |  0  |\n| **b** |  0  |  1  |  1  |  0  |  0  |\n| **b** |  0  |  0  |  1  |  0  |  0  |\n| **a** |  0  |  0  |  0  |  1  |  0  |\n| **e** |  0  |  0  |  0  |  0  |  1  |\n\"\"\"\n\n\ndef countSubstrings(s: str) -&gt; int:\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    res = 0\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i, n):\n            if s[i] == s[j]:\n                if j - i &lt;= 1:\n                    dp[i][j] = 1\n                    res += 1\n                elif dp[i + 1][j - 1]:\n                    dp[i][j] = 1\n                    res += 1\n\n    return res\n\n\nprint(countSubstrings(\"abbae\"))  # 7\n</code></pre>"},{"location":"LeetPattern/dp_interval/#5-longest-palindromic-substring","title":"5. Longest Palindromic Substring","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Dynamic Programming</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the longest palindromic substring in `s`.\n\"\"\"\n\n\n# DP - Interval\ndef longestPalindromeDP(s: str) -&gt; str:\n    n = len(s)\n    if n &lt;= 1:\n        return s\n\n    start, maxLen = 0, 1\n\n    # Init\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for j in range(1, n):\n        for i in range(j):\n            if s[i] == s[j]:\n                if j - i &lt;= 2:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1]\n\n                if dp[i][j] and j - i + 1 &gt; maxLen:\n                    maxLen = j - i + 1\n                    start = i\n\n    return s[start : start + maxLen]\n\n\n# Expand Around Center\ndef longestPalindromeCenter(s: str) -&gt; str:\n    def expand_around_center(left, right):\n        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n\n    if len(s) &lt;= 1:\n        return s\n\n    start, end = 0, 0\n    for i in range(len(s)):\n        len1 = expand_around_center(i, i)  # odd\n        len2 = expand_around_center(i, i + 1)  # even\n\n        maxLen = max(len1, len2)\n        if maxLen &gt; end - start:\n            start = i - (maxLen - 1) // 2\n            end = i + maxLen // 2\n\n    return s[start : end + 1]\n\n\ns = \"babad\"\nprint(longestPalindromeDP(s))  # \"bab\"\nprint(longestPalindromeCenter(s))  # \"aba\"\n</code></pre>"},{"location":"LeetPattern/dp_kadane/","title":"DP Kadane","text":""},{"location":"LeetPattern/dp_kadane/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 53. Maximum Subarray (Medium)</li> <li> 918. Maximum Sum Circular Subarray (Medium)</li> <li> 152. Maximum Product Subarray (Medium)</li> <li> 978. Longest Turbulent Subarray (Medium)</li> <li> 1186. Maximum Subarray Sum with One Deletion (Medium)</li> </ul>"},{"location":"LeetPattern/dp_kadane/#53-maximum-subarray","title":"53. Maximum Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Divide And Conquer, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP Kadane\ndef maxSubArrayDP(nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n\n    dp[0] = nums[0]\n    maxSum = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(\n            dp[i - 1] + nums[i],  # continue the previous subarray\n            nums[i],  # start a new subarray\n        )\n        maxSum = max(maxSum, dp[i])\n\n    return maxSum\n\n\n# Greedy\ndef maxSubArrayGreedy(nums: List[int]) -&gt; int:\n    max_sum = nums[0]\n    cur_sum = 0\n\n    for num in nums:\n        cur_sum = max(cur_sum + num, num)\n        max_sum = max(max_sum, cur_sum)\n\n    return max_sum\n\n\n# Prefix Sum\ndef maxSubArrayPrefixSum(nums: List[int]) -&gt; int:\n    prefix_sum = 0\n    prefix_sum_min = 0\n    res = float(\"-inf\")\n\n    for num in nums:\n        prefix_sum += num\n        res = max(res, prefix_sum - prefix_sum_min)\n        prefix_sum_min = min(prefix_sum_min, prefix_sum)\n\n    return res\n\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArrayDP(nums))  # 6\nprint(maxSubArrayGreedy(nums))  # 6\nprint(maxSubArrayPrefixSum(nums))  # 6\n</code></pre>"},{"location":"LeetPattern/dp_kadane/#918-maximum-sum-circular-subarray","title":"918. Maximum Sum Circular Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Divide And Conquer, Dynamic Programming, Queue, Monotonic Queue</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# DP - Kadane\ndef maxSubarraySumCircularKadane(nums: List[int]) -&gt; int:\n    max_sum = min_sum = nums[0]\n    max_cur = min_cur = 0\n    total = 0\n\n    for num in nums:\n        max_cur = max(max_cur + num, num)\n        min_cur = min(min_cur + num, num)\n        total += num\n\n        max_sum = max(max_sum, max_cur)\n        min_sum = min(min_sum, min_cur)\n\n    return max(max_sum, total - min_sum) if max_sum &gt; 0 else max_sum\n\n\n# Monotonic Queue\ndef maxSubarraySumCircularMQ(nums: List[int]) -&gt; int:\n    n = len(nums)\n    prefix_sum = [0] * (2 * n + 1)\n\n    for i in range(1, 2 * n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + nums[(i - 1) % n]\n\n    q = deque([0])\n    max_sum = float(\"-inf\")\n\n    for i in range(1, 2 * n + 1):\n        if q[0] &lt; i - n:\n            q.popleft()\n\n        max_sum = max(max_sum, prefix_sum[i] - prefix_sum[q[0]])\n\n        while q and prefix_sum[q[-1]] &gt;= prefix_sum[i]:\n            q.pop()\n\n        q.append(i)\n\n    return max_sum\n\n\nnums = [1, -2, 3, -2]\nprint(maxSubarraySumCircularKadane(nums))  # 3\nprint(maxSubarraySumCircularMQ(nums))  # 3\n</code></pre>"},{"location":"LeetPattern/dp_kadane/#152-maximum-product-subarray","title":"152. Maximum Product Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxProduct(nums: List[int]) -&gt; int:\n    n = len(nums)\n    dp_max = [0 for _ in range(n)]\n    dp_min = [0 for _ in range(n)]\n\n    dp_max[0] = nums[0]\n    dp_min[0] = nums[0]\n    max_product = nums[0]\n\n    for i in range(1, n):\n        dp_max[i] = max(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n        dp_min[i] = min(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n\n        max_product = max(max_product, dp_max[i])\n\n    return max_product\n\n\nnums = [2, 3, -2, 4]\nprint(maxProduct(nums))  # 6\n</code></pre>"},{"location":"LeetPattern/dp_kadane/#978-longest-turbulent-subarray","title":"978. Longest Turbulent Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Sliding Window</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxTurbulenceSize(arr: List[int]) -&gt; int:\n    n = len(arr)\n    up = [1 for _ in range(n)]\n    down = [1 for _ in range(n)]\n    maxLen = 1\n\n    for i in range(1, n):\n        if arr[i - 1] &lt; arr[i]:\n            up[i] = down[i - 1] + 1\n            down[i] = 1\n        elif arr[i - 1] &gt; arr[i]:\n            down[i] = up[i - 1] + 1\n            up[i] = 1\n        else:\n            up[i] = 1\n            down[i] = 1\n\n        maxLen = max(maxLen, up[i], down[i])\n\n    return maxLen\n\n\narr = [9, 4, 2, 10, 7, 8, 8, 1, 9]\nprint(maxTurbulenceSize(arr))  # 5\n</code></pre>"},{"location":"LeetPattern/dp_kadane/#1186-maximum-subarray-sum-with-one-deletion","title":"1186. Maximum Subarray Sum with One Deletion","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>\"\"\"\n- [\u7075\u795e\uff1a\u6559\u4f60\u4e00\u6b65\u6b65\u601d\u8003\u52a8\u6001\u89c4\u5212 - \u4ece\u8bb0\u5fc6\u5316\u641c\u7d22\u5230\u9012\u63a8](https://leetcode.cn/problems/maximum-subarray-sum-with-one-deletion/solutions/2321829/jiao-ni-yi-bu-bu-si-kao-dong-tai-gui-hua-hzz6))\n\"\"\"\n\nfrom functools import cache\nfrom math import inf\nfrom typing import List\n\n\n# DP - Kadane\ndef maximumSum(arr: List[int]) -&gt; int:\n    dp0 = arr[0]\n    dp1 = 0\n    res = dp0\n\n    for i in range(1, len(arr)):\n        dp1 = max(dp1 + arr[i], dp0)  # delete previous element or not\n        dp0 = max(dp0, 0) + arr[i]  # delete current element or not\n        res = max(res, dp0, dp1)  # update result\n\n    return res\n\n\n# DP - Memoization\ndef maximumSumMemo(arr: List[int]) -&gt; int:\n    @cache\n    def dfs(i: int, j: int) -&gt; int:\n        if i &lt; 0:\n            return -inf\n        if j == 0:\n            return max(dfs(i - 1, 0), 0) + arr[i]\n        return max(dfs(i - 1, 1) + arr[i], dfs(i - 1, 0))\n\n    return max(max(dfs(i, 0), dfs(i, 1)) for i in range(len(arr)))\n\n\nif __name__ == \"__main__\":\n    arr = [1, -2, 0, 3]\n    assert maximumSum(arr) == 4\n    assert maximumSumMemo(arr) == 4\n</code></pre>"},{"location":"LeetPattern/dp_lcs/","title":"DP LCS","text":""},{"location":"LeetPattern/dp_lcs/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1143. Longest Common Subsequence (Medium)</li> <li> 72. Edit Distance (Medium)</li> <li> 115. Distinct Subsequences (Hard)</li> <li> 392. Is Subsequence (Easy)</li> <li> 583. Delete Operation for Two Strings (Medium)</li> <li> 674. Longest Continuous Increasing Subsequence (Easy)</li> <li> 718. Maximum Length of Repeated Subarray (Medium)</li> <li> 1035. Uncrossed Lines (Medium)</li> </ul>"},{"location":"LeetPattern/dp_lcs/#1143-longest-common-subsequence","title":"1143. Longest Common Subsequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul> Python <pre><code>from functools import cache\n\n\nclass LongestCommonSubsequence:\n    def memoization(self, text1: str, text2: str) -&gt; int:\n        m, n = len(text1), len(text2)\n\n        @cache\n        def dfs(i: int, j: int) -&gt; int:\n            if i &lt; 0 or j &lt; 0:\n                return 0\n            if text1[i] == text2[j]:\n                return dfs(i - 1, j - 1) + 1\n            return max(dfs(i - 1, j), dfs(i, j - 1))\n\n        return dfs(m - 1, n - 1)\n\n    def iterative(self, text1: str, text2: str) -&gt; int:\n        m, n = len(text1), len(text2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for i, x in enumerate(text1):\n            for j, y in enumerate(text2):\n                if x == y:\n                    dp[i + 1][j + 1] = dp[i][j] + 1\n                else:\n                    dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1])\n\n        return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    lcs = LongestCommonSubsequence()\n    assert lcs.memoization(\"abcde\", \"ace\") == 3\n    assert lcs.iterative(\"abcde\", \"ace\") == 3\n    assert lcs.memoization(\"abc\", \"abc\") == 3\n    assert lcs.iterative(\"abc\", \"abc\") == 3\n</code></pre>"},{"location":"LeetPattern/dp_lcs/#72-edit-distance","title":"72. Edit Distance","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul> Python <pre><code>from functools import cache\n\n\n# Recursive\ndef minDistanceDFS(word1: str, word2: str) -&gt; int:\n    n, m = len(word1), len(word2)\n\n    @cache\n    def dfs(i: int, j: int) -&gt; int:\n        if i &lt; 0:\n            return j + 1\n        if j &lt; 0:\n            return i + 1\n        if word1[i] == word2[j]:\n            return dfs(i - 1, j - 1)\n\n        return 1 + min(dfs(i - 1, j), dfs(i, j - 1), dfs(i - 1, j - 1))\n\n    return dfs(n - 1, m - 1)\n\n\n# Iterative\ndef minDistanceDP(word1: str, word2: str) -&gt; int:\n    m, n = len(word1), len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]  # no operation\n            else:\n                dp[i][j] = 1 + min(\n                    dp[i - 1][j],  # delete\n                    dp[i][j - 1],  # insert\n                    dp[i - 1][j - 1],  # replace\n                )\n    return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    word1 = \"horse\"\n    word2 = \"ros\"\n    print(minDistanceDFS(word1, word2))  # 3\n    print(minDistanceDP(word1, word2))  # 3\n</code></pre>"},{"location":"LeetPattern/dp_lcs/#115-distinct-subsequences","title":"115. Distinct Subsequences","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul> Python <pre><code>def numDistinct(s: str, t: str) -&gt; int:\n    m = len(s)\n    n = len(t)\n    dp = [[0] * (n + 1) for _ in range((m + 1))]\n\n    for i in range(m):\n        dp[i][0] = 1\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                # include and exclude s[i-1]\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]  # exclude s[i-1]\n\n    return dp[-1][-1]\n\n\ns = \"rabbbit\"\nt = \"rabbit\"\nprint(numDistinct(s, t))  # 3\n</code></pre>"},{"location":"LeetPattern/dp_lcs/#392-is-subsequence","title":"392. Is Subsequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Dynamic Programming</p> </li> </ul> Python <pre><code># DP - LCS\ndef isSubsequenceLCS(s: str, t: str) -&gt; bool:\n    m = len(s)\n    n = len(t)\n\n    if m &gt; n:\n        return False\n\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    length = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = dp[i][j - 1]  # only delete t string\n\n            if length &lt; dp[i][j]:\n                length = dp[i][j]\n\n    return length == m\n\n\n# Two Pointers\ndef isSubsequenceTP(s: str, t: str) -&gt; bool:\n    i, j = 0, 0\n\n    while i &lt; len(s) and j &lt; len(t):\n        if s[i] == t[j]:\n            i += 1\n        j += 1\n\n    return i == len(s)\n\n\ns = \"abc\"\nt = \"ahbgdc\"\nprint(isSubsequenceLCS(s, t))  # True\nprint(isSubsequenceTP(s, t))  # True\n</code></pre>"},{"location":"LeetPattern/dp_lcs/#583-delete-operation-for-two-strings","title":"583. Delete Operation for Two Strings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul> Python <pre><code># DP - LCS\ndef minDistance1(word1: str, word2: str) -&gt; int:\n    m = len(word1)\n    n = len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]  # no need to delete\n            else:\n                dp[i][j] = min(\n                    dp[i - 1][j] + 1,  # delete word1[i]\n                    dp[i][j - 1] + 1,  # delete word2[j]\n                    dp[i - 1][j - 1] + 2,  # delete both\n                )\n    return dp[-1][-1]\n\n\n# DP - LCS\ndef minDistance2(word1: str, word2: str) -&gt; int:\n    def LCS(word1: str, word2: str) -&gt; int:\n        m = len(word1)\n        n = len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        lcs = 0\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n                if lcs &lt; dp[i][j]:\n                    lcs = dp[i][j]\n        return lcs\n\n    lcs = LCS(word1, word2)\n    return len(word1) + len(word2) - 2 * lcs\n\n\nword1 = \"sea\"\nword2 = \"eat\"\nprint(minDistance1(word1, word2))  # 2\nprint(minDistance2(word1, word2))  # 2\n</code></pre>"},{"location":"LeetPattern/dp_lcs/#674-longest-continuous-increasing-subsequence","title":"674. Longest Continuous Increasing Subsequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef findLengthOfLCIS(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return n\n\n    dp = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        if nums[i] &gt; nums[i - 1]:\n            dp[i] = dp[i - 1] + 1\n\n    return max(dp)\n\n\nprint(findLengthOfLCIS([1, 3, 5, 4, 7]))  # 3\n</code></pre>"},{"location":"LeetPattern/dp_lcs/#718-maximum-length-of-repeated-subarray","title":"718. Maximum Length of Repeated Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Dynamic Programming, Sliding Window, Rolling Hash, Hash Function</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef findLength(nums1: List[int], nums2: List[int]) -&gt; int:\n    m = len(nums1)\n    n = len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    length = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if nums1[i - 1] == nums2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            if length &lt; dp[i][j]:\n                length = dp[i][j]\n\n    return length\n\n\nprint(findLength([1, 2, 3, 2, 1], [3, 2, 1, 4, 7]))  # 3\n</code></pre>"},{"location":"LeetPattern/dp_lcs/#1035-uncrossed-lines","title":"1035. Uncrossed Lines","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef maxUncrossedLines(nums1: List[int], nums2: List[int]) -&gt; int:\n    m = len(nums1)\n    n = len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    num = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if nums1[i - 1] == nums2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n            if num &lt; dp[i][j]:\n                num = dp[i][j]\n\n    return num\n\n\nprint(maxUncrossedLines([1, 4, 2], [1, 2, 4]))  # 2\n</code></pre>"},{"location":"LeetPattern/dp_lis/","title":"DP LIS","text":""},{"location":"LeetPattern/dp_lis/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 300. Longest Increasing Subsequence (Medium)</li> <li> 673. Number of Longest Increasing Subsequence (Medium)</li> <li> 354. Russian Doll Envelopes (Hard)</li> <li> 960. Delete Columns to Make Sorted III (Hard)</li> <li> 1671. Minimum Number of Removals to Make Mountain Array (Hard)</li> <li> 941. Valid Mountain Array (Easy)</li> <li> 845. Longest Mountain in Array (Medium)</li> </ul>"},{"location":"LeetPattern/dp_lis/#300-longest-increasing-subsequence","title":"300. Longest Increasing Subsequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Dynamic Programming</p> </li> </ul> Python <pre><code>from functools import cache\nfrom typing import List\n\n\n# DP - LIS\ndef lengthOfLISMemo(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return n\n\n    @cache\n    def dfs(i: int) -&gt; int:\n        res = 0\n        for j in range(i):\n            if nums[j] &lt; nums[i]:\n                res = max(res, dfs(j))\n        return res + 1\n\n    return max(dfs(i) for i in range(n))\n\n\n# DP - LIS\ndef lengthOfLISTable(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return n\n\n    dp = [1 for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i):\n            if nums[i] &gt; nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\n\nif __name__ == \"__main__\":\n    assert lengthOfLISMemo([10, 9, 2, 5, 3, 7, 101, 18]) == 4\n    assert lengthOfLISTable([10, 9, 2, 5, 3, 7, 101, 18]) == 4\n    assert lengthOfLISMemo([0, 1, 0, 3, 2, 3]) == 4\n    assert lengthOfLISTable([0, 1, 0, 3, 2, 3]) == 4\n    assert lengthOfLISMemo([7, 7, 7, 7]) == 1\n    assert lengthOfLISTable([7, 7, 7, 7]) == 1\n</code></pre>"},{"location":"LeetPattern/dp_lis/#673-number-of-longest-increasing-subsequence","title":"673. Number of Longest Increasing Subsequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Binary Indexed Tree, Segment Tree</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP - LIS\ndef findNumberOfLIS(nums: List[int]) -&gt; int:\n    if not nums:\n        return 0\n\n    n = len(nums)\n    dp = [1 for _ in range(n)]\n    counts = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] &gt; nums[j]:\n                if dp[j] + 1 &gt; dp[i]:\n                    dp[i] = dp[j] + 1\n                    counts[i] = counts[j]\n                elif dp[j] + 1 == dp[i]:\n                    counts[i] += counts[j]\n\n    longest = max(dp)\n    return sum(c for i, c in enumerate(counts) if dp[i] == longest)\n\n\nnums = [1, 3, 5, 4, 7]\nprint(findNumberOfLIS(nums))  # 2\n</code></pre>"},{"location":"LeetPattern/dp_lis/#354-russian-doll-envelopes","title":"354. Russian Doll Envelopes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Dynamic Programming, Sorting</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP - LIS\ndef maxEnvelopes(envelopes: List[List[int]]) -&gt; int:\n    envelopes.sort(key=lambda x: (x[0], -x[1]))\n    dp = []\n\n    for w, h in envelopes:\n        left, right = 0, len(dp)\n        while left &lt; right:\n            mid = left + (right - left) // 2\n            if dp[mid][1] &lt; h:\n                left = mid + 1\n            else:\n                right = mid\n        if right == len(dp):\n            dp.append((w, h))\n        else:\n            dp[right] = (w, h)\n\n    return len(dp)\n\n\nenvelopes = [[5, 4], [6, 4], [6, 7], [2, 3]]\nprint(maxEnvelopes(envelopes))  # 3\n</code></pre>"},{"location":"LeetPattern/dp_lis/#960-delete-columns-to-make-sorted-iii","title":"960. Delete Columns to Make Sorted III","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP - LIS\ndef minDeletionSize(strs: List[str]) -&gt; int:\n    if not strs:\n        return 0\n\n    n = len(strs[0])\n    dp = [1 for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i):\n            if all(row[j] &lt;= row[i] for row in strs):\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return n - max(dp)\n</code></pre>"},{"location":"LeetPattern/dp_lis/#1671-minimum-number-of-removals-to-make-mountain-array","title":"1671. Minimum Number of Removals to Make Mountain Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Dynamic Programming, Greedy</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP - LIS\ndef minimumMountainRemovals(nums: List[int]) -&gt; int:\n    n = len(nums)\n    lis = [1 for _ in range(n)]\n    lds = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] &gt; nums[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    for i in range(n - 2, -1, -1):\n        for j in range(n - 1, i, -1):\n            if nums[i] &gt; nums[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    maxLen = 0\n    for i in range(1, n - 1):\n        if lis[i] &gt; 1 and lds[i] &gt; 1:\n            maxLen = max(maxLen, lis[i] + lds[i] - 1)\n\n    return n - maxLen\n\n\nnums = [2, 1, 1, 5, 6, 2, 3, 1]\nprint(minimumMountainRemovals(nums))  # 3\n</code></pre>"},{"location":"LeetPattern/dp_lis/#941-valid-mountain-array","title":"941. Valid Mountain Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Array\ndef validMountainArray(arr: List[int]) -&gt; bool:\n    n = len(arr)\n    i = 0\n\n    while i &lt; n - 1 and arr[i] &lt; arr[i + 1]:\n        i += 1\n\n    if i == 0 or i == n - 1:\n        return False\n\n    while i &lt; n - 1 and arr[i] &gt; arr[i + 1]:\n        i += 1\n\n    return i == n - 1\n\n\n# Left Right Pointers\ndef validMountainArrayLP(arr: List[int]) -&gt; bool:\n    n = len(arr)\n\n    if n &lt; 3:\n        return False\n\n    left, right = 0, n - 1\n\n    while left &lt; n - 1 and arr[left] &lt; arr[left + 1]:\n        left += 1\n\n    while right &gt; 0 and arr[right] &lt; arr[right - 1]:\n        right -= 1\n\n    return 0 &lt; left == right &lt; n - 1\n\n\narr = [0, 3, 2, 1]\nprint(validMountainArray(arr))  # True\nprint(validMountainArrayLP(arr))  # True\n</code></pre>"},{"location":"LeetPattern/dp_lis/#845-longest-mountain-in-array","title":"845. Longest Mountain in Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Dynamic Programming, Enumeration</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef longestMountain(arr: List[int]) -&gt; int:\n    n = len(arr)\n    res = 0\n    left = 0\n\n    while left &lt; n:\n        right = left\n\n        if right &lt; n - 1 and arr[right] &lt; arr[right + 1]:\n            while right &lt; n - 1 and arr[right] &lt; arr[right + 1]:\n                right += 1\n\n            if right &lt; n - 1 and arr[right] &gt; arr[right + 1]:\n                while right &lt; n - 1 and arr[right] &gt; arr[right + 1]:\n                    right += 1\n                res = max(res, right - left + 1)\n\n        left = max(right, left + 1)\n\n    return res\n\n\narr = [2, 1, 4, 7, 3, 2, 5]\nprint(longestMountain(arr))  # 5\n</code></pre>"},{"location":"LeetPattern/dp_stock/","title":"DP Stock","text":""},{"location":"LeetPattern/dp_stock/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 121. Best Time to Buy and Sell Stock (Easy)</li> <li> 122. Best Time to Buy and Sell Stock II (Medium)</li> <li> 123. Best Time to Buy and Sell Stock III (Hard)</li> <li> 188. Best Time to Buy and Sell Stock IV (Hard)</li> <li> 309. Best Time to Buy and Sell Stock with Cooldown (Medium)</li> <li> 714. Best Time to Buy and Sell Stock with Transaction Fee (Medium)</li> </ul>"},{"location":"LeetPattern/dp_stock/#121-best-time-to-buy-and-sell-stock","title":"121. Best Time to Buy and Sell Stock","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return the maximum profit that can be achieved from buying on one day and selling on another day.\n\"\"\"\n\nfrom typing import List\n\n\n# Brute Force\ndef maxProfitBF(prices: List[int]) -&gt; int:\n    max_profit = 0\n    n = len(prices)\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_profit = max(max_profit, prices[j] - prices[i])\n\n    return max_profit\n\n\n# DP\ndef maxProfitDP(prices: List[int]) -&gt; int:\n    dp = [[0] * 2 for _ in range(len(prices))]\n    dp[0][0] = -prices[0]  # buy\n    dp[0][1] = 0  # sell\n\n    for i in range(1, len(prices)):\n        dp[i][0] = max(dp[i - 1][0], -prices[i])  # the lowest price to buy\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    max_profit = 0\n    seen_min = prices[0]\n\n    for i in range(1, len(prices)):\n        max_profit = max(max_profit, prices[i] - seen_min)\n        seen_min = min(seen_min, prices[i])\n\n    return max_profit\n\n\n# Fast Slow Pointers\ndef maxProfitFS(prices: List[int]) -&gt; int:\n    max_profit = 0\n    slow, fast = 0, 1\n\n    while fast &lt; len(prices):\n        if prices[fast] &gt; prices[slow]:\n            max_profit = max(max_profit, prices[fast] - prices[slow])\n        else:\n            slow = fast\n        fast += 1\n\n    return max_profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force|  O(n^2)|  O(1)   |\n# | DP         |  O(n)  |  O(n)   |\n# | Greedy     |  O(n)  |  O(1)   |\n# | Fast Slow  |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitBF(prices))  # 5\nprint(maxProfitDP(prices))  # 5\nprint(maxProfitGreedy(prices))  # 5\nprint(maxProfitFS(prices))  # 5\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int maxProfitMemo(vector&lt;int&gt; &amp;prices) {\n        if (prices.size() &lt;= 1) return 0;\n\n        int seen_min = prices[0];\n        int res = 0;\n\n        for (int &amp;price : prices) {\n            res = max(res, price - seen_min);\n            seen_min = min(seen_min, price);\n        }\n        return res;\n    }\n};\n\nint main() {\n    vector&lt;int&gt; prices = {7, 1, 5, 3, 6, 4};\n    Solution obj;\n    cout &lt;&lt; obj.maxProfitMemo(prices) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/dp_stock/#122-best-time-to-buy-and-sell-stock-ii","title":"122. Best Time to Buy and Sell Stock II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return the maximum profit you can achieve.\n\"\"\"\n\nfrom typing import List\n\n\n# DP\ndef maxProfitDP1(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 2 for _ in range(n)]\n    dp[0][0] = -prices[0]\n    dp[0][1] = 0\n\n    for i in range(1, n):\n        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i])\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# DP - Optimized\ndef maxProfitDP2(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    hold = -prices[0]\n    profit = 0\n\n    for i in range(1, n):\n        hold = max(hold, profit - prices[i])\n        profit = max(profit, hold + prices[i])\n\n    return profit\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    profit = 0\n\n    for i in range(1, len(prices)):\n        profit += max(prices[i] - prices[i - 1], 0)\n\n    return profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |     DP1    |  O(n)  |   O(n)  |\n# |     DP2    |  O(n)  |   O(1)  |\n# |   Greedy   |  O(n)  |   O(1)  |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitDP1(prices))  # 7\nprint(maxProfitDP2(prices))  # 7\nprint(maxProfitGreedy(prices))  # 7\n</code></pre> <pre><code>#include &lt;array&gt;\n#include &lt;cassert&gt;\n#include &lt;climits&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int maxProfitMemo(vector&lt;int&gt;&amp; prices) {\n        int n = prices.size();\n        vector&lt;array&lt;int, 2&gt;&gt; memo(n, {-1, -1});\n\n        auto dfs = [&amp;](this auto&amp;&amp; dfs, int i, bool hold) -&gt; int {\n            if (i &lt; 0) {\n                return hold ? INT_MIN : 0;\n            }\n            int&amp; res = memo[i][hold];\n            if (res != -1) {\n                return res;\n            }\n            if (hold) {\n                return res = max(dfs(i - 1, true),                // skip\n                                 dfs(i - 1, false) - prices[i]);  // buy\n            } else {\n                return res = max(dfs(i - 1, false),              // skip\n                                 dfs(i - 1, true) + prices[i]);  // sell\n            }\n        };\n\n        return dfs(n - 1, false);\n    }\n\n    int maxProfitIterative(vector&lt;int&gt;&amp; prices) {\n        int n = prices.size();\n        vector&lt;array&lt;int, 2&gt;&gt; dp(n, {0, 0});\n        dp[0][0] = -prices[0];\n        dp[0][1] = 0;\n\n        for (int i = 1; i &lt; n; i++) {\n            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);  // buy\n            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);  // sell\n        }\n        return dp[n - 1][1];\n    }\n\n    int maxProfitIterativeOptimized(vector&lt;int&gt;&amp; prices) {\n        int n = prices.size();\n        if (n &lt;= 1) return 0;\n\n        int hold = -prices[0], res = 0;\n\n        for (int i = 1; i &lt; n; i++) {\n            hold = max(hold, res - prices[i]);  // buy\n            res = max(res, hold + prices[i]);   // sell\n        }\n        return res;\n    }\n\n    int maxProfitGreedy(vector&lt;int&gt;&amp; prices) {\n        int n = prices.size();\n        if (n &lt;= 1) return 0;\n\n        int res = 0;\n\n        for (int i = 1; i &lt; n; i++) {\n            if (prices[i] &gt; prices[i - 1]) {\n                res += prices[i] - prices[i - 1];\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; prices = {7, 1, 5, 3, 6, 4};\n    assert(solution.maxProfitMemo(prices) == 7);\n    assert(solution.maxProfitIterative(prices) == 7);\n    assert(solution.maxProfitIterativeOptimized(prices) == 7);\n    assert(solution.maxProfitGreedy(prices) == 7);\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/dp_stock/#123-best-time-to-buy-and-sell-stock-iii","title":"123. Best Time to Buy and Sell Stock III","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# 1. DP\ndef maxProfitDP1(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 5 for _ in range(n)]\n\n    dp[0][0] = 0  # no transaction\n    dp[0][1] = -prices[0]  # buy 1\n    dp[0][2] = 0  # sell 1\n    dp[0][3] = -prices[0]  # buy 2\n    dp[0][4] = 0  # sell 2\n\n    for i in range(1, n):\n        dp[i][0] = dp[i - 1][0]\n        dp[i][1] = max(dp[i - 1][1], -prices[i])\n        dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i])\n        dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i])\n        dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i])\n\n    return dp[-1][4]\n\n\n# 2. DP - Optimized\ndef maxProfitDP2(prices: List[int]) -&gt; int:\n    b1, b2 = float(\"inf\"), float(\"inf\")\n    s1, s2 = 0, 0\n\n    for price in prices:\n        b1 = min(b1, price)\n        s1 = max(s1, price - b1)\n        b2 = min(b2, price - s1)\n        s2 = max(s2, price - b2)\n\n    return s2\n\n\nprices = [3, 3, 5, 0, 0, 3, 1, 4]\nprint(maxProfitDP1(prices))  # 6\nprint(maxProfitDP2(prices))  # 6\n</code></pre>"},{"location":"LeetPattern/dp_stock/#188-best-time-to-buy-and-sell-stock-iv","title":"188. Best Time to Buy and Sell Stock IV","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP\ndef maxProfit(k: int, prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * (2 * k + 1) for _ in range(n)]\n\n    for j in range(1, 2 * k, 2):\n        dp[0][j] = -prices[0]\n\n    for i in range(1, n):\n        for j in range(0, 2 * k - 1, 2):\n            dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i])\n            dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i])\n\n    return dp[-1][2 * k]\n\n\nk = 2\nprices = [2, 4, 1]\nprint(maxProfit(k, prices))  # 2\n</code></pre>"},{"location":"LeetPattern/dp_stock/#309-best-time-to-buy-and-sell-stock-with-cooldown","title":"309. Best Time to Buy and Sell Stock with Cooldown","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP\ndef maxProfit(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 4 for _ in range(n)]\n\n    dp[0][0] = -prices[0]  # poessess\n    dp[0][1] = 0  # stay sold\n    dp[0][2] = 0  # sell\n    dp[0][3] = 0  # cooldown\n\n    for i in range(1, n):\n        dp[i][0] = max(\n            dp[i - 1][0],  # stay poessess\n            dp[i - 1][1] - prices[i],  # buy after stay sold\n            dp[i - 1][3] - prices[i],  # buy after cooldown\n        )\n        dp[i][1] = max(\n            dp[i - 1][1],  # stay sold\n            dp[i - 1][3],  # stay cooldown\n        )\n        dp[i][2] = dp[i - 1][0] + prices[i]\n        dp[i][3] = dp[i - 1][2]\n\n    return max(dp[-1])\n\n\nprices = [1, 2, 3, 0, 2]\nprint(maxProfit(prices))  # 3\n</code></pre>"},{"location":"LeetPattern/dp_stock/#714-best-time-to-buy-and-sell-stock-with-transaction-fee","title":"714. Best Time to Buy and Sell Stock with Transaction Fee","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the maximum profit you can achieve with the given transaction fee.\n\"\"\"\n\nfrom typing import List\n\n\n# 1. DP\ndef maxProfitDP(prices: List[int], fee: int) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 2 for _ in range(n)]\n\n    dp[0][0] = -prices[0] - fee\n    dp[0][1] = 0\n\n    for i in range(1, n):\n        dp[i][0] = max(\n            dp[i - 1][0],  # hold\n            dp[i - 1][1] - prices[i] - fee,  # buy\n        )\n        dp[i][1] = max(\n            dp[i - 1][1],  # hold\n            dp[i - 1][0] + prices[i],  # sell\n        )\n\n    return max(dp[-1])\n\n\n# 2. Greedy\ndef maxProfitGreedy(prices: List[int], fee: int) -&gt; int:\n    n = len(prices)\n    if n == 0:\n        return 0\n\n    buy = prices[0]\n    profit = 0\n\n    for i in range(1, n):\n        if prices[i] &lt; buy:\n            buy = prices[i]\n        elif prices[i] &gt; buy + fee:\n            profit += prices[i] - buy - fee\n            buy = prices[i] - fee\n\n    return profit\n\n\nprices = [1, 3, 2, 8, 4, 9]\nfee = 2\nprint(maxProfitDP(prices, fee))  # 8\nprint(maxProfitGreedy(prices, fee))  # 8\n</code></pre>"},{"location":"LeetPattern/dp_unbounded_knapsack/","title":"DP Unbounded Knapsack","text":""},{"location":"LeetPattern/dp_unbounded_knapsack/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 139. Word Break (Medium)</li> <li> 279. Perfect Squares (Medium)</li> <li> 322. Coin Change (Medium)</li> <li> 518. Coin Change II (Medium)</li> <li> 377. Combination Sum IV (Medium)</li> </ul>"},{"location":"LeetPattern/dp_unbounded_knapsack/#139-word-break","title":"139. Word Break","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Dynamic Programming, Trie, Memoization</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\n# DP (Unbounded Knapsack)\ndef wordBreak(s: str, wordDict: List[str]) -&gt; bool:\n    n = len(s)\n    dp = [False for _ in range(n + 1)]\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for word in wordDict:\n            m = len(word)\n            if s[i - m : i] == word and dp[i - m]:\n                dp[i] = True\n    return dp[-1]\n\n\ns = \"leetcode\"\nwordDict = [\"leet\", \"code\"]\nprint(wordBreak(s, wordDict))  # True\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;cassert&gt;\n#include &lt;ranges&gt;\n#include &lt;string&gt;\n#include &lt;unordered_set&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) {\n        int max_len = ranges::max(wordDict, {}, &amp;string::length).length();\n        unordered_set&lt;string&gt; words(wordDict.begin(), wordDict.end());\n\n        int n = s.length();\n        vector&lt;int&gt; f(n + 1);\n        f[0] = true;\n        for (int i = 1; i &lt;= n; i++) {\n            for (int j = i - 1; j &gt;= max(i - max_len, 0); j--) {\n                if (f[j] &amp;&amp; words.count(s.substr(j, i - j))) {\n                    f[i] = true;\n                    break;\n                }\n            }\n        }\n        return f[n];\n    }\n};\n\nint main() {\n    Solution solution;\n    string s = \"leetcode\";\n    vector&lt;string&gt; wordDict = {\"leet\", \"code\"};\n    assert(solution.wordBreak(s, wordDict) == true);\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/dp_unbounded_knapsack/#279-perfect-squares","title":"279. Perfect Squares","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Breadth First Search</p> </li> </ul> Python <pre><code>import math\n\n\n# DP - Knapsack Unbounded\ndef numSquares(n: int) -&gt; int:\n    dp = [float(\"inf\") for _ in range(n + 1)]\n    dp[0] = 0\n\n    for i in range(1, n + 1):\n        for j in range(1, int(math.sqrt(n)) + 1):\n            dp[i] = min(dp[i], dp[i - j**2] + 1)\n\n    return dp[n]\n\n\nn = 12\nprint(numSquares(n))  # 3\n</code></pre>"},{"location":"LeetPattern/dp_unbounded_knapsack/#322-coin-change","title":"322. Coin Change","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Breadth First Search</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef coinChange(coins: List[int], amount: int) -&gt; int:\n    dp = [float(\"inf\") for _ in range(amount + 1)]\n\n    dp[0] = 0\n\n    for i in range(1, amount + 1):\n        for c in coins:\n            if i - c &gt;= 0:\n                dp[i] = min(dp[i], 1 + dp[i - c])\n\n    return dp[amount] if dp[amount] != float(\"inf\") else -1\n\n\ncoins = [1, 2, 5]\namount = 11\nprint(coinChange(coins, amount))  # 3\n</code></pre>"},{"location":"LeetPattern/dp_unbounded_knapsack/#518-coin-change-ii","title":"518. Coin Change II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef change(amount: int, coins: List[int]) -&gt; int:\n    dp = [0 for _ in range(amount + 1)]\n    dp[0] = 1\n\n    for i in range(len(coins)):\n        for j in range(coins[i], amount + 1):\n            dp[j] += dp[j - coins[i]]\n\n    return dp[-1]\n\n\namount = 5\ncoins = [1, 2, 5]\nprint(change(amount, coins))  # 4\n</code></pre>"},{"location":"LeetPattern/dp_unbounded_knapsack/#377-combination-sum-iv","title":"377. Combination Sum IV","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef combinationSum4(nums: List[int], target: int) -&gt; int:\n    dp = [0 for _ in range(target + 1)]\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for j in range(len(nums)):\n            if i - nums[j] &gt;= 0:\n                dp[i] += dp[i - nums[j]]\n\n        return dp[target]\n\n\nnums = [1, 2, 3]\ntarget = 4\nprint(combinationSum4(nums, target))  # 7\n</code></pre>"},{"location":"LeetPattern/fast_slow_pointers/","title":"Fast Slow Pointers","text":""},{"location":"LeetPattern/fast_slow_pointers/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 27. Remove Element (Easy)</li> <li> 26. Remove Duplicates from Sorted Array (Easy)</li> <li> 80. Remove Duplicates from Sorted Array II (Medium)</li> <li> 283. Move Zeroes (Easy)</li> <li> 1089. Duplicate Zeros (Easy)</li> <li> 287. Find the Duplicate Number (Medium)</li> </ul>"},{"location":"LeetPattern/fast_slow_pointers/#27-remove-element","title":"27. Remove Element","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Remove all instances of a given value in-place.\n\"\"\"\n\nfrom typing import List\n\n\n# Fast Slow Pointers\ndef removeElement(nums: List[int], val: int) -&gt; int:\n    fast, slow = 0, 0\n\n    while fast &lt; len(nums):\n        if nums[fast] != val:\n            nums[slow] = nums[fast]\n            slow += 1\n        fast += 1\n\n    return slow\n\n\nnums = [0, 1, 2, 2, 3, 0, 4, 2]\nval = 2\nprint(removeElement(nums, val))  # 5\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// Fast Slow Pointers\nint removeElement(vector&lt;int&gt;&amp; nums, int val) {\n    size_t n = nums.size();\n    size_t slow = 0, fast = 0;\n\n    while (fast &lt; n) {\n        if (nums[fast] != val) {\n            nums[slow] = nums[fast];\n            slow++;\n        }\n        fast++;\n    }\n    return (int)slow;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {3, 2, 2, 3};\n    int val = 3;\n    cout &lt;&lt; removeElement(nums, val) &lt;&lt; endl;  // 2\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/fast_slow_pointers/#26-remove-duplicates-from-sorted-array","title":"26. Remove Duplicates from Sorted Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Remove duplicates in-place.\n\"\"\"\n\nfrom typing import List\n\n\ndef removeDuplicates(nums: List[int]) -&gt; int:\n    fast, slow = 1, 1\n\n    while fast &lt; len(nums):\n        if nums[fast] != nums[fast - 1]:\n            nums[slow] = nums[fast]\n            slow += 1\n        fast += 1\n\n    return slow\n\n\nnums = [1, 1, 2]\nprint(removeDuplicates(nums))  # 2\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int removeDuplicates(vector&lt;int&gt;&amp; nums) {\n        int fast = 1, slow = 1;\n        int n = nums.size();\n\n        while (fast &lt; n) {\n            if (nums[fast] != nums[fast - 1]) {\n                nums[slow] = nums[fast];\n                slow++;\n            }\n            fast++;\n        }\n        return slow;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; nums = {0, 0, 1, 1, 1, 2, 2, 3, 3, 4};\n    assert(solution.removeDuplicates(nums) == 5);\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/fast_slow_pointers/#80-remove-duplicates-from-sorted-array-ii","title":"80. Remove Duplicates from Sorted Array II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Allow at most two duplicates.\n-   fast pointer: explore the array\n-   slow pointer: point to the position to be replaced\n\"\"\"\n\nfrom typing import List\n\n\ndef removeDuplicates(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 2:\n        return len(nums)\n\n    fast, slow = 2, 2\n\n    while fast &lt; len(nums):\n        if nums[fast] != nums[slow - 2]:\n            nums[slow] = nums[fast]\n            slow += 1\n        fast += 1\n\n    return slow\n\n\nnums = [1, 1, 1, 2, 2, 3]\nprint(removeDuplicates(nums))\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int removeDuplicates(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n        if (n &lt;= 2) return n;\n\n        int fast = 2, slow = 2;\n\n        while (fast &lt; n) {\n            if (nums[fast] != nums[slow - 2]) {\n                nums[slow] = nums[fast];\n                slow++;\n            }\n            fast++;\n        }\n        return slow;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; nums = {0, 0, 1, 1, 1, 1, 2, 2, 3, 3, 4};\n    assert(solution.removeDuplicates(nums) == 9);\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/fast_slow_pointers/#283-move-zeroes","title":"283. Move Zeroes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Move all zeroes to the end of the array while maintaining the relative order of the non-zero elements.\n\"\"\"\n\nfrom typing import List\n\n\ndef moveZeroes(nums: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    fast, slow = 0, 0\n\n    while fast &lt; len(nums):\n        if nums[fast] != 0:\n            nums[slow], nums[fast] = nums[fast], nums[slow]\n            slow += 1\n        fast += 1\n\n\nnums = [0, 1, 0, 3, 12]\nmoveZeroes(nums)\nprint(nums)  # [1, 3, 12, 0, 0]\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvoid moveZeroes(vector&lt;int&gt;&amp; nums) {\n    size_t n = nums.size();\n    size_t fast = 0, slow = 0;\n\n    while (fast &lt; n) {\n        if (nums[fast] != 0) {\n            swap(nums[slow], nums[fast]);\n            slow++;\n        }\n        fast++;\n    }\n}\n\nint main() {\n    vector&lt;int&gt; nums = {0, 1, 0, 3, 12};\n    moveZeroes(nums);\n    // [1, 3, 12, 0, 0]\n    for (size_t i = 0; i &lt; nums.size(); i++) {\n        cout &lt;&lt; nums[i] &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/fast_slow_pointers/#1089-duplicate-zeros","title":"1089. Duplicate Zeros","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers</p> </li> </ul> Python <pre><code>\"\"\"\n-   Duplicate each occurrence of zero, shifting the remaining elements to the right.\n\"\"\"\n\nfrom typing import List\n\n\ndef duplicateZeros(arr: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify arr in-place instead.\n    \"\"\"\n    n = len(arr)\n    fast, slow = 0, 0\n\n    # First pass: find the position\n    # where the last element would be in the expanded array\n    while fast &lt; n:\n        if arr[slow] == 0:\n            fast += 1\n        slow += 1\n        fast += 1\n\n    slow -= 1\n    fast -= 1\n\n    # Second pass: move elements backwards\n    while slow &gt;= 0:\n        if fast &lt; n:\n            arr[fast] = arr[slow]\n\n        if arr[slow] == 0:\n            fast -= 1\n            if fast &lt; n:\n                arr[fast] = 0\n\n        slow -= 1\n        fast -= 1\n\n\narr = [1, 0, 2, 3, 0, 4, 5, 0]\nduplicateZeros(arr)\nprint(arr)  # [1, 0, 0, 2, 3, 0, 0, 4]\n</code></pre>"},{"location":"LeetPattern/fast_slow_pointers/#287-find-the-duplicate-number","title":"287. Find the Duplicate Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Bit Manipulation</p> </li> </ul> Python <pre><code>\"\"\"\n-   Find the duplicate number in an array containing `n + 1` integers where each integer is between `1` and `n` inclusive.\n-   Floyd's Tortoise and Hare (Cycle Detection)\n    -   141. Linked List Cycle\n    -   142. Linked List Cycle II\n-   Time Complexity: O(n)\n-   Space Complexity: O(1)\n\nExample: `nums = [1, 3, 4, 2, 2]`\n\n|  0   |  1   |  2   |  3   |  4   |\n| :--: | :--: | :--: | :--: | :--: |\n|  1   |  3   |  4   |  2   |  2   |\n\n\n\"\"\"\n\nfrom typing import List\n\n\n# Floyd Cycle Detection Algorithm\ndef findDuplicate(nums: List[int]) -&gt; int:\n    fast, slow = nums[0], nums[0]\n\n    while True:\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n        if slow == fast:\n            break\n\n    slow = nums[0]\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[fast]\n\n    return slow\n\n\nnums = [1, 3, 4, 2, 2]\nprint(findDuplicate(nums))  # 2\n</code></pre>"},{"location":"LeetPattern/graph_bellman_ford/","title":"Graph Bellman Ford","text":""},{"location":"LeetPattern/graph_bellman_ford/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 743. Network Delay Time (Medium)</li> <li> 787. Cheapest Flights Within K Stops (Medium)</li> </ul>"},{"location":"LeetPattern/graph_bellman_ford/#743-network-delay-time","title":"743. Network Delay Time","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Graph, Heap Priority Queue, Shortest Path</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return the minimum time taken to reach all nodes in a network.\n-   Shortest Path Problem: Find the shortest path between two vertices in a graph.\n-   Dijkstra's Algorithm\n    -   Shortest path algorithm\n    -   Weighted graph (non-negative weights)\n    -   Data Structure: Heap; Hash Set\n    -   Time Complexity: O(E * logV)\n    -   Space Complexity: O(V)\n\"\"\"\n\nimport heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Dijkstra - Set\ndef networkDelayTime1(times: List[List[int]], n: int, k: int) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    heap = [(0, k)]\n    visit = set()\n    t = 0\n\n    while heap:\n        w1, n1 = heapq.heappop(heap)\n        if n1 in visit:\n            continue\n\n        visit.add(n1)\n        t = w1\n\n        for n2, w2 in graph[n1]:\n            heapq.heappush(heap, (w1 + w2, n2))\n\n    return t if len(visit) == n else -1\n\n\n# Dijkstra - Dict\ndef networkDelayTime2(times: List[List[int]], n: int, k: int) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    heap = [(0, k)]\n    dist = defaultdict(int)\n\n    while heap:\n        w1, n1 = heapq.heappop(heap)\n        if n1 in dist:\n            continue\n\n        dist[n1] = w1\n\n        for n2, w2 in graph[n1]:\n            heapq.heappush(heap, (w1 + w2, n2))\n\n    return max(dist.values()) if len(dist) == n else -1\n\n\n# Bellman-Ford\ndef networkDelayTimeBF(times: List[List[int]], n: int, k: int) -&gt; int:\n    delay = {i: float(\"inf\") for i in range(1, n + 1)}\n    delay[k] = 0\n\n    for _ in range(n - 1):\n        for u, v, t in times:\n            delay[v] = min(delay[v], delay[u] + t)\n\n    max_delay = max(delay.values())\n    return max_delay if max_delay &lt; float(\"inf\") else -1\n\n\n# |--------------|-----------|--------|\n# | Approach     | Time      | Space  |\n# |--------------|-----------|--------|\n# | Dijkstra     | O(E*logV) | O(V+E) |\n# | Bellman-Ford | O(E*V)    | O(V)   |\n# |--------------|-----------|--------|\n\nif __name__ == \"__main__\":\n    times = [[2, 1, 1], [2, 3, 1], [3, 4, 1]]\n    n = 4\n    k = 2\n    print(networkDelayTime1(times, n, k))  # 2\n    print(networkDelayTime2(times, n, k))  # 2\n    print(networkDelayTimeBF(times, n, k))  # 2\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;cassert&gt;\n#include &lt;climits&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass NetworkDelayTime {\n   public:\n    // single-source, non-negative weight -&gt; Dijkstra's\n    // https://leetcode.cn/problems/network-delay-time/solutions/2668220/liang-chong-dijkstra-xie-fa-fu-ti-dan-py-ooe8/\n    int dijkstra(vector&lt;vector&lt;int&gt;&gt;&amp; times, int n, int k) {\n        vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; graph(n + 1);\n        for (auto&amp; t : times) {\n            graph[t[0]].push_back({t[1], t[2]});\n        }\n\n        vector&lt;int&gt; dist(n + 1, INT_MAX);\n        // min heap\n        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;,\n                       greater&lt;pair&lt;int, int&gt;&gt;&gt;\n            min_heap;\n\n        dist[k] = 0;\n        min_heap.push({0, k});  // [dist, node]\n\n        while (!min_heap.empty()) {\n            auto [d, u] = min_heap.top();\n            min_heap.pop();\n\n            if (d &gt; dist[u]) continue;  // found the shortest\n\n            for (auto&amp; [v, w] : graph[u]) {\n                if (dist[u] + w &lt; dist[v]) {\n                    dist[v] = dist[u] + w;\n                    min_heap.push({dist[v], v});\n                }\n            }\n        }\n\n        int res = 0;\n        for (int i = 1; i &lt;= n; ++i) {\n            if (dist[i] == INT_MAX) return -1;\n            res = max(res, dist[i]);\n        }\n        return res;\n    }\n\n    // single source -&gt; Bellman-Ford\n    int bellman_ford(vector&lt;vector&lt;int&gt;&gt;&amp; times, int n, int k) {\n        vector&lt;int&gt; dist(n + 1, INT_MAX);\n        dist[k] = 0;\n\n        for (int i = 1; i &lt;= n - 1; i++) {\n            for (auto&amp; edge : times) {\n                int u = edge[0], v = edge[1], t = edge[2];\n                if (dist[u] != INT_MAX &amp;&amp; dist[v] &gt; dist[u] + t) {\n                    dist[v] = dist[u] + t;\n                }\n            }\n        }\n\n        int res = 0;\n        for (int i = 1; i &lt;= n; i++) {\n            if (dist[i] == INT_MAX) return -1;\n            res = max(res, dist[i]);\n        }\n        return res;\n    }\n};\n\nint main() {\n    NetworkDelayTime solution;\n    vector&lt;vector&lt;int&gt;&gt; times = {{2, 1, 1}, {2, 3, 1}, {3, 4, 1}};\n    assert(solution.dijkstra(times, 4, 2) == 2);\n    assert(solution.bellman_ford(times, 4, 2) == 2);\n\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/graph_bellman_ford/#787-cheapest-flights-within-k-stops","title":"787. Cheapest Flights Within K Stops","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Depth First Search, Breadth First Search, Graph, Heap Priority Queue, Shortest Path</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return the cheapest price from `src` to `dst` with at most `K` stops.\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/5eIK3zUdYmE?si=aBR0VbHXTgNuVlGz\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen&gt;&lt;/iframe&gt;\n\"\"\"\n\nimport heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Bellman-Ford\ndef findCheapestPriceBF(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    prices = [float(\"inf\") for _ in range(n)]\n    prices[src] = 0\n\n    for _ in range(k + 1):\n        temp = prices[:]\n        for u, v, w in flights:\n            temp[v] = min(temp[v], prices[u] + w)\n        prices = temp\n\n    return prices[dst] if prices[dst] != float(\"inf\") else -1\n\n\n# Dijkstra\ndef findCheapestPriceDijkstra(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in flights:\n        graph[u].append((v, w))\n\n    heap = [(0, src, 0)]  # (price, city, stops)\n    visited = defaultdict(int)  # {city: stops}\n\n    while heap:\n        price, city, stops = heapq.heappop(heap)\n\n        if city == dst:\n            return price\n\n        if stops &gt; k:\n            continue\n\n        if city in visited and visited[city] &lt;= stops:\n            continue\n\n        visited[city] = stops\n\n        for neighbor, cost in graph[city]:\n            heapq.heappush(heap, (price + cost, neighbor, stops + 1))\n\n    return -1\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |Bellman-Ford|    O(k * E)      |  O(n)   |\n# | Dijkstra   | O(E * log(V))    |  O(n)   |\n# |------------|------------------|---------|\n\n\nn = 4\nflights = [[0, 1, 100], [1, 2, 100], [2, 0, 100], [1, 3, 600], [2, 3, 200]]\nsrc = 0\ndst = 3\nk = 1\nprint(findCheapestPriceBF(n, flights, src, dst, k))  # 700\nprint(findCheapestPriceDijkstra(n, flights, src, dst, k))  # 700\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;climits&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass FindCheapestPrice {\n   public:\n    int bellman_ford(int n, vector&lt;vector&lt;int&gt;&gt;&amp; flights, int src, int dst,\n                     int k) {\n        vector&lt;int&gt; dist(n, INT_MAX);\n        dist[src] = 0;\n\n        for (int i = 0; i &lt;= k; ++i) {\n            vector&lt;int&gt; temp(dist);\n            for (auto&amp; flight : flights) {\n                int u = flight[0], v = flight[1], w = flight[2];\n                if (dist[u] != INT_MAX &amp;&amp; dist[u] + w &lt; temp[v]) {\n                    temp[v] = dist[u] + w;\n                }\n            }\n            dist = temp;\n        }\n        return dist[dst] == INT_MAX ? -1 : dist[dst];\n    }\n\n    int dijkstra(int n, vector&lt;vector&lt;int&gt;&gt;&amp; flights, int src, int dst, int k) {\n        vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; graph(n);\n        for (auto&amp; flight : flights) {\n            graph[flight[0]].push_back({flight[1], flight[2]});\n        }\n        priority_queue&lt;array&lt;int, 3&gt;, vector&lt;array&lt;int, 3&gt;&gt;,\n                       greater&lt;array&lt;int, 3&gt;&gt;&gt;\n            min_heap;\n        min_heap.push({0, src, k + 1});\n\n        while (!min_heap.empty()) {\n            auto [cost, u, stops] = min_heap.top();\n            min_heap.pop();\n            if (u == dst) {\n                return cost;\n            }\n            if (stops &gt; 0) {\n                for (auto&amp; [v, w] : graph[u]) {\n                    min_heap.push({cost + w, v, stops - 1});\n                }\n            }\n        }\n\n        return -1;\n    }\n};\n\nint main() {\n    FindCheapestPrice solution;\n    int n = 4;\n    vector&lt;vector&lt;int&gt;&gt; flights = {\n        {0, 1, 100}, {1, 2, 100}, {2, 0, 100}, {1, 3, 600}, {2, 3, 200}};\n    int src = 0, dst = 3, k = 1;\n    assert(solution.bellman_ford(n, flights, src, dst, k) == 700);\n    assert(solution.dijkstra(n, flights, src, dst, k) == 700);\n\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/graph_bfs/","title":"Graph BFS","text":""},{"location":"LeetPattern/graph_bfs/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 994. Rotting Oranges (Medium)</li> <li> 127. Word Ladder (Hard)</li> <li> 1466. Reorder Routes to Make All Paths Lead to the City Zero (Medium)</li> <li> 286. Walls and Gates (Medium) \ud83d\udc51</li> <li> 815. Bus Routes (Hard)</li> </ul>"},{"location":"LeetPattern/graph_bfs/#994-rotting-oranges","title":"994. Rotting Oranges","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Breadth First Search, Matrix</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the minimum number of minutes that must elapse until no cell has a fresh orange.\n-   Hint: Multi-source BFS to count the level.\n\n![994](https://assets.leetcode.com/uploads/2019/02/16/oranges.png)\n\"\"\"\n\nfrom collections import deque\nfrom typing import List\n\n\n# BFS\ndef orangesRotting(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    fresh = 0\n    q = deque()\n    dirs = [[1, 0], [0, 1], [0, -1], [-1, 0]]\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 2:\n                q.append([i, j])\n            elif grid[i][j] == 1:\n                fresh += 1\n    res = 0\n\n    while q and fresh &gt; 0:\n        size = len(q)\n        for _ in range(size):\n            r, c = q.popleft()\n            for dr, dc in dirs:\n                nr, nc = dr + r, dc + c\n                if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and grid[nr][nc] == 1:\n                    q.append([nr, nc])\n                    grid[nr][nc] = 2\n                    fresh -= 1\n        res += 1\n\n    return res if fresh == 0 else -1\n\n\ngrid = [[2, 1, 1], [1, 1, 0], [0, 1, 1]]\nassert orangesRotting(grid) == 4\n</code></pre>"},{"location":"LeetPattern/graph_bfs/#127-word-ladder","title":"127. Word Ladder","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Breadth First Search</p> </li> </ul> Python <pre><code>\"\"\"\n-   The most classic BFS problem.\n-   Return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\n-   Approach: BFS\n-   Time Complexity: O(n * m^2)\n-   Space Complexity: O(n * m)\n\"\"\"\n\nfrom collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef ladderLength(beginWord: str, endWord: str, wordList: List[str]) -&gt; int:\n    if endWord not in wordList:\n        return 0\n\n    n = len(beginWord)\n    graph = defaultdict(list)  # pattern: words\n    wordList.append(beginWord)\n\n    for word in wordList:\n        for i in range(n):\n            pattern = word[:i] + \"*\" + word[i + 1 :]\n            graph[pattern].append(word)\n\n    visited = set([beginWord])\n    q = deque([beginWord])\n    res = 1\n\n    while q:\n        size = len(q)\n        for _ in range(size):\n            word = q.popleft()\n            if word == endWord:\n                return res\n\n            for i in range(n):\n                pattern = word[:i] + \"*\" + word[i + 1 :]\n                for neighbor in graph[pattern]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        q.append(neighbor)\n        res += 1\n\n    return 0\n\n\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]\nprint(ladderLength(beginWord, endWord, wordList))  # 5\n</code></pre>"},{"location":"LeetPattern/graph_bfs/#1466-reorder-routes-to-make-all-paths-lead-to-the-city-zero","title":"1466. Reorder Routes to Make All Paths Lead to the City Zero","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Graph</p> </li> </ul> Python <pre><code>\"\"\"\n-   ![1466](https://assets.leetcode.com/uploads/2020/05/13/sample_1_1819.png)\n\"\"\"\n\nfrom collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef minReorderBFS(n: int, connections: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append((v, 1))  # go\n        graph[v].append((u, 0))  # come\n\n    changes = 0\n    q = deque([(0, -1)])\n\n    while q:\n        n1, d1 = q.popleft()\n\n        for n2, d2 in graph[n1]:\n            if n2 != d1:\n                changes += d2\n                q.append((n2, n1))\n\n    return changes\n\n\n# DFS\ndef minReorderDFS(n: int, connections: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append((v, 1))  # go\n        graph[v].append((u, 0))  # come\n\n    def dfs(n1, d1):\n        changes = 0\n        for n2, d2 in graph[n1]:\n            if n2 != d1:\n                changes += d2 + dfs(n2, n1)\n        return changes\n\n    return dfs(0, -1)\n\n\nn = 5\nconnections = [[1, 0], [1, 2], [3, 2], [3, 4]]\nprint(minReorderBFS(n, connections))  # 2\nprint(minReorderDFS(n, connections))  # 2\n</code></pre>"},{"location":"LeetPattern/graph_bfs/#286-walls-and-gates","title":"286. Walls and Gates \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Breadth First Search, Matrix</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# Multi-Source BFS\ndef wallsAndGates(rooms: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify rooms in-place instead.\n    \"\"\"\n    m, n = len(rooms), len(rooms[0])\n    visited = set()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def addRoom(r, c):\n        if 0 &lt;= r &lt; m and 0 &lt;= c &lt; n and (r, c) not in visited and rooms[r][c] != -1:\n            q.append((r, c))\n            visited.add((r, c))\n\n    q = deque()\n    for r in range(m):\n        for c in range(n):\n            if rooms[r][c] == 0:\n                q.append((r, c))\n                visited.add((r, c))\n\n    dist = 0\n\n    while q:\n        for _ in range(len(q)):\n            r, c = q.popleft()\n            rooms[r][c] = dist\n\n            for dr, dc in directions:\n                addRoom(r + dr, c + dc)\n        dist += 1\n\n\nif __name__ == \"__main__\":\n    rooms = [\n        [2147483647, -1, 0, 2147483647],\n        [2147483647, 2147483647, 2147483647, -1],\n        [2147483647, -1, 2147483647, -1],\n        [0, -1, 2147483647, 2147483647],\n    ]\n    wallsAndGates(rooms)\n    assert rooms == [\n        [3, -1, 0, 1],\n        [2, 2, 1, -1],\n        [1, -1, 2, -1],\n        [0, -1, 3, 4],\n    ]\n</code></pre>"},{"location":"LeetPattern/graph_bfs/#815-bus-routes","title":"815. Bus Routes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Breadth First Search</p> </li> </ul> Python <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef numBusesToDestination(routes: List[List[int]], source: int, target: int) -&gt; int:\n    if source == target:\n        return 0\n\n    graph = defaultdict(set)  # {stop: buses}\n    for buses, route in enumerate(routes):\n        for stop in route:\n            graph[stop].add(buses)\n\n    q = deque([(source, 0)])  # (stop, bus)\n    visited_stops = set([source])\n    visited_buses = set()\n\n    while q:\n        stop, bus = q.popleft()\n\n        if stop == target:\n            return bus\n\n        for buses in graph[stop]:\n            if buses not in visited_buses:\n                visited_buses.add(buses)\n                for next_stop in routes[buses]:\n                    if next_stop not in visited_stops:\n                        visited_stops.add(next_stop)\n                        q.append((next_stop, bus + 1))\n\n    return -1\n\n\nroutes = [[1, 2, 7], [3, 6, 7]]\nsource = 1\ntarget = 6\nprint(numBusesToDestination(routes, source, target))  # 2\n</code></pre>"},{"location":"LeetPattern/graph_coloring/","title":"Graph Coloring","text":""},{"location":"LeetPattern/graph_coloring/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 785. Is Graph Bipartite? (Medium)</li> <li> 886. Possible Bipartition (Medium)</li> <li> 924. Minimize Malware Spread (Hard)</li> </ul>"},{"location":"LeetPattern/graph_coloring/#785-is-graph-bipartite","title":"785. Is Graph Bipartite?","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Union Find, Graph</p> </li> </ul> Python <pre><code>\"\"\"\n-   Determine if a graph is bipartite.\n\nHow to group\n\n|          | Uncolored | Color 1 | Color 2 | Operation   |\n| -------- | --------- | ------- | ------- | ----------- |\n| Method 1 | -1        | 0       | 1       | `1 - color` |\n| Method 2 | 0         | 1       | -1      | `-color`    |\n\"\"\"\n\nfrom collections import deque\nfrom typing import List\n\n\n# BFS\ndef isBipartiteBFS(graph: List[List[int]]) -&gt; bool:\n    n = len(graph)\n    # -1: not colored; 0: blue; 1: red\n    color = [-1 for _ in range(n)]\n\n    def bfs(node):\n        q = deque([node])\n        color[node] = 0\n\n        while q:\n            cur = q.popleft()\n\n            for neighbor in graph[cur]:\n                if color[neighbor] == -1:\n                    color[neighbor] = 1 - color[cur]\n                    q.append(neighbor)\n                elif color[neighbor] == color[cur]:\n                    return False\n        return True\n\n    for i in range(n):\n        if color[i] == -1:\n            if not bfs(i):\n                return False\n\n    return True\n\n\n# DFS\ndef isBipartiteDFS(graph: List[List[int]]) -&gt; bool:\n    n = len(graph)\n    # -1: not colored; 0: blue; 1: red\n    color = [-1] * n\n\n    def dfs(node, c):\n        color[node] = c\n        for neighbor in graph[node]:\n            if color[neighbor] == -1:\n                if not dfs(neighbor, 1 - c):\n                    return False\n            elif color[neighbor] == c:\n                return False\n        return True\n\n    for i in range(n):\n        if color[i] == -1:\n            if not dfs(i, 0):\n                return False\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |    BFS     | O(V+E) |  O(V)   |\n# |    DFS     | O(V+E) |  O(V)   |\n# |------------|--------|---------|\n\n\ngraph = [[1, 2, 3], [0, 2], [0, 1, 3], [0, 2]]\nprint(isBipartiteBFS(graph))  # False\nprint(isBipartiteDFS(graph))  # False\n</code></pre>"},{"location":"LeetPattern/graph_coloring/#886-possible-bipartition","title":"886. Possible Bipartition","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Union Find, Graph</p> </li> </ul> Python <pre><code>\"\"\"\n-   Determine if a graph can be divided into two groups such that no two nodes of the same group are connected.\n\"\"\"\n\nfrom collections import deque\nfrom typing import List\n\n\n# BFS\ndef possibleBipartitionBFS(n: int, dislikes: List[List[int]]) -&gt; bool:\n    group = {i: -1 for i in range(1, n + 1)}\n\n    # Undirected graph\n    graph = {i: [] for i in range(1, n + 1)}\n    for i, j in dislikes:\n        graph[i].append(j)\n        graph[j].append(i)\n\n    def bfs(person):\n        q = deque([person])\n        group[person] = 0\n\n        while q:\n            cur = q.popleft()\n\n            for neighbor in graph[cur]:\n                if group[neighbor] == -1:\n                    group[neighbor] = 1 - group[cur]\n                    q.append(neighbor)\n                elif group[neighbor] == group[cur]:\n                    return False\n        return True\n\n    for i in range(1, n + 1):\n        if group[i] == -1:\n            if not bfs(i):\n                return False\n    return True\n\n\n# DFS\ndef possibleBipartitionDFS(n: int, dislikes: List[List[int]]) -&gt; bool:\n    group = {i: -1 for i in range(1, n + 1)}\n    graph = {i: [] for i in range(1, n + 1)}\n    for i, j in dislikes:\n        graph[i].append(j)\n        graph[j].append(i)\n\n    def dfs(person, g):\n        group[person] = g\n\n        for neighbor in graph[person]:\n            if group[neighbor] == -1:\n                if not dfs(neighbor, 1 - g):\n                    return False\n            elif group[neighbor] == g:\n                return False\n\n        return True\n\n    for i in range(1, n + 1):\n        if group[i] == -1:\n            if not dfs(i, 0):\n                return False\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |    BFS     | O(V+E) |  O(V+E) |\n# |    DFS     | O(V+E) |  O(V+E) |\n# |------------|--------|---------|\n\n\nn = 4\ndislikes = [[1, 2], [1, 3], [2, 4]]\nprint(possibleBipartitionBFS(n, dislikes))  # True\nprint(possibleBipartitionDFS(n, dislikes))  # True\n</code></pre>"},{"location":"LeetPattern/graph_coloring/#924-minimize-malware-spread","title":"924. Minimize Malware Spread","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Depth First Search, Breadth First Search, Union Find, Graph</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Coloring\ndef minMalwareSpread(graph: List[List[int]], initial: List[int]) -&gt; int:\n    n = len(graph)\n    initial = set(initial)\n\n    def dfs(x):\n        visited.add(x)\n        mark[x] = 1\n        if x in initial:\n            v.append(x)\n        for nxt in range(n):\n            if graph[x][nxt] and nxt != x and not mark[nxt]:\n                dfs(nxt)\n\n    ans = min(initial)\n    mx = 0\n    mark = [0] * n\n    for i in range(n):\n        if not mark[i]:\n            visited = set()\n            v = []\n            dfs(i)\n            if len(v) == 1 and (len(visited) &gt; mx or len(visited) == mx and v[0] &lt; ans):\n                ans, mx = v[0], len(visited)\n    return ans\n\n\ngraph = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]\ninitial = [0, 1]\nprint(minMalwareSpread(graph, initial))  # 0\n</code></pre>"},{"location":"LeetPattern/graph_flood_fill/","title":"Graph Flood Fill","text":""},{"location":"LeetPattern/graph_flood_fill/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 733. Flood Fill (Easy)</li> <li> 200. Number of Islands (Medium)</li> <li> 695. Max Area of Island (Medium)</li> <li> 463. Island Perimeter (Easy)</li> <li> 130. Surrounded Regions (Medium)</li> <li> 417. Pacific Atlantic Water Flow (Medium)</li> <li> 827. Making A Large Island (Hard)</li> </ul>"},{"location":"LeetPattern/graph_flood_fill/#733-flood-fill","title":"733. Flood Fill","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Matrix</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Replace all the pixels of the same color starting from the given pixel.\n- In other words, find the connected component of the starting pixel and change the color of all the pixels in that component.\n- Edge cases: If the starting pixel is already the target color, return the image as it is.\n- **Flood Fill** is essentially a graph traversal algorithm (like BFS or DFS) applied to matrices (2D grids).\n  It checks adjacent cells (up, down, left, right) of a starting point to determine whether they belong to the same region.\n  Typically, it involves modifying or marking the cells that belong to the same connected component.\n\n![flood_fill](../../assets/flood_fill_example.png)\n\n![733](../../assets/0733.jpg)\n\n|  1  |   1   |  1  |\n| :-: | :---: | :-: |\n|  1  | ==1== |  0  |\n|  1  |   0   |  1  |\n\n|  1  |   1   |  1  |\n| :-: | :---: | :-: |\n|  1  | ==2== |  0  |\n|  1  |   0   |  1  |\n\n|   1   | ==2== |  1  |\n| :---: | :---: | :-: |\n| ==2== | ==2== |  0  |\n|   1   |   0   |  1  |\n\n| ==2== | ==2== | ==2== |\n| :---: | :---: | :---: |\n| ==2== | ==2== |   0   |\n| ==2== |   0   |   1   |\n\"\"\"\n\nfrom collections import deque\nfrom typing import List\n\n\n# DFS\ndef floodFillDFS(image: List[List[int]], sr: int, sc: int, color: int) -&gt; List[List[int]]:\n\n    org = image[sr][sc]\n    m, n = len(image), len(image[0])\n\n    if org == color:\n        return image\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or image[r][c] != org:\n            return None\n\n        image[r][c] = color\n\n        dfs(r - 1, c)\n        dfs(r + 1, c)\n        dfs(r, c - 1)\n        dfs(r, c + 1)\n\n    dfs(sr, sc)\n\n    return image\n\n\n# BFS\ndef floodFillBFS(image: List[List[int]], sr: int, sc: int, color: int) -&gt; List[List[int]]:\n\n    org = image[sr][sc]\n    m, n = len(image), len(image[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    if org == color:\n        return image\n\n    q = deque([(sr, sc)])\n\n    while q:\n        r, c = q.popleft()\n        image[r][c] = color\n\n        for dr, dc in dirs:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and image[nr][nc] == org:\n                q.append((nr, nc))\n\n    return image\n\n\nimage = [[1, 1, 1], [1, 1, 0], [1, 0, 1]]\nsr = 1\nsc = 1\n\nprint(floodFillDFS(image, sr, sc, 2))\n# [[2, 2, 2], [2, 2, 0], [2, 0, 1]]\nprint(floodFillBFS(image, sr, sc, 2))\n# [[2, 2, 2], [2, 2, 0], [2, 0, 1]]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;functional&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   private:\n    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; image, int org, int color, int r, int c) {\n        int m = image.size(), n = image[0].size();\n        if (r &lt; 0 || r &gt;= m || c &lt; 0 || c &gt;= n || image[r][c] != org) {\n            return;\n        }\n        image[r][c] = color;\n        dfs(image, org, color, r - 1, c);\n        dfs(image, org, color, r + 1, c);\n        dfs(image, org, color, r, c - 1);\n        dfs(image, org, color, r, c + 1);\n    }\n\n   public:\n    // DFS\n    vector&lt;vector&lt;int&gt;&gt; flood_fill_dfs(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr,\n                                       int sc, int color) {\n        int org = image[sr][sc];\n        if (org == color) return image;\n\n        dfs(image, org, color, sr, sc);\n        return image;\n    }\n\n    // DFS with lambda\n    vector&lt;vector&lt;int&gt;&gt; flood_fill_dfs_lambda(vector&lt;vector&lt;int&gt;&gt;&amp; image,\n                                              int sr, int sc, int color) {\n        int org = image[sr][sc];\n        if (org == color) return image;\n\n        int m = image.size(), n = image[0].size();\n\n        function&lt;void(int, int)&gt; dfs = [&amp;](int r, int c) -&gt; void {\n            if (r &lt; 0 || r &gt;= m || c &lt; 0 || c &gt;= n || image[r][c] != org) {\n                return;\n            }\n            image[r][c] = color;\n            dfs(r - 1, c);\n            dfs(r + 1, c);\n            dfs(r, c - 1);\n            dfs(r, c + 1);\n        };\n\n        dfs(sr, sc);\n\n        return image;\n    }\n\n    // BFS\n    vector&lt;vector&lt;int&gt;&gt; flood_fill_bfs(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr,\n                                       int sc, int color) {\n        int org = image[sr][sc];\n        if (org == color) return image;\n\n        int m = image.size(), n = image[0].size();\n        vector&lt;pair&lt;int, int&gt;&gt; dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        queue&lt;pair&lt;int, int&gt;&gt; q;\n        q.push({sr, sc});\n\n        while (!q.empty()) {\n            auto [r, c] = q.front();\n            q.pop();\n            image[r][c] = color;\n            for (auto&amp; dir : dirs) {\n                int nr = r + dir.first;\n                int nc = c + dir.second;\n                if (nr &gt;= 0 &amp;&amp; nr &lt; m &amp;&amp; nc &gt;= 0 &amp;&amp; nc &lt; n &amp;&amp;\n                    image[nr][nc] == org) {\n                    q.push({nr, nc});\n                }\n            }\n        }\n\n        return image;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;vector&lt;int&gt;&gt; image = {{1, 1, 1}, {1, 1, 0}, {1, 0, 1}};\n    solution.flood_fill_dfs(image, 1, 1, 2);\n    vector&lt;vector&lt;int&gt;&gt; expected = {{2, 2, 2}, {2, 2, 0}, {2, 0, 1}};\n    assert((image == expected));\n\n    image = {{1, 1, 1}, {1, 1, 0}, {1, 0, 1}};\n    solution.flood_fill_dfs_lambda(image, 1, 1, 2);\n    assert((image == expected));\n\n    image = {{1, 1, 1}, {1, 1, 0}, {1, 0, 1}};\n    solution.flood_fill_bfs(image, 1, 1, 2);\n    assert((image == expected));\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/graph_flood_fill/#200-number-of-islands","title":"200. Number of Islands","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Union Find, Matrix</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Count the number of islands in a 2D grid.\n-   Method 1: DFS\n-   Method 2: BFS (use a queue to traverse the grid)\n\n-   How to keep track of visited cells?\n\n    1. Mark the visited cell as `0` (or any other value) to avoid revisiting it.\n    2. Use a set to store the visited cells.\n\n-   Steps:\n    1. Init: variables\n    2. DFS/BFS: starting from the cell with `1`, turn all the connected `1`s to `0`.\n    3. Traverse the grid, and if the cell is `1`, increment the count and call DFS/BFS.\n\n![0200](../../assets/0200.jpg)\n\"\"\"\n\nfrom collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef numIslandsDFS(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    res = 0\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] != \"1\":\n            return\n\n        grid[r][c] = \"2\"\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                dfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Set\ndef numIslandsBFS1(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == \"0\"\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\" and (r, c) not in visited:\n                visited.add((r, c))\n                bfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = dr + row, dc + col\n                if nr &lt; 0 or nr &gt;= m or nc &lt; 0 or nc &gt;= n or grid[nr][nc] != \"1\":\n                    continue\n                grid[nr][nc] = \"2\"\n                q.append((nr, nc))\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == \"1\":\n                grid[i][j] = \"2\"\n                bfs(i, j)\n                res += 1\n\n    return res\n\n\ngrid = [\n    [\"1\", \"1\", \"1\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"0\", \"0\", \"0\", \"0\", \"0\"],\n]\n\nprint(numIslandsDFS(deepcopy(grid)))  # 1\nprint(numIslandsBFS1(deepcopy(grid)))  # 1\nprint(numIslandsBFS2(deepcopy(grid)))  # 1\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    // dfs\n    int num_islands_dfs(vector&lt;vector&lt;char&gt;&gt; &amp;grid) {\n        int m = grid.size(), n = grid[0].size();\n        int res = 0;\n\n        // c++23 lambda recursion\n        auto dfs = [&amp;](this auto &amp;&amp;dfs, int r, int c) -&gt; void {\n            if (r &lt; 0 || r &gt;= m || c &lt; 0 || c &gt;= n || grid[r][c] != '1') {\n                return;\n            }\n            grid[r][c] = '0';\n            dfs(r + 1, c);\n            dfs(r - 1, c);\n            dfs(r, c + 1);\n            dfs(r, c - 1);\n        };\n\n        for (int i = 0; i &lt; m; i++) {\n            for (int j = 0; j &lt; n; j++) {\n                if (grid[i][j] == '1') {\n                    res++;\n                    dfs(i, j);\n                }\n            }\n        }\n        return res;\n    }\n\n    // bfs\n    int num_islands_bfs(vector&lt;vector&lt;char&gt;&gt; &amp;grid) {\n        int m = grid.size(), n = grid[0].size();\n        int res = 0;\n        vector&lt;pair&lt;int, int&gt;&gt; dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\n        auto bfs = [&amp;](int r, int c) {\n            queue&lt;pair&lt;int, int&gt;&gt; q;\n            q.push({r, c});\n            grid[r][c] = '0';\n            while (!q.empty()) {\n                auto [cr, cc] = q.front();\n                q.pop();\n                for (auto &amp;[dr, dc] : dirs) {\n                    int nr = cr + dr, nc = cc + dc;\n                    if (nr &gt;= 0 &amp;&amp; nr &lt; m &amp;&amp; nc &gt;= 0 &amp;&amp; nc &lt; n &amp;&amp;\n                        grid[nr][nc] == '1') {\n                        grid[nr][nc] = '0';\n                        q.push({nr, nc});\n                    }\n                }\n            }\n        };\n\n        for (int i = 0; i &lt; m; i++) {\n            for (int j = 0; j &lt; n; j++) {\n                if (grid[i][j] == '1') {\n                    res++;\n                    bfs(i, j);\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;vector&lt;char&gt;&gt; grid = {{'1', '1', '0', '0', '0'},\n                                 {'1', '1', '0', '0', '0'},\n                                 {'0', '0', '1', '0', '0'},\n                                 {'0', '0', '0', '1', '1'}};\n    assert(solution.num_islands_dfs(grid) == 3);\n    grid = {{'1', '1', '0', '0', '0'},\n            {'1', '1', '0', '0', '0'},\n            {'0', '0', '1', '0', '0'},\n            {'0', '0', '0', '1', '1'}};\n    assert(solution.num_islands_bfs(grid) == 3);\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/graph_flood_fill/#695-max-area-of-island","title":"695. Max Area of Island","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Union Find, Matrix</p> </li> </ul> PythonCPP <pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef maxAreaOfIslandDFS(grid: List[List[int]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] == 0:\n            return 0\n\n        grid[r][c] = 0\n\n        return 1 + dfs(r + 1, c) + dfs(r - 1, c) + dfs(r, c + 1) + dfs(r, c - 1)\n\n    res = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                res = max(res, dfs(i, j))\n    return res\n\n\n# BFS\ndef maxAreaOfIslandBFS1(grid: List[List[int]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        area = 0\n\n        while q:\n            row, col = q.popleft()\n            area += 1\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == 0\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n        return area\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1 and (r, c) not in visited:\n                visited.add((r, c))\n                res = max(res, bfs(r, c))\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        area = 0\n\n        while q:\n            row, col = q.popleft()\n            area += 1\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n\n                if nr &lt; 0 or nr &gt;= m or nc &lt; 0 or nc &gt;= n or grid[nr][nc] == 0:\n                    continue\n\n                q.append((nr, nc))\n                grid[nr][nc] = 0\n\n        return area\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                grid[r][c] = 0\n                res = max(res, bfs(r, c))\n\n    return res\n\n\ngrid = [\n    [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0],\n    [0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],\n]\nprint(maxAreaOfIslandDFS(grid))  # 6\nprint(maxAreaOfIslandBFS1(grid))  # 6\nprint(numIslandsBFS2(grid))  # 6\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int max_area_of_island(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {\n        int m = grid.size(), n = grid[0].size();\n        int res = 0;\n\n        auto dfs = [&amp;](this auto&amp;&amp; dfs, int r, int c) -&gt; int {\n            if (r &lt; 0 || r &gt;= m || c &lt; 0 || c &gt;= n || grid[r][c] != 1) {\n                return 0;\n            }\n            grid[r][c] = 0;\n\n            return 1 + dfs(r + 1, c) + dfs(r - 1, c) + dfs(r, c + 1) +\n                   dfs(r, c - 1);\n        };\n\n        for (int i = 0; i &lt; m; i++) {\n            for (int j = 0; j &lt; n; j++) {\n                if (grid[i][j] == 1) {\n                    int area = dfs(i, j);\n                    res = max(res, area);\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;vector&lt;int&gt;&gt; grid = {{0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},\n                                {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},\n                                {0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},\n                                {0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0},\n                                {0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0},\n                                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0},\n                                {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},\n                                {0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0}};\n    assert(solution.max_area_of_island(grid) == 6);\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/graph_flood_fill/#463-island-perimeter","title":"463. Island Perimeter","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Matrix</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DFS\ndef islandPerimeterDFS(grid: List[List[int]]) -&gt; int:\n    # TC: O(m * n)\n    # SC: O(m * n)\n\n    visited = set()\n    m, n = len(grid), len(grid[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def dfs(r, c):\n        if (r, c) in visited or grid[r][c] == 0:\n            return 0\n        visited.add((r, c))\n        perimeter = 0\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if nr not in range(m) or nc not in range(n) or grid[nr][nc] == 0:\n                perimeter += 1\n            else:\n                perimeter += dfs(nr, nc)\n\n        return perimeter\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                return dfs(r, c)\n    return 0\n\n\ndef islandPerimeter(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    perimeter = 0\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                perimeter += 4\n\n                if r &gt; 0 and grid[r - 1][c] == 1:\n                    perimeter -= 2\n\n                if c &gt; 0 and grid[r][c - 1] == 1:\n                    perimeter -= 2\n\n    return perimeter\n\n\ngrid = [[0, 1, 0, 0], [1, 1, 1, 0], [0, 1, 0, 0], [1, 1, 0, 0]]\nprint(islandPerimeterDFS(grid))  # 16\nprint(islandPerimeter(grid))  # 16\n</code></pre>"},{"location":"LeetPattern/graph_flood_fill/#130-surrounded-regions","title":"130. Surrounded Regions","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Union Find, Matrix</p> </li> </ul> Python <pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef solveDFS(board: List[List[str]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n    if not board and not board[0]:\n        return None\n\n    m, n = len(board), len(board[0])\n\n    def capture(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or board[r][c] != \"O\":\n            return None\n\n        board[r][c] = \"T\"\n        capture(r + 1, c)\n        capture(r - 1, c)\n        capture(r, c + 1)\n        capture(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\" and (r in [0, m - 1] or c in [0, n - 1]):\n                capture(r, c)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\":\n                board[r][c] = \"X\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"T\":\n                board[r][c] = \"O\"\n\n\n# BFS\ndef solveBFS(board: List[List[str]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n    if not board and not board[0]:\n        return None\n\n    m, n = len(board), len(board[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def capture(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr = row + dr\n                nc = col + dc\n                if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and board[nr][nc] == \"O\":\n                    board[nr][nc] = \"T\"\n                    q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\" and (r in [0, m - 1] or c in [0, n - 1]):\n                board[r][c] = \"T\"\n                capture(r, c)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\":\n                board[r][c] = \"X\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"T\":\n                board[r][c] = \"O\"\n\n\nif __name__ == \"__main__\":\n    board = [\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"O\", \"O\", \"X\"],\n        [\"X\", \"X\", \"O\", \"X\"],\n        [\"X\", \"O\", \"X\", \"X\"],\n    ]\n\n    b = deepcopy(board)\n    solveDFS(b)\n    assert b == [\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"O\", \"X\", \"X\"],\n    ]\n\n    b = deepcopy(board)\n    solveBFS(b)\n    assert b == [\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"O\", \"X\", \"X\"],\n    ]\n</code></pre>"},{"location":"LeetPattern/graph_flood_fill/#417-pacific-atlantic-water-flow","title":"417. Pacific Atlantic Water Flow","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Matrix</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef pacificAtlanticDFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(r, c, visited, prev_height):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or heights[r][c] &lt; prev_height\n            or (r, c) in visited\n        ):\n            return None\n\n        visited.add((r, c))\n        height = heights[r][c]\n        for dr, dc in directions:\n            dfs(dr + r, dc + c, visited, height)\n\n    for c in range(n):\n        dfs(0, c, pac, heights[0][c])\n        dfs(m - 1, c, atl, heights[m - 1][c])\n\n    for r in range(m):\n        dfs(r, 0, pac, heights[r][0])\n        dfs(r, n - 1, atl, heights[r][n - 1])\n\n    return list(pac &amp; atl)\n\n\n# BFS\ndef pacificAtlanticBFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def bfs(r, c, visited):\n        q = deque([(r, c)])\n        visited.add((r, c))\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr in range(m)\n                    and nc in range(n)\n                    and heights[row][col] &lt;= heights[nr][nc]\n                    and (nr, nc) not in visited\n                ):\n                    q.append((nr, nc))\n                    visited.add((nr, nc))\n\n    for c in range(n):\n        bfs(0, c, pac)  # top\n        bfs(m - 1, c, atl)  # bottom\n\n    for r in range(m):\n        bfs(r, 0, pac)  # left\n        bfs(r, n - 1, atl)  # right\n\n    return list(pac &amp; atl)\n\n\nheights = [\n    [1, 2, 2, 3, 5],\n    [3, 2, 3, 4, 4],\n    [2, 4, 5, 3, 1],\n    [6, 7, 1, 4, 5],\n    [5, 1, 1, 2, 4],\n]\nprint(pacificAtlanticDFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\nprint(pacificAtlanticBFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\n</code></pre>"},{"location":"LeetPattern/graph_flood_fill/#827-making-a-large-island","title":"827. Making A Large Island","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Union Find, Matrix</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Flood Fill\ndef largestIsland(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    areas = defaultdict(int)  # {index: area}\n    index = 2\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(r, c, index):\n        area = 1\n        grid[r][c] = index\n        for dr, dc in dirs:\n            nr, nc = r + dr, c + dc\n            if 0 &lt;= nr &lt; n and 0 &lt;= nc &lt; n and grid[nr][nc] == 1:\n                area += dfs(nr, nc, index)\n        return area\n\n    for r in range(n):\n        for c in range(n):\n            if grid[r][c] == 1:\n                areas[index] = dfs(r, c, index)\n                index += 1\n\n    if not areas:\n        return 1\n\n    res = max(areas.values())\n\n    for r in range(n):\n        for c in range(n):\n            if grid[r][c] == 0:\n                connected = set()\n                area = 1\n                for dr, dc in dirs:\n                    nr, nc = r + dr, c + dc\n                    if 0 &lt;= nr &lt; n and 0 &lt;= nc &lt; n and grid[nr][nc] &gt; 1:\n                        connected.add(grid[nr][nc])\n\n                for island in connected:\n                    area += areas[island]\n                res = max(res, area)\n\n    return res\n\n\ngrid = [[1, 0], [0, 1]]\nprint(largestIsland(grid))  # 3\n</code></pre>"},{"location":"LeetPattern/graph_minimum_spanning_tree/","title":"Graph Minimum Spanning Tree","text":""},{"location":"LeetPattern/graph_minimum_spanning_tree/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1584. Min Cost to Connect All Points (Medium)</li> <li> 1135. Connecting Cities With Minimum Cost (Medium) \ud83d\udc51</li> <li> 1168. Optimize Water Distribution in a Village (Hard) \ud83d\udc51</li> <li> 1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree (Hard)</li> <li> 1631. Path With Minimum Effort (Medium)</li> <li> 1579. Remove Max Number of Edges to Keep Graph Fully Traversable (Hard)</li> </ul>"},{"location":"LeetPattern/graph_minimum_spanning_tree/#1584-min-cost-to-connect-all-points","title":"1584. Min Cost to Connect All Points","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Union Find, Graph, Minimum Spanning Tree</p> </li> </ul> Python <pre><code>\"\"\"\n- Tree: a connected acyclic graph\n- Spanning Tree: a subgraph that is a tree and connects all the vertices together\n- Minimum Spanning Tree (MST): a spanning tree with the minimum possible sum of edge weights\n- Prim's Algorithm\n  - Data Structure: Heap\n  - Time Complexity: O(E * logV)\n  - Space Complexity: O(V + E)\n- Kruskal's Algorithm\n  - Union Find\n  - Time Complexity: O(E * logV)\n  - Space Complexity: O(V + E)\n\"\"\"\n\nimport heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minCostConnectPointsPrim(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    graph = defaultdict(list)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            dist = abs(x1 - x2) + abs(y1 - y2)\n            graph[i].append((dist, j))\n            graph[j].append((dist, i))\n\n    cost = 0\n    heap = [(0, 0)]  # (cost, node)\n    visited = set()\n\n    while heap:\n        d1, n1 = heapq.heappop(heap)\n        if n1 in visited:\n            continue\n        visited.add(n1)\n        cost += d1\n\n        for d2, n2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (d2, n2))\n\n    return cost\n\n\n# Kruskal\ndef minCostConnectPointsKruskal(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    par = {i: i for i in range(n)}\n    rank = {i: 0 for i in range(n)}\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 == p2:\n            return False\n\n        if rank[p1] &gt; rank[p2]:\n            par[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n        else:\n            par[p2] = p1\n            rank[p1] += 1\n\n        return True\n\n    heap = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            dist = abs(x1 - x2) + abs(y1 - y2)\n            heapq.heappush(heap, (dist, i, j))\n\n    cost = 0\n    while heap:\n        d, n1, n2 = heapq.heappop(heap)\n        if union(n1, n2):\n            cost += d\n\n    return cost\n\n\nif __name__ == \"__main__\":\n    points = [[0, 0], [2, 2], [3, 10], [5, 2], [7, 0]]\n    print(minCostConnectPointsPrim(points))  # 20\n    print(minCostConnectPointsKruskal(points))  # 20\n</code></pre>"},{"location":"LeetPattern/graph_minimum_spanning_tree/#1135-connecting-cities-with-minimum-cost","title":"1135. Connecting Cities With Minimum Cost \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Union Find, Graph, Heap Priority Queue, Minimum Spanning Tree</p> </li> </ul> Python <pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minimumCost(n: int, connections: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, c in connections:\n        graph[u].append((c, v))\n        graph[v].append((c, u))\n\n    cost = 0\n    heap = [(0, 1)]  # (cost, node)\n    visited = set()\n\n    while heap:\n        c1, n1 = heapq.heappop(heap)\n\n        if n1 in visited:\n            continue\n\n        visited.add(n1)\n\n        cost += c1\n\n        for c2, n2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (c2, n2))\n\n    return cost if len(visited) == n else -1\n\n\nn = 3\nconnections = [[1, 2, 5], [1, 3, 6], [2, 3, 1]]\nprint(minimumCost(n, connections))  # 6\n</code></pre>"},{"location":"LeetPattern/graph_minimum_spanning_tree/#1168-optimize-water-distribution-in-a-village","title":"1168. Optimize Water Distribution in a Village \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Union Find, Graph, Heap Priority Queue, Minimum Spanning Tree</p> </li> </ul> Python <pre><code>\"\"\"\n- ![1168_0](../../assets/1168_0.png)\n\n- ![1168_1](../../assets/1168_1.png)\n\"\"\"\n\nimport heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minCostToSupplyWater1(n: int, wells: List[int], pipes: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n\n    for h1, h2, cost in pipes:\n        graph[h1].append((h2, cost))\n        graph[h2].append((h1, cost))\n\n    # Add the cost of the wells to the graph (house 0)\n    for i in range(n):\n        graph[0].append((i + 1, wells[i]))\n        graph[i + 1].append((0, wells[i]))\n\n    visited = set([0])\n    heap = [(cost, dest) for dest, cost in graph[0]]\n    heapq.heapify(heap)\n\n    cost = 0\n\n    while heap:\n        c1, n1 = heapq.heappop(heap)\n        if n1 in visited:\n            continue\n        visited.add(n1)\n        cost += c1\n\n        for n2, c2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (c2, n2))\n\n    return cost\n\n\n# Kruskal\ndef minCostToSupplyWater2(n: int, wells: List[int], pipes: List[List[int]]) -&gt; int:\n    par = list(range(n + 1))\n    rank = [0] * (n + 1)\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            if rank[p1] &lt; rank[p2]:\n                par[p1] = p2\n            elif rank[p1] &gt; rank[p2]:\n                par[p2] = p1\n            else:\n                par[p1] = p2\n                rank[p2] += 1\n            return True\n        return False\n\n    graph = [(c, 0, i + 1) for i, c in enumerate(wells)]\n    for h1, h2, c in pipes:\n        graph.append((c, h1, h2))\n\n    graph.sort()\n\n    cost = 0\n\n    for c, h1, h2 in graph:\n        if union(h1, h2):\n            cost += c\n\n    return cost\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |    Prim    | O((V + E) log V) | O(V + E)|\n# |  Kruskal   |     O(E log E)   | O(V + E)|\n# |------------|------------------|---------|\n\n\nn = 3\nwells = [1, 2, 2]\npipes = [[1, 2, 1], [2, 3, 1]]\nprint(minCostToSupplyWater1(n, wells, pipes))  # 3\nprint(minCostToSupplyWater2(n, wells, pipes))  # 3\n</code></pre>"},{"location":"LeetPattern/graph_minimum_spanning_tree/#1489-find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree","title":"1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Union Find, Graph, Sorting, Minimum Spanning Tree, Strongly Connected Component</p> </li> </ul> Python <pre><code>from typing import List\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [1 for _ in range(n)]\n        self.part = n\n\n    def find(self, n):\n        p = self.parent[n]\n        while p != self.parent[p]:\n            self.parent[p] = self.parent[self.parent[p]]\n            p = self.parent[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return False\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.parent[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.parent[p1] = p2\n        else:\n            self.parent[p2] = p1\n            self.rank[p1] += 1\n\n        self.part -= 1\n        return True\n\n\n# Kruskal\ndef findCriticalAndPseudoCriticalEdges(n: int, edges: List[List[int]]) -&gt; List[List[int]]:\n    m = len(edges)\n\n    # Add index to edges\n    lst = list(range(m))\n    lst.sort(key=lambda x: edges[x][2])\n\n    # Calculate minimum cost\n    min_cost = 0\n    uf = UnionFind(n)\n    for i in lst:\n        x, y, cost = edges[i]\n        if uf.union(x, y):\n            min_cost += cost\n\n    # Calculate key edges\n    key = set()\n    for i in lst:\n        cur_cost = 0\n        uf = UnionFind(n)\n        for j in lst:\n            if j != i:\n                x, y, cost = edges[j]\n                if uf.union(x, y):\n                    cur_cost += cost\n        if cur_cost &gt; min_cost or uf.part != 1:\n            key.add(i)\n\n    # Calculate fake edges\n    fake = set()\n    for i in lst:\n        if i not in key:\n            cur_cost = edges[i][2]\n            uf = UnionFind(n)\n            uf.union(edges[i][0], edges[i][1])\n            for j in lst:\n                x, y, cost = edges[j]\n                if uf.union(x, y):\n                    cur_cost += cost\n            if cur_cost == min_cost and uf.part == 1:\n                fake.add(i)\n\n    return [sorted(list(key)), sorted(list(fake))]\n\n\nn = 5\nedges = [\n    [0, 1, 1],\n    [1, 2, 1],\n    [2, 3, 2],\n    [0, 3, 2],\n    [0, 4, 3],\n    [3, 4, 3],\n    [1, 4, 6],\n]\nprint(findCriticalAndPseudoCriticalEdges(n, edges))\n</code></pre>"},{"location":"LeetPattern/graph_minimum_spanning_tree/#1631-path-with-minimum-effort","title":"1631. Path With Minimum Effort","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Depth First Search, Breadth First Search, Union Find, Heap Priority Queue, Matrix</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the minimum effort required to travel from the top-left to the bottom-right corner.\n\"\"\"\n\nimport heapq\nfrom typing import List\n\n\n# Prim\ndef minimumEffortPath(heights: List[List[int]]) -&gt; int:\n    m, n = len(heights), len(heights[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * n for _ in range(m)]\n    heap = [(0, 0, 0)]  # (effort, row, col)\n\n    while heap:\n        effort, r, c = heapq.heappop(heap)\n\n        if visited[r][c]:\n            continue\n\n        if r == m - 1 and c == n - 1:\n            return effort\n\n        visited[r][c] = True\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and not visited[nr][nc]:\n                updated = max(effort, abs(heights[r][c] - heights[nr][nc]))\n                heapq.heappush(heap, (updated, nr, nc))\n\n    return -1\n\n\nheights = [[1, 2, 2], [3, 8, 2], [5, 3, 5]]\nprint(minimumEffortPath(heights))  # 2\n</code></pre>"},{"location":"LeetPattern/graph_minimum_spanning_tree/#1579-remove-max-number-of-edges-to-keep-graph-fully-traversable","title":"1579. Remove Max Number of Edges to Keep Graph Fully Traversable","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Union Find, Graph</p> </li> </ul> Python <pre><code>\"\"\"\n- Return the maximum number of edges you can remove so that the graph remains fully traversable.\n\n![1579](../../assets/1579.png){width=200px}\n\"\"\"\n\nfrom typing import List\n\n\n# Kruskal\ndef maxNumEdgesToRemove(n: int, edges: List[List[int]]) -&gt; int:\n    alice, bob = UnionFind(n), UnionFind(n)\n    visited = 0\n\n    for t, u, v in edges:\n        if t == 3:\n            if alice.union(u, v) | bob.union(u, v):\n                visited += 1\n\n    for t, u, v in edges:\n        if t == 1:\n            if alice.union(u, v):\n                visited += 1\n        elif t == 2:\n            if bob.union(u, v):\n                visited += 1\n\n    if alice.components &gt; 1 or bob.components &gt; 1:\n        return -1\n\n    return len(edges) - visited\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = {i: i for i in range(1, n + 1)}\n        self.rank = {i: 0 for i in range(1, n + 1)}\n        self.components = n\n\n    def find(self, n):\n        p = self.parent[n]\n        while self.parent[p] != p:\n            self.parent[p] = self.parent[self.parent[p]]\n            p = self.parent[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return False\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.parent[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.parent[p1] = p2\n        else:\n            self.parent[p2] = p1\n            self.rank[p1] += 1\n\n        self.components -= 1\n\n        return True\n\n\nn = 4\nedges = [[3, 1, 2], [3, 2, 3], [1, 1, 3], [1, 2, 4], [1, 1, 2], [2, 3, 4]]\nprint(maxNumEdgesToRemove(n, edges))  # 2\n</code></pre>"},{"location":"LeetPattern/graph_shortest_path/","title":"Graph Shortest Path","text":""},{"location":"LeetPattern/graph_shortest_path/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 743. Network Delay Time (Medium)</li> <li> 778. Swim in Rising Water (Hard)</li> <li> 1631. Path With Minimum Effort (Medium)</li> <li> 787. Cheapest Flights Within K Stops (Medium)</li> <li> 1514. Path with Maximum Probability (Medium)</li> <li> 505. The Maze II (Medium) \ud83d\udc51</li> <li> 499. The Maze III (Hard) \ud83d\udc51</li> <li> 882. Reachable Nodes In Subdivided Graph (Hard)</li> <li> 1376. Time Needed to Inform All Employees (Medium)</li> <li> 1168. Optimize Water Distribution in a Village (Hard) \ud83d\udc51</li> <li> 1976. Number of Ways to Arrive at Destination (Medium)</li> </ul>"},{"location":"LeetPattern/graph_shortest_path/#743-network-delay-time","title":"743. Network Delay Time","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Graph, Heap Priority Queue, Shortest Path</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return the minimum time taken to reach all nodes in a network.\n-   Shortest Path Problem: Find the shortest path between two vertices in a graph.\n-   Dijkstra's Algorithm\n    -   Shortest path algorithm\n    -   Weighted graph (non-negative weights)\n    -   Data Structure: Heap; Hash Set\n    -   Time Complexity: O(E * logV)\n    -   Space Complexity: O(V)\n\"\"\"\n\nimport heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Dijkstra - Set\ndef networkDelayTime1(times: List[List[int]], n: int, k: int) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    heap = [(0, k)]\n    visit = set()\n    t = 0\n\n    while heap:\n        w1, n1 = heapq.heappop(heap)\n        if n1 in visit:\n            continue\n\n        visit.add(n1)\n        t = w1\n\n        for n2, w2 in graph[n1]:\n            heapq.heappush(heap, (w1 + w2, n2))\n\n    return t if len(visit) == n else -1\n\n\n# Dijkstra - Dict\ndef networkDelayTime2(times: List[List[int]], n: int, k: int) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    heap = [(0, k)]\n    dist = defaultdict(int)\n\n    while heap:\n        w1, n1 = heapq.heappop(heap)\n        if n1 in dist:\n            continue\n\n        dist[n1] = w1\n\n        for n2, w2 in graph[n1]:\n            heapq.heappush(heap, (w1 + w2, n2))\n\n    return max(dist.values()) if len(dist) == n else -1\n\n\n# Bellman-Ford\ndef networkDelayTimeBF(times: List[List[int]], n: int, k: int) -&gt; int:\n    delay = {i: float(\"inf\") for i in range(1, n + 1)}\n    delay[k] = 0\n\n    for _ in range(n - 1):\n        for u, v, t in times:\n            delay[v] = min(delay[v], delay[u] + t)\n\n    max_delay = max(delay.values())\n    return max_delay if max_delay &lt; float(\"inf\") else -1\n\n\n# |--------------|-----------|--------|\n# | Approach     | Time      | Space  |\n# |--------------|-----------|--------|\n# | Dijkstra     | O(E*logV) | O(V+E) |\n# | Bellman-Ford | O(E*V)    | O(V)   |\n# |--------------|-----------|--------|\n\nif __name__ == \"__main__\":\n    times = [[2, 1, 1], [2, 3, 1], [3, 4, 1]]\n    n = 4\n    k = 2\n    print(networkDelayTime1(times, n, k))  # 2\n    print(networkDelayTime2(times, n, k))  # 2\n    print(networkDelayTimeBF(times, n, k))  # 2\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;cassert&gt;\n#include &lt;climits&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass NetworkDelayTime {\n   public:\n    // single-source, non-negative weight -&gt; Dijkstra's\n    // https://leetcode.cn/problems/network-delay-time/solutions/2668220/liang-chong-dijkstra-xie-fa-fu-ti-dan-py-ooe8/\n    int dijkstra(vector&lt;vector&lt;int&gt;&gt;&amp; times, int n, int k) {\n        vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; graph(n + 1);\n        for (auto&amp; t : times) {\n            graph[t[0]].push_back({t[1], t[2]});\n        }\n\n        vector&lt;int&gt; dist(n + 1, INT_MAX);\n        // min heap\n        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;,\n                       greater&lt;pair&lt;int, int&gt;&gt;&gt;\n            min_heap;\n\n        dist[k] = 0;\n        min_heap.push({0, k});  // [dist, node]\n\n        while (!min_heap.empty()) {\n            auto [d, u] = min_heap.top();\n            min_heap.pop();\n\n            if (d &gt; dist[u]) continue;  // found the shortest\n\n            for (auto&amp; [v, w] : graph[u]) {\n                if (dist[u] + w &lt; dist[v]) {\n                    dist[v] = dist[u] + w;\n                    min_heap.push({dist[v], v});\n                }\n            }\n        }\n\n        int res = 0;\n        for (int i = 1; i &lt;= n; ++i) {\n            if (dist[i] == INT_MAX) return -1;\n            res = max(res, dist[i]);\n        }\n        return res;\n    }\n\n    // single source -&gt; Bellman-Ford\n    int bellman_ford(vector&lt;vector&lt;int&gt;&gt;&amp; times, int n, int k) {\n        vector&lt;int&gt; dist(n + 1, INT_MAX);\n        dist[k] = 0;\n\n        for (int i = 1; i &lt;= n - 1; i++) {\n            for (auto&amp; edge : times) {\n                int u = edge[0], v = edge[1], t = edge[2];\n                if (dist[u] != INT_MAX &amp;&amp; dist[v] &gt; dist[u] + t) {\n                    dist[v] = dist[u] + t;\n                }\n            }\n        }\n\n        int res = 0;\n        for (int i = 1; i &lt;= n; i++) {\n            if (dist[i] == INT_MAX) return -1;\n            res = max(res, dist[i]);\n        }\n        return res;\n    }\n};\n\nint main() {\n    NetworkDelayTime solution;\n    vector&lt;vector&lt;int&gt;&gt; times = {{2, 1, 1}, {2, 3, 1}, {3, 4, 1}};\n    assert(solution.dijkstra(times, 4, 2) == 2);\n    assert(solution.bellman_ford(times, 4, 2) == 2);\n\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/graph_shortest_path/#778-swim-in-rising-water","title":"778. Swim in Rising Water","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Depth First Search, Breadth First Search, Union Find, Heap Priority Queue, Matrix</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the minimum time when you can reach the target.\n\n![778](https://assets.leetcode.com/uploads/2021/06/29/swim2-grid-1.jpg)\n\"\"\"\n\nimport heapq\nfrom typing import List\n\n\n# Dijkstra's\ndef swimInWater(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    visited = set()\n    minHeap = [(grid[0][0], 0, 0)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    visited.add((0, 0))\n\n    while minHeap:\n        time, r, c = heapq.heappop(minHeap)\n\n        if r == n - 1 and c == n - 1:\n            return time\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if nr in range(n) and nc in range(n) and (nr, nc) not in visited:\n                visited.add((nr, nc))\n                heapq.heappush(minHeap, (max(time, grid[nr][nc]), nr, nc))\n\n\ngrid = [\n    [0, 1, 2, 3, 4],\n    [24, 23, 22, 21, 5],\n    [12, 13, 14, 15, 16],\n    [11, 17, 18, 19, 20],\n    [10, 9, 8, 7, 6],\n]\nprint(swimInWater(grid))  # 16\n</code></pre>"},{"location":"LeetPattern/graph_shortest_path/#1631-path-with-minimum-effort","title":"1631. Path With Minimum Effort","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Depth First Search, Breadth First Search, Union Find, Heap Priority Queue, Matrix</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the minimum effort required to travel from the top-left to the bottom-right corner.\n\"\"\"\n\nimport heapq\nfrom typing import List\n\n\n# Prim\ndef minimumEffortPath(heights: List[List[int]]) -&gt; int:\n    m, n = len(heights), len(heights[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * n for _ in range(m)]\n    heap = [(0, 0, 0)]  # (effort, row, col)\n\n    while heap:\n        effort, r, c = heapq.heappop(heap)\n\n        if visited[r][c]:\n            continue\n\n        if r == m - 1 and c == n - 1:\n            return effort\n\n        visited[r][c] = True\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and not visited[nr][nc]:\n                updated = max(effort, abs(heights[r][c] - heights[nr][nc]))\n                heapq.heappush(heap, (updated, nr, nc))\n\n    return -1\n\n\nheights = [[1, 2, 2], [3, 8, 2], [5, 3, 5]]\nprint(minimumEffortPath(heights))  # 2\n</code></pre>"},{"location":"LeetPattern/graph_shortest_path/#787-cheapest-flights-within-k-stops","title":"787. Cheapest Flights Within K Stops","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Depth First Search, Breadth First Search, Graph, Heap Priority Queue, Shortest Path</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return the cheapest price from `src` to `dst` with at most `K` stops.\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/5eIK3zUdYmE?si=aBR0VbHXTgNuVlGz\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen&gt;&lt;/iframe&gt;\n\"\"\"\n\nimport heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Bellman-Ford\ndef findCheapestPriceBF(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    prices = [float(\"inf\") for _ in range(n)]\n    prices[src] = 0\n\n    for _ in range(k + 1):\n        temp = prices[:]\n        for u, v, w in flights:\n            temp[v] = min(temp[v], prices[u] + w)\n        prices = temp\n\n    return prices[dst] if prices[dst] != float(\"inf\") else -1\n\n\n# Dijkstra\ndef findCheapestPriceDijkstra(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in flights:\n        graph[u].append((v, w))\n\n    heap = [(0, src, 0)]  # (price, city, stops)\n    visited = defaultdict(int)  # {city: stops}\n\n    while heap:\n        price, city, stops = heapq.heappop(heap)\n\n        if city == dst:\n            return price\n\n        if stops &gt; k:\n            continue\n\n        if city in visited and visited[city] &lt;= stops:\n            continue\n\n        visited[city] = stops\n\n        for neighbor, cost in graph[city]:\n            heapq.heappush(heap, (price + cost, neighbor, stops + 1))\n\n    return -1\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |Bellman-Ford|    O(k * E)      |  O(n)   |\n# | Dijkstra   | O(E * log(V))    |  O(n)   |\n# |------------|------------------|---------|\n\n\nn = 4\nflights = [[0, 1, 100], [1, 2, 100], [2, 0, 100], [1, 3, 600], [2, 3, 200]]\nsrc = 0\ndst = 3\nk = 1\nprint(findCheapestPriceBF(n, flights, src, dst, k))  # 700\nprint(findCheapestPriceDijkstra(n, flights, src, dst, k))  # 700\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;climits&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass FindCheapestPrice {\n   public:\n    int bellman_ford(int n, vector&lt;vector&lt;int&gt;&gt;&amp; flights, int src, int dst,\n                     int k) {\n        vector&lt;int&gt; dist(n, INT_MAX);\n        dist[src] = 0;\n\n        for (int i = 0; i &lt;= k; ++i) {\n            vector&lt;int&gt; temp(dist);\n            for (auto&amp; flight : flights) {\n                int u = flight[0], v = flight[1], w = flight[2];\n                if (dist[u] != INT_MAX &amp;&amp; dist[u] + w &lt; temp[v]) {\n                    temp[v] = dist[u] + w;\n                }\n            }\n            dist = temp;\n        }\n        return dist[dst] == INT_MAX ? -1 : dist[dst];\n    }\n\n    int dijkstra(int n, vector&lt;vector&lt;int&gt;&gt;&amp; flights, int src, int dst, int k) {\n        vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; graph(n);\n        for (auto&amp; flight : flights) {\n            graph[flight[0]].push_back({flight[1], flight[2]});\n        }\n        priority_queue&lt;array&lt;int, 3&gt;, vector&lt;array&lt;int, 3&gt;&gt;,\n                       greater&lt;array&lt;int, 3&gt;&gt;&gt;\n            min_heap;\n        min_heap.push({0, src, k + 1});\n\n        while (!min_heap.empty()) {\n            auto [cost, u, stops] = min_heap.top();\n            min_heap.pop();\n            if (u == dst) {\n                return cost;\n            }\n            if (stops &gt; 0) {\n                for (auto&amp; [v, w] : graph[u]) {\n                    min_heap.push({cost + w, v, stops - 1});\n                }\n            }\n        }\n\n        return -1;\n    }\n};\n\nint main() {\n    FindCheapestPrice solution;\n    int n = 4;\n    vector&lt;vector&lt;int&gt;&gt; flights = {\n        {0, 1, 100}, {1, 2, 100}, {2, 0, 100}, {1, 3, 600}, {2, 3, 200}};\n    int src = 0, dst = 3, k = 1;\n    assert(solution.bellman_ford(n, flights, src, dst, k) == 700);\n    assert(solution.dijkstra(n, flights, src, dst, k) == 700);\n\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/graph_shortest_path/#1514-path-with-maximum-probability","title":"1514. Path with Maximum Probability","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Graph, Heap Priority Queue, Shortest Path</p> </li> </ul> Python <pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Dijkstra - Dict\ndef maxProbability1(\n    n: int,\n    edges: List[List[int]],\n    succProb: List[float],\n    start_node: int,\n    end_node: int,\n) -&gt; float:\n    graph = defaultdict(list)\n    for i, (u, v) in enumerate(edges):\n        graph[u].append((v, succProb[i]))\n        graph[v].append((u, succProb[i]))\n\n    heap = [(-1, start_node)]\n    max_prob = {i: 0.0 for i in range(n)}\n    max_prob[start_node] = 1.0\n\n    while heap:\n        p1, n1 = heapq.heappop(heap)\n\n        if n1 == end_node:\n            return -p1\n\n        for n2, p2 in graph[n1]:\n            p2 *= -p1\n            if p2 &gt; max_prob[n2]:\n                max_prob[n2] = p2\n                heapq.heappush(heap, (-p2, n2))\n\n    return 0.0\n\n\n# Dijkstra - Set\ndef maxProbability2(\n    n: int,\n    edges: List[List[int]],\n    succProb: List[float],\n    start_node: int,\n    end_node: int,\n) -&gt; float:\n    graph = defaultdict(list)\n    for i, (u, v) in enumerate(edges):\n        graph[u].append((v, succProb[i]))\n        graph[v].append((u, succProb[i]))\n\n    heap = [(-1, start_node)]\n    visited = set()\n\n    while heap:\n        p1, n1 = heapq.heappop(heap)\n        visited.add(n1)\n\n        if n1 == end_node:\n            return -p1\n\n        for n2, p2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (p1 * p2, n2))\n\n    return 0.0\n\n\n# |------------|-----------|-----------|\n# |  Approach  |    Time   |   Space   |\n# |------------|-----------|-----------|\n# |  Dijkstra  | O(E log V)|   O(E)    |\n# |------------|-----------|-----------|\n\n\nn = 3\nedges = [[0, 1], [1, 2], [0, 2]]\nsuccProb = [0.5, 0.5, 0.2]\nstart = 0\nend = 2\n\nprint(maxProbability1(n, edges, succProb, start, end))  # 0.25\nprint(maxProbability2(n, edges, succProb, start, end))  # 0.25\n</code></pre>"},{"location":"LeetPattern/graph_shortest_path/#505-the-maze-ii","title":"505. The Maze II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Graph, Heap Priority Queue, Matrix, Shortest Path</p> </li> </ul> Python <pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra\ndef shortestDistance(\n    maze: List[List[int]], start: List[int], destination: List[int]\n) -&gt; int:\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    m, n = len(maze), len(maze[0])\n\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    dist[start[0]][start[1]] = 0\n\n    heap = [(0, start[0], start[1])]\n\n    while heap:\n        d, r, c = heapq.heappop(heap)\n\n        if [r, c] == destination:\n            return d\n\n        for dr, dc in directions:\n            nr, nc, nd = r, c, d\n\n            while 0 &lt;= nr + dr &lt; m and 0 &lt;= nc + dc &lt; n and maze[nr + dr][nc + dc] == 0:\n                nr += dr\n                nc += dc\n                nd += 1\n\n            if nd &lt; dist[nr][nc]:\n                dist[nr][nc] = nd\n                heapq.heappush(heap, (nd, nr, nc))\n\n    return -1\n\n\nmaze = [\n    [0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0],\n    [0, 0, 0, 1, 0],\n    [1, 1, 0, 1, 1],\n    [0, 0, 0, 0, 0],\n]\nstart = [0, 4]\ndestination = [4, 4]\nprint(shortestDistance(maze, start, destination))  # 12\n</code></pre>"},{"location":"LeetPattern/graph_shortest_path/#499-the-maze-iii","title":"499. The Maze III \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Depth First Search, Breadth First Search, Graph, Heap Priority Queue, Matrix, Shortest Path</p> </li> </ul> Python <pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra\ndef findShortestWay(maze: List[List[int]], ball: List[int], hole: List[int]) -&gt; str:\n    directions = [(-1, 0, \"u\"), (1, 0, \"d\"), (0, -1, \"l\"), (0, 1, \"r\")]\n    m, n = len(maze), len(maze[0])\n\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    dist[ball[0]][ball[1]] = 0\n\n    paths = [[\"\"] * n for _ in range(m)]\n    paths[ball[0]][ball[1]] = \"\"\n\n    heap = [(0, \"\", ball[0], ball[1])]\n\n    while heap:\n        d, path, x, y = heapq.heappop(heap)\n\n        if [x, y] == hole:\n            return path\n\n        for dx, dy, direction in directions:\n            nx, ny, nd = x, y, d\n\n            while 0 &lt;= nx + dx &lt; m and 0 &lt;= ny + dy &lt; n and maze[nx + dx][ny + dy] == 0:\n                nx += dx\n                ny += dy\n                nd += 1\n\n                if [nx, ny] == hole:\n                    break\n\n            new_path = path + direction\n            if nd &lt; dist[nx][ny] or (nd == dist[nx][ny] and new_path &lt; paths[nx][ny]):\n                dist[nx][ny] = nd\n                paths[nx][ny] = new_path\n                heapq.heappush(heap, (nd, new_path, nx, ny))\n\n    return \"impossible\"\n\n\nmaze = [\n    [0, 0, 0, 0, 0],\n    [1, 1, 0, 0, 1],\n    [0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 1],\n    [0, 1, 0, 0, 0],\n]\nball = [4, 3]\nhole = [0, 1]\nprint(findShortestWay(maze, ball, hole))  # \"lul\"\n</code></pre>"},{"location":"LeetPattern/graph_shortest_path/#882-reachable-nodes-in-subdivided-graph","title":"882. Reachable Nodes In Subdivided Graph","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Graph, Heap Priority Queue, Shortest Path</p> </li> </ul> Python <pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra's\ndef reachableNodes(self, edges: List[List[int]], maxMoves: int, n: int) -&gt; int:\n    graph = {i: {} for i in range(n)}\n    for u, v, cnt in edges:\n        graph[u][v] = cnt\n        graph[v][u] = cnt\n\n    heap = [(-maxMoves, 0)]\n    seen = {}\n\n    while heap:\n        moves, node = heapq.heappop(heap)\n        if node in seen:\n            continue\n        seen[node] = -moves\n        for nxt, cnt in graph[node].items():\n            movesLeft = -moves - cnt - 1\n            if nxt not in seen and movesLeft &gt;= 0:\n                heapq.heappush(heap, (-movesLeft, nxt))\n\n    res = len(seen)\n    for u, v, cnt in edges:\n        res += min(seen.get(u, 0) + seen.get(v, 0), cnt)\n\n    return res\n\n\nedges = [[0, 1, 10], [0, 2, 1], [1, 2, 2]]\nmaxMoves = 6\nn = 3\nprint(reachableNodes(None, edges, maxMoves, n))  # 13\n</code></pre>"},{"location":"LeetPattern/graph_shortest_path/#1376-time-needed-to-inform-all-employees","title":"1376. Time Needed to Inform All Employees","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search</p> </li> </ul> Python <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# DFS\ndef numOfMinutesDFS(\n    n: int, headID: int, manager: List[int], informTime: List[int]\n) -&gt; int:\n    graph = defaultdict(list)\n    for i in range(n):\n        if manager[i] != -1:\n            graph[manager[i]].append(i)\n\n    def dfs(node):\n        time = 0\n        for sub in graph[node]:\n            time = max(time, dfs(sub))\n        return time + informTime[node]\n\n    return dfs(headID)\n\n\n# BFS\ndef numOfMinutesBFS(\n    n: int, headID: int, manager: List[int], informTime: List[int]\n) -&gt; int:\n    graph = defaultdict(list)\n    for i in range(n):\n        if manager[i] != -1:\n            graph[manager[i]].append(i)\n\n    q = deque([(headID, 0)])\n    max_time = 0\n\n    while q:\n        node, time = q.popleft()\n        max_time = max(max_time, time)\n        for sub in graph[node]:\n            q.append((sub, time + informTime[node]))\n\n    return max_time\n\n\nn = 6\nheadID = 2\nmanager = [2, 2, -1, 2, 2, 2]\ninformTime = [0, 0, 1, 0, 0, 0]\nprint(numOfMinutesDFS(n, headID, manager, informTime))  # 1\nprint(numOfMinutesBFS(n, headID, manager, informTime))  # 1\n</code></pre>"},{"location":"LeetPattern/graph_shortest_path/#1168-optimize-water-distribution-in-a-village","title":"1168. Optimize Water Distribution in a Village \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Union Find, Graph, Heap Priority Queue, Minimum Spanning Tree</p> </li> </ul> Python <pre><code>\"\"\"\n- ![1168_0](../../assets/1168_0.png)\n\n- ![1168_1](../../assets/1168_1.png)\n\"\"\"\n\nimport heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minCostToSupplyWater1(n: int, wells: List[int], pipes: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n\n    for h1, h2, cost in pipes:\n        graph[h1].append((h2, cost))\n        graph[h2].append((h1, cost))\n\n    # Add the cost of the wells to the graph (house 0)\n    for i in range(n):\n        graph[0].append((i + 1, wells[i]))\n        graph[i + 1].append((0, wells[i]))\n\n    visited = set([0])\n    heap = [(cost, dest) for dest, cost in graph[0]]\n    heapq.heapify(heap)\n\n    cost = 0\n\n    while heap:\n        c1, n1 = heapq.heappop(heap)\n        if n1 in visited:\n            continue\n        visited.add(n1)\n        cost += c1\n\n        for n2, c2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (c2, n2))\n\n    return cost\n\n\n# Kruskal\ndef minCostToSupplyWater2(n: int, wells: List[int], pipes: List[List[int]]) -&gt; int:\n    par = list(range(n + 1))\n    rank = [0] * (n + 1)\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            if rank[p1] &lt; rank[p2]:\n                par[p1] = p2\n            elif rank[p1] &gt; rank[p2]:\n                par[p2] = p1\n            else:\n                par[p1] = p2\n                rank[p2] += 1\n            return True\n        return False\n\n    graph = [(c, 0, i + 1) for i, c in enumerate(wells)]\n    for h1, h2, c in pipes:\n        graph.append((c, h1, h2))\n\n    graph.sort()\n\n    cost = 0\n\n    for c, h1, h2 in graph:\n        if union(h1, h2):\n            cost += c\n\n    return cost\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |    Prim    | O((V + E) log V) | O(V + E)|\n# |  Kruskal   |     O(E log E)   | O(V + E)|\n# |------------|------------------|---------|\n\n\nn = 3\nwells = [1, 2, 2]\npipes = [[1, 2, 1], [2, 3, 1]]\nprint(minCostToSupplyWater1(n, wells, pipes))  # 3\nprint(minCostToSupplyWater2(n, wells, pipes))  # 3\n</code></pre>"},{"location":"LeetPattern/graph_shortest_path/#1976-number-of-ways-to-arrive-at-destination","title":"1976. Number of Ways to Arrive at Destination","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Graph, Topological Sort, Shortest Path</p> </li> </ul> Python <pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra\ndef countPaths(n: int, roads: List[List[int]]) -&gt; int:\n    mod = 10**9 + 7\n    graph = [[] for _ in range(n)]\n    for u, v, w in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n\n    dist = [float(\"inf\") for _ in range(n)]\n    dist[0] = 0\n    count = [0 for _ in range(n)]\n    count[0] = 1\n\n    heap = [(0, 0)]\n\n    while heap:\n        d, u = heapq.heappop(heap)\n        if d &gt; dist[u]:\n            continue\n\n        for v, w in graph[u]:\n            if dist[u] + w &lt; dist[v]:\n                dist[v] = dist[u] + w\n                count[v] = count[u]\n                heapq.heappush(heap, (dist[v], v))\n            elif dist[u] + w == dist[v]:\n                count[v] += count[u]\n                count[v] %= mod\n\n    return count[-1]\n\n\nn = 7\nroads = [\n    [0, 6, 7],\n    [0, 1, 2],\n    [1, 2, 3],\n    [1, 3, 3],\n    [6, 3, 3],\n    [3, 5, 1],\n    [6, 5, 1],\n    [2, 5, 1],\n    [0, 4, 5],\n    [4, 6, 2],\n]\nprint(countPaths(n, roads))  # 4\n</code></pre>"},{"location":"LeetPattern/graph_tarjan/","title":"Graph Tarjan","text":""},{"location":"LeetPattern/graph_tarjan/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1192. Critical Connections in a Network (Hard)</li> </ul>"},{"location":"LeetPattern/graph_tarjan/#1192-critical-connections-in-a-network","title":"1192. Critical Connections in a Network","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Graph, Biconnected Component</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Tarjan\ndef criticalConnections(n: int, connections: List[List[int]]) -&gt; List[List[int]]:\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    disc = [-1] * n\n    low = [-1] * n\n    bridges = []\n    time = 0\n\n    def dfs(n1, prev):\n        nonlocal time\n        disc[n1], low[n1] = time, time\n        time += 1\n\n        for n2 in graph[n1]:\n            if n2 == prev:\n                continue\n            if disc[n2] == -1:\n                dfs(n2, n1)\n                low[n1] = min(low[n1], low[n2])\n\n                if low[n2] &gt; disc[n1]:\n                    bridges.append([n1, n2])\n            else:\n                low[n1] = min(low[n1], disc[n2])\n\n    for i in range(n):\n        if disc[i] == -1:\n            dfs(i, -1)\n\n    return bridges\n\n\nn = 4\nconnections = [[0, 1], [1, 2], [2, 0], [1, 3]]\nprint(criticalConnections(n, connections))  # [[1, 3]]\n</code></pre>"},{"location":"LeetPattern/graph_topological_sort/","title":"Graph Topological Sort","text":""},{"location":"LeetPattern/graph_topological_sort/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1557. Minimum Number of Vertices to Reach All Nodes (Medium)</li> <li> 207. Course Schedule (Medium)</li> <li> 210. Course Schedule II (Medium)</li> <li> 269. Alien Dictionary (Hard) \ud83d\udc51</li> <li> 1203. Sort Items by Groups Respecting Dependencies (Hard)</li> <li> 1857. Largest Color Value in a Directed Graph (Hard)</li> <li> 1136. Parallel Courses (Medium) \ud83d\udc51</li> </ul>"},{"location":"LeetPattern/graph_topological_sort/#1557-minimum-number-of-vertices-to-reach-all-nodes","title":"1557. Minimum Number of Vertices to Reach All Nodes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Graph</p> </li> </ul> Python <pre><code>\"\"\"\n- Return a list of integers representing the minimum number of vertices needed to traverse all the nodes.\n- Hint: Return the vertices with indegree 0.\n\"\"\"\n\nfrom typing import List\n\n\n# Graph\ndef findSmallestSetOfVertices(n: int, edges: List[List[int]]) -&gt; List[int]:\n    indegree = {i: 0 for i in range(n)}\n\n    for _, end in edges:\n        indegree[end] += 1\n\n    return [i for i in range(n) if indegree[i] == 0]\n\n\nif __name__ == \"__main__\":\n    n = 6\n    edges = [[0, 1], [0, 2], [2, 5], [3, 4], [4, 2]]\n    assert findSmallestSetOfVertices(n, edges) == [0, 3]\n</code></pre>"},{"location":"LeetPattern/graph_topological_sort/#207-course-schedule","title":"207. Course Schedule","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Graph, Topological Sort</p> </li> </ul> PythonCPP <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS (Kahn's Algorithm)\ndef canFinishBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    count = 0\n\n    while q:\n        crs = q.popleft()\n        count += 1\n\n        for nxt in graph[crs]:\n            indegree[nxt] -= 1\n\n            if indegree[nxt] == 0:\n                q.append(nxt)\n\n    return count == numCourses\n\n\n# DFS + Set\ndef canFinishDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for crs, pre in prerequisites:\n        graph[crs].append(pre)\n\n    visiting = set()\n\n    def dfs(crs):\n        if crs in visiting:  # cycle detected\n            return False\n        if graph[crs] == []:\n            return True\n\n        visiting.add(crs)\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        visiting.remove(crs)\n        graph[crs] = []\n\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\n# DFS + List\ndef canFinishDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for pre, crs in prerequisites:\n        graph[crs].append(pre)\n\n    # 0: init, 1: visiting, 2: visited\n    status = [0] * numCourses\n\n    def dfs(crs):\n        if status[crs] == 1:  # cycle detected\n            return False\n        if status[crs] == 2:\n            return True\n\n        status[crs] = 1\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        status[crs] = 2\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(canFinishBFS(5, prerequisites))  # True\nprint(canFinishDFS1(5, prerequisites))  # True\nprint(canFinishDFS2(5, prerequisites))  # True\n</code></pre> <pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    // BFS\n    bool canFinishBFS(int numCourses, vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        vector&lt;int&gt; indegree(numCourses, 0);\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n            indegree[pre[0]]++;\n        }\n\n        queue&lt;int&gt; q;\n        for (int i = 0; i &lt; numCourses; i++) {\n            if (indegree[i] == 0) {\n                q.push(i);\n            }\n        }\n\n        int cnt = 0;\n        while (!q.empty()) {\n            int cur = q.front();\n            q.pop();\n            cnt++;\n\n            for (int nxt : graph[cur]) {\n                indegree[nxt]--;\n                if (indegree[nxt] == 0) {\n                    q.push(nxt);\n                }\n            }\n        }\n        return cnt == numCourses;\n    }\n\n    // DFS\n    bool canFinishDFS(int numCourses, vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n        }\n        // 0: not visited, 1: visiting, 2: visited\n        vector&lt;int&gt; state(numCourses, 0);\n\n        function&lt;bool(int)&gt; dfs = [&amp;](int pre) -&gt; bool {\n            state[pre] = 1;  // visiting\n            for (int crs : graph[pre]) {\n                if (state[crs] == 1 || (state[crs] == 0 &amp;&amp; dfs(crs))) {\n                    return true;\n                }\n            }\n            state[pre] = 2;  // visited\n            return false;\n        };\n\n        for (int i = 0; i &lt; numCourses; i++) {\n            if (state[i] == 0 &amp;&amp; dfs(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution sol;\n    vector&lt;vector&lt;int&gt;&gt; prerequisites = {{1, 0}, {2, 1}, {3, 2}, {4, 3},\n                                         {5, 4}, {6, 5}, {7, 6}, {8, 7},\n                                         {9, 8}, {10, 9}};\n    int numCourses = 11;\n    cout &lt;&lt; sol.canFinishBFS(numCourses, prerequisites) &lt;&lt; endl;\n    cout &lt;&lt; sol.canFinishDFS(numCourses, prerequisites) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/graph_topological_sort/#210-course-schedule-ii","title":"210. Course Schedule II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Graph, Topological Sort</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return the ordering of courses you should take to finish all courses. If there are multiple valid answers, return any of them.\n\n![0207](../../assets/0207.png)\n\"\"\"\n\nfrom collections import defaultdict, deque\nfrom typing import List\n\n\n# 1. BFS - Kahn's Algorithm\ndef findOrderBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    order = []\n\n    while q:\n        pre = q.popleft()\n        order.append(pre)\n\n        for crs in graph[pre]:\n            indegree[crs] -= 1\n            if indegree[crs] == 0:\n                q.append(crs)\n\n    return order if len(order) == numCourses else []\n\n\n# 2. DFS + Set\ndef findOrderDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]:\n    adj = defaultdict(list)\n    for crs, pre in prerequisites:\n        adj[crs].append(pre)\n\n    visit, cycle = set(), set()\n    order = []\n\n    def dfs(crs):\n        if crs in cycle:\n            return False\n        if crs in visit:\n            return True\n\n        cycle.add(crs)\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        cycle.remove(crs)\n        visit.add(crs)\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order\n\n\n# 3. DFS + List\ndef findOrderDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]:\n    adj = defaultdict(list)\n    for pre, crs in prerequisites:\n        adj[crs].append(pre)\n\n    # 0: not visited, 1: visiting, 2: visited\n    state = [0] * numCourses\n    order = []\n\n    def dfs(crs):\n        if state[crs] == 1:\n            return False\n        if state[crs] == 2:\n            return True\n\n        state[crs] = 1\n\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        state[crs] = 2\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order[::-1]\n\n\nnumCourses = 5\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(findOrderBFS(numCourses, prerequisites))  # [2, 4, 3, 1, 0]\nprint(findOrderDFS1(numCourses, prerequisites))  # [4, 3, 1, 2, 0]\nprint(findOrderDFS2(numCourses, prerequisites))  # [4, 3, 2, 1, 0]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    // BFS\n    vector&lt;int&gt; findOrderBFS(int numCourses,\n                             vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        vector&lt;int&gt; in_degree(numCourses, 0);\n        vector&lt;int&gt; res;\n\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n            in_degree[pre[0]]++;\n        }\n\n        queue&lt;int&gt; q;\n        for (int i = 0; i &lt; numCourses; i++)\n            if (in_degree[i] == 0) q.push(i);\n\n        while (!q.empty()) {\n            int cur = q.front();\n            q.pop();\n            res.push_back(cur);\n\n            for (int next : graph[cur]) {\n                in_degree[next]--;\n                if (in_degree[next] == 0) q.push(next);\n            }\n        }\n\n        return (int)res.size() == numCourses ? res : vector&lt;int&gt;{};\n    }\n};\n\nint main() {\n    Solution obj;\n    vector&lt;vector&lt;int&gt;&gt; prerequisites{{1, 0}, {2, 0}, {3, 1}, {3, 2}};\n    vector&lt;int&gt; res = obj.findOrderBFS(4, prerequisites);\n    assert((res == vector&lt;int&gt;{0, 1, 2, 3} || res == vector&lt;int&gt;{0, 2, 1, 3}));\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/graph_topological_sort/#269-alien-dictionary","title":"269. Alien Dictionary \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Depth First Search, Breadth First Search, Graph, Topological Sort</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the correct order of characters in the alien language.\n\"\"\"\n\nfrom collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS - Kahn's algorithm (Topological Sort)\ndef alienOrderBFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    indegree = {c: 0 for word in words for c in word}\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                    indegree[w2[j]] += 1\n                break\n\n    q = deque([c for c in indegree if indegree[c] == 0])\n    result = []\n\n    while q:\n        char = q.popleft()\n        result.append(char)\n\n        for neighbor in graph[char]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n\n    return \"\".join(result) if len(result) == len(indegree) else \"\"\n\n\n# DFS - Topological Sort\ndef alienOrderDFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    visited = {}\n    result = []\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                break\n\n    def dfs(c):\n        if c in visited:\n            return visited[c]\n\n        visited[c] = False\n        for neighbor in graph[c]:\n            if not dfs(neighbor):\n                return False\n\n        visited[c] = True\n        result.append(c)\n        return True\n\n    for c in list(graph.keys()):\n        if not dfs(c):\n            return \"\"\n\n    return \"\".join(result[::-1])\n\n\nwords = [\"wrt\", \"wrf\", \"er\", \"ett\", \"rftt\"]\nprint(alienOrderBFS(words))  # wertf\nprint(alienOrderDFS(words))  # wertf\n</code></pre>"},{"location":"LeetPattern/graph_topological_sort/#1203-sort-items-by-groups-respecting-dependencies","title":"1203. Sort Items by Groups Respecting Dependencies","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Graph, Topological Sort</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return any permutation of the items that satisfies the requirements.\n\"\"\"\n\nfrom collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS - Kahn's algorithm (Topological Sort)\ndef sortItems(\n    n: int, m: int, group: List[int], beforeItems: List[List[int]]\n) -&gt; List[int]:\n    def topological_sort(graph, indegree, nodes):\n        q = deque([node for node in nodes if indegree[node] == 0])\n        result = []\n\n        while q:\n            node = q.popleft()\n            result.append(node)\n\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    q.append(neighbor)\n\n        return result if len(result) == len(nodes) else []\n\n    groupItems = defaultdict(list)\n    groupGraph = defaultdict(set)\n    groupIndegree = defaultdict(int)\n    itemGraph = defaultdict(set)\n    itemIndegree = defaultdict(int)\n\n    for i in range(n):\n        if group[i] == -1:\n            group[i] = m\n            m += 1\n        groupItems[group[i]].append(i)\n\n    for i, beforeItem in enumerate(beforeItems):\n        for before in beforeItem:\n            if group[before] != group[i]:\n                if group[i] not in groupGraph[group[before]]:\n                    groupGraph[group[before]].add(group[i])\n                    groupIndegree[group[i]] += 1\n            else:\n                itemGraph[before].add(i)\n                itemIndegree[i] += 1\n\n    allGroups = list(set(group))\n    groupOrder = topological_sort(groupGraph, groupIndegree, allGroups)\n    if not groupOrder:\n        return []\n\n    result = []\n    for g in groupOrder:\n        items = groupItems[g]\n        itemOrder = topological_sort(itemGraph, itemIndegree, items)\n        if not itemOrder:\n            return []\n        result.extend(itemOrder)\n\n    return result\n\n\nn = 8\nm = 2\ngroup = [-1, -1, 1, 0, 0, 1, 0, -1]\nbeforeItems = [[], [6], [5], [6], [3, 6], [], [], []]\nprint(sortItems(n, m, group, beforeItems))\n</code></pre>"},{"location":"LeetPattern/graph_topological_sort/#1857-largest-color-value-in-a-directed-graph","title":"1857. Largest Color Value in a Directed Graph","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Dynamic Programming, Graph, Topological Sort, Memoization, Counting</p> </li> </ul> Python <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# Topological Sort\ndef largestPathValue(colors: str, edges: List[List[int]]) -&gt; int:\n    n = len(colors)\n    graph = defaultdict(list)\n    indegree = [0 for _ in range(n)]\n\n    for u, v in edges:\n        graph[u].append(v)\n        indegree[v] += 1\n\n    q = deque([i for i in range(n) if indegree[i] == 0])\n\n    dp = [[0] * 26 for _ in range(n)]\n\n    for i in range(n):\n        dp[i][ord(colors[i]) - ord(\"a\")] = 1\n\n    processed, max_color = 0, 0\n\n    while q:\n        n1 = q.popleft()\n        processed += 1\n        max_color = max(max_color, max(dp[n1]))\n\n        for n2 in graph[n1]:\n            indegree[n2] -= 1\n            for i in range(26):\n                dp[n2][i] = max(\n                    dp[n2][i],\n                    dp[n1][i] + (1 if i == ord(colors[n2]) - ord(\"a\") else 0),\n                )\n            if indegree[n2] == 0:\n                q.append(n2)\n\n    return max_color if processed == n else -1\n\n\ncolors = \"abaca\"\nedges = [[0, 1], [0, 2], [2, 3], [3, 4]]\nprint(largestPathValue(colors, edges))  # 3\n</code></pre>"},{"location":"LeetPattern/graph_topological_sort/#1136-parallel-courses","title":"1136. Parallel Courses \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Graph, Topological Sort</p> </li> </ul> Python <pre><code>\"\"\"\n- Return the minimum number of semesters needed to take all courses.\n\n![1136](../../assets/1136.png)\n\"\"\"\n\nfrom collections import deque\nfrom typing import List\n\n\n# Topological Sort\ndef minimumSemesters(n: int, relations: List[List[int]]) -&gt; int:\n    graph = {i: [] for i in range(1, n + 1)}\n    indegree = {i: 0 for i in range(1, n + 1)}\n\n    for pre, nxt in relations:\n        graph[pre].append(nxt)\n        indegree[nxt] += 1\n\n    q = deque([i for i in range(1, n + 1) if indegree[i] == 0])\n    semester = 0\n    done = 0\n\n    while q:\n        semester += 1\n        size = len(q)\n\n        for _ in range(size):\n            pre = q.popleft()\n            done += 1\n\n            for nxt in graph[pre]:\n                indegree[nxt] -= 1\n                if indegree[nxt] == 0:\n                    q.append(nxt)\n\n    return semester if done == n else -1\n\n\nn = 3\nrelations = [[1, 3], [2, 3]]\nprint(minimumSemesters(n, relations))  # 2\n</code></pre>"},{"location":"LeetPattern/graph_union_find/","title":"Graph Union Find","text":""},{"location":"LeetPattern/graph_union_find/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 547. Number of Provinces (Medium)</li> <li> 684. Redundant Connection (Medium)</li> <li> 323. Number of Connected Components in an Undirected Graph (Medium) \ud83d\udc51</li> <li> 721. Accounts Merge (Medium)</li> <li> 990. Satisfiability of Equality Equations (Medium)</li> <li> 952. Largest Component Size by Common Factor (Hard)</li> <li> 839. Similar String Groups (Hard)</li> <li> 305. Number of Islands II (Hard) \ud83d\udc51</li> <li> 1202. Smallest String With Swaps (Medium)</li> <li> 685. Redundant Connection II (Hard)</li> <li> 399. Evaluate Division (Medium)</li> <li> 1101. The Earliest Moment When Everyone Become Friends (Medium) \ud83d\udc51</li> </ul>"},{"location":"LeetPattern/graph_union_find/#547-number-of-provinces","title":"547. Number of Provinces","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Union Find, Graph</p> </li> </ul> Python <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\nclass FindCircleNum:\n    def dfs_adjacency_list(self, isConnected: List[List[int]]) -&gt; int:\n        # edge case\n        if not isConnected:\n            return 0\n\n        # init\n        n = len(isConnected)\n        visited = set()\n        res = 0\n\n        # build adjacency list\n        graph = defaultdict(list)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if isConnected[i][j] == 1:\n                    graph[i].append(j)\n                    graph[j].append(i)\n\n        def dfs(node):\n            if node in visited:\n                return\n            visited.add(node)\n            for adj in graph[node]:\n                dfs(adj)\n\n        # loop\n        for i in range(n):\n            if i not in visited:\n                res += 1\n                dfs(i)\n\n        return res\n\n    def dfs_adjacency_matrix(self, isConnected: List[List[int]]) -&gt; int:\n        \"\"\"\n        Time complexity: O(V + E)\n        Space complexity: O(V)\n        \"\"\"\n        # edge case\n        if not isConnected:\n            return 0\n\n        # init\n        n = len(isConnected)\n        visited = set()\n        res = 0\n\n        def dfs(node):\n            if node in visited:\n                return\n            visited.add(node)\n            for adj in range(n):\n                if node != adj and isConnected[node][adj] == 1:\n                    dfs(adj)\n\n        # loop\n        for i in range(n):\n            if i not in visited:\n                res += 1\n                dfs(i)\n\n        return res\n\n    def bfs_adjacency_list(self, isConnected: List[List[int]]) -&gt; int:\n        # edge case\n        if not isConnected:\n            return 0\n\n        # init\n        n = len(isConnected)\n        visited = set()\n        res = 0\n\n        # build adjacency list\n        graph = defaultdict(list)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if isConnected[i][j] == 1:\n                    graph[i].append(j)\n                    graph[j].append(i)\n\n        # loop\n        for i in range(n):\n            if i not in visited:\n                q = deque([i])\n                visited.add(i)\n                res += 1\n\n                while q:\n                    node = q.popleft()\n                    for adj in graph[node]:\n                        if adj not in visited:\n                            q.append(adj)\n                            visited.add(adj)\n\n        return res\n\n    def bfs_adjacency_matrix(self, isConnected: List[List[int]]) -&gt; int:\n        if not isConnected:\n            return 0\n\n        res = 0\n        visited = set()\n        n = len(isConnected)\n\n        for i in range(n):\n            if i not in visited:\n                q = deque([i])\n                visited.add(i)\n                res += 1\n\n                while q:\n                    cur = q.popleft()\n                    for adj in range(n):\n                        if (\n                            adj != cur\n                            and adj not in visited\n                            and isConnected[adj][cur] == 1\n                        ):\n                            q.append(adj)\n                            visited.add(adj)\n\n        return res\n\n    def union_find(self, isConnected: List[List[int]]) -&gt; int:\n        n = len(isConnected)\n        par = {i: i for i in range(n)}\n        rank = {i: 0 for i in range(n)}\n\n        def find(n):\n            if par[n] != n:\n                par[n] = find(par[n])\n            return par[n]\n\n        def union(n1, n2):\n            p1, p2 = find(n1), find(n2)\n\n            if p1 == p2:\n                return None\n\n            if rank[p1] &gt; rank[p2]:\n                par[p2] = p1\n            elif rank[p1] &lt; rank[p2]:\n                par[p1] = p2\n            else:\n                par[p2] = p1\n                rank[p1] += 1\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if isConnected[i][j] == 1:\n                    union(i, j)\n\n        res = len(set(find(i) for i in range(n)))\n\n        return res\n\n\nif __name__ == \"__main__\":\n    isConnected = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]\n    sol = FindCircleNum()\n    assert sol.dfs_adjacency_list(isConnected) == 2\n    assert sol.dfs_adjacency_matrix(isConnected) == 2\n    assert sol.bfs_adjacency_list(isConnected) == 2\n    assert sol.bfs_adjacency_matrix(isConnected) == 2\n    assert sol.union_find(isConnected) == 2\n</code></pre>"},{"location":"LeetPattern/graph_union_find/#684-redundant-connection","title":"684. Redundant Connection","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Union Find, Graph</p> </li> </ul> Python <pre><code>from typing import List\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(1, n + 1)}\n        self.rank = {i: 1 for i in range(1, n + 1)}\n\n    def find(self, n):\n        p = self.par[n]\n        while self.par[p] != p:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return False\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.par[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.par[p1] = p2\n        else:\n            self.par[p2] = p1\n            self.rank[p1] += 1\n\n        return True\n\n\n# Union Find\ndef findRedundantConnectionUF(edges: List[List[int]]) -&gt; List[int]:\n    n = len(edges)\n    uf = UnionFind(n)\n\n    for u, v in edges:\n        if not uf.union(u, v):\n            return (u, v)\n\n\n# DFS\ndef findRedundantConnectionDFS(edges: List[List[int]]) -&gt; List[int]:\n    graph, cycle = {}, {}\n    for a, b in edges:\n        graph.setdefault(a, []).append(b)\n        graph.setdefault(b, []).append(a)\n\n    def dfs(node, parent):\n        if node in cycle:\n            for k in list(cycle.keys()):\n                if k == node:\n                    return True\n                del cycle[k]\n\n        cycle[node] = None\n        for child in graph[node]:\n            if child != parent and dfs(child, node):\n                return True\n        del cycle[node]\n        return False\n\n    dfs(edges[0][0], -1)\n    for a, b in edges[::-1]:\n        if a in cycle and b in cycle:\n            return (a, b)\n\n\nedges = [[1, 2], [1, 3], [2, 3]]\nprint(findRedundantConnectionUF(edges))  # (2, 3)\nprint(findRedundantConnectionDFS(edges))  # (2, 3)\n</code></pre>"},{"location":"LeetPattern/graph_union_find/#323-number-of-connected-components-in-an-undirected-graph","title":"323. Number of Connected Components in an Undirected Graph \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Union Find, Graph</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Union Find\ndef countComponents(n: int, edges: List[List[int]]) -&gt; int:\n    uf = UnionFind(n)\n    count = n\n\n    for u, v in edges:\n        count -= uf.union(u, v)\n\n    return count\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(n)}\n        self.rank = {i: 1 for i in range(n)}\n\n    def find(self, n):\n        p = self.par[n]\n        while self.par[p] != p:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return 0\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.par[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.par[p1] = p2\n        else:\n            self.par[p2] = p1\n            self.rank[p1] += 1\n\n        return 1\n\n\nprint(countComponents(5, [[0, 1], [1, 2], [3, 4]]))  # 2\n</code></pre>"},{"location":"LeetPattern/graph_union_find/#721-accounts-merge","title":"721. Accounts Merge","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Depth First Search, Breadth First Search, Union Find, Sorting</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef accountsMerge(accounts: List[List[str]]) -&gt; List[List[str]]:\n    parent = defaultdict(str)\n    rank = defaultdict(int)\n    email_to_name = defaultdict(str)\n    merged_accounts = defaultdict(list)\n\n    def find(n):\n        p = parent[n]\n        while p != parent[p]:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    for account in accounts:\n        name = account[0]\n        first_email = account[1]\n\n        for email in account[1:]:\n            if email not in parent:\n                parent[email] = email\n                rank[email] = 1\n            email_to_name[email] = name\n            union(first_email, email)\n\n    for email in parent:\n        root_email = find(email)\n        merged_accounts[root_email].append(email)\n\n    result = []\n    for root_email, emails in merged_accounts.items():\n        result.append([email_to_name[root_email]] + sorted(emails))\n\n    return result\n\n\naccounts = [\n    [\"John\", \"johnsmith@mail.com\", \"john_newyork@mail.com\"],\n    [\"John\", \"johnsmith@mail.com\", \"john00@mail.com\"],\n    [\"Mary\", \"mary@mail.com\"],\n    [\"John\", \"johnnybravo@mail.com\"],\n]\nprint(accountsMerge(accounts))\n# [['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],\n# ['Mary', 'mary@mail.com'],\n# ['John', 'johnnybravo@mail.com']]\n</code></pre>"},{"location":"LeetPattern/graph_union_find/#990-satisfiability-of-equality-equations","title":"990. Satisfiability of Equality Equations","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Union Find, Graph</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef equationsPossible(equations: List[str]) -&gt; bool:\n    parent = defaultdict(str)\n    rank = defaultdict(int)\n\n    def find(n):\n        p = parent[n]\n        while p != parent[p]:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    for equation in equations:\n        if equation[0] not in parent:\n            parent[equation[0]] = equation[0]\n            rank[equation[0]] = 1\n        if equation[3] not in parent:\n            parent[equation[3]] = equation[3]\n            rank[equation[3]] = 1\n\n    for equation in equations:\n        if equation[1] == \"=\":\n            union(equation[0], equation[3])\n\n    for equation in equations:\n        if equation[1] == \"!\":\n            if find(equation[0]) == find(equation[3]):\n                return False\n\n    return True\n\n\nequations = [\"a==b\", \"b!=a\"]\nprint(equationsPossible(equations))  # False\n</code></pre>"},{"location":"LeetPattern/graph_union_find/#952-largest-component-size-by-common-factor","title":"952. Largest Component Size by Common Factor","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Union Find, Number Theory</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef largestComponentSize(nums: List[int]) -&gt; int:\n    par = {i: i for i in nums}\n    rank = {i: 0 for i in nums}\n\n    def find(n):\n        p = par[n]\n        while par[p] != p:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            if rank[p1] &gt; rank[p2]:\n                par[p2] = p1\n            elif rank[p1] &lt; rank[p2]:\n                par[p1] = p2\n            else:\n                par[p2] = p1\n                rank[p1] += 1\n\n    def prime_factors(n):\n        \"\"\"Return the prime factors of n.\"\"\"\n        i = 2\n        factors = set()\n        while i * i &lt;= n:\n            while (n % i) == 0:\n                factors.add(i)\n                n //= i\n            i += 1\n        if n &gt; 1:\n            factors.add(n)\n        return factors\n\n    factor_map = defaultdict(list)  # factor -&gt; [nums]\n    for num in nums:\n        factors = prime_factors(num)\n        for factor in factors:\n            factor_map[factor].append(num)\n\n    for factor, group in factor_map.items():\n        for i in range(1, len(group)):\n            union(group[0], group[i])\n\n    sizes = defaultdict(int)  # component root -&gt; size\n    for num in nums:\n        root = find(num)\n        sizes[root] += 1\n\n    return max(sizes.values())\n\n\nnums = [20, 50, 9, 63]\nprint(largestComponentSize(nums))  # 2\n</code></pre>"},{"location":"LeetPattern/graph_union_find/#839-similar-string-groups","title":"839. Similar String Groups","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Depth First Search, Breadth First Search, Union Find</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef numSimilarGroups(strs: List[str]) -&gt; int:\n    n = len(strs)\n    parent = list(range(n))\n    rank = [0 for _ in range(n)]\n\n    def find(n):\n        p = parent[n]\n        while parent[p] != p:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    def is_similar(s1, s2):\n        diff = 0\n        for c1, c2 in zip(s1, s2):\n            if c1 != c2:\n                diff += 1\n            if diff &gt; 2:\n                return False\n        return True\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_similar(strs[i], strs[j]):\n                union(i, j)\n\n    return sum(find(i) == i for i in range(n))\n\n\nstrs = [\"tars\", \"rats\", \"arts\", \"star\"]\nprint(numSimilarGroups(strs))  # 2\n</code></pre>"},{"location":"LeetPattern/graph_union_find/#305-number-of-islands-ii","title":"305. Number of Islands II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Union Find</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef numIslands2(m: int, n: int, positions: List[List[int]]) -&gt; List[int]:\n    parent = defaultdict(tuple)\n    islands = 0\n    result = []\n    visited = set()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def find(node):\n        p = parent[node]\n        while parent[p] != p:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            parent[p1] = p2\n            return True\n        return False\n\n    for r, c in positions:\n        if (r, c) in visited:\n            result.append(islands)\n            continue\n\n        islands += 1\n        parent[(r, c)] = (r, c)\n        visited.add((r, c))\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if (nr, nc) in visited:\n                if union((r, c), (nr, nc)):\n                    islands -= 1\n\n        result.append(islands)\n\n    return result\n\n\nm = 3\nn = 3\npositions = [[0, 0], [0, 1], [1, 2], [2, 1]]\nprint(numIslands2(m, n, positions))  # [1, 1, 2, 3]\n</code></pre>"},{"location":"LeetPattern/graph_union_find/#1202-smallest-string-with-swaps","title":"1202. Smallest String With Swaps","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Depth First Search, Breadth First Search, Union Find, Sorting</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef smallestStringWithSwaps(s: str, pairs: List[List[int]]) -&gt; str:\n    n = len(s)\n    par = list(range(n))\n    components = defaultdict(list)\n\n    def find(node):\n        p = par[node]\n        while par[p] != p:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 != p2:\n            par[p1] = p2\n\n    for index, j in pairs:\n        union(index, j)\n\n    for index in range(n):\n        components[find(index)].append(index)\n\n    res = list(s)\n    for indices in components.values():\n        chars = sorted([s[index] for index in indices])\n        for index, char in zip(indices, chars):\n            res[index] = char\n\n    return \"\".join(res)\n\n\ns = \"dcab\"\npairs = [[0, 3], [1, 2]]\nprint(smallestStringWithSwaps(s, pairs))  # \"bacd\"\n</code></pre>"},{"location":"LeetPattern/graph_union_find/#685-redundant-connection-ii","title":"685. Redundant Connection II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Union Find, Graph</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Union Find\ndef findRedundantDirectedConnectionUF(edges: List[List[int]]) -&gt; List[int]:\n    n = len(edges)\n    uf = UnionFind(n + 1)\n    parent = list(range(n + 1))\n    candidates = []\n\n    for u, v in edges:\n        if parent[v] != v:\n            candidates.append([parent[v], v])\n            candidates.append([u, v])\n        else:\n            parent[v] = u\n\n    if not candidates:\n        for u, v in edges:\n            if not uf.union(u, v):\n                return [u, v]\n\n    for u, v in edges:\n        if [u, v] == candidates[1]:\n            continue\n        if not uf.union(u, v):\n            return candidates[0]\n\n    return candidates[1]\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(1, n + 1)}\n\n    def find(self, n):\n        p = self.par[n]\n        while p != self.par[p]:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n        if p1 == p2:\n            return False\n        self.par[p1] = p2\n        return True\n\n\nedges = [[1, 2], [1, 3], [2, 3]]\nprint(findRedundantDirectedConnectionUF(edges))\n</code></pre>"},{"location":"LeetPattern/graph_union_find/#399-evaluate-division","title":"399. Evaluate Division","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Depth First Search, Breadth First Search, Union Find, Graph, Shortest Path</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef calcEquation(\n    equations: List[List[str]], values: List[float], queries: List[List[str]]\n) -&gt; List[float]:\n    graph = defaultdict(dict)\n    for (a, b), v in zip(equations, values):\n        graph[a][b] = v\n        graph[b][a] = 1 / v\n\n    def dfs(a, b, visited):\n        if a not in graph or b not in graph:\n            return -1.0\n\n        if b in graph[a]:\n            return graph[a][b]\n\n        for c in graph[a]:\n            if c not in visited:\n                visited.add(c)\n                d = dfs(c, b, visited)\n                if d != -1.0:\n                    return graph[a][c] * d\n        return -1.0\n\n    result = []\n    for a, b in queries:\n        result.append(dfs(a, b, set()))\n\n    return result\n\n\nequations = [[\"a\", \"b\"], [\"b\", \"c\"]]\nvalues = [2.0, 3.0]\nqueries = [[\"a\", \"c\"], [\"b\", \"a\"], [\"a\", \"e\"], [\"a\", \"a\"], [\"x\", \"x\"]]\nprint(calcEquation(equations, values, queries))  # [6.0, 0.5, -1.0, 1.0, -1.0]\n</code></pre>"},{"location":"LeetPattern/graph_union_find/#1101-the-earliest-moment-when-everyone-become-friends","title":"1101. The Earliest Moment When Everyone Become Friends \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Union Find, Sorting</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Union Find\ndef earliestAcq(logs: List[List[int]], n: int) -&gt; int:\n    logs.sort()\n    par = {i: i for i in range(n)}\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    for time, a, b in logs:\n        pa, pb = find(a), find(b)\n        if pa != pb:\n            par[pa] = pb\n            n -= 1\n        if n == 1:\n            return time\n    return -1\n\n\nlogs = [[0, 2, 0], [1, 0, 1], [3, 0, 3], [4, 1, 2], [7, 3, 1]]\nn = 4\nprint(earliestAcq(logs, n))  # 3\n</code></pre>"},{"location":"LeetPattern/greedy/","title":"Greedy","text":""},{"location":"LeetPattern/greedy/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 455. Assign Cookies (Easy)</li> <li> 1005. Maximize Sum Of Array After K Negations (Easy)</li> <li> 860. Lemonade Change (Easy)</li> <li> 2037. Minimum Number of Moves to Seat Everyone (Easy)</li> <li> 376. Wiggle Subsequence (Medium)</li> <li> 738. Monotone Increasing Digits (Medium)</li> <li> 122. Best Time to Buy and Sell Stock II (Medium)</li> <li> 714. Best Time to Buy and Sell Stock with Transaction Fee (Medium)</li> <li> 135. Candy (Hard)</li> <li> 406. Queue Reconstruction by Height (Medium)</li> <li> 3075. Maximize Happiness of Selected Children (Medium)</li> <li> 945. Minimum Increment to Make Array Unique (Medium)</li> <li> 53. Maximum Subarray (Medium)</li> <li> 134. Gas Station (Medium)</li> <li> 968. Binary Tree Cameras (Hard)</li> <li> 1589. Maximum Sum Obtained of Any Permutation (Medium)</li> </ul>"},{"location":"LeetPattern/greedy/#455-assign-cookies","title":"455. Assign Cookies","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Greedy, Sorting</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the maximum number of your content children that can be satisfied.\n\"\"\"\n\nfrom typing import List\n\n\n# Greedy\ndef findContentChildren(g: List[int], s: List[int]) -&gt; int:\n    g.sort()\n    s.sort()\n    i, j = 0, 0\n\n    while i &lt; len(g) and j &lt; len(s):\n        if g[i] &lt;= s[j]:\n            i += 1\n        j += 1\n\n    return i\n\n\n# |-------------|-------------|--------------|\n# |   Approach  |    Time     |    Space     |\n# |-------------|-------------|--------------|\n# |   Greedy    | O(N * logN) |    O(1)      |\n# |-------------|-------------|--------------|\n\n\ng = [1, 2, 3]\ns = [1, 1]\nprint(findContentChildren(g, s))  # 1\n</code></pre>"},{"location":"LeetPattern/greedy/#1005-maximize-sum-of-array-after-k-negations","title":"1005. Maximize Sum Of Array After K Negations","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the maximum sum of the array after changing at most `k` elements.\n\"\"\"\n\nfrom heapq import heapify, heapreplace\nfrom typing import List\n\n\n# Greedy\ndef largestSumAfterKNegationsGreedy(nums: List[int], k: int) -&gt; int:\n    nums.sort(key=abs, reverse=True)\n\n    for i in range(len(nums)):\n        if nums[i] &lt; 0 and k &gt; 0:\n            nums[i] *= -1\n            k -= 1\n\n    if k % 2:\n        nums[-1] *= -1\n\n    return sum(nums)\n\n\n# Heap\ndef largestSumAfterKNegationsHeap(nums: List[int], k: int) -&gt; int:\n    heapify(nums)\n\n    while k and nums[0] &lt; 0:\n        heapreplace(nums, -nums[0])\n        k -= 1\n\n    if k % 2:\n        heapreplace(nums, -nums[0])\n\n    return sum(nums)\n\n\nprint(largestSumAfterKNegationsGreedy([4, 2, 3], 1))  # 5\nprint(largestSumAfterKNegationsHeap([4, 2, 3], 1))\n</code></pre>"},{"location":"LeetPattern/greedy/#860-lemonade-change","title":"860. Lemonade Change","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return `True` if and only if you can provide every customer with correct change.\n\"\"\"\n\nfrom typing import List\n\n\n# Greedy\ndef lemonadeChange(bills: List[int]) -&gt; bool:\n    hashmap = {5: 0, 10: 0, 20: 0}\n\n    for i in bills:\n        if i == 5:\n            hashmap[5] += 1\n\n        if i == 10:\n            if hashmap[5] &lt; 1:\n                return False\n\n            hashmap[5] -= 1\n            hashmap[10] += 1\n\n        if i == 20:\n            if hashmap[5] &gt;= 1 and hashmap[10] &gt;= 1:\n                hashmap[5] -= 1\n                hashmap[10] -= 1\n                hashmap[20] += 1\n\n            elif hashmap[5] &gt;= 3:\n                hashmap[5] -= 3\n                hashmap[20] += 1\n\n            else:\n                return False\n\n    return True\n\n\nprint(lemonadeChange([5, 5, 5, 10, 20]))  # True\n</code></pre>"},{"location":"LeetPattern/greedy/#2037-minimum-number-of-moves-to-seat-everyone","title":"2037. Minimum Number of Moves to Seat Everyone","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting, Counting Sort</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the minimum number of moves needed to seat everyone.\n\"\"\"\n\nfrom typing import List\n\n\n# Greedy\ndef minMovesToSeat(seats: List[int], students: List[int]) -&gt; int:\n    seats.sort()\n    students.sort()\n    moves = 0\n\n    for i, j in zip(seats, students):\n        moves += abs(i - j)\n\n    return moves\n\n\nprint(minMovesToSeat([3, 1, 5], [2, 7, 4]))  # 4\n</code></pre>"},{"location":"LeetPattern/greedy/#376-wiggle-subsequence","title":"376. Wiggle Subsequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the length of the longest wiggle subsequence.\n-   `up[n]` stores the length of the longest wiggle subsequence ending at `n` with a rising wiggle.\n-   `down[n]` stores the length of the longest wiggle subsequence ending at `n` with a falling wiggle.\n-   Initialize `up[0] = 1` and `down[0] = 1`.\n-   Example: `nums = [1, 7, 4, 9, 2, 5]`\n\n| `nums[n]` | `nums[n-1]` | `up[n-1]` | `down[n-1]` | `up[n]` | `down[n]` |\n| :-------: | :---------: | :-------: | :---------: | :-----: | :-------: |\n|     1     |      -      |     -     |      -      |    1    |     1     |\n|     7     |      1      |     1     |      1      |    2    |     1     |\n|     4     |      7      |     2     |      1      |    2    |     3     |\n|     9     |      4      |     2     |      3      |    4    |     3     |\n|     2     |      9      |     4     |      3      |    4    |     5     |\n|     5     |      2      |     4     |      5      |    6    |     5     |\n\"\"\"\n\nfrom typing import List\n\n\n# DP\ndef wiggleMaxLengthDP(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 1:\n        return len(nums)\n\n    up = [0 for _ in range(len(nums))]\n    down = [0 for _ in range(len(nums))]\n\n    up[0], down[0] = 1, 1\n\n    for i in range(1, len(nums)):\n        if nums[i] &gt; nums[i - 1]:\n            up[i] = down[i - 1] + 1\n            down[i] = down[i - 1]\n        elif nums[i] &lt; nums[i - 1]:\n            down[i] = up[i - 1] + 1\n            up[i] = up[i - 1]\n        else:\n            up[i] = up[i - 1]\n            down[i] = down[i - 1]\n\n    return max(up[-1], down[-1])\n\n\n# Greedy\ndef wiggleMaxLengthGreedy(nums: List[int]) -&gt; int:\n    if len(nums) &lt; 2:\n        return len(nums)\n\n    prev_diff = nums[1] - nums[0]\n    count = 2 if prev_diff != 0 else 1\n\n    for i in range(2, len(nums)):\n        diff = nums[i] - nums[i - 1]\n        if (diff &gt; 0 and prev_diff &lt;= 0) or (diff &lt; 0 and prev_diff &gt;= 0):\n            count += 1\n            prev_diff = diff\n\n    return count\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    DP       |      O(n)       |     O(n)     |\n# |  Greedy     |      O(n)       |     O(1)     |\n# |-------------|-----------------|--------------|\n\nnums = [1, 7, 4, 9, 2, 5]\nprint(wiggleMaxLengthDP(nums))  # 6\nprint(wiggleMaxLengthGreedy(nums))  # 6\n</code></pre>"},{"location":"LeetPattern/greedy/#738-monotone-increasing-digits","title":"738. Monotone Increasing Digits","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Greedy</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the largest number that is less than or equal to `n` with monotone increasing digits.\n\"\"\"\n\n\n# Greedy\ndef monotoneIncreasingDigits(n: int) -&gt; int:\n    strNum = list(str(n))\n\n    for i in range(len(strNum) - 2, -1, -1):\n        if int(strNum[i]) &gt; int(strNum[i + 1]):\n            strNum[i] = str(int(strNum[i]) - 1)\n            strNum[i + 1 :] = [\"9\"] * (len(strNum) - (i + 1))\n\n    return int(\"\".join(strNum))\n\n\nn = 332\nprint(monotoneIncreasingDigits(n))  # 299\n</code></pre>"},{"location":"LeetPattern/greedy/#122-best-time-to-buy-and-sell-stock-ii","title":"122. Best Time to Buy and Sell Stock II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return the maximum profit you can achieve.\n\"\"\"\n\nfrom typing import List\n\n\n# DP\ndef maxProfitDP1(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 2 for _ in range(n)]\n    dp[0][0] = -prices[0]\n    dp[0][1] = 0\n\n    for i in range(1, n):\n        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i])\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# DP - Optimized\ndef maxProfitDP2(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    hold = -prices[0]\n    profit = 0\n\n    for i in range(1, n):\n        hold = max(hold, profit - prices[i])\n        profit = max(profit, hold + prices[i])\n\n    return profit\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    profit = 0\n\n    for i in range(1, len(prices)):\n        profit += max(prices[i] - prices[i - 1], 0)\n\n    return profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |     DP1    |  O(n)  |   O(n)  |\n# |     DP2    |  O(n)  |   O(1)  |\n# |   Greedy   |  O(n)  |   O(1)  |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitDP1(prices))  # 7\nprint(maxProfitDP2(prices))  # 7\nprint(maxProfitGreedy(prices))  # 7\n</code></pre> <pre><code>#include &lt;array&gt;\n#include &lt;cassert&gt;\n#include &lt;climits&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int maxProfitMemo(vector&lt;int&gt;&amp; prices) {\n        int n = prices.size();\n        vector&lt;array&lt;int, 2&gt;&gt; memo(n, {-1, -1});\n\n        auto dfs = [&amp;](this auto&amp;&amp; dfs, int i, bool hold) -&gt; int {\n            if (i &lt; 0) {\n                return hold ? INT_MIN : 0;\n            }\n            int&amp; res = memo[i][hold];\n            if (res != -1) {\n                return res;\n            }\n            if (hold) {\n                return res = max(dfs(i - 1, true),                // skip\n                                 dfs(i - 1, false) - prices[i]);  // buy\n            } else {\n                return res = max(dfs(i - 1, false),              // skip\n                                 dfs(i - 1, true) + prices[i]);  // sell\n            }\n        };\n\n        return dfs(n - 1, false);\n    }\n\n    int maxProfitIterative(vector&lt;int&gt;&amp; prices) {\n        int n = prices.size();\n        vector&lt;array&lt;int, 2&gt;&gt; dp(n, {0, 0});\n        dp[0][0] = -prices[0];\n        dp[0][1] = 0;\n\n        for (int i = 1; i &lt; n; i++) {\n            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);  // buy\n            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);  // sell\n        }\n        return dp[n - 1][1];\n    }\n\n    int maxProfitIterativeOptimized(vector&lt;int&gt;&amp; prices) {\n        int n = prices.size();\n        if (n &lt;= 1) return 0;\n\n        int hold = -prices[0], res = 0;\n\n        for (int i = 1; i &lt; n; i++) {\n            hold = max(hold, res - prices[i]);  // buy\n            res = max(res, hold + prices[i]);   // sell\n        }\n        return res;\n    }\n\n    int maxProfitGreedy(vector&lt;int&gt;&amp; prices) {\n        int n = prices.size();\n        if (n &lt;= 1) return 0;\n\n        int res = 0;\n\n        for (int i = 1; i &lt; n; i++) {\n            if (prices[i] &gt; prices[i - 1]) {\n                res += prices[i] - prices[i - 1];\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; prices = {7, 1, 5, 3, 6, 4};\n    assert(solution.maxProfitMemo(prices) == 7);\n    assert(solution.maxProfitIterative(prices) == 7);\n    assert(solution.maxProfitIterativeOptimized(prices) == 7);\n    assert(solution.maxProfitGreedy(prices) == 7);\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/greedy/#714-best-time-to-buy-and-sell-stock-with-transaction-fee","title":"714. Best Time to Buy and Sell Stock with Transaction Fee","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the maximum profit you can achieve with the given transaction fee.\n\"\"\"\n\nfrom typing import List\n\n\n# 1. DP\ndef maxProfitDP(prices: List[int], fee: int) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 2 for _ in range(n)]\n\n    dp[0][0] = -prices[0] - fee\n    dp[0][1] = 0\n\n    for i in range(1, n):\n        dp[i][0] = max(\n            dp[i - 1][0],  # hold\n            dp[i - 1][1] - prices[i] - fee,  # buy\n        )\n        dp[i][1] = max(\n            dp[i - 1][1],  # hold\n            dp[i - 1][0] + prices[i],  # sell\n        )\n\n    return max(dp[-1])\n\n\n# 2. Greedy\ndef maxProfitGreedy(prices: List[int], fee: int) -&gt; int:\n    n = len(prices)\n    if n == 0:\n        return 0\n\n    buy = prices[0]\n    profit = 0\n\n    for i in range(1, n):\n        if prices[i] &lt; buy:\n            buy = prices[i]\n        elif prices[i] &gt; buy + fee:\n            profit += prices[i] - buy - fee\n            buy = prices[i] - fee\n\n    return profit\n\n\nprices = [1, 3, 2, 8, 4, 9]\nfee = 2\nprint(maxProfitDP(prices, fee))  # 8\nprint(maxProfitGreedy(prices, fee))  # 8\n</code></pre>"},{"location":"LeetPattern/greedy/#135-candy","title":"135. Candy","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the minimum number of candies you must give.\n\"\"\"\n\nfrom typing import List\n\n\n# Greedy\ndef candy(ratings: List[int]) -&gt; int:\n    # TC: O(n)\n    # SC: O(n)\n    n = len(ratings)\n\n    if n &lt;= 1:\n        return n\n\n    candy = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        if ratings[i] &gt; ratings[i - 1]:\n            candy[i] = candy[i - 1] + 1\n\n    for j in range(n - 2, -1, -1):\n        if ratings[j] &gt; ratings[j + 1]:\n            candy[j] = max(candy[j], candy[j + 1] + 1)\n\n    return sum(candy)\n\n\nratings = [1, 0, 2]\nprint(candy(ratings))  # 5\n</code></pre>"},{"location":"LeetPattern/greedy/#406-queue-reconstruction-by-height","title":"406. Queue Reconstruction by Height","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Indexed Tree, Segment Tree, Sorting</p> </li> </ul> Python <pre><code>\"\"\"\n-   Reconstruct the queue.\n\"\"\"\n\nfrom typing import List\n\n\n# Greedy\ndef reconstructQueue(people: List[List[int]]) -&gt; List[List[int]]:\n    queue = []\n    people.sort(key=lambda x: (-x[0], x[1]))\n\n    for i in people:\n        queue.insert(i[1], i)\n\n    return queue\n\n\npeople = [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nprint(reconstructQueue(people))\n# [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]\n</code></pre>"},{"location":"LeetPattern/greedy/#3075-maximize-happiness-of-selected-children","title":"3075. Maximize Happiness of Selected Children","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul> Python <pre><code>from typing import List\n\n\nclass maximumHappinessSum:\n    @staticmethod\n    def greedy(happiness: List[int], k: int) -&gt; int:\n        happiness.sort(reverse=True)\n        res = 0\n        i = 0\n\n        while i &lt; k:\n            if happiness[i] &lt;= i:\n                break\n            res += happiness[i] - i\n            i += 1\n\n        return res\n\n\nif __name__ == \"__main__\":\n    assert maximumHappinessSum.greedy([1, 2, 3], 2) == 4\n    assert maximumHappinessSum.greedy([5, 1, 3, 7], 3) == 12\n</code></pre>"},{"location":"LeetPattern/greedy/#945-minimum-increment-to-make-array-unique","title":"945. Minimum Increment to Make Array Unique","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting, Counting</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Greedy\ndef minIncrementForUnique(nums: List[int]) -&gt; int:\n    nums.sort()\n    moves = 0\n\n    for i in range(1, len(nums)):\n        if nums[i] &lt;= nums[i - 1]:\n            moves += nums[i - 1] + 1 - nums[i]\n            nums[i] = nums[i - 1] + 1\n\n    return moves\n\n\nnums = [1, 2, 2]\nprint(minIncrementForUnique(nums))  # 1\n</code></pre>"},{"location":"LeetPattern/greedy/#53-maximum-subarray","title":"53. Maximum Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Divide And Conquer, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP Kadane\ndef maxSubArrayDP(nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n\n    dp[0] = nums[0]\n    maxSum = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(\n            dp[i - 1] + nums[i],  # continue the previous subarray\n            nums[i],  # start a new subarray\n        )\n        maxSum = max(maxSum, dp[i])\n\n    return maxSum\n\n\n# Greedy\ndef maxSubArrayGreedy(nums: List[int]) -&gt; int:\n    max_sum = nums[0]\n    cur_sum = 0\n\n    for num in nums:\n        cur_sum = max(cur_sum + num, num)\n        max_sum = max(max_sum, cur_sum)\n\n    return max_sum\n\n\n# Prefix Sum\ndef maxSubArrayPrefixSum(nums: List[int]) -&gt; int:\n    prefix_sum = 0\n    prefix_sum_min = 0\n    res = float(\"-inf\")\n\n    for num in nums:\n        prefix_sum += num\n        res = max(res, prefix_sum - prefix_sum_min)\n        prefix_sum_min = min(prefix_sum_min, prefix_sum)\n\n    return res\n\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArrayDP(nums))  # 6\nprint(maxSubArrayGreedy(nums))  # 6\nprint(maxSubArrayPrefixSum(nums))  # 6\n</code></pre>"},{"location":"LeetPattern/greedy/#134-gas-station","title":"134. Gas Station","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\nclass canCompleteCircuit:\n    def greedy(self, gas: List[int], cost: List[int]) -&gt; int:\n        \"\"\"\n        Approach: Greedy\n        Time Complexity: O(n)\n        Space Complexity: O(1)\n        \"\"\"\n\n        # edge case\n        if sum(gas) &lt; sum(cost):\n            return -1\n\n        cur_sum = 0\n        start = 0\n\n        for i in range(len(gas)):\n            cur_sum += gas[i] - cost[i]\n\n            if cur_sum &lt; 0:\n                start = i + 1\n                cur_sum = 0\n\n        return start\n\n\nif __name__ == \"__main__\":\n    solution = canCompleteCircuit()\n    gas = [1, 2, 3, 4, 5]\n    cost = [3, 4, 5, 1, 2]\n    assert solution.greedy(gas, cost) == 3\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) {\n        int totalTank = 0, currTank = 0;\n        int start = 0;\n        int n = gas.size();\n\n        for (int i = 0; i &lt; n; i++) {\n            int diff = gas[i] - cost[i];\n            totalTank += diff;\n            currTank += diff;\n\n            if (currTank &lt; 0) {\n                start = i + 1;\n                currTank = 0;\n            }\n        }\n\n        return (totalTank &gt;= 0) ? start : -1;\n    }\n};\n\nint main() {\n    Solution obj;\n    vector&lt;int&gt; gas{1, 2, 3, 4, 5};\n    vector&lt;int&gt; cost{3, 4, 5, 1, 2};\n    int res = obj.canCompleteCircuit(gas, cost);\n    assert(res == 3);\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/greedy/#968-binary-tree-cameras","title":"968. Binary Tree Cameras","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Tree, Depth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef minCameraCover(root: Optional[TreeNode]) -&gt; int:\n    res = 0\n\n    def dfs(node, hasParent):\n        if not node:\n            return -1\n\n        nonlocal res\n        left, right = dfs(node.left, True), dfs(node.right, True)\n\n        if left == -1 and right == -1:\n            if hasParent:\n                return 0\n            res += 1\n            return 2\n        if left == 0 or right == 0:\n            res += 1\n            return 2\n        if left == 2 or right == 2:\n            return 1\n        if hasParent:\n            return 0\n        res += 1\n        return 2\n\n    dfs(root, False)\n\n    return res\n\n\nroot = build([0, 0, None, 0, 0])\nprint(root)\nprint(minCameraCover(root))  # 1\n</code></pre>"},{"location":"LeetPattern/greedy/#1589-maximum-sum-obtained-of-any-permutation","title":"1589. Maximum Sum Obtained of Any Permutation","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting, Prefix Sum</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Greedy\ndef maxSumRangeQuery(nums: List[int], requests: List[List[int]]) -&gt; int:\n    n = len(nums)\n    freq = [0 for _ in range(n + 1)]\n\n    for start, end in requests:\n        freq[start] += 1\n        if end + 1 &lt; n:\n            freq[end + 1] -= 1\n\n    for i in range(1, n):\n        freq[i] += freq[i - 1]\n\n    freq.pop()\n\n    freq.sort(reverse=True)\n    nums.sort(reverse=True)\n\n    max_sum = 0\n    mod = 10**9 + 7\n\n    for i, j in zip(nums, freq):\n        max_sum += i * j\n        max_sum %= mod\n\n    return max_sum\n\n\nnums = [1, 2, 3, 4, 5]\nrequests = [[1, 3], [0, 1]]\nprint(maxSumRangeQuery(nums, requests))  # 19\n</code></pre>"},{"location":"LeetPattern/hash_counting/","title":"Hash Counting","text":""},{"location":"LeetPattern/hash_counting/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 242. Valid Anagram (Easy)</li> <li> 560. Subarray Sum Equals K (Medium)</li> <li> 49. Group Anagrams (Medium)</li> <li> 438. Find All Anagrams in a String (Medium)</li> </ul>"},{"location":"LeetPattern/hash_counting/#242-valid-anagram","title":"242. Valid Anagram","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sorting</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return true if an input string is an anagram of another string.\n-   An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once, e.g., `listen` is an anagram of `silent`.\n\"\"\"\n\nfrom collections import Counter\n\n\n# Hashmap\ndef isAnagramHash(s: str, t: str) -&gt; bool:\n    \"\"\"Return True if t is an anagram of s, False otherwise.\"\"\"\n    if len(s) != len(t):\n        return False\n\n    count = dict()\n\n    for i in s:\n        if i in count:\n            count[i] += 1\n        else:\n            count[i] = 1\n\n    for j in t:\n        if j in count:\n            count[j] -= 1\n        else:\n            return False\n\n    for count in count.values():\n        if count != 0:\n            return False\n\n    return True\n\n\n# Array\ndef isAnagramArray(s: str, t: str) -&gt; bool:\n    if len(s) != len(t):\n        return False\n\n    count = [0 for _ in range(26)]\n\n    for i in s:\n        count[ord(i) - ord(\"a\")] += 1\n\n    for j in t:\n        count[ord(j) - ord(\"a\")] -= 1\n\n    for i in count:\n        if i != 0:\n            return False\n\n    return True\n\n\n# Counter\ndef isAnagramCounter(s: str, t: str) -&gt; bool:\n    return Counter(s) == Counter(t)\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |   Hashmap   |       O(n)      |     O(1)     |\n# |    Array    |       O(n)      |     O(1)     |\n# |   Counter   |       O(n)      |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\ns = \"anagram\"\nt = \"nagaram\"\nprint(isAnagramHash(s, t))  # True\nprint(isAnagramArray(s, t))  # True\nprint(isAnagramCounter(s, t))  # True\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool isAnagram(string s, string t) {\n        if (s.size() != t.size()) return false;\n\n        vector&lt;int&gt; count(26, 0);\n\n        for (char ch : s) count[ch - 'a']++;\n        for (char ch : t) count[ch - 'a']--;\n        for (int c : count) {\n            if (c != 0) return false;\n        }\n\n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n    assert(solution.isAnagram(\"anagram\", \"nagaram\") == true);\n    assert(solution.isAnagram(\"rat\", \"car\") == false);\n    assert(solution.isAnagram(\"a\", \"ab\") == false);\n    assert(solution.isAnagram(\"a\", \"a\") == true);\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/hash_counting/#560-subarray-sum-equals-k","title":"560. Subarray Sum Equals K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Prefix Sum</p> </li> </ul> PythonCPP <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Prefix Sum\ndef subarraySum(nums: List[int], k: int) -&gt; int:\n    preSums = defaultdict(int)\n    preSums[0] = 1\n    curSum = 0\n    res = 0\n\n    for num in nums:\n        curSum += num\n        res += preSums[curSum - k]\n        preSums[curSum] += 1\n\n    return res\n\n\nnums = [1, 1, 1]\nk = 2\nprint(subarraySum(nums, k))  # 2\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint subarraySum(vector&lt;int&gt;&amp; nums, int k) {\n    int n = nums.size();\n    vector&lt;int&gt; prefixSum(n + 1);\n    for (int i = 0; i &lt; n; i++) {\n        prefixSum[i + 1] = prefixSum[i] + nums[i];\n    }\n\n    int res = 0;\n    unordered_map&lt;int, int&gt; cnt;\n\n    for (int ps : prefixSum) {\n        if (cnt.find(ps - k) != cnt.end()) res += cnt[ps - k];\n        cnt[ps]++;\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {1, 1, 1};\n    int k = 2;\n    cout &lt;&lt; subarraySum(nums, k) &lt;&lt; endl;  // 2\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/hash_counting/#49-group-anagrams","title":"49. Group Anagrams","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Sorting</p> </li> </ul> PythonCPP <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash - List\ndef groupAnagrams(strs: List[str]) -&gt; List[List[str]]:\n    result = defaultdict(list)\n\n    for s in strs:\n        count = [0] * 26\n        for i in s:\n            count[ord(i) - ord(\"a\")] += 1\n\n        result[tuple(count)].append(s)\n\n    return list(result.values())\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Hash     |     O(n * k)    |     O(n)     |\n# |-------------|-----------------|--------------|\n\n\nstrs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\nprint(groupAnagrams(strs))\n# [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;cassert&gt;\n#include &lt;ranges&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Solution {\n   public:\n    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) {\n        unordered_map&lt;string, vector&lt;string&gt;&gt; map;\n\n        for (string&amp; s : strs) {\n            string sorted = s;\n            ranges::sort(sorted);\n            map[sorted].push_back(s);\n        }\n\n        vector&lt;vector&lt;string&gt;&gt; res;\n\n        for (auto&amp; kv : map) {\n            res.push_back(kv.second);\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;string&gt; strs = {\"eat\", \"tea\", \"tan\"};\n    vector&lt;vector&lt;string&gt;&gt; res = solution.groupAnagrams(strs);\n    assert((res == vector&lt;vector&lt;string&gt;&gt;{{\"eat\", \"tea\"}, {\"tan\"}} ||\n            res == vector&lt;vector&lt;string&gt;&gt;{{\"tan\"}, {\"eat\", \"tea\"}}));\n\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/hash_counting/#438-find-all-anagrams-in-a-string","title":"438. Find All Anagrams in a String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Sliding Window Fixed Size\ndef findAnagrams(s: str, p: str) -&gt; List[int]:\n    n, k = len(s), len(p)\n    target = [0 for _ in range(26)]\n    for ch in p:\n        target[ord(ch) - ord(\"a\")] += 1\n\n    count = [0 for _ in range(26)]\n    left = 0\n    res = []\n\n    for right in range(n):\n        count[ord(s[right]) - ord(\"a\")] += 1\n        if right &lt; k - 1:\n            continue\n\n        if count == target:\n            res.append(left)\n\n        count[ord(s[left]) - ord(\"a\")] -= 1\n        left += 1\n\n    return res\n\n\ns = \"cbaebabacd\"\np = \"abc\"\nprint(findAnagrams(s, p))  # [0, 6]\n</code></pre>"},{"location":"LeetPattern/hash_map/","title":"Hash Map","text":""},{"location":"LeetPattern/hash_map/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 383. Ransom Note (Easy)</li> <li> 350. Intersection of Two Arrays II (Easy)</li> <li> 1. Two Sum (Easy)</li> <li> 409. Longest Palindrome (Easy)</li> <li> 1365. How Many Numbers Are Smaller Than the Current Number (Easy)</li> <li> 202. Happy Number (Easy)</li> <li> 454. 4Sum II (Medium)</li> </ul>"},{"location":"LeetPattern/hash_map/#383-ransom-note","title":"383. Ransom Note","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Counting</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return `True` if the ransom note can be constructed from the magazines, otherwise, return `False`.\n\"\"\"\n\nfrom collections import Counter, defaultdict\n\n\n# Array\ndef canConstructArray(ransomNote: str, magazine: str) -&gt; bool:\n    if len(ransomNote) &gt; len(magazine):\n        return False\n\n    record = [0 for _ in range(26)]\n\n    for i in magazine:\n        record[ord(i) - ord(\"a\")] += 1\n\n    for j in ransomNote:\n        record[ord(j) - ord(\"a\")] -= 1\n\n    for i in record:\n        if i &lt; 0:\n            return False\n\n    return True\n\n\n# Dict\ndef canConstructDict(ransomNote: str, magazine: str) -&gt; bool:\n    if len(ransomNote) &gt; len(magazine):\n        return False\n\n    record = defaultdict(int)\n\n    for i in magazine:\n        record[i] += 1\n\n    for j in ransomNote:\n        if j not in record or record[j] == 0:\n            return False\n        record[j] -= 1\n\n    return True\n\n\n# Counter\ndef canConstructCounter(ransomNote: str, magazine: str) -&gt; bool:\n    return not Counter(ransomNote) - Counter(magazine)\n\n\nransomNote = \"aa\"\nmagazine = \"aab\"\nprint(canConstructArray(ransomNote, magazine))  # True\nprint(canConstructDict(ransomNote, magazine))  # True\nprint(canConstructCounter(ransomNote, magazine))  # True\n</code></pre>"},{"location":"LeetPattern/hash_map/#350-intersection-of-two-arrays-ii","title":"350. Intersection of Two Arrays II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Two Pointers, Binary Search, Sorting</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the intersection of two arrays.\n\"\"\"\n\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Hashmap\ndef intersect(nums1: List[int], nums2: List[int]) -&gt; List[int]:\n    hashmap = defaultdict(int)  # {num: count}\n    result = []\n\n    for i in nums1:\n        hashmap[i] += 1\n\n    for i in nums2:\n        if hashmap[i] &gt; 0:\n            result.append(i)\n            hashmap[i] -= 1\n\n    return result\n\n\n# |-------------|-------------|--------------|\n# |   Approach  |    Time     |    Space     |\n# |-------------|-------------|--------------|\n# |   Hashmap   |   O(n + m)  | O(min(n, m)) |\n# |-------------|-------------|--------------|\n\nnums1 = [1, 2, 2, 1]\nnums2 = [2, 2]\nprint(intersect(nums1, nums2))  # [2, 2]\n</code></pre>"},{"location":"LeetPattern/hash_map/#1-two-sum","title":"1. Two Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return the indices of the two numbers such that they add up to a specific target.\n- Approach: Use a hashmap to store the indices of the numbers.\n- Time Complexity: O(n)\n- Space Complexity: O(n)\n\"\"\"\n\nfrom typing import List\n\n\ndef two_sum(nums: List[int], target: int) -&gt; List[int]:\n    hashmap = {}  # val: idx\n\n    for idx, val in enumerate(nums):\n        if (target - val) in hashmap:\n            return [hashmap[target - val], idx]\n\n        hashmap[val] = idx\n\n    return []\n\n\ndef test_two_sum():\n    assert two_sum([2, 7, 11, 15], 9) == [0, 1]\n    assert two_sum([3, 2, 4], 6) == [1, 2]\n    assert two_sum([3, 3], 6) == [0, 1]\n    assert two_sum([1, 2, 3, 4, 5], 10) == []\n    assert two_sum([-1, -2, -3, -4, -5], -8) == [2, 4]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Solution {\n   public:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {\n        unordered_map&lt;int, int&gt; map;\n\n        for (size_t i = 0; i &lt; nums.size(); i++) {\n            int diff = target - nums[i];\n            if (map.find(diff) != map.end()) {\n                return {map[diff], (int)i};\n            }\n            map[nums[i]] = (int)i;\n        }\n        return {-1, -1};\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; nums = {2, 7, 11, 15};\n    int target = 9;\n    vector&lt;int&gt; result = solution.twoSum(nums, target);\n    assert((result == vector&lt;int&gt;{0, 1}));\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/hash_map/#409-longest-palindrome","title":"409. Longest Palindrome","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Greedy</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the length of the longest palindrome that can be built with the characters in the string.\n\"\"\"\n\n\ndef longestPalindrome(s: str) -&gt; int:\n    hashmap = dict()\n    result = 0\n\n    for char in s:\n        if char not in hashmap or hashmap[char] == 0:\n            hashmap[char] = 1\n        else:\n            result += 2\n            hashmap[char] = 0\n\n    if any(hashmap.values()):\n        result += 1\n\n    return result\n\n\nprint(longestPalindrome(\"abccccdd\"))  # 7\n</code></pre>"},{"location":"LeetPattern/hash_map/#1365-how-many-numbers-are-smaller-than-the-current-number","title":"1365. How Many Numbers Are Smaller Than the Current Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Sorting, Counting</p> </li> </ul> Python <pre><code>\"\"\"\n-   For each number in the array, return how many numbers are smaller than it.\n\"\"\"\n\nfrom typing import List\n\n\ndef smallerNumbersThanCurrent(nums: List[int]) -&gt; List[int]:\n    sortedNums = sorted(nums)\n\n    hashmap = dict()\n\n    for i, num in enumerate(sortedNums):\n        if num not in hashmap:\n            hashmap[num] = i\n\n    result = []\n    for i in range(len(sortedNums)):\n        result.append(hashmap[nums[i]])\n\n    return result\n\n\nnums = [8, 1, 2, 2, 3]\nprint(smallerNumbersThanCurrent(nums))  # [4, 0, 1, 1, 3]\n</code></pre>"},{"location":"LeetPattern/hash_map/#202-happy-number","title":"202. Happy Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Math, Two Pointers</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return `True` if the number is a happy number, otherwise, return `False`.\n-   A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.\n\"\"\"\n\n\ndef isHappy(n: int) -&gt; bool:\n\n    def getSum(n):\n        sum_of_squares = 0\n        while n:\n            a, b = divmod(n, 10)\n            sum_of_squares += b**2\n            n = a\n        return sum_of_squares\n\n    record = set()\n\n    while True:\n        if n == 1:\n            return True\n\n        if n in record:\n            return False\n        else:\n            record.add(n)\n\n        n = getSum(n)\n\n\nn = 19\nprint(isHappy(n))  # True\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;unordered_set&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int getNext(int n) {\n        int res = 0;\n        while (n) {\n            int mod = n % 10;\n            res += mod * mod;\n            n /= 10;\n        }\n        return res;\n    }\n\n    bool isHappy(int n) {\n        unordered_set&lt;int&gt; seen;\n        while (n != 1) {\n            n = getNext(n);\n            if (seen.find(n) != seen.end()) return false;\n            seen.insert(n);\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution s;\n    assert(s.isHappy(19) == true);\n    assert(s.isHappy(2) == false);\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/hash_map/#454-4sum-ii","title":"454. 4Sum II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the number of tuples `(i, j, k, l)` such that `A[i] + B[j] + C[k] + D[l] == 0`.\n\"\"\"\n\nfrom collections import defaultdict\nfrom typing import List\n\n\ndef fourSumCount(\n    nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]\n) -&gt; int:\n\n    sumAB = defaultdict(int)\n    result = 0\n\n    for i in nums1:\n        for j in nums2:\n            sumAB[i + j] += 1\n\n    for i in nums3:\n        for j in nums4:\n            if -(i + j) in sumAB:\n                result += sumAB[-(i + j)]\n\n    return result\n\n\nnums1 = [1, 2]\nnums2 = [-2, -1]\nnums3 = [-1, 2]\nnums4 = [0, 2]\nprint(fourSumCount(nums1, nums2, nums3, nums4))  # 2\n</code></pre>"},{"location":"LeetPattern/hash_set/","title":"Hash Set","text":""},{"location":"LeetPattern/hash_set/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 349. Intersection of Two Arrays (Easy)</li> </ul>"},{"location":"LeetPattern/hash_set/#349-intersection-of-two-arrays","title":"349. Intersection of Two Arrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Two Pointers, Binary Search, Sorting</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Set\ndef intersectionSet(nums1: List[int], nums2: List[int]) -&gt; List[int]:\n    set1 = set(nums1)\n    set2 = set(nums2)\n    return list(set1 &amp; set2)\n\n\n# Hash\ndef intersectionHash(nums1: List[int], nums2: List[int]) -&gt; List[int]:\n    set1 = set(nums1)\n    result = set()\n\n    for num in nums2:\n        if num in set1:\n            result.add(num)\n\n    return list(result)\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |     Set    | O(n+m) |  O(n+m) |\n# |    Hash    | O(n+m) |   O(n)  |\n# |------------|--------|---------|\n\n\nnums1 = [1, 2, 2, 1]\nnums2 = [2, 2]\nprint(intersectionSet(nums1, nums2))  # [2]\nprint(intersectionHash(nums1, nums2))  # [2]\n</code></pre>"},{"location":"LeetPattern/heap/","title":"Heap","text":""},{"location":"LeetPattern/heap/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1046. Last Stone Weight (Easy)</li> </ul>"},{"location":"LeetPattern/heap/#1046-last-stone-weight","title":"1046. Last Stone Weight","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Heap Priority Queue</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Heap\n    - Time: O(n log n); Space: O(n)\n- 0/1 Knapsack\n    - Time: O(n); Space: O(n)\n\"\"\"\n\nfrom heapq import heapify, heappop, heappush\nfrom typing import List\n\n\n# Heap\ndef lastStoneWeightHeap(stones: List[int]) -&gt; int:\n    maxHeap = [-s for s in stones]\n    heapify(maxHeap)\n\n    while len(maxHeap) &gt; 1:\n        s1 = heappop(maxHeap)\n        s2 = heappop(maxHeap)\n\n        if s1 != s2:\n            heappush(maxHeap, s1 - s2)\n\n    return -maxHeap[0] if maxHeap else 0\n\n\n# 0/1 Knapsack\ndef lastStoneWeightKnapsack(stones: List[int]) -&gt; int:\n    total = sum(stones)\n    target = total // 2\n\n    dp = [0 for _ in range(target + 1)]\n\n    for i in stones:\n        for j in range(target, i - 1, -1):\n            dp[j] = max(dp[j], dp[j - i] + i)\n\n    return total - 2 * dp[target]\n\n\nif __name__ == \"__main__\":\n    stones = [2, 7, 4, 1, 8, 1]\n    assert lastStoneWeightHeap(stones) == 1\n    assert lastStoneWeightKnapsack(stones) == 1\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint lastStoneWeight(vector&lt;int&gt; &amp;stones) {\n    priority_queue&lt;int&gt; maxHeap(stones.begin(), stones.end());\n\n    // Only while there are at least two stones to smash\n    while (maxHeap.size() &gt; 1) {\n        int first = maxHeap.top();\n        maxHeap.pop();\n        int second = maxHeap.top();\n        maxHeap.pop();\n\n        if (first != second) {\n            maxHeap.push(first - second);\n        }\n    }\n\n    return maxHeap.empty() ? 0 : maxHeap.top();\n}\n\nint main() {\n    vector&lt;int&gt; stones = {2, 7, 4, 1, 8, 1};\n    cout &lt;&lt; lastStoneWeight(stones) &lt;&lt; endl;  // 1\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/heap_merge_k_sorted/","title":"Heap Merge K Sorted","text":""},{"location":"LeetPattern/heap_merge_k_sorted/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 23. Merge k Sorted Lists (Hard)</li> <li> 373. Find K Pairs with Smallest Sums (Medium)</li> <li> 378. Kth Smallest Element in a Sorted Matrix (Medium)</li> </ul>"},{"location":"LeetPattern/heap_merge_k_sorted/#23-merge-k-sorted-lists","title":"23. Merge k Sorted Lists","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Divide And Conquer, Heap Priority Queue, Merge Sort</p> </li> </ul> Python <pre><code>\"\"\"\n-   Prerequisite: 21. Merge Two Sorted Lists\n-   Video explanation: [23. Merge K Sorted Lists - NeetCode](https://youtu.be/q5a5OiGbT6Q?si=SQ2dCvsYQ3LQctPh)\n\"\"\"\n\nimport copy\nimport heapq\nfrom typing import List, Optional\n\nfrom leetpattern.utils import ListNode, list_from_array, list_to_array\n\n\ndef merge_k_lists_divide_conquer(\n    lists: List[Optional[ListNode]],\n) -&gt; Optional[ListNode]:\n    if not lists or len(lists) == 0:\n        return None\n\n    def mergeTwo(l1, l2):\n        dummy = ListNode()\n        cur = dummy\n\n        while l1 and l2:\n            if l1.val &lt; l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n\n            cur = cur.next\n\n        cur.next = l1 if l1 else l2\n\n        return dummy.next\n\n    while len(lists) &gt; 1:\n        merged = []\n\n        for i in range(0, len(lists), 2):\n            l1 = lists[i]\n            l2 = lists[i + 1] if i + 1 &lt; len(lists) else None\n            merged.append(mergeTwo(l1, l2))\n\n        lists = merged\n\n    return lists[0]\n\n\ndef merge_k_lists_heap(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    min_heap = []  # (val, idx, node)\n\n    for idx, head in enumerate(lists):\n        if head:\n            heapq.heappush(min_heap, (head.val, idx, head))\n\n    while min_heap:\n        _, idx, node = heapq.heappop(min_heap)\n        cur.next = node\n        cur = cur.next\n\n        node = node.next\n        if node:\n            heapq.heappush(min_heap, (node.val, idx, node))\n\n    return dummy.next\n\n\ndef test_merge_k_lists() -&gt; None:\n    n1 = list_from_array([1, 4])\n    n2 = list_from_array([1, 3])\n    n3 = list_from_array([2, 6])\n    lists = [n1, n2, n3]\n    lists1 = copy.deepcopy(lists)\n    lists2 = copy.deepcopy(lists)\n    assert (list_to_array(merge_k_lists_divide_conquer(lists1))) == [\n        1,\n        1,\n        2,\n        3,\n        4,\n        6,\n    ]\n    assert (list_to_array(merge_k_lists_heap(lists2))) == [1, 1, 2, 3, 4, 6]\n</code></pre>"},{"location":"LeetPattern/heap_merge_k_sorted/#373-find-k-pairs-with-smallest-sums","title":"373. Find K Pairs with Smallest Sums","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Heap Priority Queue</p> </li> </ul> Python <pre><code>import heapq\nfrom typing import List\n\n\n# Heap - Merge K Sorted\ndef kSmallestPairs(nums1: List[int], nums2: List[int], k: int) -&gt; List[List[int]]:\n    if not nums1 or not nums2 or k &lt;= 0:\n        return []\n\n    res = []\n    min_heap = []\n\n    for j in range(min(k, len(nums2))):\n        heapq.heappush(min_heap, (nums1[0] + nums2[j], 0, j))\n\n    while k &gt; 0 and min_heap:\n        _, i, j = heapq.heappop(min_heap)\n        res.append([nums1[i], nums2[j]])\n        k -= 1\n\n        if i + 1 &lt; len(nums1):\n            heapq.heappush(min_heap, (nums1[i + 1] + nums2[j], i + 1, j))\n\n    return res\n\n\nif __name__ == \"__main__\":\n    nums1 = [1, 2, 4, 5, 6]\n    nums2 = [3, 5, 7, 9]\n    k = 3\n    assert kSmallestPairs(nums1, nums2, k) == [[1, 3], [2, 3], [1, 5]]\n</code></pre>"},{"location":"LeetPattern/heap_merge_k_sorted/#378-kth-smallest-element-in-a-sorted-matrix","title":"378. Kth Smallest Element in a Sorted Matrix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Sorting, Heap Priority Queue, Matrix</p> </li> </ul> Python <pre><code>\"\"\"\n-   Given an `n x n` matrix where each of the rows and columns are sorted in ascending order, return the `k-th` smallest element in the matrix.\n\"\"\"\n\nfrom heapq import heapify, heappop, heappush\nfrom typing import List\n\n\n# Heap - Merge K Sorted\ndef kthSmallestHeap(matrix: List[List[int]], k: int) -&gt; int:\n    n = len(matrix)\n    heap = [(matrix[i][0], i, 0) for i in range(n)]\n    heapify(heap)\n\n    for _ in range(k - 1):\n        _, row, col = heappop(heap)\n\n        if col + 1 &lt; n:\n            heappush(heap, (matrix[row][col + 1], row, col + 1))\n\n    return heappop(heap)[0]\n\n\n# Binary Search\ndef kthSmallestBinarySearch(matrix: List[List[int]], k: int) -&gt; int:\n    n = len(matrix)\n\n    def check(mid):\n        i, j = n - 1, 0\n        num = 0\n\n        while i &gt;= 0 and j &lt; n:\n            if matrix[i][j] &lt;= mid:\n                num += i + 1\n                j += 1\n            else:\n                i -= 1\n\n        return num &gt;= k\n\n    left, right = matrix[0][0], matrix[-1][-1]\n\n    while left &lt; right:\n        mid = (left + right) // 2\n        if check(mid):\n            right = mid\n        else:\n            left = mid + 1\n\n    return left\n\n\nmatrix = [[1, 5, 9], [10, 11, 13], [12, 13, 15]]\nk = 8\n\nprint(kthSmallestHeap(matrix, k))  # 13\nprint(kthSmallestBinarySearch(matrix, k))  # 13\n</code></pre>"},{"location":"LeetPattern/heap_top_k/","title":"Heap Top K","text":""},{"location":"LeetPattern/heap_top_k/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 215. Kth Largest Element in an Array (Medium)</li> <li> 973. K Closest Points to Origin (Medium)</li> <li> 347. Top K Frequent Elements (Medium)</li> <li> 692. Top K Frequent Words (Medium)</li> <li> 264. Ugly Number II (Medium)</li> <li> 451. Sort Characters By Frequency (Medium)</li> <li> 703. Kth Largest Element in a Stream (Easy)</li> <li> 767. Reorganize String (Medium)</li> <li> 786. K-th Smallest Prime Fraction (Medium)</li> </ul>"},{"location":"LeetPattern/heap_top_k/#215-kth-largest-element-in-an-array","title":"215. Kth Largest Element in an Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Divide And Conquer, Sorting, Heap Priority Queue, Quickselect</p> </li> </ul> Python <pre><code>import heapq\nfrom typing import List\n\n\ndef findKthLargest(nums: List[int], k: int) -&gt; int:\n    min_heap = []\n\n    for i, num in enumerate(nums):\n        heapq.heappush(min_heap, num)\n        if i &gt;= k:\n            heapq.heappop(min_heap)\n\n    return min_heap[0]\n\n\nif __name__ == \"__main__\":\n    assert findKthLargest([3, 2, 1, 5, 6, 4], 2) == 5\n</code></pre>"},{"location":"LeetPattern/heap_top_k/#973-k-closest-points-to-origin","title":"973. K Closest Points to Origin","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Divide And Conquer, Geometry, Sorting, Heap Priority Queue, Quickselect</p> </li> </ul> Python <pre><code>import heapq\nfrom typing import List\n\n\ndef kClosest(points: List[List[int]], k: int) -&gt; List[List[int]]:\n    heap = []\n\n    for x, y in points:\n        dist = -(x**2 + y**2)  # max heap\n        if len(heap) &lt; k:\n            heapq.heappush(heap, (dist, x, y))\n        else:\n            heapq.heappushpop(heap, (dist, x, y))  # push and pop the smallest\n\n    return [[x, y] for (_, x, y) in heap]\n\n\n# Time complexity: O(n * log(k))\n#   - O(log(k)) for heapify\n#   - O(n) for iterating through the input list\n# Space complexity: O(k)\n\npoints = [[1, 3], [-2, 2]]\nk = 1\nprint(kClosest(points, k))  # [[-2, 2]]\n</code></pre>"},{"location":"LeetPattern/heap_top_k/#347-top-k-frequent-elements","title":"347. Top K Frequent Elements","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Divide And Conquer, Sorting, Heap Priority Queue, Bucket Sort, Counting, Quickselect</p> </li> </ul> Python <pre><code>import heapq\nfrom collections import Counter\nfrom typing import List\n\n\n# Heap + Counter\ndef topKFrequent(nums: List[int], k: int) -&gt; List[int]:\n    minHeap = []\n\n    for val, freq in Counter(nums).items():\n        if len(minHeap) &lt; k:\n            heapq.heappush(minHeap, (freq, val))\n        else:\n            heapq.heappushpop(minHeap, (freq, val))\n\n    return [i for _, i in minHeap]\n\n\n# Counter (Most Common)\ndef topKFrequentCounter(nums: List[int], k: int) -&gt; List[int]:\n    commons = Counter(nums).most_common(k)\n    return [i for i, _ in commons]\n\n\nnums = [1, 1, 1, 2, 2, 3]\nk = 2\nprint(topKFrequent(nums, k))  # [1, 2]\nprint(topKFrequentCounter(nums, k))  # [1, 2]\n</code></pre>"},{"location":"LeetPattern/heap_top_k/#692-top-k-frequent-words","title":"692. Top K Frequent Words","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Trie, Sorting, Heap Priority Queue, Bucket Sort, Counting</p> </li> </ul> Python <pre><code>import heapq\nfrom collections import Counter\nfrom typing import List\n\n\nclass WordFrequency:\n    def __init__(self, word, freq):\n        self.word = word\n        self.freq = freq\n\n    def __lt__(self, other):\n        # If the frequency is different\n        if self.freq != other.freq:\n            # The word with the lower frequency comes first\n            return self.freq &lt; other.freq\n        else:\n            # The word with the lower alphabetical order comes first\n            return self.word &gt; other.word\n\n\ndef topKFrequent(words: List[str], k: int) -&gt; List[str]:\n    heap = []\n\n    for word, freq in Counter(words).items():\n        heapq.heappush(heap, WordFrequency(word, freq))\n\n        if len(heap) &gt; k:\n            heapq.heappop(heap)\n\n    heap.sort(reverse=True)\n    return [x.word for x in heap]\n\n\nwords = [\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"]\nk = 2\nprint(topKFrequent(words, k))  # [\"i\", \"love\"]\n</code></pre>"},{"location":"LeetPattern/heap_top_k/#264-ugly-number-ii","title":"264. Ugly Number II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Math, Dynamic Programming, Heap Priority Queue</p> </li> </ul> Python <pre><code>import heapq\n\n\ndef nthUglyNumber(n: int) -&gt; int:\n    heap = [1]\n    seen = set(heap)\n\n    factors = [2, 3, 5]\n    current = 1\n\n    # Pop the smallest ugly number n times\n    for _ in range(n):\n        current = heapq.heappop(heap)  # Pop the smallest ugly number\n\n        for factor in factors:\n            new = current * factor\n            if new not in seen:\n                seen.add(new)\n                heapq.heappush(heap, new)\n\n    return current\n\n\nprint(nthUglyNumber(10))  # 12\n</code></pre>"},{"location":"LeetPattern/heap_top_k/#451-sort-characters-by-frequency","title":"451. Sort Characters By Frequency","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sorting, Heap Priority Queue, Bucket Sort, Counting</p> </li> </ul> Python <pre><code>import heapq\nfrom collections import Counter\n\n\ndef frequencySort(s: str) -&gt; str:\n    result = \"\"\n\n    # Max Heap\n    heap = [(-freq, val) for val, freq in Counter(s).items()]\n    heapq.heapify(heap)\n\n    while heap:\n        freq, val = heapq.heappop(heap)\n        result += val * -freq\n\n    return result\n\n\nprint(frequencySort(\"tree\"))  # eert\n</code></pre>"},{"location":"LeetPattern/heap_top_k/#703-kth-largest-element-in-a-stream","title":"703. Kth Largest Element in a Stream","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Design, Binary Search Tree, Heap Priority Queue, Binary Tree, Data Stream</p> </li> </ul> Python <pre><code>import heapq\nfrom typing import List\n\n\n# Heap\nclass KthLargest:\n\n    def __init__(self, k: int, nums: List[int]):\n        self.k = k\n        self.heap = []\n        for num in nums:\n            self.add(num)\n\n    def add(self, val: int) -&gt; int:\n        heapq.heappush(self.heap, val)\n\n        if len(self.heap) &gt; self.k:\n            heapq.heappop(self.heap)\n\n        return self.heap[0]\n\n\nobj = KthLargest(3, [4, 5, 8, 2])\nprint(obj.add(3))  # 4\nprint(obj.add(5))  # 5\nprint(obj.add(10))  # 5\n</code></pre>"},{"location":"LeetPattern/heap_top_k/#767-reorganize-string","title":"767. Reorganize String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Greedy, Sorting, Heap Priority Queue, Counting</p> </li> </ul> Python <pre><code>import heapq\nfrom collections import Counter\n\n\ndef reorganizeString(s: str) -&gt; str:\n    if not s:\n        return \"\"\n\n    heap = [(-freq, char) for char, freq in Counter(s).items()]  # max heap\n    heapq.heapify(heap)\n\n    result = []\n    prev_count, prev_char = 0, \"\"\n\n    while heap:\n        count, char = heapq.heappop(heap)  # pop the most frequent character\n        result.append(char)  # append the character to the result\n\n        if prev_count &lt; 0:  # if the previous character still has remaining count\n            heapq.heappush(heap, (prev_count, prev_char))\n\n        prev_count = count + 1  # update the current character's remaining count\n        prev_char = char  # update the current character\n\n    # check if there is any invalid result\n    if len(result) != len(s):\n        return \"\"\n\n    return \"\".join(result)\n\n\nprint(reorganizeString(\"aab\"))\n</code></pre>"},{"location":"LeetPattern/heap_top_k/#786-k-th-smallest-prime-fraction","title":"786. K-th Smallest Prime Fraction","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Sorting, Heap Priority Queue</p> </li> </ul> Python <pre><code>import heapq\nfrom typing import List\n\n\ndef kthSmallestPrimeFraction(arr: List[int], k: int) -&gt; List[int]:\n    max_heap = []\n\n    for j in range(1, len(arr)):\n        for i in range(j):\n            heapq.heappush(max_heap, (-arr[i] / arr[j], arr[i], arr[j]))\n\n            if len(max_heap) &gt; k:\n                heapq.heappop(max_heap)\n\n    return [max_heap[0][1], max_heap[0][2]]\n\n\narr = [1, 2, 3, 5]\nk = 3\nprint(kthSmallestPrimeFraction(arr, k))  # [2, 5]\n</code></pre>"},{"location":"LeetPattern/heap_two_heaps/","title":"Heap Two Heaps","text":""},{"location":"LeetPattern/heap_two_heaps/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 295. Find Median from Data Stream (Hard)</li> <li> 480. Sliding Window Median (Hard)</li> <li> 502. IPO (Hard)</li> </ul>"},{"location":"LeetPattern/heap_two_heaps/#295-find-median-from-data-stream","title":"295. Find Median from Data Stream","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, Design, Sorting, Heap Priority Queue, Data Stream</p> </li> </ul> PythonCPP <pre><code>from heapq import heappop, heappush\n\n\nclass MedianFinder:\n\n    def __init__(self):\n        self.minHeap = []\n        self.maxHeap = []\n        self.min_size = 0\n        self.max_size = 0\n\n    def addNum(self, num: int) -&gt; None:\n        heappush(self.maxHeap, -num)\n        heappush(self.minHeap, -heappop(self.maxHeap))\n        self.min_size += 1\n\n        if self.min_size &gt; self.max_size:\n            heappush(self.maxHeap, -heappop(self.minHeap))\n            self.min_size -= 1\n            self.max_size += 1\n\n    def findMedian(self) -&gt; float:\n        if self.min_size == self.max_size:\n            return (-self.maxHeap[0] + self.minHeap[0]) / 2.0\n        return float(-self.maxHeap[0])\n\n\ndef test_median_finder():\n    obj = MedianFinder()\n    obj.addNum(1)\n    obj.addNum(2)\n    assert obj.findMedian() == 1.5\n    obj.addNum(3)\n    assert obj.findMedian() == 2.0\n    obj.addNum(4)\n    assert obj.findMedian() == 2.5\n    obj.addNum(5)\n    assert obj.findMedian() == 3.0\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass MedianFinder {\n   private:\n    priority_queue&lt;int&gt; maxHeap;\n    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;\n    int max_size = 0;\n    int min_size = 0;\n\n   public:\n    MedianFinder() {}\n\n    void addNum(int num) {\n        if (min_size == max_size) {\n            minHeap.push(num);\n            maxHeap.push(minHeap.top());\n            minHeap.pop();\n            max_size++;\n        } else {\n            maxHeap.push(num);\n            minHeap.push(maxHeap.top());\n            maxHeap.pop();\n            min_size++;\n        }\n    }\n\n    double findMedian() {\n        if (min_size == max_size) {\n            return (maxHeap.top() + minHeap.top()) / 2.0;\n        } else {\n            return (double)maxHeap.top();\n        }\n    }\n};\n\nint main() {\n    MedianFinder* obj = new MedianFinder();\n    obj-&gt;addNum(1);\n    obj-&gt;addNum(2);\n    cout &lt;&lt; obj-&gt;findMedian() &lt;&lt; endl;  // 1.5\n    obj-&gt;addNum(3);\n    cout &lt;&lt; obj-&gt;findMedian() &lt;&lt; endl;  // 2\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/heap_two_heaps/#480-sliding-window-median","title":"480. Sliding Window Median","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Sliding Window, Heap Priority Queue</p> </li> </ul> Python <pre><code>import heapq\nfrom typing import List\n\nfrom sortedcontainers import SortedList\n\n\n# Heap - Two Heaps\ndef medianSlidingWindow1(nums: List[int], k: int) -&gt; List[float]:\n    min_heap, max_heap = [], []\n\n    for i in range(k):\n        heapq.heappush(min_heap, (nums[i], i))\n    for i in range(k // 2):\n        n, idx = heapq.heappop(min_heap)\n        heapq.heappush(max_heap, (-n, idx))\n\n    res = [(min_heap[0][0] - max_heap[0][0]) / 2 if k % 2 == 0 else min_heap[0][0] * 1.0]\n\n    for i in range(k, len(nums)):\n        if nums[i] &lt; min_heap[0][0]:\n            heapq.heappush(max_heap, (-nums[i], i))\n\n            if nums[i - k] &gt;= min_heap[0][0]:\n                n, idx = heapq.heappop(max_heap)\n                heapq.heappush(min_heap, (-n, idx))\n        else:\n            heapq.heappush(min_heap, (nums[i], i))\n\n            if nums[i - k] &lt;= min_heap[0][0]:\n                n, idx = heapq.heappop(min_heap)\n                heapq.heappush(max_heap, (-n, idx))\n\n        while min_heap and min_heap[0][1] &lt;= i - k:\n            heapq.heappop(min_heap)\n        while max_heap and max_heap[0][1] &lt;= i - k:\n            heapq.heappop(max_heap)\n\n        res.append(\n            (min_heap[0][0] - max_heap[0][0]) / 2 if k % 2 == 0 else min_heap[0][0] * 1.0\n        )\n\n    return res\n\n\n# Sorted List\ndef medianSlidingWindow2(nums: List[int], k: int) -&gt; List[float]:\n    window = SortedList()\n    res = []\n\n    for i in range(len(nums)):\n        window.add(nums[i])\n\n        if len(window) == k:\n            if k % 2 == 1:\n                res.append(window[k // 2])\n            else:\n                res.append((window[k // 2 - 1] + window[k // 2]) / 2.0)\n\n            window.remove(nums[i - k + 1])\n\n    return res\n\n\nnums = [1, 2, 3, 4, 2, 3, 1, 4, 2]\nk = 3\nprint(medianSlidingWindow1(nums, k))\nprint(medianSlidingWindow2(nums, k))\n</code></pre>"},{"location":"LeetPattern/heap_two_heaps/#502-ipo","title":"502. IPO","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting, Heap Priority Queue</p> </li> </ul> Python <pre><code>import heapq\nfrom typing import List\n\n\n# Heap - Two Heaps\ndef findMaximizedCapital(k: int, w: int, profits: List[int], capital: List[int]) -&gt; int:\n    \"\"\"\n    Time Complexity: O(k log N)\n    Space Complexity: O(N)\n    \"\"\"\n    if not profits or not capital:\n        return w\n\n    if w &gt;= max(capital) and k &gt;= len(capital):\n        return sum(profits) + w\n\n    max_profit = []\n    min_capital = [(c, p) for c, p in zip(capital, profits)]\n    heapq.heapify(min_capital)\n\n    for _ in range(k):\n        while min_capital and min_capital[0][0] &lt;= w:\n            _, pro = heapq.heappop(min_capital)\n            heapq.heappush(max_profit, -pro)\n\n        if max_profit:\n            w += -heapq.heappop(max_profit)\n\n    return w\n\n\nif __name__ == \"__main__\":\n    k = 2\n    w = 0\n    profits = [1, 2, 3]\n    capital = [0, 1, 1]\n    assert findMaximizedCapital(k, w, profits, capital) == 4\n</code></pre>"},{"location":"LeetPattern/intervals/","title":"Intervals","text":""},{"location":"LeetPattern/intervals/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 55. Jump Game (Medium)</li> <li> 45. Jump Game II (Medium)</li> <li> 452. Minimum Number of Arrows to Burst Balloons (Medium)</li> <li> 435. Non-overlapping Intervals (Medium)</li> <li> 763. Partition Labels (Medium)</li> <li> 56. Merge Intervals (Medium)</li> </ul>"},{"location":"LeetPattern/intervals/#55-jump-game","title":"55. Jump Game","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return `True` if you can reach the last index, otherwise `False`.\n\"\"\"\n\nfrom typing import List\n\n\n# Greedy - Interval\ndef canJump(nums: List[int]) -&gt; bool:\n    n = len(nums)\n    reach = 0\n    i = 0\n\n    while reach &gt;= i:\n        if reach &gt;= n - 1:\n            return True\n        reach = max(reach, i + nums[i])\n        i += 1\n\n    return False\n\n\nif __name__ == \"__main__\":\n    assert canJump([2, 3, 1, 1, 4]) is True\n    assert canJump([3, 2, 1, 0, 4]) is False\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool canJump(vector&lt;int&gt;&amp; nums) {\n        int canReach = 0;\n        int n = nums.size();\n\n        for (int i = 0; i &lt; n; i++) {\n            if (i &gt; canReach) return false;\n            canReach = max(canReach, i + nums[i]);\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution obj;\n    vector&lt;int&gt; nums = {2, 3, 1, 1, 4};\n    cout &lt;&lt; obj.canJump(nums) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/intervals/#45-jump-game-ii","title":"45. Jump Game II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy</p> </li> </ul> Python <pre><code>\"\"\"\n- Return the minimum number of jumps to reach the last index.\n\"\"\"\n\nfrom typing import List\n\n\n# Greedy - Interval\ndef jump(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n == 1:\n        return 0\n\n    reach = 0\n    left, right = 0, 0\n    res = 0\n\n    while right &lt; n - 1:\n        for i in range(left, right + 1):\n            reach = max(reach, i + nums[i])\n\n        left = right + 1\n        right = reach\n        res += 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert jump([2, 3, 1, 1, 4]) == 2\n    assert jump([2, 3, 0, 1, 4]) == 2\n</code></pre>"},{"location":"LeetPattern/intervals/#452-minimum-number-of-arrows-to-burst-balloons","title":"452. Minimum Number of Arrows to Burst Balloons","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the minimum number of arrows.\n\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/lPmkKnvNPrw?si=P0rkcvTOxRGoFpkG\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen&gt;&lt;/iframe&gt;\n\n-   Differece between two versions\n    1. Start from 1: if there is no overlap, we add one more arrow.\n    2. Start from the number of balloons: if there is overlap, we need to reduce one arrow.\n\"\"\"\n\nfrom typing import List\n\nimport matplotlib.pyplot as plt\n\n\n# Greedy - Interval\ndef findMinArrowShotsGreedy1(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    if n &lt;= 1:\n        return n\n\n    res = 1\n    points.sort(key=lambda x: x[0])\n\n    for i in range(1, n):\n        if points[i][0] &gt; points[i - 1][1]:\n            res += 1\n        else:\n            points[i][1] = min(points[i][1], points[i - 1][1])\n    return res\n\n\n# Greedy - Interval (Neetcode's version)\ndef findMinArrowShotsGreedy2(points: List[List[int]]) -&gt; int:\n    res = len(points)\n    if res == 0:\n        return 0\n\n    points.sort()\n    prev = points[0]\n\n    for i in range(1, len(points)):\n        cur = points[i]\n        if cur[0] &lt;= prev[1]:\n            res -= 1\n            prev = [cur[0], min(prev[1], cur[1])]\n        else:\n            prev = cur\n\n    return res\n\n\n# Greedy - Interval\ndef findMinArrowShotsGreedy3(points: List[List[int]]) -&gt; int:\n    if not points:\n        return 0\n\n    points.sort(key=lambda x: x[1])\n\n    res = 1\n    cur_end = points[0][1]\n\n    for i in range(1, len(points)):\n        if points[i][0] &gt; cur_end:\n            res += 1\n            cur_end = points[i][1]\n\n    return res\n\n\n# Utility\ndef plot(points, i=None):\n    plt.figure(figsize=(8, 4))\n    for idx in range(len(points)):\n        color = \"b\" if idx == i else \"k\"\n        plt.plot(\n            [points[idx][0], points[idx][1]],\n            [idx + 1, idx + 1],\n            f\"{color}o-\",\n            label=f\"Line {idx + 1}\",\n        )\n\n    plt.title(\"Find Min Arrow Shots\")\n    plt.xlabel(\"X-axis\")\n    plt.xlim(0, 17)\n    plt.grid(True)\n    plt.savefig(f\"find_min_arrow_shots_{i}.png\")\n    plt.show()\n\n\n# |------------|-----------|---------|\n# |  Approach  |  Time     |  Space  |\n# |------------|-----------|---------|\n# |  Greedy    |  O(NlogN) |  O(1)   |\n# |------------|-----------|---------|\n\n\npoints = [[10, 16], [2, 8], [1, 6], [7, 12]]\nprint(findMinArrowShotsGreedy1(points))  # 2\nprint(findMinArrowShotsGreedy2(points))  # 2\n</code></pre>"},{"location":"LeetPattern/intervals/#435-non-overlapping-intervals","title":"435. Non-overlapping Intervals","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy, Sorting</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef eraseOverlapIntervals(intervals: List[List[int]]) -&gt; int:\n    if len(intervals) &lt;= 1:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n    result = 0\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &gt;= intervals[i - 1][1]:\n            continue\n        else:\n            result += 1\n            intervals[i][1] = min(intervals[i][1], intervals[i - 1][1])\n\n    return result\n\n\nprint(eraseOverlapIntervals([[1, 2], [2, 3], [3, 4], [1, 3]]))  # 1\n</code></pre>"},{"location":"LeetPattern/intervals/#763-partition-labels","title":"763. Partition Labels","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Two Pointers, String, Greedy</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# 1. Hashmap\ndef partitionLabels1(s: str) -&gt; List[int]:\n    hashmap = {}\n\n    for i, j in enumerate(s):\n        if j not in hashmap:\n            hashmap[j] = [i, i]\n        else:\n            hashmap[j][1] = i\n\n    intervals = list(hashmap.values())\n    intervals.sort(key=lambda x: x[0])\n\n    if len(intervals) &lt; 2:\n        return len(intervals)\n\n    res = []\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &lt; intervals[i - 1][1]:\n            intervals[i][1] = max(intervals[i][1], intervals[i - 1][1])\n        else:\n            res.append(intervals[i][0])\n\n    res.append(intervals[-1][1] + 1)\n\n    if len(res) == 1:\n        return res\n    else:\n        for i in range(len(res) - 1, 0, -1):\n            res[i] -= res[i - 1]\n        return res\n\n\n# Single Pass Partitioning\ndef partitionLabels2(s: str) -&gt; List[int]:\n    last = {c: i for i, c in enumerate(s)}\n    res = []\n    start, end = 0, 0\n\n    for i, c in enumerate(s):\n        end = max(end, last[c])\n        if end == i:\n            res.append(end - start + 1)\n            start = i + 1\n\n    return res\n\n\nprint(partitionLabels1(\"abaccd\"))  # [3, 2, 1]\nprint(partitionLabels2(\"abaccd\"))  # [3, 2, 1]\n</code></pre>"},{"location":"LeetPattern/intervals/#56-merge-intervals","title":"56. Merge Intervals","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sorting</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Merge all overlapping intervals.\n\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/44H3cEC2fFM?si=J-Jr_Fg2eDse3-de\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen&gt;&lt;/iframe&gt;\n\"\"\"\n\nfrom typing import List\n\n\n# Intervals\ndef merge(intervals: List[List[int]]) -&gt; List[List[int]]:\n    n = len(intervals)\n    if n &lt;= 1:\n        return intervals\n\n    intervals.sort(key=lambda x: x[0])\n    res = [intervals[0]]\n\n    for i in range(1, n):\n        if intervals[i][0] &lt;= res[-1][1]:\n            res[-1][1] = max(res[-1][1], intervals[i][1])\n        else:\n            res.append(intervals[i])\n\n    return res\n\n\nprint(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))\n# [[1, 6], [8, 10], [15, 18]]\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// Interval\nvector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {\n    sort(intervals.begin(), intervals.end());\n    vector&lt;vector&lt;int&gt;&gt; res;\n\n    for (auto&amp; range : intervals) {\n        if (!res.empty() &amp;&amp; range[0] &lt;= res.back()[1]) {\n            res.back()[1] = max(res.back()[1], range[1]);\n        } else {\n            res.emplace_back(range);\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;vector&lt;int&gt;&gt; intervals = {{1, 3}, {2, 6}, {8, 10}, {15, 18}};\n    vector&lt;vector&lt;int&gt;&gt; res = merge(intervals);\n    for (auto&amp; range : res) {\n        cout &lt;&lt; range[0] &lt;&lt; \", \" &lt;&lt; range[1] &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/kmp/","title":"KMP","text":""},{"location":"LeetPattern/kmp/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 28. Find the Index of the First Occurrence in a String (Easy)</li> <li> 459. Repeated Substring Pattern (Easy)</li> <li> 686. Repeated String Match (Medium)</li> <li> 1392. Longest Happy Prefix (Hard)</li> <li> 214. Shortest Palindrome (Hard)</li> </ul>"},{"location":"LeetPattern/kmp/#28-find-the-index-of-the-first-occurrence-in-a-string","title":"28. Find the Index of the First Occurrence in a String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, String Matching</p> </li> </ul> Python <pre><code>from leetpattern.utils import LPS\n\n\n# Brute Force\ndef strStrBF(haystack: str, needle: str) -&gt; int:\n    m, n = len(haystack), len(needle)\n    for i in range(m - n + 1):\n        if haystack[i : i + n] == needle:\n            return i\n    return -1\n\n\n# KMP\ndef strStrKMP(haystack: str, needle: str) -&gt; int:\n    lps = LPS(needle)\n    m, n = len(haystack), len(needle)\n    j = 0\n\n    for i in range(m):\n        while j &gt; 0 and haystack[i] != needle[j]:\n            j = lps[j - 1]\n        if haystack[i] == needle[j]:\n            j += 1\n        if j == n:\n            return i - n + 1\n    return -1\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# | Brute Force| O((m - n) * n)   | O(1)    |\n# | KMP        | O(m + n)         | O(n)    |\n# |------------|------------------|---------|\n\n\nhaystack = \"hello\"\nneedle = \"ll\"\nprint(strStrBF(haystack, needle))  # 2\nprint(strStrKMP(haystack, needle))  # 2\n</code></pre>"},{"location":"LeetPattern/kmp/#459-repeated-substring-pattern","title":"459. Repeated Substring Pattern","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, String Matching</p> </li> </ul> Python <pre><code>from leetpattern.utils import LPS\n\n\n# KMP\ndef repeatedSubstringPattern(s: str) -&gt; bool:\n    lps = LPS(s)\n    length = len(s)\n\n    if lps[-1] != 0 and length % (length - lps[-1]) == 0:\n        return True\n\n    return False\n\n\ns = \"abab\"\nprint(repeatedSubstringPattern(s))  # True\n</code></pre>"},{"location":"LeetPattern/kmp/#686-repeated-string-match","title":"686. Repeated String Match","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, String Matching</p> </li> </ul> Python <pre><code>import math\n\nfrom leetpattern.utils import LPS\n\n\n# KMP\ndef repeatedStringMatch(a: str, b: str) -&gt; int:\n    min_repeat = math.ceil(len(b) / len(a))\n\n    def kmp(text, pattern):\n        n, m = len(text), len(pattern)\n        lps = LPS(pattern)\n        j = 0\n\n        for i in range(n):\n            while j &gt; 0 and text[i] != pattern[j]:\n                j = lps[j - 1]\n            if text[i] == pattern[j]:\n                j += 1\n            if j == m:\n                return i - j + 1\n        return -1\n\n    for i in range(min_repeat, min_repeat + 2):\n        if kmp(a * i, b) != -1:\n            return i\n    return -1\n\n\nprint(repeatedStringMatch(\"abcd\", \"cdabcdab\"))  # 3\n</code></pre>"},{"location":"LeetPattern/kmp/#1392-longest-happy-prefix","title":"1392. Longest Happy Prefix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Rolling Hash, String Matching, Hash Function</p> </li> </ul> Python <pre><code>from leetpattern.utils import LPS\n\n\n# KMP\ndef longestPrefix(s: str) -&gt; str:\n    if len(s) &lt;= 1:\n        return \"\"\n\n    lps = LPS(s)\n\n    return s[: lps[-1]]\n\n\nprint(longestPrefix(\"ababab\"))  # abab\n</code></pre>"},{"location":"LeetPattern/kmp/#214-shortest-palindrome","title":"214. Shortest Palindrome","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Rolling Hash, String Matching, Hash Function</p> </li> </ul> Python <pre><code>from leetpattern.utils import LPS\n\n\n# KMP\ndef shortestPalindrome(s: str) -&gt; str:\n    if not s:\n        return s\n\n    new = s + \"#\" + s[::-1]\n    lps = LPS(new)\n\n    add_len = len(s) - lps[-1]\n\n    return s[::-1][:add_len] + s\n\n\nprint(shortestPalindrome(\"aacecaaa\"))  # aaacecaaa\n</code></pre>"},{"location":"LeetPattern/left_right_pointers/","title":"Left Right Pointers","text":""},{"location":"LeetPattern/left_right_pointers/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 9. Palindrome Number (Easy)</li> <li> 15. 3Sum (Medium)</li> <li> 18. 4Sum (Medium)</li> <li> 69. Sqrt(x) (Easy)</li> <li> 88. Merge Sorted Array (Easy)</li> <li> 977. Squares of a Sorted Array (Easy)</li> <li> 881. Boats to Save People (Medium)</li> <li> 75. Sort Colors (Medium)</li> <li> 125. Valid Palindrome (Easy)</li> <li> 167. Two Sum II - Input Array Is Sorted (Medium)</li> <li> 11. Container With Most Water (Medium)</li> </ul>"},{"location":"LeetPattern/left_right_pointers/#9-palindrome-number","title":"9. Palindrome Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return true if the given number is a palindrome. Otherwise, return false.\n\"\"\"\n\n\n# Reverse\ndef isPalindromeReverse(x: int) -&gt; bool:\n    if x &lt; 0:\n        return False\n\n    return str(x) == str(x)[::-1]\n\n\n# Left Right Pointers\ndef isPalindromeLR(x: int) -&gt; bool:\n    if x &lt; 0:\n        return False\n\n    x = list(str(x))  # 121 -&gt; ['1', '2', '1']\n\n    left, right = 0, len(x) - 1\n\n    while left &lt; right:\n        if x[left] != x[right]:\n            return False\n        left += 1\n        right -= 1\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |  Reverse   |  O(N)  |   O(N)  |\n# | Left Right |  O(N)  |   O(1)  |\n# |------------|--------|---------|\n\n\nx = 121\nprint(isPalindromeReverse(x))  # True\nprint(isPalindromeLR(x))  # True\n</code></pre>"},{"location":"LeetPattern/left_right_pointers/#15-3sum","title":"15. 3Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Sorting</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef threeSum(nums: List[int]) -&gt; List[List[int]]:\n    nums.sort()\n    res = []\n    n = len(nums)\n\n    for i in range(n - 2):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        left, right = i + 1, n - 1\n\n        while left &lt; right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total &gt; 0:\n                right -= 1\n            elif total &lt; 0:\n                left += 1\n            else:\n                res.append([nums[i], nums[left], nums[right]])\n\n                while left &lt; right and nums[left] == nums[left + 1]:\n                    left += 1\n\n                while left &lt; right and nums[right] == nums[right - 1]:\n                    right -= 1\n\n                left += 1\n                right -= 1\n\n    return res\n\n\nnums = [-1, 0, 1, 2, -1, -4]\nassert threeSum(nums) == [[-1, -1, 2], [-1, 0, 1]]\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {\n    sort(nums.begin(), nums.end());\n    vector&lt;vector&lt;int&gt;&gt; res;\n    int n = nums.size();\n\n    for (int i = 0; i &lt; n - 2; i++) {\n        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) {\n            continue;\n        }\n\n        int left = i + 1, right = n - 1;\n\n        while (left &lt; right) {\n            int total = nums[i] + nums[left] + nums[right];\n\n            if (total &gt; 0)\n                right--;\n            else if (total &lt; 0)\n                left++;\n            else {\n                res.push_back({nums[i], nums[left], nums[right]});\n                while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++;\n                while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--;\n                left++;\n                right--;\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {-1, 0, 1, 2, -1, -4};\n    vector&lt;vector&lt;int&gt;&gt; res = threeSum(nums);\n    for (auto&amp; v : res) {\n        for (int i : v) {\n            cout &lt;&lt; i &lt;&lt; \" \";\n        }\n        cout &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/left_right_pointers/#18-4sum","title":"18. 4Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Sorting</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef fourSum(nums: List[int], target: int) -&gt; List[List[int]]:\n    \"\"\"Returns all unique quadruplets that sum up to the target.\"\"\"\n    nums.sort()\n    result = []\n\n    for i in range(len(nums) - 3):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        for j in range(i + 1, len(nums) - 2):\n            if j &gt; i + 1 and nums[j] == nums[j - 1]:\n                continue\n\n            left = j + 1\n            right = len(nums) - 1\n\n            while left &lt; right:\n                total = nums[i] + nums[j] + nums[left] + nums[right]\n\n                if total &gt; target:\n                    right -= 1\n                elif total &lt; target:\n                    left += 1\n                else:\n                    result.append([nums[i], nums[j], nums[left], nums[right]])\n                    while left &lt; right and nums[left] == nums[left + 1]:\n                        left += 1\n                    while left &lt; right and nums[right] == nums[right - 1]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n\n    return result\n\n\nnums = [1, 0, -1, 0, -2, 2]\ntarget = 0\nprint(fourSum(nums, target))\n# [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]\n</code></pre>"},{"location":"LeetPattern/left_right_pointers/#69-sqrtx","title":"69. Sqrt(x)","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Binary Search</p> </li> </ul> PythonCPP <pre><code># Left Right Pointers\ndef mySqrt(x: int) -&gt; int:\n    \"\"\"Returns the square root of a number.\"\"\"\n    if x &lt; 2:\n        return x\n\n    left, right = 0, x // 2\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        if mid * mid &lt;= x &lt; (mid + 1) * (mid + 1):\n            return mid\n        elif mid * mid &lt; x:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n\nx = 8\nprint(mySqrt(x))  # 2\n</code></pre> <pre><code>#include &lt;cassert&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int mySqrt(int x) {\n        if (x &lt; 2) return x;\n        int left = 0, right = x / 2;\n        int mid = 0;\n\n        while (left &lt;= right) {\n            mid = left + (right - left) / 2;\n            long long a = 1LL * mid * mid;\n            long long b = 1LL * (mid + 1) * (mid + 1);\n\n            if (a &lt;= x &amp;&amp; x &lt; b) {\n                return mid;\n            } else if (a &lt; x)\n                left = mid + 1;\n            else\n                right = mid - 1;\n        }\n        return right;\n    }\n};\n\nint main() {\n    Solution solution;\n    assert(solution.mySqrt(4) == 2);\n    assert(solution.mySqrt(8) == 2);\n    assert(solution.mySqrt(1999) == 44);\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/left_right_pointers/#88-merge-sorted-array","title":"88. Merge Sorted Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Sorting</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\nclass merge:\n    @staticmethod\n    def lr(nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None:\n        \"\"\"\n        Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        p1, p2, t = m - 1, n - 1, m + n - 1\n\n        while p1 &gt;= 0 or p2 &gt;= 0:\n            if p1 == -1:\n                nums1[t] = nums2[p2]\n                p2 -= 1\n            elif p2 == -1:\n                nums1[t] = nums1[p1]\n                p1 -= 1\n            elif nums1[p1] &gt; nums2[p2]:\n                nums1[t] = nums1[p1]\n                p1 -= 1\n            else:\n                nums1[t] = nums2[p2]\n                p2 -= 1\n\n            t -= 1\n\n\nif __name__ == \"__main__\":\n    nums1 = [1, 2, 3, 0, 0, 0]\n    m = 3\n    nums2 = [2, 5, 6]\n    n = 3\n    merge.lr(nums1, m, nums2, n)\n    assert nums1 == [1, 2, 2, 3, 5, 6]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {\n        int p1 = m - 1, p2 = n - 1, t = m + n - 1;\n\n        while (p1 &gt;= 0 || p2 &gt;= 0) {\n            if (p1 == -1) {\n                nums1[t] = nums2[p2];\n                p2--;\n            } else if (p2 == -1) {\n                nums1[t] = nums1[p1];\n                p1--;\n            } else if (nums1[p1] &gt; nums2[p2]) {\n                nums1[t] = nums1[p1];\n                p1--;\n            } else {\n                nums1[t] = nums2[p2];\n                p2--;\n            }\n            t--;\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; nums1 = {1, 3, 6, 0, 0, 0};\n    vector&lt;int&gt; nums2 = {2, 5, 6};\n    vector&lt;int&gt; output = {1, 2, 3, 5, 6, 6};\n    solution.merge(nums1, 3, nums2, 3);\n    assert(nums1 == output);\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/left_right_pointers/#977-squares-of-a-sorted-array","title":"977. Squares of a Sorted Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Sorting</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef sortedSquares(nums: List[int]) -&gt; List[int]:\n    \"\"\"Returns the squares of the sorted array.\"\"\"\n    n = len(nums)\n    result = [0 for _ in range(n)]\n\n    left, right, tail = 0, n - 1, n - 1\n\n    while left &lt;= right:\n        if abs(nums[left]) &gt;= abs(nums[right]):\n            result[tail] = nums[left] ** 2\n            left += 1\n        else:\n            result[tail] = nums[right] ** 2\n            right -= 1\n        tail -= 1\n\n    return result\n\n\n# |---------------------|------|-------|\n# | Approach            | Time | Space |\n# |---------------------|------|-------|\n# | Left Right Pointers | O(n) | O(n)  |\n# |---------------------|------|-------|\n\n\nnums = [-4, -1, 0, 3, 10]\nprint(sortedSquares(nums))  # [0, 1, 9, 16, 100]\n</code></pre>"},{"location":"LeetPattern/left_right_pointers/#881-boats-to-save-people","title":"881. Boats to Save People","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Greedy, Sorting</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef numRescueBoats(people: List[int], limit: int) -&gt; int:\n    \"\"\"Returns the minimum number of boats to rescue people.\"\"\"\n    people.sort()\n    left, right = 0, len(people) - 1\n    boats = 0\n\n    while left &lt;= right:\n        if people[left] + people[right] &lt;= limit:\n            left += 1\n        right -= 1\n        boats += 1\n\n    return boats\n\n\npeople = [3, 2, 2, 1]\nlimit = 3\nprint(numRescueBoats(people, limit))  # 3\n</code></pre>"},{"location":"LeetPattern/left_right_pointers/#75-sort-colors","title":"75. Sort Colors","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Sorting</p> </li> </ul> Python <pre><code>from copy import deepcopy\nfrom typing import List\n\n\n# Left Right Pointers\ndef sort_colors_lr_pointers(nums: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    n = len(nums)\n    left = 0\n    for right in range(n):\n        if nums[right] == 0:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n\n    for right in range(left, n):\n        if nums[right] == 1:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n\n\n# Three Pointers\ndef sort_colors_three_pointers(nums: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    cur = 0\n\n    while cur &lt;= right:\n        if nums[cur] == 0:\n            nums[left], nums[cur] = nums[cur], nums[left]\n            left += 1\n            cur += 1\n        elif nums[cur] == 2:\n            nums[right], nums[cur] = nums[cur], nums[right]\n            right -= 1\n        else:\n            cur += 1\n\n\nnums = [2, 0, 2, 1, 1, 0]\nnums1, nums2 = deepcopy(nums), deepcopy(nums)\nsort_colors_lr_pointers(nums1)\nprint(nums1)  # [0, 0, 1, 1, 2, 2]\nsort_colors_three_pointers(nums2)\nprint(nums2)  # [0, 0, 1, 1, 2, 2]\n</code></pre>"},{"location":"LeetPattern/left_right_pointers/#125-valid-palindrome","title":"125. Valid Palindrome","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String</p> </li> </ul> Python <pre><code># List Comprehension\ndef isPalindrome(s: str) -&gt; bool:\n    s = [char.lower() for char in s if char.isalnum()]\n    return s == s[::-1]\n\n\n# Left Right Pointers\ndef isPalindromeLR(s: str) -&gt; bool:\n    left, right = 0, len(s) - 1\n\n    while left &lt; right:\n        while left &lt; right and not s[left].isalnum():\n            left += 1\n        while left &lt; right and not s[right].isalnum():\n            right -= 1\n\n        if s[left].lower() != s[right].lower():\n            return False\n\n        left += 1\n        right -= 1\n\n    return True\n\n\ns = \"A man, a plan, a canal: Panama\"\nprint(isPalindrome(s))  # True\nprint(isPalindromeLR(s))  # True\n</code></pre>"},{"location":"LeetPattern/left_right_pointers/#167-two-sum-ii-input-array-is-sorted","title":"167. Two Sum II - Input Array Is Sorted","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef twoSum(numbers: List[int], target: int) -&gt; List[int]:\n    left, right = 0, len(numbers) - 1\n\n    while left &lt; right:\n        total = numbers[left] + numbers[right]\n\n        if total &gt; target:\n            right -= 1\n        elif total &lt; target:\n            left += 1\n        else:\n            return [left + 1, right + 1]\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nnumbers = [2, 7, 11, 15]\ntarget = 9\nprint(twoSum(numbers, target))  # [1, 2]\n</code></pre>"},{"location":"LeetPattern/left_right_pointers/#11-container-with-most-water","title":"11. Container With Most Water","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Greedy</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return the maximum area of water that can be trapped between the vertical lines.\n\n![11](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)\n\"\"\"\n\nfrom typing import List\n\n\n# Brute Force\ndef maxAreaBF(height: List[int]) -&gt; int:\n    max_area = 0\n\n    for i in range(len(height)):\n        for j in range(i + 1, len(height)):\n            h = min(height[i], height[j])\n            w = j - i\n            max_area = max(max_area, h * w)\n\n    return max_area\n\n\n# Left Right Pointers\ndef maxAreaLR(height: List[int]) -&gt; int:\n    left, right = 0, len(height) - 1\n    res = 0\n\n    while left &lt; right:\n        h = min(height[left], height[right])\n        w = right - left\n        res = max(res, h * w)\n\n        if height[left] &lt; height[right]:\n            left += 1\n        else:\n            right -= 1\n\n    return res\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force| O(n^2) |  O(1)   |\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nheight = [1, 8, 6, 2, 5, 4, 8, 3, 7]\nprint(maxAreaBF(height))  # 49\nprint(maxAreaLR(height))  # 49\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint maxArea(vector&lt;int&gt;&amp; height) {\n    int left = 0, right = height.size() - 1;\n    int res = 0;\n\n    while (left &lt; right) {\n        int h = min(height[left], height[right]);\n        int w = right - left;\n        res = max(res, h * w);\n\n        if (height[left] &lt; height[right])\n            left++;\n        else\n            right--;\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; height = {1, 8, 6, 2, 5, 4, 8, 3, 7};\n    cout &lt;&lt; maxArea(height) &lt;&lt; endl;  // 49\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/linked_list/","title":"Linked List","text":""},{"location":"LeetPattern/linked_list/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 203. Remove Linked List Elements (Easy)</li> <li> 707. Design Linked List (Medium)</li> <li> 206. Reverse Linked List (Easy)</li> <li> 237. Delete Node in a Linked List (Medium)</li> <li> 2487. Remove Nodes From Linked List (Medium)</li> <li> 24. Swap Nodes in Pairs (Medium)</li> <li> 19. Remove Nth Node From End of List (Medium)</li> <li> 160. Intersection of Two Linked Lists (Easy)</li> <li> 141. Linked List Cycle (Easy)</li> <li> 142. Linked List Cycle II (Medium)</li> <li> 2816. Double a Number Represented as a Linked List (Medium)</li> <li> 2. Add Two Numbers (Medium)</li> </ul>"},{"location":"LeetPattern/linked_list/#203-remove-linked-list-elements","title":"203. Remove Linked List Elements","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Recursion</p> </li> </ul> Python <pre><code>\"\"\"\n-   Remove all elements from a linked list of integers that have value `val`.\n\"\"\"\n\nfrom typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\n# Iterative\ndef removeElements(head: Optional[ListNode], val: int) -&gt; Optional[ListNode]:\n    dummy = ListNode(0)\n    dummy.next = head\n    cur = dummy\n\n    while cur.next:\n        if cur.next.val == val:\n            cur.next = cur.next.next\n        else:\n            cur = cur.next\n\n    return dummy.next\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |  Iterative  |      O(N)       |    O(1)      |\n# |-------------|-----------------|--------------|\n\n\ndef test_removeElements():\n    # Test case 1: Remove elements from middle and end\n    nums = [1, 2, 6, 3, 4, 5, 6]\n    val = 6\n    ll = LinkedList(nums)\n    assert ll.to_array() == [1, 2, 6, 3, 4, 5, 6]\n    result = removeElements(ll.head, val)\n    ll_result = LinkedList(result)\n    assert ll_result.to_array() == [1, 2, 3, 4, 5]\n\n    # Test case 2: Remove all elements\n    ll2 = LinkedList([7, 7, 7, 7])\n    result2 = removeElements(ll2.head, 7)\n    assert result2 is None\n\n    # Test case 3: Remove elements from beginning\n    ll3 = LinkedList([1, 1, 2, 3, 4])\n    result3 = removeElements(ll3.head, 1)\n    ll_result3 = LinkedList(result3)\n    assert ll_result3.to_array() == [2, 3, 4]\n\n    # Test case 4: No elements to remove\n    ll4 = LinkedList([1, 2, 3, 4])\n    result4 = removeElements(ll4.head, 5)\n    ll_result4 = LinkedList(result4)\n    assert ll_result4.to_array() == [1, 2, 3, 4]\n</code></pre>"},{"location":"LeetPattern/linked_list/#707-design-linked-list","title":"707. Design Linked List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Design</p> </li> </ul> Python <pre><code>\"\"\"\n-   Design your implementation of the linked list. You can choose to use a singly or doubly linked list.\n\"\"\"\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass MyLinkedList:\n\n    def __init__(self):\n        self.dummy = ListNode()\n        self.size = 0\n\n    def get(self, index: int) -&gt; int:\n        if index &lt; 0 or index &gt;= self.size:\n            return -1\n\n        current = self.dummy.next\n        for _ in range(index):\n            current = current.next\n\n        return current.val\n\n    def addAtHead(self, val: int) -&gt; None:\n        self.dummy.next = ListNode(val, self.dummy.next)\n        self.size += 1\n\n    def addAtTail(self, val: int) -&gt; None:\n        current = self.dummy\n        while current.next:\n            current = current.next\n        current.next = ListNode(val)\n        self.size += 1\n\n    def addAtIndex(self, index: int, val: int) -&gt; None:\n        if index &lt; 0 or index &gt; self.size:\n            return\n\n        current = self.dummy\n        for i in range(index):\n            current = current.next\n        current.next = ListNode(val, current.next)\n        self.size += 1\n\n    def deleteAtIndex(self, index: int) -&gt; None:\n        if index &lt; 0 or index &gt;= self.size:\n            return\n\n        current = self.dummy\n        for i in range(index):\n            current = current.next\n        current.next = current.next.next\n        self.size -= 1\n\n\nll = MyLinkedList()\nll.addAtHead(1)\nll.addAtTail(3)\nll.addAtIndex(1, 2)  # 1 -&gt; 2 -&gt; 3\nprint(ll.get(1))  # 2\n</code></pre>"},{"location":"LeetPattern/linked_list/#206-reverse-linked-list","title":"206. Reverse Linked List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Recursion</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\ndef reverse_list_iterative(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    cur = head\n    prev = None\n\n    while cur:\n        temp = cur.next\n        cur.next = prev\n\n        prev = cur\n        cur = temp\n\n    return prev\n\n\ndef reverse_list_recursive(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    def reverse(cur, prev):\n        if not cur:\n            return prev\n\n        temp = cur.next\n        cur.next = prev\n        return reverse(temp, cur)\n\n    return reverse(head, None)\n\n\ndef test_reverse_list():\n    ll = LinkedList([1, 2, 3, 4, 5])\n    ll.head = reverse_list_iterative(ll.head)\n    assert ll.to_array() == [5, 4, 3, 2, 1]\n\n    ll = LinkedList([1, 2, 3, 4, 5])\n    ll.head = reverse_list_recursive(ll.head)\n    assert ll.to_array() == [5, 4, 3, 2, 1]\n</code></pre>"},{"location":"LeetPattern/linked_list/#237-delete-node-in-a-linked-list","title":"237. Delete Node in a Linked List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List</p> </li> </ul> Python <pre><code>\"\"\"\n-   Delete a node in a singly linked list. You are given only the node to be deleted.\n\"\"\"\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\ndef deleteNode(node: ListNode) -&gt; None:\n    node.val = node.next.val\n    node.next = node.next.next\n\n\ndef test_deleteNode():\n    # Test case 1: Delete middle node\n    ll = LinkedList([4, 5, 1, 9])\n    assert ll.to_array() == [4, 5, 1, 9]\n    node = ll.head.next  # node with value 5\n    deleteNode(node)\n    assert ll.to_array() == [4, 1, 9]\n\n    # Test case 2: Delete another middle node\n    ll2 = LinkedList([4, 5, 1, 9])\n    node2 = ll2.head.next.next  # node with value 1\n    deleteNode(node2)\n    assert ll2.to_array() == [4, 5, 9]\n</code></pre>"},{"location":"LeetPattern/linked_list/#2487-remove-nodes-from-linked-list","title":"2487. Remove Nodes From Linked List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Stack, Recursion, Monotonic Stack</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\ndef remove_nodes_recursive(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    if not head:\n        return None\n\n    head.next = remove_nodes_recursive(head.next)\n\n    if head.next and head.val &lt; head.next.val:\n        return head.next\n\n    return head\n\n\ndef remove_nodes_iterative(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    stack = []\n    cur = head\n\n    while cur:\n        while stack and cur.val &gt; stack[-1].val:\n            stack.pop()\n\n        stack.append(cur)\n        cur = cur.next\n\n    dummy = ListNode()\n    cur = dummy\n\n    for node in stack:\n        cur.next = node\n        cur = cur.next\n\n    return dummy.next\n\n\ndef test_remove_nodes() -&gt; None:\n    ll = LinkedList([5, 2, 13, 3, 8])\n    ll = LinkedList(remove_nodes_recursive(ll.head))\n    assert ll.to_array() == [13, 8]\n    ll = LinkedList([5, 2, 13, 3, 8])\n    ll = LinkedList(remove_nodes_iterative(ll.head))\n    assert ll.to_array() == [13, 8]\n</code></pre>"},{"location":"LeetPattern/linked_list/#24-swap-nodes-in-pairs","title":"24. Swap Nodes in Pairs","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Recursion</p> </li> </ul> Python <pre><code>\"\"\"\n-   Given a linked list, swap every two adjacent nodes and return its head.\n\"\"\"\n\nfrom typing import Optional\n\nfrom leetpattern.utils import ListNode, list_from_array, list_to_array\n\n\ndef swap_pairs(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    dummy = ListNode(0, head)\n    n0 = dummy\n    n1 = dummy.next\n\n    while n1 and n1.next:\n        n2 = n1.next\n        n3 = n2.next\n\n        n0.next = n2\n        n2.next = n1\n        n1.next = n3\n\n        n0 = n1\n        n1 = n3\n\n    return dummy.next\n\n\ndef test_swap_pairs():\n    head = list_from_array([1, 2, 3, 4, 5])\n    assert list_to_array(swap_pairs(head)) == [2, 1, 4, 3, 5]\n</code></pre>"},{"location":"LeetPattern/linked_list/#19-remove-nth-node-from-end-of-list","title":"19. Remove Nth Node From End of List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Two Pointers</p> </li> </ul> Python <pre><code>\"\"\"\n-   Given the `head` of a linked list, remove the `n-th` node from the end of the list and return its head.\n\"\"\"\n\nfrom typing import Optional\n\nfrom leetpattern.utils import ListNode, list_from_array, list_to_array\n\n\n# Linked List\ndef removeNthFromEnd(head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:\n    dummy = ListNode(0, head)\n    fast, slow = dummy, dummy\n\n    for _ in range(n):\n        fast = fast.next\n\n    while fast.next:\n        fast = fast.next\n        slow = slow.next\n\n    slow.next = slow.next.next\n\n    return dummy.next\n\n\ndef test_removeNthFromEnd() -&gt; None:\n    head = list_from_array([1, 2, 3, 4, 5])\n    assert (list_to_array(removeNthFromEnd(head, 2))) == [1, 2, 3, 5]\n</code></pre>"},{"location":"LeetPattern/linked_list/#160-intersection-of-two-linked-lists","title":"160. Intersection of Two Linked Lists","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Linked List, Two Pointers</p> </li> </ul> Python <pre><code>\"\"\"\n-   Find the node at which the intersection of two singly linked lists begins.\n\"\"\"\n\nfrom typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\n# Hash Set\ndef getIntersectionNodeHash(headA: ListNode, headB: ListNode) -&gt; Optional[ListNode]:\n    if not headA or not headB:\n        return None\n\n    visited = set()\n    cur = headA\n    while cur:\n        visited.add(cur)\n        cur = cur.next\n\n    cur = headB\n    while cur:\n        if cur in visited:\n            return cur\n        cur = cur.next\n\n    return None\n\n\n# Two Pointers\ndef getIntersectionNodeTP(headA: ListNode, headB: ListNode) -&gt; Optional[ListNode]:\n    if not headA or not headB:\n        return None\n\n    a, b = headA, headB\n\n    while a != b:\n        a = a.next if a else headB\n        b = b.next if b else headA\n\n    return a\n\n\ndef test_intersection():\n    # Test case 1: Lists with intersection\n    llA = LinkedList([4, 1, 8, 4, 5])\n    llB = LinkedList([5, 6, 1])\n\n    # Create intersection at node with value 8\n    nodeA = llA.head\n    while nodeA and nodeA.val != 8:\n        nodeA = nodeA.next\n\n    # Connect listB to the intersection point\n    llB.head.next.next.next = nodeA\n\n    assert llA.to_array() == [4, 1, 8, 4, 5]\n\n    intersection_hash = getIntersectionNodeHash(llA.head, llB.head)\n    intersection_tp = getIntersectionNodeTP(llA.head, llB.head)\n\n    assert intersection_hash is not None\n    assert intersection_tp is not None\n    assert intersection_hash.val == 8\n    assert intersection_tp.val == 8\n    assert intersection_hash == intersection_tp\n\n    # Test case 2: Lists without intersection\n    llC = LinkedList([2, 6, 4])\n    llD = LinkedList([1, 5])\n\n    intersection_hash = getIntersectionNodeHash(llC.head, llD.head)\n    intersection_tp = getIntersectionNodeTP(llC.head, llD.head)\n\n    assert intersection_hash is None\n    assert intersection_tp is None\n</code></pre>"},{"location":"LeetPattern/linked_list/#141-linked-list-cycle","title":"141. Linked List Cycle","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Linked List, Two Pointers</p> </li> </ul> PythonCPP <pre><code>from typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\ndef has_cycle(head: Optional[ListNode]) -&gt; bool:\n    slow, fast = head, head\n\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n        if slow == fast:\n            return True\n\n    return False\n\n\ndef test_has_cycle():\n    ll = LinkedList([3, 2, 0, -4])\n    ll.make_cycle(pos=1)\n    assert has_cycle(ll.head)\n\n    ll = LinkedList([1, 2])\n    ll.make_cycle(pos=0)\n    assert has_cycle(ll.head)\n\n    ll = LinkedList([1, 2, 3, 4, 5])\n    assert not has_cycle(ll.head)\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n\n#include \"include/lists.hpp\"\nusing namespace std;\n\nclass Solution {\n   public:\n    bool has_cycle(ListNode* head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while (fast &amp;&amp; fast-&gt;next) {\n            slow = slow-&gt;next;\n            fast = fast-&gt;next-&gt;next;\n\n            if (fast == slow) return true;\n        }\n        return false;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    ListNode* head = LinkedList::build({3, 2, 0, -4});\n    // create cycle\n    head = LinkedList::make_cycle(head, 1);\n    assert(solution.has_cycle(head) == true);\n    // no cycle\n    ListNode* head2 = LinkedList::build({1, 2});\n    assert(solution.has_cycle(head2) == false);\n    // no cycle\n    ListNode* head3 = LinkedList::build({1});\n    assert(solution.has_cycle(head3) == false);\n\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/linked_list/#142-linked-list-cycle-ii","title":"142. Linked List Cycle II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Linked List, Two Pointers</p> </li> </ul> PythonCPP <pre><code>from typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\ndef detectCycle(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    slow, fast = head, head\n\n    while fast and fast.next:\n        fast = fast.next.next\n        slow = slow.next\n\n        if slow == fast:\n            slow = head\n            while slow != fast:\n                slow = slow.next\n                fast = fast.next\n            return slow\n\n    return None\n\n\ndef test_detectCycle():\n    l1 = LinkedList([3, 2, 0, -4])\n    l1.make_cycle(1)\n    assert detectCycle(l1.head).val == 2\n    l2 = LinkedList([3, 2, 0, -4])\n    assert not detectCycle(l2.head)\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nclass Solution {\n   public:\n    ListNode* detectCycle(ListNode* head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while (fast &amp;&amp; fast-&gt;next) {\n            slow = slow-&gt;next;\n            fast = fast-&gt;next-&gt;next;\n\n            if (fast == slow) {\n                slow = head;\n                while (slow != fast) {\n                    slow = slow-&gt;next;\n                    fast = fast-&gt;next;\n                }\n                return slow;\n            }\n        }\n        return nullptr;\n    }\n};\n\nint main() {\n    Solution sol;\n\n    ListNode* head = new ListNode(3);\n    head-&gt;next = new ListNode(2);\n    head-&gt;next-&gt;next = new ListNode(0);\n    head-&gt;next-&gt;next-&gt;next = new ListNode(-4);\n    head-&gt;next-&gt;next-&gt;next-&gt;next = head-&gt;next;  // Create a cycle\n    assert(sol.detectCycle(head) == head-&gt;next);\n\n    ListNode* head2 = new ListNode(1);\n    head2-&gt;next = new ListNode(2);\n    head2-&gt;next-&gt;next = head2;  // Create a cycle\n    assert(sol.detectCycle(head2) == head2);\n\n    ListNode* head3 = new ListNode(1);\n    assert(sol.detectCycle(head3) == nullptr);\n\n    ListNode* head4 = nullptr;\n    assert(sol.detectCycle(head4) == nullptr);\n\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/linked_list/#2816-double-a-number-represented-as-a-linked-list","title":"2816. Double a Number Represented as a Linked List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Math, Stack</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\ndef doubleIt(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n\n    def twice(node):\n        if not node:\n            return 0\n        doubled = node.val * 2 + twice(node.next)\n        node.val = doubled % 10\n        return doubled // 10\n\n    carry = twice(head)\n\n    if carry:\n        head = ListNode(val=carry, next=head)\n\n    return head\n\n\ndef test_doubleIt() -&gt; None:\n    ll = LinkedList([9, 9, 9])\n    ll = LinkedList(doubleIt(ll.head))\n    assert ll.to_array() == [1, 9, 9, 8]\n</code></pre>"},{"location":"LeetPattern/linked_list/#2-add-two-numbers","title":"2. Add Two Numbers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Math, Recursion</p> </li> </ul> PythonCPP <pre><code>from typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\ndef add_two_numbers(l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]:\n    \"\"\"Add two numbers represented by linked lists.\"\"\"\n    dummy = ListNode()\n    cur = dummy\n    carry = 0\n\n    while l1 or l2:\n        v1 = l1.val if l1 else 0\n        v2 = l2.val if l2 else 0\n\n        carry, val = divmod(v1 + v2 + carry, 10)\n        cur.next = ListNode(val)\n        cur = cur.next\n\n        if l1:\n            l1 = l1.next\n        if l2:\n            l2 = l2.next\n\n    if carry:\n        cur.next = ListNode(val=carry)\n\n    return dummy.next\n\n\ndef test_add_two_numbers():\n    l1 = LinkedList([2, 4, 3]).head\n    l2 = LinkedList([5, 6, 4]).head\n    added = add_two_numbers(l1, l2)\n    assert LinkedList(added).to_array() == [7, 0, 8]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode* next) : val(x), next(next) {}\n};\n\nclass Solution {\n   public:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode dummy;\n        ListNode* cur = &amp;dummy;\n        int carry = 0;\n\n        while (l1 || l2 || carry) {\n            if (l1) {\n                carry += l1-&gt;val;\n                l1 = l1-&gt;next;\n            }\n            if (l2) {\n                carry += l2-&gt;val;\n                l2 = l2-&gt;next;\n            }\n            cur-&gt;next = new ListNode(carry % 10);\n            cur = cur-&gt;next;\n            carry /= 10;\n        }\n        return dummy.next;\n    }\n};\n\nint main() {\n    Solution sol;\n\n    ListNode* l1 = new ListNode(2, new ListNode(4, new ListNode(3)));\n    ListNode* l2 = new ListNode(5, new ListNode(6, new ListNode(4)));\n    ListNode* result = sol.addTwoNumbers(l1, l2);\n\n    vector&lt;int&gt; expected = {7, 0, 8};\n    for (int val : expected) {\n        assert(result != nullptr &amp;&amp; result-&gt;val == val);\n        result = result-&gt;next;\n    }\n    assert(result == nullptr);  // End of list\n\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/math/","title":"Math","text":""},{"location":"LeetPattern/math/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1945. Sum of Digits of String After Convert (Easy)</li> <li> 1894. Find the Student that Will Replace the Chalk (Medium)</li> <li> 7. Reverse Integer (Medium)</li> </ul>"},{"location":"LeetPattern/math/#1945-sum-of-digits-of-string-after-convert","title":"1945. Sum of Digits of String After Convert","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Simulation</p> </li> </ul> Python <pre><code># Math\ndef getLucky(s: str, k: int) -&gt; int:\n    def getSum(n: int) -&gt; int:\n        total = 0\n        while n != 0:\n            n, m = divmod(n, 10)\n            total += m\n        return total\n\n    result = \"\"\n    for i in s:\n        result += str(ord(i) - ord(\"a\") + 1)\n    result = int(result)\n\n    for _ in range(k):\n        result = getSum(result)\n\n    return result\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |    Math    |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\ns = \"iiii\"\nk = 1\n\nprint(getLucky(s, k))  # 36\n</code></pre>"},{"location":"LeetPattern/math/#1894-find-the-student-that-will-replace-the-chalk","title":"1894. Find the Student that Will Replace the Chalk","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Simulation, Prefix Sum</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Math\ndef chalkReplacer(chalk: List[int], k: int) -&gt; int:\n    total = sum(chalk)\n\n    k %= total\n\n    for i, c in enumerate(chalk):\n        k -= c\n\n        if k &lt; 0:\n            return i\n\n    return -1\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |    Math    |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nchalk = [5, 1, 5]\nk = 22\n\nprint(chalkReplacer(chalk, k))  # 0\n</code></pre>"},{"location":"LeetPattern/math/#7-reverse-integer","title":"7. Reverse Integer","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math</p> </li> </ul> Python <pre><code># Math\ndef reverse(x: int) -&gt; int:\n    INT_MAX = 2**31 - 1\n\n    sign = -1 if x &lt; 0 else 1\n    x = abs(x)\n    res = 0\n\n    while x != 0:\n        x, pop = divmod(x, 10)\n\n        if res &gt; (INT_MAX - pop) // 10:\n            return 0\n\n        res = res * 10 + pop\n\n    return res * sign\n\n\nprint(reverse(123))  # 321\nprint(reverse(-123))  # -321\n</code></pre>"},{"location":"LeetPattern/prefix_sum/","title":"Prefix Sum","text":""},{"location":"LeetPattern/prefix_sum/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2574. Left and Right Sum Differences (Easy)</li> <li> 1732. Find the Highest Altitude (Easy)</li> <li> 303. Range Sum Query - Immutable (Easy)</li> <li> 304. Range Sum Query 2D - Immutable (Medium)</li> <li> 560. Subarray Sum Equals K (Medium)</li> <li> 238. Product of Array Except Self (Medium)</li> <li> 974. Subarray Sums Divisible by K (Medium)</li> <li> 209. Minimum Size Subarray Sum (Medium)</li> <li> 523. Continuous Subarray Sum (Medium)</li> <li> 1248. Count Number of Nice Subarrays (Medium)</li> <li> 325. Maximum Size Subarray Sum Equals k (Medium) \ud83d\udc51</li> <li> 862. Shortest Subarray with Sum at Least K (Hard)</li> <li> 1171. Remove Zero Sum Consecutive Nodes from Linked List (Medium)</li> </ul>"},{"location":"LeetPattern/prefix_sum/#2574-left-and-right-sum-differences","title":"2574. Left and Right Sum Differences","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Prefix Sum</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Prefix Sum\ndef leftRightDifferenceSum(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    left = [0 for _ in range(n)]\n    right = [0 for _ in range(n)]\n\n    for i in range(1, n):\n        left[i] = left[i - 1] + nums[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        right[i] = right[i + 1] + nums[i + 1]\n\n    return [abs(left[i] - right[i]) for i in range(n)]\n\n\n# Left Right Pointers\ndef leftRightDifferencePointer(nums: List[int]) -&gt; List[int]:\n    left, right = 0, sum(nums)\n    result = []\n\n    for num in nums:\n        right -= num\n        result.append(abs(left - right))\n        left += num\n\n    return result\n\n\nnums = [10, 4, 8, 3]\nprint(leftRightDifferenceSum(nums))  # [15, 1, 11, 22]\nprint(leftRightDifferencePointer(nums))  # [15, 1, 11, 22]\n</code></pre>"},{"location":"LeetPattern/prefix_sum/#1732-find-the-highest-altitude","title":"1732. Find the Highest Altitude","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Prefix Sum</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef largestAltitude(gain: List[int]) -&gt; int:\n    result, altitude = 0, 0\n\n    for i in gain:\n        altitude += i\n        result = max(result, altitude)\n\n    return result\n\n\ngain = [-5, 1, 5, 0, -7]\nprint(largestAltitude(gain))  # 1\n</code></pre>"},{"location":"LeetPattern/prefix_sum/#303-range-sum-query-immutable","title":"303. Range Sum Query - Immutable","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Design, Prefix Sum</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Prefix Sum\nclass NumArray:\n\n    def __init__(self, nums: List[int]):\n        n = len(nums)\n        self.ps = [0 for _ in range(n + 1)]  # prefix sum\n        for i in range(1, n + 1):\n            self.ps[i] = self.ps[i - 1] + nums[i - 1]\n\n    def sumRange(self, left: int, right: int) -&gt; int:\n        return self.ps[right + 1] - self.ps[left]\n\n\nnums = [-2, 0, 3, -5, 2, -1]\nobj = NumArray(nums)\nassert obj.sumRange(0, 2) == 1\nassert obj.sumRange(2, 5) == -1\nassert obj.sumRange(0, 5) == -3\nprint(\"PASSED\")\n</code></pre>"},{"location":"LeetPattern/prefix_sum/#304-range-sum-query-2d-immutable","title":"304. Range Sum Query 2D - Immutable","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Design, Matrix, Prefix Sum</p> </li> </ul> Python <pre><code>from typing import List\n\n\nclass NumMatrix:\n\n    def __init__(self, matrix: List[List[int]]):\n        m, n = len(matrix), len(matrix[0])\n        if m == 0 or n == 0:\n            return None\n\n        self.sum = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                self.sum[i][j] = (\n                    matrix[i - 1][j - 1]\n                    + self.sum[i - 1][j]\n                    + self.sum[i][j - 1]\n                    - self.sum[i - 1][j - 1]  # to avoid double counting\n                )\n\n    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -&gt; int:\n        return (\n            self.sum[row2 + 1][col2 + 1]\n            - self.sum[row1][col2 + 1]\n            - self.sum[row2 + 1][col1]\n            + self.sum[row1][col1]\n        )\n\n\nmatrix = [\n    [3, 0, 1, 4, 2],\n    [5, 6, 3, 2, 1],\n    [1, 2, 0, 1, 5],\n    [4, 1, 0, 1, 7],\n    [1, 0, 3, 0, 5],\n]\nobj = NumMatrix(matrix)\nassert obj.sumRegion(2, 1, 4, 3) == 8\nassert obj.sumRegion(1, 1, 2, 2) == 11\nassert obj.sumRegion(1, 2, 2, 4) == 12\nprint(\"PASSED\")\n</code></pre>"},{"location":"LeetPattern/prefix_sum/#560-subarray-sum-equals-k","title":"560. Subarray Sum Equals K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Prefix Sum</p> </li> </ul> PythonCPP <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Prefix Sum\ndef subarraySum(nums: List[int], k: int) -&gt; int:\n    preSums = defaultdict(int)\n    preSums[0] = 1\n    curSum = 0\n    res = 0\n\n    for num in nums:\n        curSum += num\n        res += preSums[curSum - k]\n        preSums[curSum] += 1\n\n    return res\n\n\nnums = [1, 1, 1]\nk = 2\nprint(subarraySum(nums, k))  # 2\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint subarraySum(vector&lt;int&gt;&amp; nums, int k) {\n    int n = nums.size();\n    vector&lt;int&gt; prefixSum(n + 1);\n    for (int i = 0; i &lt; n; i++) {\n        prefixSum[i + 1] = prefixSum[i] + nums[i];\n    }\n\n    int res = 0;\n    unordered_map&lt;int, int&gt; cnt;\n\n    for (int ps : prefixSum) {\n        if (cnt.find(ps - k) != cnt.end()) res += cnt[ps - k];\n        cnt[ps]++;\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {1, 1, 1};\n    int k = 2;\n    cout &lt;&lt; subarraySum(nums, k) &lt;&lt; endl;  // 2\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/prefix_sum/#238-product-of-array-except-self","title":"238. Product of Array Except Self","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Prefix Sum</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Classic **Prefix Sum** problem\n-   Return an array `output` such that `output[i]` is equal to the product of all the elements of `nums` except `nums[i]`.\n\n| Approach           | Time | Space |\n| ------------------ | ---- | ----- |\n| Prefix             | O(n) | O(n)  |\n| Prefix (Optimized) | O(n) | O(1)  |\n\"\"\"\n\nfrom typing import List\n\n\n# Prefix\ndef productExceptSelf(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    prefix = [1 for _ in range(n)]\n    suffix = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        prefix[i] = nums[i - 1] * prefix[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        suffix[i] = nums[i + 1] * suffix[i + 1]\n\n    result = [i * j for i, j in zip(prefix, suffix)]\n\n    return result\n\n\n# Prefix (Optimized)\ndef productExceptSelfOptimized(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    result = [1 for _ in range(n)]\n\n    prefix = 1\n    for i in range(n):\n        result[i] = prefix\n        prefix *= nums[i]\n\n    suffix = 1\n    for i in range(n - 1, -1, -1):\n        result[i] *= suffix\n        suffix *= nums[i]\n\n    return result\n\n\nprint(productExceptSelf([1, 2, 3, 4]))\n# [24, 12, 8, 6]\nprint(productExceptSelfOptimized([1, 2, 3, 4]))\n# [24, 12, 8, 6]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt; &amp;nums) {\n        int n = nums.size();\n        vector&lt;int&gt; prefix(n, 1);\n        vector&lt;int&gt; suffix(n, 1);\n        vector&lt;int&gt; res(n, 1);\n\n        for (int i = 1; i &lt; n; i++) {\n            prefix[i] = prefix[i - 1] * nums[i - 1];\n        }\n\n        for (int i = n - 2; i &gt;= 0; i--) {\n            suffix[i] = suffix[i + 1] * nums[i + 1];\n        }\n\n        for (int i = 0; i &lt; n; i++) {\n            res[i] = prefix[i] * suffix[i];\n        }\n        return res;\n    }\n};\n\nint main() {\n    vector&lt;int&gt; nums = {1, 2, 3, 4};\n    Solution obj;\n    vector&lt;int&gt; result = obj.productExceptSelf(nums);\n    assert(result == vector&lt;int&gt;({24, 12, 8, 6}));\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/prefix_sum/#974-subarray-sums-divisible-by-k","title":"974. Subarray Sums Divisible by K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Prefix Sum</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef subarraysDivByK_1(nums: List[int], k: int) -&gt; int:\n    mods = {0: 1}\n    prefixSum, result = 0, 0\n\n    for num in nums:\n        prefixSum += num\n        mod = prefixSum % k\n\n        if mod &lt; 0:\n            mod += k\n\n        if mod in mods:\n            result += mods[mod]\n\n        if mod in mods:\n            mods[mod] += 1\n        else:\n            mods[mod] = 1\n\n    return result\n\n\ndef subarraysDivByK_2(nums: List[int], k: int) -&gt; int:\n    mods = {0: 1}\n    prefixSum, result = 0, 0\n\n    for num in nums:\n        prefixSum += num\n        mod = prefixSum % k\n        result += mods.get(mod, 0)\n        mods[mod] = mods.get(mod, 0) + 1\n\n    return result\n\n\nnums = [4, 5, 0, -2, -3, 1]\nk = 5\nprint(subarraysDivByK_1(nums, k))  # 7\nprint(subarraysDivByK_2(nums, k))  # 7\n</code></pre>"},{"location":"LeetPattern/prefix_sum/#209-minimum-size-subarray-sum","title":"209. Minimum Size Subarray Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Sliding Window, Prefix Sum</p> </li> </ul> Python <pre><code>import bisect\nfrom typing import List\n\n\n# Prefix Sum\ndef minSubArrayLenPS(target: int, nums: List[int]) -&gt; int:\n    n = len(nums)\n    prefix_sums = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        prefix_sums[i] = prefix_sums[i - 1] + nums[i - 1]\n\n    minLen = float(\"inf\")\n\n    for i in range(n + 1):\n        new_target = target + prefix_sums[i]\n        bound = bisect.bisect_left(prefix_sums, new_target)\n        if bound != len(prefix_sums):\n            minLen = min(minLen, bound - i)\n\n    return 0 if minLen == float(\"inf\") else minLen\n\n\n# Sliding Window Variable Size\ndef minSubArrayLenSW(target: int, nums: List[int]) -&gt; int:\n    res, cur = float(\"inf\"), 0\n    left = 0\n\n    for right in range(len(nums)):\n        cur += nums[right]\n\n        while cur &gt;= target:\n            res = min(res, right - left + 1)\n            cur -= nums[left]\n            left += 1\n\n    return res if res != float(\"inf\") else 0\n\n\ntarget = 7\nnums = [2, 3, 1, 2, 4, 3]\nprint(minSubArrayLenPS(target, nums))  # 2\nprint(minSubArrayLenSW(target, nums))  # 2\n</code></pre>"},{"location":"LeetPattern/prefix_sum/#523-continuous-subarray-sum","title":"523. Continuous Subarray Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Prefix Sum</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Prefix Sum\ndef checkSubarraySum(nums: List[int], k: int) -&gt; bool:\n    if k == 0:\n        for i in range(1, len(nums)):\n            if nums[i - 1] == 0 and nums[i] == 0:\n                return True\n\n    prefix_sum = 0\n    mod_dict = {0: -1}\n\n    for i, num in enumerate(nums):\n        prefix_sum += num\n        mod = prefix_sum % k\n\n        if mod in mod_dict:\n            if i - mod_dict[mod] &gt; 1:\n                return True\n        else:\n            mod_dict[mod] = i\n\n    return False\n\n\nnums = [23, 2, 4, 6, 7]\nk = 6\nprint(checkSubarraySum(nums, k))  # True\n</code></pre>"},{"location":"LeetPattern/prefix_sum/#1248-count-number-of-nice-subarrays","title":"1248. Count Number of Nice Subarrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Sliding Window, Prefix Sum</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Prefix Sum\ndef numberOfSubarrays(nums: List[int], k: int) -&gt; int:\n    count = 0\n    odd_counts = {0: 1}  # odd_count -&gt; count\n    odd_count = 0\n\n    for num in nums:\n        if num % 2 == 1:\n            odd_count += 1\n        if odd_count - k in odd_counts:\n            count += odd_counts[odd_count - k]\n        if odd_count in odd_counts:\n            odd_counts[odd_count] += 1\n        else:\n            odd_counts[odd_count] = 1\n\n    return count\n\n\nnums = [1, 1, 2, 1, 1]\nk = 3\nprint(numberOfSubarrays(nums, k))  # 2\n</code></pre>"},{"location":"LeetPattern/prefix_sum/#325-maximum-size-subarray-sum-equals-k","title":"325. Maximum Size Subarray Sum Equals k \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Prefix Sum</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Prefix Sum\ndef maxSubArrayLen(nums: List[int], k: int) -&gt; int:\n    res = 0\n    prefix = 0\n    sumMap = {0: -1}  # sum -&gt; index\n\n    for i, num in enumerate(nums):\n        prefix += num\n        if prefix - k in sumMap:\n            res = max(res, i - sumMap[prefix - k])\n        if prefix not in sumMap:\n            sumMap[prefix] = i\n\n    return res\n\n\nnums = [1, -1, 5, -2, 3]\nk = 3\nprint(maxSubArrayLen(nums, k))  # 4\n</code></pre>"},{"location":"LeetPattern/prefix_sum/#862-shortest-subarray-with-sum-at-least-k","title":"862. Shortest Subarray with Sum at Least K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Queue, Sliding Window, Heap Priority Queue, Prefix Sum, Monotonic Queue</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# Prefix Sum + Monotonic Queue\ndef shortestSubarray(nums: List[int], k: int) -&gt; int:\n    n = len(nums)\n    ps = [0 for _ in range(n + 1)]\n\n    for i in range(n):\n        ps[i + 1] = ps[i] + nums[i]\n\n    res = float(\"inf\")\n    q = deque()\n\n    for i in range(n + 1):\n        while q and ps[i] - ps[q[0]] &gt;= k:\n            res = min(res, i - q.popleft())\n        while q and ps[i] &lt;= ps[q[-1]]:\n            q.pop()\n        q.append(i)\n\n    return res if res != float(\"inf\") else -1\n\n\nnums = [2, -1, 2]\nk = 3\nprint(shortestSubarray(nums, k))  # 3\n</code></pre>"},{"location":"LeetPattern/prefix_sum/#1171-remove-zero-sum-consecutive-nodes-from-linked-list","title":"1171. Remove Zero Sum Consecutive Nodes from Linked List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Linked List</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom leetpattern.utils import ListNode\n\n\n# Prefix Sum\ndef removeZeroSumSublists(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    dummy = ListNode(0)\n    dummy.next = head\n    cur = head\n    prefix_sum = 0\n    seen = {0: dummy}\n\n    while cur:\n        prefix_sum += cur.val\n        if prefix_sum in seen:\n            node = seen[prefix_sum].next\n            temp_sum = prefix_sum\n            while node != cur:\n                temp_sum += node.val\n                del seen[temp_sum]\n                node = node.next\n            seen[prefix_sum].next = cur.next\n        else:\n            seen[prefix_sum] = cur\n        cur = cur.next\n\n    return dummy.next\n\n\nhead = ListNode().create([1, 2, -3, 3, 1])\nprint(removeZeroSumSublists(head))  # 3 -&gt; 1\n</code></pre>"},{"location":"LeetPattern/queue/","title":"Queue","text":""},{"location":"LeetPattern/queue/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 232. Implement Queue using Stacks (Easy)</li> <li> 225. Implement Stack using Queues (Easy)</li> </ul>"},{"location":"LeetPattern/queue/#232-implement-queue-using-stacks","title":"232. Implement Queue using Stacks","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Stack, Design, Queue</p> </li> </ul> Python <pre><code>\"\"\"\n-   Implement the following operations of a queue using stacks.\n    -   `push(x)` - Push element x to the back of queue.\n    -   `pop()` - Removes the element from in front of queue.\n    -   `peek()` - Get the front element.\n    -   `empty()` - Return whether the queue is empty.\n\"\"\"\n\n\nclass MyQueue:\n    def __init__(self):\n        self.stack_in = []\n        self.stack_out = []\n\n    def push(self, x: int) -&gt; None:\n        self.stack_in.append(x)\n\n    def pop(self) -&gt; int:\n        if self.empty():\n            return None\n\n        if self.stack_out:\n            return self.stack_out.pop()\n        else:\n            for _ in range(len(self.stack_in)):\n                self.stack_out.append(self.stack_in.pop())\n            return self.stack_out.pop()\n\n    def peek(self) -&gt; int:\n        answer = self.pop()\n        self.stack_out.append(answer)\n        return answer\n\n    def empty(self) -&gt; bool:\n        return not (self.stack_in or self.stack_out)\n\n\nobj = MyQueue()\nobj.push(1)\nprint(obj.pop())  # 1\nprint(obj.peek())  # None\nprint(obj.empty())  # False\n</code></pre>"},{"location":"LeetPattern/queue/#225-implement-stack-using-queues","title":"225. Implement Stack using Queues","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Stack, Design, Queue</p> </li> </ul> Python <pre><code>from collections import deque\n\n\n# Queue\nclass MyStack:\n\n    def __init__(self):\n        self.q1 = deque()  # main queue\n        self.q2 = deque()  # auxiliary queue\n\n    def push(self, x: int) -&gt; None:\n        self.q1.append(x)\n\n    def pop(self) -&gt; int:\n        while len(self.q1) &gt; 1:\n            self.q2.append(self.q1.popleft())\n        res = self.q1.popleft()\n        self.q1, self.q2 = self.q2, self.q1\n        return res\n\n    def top(self) -&gt; int:\n        while len(self.q1) &gt; 1:\n            self.q2.append(self.q1.popleft())\n        res = self.q1[0]\n        self.q2.append(self.q1.popleft())\n        self.q1, self.q2 = self.q2, self.q1\n        return res\n\n    def empty(self) -&gt; bool:\n        return not self.q1\n\n\nobj = MyStack()\nobj.push(1)\nobj.push(2)\nobj.push(3)\nobj.push(4)\nprint(obj.pop())  # 4\nprint(obj.top())  # 3\nprint(obj.empty())  # False\nprint(obj.pop())  # 3\n</code></pre>"},{"location":"LeetPattern/queue_monotonic/","title":"Queue Monotonic","text":""},{"location":"LeetPattern/queue_monotonic/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 918. Maximum Sum Circular Subarray (Medium)</li> <li> 862. Shortest Subarray with Sum at Least K (Hard)</li> <li> 239. Sliding Window Maximum (Hard)</li> <li> 2398. Maximum Number of Robots Within Budget (Hard)</li> </ul>"},{"location":"LeetPattern/queue_monotonic/#918-maximum-sum-circular-subarray","title":"918. Maximum Sum Circular Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Divide And Conquer, Dynamic Programming, Queue, Monotonic Queue</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# DP - Kadane\ndef maxSubarraySumCircularKadane(nums: List[int]) -&gt; int:\n    max_sum = min_sum = nums[0]\n    max_cur = min_cur = 0\n    total = 0\n\n    for num in nums:\n        max_cur = max(max_cur + num, num)\n        min_cur = min(min_cur + num, num)\n        total += num\n\n        max_sum = max(max_sum, max_cur)\n        min_sum = min(min_sum, min_cur)\n\n    return max(max_sum, total - min_sum) if max_sum &gt; 0 else max_sum\n\n\n# Monotonic Queue\ndef maxSubarraySumCircularMQ(nums: List[int]) -&gt; int:\n    n = len(nums)\n    prefix_sum = [0] * (2 * n + 1)\n\n    for i in range(1, 2 * n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + nums[(i - 1) % n]\n\n    q = deque([0])\n    max_sum = float(\"-inf\")\n\n    for i in range(1, 2 * n + 1):\n        if q[0] &lt; i - n:\n            q.popleft()\n\n        max_sum = max(max_sum, prefix_sum[i] - prefix_sum[q[0]])\n\n        while q and prefix_sum[q[-1]] &gt;= prefix_sum[i]:\n            q.pop()\n\n        q.append(i)\n\n    return max_sum\n\n\nnums = [1, -2, 3, -2]\nprint(maxSubarraySumCircularKadane(nums))  # 3\nprint(maxSubarraySumCircularMQ(nums))  # 3\n</code></pre>"},{"location":"LeetPattern/queue_monotonic/#862-shortest-subarray-with-sum-at-least-k","title":"862. Shortest Subarray with Sum at Least K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Queue, Sliding Window, Heap Priority Queue, Prefix Sum, Monotonic Queue</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# Prefix Sum + Monotonic Queue\ndef shortestSubarray(nums: List[int], k: int) -&gt; int:\n    n = len(nums)\n    ps = [0 for _ in range(n + 1)]\n\n    for i in range(n):\n        ps[i + 1] = ps[i] + nums[i]\n\n    res = float(\"inf\")\n    q = deque()\n\n    for i in range(n + 1):\n        while q and ps[i] - ps[q[0]] &gt;= k:\n            res = min(res, i - q.popleft())\n        while q and ps[i] &lt;= ps[q[-1]]:\n            q.pop()\n        q.append(i)\n\n    return res if res != float(\"inf\") else -1\n\n\nnums = [2, -1, 2]\nk = 3\nprint(shortestSubarray(nums, k))  # 3\n</code></pre>"},{"location":"LeetPattern/queue_monotonic/#239-sliding-window-maximum","title":"239. Sliding Window Maximum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Queue, Sliding Window, Heap Priority Queue, Monotonic Queue</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# Monotonic Queue\ndef maxSlidingWindow(nums: List[int], k: int) -&gt; List[int]:\n    q = deque()\n    res = []\n\n    for i, num in enumerate(nums):\n        if q and q[0] &lt; i - k + 1:\n            q.popleft()\n\n        while q and nums[q[-1]] &lt; num:\n            q.pop()\n\n        q.append(i)\n\n        if i &gt;= k - 1:\n            res.append(nums[q[0]])\n\n    return res\n\n\nnums = [1, 3, -1, -3, 5, 3, 6, 7]\nk = 3\nprint(maxSlidingWindow(nums, k))  # [3, 3, 5, 5, 6, 7]\n</code></pre>"},{"location":"LeetPattern/queue_monotonic/#2398-maximum-number-of-robots-within-budget","title":"2398. Maximum Number of Robots Within Budget","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Queue, Sliding Window, Heap Priority Queue, Prefix Sum, Monotonic Queue</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# Monotonic Queue\ndef maximumRobots(chargeTimes: List[int], runningCosts: List[int], budget: int) -&gt; int:\n    ans = sum_cost = left = 0\n    q = deque()\n\n    for right, (time, cost) in enumerate(zip(chargeTimes, runningCosts)):\n        # 1. Add\n        while q and time &gt;= chargeTimes[q[-1]]:\n            q.pop()\n        q.append(right)\n        sum_cost += cost\n\n        # 2. Remove\n        while q and chargeTimes[q[0]] + (right - left + 1) * sum_cost &gt; budget:\n            if q[0] == left:\n                q.popleft()\n            sum_cost -= runningCosts[left]\n            left += 1\n\n        # 3. Update\n        ans = max(ans, right - left + 1)\n    return ans\n\n\nchargeTimes = [3, 6, 1, 3, 4]\nrunningCosts = [2, 1, 3, 4, 5]\nbudget = 25\nprint(maximumRobots(chargeTimes, runningCosts, budget))  # 3\n</code></pre>"},{"location":"LeetPattern/simulation/","title":"Simulation","text":""},{"location":"LeetPattern/simulation/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 874. Walking Robot Simulation (Medium)</li> </ul>"},{"location":"LeetPattern/simulation/#874-walking-robot-simulation","title":"874. Walking Robot Simulation","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Simulation</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Simulation\ndef robotSim(commands: List[int], obstacles: List[List[int]]) -&gt; int:\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    obstacles_set = set(map(tuple, obstacles))\n\n    x, y, d = 0, 0, 0\n    res = 0\n\n    for command in commands:\n        if command == -2:  # Turn left\n            d = (d - 1) % 4\n        elif command == -1:  # Turn right\n            d = (d + 1) % 4\n        else:\n            dx, dy = dirs[d]\n            for _ in range(command):\n                if (x + dx, y + dy) not in obstacles_set:\n                    x += dx\n                    y += dy\n                    res = max(res, x**2 + y**2)\n                else:\n                    break\n\n    return res\n\n\ncommands = [4, -1, 4, -2, 4]\nobstacles = [[2, 4]]\nprint(robotSim(commands, obstacles))  # 65\n</code></pre>"},{"location":"LeetPattern/sliding_window_fixed/","title":"Sliding Window Fixed","text":""},{"location":"LeetPattern/sliding_window_fixed/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 643. Maximum Average Subarray I (Easy)</li> <li> 219. Contains Duplicate II (Easy)</li> <li> 1456. Maximum Number of Vowels in a Substring of Given Length (Medium)</li> <li> 567. Permutation in String (Medium)</li> <li> 713. Subarray Product Less Than K (Medium)</li> <li> 1151. Minimum Swaps to Group All 1's Together (Medium) \ud83d\udc51</li> <li> 209. Minimum Size Subarray Sum (Medium)</li> <li> 76. Minimum Window Substring (Hard)</li> </ul>"},{"location":"LeetPattern/sliding_window_fixed/#643-maximum-average-subarray-i","title":"643. Maximum Average Subarray I","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sliding Window</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Sliding Window Fixed Size\ndef findMaxAverage1(nums: List[int], k: int) -&gt; float:\n    maxSum = float(\"-inf\")\n    cur = 0\n\n    for idx, num in enumerate(nums):\n        cur += num\n\n        if idx &lt; k - 1:\n            continue\n\n        maxSum = max(maxSum, cur)\n        cur -= nums[idx - k + 1]\n\n    return maxSum / k\n\n\n# Sliding Window Fixed Size\ndef findMaxAverage2(nums: List[int], k: int) -&gt; float:\n    n = len(nums)\n    if n == 1:\n        return float(nums[0])\n\n    cur = sum(nums[:k])\n\n    maxSum = cur\n    for i in range(k, n):\n        cur += nums[i] - nums[i - k]\n        maxSum = max(maxSum, cur)\n\n    return maxSum / k\n\n\nnums = [1, 12, -5, -6, 50, 3]\nk = 4\nprint(findMaxAverage1(nums, k))  # 12.75\nprint(findMaxAverage2(nums, k))  # 12.75\n</code></pre>"},{"location":"LeetPattern/sliding_window_fixed/#219-contains-duplicate-ii","title":"219. Contains Duplicate II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Sliding Window</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\n# Hash\ndef containsNearbyDuplicateHash(nums: List[int], k: int) -&gt; bool:\n    hashmap = {}  # num: last index\n\n    for idx, num in enumerate(nums):\n        if num in hashmap:\n            if idx - hashmap[num] &lt;= k:\n                return True\n\n        hashmap[num] = idx\n\n    return False\n\n\n# Sliding window - Fixed\ndef containsNearbyDuplicateWindow(nums: List[int], k: int) -&gt; bool:\n    window = set()\n    left = 0\n\n    for right in range(len(nums)):\n        if right - left &gt; k:\n            window.remove(nums[left])\n            left += 1\n        if nums[right] in window:\n            return True\n        window.add(nums[right])\n\n    return False\n\n\nnums = [1, 2, 3, 1]\nk = 3\nprint(containsNearbyDuplicateHash(nums, k))  # True\nprint(containsNearbyDuplicateWindow(nums, k))  # True\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;unordered_map&gt;\n#include &lt;unordered_set&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) {\n        unordered_map&lt;int, int&gt; last;\n\n        for (size_t i = 0; i &lt; nums.size(); i++) {\n            int num = nums[i];\n            if (last.contains(num) &amp;&amp; ((int)i - last[num] &lt;= k)) return true;\n            last[num] = i;\n        }\n        return false;\n    }\n    bool containsNearbyDuplicateSlidingWindow(vector&lt;int&gt;&amp; nums, int k) {\n        unordered_set&lt;int&gt; window;\n\n        for (size_t i = 0; i &lt; nums.size(); i++) {\n            if (window.contains(nums[i])) return true;\n            window.insert(nums[i]);\n\n            if ((int)i - k &gt;= 0) {\n                window.erase(nums[i - k]);\n            }\n        }\n        return false;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; nums = {1, 2, 3, 1};\n    assert(solution.containsNearbyDuplicate(nums, 3));\n    assert(solution.containsNearbyDuplicateSlidingWindow(nums, 3));\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/sliding_window_fixed/#1456-maximum-number-of-vowels-in-a-substring-of-given-length","title":"1456. Maximum Number of Vowels in a Substring of Given Length","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Sliding Window</p> </li> </ul> PythonCPP <pre><code>class maxVowels:\n    \"\"\"\n    Template problem for Fixed Size Sliding Window.\n    Technique: add-update-remove (\u5165-\u66f4\u65b0-\u51fa)\n    \"\"\"\n\n    @staticmethod\n    def fixed_sliding_window(s: str, k: int) -&gt; int:\n        res, cnt = 0, 0\n\n        for idx, ch in enumerate(s):\n            # ADD\n            if ch in \"aeiou\":\n                cnt += 1\n\n            # FORM\n            if idx &lt; k - 1:\n                continue\n\n            # UPDATE\n            res = max(res, cnt)\n\n            # REMOVE\n            if s[idx - k + 1] in \"aeiou\":\n                cnt -= 1\n\n        return res\n\n    @staticmethod\n    def fixed_sliding_window_substring(s: str, k: int) -&gt; int:\n        \"\"\"Sliding Window on Substring\"\"\"\n\n        vowels = set(\"aeiou\")\n        n = len(s)\n        cnt, res = 0, 0\n\n        # init\n        for i in range(k):\n            if s[i] in vowels:\n                cnt += 1\n\n        res = cnt\n\n        # slide\n        for i in range(k, n):\n            if s[i] in vowels:\n                cnt += 1\n            if s[i - k] in vowels:\n                cnt -= 1\n            res = max(res, cnt)\n\n        return res\n\n\nif __name__ == \"__main__\":\n    s = \"abciiidef\"\n    k = 3\n    assert maxVowels.fixed_sliding_window(s, k) == 3\n    assert maxVowels.fixed_sliding_window_substring(s, k) == 3\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;string&gt;\n#include &lt;unordered_set&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int maxVowels(string s, int k) {\n        int n = s.size();\n        int res = 0, cnt = 0;\n        unordered_set&lt;char&gt; vowels = {'a', 'e', 'i', 'o', 'u'};\n\n        for (int right = 0; right &lt; n; right++) {\n            if (vowels.count(s[right])) cnt++;\n\n            int left = right - k + 1;\n            if (left &lt; 0) continue;\n\n            res = max(res, cnt);\n            if (vowels.count(s[left])) cnt--;\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    assert(solution.maxVowels(\"abciiidef\", 3) == 3);\n    assert(solution.maxVowels(\"aeiou\", 2) == 2);\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/sliding_window_fixed/#567-permutation-in-string","title":"567. Permutation in String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Two Pointers, String, Sliding Window</p> </li> </ul> Python <pre><code>def checkInclusion(s1: str, s2: str) -&gt; bool:\n    if len(s1) &gt; len(s2):\n        return False\n\n    count1 = [0] * 26\n    count2 = [0] * 26\n\n    for i in range(len(s1)):\n        count1[ord(s1[i]) - ord(\"a\")] += 1\n        count2[ord(s2[i]) - ord(\"a\")] += 1\n\n    matches = 0\n    for i in range(26):\n        if count1[i] == count2[i]:\n            matches += 1\n\n    l = 0\n    for r in range(len(s1), len(s2)):\n        if matches == 26:\n            return True\n\n        index = ord(s2[r]) - ord(\"a\")\n        count2[index] += 1\n        if count1[index] == count2[index]:\n            matches += 1\n        elif count1[index] + 1 == count2[index]:\n            matches -= 1\n\n        index = ord(s2[l]) - ord(\"a\")\n        count2[index] -= 1\n        if count1[index] == count2[index]:\n            matches += 1\n        elif count1[index] - 1 == count2[index]:\n            matches -= 1\n\n        l += 1\n\n    return matches == 26\n\n\ns1 = \"ab\"\ns2 = \"eidba\"\nprint(checkInclusion(s1, s2))  # True\n</code></pre>"},{"location":"LeetPattern/sliding_window_fixed/#713-subarray-product-less-than-k","title":"713. Subarray Product Less Than K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Sliding Window, Prefix Sum</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Sliding Window Variable Subarrays Shorter\ndef numSubarrayProductLessThanK(nums: List[int], k: int) -&gt; int:\n    if k &lt;= 1:\n        return 0\n\n    left = 0\n    prod = 1\n    res = 0\n\n    for right in range(len(nums)):\n        prod *= nums[right]\n\n        while prod &gt;= k:\n            prod //= nums[left]\n            left += 1\n\n        res += right - left + 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert numSubarrayProductLessThanK([10, 5, 2, 6], 100) == 8\n    assert numSubarrayProductLessThanK([1, 2, 3], 0) == 0\n    assert numSubarrayProductLessThanK([1, 2, 3], 1) == 0\n    assert numSubarrayProductLessThanK([1, 2, 3], 2) == 1\n    assert numSubarrayProductLessThanK([1, 2, 3], 3) == 3\n</code></pre>"},{"location":"LeetPattern/sliding_window_fixed/#1151-minimum-swaps-to-group-all-1s-together","title":"1151. Minimum Swaps to Group All 1's Together \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sliding Window</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef minSwaps(data: List[int]) -&gt; int:\n    n = len(data)\n    total = sum(data)\n\n    if total == 0 or total == 1 or total == n:\n        return 0\n\n    max_count = 0\n    cur = 0\n    left = 0\n\n    for right in range(n):\n        cur += data[right]\n\n        if right - left + 1 &gt; total:\n            cur -= data[left]\n            left += 1\n\n        max_count = max(max_count, cur)\n\n    return total - max_count\n\n\ndata = [1, 0, 1, 0, 1]\nprint(minSwaps(data))  # 1\n</code></pre>"},{"location":"LeetPattern/sliding_window_fixed/#209-minimum-size-subarray-sum","title":"209. Minimum Size Subarray Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Sliding Window, Prefix Sum</p> </li> </ul> Python <pre><code>import bisect\nfrom typing import List\n\n\n# Prefix Sum\ndef minSubArrayLenPS(target: int, nums: List[int]) -&gt; int:\n    n = len(nums)\n    prefix_sums = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        prefix_sums[i] = prefix_sums[i - 1] + nums[i - 1]\n\n    minLen = float(\"inf\")\n\n    for i in range(n + 1):\n        new_target = target + prefix_sums[i]\n        bound = bisect.bisect_left(prefix_sums, new_target)\n        if bound != len(prefix_sums):\n            minLen = min(minLen, bound - i)\n\n    return 0 if minLen == float(\"inf\") else minLen\n\n\n# Sliding Window Variable Size\ndef minSubArrayLenSW(target: int, nums: List[int]) -&gt; int:\n    res, cur = float(\"inf\"), 0\n    left = 0\n\n    for right in range(len(nums)):\n        cur += nums[right]\n\n        while cur &gt;= target:\n            res = min(res, right - left + 1)\n            cur -= nums[left]\n            left += 1\n\n    return res if res != float(\"inf\") else 0\n\n\ntarget = 7\nnums = [2, 3, 1, 2, 4, 3]\nprint(minSubArrayLenPS(target, nums))  # 2\nprint(minSubArrayLenSW(target, nums))  # 2\n</code></pre>"},{"location":"LeetPattern/sliding_window_fixed/#76-minimum-window-substring","title":"76. Minimum Window Substring","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> Python <pre><code>from collections import Counter\n\n\ndef minWindow(s: str, t: str) -&gt; str:\n    if not t or not s:\n        return \"\"\n\n    counts = Counter(t)\n    required = len(counts)\n\n    left, right = 0, 0\n    formed = 0\n    window_counts = dict()\n\n    result = float(\"inf\"), None, None\n\n    while right &lt; len(s):\n        char = s[right]\n        window_counts[char] = window_counts.get(char, 0) + 1\n        if char in counts and window_counts[char] == counts[char]:\n            formed += 1\n\n        while left &lt;= right and formed == required:\n            char = s[left]\n            if right - left + 1 &lt; result[0]:\n                result = (right - left + 1, left, right)\n            window_counts[char] -= 1\n            if char in counts and window_counts[char] &lt; counts[char]:\n                formed -= 1\n            left += 1\n\n        right += 1\n\n    return \"\" if result[0] == float(\"inf\") else s[result[1] : result[2] + 1]\n\n\ns = \"ADOBECODEBANC\"\nt = \"ABC\"\nprint(minWindow(s, t))  # BANC\n</code></pre>"},{"location":"LeetPattern/sliding_window_variable/","title":"Sliding Window Variable","text":""},{"location":"LeetPattern/sliding_window_variable/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3. Longest Substring Without Repeating Characters (Medium)</li> <li> 159. Longest Substring with At Most Two Distinct Characters (Medium) \ud83d\udc51</li> <li> 424. Longest Repeating Character Replacement (Medium)</li> <li> 1208. Get Equal Substrings Within Budget (Medium)</li> <li> 1004. Max Consecutive Ones III (Medium)</li> <li> 438. Find All Anagrams in a String (Medium)</li> <li> 992. Subarrays with K Different Integers (Hard)</li> <li> 2024. Maximize the Confusion of an Exam (Medium)</li> </ul>"},{"location":"LeetPattern/sliding_window_variable/#3-longest-substring-without-repeating-characters","title":"3. Longest Substring Without Repeating Characters","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Classic variable sliding window problem. Use a set to keep track of the characters in the current window.\n- Return the length of the longest substring without repeating characters.\n- [Template tutorial by \u7075\u5c71\u8336\u827e\u5e9c](https://leetcode.cn/problems/longest-substring-without-repeating-characters/solutions/1959540/xia-biao-zong-suan-cuo-qing-kan-zhe-by-e-iaks)\n\"\"\"\n\nfrom collections import defaultdict\n\n\n# Sliding Window Variable Max - HashMap\ndef lengthOfLongestSubstringHash(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    left = 0\n    cnt = defaultdict(int)\n    res = 0\n\n    for right in range(n):\n        cnt[s[right]] += 1\n\n        while cnt[s[right]] &gt; 1:\n            cnt[s[left]] -= 1\n            left += 1\n\n        res = max(res, right - left + 1)\n\n    return res\n\n\n# Sliding Window Variable Max - Set\ndef lengthOfLongestSubstringSet(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    left = 0\n    res = 0\n    window = set()\n\n    for right in range(n):\n        while left &lt; right and s[right] in window:\n            window.remove(s[left])\n            left += 1\n        window.add(s[right])\n        res = max(res, right - left + 1)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    s = \"abcabcbb\"\n    assert lengthOfLongestSubstringHash(s) == 3\n    assert lengthOfLongestSubstringSet(s) == 3\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;unordered_set&gt;\nusing namespace std;\n\nint lengthOfLongestSubstring(string s) {\n    int n = s.length();\n    int res = 0;\n    int left = 0;\n    unordered_set&lt;char&gt; window;\n\n    for (int right = 0; right &lt; n; right++) {\n        char ch = s[right];\n\n        while (window.find(ch) != window.end()) {\n            window.erase(s[left]);\n            left++;\n        }\n\n        window.insert(ch);\n        res = max(res, right - left + 1);\n    }\n    return (int)res;\n}\n\nint main() {\n    string s = \"abcabcbb\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 3\n    s = \"bbbbb\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 1\n    s = \"pwwkew\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 3\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/sliding_window_variable/#159-longest-substring-with-at-most-two-distinct-characters","title":"159. Longest Substring with At Most Two Distinct Characters \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> Python <pre><code>\"\"\"\n-   Prerequisite: 3. Longest Substring Without Repeating Characters\n\"\"\"\n\nfrom collections import defaultdict\n\n\n# Sliding Window - Variable\ndef lengthOfLongestSubstringTwoDistinct(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 2:\n        return n\n\n    window = defaultdict(int)\n    left, res = 0, 0\n\n    for right in range(n):\n        window[s[right]] += 1\n\n        while len(window) &gt; 2:\n            window[s[left]] -= 1\n            if window[s[left]] == 0:\n                del window[s[left]]\n            left += 1\n\n        res = max(res, right - left + 1)\n\n    return res\n\n\ns = \"ccaabbb\"\nassert lengthOfLongestSubstringTwoDistinct(s) == 5\n</code></pre>"},{"location":"LeetPattern/sliding_window_variable/#424-longest-repeating-character-replacement","title":"424. Longest Repeating Character Replacement","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> Python <pre><code>from collections import defaultdict\n\n\n# Sliding Window - Variable\ndef characterReplacement(s: str, k: int) -&gt; int:\n    left = 0\n    maxCount = 0\n    counts = defaultdict(int)\n    maxLen = 0\n\n    for right in range(len(s)):\n        counts[s[right]] += 1\n        maxCount = max(maxCount, counts[s[right]])\n\n        while right - left + 1 - maxCount &gt; k:\n            counts[s[left]] -= 1\n            left += 1\n\n        maxLen = max(maxLen, right - left + 1)\n\n    return maxLen\n\n\ns = \"ABAB\"\nk = 2\nprint(characterReplacement(s, k))  # 4\n</code></pre>"},{"location":"LeetPattern/sliding_window_variable/#1208-get-equal-substrings-within-budget","title":"1208. Get Equal Substrings Within Budget","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Binary Search, Sliding Window, Prefix Sum</p> </li> </ul> Python <pre><code># Sliding Window - Variable\ndef equalSubstring(s: str, t: str, maxCost: int) -&gt; int:\n    left = 0\n    maxLen = 0\n    currentCost = 0\n\n    for right in range(len(s)):\n        currentCost += abs(ord(s[right]) - ord(t[right]))\n\n        while currentCost &gt; maxCost:\n            currentCost -= abs(ord(s[left]) - ord(t[left]))\n            left += 1\n\n        maxLen = max(maxLen, right - left + 1)\n\n    return maxLen\n\n\ns = \"abcd\"\nt = \"bcdf\"\nmaxCost = 3\nprint(equalSubstring(s, t, maxCost))  # 3\n</code></pre>"},{"location":"LeetPattern/sliding_window_variable/#1004-max-consecutive-ones-iii","title":"1004. Max Consecutive Ones III","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Sliding Window, Prefix Sum</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Sliding Window - Variable\ndef longestOnes(nums: List[int], k: int) -&gt; int:\n    left = 0\n    maxLen = 0\n    zero_count = 0\n\n    for right in range(len(nums)):\n        if nums[right] == 0:\n            zero_count += 1\n\n        while zero_count &gt; k:\n            if nums[left] == 0:\n                zero_count -= 1\n            left += 1\n\n        maxLen = max(maxLen, right - left + 1)\n\n    return maxLen\n\n\nnums = [1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0]\nk = 2\nprint(longestOnes(nums, k))  # 6\n</code></pre>"},{"location":"LeetPattern/sliding_window_variable/#438-find-all-anagrams-in-a-string","title":"438. Find All Anagrams in a String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Sliding Window Fixed Size\ndef findAnagrams(s: str, p: str) -&gt; List[int]:\n    n, k = len(s), len(p)\n    target = [0 for _ in range(26)]\n    for ch in p:\n        target[ord(ch) - ord(\"a\")] += 1\n\n    count = [0 for _ in range(26)]\n    left = 0\n    res = []\n\n    for right in range(n):\n        count[ord(s[right]) - ord(\"a\")] += 1\n        if right &lt; k - 1:\n            continue\n\n        if count == target:\n            res.append(left)\n\n        count[ord(s[left]) - ord(\"a\")] -= 1\n        left += 1\n\n    return res\n\n\ns = \"cbaebabacd\"\np = \"abc\"\nprint(findAnagrams(s, p))  # [0, 6]\n</code></pre>"},{"location":"LeetPattern/sliding_window_variable/#992-subarrays-with-k-different-integers","title":"992. Subarrays with K Different Integers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Sliding Window, Counting</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Sliding Window - Variable\ndef subarraysWithKDistinct(nums: List[int], k: int) -&gt; int:\n    def atMost(k: int) -&gt; int:\n        count = 0\n        left = 0\n        freq = {}\n\n        for right in range(len(nums)):\n            if nums[right] not in freq:\n                freq[nums[right]] = 0\n            freq[nums[right]] += 1\n\n            while len(freq) &gt; k:\n                freq[nums[left]] -= 1\n                if freq[nums[left]] == 0:\n                    del freq[nums[left]]\n                left += 1\n\n            count += right - left + 1\n\n        return count\n\n    return atMost(k) - atMost(k - 1)\n\n\nnums = [1, 2, 1, 2, 3]\nk = 2\nprint(subarraysWithKDistinct(nums, k))  # 7\n</code></pre>"},{"location":"LeetPattern/sliding_window_variable/#2024-maximize-the-confusion-of-an-exam","title":"2024. Maximize the Confusion of an Exam","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Binary Search, Sliding Window, Prefix Sum</p> </li> </ul> Python <pre><code># Sliding Window - Variable\ndef maxConsecutiveAnswers1(answerKey: str, k: int) -&gt; int:\n    def maxConsecutiveChar(s: str, k: int, char: str) -&gt; int:\n        max_len = 0\n        left = 0\n        count = 0  # num of str != char\n\n        for right in range(len(s)):\n            if s[right] != char:\n                count += 1\n\n            while count &gt; k:\n                if s[left] != char:\n                    count -= 1\n                left += 1\n\n            max_len = max(max_len, right - left + 1)\n\n        return max_len\n\n    max_t = maxConsecutiveChar(answerKey, k, \"T\")\n    max_f = maxConsecutiveChar(answerKey, k, \"F\")\n\n    return max(max_t, max_f)\n\n\n# Sliding Window - Variable\ndef maxConsecutiveAnswers2(answerKey: str, k: int) -&gt; int:\n    def maxConsecutiveChar(s: str, k: int, char: str) -&gt; int:\n        max_len = 0\n        left, right = 0, 0\n\n        while right &lt; len(s):\n            if s[right] != char:\n                k -= 1\n\n            while k &lt; 0:\n                if s[left] != char:\n                    k += 1\n                left += 1\n\n            max_len = max(max_len, right - left + 1)\n            right += 1\n\n        return max_len\n\n    max_t = maxConsecutiveChar(answerKey, k, \"T\")\n    max_f = maxConsecutiveChar(answerKey, k, \"F\")\n\n    return max(max_t, max_f)\n\n\n# |-----------------|---------|------------|\n# |  Approach       |  Time   |  Space     |\n# |-----------------|---------|------------|\n# | Sliding Window  |  O(N)   |  O(1)      |\n# |-----------------|---------|------------|\n\n\nanswerKey = \"TTFF\"\nk = 2\nprint(maxConsecutiveAnswers1(answerKey, k))  # 4\nprint(maxConsecutiveAnswers2(answerKey, k))  # 4\n</code></pre>"},{"location":"LeetPattern/stack/","title":"Stack","text":""},{"location":"LeetPattern/stack/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2390. Removing Stars From a String (Medium)</li> <li> 1544. Make The String Great (Easy)</li> <li> 20. Valid Parentheses (Easy)</li> <li> 155. Min Stack (Medium)</li> <li> 150. Evaluate Reverse Polish Notation (Medium)</li> <li> 394. Decode String (Medium)</li> <li> 22. Generate Parentheses (Medium)</li> <li> 853. Car Fleet (Medium)</li> <li> 224. Basic Calculator (Hard)</li> <li> 227. Basic Calculator II (Medium)</li> <li> 772. Basic Calculator III (Hard) \ud83d\udc51</li> <li> 770. Basic Calculator IV (Hard)</li> </ul>"},{"location":"LeetPattern/stack/#2390-removing-stars-from-a-string","title":"2390. Removing Stars From a String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack, Simulation</p> </li> </ul> Python <pre><code>\"\"\"\n-   Remove all `*` characters and their adjacent characters from the string.\n-   Steps for the string `leet**cod*e`:\n\n| char | action | stack   |\n| ---- | ------ | ------- |\n| l    | push   | \"l\"     |\n| e    | push   | \"le\"    |\n| e    | push   | \"lee\"   |\n| t    | push   | \"leet\"  |\n| *    | pop    | \"lee\"   |\n| *    | pop    | \"le\"    |\n| c    | push   | \"lec\"   |\n| o    | push   | \"leco\"  |\n| d    | push   | \"lecod\" |\n| *    | pop    | \"leco\"  |\n| e    | push   | \"lecoe\" |\n\"\"\"\n\n\n# Stack\ndef removeStars(s: str) -&gt; str:\n    stack = []\n\n    for char in s:\n        if char == \"*\":\n            stack.pop()\n        else:\n            stack.append(char)\n\n    return \"\".join(stack)\n\n\ns = \"leet**cod*e\"\nprint(removeStars(s))  # \"lecoe\"\n</code></pre>"},{"location":"LeetPattern/stack/#1544-make-the-string-great","title":"1544. Make The String Great","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack</p> </li> </ul> Python <pre><code>\"\"\"\n-   Remove all adjacent characters that are the same and have different cases.\n-   Steps for the string `leEeetcode`:\n\n| char | action | stack      |\n| ---- | ------ | ---------- |\n| l    | push   | \"l\"        |\n| e    | push   | \"le\"       |\n| E    | pop    | \"l\"        |\n| e    | push   | \"le\"       |\n| e    | push   | \"lee\"      |\n| t    | push   | \"leet\"     |\n| c    | push   | \"leetc\"    |\n| o    | push   | \"leetco\"   |\n| d    | push   | \"leetcod\"  |\n| e    | push   | \"leetcode\" |\n\"\"\"\n\n\n# Stack\ndef makeGood(s: str) -&gt; str:\n    stack = []\n\n    for i in range(len(s)):\n        if stack and stack[-1] == s[i].swapcase():\n            stack.pop()\n        else:\n            stack.append(s[i])\n    return \"\".join(stack)\n\n\nprint(makeGood(\"leEeetcode\"))  # \"leetcode\"\n</code></pre>"},{"location":"LeetPattern/stack/#20-valid-parentheses","title":"20. Valid Parentheses","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack</p> </li> </ul> PythonCPP <pre><code># Stack\ndef is_valid(s: str) -&gt; bool:\n    if len(s) % 2:\n        return False\n\n    pairs = {\n        \"(\": \")\",\n        \"{\": \"}\",\n        \"[\": \"]\",\n    }\n    stack = []\n    for ch in s:\n        if ch in pairs:\n            stack.append(ch)\n        elif not stack or ch != pairs[stack.pop()]:\n            return False\n\n    return True if not stack else False\n\n\ndef test_is_valid():\n    assert is_valid(\"()[]{}\")\n    assert not is_valid(\"(]\")\n    assert not is_valid(\"([)]\")\n    assert is_valid(\"{[]}\")\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;stack&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool isValid(string s) {\n        unordered_map&lt;char, char&gt; map{{')', '('}, {'}', '{'}, {']', '['}};\n        stack&lt;char&gt; stack;\n        if (s.length() % 2 == 1) return false;\n\n        for (char&amp; ch : s) {\n            if (stack.empty() || map.find(ch) == map.end()) {\n                stack.push(ch);\n            } else {\n                if (map[ch] != stack.top()) {\n                    return false;\n                }\n                stack.pop();\n            }\n        }\n        return stack.empty();\n    }\n};\n\nint main() {\n    Solution s;\n    assert(s.isValid(\"()\") == true);\n    assert(s.isValid(\"()[]{}\") == true);\n    assert(s.isValid(\"(]\") == false);\n    assert(s.isValid(\"([)]\") == false);\n    assert(s.isValid(\"{[]}\") == true);\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/stack/#155-min-stack","title":"155. Min Stack","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Stack, Design</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Implement a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\"\"\"\n\n\n# Stack\nclass MinStack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, val: int) -&gt; None:\n        if self.stack:\n            self.stack.append((val, min(val, self.getMin())))\n        else:\n            self.stack.append((val, val))\n\n    def pop(self) -&gt; None:\n        self.stack.pop()\n\n    def top(self) -&gt; int:\n        return self.stack[-1][0]\n\n    def getMin(self) -&gt; int:\n        return self.stack[-1][1]\n\n\nobj = MinStack()\nobj.push(3)\nobj.push(2)\nobj.pop()\nprint(obj.top())  # 3\nprint(obj.getMin())  # 3\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;climits&gt;\n#include &lt;iostream&gt;\n#include &lt;stack&gt;\n#include &lt;utility&gt;\nusing namespace std;\n\nclass MinStack {\n    stack&lt;pair&lt;int, int&gt;&gt; st;\n\n   public:\n    MinStack() { st.emplace(0, INT_MAX); }\n\n    void push(int val) { st.emplace(val, min(getMin(), val)); }\n\n    void pop() { st.pop(); }\n\n    int top() { return st.top().first; }\n\n    int getMin() { return st.top().second; }\n};\n\nint main() {\n    MinStack minStack;\n    minStack.push(-2);\n    minStack.push(0);\n    minStack.push(-3);\n    cout &lt;&lt; minStack.getMin() &lt;&lt; endl;  // -3\n    minStack.pop();\n    cout &lt;&lt; minStack.top() &lt;&lt; endl;     // 0\n    cout &lt;&lt; minStack.getMin() &lt;&lt; endl;  // -2\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/stack/#150-evaluate-reverse-polish-notation","title":"150. Evaluate Reverse Polish Notation","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Stack</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Stack\ndef evalRPN(tokens: List[str]) -&gt; int:\n    stack = []\n\n    for c in tokens:\n        if c == \"+\":\n            stack.append(stack.pop() + stack.pop())\n        elif c == \"-\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(b - a)\n        elif c == \"*\":\n            stack.append(stack.pop() * stack.pop())\n        elif c == \"/\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(int(b / a))\n        else:\n            stack.append(int(c))\n\n    return stack[0]\n\n\ndef test_evalRPN():\n    print(evalRPN([\"2\", \"1\", \"+\", \"3\", \"*\"]))  # 9\n    print(evalRPN([\"4\", \"13\", \"5\", \"/\", \"-\"]))  # 2\n    print(evalRPN([\"18\"]))  # 18\n    print(evalRPN([\"4\", \"3\", \"-\"]))  # 1\n</code></pre>"},{"location":"LeetPattern/stack/#394-decode-string","title":"394. Decode String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack, Recursion</p> </li> </ul> Python <pre><code># Stack\ndef decodeString(s: str) -&gt; str:\n    stack = []  # (str, int)\n    num = 0\n    res = \"\"\n\n    for c in s:\n        if c.isdigit():\n            num = num * 10 + int(c)\n        elif c == \"[\":\n            stack.append((res, num))\n            res, num = \"\", 0\n        elif c == \"]\":\n            top = stack.pop()\n            res = top[0] + res * top[1]\n        else:\n            res += c\n\n    return res\n\n\ns = \"3[a2[c]]\"\nprint(decodeString(s))  # accaccacc\n</code></pre>"},{"location":"LeetPattern/stack/#22-generate-parentheses","title":"22. Generate Parentheses","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Backtracking</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Backtracking\ndef generateParenthesis1(n: int) -&gt; List[str]:\n    path, res = [], []\n\n    def dfs(openN, closeN):\n        if openN == closeN == n:\n            res.append(\"\".join(path))\n            return\n\n        if openN &lt; n:\n            path.append(\"(\")\n            dfs(openN + 1, closeN)\n            path.pop()\n\n        if closeN &lt; openN:\n            path.append(\")\")\n            dfs(openN, closeN + 1)\n            path.pop()\n\n    dfs(0, 0)\n\n    return res\n\n\n# Backtracking\ndef generateParenthesis2(n: int) -&gt; List[str]:\n    m = n * 2\n    res, path = [], [\"\"] * m\n\n    def dfs(i, left):\n        if i == m:\n            res.append(\"\".join(path))\n            return\n\n        if left &lt; n:\n            path[i] = \"(\"\n            dfs(i + 1, left + 1)\n        if i - left &lt; left:\n            path[i] = \")\"\n            dfs(i + 1, left)\n\n    dfs(0, 0)\n    return res\n\n\nif __name__ == \"__main__\":\n    print(generateParenthesis1(3))\n    # ['((()))', '(()())', '(())()', '()(())', '()()()']\n    print(generateParenthesis2(3))\n    # ['((()))', '(()())', '(())()', '()(())', '()()()']\n</code></pre>"},{"location":"LeetPattern/stack/#853-car-fleet","title":"853. Car Fleet","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Stack, Sorting, Monotonic Stack</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Stack\ndef carFleet(target: int, position: List[int], speed: List[int]) -&gt; int:\n    cars = sorted(zip(position, speed), reverse=True)\n    stack = []\n\n    for p, s in cars:\n        time = (target - p) / s\n\n        if not stack or time &gt; stack[-1]:\n            stack.append(time)\n\n    return len(stack)\n\n\nprint(carFleet(12, [10, 8, 0, 5, 3], [2, 4, 1, 1, 3]))  # 3\n</code></pre>"},{"location":"LeetPattern/stack/#224-basic-calculator","title":"224. Basic Calculator","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String, Stack, Recursion</p> </li> </ul> Python <pre><code># Stack\ndef calculate(s: str) -&gt; int:\n    stack = []\n    result = 0\n    number = 0\n    sign = 1\n\n    for char in s:\n        if char.isdigit():\n            number = number * 10 + int(char)\n\n        elif char == \"+\":\n            result += sign * number\n            number = 0\n            sign = 1\n        elif char == \"-\":\n            result += sign * number\n            number = 0\n            sign = -1\n\n        elif char == \"(\":\n            stack.append(result)\n            stack.append(sign)\n            result = 0\n            sign = 1\n        elif char == \")\":\n            result += sign * number\n            number = 0\n            result *= stack.pop()  # pop sign\n            result += stack.pop()  # pop previous result\n\n    result += sign * number\n\n    return result\n\n\nprint(calculate(\"(1+(4+5+2)-3)+(6+8)\"))  # 23\n</code></pre>"},{"location":"LeetPattern/stack/#227-basic-calculator-ii","title":"227. Basic Calculator II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String, Stack</p> </li> </ul> Python <pre><code># Stack\ndef calculate(s: str) -&gt; int:\n    stack = []\n    num = 0\n    sign = \"+\"\n\n    for index, char in enumerate(s):\n        if char.isdigit():\n            num = num * 10 + int(char)\n\n        if char in \"+-*/\" or index == len(s) - 1:\n            if sign == \"+\":\n                stack.append(num)\n            elif sign == \"-\":\n                stack.append(-num)\n            elif sign == \"*\":\n                stack.append(stack.pop() * num)\n            elif sign == \"/\":\n                stack.append(int(stack.pop() / num))\n            sign = char\n            num = 0\n\n    return sum(stack)\n\n\ns = \"3+2*2\"\nprint(calculate(s))  # 7\n</code></pre>"},{"location":"LeetPattern/stack/#772-basic-calculator-iii","title":"772. Basic Calculator III \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String, Stack, Recursion</p> </li> </ul> Python <pre><code># Stack\ndef calculate(s: str) -&gt; int:\n    def helper(index):\n        stack = []\n        num = 0\n        sign = \"+\"\n\n        while index &lt; len(s):\n            char = s[index]\n            if char.isdigit():\n                num = num * 10 + int(char)\n            if char == \"(\":\n                num, index = helper(index + 1)\n            if char in \"+-*/)\" or index == len(s) - 1:\n                if sign == \"+\":\n                    stack.append(num)\n                elif sign == \"-\":\n                    stack.append(-num)\n                elif sign == \"*\":\n                    stack.append(stack.pop() * num)\n                elif sign == \"/\":\n                    stack.append(int(stack.pop() / num))  # \u5411\u96f6\u53d6\u6574\n                num = 0\n                sign = char\n            if char == \")\":\n                break\n            index += 1\n\n        return sum(stack), index\n\n    s = s.replace(\" \", \"\")\n    result, _ = helper(0)\n\n    return result\n\n\ns = \"2*(5+5*2)/3+(6/2+8)\"\nprint(calculate(s))  # 21\n</code></pre>"},{"location":"LeetPattern/stack/#770-basic-calculator-iv","title":"770. Basic Calculator IV","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Math, String, Stack, Recursion</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Stack\nclass Solution:\n    def __init__(self):\n        self.operators = set([\"+\", \"-\", \"*\"])\n\n    def basicCalculatorIV(\n        self, expression: str, evalvars: List[str], evalints: List[int]\n    ) -&gt; List[str]:\n        evalmap = dict(zip(evalvars, evalints))\n        tokens = self.parse_expression(expression)\n        result_terms = self.evaluate(tokens, evalmap)\n        return self.format_result(result_terms)\n\n    def parse_expression(self, expression):\n        tokens = []\n        i = 0\n        while i &lt; len(expression):\n            if expression[i].isalnum():  # Variable or digit\n                start = i\n                while i &lt; len(expression) and (\n                    expression[i].isalnum() or expression[i] == \"_\"\n                ):\n                    i += 1\n                tokens.append(expression[start:i])\n            elif expression[i] in self.operators or expression[i] in \"()\":\n                tokens.append(expression[i])\n                i += 1\n            elif expression[i] == \" \":\n                i += 1  # skip whitespace\n        return tokens\n\n    def evaluate(self, tokens, evalmap):\n        def apply_operator(op, b, a):\n            if op == \"+\":\n                return self.add_terms(a, b)\n            elif op == \"-\":\n                return self.add_terms(a, self.negate_terms(b))\n            elif op == \"*\":\n                return self.multiply_terms(a, b)\n\n        def process_token(token):\n            if token.isalnum():\n                if token in evalmap:\n                    stack.append({(): evalmap[token]})\n                elif token.isdigit():\n                    stack.append({(): int(token)})\n                else:\n                    stack.append({(token,): 1})\n            elif token == \"(\":\n                ops.append(token)\n            elif token == \")\":\n                while ops and ops[-1] != \"(\":\n                    operate()\n                ops.pop()\n            else:\n                while (\n                    ops\n                    and ops[-1] in precedence\n                    and precedence[ops[-1]] &gt;= precedence[token]\n                ):\n                    operate()\n                ops.append(token)\n\n        def operate():\n            if len(stack) &lt; 2 or not ops:\n                return\n            b = stack.pop()\n            a = stack.pop()\n            op = ops.pop()\n            stack.append(apply_operator(op, b, a))\n\n        stack = []\n        ops = []\n        precedence = {\"+\": 1, \"-\": 1, \"*\": 2}\n\n        for token in tokens:\n            process_token(token)\n\n        while ops:\n            operate()\n        return self.combine_terms(stack[-1])\n\n    def add_terms(self, a, b):\n        result = defaultdict(int, a)\n        for term, coef in b.items():\n            result[term] += coef\n        return dict(result)\n\n    def negate_terms(self, a):\n        return {term: -coef for term, coef in a.items()}\n\n    def multiply_terms(self, a, b):\n        result = defaultdict(int)\n        for term1, coef1 in a.items():\n            for term2, coef2 in b.items():\n                new_term = tuple(sorted(term1 + term2))\n                result[new_term] += coef1 * coef2\n        return dict(result)\n\n    def combine_terms(self, terms):\n        result = defaultdict(int)\n        for term, coef in terms.items():\n            if coef != 0:\n                result[term] = coef\n        return dict(result)\n\n    def format_result(self, result_terms):\n        result = []\n        for term in sorted(result_terms.keys(), key=lambda x: (-len(x), x)):\n            coef = result_terms[term]\n            if coef != 0:\n                term_str = \"*\".join(term)\n                if term_str:\n                    result.append(f\"{coef}*{term_str}\")\n                else:\n                    result.append(str(coef))\n        return result\n\n\ncalculator = Solution()\nexpression = \"e + 8 - a + 5\"\nevalvars = [\"e\"]\nevalints = [1]\nprint(calculator.basicCalculatorIV(expression, evalvars, evalints))\n# ['-1*a', '14']\n</code></pre>"},{"location":"LeetPattern/stack_monotonic/","title":"Stack Monotonic","text":""},{"location":"LeetPattern/stack_monotonic/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 739. Daily Temperatures (Medium)</li> <li> 496. Next Greater Element I (Easy)</li> <li> 503. Next Greater Element II (Medium)</li> <li> 84. Largest Rectangle in Histogram (Hard)</li> <li> 85. Maximal Rectangle (Hard)</li> <li> 42. Trapping Rain Water (Hard)</li> <li> 901. Online Stock Span (Medium)</li> <li> 316. Remove Duplicate Letters (Medium)</li> <li> 456. 132 Pattern (Medium)</li> <li> 2281. Sum of Total Strength of Wizards (Hard)</li> </ul>"},{"location":"LeetPattern/stack_monotonic/#739-daily-temperatures","title":"739. Daily Temperatures","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Stack, Monotonic Stack</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return an array `res` such that `res[i]` is the number of days you have to wait after the `ith` day to get a warmer temperature.\n\n| Index | Temp | &gt; stack last | stack                           | result    |\n| ----- | ---- | ------------ | ------------------------------- | --------- |\n| 0     | 73   | False        | `[ [73, 0] ]`                   | 1 - 0 = 1 |\n| 1     | 74   | True         | `[ [74, 1] ]`                   | 2 - 1 = 1 |\n| 2     | 75   | True         | `[ [75, 2] ]`                   | 6 - 2 = 4 |\n| 3     | 71   | False        | `[ [75, 2], [71, 3] ]`          | 5 - 3 = 2 |\n| 4     | 69   | False        | `[ [75, 2], [71, 3], [69, 4] ]` | 5 - 4 = 1 |\n| 5     | 72   | True         | `[ [75, 2], [72, 5] ]`          | 6 - 5 = 1 |\n| 6     | 76   | True         | `[ [76, 6] ]`                   | 0         |\n| 7     | 73   | False        | `[[76, 6], [73, 7]]`            | 0         |\n\"\"\"\n\nfrom typing import List\n\n\n# Monotonic Stack\ndef dailyTemperatures(temperatures: List[int]) -&gt; List[int]:\n    res = [0 for _ in range(len(temperatures))]\n    stack = []  # [temp, index]\n\n    for i, temp in enumerate(temperatures):\n        while stack and temp &gt; stack[-1][0]:\n            _, idx = stack.pop()\n            res[idx] = i - idx\n\n        stack.append([temp, i])\n\n    return res\n\n\nprint(dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73]))\n# [1, 1, 4, 2, 1, 1, 0, 0]\n</code></pre>"},{"location":"LeetPattern/stack_monotonic/#496-next-greater-element-i","title":"496. Next Greater Element I","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Stack, Monotonic Stack</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Monotonic Stack\ndef nextGreaterElement(nums1: List[int], nums2: List[int]) -&gt; List[int]:\n    next_greater = {}\n    stack = []\n    result = []\n\n    for num in nums2:\n        while stack and num &gt; stack[-1]:\n            next_greater[stack.pop()] = num\n        stack.append(num)\n\n    for num in nums1:\n        result.append(next_greater.get(num, -1))\n\n    return result\n\n\nnums1 = [4, 1, 2]\nnums2 = [1, 3, 4, 2]\nprint(nextGreaterElement(nums1, nums2))  # [3, -1, -1]\n</code></pre>"},{"location":"LeetPattern/stack_monotonic/#503-next-greater-element-ii","title":"503. Next Greater Element II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Stack, Monotonic Stack</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Monotonic Stack\ndef nextGreaterElements(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    result = [-1] * n\n    stack = []\n\n    for i in range(2 * n):\n        while stack and nums[stack[-1]] &lt; nums[i % n]:\n            result[stack.pop()] = nums[i % n]\n        if i &lt; n:\n            stack.append(i)\n\n    return result\n\n\nnums = [1, 2, 1]\nprint(nextGreaterElements(nums))  # [2, -1, 2]\n</code></pre>"},{"location":"LeetPattern/stack_monotonic/#84-largest-rectangle-in-histogram","title":"84. Largest Rectangle in Histogram","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Stack, Monotonic Stack</p> </li> </ul> Python <pre><code>from typing import List\n\n\nclass LargestRectangleArea:\n    def monotonic_stack(self, heights: List[int]) -&gt; int:\n        stack = []\n        res = 0\n        n = len(heights)\n\n        for i in range(n + 1):\n            h = heights[i] if i &lt; n else 0\n\n            while stack and h &lt; heights[stack[-1]]:\n                height = heights[stack.pop()]\n                width = i if not stack else i - stack[-1] - 1\n                res = max(res, height * width)\n\n            stack.append(i)\n\n        return res\n\n\nif __name__ == \"__main__\":\n    sol = LargestRectangleArea()\n    assert sol.monotonic_stack([2, 1, 5, 6, 2, 3]) == 10\n    assert sol.monotonic_stack([2, 4]) == 4\n</code></pre>"},{"location":"LeetPattern/stack_monotonic/#85-maximal-rectangle","title":"85. Maximal Rectangle","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Stack, Matrix, Monotonic Stack</p> </li> </ul> Python <pre><code>from typing import List\n\n\nclass maximalRectangle:\n    \"\"\"\n    prerequisite: 84. Largest Rectangle in Histogram\n    \"\"\"\n\n    def monotonic_stack(self, matrix: List[List[str]]) -&gt; int:\n        if not matrix or not matrix[0]:\n            return 0\n\n        n = len(matrix[0])\n        heights = [0] * (n + 1)\n        res = 0\n\n        for row in matrix:\n            for i in range(n):\n                if row[i] == \"1\":\n                    heights[i] += 1\n                else:\n                    heights[i] = 0\n\n            stack = [-1]\n            for i in range(n + 1):\n                while heights[i] &lt; heights[stack[-1]]:\n                    h = heights[stack.pop()]\n                    w = i - stack[-1] - 1\n                    res = max(res, h * w)\n                stack.append(i)\n\n        return res\n\n\nif __name__ == \"__main__\":\n    sol = maximalRectangle()\n    matrix = [\n        [\"1\", \"0\", \"1\", \"0\", \"0\"],\n        [\"1\", \"0\", \"1\", \"1\", \"1\"],\n        [\"1\", \"1\", \"1\", \"1\", \"1\"],\n        [\"1\", \"0\", \"0\", \"1\", \"0\"],\n    ]\n    assert sol.monotonic_stack(matrix) == 6\n</code></pre>"},{"location":"LeetPattern/stack_monotonic/#42-trapping-rain-water","title":"42. Trapping Rain Water","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Dynamic Programming, Stack, Monotonic Stack</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- ![42](../../assets/0042.png)\n\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/ZI2z5pq0TqA?si=OEYg01dbmzvmtIwZ\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen&gt;&lt;/iframe&gt;\n\n| Approach   | Time | Space |\n| ---------- | ---- | ----- |\n| DP         | O(N) | O(N)  |\n| Left Right | O(N) | O(1)  |\n| Monotonic  | O(N) | O(N)  |\n\"\"\"\n\nfrom typing import List\n\n\n# DP\ndef trapDP(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    n = len(height)\n    maxLeft, maxRight = [0 for _ in range(n)], [0 for _ in range(n)]\n\n    for i in range(1, n):\n        maxLeft[i] = max(maxLeft[i - 1], height[i - 1])\n\n    for i in range(n - 2, -1, -1):\n        maxRight[i] = max(maxRight[i + 1], height[i + 1])\n\n    res = 0\n    for i in range(n):\n        res += max(0, min(maxLeft[i], maxRight[i]) - height[i])\n\n    return res\n\n\n# Left Right Pointers\ndef trapLR(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    left, right = 0, len(height) - 1\n    maxL, maxR = height[left], height[right]\n    res = 0\n\n    while left &lt; right:\n        if maxL &lt; maxR:\n            left += 1\n            maxL = max(maxL, height[left])\n            res += maxL - height[left]\n        else:\n            right -= 1\n            maxR = max(maxR, height[right])\n            res += maxR - height[right]\n\n    return res\n\n\n# Monotonic Stack\ndef trapStack(height: List[int]) -&gt; int:\n    stack = []\n    total = 0\n\n    for i in range(len(height)):\n        while stack and height[i] &gt; height[stack[-1]]:\n            top = stack.pop()\n            if not stack:\n                break\n            distance = i - stack[-1] - 1\n            bounded_height = min(height[i], height[stack[-1]]) - height[top]\n            total += distance * bounded_height\n        stack.append(i)\n\n    return total\n\n\nheight = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\nprint(trapDP(height))  # 6\nprint(trapLR(height))  # 6\nprint(trapStack(height))  # 6\n</code></pre> <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int trap(vector&lt;int&gt; &amp;height)\n    {\n        if (height.empty())\n            return 0;\n\n        int res = 0;\n        int left = 0, right = height.size() - 1;\n        int maxL = height[left], maxR = height[right];\n\n        while (left &lt; right)\n        {\n            if (maxL &lt; maxR)\n            {\n                left++;\n                maxL = max(maxL, height[left]);\n                res += maxL - height[left];\n            }\n            else\n            {\n                right--;\n                maxR = max(maxR, height[right]);\n                res += maxR - height[right];\n            }\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    vector&lt;int&gt; height = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};\n    Solution solution;\n    cout &lt;&lt; solution.trap(height) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/stack_monotonic/#901-online-stock-span","title":"901. Online Stock Span","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Stack, Design, Monotonic Stack, Data Stream</p> </li> </ul> Python <pre><code>\"\"\"\n-   Design a class `StockSpanner` to return the number of consecutive days (including the current day) the price of the stock has been less than or equal to the current price.\n\"\"\"\n\nfrom typing import List\n\n\n# Monotonic Stack\nclass StockSpanner:\n\n    def __init__(self):\n        self.stack = [(-1, float(\"inf\"))]\n        self.cur_day = -1\n\n    def next(self, price: int) -&gt; int:\n        while price &gt;= self.stack[-1][1]:\n            self.stack.pop()\n        self.cur_day += 1\n        self.stack.append((self.cur_day, price))\n        return self.cur_day - self.stack[-2][0]\n\n\nif __name__ == \"__main__\":\n    ss = StockSpanner()\n    prices = [100, 80, 60, 70, 60, 75, 85]\n    print([ss.next(price) for price in prices])  # [1, 1, 1, 2, 1, 4, 6]\n</code></pre>"},{"location":"LeetPattern/stack_monotonic/#316-remove-duplicate-letters","title":"316. Remove Duplicate Letters","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack, Greedy, Monotonic Stack</p> </li> </ul> Python <pre><code># Monotonic Stack\ndef removeDuplicateLetters(s: str) -&gt; str:\n    stack = []\n    seen = set()\n    last = {c: i for i, c in enumerate(s)}\n\n    for i, c in enumerate(s):\n        if c not in seen:\n            while stack and c &lt; stack[-1] and i &lt; last[stack[-1]]:\n                seen.discard(stack.pop())\n            seen.add(c)\n            stack.append(c)\n\n    return \"\".join(stack)\n\n\ns = \"cbacdcbc\"\nprint(removeDuplicateLetters(s))  # acdb\n</code></pre>"},{"location":"LeetPattern/stack_monotonic/#456-132-pattern","title":"456. 132 Pattern","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Stack, Monotonic Stack, Ordered Set</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Monotonic Stack\ndef find132pattern(nums: List[int]) -&gt; bool:\n    n = len(nums)\n    if n &lt; 3:\n        return False\n\n    stack = []\n    second_max = float(\"-inf\")\n\n    for i in range(n - 1, -1, -1):\n        if nums[i] &lt; second_max:\n            return True\n\n        while stack and stack[-1] &lt; nums[i]:\n            second_max = stack.pop()\n\n        stack.append(nums[i])\n\n    return False\n\n\nnums = [-1, 3, 2, 0]\nprint(find132pattern(nums))  # True\n</code></pre>"},{"location":"LeetPattern/stack_monotonic/#2281-sum-of-total-strength-of-wizards","title":"2281. Sum of Total Strength of Wizards","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Stack, Monotonic Stack, Prefix Sum</p> </li> </ul> Python <pre><code>from itertools import accumulate\nfrom typing import List\n\n\n# Monotonic Stack\ndef totalStrength(strength: List[int]) -&gt; int:\n    n = len(strength)\n    left = [-1 for _ in range(n)]\n    right = [n for _ in range(n)]\n    stack = []\n\n    for i, v in enumerate(strength):\n        while stack and strength[stack[-1]] &gt;= v:\n            right[stack.pop()] = i\n        if stack:\n            left[i] = stack[-1]\n        stack.append(i)\n\n    prefix_sum = list(accumulate(accumulate(strength, initial=0), initial=0))\n\n    ans = 0\n    for i, v in enumerate(strength):\n        l, r = left[i] + 1, right[i] - 1\n        tot = (i - l + 1) * (prefix_sum[r + 2] - prefix_sum[i + 1]) - (r - i + 1) * (\n            prefix_sum[i + 1] - prefix_sum[l]\n        )\n        ans += v * tot\n\n    return ans % (10**9 + 7)\n\n\nstrength = [1, 3, 1, 2]\nprint(totalStrength(strength))  # 44\n</code></pre>"},{"location":"LeetPattern/string/","title":"String","text":""},{"location":"LeetPattern/string/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 344. Reverse String (Easy)</li> <li> 541. Reverse String II (Easy)</li> <li> 151. Reverse Words in a String (Medium)</li> <li> 58. Length of Last Word (Easy)</li> <li> 844. Backspace String Compare (Easy)</li> <li> 2185. Counting Words With a Given Prefix (Easy)</li> <li> 2000. Reverse Prefix of Word (Easy)</li> </ul>"},{"location":"LeetPattern/string/#344-reverse-string","title":"344. Reverse String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\ndef reverseString(s: List[str]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify s in-place instead.\n    \"\"\"\n    left, right = 0, len(s) - 1\n\n    while left &lt; right:\n        s[left], s[right] = s[right], s[left]\n        left += 1\n        right -= 1\n\n\ns = [\"h\", \"e\", \"l\", \"l\", \"o\"]\nreverseString(s)\nprint(s)  # ['o', 'l', 'l', 'e', 'h']\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    void reverseString(vector&lt;char&gt;&amp; s) {\n        int left = 0, right = s.size() - 1;\n        while (left &lt; right) {\n            swap(s[left], s[right]);\n\n            left++;\n            right--;\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;char&gt; s = {'h', 'e', 'l', 'l', 'o'};\n    solution.reverseString(s);\n    assert(s == vector&lt;char&gt;({'o', 'l', 'l', 'e', 'h'}));\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/string/#541-reverse-string-ii","title":"541. Reverse String II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String</p> </li> </ul> Python <pre><code>def reverseStr(s: str, k: int) -&gt; str:\n    def reverse_substring(text):\n        left, right = 0, len(text) - 1\n        while left &lt; right:\n            text[left], text[right] = text[right], text[left]\n            left += 1\n            right -= 1\n        return text\n\n    result = list(s)\n\n    for i in range(0, len(s), 2 * k):\n        result[i : i + k] = reverse_substring(result[i : i + k])\n\n    return \"\".join(result)\n\n\ns = \"abcdefg\"\nk = 2\nprint(reverseStr(s, k))  # \"bacdfeg\"\n</code></pre>"},{"location":"LeetPattern/string/#151-reverse-words-in-a-string","title":"151. Reverse Words in a String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String</p> </li> </ul> Python <pre><code>def reverseWords(s: str) -&gt; str:\n    words = s.split()\n\n    left, right = 0, len(words) - 1\n\n    while left &lt; right:\n        words[left], words[right] = words[right], words[left]\n        left += 1\n        right -= 1\n\n    return \" \".join(words)\n\n\ns = \"the sky is blue\"\nprint(reverseWords(s))  # \"blue is sky the\"\n</code></pre>"},{"location":"LeetPattern/string/#58-length-of-last-word","title":"58. Length of Last Word","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String</p> </li> </ul> Python <pre><code>class lengthOfLastWord:\n    def array(self, s: str) -&gt; int:\n        res = 0\n\n        for i in range(len(s) - 1, -1, -1):\n            if s[i] != \" \":\n                res += 1\n            elif s[i] == \" \" and res &gt; 0:\n                return res\n\n        return res\n\n\nif __name__ == \"__main__\":\n    solution = lengthOfLastWord()\n    assert solution.array(\"Hello World\") == 5\n</code></pre>"},{"location":"LeetPattern/string/#844-backspace-string-compare","title":"844. Backspace String Compare","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Stack, Simulation</p> </li> </ul> Python <pre><code>def backspaceCompare(s: str, t: str) -&gt; bool:\n\n    def build(text):\n        stack = []\n\n        for char in text:\n            if char != \"#\":\n                stack.append(char)\n            elif stack:\n                stack.pop()\n\n        return \"\".join(stack)\n\n    return build(s) == build(t)\n\n\nprint(backspaceCompare(\"ab#c\", \"ad#c\"))  # True\n</code></pre>"},{"location":"LeetPattern/string/#2185-counting-words-with-a-given-prefix","title":"2185. Counting Words With a Given Prefix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, String Matching</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# 1\ndef prefixCount1(words: List[str], pref: str) -&gt; int:\n    count = 0\n\n    for word in words:\n        if word.startswith(pref):\n            count += 1\n\n    return count\n\n\n# 2\ndef prefixCount2(words: List[str], pref: str) -&gt; int:\n    count = 0\n\n    for word in words:\n        n = len(pref)\n\n        if len(word) &lt; n:\n            continue\n\n        if word[:n] == pref:\n            count += 1\n\n    return count\n\n\nwords = [\"pay\", \"attention\", \"practice\", \"attend\"]\npref = \"at\"\nprint(prefixCount1(words, pref))  # 2\nprint(prefixCount2(words, pref))  # 2\n</code></pre>"},{"location":"LeetPattern/string/#2000-reverse-prefix-of-word","title":"2000. Reverse Prefix of Word","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Stack</p> </li> </ul> Python <pre><code>def reversePrefix(word: str, ch: str) -&gt; str:\n    if ch not in word:\n        return word\n\n    wordList = list(word)\n    left, right = 0, 0\n\n    for i in range(len(wordList)):\n        if wordList[i] == ch:\n            right = i\n            break\n\n    while left &lt; right:\n        wordList[left], wordList[right] = wordList[right], wordList[left]\n        left += 1\n        right -= 1\n\n    return \"\".join(wordList)\n\n\nword = \"abcdefd\"\nch = \"d\"\nprint(reversePrefix(word, ch))  # \"dcbaefd\"\n</code></pre>"},{"location":"LeetPattern/tree_bfs/","title":"Tree BFS","text":""},{"location":"LeetPattern/tree_bfs/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 199. Binary Tree Right Side View (Medium)</li> <li> 111. Minimum Depth of Binary Tree (Easy)</li> <li> 104. Maximum Depth of Binary Tree (Easy)</li> <li> 637. Average of Levels in Binary Tree (Easy)</li> <li> 429. N-ary Tree Level Order Traversal (Medium)</li> <li> 515. Find Largest Value in Each Tree Row (Medium)</li> <li> 116. Populating Next Right Pointers in Each Node (Medium)</li> <li> 117. Populating Next Right Pointers in Each Node II (Medium)</li> <li> 513. Find Bottom Left Tree Value (Medium)</li> <li> 863. All Nodes Distance K in Binary Tree (Medium)</li> </ul>"},{"location":"LeetPattern/tree_bfs/#199-binary-tree-right-side-view","title":"199. Binary Tree Right Side View","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Binary Tree BFS\ndef rightSideViewBFS(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        n = len(q)\n        for i in range(n):\n            node = q.popleft()\n            if i == n - 1:\n                res.append(node.val)\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return res\n\n\n# Binary Tree DFS\ndef rightSideViewDFS(root: Optional[TreeNode]) -&gt; List[int]:\n    \"\"\"\u540e\u5e8f\u904d\u5386\uff0c\u5148\u53f3\u540e\u5de6\uff0c\u9047\u5230\u7684\u7b2c\u4e00\u4e2a\u8282\u70b9\u5c31\u662f\u8be5\u6df1\u5ea6\u7684\u6700\u53f3\u4fa7\u8282\u70b9\"\"\"\n    ans = []\n\n    def dfs(node, depth):\n        if node is None:\n            return\n        if depth == len(ans):  # \u8fd9\u4e2a\u6df1\u5ea6\u9996\u6b21\u9047\u5230\n            ans.append(node.val)\n\n        dfs(node.right, depth + 1)\n        dfs(node.left, depth + 1)\n\n    dfs(root, 0)\n\n    return ans\n\n\nif __name__ == \"__main__\":\n    root = [1, 2, 2, 3, 4, None, 3, None, None, 5]\n    root = build(root)\n    print(root)\n    #     ____1\n    #    /     \\\n    #   2__     2\n    #  /   \\     \\\n    # 3     4     3\n    #      /\n    #     5\n    assert rightSideViewBFS(root) == [1, 2, 3, 5]\n    assert rightSideViewDFS(root) == [1, 2, 3, 5]\n</code></pre>"},{"location":"LeetPattern/tree_bfs/#111-minimum-depth-of-binary-tree","title":"111. Minimum Depth of Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Iterative\ndef minDepthIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n    res = 0\n\n    while q:\n        res += 1\n\n        for _ in range(len(q)):\n            node = q.popleft()\n\n            if not node.left and not node.right:\n                return res\n\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n\n# Recursive\ndef minDepthRecursive(root: Optional[TreeNode]) -&gt; int:\n    if root is None:\n        return 0\n\n    if root.left is None and root.right is not None:\n        return 1 + minDepthRecursive(root.right)\n    if root.left is not None and root.right is None:\n        return 1 + minDepthRecursive(root.left)\n\n    return 1 + min(minDepthRecursive(root.left), minDepthRecursive(root.right))\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n\"\"\"\n    ____1\n   /     \\\n  2__     2\n /   \\\n3     4\n     /\n    5\n\n\"\"\"\nprint(minDepthIterative(root))  # 2\nprint(minDepthRecursive(root))  # 2\n</code></pre>"},{"location":"LeetPattern/tree_bfs/#104-maximum-depth-of-binary-tree","title":"104. Maximum Depth of Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef maxDepthRecursive(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    left = maxDepthRecursive(root.left)\n    right = maxDepthRecursive(root.right)\n\n    return 1 + max(left, right)\n\n\n# DFS\ndef maxDepthDFS(root: Optional[TreeNode]) -&gt; int:\n    res = 0\n\n    def dfs(node, cnt):\n        if node is None:\n            return\n        cnt += 1\n        nonlocal res\n        res = max(res, cnt)\n\n        dfs(node.left, cnt)\n        dfs(node.right, cnt)\n\n    dfs(root, 0)\n\n    return res\n\n\n# Iterative\ndef maxDepthIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n    res = 0\n\n    while q:\n        res += 1\n        n = len(q)\n\n        for _ in range(n):\n            node = q.popleft()\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    root = [1, 2, 2, 3, 4, None, None, None, None, 5]\n    root = build(root)\n    print(root)\n    #     ____1\n    #    /     \\\n    #   2__     2\n    #  /   \\\n    # 3     4\n    #      /\n    #     5\n    assert maxDepthRecursive(root) == 4\n    assert maxDepthDFS(root) == 4\n    assert maxDepthIterative(root) == 4\n</code></pre>"},{"location":"LeetPattern/tree_bfs/#637-average-of-levels-in-binary-tree","title":"637. Average of Levels in Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Binary Tree BFS\ndef averageOfLevels(root: Optional[TreeNode]) -&gt; List[float]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        n = len(q)\n        level = 0\n        for _ in range(n):\n            cur = q.popleft()\n            level += cur.val\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(float(level / n))\n\n    return res\n\n\nif __name__ == \"__main__\":\n    root = [3, 9, 20, None, None, 15, 7]\n    root = build(root)\n    print(root)\n    #   3___\n    #  /    \\\n    # 9     _20\n    #      /   \\\n    #     15    7\n    assert averageOfLevels(root) == [3.00000, 14.50000, 11.00000]\n</code></pre>"},{"location":"LeetPattern/tree_bfs/#429-n-ary-tree-level-order-traversal","title":"429. N-ary Tree Level Order Traversal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Breadth First Search</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List, Optional\n\n\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\n\ndef levelOrder(root: Optional[Node]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    queue = deque([root])\n    result = []\n\n    while queue:\n        level = []\n        size = len(queue)\n\n        for _ in range(size):\n            node = queue.popleft()\n            level.append(node.val)\n\n            for child in node.children:\n                queue.append(child)\n\n        result.append(level)\n\n    return result\n\n\nroot = Node(\n    1,\n    [\n        Node(\n            3,\n            [\n                Node(5, []),\n                Node(6, []),\n            ],\n        ),\n        Node(2, []),\n        Node(4, []),\n    ],\n)\nprint(levelOrder(root))  # [[1], [3, 2, 4], [5, 6]]\n</code></pre>"},{"location":"LeetPattern/tree_bfs/#515-find-largest-value-in-each-tree-row","title":"515. Find Largest Value in Each Tree Row","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef largestValues(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    queue = deque([root])\n    result = []\n\n    while queue:\n        levelMax = float(\"-inf\")\n        for _ in range(len(queue)):\n            node = queue.popleft()\n\n            levelMax = max(levelMax, node.val)\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n        result.append(levelMax)\n\n    return result\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n#     ____1\n#    /     \\\n#   2__     2\n#  /   \\\n# 3     4\n#      /\n#     5\nprint(largestValues(root))  # [1, 2, 4, 5]\n</code></pre>"},{"location":"LeetPattern/tree_bfs/#116-populating-next-right-pointers-in-each-node","title":"116. Populating Next Right Pointers in Each Node","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>\"\"\"\n-   Perfect Binary Tree\n\"\"\"\n\nfrom collections import deque\nfrom typing import Optional\n\n\nclass Node:\n    def __init__(\n        self,\n        val: int = 0,\n        left: \"Node\" = None,\n        right: \"Node\" = None,\n        next: \"Node\" = None,\n    ):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\n\ndef connect(root: \"Optional[Node]\") -&gt; \"Optional[Node]\":\n    if not root:\n        return root\n\n    queue = deque([root])\n\n    while queue:\n        size = len(queue)\n        prev = None\n\n        for _ in range(size):\n            node = queue.popleft()\n\n            if prev:\n                prev.next = node\n            prev = node\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n    return root\n\n\n# Perfect binary tree creation\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.right.left = Node(6)\nroot.right.right = Node(7)\n#     __1__\n#    /     \\\n#   2__     3\n#  /   \\   / \\\n# 4     5 6   7\n\n\n# Connect the nodes\nconnect(root)\n#      __1__ -&gt; None\n#     /     \\\n#   _2_ -&gt;  3 -&gt; None\n#  /   \\   / \\\n# 4 -&gt; 5-&gt;6-&gt; 7 -&gt; None\n\n\nassert root.next is None\nassert root.left.next == root.right\nassert root.left.left.next == root.left.right\nassert root.left.right.next == root.right.left\nassert root.right.left.next == root.right.right\nassert root.right.right.next is None\nprint(\"All tests passed.\")\n</code></pre>"},{"location":"LeetPattern/tree_bfs/#117-populating-next-right-pointers-in-each-node-ii","title":"117. Populating Next Right Pointers in Each Node II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import Optional\n\n\nclass Node:\n    def __init__(\n        self,\n        val: int = 0,\n        left: Optional[\"Node\"] = None,\n        right: Optional[\"Node\"] = None,\n        next: Optional[\"Node\"] = None,\n    ):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\n\nclass connect:\n    def level_order(self, root: \"Node\") -&gt; \"Node\":\n        if not root:\n            return None\n\n        q = deque([root])\n\n        while q:\n            size = len(q)\n            prev = None\n\n            for _ in range(size):\n                node = q.popleft()\n\n                if prev:\n                    prev.next = node\n                prev = node\n\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n\n        return root\n\n\nif __name__ == \"__main__\":\n\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    root.right.right = Node(7)\n    #       1\n    #      / \\\n    #     2   3\n    #    / \\   \\\n    #   4   5   7\n\n    solution = connect()\n    root = solution.level_order(root)\n    assert root.next is None\n    assert root.left.next == root.right\n    assert root.right.next is None\n    assert root.left.left.next == root.left.right\n    assert root.left.right.next == root.right.right\n    assert root.right.right.next is None\n    #       1 -&gt; None\n    #      / \\\n    #     2 -&gt; 3 -&gt; None\n    #    / \\    \\\n    #   4 -&gt; 5 -&gt; 7 -&gt; None\n</code></pre>"},{"location":"LeetPattern/tree_bfs/#513-find-bottom-left-tree-value","title":"513. Find Bottom Left Tree Value","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef findBottomLeftValue(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    queue = deque([root])\n    result = 0\n\n    while queue:\n        size = len(queue)\n\n        for i in range(size):\n            node = queue.popleft()\n            if i == 0:\n                result = node.val\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n    return result\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n#     ____1\n#    /     \\\n#   2__     2\n#  /   \\\n# 3     4\n#      /\n#     5\n\nprint(findBottomLeftValue(root))  # 5\n</code></pre>"},{"location":"LeetPattern/tree_bfs/#863-all-nodes-distance-k-in-binary-tree","title":"863. All Nodes Distance K in Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BFS\ndef distanceK(root: TreeNode, target: TreeNode, k: int) -&gt; List[int]:\n    parent = dict()\n\n    def dfs(node, par=None):\n        if node:\n            parent[node] = par\n            dfs(node.left, node)\n            dfs(node.right, node)\n\n    dfs(root)\n\n    q = deque([(target, 0)])\n    seen = set([target])\n\n    while q:\n        node, dist = q.popleft()\n\n        if dist == k:\n            return [node.val] + [node.val for node, _ in q]\n\n        for nei in (node.left, node.right, parent[node]):\n            if nei and nei not in seen:\n                seen.add(nei)\n                q.append((nei, dist + 1))\n\n    return []\n\n\nroot = build([3, 5, 1, 6, 2, 0, 8, None, None, 7, 4])\nprint(root)\n#     ______3__\n#    /         \\\n#   5__         1\n#  /   \\       / \\\n# 6     2     0   8\n#      / \\\n#     7   4\ntarget = root.left\nk = 2\nprint(distanceK(root, target, k))  # [7, 4, 1]\n</code></pre>"},{"location":"LeetPattern/tree_feature/","title":"Tree Feature","text":""},{"location":"LeetPattern/tree_feature/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 101. Symmetric Tree (Easy)</li> <li> 222. Count Complete Tree Nodes (Easy)</li> <li> 110. Balanced Binary Tree (Easy)</li> <li> 257. Binary Tree Paths (Easy)</li> <li> 404. Sum of Left Leaves (Easy)</li> <li> 112. Path Sum (Easy)</li> <li> 2331. Evaluate Boolean Binary Tree (Easy)</li> <li> 100. Same Tree (Easy)</li> <li> 235. Lowest Common Ancestor of a Binary Search Tree (Medium)</li> <li> 236. Lowest Common Ancestor of a Binary Tree (Medium)</li> </ul>"},{"location":"LeetPattern/tree_feature/#101-symmetric-tree","title":"101. Symmetric Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> PythonCPP <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef is_symmetric_recursive(root: Optional[TreeNode]) -&gt; bool:\n    if not root:\n        return True\n\n    def check(left, right):\n        if left is right:\n            return True\n        if not left or not right or left.val != right.val:\n            return False\n        outside = check(left.left, right.right)\n        inside = check(left.right, right.left)\n        return outside and inside\n\n    return check(root.left, root.right)\n\n\n# Iterative\ndef is_symmetric_iterative(root: Optional[TreeNode]) -&gt; bool:\n    if not root:\n        return True\n\n    q = deque()\n    q.append(root.left)\n    q.append(root.right)\n\n    while q:\n        left = q.popleft()\n        right = q.popleft()\n\n        if not left and not right:\n            continue\n\n        if not left or not right or left.val != right.val:\n            return False\n\n        q.append(left.left)\n        q.append(right.right)\n        q.append(left.right)\n        q.append(right.left)\n\n    return True\n\n\nif __name__ == \"__main__\":\n    root = [1, 2, 2, 3, 4, 4, 3]\n    root = build(root)\n    print(root)\n    #     __1__\n    #    /     \\\n    #   2       2\n    #  / \\     / \\\n    # 3   4   4   3\n    assert is_symmetric_recursive(root) is True\n    assert is_symmetric_iterative(root) is True\n</code></pre> <pre><code>#include &lt;iostream&gt;\n\n#include \"include/trees.hpp\"\n\nclass Solution {\n   private:\n    bool dfs(TreeNode *Left, TreeNode *Right) {\n        if (Left == nullptr &amp;&amp; Right == nullptr) return true;\n        if (Left == nullptr || Right == nullptr || Left-&gt;val != Right-&gt;val)\n            return false;\n        return dfs(Left-&gt;left, Right-&gt;right) &amp;&amp; dfs(Left-&gt;right, Right-&gt;left);\n    }\n\n   public:\n    bool isSymmetric(TreeNode *root) {\n        return root == nullptr || dfs(root-&gt;left, root-&gt;right);\n    }\n};\n\nint main() {\n    Solution solution;\n    // Test with a symmetric tree\n    std::vector&lt;int&gt; values = {1, 2, 2, 3, 4, 4, 3};\n    TreeNode *root = TreeUtils::buildTree(values);\n    bool result = solution.isSymmetric(root);\n    std::cout &lt;&lt; \"Is symmetric: \" &lt;&lt; (result ? \"true\" : \"false\") &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/tree_feature/#222-count-complete-tree-nodes","title":"222. Count Complete Tree Nodes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Binary Search, Bit Manipulation, Tree, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef countNodesRecursive(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    num = 1 + countNodesRecursive(root.left) + countNodesRecursive(root.right)\n\n    return num\n\n\n# Iterative\ndef countNodesIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n    count = 0\n\n    while q:\n        n = len(q)\n\n        for _ in range(n):\n            node = q.popleft()\n            count += 1\n\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return count\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Recursive  |  O(n)  |  O(n)   |\n# | Iterative  |  O(n)  |  O(n)   |\n# |------------|--------|---------|\n\nroot = [1, 2, 3, 4, 5, 6]\nroot = build(root)\nprint(root)\n#     __1__\n#    /     \\\n#   2       3\n#  / \\     /\n# 4   5   6\nprint(countNodesRecursive(root))  # 6\nprint(countNodesIterative(root))  # 6\n</code></pre>"},{"location":"LeetPattern/tree_feature/#110-balanced-binary-tree","title":"110. Balanced Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef isBalanced(root: Optional[TreeNode]) -&gt; bool:\n    def getHeight(node):\n        if not node:\n            return 0\n\n        # post order\n        leftHeight = getHeight(node.left)\n        rightHeight = getHeight(node.right)\n\n        if leftHeight == -1 or rightHeight == -1:\n            return -1\n\n        if abs(leftHeight - rightHeight) &gt; 1:\n            return -1\n        else:\n            return 1 + max(leftHeight, rightHeight)\n\n    if getHeight(root) != -1:\n        return True\n    else:\n        return False\n\n\nroot = [3, 9, 20, None, None, 15, 7]\nroot = build(root)\nprint(root)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(isBalanced(root))  # True\n</code></pre>"},{"location":"LeetPattern/tree_feature/#257-binary-tree-paths","title":"257. Binary Tree Paths","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Backtracking, Tree, Depth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef binaryTreePaths(root: Optional[TreeNode]) -&gt; List[str]:\n    res = []\n\n    def dfs(node, path):\n        if not node:\n            return\n        path += str(node.val)\n\n        if not node.left and not node.right:\n            res.append(path)\n            return\n\n        path += \"-&gt;\"\n\n        dfs(node.left, path)\n        dfs(node.right, path)\n\n    dfs(root, \"\")\n\n    return res\n\n\nroot = build([1, 2, 3, None, 5])\nprint(root)\n#   __1\n#  /   \\\n# 2     3\n#  \\\n#   5\nprint(binaryTreePaths(root))  # ['1-&gt;2-&gt;5', '1-&gt;3']\n</code></pre>"},{"location":"LeetPattern/tree_feature/#404-sum-of-left-leaves","title":"404. Sum of Left Leaves","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Iterative\ndef sumOfLeftLeaves(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    stack = [root]\n    sumLL = 0\n\n    while stack:\n        node = stack.pop()\n\n        if node.left and not node.left.left and not node.left.right:\n            sumLL += node.left.val\n\n        if node.right:\n            stack.append(node.right)\n        if node.left:\n            stack.append(node.left)\n\n    return sumLL\n\n\n# Left Leave None:\n#   - node.left is not None\n#   - node.left.left is None\n#   - node.left.right is None\n\nroot = build([3, 9, 20, None, None, 15, 7])\nprint(root)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(sumOfLeftLeaves(root))  # 24\n</code></pre>"},{"location":"LeetPattern/tree_feature/#112-path-sum","title":"112. Path Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef hasPathSum(root: Optional[TreeNode], targetSum: int) -&gt; bool:\n    if not root:\n        return False\n\n    if not root.left and not root.right:\n        return root.val == targetSum\n\n    targetSum -= root.val\n\n    return hasPathSum(root.left, targetSum) or hasPathSum(root.right, targetSum)\n\n\nroot = build([5, 4, 8, 11, None, 13, 4, 7, 2, None, None, None, None, None, 1])\nprint(root)\n#          5___\n#         /    \\\n#     ___4     _8\n#    /        /  \\\n#   11       13   4\n#  /  \\            \\\n# 7    2            1\nprint(hasPathSum(root, 22))  # True\n</code></pre>"},{"location":"LeetPattern/tree_feature/#2331-evaluate-boolean-binary-tree","title":"2331. Evaluate Boolean Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef evaluateTree(root: Optional[TreeNode]) -&gt; bool:\n    if not root.left and not root.right:\n        return root.val\n\n    left = evaluateTree(root.left)\n    right = evaluateTree(root.right)\n\n    if root.val == 2:\n        return left or right\n    elif root.val == 3:\n        return left and right\n\n\nroot = build([2, 1, 3, None, None, 0, 1])\nprint(root)\n#   2__\n#  /   \\\n# 1     3\n#      / \\\n#     0   1\nboolTree = build([\"OR\", \"True\", \"AND\", None, None, \"False\", \"True\"])\nprint(boolTree)\n#    __OR_______\n#   /           \\\n# True        __AND_\n#            /      \\\n#         False     True\nprint(evaluateTree(root))  # 1\n</code></pre>"},{"location":"LeetPattern/tree_feature/#100-same-tree","title":"100. Same Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# 1. Recursive\ndef isSameTreeRecursive(p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:\n    if not p and not q:\n        return True\n    elif not p or not q:\n        return False\n    elif p.val != q.val:\n        return False\n\n    return isSameTreeRecursive(p.left, q.left) and isSameTreeRecursive(p.right, q.right)\n\n\n# 2. Iterative with queue\ndef isSameTreeIterativeQueue(p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:\n    queue = deque([(p, q)])\n\n    while queue:\n        p, q = queue.popleft()\n\n        if not p and not q:\n            continue\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n\n        queue.append((p.left, q.left))\n        queue.append((p.right, q.right))\n\n    return True\n\n\n# 3. Iterative with stack\ndef isSameTreeIterativeStack(p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:\n    stack = [(p, q)]\n\n    while stack:\n        n1, n2 = stack.pop()\n\n        if not n1 and not n2:\n            continue\n        if not n1 or not n2:\n            return False\n        if n1.val != n2.val:\n            return False\n\n        stack.append((n1.left, n2.left))\n        stack.append((n1.right, n2.right))\n\n    return True\n\n\nif __name__ == \"__main__\":\n    p1 = build([1, 2, 3])\n    q1 = build([1, 2, 3])\n    p2 = build([1, 2])\n    q2 = build([1, None, 2])\n\n    assert isSameTreeRecursive(p1, q1) is True\n    assert isSameTreeRecursive(p2, q2) is False\n    assert isSameTreeIterativeQueue(p1, q1) is True\n    assert isSameTreeIterativeQueue(p2, q2) is False\n    assert isSameTreeIterativeStack(p1, q1) is True\n    assert isSameTreeIterativeStack(p2, q2) is False\n</code></pre>"},{"location":"LeetPattern/tree_feature/#235-lowest-common-ancestor-of-a-binary-search-tree","title":"235. Lowest Common Ancestor of a Binary Search Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Search Tree, Binary Tree</p> </li> </ul> Python <pre><code>from binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef lowestCommonAncestor(root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\") -&gt; \"TreeNode\":\n    while root:\n        if root.val &gt; p.val and root.val &gt; q.val:\n            root = root.left\n        elif root.val &lt; p.val and root.val &lt; q.val:\n            root = root.right\n        else:\n            return root\n\n\nroot = [6, 2, 8, 0, 4, 7, 9, None, None, 3, 5]\nroot = build(root)\np = root.left\nq = root.right\nprint(root)\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\nprint(lowestCommonAncestor(root, p, q))\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\n</code></pre>"},{"location":"LeetPattern/tree_feature/#236-lowest-common-ancestor-of-a-binary-tree","title":"236. Lowest Common Ancestor of a Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul> PythonCPP <pre><code>from typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass LowestCommonAncestor:\n    def lowestCommonAncestor(\n        self, root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n    ) -&gt; \"TreeNode\":\n        if not root or q == root or p == root:\n            return root\n\n        left = self.lowestCommonAncestor(root.left, p, q)\n        right = self.lowestCommonAncestor(root.right, p, q)\n\n        if left and right:\n            return root\n\n        return left or right\n\n\nif __name__ == \"__main__\":\n    root = build([3, 5, 1, 6, 2, 0, 8, None, None, 7, 4])\n    print(root)\n    #     ______3__\n    #    /         \\\n    #   5__         1\n    #  /   \\       / \\\n    # 6     2     0   8\n    #      / \\\n    #     7   4\n    p = root.left  # 5\n    q = root.right  # 1\n    sol = LowestCommonAncestor()\n    print(sol.lowestCommonAncestor(root, p, q))\n    #     ______3__\n    #    /         \\\n    #   5__         1\n    #  /   \\       / \\\n    # 6     2     0   8\n    #      / \\\n    #     7   4\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   public:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if (root == nullptr || root == p || root == q) {\n            return root;\n        }\n\n        TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);\n        TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);\n\n        if (left &amp;&amp; right) {\n            return root;\n        }\n\n        return left ? left : right;\n    }\n};\n\nint main() { return 0; }\n</code></pre>"},{"location":"LeetPattern/tree_modification/","title":"Tree Modification","text":""},{"location":"LeetPattern/tree_modification/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 226. Invert Binary Tree (Easy)</li> <li> 105. Construct Binary Tree from Preorder and Inorder Traversal (Medium)</li> <li> 106. Construct Binary Tree from Inorder and Postorder Traversal (Medium)</li> <li> 654. Maximum Binary Tree (Medium)</li> <li> 617. Merge Two Binary Trees (Easy)</li> </ul>"},{"location":"LeetPattern/tree_modification/#226-invert-binary-tree","title":"226. Invert Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef invertTreeRecursive(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    root.left, root.right = root.right, root.left\n\n    invertTreeRecursive(root.left)\n    invertTreeRecursive(root.right)\n\n    return root\n\n\n# Iterative\ndef invertTreeIterative(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    stack = [root]\n\n    while stack:\n        node = stack.pop()\n\n        node.left, node.right = node.right, node.left\n        if node.left:\n            stack.append(node.left)\n        if node.right:\n            stack.append(node.right)\n\n    return root\n\n\nroot = build([4, 2, 7, 1, 3, 6, 9])\nprint(root)\n#     __4__\n#    /     \\\n#   2       7\n#  / \\     / \\\n# 1   3   6   9\ninvertedRecursive = invertTreeRecursive(root)\nprint(invertedRecursive)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\nroot = build([4, 2, 7, 1, 3, 6, 9])\ninvertedIterative = invertTreeIterative(root)\nprint(invertedIterative)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\n</code></pre>"},{"location":"LeetPattern/tree_modification/#105-construct-binary-tree-from-preorder-and-inorder-traversal","title":"105. Construct Binary Tree from Preorder and Inorder Traversal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Divide And Conquer, Tree, Binary Tree</p> </li> </ul> PythonCPP <pre><code>from typing import List, Optional\n\nfrom helper import TreeNode\n\n\ndef buildTree(preorder: List[int], inorder: List[int]) -&gt; Optional[TreeNode]:\n    \"\"\"\n    preorder  root left right  1  2  3\n    inorder   left root right  4  5  6\n    \"\"\"\n    if len(preorder) == 0:\n        return None\n\n    root_val = preorder[0]  # 1\n    root = TreeNode(root_val)\n\n    separator_idx = inorder.index(root_val)  # 5\n\n    left_inorder = inorder[:separator_idx]  # 4\n    right_inorder = inorder[separator_idx + 1 :]  # 6\n\n    left_preorder = preorder[1 : 1 + len(left_inorder)]  # 2\n    right_preorder = preorder[1 + len(left_inorder) :]  # 3\n\n    root.left = buildTree(left_preorder, left_inorder)\n    root.right = buildTree(right_preorder, right_inorder)\n\n    return root\n\n\npreorder = [3, 9, 20, 15, 7]\ninorder = [9, 3, 15, 20, 7]\nroot = buildTree(preorder, inorder)\nprint(root)\n#     3\n#    / \\\n#   9  20\n#     /  \\\n#    15   7\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   public:\n    vector&lt;int&gt; preorder;\n    unordered_map&lt;int, int&gt; inorderMap;\n\n    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {\n        this-&gt;preorder = preorder;\n        for (size_t i = 0; i &lt; inorder.size(); i++) {\n            inorderMap[inorder[i]] = i;\n        }\n        return buildSubtree(0, 0, inorder.size() - 1);\n    }\n\n   private:\n    TreeNode* buildSubtree(int rootIndex, int left, int right) {\n        if (left &gt; right) return nullptr;\n\n        TreeNode* root = new TreeNode(preorder[rootIndex]);\n        int inorderIndex = inorderMap[preorder[rootIndex]];\n\n        root-&gt;left = buildSubtree(rootIndex + 1, left, inorderIndex - 1);\n        root-&gt;right = buildSubtree(rootIndex + (inorderIndex - left + 1),\n                                   inorderIndex + 1, right);\n\n        return root;\n    }\n};\n\nint main() {\n    vector&lt;int&gt; preorder = {3, 9, 20, 15, 7};\n    vector&lt;int&gt; inorder = {9, 3, 15, 20, 7};\n    Solution solution;\n    TreeNode* root = solution.buildTree(preorder, inorder);\n    cout &lt;&lt; root-&gt;val &lt;&lt; endl;                // 3\n    cout &lt;&lt; root-&gt;left-&gt;val &lt;&lt; endl;          // 9\n    cout &lt;&lt; root-&gt;right-&gt;val &lt;&lt; endl;         // 20\n    cout &lt;&lt; root-&gt;right-&gt;left-&gt;val &lt;&lt; endl;   // 15\n    cout &lt;&lt; root-&gt;right-&gt;right-&gt;val &lt;&lt; endl;  // 7\n    return 0;\n}\n</code></pre>"},{"location":"LeetPattern/tree_modification/#106-construct-binary-tree-from-inorder-and-postorder-traversal","title":"106. Construct Binary Tree from Inorder and Postorder Traversal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Divide And Conquer, Tree, Binary Tree</p> </li> </ul> Python <pre><code>from typing import List, Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef buildTree(inorder: List[int], postorder: List[int]) -&gt; Optional[TreeNode]:\n    \"\"\"\n    inorder:    left root  right   1  2  3\n    postorder:  left right root    4  5  6\n    \"\"\"\n\n    if not postorder:\n        return None\n\n    root_val = postorder[-1]  # 6\n    root = TreeNode(root_val)\n\n    separator_idx = inorder.index(root_val)  # 2\n\n    left_inorder = inorder[:separator_idx]  # 1\n    right_inorder = inorder[separator_idx + 1 :]  # 3\n\n    left_postorder = postorder[: len(left_inorder)]  # 4\n    right_postorder = postorder[len(left_inorder) : -1]  # 5\n\n    root.left = buildTree(left_inorder, left_postorder)\n    root.right = buildTree(right_inorder, right_postorder)\n\n    return root\n\n\ninorder = [9, 3, 15, 20, 7]\npostorder = [9, 15, 7, 20, 3]\nroot = buildTree(inorder, postorder)\nprint(root)\n#     3\n#    / \\\n#   9  20\n#     /  \\\n#    15   7\n</code></pre>"},{"location":"LeetPattern/tree_modification/#654-maximum-binary-tree","title":"654. Maximum Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Divide And Conquer, Stack, Tree, Monotonic Stack, Binary Tree</p> </li> </ul> Python <pre><code>from typing import List, Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef constructMaximumBinaryTree(nums: List[int]) -&gt; Optional[TreeNode]:\n    if len(nums) == 0:\n        return None\n\n    maximum = max(nums)\n    rootIndex = nums.index(maximum)\n\n    root = TreeNode(maximum)\n\n    left_nums = nums[:rootIndex]\n    right_nums = nums[rootIndex + 1 :]\n\n    root.left = constructMaximumBinaryTree(left_nums)\n    root.right = constructMaximumBinaryTree(right_nums)\n\n    return root\n\n\nnums = [3, 2, 1, 6, 0, 5]\nroot = constructMaximumBinaryTree(nums)\n#     __6__\n#    /     \\\n#   3       5\n#    \\     /\n#     2   0\n#      \\\n#       1\n</code></pre>"},{"location":"LeetPattern/tree_modification/#617-merge-two-binary-trees","title":"617. Merge Two Binary Trees","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import List, Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef mergeTrees(\n    root1: Optional[TreeNode], root2: Optional[TreeNode]\n) -&gt; Optional[TreeNode]:\n\n    if not root1:\n        return root2\n    if not root2:\n        return root1\n\n    root = TreeNode()\n\n    root.val += root1.val + root2.val\n    root.left = mergeTrees(root1.left, root2.left)\n    root.right = mergeTrees(root1.right, root2.right)\n\n    return root\n\n\nroot1 = TreeNode(1)\nroot1.left = TreeNode(3)\nroot1.right = TreeNode(2)\nroot1.left.left = TreeNode(5)\n#     1\n#    / \\\n#   3   2\n#  /\n# 5\n\nroot2 = TreeNode(2)\nroot2.left = TreeNode(1)\nroot2.right = TreeNode(3)\nroot2.left.right = TreeNode(4)\nroot2.right.right = TreeNode(7)\n#     2\n#    / \\\n#   1   3\n#    \\   \\\n#     4   7\n\nroot = mergeTrees(root1, root2)\n#     3\n#    / \\\n#   4   5\n#  / \\   \\\n# 5   4   7\n</code></pre>"},{"location":"LeetPattern/tree_traversal/","title":"Tree Traversal","text":""},{"location":"LeetPattern/tree_traversal/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 144. Binary Tree Preorder Traversal (Easy)</li> <li> 94. Binary Tree Inorder Traversal (Easy)</li> <li> 145. Binary Tree Postorder Traversal (Easy)</li> <li> 102. Binary Tree Level Order Traversal (Medium)</li> <li> 107. Binary Tree Level Order Traversal II (Medium)</li> <li> 103. Binary Tree Zigzag Level Order Traversal (Medium)</li> </ul>"},{"location":"LeetPattern/tree_traversal/#144-binary-tree-preorder-traversal","title":"144. Binary Tree Preorder Traversal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Stack, Tree, Depth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\nclass PreorderTraversal:\n    def recursive(self, root: Optional[TreeNode]) -&gt; List[int]:\n        res = []\n\n        def dfs(node):\n            if not node:\n                return None\n\n            res.append(node.val)  # &lt;--\n            dfs(node.left)\n            dfs(node.right)\n\n        dfs(root)\n\n        return res\n\n    def iterative(self, root: Optional[TreeNode]) -&gt; List[int]:\n        if not root:\n            return []\n\n        stack = [root]\n        res = []\n\n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n\n        return res\n\n\nif __name__ == \"__main__\":\n    tree = build([0, 1, 2, 3, 4, 5, 6])\n    print(tree)\n    #     __0__\n    #    /     \\\n    #   1       2\n    #  / \\     / \\\n    # 3   4   5   6\n    sol = PreorderTraversal()\n    assert sol.recursive(tree) == [0, 1, 3, 4, 2, 5, 6]\n    assert sol.iterative(tree) == [0, 1, 3, 4, 2, 5, 6]\n</code></pre>"},{"location":"LeetPattern/tree_traversal/#94-binary-tree-inorder-traversal","title":"94. Binary Tree Inorder Traversal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Stack, Tree, Depth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef inorderTraversalRecursive(root: TreeNode) -&gt; List[int]:\n    res = []\n\n    def dfs(node):\n        if not node:\n            return\n\n        dfs(node.left)\n        res.append(node.val)  # &lt;--\n        dfs(node.right)\n\n    dfs(root)\n\n    return res\n\n\n# Iterative\ndef inorderTraversalIterative(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    stack = []\n    res = []\n    cur = root\n\n    while cur or stack:\n        if cur:\n            stack.append(cur)\n            cur = cur.left\n        else:\n            cur = stack.pop()\n            res.append(cur.val)\n            cur = cur.right\n\n    return res\n\n\ntree = build([0, 1, 2, 3, 4, 5, 6])\nprint(tree)\n#     __0__\n#    /     \\\n#   1       2\n#  / \\     / \\\n# 3   4   5   6\nprint(inorderTraversalRecursive(tree))  # [3, 1, 4, 0, 5, 2, 6]\nprint(inorderTraversalIterative(tree))  # [3, 1, 4, 0, 5, 2, 6]\n</code></pre>"},{"location":"LeetPattern/tree_traversal/#145-binary-tree-postorder-traversal","title":"145. Binary Tree Postorder Traversal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Stack, Tree, Depth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef postorderTraversalRecursive(root: Optional[TreeNode]) -&gt; List[int]:\n    res = []\n\n    def dfs(node):\n        if not node:\n            return\n\n        dfs(node.left)\n        dfs(node.right)\n        res.append(node.val)  # &lt;--\n\n    dfs(root)\n\n    return res\n\n\n# Iterative\ndef postorderTraversalIterative(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    res = []\n    stack = [root]\n\n    while stack:\n        node = stack.pop()\n        res.append(node.val)\n\n        if node.left:\n            stack.append(node.left)\n        if node.right:\n            stack.append(node.right)\n\n    return res[::-1]\n\n\ntree = build([0, 1, 2, 3, 4, 5, 6])\nprint(tree)\n#     __0__\n#    /     \\\n#   1       2\n#  / \\     / \\\n# 3   4   5   6\nprint(postorderTraversalRecursive(tree))  # [3, 4, 1, 5, 6, 2, 0]\nprint(postorderTraversalIterative(tree))  # [3, 4, 1, 5, 6, 2, 0]\n</code></pre>"},{"location":"LeetPattern/tree_traversal/#102-binary-tree-level-order-traversal","title":"102. Binary Tree Level Order Traversal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef levelOrder(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        level = []\n        size = len(q)\n\n        for _ in range(size):\n            cur = q.popleft()\n            level.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(level)\n\n    return res\n\n\ntree = build([3, 9, 20, None, None, 15, 7])\nprint(tree)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(levelOrder(tree))  # [[3], [9, 20], [15, 7]]\n</code></pre>"},{"location":"LeetPattern/tree_traversal/#107-binary-tree-level-order-traversal-ii","title":"107. Binary Tree Level Order Traversal II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef levelOrderBottom(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    res = []\n    q = deque([root])\n\n    while q:\n        level = []\n        n = len(q)\n\n        for _ in range(n):\n            cur = q.popleft()\n            level.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(level)\n\n    return res[::-1]\n\n\ntree = build([3, 9, 20, None, None, 15, 7])\nprint(tree)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(levelOrderBottom(tree))  # [[15, 7], [9, 20], [3]]\n</code></pre>"},{"location":"LeetPattern/tree_traversal/#103-binary-tree-zigzag-level-order-traversal","title":"103. Binary Tree Zigzag Level Order Traversal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef zigzagLevelOrder(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        level = []\n        size = len(q)\n\n        for _ in range(size):\n            cur = q.popleft()\n            level.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(level if not len(res) % 2 else level[::-1])\n\n    return res\n\n\nif __name__ == \"__main__\":\n    tree = build([3, 9, 20, None, None, 15, 7])\n    print(tree)\n    #   3___\n    #  /    \\\n    # 9     _20\n    #      /   \\\n    #     15    7\n    assert zigzagLevelOrder(tree) == [[3], [20, 9], [15, 7]]\n</code></pre>"},{"location":"LeetPattern/trie/","title":"Trie","text":""},{"location":"LeetPattern/trie/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 208. Implement Trie (Prefix Tree) (Medium)</li> <li> 211. Design Add and Search Words Data Structure (Medium)</li> <li> 212. Word Search II (Hard)</li> </ul>"},{"location":"LeetPattern/trie/#208-implement-trie-prefix-tree","title":"208. Implement Trie (Prefix Tree)","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Design, Trie</p> </li> </ul> Python <pre><code>\"\"\"\n### Trie\n\n- A trie is a tree-like data structure whose nodes store the letters of an alphabet.\n\"\"\"\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.endOfWord = None\n\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.endOfWord = True\n\n    def search(self, word: str) -&gt; bool:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return node.endOfWord\n\n    def startsWith(self, prefix: str) -&gt; bool:\n        node = self.root\n\n        for c in prefix:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return True\n\n\n# Your Trie object will be instantiated and called as such:\nobj = Trie()\nobj.insert(\"apple\")\nprint(obj.search(\"word\"))  # False\nprint(obj.startsWith(\"app\"))  # True\n</code></pre>"},{"location":"LeetPattern/trie/#211-design-add-and-search-words-data-structure","title":"211. Design Add and Search Words Data Structure","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Depth First Search, Design, Trie</p> </li> </ul> Python <pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.word = False\n\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.word = True\n\n    def search(self, word: str) -&gt; bool:\n\n        def dfs(j, root):\n            node = root\n\n            for i in range(j, len(word)):\n                c = word[i]\n\n                if c == \".\":\n                    for child in node.children.values():\n                        if dfs(i + 1, child):\n                            return True\n                    return False\n                else:\n                    if c not in node.children:\n                        return False\n                    node = node.children[c]\n            return node.word\n\n        return dfs(0, self.root)\n\n\n# Your WordDictionary object will be instantiated and called as such:\nobj = WordDictionary()\nobj.addWord(\"word\")\nprint(obj.search(\"word\"))\nprint(obj.search(\"w.rd\"))\n</code></pre>"},{"location":"LeetPattern/trie/#212-word-search-ii","title":"212. Word Search II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Backtracking, Trie, Matrix</p> </li> </ul> Python <pre><code>from typing import List\n\nfrom leetpattern.utils import Trie\n\n\n# Backtracking + Trie\ndef findWords(board: List[List[str]], words: List[str]) -&gt; List[str]:\n    trie = Trie()\n    for word in words:\n        trie.add_word(word)\n\n    m, n = len(board), len(board[0])\n    result, visit = set(), set()\n\n    def dfs(r, c, node, word):\n        if (\n            r &lt; 0\n            or r &gt;= m\n            or c &lt; 0\n            or c &gt;= n\n            or (r, c) in visit\n            or board[r][c] not in node.children\n        ):\n            return None\n\n        visit.add((r, c))\n\n        node = node.children[board[r][c]]\n        word += board[r][c]\n        if node.is_word:\n            result.add(word)\n\n        dfs(r - 1, c, node, word)\n        dfs(r + 1, c, node, word)\n        dfs(r, c - 1, node, word)\n        dfs(r, c + 1, node, word)\n\n        visit.remove((r, c))\n\n    for r in range(m):\n        for c in range(n):\n            dfs(r, c, trie.root, \"\")\n\n    return list(result)\n\n\ndef test_find_words():\n    board = [\n        [\"o\", \"a\", \"a\", \"n\"],\n        [\"e\", \"t\", \"a\", \"e\"],\n        [\"i\", \"h\", \"k\", \"r\"],\n        [\"i\", \"f\", \"l\", \"v\"],\n    ]\n    words = [\"oath\", \"pea\", \"eat\", \"rain\"]\n    result = findWords(board, words)\n    assert sorted(result) == [\"eat\", \"oath\"]\n</code></pre>"},{"location":"blind-75/1d_dynamic_programming/","title":"\u4e00\u7ef4\u52a8\u6001\u89c4\u5212 1D Dynamic Programming","text":""},{"location":"blind-75/1d_dynamic_programming/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 70. Climbing Stairs (Easy)</li> <li> 198. House Robber (Medium)</li> <li> 213. House Robber II (Medium)</li> <li> 5. Longest Palindromic Substring (Medium)</li> <li> 647. Palindromic Substrings (Medium)</li> <li> 91. Decode Ways (Medium)</li> <li> 322. Coin Change (Medium)</li> <li> 152. Maximum Product Subarray (Medium)</li> <li> 139. Word Break (Medium)</li> <li> 300. Longest Increasing Subsequence (Medium)</li> </ul>"},{"location":"blind-75/1d_dynamic_programming/#70-climbing-stairs","title":"70. Climbing Stairs","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Memoization</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return the number of distinct ways to reach the top of the stairs.\n- `dp[n]` stores the number of distinct ways to reach the `n-th` stair.\n- Formula: `dp[n] = dp[n - 1] + dp[n - 2]`.\n- Initialize `dp[0] = 0`, `dp[1] = 1`, and `dp[2] = 2`.\n\"\"\"\n\nfrom functools import cache\n\n\n# DP\ndef climbStairsDP(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    dp = [i for i in range(n + 1)]\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\n# DP (Optimized)\ndef climbStairsDPOptimized(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    first, second = 1, 2\n\n    for _ in range(3, n + 1):\n        first, second = second, first + second\n\n    return second\n\n\n# Recursion\ndef climbStairsRecursion(n: int) -&gt; int:\n    @cache\n    def dfs(i: int) -&gt; int:\n        if i &lt;= 1:\n            return 1\n        return dfs(i - 1) + dfs(i - 2)\n\n    return dfs(n)\n\n\n# Greedy\ndef climbStairsGreedy(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    p1, p2 = 1, 2\n\n    for _ in range(3, n + 1):\n        p1, p2 = p2, p1 + p2\n\n    return p2\n\n\nif __name__ == \"__main__\":\n    assert climbStairsDP(10) == 89\n    assert climbStairsDPOptimized(10) == 89\n    assert climbStairsRecursion(10) == 89\n    assert climbStairsGreedy(10) == 89\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nint climbStairs(int n) {\n    if (n &lt;= 2) return n;\n    int f1 = 1, f2 = 2;\n    int res;\n\n    int i = 3;\n    while (i &lt;= n) {\n        res = f1 + f2;\n        f1 = f2;\n        f2 = res;\n        i++;\n    }\n    return res;\n}\n\nint main() {\n    assert(climbStairs(2) == 2);\n    assert(climbStairs(5) == 8);\n    assert(climbStairs(10) == 89);\n    return 0;\n}\n</code></pre>"},{"location":"blind-75/1d_dynamic_programming/#198-house-robber","title":"198. House Robber","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> PythonCPP <pre><code>from functools import cache\nfrom typing import List\n\n\nclass Rob:\n    \"\"\"\n    dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n    \"\"\"\n\n    def incursive(self, nums: List[int]) -&gt; int:\n        \"\"\"\n        time complexity: O(n)\n        space complexity: O(n)\n        \"\"\"\n        n = len(nums)\n        if n &lt;= 2:\n            return max(nums)\n\n        # init\n        dp = [0 for _ in range(n)]\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n        # update\n        for i in range(2, n):\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n        return dp[-1]\n\n    def incursive_optimized(self, nums: List[int]) -&gt; int:\n        \"\"\"\n        time complexity: O(n)\n        space complexity: O(1)\n        \"\"\"\n        f0, f1 = 0, 0\n\n        for num in nums:\n            f0, f1 = f1, max(f1, f0 + num)\n\n        return f1\n\n    def memoization(self, nums: List[int]) -&gt; int:\n        \"\"\"\n        time complexity: O(n)\n        space complexity: O(n)\n        \"\"\"\n        n = len(nums)\n\n        @cache\n        def dp(i: int) -&gt; int:\n            if i &lt; 0:\n                return 0\n            return max(dp(i - 1), dp(i - 2) + nums[i])\n\n        return dp(n - 1)\n\n\nif __name__ == \"__main__\":\n    nums = [2, 7, 9, 3, 1]\n    rob = Rob()\n    assert rob.incursive(nums) == 12\n    assert rob.incursive_optimized(nums) == 12\n    assert rob.memoization(nums) == 12\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint rob(vector&lt;int&gt; &amp;nums) {\n    int prev = 0, cur = 0, temp = 0;\n\n    for (int num : nums) {\n        temp = cur;\n        cur = max(cur, prev + num);\n        prev = temp;\n    }\n    return cur;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {2, 7, 9, 3, 1};\n    cout &lt;&lt; rob(nums) &lt;&lt; endl;  // 12\n    return 0;\n}\n</code></pre>"},{"location":"blind-75/1d_dynamic_programming/#213-house-robber-ii","title":"213. House Robber II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return the maximum amount of money that can be robbed from the houses arranged in a circle.\n-   Circular \u2192 Linear: `nums[0]` and `nums[-1]` cannot be robbed together.\n-   Rob from `0` to `n - 2`\n\n|  n  | `nums[n]` | `dp[n-2]` | `dp[n-1]` | `dp[n-2] + nums[n]` | `dp[n]` |\n| :-: | :-------: | :-------: | :-------: | :-----------------: | :-----: |\n|  0  |     2     |     -     |     2     |          -          |    2    |\n|  1  |     7     |     -     |     7     |          -          |    7    |\n|  2  |     9     |     2     |     7     |         11          |   11    |\n|  3  |     3     |     7     |    11     |         10          |   11    |\n\n-   Rob from `1` to `n - 1`\n\n|  n  | `nums[n]` | `dp[n-2]` | `dp[n-1]` | `dp[n-2] + nums[n]` | `dp[n]` |\n| :-: | :-------: | :-------: | :-------: | :-----------------: | :-----: |\n|  1  |     7     |     -     |     -     |          -          |    7    |\n|  2  |     9     |     -     |     7     |          -          |    9    |\n|  3  |     3     |     7     |     9     |         10          |   10    |\n|  4  |     1     |     9     |    10     |         10          |   10    |\n\"\"\"\n\nfrom typing import List\n\n\n# DP\ndef rob(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 3:\n        return max(nums)\n\n    def robLinear(nums: List[int]) -&gt; int:\n        dp = [0 for _ in range(len(nums))]\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n        return dp[-1]\n\n    # circle -&gt; linear\n    a = robLinear(nums[1:])  # 2nd house to the last house\n    b = robLinear(nums[:-1])  # 1st house to the 2nd last house\n\n    return max(a, b)\n\n\nnums = [2, 7, 9, 3, 1]\nprint(rob(nums))  # 11\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// DP\nint robDP(vector&lt;int&gt;&amp; nums) {\n    int n = nums.size();\n    if (n &lt;= 3) return *max_element(nums.begin(), nums.end());\n\n    vector&lt;int&gt; dp1(n, 0), dp2(n, 0);\n\n    dp1[0] = nums[0];\n    dp2[1] = max(nums[0], nums[1]);\n    for (int i = 2; i &lt; n - 1; i++) {\n        dp1[i] = max(dp1[i - 1], dp1[i - 2] + nums[i]);\n    }\n\n    dp2[1] = nums[1];\n    dp2[2] = max(nums[1], nums[2]);\n    for (int i = 3; i &lt; n; i++) {\n        dp1[i] = max(dp1[i - 1], dp1[i - 2] + nums[i]);\n    }\n\n    return max(dp1[n - 2], dp2[n - 1]);\n}\n\n// DP (Space Optimized)\nint robDPOptimized(vector&lt;int&gt;&amp; nums) {\n    int n = nums.size();\n    if (n &lt;= 3) return *max_element(nums.begin(), nums.end());\n\n    int f1 = nums[0];\n    int f2 = max(nums[0], nums[1]);\n    int res1;\n    for (int i = 2; i &lt; n - 1; i++) {\n        res1 = max(f2, f1 + nums[i]);\n        f1 = f2;\n        f2 = res1;\n    }\n\n    f1 = nums[1];\n    f2 = max(nums[1], nums[2]);\n    int res2;\n    for (int i = 3; i &lt; n; i++) {\n        res2 = max(f2, f1 + nums[i]);\n        f1 = f2;\n        f2 = res2;\n    }\n\n    return max(res1, res2);\n}\n\nint main() {\n    vector&lt;int&gt; nums = {2, 3, 2};\n    cout &lt;&lt; robDP(nums) &lt;&lt; endl;           // 3\n    cout &lt;&lt; robDPOptimized(nums) &lt;&lt; endl;  // 3\n\n    nums = {1, 2, 3, 1};\n    cout &lt;&lt; robDP(nums) &lt;&lt; endl;           // 4\n    cout &lt;&lt; robDPOptimized(nums) &lt;&lt; endl;  // 4\n\n    return 0;\n}\n</code></pre>"},{"location":"blind-75/1d_dynamic_programming/#5-longest-palindromic-substring","title":"5. Longest Palindromic Substring","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Dynamic Programming</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the longest palindromic substring in `s`.\n\"\"\"\n\n\n# DP - Interval\ndef longestPalindromeDP(s: str) -&gt; str:\n    n = len(s)\n    if n &lt;= 1:\n        return s\n\n    start, maxLen = 0, 1\n\n    # Init\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for j in range(1, n):\n        for i in range(j):\n            if s[i] == s[j]:\n                if j - i &lt;= 2:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1]\n\n                if dp[i][j] and j - i + 1 &gt; maxLen:\n                    maxLen = j - i + 1\n                    start = i\n\n    return s[start : start + maxLen]\n\n\n# Expand Around Center\ndef longestPalindromeCenter(s: str) -&gt; str:\n    def expand_around_center(left, right):\n        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n\n    if len(s) &lt;= 1:\n        return s\n\n    start, end = 0, 0\n    for i in range(len(s)):\n        len1 = expand_around_center(i, i)  # odd\n        len2 = expand_around_center(i, i + 1)  # even\n\n        maxLen = max(len1, len2)\n        if maxLen &gt; end - start:\n            start = i - (maxLen - 1) // 2\n            end = i + maxLen // 2\n\n    return s[start : end + 1]\n\n\ns = \"babad\"\nprint(longestPalindromeDP(s))  # \"bab\"\nprint(longestPalindromeCenter(s))  # \"aba\"\n</code></pre>"},{"location":"blind-75/1d_dynamic_programming/#647-palindromic-substrings","title":"647. Palindromic Substrings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Dynamic Programming</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the number of palindromic substrings in `s`.\n-   Bottom-up DP table\n\n|  dp   |  a  |  b  |  b  |  a  |  e  |\n| :---: | :-: | :-: | :-: | :-: | :-: |\n| **a** |  1  |  0  |  0  |  1  |  0  |\n| **b** |  0  |  1  |  1  |  0  |  0  |\n| **b** |  0  |  0  |  1  |  0  |  0  |\n| **a** |  0  |  0  |  0  |  1  |  0  |\n| **e** |  0  |  0  |  0  |  0  |  1  |\n\"\"\"\n\n\ndef countSubstrings(s: str) -&gt; int:\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    res = 0\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i, n):\n            if s[i] == s[j]:\n                if j - i &lt;= 1:\n                    dp[i][j] = 1\n                    res += 1\n                elif dp[i + 1][j - 1]:\n                    dp[i][j] = 1\n                    res += 1\n\n    return res\n\n\nprint(countSubstrings(\"abbae\"))  # 7\n</code></pre>"},{"location":"blind-75/1d_dynamic_programming/#91-decode-ways","title":"91. Decode Ways","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul> Python <pre><code># DP\ndef numDecodingsDP(s: str) -&gt; int:\n    if not s or s[0] == \"0\":\n        return 0\n\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for i in range(1, n + 1):\n        # Check single digit decode\n        if s[i - 1] != \"0\":\n            dp[i] += dp[i - 1]\n\n        # Check two digit decode\n        if i &gt; 1 and \"10\" &lt;= s[i - 2 : i] &lt;= \"26\":\n            dp[i] += dp[i - 2]\n\n    return dp[n]\n\n\n# DFS\ndef numDecodingsDFS(s: str) -&gt; int:\n    memo = {}\n\n    def dfs(i):\n        if i == len(s):\n            return 1\n\n        if s[i] == \"0\":\n            return 0\n\n        if i in memo:\n            return memo[i]\n\n        # Single digit decode\n        ways = dfs(i + 1)\n\n        # Two digits decode\n        if i + 1 &lt; len(s) and \"10\" &lt;= s[i : i + 2] &lt;= \"26\":\n            ways += dfs(i + 2)\n\n        memo[i] = ways\n\n        return ways\n\n    return dfs(0)\n\n\ns = \"226\"\nprint(numDecodingsDP(s))  # 3\nprint(numDecodingsDFS(s))  # 3\n</code></pre>"},{"location":"blind-75/1d_dynamic_programming/#322-coin-change","title":"322. Coin Change","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Breadth First Search</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef coinChange(coins: List[int], amount: int) -&gt; int:\n    dp = [float(\"inf\") for _ in range(amount + 1)]\n\n    dp[0] = 0\n\n    for i in range(1, amount + 1):\n        for c in coins:\n            if i - c &gt;= 0:\n                dp[i] = min(dp[i], 1 + dp[i - c])\n\n    return dp[amount] if dp[amount] != float(\"inf\") else -1\n\n\ncoins = [1, 2, 5]\namount = 11\nprint(coinChange(coins, amount))  # 3\n</code></pre>"},{"location":"blind-75/1d_dynamic_programming/#152-maximum-product-subarray","title":"152. Maximum Product Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxProduct(nums: List[int]) -&gt; int:\n    n = len(nums)\n    dp_max = [0 for _ in range(n)]\n    dp_min = [0 for _ in range(n)]\n\n    dp_max[0] = nums[0]\n    dp_min[0] = nums[0]\n    max_product = nums[0]\n\n    for i in range(1, n):\n        dp_max[i] = max(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n        dp_min[i] = min(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n\n        max_product = max(max_product, dp_max[i])\n\n    return max_product\n\n\nnums = [2, 3, -2, 4]\nprint(maxProduct(nums))  # 6\n</code></pre>"},{"location":"blind-75/1d_dynamic_programming/#139-word-break","title":"139. Word Break","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Dynamic Programming, Trie, Memoization</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\n# DP (Unbounded Knapsack)\ndef wordBreak(s: str, wordDict: List[str]) -&gt; bool:\n    n = len(s)\n    dp = [False for _ in range(n + 1)]\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for word in wordDict:\n            m = len(word)\n            if s[i - m : i] == word and dp[i - m]:\n                dp[i] = True\n    return dp[-1]\n\n\ns = \"leetcode\"\nwordDict = [\"leet\", \"code\"]\nprint(wordBreak(s, wordDict))  # True\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;cassert&gt;\n#include &lt;ranges&gt;\n#include &lt;string&gt;\n#include &lt;unordered_set&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) {\n        int max_len = ranges::max(wordDict, {}, &amp;string::length).length();\n        unordered_set&lt;string&gt; words(wordDict.begin(), wordDict.end());\n\n        int n = s.length();\n        vector&lt;int&gt; f(n + 1);\n        f[0] = true;\n        for (int i = 1; i &lt;= n; i++) {\n            for (int j = i - 1; j &gt;= max(i - max_len, 0); j--) {\n                if (f[j] &amp;&amp; words.count(s.substr(j, i - j))) {\n                    f[i] = true;\n                    break;\n                }\n            }\n        }\n        return f[n];\n    }\n};\n\nint main() {\n    Solution solution;\n    string s = \"leetcode\";\n    vector&lt;string&gt; wordDict = {\"leet\", \"code\"};\n    assert(solution.wordBreak(s, wordDict) == true);\n    return 0;\n}\n</code></pre>"},{"location":"blind-75/1d_dynamic_programming/#300-longest-increasing-subsequence","title":"300. Longest Increasing Subsequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Dynamic Programming</p> </li> </ul> Python <pre><code>from functools import cache\nfrom typing import List\n\n\n# DP - LIS\ndef lengthOfLISMemo(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return n\n\n    @cache\n    def dfs(i: int) -&gt; int:\n        res = 0\n        for j in range(i):\n            if nums[j] &lt; nums[i]:\n                res = max(res, dfs(j))\n        return res + 1\n\n    return max(dfs(i) for i in range(n))\n\n\n# DP - LIS\ndef lengthOfLISTable(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return n\n\n    dp = [1 for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i):\n            if nums[i] &gt; nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\n\nif __name__ == \"__main__\":\n    assert lengthOfLISMemo([10, 9, 2, 5, 3, 7, 101, 18]) == 4\n    assert lengthOfLISTable([10, 9, 2, 5, 3, 7, 101, 18]) == 4\n    assert lengthOfLISMemo([0, 1, 0, 3, 2, 3]) == 4\n    assert lengthOfLISTable([0, 1, 0, 3, 2, 3]) == 4\n    assert lengthOfLISMemo([7, 7, 7, 7]) == 1\n    assert lengthOfLISTable([7, 7, 7, 7]) == 1\n</code></pre>"},{"location":"blind-75/2d_dynamic_programming/","title":"\u4e8c\u7ef4\u52a8\u6001\u89c4\u5212 2D Dynamic Programming","text":""},{"location":"blind-75/2d_dynamic_programming/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 62. Unique Paths (Medium)</li> <li> 1143. Longest Common Subsequence (Medium)</li> </ul>"},{"location":"blind-75/2d_dynamic_programming/#62-unique-paths","title":"62. Unique Paths","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Combinatorics</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Count the number of unique paths to reach the bottom-right corner of a `m x n` grid.\n\n![62](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)\n\"\"\"\n\n\n# DP - 2D\ndef uniquePaths(m: int, n: int) -&gt; int:\n    if m == 1 or n == 1:\n        return 1\n\n    dp = [[1] * n for _ in range(m)]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]\n\n\nprint(uniquePaths(m=3, n=7))  # 28\n# [[1, 1, 1,  1,  1,  1,  1],\n#  [1, 2, 3,  4,  5,  6,  7],\n#  [1, 3, 6, 10, 15, 21, 28]]\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint uniquePaths(int m, int n) {\n    vector dp(m, vector&lt;int&gt;(n, 1));\n\n    for (int i = 1; i &lt; m; i++) {\n        for (int j = 1; j &lt; n; j++) {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n\n    return dp[m - 1][n - 1];\n}\n\nint main() {\n    int m = 3, n = 7;\n    cout &lt;&lt; uniquePaths(m, n) &lt;&lt; endl;  // 28\n    return 0;\n}\n</code></pre>"},{"location":"blind-75/2d_dynamic_programming/#1143-longest-common-subsequence","title":"1143. Longest Common Subsequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul> Python <pre><code>from functools import cache\n\n\nclass LongestCommonSubsequence:\n    def memoization(self, text1: str, text2: str) -&gt; int:\n        m, n = len(text1), len(text2)\n\n        @cache\n        def dfs(i: int, j: int) -&gt; int:\n            if i &lt; 0 or j &lt; 0:\n                return 0\n            if text1[i] == text2[j]:\n                return dfs(i - 1, j - 1) + 1\n            return max(dfs(i - 1, j), dfs(i, j - 1))\n\n        return dfs(m - 1, n - 1)\n\n    def iterative(self, text1: str, text2: str) -&gt; int:\n        m, n = len(text1), len(text2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for i, x in enumerate(text1):\n            for j, y in enumerate(text2):\n                if x == y:\n                    dp[i + 1][j + 1] = dp[i][j] + 1\n                else:\n                    dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1])\n\n        return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    lcs = LongestCommonSubsequence()\n    assert lcs.memoization(\"abcde\", \"ace\") == 3\n    assert lcs.iterative(\"abcde\", \"ace\") == 3\n    assert lcs.memoization(\"abc\", \"abc\") == 3\n    assert lcs.iterative(\"abc\", \"abc\") == 3\n</code></pre>"},{"location":"blind-75/advanced_graphs/","title":"\u8fdb\u9636\u56fe\u8bba Advanced Graphs","text":""},{"location":"blind-75/advanced_graphs/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 269. Alien Dictionary (Hard) \ud83d\udc51</li> </ul>"},{"location":"blind-75/advanced_graphs/#269-alien-dictionary","title":"269. Alien Dictionary \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Depth First Search, Breadth First Search, Graph, Topological Sort</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the correct order of characters in the alien language.\n\"\"\"\n\nfrom collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS - Kahn's algorithm (Topological Sort)\ndef alienOrderBFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    indegree = {c: 0 for word in words for c in word}\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                    indegree[w2[j]] += 1\n                break\n\n    q = deque([c for c in indegree if indegree[c] == 0])\n    result = []\n\n    while q:\n        char = q.popleft()\n        result.append(char)\n\n        for neighbor in graph[char]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n\n    return \"\".join(result) if len(result) == len(indegree) else \"\"\n\n\n# DFS - Topological Sort\ndef alienOrderDFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    visited = {}\n    result = []\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                break\n\n    def dfs(c):\n        if c in visited:\n            return visited[c]\n\n        visited[c] = False\n        for neighbor in graph[c]:\n            if not dfs(neighbor):\n                return False\n\n        visited[c] = True\n        result.append(c)\n        return True\n\n    for c in list(graph.keys()):\n        if not dfs(c):\n            return \"\"\n\n    return \"\".join(result[::-1])\n\n\nwords = [\"wrt\", \"wrf\", \"er\", \"ett\", \"rftt\"]\nprint(alienOrderBFS(words))  # wertf\nprint(alienOrderDFS(words))  # wertf\n</code></pre>"},{"location":"blind-75/arrays_hashing/","title":"\u6570\u7ec4\u4e0e\u54c8\u5e0c\u8868 Arrays Hashing","text":""},{"location":"blind-75/arrays_hashing/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 217. Contains Duplicate (Easy)</li> <li> 242. Valid Anagram (Easy)</li> <li> 1. Two Sum (Easy)</li> <li> 49. Group Anagrams (Medium)</li> <li> 347. Top K Frequent Elements (Medium)</li> <li> 271. Encode and Decode Strings (Medium) \ud83d\udc51</li> <li> 238. Product of Array Except Self (Medium)</li> <li> 128. Longest Consecutive Sequence (Medium)</li> </ul>"},{"location":"blind-75/arrays_hashing/#217-contains-duplicate","title":"217. Contains Duplicate","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Sorting</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return True if the array contains any duplicates, otherwise return False.\n\"\"\"\n\nfrom typing import List\n\n\n# Brute Force\ndef containsDuplicateBF(nums: List[int]) -&gt; bool:\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] == nums[j]:\n                return True\n\n    return False\n\n\n# Sort\ndef containsDuplicateSort(nums: List[int]) -&gt; bool:\n    nums.sort()\n\n    for i in range(1, len(nums)):\n        if nums[i] == nums[i - 1]:\n            return True\n\n    return False\n\n\n# Set\ndef containsDuplicateSet(nums: List[int]) -&gt; bool:\n    seen = set()\n\n    for i in nums:\n        if i in seen:\n            return True\n        seen.add(i)\n\n    return False\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# | Brute Force |    O(n^2)       |    O(1)      |\n# |     Sort    |    O(n log n)   |    O(1)      |\n# |     Set     |    O(n)         |    O(n)      |\n# |-------------|-----------------|--------------|\n\nprint(containsDuplicateBF([1, 2, 3, 1]))  # True\nprint(containsDuplicateSort([1, 2, 3, 1]))  # True\nprint(containsDuplicateSet([1, 2, 3, 1]))  # True\n</code></pre>"},{"location":"blind-75/arrays_hashing/#242-valid-anagram","title":"242. Valid Anagram","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sorting</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return true if an input string is an anagram of another string.\n-   An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once, e.g., `listen` is an anagram of `silent`.\n\"\"\"\n\nfrom collections import Counter\n\n\n# Hashmap\ndef isAnagramHash(s: str, t: str) -&gt; bool:\n    \"\"\"Return True if t is an anagram of s, False otherwise.\"\"\"\n    if len(s) != len(t):\n        return False\n\n    count = dict()\n\n    for i in s:\n        if i in count:\n            count[i] += 1\n        else:\n            count[i] = 1\n\n    for j in t:\n        if j in count:\n            count[j] -= 1\n        else:\n            return False\n\n    for count in count.values():\n        if count != 0:\n            return False\n\n    return True\n\n\n# Array\ndef isAnagramArray(s: str, t: str) -&gt; bool:\n    if len(s) != len(t):\n        return False\n\n    count = [0 for _ in range(26)]\n\n    for i in s:\n        count[ord(i) - ord(\"a\")] += 1\n\n    for j in t:\n        count[ord(j) - ord(\"a\")] -= 1\n\n    for i in count:\n        if i != 0:\n            return False\n\n    return True\n\n\n# Counter\ndef isAnagramCounter(s: str, t: str) -&gt; bool:\n    return Counter(s) == Counter(t)\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |   Hashmap   |       O(n)      |     O(1)     |\n# |    Array    |       O(n)      |     O(1)     |\n# |   Counter   |       O(n)      |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\ns = \"anagram\"\nt = \"nagaram\"\nprint(isAnagramHash(s, t))  # True\nprint(isAnagramArray(s, t))  # True\nprint(isAnagramCounter(s, t))  # True\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool isAnagram(string s, string t) {\n        if (s.size() != t.size()) return false;\n\n        vector&lt;int&gt; count(26, 0);\n\n        for (char ch : s) count[ch - 'a']++;\n        for (char ch : t) count[ch - 'a']--;\n        for (int c : count) {\n            if (c != 0) return false;\n        }\n\n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n    assert(solution.isAnagram(\"anagram\", \"nagaram\") == true);\n    assert(solution.isAnagram(\"rat\", \"car\") == false);\n    assert(solution.isAnagram(\"a\", \"ab\") == false);\n    assert(solution.isAnagram(\"a\", \"a\") == true);\n    return 0;\n}\n</code></pre>"},{"location":"blind-75/arrays_hashing/#1-two-sum","title":"1. Two Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return the indices of the two numbers such that they add up to a specific target.\n- Approach: Use a hashmap to store the indices of the numbers.\n- Time Complexity: O(n)\n- Space Complexity: O(n)\n\"\"\"\n\nfrom typing import List\n\n\ndef two_sum(nums: List[int], target: int) -&gt; List[int]:\n    hashmap = {}  # val: idx\n\n    for idx, val in enumerate(nums):\n        if (target - val) in hashmap:\n            return [hashmap[target - val], idx]\n\n        hashmap[val] = idx\n\n    return []\n\n\ndef test_two_sum():\n    assert two_sum([2, 7, 11, 15], 9) == [0, 1]\n    assert two_sum([3, 2, 4], 6) == [1, 2]\n    assert two_sum([3, 3], 6) == [0, 1]\n    assert two_sum([1, 2, 3, 4, 5], 10) == []\n    assert two_sum([-1, -2, -3, -4, -5], -8) == [2, 4]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Solution {\n   public:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {\n        unordered_map&lt;int, int&gt; map;\n\n        for (size_t i = 0; i &lt; nums.size(); i++) {\n            int diff = target - nums[i];\n            if (map.find(diff) != map.end()) {\n                return {map[diff], (int)i};\n            }\n            map[nums[i]] = (int)i;\n        }\n        return {-1, -1};\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; nums = {2, 7, 11, 15};\n    int target = 9;\n    vector&lt;int&gt; result = solution.twoSum(nums, target);\n    assert((result == vector&lt;int&gt;{0, 1}));\n    return 0;\n}\n</code></pre>"},{"location":"blind-75/arrays_hashing/#49-group-anagrams","title":"49. Group Anagrams","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Sorting</p> </li> </ul> PythonCPP <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash - List\ndef groupAnagrams(strs: List[str]) -&gt; List[List[str]]:\n    result = defaultdict(list)\n\n    for s in strs:\n        count = [0] * 26\n        for i in s:\n            count[ord(i) - ord(\"a\")] += 1\n\n        result[tuple(count)].append(s)\n\n    return list(result.values())\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Hash     |     O(n * k)    |     O(n)     |\n# |-------------|-----------------|--------------|\n\n\nstrs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\nprint(groupAnagrams(strs))\n# [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;cassert&gt;\n#include &lt;ranges&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Solution {\n   public:\n    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) {\n        unordered_map&lt;string, vector&lt;string&gt;&gt; map;\n\n        for (string&amp; s : strs) {\n            string sorted = s;\n            ranges::sort(sorted);\n            map[sorted].push_back(s);\n        }\n\n        vector&lt;vector&lt;string&gt;&gt; res;\n\n        for (auto&amp; kv : map) {\n            res.push_back(kv.second);\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;string&gt; strs = {\"eat\", \"tea\", \"tan\"};\n    vector&lt;vector&lt;string&gt;&gt; res = solution.groupAnagrams(strs);\n    assert((res == vector&lt;vector&lt;string&gt;&gt;{{\"eat\", \"tea\"}, {\"tan\"}} ||\n            res == vector&lt;vector&lt;string&gt;&gt;{{\"tan\"}, {\"eat\", \"tea\"}}));\n\n    return 0;\n}\n</code></pre>"},{"location":"blind-75/arrays_hashing/#347-top-k-frequent-elements","title":"347. Top K Frequent Elements","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Divide And Conquer, Sorting, Heap Priority Queue, Bucket Sort, Counting, Quickselect</p> </li> </ul> Python <pre><code>import heapq\nfrom collections import Counter\nfrom typing import List\n\n\n# Heap + Counter\ndef topKFrequent(nums: List[int], k: int) -&gt; List[int]:\n    minHeap = []\n\n    for val, freq in Counter(nums).items():\n        if len(minHeap) &lt; k:\n            heapq.heappush(minHeap, (freq, val))\n        else:\n            heapq.heappushpop(minHeap, (freq, val))\n\n    return [i for _, i in minHeap]\n\n\n# Counter (Most Common)\ndef topKFrequentCounter(nums: List[int], k: int) -&gt; List[int]:\n    commons = Counter(nums).most_common(k)\n    return [i for i, _ in commons]\n\n\nnums = [1, 1, 1, 2, 2, 3]\nk = 2\nprint(topKFrequent(nums, k))  # [1, 2]\nprint(topKFrequentCounter(nums, k))  # [1, 2]\n</code></pre>"},{"location":"blind-75/arrays_hashing/#271-encode-and-decode-strings","title":"271. Encode and Decode Strings \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Design</p> </li> </ul> Python <pre><code>from typing import List\n\n\nclass Codec:\n    def encode(self, strs: List[str]) -&gt; str:\n        \"\"\"Encodes a list of strings to a single string.\"\"\"\n        encoded = \"\"\n\n        for s in strs:\n            encoded += str(len(s)) + \"#\" + s\n\n        return encoded\n\n    def decode(self, s: str) -&gt; List[str]:\n        \"\"\"Decodes a single string to a list of strings.\"\"\"\n        decoded = []\n        i = 0\n\n        while i &lt; len(s):\n            j = i\n            while s[j] != \"#\":\n                j += 1\n\n            strLen = int(s[i:j])\n            decoded.append(s[j + 1 : j + 1 + strLen])\n            i = j + 1 + strLen\n\n        return decoded\n\n\n# |-------------|-------------|--------------|\n# |   Approach  |    Time     |    Space     |\n# |-------------|-------------|--------------|\n# | Two pointers|    O(n)     |     O(n)     |\n# |-------------|-------------|--------------|\n\n\ncodec = Codec()\nencoded = codec.encode([\"hello\", \"world\"])\nprint(encoded)  # \"5#hello5#world\"\ndecoded = codec.decode(encoded)\nprint(decoded)  # [\"hello\", \"world\"]\n</code></pre>"},{"location":"blind-75/arrays_hashing/#238-product-of-array-except-self","title":"238. Product of Array Except Self","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Prefix Sum</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Classic **Prefix Sum** problem\n-   Return an array `output` such that `output[i]` is equal to the product of all the elements of `nums` except `nums[i]`.\n\n| Approach           | Time | Space |\n| ------------------ | ---- | ----- |\n| Prefix             | O(n) | O(n)  |\n| Prefix (Optimized) | O(n) | O(1)  |\n\"\"\"\n\nfrom typing import List\n\n\n# Prefix\ndef productExceptSelf(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    prefix = [1 for _ in range(n)]\n    suffix = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        prefix[i] = nums[i - 1] * prefix[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        suffix[i] = nums[i + 1] * suffix[i + 1]\n\n    result = [i * j for i, j in zip(prefix, suffix)]\n\n    return result\n\n\n# Prefix (Optimized)\ndef productExceptSelfOptimized(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    result = [1 for _ in range(n)]\n\n    prefix = 1\n    for i in range(n):\n        result[i] = prefix\n        prefix *= nums[i]\n\n    suffix = 1\n    for i in range(n - 1, -1, -1):\n        result[i] *= suffix\n        suffix *= nums[i]\n\n    return result\n\n\nprint(productExceptSelf([1, 2, 3, 4]))\n# [24, 12, 8, 6]\nprint(productExceptSelfOptimized([1, 2, 3, 4]))\n# [24, 12, 8, 6]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt; &amp;nums) {\n        int n = nums.size();\n        vector&lt;int&gt; prefix(n, 1);\n        vector&lt;int&gt; suffix(n, 1);\n        vector&lt;int&gt; res(n, 1);\n\n        for (int i = 1; i &lt; n; i++) {\n            prefix[i] = prefix[i - 1] * nums[i - 1];\n        }\n\n        for (int i = n - 2; i &gt;= 0; i--) {\n            suffix[i] = suffix[i + 1] * nums[i + 1];\n        }\n\n        for (int i = 0; i &lt; n; i++) {\n            res[i] = prefix[i] * suffix[i];\n        }\n        return res;\n    }\n};\n\nint main() {\n    vector&lt;int&gt; nums = {1, 2, 3, 4};\n    Solution obj;\n    vector&lt;int&gt; result = obj.productExceptSelf(nums);\n    assert(result == vector&lt;int&gt;({24, 12, 8, 6}));\n    return 0;\n}\n</code></pre>"},{"location":"blind-75/arrays_hashing/#128-longest-consecutive-sequence","title":"128. Longest Consecutive Sequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Union Find</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Set\ndef longestConsecutiveSet(nums: List[int]) -&gt; int:\n    num_set = set(nums)  # O(n)\n    longest = 0\n\n    for n in nums:\n        if (n - 1) not in num_set:  # left boundary\n            length = 1\n\n            while (n + length) in num_set:\n                length += 1\n\n            longest = max(longest, length)\n\n    return longest\n\n\n# Union Find\ndef longestConsecutiveUF(nums: List[int]) -&gt; int:\n    if not nums:\n        return 0\n\n    par = {num: num for num in nums}\n    rank = {num: 1 for num in nums}\n\n    def find(num):\n        p = par[num]\n        while p != par[p]:\n            p = par[p]\n        return p\n\n    def union(num1, num2):\n        p1, p2 = find(num1), find(num2)\n        if p1 == p2:\n            return\n\n        if rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n            rank[p2] += rank[p1]\n        else:\n            par[p2] = p1\n            rank[p1] += rank[p2]\n\n    for num in nums:\n        if num - 1 in par:\n            union(num, num - 1)\n\n    return max(rank.values())\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |  Set       |  O(N)  |  O(N)   |\n# | Union Find |  O(N)  |  O(N)   |\n# |------------|--------|---------|\n\n\nnums = [100, 4, 200, 1, 3, 2]\nprint(longestConsecutiveSet(nums))  # 4\nprint(longestConsecutiveUF(nums))  # 4\n</code></pre>"},{"location":"blind-75/backtracking/","title":"\u56de\u6eaf Backtracking","text":""},{"location":"blind-75/backtracking/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 39. Combination Sum (Medium)</li> <li> 79. Word Search (Medium)</li> </ul>"},{"location":"blind-75/backtracking/#39-combination-sum","title":"39. Combination Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef combinationSum(candidates: List[int], target: int) -&gt; List[List[int]]:\n    n = len(candidates)\n    res, path = [], []\n\n    def dfs(total, start):\n        if total &gt; target:\n            return\n        if total == target:\n            res.append(path.copy())\n            return\n\n        for i in range(start, n):\n            total += candidates[i]\n            path.append(candidates[i])\n            dfs(total, i)\n            total -= candidates[i]\n            path.pop()\n\n    dfs(0, 0)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(combinationSum([2, 3, 5], 8))\n    # [[2, 2, 2, 2], [2, 3, 3], [3, 5]]\n    print(combinationSum([2, 3, 6, 7], 7))\n    # [[2, 2, 3], [7]]\n</code></pre>"},{"location":"blind-75/backtracking/#79-word-search","title":"79. Word Search","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Backtracking, Depth First Search, Matrix</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef exist(board: List[List[str]], word: str) -&gt; bool:\n    m, n = len(board), len(board[0])\n    path = set()\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n\n    def dfs(r, c, i):\n        if i == len(word):\n            return True\n\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or board[r][c] != word[i] or (r, c) in path:\n            return False\n\n        path.add((r, c))\n\n        for dr, dc in dirs:\n            if dfs(r + dr, c + dc, i + 1):\n                return True\n\n        path.remove((r, c))\n        return False\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, 0):\n                return True\n\n    return False\n\n\nboard = [\n    [\"A\", \"B\", \"C\", \"E\"],\n    [\"S\", \"F\", \"C\", \"S\"],\n    [\"A\", \"D\", \"E\", \"E\"],\n]\nword = \"ABCCED\"\nprint(exist(board, word))  # True\n</code></pre>"},{"location":"blind-75/binary_search/","title":"\u4e8c\u5206\u67e5\u627e Binary Search","text":""},{"location":"blind-75/binary_search/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 153. Find Minimum in Rotated Sorted Array (Medium)</li> <li> 33. Search in Rotated Sorted Array (Medium)</li> </ul>"},{"location":"blind-75/binary_search/#153-find-minimum-in-rotated-sorted-array","title":"153. Find Minimum in Rotated Sorted Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Binary Search\ndef findMin(nums: List[int]) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt; right:\n        mid = left + (right - left) // 2\n        if nums[mid] &gt; nums[right]:\n            left = mid + 1\n        else:\n            right = mid\n\n    return nums[right]\n\n\nnums = [4, 5, 6, 7, 0, 1, 2]\nprint(findMin(nums))  # 0\n</code></pre>"},{"location":"blind-75/binary_search/#33-search-in-rotated-sorted-array","title":"33. Search in Rotated Sorted Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Binary Search\ndef search(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] == target:\n            return mid\n\n        if nums[left] &lt;= nums[mid]:\n            if nums[left] &lt;= target &lt; nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if nums[mid] &lt; target &lt;= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n    return -1\n\n\nnums = [4, 5, 6, 7, 0, 1, 2]\ntarget = 0\nprint(search(nums, target))  # 4\n</code></pre>"},{"location":"blind-75/bit_manipulation/","title":"\u4f4d\u8fd0\u7b97 Bit Manipulation","text":""},{"location":"blind-75/bit_manipulation/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 191. Number of 1 Bits (Easy)</li> <li> 338. Counting Bits (Easy)</li> <li> 190. Reverse Bits (Easy)</li> <li> 268. Missing Number (Easy)</li> <li> 371. Sum of Two Integers (Medium)</li> </ul>"},{"location":"blind-75/bit_manipulation/#191-number-of-1-bits","title":"191. Number of 1 Bits","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Divide And Conquer, Bit Manipulation</p> </li> </ul> Python <pre><code># Bit Manipulation\ndef hammingWeight1(n: int) -&gt; int:\n    res = 0\n\n    while n != 0:\n        n = n &amp; (n - 1)  # Unset the rightmost 1-bit\n        res += 1\n\n    return res\n\n\ndef hammingWeight2(n: int) -&gt; int:\n    return bin(n).count(\"1\")\n\n\ndef hammingWeight3(n: int) -&gt; int:\n    def decimalToBinary(n: int) -&gt; str:\n        if n == 0:\n            return \"0\"\n\n        binary = \"\"\n        while n &gt; 0:\n            binary = str(n % 2) + binary\n            n //= 2\n\n        return binary\n\n    binary = decimalToBinary(n)\n\n    return binary.count(\"1\")\n\n\nn = 11\nprint(hammingWeight1(n))  # 3\nprint(hammingWeight2(n))  # 3\n\nn = 47\nprint(bin(n))\n</code></pre>"},{"location":"blind-75/bit_manipulation/#338-counting-bits","title":"338. Counting Bits","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Bit Manipulation</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Bit Manipulation\ndef countBits(n: int) -&gt; List[int]:\n    bits = [0 for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        bits[i] = bits[i &gt;&gt; 1] + (i &amp; 1)\n\n    return bits\n\n\nn = 5\nprint(countBits(n))  # [0, 1, 1, 2, 1, 2]\n</code></pre>"},{"location":"blind-75/bit_manipulation/#190-reverse-bits","title":"190. Reverse Bits","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Divide And Conquer, Bit Manipulation</p> </li> </ul> Python <pre><code># Bit Manipulation\ndef reverseBits(n: int) -&gt; int:\n    res = 0\n\n    for i in range(32):\n        res = (res &lt;&lt; 1) | (n &amp; 1)\n        n &gt;&gt;= 1\n\n    return res\n\n\nn = 0b00000010100101000001111010011100\nprint(reverseBits(n))  # 964176192\n</code></pre>"},{"location":"blind-75/bit_manipulation/#268-missing-number","title":"268. Missing Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Binary Search, Bit Manipulation, Sorting</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Math\ndef missingNumberMath(nums: List[int]) -&gt; int:\n    n = len(nums)\n    return (n * (n + 1)) // 2 - sum(nums)\n\n\n# Bit Manipulation (XOR)\ndef missingNumberXOR(nums: List[int]) -&gt; int:\n    n = len(nums)\n\n    for i, num in enumerate(nums):\n        n ^= i ^ num\n\n    return n\n\n\nnums = [3, 0, 1]\nprint(missingNumberMath(nums))  # 2\nprint(missingNumberXOR(nums))  # 2\n</code></pre>"},{"location":"blind-75/bit_manipulation/#371-sum-of-two-integers","title":"371. Sum of Two Integers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Bit Manipulation</p> </li> </ul> Python <pre><code># Bit Manipulation\ndef getSum(a: int, b: int) -&gt; int:\n    MASK = 0xFFFFFFFF\n    MAX_INT = 0x7FFFFFFF\n\n    while b != 0:\n        temp = (a ^ b) &amp; MASK\n        b = ((a &amp; b) &lt;&lt; 1) &amp; MASK\n        a = temp\n\n    return a if a &lt;= MAX_INT else ~(a ^ MASK)\n\n\nprint(getSum(1, 2))  # 3\n</code></pre>"},{"location":"blind-75/graphs/","title":"\u56fe\u8bba Graphs","text":""},{"location":"blind-75/graphs/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 200. Number of Islands (Medium)</li> <li> 133. Clone Graph (Medium)</li> <li> 417. Pacific Atlantic Water Flow (Medium)</li> <li> 207. Course Schedule (Medium)</li> <li> 261. Graph Valid Tree (Medium) \ud83d\udc51</li> <li> 323. Number of Connected Components in an Undirected Graph (Medium) \ud83d\udc51</li> </ul>"},{"location":"blind-75/graphs/#200-number-of-islands","title":"200. Number of Islands","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Union Find, Matrix</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Count the number of islands in a 2D grid.\n-   Method 1: DFS\n-   Method 2: BFS (use a queue to traverse the grid)\n\n-   How to keep track of visited cells?\n\n    1. Mark the visited cell as `0` (or any other value) to avoid revisiting it.\n    2. Use a set to store the visited cells.\n\n-   Steps:\n    1. Init: variables\n    2. DFS/BFS: starting from the cell with `1`, turn all the connected `1`s to `0`.\n    3. Traverse the grid, and if the cell is `1`, increment the count and call DFS/BFS.\n\n![0200](../../assets/0200.jpg)\n\"\"\"\n\nfrom collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef numIslandsDFS(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    res = 0\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] != \"1\":\n            return\n\n        grid[r][c] = \"2\"\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                dfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Set\ndef numIslandsBFS1(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == \"0\"\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\" and (r, c) not in visited:\n                visited.add((r, c))\n                bfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = dr + row, dc + col\n                if nr &lt; 0 or nr &gt;= m or nc &lt; 0 or nc &gt;= n or grid[nr][nc] != \"1\":\n                    continue\n                grid[nr][nc] = \"2\"\n                q.append((nr, nc))\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == \"1\":\n                grid[i][j] = \"2\"\n                bfs(i, j)\n                res += 1\n\n    return res\n\n\ngrid = [\n    [\"1\", \"1\", \"1\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"0\", \"0\", \"0\", \"0\", \"0\"],\n]\n\nprint(numIslandsDFS(deepcopy(grid)))  # 1\nprint(numIslandsBFS1(deepcopy(grid)))  # 1\nprint(numIslandsBFS2(deepcopy(grid)))  # 1\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    // dfs\n    int num_islands_dfs(vector&lt;vector&lt;char&gt;&gt; &amp;grid) {\n        int m = grid.size(), n = grid[0].size();\n        int res = 0;\n\n        // c++23 lambda recursion\n        auto dfs = [&amp;](this auto &amp;&amp;dfs, int r, int c) -&gt; void {\n            if (r &lt; 0 || r &gt;= m || c &lt; 0 || c &gt;= n || grid[r][c] != '1') {\n                return;\n            }\n            grid[r][c] = '0';\n            dfs(r + 1, c);\n            dfs(r - 1, c);\n            dfs(r, c + 1);\n            dfs(r, c - 1);\n        };\n\n        for (int i = 0; i &lt; m; i++) {\n            for (int j = 0; j &lt; n; j++) {\n                if (grid[i][j] == '1') {\n                    res++;\n                    dfs(i, j);\n                }\n            }\n        }\n        return res;\n    }\n\n    // bfs\n    int num_islands_bfs(vector&lt;vector&lt;char&gt;&gt; &amp;grid) {\n        int m = grid.size(), n = grid[0].size();\n        int res = 0;\n        vector&lt;pair&lt;int, int&gt;&gt; dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\n        auto bfs = [&amp;](int r, int c) {\n            queue&lt;pair&lt;int, int&gt;&gt; q;\n            q.push({r, c});\n            grid[r][c] = '0';\n            while (!q.empty()) {\n                auto [cr, cc] = q.front();\n                q.pop();\n                for (auto &amp;[dr, dc] : dirs) {\n                    int nr = cr + dr, nc = cc + dc;\n                    if (nr &gt;= 0 &amp;&amp; nr &lt; m &amp;&amp; nc &gt;= 0 &amp;&amp; nc &lt; n &amp;&amp;\n                        grid[nr][nc] == '1') {\n                        grid[nr][nc] = '0';\n                        q.push({nr, nc});\n                    }\n                }\n            }\n        };\n\n        for (int i = 0; i &lt; m; i++) {\n            for (int j = 0; j &lt; n; j++) {\n                if (grid[i][j] == '1') {\n                    res++;\n                    bfs(i, j);\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;vector&lt;char&gt;&gt; grid = {{'1', '1', '0', '0', '0'},\n                                 {'1', '1', '0', '0', '0'},\n                                 {'0', '0', '1', '0', '0'},\n                                 {'0', '0', '0', '1', '1'}};\n    assert(solution.num_islands_dfs(grid) == 3);\n    grid = {{'1', '1', '0', '0', '0'},\n            {'1', '1', '0', '0', '0'},\n            {'0', '0', '1', '0', '0'},\n            {'0', '0', '0', '1', '1'}};\n    assert(solution.num_islands_bfs(grid) == 3);\n    return 0;\n}\n</code></pre>"},{"location":"blind-75/graphs/#133-clone-graph","title":"133. Clone Graph","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Depth First Search, Breadth First Search, Graph</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import Optional\n\n\nclass Node:\n    def __init__(self, val=0, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\n\nclass CloneGraph:\n    def dfs(self, node: Optional[\"Node\"]) -&gt; Optional[\"Node\"]:\n        hashmap = {}\n\n        def dfs(node):\n            if node in hashmap:\n                return hashmap[node]\n\n            res = Node(node.val)\n            hashmap[node] = res\n\n            for nei in node.neighbors:\n                res.neighbors.append(dfs(nei))\n\n            return res\n\n        return dfs(node) if node else None\n\n    def bfs(self, node: Optional[\"Node\"]) -&gt; Optional[\"Node\"]:\n        if not node:\n            return None\n\n        hashmap = {node: Node(node.val)}\n        q = deque([node])\n\n        while q:\n            cur = q.popleft()\n\n            for nei in cur.neighbors:\n                if nei not in hashmap:\n                    hashmap[nei] = Node(nei.val)\n                    q.append(nei)\n\n                hashmap[cur].neighbors.append(hashmap[nei])\n\n        return hashmap[node]\n</code></pre>"},{"location":"blind-75/graphs/#417-pacific-atlantic-water-flow","title":"417. Pacific Atlantic Water Flow","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Matrix</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef pacificAtlanticDFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(r, c, visited, prev_height):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or heights[r][c] &lt; prev_height\n            or (r, c) in visited\n        ):\n            return None\n\n        visited.add((r, c))\n        height = heights[r][c]\n        for dr, dc in directions:\n            dfs(dr + r, dc + c, visited, height)\n\n    for c in range(n):\n        dfs(0, c, pac, heights[0][c])\n        dfs(m - 1, c, atl, heights[m - 1][c])\n\n    for r in range(m):\n        dfs(r, 0, pac, heights[r][0])\n        dfs(r, n - 1, atl, heights[r][n - 1])\n\n    return list(pac &amp; atl)\n\n\n# BFS\ndef pacificAtlanticBFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def bfs(r, c, visited):\n        q = deque([(r, c)])\n        visited.add((r, c))\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr in range(m)\n                    and nc in range(n)\n                    and heights[row][col] &lt;= heights[nr][nc]\n                    and (nr, nc) not in visited\n                ):\n                    q.append((nr, nc))\n                    visited.add((nr, nc))\n\n    for c in range(n):\n        bfs(0, c, pac)  # top\n        bfs(m - 1, c, atl)  # bottom\n\n    for r in range(m):\n        bfs(r, 0, pac)  # left\n        bfs(r, n - 1, atl)  # right\n\n    return list(pac &amp; atl)\n\n\nheights = [\n    [1, 2, 2, 3, 5],\n    [3, 2, 3, 4, 4],\n    [2, 4, 5, 3, 1],\n    [6, 7, 1, 4, 5],\n    [5, 1, 1, 2, 4],\n]\nprint(pacificAtlanticDFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\nprint(pacificAtlanticBFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\n</code></pre>"},{"location":"blind-75/graphs/#207-course-schedule","title":"207. Course Schedule","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Graph, Topological Sort</p> </li> </ul> PythonCPP <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS (Kahn's Algorithm)\ndef canFinishBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    count = 0\n\n    while q:\n        crs = q.popleft()\n        count += 1\n\n        for nxt in graph[crs]:\n            indegree[nxt] -= 1\n\n            if indegree[nxt] == 0:\n                q.append(nxt)\n\n    return count == numCourses\n\n\n# DFS + Set\ndef canFinishDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for crs, pre in prerequisites:\n        graph[crs].append(pre)\n\n    visiting = set()\n\n    def dfs(crs):\n        if crs in visiting:  # cycle detected\n            return False\n        if graph[crs] == []:\n            return True\n\n        visiting.add(crs)\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        visiting.remove(crs)\n        graph[crs] = []\n\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\n# DFS + List\ndef canFinishDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for pre, crs in prerequisites:\n        graph[crs].append(pre)\n\n    # 0: init, 1: visiting, 2: visited\n    status = [0] * numCourses\n\n    def dfs(crs):\n        if status[crs] == 1:  # cycle detected\n            return False\n        if status[crs] == 2:\n            return True\n\n        status[crs] = 1\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        status[crs] = 2\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(canFinishBFS(5, prerequisites))  # True\nprint(canFinishDFS1(5, prerequisites))  # True\nprint(canFinishDFS2(5, prerequisites))  # True\n</code></pre> <pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    // BFS\n    bool canFinishBFS(int numCourses, vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        vector&lt;int&gt; indegree(numCourses, 0);\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n            indegree[pre[0]]++;\n        }\n\n        queue&lt;int&gt; q;\n        for (int i = 0; i &lt; numCourses; i++) {\n            if (indegree[i] == 0) {\n                q.push(i);\n            }\n        }\n\n        int cnt = 0;\n        while (!q.empty()) {\n            int cur = q.front();\n            q.pop();\n            cnt++;\n\n            for (int nxt : graph[cur]) {\n                indegree[nxt]--;\n                if (indegree[nxt] == 0) {\n                    q.push(nxt);\n                }\n            }\n        }\n        return cnt == numCourses;\n    }\n\n    // DFS\n    bool canFinishDFS(int numCourses, vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n        }\n        // 0: not visited, 1: visiting, 2: visited\n        vector&lt;int&gt; state(numCourses, 0);\n\n        function&lt;bool(int)&gt; dfs = [&amp;](int pre) -&gt; bool {\n            state[pre] = 1;  // visiting\n            for (int crs : graph[pre]) {\n                if (state[crs] == 1 || (state[crs] == 0 &amp;&amp; dfs(crs))) {\n                    return true;\n                }\n            }\n            state[pre] = 2;  // visited\n            return false;\n        };\n\n        for (int i = 0; i &lt; numCourses; i++) {\n            if (state[i] == 0 &amp;&amp; dfs(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution sol;\n    vector&lt;vector&lt;int&gt;&gt; prerequisites = {{1, 0}, {2, 1}, {3, 2}, {4, 3},\n                                         {5, 4}, {6, 5}, {7, 6}, {8, 7},\n                                         {9, 8}, {10, 9}};\n    int numCourses = 11;\n    cout &lt;&lt; sol.canFinishBFS(numCourses, prerequisites) &lt;&lt; endl;\n    cout &lt;&lt; sol.canFinishDFS(numCourses, prerequisites) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"blind-75/graphs/#261-graph-valid-tree","title":"261. Graph Valid Tree \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Union Find, Graph</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Graph\ndef validTree(n: int, edges: List[List[int]]) -&gt; bool:\n    if n == 0:\n        return False\n    if len(edges) != n - 1:\n        return False\n\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = set()\n\n    def dfs(node, parent):\n        if node in visited:\n            return False\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor != parent and not dfs(neighbor, node):\n                return False\n        return True\n\n    return dfs(0, -1) and len(visited) == n\n\n\nprint(validTree(5, [[0, 1], [0, 2], [0, 3], [1, 4]]))  # True\nprint(validTree(5, [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]))  # False\n</code></pre>"},{"location":"blind-75/graphs/#323-number-of-connected-components-in-an-undirected-graph","title":"323. Number of Connected Components in an Undirected Graph \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Union Find, Graph</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Union Find\ndef countComponents(n: int, edges: List[List[int]]) -&gt; int:\n    uf = UnionFind(n)\n    count = n\n\n    for u, v in edges:\n        count -= uf.union(u, v)\n\n    return count\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(n)}\n        self.rank = {i: 1 for i in range(n)}\n\n    def find(self, n):\n        p = self.par[n]\n        while self.par[p] != p:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return 0\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.par[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.par[p1] = p2\n        else:\n            self.par[p2] = p1\n            self.rank[p1] += 1\n\n        return 1\n\n\nprint(countComponents(5, [[0, 1], [1, 2], [3, 4]]))  # 2\n</code></pre>"},{"location":"blind-75/greedy/","title":"\u8d2a\u5fc3 Greedy","text":""},{"location":"blind-75/greedy/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 53. Maximum Subarray (Medium)</li> <li> 55. Jump Game (Medium)</li> </ul>"},{"location":"blind-75/greedy/#53-maximum-subarray","title":"53. Maximum Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Divide And Conquer, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP Kadane\ndef maxSubArrayDP(nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n\n    dp[0] = nums[0]\n    maxSum = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(\n            dp[i - 1] + nums[i],  # continue the previous subarray\n            nums[i],  # start a new subarray\n        )\n        maxSum = max(maxSum, dp[i])\n\n    return maxSum\n\n\n# Greedy\ndef maxSubArrayGreedy(nums: List[int]) -&gt; int:\n    max_sum = nums[0]\n    cur_sum = 0\n\n    for num in nums:\n        cur_sum = max(cur_sum + num, num)\n        max_sum = max(max_sum, cur_sum)\n\n    return max_sum\n\n\n# Prefix Sum\ndef maxSubArrayPrefixSum(nums: List[int]) -&gt; int:\n    prefix_sum = 0\n    prefix_sum_min = 0\n    res = float(\"-inf\")\n\n    for num in nums:\n        prefix_sum += num\n        res = max(res, prefix_sum - prefix_sum_min)\n        prefix_sum_min = min(prefix_sum_min, prefix_sum)\n\n    return res\n\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArrayDP(nums))  # 6\nprint(maxSubArrayGreedy(nums))  # 6\nprint(maxSubArrayPrefixSum(nums))  # 6\n</code></pre>"},{"location":"blind-75/greedy/#55-jump-game","title":"55. Jump Game","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return `True` if you can reach the last index, otherwise `False`.\n\"\"\"\n\nfrom typing import List\n\n\n# Greedy - Interval\ndef canJump(nums: List[int]) -&gt; bool:\n    n = len(nums)\n    reach = 0\n    i = 0\n\n    while reach &gt;= i:\n        if reach &gt;= n - 1:\n            return True\n        reach = max(reach, i + nums[i])\n        i += 1\n\n    return False\n\n\nif __name__ == \"__main__\":\n    assert canJump([2, 3, 1, 1, 4]) is True\n    assert canJump([3, 2, 1, 0, 4]) is False\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool canJump(vector&lt;int&gt;&amp; nums) {\n        int canReach = 0;\n        int n = nums.size();\n\n        for (int i = 0; i &lt; n; i++) {\n            if (i &gt; canReach) return false;\n            canReach = max(canReach, i + nums[i]);\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution obj;\n    vector&lt;int&gt; nums = {2, 3, 1, 1, 4};\n    cout &lt;&lt; obj.canJump(nums) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"blind-75/heap/","title":"\u5806 Heap","text":""},{"location":"blind-75/heap/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 295. Find Median from Data Stream (Hard)</li> </ul>"},{"location":"blind-75/heap/#295-find-median-from-data-stream","title":"295. Find Median from Data Stream","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, Design, Sorting, Heap Priority Queue, Data Stream</p> </li> </ul> PythonCPP <pre><code>from heapq import heappop, heappush\n\n\nclass MedianFinder:\n\n    def __init__(self):\n        self.minHeap = []\n        self.maxHeap = []\n        self.min_size = 0\n        self.max_size = 0\n\n    def addNum(self, num: int) -&gt; None:\n        heappush(self.maxHeap, -num)\n        heappush(self.minHeap, -heappop(self.maxHeap))\n        self.min_size += 1\n\n        if self.min_size &gt; self.max_size:\n            heappush(self.maxHeap, -heappop(self.minHeap))\n            self.min_size -= 1\n            self.max_size += 1\n\n    def findMedian(self) -&gt; float:\n        if self.min_size == self.max_size:\n            return (-self.maxHeap[0] + self.minHeap[0]) / 2.0\n        return float(-self.maxHeap[0])\n\n\ndef test_median_finder():\n    obj = MedianFinder()\n    obj.addNum(1)\n    obj.addNum(2)\n    assert obj.findMedian() == 1.5\n    obj.addNum(3)\n    assert obj.findMedian() == 2.0\n    obj.addNum(4)\n    assert obj.findMedian() == 2.5\n    obj.addNum(5)\n    assert obj.findMedian() == 3.0\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass MedianFinder {\n   private:\n    priority_queue&lt;int&gt; maxHeap;\n    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;\n    int max_size = 0;\n    int min_size = 0;\n\n   public:\n    MedianFinder() {}\n\n    void addNum(int num) {\n        if (min_size == max_size) {\n            minHeap.push(num);\n            maxHeap.push(minHeap.top());\n            minHeap.pop();\n            max_size++;\n        } else {\n            maxHeap.push(num);\n            minHeap.push(maxHeap.top());\n            maxHeap.pop();\n            min_size++;\n        }\n    }\n\n    double findMedian() {\n        if (min_size == max_size) {\n            return (maxHeap.top() + minHeap.top()) / 2.0;\n        } else {\n            return (double)maxHeap.top();\n        }\n    }\n};\n\nint main() {\n    MedianFinder* obj = new MedianFinder();\n    obj-&gt;addNum(1);\n    obj-&gt;addNum(2);\n    cout &lt;&lt; obj-&gt;findMedian() &lt;&lt; endl;  // 1.5\n    obj-&gt;addNum(3);\n    cout &lt;&lt; obj-&gt;findMedian() &lt;&lt; endl;  // 2\n    return 0;\n}\n</code></pre>"},{"location":"blind-75/intervals/","title":"\u533a\u95f4\u95ee\u9898 Intervals","text":""},{"location":"blind-75/intervals/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 57. Insert Interval (Medium)</li> <li> 56. Merge Intervals (Medium)</li> <li> 252. Meeting Rooms (Easy) \ud83d\udc51</li> <li> 253. Meeting Rooms II (Medium) \ud83d\udc51</li> <li> 254. Factor Combinations (Medium) \ud83d\udc51</li> </ul>"},{"location":"blind-75/intervals/#57-insert-interval","title":"57. Insert Interval","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Interval\ndef insert(intervals: List[List[int]], newInterval: List[int]) -&gt; List[List[int]]:\n    n = len(intervals)\n\n    if n == 0:\n        return [newInterval]\n\n    if newInterval[1] &lt; intervals[0][0]:\n        return [newInterval] + intervals\n\n    if newInterval[0] &gt; intervals[-1][1]:\n        return intervals + [newInterval]\n\n    i = 0\n    result = []\n\n    while i &lt; n and intervals[i][1] &lt; newInterval[0]:\n        result.append(intervals[i])\n        i += 1\n\n    while i &lt; n and intervals[i][0] &lt;= newInterval[1]:\n        newInterval[0] = min(newInterval[0], intervals[i][0])\n        newInterval[1] = max(newInterval[1], intervals[i][1])\n        i += 1\n\n    result.append(newInterval)\n\n    while i &lt; n:\n        result.append(intervals[i])\n        i += 1\n\n    return result\n\n\nintervals = [[1, 3], [6, 9]]\nnewInterval = [2, 5]\nprint(insert(intervals, newInterval))  # [[1, 5], [6, 9]]\n</code></pre>"},{"location":"blind-75/intervals/#56-merge-intervals","title":"56. Merge Intervals","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sorting</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Merge all overlapping intervals.\n\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/44H3cEC2fFM?si=J-Jr_Fg2eDse3-de\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen&gt;&lt;/iframe&gt;\n\"\"\"\n\nfrom typing import List\n\n\n# Intervals\ndef merge(intervals: List[List[int]]) -&gt; List[List[int]]:\n    n = len(intervals)\n    if n &lt;= 1:\n        return intervals\n\n    intervals.sort(key=lambda x: x[0])\n    res = [intervals[0]]\n\n    for i in range(1, n):\n        if intervals[i][0] &lt;= res[-1][1]:\n            res[-1][1] = max(res[-1][1], intervals[i][1])\n        else:\n            res.append(intervals[i])\n\n    return res\n\n\nprint(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))\n# [[1, 6], [8, 10], [15, 18]]\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// Interval\nvector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {\n    sort(intervals.begin(), intervals.end());\n    vector&lt;vector&lt;int&gt;&gt; res;\n\n    for (auto&amp; range : intervals) {\n        if (!res.empty() &amp;&amp; range[0] &lt;= res.back()[1]) {\n            res.back()[1] = max(res.back()[1], range[1]);\n        } else {\n            res.emplace_back(range);\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;vector&lt;int&gt;&gt; intervals = {{1, 3}, {2, 6}, {8, 10}, {15, 18}};\n    vector&lt;vector&lt;int&gt;&gt; res = merge(intervals);\n    for (auto&amp; range : res) {\n        cout &lt;&lt; range[0] &lt;&lt; \", \" &lt;&lt; range[1] &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"blind-75/intervals/#252-meeting-rooms","title":"252. Meeting Rooms \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sorting</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Interval\ndef canAttendMeetings(intervals: List[List[int]]) -&gt; bool:\n    intervals.sort(key=lambda x: x[0])\n    n = len(intervals)\n\n    if n &lt;= 1:\n        return True\n\n    for i in range(1, n):\n        if intervals[i][0] &lt; intervals[i - 1][1]:\n            return False\n\n    return True\n\n\nif __name__ == \"__main__\":\n    intervals = [[0, 30], [5, 10], [15, 20]]\n    assert not canAttendMeetings(intervals)\n</code></pre>"},{"location":"blind-75/intervals/#253-meeting-rooms-ii","title":"253. Meeting Rooms II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Greedy, Sorting, Heap Priority Queue, Prefix Sum</p> </li> </ul> Python <pre><code>\"\"\"\n- Given an array of meeting time `intervals` where `intervals[i] = [start_i, end_i]`, return the minimum number of conference rooms required.\n\"\"\"\n\nimport heapq\nfrom typing import List\n\n\n# Heap\ndef minMeetingRooms(intervals: List[List[int]]) -&gt; int:\n    if not intervals:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n    minHeap = [intervals[0][1]]\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &gt;= minHeap[0]:\n            heapq.heappop(minHeap)\n        heapq.heappush(minHeap, intervals[i][1])\n\n    return len(minHeap)\n\n\nif __name__ == \"__main__\":\n    intervals = [[0, 30], [5, 10], [15, 20]]\n    assert minMeetingRooms(intervals) == 2\n</code></pre>"},{"location":"blind-75/intervals/#254-factor-combinations","title":"254. Factor Combinations \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Backtracking</p> </li> </ul>"},{"location":"blind-75/linked_list/","title":"\u94fe\u8868 Linked List","text":""},{"location":"blind-75/linked_list/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 206. Reverse Linked List (Easy)</li> <li> 21. Merge Two Sorted Lists (Easy)</li> <li> 143. Reorder List (Medium)</li> <li> 19. Remove Nth Node From End of List (Medium)</li> <li> 141. Linked List Cycle (Easy)</li> <li> 23. Merge k Sorted Lists (Hard)</li> </ul>"},{"location":"blind-75/linked_list/#206-reverse-linked-list","title":"206. Reverse Linked List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Recursion</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\ndef reverse_list_iterative(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    cur = head\n    prev = None\n\n    while cur:\n        temp = cur.next\n        cur.next = prev\n\n        prev = cur\n        cur = temp\n\n    return prev\n\n\ndef reverse_list_recursive(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    def reverse(cur, prev):\n        if not cur:\n            return prev\n\n        temp = cur.next\n        cur.next = prev\n        return reverse(temp, cur)\n\n    return reverse(head, None)\n\n\ndef test_reverse_list():\n    ll = LinkedList([1, 2, 3, 4, 5])\n    ll.head = reverse_list_iterative(ll.head)\n    assert ll.to_array() == [5, 4, 3, 2, 1]\n\n    ll = LinkedList([1, 2, 3, 4, 5])\n    ll.head = reverse_list_recursive(ll.head)\n    assert ll.to_array() == [5, 4, 3, 2, 1]\n</code></pre>"},{"location":"blind-75/linked_list/#21-merge-two-sorted-lists","title":"21. Merge Two Sorted Lists","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Recursion</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Task: Merge the two linked lists into one sorted list.\n\"\"\"\n\nfrom typing import Optional\n\nfrom leetpattern.utils import ListNode\n\n\n# Linked List\ndef merge_two_lists(\n    list1: Optional[ListNode], list2: Optional[ListNode]\n) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    while list1 and list2:\n        if list1.val &lt; list2.val:\n            cur.next = list1\n            list1 = list1.next\n        else:\n            cur.next = list2\n            list2 = list2.next\n        cur = cur.next\n\n    if list1:\n        cur.next = list1\n    elif list2:\n        cur.next = list2\n\n    return dummy.next\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode* next) : val(x), next(next) {}\n};\n\nclass Solution {\n   public:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        ListNode dummy;\n        ListNode* cur = &amp;dummy;\n\n        while (list1 &amp;&amp; list2) {\n            if (list1-&gt;val &lt; list2-&gt;val) {\n                cur-&gt;next = list1;\n                list1 = list1-&gt;next;\n            } else {\n                cur-&gt;next = list2;\n                list2 = list2-&gt;next;\n            }\n            cur = cur-&gt;next;\n        }\n\n        cur-&gt;next = list1 ? list1 : list2;\n\n        return dummy.next;\n    }\n};\n\nint main() {\n    Solution sol;\n    ListNode* list1 = new ListNode(1, new ListNode(2, new ListNode(4)));\n    ListNode* list2 = new ListNode(1, new ListNode(3, new ListNode(4)));\n    ListNode* merged = sol.mergeTwoLists(list1, list2);\n    vector&lt;int&gt; res;\n    while (merged) {\n        res.push_back(merged-&gt;val);\n        merged = merged-&gt;next;\n    }\n    assert(res == std::vector&lt;int&gt;({1, 1, 2, 3, 4, 4}));\n    return 0;\n}\n</code></pre>"},{"location":"blind-75/linked_list/#143-reorder-list","title":"143. Reorder List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Two Pointers, Stack, Recursion</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\n# Linked List\ndef reorderList(head: Optional[ListNode]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify head in-place instead.\n    \"\"\"\n    if not head or not head.next:\n        return\n\n    # Middle of the linked list\n    slow, fast = head, head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n    # Reverse the second half\n    pre, cur = None, slow\n    while cur:\n        temp = cur.next\n        cur.next = pre\n        pre = cur\n        cur = temp\n\n    # Merge two linked lists\n    first, second = head, pre\n    while second.next:\n        temp1, temp2 = first.next, second.next\n        first.next = second\n        second.next = temp1\n        first, second = temp1, temp2\n\n\ndef test_reorderList():\n    ll = LinkedList([1, 2, 3, 4, 5, 6])\n    assert ll.to_array() == [1, 2, 3, 4, 5, 6]\n    reorderList(ll.head)\n    assert ll.to_array() == [1, 6, 2, 5, 3, 4]\n\n    ll2 = LinkedList([1, 2, 3, 4, 5])\n    assert ll2.to_array() == [1, 2, 3, 4, 5]\n    reorderList(ll2.head)\n    assert ll2.to_array() == [1, 5, 2, 4, 3]\n</code></pre>"},{"location":"blind-75/linked_list/#19-remove-nth-node-from-end-of-list","title":"19. Remove Nth Node From End of List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Two Pointers</p> </li> </ul> Python <pre><code>\"\"\"\n-   Given the `head` of a linked list, remove the `n-th` node from the end of the list and return its head.\n\"\"\"\n\nfrom typing import Optional\n\nfrom leetpattern.utils import ListNode, list_from_array, list_to_array\n\n\n# Linked List\ndef removeNthFromEnd(head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:\n    dummy = ListNode(0, head)\n    fast, slow = dummy, dummy\n\n    for _ in range(n):\n        fast = fast.next\n\n    while fast.next:\n        fast = fast.next\n        slow = slow.next\n\n    slow.next = slow.next.next\n\n    return dummy.next\n\n\ndef test_removeNthFromEnd() -&gt; None:\n    head = list_from_array([1, 2, 3, 4, 5])\n    assert (list_to_array(removeNthFromEnd(head, 2))) == [1, 2, 3, 5]\n</code></pre>"},{"location":"blind-75/linked_list/#141-linked-list-cycle","title":"141. Linked List Cycle","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Linked List, Two Pointers</p> </li> </ul> PythonCPP <pre><code>from typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\ndef has_cycle(head: Optional[ListNode]) -&gt; bool:\n    slow, fast = head, head\n\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n        if slow == fast:\n            return True\n\n    return False\n\n\ndef test_has_cycle():\n    ll = LinkedList([3, 2, 0, -4])\n    ll.make_cycle(pos=1)\n    assert has_cycle(ll.head)\n\n    ll = LinkedList([1, 2])\n    ll.make_cycle(pos=0)\n    assert has_cycle(ll.head)\n\n    ll = LinkedList([1, 2, 3, 4, 5])\n    assert not has_cycle(ll.head)\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n\n#include \"include/lists.hpp\"\nusing namespace std;\n\nclass Solution {\n   public:\n    bool has_cycle(ListNode* head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while (fast &amp;&amp; fast-&gt;next) {\n            slow = slow-&gt;next;\n            fast = fast-&gt;next-&gt;next;\n\n            if (fast == slow) return true;\n        }\n        return false;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    ListNode* head = LinkedList::build({3, 2, 0, -4});\n    // create cycle\n    head = LinkedList::make_cycle(head, 1);\n    assert(solution.has_cycle(head) == true);\n    // no cycle\n    ListNode* head2 = LinkedList::build({1, 2});\n    assert(solution.has_cycle(head2) == false);\n    // no cycle\n    ListNode* head3 = LinkedList::build({1});\n    assert(solution.has_cycle(head3) == false);\n\n    return 0;\n}\n</code></pre>"},{"location":"blind-75/linked_list/#23-merge-k-sorted-lists","title":"23. Merge k Sorted Lists","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Divide And Conquer, Heap Priority Queue, Merge Sort</p> </li> </ul> Python <pre><code>\"\"\"\n-   Prerequisite: 21. Merge Two Sorted Lists\n-   Video explanation: [23. Merge K Sorted Lists - NeetCode](https://youtu.be/q5a5OiGbT6Q?si=SQ2dCvsYQ3LQctPh)\n\"\"\"\n\nimport copy\nimport heapq\nfrom typing import List, Optional\n\nfrom leetpattern.utils import ListNode, list_from_array, list_to_array\n\n\ndef merge_k_lists_divide_conquer(\n    lists: List[Optional[ListNode]],\n) -&gt; Optional[ListNode]:\n    if not lists or len(lists) == 0:\n        return None\n\n    def mergeTwo(l1, l2):\n        dummy = ListNode()\n        cur = dummy\n\n        while l1 and l2:\n            if l1.val &lt; l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n\n            cur = cur.next\n\n        cur.next = l1 if l1 else l2\n\n        return dummy.next\n\n    while len(lists) &gt; 1:\n        merged = []\n\n        for i in range(0, len(lists), 2):\n            l1 = lists[i]\n            l2 = lists[i + 1] if i + 1 &lt; len(lists) else None\n            merged.append(mergeTwo(l1, l2))\n\n        lists = merged\n\n    return lists[0]\n\n\ndef merge_k_lists_heap(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    min_heap = []  # (val, idx, node)\n\n    for idx, head in enumerate(lists):\n        if head:\n            heapq.heappush(min_heap, (head.val, idx, head))\n\n    while min_heap:\n        _, idx, node = heapq.heappop(min_heap)\n        cur.next = node\n        cur = cur.next\n\n        node = node.next\n        if node:\n            heapq.heappush(min_heap, (node.val, idx, node))\n\n    return dummy.next\n\n\ndef test_merge_k_lists() -&gt; None:\n    n1 = list_from_array([1, 4])\n    n2 = list_from_array([1, 3])\n    n3 = list_from_array([2, 6])\n    lists = [n1, n2, n3]\n    lists1 = copy.deepcopy(lists)\n    lists2 = copy.deepcopy(lists)\n    assert (list_to_array(merge_k_lists_divide_conquer(lists1))) == [\n        1,\n        1,\n        2,\n        3,\n        4,\n        6,\n    ]\n    assert (list_to_array(merge_k_lists_heap(lists2))) == [1, 1, 2, 3, 4, 6]\n</code></pre>"},{"location":"blind-75/math_geometry/","title":"\u6570\u5b66\u4e0e\u51e0\u4f55 Math Geometry","text":""},{"location":"blind-75/math_geometry/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 48. Rotate Image (Medium)</li> <li> 54. Spiral Matrix (Medium)</li> <li> 73. Set Matrix Zeroes (Medium)</li> </ul>"},{"location":"blind-75/math_geometry/#48-rotate-image","title":"48. Rotate Image","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Matrix</p> </li> </ul> Python <pre><code>from copy import deepcopy\nfrom typing import List\n\n\n# Math\ndef rotate1(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    n = len(matrix)\n\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n\n\ndef rotate2(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    n = len(matrix)\n    for i in range(n):\n        for j in range(i, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\n    for i in range(n):\n        matrix[i].reverse()\n\n\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nprint(matrix)\n# [[1, 2, 3],\n#  [4, 5, 6],\n#  [7, 8, 9]]\nmatrix1 = deepcopy(matrix)\nrotate1(matrix1)\nprint(matrix1)\n# [[7, 4, 1],\n#  [8, 5, 2],\n#  [9, 6, 3]]\nmatrix2 = deepcopy(matrix)\nrotate2(matrix2)\nprint(matrix2)\n# [[7, 4, 1],\n#  [8, 5, 2],\n#  [9, 6, 3]]\n</code></pre>"},{"location":"blind-75/math_geometry/#54-spiral-matrix","title":"54. Spiral Matrix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Matrix, Simulation</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return all elements of the matrix in spiral order.\n\"\"\"\n\nfrom typing import List\n\n\n# Array\ndef spiralOrder(matrix: List[List[int]]) -&gt; List[int]:\n    if not matrix or not matrix[0]:\n        return []\n\n    res = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n\n    while top &lt;= bottom and left &lt;= right:\n\n        for i in range(left, right + 1):\n            res.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            res.append(matrix[i][right])\n        right -= 1\n\n        if top &lt;= bottom:\n\n            for i in range(right, left - 1, -1):\n                res.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left &lt;= right:\n\n            for i in range(bottom, top - 1, -1):\n                res.append(matrix[i][left])\n            left += 1\n\n    return res\n\n\n# Math\ndef spiralOrderMath(matrix: List[List[int]]) -&gt; List[int]:\n    dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]]  # Right Down Left Up\n    m, n = len(matrix), len(matrix[0])\n    size = m * n\n    res = []\n    i, j, di = 0, -1, 0\n\n    while len(res) &lt; size:\n        dx, dy = dirs[di]\n        for _ in range(n):\n            i += dx\n            j += dy\n            res.append(matrix[i][j])\n        di = (di + 1) % 4\n        n, m = m - 1, n\n\n    return res\n\n\nprint(spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n# [1, 2, 3, 6, 9, 8, 7, 4, 5]\nprint(spiralOrderMath([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]))\n# [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]\n</code></pre>"},{"location":"blind-75/math_geometry/#73-set-matrix-zeroes","title":"73. Set Matrix Zeroes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Matrix</p> </li> </ul> Python <pre><code>from copy import deepcopy\nfrom typing import List\n\n\nclass setZeroes:\n    @staticmethod\n    def matrix(matrix: List[List[int]]) -&gt; None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        # prep\n        m, n = len(matrix), len(matrix[0])\n        rows, cols = set(), set()\n\n        # collect rows and cols\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    rows.add(i)\n                    cols.add(j)\n\n        # work on rows and cols\n        for i in rows:\n            for j in range(n):\n                matrix[i][j] = 0\n\n        for i in range(m):\n            for j in cols:\n                matrix[i][j] = 0\n\n\nif __name__ == \"__main__\":\n    matrix = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]\n    setZeroes.matrix(matrix)\n    assert matrix == [[1, 0, 1], [0, 0, 0], [1, 0, 1]]\n</code></pre>"},{"location":"blind-75/sliding_window/","title":"\u6ed1\u52a8\u7a97\u53e3 Sliding Window","text":""},{"location":"blind-75/sliding_window/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 121. Best Time to Buy and Sell Stock (Easy)</li> <li> 3. Longest Substring Without Repeating Characters (Medium)</li> <li> 424. Longest Repeating Character Replacement (Medium)</li> <li> 76. Minimum Window Substring (Hard)</li> </ul>"},{"location":"blind-75/sliding_window/#121-best-time-to-buy-and-sell-stock","title":"121. Best Time to Buy and Sell Stock","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return the maximum profit that can be achieved from buying on one day and selling on another day.\n\"\"\"\n\nfrom typing import List\n\n\n# Brute Force\ndef maxProfitBF(prices: List[int]) -&gt; int:\n    max_profit = 0\n    n = len(prices)\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_profit = max(max_profit, prices[j] - prices[i])\n\n    return max_profit\n\n\n# DP\ndef maxProfitDP(prices: List[int]) -&gt; int:\n    dp = [[0] * 2 for _ in range(len(prices))]\n    dp[0][0] = -prices[0]  # buy\n    dp[0][1] = 0  # sell\n\n    for i in range(1, len(prices)):\n        dp[i][0] = max(dp[i - 1][0], -prices[i])  # the lowest price to buy\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    max_profit = 0\n    seen_min = prices[0]\n\n    for i in range(1, len(prices)):\n        max_profit = max(max_profit, prices[i] - seen_min)\n        seen_min = min(seen_min, prices[i])\n\n    return max_profit\n\n\n# Fast Slow Pointers\ndef maxProfitFS(prices: List[int]) -&gt; int:\n    max_profit = 0\n    slow, fast = 0, 1\n\n    while fast &lt; len(prices):\n        if prices[fast] &gt; prices[slow]:\n            max_profit = max(max_profit, prices[fast] - prices[slow])\n        else:\n            slow = fast\n        fast += 1\n\n    return max_profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force|  O(n^2)|  O(1)   |\n# | DP         |  O(n)  |  O(n)   |\n# | Greedy     |  O(n)  |  O(1)   |\n# | Fast Slow  |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitBF(prices))  # 5\nprint(maxProfitDP(prices))  # 5\nprint(maxProfitGreedy(prices))  # 5\nprint(maxProfitFS(prices))  # 5\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int maxProfitMemo(vector&lt;int&gt; &amp;prices) {\n        if (prices.size() &lt;= 1) return 0;\n\n        int seen_min = prices[0];\n        int res = 0;\n\n        for (int &amp;price : prices) {\n            res = max(res, price - seen_min);\n            seen_min = min(seen_min, price);\n        }\n        return res;\n    }\n};\n\nint main() {\n    vector&lt;int&gt; prices = {7, 1, 5, 3, 6, 4};\n    Solution obj;\n    cout &lt;&lt; obj.maxProfitMemo(prices) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"blind-75/sliding_window/#3-longest-substring-without-repeating-characters","title":"3. Longest Substring Without Repeating Characters","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Classic variable sliding window problem. Use a set to keep track of the characters in the current window.\n- Return the length of the longest substring without repeating characters.\n- [Template tutorial by \u7075\u5c71\u8336\u827e\u5e9c](https://leetcode.cn/problems/longest-substring-without-repeating-characters/solutions/1959540/xia-biao-zong-suan-cuo-qing-kan-zhe-by-e-iaks)\n\"\"\"\n\nfrom collections import defaultdict\n\n\n# Sliding Window Variable Max - HashMap\ndef lengthOfLongestSubstringHash(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    left = 0\n    cnt = defaultdict(int)\n    res = 0\n\n    for right in range(n):\n        cnt[s[right]] += 1\n\n        while cnt[s[right]] &gt; 1:\n            cnt[s[left]] -= 1\n            left += 1\n\n        res = max(res, right - left + 1)\n\n    return res\n\n\n# Sliding Window Variable Max - Set\ndef lengthOfLongestSubstringSet(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    left = 0\n    res = 0\n    window = set()\n\n    for right in range(n):\n        while left &lt; right and s[right] in window:\n            window.remove(s[left])\n            left += 1\n        window.add(s[right])\n        res = max(res, right - left + 1)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    s = \"abcabcbb\"\n    assert lengthOfLongestSubstringHash(s) == 3\n    assert lengthOfLongestSubstringSet(s) == 3\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;unordered_set&gt;\nusing namespace std;\n\nint lengthOfLongestSubstring(string s) {\n    int n = s.length();\n    int res = 0;\n    int left = 0;\n    unordered_set&lt;char&gt; window;\n\n    for (int right = 0; right &lt; n; right++) {\n        char ch = s[right];\n\n        while (window.find(ch) != window.end()) {\n            window.erase(s[left]);\n            left++;\n        }\n\n        window.insert(ch);\n        res = max(res, right - left + 1);\n    }\n    return (int)res;\n}\n\nint main() {\n    string s = \"abcabcbb\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 3\n    s = \"bbbbb\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 1\n    s = \"pwwkew\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 3\n    return 0;\n}\n</code></pre>"},{"location":"blind-75/sliding_window/#424-longest-repeating-character-replacement","title":"424. Longest Repeating Character Replacement","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> Python <pre><code>from collections import defaultdict\n\n\n# Sliding Window - Variable\ndef characterReplacement(s: str, k: int) -&gt; int:\n    left = 0\n    maxCount = 0\n    counts = defaultdict(int)\n    maxLen = 0\n\n    for right in range(len(s)):\n        counts[s[right]] += 1\n        maxCount = max(maxCount, counts[s[right]])\n\n        while right - left + 1 - maxCount &gt; k:\n            counts[s[left]] -= 1\n            left += 1\n\n        maxLen = max(maxLen, right - left + 1)\n\n    return maxLen\n\n\ns = \"ABAB\"\nk = 2\nprint(characterReplacement(s, k))  # 4\n</code></pre>"},{"location":"blind-75/sliding_window/#76-minimum-window-substring","title":"76. Minimum Window Substring","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> Python <pre><code>from collections import Counter\n\n\ndef minWindow(s: str, t: str) -&gt; str:\n    if not t or not s:\n        return \"\"\n\n    counts = Counter(t)\n    required = len(counts)\n\n    left, right = 0, 0\n    formed = 0\n    window_counts = dict()\n\n    result = float(\"inf\"), None, None\n\n    while right &lt; len(s):\n        char = s[right]\n        window_counts[char] = window_counts.get(char, 0) + 1\n        if char in counts and window_counts[char] == counts[char]:\n            formed += 1\n\n        while left &lt;= right and formed == required:\n            char = s[left]\n            if right - left + 1 &lt; result[0]:\n                result = (right - left + 1, left, right)\n            window_counts[char] -= 1\n            if char in counts and window_counts[char] &lt; counts[char]:\n                formed -= 1\n            left += 1\n\n        right += 1\n\n    return \"\" if result[0] == float(\"inf\") else s[result[1] : result[2] + 1]\n\n\ns = \"ADOBECODEBANC\"\nt = \"ABC\"\nprint(minWindow(s, t))  # BANC\n</code></pre>"},{"location":"blind-75/stack/","title":"\u6808 Stack","text":""},{"location":"blind-75/stack/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 20. Valid Parentheses (Easy)</li> </ul>"},{"location":"blind-75/stack/#20-valid-parentheses","title":"20. Valid Parentheses","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack</p> </li> </ul> PythonCPP <pre><code># Stack\ndef is_valid(s: str) -&gt; bool:\n    if len(s) % 2:\n        return False\n\n    pairs = {\n        \"(\": \")\",\n        \"{\": \"}\",\n        \"[\": \"]\",\n    }\n    stack = []\n    for ch in s:\n        if ch in pairs:\n            stack.append(ch)\n        elif not stack or ch != pairs[stack.pop()]:\n            return False\n\n    return True if not stack else False\n\n\ndef test_is_valid():\n    assert is_valid(\"()[]{}\")\n    assert not is_valid(\"(]\")\n    assert not is_valid(\"([)]\")\n    assert is_valid(\"{[]}\")\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;stack&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool isValid(string s) {\n        unordered_map&lt;char, char&gt; map{{')', '('}, {'}', '{'}, {']', '['}};\n        stack&lt;char&gt; stack;\n        if (s.length() % 2 == 1) return false;\n\n        for (char&amp; ch : s) {\n            if (stack.empty() || map.find(ch) == map.end()) {\n                stack.push(ch);\n            } else {\n                if (map[ch] != stack.top()) {\n                    return false;\n                }\n                stack.pop();\n            }\n        }\n        return stack.empty();\n    }\n};\n\nint main() {\n    Solution s;\n    assert(s.isValid(\"()\") == true);\n    assert(s.isValid(\"()[]{}\") == true);\n    assert(s.isValid(\"(]\") == false);\n    assert(s.isValid(\"([)]\") == false);\n    assert(s.isValid(\"{[]}\") == true);\n    return 0;\n}\n</code></pre>"},{"location":"blind-75/trees/","title":"\u6811 Trees","text":""},{"location":"blind-75/trees/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 226. Invert Binary Tree (Easy)</li> <li> 104. Maximum Depth of Binary Tree (Easy)</li> <li> 100. Same Tree (Easy)</li> <li> 572. Subtree of Another Tree (Easy)</li> <li> 235. Lowest Common Ancestor of a Binary Search Tree (Medium)</li> <li> 102. Binary Tree Level Order Traversal (Medium)</li> <li> 98. Validate Binary Search Tree (Medium)</li> <li> 230. Kth Smallest Element in a BST (Medium)</li> <li> 105. Construct Binary Tree from Preorder and Inorder Traversal (Medium)</li> <li> 124. Binary Tree Maximum Path Sum (Hard)</li> <li> 298. Binary Tree Longest Consecutive Sequence (Medium) \ud83d\udc51</li> </ul>"},{"location":"blind-75/trees/#226-invert-binary-tree","title":"226. Invert Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef invertTreeRecursive(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    root.left, root.right = root.right, root.left\n\n    invertTreeRecursive(root.left)\n    invertTreeRecursive(root.right)\n\n    return root\n\n\n# Iterative\ndef invertTreeIterative(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    stack = [root]\n\n    while stack:\n        node = stack.pop()\n\n        node.left, node.right = node.right, node.left\n        if node.left:\n            stack.append(node.left)\n        if node.right:\n            stack.append(node.right)\n\n    return root\n\n\nroot = build([4, 2, 7, 1, 3, 6, 9])\nprint(root)\n#     __4__\n#    /     \\\n#   2       7\n#  / \\     / \\\n# 1   3   6   9\ninvertedRecursive = invertTreeRecursive(root)\nprint(invertedRecursive)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\nroot = build([4, 2, 7, 1, 3, 6, 9])\ninvertedIterative = invertTreeIterative(root)\nprint(invertedIterative)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\n</code></pre>"},{"location":"blind-75/trees/#104-maximum-depth-of-binary-tree","title":"104. Maximum Depth of Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef maxDepthRecursive(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    left = maxDepthRecursive(root.left)\n    right = maxDepthRecursive(root.right)\n\n    return 1 + max(left, right)\n\n\n# DFS\ndef maxDepthDFS(root: Optional[TreeNode]) -&gt; int:\n    res = 0\n\n    def dfs(node, cnt):\n        if node is None:\n            return\n        cnt += 1\n        nonlocal res\n        res = max(res, cnt)\n\n        dfs(node.left, cnt)\n        dfs(node.right, cnt)\n\n    dfs(root, 0)\n\n    return res\n\n\n# Iterative\ndef maxDepthIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n    res = 0\n\n    while q:\n        res += 1\n        n = len(q)\n\n        for _ in range(n):\n            node = q.popleft()\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    root = [1, 2, 2, 3, 4, None, None, None, None, 5]\n    root = build(root)\n    print(root)\n    #     ____1\n    #    /     \\\n    #   2__     2\n    #  /   \\\n    # 3     4\n    #      /\n    #     5\n    assert maxDepthRecursive(root) == 4\n    assert maxDepthDFS(root) == 4\n    assert maxDepthIterative(root) == 4\n</code></pre>"},{"location":"blind-75/trees/#100-same-tree","title":"100. Same Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# 1. Recursive\ndef isSameTreeRecursive(p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:\n    if not p and not q:\n        return True\n    elif not p or not q:\n        return False\n    elif p.val != q.val:\n        return False\n\n    return isSameTreeRecursive(p.left, q.left) and isSameTreeRecursive(p.right, q.right)\n\n\n# 2. Iterative with queue\ndef isSameTreeIterativeQueue(p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:\n    queue = deque([(p, q)])\n\n    while queue:\n        p, q = queue.popleft()\n\n        if not p and not q:\n            continue\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n\n        queue.append((p.left, q.left))\n        queue.append((p.right, q.right))\n\n    return True\n\n\n# 3. Iterative with stack\ndef isSameTreeIterativeStack(p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:\n    stack = [(p, q)]\n\n    while stack:\n        n1, n2 = stack.pop()\n\n        if not n1 and not n2:\n            continue\n        if not n1 or not n2:\n            return False\n        if n1.val != n2.val:\n            return False\n\n        stack.append((n1.left, n2.left))\n        stack.append((n1.right, n2.right))\n\n    return True\n\n\nif __name__ == \"__main__\":\n    p1 = build([1, 2, 3])\n    q1 = build([1, 2, 3])\n    p2 = build([1, 2])\n    q2 = build([1, None, 2])\n\n    assert isSameTreeRecursive(p1, q1) is True\n    assert isSameTreeRecursive(p2, q2) is False\n    assert isSameTreeIterativeQueue(p1, q1) is True\n    assert isSameTreeIterativeQueue(p2, q2) is False\n    assert isSameTreeIterativeStack(p1, q1) is True\n    assert isSameTreeIterativeStack(p2, q2) is False\n</code></pre>"},{"location":"blind-75/trees/#572-subtree-of-another-tree","title":"572. Subtree of Another Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, String Matching, Binary Tree, Hash Function</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# DFS - Tree\ndef isSubtree(root: Optional[TreeNode], subRoot: Optional[TreeNode]) -&gt; bool:\n    def isSameTree(p, q):\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n\n        return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)\n\n    if not root:\n        return False\n\n    return (\n        isSameTree(root, subRoot)\n        or isSubtree(root.left, subRoot)\n        or isSubtree(root.right, subRoot)\n    )\n\n\n# |------------|---------|----------|\n# | Approach   | Time    | Space    |\n# |------------|---------|----------|\n# | DFS        | O(n * m)| O(n)     |\n# |------------|---------|----------|\n\n\nroot = build([3, 4, 5, 1, 2, None, None, None, None, 0])\nsubRoot = build([4, 1, 2])\nprint(root)\n#     ____3\n#    /     \\\n#   4__     5\n#  /   \\\n# 1     2\n#      /\n#     0\nprint(subRoot)\n#   4\n#  / \\\n# 1   2\nprint(isSubtree(root, subRoot))  # False\n</code></pre>"},{"location":"blind-75/trees/#235-lowest-common-ancestor-of-a-binary-search-tree","title":"235. Lowest Common Ancestor of a Binary Search Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Search Tree, Binary Tree</p> </li> </ul> Python <pre><code>from binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef lowestCommonAncestor(root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\") -&gt; \"TreeNode\":\n    while root:\n        if root.val &gt; p.val and root.val &gt; q.val:\n            root = root.left\n        elif root.val &lt; p.val and root.val &lt; q.val:\n            root = root.right\n        else:\n            return root\n\n\nroot = [6, 2, 8, 0, 4, 7, 9, None, None, 3, 5]\nroot = build(root)\np = root.left\nq = root.right\nprint(root)\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\nprint(lowestCommonAncestor(root, p, q))\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\n</code></pre>"},{"location":"blind-75/trees/#102-binary-tree-level-order-traversal","title":"102. Binary Tree Level Order Traversal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef levelOrder(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        level = []\n        size = len(q)\n\n        for _ in range(size):\n            cur = q.popleft()\n            level.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(level)\n\n    return res\n\n\ntree = build([3, 9, 20, None, None, 15, 7])\nprint(tree)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(levelOrder(tree))  # [[3], [9, 20], [15, 7]]\n</code></pre>"},{"location":"blind-75/trees/#98-validate-binary-search-tree","title":"98. Validate Binary Search Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Search Tree, Binary Tree</p> </li> </ul> PythonCPP <pre><code>from itertools import pairwise\nfrom math import inf\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef isValidBST1(root: Optional[TreeNode]) -&gt; bool:\n    inorder = []  # inorder traversal\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    for a, b in pairwise(inorder):\n        if a &gt;= b:\n            return False\n\n    return True\n\n\ndef isValidBST2(root: Optional[TreeNode]) -&gt; bool:\n    if not root:\n        return True\n    pre = -inf\n\n    def dfs(node):\n        if not node:\n            return True\n        if not dfs(node.left):\n            return False\n\n        nonlocal pre\n        if node.val &lt;= pre:\n            return False\n        pre = node.val\n\n        return dfs(node.right)\n\n    return dfs(root)\n\n\nif __name__ == \"__main__\":\n    root = [5, 1, 4, None, None, 3, 6]\n    root = build(root)\n    print(root)\n    #   5__\n    #  /   \\\n    # 1     4\n    #      / \\\n    #     3   6\n    assert not isValidBST1(root)  # [1, 5, 3, 4, 6]\n    assert not isValidBST2(root)  # [1, 5, 3, 4, 6]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   private:\n    vector&lt;int&gt; inorder;\n    bool check(vector&lt;int&gt; inorder) {\n        int n = inorder.size();\n        if (n &lt;= 1) return true;\n        for (int i = 1; i &lt; n; i++) {\n            if (inorder[i] &lt;= inorder[i - 1]) return false;\n        }\n        return true;\n    }\n\n   public:\n    bool isValidBST(TreeNode *root) {\n        auto dfs = [&amp;](auto &amp;&amp;self, TreeNode *node) -&gt; void {\n            if (!node) return;\n\n            self(self, node-&gt;left);\n            inorder.push_back(node-&gt;val);\n            self(self, node-&gt;right);\n        };\n\n        dfs(dfs, root);\n\n        return check(inorder);\n    }\n};\n\nint main() {\n    Solution s;\n    TreeNode *root = new TreeNode(2);\n    root-&gt;left = new TreeNode(1);\n    root-&gt;right = new TreeNode(3);\n    assert(s.isValidBST(root) == true);\n\n    root = new TreeNode(5);\n    root-&gt;left = new TreeNode(1);\n    root-&gt;right = new TreeNode(4);\n    root-&gt;right-&gt;left = new TreeNode(3);\n    root-&gt;right-&gt;right = new TreeNode(6);\n    assert(s.isValidBST(root) == false);\n\n    root = new TreeNode(5);\n    root-&gt;left = new TreeNode(4);\n    root-&gt;right = new TreeNode(6);\n    root-&gt;right-&gt;left = new TreeNode(3);\n    root-&gt;right-&gt;right = new TreeNode(7);\n    assert(s.isValidBST(root) == false);\n\n    return 0;\n}\n</code></pre>"},{"location":"blind-75/trees/#230-kth-smallest-element-in-a-bst","title":"230. Kth Smallest Element in a BST","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Search Tree, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef kthSmallestRecursive(root: Optional[TreeNode], k: int) -&gt; int:\n    inorder = []\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n    return inorder[k - 1]\n\n\n# Iteratve\ndef kthSmallestIteratve(root: Optional[TreeNode], k: int) -&gt; int:\n    stack = []\n    while True:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        k -= 1\n        if not k:\n            return root.val\n        root = root.right\n\n\nif __name__ == \"__main__\":\n    root = build([3, 1, 4, None, 2])\n    k = 1\n    assert kthSmallestRecursive(root, k) == 1\n    assert kthSmallestIteratve(root, k) == 1\n</code></pre>"},{"location":"blind-75/trees/#105-construct-binary-tree-from-preorder-and-inorder-traversal","title":"105. Construct Binary Tree from Preorder and Inorder Traversal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Divide And Conquer, Tree, Binary Tree</p> </li> </ul> PythonCPP <pre><code>from typing import List, Optional\n\nfrom helper import TreeNode\n\n\ndef buildTree(preorder: List[int], inorder: List[int]) -&gt; Optional[TreeNode]:\n    \"\"\"\n    preorder  root left right  1  2  3\n    inorder   left root right  4  5  6\n    \"\"\"\n    if len(preorder) == 0:\n        return None\n\n    root_val = preorder[0]  # 1\n    root = TreeNode(root_val)\n\n    separator_idx = inorder.index(root_val)  # 5\n\n    left_inorder = inorder[:separator_idx]  # 4\n    right_inorder = inorder[separator_idx + 1 :]  # 6\n\n    left_preorder = preorder[1 : 1 + len(left_inorder)]  # 2\n    right_preorder = preorder[1 + len(left_inorder) :]  # 3\n\n    root.left = buildTree(left_preorder, left_inorder)\n    root.right = buildTree(right_preorder, right_inorder)\n\n    return root\n\n\npreorder = [3, 9, 20, 15, 7]\ninorder = [9, 3, 15, 20, 7]\nroot = buildTree(preorder, inorder)\nprint(root)\n#     3\n#    / \\\n#   9  20\n#     /  \\\n#    15   7\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   public:\n    vector&lt;int&gt; preorder;\n    unordered_map&lt;int, int&gt; inorderMap;\n\n    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {\n        this-&gt;preorder = preorder;\n        for (size_t i = 0; i &lt; inorder.size(); i++) {\n            inorderMap[inorder[i]] = i;\n        }\n        return buildSubtree(0, 0, inorder.size() - 1);\n    }\n\n   private:\n    TreeNode* buildSubtree(int rootIndex, int left, int right) {\n        if (left &gt; right) return nullptr;\n\n        TreeNode* root = new TreeNode(preorder[rootIndex]);\n        int inorderIndex = inorderMap[preorder[rootIndex]];\n\n        root-&gt;left = buildSubtree(rootIndex + 1, left, inorderIndex - 1);\n        root-&gt;right = buildSubtree(rootIndex + (inorderIndex - left + 1),\n                                   inorderIndex + 1, right);\n\n        return root;\n    }\n};\n\nint main() {\n    vector&lt;int&gt; preorder = {3, 9, 20, 15, 7};\n    vector&lt;int&gt; inorder = {9, 3, 15, 20, 7};\n    Solution solution;\n    TreeNode* root = solution.buildTree(preorder, inorder);\n    cout &lt;&lt; root-&gt;val &lt;&lt; endl;                // 3\n    cout &lt;&lt; root-&gt;left-&gt;val &lt;&lt; endl;          // 9\n    cout &lt;&lt; root-&gt;right-&gt;val &lt;&lt; endl;         // 20\n    cout &lt;&lt; root-&gt;right-&gt;left-&gt;val &lt;&lt; endl;   // 15\n    cout &lt;&lt; root-&gt;right-&gt;right-&gt;val &lt;&lt; endl;  // 7\n    return 0;\n}\n</code></pre>"},{"location":"blind-75/trees/#124-binary-tree-maximum-path-sum","title":"124. Binary Tree Maximum Path Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Tree, Depth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef maxPathSum(root: Optional[TreeNode]) -&gt; int:\n    res = float(\"-inf\")\n\n    def dfs(node):\n        if not node:\n            return 0\n\n        leftMax = max(dfs(node.left), 0)\n        rightMax = max(dfs(node.right), 0)\n\n        cur = node.val + leftMax + rightMax\n        nonlocal res\n        res = max(res, cur)\n\n        return node.val + max(leftMax, rightMax)\n\n    dfs(root)\n\n    return res\n\n\nroot = build([-10, 9, 20, None, None, 15, 7])\nprint(root)\n#   -10___\n#  /      \\\n# 9       _20\n#        /   \\\n#       15    7\nprint(maxPathSum(root))  # 42\n</code></pre>"},{"location":"blind-75/trees/#298-binary-tree-longest-consecutive-sequence","title":"298. Binary Tree Longest Consecutive Sequence \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Binary Tree\ndef longestConsecutive(root: Optional[TreeNode]) -&gt; int:\n    res = 0\n\n    def dfs(node):\n        if not node:\n            return 0\n\n        left, right = dfs(node.left), dfs(node.right)\n        cur = 1\n        if node.left and node.left.val == (node.val + 1):\n            cur = max(cur, left + 1)\n        if node.right and node.right.val == (node.val + 1):\n            cur = max(cur, right + 1)\n\n        nonlocal res\n        res = max(res, cur)\n        return cur\n\n    dfs(root)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    root = build([1, 3, 2, 4, None, None, None, 5])\n    print(root)\n    #       1\n    #      / \\\n    #     3   2\n    #    /\n    #   4\n    #  /\n    # 5\n    print(longestConsecutive(root))  # 3\n</code></pre>"},{"location":"blind-75/tries/","title":"\u5b57\u5178\u6811 Tries","text":""},{"location":"blind-75/tries/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 208. Implement Trie (Prefix Tree) (Medium)</li> <li> 212. Word Search II (Hard)</li> <li> 211. Design Add and Search Words Data Structure (Medium)</li> </ul>"},{"location":"blind-75/tries/#208-implement-trie-prefix-tree","title":"208. Implement Trie (Prefix Tree)","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Design, Trie</p> </li> </ul> Python <pre><code>\"\"\"\n### Trie\n\n- A trie is a tree-like data structure whose nodes store the letters of an alphabet.\n\"\"\"\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.endOfWord = None\n\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.endOfWord = True\n\n    def search(self, word: str) -&gt; bool:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return node.endOfWord\n\n    def startsWith(self, prefix: str) -&gt; bool:\n        node = self.root\n\n        for c in prefix:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return True\n\n\n# Your Trie object will be instantiated and called as such:\nobj = Trie()\nobj.insert(\"apple\")\nprint(obj.search(\"word\"))  # False\nprint(obj.startsWith(\"app\"))  # True\n</code></pre>"},{"location":"blind-75/tries/#212-word-search-ii","title":"212. Word Search II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Backtracking, Trie, Matrix</p> </li> </ul> Python <pre><code>from typing import List\n\nfrom leetpattern.utils import Trie\n\n\n# Backtracking + Trie\ndef findWords(board: List[List[str]], words: List[str]) -&gt; List[str]:\n    trie = Trie()\n    for word in words:\n        trie.add_word(word)\n\n    m, n = len(board), len(board[0])\n    result, visit = set(), set()\n\n    def dfs(r, c, node, word):\n        if (\n            r &lt; 0\n            or r &gt;= m\n            or c &lt; 0\n            or c &gt;= n\n            or (r, c) in visit\n            or board[r][c] not in node.children\n        ):\n            return None\n\n        visit.add((r, c))\n\n        node = node.children[board[r][c]]\n        word += board[r][c]\n        if node.is_word:\n            result.add(word)\n\n        dfs(r - 1, c, node, word)\n        dfs(r + 1, c, node, word)\n        dfs(r, c - 1, node, word)\n        dfs(r, c + 1, node, word)\n\n        visit.remove((r, c))\n\n    for r in range(m):\n        for c in range(n):\n            dfs(r, c, trie.root, \"\")\n\n    return list(result)\n\n\ndef test_find_words():\n    board = [\n        [\"o\", \"a\", \"a\", \"n\"],\n        [\"e\", \"t\", \"a\", \"e\"],\n        [\"i\", \"h\", \"k\", \"r\"],\n        [\"i\", \"f\", \"l\", \"v\"],\n    ]\n    words = [\"oath\", \"pea\", \"eat\", \"rain\"]\n    result = findWords(board, words)\n    assert sorted(result) == [\"eat\", \"oath\"]\n</code></pre>"},{"location":"blind-75/tries/#211-design-add-and-search-words-data-structure","title":"211. Design Add and Search Words Data Structure","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Depth First Search, Design, Trie</p> </li> </ul> Python <pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.word = False\n\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.word = True\n\n    def search(self, word: str) -&gt; bool:\n\n        def dfs(j, root):\n            node = root\n\n            for i in range(j, len(word)):\n                c = word[i]\n\n                if c == \".\":\n                    for child in node.children.values():\n                        if dfs(i + 1, child):\n                            return True\n                    return False\n                else:\n                    if c not in node.children:\n                        return False\n                    node = node.children[c]\n            return node.word\n\n        return dfs(0, self.root)\n\n\n# Your WordDictionary object will be instantiated and called as such:\nobj = WordDictionary()\nobj.addWord(\"word\")\nprint(obj.search(\"word\"))\nprint(obj.search(\"w.rd\"))\n</code></pre>"},{"location":"blind-75/two_pointers/","title":"\u53cc\u6307\u9488 Two Pointers","text":""},{"location":"blind-75/two_pointers/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 125. Valid Palindrome (Easy)</li> <li> 15. 3Sum (Medium)</li> <li> 11. Container With Most Water (Medium)</li> </ul>"},{"location":"blind-75/two_pointers/#125-valid-palindrome","title":"125. Valid Palindrome","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String</p> </li> </ul> Python <pre><code># List Comprehension\ndef isPalindrome(s: str) -&gt; bool:\n    s = [char.lower() for char in s if char.isalnum()]\n    return s == s[::-1]\n\n\n# Left Right Pointers\ndef isPalindromeLR(s: str) -&gt; bool:\n    left, right = 0, len(s) - 1\n\n    while left &lt; right:\n        while left &lt; right and not s[left].isalnum():\n            left += 1\n        while left &lt; right and not s[right].isalnum():\n            right -= 1\n\n        if s[left].lower() != s[right].lower():\n            return False\n\n        left += 1\n        right -= 1\n\n    return True\n\n\ns = \"A man, a plan, a canal: Panama\"\nprint(isPalindrome(s))  # True\nprint(isPalindromeLR(s))  # True\n</code></pre>"},{"location":"blind-75/two_pointers/#15-3sum","title":"15. 3Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Sorting</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef threeSum(nums: List[int]) -&gt; List[List[int]]:\n    nums.sort()\n    res = []\n    n = len(nums)\n\n    for i in range(n - 2):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        left, right = i + 1, n - 1\n\n        while left &lt; right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total &gt; 0:\n                right -= 1\n            elif total &lt; 0:\n                left += 1\n            else:\n                res.append([nums[i], nums[left], nums[right]])\n\n                while left &lt; right and nums[left] == nums[left + 1]:\n                    left += 1\n\n                while left &lt; right and nums[right] == nums[right - 1]:\n                    right -= 1\n\n                left += 1\n                right -= 1\n\n    return res\n\n\nnums = [-1, 0, 1, 2, -1, -4]\nassert threeSum(nums) == [[-1, -1, 2], [-1, 0, 1]]\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {\n    sort(nums.begin(), nums.end());\n    vector&lt;vector&lt;int&gt;&gt; res;\n    int n = nums.size();\n\n    for (int i = 0; i &lt; n - 2; i++) {\n        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) {\n            continue;\n        }\n\n        int left = i + 1, right = n - 1;\n\n        while (left &lt; right) {\n            int total = nums[i] + nums[left] + nums[right];\n\n            if (total &gt; 0)\n                right--;\n            else if (total &lt; 0)\n                left++;\n            else {\n                res.push_back({nums[i], nums[left], nums[right]});\n                while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++;\n                while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--;\n                left++;\n                right--;\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {-1, 0, 1, 2, -1, -4};\n    vector&lt;vector&lt;int&gt;&gt; res = threeSum(nums);\n    for (auto&amp; v : res) {\n        for (int i : v) {\n            cout &lt;&lt; i &lt;&lt; \" \";\n        }\n        cout &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"blind-75/two_pointers/#11-container-with-most-water","title":"11. Container With Most Water","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Greedy</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return the maximum area of water that can be trapped between the vertical lines.\n\n![11](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)\n\"\"\"\n\nfrom typing import List\n\n\n# Brute Force\ndef maxAreaBF(height: List[int]) -&gt; int:\n    max_area = 0\n\n    for i in range(len(height)):\n        for j in range(i + 1, len(height)):\n            h = min(height[i], height[j])\n            w = j - i\n            max_area = max(max_area, h * w)\n\n    return max_area\n\n\n# Left Right Pointers\ndef maxAreaLR(height: List[int]) -&gt; int:\n    left, right = 0, len(height) - 1\n    res = 0\n\n    while left &lt; right:\n        h = min(height[left], height[right])\n        w = right - left\n        res = max(res, h * w)\n\n        if height[left] &lt; height[right]:\n            left += 1\n        else:\n            right -= 1\n\n    return res\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force| O(n^2) |  O(1)   |\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nheight = [1, 8, 6, 2, 5, 4, 8, 3, 7]\nprint(maxAreaBF(height))  # 49\nprint(maxAreaLR(height))  # 49\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint maxArea(vector&lt;int&gt;&amp; height) {\n    int left = 0, right = height.size() - 1;\n    int res = 0;\n\n    while (left &lt; right) {\n        int h = min(height[left], height[right]);\n        int w = right - left;\n        res = max(res, h * w);\n\n        if (height[left] &lt; height[right])\n            left++;\n        else\n            right--;\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; height = {1, 8, 6, 2, 5, 4, 8, 3, 7};\n    cout &lt;&lt; maxArea(height) &lt;&lt; endl;  // 49\n    return 0;\n}\n</code></pre>"},{"location":"graph-theory/bfs/","title":"BFS","text":""},{"location":"graph-theory/bfs/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1926. Nearest Exit from Entrance in Maze (Medium)</li> <li> 934. Shortest Bridge (Medium)</li> <li> 433. Minimum Genetic Mutation (Medium)</li> <li> 127. Word Ladder (Hard)</li> <li> 1306. Jump Game III (Medium)</li> <li> 542. 01 Matrix (Medium)</li> <li> 1091. Shortest Path in Binary Matrix (Medium)</li> <li> 863. All Nodes Distance K in Binary Tree (Medium)</li> <li> 864. Shortest Path to Get All Keys (Hard)</li> </ul>"},{"location":"graph-theory/bfs/#1926-nearest-exit-from-entrance-in-maze","title":"1926. Nearest Exit from Entrance in Maze","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Breadth First Search, Matrix</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef nearestExit(maze: List[List[str]], entrance: List[int]) -&gt; int:\n    m, n = len(maze), len(maze[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque([(entrance[0], entrance[1], 0)])\n    maze[entrance[0]][entrance[1]] = \"+\"\n\n    while q:\n        r, c, steps = q.popleft()\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and maze[nr][nc] == \".\":\n                if nr in [0, m - 1] or nc in [0, n - 1]:\n                    return steps + 1\n                q.append((nr, nc, steps + 1))\n                maze[nr][nc] = \"+\"\n\n    return -1\n\n\nmaze = [[\"+\", \"+\", \".\", \"+\"], [\".\", \".\", \".\", \"+\"], [\"+\", \"+\", \"+\", \".\"]]\nentrance = [1, 2]\nprint(nearestExit(maze, entrance))  # 1\n</code></pre>"},{"location":"graph-theory/bfs/#934-shortest-bridge","title":"934. Shortest Bridge","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Matrix</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS + DFS; Coloring\ndef shortestBridge(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(r, c, queue):\n        grid[r][c] = 2\n        queue.append((r, c))\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if nr in range(n) and nc in range(n) and grid[nr][nc] == 1:\n                dfs(nr, nc, queue)\n\n    q = deque()\n    found = False\n    for r in range(n):\n        if found:\n            break\n        for c in range(n):\n            if grid[r][c] == 1:\n                dfs(r, c, q)\n                found = True\n                break\n\n    steps = 0\n    while q:\n        m = len(q)\n        for _ in range(m):\n            r, c = q.popleft()\n            for dr, dc in directions:\n                nr, nc = r + dr, c + dc\n                if nr in range(n) and nc in range(n):\n                    if grid[nr][nc] == 1:\n                        return steps\n                    elif grid[nr][nc] == 0:\n                        grid[nr][nc] = 2\n                        q.append((nr, nc))\n        steps += 1\n\n    return -1\n\n\ngrid = [\n    [1, 1, 1, 1, 1],\n    [1, 0, 0, 0, 1],\n    [1, 0, 1, 0, 1],\n    [1, 0, 0, 0, 1],\n    [1, 1, 1, 1, 1],\n]\nprint(shortestBridge(grid))  # 1\n</code></pre>"},{"location":"graph-theory/bfs/#433-minimum-genetic-mutation","title":"433. Minimum Genetic Mutation","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Breadth First Search</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef minMutation(startGene: str, endGene: str, bank: List[str]) -&gt; int:\n    if endGene not in bank:\n        return -1\n\n    bank = set(bank)\n    q = deque([(startGene, 0)])\n\n    while q:\n        gene, step = q.popleft()\n        if gene == endGene:\n            return step\n\n        for i in range(8):\n            for c in \"ACGT\":\n                if gene[i] == c:\n                    continue\n                newGene = gene[:i] + c + gene[i + 1 :]\n                if newGene in bank:\n                    bank.remove(newGene)\n                    q.append((newGene, step + 1))\n    return -1\n\n\nstartGene = \"AACCGGTT\"\nendGene = \"AAACGGTA\"\nbank = [\"AACCGGTA\", \"AACCGCTA\", \"AAACGGTA\"]\nprint(minMutation(startGene, endGene, bank))  # 2\n</code></pre>"},{"location":"graph-theory/bfs/#127-word-ladder","title":"127. Word Ladder","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Breadth First Search</p> </li> </ul> Python <pre><code>\"\"\"\n-   The most classic BFS problem.\n-   Return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\n-   Approach: BFS\n-   Time Complexity: O(n * m^2)\n-   Space Complexity: O(n * m)\n\"\"\"\n\nfrom collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef ladderLength(beginWord: str, endWord: str, wordList: List[str]) -&gt; int:\n    if endWord not in wordList:\n        return 0\n\n    n = len(beginWord)\n    graph = defaultdict(list)  # pattern: words\n    wordList.append(beginWord)\n\n    for word in wordList:\n        for i in range(n):\n            pattern = word[:i] + \"*\" + word[i + 1 :]\n            graph[pattern].append(word)\n\n    visited = set([beginWord])\n    q = deque([beginWord])\n    res = 1\n\n    while q:\n        size = len(q)\n        for _ in range(size):\n            word = q.popleft()\n            if word == endWord:\n                return res\n\n            for i in range(n):\n                pattern = word[:i] + \"*\" + word[i + 1 :]\n                for neighbor in graph[pattern]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        q.append(neighbor)\n        res += 1\n\n    return 0\n\n\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]\nprint(ladderLength(beginWord, endWord, wordList))  # 5\n</code></pre>"},{"location":"graph-theory/bfs/#1306-jump-game-iii","title":"1306. Jump Game III","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef canReach(arr: List[int], start: int) -&gt; bool:\n    n = len(arr)\n    visited = [False for _ in range(n)]\n    q = deque([start])\n\n    while q:\n        i = q.popleft()\n\n        if arr[i] == 0:\n            return True\n\n        visited[i] = True\n\n        for j in [i - arr[i], i + arr[i]]:\n            if j in range(n) and not visited[j]:\n                q.append(j)\n\n    return False\n\n\narr = [4, 2, 3, 0, 3, 1, 2]\nstart = 5\nprint(canReach(arr, start))  # True\n</code></pre>"},{"location":"graph-theory/bfs/#542-01-matrix","title":"542. 01 Matrix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Breadth First Search, Matrix</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef updateMatrix(mat: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(mat), len(mat[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    q = deque()\n\n    for i in range(m):\n        for j in range(n):\n            if mat[i][j] == 0:\n                dist[i][j] = 0\n                q.append((i, j))\n\n    while q:\n        r, c = q.popleft()\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and dist[nr][nc] &gt; dist[r][c] + 1:\n                dist[nr][nc] = dist[r][c] + 1\n                q.append((nr, nc))\n\n    return dist\n\n\nmat = [[0, 0, 0], [0, 1, 0], [1, 1, 1]]\nprint(updateMatrix(mat))\n# [[0, 0, 0], [0, 1, 0], [1, 2, 1]]\n</code></pre>"},{"location":"graph-theory/bfs/#1091-shortest-path-in-binary-matrix","title":"1091. Shortest Path in Binary Matrix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Breadth First Search, Matrix</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    if grid[0][0] == 1 or grid[n - 1][n - 1] == 1:\n        return -1\n    if n == 1:\n        return 1\n\n    directions = [\n        (0, 1),\n        (1, 0),\n        (0, -1),\n        (-1, 0),\n        (1, 1),\n        (-1, -1),\n        (1, -1),\n        (-1, 1),\n    ]\n    q = deque([(0, 0, 1)])  # (row, column, distance)\n    grid[0][0] = 1\n\n    while q:\n        r, c, d = q.popleft()\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 &lt;= nr &lt; n and 0 &lt;= nc &lt; n and grid[nr][nc] == 0:\n                if nr == nc == n - 1:\n                    return d + 1\n                q.append((nr, nc, d + 1))\n                grid[nr][nc] = 1\n\n    return -1\n\n\ngrid = [[0, 0, 0], [1, 1, 0], [1, 1, 0]]\nprint(shortestPathBinaryMatrix(grid))  # 4\n</code></pre>"},{"location":"graph-theory/bfs/#863-all-nodes-distance-k-in-binary-tree","title":"863. All Nodes Distance K in Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BFS\ndef distanceK(root: TreeNode, target: TreeNode, k: int) -&gt; List[int]:\n    parent = dict()\n\n    def dfs(node, par=None):\n        if node:\n            parent[node] = par\n            dfs(node.left, node)\n            dfs(node.right, node)\n\n    dfs(root)\n\n    q = deque([(target, 0)])\n    seen = set([target])\n\n    while q:\n        node, dist = q.popleft()\n\n        if dist == k:\n            return [node.val] + [node.val for node, _ in q]\n\n        for nei in (node.left, node.right, parent[node]):\n            if nei and nei not in seen:\n                seen.add(nei)\n                q.append((nei, dist + 1))\n\n    return []\n\n\nroot = build([3, 5, 1, 6, 2, 0, 8, None, None, 7, 4])\nprint(root)\n#     ______3__\n#    /         \\\n#   5__         1\n#  /   \\       / \\\n# 6     2     0   8\n#      / \\\n#     7   4\ntarget = root.left\nk = 2\nprint(distanceK(root, target, k))  # [7, 4, 1]\n</code></pre>"},{"location":"graph-theory/bfs/#864-shortest-path-to-get-all-keys","title":"864. Shortest Path to Get All Keys","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation, Breadth First Search, Matrix</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef shortestPathAllKeys(grid: List[str]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    q = deque()\n    visited = set()\n    total = 0\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"@\":\n                q.append((r, c, 0, 0))\n                visited.add((r, c, 0))\n            if grid[r][c].islower():\n                total += 1\n\n    while q:\n        r, c, keys, steps = q.popleft()\n\n        if keys == (1 &lt;&lt; total) - 1:\n            return steps\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n:\n                cell = grid[nr][nc]\n\n                if cell == \"#\":\n                    continue\n\n                new_keys = keys\n                if cell.islower():\n                    new_keys |= 1 &lt;&lt; (ord(cell) - ord(\"a\"))\n\n                if cell.isupper() and not (keys &amp; (1 &lt;&lt; (ord(cell) - ord(\"A\")))):\n                    continue\n\n                if (nr, nc, new_keys) not in visited:\n                    visited.add((nr, nc, new_keys))\n                    q.append((nr, nc, new_keys, steps + 1))\n\n    return -1\n\n\ngrid = [\"@.a..\", \"###.#\", \"b.A.B\"]\nprint(shortestPathAllKeys(grid))  # 8\n</code></pre>"},{"location":"graph-theory/dijkstra%27s/","title":"Dijkstra's","text":""},{"location":"graph-theory/dijkstra%27s/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 787. Cheapest Flights Within K Stops (Medium)</li> <li> 1514. Path with Maximum Probability (Medium)</li> <li> 505. The Maze II (Medium) \ud83d\udc51</li> <li> 499. The Maze III (Hard) \ud83d\udc51</li> </ul>"},{"location":"graph-theory/dijkstra%27s/#787-cheapest-flights-within-k-stops","title":"787. Cheapest Flights Within K Stops","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Depth First Search, Breadth First Search, Graph, Heap Priority Queue, Shortest Path</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return the cheapest price from `src` to `dst` with at most `K` stops.\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/5eIK3zUdYmE?si=aBR0VbHXTgNuVlGz\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen&gt;&lt;/iframe&gt;\n\"\"\"\n\nimport heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Bellman-Ford\ndef findCheapestPriceBF(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    prices = [float(\"inf\") for _ in range(n)]\n    prices[src] = 0\n\n    for _ in range(k + 1):\n        temp = prices[:]\n        for u, v, w in flights:\n            temp[v] = min(temp[v], prices[u] + w)\n        prices = temp\n\n    return prices[dst] if prices[dst] != float(\"inf\") else -1\n\n\n# Dijkstra\ndef findCheapestPriceDijkstra(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in flights:\n        graph[u].append((v, w))\n\n    heap = [(0, src, 0)]  # (price, city, stops)\n    visited = defaultdict(int)  # {city: stops}\n\n    while heap:\n        price, city, stops = heapq.heappop(heap)\n\n        if city == dst:\n            return price\n\n        if stops &gt; k:\n            continue\n\n        if city in visited and visited[city] &lt;= stops:\n            continue\n\n        visited[city] = stops\n\n        for neighbor, cost in graph[city]:\n            heapq.heappush(heap, (price + cost, neighbor, stops + 1))\n\n    return -1\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |Bellman-Ford|    O(k * E)      |  O(n)   |\n# | Dijkstra   | O(E * log(V))    |  O(n)   |\n# |------------|------------------|---------|\n\n\nn = 4\nflights = [[0, 1, 100], [1, 2, 100], [2, 0, 100], [1, 3, 600], [2, 3, 200]]\nsrc = 0\ndst = 3\nk = 1\nprint(findCheapestPriceBF(n, flights, src, dst, k))  # 700\nprint(findCheapestPriceDijkstra(n, flights, src, dst, k))  # 700\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;climits&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass FindCheapestPrice {\n   public:\n    int bellman_ford(int n, vector&lt;vector&lt;int&gt;&gt;&amp; flights, int src, int dst,\n                     int k) {\n        vector&lt;int&gt; dist(n, INT_MAX);\n        dist[src] = 0;\n\n        for (int i = 0; i &lt;= k; ++i) {\n            vector&lt;int&gt; temp(dist);\n            for (auto&amp; flight : flights) {\n                int u = flight[0], v = flight[1], w = flight[2];\n                if (dist[u] != INT_MAX &amp;&amp; dist[u] + w &lt; temp[v]) {\n                    temp[v] = dist[u] + w;\n                }\n            }\n            dist = temp;\n        }\n        return dist[dst] == INT_MAX ? -1 : dist[dst];\n    }\n\n    int dijkstra(int n, vector&lt;vector&lt;int&gt;&gt;&amp; flights, int src, int dst, int k) {\n        vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; graph(n);\n        for (auto&amp; flight : flights) {\n            graph[flight[0]].push_back({flight[1], flight[2]});\n        }\n        priority_queue&lt;array&lt;int, 3&gt;, vector&lt;array&lt;int, 3&gt;&gt;,\n                       greater&lt;array&lt;int, 3&gt;&gt;&gt;\n            min_heap;\n        min_heap.push({0, src, k + 1});\n\n        while (!min_heap.empty()) {\n            auto [cost, u, stops] = min_heap.top();\n            min_heap.pop();\n            if (u == dst) {\n                return cost;\n            }\n            if (stops &gt; 0) {\n                for (auto&amp; [v, w] : graph[u]) {\n                    min_heap.push({cost + w, v, stops - 1});\n                }\n            }\n        }\n\n        return -1;\n    }\n};\n\nint main() {\n    FindCheapestPrice solution;\n    int n = 4;\n    vector&lt;vector&lt;int&gt;&gt; flights = {\n        {0, 1, 100}, {1, 2, 100}, {2, 0, 100}, {1, 3, 600}, {2, 3, 200}};\n    int src = 0, dst = 3, k = 1;\n    assert(solution.bellman_ford(n, flights, src, dst, k) == 700);\n    assert(solution.dijkstra(n, flights, src, dst, k) == 700);\n\n    return 0;\n}\n</code></pre>"},{"location":"graph-theory/dijkstra%27s/#1514-path-with-maximum-probability","title":"1514. Path with Maximum Probability","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Graph, Heap Priority Queue, Shortest Path</p> </li> </ul> Python <pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Dijkstra - Dict\ndef maxProbability1(\n    n: int,\n    edges: List[List[int]],\n    succProb: List[float],\n    start_node: int,\n    end_node: int,\n) -&gt; float:\n    graph = defaultdict(list)\n    for i, (u, v) in enumerate(edges):\n        graph[u].append((v, succProb[i]))\n        graph[v].append((u, succProb[i]))\n\n    heap = [(-1, start_node)]\n    max_prob = {i: 0.0 for i in range(n)}\n    max_prob[start_node] = 1.0\n\n    while heap:\n        p1, n1 = heapq.heappop(heap)\n\n        if n1 == end_node:\n            return -p1\n\n        for n2, p2 in graph[n1]:\n            p2 *= -p1\n            if p2 &gt; max_prob[n2]:\n                max_prob[n2] = p2\n                heapq.heappush(heap, (-p2, n2))\n\n    return 0.0\n\n\n# Dijkstra - Set\ndef maxProbability2(\n    n: int,\n    edges: List[List[int]],\n    succProb: List[float],\n    start_node: int,\n    end_node: int,\n) -&gt; float:\n    graph = defaultdict(list)\n    for i, (u, v) in enumerate(edges):\n        graph[u].append((v, succProb[i]))\n        graph[v].append((u, succProb[i]))\n\n    heap = [(-1, start_node)]\n    visited = set()\n\n    while heap:\n        p1, n1 = heapq.heappop(heap)\n        visited.add(n1)\n\n        if n1 == end_node:\n            return -p1\n\n        for n2, p2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (p1 * p2, n2))\n\n    return 0.0\n\n\n# |------------|-----------|-----------|\n# |  Approach  |    Time   |   Space   |\n# |------------|-----------|-----------|\n# |  Dijkstra  | O(E log V)|   O(E)    |\n# |------------|-----------|-----------|\n\n\nn = 3\nedges = [[0, 1], [1, 2], [0, 2]]\nsuccProb = [0.5, 0.5, 0.2]\nstart = 0\nend = 2\n\nprint(maxProbability1(n, edges, succProb, start, end))  # 0.25\nprint(maxProbability2(n, edges, succProb, start, end))  # 0.25\n</code></pre>"},{"location":"graph-theory/dijkstra%27s/#505-the-maze-ii","title":"505. The Maze II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Graph, Heap Priority Queue, Matrix, Shortest Path</p> </li> </ul> Python <pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra\ndef shortestDistance(\n    maze: List[List[int]], start: List[int], destination: List[int]\n) -&gt; int:\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    m, n = len(maze), len(maze[0])\n\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    dist[start[0]][start[1]] = 0\n\n    heap = [(0, start[0], start[1])]\n\n    while heap:\n        d, r, c = heapq.heappop(heap)\n\n        if [r, c] == destination:\n            return d\n\n        for dr, dc in directions:\n            nr, nc, nd = r, c, d\n\n            while 0 &lt;= nr + dr &lt; m and 0 &lt;= nc + dc &lt; n and maze[nr + dr][nc + dc] == 0:\n                nr += dr\n                nc += dc\n                nd += 1\n\n            if nd &lt; dist[nr][nc]:\n                dist[nr][nc] = nd\n                heapq.heappush(heap, (nd, nr, nc))\n\n    return -1\n\n\nmaze = [\n    [0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0],\n    [0, 0, 0, 1, 0],\n    [1, 1, 0, 1, 1],\n    [0, 0, 0, 0, 0],\n]\nstart = [0, 4]\ndestination = [4, 4]\nprint(shortestDistance(maze, start, destination))  # 12\n</code></pre>"},{"location":"graph-theory/dijkstra%27s/#499-the-maze-iii","title":"499. The Maze III \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Depth First Search, Breadth First Search, Graph, Heap Priority Queue, Matrix, Shortest Path</p> </li> </ul> Python <pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra\ndef findShortestWay(maze: List[List[int]], ball: List[int], hole: List[int]) -&gt; str:\n    directions = [(-1, 0, \"u\"), (1, 0, \"d\"), (0, -1, \"l\"), (0, 1, \"r\")]\n    m, n = len(maze), len(maze[0])\n\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    dist[ball[0]][ball[1]] = 0\n\n    paths = [[\"\"] * n for _ in range(m)]\n    paths[ball[0]][ball[1]] = \"\"\n\n    heap = [(0, \"\", ball[0], ball[1])]\n\n    while heap:\n        d, path, x, y = heapq.heappop(heap)\n\n        if [x, y] == hole:\n            return path\n\n        for dx, dy, direction in directions:\n            nx, ny, nd = x, y, d\n\n            while 0 &lt;= nx + dx &lt; m and 0 &lt;= ny + dy &lt; n and maze[nx + dx][ny + dy] == 0:\n                nx += dx\n                ny += dy\n                nd += 1\n\n                if [nx, ny] == hole:\n                    break\n\n            new_path = path + direction\n            if nd &lt; dist[nx][ny] or (nd == dist[nx][ny] and new_path &lt; paths[nx][ny]):\n                dist[nx][ny] = nd\n                paths[nx][ny] = new_path\n                heapq.heappush(heap, (nd, new_path, nx, ny))\n\n    return \"impossible\"\n\n\nmaze = [\n    [0, 0, 0, 0, 0],\n    [1, 1, 0, 0, 1],\n    [0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 1],\n    [0, 1, 0, 0, 0],\n]\nball = [4, 3]\nhole = [0, 1]\nprint(findShortestWay(maze, ball, hole))  # \"lul\"\n</code></pre>"},{"location":"graph-theory/graph_theory/","title":"Graph Theory","text":""},{"location":"graph-theory/graph_theory/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 997. Find the Town Judge (Easy)</li> <li> 1557. Minimum Number of Vertices to Reach All Nodes (Medium)</li> <li> 1615. Maximal Network Rank (Medium)</li> <li> 785. Is Graph Bipartite? (Medium)</li> <li> 261. Graph Valid Tree (Medium) \ud83d\udc51</li> </ul>"},{"location":"graph-theory/graph_theory/#997-find-the-town-judge","title":"997. Find the Town Judge","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Graph</p> </li> </ul> Python <pre><code>\"\"\"\n-   `trust = [[1, 3], [2, 3], [1, 2], [4, 3]]`\n\"\"\"\n\nfrom typing import List\n\n\n# Graph\ndef findJudge(n: int, trust: List[List[int]]) -&gt; int:\n    indegree = {i: 0 for i in range(1, n + 1)}\n    outdegree = {i: 0 for i in range(1, n + 1)}\n\n    for a, b in trust:\n        outdegree[a] += 1\n        indegree[b] += 1\n\n    for i in range(1, n + 1):\n        if indegree[i] == n - 1 and outdegree[i] == 0:\n            return i\n\n    return -1\n\n\nn = 4\ntrust = [[1, 3], [2, 3], [1, 2], [4, 3]]\nprint(findJudge(n, trust))  # 4\n</code></pre>"},{"location":"graph-theory/graph_theory/#1557-minimum-number-of-vertices-to-reach-all-nodes","title":"1557. Minimum Number of Vertices to Reach All Nodes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Graph</p> </li> </ul> Python <pre><code>\"\"\"\n- Return a list of integers representing the minimum number of vertices needed to traverse all the nodes.\n- Hint: Return the vertices with indegree 0.\n\"\"\"\n\nfrom typing import List\n\n\n# Graph\ndef findSmallestSetOfVertices(n: int, edges: List[List[int]]) -&gt; List[int]:\n    indegree = {i: 0 for i in range(n)}\n\n    for _, end in edges:\n        indegree[end] += 1\n\n    return [i for i in range(n) if indegree[i] == 0]\n\n\nif __name__ == \"__main__\":\n    n = 6\n    edges = [[0, 1], [0, 2], [2, 5], [3, 4], [4, 2]]\n    assert findSmallestSetOfVertices(n, edges) == [0, 3]\n</code></pre>"},{"location":"graph-theory/graph_theory/#1615-maximal-network-rank","title":"1615. Maximal Network Rank","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Graph</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Graph\ndef maximalNetworkRank(n: int, roads: List[List[int]]) -&gt; int:\n    degree = defaultdict(int)\n    roads_set = set(map(tuple, roads))\n\n    for a, b in roads_set:\n        degree[a] += 1\n        degree[b] += 1\n\n    rank = 0\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if (i, j) in roads_set or (j, i) in roads_set:\n                rank = max(rank, degree[i] + degree[j] - 1)\n            else:\n                rank = max(rank, degree[i] + degree[j])\n\n    return rank\n\n\nn = 4\nroads = [[0, 1], [0, 3], [1, 2], [1, 3]]\nprint(maximalNetworkRank(n, roads))  # 4\n</code></pre>"},{"location":"graph-theory/graph_theory/#785-is-graph-bipartite","title":"785. Is Graph Bipartite?","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Union Find, Graph</p> </li> </ul> Python <pre><code>\"\"\"\n-   Determine if a graph is bipartite.\n\nHow to group\n\n|          | Uncolored | Color 1 | Color 2 | Operation   |\n| -------- | --------- | ------- | ------- | ----------- |\n| Method 1 | -1        | 0       | 1       | `1 - color` |\n| Method 2 | 0         | 1       | -1      | `-color`    |\n\"\"\"\n\nfrom collections import deque\nfrom typing import List\n\n\n# BFS\ndef isBipartiteBFS(graph: List[List[int]]) -&gt; bool:\n    n = len(graph)\n    # -1: not colored; 0: blue; 1: red\n    color = [-1 for _ in range(n)]\n\n    def bfs(node):\n        q = deque([node])\n        color[node] = 0\n\n        while q:\n            cur = q.popleft()\n\n            for neighbor in graph[cur]:\n                if color[neighbor] == -1:\n                    color[neighbor] = 1 - color[cur]\n                    q.append(neighbor)\n                elif color[neighbor] == color[cur]:\n                    return False\n        return True\n\n    for i in range(n):\n        if color[i] == -1:\n            if not bfs(i):\n                return False\n\n    return True\n\n\n# DFS\ndef isBipartiteDFS(graph: List[List[int]]) -&gt; bool:\n    n = len(graph)\n    # -1: not colored; 0: blue; 1: red\n    color = [-1] * n\n\n    def dfs(node, c):\n        color[node] = c\n        for neighbor in graph[node]:\n            if color[neighbor] == -1:\n                if not dfs(neighbor, 1 - c):\n                    return False\n            elif color[neighbor] == c:\n                return False\n        return True\n\n    for i in range(n):\n        if color[i] == -1:\n            if not dfs(i, 0):\n                return False\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |    BFS     | O(V+E) |  O(V)   |\n# |    DFS     | O(V+E) |  O(V)   |\n# |------------|--------|---------|\n\n\ngraph = [[1, 2, 3], [0, 2], [0, 1, 3], [0, 2]]\nprint(isBipartiteBFS(graph))  # False\nprint(isBipartiteDFS(graph))  # False\n</code></pre>"},{"location":"graph-theory/graph_theory/#261-graph-valid-tree","title":"261. Graph Valid Tree \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Union Find, Graph</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Graph\ndef validTree(n: int, edges: List[List[int]]) -&gt; bool:\n    if n == 0:\n        return False\n    if len(edges) != n - 1:\n        return False\n\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = set()\n\n    def dfs(node, parent):\n        if node in visited:\n            return False\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor != parent and not dfs(neighbor, node):\n                return False\n        return True\n\n    return dfs(0, -1) and len(visited) == n\n\n\nprint(validTree(5, [[0, 1], [0, 2], [0, 3], [1, 4]]))  # True\nprint(validTree(5, [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]))  # False\n</code></pre>"},{"location":"graph-theory/matrix_graphs/","title":"Matrix Graphs","text":""},{"location":"graph-theory/matrix_graphs/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 200. Number of Islands (Medium)</li> <li> 1020. Number of Enclaves (Medium)</li> <li> 1254. Number of Closed Islands (Medium)</li> <li> 695. Max Area of Island (Medium)</li> <li> 417. Pacific Atlantic Water Flow (Medium)</li> </ul>"},{"location":"graph-theory/matrix_graphs/#200-number-of-islands","title":"200. Number of Islands","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Union Find, Matrix</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Count the number of islands in a 2D grid.\n-   Method 1: DFS\n-   Method 2: BFS (use a queue to traverse the grid)\n\n-   How to keep track of visited cells?\n\n    1. Mark the visited cell as `0` (or any other value) to avoid revisiting it.\n    2. Use a set to store the visited cells.\n\n-   Steps:\n    1. Init: variables\n    2. DFS/BFS: starting from the cell with `1`, turn all the connected `1`s to `0`.\n    3. Traverse the grid, and if the cell is `1`, increment the count and call DFS/BFS.\n\n![0200](../../assets/0200.jpg)\n\"\"\"\n\nfrom collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef numIslandsDFS(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    res = 0\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] != \"1\":\n            return\n\n        grid[r][c] = \"2\"\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                dfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Set\ndef numIslandsBFS1(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == \"0\"\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\" and (r, c) not in visited:\n                visited.add((r, c))\n                bfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = dr + row, dc + col\n                if nr &lt; 0 or nr &gt;= m or nc &lt; 0 or nc &gt;= n or grid[nr][nc] != \"1\":\n                    continue\n                grid[nr][nc] = \"2\"\n                q.append((nr, nc))\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == \"1\":\n                grid[i][j] = \"2\"\n                bfs(i, j)\n                res += 1\n\n    return res\n\n\ngrid = [\n    [\"1\", \"1\", \"1\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"0\", \"0\", \"0\", \"0\", \"0\"],\n]\n\nprint(numIslandsDFS(deepcopy(grid)))  # 1\nprint(numIslandsBFS1(deepcopy(grid)))  # 1\nprint(numIslandsBFS2(deepcopy(grid)))  # 1\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    // dfs\n    int num_islands_dfs(vector&lt;vector&lt;char&gt;&gt; &amp;grid) {\n        int m = grid.size(), n = grid[0].size();\n        int res = 0;\n\n        // c++23 lambda recursion\n        auto dfs = [&amp;](this auto &amp;&amp;dfs, int r, int c) -&gt; void {\n            if (r &lt; 0 || r &gt;= m || c &lt; 0 || c &gt;= n || grid[r][c] != '1') {\n                return;\n            }\n            grid[r][c] = '0';\n            dfs(r + 1, c);\n            dfs(r - 1, c);\n            dfs(r, c + 1);\n            dfs(r, c - 1);\n        };\n\n        for (int i = 0; i &lt; m; i++) {\n            for (int j = 0; j &lt; n; j++) {\n                if (grid[i][j] == '1') {\n                    res++;\n                    dfs(i, j);\n                }\n            }\n        }\n        return res;\n    }\n\n    // bfs\n    int num_islands_bfs(vector&lt;vector&lt;char&gt;&gt; &amp;grid) {\n        int m = grid.size(), n = grid[0].size();\n        int res = 0;\n        vector&lt;pair&lt;int, int&gt;&gt; dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\n        auto bfs = [&amp;](int r, int c) {\n            queue&lt;pair&lt;int, int&gt;&gt; q;\n            q.push({r, c});\n            grid[r][c] = '0';\n            while (!q.empty()) {\n                auto [cr, cc] = q.front();\n                q.pop();\n                for (auto &amp;[dr, dc] : dirs) {\n                    int nr = cr + dr, nc = cc + dc;\n                    if (nr &gt;= 0 &amp;&amp; nr &lt; m &amp;&amp; nc &gt;= 0 &amp;&amp; nc &lt; n &amp;&amp;\n                        grid[nr][nc] == '1') {\n                        grid[nr][nc] = '0';\n                        q.push({nr, nc});\n                    }\n                }\n            }\n        };\n\n        for (int i = 0; i &lt; m; i++) {\n            for (int j = 0; j &lt; n; j++) {\n                if (grid[i][j] == '1') {\n                    res++;\n                    bfs(i, j);\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;vector&lt;char&gt;&gt; grid = {{'1', '1', '0', '0', '0'},\n                                 {'1', '1', '0', '0', '0'},\n                                 {'0', '0', '1', '0', '0'},\n                                 {'0', '0', '0', '1', '1'}};\n    assert(solution.num_islands_dfs(grid) == 3);\n    grid = {{'1', '1', '0', '0', '0'},\n            {'1', '1', '0', '0', '0'},\n            {'0', '0', '1', '0', '0'},\n            {'0', '0', '0', '1', '1'}};\n    assert(solution.num_islands_bfs(grid) == 3);\n    return 0;\n}\n</code></pre>"},{"location":"graph-theory/matrix_graphs/#1020-number-of-enclaves","title":"1020. Number of Enclaves","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Union Find, Matrix</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DFS\ndef numEnclaves(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    visited = set()\n\n    def dfs(r, c):\n        if r not in range(m) or c not in range(n) or grid[r][c] == 0 or (r, c) in visited:\n            return\n\n        grid[r][c] = 0\n        visited.add((r, c))\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if (\n                (r in [0, m - 1] or c in [0, n - 1])\n                and grid[r][c] == 1\n                and (r, c) not in visited\n            ):\n                dfs(r, c)\n\n    count = 0\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1 and (r, c) not in visited:\n                count += 1\n\n    return count\n\n\ngrid = [[0, 0, 0, 0], [1, 0, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0]]\nprint(numEnclaves(grid))  # 3\n</code></pre>"},{"location":"graph-theory/matrix_graphs/#1254-number-of-closed-islands","title":"1254. Number of Closed Islands","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Union Find, Matrix</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DFS\ndef closedIsland(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    visited = set()\n\n    def dfs(r, c):\n        if r not in range(m) or c not in range(n) or grid[r][c] == 1 or (r, c) in visited:\n            return\n\n        grid[r][c] = 1\n        visited.add((r, c))\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if (\n                (r in [0, m - 1] or c in [0, n - 1])\n                and grid[r][c] == 0\n                and (r, c) not in visited\n            ):\n                dfs(r, c)\n\n    island = 0\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 0 and (r, c) not in visited:\n                island += 1\n                dfs(r, c)\n\n    return island\n\n\ngrid = [\n    [1, 1, 1, 1, 1, 1, 1, 0],\n    [1, 0, 0, 0, 0, 1, 1, 0],\n    [1, 0, 1, 0, 1, 1, 1, 0],\n    [1, 0, 0, 0, 0, 1, 0, 1],\n    [1, 1, 1, 1, 1, 1, 1, 0],\n]\nprint(closedIsland(grid))  # 2\n</code></pre>"},{"location":"graph-theory/matrix_graphs/#695-max-area-of-island","title":"695. Max Area of Island","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Union Find, Matrix</p> </li> </ul> PythonCPP <pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef maxAreaOfIslandDFS(grid: List[List[int]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] == 0:\n            return 0\n\n        grid[r][c] = 0\n\n        return 1 + dfs(r + 1, c) + dfs(r - 1, c) + dfs(r, c + 1) + dfs(r, c - 1)\n\n    res = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                res = max(res, dfs(i, j))\n    return res\n\n\n# BFS\ndef maxAreaOfIslandBFS1(grid: List[List[int]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        area = 0\n\n        while q:\n            row, col = q.popleft()\n            area += 1\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == 0\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n        return area\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1 and (r, c) not in visited:\n                visited.add((r, c))\n                res = max(res, bfs(r, c))\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        area = 0\n\n        while q:\n            row, col = q.popleft()\n            area += 1\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n\n                if nr &lt; 0 or nr &gt;= m or nc &lt; 0 or nc &gt;= n or grid[nr][nc] == 0:\n                    continue\n\n                q.append((nr, nc))\n                grid[nr][nc] = 0\n\n        return area\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                grid[r][c] = 0\n                res = max(res, bfs(r, c))\n\n    return res\n\n\ngrid = [\n    [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0],\n    [0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],\n]\nprint(maxAreaOfIslandDFS(grid))  # 6\nprint(maxAreaOfIslandBFS1(grid))  # 6\nprint(numIslandsBFS2(grid))  # 6\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int max_area_of_island(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {\n        int m = grid.size(), n = grid[0].size();\n        int res = 0;\n\n        auto dfs = [&amp;](this auto&amp;&amp; dfs, int r, int c) -&gt; int {\n            if (r &lt; 0 || r &gt;= m || c &lt; 0 || c &gt;= n || grid[r][c] != 1) {\n                return 0;\n            }\n            grid[r][c] = 0;\n\n            return 1 + dfs(r + 1, c) + dfs(r - 1, c) + dfs(r, c + 1) +\n                   dfs(r, c - 1);\n        };\n\n        for (int i = 0; i &lt; m; i++) {\n            for (int j = 0; j &lt; n; j++) {\n                if (grid[i][j] == 1) {\n                    int area = dfs(i, j);\n                    res = max(res, area);\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;vector&lt;int&gt;&gt; grid = {{0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},\n                                {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},\n                                {0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},\n                                {0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0},\n                                {0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0},\n                                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0},\n                                {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},\n                                {0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0}};\n    assert(solution.max_area_of_island(grid) == 6);\n    return 0;\n}\n</code></pre>"},{"location":"graph-theory/matrix_graphs/#417-pacific-atlantic-water-flow","title":"417. Pacific Atlantic Water Flow","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Matrix</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef pacificAtlanticDFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(r, c, visited, prev_height):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or heights[r][c] &lt; prev_height\n            or (r, c) in visited\n        ):\n            return None\n\n        visited.add((r, c))\n        height = heights[r][c]\n        for dr, dc in directions:\n            dfs(dr + r, dc + c, visited, height)\n\n    for c in range(n):\n        dfs(0, c, pac, heights[0][c])\n        dfs(m - 1, c, atl, heights[m - 1][c])\n\n    for r in range(m):\n        dfs(r, 0, pac, heights[r][0])\n        dfs(r, n - 1, atl, heights[r][n - 1])\n\n    return list(pac &amp; atl)\n\n\n# BFS\ndef pacificAtlanticBFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def bfs(r, c, visited):\n        q = deque([(r, c)])\n        visited.add((r, c))\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr in range(m)\n                    and nc in range(n)\n                    and heights[row][col] &lt;= heights[nr][nc]\n                    and (nr, nc) not in visited\n                ):\n                    q.append((nr, nc))\n                    visited.add((nr, nc))\n\n    for c in range(n):\n        bfs(0, c, pac)  # top\n        bfs(m - 1, c, atl)  # bottom\n\n    for r in range(m):\n        bfs(r, 0, pac)  # left\n        bfs(r, n - 1, atl)  # right\n\n    return list(pac &amp; atl)\n\n\nheights = [\n    [1, 2, 2, 3, 5],\n    [3, 2, 3, 4, 4],\n    [2, 4, 5, 3, 1],\n    [6, 7, 1, 4, 5],\n    [5, 1, 1, 2, 4],\n]\nprint(pacificAtlanticDFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\nprint(pacificAtlanticBFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\n</code></pre>"},{"location":"graph-theory/mst/","title":"MST","text":""},{"location":"graph-theory/mst/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1135. Connecting Cities With Minimum Cost (Medium) \ud83d\udc51</li> <li> 1584. Min Cost to Connect All Points (Medium)</li> <li> 1168. Optimize Water Distribution in a Village (Hard) \ud83d\udc51</li> <li> 1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree (Hard)</li> </ul>"},{"location":"graph-theory/mst/#1135-connecting-cities-with-minimum-cost","title":"1135. Connecting Cities With Minimum Cost \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Union Find, Graph, Heap Priority Queue, Minimum Spanning Tree</p> </li> </ul> Python <pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minimumCost(n: int, connections: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, c in connections:\n        graph[u].append((c, v))\n        graph[v].append((c, u))\n\n    cost = 0\n    heap = [(0, 1)]  # (cost, node)\n    visited = set()\n\n    while heap:\n        c1, n1 = heapq.heappop(heap)\n\n        if n1 in visited:\n            continue\n\n        visited.add(n1)\n\n        cost += c1\n\n        for c2, n2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (c2, n2))\n\n    return cost if len(visited) == n else -1\n\n\nn = 3\nconnections = [[1, 2, 5], [1, 3, 6], [2, 3, 1]]\nprint(minimumCost(n, connections))  # 6\n</code></pre>"},{"location":"graph-theory/mst/#1584-min-cost-to-connect-all-points","title":"1584. Min Cost to Connect All Points","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Union Find, Graph, Minimum Spanning Tree</p> </li> </ul> Python <pre><code>\"\"\"\n- Tree: a connected acyclic graph\n- Spanning Tree: a subgraph that is a tree and connects all the vertices together\n- Minimum Spanning Tree (MST): a spanning tree with the minimum possible sum of edge weights\n- Prim's Algorithm\n  - Data Structure: Heap\n  - Time Complexity: O(E * logV)\n  - Space Complexity: O(V + E)\n- Kruskal's Algorithm\n  - Union Find\n  - Time Complexity: O(E * logV)\n  - Space Complexity: O(V + E)\n\"\"\"\n\nimport heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minCostConnectPointsPrim(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    graph = defaultdict(list)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            dist = abs(x1 - x2) + abs(y1 - y2)\n            graph[i].append((dist, j))\n            graph[j].append((dist, i))\n\n    cost = 0\n    heap = [(0, 0)]  # (cost, node)\n    visited = set()\n\n    while heap:\n        d1, n1 = heapq.heappop(heap)\n        if n1 in visited:\n            continue\n        visited.add(n1)\n        cost += d1\n\n        for d2, n2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (d2, n2))\n\n    return cost\n\n\n# Kruskal\ndef minCostConnectPointsKruskal(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    par = {i: i for i in range(n)}\n    rank = {i: 0 for i in range(n)}\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 == p2:\n            return False\n\n        if rank[p1] &gt; rank[p2]:\n            par[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n        else:\n            par[p2] = p1\n            rank[p1] += 1\n\n        return True\n\n    heap = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            dist = abs(x1 - x2) + abs(y1 - y2)\n            heapq.heappush(heap, (dist, i, j))\n\n    cost = 0\n    while heap:\n        d, n1, n2 = heapq.heappop(heap)\n        if union(n1, n2):\n            cost += d\n\n    return cost\n\n\nif __name__ == \"__main__\":\n    points = [[0, 0], [2, 2], [3, 10], [5, 2], [7, 0]]\n    print(minCostConnectPointsPrim(points))  # 20\n    print(minCostConnectPointsKruskal(points))  # 20\n</code></pre>"},{"location":"graph-theory/mst/#1168-optimize-water-distribution-in-a-village","title":"1168. Optimize Water Distribution in a Village \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Union Find, Graph, Heap Priority Queue, Minimum Spanning Tree</p> </li> </ul> Python <pre><code>\"\"\"\n- ![1168_0](../../assets/1168_0.png)\n\n- ![1168_1](../../assets/1168_1.png)\n\"\"\"\n\nimport heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minCostToSupplyWater1(n: int, wells: List[int], pipes: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n\n    for h1, h2, cost in pipes:\n        graph[h1].append((h2, cost))\n        graph[h2].append((h1, cost))\n\n    # Add the cost of the wells to the graph (house 0)\n    for i in range(n):\n        graph[0].append((i + 1, wells[i]))\n        graph[i + 1].append((0, wells[i]))\n\n    visited = set([0])\n    heap = [(cost, dest) for dest, cost in graph[0]]\n    heapq.heapify(heap)\n\n    cost = 0\n\n    while heap:\n        c1, n1 = heapq.heappop(heap)\n        if n1 in visited:\n            continue\n        visited.add(n1)\n        cost += c1\n\n        for n2, c2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (c2, n2))\n\n    return cost\n\n\n# Kruskal\ndef minCostToSupplyWater2(n: int, wells: List[int], pipes: List[List[int]]) -&gt; int:\n    par = list(range(n + 1))\n    rank = [0] * (n + 1)\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            if rank[p1] &lt; rank[p2]:\n                par[p1] = p2\n            elif rank[p1] &gt; rank[p2]:\n                par[p2] = p1\n            else:\n                par[p1] = p2\n                rank[p2] += 1\n            return True\n        return False\n\n    graph = [(c, 0, i + 1) for i, c in enumerate(wells)]\n    for h1, h2, c in pipes:\n        graph.append((c, h1, h2))\n\n    graph.sort()\n\n    cost = 0\n\n    for c, h1, h2 in graph:\n        if union(h1, h2):\n            cost += c\n\n    return cost\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |    Prim    | O((V + E) log V) | O(V + E)|\n# |  Kruskal   |     O(E log E)   | O(V + E)|\n# |------------|------------------|---------|\n\n\nn = 3\nwells = [1, 2, 2]\npipes = [[1, 2, 1], [2, 3, 1]]\nprint(minCostToSupplyWater1(n, wells, pipes))  # 3\nprint(minCostToSupplyWater2(n, wells, pipes))  # 3\n</code></pre>"},{"location":"graph-theory/mst/#1489-find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree","title":"1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Union Find, Graph, Sorting, Minimum Spanning Tree, Strongly Connected Component</p> </li> </ul> Python <pre><code>from typing import List\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [1 for _ in range(n)]\n        self.part = n\n\n    def find(self, n):\n        p = self.parent[n]\n        while p != self.parent[p]:\n            self.parent[p] = self.parent[self.parent[p]]\n            p = self.parent[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return False\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.parent[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.parent[p1] = p2\n        else:\n            self.parent[p2] = p1\n            self.rank[p1] += 1\n\n        self.part -= 1\n        return True\n\n\n# Kruskal\ndef findCriticalAndPseudoCriticalEdges(n: int, edges: List[List[int]]) -&gt; List[List[int]]:\n    m = len(edges)\n\n    # Add index to edges\n    lst = list(range(m))\n    lst.sort(key=lambda x: edges[x][2])\n\n    # Calculate minimum cost\n    min_cost = 0\n    uf = UnionFind(n)\n    for i in lst:\n        x, y, cost = edges[i]\n        if uf.union(x, y):\n            min_cost += cost\n\n    # Calculate key edges\n    key = set()\n    for i in lst:\n        cur_cost = 0\n        uf = UnionFind(n)\n        for j in lst:\n            if j != i:\n                x, y, cost = edges[j]\n                if uf.union(x, y):\n                    cur_cost += cost\n        if cur_cost &gt; min_cost or uf.part != 1:\n            key.add(i)\n\n    # Calculate fake edges\n    fake = set()\n    for i in lst:\n        if i not in key:\n            cur_cost = edges[i][2]\n            uf = UnionFind(n)\n            uf.union(edges[i][0], edges[i][1])\n            for j in lst:\n                x, y, cost = edges[j]\n                if uf.union(x, y):\n                    cur_cost += cost\n            if cur_cost == min_cost and uf.part == 1:\n                fake.add(i)\n\n    return [sorted(list(key)), sorted(list(fake))]\n\n\nn = 5\nedges = [\n    [0, 1, 1],\n    [1, 2, 1],\n    [2, 3, 2],\n    [0, 3, 2],\n    [0, 4, 3],\n    [3, 4, 3],\n    [1, 4, 6],\n]\nprint(findCriticalAndPseudoCriticalEdges(n, edges))\n</code></pre>"},{"location":"graph-theory/standard_traversal/","title":"Standard Traversal","text":""},{"location":"graph-theory/standard_traversal/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 547. Number of Provinces (Medium)</li> <li> 802. Find Eventual Safe States (Medium)</li> <li> 841. Keys and Rooms (Medium)</li> <li> 1129. Shortest Path with Alternating Colors (Medium)</li> <li> 1376. Time Needed to Inform All Employees (Medium)</li> <li> 1466. Reorder Routes to Make All Paths Lead to the City Zero (Medium)</li> <li> 797. All Paths From Source to Target (Medium)</li> <li> 1192. Critical Connections in a Network (Hard)</li> </ul>"},{"location":"graph-theory/standard_traversal/#547-number-of-provinces","title":"547. Number of Provinces","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Union Find, Graph</p> </li> </ul> Python <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\nclass FindCircleNum:\n    def dfs_adjacency_list(self, isConnected: List[List[int]]) -&gt; int:\n        # edge case\n        if not isConnected:\n            return 0\n\n        # init\n        n = len(isConnected)\n        visited = set()\n        res = 0\n\n        # build adjacency list\n        graph = defaultdict(list)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if isConnected[i][j] == 1:\n                    graph[i].append(j)\n                    graph[j].append(i)\n\n        def dfs(node):\n            if node in visited:\n                return\n            visited.add(node)\n            for adj in graph[node]:\n                dfs(adj)\n\n        # loop\n        for i in range(n):\n            if i not in visited:\n                res += 1\n                dfs(i)\n\n        return res\n\n    def dfs_adjacency_matrix(self, isConnected: List[List[int]]) -&gt; int:\n        \"\"\"\n        Time complexity: O(V + E)\n        Space complexity: O(V)\n        \"\"\"\n        # edge case\n        if not isConnected:\n            return 0\n\n        # init\n        n = len(isConnected)\n        visited = set()\n        res = 0\n\n        def dfs(node):\n            if node in visited:\n                return\n            visited.add(node)\n            for adj in range(n):\n                if node != adj and isConnected[node][adj] == 1:\n                    dfs(adj)\n\n        # loop\n        for i in range(n):\n            if i not in visited:\n                res += 1\n                dfs(i)\n\n        return res\n\n    def bfs_adjacency_list(self, isConnected: List[List[int]]) -&gt; int:\n        # edge case\n        if not isConnected:\n            return 0\n\n        # init\n        n = len(isConnected)\n        visited = set()\n        res = 0\n\n        # build adjacency list\n        graph = defaultdict(list)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if isConnected[i][j] == 1:\n                    graph[i].append(j)\n                    graph[j].append(i)\n\n        # loop\n        for i in range(n):\n            if i not in visited:\n                q = deque([i])\n                visited.add(i)\n                res += 1\n\n                while q:\n                    node = q.popleft()\n                    for adj in graph[node]:\n                        if adj not in visited:\n                            q.append(adj)\n                            visited.add(adj)\n\n        return res\n\n    def bfs_adjacency_matrix(self, isConnected: List[List[int]]) -&gt; int:\n        if not isConnected:\n            return 0\n\n        res = 0\n        visited = set()\n        n = len(isConnected)\n\n        for i in range(n):\n            if i not in visited:\n                q = deque([i])\n                visited.add(i)\n                res += 1\n\n                while q:\n                    cur = q.popleft()\n                    for adj in range(n):\n                        if (\n                            adj != cur\n                            and adj not in visited\n                            and isConnected[adj][cur] == 1\n                        ):\n                            q.append(adj)\n                            visited.add(adj)\n\n        return res\n\n    def union_find(self, isConnected: List[List[int]]) -&gt; int:\n        n = len(isConnected)\n        par = {i: i for i in range(n)}\n        rank = {i: 0 for i in range(n)}\n\n        def find(n):\n            if par[n] != n:\n                par[n] = find(par[n])\n            return par[n]\n\n        def union(n1, n2):\n            p1, p2 = find(n1), find(n2)\n\n            if p1 == p2:\n                return None\n\n            if rank[p1] &gt; rank[p2]:\n                par[p2] = p1\n            elif rank[p1] &lt; rank[p2]:\n                par[p1] = p2\n            else:\n                par[p2] = p1\n                rank[p1] += 1\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if isConnected[i][j] == 1:\n                    union(i, j)\n\n        res = len(set(find(i) for i in range(n)))\n\n        return res\n\n\nif __name__ == \"__main__\":\n    isConnected = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]\n    sol = FindCircleNum()\n    assert sol.dfs_adjacency_list(isConnected) == 2\n    assert sol.dfs_adjacency_matrix(isConnected) == 2\n    assert sol.bfs_adjacency_list(isConnected) == 2\n    assert sol.bfs_adjacency_matrix(isConnected) == 2\n    assert sol.union_find(isConnected) == 2\n</code></pre>"},{"location":"graph-theory/standard_traversal/#802-find-eventual-safe-states","title":"802. Find Eventual Safe States","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Graph, Topological Sort</p> </li> </ul> Python <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# Topological Sort\ndef eventualSafeNodesTS(graph: List[List[int]]) -&gt; List[int]:\n    n = len(graph)\n    reverse_graph = defaultdict(list)\n    indegree = [0 for _ in range(n)]\n    safe = [False for _ in range(n)]\n\n    for u in range(n):\n        for v in graph[u]:\n            reverse_graph[v].append(u)\n        indegree[u] = len(graph[u])\n\n    q = deque([i for i in range(n) if indegree[i] == 0])\n\n    while q:\n        node = q.popleft()\n        safe[node] = True\n\n        for neighbor in reverse_graph[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n\n    return [i for i in range(n) if safe[i]]\n\n\n# DFS\ndef eventualSafeNodesDFS(graph: List[List[int]]) -&gt; List[int]:\n    n = len(graph)\n    state = [0 for _ in range(n)]  # 0: unvisited, 1: visiting, 2: visited\n\n    def dfs(node):\n        if state[node] &gt; 0:\n            return state[node] == 2\n        state[node] = 1\n        for neighbor in graph[node]:\n            if state[neighbor] == 1 or not dfs(neighbor):\n                return False\n        state[node] = 2\n        return True\n\n    return [i for i in range(n) if dfs(i)]\n\n\ngraph = [[1, 2], [2, 3], [5], [0], [5], [], []]\nprint(eventualSafeNodesTS(graph))  # [2, 4, 5, 6]\nprint(eventualSafeNodesDFS(graph))  # [2, 4, 5, 6]\n</code></pre>"},{"location":"graph-theory/standard_traversal/#841-keys-and-rooms","title":"841. Keys and Rooms","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Graph</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef canVisitAllRoomsDFS(rooms: List[List[int]]) -&gt; bool:\n    n = len(rooms)\n    visited = [False for _ in range(n)]\n\n    def dfs(room):\n        visited[room] = True\n        for key in rooms[room]:\n            if not visited[key]:\n                dfs(key)\n\n    dfs(0)\n\n    return all(visited)\n\n\n# BFS\ndef canVisitAllRoomsBFS(rooms):\n    n = len(rooms)\n    visited = [False for _ in range(n)]\n    q = deque([0])\n    visited[0] = True\n\n    while q:\n        room = q.popleft()\n        for key in rooms[room]:\n            if not visited[key]:\n                visited[key] = True\n                q.append(key)\n\n    return all(visited)\n\n\nrooms = [[1, 3], [3, 0, 1], [2], [0]]\nprint(canVisitAllRoomsDFS(rooms))  # False\nprint(canVisitAllRoomsBFS(rooms))  # False\n</code></pre>"},{"location":"graph-theory/standard_traversal/#1129-shortest-path-with-alternating-colors","title":"1129. Shortest Path with Alternating Colors","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Breadth First Search, Graph</p> </li> </ul> Python <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef shortestAlternatingPaths(\n    n: int, redEdges: List[List[int]], blueEdges: List[List[int]]\n) -&gt; List[int]:\n    red_graph = defaultdict(list)\n    blue_graph = defaultdict(list)\n\n    for u, v in redEdges:\n        red_graph[u].append(v)\n    for u, v in blueEdges:\n        blue_graph[u].append(v)\n\n    answer = [-1 for _ in range(n)]\n    q = deque([(0, 0, 0), (0, 0, 1)])  # (node, distance, color)\n    visited = set()\n\n    while q:\n        node, dist, color = q.popleft()\n        if (node, color) in visited:\n            continue\n        visited.add((node, color))\n        if answer[node] == -1:\n            answer[node] = dist\n        if color == 0:\n            for neighbor in blue_graph[node]:\n                q.append((neighbor, dist + 1, 1))\n        else:\n            for neighbor in red_graph[node]:\n                q.append((neighbor, dist + 1, 0))\n\n    return answer\n\n\nn = 3\nred_edges = [[0, 1], [1, 2]]\nblue_edges = []\nprint(shortestAlternatingPaths(n, red_edges, blue_edges))  # [0, 1, -1]\n</code></pre>"},{"location":"graph-theory/standard_traversal/#1376-time-needed-to-inform-all-employees","title":"1376. Time Needed to Inform All Employees","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search</p> </li> </ul> Python <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# DFS\ndef numOfMinutesDFS(\n    n: int, headID: int, manager: List[int], informTime: List[int]\n) -&gt; int:\n    graph = defaultdict(list)\n    for i in range(n):\n        if manager[i] != -1:\n            graph[manager[i]].append(i)\n\n    def dfs(node):\n        time = 0\n        for sub in graph[node]:\n            time = max(time, dfs(sub))\n        return time + informTime[node]\n\n    return dfs(headID)\n\n\n# BFS\ndef numOfMinutesBFS(\n    n: int, headID: int, manager: List[int], informTime: List[int]\n) -&gt; int:\n    graph = defaultdict(list)\n    for i in range(n):\n        if manager[i] != -1:\n            graph[manager[i]].append(i)\n\n    q = deque([(headID, 0)])\n    max_time = 0\n\n    while q:\n        node, time = q.popleft()\n        max_time = max(max_time, time)\n        for sub in graph[node]:\n            q.append((sub, time + informTime[node]))\n\n    return max_time\n\n\nn = 6\nheadID = 2\nmanager = [2, 2, -1, 2, 2, 2]\ninformTime = [0, 0, 1, 0, 0, 0]\nprint(numOfMinutesDFS(n, headID, manager, informTime))  # 1\nprint(numOfMinutesBFS(n, headID, manager, informTime))  # 1\n</code></pre>"},{"location":"graph-theory/standard_traversal/#1466-reorder-routes-to-make-all-paths-lead-to-the-city-zero","title":"1466. Reorder Routes to Make All Paths Lead to the City Zero","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Graph</p> </li> </ul> Python <pre><code>\"\"\"\n-   ![1466](https://assets.leetcode.com/uploads/2020/05/13/sample_1_1819.png)\n\"\"\"\n\nfrom collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef minReorderBFS(n: int, connections: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append((v, 1))  # go\n        graph[v].append((u, 0))  # come\n\n    changes = 0\n    q = deque([(0, -1)])\n\n    while q:\n        n1, d1 = q.popleft()\n\n        for n2, d2 in graph[n1]:\n            if n2 != d1:\n                changes += d2\n                q.append((n2, n1))\n\n    return changes\n\n\n# DFS\ndef minReorderDFS(n: int, connections: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append((v, 1))  # go\n        graph[v].append((u, 0))  # come\n\n    def dfs(n1, d1):\n        changes = 0\n        for n2, d2 in graph[n1]:\n            if n2 != d1:\n                changes += d2 + dfs(n2, n1)\n        return changes\n\n    return dfs(0, -1)\n\n\nn = 5\nconnections = [[1, 0], [1, 2], [3, 2], [3, 4]]\nprint(minReorderBFS(n, connections))  # 2\nprint(minReorderDFS(n, connections))  # 2\n</code></pre>"},{"location":"graph-theory/standard_traversal/#797-all-paths-from-source-to-target","title":"797. All Paths From Source to Target","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Backtracking, Depth First Search, Breadth First Search, Graph</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS (Backtracking)\ndef allPathsSourceTargetDFS(graph: List[List[int]]) -&gt; List[List[int]]:\n    res = []\n    n = len(graph)\n\n    def dfs(node, path):\n        if node == n - 1:\n            res.append(path.copy())\n            return None\n\n        for nei in graph[node]:\n            path.append(nei)\n            dfs(nei, path)\n            path.pop()\n\n    dfs(0, [0])\n\n    return res\n\n\n# BFS\ndef allPathsSourceTargetBFS(graph: List[List[int]]) -&gt; List[List[int]]:\n    n = len(graph)\n    res = []\n    q = deque([(0, [0])])\n\n    while q:\n        node, path = q.popleft()\n\n        if node == n - 1:\n            res.append(path)\n\n        for nei in graph[node]:\n            q.append((nei, path + [nei]))\n\n    return res\n\n\ngraph = [[1, 2], [3], [3], []]\nprint(allPathsSourceTargetDFS(graph))  # [[0, 1, 3], [0, 2, 3]]\nprint(allPathsSourceTargetBFS(graph))  # [[0, 1, 3], [0, 2, 3]]\n</code></pre>"},{"location":"graph-theory/standard_traversal/#1192-critical-connections-in-a-network","title":"1192. Critical Connections in a Network","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Graph, Biconnected Component</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Tarjan\ndef criticalConnections(n: int, connections: List[List[int]]) -&gt; List[List[int]]:\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    disc = [-1] * n\n    low = [-1] * n\n    bridges = []\n    time = 0\n\n    def dfs(n1, prev):\n        nonlocal time\n        disc[n1], low[n1] = time, time\n        time += 1\n\n        for n2 in graph[n1]:\n            if n2 == prev:\n                continue\n            if disc[n2] == -1:\n                dfs(n2, n1)\n                low[n1] = min(low[n1], low[n2])\n\n                if low[n2] &gt; disc[n1]:\n                    bridges.append([n1, n2])\n            else:\n                low[n1] = min(low[n1], disc[n2])\n\n    for i in range(n):\n        if disc[i] == -1:\n            dfs(i, -1)\n\n    return bridges\n\n\nn = 4\nconnections = [[0, 1], [1, 2], [2, 0], [1, 3]]\nprint(criticalConnections(n, connections))  # [[1, 3]]\n</code></pre>"},{"location":"graph-theory/topological_sort/","title":"Topological Sort","text":""},{"location":"graph-theory/topological_sort/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 207. Course Schedule (Medium)</li> <li> 210. Course Schedule II (Medium)</li> <li> 269. Alien Dictionary (Hard) \ud83d\udc51</li> <li> 1203. Sort Items by Groups Respecting Dependencies (Hard)</li> <li> 1857. Largest Color Value in a Directed Graph (Hard)</li> </ul>"},{"location":"graph-theory/topological_sort/#207-course-schedule","title":"207. Course Schedule","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Graph, Topological Sort</p> </li> </ul> PythonCPP <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS (Kahn's Algorithm)\ndef canFinishBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    count = 0\n\n    while q:\n        crs = q.popleft()\n        count += 1\n\n        for nxt in graph[crs]:\n            indegree[nxt] -= 1\n\n            if indegree[nxt] == 0:\n                q.append(nxt)\n\n    return count == numCourses\n\n\n# DFS + Set\ndef canFinishDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for crs, pre in prerequisites:\n        graph[crs].append(pre)\n\n    visiting = set()\n\n    def dfs(crs):\n        if crs in visiting:  # cycle detected\n            return False\n        if graph[crs] == []:\n            return True\n\n        visiting.add(crs)\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        visiting.remove(crs)\n        graph[crs] = []\n\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\n# DFS + List\ndef canFinishDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for pre, crs in prerequisites:\n        graph[crs].append(pre)\n\n    # 0: init, 1: visiting, 2: visited\n    status = [0] * numCourses\n\n    def dfs(crs):\n        if status[crs] == 1:  # cycle detected\n            return False\n        if status[crs] == 2:\n            return True\n\n        status[crs] = 1\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        status[crs] = 2\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(canFinishBFS(5, prerequisites))  # True\nprint(canFinishDFS1(5, prerequisites))  # True\nprint(canFinishDFS2(5, prerequisites))  # True\n</code></pre> <pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    // BFS\n    bool canFinishBFS(int numCourses, vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        vector&lt;int&gt; indegree(numCourses, 0);\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n            indegree[pre[0]]++;\n        }\n\n        queue&lt;int&gt; q;\n        for (int i = 0; i &lt; numCourses; i++) {\n            if (indegree[i] == 0) {\n                q.push(i);\n            }\n        }\n\n        int cnt = 0;\n        while (!q.empty()) {\n            int cur = q.front();\n            q.pop();\n            cnt++;\n\n            for (int nxt : graph[cur]) {\n                indegree[nxt]--;\n                if (indegree[nxt] == 0) {\n                    q.push(nxt);\n                }\n            }\n        }\n        return cnt == numCourses;\n    }\n\n    // DFS\n    bool canFinishDFS(int numCourses, vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n        }\n        // 0: not visited, 1: visiting, 2: visited\n        vector&lt;int&gt; state(numCourses, 0);\n\n        function&lt;bool(int)&gt; dfs = [&amp;](int pre) -&gt; bool {\n            state[pre] = 1;  // visiting\n            for (int crs : graph[pre]) {\n                if (state[crs] == 1 || (state[crs] == 0 &amp;&amp; dfs(crs))) {\n                    return true;\n                }\n            }\n            state[pre] = 2;  // visited\n            return false;\n        };\n\n        for (int i = 0; i &lt; numCourses; i++) {\n            if (state[i] == 0 &amp;&amp; dfs(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution sol;\n    vector&lt;vector&lt;int&gt;&gt; prerequisites = {{1, 0}, {2, 1}, {3, 2}, {4, 3},\n                                         {5, 4}, {6, 5}, {7, 6}, {8, 7},\n                                         {9, 8}, {10, 9}};\n    int numCourses = 11;\n    cout &lt;&lt; sol.canFinishBFS(numCourses, prerequisites) &lt;&lt; endl;\n    cout &lt;&lt; sol.canFinishDFS(numCourses, prerequisites) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"graph-theory/topological_sort/#210-course-schedule-ii","title":"210. Course Schedule II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Graph, Topological Sort</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return the ordering of courses you should take to finish all courses. If there are multiple valid answers, return any of them.\n\n![0207](../../assets/0207.png)\n\"\"\"\n\nfrom collections import defaultdict, deque\nfrom typing import List\n\n\n# 1. BFS - Kahn's Algorithm\ndef findOrderBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    order = []\n\n    while q:\n        pre = q.popleft()\n        order.append(pre)\n\n        for crs in graph[pre]:\n            indegree[crs] -= 1\n            if indegree[crs] == 0:\n                q.append(crs)\n\n    return order if len(order) == numCourses else []\n\n\n# 2. DFS + Set\ndef findOrderDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]:\n    adj = defaultdict(list)\n    for crs, pre in prerequisites:\n        adj[crs].append(pre)\n\n    visit, cycle = set(), set()\n    order = []\n\n    def dfs(crs):\n        if crs in cycle:\n            return False\n        if crs in visit:\n            return True\n\n        cycle.add(crs)\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        cycle.remove(crs)\n        visit.add(crs)\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order\n\n\n# 3. DFS + List\ndef findOrderDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]:\n    adj = defaultdict(list)\n    for pre, crs in prerequisites:\n        adj[crs].append(pre)\n\n    # 0: not visited, 1: visiting, 2: visited\n    state = [0] * numCourses\n    order = []\n\n    def dfs(crs):\n        if state[crs] == 1:\n            return False\n        if state[crs] == 2:\n            return True\n\n        state[crs] = 1\n\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        state[crs] = 2\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order[::-1]\n\n\nnumCourses = 5\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(findOrderBFS(numCourses, prerequisites))  # [2, 4, 3, 1, 0]\nprint(findOrderDFS1(numCourses, prerequisites))  # [4, 3, 1, 2, 0]\nprint(findOrderDFS2(numCourses, prerequisites))  # [4, 3, 2, 1, 0]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    // BFS\n    vector&lt;int&gt; findOrderBFS(int numCourses,\n                             vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        vector&lt;int&gt; in_degree(numCourses, 0);\n        vector&lt;int&gt; res;\n\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n            in_degree[pre[0]]++;\n        }\n\n        queue&lt;int&gt; q;\n        for (int i = 0; i &lt; numCourses; i++)\n            if (in_degree[i] == 0) q.push(i);\n\n        while (!q.empty()) {\n            int cur = q.front();\n            q.pop();\n            res.push_back(cur);\n\n            for (int next : graph[cur]) {\n                in_degree[next]--;\n                if (in_degree[next] == 0) q.push(next);\n            }\n        }\n\n        return (int)res.size() == numCourses ? res : vector&lt;int&gt;{};\n    }\n};\n\nint main() {\n    Solution obj;\n    vector&lt;vector&lt;int&gt;&gt; prerequisites{{1, 0}, {2, 0}, {3, 1}, {3, 2}};\n    vector&lt;int&gt; res = obj.findOrderBFS(4, prerequisites);\n    assert((res == vector&lt;int&gt;{0, 1, 2, 3} || res == vector&lt;int&gt;{0, 2, 1, 3}));\n    return 0;\n}\n</code></pre>"},{"location":"graph-theory/topological_sort/#269-alien-dictionary","title":"269. Alien Dictionary \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Depth First Search, Breadth First Search, Graph, Topological Sort</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the correct order of characters in the alien language.\n\"\"\"\n\nfrom collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS - Kahn's algorithm (Topological Sort)\ndef alienOrderBFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    indegree = {c: 0 for word in words for c in word}\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                    indegree[w2[j]] += 1\n                break\n\n    q = deque([c for c in indegree if indegree[c] == 0])\n    result = []\n\n    while q:\n        char = q.popleft()\n        result.append(char)\n\n        for neighbor in graph[char]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n\n    return \"\".join(result) if len(result) == len(indegree) else \"\"\n\n\n# DFS - Topological Sort\ndef alienOrderDFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    visited = {}\n    result = []\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                break\n\n    def dfs(c):\n        if c in visited:\n            return visited[c]\n\n        visited[c] = False\n        for neighbor in graph[c]:\n            if not dfs(neighbor):\n                return False\n\n        visited[c] = True\n        result.append(c)\n        return True\n\n    for c in list(graph.keys()):\n        if not dfs(c):\n            return \"\"\n\n    return \"\".join(result[::-1])\n\n\nwords = [\"wrt\", \"wrf\", \"er\", \"ett\", \"rftt\"]\nprint(alienOrderBFS(words))  # wertf\nprint(alienOrderDFS(words))  # wertf\n</code></pre>"},{"location":"graph-theory/topological_sort/#1203-sort-items-by-groups-respecting-dependencies","title":"1203. Sort Items by Groups Respecting Dependencies","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Graph, Topological Sort</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return any permutation of the items that satisfies the requirements.\n\"\"\"\n\nfrom collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS - Kahn's algorithm (Topological Sort)\ndef sortItems(\n    n: int, m: int, group: List[int], beforeItems: List[List[int]]\n) -&gt; List[int]:\n    def topological_sort(graph, indegree, nodes):\n        q = deque([node for node in nodes if indegree[node] == 0])\n        result = []\n\n        while q:\n            node = q.popleft()\n            result.append(node)\n\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    q.append(neighbor)\n\n        return result if len(result) == len(nodes) else []\n\n    groupItems = defaultdict(list)\n    groupGraph = defaultdict(set)\n    groupIndegree = defaultdict(int)\n    itemGraph = defaultdict(set)\n    itemIndegree = defaultdict(int)\n\n    for i in range(n):\n        if group[i] == -1:\n            group[i] = m\n            m += 1\n        groupItems[group[i]].append(i)\n\n    for i, beforeItem in enumerate(beforeItems):\n        for before in beforeItem:\n            if group[before] != group[i]:\n                if group[i] not in groupGraph[group[before]]:\n                    groupGraph[group[before]].add(group[i])\n                    groupIndegree[group[i]] += 1\n            else:\n                itemGraph[before].add(i)\n                itemIndegree[i] += 1\n\n    allGroups = list(set(group))\n    groupOrder = topological_sort(groupGraph, groupIndegree, allGroups)\n    if not groupOrder:\n        return []\n\n    result = []\n    for g in groupOrder:\n        items = groupItems[g]\n        itemOrder = topological_sort(itemGraph, itemIndegree, items)\n        if not itemOrder:\n            return []\n        result.extend(itemOrder)\n\n    return result\n\n\nn = 8\nm = 2\ngroup = [-1, -1, 1, 0, 0, 1, 0, -1]\nbeforeItems = [[], [6], [5], [6], [3, 6], [], [], []]\nprint(sortItems(n, m, group, beforeItems))\n</code></pre>"},{"location":"graph-theory/topological_sort/#1857-largest-color-value-in-a-directed-graph","title":"1857. Largest Color Value in a Directed Graph","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Dynamic Programming, Graph, Topological Sort, Memoization, Counting</p> </li> </ul> Python <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# Topological Sort\ndef largestPathValue(colors: str, edges: List[List[int]]) -&gt; int:\n    n = len(colors)\n    graph = defaultdict(list)\n    indegree = [0 for _ in range(n)]\n\n    for u, v in edges:\n        graph[u].append(v)\n        indegree[v] += 1\n\n    q = deque([i for i in range(n) if indegree[i] == 0])\n\n    dp = [[0] * 26 for _ in range(n)]\n\n    for i in range(n):\n        dp[i][ord(colors[i]) - ord(\"a\")] = 1\n\n    processed, max_color = 0, 0\n\n    while q:\n        n1 = q.popleft()\n        processed += 1\n        max_color = max(max_color, max(dp[n1]))\n\n        for n2 in graph[n1]:\n            indegree[n2] -= 1\n            for i in range(26):\n                dp[n2][i] = max(\n                    dp[n2][i],\n                    dp[n1][i] + (1 if i == ord(colors[n2]) - ord(\"a\") else 0),\n                )\n            if indegree[n2] == 0:\n                q.append(n2)\n\n    return max_color if processed == n else -1\n\n\ncolors = \"abaca\"\nedges = [[0, 1], [0, 2], [2, 3], [3, 4]]\nprint(largestPathValue(colors, edges))  # 3\n</code></pre>"},{"location":"graph-theory/union_find/","title":"Union Find","text":""},{"location":"graph-theory/union_find/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 721. Accounts Merge (Medium)</li> <li> 990. Satisfiability of Equality Equations (Medium)</li> <li> 1061. Lexicographically Smallest Equivalent String (Medium)</li> <li> 839. Similar String Groups (Hard)</li> </ul>"},{"location":"graph-theory/union_find/#721-accounts-merge","title":"721. Accounts Merge","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Depth First Search, Breadth First Search, Union Find, Sorting</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef accountsMerge(accounts: List[List[str]]) -&gt; List[List[str]]:\n    parent = defaultdict(str)\n    rank = defaultdict(int)\n    email_to_name = defaultdict(str)\n    merged_accounts = defaultdict(list)\n\n    def find(n):\n        p = parent[n]\n        while p != parent[p]:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    for account in accounts:\n        name = account[0]\n        first_email = account[1]\n\n        for email in account[1:]:\n            if email not in parent:\n                parent[email] = email\n                rank[email] = 1\n            email_to_name[email] = name\n            union(first_email, email)\n\n    for email in parent:\n        root_email = find(email)\n        merged_accounts[root_email].append(email)\n\n    result = []\n    for root_email, emails in merged_accounts.items():\n        result.append([email_to_name[root_email]] + sorted(emails))\n\n    return result\n\n\naccounts = [\n    [\"John\", \"johnsmith@mail.com\", \"john_newyork@mail.com\"],\n    [\"John\", \"johnsmith@mail.com\", \"john00@mail.com\"],\n    [\"Mary\", \"mary@mail.com\"],\n    [\"John\", \"johnnybravo@mail.com\"],\n]\nprint(accountsMerge(accounts))\n# [['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],\n# ['Mary', 'mary@mail.com'],\n# ['John', 'johnnybravo@mail.com']]\n</code></pre>"},{"location":"graph-theory/union_find/#990-satisfiability-of-equality-equations","title":"990. Satisfiability of Equality Equations","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Union Find, Graph</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef equationsPossible(equations: List[str]) -&gt; bool:\n    parent = defaultdict(str)\n    rank = defaultdict(int)\n\n    def find(n):\n        p = parent[n]\n        while p != parent[p]:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    for equation in equations:\n        if equation[0] not in parent:\n            parent[equation[0]] = equation[0]\n            rank[equation[0]] = 1\n        if equation[3] not in parent:\n            parent[equation[3]] = equation[3]\n            rank[equation[3]] = 1\n\n    for equation in equations:\n        if equation[1] == \"=\":\n            union(equation[0], equation[3])\n\n    for equation in equations:\n        if equation[1] == \"!\":\n            if find(equation[0]) == find(equation[3]):\n                return False\n\n    return True\n\n\nequations = [\"a==b\", \"b!=a\"]\nprint(equationsPossible(equations))  # False\n</code></pre>"},{"location":"graph-theory/union_find/#1061-lexicographically-smallest-equivalent-string","title":"1061. Lexicographically Smallest Equivalent String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Union Find</p> </li> </ul> Python <pre><code># Union Find\ndef smallestEquivalentString(s1: str, s2: str, baseStr: str) -&gt; str:\n    parent = {chr(i): chr(i) for i in range(ord(\"a\"), ord(\"z\") + 1)}\n\n    def find(n):\n        p = parent[n]\n        while parent[p] != p:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            if p1 &lt; p2:\n                parent[p2] = p1\n            else:\n                parent[p1] = p2\n\n    for i in range(len(s1)):\n        union(s1[i], s2[i])\n\n    result = []\n    for c in baseStr:\n        result.append(find(c))\n\n    return \"\".join(result)\n\n\nif __name__ == \"__main__\":\n    s1 = \"parker\"\n    s2 = \"morris\"\n    baseStr = \"parser\"\n    assert smallestEquivalentString(s1, s2, baseStr) == \"makkek\"\n</code></pre>"},{"location":"graph-theory/union_find/#839-similar-string-groups","title":"839. Similar String Groups","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Depth First Search, Breadth First Search, Union Find</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef numSimilarGroups(strs: List[str]) -&gt; int:\n    n = len(strs)\n    parent = list(range(n))\n    rank = [0 for _ in range(n)]\n\n    def find(n):\n        p = parent[n]\n        while parent[p] != p:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    def is_similar(s1, s2):\n        diff = 0\n        for c1, c2 in zip(s1, s2):\n            if c1 != c2:\n                diff += 1\n            if diff &gt; 2:\n                return False\n        return True\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_similar(strs[i], strs[j]):\n                union(i, j)\n\n    return sum(find(i) == i for i in range(n))\n\n\nstrs = [\"tars\", \"rats\", \"arts\", \"star\"]\nprint(numSimilarGroups(strs))  # 2\n</code></pre>"},{"location":"grind-75/array/","title":"Array","text":""},{"location":"grind-75/array/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1. Two Sum (Easy)</li> <li> 121. Best Time to Buy and Sell Stock (Easy)</li> <li> 169. Majority Element (Easy)</li> <li> 217. Contains Duplicate (Easy)</li> <li> 57. Insert Interval (Medium)</li> <li> 15. 3Sum (Medium)</li> <li> 238. Product of Array Except Self (Medium)</li> <li> 39. Combination Sum (Medium)</li> <li> 56. Merge Intervals (Medium)</li> <li> 75. Sort Colors (Medium)</li> <li> 11. Container With Most Water (Medium)</li> </ul>"},{"location":"grind-75/array/#1-two-sum","title":"1. Two Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return the indices of the two numbers such that they add up to a specific target.\n- Approach: Use a hashmap to store the indices of the numbers.\n- Time Complexity: O(n)\n- Space Complexity: O(n)\n\"\"\"\n\nfrom typing import List\n\n\ndef two_sum(nums: List[int], target: int) -&gt; List[int]:\n    hashmap = {}  # val: idx\n\n    for idx, val in enumerate(nums):\n        if (target - val) in hashmap:\n            return [hashmap[target - val], idx]\n\n        hashmap[val] = idx\n\n    return []\n\n\ndef test_two_sum():\n    assert two_sum([2, 7, 11, 15], 9) == [0, 1]\n    assert two_sum([3, 2, 4], 6) == [1, 2]\n    assert two_sum([3, 3], 6) == [0, 1]\n    assert two_sum([1, 2, 3, 4, 5], 10) == []\n    assert two_sum([-1, -2, -3, -4, -5], -8) == [2, 4]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Solution {\n   public:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {\n        unordered_map&lt;int, int&gt; map;\n\n        for (size_t i = 0; i &lt; nums.size(); i++) {\n            int diff = target - nums[i];\n            if (map.find(diff) != map.end()) {\n                return {map[diff], (int)i};\n            }\n            map[nums[i]] = (int)i;\n        }\n        return {-1, -1};\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; nums = {2, 7, 11, 15};\n    int target = 9;\n    vector&lt;int&gt; result = solution.twoSum(nums, target);\n    assert((result == vector&lt;int&gt;{0, 1}));\n    return 0;\n}\n</code></pre>"},{"location":"grind-75/array/#121-best-time-to-buy-and-sell-stock","title":"121. Best Time to Buy and Sell Stock","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return the maximum profit that can be achieved from buying on one day and selling on another day.\n\"\"\"\n\nfrom typing import List\n\n\n# Brute Force\ndef maxProfitBF(prices: List[int]) -&gt; int:\n    max_profit = 0\n    n = len(prices)\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_profit = max(max_profit, prices[j] - prices[i])\n\n    return max_profit\n\n\n# DP\ndef maxProfitDP(prices: List[int]) -&gt; int:\n    dp = [[0] * 2 for _ in range(len(prices))]\n    dp[0][0] = -prices[0]  # buy\n    dp[0][1] = 0  # sell\n\n    for i in range(1, len(prices)):\n        dp[i][0] = max(dp[i - 1][0], -prices[i])  # the lowest price to buy\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    max_profit = 0\n    seen_min = prices[0]\n\n    for i in range(1, len(prices)):\n        max_profit = max(max_profit, prices[i] - seen_min)\n        seen_min = min(seen_min, prices[i])\n\n    return max_profit\n\n\n# Fast Slow Pointers\ndef maxProfitFS(prices: List[int]) -&gt; int:\n    max_profit = 0\n    slow, fast = 0, 1\n\n    while fast &lt; len(prices):\n        if prices[fast] &gt; prices[slow]:\n            max_profit = max(max_profit, prices[fast] - prices[slow])\n        else:\n            slow = fast\n        fast += 1\n\n    return max_profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force|  O(n^2)|  O(1)   |\n# | DP         |  O(n)  |  O(n)   |\n# | Greedy     |  O(n)  |  O(1)   |\n# | Fast Slow  |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitBF(prices))  # 5\nprint(maxProfitDP(prices))  # 5\nprint(maxProfitGreedy(prices))  # 5\nprint(maxProfitFS(prices))  # 5\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int maxProfitMemo(vector&lt;int&gt; &amp;prices) {\n        if (prices.size() &lt;= 1) return 0;\n\n        int seen_min = prices[0];\n        int res = 0;\n\n        for (int &amp;price : prices) {\n            res = max(res, price - seen_min);\n            seen_min = min(seen_min, price);\n        }\n        return res;\n    }\n};\n\nint main() {\n    vector&lt;int&gt; prices = {7, 1, 5, 3, 6, 4};\n    Solution obj;\n    cout &lt;&lt; obj.maxProfitMemo(prices) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"grind-75/array/#169-majority-element","title":"169. Majority Element","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Divide And Conquer, Sorting, Counting</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the majority element in an array. The majority element is the element that appears more than `n // 2` times.\n\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/7pnhv842keE?si=fBYlNfKzdkiLgkF1\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen&gt;&lt;/iframe&gt;\n\n| `num` | `count` | `res` |\n| ----- | ------- | ----- |\n| 2     | 1       | 2     |\n| 2     | 2       | 2     |\n| 1     | 1       | 2     |\n| 1     | 0       | 2     |\n| 1     | 1       | 1     |\n| 2     | 0       | 1     |\n| 2     | 1       | 2     |\n\"\"\"\n\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Hash Map\ndef majorityElementHashMap(nums: List[int]) -&gt; int:\n    n = len(nums)\n    freq = defaultdict(int)\n\n    for num in nums:\n        freq[num] += 1\n        if freq[num] &gt; n // 2:\n            return num\n\n\n# Array - Boyer-Moore Voting Algorithm\ndef majorityElementArray(nums: List[int]) -&gt; int:\n    res = None\n    count = 0\n\n    for num in nums:\n        if count == 0:\n            res = num\n        count += 1 if num == res else -1\n\n    return res\n\n\n# | Algorithm | Time Complexity | Space Complexity |\n# |-----------|-----------------|------------------|\n# | HashMap   | O(N)            | O(N)             |\n# | Array     | O(N)            | O(1)             |\n# |-----------|-----------------|------------------|\n\n\nnums = [2, 2, 1, 1, 1, 2, 2]\nprint(majorityElementArray(nums))  # 2\nprint(majorityElementHashMap(nums))  # 2\n</code></pre>"},{"location":"grind-75/array/#217-contains-duplicate","title":"217. Contains Duplicate","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Sorting</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return True if the array contains any duplicates, otherwise return False.\n\"\"\"\n\nfrom typing import List\n\n\n# Brute Force\ndef containsDuplicateBF(nums: List[int]) -&gt; bool:\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] == nums[j]:\n                return True\n\n    return False\n\n\n# Sort\ndef containsDuplicateSort(nums: List[int]) -&gt; bool:\n    nums.sort()\n\n    for i in range(1, len(nums)):\n        if nums[i] == nums[i - 1]:\n            return True\n\n    return False\n\n\n# Set\ndef containsDuplicateSet(nums: List[int]) -&gt; bool:\n    seen = set()\n\n    for i in nums:\n        if i in seen:\n            return True\n        seen.add(i)\n\n    return False\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# | Brute Force |    O(n^2)       |    O(1)      |\n# |     Sort    |    O(n log n)   |    O(1)      |\n# |     Set     |    O(n)         |    O(n)      |\n# |-------------|-----------------|--------------|\n\nprint(containsDuplicateBF([1, 2, 3, 1]))  # True\nprint(containsDuplicateSort([1, 2, 3, 1]))  # True\nprint(containsDuplicateSet([1, 2, 3, 1]))  # True\n</code></pre>"},{"location":"grind-75/array/#57-insert-interval","title":"57. Insert Interval","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Interval\ndef insert(intervals: List[List[int]], newInterval: List[int]) -&gt; List[List[int]]:\n    n = len(intervals)\n\n    if n == 0:\n        return [newInterval]\n\n    if newInterval[1] &lt; intervals[0][0]:\n        return [newInterval] + intervals\n\n    if newInterval[0] &gt; intervals[-1][1]:\n        return intervals + [newInterval]\n\n    i = 0\n    result = []\n\n    while i &lt; n and intervals[i][1] &lt; newInterval[0]:\n        result.append(intervals[i])\n        i += 1\n\n    while i &lt; n and intervals[i][0] &lt;= newInterval[1]:\n        newInterval[0] = min(newInterval[0], intervals[i][0])\n        newInterval[1] = max(newInterval[1], intervals[i][1])\n        i += 1\n\n    result.append(newInterval)\n\n    while i &lt; n:\n        result.append(intervals[i])\n        i += 1\n\n    return result\n\n\nintervals = [[1, 3], [6, 9]]\nnewInterval = [2, 5]\nprint(insert(intervals, newInterval))  # [[1, 5], [6, 9]]\n</code></pre>"},{"location":"grind-75/array/#15-3sum","title":"15. 3Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Sorting</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef threeSum(nums: List[int]) -&gt; List[List[int]]:\n    nums.sort()\n    res = []\n    n = len(nums)\n\n    for i in range(n - 2):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        left, right = i + 1, n - 1\n\n        while left &lt; right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total &gt; 0:\n                right -= 1\n            elif total &lt; 0:\n                left += 1\n            else:\n                res.append([nums[i], nums[left], nums[right]])\n\n                while left &lt; right and nums[left] == nums[left + 1]:\n                    left += 1\n\n                while left &lt; right and nums[right] == nums[right - 1]:\n                    right -= 1\n\n                left += 1\n                right -= 1\n\n    return res\n\n\nnums = [-1, 0, 1, 2, -1, -4]\nassert threeSum(nums) == [[-1, -1, 2], [-1, 0, 1]]\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {\n    sort(nums.begin(), nums.end());\n    vector&lt;vector&lt;int&gt;&gt; res;\n    int n = nums.size();\n\n    for (int i = 0; i &lt; n - 2; i++) {\n        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) {\n            continue;\n        }\n\n        int left = i + 1, right = n - 1;\n\n        while (left &lt; right) {\n            int total = nums[i] + nums[left] + nums[right];\n\n            if (total &gt; 0)\n                right--;\n            else if (total &lt; 0)\n                left++;\n            else {\n                res.push_back({nums[i], nums[left], nums[right]});\n                while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++;\n                while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--;\n                left++;\n                right--;\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {-1, 0, 1, 2, -1, -4};\n    vector&lt;vector&lt;int&gt;&gt; res = threeSum(nums);\n    for (auto&amp; v : res) {\n        for (int i : v) {\n            cout &lt;&lt; i &lt;&lt; \" \";\n        }\n        cout &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"grind-75/array/#238-product-of-array-except-self","title":"238. Product of Array Except Self","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Prefix Sum</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Classic **Prefix Sum** problem\n-   Return an array `output` such that `output[i]` is equal to the product of all the elements of `nums` except `nums[i]`.\n\n| Approach           | Time | Space |\n| ------------------ | ---- | ----- |\n| Prefix             | O(n) | O(n)  |\n| Prefix (Optimized) | O(n) | O(1)  |\n\"\"\"\n\nfrom typing import List\n\n\n# Prefix\ndef productExceptSelf(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    prefix = [1 for _ in range(n)]\n    suffix = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        prefix[i] = nums[i - 1] * prefix[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        suffix[i] = nums[i + 1] * suffix[i + 1]\n\n    result = [i * j for i, j in zip(prefix, suffix)]\n\n    return result\n\n\n# Prefix (Optimized)\ndef productExceptSelfOptimized(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    result = [1 for _ in range(n)]\n\n    prefix = 1\n    for i in range(n):\n        result[i] = prefix\n        prefix *= nums[i]\n\n    suffix = 1\n    for i in range(n - 1, -1, -1):\n        result[i] *= suffix\n        suffix *= nums[i]\n\n    return result\n\n\nprint(productExceptSelf([1, 2, 3, 4]))\n# [24, 12, 8, 6]\nprint(productExceptSelfOptimized([1, 2, 3, 4]))\n# [24, 12, 8, 6]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt; &amp;nums) {\n        int n = nums.size();\n        vector&lt;int&gt; prefix(n, 1);\n        vector&lt;int&gt; suffix(n, 1);\n        vector&lt;int&gt; res(n, 1);\n\n        for (int i = 1; i &lt; n; i++) {\n            prefix[i] = prefix[i - 1] * nums[i - 1];\n        }\n\n        for (int i = n - 2; i &gt;= 0; i--) {\n            suffix[i] = suffix[i + 1] * nums[i + 1];\n        }\n\n        for (int i = 0; i &lt; n; i++) {\n            res[i] = prefix[i] * suffix[i];\n        }\n        return res;\n    }\n};\n\nint main() {\n    vector&lt;int&gt; nums = {1, 2, 3, 4};\n    Solution obj;\n    vector&lt;int&gt; result = obj.productExceptSelf(nums);\n    assert(result == vector&lt;int&gt;({24, 12, 8, 6}));\n    return 0;\n}\n</code></pre>"},{"location":"grind-75/array/#39-combination-sum","title":"39. Combination Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef combinationSum(candidates: List[int], target: int) -&gt; List[List[int]]:\n    n = len(candidates)\n    res, path = [], []\n\n    def dfs(total, start):\n        if total &gt; target:\n            return\n        if total == target:\n            res.append(path.copy())\n            return\n\n        for i in range(start, n):\n            total += candidates[i]\n            path.append(candidates[i])\n            dfs(total, i)\n            total -= candidates[i]\n            path.pop()\n\n    dfs(0, 0)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(combinationSum([2, 3, 5], 8))\n    # [[2, 2, 2, 2], [2, 3, 3], [3, 5]]\n    print(combinationSum([2, 3, 6, 7], 7))\n    # [[2, 2, 3], [7]]\n</code></pre>"},{"location":"grind-75/array/#56-merge-intervals","title":"56. Merge Intervals","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sorting</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Merge all overlapping intervals.\n\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/44H3cEC2fFM?si=J-Jr_Fg2eDse3-de\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen&gt;&lt;/iframe&gt;\n\"\"\"\n\nfrom typing import List\n\n\n# Intervals\ndef merge(intervals: List[List[int]]) -&gt; List[List[int]]:\n    n = len(intervals)\n    if n &lt;= 1:\n        return intervals\n\n    intervals.sort(key=lambda x: x[0])\n    res = [intervals[0]]\n\n    for i in range(1, n):\n        if intervals[i][0] &lt;= res[-1][1]:\n            res[-1][1] = max(res[-1][1], intervals[i][1])\n        else:\n            res.append(intervals[i])\n\n    return res\n\n\nprint(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))\n# [[1, 6], [8, 10], [15, 18]]\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// Interval\nvector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {\n    sort(intervals.begin(), intervals.end());\n    vector&lt;vector&lt;int&gt;&gt; res;\n\n    for (auto&amp; range : intervals) {\n        if (!res.empty() &amp;&amp; range[0] &lt;= res.back()[1]) {\n            res.back()[1] = max(res.back()[1], range[1]);\n        } else {\n            res.emplace_back(range);\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;vector&lt;int&gt;&gt; intervals = {{1, 3}, {2, 6}, {8, 10}, {15, 18}};\n    vector&lt;vector&lt;int&gt;&gt; res = merge(intervals);\n    for (auto&amp; range : res) {\n        cout &lt;&lt; range[0] &lt;&lt; \", \" &lt;&lt; range[1] &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"grind-75/array/#75-sort-colors","title":"75. Sort Colors","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Sorting</p> </li> </ul> Python <pre><code>from copy import deepcopy\nfrom typing import List\n\n\n# Left Right Pointers\ndef sort_colors_lr_pointers(nums: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    n = len(nums)\n    left = 0\n    for right in range(n):\n        if nums[right] == 0:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n\n    for right in range(left, n):\n        if nums[right] == 1:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n\n\n# Three Pointers\ndef sort_colors_three_pointers(nums: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    cur = 0\n\n    while cur &lt;= right:\n        if nums[cur] == 0:\n            nums[left], nums[cur] = nums[cur], nums[left]\n            left += 1\n            cur += 1\n        elif nums[cur] == 2:\n            nums[right], nums[cur] = nums[cur], nums[right]\n            right -= 1\n        else:\n            cur += 1\n\n\nnums = [2, 0, 2, 1, 1, 0]\nnums1, nums2 = deepcopy(nums), deepcopy(nums)\nsort_colors_lr_pointers(nums1)\nprint(nums1)  # [0, 0, 1, 1, 2, 2]\nsort_colors_three_pointers(nums2)\nprint(nums2)  # [0, 0, 1, 1, 2, 2]\n</code></pre>"},{"location":"grind-75/array/#11-container-with-most-water","title":"11. Container With Most Water","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Greedy</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return the maximum area of water that can be trapped between the vertical lines.\n\n![11](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)\n\"\"\"\n\nfrom typing import List\n\n\n# Brute Force\ndef maxAreaBF(height: List[int]) -&gt; int:\n    max_area = 0\n\n    for i in range(len(height)):\n        for j in range(i + 1, len(height)):\n            h = min(height[i], height[j])\n            w = j - i\n            max_area = max(max_area, h * w)\n\n    return max_area\n\n\n# Left Right Pointers\ndef maxAreaLR(height: List[int]) -&gt; int:\n    left, right = 0, len(height) - 1\n    res = 0\n\n    while left &lt; right:\n        h = min(height[left], height[right])\n        w = right - left\n        res = max(res, h * w)\n\n        if height[left] &lt; height[right]:\n            left += 1\n        else:\n            right -= 1\n\n    return res\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force| O(n^2) |  O(1)   |\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nheight = [1, 8, 6, 2, 5, 4, 8, 3, 7]\nprint(maxAreaBF(height))  # 49\nprint(maxAreaLR(height))  # 49\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint maxArea(vector&lt;int&gt;&amp; height) {\n    int left = 0, right = height.size() - 1;\n    int res = 0;\n\n    while (left &lt; right) {\n        int h = min(height[left], height[right]);\n        int w = right - left;\n        res = max(res, h * w);\n\n        if (height[left] &lt; height[right])\n            left++;\n        else\n            right--;\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; height = {1, 8, 6, 2, 5, 4, 8, 3, 7};\n    cout &lt;&lt; maxArea(height) &lt;&lt; endl;  // 49\n    return 0;\n}\n</code></pre>"},{"location":"grind-75/binary/","title":"Binary","text":""},{"location":"grind-75/binary/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 67. Add Binary (Easy)</li> </ul>"},{"location":"grind-75/binary/#67-add-binary","title":"67. Add Binary","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String, Bit Manipulation, Simulation</p> </li> </ul>"},{"location":"grind-75/binary_search/","title":"Binary Search","text":""},{"location":"grind-75/binary_search/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 704. Binary Search (Easy)</li> <li> 278. First Bad Version (Easy)</li> <li> 33. Search in Rotated Sorted Array (Medium)</li> <li> 981. Time Based Key-Value Store (Medium)</li> <li> 1235. Maximum Profit in Job Scheduling (Hard)</li> </ul>"},{"location":"grind-75/binary_search/#704-binary-search","title":"704. Binary Search","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> Python <pre><code>\"\"\"\n- Implement binary search algorithm.\n\"\"\"\n\nfrom typing import List\n\n\n# Binary Search [left, right]\ndef search(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] &lt; target:\n            left = mid + 1\n        elif nums[mid] &gt; target:\n            right = mid - 1\n        else:\n            return mid\n\n    return -1\n\n\n# Binary Search [left, right)\ndef search_half_open(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums)\n\n    while left &lt; right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] &lt; target:\n            left = mid + 1\n        elif nums[mid] &gt; target:\n            right = mid\n        else:\n            return mid\n\n    return -1\n\n\n# Binary Search (left, right)\ndef search_open_interval(nums: List[int], target: int) -&gt; int:\n    left, right = -1, len(nums)\n\n    while left + 1 &lt; right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] &lt; target:\n            left = mid\n        elif nums[mid] &gt; target:\n            right = mid\n        else:\n            return mid\n\n    return -1\n\n\nif __name__ == \"__main__\":\n    nums = [-1, 0, 3, 5, 9, 12]\n    target = 9\n    assert search(nums, target) == 4\n    assert search_half_open(nums, target) == 4\n    assert search_open_interval(nums, target) == 4\n</code></pre>"},{"location":"grind-75/binary_search/#278-first-bad-version","title":"278. First Bad Version","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Binary Search, Interactive</p> </li> </ul> Python <pre><code>\"\"\"\n-   Find the first bad version given a function `isBadVersion`.\n\"\"\"\n\n\n# Binary Search\ndef firstBadVersion(n: int) -&gt; int:\n    left, right = 1, n\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if isBadVersion(mid):\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return left\n\n\ndef isBadVersion(version: int) -&gt; bool:\n    pass\n</code></pre>"},{"location":"grind-75/binary_search/#33-search-in-rotated-sorted-array","title":"33. Search in Rotated Sorted Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Binary Search\ndef search(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] == target:\n            return mid\n\n        if nums[left] &lt;= nums[mid]:\n            if nums[left] &lt;= target &lt; nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if nums[mid] &lt; target &lt;= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n    return -1\n\n\nnums = [4, 5, 6, 7, 0, 1, 2]\ntarget = 0\nprint(search(nums, target))  # 4\n</code></pre>"},{"location":"grind-75/binary_search/#981-time-based-key-value-store","title":"981. Time Based Key-Value Store","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Binary Search, Design</p> </li> </ul> Python <pre><code>from collections import defaultdict\n\n\n# Binary Search\nclass TimeMap:\n\n    def __init__(self):\n        self.keys = defaultdict(list)\n        self.times = dict()\n\n    def set(self, key: str, value: str, timestamp: int) -&gt; None:\n        self.keys[key].append(timestamp)\n        self.times[timestamp] = value\n\n    def get(self, key: str, timestamp: int) -&gt; str:\n        tmp = self.keys[key]\n\n        left, right = 0, len(tmp) - 1\n        while left &lt;= right:\n            mid = left + (right - left) // 2\n            if tmp[mid] &gt; timestamp:\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        return self.times[tmp[right]] if right &gt;= 0 else \"\"\n\n\nobj = TimeMap()\nobj.set(\"foo\", \"bar\", 1)\nprint(obj.get(\"foo\", 1))  # bar\nprint(obj.get(\"foo\", 3))  # bar\nobj.set(\"foo\", \"bar2\", 4)\nprint(obj.get(\"foo\", 4))  # bar2\nprint(obj.get(\"foo\", 5))  # bar2\n</code></pre>"},{"location":"grind-75/binary_search/#1235-maximum-profit-in-job-scheduling","title":"1235. Maximum Profit in Job Scheduling","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Dynamic Programming, Sorting</p> </li> </ul>"},{"location":"grind-75/binary_search_tree/","title":"Binary Search Tree","text":""},{"location":"grind-75/binary_search_tree/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 235. Lowest Common Ancestor of a Binary Search Tree (Medium)</li> <li> 98. Validate Binary Search Tree (Medium)</li> <li> 230. Kth Smallest Element in a BST (Medium)</li> </ul>"},{"location":"grind-75/binary_search_tree/#235-lowest-common-ancestor-of-a-binary-search-tree","title":"235. Lowest Common Ancestor of a Binary Search Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Search Tree, Binary Tree</p> </li> </ul> Python <pre><code>from binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef lowestCommonAncestor(root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\") -&gt; \"TreeNode\":\n    while root:\n        if root.val &gt; p.val and root.val &gt; q.val:\n            root = root.left\n        elif root.val &lt; p.val and root.val &lt; q.val:\n            root = root.right\n        else:\n            return root\n\n\nroot = [6, 2, 8, 0, 4, 7, 9, None, None, 3, 5]\nroot = build(root)\np = root.left\nq = root.right\nprint(root)\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\nprint(lowestCommonAncestor(root, p, q))\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\n</code></pre>"},{"location":"grind-75/binary_search_tree/#98-validate-binary-search-tree","title":"98. Validate Binary Search Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Search Tree, Binary Tree</p> </li> </ul> PythonCPP <pre><code>from itertools import pairwise\nfrom math import inf\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef isValidBST1(root: Optional[TreeNode]) -&gt; bool:\n    inorder = []  # inorder traversal\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    for a, b in pairwise(inorder):\n        if a &gt;= b:\n            return False\n\n    return True\n\n\ndef isValidBST2(root: Optional[TreeNode]) -&gt; bool:\n    if not root:\n        return True\n    pre = -inf\n\n    def dfs(node):\n        if not node:\n            return True\n        if not dfs(node.left):\n            return False\n\n        nonlocal pre\n        if node.val &lt;= pre:\n            return False\n        pre = node.val\n\n        return dfs(node.right)\n\n    return dfs(root)\n\n\nif __name__ == \"__main__\":\n    root = [5, 1, 4, None, None, 3, 6]\n    root = build(root)\n    print(root)\n    #   5__\n    #  /   \\\n    # 1     4\n    #      / \\\n    #     3   6\n    assert not isValidBST1(root)  # [1, 5, 3, 4, 6]\n    assert not isValidBST2(root)  # [1, 5, 3, 4, 6]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   private:\n    vector&lt;int&gt; inorder;\n    bool check(vector&lt;int&gt; inorder) {\n        int n = inorder.size();\n        if (n &lt;= 1) return true;\n        for (int i = 1; i &lt; n; i++) {\n            if (inorder[i] &lt;= inorder[i - 1]) return false;\n        }\n        return true;\n    }\n\n   public:\n    bool isValidBST(TreeNode *root) {\n        auto dfs = [&amp;](auto &amp;&amp;self, TreeNode *node) -&gt; void {\n            if (!node) return;\n\n            self(self, node-&gt;left);\n            inorder.push_back(node-&gt;val);\n            self(self, node-&gt;right);\n        };\n\n        dfs(dfs, root);\n\n        return check(inorder);\n    }\n};\n\nint main() {\n    Solution s;\n    TreeNode *root = new TreeNode(2);\n    root-&gt;left = new TreeNode(1);\n    root-&gt;right = new TreeNode(3);\n    assert(s.isValidBST(root) == true);\n\n    root = new TreeNode(5);\n    root-&gt;left = new TreeNode(1);\n    root-&gt;right = new TreeNode(4);\n    root-&gt;right-&gt;left = new TreeNode(3);\n    root-&gt;right-&gt;right = new TreeNode(6);\n    assert(s.isValidBST(root) == false);\n\n    root = new TreeNode(5);\n    root-&gt;left = new TreeNode(4);\n    root-&gt;right = new TreeNode(6);\n    root-&gt;right-&gt;left = new TreeNode(3);\n    root-&gt;right-&gt;right = new TreeNode(7);\n    assert(s.isValidBST(root) == false);\n\n    return 0;\n}\n</code></pre>"},{"location":"grind-75/binary_search_tree/#230-kth-smallest-element-in-a-bst","title":"230. Kth Smallest Element in a BST","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Search Tree, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef kthSmallestRecursive(root: Optional[TreeNode], k: int) -&gt; int:\n    inorder = []\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n    return inorder[k - 1]\n\n\n# Iteratve\ndef kthSmallestIteratve(root: Optional[TreeNode], k: int) -&gt; int:\n    stack = []\n    while True:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        k -= 1\n        if not k:\n            return root.val\n        root = root.right\n\n\nif __name__ == \"__main__\":\n    root = build([3, 1, 4, None, 2])\n    k = 1\n    assert kthSmallestRecursive(root, k) == 1\n    assert kthSmallestIteratve(root, k) == 1\n</code></pre>"},{"location":"grind-75/binary_tree/","title":"Binary Tree","text":""},{"location":"grind-75/binary_tree/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 226. Invert Binary Tree (Easy)</li> <li> 110. Balanced Binary Tree (Easy)</li> <li> 543. Diameter of Binary Tree (Easy)</li> <li> 104. Maximum Depth of Binary Tree (Easy)</li> <li> 102. Binary Tree Level Order Traversal (Medium)</li> <li> 236. Lowest Common Ancestor of a Binary Tree (Medium)</li> <li> 199. Binary Tree Right Side View (Medium)</li> <li> 105. Construct Binary Tree from Preorder and Inorder Traversal (Medium)</li> <li> 297. Serialize and Deserialize Binary Tree (Hard)</li> </ul>"},{"location":"grind-75/binary_tree/#226-invert-binary-tree","title":"226. Invert Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef invertTreeRecursive(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    root.left, root.right = root.right, root.left\n\n    invertTreeRecursive(root.left)\n    invertTreeRecursive(root.right)\n\n    return root\n\n\n# Iterative\ndef invertTreeIterative(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    stack = [root]\n\n    while stack:\n        node = stack.pop()\n\n        node.left, node.right = node.right, node.left\n        if node.left:\n            stack.append(node.left)\n        if node.right:\n            stack.append(node.right)\n\n    return root\n\n\nroot = build([4, 2, 7, 1, 3, 6, 9])\nprint(root)\n#     __4__\n#    /     \\\n#   2       7\n#  / \\     / \\\n# 1   3   6   9\ninvertedRecursive = invertTreeRecursive(root)\nprint(invertedRecursive)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\nroot = build([4, 2, 7, 1, 3, 6, 9])\ninvertedIterative = invertTreeIterative(root)\nprint(invertedIterative)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\n</code></pre>"},{"location":"grind-75/binary_tree/#110-balanced-binary-tree","title":"110. Balanced Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef isBalanced(root: Optional[TreeNode]) -&gt; bool:\n    def getHeight(node):\n        if not node:\n            return 0\n\n        # post order\n        leftHeight = getHeight(node.left)\n        rightHeight = getHeight(node.right)\n\n        if leftHeight == -1 or rightHeight == -1:\n            return -1\n\n        if abs(leftHeight - rightHeight) &gt; 1:\n            return -1\n        else:\n            return 1 + max(leftHeight, rightHeight)\n\n    if getHeight(root) != -1:\n        return True\n    else:\n        return False\n\n\nroot = [3, 9, 20, None, None, 15, 7]\nroot = build(root)\nprint(root)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(isBalanced(root))  # True\n</code></pre>"},{"location":"grind-75/binary_tree/#543-diameter-of-binary-tree","title":"543. Diameter of Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul> PythonCPP <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Tree DFS\nclass Solution:\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -&gt; int:\n        self.diameter = 0\n\n        def dfs(node):\n            if not node:\n                return 0\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n            self.diameter = max(self.diameter, left + right)\n\n            return 1 + max(left, right)\n\n        dfs(root)\n\n        return self.diameter\n\n\nroot = build([1, 2, 3, 4, 5])\nprint(root)\n#     __1\n#    /   \\\n#   2     3\n#  / \\\n# 4   5\nobj = Solution()\nprint(obj.diameterOfBinaryTree(root))  # 3\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nint diameterOfBinaryTree(TreeNode* root) {\n    int diameter = 0;\n\n    auto dfs = [&amp;](auto&amp;&amp; self, TreeNode* node) -&gt; int {\n        if (!node) return 0;\n        int left = self(self, node-&gt;left);\n        int right = self(self, node-&gt;right);\n\n        diameter = max(diameter, left + right);\n\n        return 1 + max(left, right);\n    };\n\n    dfs(dfs, root);\n    return diameter;\n}\n\nint main() {\n    // [1, 2, 3, 4, 5]\n    TreeNode* root = new TreeNode(1);\n    root-&gt;left = new TreeNode(2);\n    root-&gt;right = new TreeNode(3);\n    root-&gt;left-&gt;left = new TreeNode(4);\n    root-&gt;left-&gt;right = new TreeNode(5);\n    cout &lt;&lt; diameterOfBinaryTree(root) &lt;&lt; endl;  // 3\n\n    return 0;\n}\n</code></pre>"},{"location":"grind-75/binary_tree/#104-maximum-depth-of-binary-tree","title":"104. Maximum Depth of Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef maxDepthRecursive(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    left = maxDepthRecursive(root.left)\n    right = maxDepthRecursive(root.right)\n\n    return 1 + max(left, right)\n\n\n# DFS\ndef maxDepthDFS(root: Optional[TreeNode]) -&gt; int:\n    res = 0\n\n    def dfs(node, cnt):\n        if node is None:\n            return\n        cnt += 1\n        nonlocal res\n        res = max(res, cnt)\n\n        dfs(node.left, cnt)\n        dfs(node.right, cnt)\n\n    dfs(root, 0)\n\n    return res\n\n\n# Iterative\ndef maxDepthIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n    res = 0\n\n    while q:\n        res += 1\n        n = len(q)\n\n        for _ in range(n):\n            node = q.popleft()\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    root = [1, 2, 2, 3, 4, None, None, None, None, 5]\n    root = build(root)\n    print(root)\n    #     ____1\n    #    /     \\\n    #   2__     2\n    #  /   \\\n    # 3     4\n    #      /\n    #     5\n    assert maxDepthRecursive(root) == 4\n    assert maxDepthDFS(root) == 4\n    assert maxDepthIterative(root) == 4\n</code></pre>"},{"location":"grind-75/binary_tree/#102-binary-tree-level-order-traversal","title":"102. Binary Tree Level Order Traversal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef levelOrder(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        level = []\n        size = len(q)\n\n        for _ in range(size):\n            cur = q.popleft()\n            level.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(level)\n\n    return res\n\n\ntree = build([3, 9, 20, None, None, 15, 7])\nprint(tree)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(levelOrder(tree))  # [[3], [9, 20], [15, 7]]\n</code></pre>"},{"location":"grind-75/binary_tree/#236-lowest-common-ancestor-of-a-binary-tree","title":"236. Lowest Common Ancestor of a Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul> PythonCPP <pre><code>from typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass LowestCommonAncestor:\n    def lowestCommonAncestor(\n        self, root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n    ) -&gt; \"TreeNode\":\n        if not root or q == root or p == root:\n            return root\n\n        left = self.lowestCommonAncestor(root.left, p, q)\n        right = self.lowestCommonAncestor(root.right, p, q)\n\n        if left and right:\n            return root\n\n        return left or right\n\n\nif __name__ == \"__main__\":\n    root = build([3, 5, 1, 6, 2, 0, 8, None, None, 7, 4])\n    print(root)\n    #     ______3__\n    #    /         \\\n    #   5__         1\n    #  /   \\       / \\\n    # 6     2     0   8\n    #      / \\\n    #     7   4\n    p = root.left  # 5\n    q = root.right  # 1\n    sol = LowestCommonAncestor()\n    print(sol.lowestCommonAncestor(root, p, q))\n    #     ______3__\n    #    /         \\\n    #   5__         1\n    #  /   \\       / \\\n    # 6     2     0   8\n    #      / \\\n    #     7   4\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   public:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if (root == nullptr || root == p || root == q) {\n            return root;\n        }\n\n        TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);\n        TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);\n\n        if (left &amp;&amp; right) {\n            return root;\n        }\n\n        return left ? left : right;\n    }\n};\n\nint main() { return 0; }\n</code></pre>"},{"location":"grind-75/binary_tree/#199-binary-tree-right-side-view","title":"199. Binary Tree Right Side View","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Binary Tree BFS\ndef rightSideViewBFS(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        n = len(q)\n        for i in range(n):\n            node = q.popleft()\n            if i == n - 1:\n                res.append(node.val)\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return res\n\n\n# Binary Tree DFS\ndef rightSideViewDFS(root: Optional[TreeNode]) -&gt; List[int]:\n    \"\"\"\u540e\u5e8f\u904d\u5386\uff0c\u5148\u53f3\u540e\u5de6\uff0c\u9047\u5230\u7684\u7b2c\u4e00\u4e2a\u8282\u70b9\u5c31\u662f\u8be5\u6df1\u5ea6\u7684\u6700\u53f3\u4fa7\u8282\u70b9\"\"\"\n    ans = []\n\n    def dfs(node, depth):\n        if node is None:\n            return\n        if depth == len(ans):  # \u8fd9\u4e2a\u6df1\u5ea6\u9996\u6b21\u9047\u5230\n            ans.append(node.val)\n\n        dfs(node.right, depth + 1)\n        dfs(node.left, depth + 1)\n\n    dfs(root, 0)\n\n    return ans\n\n\nif __name__ == \"__main__\":\n    root = [1, 2, 2, 3, 4, None, 3, None, None, 5]\n    root = build(root)\n    print(root)\n    #     ____1\n    #    /     \\\n    #   2__     2\n    #  /   \\     \\\n    # 3     4     3\n    #      /\n    #     5\n    assert rightSideViewBFS(root) == [1, 2, 3, 5]\n    assert rightSideViewDFS(root) == [1, 2, 3, 5]\n</code></pre>"},{"location":"grind-75/binary_tree/#105-construct-binary-tree-from-preorder-and-inorder-traversal","title":"105. Construct Binary Tree from Preorder and Inorder Traversal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Divide And Conquer, Tree, Binary Tree</p> </li> </ul> PythonCPP <pre><code>from typing import List, Optional\n\nfrom helper import TreeNode\n\n\ndef buildTree(preorder: List[int], inorder: List[int]) -&gt; Optional[TreeNode]:\n    \"\"\"\n    preorder  root left right  1  2  3\n    inorder   left root right  4  5  6\n    \"\"\"\n    if len(preorder) == 0:\n        return None\n\n    root_val = preorder[0]  # 1\n    root = TreeNode(root_val)\n\n    separator_idx = inorder.index(root_val)  # 5\n\n    left_inorder = inorder[:separator_idx]  # 4\n    right_inorder = inorder[separator_idx + 1 :]  # 6\n\n    left_preorder = preorder[1 : 1 + len(left_inorder)]  # 2\n    right_preorder = preorder[1 + len(left_inorder) :]  # 3\n\n    root.left = buildTree(left_preorder, left_inorder)\n    root.right = buildTree(right_preorder, right_inorder)\n\n    return root\n\n\npreorder = [3, 9, 20, 15, 7]\ninorder = [9, 3, 15, 20, 7]\nroot = buildTree(preorder, inorder)\nprint(root)\n#     3\n#    / \\\n#   9  20\n#     /  \\\n#    15   7\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   public:\n    vector&lt;int&gt; preorder;\n    unordered_map&lt;int, int&gt; inorderMap;\n\n    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {\n        this-&gt;preorder = preorder;\n        for (size_t i = 0; i &lt; inorder.size(); i++) {\n            inorderMap[inorder[i]] = i;\n        }\n        return buildSubtree(0, 0, inorder.size() - 1);\n    }\n\n   private:\n    TreeNode* buildSubtree(int rootIndex, int left, int right) {\n        if (left &gt; right) return nullptr;\n\n        TreeNode* root = new TreeNode(preorder[rootIndex]);\n        int inorderIndex = inorderMap[preorder[rootIndex]];\n\n        root-&gt;left = buildSubtree(rootIndex + 1, left, inorderIndex - 1);\n        root-&gt;right = buildSubtree(rootIndex + (inorderIndex - left + 1),\n                                   inorderIndex + 1, right);\n\n        return root;\n    }\n};\n\nint main() {\n    vector&lt;int&gt; preorder = {3, 9, 20, 15, 7};\n    vector&lt;int&gt; inorder = {9, 3, 15, 20, 7};\n    Solution solution;\n    TreeNode* root = solution.buildTree(preorder, inorder);\n    cout &lt;&lt; root-&gt;val &lt;&lt; endl;                // 3\n    cout &lt;&lt; root-&gt;left-&gt;val &lt;&lt; endl;          // 9\n    cout &lt;&lt; root-&gt;right-&gt;val &lt;&lt; endl;         // 20\n    cout &lt;&lt; root-&gt;right-&gt;left-&gt;val &lt;&lt; endl;   // 15\n    cout &lt;&lt; root-&gt;right-&gt;right-&gt;val &lt;&lt; endl;  // 7\n    return 0;\n}\n</code></pre>"},{"location":"grind-75/binary_tree/#297-serialize-and-deserialize-binary-tree","title":"297. Serialize and Deserialize Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Tree, Depth First Search, Breadth First Search, Design, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BFS\nclass BFS:\n    def serialize(self, root: Optional[TreeNode]) -&gt; str:\n        if not root:\n            return \"\"\n\n        res = []\n        q = deque([root])\n\n        while q:\n            node = q.popleft()\n\n            if node:\n                res.append(str(node.val))\n                q.append(node.left)\n                q.append(node.right)\n            else:\n                res.append(\"null\")\n\n        return \",\".join(res)\n\n    def deserialize(self, data: str) -&gt; Optional[TreeNode]:\n        if not data:\n            return None\n\n        nodes = data.split(\",\")\n        root = TreeNode(int(nodes[0]))\n        q = deque([root])\n        index = 1\n\n        while q:\n            node = q.popleft()\n\n            if nodes[index] != \"null\":\n                node.left = TreeNode(int(nodes[index]))\n                q.append(node.left)\n            index += 1\n\n            if nodes[index] != \"null\":\n                node.right = TreeNode(int(nodes[index]))\n                q.append(node.right)\n            index += 1\n\n        return root\n\n\n# DFS\nclass DFS:\n    def serialize(self, root: Optional[TreeNode]) -&gt; str:\n        def dfs(node):\n            if not node:\n                return [\"null\"]\n            return [str(node.val)] + dfs(node.left) + dfs(node.right)\n\n        return \",\".join(dfs(root))\n\n    def deserialize(self, data: str) -&gt; Optional[TreeNode]:\n        nodes = data.split(\",\")\n        self.index = 0\n\n        def dfs():\n            if nodes[self.index] == \"null\":\n                self.index += 1\n                return None\n\n            node = TreeNode(int(nodes[self.index]))\n            self.index += 1\n\n            node.left = dfs()\n            node.right = dfs()\n\n            return node\n\n        root = dfs()\n        return root\n\n\nroot = build([1, 2, 3, None, None, 4, 5])\nprint(root)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n\nbfs = BFS()\ndata1 = bfs.serialize(root)\nprint(data1)  # \"1,2,3,null,null,4,5,null,null,null,null\"\nroot1 = bfs.deserialize(data1)\nprint(root1)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n\ndfs = DFS()\ndata2 = dfs.serialize(root)\nprint(data2)  # \"1,2,null,null,3,4,null,null,5,null,null\"\nroot2 = dfs.deserialize(data2)\nprint(root2)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n</code></pre>"},{"location":"grind-75/dynamic_programming/","title":"Dynamic Programming","text":""},{"location":"grind-75/dynamic_programming/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 70. Climbing Stairs (Easy)</li> <li> 53. Maximum Subarray (Medium)</li> <li> 322. Coin Change (Medium)</li> <li> 416. Partition Equal Subset Sum (Medium)</li> <li> 62. Unique Paths (Medium)</li> </ul>"},{"location":"grind-75/dynamic_programming/#70-climbing-stairs","title":"70. Climbing Stairs","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Memoization</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return the number of distinct ways to reach the top of the stairs.\n- `dp[n]` stores the number of distinct ways to reach the `n-th` stair.\n- Formula: `dp[n] = dp[n - 1] + dp[n - 2]`.\n- Initialize `dp[0] = 0`, `dp[1] = 1`, and `dp[2] = 2`.\n\"\"\"\n\nfrom functools import cache\n\n\n# DP\ndef climbStairsDP(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    dp = [i for i in range(n + 1)]\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\n# DP (Optimized)\ndef climbStairsDPOptimized(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    first, second = 1, 2\n\n    for _ in range(3, n + 1):\n        first, second = second, first + second\n\n    return second\n\n\n# Recursion\ndef climbStairsRecursion(n: int) -&gt; int:\n    @cache\n    def dfs(i: int) -&gt; int:\n        if i &lt;= 1:\n            return 1\n        return dfs(i - 1) + dfs(i - 2)\n\n    return dfs(n)\n\n\n# Greedy\ndef climbStairsGreedy(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    p1, p2 = 1, 2\n\n    for _ in range(3, n + 1):\n        p1, p2 = p2, p1 + p2\n\n    return p2\n\n\nif __name__ == \"__main__\":\n    assert climbStairsDP(10) == 89\n    assert climbStairsDPOptimized(10) == 89\n    assert climbStairsRecursion(10) == 89\n    assert climbStairsGreedy(10) == 89\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nint climbStairs(int n) {\n    if (n &lt;= 2) return n;\n    int f1 = 1, f2 = 2;\n    int res;\n\n    int i = 3;\n    while (i &lt;= n) {\n        res = f1 + f2;\n        f1 = f2;\n        f2 = res;\n        i++;\n    }\n    return res;\n}\n\nint main() {\n    assert(climbStairs(2) == 2);\n    assert(climbStairs(5) == 8);\n    assert(climbStairs(10) == 89);\n    return 0;\n}\n</code></pre>"},{"location":"grind-75/dynamic_programming/#53-maximum-subarray","title":"53. Maximum Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Divide And Conquer, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP Kadane\ndef maxSubArrayDP(nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n\n    dp[0] = nums[0]\n    maxSum = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(\n            dp[i - 1] + nums[i],  # continue the previous subarray\n            nums[i],  # start a new subarray\n        )\n        maxSum = max(maxSum, dp[i])\n\n    return maxSum\n\n\n# Greedy\ndef maxSubArrayGreedy(nums: List[int]) -&gt; int:\n    max_sum = nums[0]\n    cur_sum = 0\n\n    for num in nums:\n        cur_sum = max(cur_sum + num, num)\n        max_sum = max(max_sum, cur_sum)\n\n    return max_sum\n\n\n# Prefix Sum\ndef maxSubArrayPrefixSum(nums: List[int]) -&gt; int:\n    prefix_sum = 0\n    prefix_sum_min = 0\n    res = float(\"-inf\")\n\n    for num in nums:\n        prefix_sum += num\n        res = max(res, prefix_sum - prefix_sum_min)\n        prefix_sum_min = min(prefix_sum_min, prefix_sum)\n\n    return res\n\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArrayDP(nums))  # 6\nprint(maxSubArrayGreedy(nums))  # 6\nprint(maxSubArrayPrefixSum(nums))  # 6\n</code></pre>"},{"location":"grind-75/dynamic_programming/#322-coin-change","title":"322. Coin Change","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Breadth First Search</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef coinChange(coins: List[int], amount: int) -&gt; int:\n    dp = [float(\"inf\") for _ in range(amount + 1)]\n\n    dp[0] = 0\n\n    for i in range(1, amount + 1):\n        for c in coins:\n            if i - c &gt;= 0:\n                dp[i] = min(dp[i], 1 + dp[i - c])\n\n    return dp[amount] if dp[amount] != float(\"inf\") else -1\n\n\ncoins = [1, 2, 5]\namount = 11\nprint(coinChange(coins, amount))  # 3\n</code></pre>"},{"location":"grind-75/dynamic_programming/#416-partition-equal-subset-sum","title":"416. Partition Equal Subset Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>from functools import cache\nfrom typing import List\n\nfrom leetpattern.utils import knapsack01\n\n\n# Memoization\ndef canPartitionMemoization(nums: List[int]) -&gt; bool:\n    total = sum(nums)\n    n = len(nums)\n\n    if total % 2 == 1 or n &lt;= 1:\n        return False\n\n    @cache\n    def dfs(i, j):\n        if i &lt; 0:\n            return j == 0\n        return j &gt;= nums[i] and dfs(i - 1, j - nums[i]) or dfs(i - 1, j)\n\n    return dfs(n - 1, total // 2)\n\n\n# DP - Knapsack 01\ndef canPartitionTemplate(nums: List[int]) -&gt; bool:\n    total = sum(nums)\n\n    if total % 2 == 1 or len(nums) &lt; 2:\n        return False\n\n    target = total // 2\n\n    return knapsack01(nums, nums, target) == target\n\n\n# DP - Knapsack 01\ndef canPartition(nums: List[int]) -&gt; bool:\n    total = sum(nums)\n\n    if total % 2 == 1 or len(nums) &lt; 2:\n        return False\n\n    target = total // 2\n\n    dp = [0 for _ in range(target + 1)]\n\n    for i in range(len(nums)):\n        for j in range(target, nums[i] - 1, -1):\n            dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])\n\n    return dp[target] == target\n\n\nif __name__ == \"__main__\":\n    nums = [1, 5, 11, 5]\n    print(canPartitionTemplate(nums))  # True\n    print(canPartition(nums))  # True\n    print(canPartitionMemoization(nums))  # True\n</code></pre>"},{"location":"grind-75/dynamic_programming/#62-unique-paths","title":"62. Unique Paths","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Combinatorics</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Count the number of unique paths to reach the bottom-right corner of a `m x n` grid.\n\n![62](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)\n\"\"\"\n\n\n# DP - 2D\ndef uniquePaths(m: int, n: int) -&gt; int:\n    if m == 1 or n == 1:\n        return 1\n\n    dp = [[1] * n for _ in range(m)]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]\n\n\nprint(uniquePaths(m=3, n=7))  # 28\n# [[1, 1, 1,  1,  1,  1,  1],\n#  [1, 2, 3,  4,  5,  6,  7],\n#  [1, 3, 6, 10, 15, 21, 28]]\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint uniquePaths(int m, int n) {\n    vector dp(m, vector&lt;int&gt;(n, 1));\n\n    for (int i = 1; i &lt; m; i++) {\n        for (int j = 1; j &lt; n; j++) {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n\n    return dp[m - 1][n - 1];\n}\n\nint main() {\n    int m = 3, n = 7;\n    cout &lt;&lt; uniquePaths(m, n) &lt;&lt; endl;  // 28\n    return 0;\n}\n</code></pre>"},{"location":"grind-75/graph/","title":"Graph","text":""},{"location":"grind-75/graph/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 733. Flood Fill (Easy)</li> <li> 542. 01 Matrix (Medium)</li> <li> 133. Clone Graph (Medium)</li> <li> 207. Course Schedule (Medium)</li> <li> 200. Number of Islands (Medium)</li> <li> 994. Rotting Oranges (Medium)</li> <li> 721. Accounts Merge (Medium)</li> <li> 79. Word Search (Medium)</li> <li> 310. Minimum Height Trees (Medium)</li> <li> 127. Word Ladder (Hard)</li> </ul>"},{"location":"grind-75/graph/#733-flood-fill","title":"733. Flood Fill","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Matrix</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Replace all the pixels of the same color starting from the given pixel.\n- In other words, find the connected component of the starting pixel and change the color of all the pixels in that component.\n- Edge cases: If the starting pixel is already the target color, return the image as it is.\n- **Flood Fill** is essentially a graph traversal algorithm (like BFS or DFS) applied to matrices (2D grids).\n  It checks adjacent cells (up, down, left, right) of a starting point to determine whether they belong to the same region.\n  Typically, it involves modifying or marking the cells that belong to the same connected component.\n\n![flood_fill](../../assets/flood_fill_example.png)\n\n![733](../../assets/0733.jpg)\n\n|  1  |   1   |  1  |\n| :-: | :---: | :-: |\n|  1  | ==1== |  0  |\n|  1  |   0   |  1  |\n\n|  1  |   1   |  1  |\n| :-: | :---: | :-: |\n|  1  | ==2== |  0  |\n|  1  |   0   |  1  |\n\n|   1   | ==2== |  1  |\n| :---: | :---: | :-: |\n| ==2== | ==2== |  0  |\n|   1   |   0   |  1  |\n\n| ==2== | ==2== | ==2== |\n| :---: | :---: | :---: |\n| ==2== | ==2== |   0   |\n| ==2== |   0   |   1   |\n\"\"\"\n\nfrom collections import deque\nfrom typing import List\n\n\n# DFS\ndef floodFillDFS(image: List[List[int]], sr: int, sc: int, color: int) -&gt; List[List[int]]:\n\n    org = image[sr][sc]\n    m, n = len(image), len(image[0])\n\n    if org == color:\n        return image\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or image[r][c] != org:\n            return None\n\n        image[r][c] = color\n\n        dfs(r - 1, c)\n        dfs(r + 1, c)\n        dfs(r, c - 1)\n        dfs(r, c + 1)\n\n    dfs(sr, sc)\n\n    return image\n\n\n# BFS\ndef floodFillBFS(image: List[List[int]], sr: int, sc: int, color: int) -&gt; List[List[int]]:\n\n    org = image[sr][sc]\n    m, n = len(image), len(image[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    if org == color:\n        return image\n\n    q = deque([(sr, sc)])\n\n    while q:\n        r, c = q.popleft()\n        image[r][c] = color\n\n        for dr, dc in dirs:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and image[nr][nc] == org:\n                q.append((nr, nc))\n\n    return image\n\n\nimage = [[1, 1, 1], [1, 1, 0], [1, 0, 1]]\nsr = 1\nsc = 1\n\nprint(floodFillDFS(image, sr, sc, 2))\n# [[2, 2, 2], [2, 2, 0], [2, 0, 1]]\nprint(floodFillBFS(image, sr, sc, 2))\n# [[2, 2, 2], [2, 2, 0], [2, 0, 1]]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;functional&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   private:\n    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; image, int org, int color, int r, int c) {\n        int m = image.size(), n = image[0].size();\n        if (r &lt; 0 || r &gt;= m || c &lt; 0 || c &gt;= n || image[r][c] != org) {\n            return;\n        }\n        image[r][c] = color;\n        dfs(image, org, color, r - 1, c);\n        dfs(image, org, color, r + 1, c);\n        dfs(image, org, color, r, c - 1);\n        dfs(image, org, color, r, c + 1);\n    }\n\n   public:\n    // DFS\n    vector&lt;vector&lt;int&gt;&gt; flood_fill_dfs(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr,\n                                       int sc, int color) {\n        int org = image[sr][sc];\n        if (org == color) return image;\n\n        dfs(image, org, color, sr, sc);\n        return image;\n    }\n\n    // DFS with lambda\n    vector&lt;vector&lt;int&gt;&gt; flood_fill_dfs_lambda(vector&lt;vector&lt;int&gt;&gt;&amp; image,\n                                              int sr, int sc, int color) {\n        int org = image[sr][sc];\n        if (org == color) return image;\n\n        int m = image.size(), n = image[0].size();\n\n        function&lt;void(int, int)&gt; dfs = [&amp;](int r, int c) -&gt; void {\n            if (r &lt; 0 || r &gt;= m || c &lt; 0 || c &gt;= n || image[r][c] != org) {\n                return;\n            }\n            image[r][c] = color;\n            dfs(r - 1, c);\n            dfs(r + 1, c);\n            dfs(r, c - 1);\n            dfs(r, c + 1);\n        };\n\n        dfs(sr, sc);\n\n        return image;\n    }\n\n    // BFS\n    vector&lt;vector&lt;int&gt;&gt; flood_fill_bfs(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr,\n                                       int sc, int color) {\n        int org = image[sr][sc];\n        if (org == color) return image;\n\n        int m = image.size(), n = image[0].size();\n        vector&lt;pair&lt;int, int&gt;&gt; dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        queue&lt;pair&lt;int, int&gt;&gt; q;\n        q.push({sr, sc});\n\n        while (!q.empty()) {\n            auto [r, c] = q.front();\n            q.pop();\n            image[r][c] = color;\n            for (auto&amp; dir : dirs) {\n                int nr = r + dir.first;\n                int nc = c + dir.second;\n                if (nr &gt;= 0 &amp;&amp; nr &lt; m &amp;&amp; nc &gt;= 0 &amp;&amp; nc &lt; n &amp;&amp;\n                    image[nr][nc] == org) {\n                    q.push({nr, nc});\n                }\n            }\n        }\n\n        return image;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;vector&lt;int&gt;&gt; image = {{1, 1, 1}, {1, 1, 0}, {1, 0, 1}};\n    solution.flood_fill_dfs(image, 1, 1, 2);\n    vector&lt;vector&lt;int&gt;&gt; expected = {{2, 2, 2}, {2, 2, 0}, {2, 0, 1}};\n    assert((image == expected));\n\n    image = {{1, 1, 1}, {1, 1, 0}, {1, 0, 1}};\n    solution.flood_fill_dfs_lambda(image, 1, 1, 2);\n    assert((image == expected));\n\n    image = {{1, 1, 1}, {1, 1, 0}, {1, 0, 1}};\n    solution.flood_fill_bfs(image, 1, 1, 2);\n    assert((image == expected));\n    return 0;\n}\n</code></pre>"},{"location":"grind-75/graph/#542-01-matrix","title":"542. 01 Matrix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Breadth First Search, Matrix</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef updateMatrix(mat: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(mat), len(mat[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    q = deque()\n\n    for i in range(m):\n        for j in range(n):\n            if mat[i][j] == 0:\n                dist[i][j] = 0\n                q.append((i, j))\n\n    while q:\n        r, c = q.popleft()\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and dist[nr][nc] &gt; dist[r][c] + 1:\n                dist[nr][nc] = dist[r][c] + 1\n                q.append((nr, nc))\n\n    return dist\n\n\nmat = [[0, 0, 0], [0, 1, 0], [1, 1, 1]]\nprint(updateMatrix(mat))\n# [[0, 0, 0], [0, 1, 0], [1, 2, 1]]\n</code></pre>"},{"location":"grind-75/graph/#133-clone-graph","title":"133. Clone Graph","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Depth First Search, Breadth First Search, Graph</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import Optional\n\n\nclass Node:\n    def __init__(self, val=0, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\n\nclass CloneGraph:\n    def dfs(self, node: Optional[\"Node\"]) -&gt; Optional[\"Node\"]:\n        hashmap = {}\n\n        def dfs(node):\n            if node in hashmap:\n                return hashmap[node]\n\n            res = Node(node.val)\n            hashmap[node] = res\n\n            for nei in node.neighbors:\n                res.neighbors.append(dfs(nei))\n\n            return res\n\n        return dfs(node) if node else None\n\n    def bfs(self, node: Optional[\"Node\"]) -&gt; Optional[\"Node\"]:\n        if not node:\n            return None\n\n        hashmap = {node: Node(node.val)}\n        q = deque([node])\n\n        while q:\n            cur = q.popleft()\n\n            for nei in cur.neighbors:\n                if nei not in hashmap:\n                    hashmap[nei] = Node(nei.val)\n                    q.append(nei)\n\n                hashmap[cur].neighbors.append(hashmap[nei])\n\n        return hashmap[node]\n</code></pre>"},{"location":"grind-75/graph/#207-course-schedule","title":"207. Course Schedule","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Graph, Topological Sort</p> </li> </ul> PythonCPP <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS (Kahn's Algorithm)\ndef canFinishBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    count = 0\n\n    while q:\n        crs = q.popleft()\n        count += 1\n\n        for nxt in graph[crs]:\n            indegree[nxt] -= 1\n\n            if indegree[nxt] == 0:\n                q.append(nxt)\n\n    return count == numCourses\n\n\n# DFS + Set\ndef canFinishDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for crs, pre in prerequisites:\n        graph[crs].append(pre)\n\n    visiting = set()\n\n    def dfs(crs):\n        if crs in visiting:  # cycle detected\n            return False\n        if graph[crs] == []:\n            return True\n\n        visiting.add(crs)\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        visiting.remove(crs)\n        graph[crs] = []\n\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\n# DFS + List\ndef canFinishDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for pre, crs in prerequisites:\n        graph[crs].append(pre)\n\n    # 0: init, 1: visiting, 2: visited\n    status = [0] * numCourses\n\n    def dfs(crs):\n        if status[crs] == 1:  # cycle detected\n            return False\n        if status[crs] == 2:\n            return True\n\n        status[crs] = 1\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        status[crs] = 2\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(canFinishBFS(5, prerequisites))  # True\nprint(canFinishDFS1(5, prerequisites))  # True\nprint(canFinishDFS2(5, prerequisites))  # True\n</code></pre> <pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    // BFS\n    bool canFinishBFS(int numCourses, vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        vector&lt;int&gt; indegree(numCourses, 0);\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n            indegree[pre[0]]++;\n        }\n\n        queue&lt;int&gt; q;\n        for (int i = 0; i &lt; numCourses; i++) {\n            if (indegree[i] == 0) {\n                q.push(i);\n            }\n        }\n\n        int cnt = 0;\n        while (!q.empty()) {\n            int cur = q.front();\n            q.pop();\n            cnt++;\n\n            for (int nxt : graph[cur]) {\n                indegree[nxt]--;\n                if (indegree[nxt] == 0) {\n                    q.push(nxt);\n                }\n            }\n        }\n        return cnt == numCourses;\n    }\n\n    // DFS\n    bool canFinishDFS(int numCourses, vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n        }\n        // 0: not visited, 1: visiting, 2: visited\n        vector&lt;int&gt; state(numCourses, 0);\n\n        function&lt;bool(int)&gt; dfs = [&amp;](int pre) -&gt; bool {\n            state[pre] = 1;  // visiting\n            for (int crs : graph[pre]) {\n                if (state[crs] == 1 || (state[crs] == 0 &amp;&amp; dfs(crs))) {\n                    return true;\n                }\n            }\n            state[pre] = 2;  // visited\n            return false;\n        };\n\n        for (int i = 0; i &lt; numCourses; i++) {\n            if (state[i] == 0 &amp;&amp; dfs(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution sol;\n    vector&lt;vector&lt;int&gt;&gt; prerequisites = {{1, 0}, {2, 1}, {3, 2}, {4, 3},\n                                         {5, 4}, {6, 5}, {7, 6}, {8, 7},\n                                         {9, 8}, {10, 9}};\n    int numCourses = 11;\n    cout &lt;&lt; sol.canFinishBFS(numCourses, prerequisites) &lt;&lt; endl;\n    cout &lt;&lt; sol.canFinishDFS(numCourses, prerequisites) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"grind-75/graph/#200-number-of-islands","title":"200. Number of Islands","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Union Find, Matrix</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Count the number of islands in a 2D grid.\n-   Method 1: DFS\n-   Method 2: BFS (use a queue to traverse the grid)\n\n-   How to keep track of visited cells?\n\n    1. Mark the visited cell as `0` (or any other value) to avoid revisiting it.\n    2. Use a set to store the visited cells.\n\n-   Steps:\n    1. Init: variables\n    2. DFS/BFS: starting from the cell with `1`, turn all the connected `1`s to `0`.\n    3. Traverse the grid, and if the cell is `1`, increment the count and call DFS/BFS.\n\n![0200](../../assets/0200.jpg)\n\"\"\"\n\nfrom collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef numIslandsDFS(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    res = 0\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] != \"1\":\n            return\n\n        grid[r][c] = \"2\"\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                dfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Set\ndef numIslandsBFS1(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == \"0\"\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\" and (r, c) not in visited:\n                visited.add((r, c))\n                bfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = dr + row, dc + col\n                if nr &lt; 0 or nr &gt;= m or nc &lt; 0 or nc &gt;= n or grid[nr][nc] != \"1\":\n                    continue\n                grid[nr][nc] = \"2\"\n                q.append((nr, nc))\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == \"1\":\n                grid[i][j] = \"2\"\n                bfs(i, j)\n                res += 1\n\n    return res\n\n\ngrid = [\n    [\"1\", \"1\", \"1\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"0\", \"0\", \"0\", \"0\", \"0\"],\n]\n\nprint(numIslandsDFS(deepcopy(grid)))  # 1\nprint(numIslandsBFS1(deepcopy(grid)))  # 1\nprint(numIslandsBFS2(deepcopy(grid)))  # 1\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    // dfs\n    int num_islands_dfs(vector&lt;vector&lt;char&gt;&gt; &amp;grid) {\n        int m = grid.size(), n = grid[0].size();\n        int res = 0;\n\n        // c++23 lambda recursion\n        auto dfs = [&amp;](this auto &amp;&amp;dfs, int r, int c) -&gt; void {\n            if (r &lt; 0 || r &gt;= m || c &lt; 0 || c &gt;= n || grid[r][c] != '1') {\n                return;\n            }\n            grid[r][c] = '0';\n            dfs(r + 1, c);\n            dfs(r - 1, c);\n            dfs(r, c + 1);\n            dfs(r, c - 1);\n        };\n\n        for (int i = 0; i &lt; m; i++) {\n            for (int j = 0; j &lt; n; j++) {\n                if (grid[i][j] == '1') {\n                    res++;\n                    dfs(i, j);\n                }\n            }\n        }\n        return res;\n    }\n\n    // bfs\n    int num_islands_bfs(vector&lt;vector&lt;char&gt;&gt; &amp;grid) {\n        int m = grid.size(), n = grid[0].size();\n        int res = 0;\n        vector&lt;pair&lt;int, int&gt;&gt; dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\n        auto bfs = [&amp;](int r, int c) {\n            queue&lt;pair&lt;int, int&gt;&gt; q;\n            q.push({r, c});\n            grid[r][c] = '0';\n            while (!q.empty()) {\n                auto [cr, cc] = q.front();\n                q.pop();\n                for (auto &amp;[dr, dc] : dirs) {\n                    int nr = cr + dr, nc = cc + dc;\n                    if (nr &gt;= 0 &amp;&amp; nr &lt; m &amp;&amp; nc &gt;= 0 &amp;&amp; nc &lt; n &amp;&amp;\n                        grid[nr][nc] == '1') {\n                        grid[nr][nc] = '0';\n                        q.push({nr, nc});\n                    }\n                }\n            }\n        };\n\n        for (int i = 0; i &lt; m; i++) {\n            for (int j = 0; j &lt; n; j++) {\n                if (grid[i][j] == '1') {\n                    res++;\n                    bfs(i, j);\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;vector&lt;char&gt;&gt; grid = {{'1', '1', '0', '0', '0'},\n                                 {'1', '1', '0', '0', '0'},\n                                 {'0', '0', '1', '0', '0'},\n                                 {'0', '0', '0', '1', '1'}};\n    assert(solution.num_islands_dfs(grid) == 3);\n    grid = {{'1', '1', '0', '0', '0'},\n            {'1', '1', '0', '0', '0'},\n            {'0', '0', '1', '0', '0'},\n            {'0', '0', '0', '1', '1'}};\n    assert(solution.num_islands_bfs(grid) == 3);\n    return 0;\n}\n</code></pre>"},{"location":"grind-75/graph/#994-rotting-oranges","title":"994. Rotting Oranges","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Breadth First Search, Matrix</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the minimum number of minutes that must elapse until no cell has a fresh orange.\n-   Hint: Multi-source BFS to count the level.\n\n![994](https://assets.leetcode.com/uploads/2019/02/16/oranges.png)\n\"\"\"\n\nfrom collections import deque\nfrom typing import List\n\n\n# BFS\ndef orangesRotting(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    fresh = 0\n    q = deque()\n    dirs = [[1, 0], [0, 1], [0, -1], [-1, 0]]\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 2:\n                q.append([i, j])\n            elif grid[i][j] == 1:\n                fresh += 1\n    res = 0\n\n    while q and fresh &gt; 0:\n        size = len(q)\n        for _ in range(size):\n            r, c = q.popleft()\n            for dr, dc in dirs:\n                nr, nc = dr + r, dc + c\n                if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and grid[nr][nc] == 1:\n                    q.append([nr, nc])\n                    grid[nr][nc] = 2\n                    fresh -= 1\n        res += 1\n\n    return res if fresh == 0 else -1\n\n\ngrid = [[2, 1, 1], [1, 1, 0], [0, 1, 1]]\nassert orangesRotting(grid) == 4\n</code></pre>"},{"location":"grind-75/graph/#721-accounts-merge","title":"721. Accounts Merge","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Depth First Search, Breadth First Search, Union Find, Sorting</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef accountsMerge(accounts: List[List[str]]) -&gt; List[List[str]]:\n    parent = defaultdict(str)\n    rank = defaultdict(int)\n    email_to_name = defaultdict(str)\n    merged_accounts = defaultdict(list)\n\n    def find(n):\n        p = parent[n]\n        while p != parent[p]:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    for account in accounts:\n        name = account[0]\n        first_email = account[1]\n\n        for email in account[1:]:\n            if email not in parent:\n                parent[email] = email\n                rank[email] = 1\n            email_to_name[email] = name\n            union(first_email, email)\n\n    for email in parent:\n        root_email = find(email)\n        merged_accounts[root_email].append(email)\n\n    result = []\n    for root_email, emails in merged_accounts.items():\n        result.append([email_to_name[root_email]] + sorted(emails))\n\n    return result\n\n\naccounts = [\n    [\"John\", \"johnsmith@mail.com\", \"john_newyork@mail.com\"],\n    [\"John\", \"johnsmith@mail.com\", \"john00@mail.com\"],\n    [\"Mary\", \"mary@mail.com\"],\n    [\"John\", \"johnnybravo@mail.com\"],\n]\nprint(accountsMerge(accounts))\n# [['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],\n# ['Mary', 'mary@mail.com'],\n# ['John', 'johnnybravo@mail.com']]\n</code></pre>"},{"location":"grind-75/graph/#79-word-search","title":"79. Word Search","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Backtracking, Depth First Search, Matrix</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef exist(board: List[List[str]], word: str) -&gt; bool:\n    m, n = len(board), len(board[0])\n    path = set()\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n\n    def dfs(r, c, i):\n        if i == len(word):\n            return True\n\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or board[r][c] != word[i] or (r, c) in path:\n            return False\n\n        path.add((r, c))\n\n        for dr, dc in dirs:\n            if dfs(r + dr, c + dc, i + 1):\n                return True\n\n        path.remove((r, c))\n        return False\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, 0):\n                return True\n\n    return False\n\n\nboard = [\n    [\"A\", \"B\", \"C\", \"E\"],\n    [\"S\", \"F\", \"C\", \"S\"],\n    [\"A\", \"D\", \"E\", \"E\"],\n]\nword = \"ABCCED\"\nprint(exist(board, word))  # True\n</code></pre>"},{"location":"grind-75/graph/#310-minimum-height-trees","title":"310. Minimum Height Trees","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Graph, Topological Sort</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\ndef findMinHeightTrees(n: int, edges: List[List[int]]) -&gt; List[int]:\n    if n == 1:\n        return [0]\n\n    graph = {i: set() for i in range(n)}\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    q = deque([i for i in range(n) if len(graph[i]) == 1])\n    remaining = n\n\n    while remaining &gt; 2:\n        size = len(q)\n        remaining -= size\n\n        for _ in range(size):\n            cur = q.popleft()\n            nei = graph[cur].pop()\n            graph[nei].remove(cur)\n\n            if len(graph[nei]) == 1:\n                q.append(nei)\n\n    return list(q)\n\n\nn = 6\nedges = [[3, 0], [3, 1], [3, 2], [3, 4], [5, 4]]\nprint(findMinHeightTrees(n, edges))  # [3, 4]\n</code></pre>"},{"location":"grind-75/graph/#127-word-ladder","title":"127. Word Ladder","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Breadth First Search</p> </li> </ul> Python <pre><code>\"\"\"\n-   The most classic BFS problem.\n-   Return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\n-   Approach: BFS\n-   Time Complexity: O(n * m^2)\n-   Space Complexity: O(n * m)\n\"\"\"\n\nfrom collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef ladderLength(beginWord: str, endWord: str, wordList: List[str]) -&gt; int:\n    if endWord not in wordList:\n        return 0\n\n    n = len(beginWord)\n    graph = defaultdict(list)  # pattern: words\n    wordList.append(beginWord)\n\n    for word in wordList:\n        for i in range(n):\n            pattern = word[:i] + \"*\" + word[i + 1 :]\n            graph[pattern].append(word)\n\n    visited = set([beginWord])\n    q = deque([beginWord])\n    res = 1\n\n    while q:\n        size = len(q)\n        for _ in range(size):\n            word = q.popleft()\n            if word == endWord:\n                return res\n\n            for i in range(n):\n                pattern = word[:i] + \"*\" + word[i + 1 :]\n                for neighbor in graph[pattern]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        q.append(neighbor)\n        res += 1\n\n    return 0\n\n\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]\nprint(ladderLength(beginWord, endWord, wordList))  # 5\n</code></pre>"},{"location":"grind-75/hash_table/","title":"Hash Table","text":""},{"location":"grind-75/hash_table/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 383. Ransom Note (Easy)</li> </ul>"},{"location":"grind-75/hash_table/#383-ransom-note","title":"383. Ransom Note","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Counting</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return `True` if the ransom note can be constructed from the magazines, otherwise, return `False`.\n\"\"\"\n\nfrom collections import Counter, defaultdict\n\n\n# Array\ndef canConstructArray(ransomNote: str, magazine: str) -&gt; bool:\n    if len(ransomNote) &gt; len(magazine):\n        return False\n\n    record = [0 for _ in range(26)]\n\n    for i in magazine:\n        record[ord(i) - ord(\"a\")] += 1\n\n    for j in ransomNote:\n        record[ord(j) - ord(\"a\")] -= 1\n\n    for i in record:\n        if i &lt; 0:\n            return False\n\n    return True\n\n\n# Dict\ndef canConstructDict(ransomNote: str, magazine: str) -&gt; bool:\n    if len(ransomNote) &gt; len(magazine):\n        return False\n\n    record = defaultdict(int)\n\n    for i in magazine:\n        record[i] += 1\n\n    for j in ransomNote:\n        if j not in record or record[j] == 0:\n            return False\n        record[j] -= 1\n\n    return True\n\n\n# Counter\ndef canConstructCounter(ransomNote: str, magazine: str) -&gt; bool:\n    return not Counter(ransomNote) - Counter(magazine)\n\n\nransomNote = \"aa\"\nmagazine = \"aab\"\nprint(canConstructArray(ransomNote, magazine))  # True\nprint(canConstructDict(ransomNote, magazine))  # True\nprint(canConstructCounter(ransomNote, magazine))  # True\n</code></pre>"},{"location":"grind-75/heap/","title":"Heap","text":""},{"location":"grind-75/heap/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 973. K Closest Points to Origin (Medium)</li> <li> 621. Task Scheduler (Medium)</li> <li> 295. Find Median from Data Stream (Hard)</li> <li> 23. Merge k Sorted Lists (Hard)</li> </ul>"},{"location":"grind-75/heap/#973-k-closest-points-to-origin","title":"973. K Closest Points to Origin","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Divide And Conquer, Geometry, Sorting, Heap Priority Queue, Quickselect</p> </li> </ul> Python <pre><code>import heapq\nfrom typing import List\n\n\ndef kClosest(points: List[List[int]], k: int) -&gt; List[List[int]]:\n    heap = []\n\n    for x, y in points:\n        dist = -(x**2 + y**2)  # max heap\n        if len(heap) &lt; k:\n            heapq.heappush(heap, (dist, x, y))\n        else:\n            heapq.heappushpop(heap, (dist, x, y))  # push and pop the smallest\n\n    return [[x, y] for (_, x, y) in heap]\n\n\n# Time complexity: O(n * log(k))\n#   - O(log(k)) for heapify\n#   - O(n) for iterating through the input list\n# Space complexity: O(k)\n\npoints = [[1, 3], [-2, 2]]\nk = 1\nprint(kClosest(points, k))  # [[-2, 2]]\n</code></pre>"},{"location":"grind-75/heap/#621-task-scheduler","title":"621. Task Scheduler","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Greedy, Sorting, Heap Priority Queue, Counting</p> </li> </ul> Python <pre><code>import heapq\nfrom collections import Counter, deque\nfrom typing import List\n\n\n# Heap\ndef leastInterval1(tasks: List[str], n: int) -&gt; int:\n    count = Counter(tasks)\n    heap = [-c for c in count.values()]\n    heapq.heapify(heap)\n\n    time = 0\n\n    q = deque()\n\n    while heap or q:\n        time += 1\n\n        if heap:\n            cnt = 1 + heapq.heappop(heap)\n            if cnt:\n                q.append((cnt, time + n))\n\n        if q and q[0][1] == time:\n            heapq.heappush(heap, q.popleft()[0])\n\n    return time\n\n\ndef leastInterval2(tasks: List[str], n: int) -&gt; int:\n    freq = Counter(tasks)\n\n    maxExec = max(freq.values())\n    maxCount = sum(1 for v in freq.values() if v == maxExec)\n\n    return max((maxExec - 1) * (n + 1) + maxCount, len(tasks))\n\n\ntasks = [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\"]\nn = 2\nprint(leastInterval1(tasks, n))  # 8\nprint(leastInterval2(tasks, n))  # 8\n</code></pre>"},{"location":"grind-75/heap/#295-find-median-from-data-stream","title":"295. Find Median from Data Stream","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, Design, Sorting, Heap Priority Queue, Data Stream</p> </li> </ul> PythonCPP <pre><code>from heapq import heappop, heappush\n\n\nclass MedianFinder:\n\n    def __init__(self):\n        self.minHeap = []\n        self.maxHeap = []\n        self.min_size = 0\n        self.max_size = 0\n\n    def addNum(self, num: int) -&gt; None:\n        heappush(self.maxHeap, -num)\n        heappush(self.minHeap, -heappop(self.maxHeap))\n        self.min_size += 1\n\n        if self.min_size &gt; self.max_size:\n            heappush(self.maxHeap, -heappop(self.minHeap))\n            self.min_size -= 1\n            self.max_size += 1\n\n    def findMedian(self) -&gt; float:\n        if self.min_size == self.max_size:\n            return (-self.maxHeap[0] + self.minHeap[0]) / 2.0\n        return float(-self.maxHeap[0])\n\n\ndef test_median_finder():\n    obj = MedianFinder()\n    obj.addNum(1)\n    obj.addNum(2)\n    assert obj.findMedian() == 1.5\n    obj.addNum(3)\n    assert obj.findMedian() == 2.0\n    obj.addNum(4)\n    assert obj.findMedian() == 2.5\n    obj.addNum(5)\n    assert obj.findMedian() == 3.0\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass MedianFinder {\n   private:\n    priority_queue&lt;int&gt; maxHeap;\n    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;\n    int max_size = 0;\n    int min_size = 0;\n\n   public:\n    MedianFinder() {}\n\n    void addNum(int num) {\n        if (min_size == max_size) {\n            minHeap.push(num);\n            maxHeap.push(minHeap.top());\n            minHeap.pop();\n            max_size++;\n        } else {\n            maxHeap.push(num);\n            minHeap.push(maxHeap.top());\n            maxHeap.pop();\n            min_size++;\n        }\n    }\n\n    double findMedian() {\n        if (min_size == max_size) {\n            return (maxHeap.top() + minHeap.top()) / 2.0;\n        } else {\n            return (double)maxHeap.top();\n        }\n    }\n};\n\nint main() {\n    MedianFinder* obj = new MedianFinder();\n    obj-&gt;addNum(1);\n    obj-&gt;addNum(2);\n    cout &lt;&lt; obj-&gt;findMedian() &lt;&lt; endl;  // 1.5\n    obj-&gt;addNum(3);\n    cout &lt;&lt; obj-&gt;findMedian() &lt;&lt; endl;  // 2\n    return 0;\n}\n</code></pre>"},{"location":"grind-75/heap/#23-merge-k-sorted-lists","title":"23. Merge k Sorted Lists","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Divide And Conquer, Heap Priority Queue, Merge Sort</p> </li> </ul> Python <pre><code>\"\"\"\n-   Prerequisite: 21. Merge Two Sorted Lists\n-   Video explanation: [23. Merge K Sorted Lists - NeetCode](https://youtu.be/q5a5OiGbT6Q?si=SQ2dCvsYQ3LQctPh)\n\"\"\"\n\nimport copy\nimport heapq\nfrom typing import List, Optional\n\nfrom leetpattern.utils import ListNode, list_from_array, list_to_array\n\n\ndef merge_k_lists_divide_conquer(\n    lists: List[Optional[ListNode]],\n) -&gt; Optional[ListNode]:\n    if not lists or len(lists) == 0:\n        return None\n\n    def mergeTwo(l1, l2):\n        dummy = ListNode()\n        cur = dummy\n\n        while l1 and l2:\n            if l1.val &lt; l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n\n            cur = cur.next\n\n        cur.next = l1 if l1 else l2\n\n        return dummy.next\n\n    while len(lists) &gt; 1:\n        merged = []\n\n        for i in range(0, len(lists), 2):\n            l1 = lists[i]\n            l2 = lists[i + 1] if i + 1 &lt; len(lists) else None\n            merged.append(mergeTwo(l1, l2))\n\n        lists = merged\n\n    return lists[0]\n\n\ndef merge_k_lists_heap(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    min_heap = []  # (val, idx, node)\n\n    for idx, head in enumerate(lists):\n        if head:\n            heapq.heappush(min_heap, (head.val, idx, head))\n\n    while min_heap:\n        _, idx, node = heapq.heappop(min_heap)\n        cur.next = node\n        cur = cur.next\n\n        node = node.next\n        if node:\n            heapq.heappush(min_heap, (node.val, idx, node))\n\n    return dummy.next\n\n\ndef test_merge_k_lists() -&gt; None:\n    n1 = list_from_array([1, 4])\n    n2 = list_from_array([1, 3])\n    n3 = list_from_array([2, 6])\n    lists = [n1, n2, n3]\n    lists1 = copy.deepcopy(lists)\n    lists2 = copy.deepcopy(lists)\n    assert (list_to_array(merge_k_lists_divide_conquer(lists1))) == [\n        1,\n        1,\n        2,\n        3,\n        4,\n        6,\n    ]\n    assert (list_to_array(merge_k_lists_heap(lists2))) == [1, 1, 2, 3, 4, 6]\n</code></pre>"},{"location":"grind-75/linked_list/","title":"Linked List","text":""},{"location":"grind-75/linked_list/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 21. Merge Two Sorted Lists (Easy)</li> <li> 141. Linked List Cycle (Easy)</li> <li> 206. Reverse Linked List (Easy)</li> <li> 876. Middle of the Linked List (Easy)</li> <li> 146. LRU Cache (Medium)</li> </ul>"},{"location":"grind-75/linked_list/#21-merge-two-sorted-lists","title":"21. Merge Two Sorted Lists","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Recursion</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Task: Merge the two linked lists into one sorted list.\n\"\"\"\n\nfrom typing import Optional\n\nfrom leetpattern.utils import ListNode\n\n\n# Linked List\ndef merge_two_lists(\n    list1: Optional[ListNode], list2: Optional[ListNode]\n) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    while list1 and list2:\n        if list1.val &lt; list2.val:\n            cur.next = list1\n            list1 = list1.next\n        else:\n            cur.next = list2\n            list2 = list2.next\n        cur = cur.next\n\n    if list1:\n        cur.next = list1\n    elif list2:\n        cur.next = list2\n\n    return dummy.next\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode* next) : val(x), next(next) {}\n};\n\nclass Solution {\n   public:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        ListNode dummy;\n        ListNode* cur = &amp;dummy;\n\n        while (list1 &amp;&amp; list2) {\n            if (list1-&gt;val &lt; list2-&gt;val) {\n                cur-&gt;next = list1;\n                list1 = list1-&gt;next;\n            } else {\n                cur-&gt;next = list2;\n                list2 = list2-&gt;next;\n            }\n            cur = cur-&gt;next;\n        }\n\n        cur-&gt;next = list1 ? list1 : list2;\n\n        return dummy.next;\n    }\n};\n\nint main() {\n    Solution sol;\n    ListNode* list1 = new ListNode(1, new ListNode(2, new ListNode(4)));\n    ListNode* list2 = new ListNode(1, new ListNode(3, new ListNode(4)));\n    ListNode* merged = sol.mergeTwoLists(list1, list2);\n    vector&lt;int&gt; res;\n    while (merged) {\n        res.push_back(merged-&gt;val);\n        merged = merged-&gt;next;\n    }\n    assert(res == std::vector&lt;int&gt;({1, 1, 2, 3, 4, 4}));\n    return 0;\n}\n</code></pre>"},{"location":"grind-75/linked_list/#141-linked-list-cycle","title":"141. Linked List Cycle","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Linked List, Two Pointers</p> </li> </ul> PythonCPP <pre><code>from typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\ndef has_cycle(head: Optional[ListNode]) -&gt; bool:\n    slow, fast = head, head\n\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n        if slow == fast:\n            return True\n\n    return False\n\n\ndef test_has_cycle():\n    ll = LinkedList([3, 2, 0, -4])\n    ll.make_cycle(pos=1)\n    assert has_cycle(ll.head)\n\n    ll = LinkedList([1, 2])\n    ll.make_cycle(pos=0)\n    assert has_cycle(ll.head)\n\n    ll = LinkedList([1, 2, 3, 4, 5])\n    assert not has_cycle(ll.head)\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n\n#include \"include/lists.hpp\"\nusing namespace std;\n\nclass Solution {\n   public:\n    bool has_cycle(ListNode* head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while (fast &amp;&amp; fast-&gt;next) {\n            slow = slow-&gt;next;\n            fast = fast-&gt;next-&gt;next;\n\n            if (fast == slow) return true;\n        }\n        return false;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    ListNode* head = LinkedList::build({3, 2, 0, -4});\n    // create cycle\n    head = LinkedList::make_cycle(head, 1);\n    assert(solution.has_cycle(head) == true);\n    // no cycle\n    ListNode* head2 = LinkedList::build({1, 2});\n    assert(solution.has_cycle(head2) == false);\n    // no cycle\n    ListNode* head3 = LinkedList::build({1});\n    assert(solution.has_cycle(head3) == false);\n\n    return 0;\n}\n</code></pre>"},{"location":"grind-75/linked_list/#206-reverse-linked-list","title":"206. Reverse Linked List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Recursion</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\ndef reverse_list_iterative(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    cur = head\n    prev = None\n\n    while cur:\n        temp = cur.next\n        cur.next = prev\n\n        prev = cur\n        cur = temp\n\n    return prev\n\n\ndef reverse_list_recursive(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    def reverse(cur, prev):\n        if not cur:\n            return prev\n\n        temp = cur.next\n        cur.next = prev\n        return reverse(temp, cur)\n\n    return reverse(head, None)\n\n\ndef test_reverse_list():\n    ll = LinkedList([1, 2, 3, 4, 5])\n    ll.head = reverse_list_iterative(ll.head)\n    assert ll.to_array() == [5, 4, 3, 2, 1]\n\n    ll = LinkedList([1, 2, 3, 4, 5])\n    ll.head = reverse_list_recursive(ll.head)\n    assert ll.to_array() == [5, 4, 3, 2, 1]\n</code></pre>"},{"location":"grind-75/linked_list/#876-middle-of-the-linked-list","title":"876. Middle of the Linked List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Two Pointers</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\n# Linked List\ndef middleNode(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    fast, slow = head, head\n\n    while fast and fast.next:\n        fast = fast.next.next\n        slow = slow.next\n\n    return slow\n\n\ndef test_middleNode():\n    # Test case 1: Odd number of nodes\n    ll1 = LinkedList([1, 2, 3, 4, 5])\n    middle1 = middleNode(ll1.head)\n    result1 = LinkedList(middle1)\n    assert result1.to_array() == [3, 4, 5]\n\n    # Test case 2: Even number of nodes\n    ll2 = LinkedList([1, 2, 3, 4, 5, 6])\n    middle2 = middleNode(ll2.head)\n    result2 = LinkedList(middle2)\n    assert result2.to_array() == [4, 5, 6]\n\n    # Test case 3: Single node\n    ll3 = LinkedList([1])\n    middle3 = middleNode(ll3.head)\n    result3 = LinkedList(middle3)\n    assert result3.to_array() == [1]\n\n    # Test case 4: Two nodes\n    ll4 = LinkedList([1, 2])\n    middle4 = middleNode(ll4.head)\n    result4 = LinkedList(middle4)\n    assert result4.to_array() == [2]\n</code></pre>"},{"location":"grind-75/linked_list/#146-lru-cache","title":"146. LRU Cache","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Linked List, Design, Doubly Linked List</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Design and implement a data structure for **Least Recently Used (LRU) cache**. It should support the following operations: get and put.\n- [lru](https://media.geeksforgeeks.org/wp-content/uploads/20240909142802/Working-of-LRU-Cache-copy-2.webp)\n- ![146](https://miro.medium.com/v2/resize:fit:650/0*fOwBd3z0XtHh7WN1.png)\n\n| Data structure     | Description                   |\n| ------------------ | ----------------------------- |\n| Doubly Linked List | To store the key-value pairs. |\n| Hash Map           | To store the key-node pairs.  |\n\"\"\"\n\nfrom collections import OrderedDict\n\n\n# Doubly Linked List\nclass Node:\n    def __init__(self, key=0, val=0):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.cache = {}\n        self.head = Node()\n        self.tail = Node()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def add_to_last(self, node):\n        self.tail.prev.next = node\n        node.prev = self.tail.prev\n        node.next = self.tail\n        self.tail.prev = node\n\n    def move_to_last(self, node):\n        self.remove(node)\n        self.add_to_last(node)\n\n    def get(self, key: int) -&gt; int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self.move_to_last(node)\n        return node.val\n\n    def put(self, key: int, value: int) -&gt; None:\n        if key in self.cache:\n            node = self.cache[key]\n            node.val = value\n            self.move_to_last(node)\n            return None\n\n        if len(self.cache) == self.cap:\n            del self.cache[self.head.next.key]\n            self.remove(self.head.next)\n\n        node = Node(key=key, val=value)\n        self.cache[key] = node\n        self.add_to_last(node)\n\n\n# OrderedDict\nclass LRUCacheOrderedDict:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.cap = capacity\n\n    def get(self, key: int):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key, last=True)\n        return self.cache[key]\n\n    def put(self, key: int, value: int):\n        if key in self.cache:\n            self.cache.move_to_end(key, last=True)\n        elif len(self.cache) &gt;= self.cap:\n            self.cache.popitem(last=False)\n\n        self.cache[key] = value\n\n\ncache = LRUCache(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\n\ncache = LRUCacheOrderedDict(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\nprint(\"LRU Cache passed\")\nprint(\"LRU Cache Ordered Dict passed\")\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nclass Node {\n   public:\n    int key;\n    int val;\n    Node *prev;\n    Node *next;\n\n    Node(int k = 0, int v = 0) : key(k), val(v), prev(nullptr), next(nullptr) {}\n};\n\nclass LRUCache {\n   private:\n    int cap;\n    unordered_map&lt;int, Node *&gt; cache;\n    Node *head;\n    Node *tail;\n\n    void remove(Node *node) {\n        node-&gt;prev-&gt;next = node-&gt;next;\n        node-&gt;next-&gt;prev = node-&gt;prev;\n    }\n\n    void insert_to_last(Node *node) {\n        tail-&gt;prev-&gt;next = node;\n        node-&gt;prev = tail-&gt;prev;\n        tail-&gt;prev = node;\n        node-&gt;next = tail;\n    }\n\n    void move_to_last(Node *node) {\n        remove(node);\n        insert_to_last(node);\n    }\n\n   public:\n    LRUCache(int capacity) {\n        this-&gt;cap = capacity;\n        head = new Node();\n        tail = new Node();\n        head-&gt;next = tail;\n        tail-&gt;prev = head;\n    }\n\n    int get(int key) {\n        if (cache.find(key) != cache.end()) {\n            Node *node = cache[key];\n            move_to_last(node);\n            return node-&gt;val;\n        }\n        return -1;\n    }\n\n    void put(int key, int value) {\n        if (cache.find(key) != cache.end()) {\n            Node *node = cache[key];\n            node-&gt;val = value;\n            move_to_last(node);\n        } else {\n            Node *newNode = new Node(key, value);\n            cache[key] = newNode;\n            insert_to_last(newNode);\n\n            if ((int)cache.size() &gt; cap) {\n                Node *removed = head-&gt;next;\n                remove(removed);\n                cache.erase(removed-&gt;key);\n                delete removed;\n            }\n        }\n    }\n};\n\nint main() {\n    LRUCache lru(2);\n    lru.put(1, 1);\n    lru.put(2, 2);\n    assert(lru.get(1) == 1);   // returns 1\n    lru.put(3, 3);             // evicts key 2\n    assert(lru.get(2) == -1);  // returns -1 (not found)\n    lru.put(4, 4);             // evicts key 1\n    assert(lru.get(1) == -1);  // returns -1 (not found)\n    assert(lru.get(3) == 3);   // returns 3\n    assert(lru.get(4) == 4);   // returns 4\n    return 0;\n}\n</code></pre>"},{"location":"grind-75/matrix/","title":"Matrix","text":""},{"location":"grind-75/matrix/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 54. Spiral Matrix (Medium)</li> </ul>"},{"location":"grind-75/matrix/#54-spiral-matrix","title":"54. Spiral Matrix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Matrix, Simulation</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return all elements of the matrix in spiral order.\n\"\"\"\n\nfrom typing import List\n\n\n# Array\ndef spiralOrder(matrix: List[List[int]]) -&gt; List[int]:\n    if not matrix or not matrix[0]:\n        return []\n\n    res = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n\n    while top &lt;= bottom and left &lt;= right:\n\n        for i in range(left, right + 1):\n            res.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            res.append(matrix[i][right])\n        right -= 1\n\n        if top &lt;= bottom:\n\n            for i in range(right, left - 1, -1):\n                res.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left &lt;= right:\n\n            for i in range(bottom, top - 1, -1):\n                res.append(matrix[i][left])\n            left += 1\n\n    return res\n\n\n# Math\ndef spiralOrderMath(matrix: List[List[int]]) -&gt; List[int]:\n    dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]]  # Right Down Left Up\n    m, n = len(matrix), len(matrix[0])\n    size = m * n\n    res = []\n    i, j, di = 0, -1, 0\n\n    while len(res) &lt; size:\n        dx, dy = dirs[di]\n        for _ in range(n):\n            i += dx\n            j += dy\n            res.append(matrix[i][j])\n        di = (di + 1) % 4\n        n, m = m - 1, n\n\n    return res\n\n\nprint(spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n# [1, 2, 3, 6, 9, 8, 7, 4, 5]\nprint(spiralOrderMath([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]))\n# [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]\n</code></pre>"},{"location":"grind-75/recursion/","title":"Recursion","text":""},{"location":"grind-75/recursion/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 46. Permutations (Medium)</li> <li> 78. Subsets (Medium)</li> <li> 17. Letter Combinations of a Phone Number (Medium)</li> </ul>"},{"location":"grind-75/recursion/#46-permutations","title":"46. Permutations","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Backtracking\ndef permute(nums: List[int]) -&gt; List[List[int]]:\n    n = len(nums)\n    path, res = [], []\n    used = [False for _ in range(n)]\n\n    def dfs(x: int):\n        if x == n:\n            res.append(path[:])\n            return\n\n        for i in range(n):\n            if used[i]:\n                continue\n            used[i] = True\n            path.append(nums[i])\n            dfs(x + 1)\n            path.pop()\n            used[i] = False\n\n    dfs(0)\n\n    return res\n\n\nprint(permute([1, 2, 3]))\n# [[1, 2, 3], [1, 3, 2], [2, 1, 3],\n#  [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n</code></pre>"},{"location":"grind-75/recursion/#78-subsets","title":"78. Subsets","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking, Bit Manipulation</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Iterative Inclusion Backtracking\ndef subsets_iterative_inclusion(nums: List[int]) -&gt; List[List[int]]:\n    n = len(nums)\n    res, path = [], []\n\n    def dfs(i):\n        res.append(path.copy())\n\n        for j in range(i, n):\n            path.append(nums[j])\n            dfs(j + 1)\n            path.pop()\n\n    dfs(0)\n\n    return res\n\n\n# Binary Decision Backtracking\ndef subsets_binary_decision(nums: List[int]) -&gt; List[List[int]]:\n    n = len(nums)\n    res, path = [], []\n\n    def dfs(i):\n        if i == n:\n            res.append(path.copy())\n            return\n\n        # Exclude\n        dfs(i + 1)\n\n        # Include\n        path.append(nums[i])\n        dfs(i + 1)\n        path.pop()\n\n    dfs(0)\n\n    return res\n\n\nprint(subsets_iterative_inclusion([1, 2, 3]))\n# [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]\nprint(subsets_binary_decision([1, 2, 3]))\n# [[], [3], [2], [2, 3], [1], [1, 3], [1, 2], [1, 2, 3]]\n</code></pre>"},{"location":"grind-75/recursion/#17-letter-combinations-of-a-phone-number","title":"17. Letter Combinations of a Phone Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Backtracking</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return all possible letter combinations that the number could represent.\n\n![17](https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png)\n\"\"\"\n\nfrom typing import List\n\n\n# Backtracking\ndef letterCombinations(digits: str) -&gt; List[str]:\n    letter_map = {\n        \"2\": \"abc\",\n        \"3\": \"def\",\n        \"4\": \"ghi\",\n        \"5\": \"jkl\",\n        \"6\": \"mno\",\n        \"7\": \"pqrs\",\n        \"8\": \"tuv\",\n        \"9\": \"wxyz\",\n    }\n\n    n = len(digits)\n    if n == 0:\n        return []\n\n    res = []\n\n    def dfs(idx, path):\n        if idx == n:\n            res.append(path)\n            return None\n\n        letters = letter_map[digits[idx]]\n\n        for i in range(len(letters)):\n            dfs(idx + 1, path + letters[i])\n\n    dfs(0, \"\")\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert letterCombinations(\"23\") == [\n        \"ad\",\n        \"ae\",\n        \"af\",\n        \"bd\",\n        \"be\",\n        \"bf\",\n        \"cd\",\n        \"ce\",\n        \"cf\",\n    ]\n</code></pre>"},{"location":"grind-75/stack/","title":"Stack","text":""},{"location":"grind-75/stack/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 20. Valid Parentheses (Easy)</li> <li> 232. Implement Queue using Stacks (Easy)</li> <li> 150. Evaluate Reverse Polish Notation (Medium)</li> <li> 155. Min Stack (Medium)</li> <li> 42. Trapping Rain Water (Hard)</li> <li> 224. Basic Calculator (Hard)</li> <li> 84. Largest Rectangle in Histogram (Hard)</li> </ul>"},{"location":"grind-75/stack/#20-valid-parentheses","title":"20. Valid Parentheses","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack</p> </li> </ul> PythonCPP <pre><code># Stack\ndef is_valid(s: str) -&gt; bool:\n    if len(s) % 2:\n        return False\n\n    pairs = {\n        \"(\": \")\",\n        \"{\": \"}\",\n        \"[\": \"]\",\n    }\n    stack = []\n    for ch in s:\n        if ch in pairs:\n            stack.append(ch)\n        elif not stack or ch != pairs[stack.pop()]:\n            return False\n\n    return True if not stack else False\n\n\ndef test_is_valid():\n    assert is_valid(\"()[]{}\")\n    assert not is_valid(\"(]\")\n    assert not is_valid(\"([)]\")\n    assert is_valid(\"{[]}\")\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;stack&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool isValid(string s) {\n        unordered_map&lt;char, char&gt; map{{')', '('}, {'}', '{'}, {']', '['}};\n        stack&lt;char&gt; stack;\n        if (s.length() % 2 == 1) return false;\n\n        for (char&amp; ch : s) {\n            if (stack.empty() || map.find(ch) == map.end()) {\n                stack.push(ch);\n            } else {\n                if (map[ch] != stack.top()) {\n                    return false;\n                }\n                stack.pop();\n            }\n        }\n        return stack.empty();\n    }\n};\n\nint main() {\n    Solution s;\n    assert(s.isValid(\"()\") == true);\n    assert(s.isValid(\"()[]{}\") == true);\n    assert(s.isValid(\"(]\") == false);\n    assert(s.isValid(\"([)]\") == false);\n    assert(s.isValid(\"{[]}\") == true);\n    return 0;\n}\n</code></pre>"},{"location":"grind-75/stack/#232-implement-queue-using-stacks","title":"232. Implement Queue using Stacks","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Stack, Design, Queue</p> </li> </ul> Python <pre><code>\"\"\"\n-   Implement the following operations of a queue using stacks.\n    -   `push(x)` - Push element x to the back of queue.\n    -   `pop()` - Removes the element from in front of queue.\n    -   `peek()` - Get the front element.\n    -   `empty()` - Return whether the queue is empty.\n\"\"\"\n\n\nclass MyQueue:\n    def __init__(self):\n        self.stack_in = []\n        self.stack_out = []\n\n    def push(self, x: int) -&gt; None:\n        self.stack_in.append(x)\n\n    def pop(self) -&gt; int:\n        if self.empty():\n            return None\n\n        if self.stack_out:\n            return self.stack_out.pop()\n        else:\n            for _ in range(len(self.stack_in)):\n                self.stack_out.append(self.stack_in.pop())\n            return self.stack_out.pop()\n\n    def peek(self) -&gt; int:\n        answer = self.pop()\n        self.stack_out.append(answer)\n        return answer\n\n    def empty(self) -&gt; bool:\n        return not (self.stack_in or self.stack_out)\n\n\nobj = MyQueue()\nobj.push(1)\nprint(obj.pop())  # 1\nprint(obj.peek())  # None\nprint(obj.empty())  # False\n</code></pre>"},{"location":"grind-75/stack/#150-evaluate-reverse-polish-notation","title":"150. Evaluate Reverse Polish Notation","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Stack</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Stack\ndef evalRPN(tokens: List[str]) -&gt; int:\n    stack = []\n\n    for c in tokens:\n        if c == \"+\":\n            stack.append(stack.pop() + stack.pop())\n        elif c == \"-\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(b - a)\n        elif c == \"*\":\n            stack.append(stack.pop() * stack.pop())\n        elif c == \"/\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(int(b / a))\n        else:\n            stack.append(int(c))\n\n    return stack[0]\n\n\ndef test_evalRPN():\n    print(evalRPN([\"2\", \"1\", \"+\", \"3\", \"*\"]))  # 9\n    print(evalRPN([\"4\", \"13\", \"5\", \"/\", \"-\"]))  # 2\n    print(evalRPN([\"18\"]))  # 18\n    print(evalRPN([\"4\", \"3\", \"-\"]))  # 1\n</code></pre>"},{"location":"grind-75/stack/#155-min-stack","title":"155. Min Stack","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Stack, Design</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Implement a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\"\"\"\n\n\n# Stack\nclass MinStack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, val: int) -&gt; None:\n        if self.stack:\n            self.stack.append((val, min(val, self.getMin())))\n        else:\n            self.stack.append((val, val))\n\n    def pop(self) -&gt; None:\n        self.stack.pop()\n\n    def top(self) -&gt; int:\n        return self.stack[-1][0]\n\n    def getMin(self) -&gt; int:\n        return self.stack[-1][1]\n\n\nobj = MinStack()\nobj.push(3)\nobj.push(2)\nobj.pop()\nprint(obj.top())  # 3\nprint(obj.getMin())  # 3\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;climits&gt;\n#include &lt;iostream&gt;\n#include &lt;stack&gt;\n#include &lt;utility&gt;\nusing namespace std;\n\nclass MinStack {\n    stack&lt;pair&lt;int, int&gt;&gt; st;\n\n   public:\n    MinStack() { st.emplace(0, INT_MAX); }\n\n    void push(int val) { st.emplace(val, min(getMin(), val)); }\n\n    void pop() { st.pop(); }\n\n    int top() { return st.top().first; }\n\n    int getMin() { return st.top().second; }\n};\n\nint main() {\n    MinStack minStack;\n    minStack.push(-2);\n    minStack.push(0);\n    minStack.push(-3);\n    cout &lt;&lt; minStack.getMin() &lt;&lt; endl;  // -3\n    minStack.pop();\n    cout &lt;&lt; minStack.top() &lt;&lt; endl;     // 0\n    cout &lt;&lt; minStack.getMin() &lt;&lt; endl;  // -2\n    return 0;\n}\n</code></pre>"},{"location":"grind-75/stack/#42-trapping-rain-water","title":"42. Trapping Rain Water","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Dynamic Programming, Stack, Monotonic Stack</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- ![42](../../assets/0042.png)\n\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/ZI2z5pq0TqA?si=OEYg01dbmzvmtIwZ\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen&gt;&lt;/iframe&gt;\n\n| Approach   | Time | Space |\n| ---------- | ---- | ----- |\n| DP         | O(N) | O(N)  |\n| Left Right | O(N) | O(1)  |\n| Monotonic  | O(N) | O(N)  |\n\"\"\"\n\nfrom typing import List\n\n\n# DP\ndef trapDP(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    n = len(height)\n    maxLeft, maxRight = [0 for _ in range(n)], [0 for _ in range(n)]\n\n    for i in range(1, n):\n        maxLeft[i] = max(maxLeft[i - 1], height[i - 1])\n\n    for i in range(n - 2, -1, -1):\n        maxRight[i] = max(maxRight[i + 1], height[i + 1])\n\n    res = 0\n    for i in range(n):\n        res += max(0, min(maxLeft[i], maxRight[i]) - height[i])\n\n    return res\n\n\n# Left Right Pointers\ndef trapLR(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    left, right = 0, len(height) - 1\n    maxL, maxR = height[left], height[right]\n    res = 0\n\n    while left &lt; right:\n        if maxL &lt; maxR:\n            left += 1\n            maxL = max(maxL, height[left])\n            res += maxL - height[left]\n        else:\n            right -= 1\n            maxR = max(maxR, height[right])\n            res += maxR - height[right]\n\n    return res\n\n\n# Monotonic Stack\ndef trapStack(height: List[int]) -&gt; int:\n    stack = []\n    total = 0\n\n    for i in range(len(height)):\n        while stack and height[i] &gt; height[stack[-1]]:\n            top = stack.pop()\n            if not stack:\n                break\n            distance = i - stack[-1] - 1\n            bounded_height = min(height[i], height[stack[-1]]) - height[top]\n            total += distance * bounded_height\n        stack.append(i)\n\n    return total\n\n\nheight = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\nprint(trapDP(height))  # 6\nprint(trapLR(height))  # 6\nprint(trapStack(height))  # 6\n</code></pre> <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int trap(vector&lt;int&gt; &amp;height)\n    {\n        if (height.empty())\n            return 0;\n\n        int res = 0;\n        int left = 0, right = height.size() - 1;\n        int maxL = height[left], maxR = height[right];\n\n        while (left &lt; right)\n        {\n            if (maxL &lt; maxR)\n            {\n                left++;\n                maxL = max(maxL, height[left]);\n                res += maxL - height[left];\n            }\n            else\n            {\n                right--;\n                maxR = max(maxR, height[right]);\n                res += maxR - height[right];\n            }\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    vector&lt;int&gt; height = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};\n    Solution solution;\n    cout &lt;&lt; solution.trap(height) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"grind-75/stack/#224-basic-calculator","title":"224. Basic Calculator","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String, Stack, Recursion</p> </li> </ul> Python <pre><code># Stack\ndef calculate(s: str) -&gt; int:\n    stack = []\n    result = 0\n    number = 0\n    sign = 1\n\n    for char in s:\n        if char.isdigit():\n            number = number * 10 + int(char)\n\n        elif char == \"+\":\n            result += sign * number\n            number = 0\n            sign = 1\n        elif char == \"-\":\n            result += sign * number\n            number = 0\n            sign = -1\n\n        elif char == \"(\":\n            stack.append(result)\n            stack.append(sign)\n            result = 0\n            sign = 1\n        elif char == \")\":\n            result += sign * number\n            number = 0\n            result *= stack.pop()  # pop sign\n            result += stack.pop()  # pop previous result\n\n    result += sign * number\n\n    return result\n\n\nprint(calculate(\"(1+(4+5+2)-3)+(6+8)\"))  # 23\n</code></pre>"},{"location":"grind-75/stack/#84-largest-rectangle-in-histogram","title":"84. Largest Rectangle in Histogram","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Stack, Monotonic Stack</p> </li> </ul> Python <pre><code>from typing import List\n\n\nclass LargestRectangleArea:\n    def monotonic_stack(self, heights: List[int]) -&gt; int:\n        stack = []\n        res = 0\n        n = len(heights)\n\n        for i in range(n + 1):\n            h = heights[i] if i &lt; n else 0\n\n            while stack and h &lt; heights[stack[-1]]:\n                height = heights[stack.pop()]\n                width = i if not stack else i - stack[-1] - 1\n                res = max(res, height * width)\n\n            stack.append(i)\n\n        return res\n\n\nif __name__ == \"__main__\":\n    sol = LargestRectangleArea()\n    assert sol.monotonic_stack([2, 1, 5, 6, 2, 3]) == 10\n    assert sol.monotonic_stack([2, 4]) == 4\n</code></pre>"},{"location":"grind-75/string/","title":"String","text":""},{"location":"grind-75/string/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 125. Valid Palindrome (Easy)</li> <li> 242. Valid Anagram (Easy)</li> <li> 409. Longest Palindrome (Easy)</li> <li> 3. Longest Substring Without Repeating Characters (Medium)</li> <li> 8. String to Integer (atoi) (Medium)</li> <li> 5. Longest Palindromic Substring (Medium)</li> <li> 438. Find All Anagrams in a String (Medium)</li> <li> 76. Minimum Window Substring (Hard)</li> </ul>"},{"location":"grind-75/string/#125-valid-palindrome","title":"125. Valid Palindrome","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String</p> </li> </ul> Python <pre><code># List Comprehension\ndef isPalindrome(s: str) -&gt; bool:\n    s = [char.lower() for char in s if char.isalnum()]\n    return s == s[::-1]\n\n\n# Left Right Pointers\ndef isPalindromeLR(s: str) -&gt; bool:\n    left, right = 0, len(s) - 1\n\n    while left &lt; right:\n        while left &lt; right and not s[left].isalnum():\n            left += 1\n        while left &lt; right and not s[right].isalnum():\n            right -= 1\n\n        if s[left].lower() != s[right].lower():\n            return False\n\n        left += 1\n        right -= 1\n\n    return True\n\n\ns = \"A man, a plan, a canal: Panama\"\nprint(isPalindrome(s))  # True\nprint(isPalindromeLR(s))  # True\n</code></pre>"},{"location":"grind-75/string/#242-valid-anagram","title":"242. Valid Anagram","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sorting</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return true if an input string is an anagram of another string.\n-   An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once, e.g., `listen` is an anagram of `silent`.\n\"\"\"\n\nfrom collections import Counter\n\n\n# Hashmap\ndef isAnagramHash(s: str, t: str) -&gt; bool:\n    \"\"\"Return True if t is an anagram of s, False otherwise.\"\"\"\n    if len(s) != len(t):\n        return False\n\n    count = dict()\n\n    for i in s:\n        if i in count:\n            count[i] += 1\n        else:\n            count[i] = 1\n\n    for j in t:\n        if j in count:\n            count[j] -= 1\n        else:\n            return False\n\n    for count in count.values():\n        if count != 0:\n            return False\n\n    return True\n\n\n# Array\ndef isAnagramArray(s: str, t: str) -&gt; bool:\n    if len(s) != len(t):\n        return False\n\n    count = [0 for _ in range(26)]\n\n    for i in s:\n        count[ord(i) - ord(\"a\")] += 1\n\n    for j in t:\n        count[ord(j) - ord(\"a\")] -= 1\n\n    for i in count:\n        if i != 0:\n            return False\n\n    return True\n\n\n# Counter\ndef isAnagramCounter(s: str, t: str) -&gt; bool:\n    return Counter(s) == Counter(t)\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |   Hashmap   |       O(n)      |     O(1)     |\n# |    Array    |       O(n)      |     O(1)     |\n# |   Counter   |       O(n)      |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\ns = \"anagram\"\nt = \"nagaram\"\nprint(isAnagramHash(s, t))  # True\nprint(isAnagramArray(s, t))  # True\nprint(isAnagramCounter(s, t))  # True\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool isAnagram(string s, string t) {\n        if (s.size() != t.size()) return false;\n\n        vector&lt;int&gt; count(26, 0);\n\n        for (char ch : s) count[ch - 'a']++;\n        for (char ch : t) count[ch - 'a']--;\n        for (int c : count) {\n            if (c != 0) return false;\n        }\n\n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n    assert(solution.isAnagram(\"anagram\", \"nagaram\") == true);\n    assert(solution.isAnagram(\"rat\", \"car\") == false);\n    assert(solution.isAnagram(\"a\", \"ab\") == false);\n    assert(solution.isAnagram(\"a\", \"a\") == true);\n    return 0;\n}\n</code></pre>"},{"location":"grind-75/string/#409-longest-palindrome","title":"409. Longest Palindrome","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Greedy</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the length of the longest palindrome that can be built with the characters in the string.\n\"\"\"\n\n\ndef longestPalindrome(s: str) -&gt; int:\n    hashmap = dict()\n    result = 0\n\n    for char in s:\n        if char not in hashmap or hashmap[char] == 0:\n            hashmap[char] = 1\n        else:\n            result += 2\n            hashmap[char] = 0\n\n    if any(hashmap.values()):\n        result += 1\n\n    return result\n\n\nprint(longestPalindrome(\"abccccdd\"))  # 7\n</code></pre>"},{"location":"grind-75/string/#3-longest-substring-without-repeating-characters","title":"3. Longest Substring Without Repeating Characters","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Classic variable sliding window problem. Use a set to keep track of the characters in the current window.\n- Return the length of the longest substring without repeating characters.\n- [Template tutorial by \u7075\u5c71\u8336\u827e\u5e9c](https://leetcode.cn/problems/longest-substring-without-repeating-characters/solutions/1959540/xia-biao-zong-suan-cuo-qing-kan-zhe-by-e-iaks)\n\"\"\"\n\nfrom collections import defaultdict\n\n\n# Sliding Window Variable Max - HashMap\ndef lengthOfLongestSubstringHash(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    left = 0\n    cnt = defaultdict(int)\n    res = 0\n\n    for right in range(n):\n        cnt[s[right]] += 1\n\n        while cnt[s[right]] &gt; 1:\n            cnt[s[left]] -= 1\n            left += 1\n\n        res = max(res, right - left + 1)\n\n    return res\n\n\n# Sliding Window Variable Max - Set\ndef lengthOfLongestSubstringSet(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    left = 0\n    res = 0\n    window = set()\n\n    for right in range(n):\n        while left &lt; right and s[right] in window:\n            window.remove(s[left])\n            left += 1\n        window.add(s[right])\n        res = max(res, right - left + 1)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    s = \"abcabcbb\"\n    assert lengthOfLongestSubstringHash(s) == 3\n    assert lengthOfLongestSubstringSet(s) == 3\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;unordered_set&gt;\nusing namespace std;\n\nint lengthOfLongestSubstring(string s) {\n    int n = s.length();\n    int res = 0;\n    int left = 0;\n    unordered_set&lt;char&gt; window;\n\n    for (int right = 0; right &lt; n; right++) {\n        char ch = s[right];\n\n        while (window.find(ch) != window.end()) {\n            window.erase(s[left]);\n            left++;\n        }\n\n        window.insert(ch);\n        res = max(res, right - left + 1);\n    }\n    return (int)res;\n}\n\nint main() {\n    string s = \"abcabcbb\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 3\n    s = \"bbbbb\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 1\n    s = \"pwwkew\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 3\n    return 0;\n}\n</code></pre>"},{"location":"grind-75/string/#8-string-to-integer-atoi","title":"8. String to Integer (atoi)","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String</p> </li> </ul>"},{"location":"grind-75/string/#5-longest-palindromic-substring","title":"5. Longest Palindromic Substring","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Dynamic Programming</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the longest palindromic substring in `s`.\n\"\"\"\n\n\n# DP - Interval\ndef longestPalindromeDP(s: str) -&gt; str:\n    n = len(s)\n    if n &lt;= 1:\n        return s\n\n    start, maxLen = 0, 1\n\n    # Init\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for j in range(1, n):\n        for i in range(j):\n            if s[i] == s[j]:\n                if j - i &lt;= 2:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1]\n\n                if dp[i][j] and j - i + 1 &gt; maxLen:\n                    maxLen = j - i + 1\n                    start = i\n\n    return s[start : start + maxLen]\n\n\n# Expand Around Center\ndef longestPalindromeCenter(s: str) -&gt; str:\n    def expand_around_center(left, right):\n        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n\n    if len(s) &lt;= 1:\n        return s\n\n    start, end = 0, 0\n    for i in range(len(s)):\n        len1 = expand_around_center(i, i)  # odd\n        len2 = expand_around_center(i, i + 1)  # even\n\n        maxLen = max(len1, len2)\n        if maxLen &gt; end - start:\n            start = i - (maxLen - 1) // 2\n            end = i + maxLen // 2\n\n    return s[start : end + 1]\n\n\ns = \"babad\"\nprint(longestPalindromeDP(s))  # \"bab\"\nprint(longestPalindromeCenter(s))  # \"aba\"\n</code></pre>"},{"location":"grind-75/string/#438-find-all-anagrams-in-a-string","title":"438. Find All Anagrams in a String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Sliding Window Fixed Size\ndef findAnagrams(s: str, p: str) -&gt; List[int]:\n    n, k = len(s), len(p)\n    target = [0 for _ in range(26)]\n    for ch in p:\n        target[ord(ch) - ord(\"a\")] += 1\n\n    count = [0 for _ in range(26)]\n    left = 0\n    res = []\n\n    for right in range(n):\n        count[ord(s[right]) - ord(\"a\")] += 1\n        if right &lt; k - 1:\n            continue\n\n        if count == target:\n            res.append(left)\n\n        count[ord(s[left]) - ord(\"a\")] -= 1\n        left += 1\n\n    return res\n\n\ns = \"cbaebabacd\"\np = \"abc\"\nprint(findAnagrams(s, p))  # [0, 6]\n</code></pre>"},{"location":"grind-75/string/#76-minimum-window-substring","title":"76. Minimum Window Substring","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> Python <pre><code>from collections import Counter\n\n\ndef minWindow(s: str, t: str) -&gt; str:\n    if not t or not s:\n        return \"\"\n\n    counts = Counter(t)\n    required = len(counts)\n\n    left, right = 0, 0\n    formed = 0\n    window_counts = dict()\n\n    result = float(\"inf\"), None, None\n\n    while right &lt; len(s):\n        char = s[right]\n        window_counts[char] = window_counts.get(char, 0) + 1\n        if char in counts and window_counts[char] == counts[char]:\n            formed += 1\n\n        while left &lt;= right and formed == required:\n            char = s[left]\n            if right - left + 1 &lt; result[0]:\n                result = (right - left + 1, left, right)\n            window_counts[char] -= 1\n            if char in counts and window_counts[char] &lt; counts[char]:\n                formed -= 1\n            left += 1\n\n        right += 1\n\n    return \"\" if result[0] == float(\"inf\") else s[result[1] : result[2] + 1]\n\n\ns = \"ADOBECODEBANC\"\nt = \"ABC\"\nprint(minWindow(s, t))  # BANC\n</code></pre>"},{"location":"grind-75/trie/","title":"Trie","text":""},{"location":"grind-75/trie/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 208. Implement Trie (Prefix Tree) (Medium)</li> <li> 139. Word Break (Medium)</li> </ul>"},{"location":"grind-75/trie/#208-implement-trie-prefix-tree","title":"208. Implement Trie (Prefix Tree)","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Design, Trie</p> </li> </ul> Python <pre><code>\"\"\"\n### Trie\n\n- A trie is a tree-like data structure whose nodes store the letters of an alphabet.\n\"\"\"\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.endOfWord = None\n\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.endOfWord = True\n\n    def search(self, word: str) -&gt; bool:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return node.endOfWord\n\n    def startsWith(self, prefix: str) -&gt; bool:\n        node = self.root\n\n        for c in prefix:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return True\n\n\n# Your Trie object will be instantiated and called as such:\nobj = Trie()\nobj.insert(\"apple\")\nprint(obj.search(\"word\"))  # False\nprint(obj.startsWith(\"app\"))  # True\n</code></pre>"},{"location":"grind-75/trie/#139-word-break","title":"139. Word Break","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Dynamic Programming, Trie, Memoization</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\n# DP (Unbounded Knapsack)\ndef wordBreak(s: str, wordDict: List[str]) -&gt; bool:\n    n = len(s)\n    dp = [False for _ in range(n + 1)]\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for word in wordDict:\n            m = len(word)\n            if s[i - m : i] == word and dp[i - m]:\n                dp[i] = True\n    return dp[-1]\n\n\ns = \"leetcode\"\nwordDict = [\"leet\", \"code\"]\nprint(wordBreak(s, wordDict))  # True\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;cassert&gt;\n#include &lt;ranges&gt;\n#include &lt;string&gt;\n#include &lt;unordered_set&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) {\n        int max_len = ranges::max(wordDict, {}, &amp;string::length).length();\n        unordered_set&lt;string&gt; words(wordDict.begin(), wordDict.end());\n\n        int n = s.length();\n        vector&lt;int&gt; f(n + 1);\n        f[0] = true;\n        for (int i = 1; i &lt;= n; i++) {\n            for (int j = i - 1; j &gt;= max(i - max_len, 0); j--) {\n                if (f[j] &amp;&amp; words.count(s.substr(j, i - j))) {\n                    f[i] = true;\n                    break;\n                }\n            }\n        }\n        return f[n];\n    }\n};\n\nint main() {\n    Solution solution;\n    string s = \"leetcode\";\n    vector&lt;string&gt; wordDict = {\"leet\", \"code\"};\n    assert(solution.wordBreak(s, wordDict) == true);\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/1d_dynamic_programming/","title":"1D Dynamic Programming","text":""},{"location":"interview-150/1d_dynamic_programming/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 70. Climbing Stairs (Easy)</li> <li> 198. House Robber (Medium)</li> <li> 139. Word Break (Medium)</li> <li> 322. Coin Change (Medium)</li> <li> 300. Longest Increasing Subsequence (Medium)</li> </ul>"},{"location":"interview-150/1d_dynamic_programming/#70-climbing-stairs","title":"70. Climbing Stairs","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Memoization</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return the number of distinct ways to reach the top of the stairs.\n- `dp[n]` stores the number of distinct ways to reach the `n-th` stair.\n- Formula: `dp[n] = dp[n - 1] + dp[n - 2]`.\n- Initialize `dp[0] = 0`, `dp[1] = 1`, and `dp[2] = 2`.\n\"\"\"\n\nfrom functools import cache\n\n\n# DP\ndef climbStairsDP(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    dp = [i for i in range(n + 1)]\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\n# DP (Optimized)\ndef climbStairsDPOptimized(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    first, second = 1, 2\n\n    for _ in range(3, n + 1):\n        first, second = second, first + second\n\n    return second\n\n\n# Recursion\ndef climbStairsRecursion(n: int) -&gt; int:\n    @cache\n    def dfs(i: int) -&gt; int:\n        if i &lt;= 1:\n            return 1\n        return dfs(i - 1) + dfs(i - 2)\n\n    return dfs(n)\n\n\n# Greedy\ndef climbStairsGreedy(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    p1, p2 = 1, 2\n\n    for _ in range(3, n + 1):\n        p1, p2 = p2, p1 + p2\n\n    return p2\n\n\nif __name__ == \"__main__\":\n    assert climbStairsDP(10) == 89\n    assert climbStairsDPOptimized(10) == 89\n    assert climbStairsRecursion(10) == 89\n    assert climbStairsGreedy(10) == 89\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nint climbStairs(int n) {\n    if (n &lt;= 2) return n;\n    int f1 = 1, f2 = 2;\n    int res;\n\n    int i = 3;\n    while (i &lt;= n) {\n        res = f1 + f2;\n        f1 = f2;\n        f2 = res;\n        i++;\n    }\n    return res;\n}\n\nint main() {\n    assert(climbStairs(2) == 2);\n    assert(climbStairs(5) == 8);\n    assert(climbStairs(10) == 89);\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/1d_dynamic_programming/#198-house-robber","title":"198. House Robber","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> PythonCPP <pre><code>from functools import cache\nfrom typing import List\n\n\nclass Rob:\n    \"\"\"\n    dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n    \"\"\"\n\n    def incursive(self, nums: List[int]) -&gt; int:\n        \"\"\"\n        time complexity: O(n)\n        space complexity: O(n)\n        \"\"\"\n        n = len(nums)\n        if n &lt;= 2:\n            return max(nums)\n\n        # init\n        dp = [0 for _ in range(n)]\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n        # update\n        for i in range(2, n):\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n        return dp[-1]\n\n    def incursive_optimized(self, nums: List[int]) -&gt; int:\n        \"\"\"\n        time complexity: O(n)\n        space complexity: O(1)\n        \"\"\"\n        f0, f1 = 0, 0\n\n        for num in nums:\n            f0, f1 = f1, max(f1, f0 + num)\n\n        return f1\n\n    def memoization(self, nums: List[int]) -&gt; int:\n        \"\"\"\n        time complexity: O(n)\n        space complexity: O(n)\n        \"\"\"\n        n = len(nums)\n\n        @cache\n        def dp(i: int) -&gt; int:\n            if i &lt; 0:\n                return 0\n            return max(dp(i - 1), dp(i - 2) + nums[i])\n\n        return dp(n - 1)\n\n\nif __name__ == \"__main__\":\n    nums = [2, 7, 9, 3, 1]\n    rob = Rob()\n    assert rob.incursive(nums) == 12\n    assert rob.incursive_optimized(nums) == 12\n    assert rob.memoization(nums) == 12\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint rob(vector&lt;int&gt; &amp;nums) {\n    int prev = 0, cur = 0, temp = 0;\n\n    for (int num : nums) {\n        temp = cur;\n        cur = max(cur, prev + num);\n        prev = temp;\n    }\n    return cur;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {2, 7, 9, 3, 1};\n    cout &lt;&lt; rob(nums) &lt;&lt; endl;  // 12\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/1d_dynamic_programming/#139-word-break","title":"139. Word Break","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Dynamic Programming, Trie, Memoization</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\n# DP (Unbounded Knapsack)\ndef wordBreak(s: str, wordDict: List[str]) -&gt; bool:\n    n = len(s)\n    dp = [False for _ in range(n + 1)]\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for word in wordDict:\n            m = len(word)\n            if s[i - m : i] == word and dp[i - m]:\n                dp[i] = True\n    return dp[-1]\n\n\ns = \"leetcode\"\nwordDict = [\"leet\", \"code\"]\nprint(wordBreak(s, wordDict))  # True\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;cassert&gt;\n#include &lt;ranges&gt;\n#include &lt;string&gt;\n#include &lt;unordered_set&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) {\n        int max_len = ranges::max(wordDict, {}, &amp;string::length).length();\n        unordered_set&lt;string&gt; words(wordDict.begin(), wordDict.end());\n\n        int n = s.length();\n        vector&lt;int&gt; f(n + 1);\n        f[0] = true;\n        for (int i = 1; i &lt;= n; i++) {\n            for (int j = i - 1; j &gt;= max(i - max_len, 0); j--) {\n                if (f[j] &amp;&amp; words.count(s.substr(j, i - j))) {\n                    f[i] = true;\n                    break;\n                }\n            }\n        }\n        return f[n];\n    }\n};\n\nint main() {\n    Solution solution;\n    string s = \"leetcode\";\n    vector&lt;string&gt; wordDict = {\"leet\", \"code\"};\n    assert(solution.wordBreak(s, wordDict) == true);\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/1d_dynamic_programming/#322-coin-change","title":"322. Coin Change","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Breadth First Search</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef coinChange(coins: List[int], amount: int) -&gt; int:\n    dp = [float(\"inf\") for _ in range(amount + 1)]\n\n    dp[0] = 0\n\n    for i in range(1, amount + 1):\n        for c in coins:\n            if i - c &gt;= 0:\n                dp[i] = min(dp[i], 1 + dp[i - c])\n\n    return dp[amount] if dp[amount] != float(\"inf\") else -1\n\n\ncoins = [1, 2, 5]\namount = 11\nprint(coinChange(coins, amount))  # 3\n</code></pre>"},{"location":"interview-150/1d_dynamic_programming/#300-longest-increasing-subsequence","title":"300. Longest Increasing Subsequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Dynamic Programming</p> </li> </ul> Python <pre><code>from functools import cache\nfrom typing import List\n\n\n# DP - LIS\ndef lengthOfLISMemo(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return n\n\n    @cache\n    def dfs(i: int) -&gt; int:\n        res = 0\n        for j in range(i):\n            if nums[j] &lt; nums[i]:\n                res = max(res, dfs(j))\n        return res + 1\n\n    return max(dfs(i) for i in range(n))\n\n\n# DP - LIS\ndef lengthOfLISTable(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return n\n\n    dp = [1 for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i):\n            if nums[i] &gt; nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\n\nif __name__ == \"__main__\":\n    assert lengthOfLISMemo([10, 9, 2, 5, 3, 7, 101, 18]) == 4\n    assert lengthOfLISTable([10, 9, 2, 5, 3, 7, 101, 18]) == 4\n    assert lengthOfLISMemo([0, 1, 0, 3, 2, 3]) == 4\n    assert lengthOfLISTable([0, 1, 0, 3, 2, 3]) == 4\n    assert lengthOfLISMemo([7, 7, 7, 7]) == 1\n    assert lengthOfLISTable([7, 7, 7, 7]) == 1\n</code></pre>"},{"location":"interview-150/arrays_string/","title":"Arrays String","text":""},{"location":"interview-150/arrays_string/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 88. Merge Sorted Array (Easy)</li> <li> 27. Remove Element (Easy)</li> <li> 26. Remove Duplicates from Sorted Array (Easy)</li> <li> 80. Remove Duplicates from Sorted Array II (Medium)</li> <li> 169. Majority Element (Easy)</li> <li> 189. Rotate Array (Medium)</li> <li> 121. Best Time to Buy and Sell Stock (Easy)</li> <li> 122. Best Time to Buy and Sell Stock II (Medium)</li> <li> 55. Jump Game (Medium)</li> <li> 45. Jump Game II (Medium)</li> <li> 274. H-Index (Medium)</li> <li> 380. Insert Delete GetRandom O(1) (Medium)</li> <li> 238. Product of Array Except Self (Medium)</li> <li> 134. Gas Station (Medium)</li> <li> 135. Candy (Hard)</li> <li> 42. Trapping Rain Water (Hard)</li> <li> 13. Roman to Integer (Easy)</li> <li> 12. Integer to Roman (Medium)</li> <li> 58. Length of Last Word (Easy)</li> <li> 14. Longest Common Prefix (Easy)</li> <li> 151. Reverse Words in a String (Medium)</li> <li> 6. Zigzag Conversion (Medium)</li> <li> 28. Find the Index of the First Occurrence in a String (Easy)</li> <li> 68. Text Justification (Hard)</li> </ul>"},{"location":"interview-150/arrays_string/#88-merge-sorted-array","title":"88. Merge Sorted Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Sorting</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\nclass merge:\n    @staticmethod\n    def lr(nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None:\n        \"\"\"\n        Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        p1, p2, t = m - 1, n - 1, m + n - 1\n\n        while p1 &gt;= 0 or p2 &gt;= 0:\n            if p1 == -1:\n                nums1[t] = nums2[p2]\n                p2 -= 1\n            elif p2 == -1:\n                nums1[t] = nums1[p1]\n                p1 -= 1\n            elif nums1[p1] &gt; nums2[p2]:\n                nums1[t] = nums1[p1]\n                p1 -= 1\n            else:\n                nums1[t] = nums2[p2]\n                p2 -= 1\n\n            t -= 1\n\n\nif __name__ == \"__main__\":\n    nums1 = [1, 2, 3, 0, 0, 0]\n    m = 3\n    nums2 = [2, 5, 6]\n    n = 3\n    merge.lr(nums1, m, nums2, n)\n    assert nums1 == [1, 2, 2, 3, 5, 6]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {\n        int p1 = m - 1, p2 = n - 1, t = m + n - 1;\n\n        while (p1 &gt;= 0 || p2 &gt;= 0) {\n            if (p1 == -1) {\n                nums1[t] = nums2[p2];\n                p2--;\n            } else if (p2 == -1) {\n                nums1[t] = nums1[p1];\n                p1--;\n            } else if (nums1[p1] &gt; nums2[p2]) {\n                nums1[t] = nums1[p1];\n                p1--;\n            } else {\n                nums1[t] = nums2[p2];\n                p2--;\n            }\n            t--;\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; nums1 = {1, 3, 6, 0, 0, 0};\n    vector&lt;int&gt; nums2 = {2, 5, 6};\n    vector&lt;int&gt; output = {1, 2, 3, 5, 6, 6};\n    solution.merge(nums1, 3, nums2, 3);\n    assert(nums1 == output);\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/arrays_string/#27-remove-element","title":"27. Remove Element","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Remove all instances of a given value in-place.\n\"\"\"\n\nfrom typing import List\n\n\n# Fast Slow Pointers\ndef removeElement(nums: List[int], val: int) -&gt; int:\n    fast, slow = 0, 0\n\n    while fast &lt; len(nums):\n        if nums[fast] != val:\n            nums[slow] = nums[fast]\n            slow += 1\n        fast += 1\n\n    return slow\n\n\nnums = [0, 1, 2, 2, 3, 0, 4, 2]\nval = 2\nprint(removeElement(nums, val))  # 5\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// Fast Slow Pointers\nint removeElement(vector&lt;int&gt;&amp; nums, int val) {\n    size_t n = nums.size();\n    size_t slow = 0, fast = 0;\n\n    while (fast &lt; n) {\n        if (nums[fast] != val) {\n            nums[slow] = nums[fast];\n            slow++;\n        }\n        fast++;\n    }\n    return (int)slow;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {3, 2, 2, 3};\n    int val = 3;\n    cout &lt;&lt; removeElement(nums, val) &lt;&lt; endl;  // 2\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/arrays_string/#26-remove-duplicates-from-sorted-array","title":"26. Remove Duplicates from Sorted Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Remove duplicates in-place.\n\"\"\"\n\nfrom typing import List\n\n\ndef removeDuplicates(nums: List[int]) -&gt; int:\n    fast, slow = 1, 1\n\n    while fast &lt; len(nums):\n        if nums[fast] != nums[fast - 1]:\n            nums[slow] = nums[fast]\n            slow += 1\n        fast += 1\n\n    return slow\n\n\nnums = [1, 1, 2]\nprint(removeDuplicates(nums))  # 2\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int removeDuplicates(vector&lt;int&gt;&amp; nums) {\n        int fast = 1, slow = 1;\n        int n = nums.size();\n\n        while (fast &lt; n) {\n            if (nums[fast] != nums[fast - 1]) {\n                nums[slow] = nums[fast];\n                slow++;\n            }\n            fast++;\n        }\n        return slow;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; nums = {0, 0, 1, 1, 1, 2, 2, 3, 3, 4};\n    assert(solution.removeDuplicates(nums) == 5);\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/arrays_string/#80-remove-duplicates-from-sorted-array-ii","title":"80. Remove Duplicates from Sorted Array II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Allow at most two duplicates.\n-   fast pointer: explore the array\n-   slow pointer: point to the position to be replaced\n\"\"\"\n\nfrom typing import List\n\n\ndef removeDuplicates(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 2:\n        return len(nums)\n\n    fast, slow = 2, 2\n\n    while fast &lt; len(nums):\n        if nums[fast] != nums[slow - 2]:\n            nums[slow] = nums[fast]\n            slow += 1\n        fast += 1\n\n    return slow\n\n\nnums = [1, 1, 1, 2, 2, 3]\nprint(removeDuplicates(nums))\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int removeDuplicates(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n        if (n &lt;= 2) return n;\n\n        int fast = 2, slow = 2;\n\n        while (fast &lt; n) {\n            if (nums[fast] != nums[slow - 2]) {\n                nums[slow] = nums[fast];\n                slow++;\n            }\n            fast++;\n        }\n        return slow;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; nums = {0, 0, 1, 1, 1, 1, 2, 2, 3, 3, 4};\n    assert(solution.removeDuplicates(nums) == 9);\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/arrays_string/#169-majority-element","title":"169. Majority Element","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Divide And Conquer, Sorting, Counting</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the majority element in an array. The majority element is the element that appears more than `n // 2` times.\n\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/7pnhv842keE?si=fBYlNfKzdkiLgkF1\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen&gt;&lt;/iframe&gt;\n\n| `num` | `count` | `res` |\n| ----- | ------- | ----- |\n| 2     | 1       | 2     |\n| 2     | 2       | 2     |\n| 1     | 1       | 2     |\n| 1     | 0       | 2     |\n| 1     | 1       | 1     |\n| 2     | 0       | 1     |\n| 2     | 1       | 2     |\n\"\"\"\n\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Hash Map\ndef majorityElementHashMap(nums: List[int]) -&gt; int:\n    n = len(nums)\n    freq = defaultdict(int)\n\n    for num in nums:\n        freq[num] += 1\n        if freq[num] &gt; n // 2:\n            return num\n\n\n# Array - Boyer-Moore Voting Algorithm\ndef majorityElementArray(nums: List[int]) -&gt; int:\n    res = None\n    count = 0\n\n    for num in nums:\n        if count == 0:\n            res = num\n        count += 1 if num == res else -1\n\n    return res\n\n\n# | Algorithm | Time Complexity | Space Complexity |\n# |-----------|-----------------|------------------|\n# | HashMap   | O(N)            | O(N)             |\n# | Array     | O(N)            | O(1)             |\n# |-----------|-----------------|------------------|\n\n\nnums = [2, 2, 1, 1, 1, 2, 2]\nprint(majorityElementArray(nums))  # 2\nprint(majorityElementHashMap(nums))  # 2\n</code></pre>"},{"location":"interview-150/arrays_string/#189-rotate-array","title":"189. Rotate Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Two Pointers</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Rotate array with reversing subarrays\n\"\"\"\n\nfrom typing import List\n\n\n# Array\ndef rotate(nums: List[int], k: int) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n\n    def reverse(i: int, j: int) -&gt; None:\n        while i &lt; j:\n            nums[i], nums[j] = nums[j], nums[i]\n            i += 1\n            j -= 1\n\n    n = len(nums)\n    k %= n\n    reverse(0, n - 1)\n    reverse(0, k - 1)\n    reverse(k, n - 1)\n\n\nnums = [1, 2, 3, 4, 5, 6, 7]\nk = 3\nrotate(nums, k)\nprint(nums)  # [5, 6, 7, 1, 2, 3, 4]\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// Array\nvoid rotate(vector&lt;int&gt;&amp; nums, int k) {\n    k %= nums.size();\n\n    reverse(nums.begin(), nums.end());\n    reverse(nums.begin(), nums.begin() + k);\n    reverse(nums.begin() + k, nums.end());\n}\n\nint main() {\n    vector&lt;int&gt; nums = {1, 2, 3, 4, 5, 6, 7};\n    int k = 3;\n    rotate(nums, k);\n    // [5, 6, 7, 1, 2, 3, 4]\n    for (const auto&amp; num : nums) {\n        cout &lt;&lt; num &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/arrays_string/#121-best-time-to-buy-and-sell-stock","title":"121. Best Time to Buy and Sell Stock","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return the maximum profit that can be achieved from buying on one day and selling on another day.\n\"\"\"\n\nfrom typing import List\n\n\n# Brute Force\ndef maxProfitBF(prices: List[int]) -&gt; int:\n    max_profit = 0\n    n = len(prices)\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_profit = max(max_profit, prices[j] - prices[i])\n\n    return max_profit\n\n\n# DP\ndef maxProfitDP(prices: List[int]) -&gt; int:\n    dp = [[0] * 2 for _ in range(len(prices))]\n    dp[0][0] = -prices[0]  # buy\n    dp[0][1] = 0  # sell\n\n    for i in range(1, len(prices)):\n        dp[i][0] = max(dp[i - 1][0], -prices[i])  # the lowest price to buy\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    max_profit = 0\n    seen_min = prices[0]\n\n    for i in range(1, len(prices)):\n        max_profit = max(max_profit, prices[i] - seen_min)\n        seen_min = min(seen_min, prices[i])\n\n    return max_profit\n\n\n# Fast Slow Pointers\ndef maxProfitFS(prices: List[int]) -&gt; int:\n    max_profit = 0\n    slow, fast = 0, 1\n\n    while fast &lt; len(prices):\n        if prices[fast] &gt; prices[slow]:\n            max_profit = max(max_profit, prices[fast] - prices[slow])\n        else:\n            slow = fast\n        fast += 1\n\n    return max_profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force|  O(n^2)|  O(1)   |\n# | DP         |  O(n)  |  O(n)   |\n# | Greedy     |  O(n)  |  O(1)   |\n# | Fast Slow  |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitBF(prices))  # 5\nprint(maxProfitDP(prices))  # 5\nprint(maxProfitGreedy(prices))  # 5\nprint(maxProfitFS(prices))  # 5\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int maxProfitMemo(vector&lt;int&gt; &amp;prices) {\n        if (prices.size() &lt;= 1) return 0;\n\n        int seen_min = prices[0];\n        int res = 0;\n\n        for (int &amp;price : prices) {\n            res = max(res, price - seen_min);\n            seen_min = min(seen_min, price);\n        }\n        return res;\n    }\n};\n\nint main() {\n    vector&lt;int&gt; prices = {7, 1, 5, 3, 6, 4};\n    Solution obj;\n    cout &lt;&lt; obj.maxProfitMemo(prices) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/arrays_string/#122-best-time-to-buy-and-sell-stock-ii","title":"122. Best Time to Buy and Sell Stock II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return the maximum profit you can achieve.\n\"\"\"\n\nfrom typing import List\n\n\n# DP\ndef maxProfitDP1(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 2 for _ in range(n)]\n    dp[0][0] = -prices[0]\n    dp[0][1] = 0\n\n    for i in range(1, n):\n        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i])\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# DP - Optimized\ndef maxProfitDP2(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    hold = -prices[0]\n    profit = 0\n\n    for i in range(1, n):\n        hold = max(hold, profit - prices[i])\n        profit = max(profit, hold + prices[i])\n\n    return profit\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    profit = 0\n\n    for i in range(1, len(prices)):\n        profit += max(prices[i] - prices[i - 1], 0)\n\n    return profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |     DP1    |  O(n)  |   O(n)  |\n# |     DP2    |  O(n)  |   O(1)  |\n# |   Greedy   |  O(n)  |   O(1)  |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitDP1(prices))  # 7\nprint(maxProfitDP2(prices))  # 7\nprint(maxProfitGreedy(prices))  # 7\n</code></pre> <pre><code>#include &lt;array&gt;\n#include &lt;cassert&gt;\n#include &lt;climits&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int maxProfitMemo(vector&lt;int&gt;&amp; prices) {\n        int n = prices.size();\n        vector&lt;array&lt;int, 2&gt;&gt; memo(n, {-1, -1});\n\n        auto dfs = [&amp;](this auto&amp;&amp; dfs, int i, bool hold) -&gt; int {\n            if (i &lt; 0) {\n                return hold ? INT_MIN : 0;\n            }\n            int&amp; res = memo[i][hold];\n            if (res != -1) {\n                return res;\n            }\n            if (hold) {\n                return res = max(dfs(i - 1, true),                // skip\n                                 dfs(i - 1, false) - prices[i]);  // buy\n            } else {\n                return res = max(dfs(i - 1, false),              // skip\n                                 dfs(i - 1, true) + prices[i]);  // sell\n            }\n        };\n\n        return dfs(n - 1, false);\n    }\n\n    int maxProfitIterative(vector&lt;int&gt;&amp; prices) {\n        int n = prices.size();\n        vector&lt;array&lt;int, 2&gt;&gt; dp(n, {0, 0});\n        dp[0][0] = -prices[0];\n        dp[0][1] = 0;\n\n        for (int i = 1; i &lt; n; i++) {\n            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);  // buy\n            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);  // sell\n        }\n        return dp[n - 1][1];\n    }\n\n    int maxProfitIterativeOptimized(vector&lt;int&gt;&amp; prices) {\n        int n = prices.size();\n        if (n &lt;= 1) return 0;\n\n        int hold = -prices[0], res = 0;\n\n        for (int i = 1; i &lt; n; i++) {\n            hold = max(hold, res - prices[i]);  // buy\n            res = max(res, hold + prices[i]);   // sell\n        }\n        return res;\n    }\n\n    int maxProfitGreedy(vector&lt;int&gt;&amp; prices) {\n        int n = prices.size();\n        if (n &lt;= 1) return 0;\n\n        int res = 0;\n\n        for (int i = 1; i &lt; n; i++) {\n            if (prices[i] &gt; prices[i - 1]) {\n                res += prices[i] - prices[i - 1];\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; prices = {7, 1, 5, 3, 6, 4};\n    assert(solution.maxProfitMemo(prices) == 7);\n    assert(solution.maxProfitIterative(prices) == 7);\n    assert(solution.maxProfitIterativeOptimized(prices) == 7);\n    assert(solution.maxProfitGreedy(prices) == 7);\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/arrays_string/#55-jump-game","title":"55. Jump Game","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return `True` if you can reach the last index, otherwise `False`.\n\"\"\"\n\nfrom typing import List\n\n\n# Greedy - Interval\ndef canJump(nums: List[int]) -&gt; bool:\n    n = len(nums)\n    reach = 0\n    i = 0\n\n    while reach &gt;= i:\n        if reach &gt;= n - 1:\n            return True\n        reach = max(reach, i + nums[i])\n        i += 1\n\n    return False\n\n\nif __name__ == \"__main__\":\n    assert canJump([2, 3, 1, 1, 4]) is True\n    assert canJump([3, 2, 1, 0, 4]) is False\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool canJump(vector&lt;int&gt;&amp; nums) {\n        int canReach = 0;\n        int n = nums.size();\n\n        for (int i = 0; i &lt; n; i++) {\n            if (i &gt; canReach) return false;\n            canReach = max(canReach, i + nums[i]);\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution obj;\n    vector&lt;int&gt; nums = {2, 3, 1, 1, 4};\n    cout &lt;&lt; obj.canJump(nums) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/arrays_string/#45-jump-game-ii","title":"45. Jump Game II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy</p> </li> </ul> Python <pre><code>\"\"\"\n- Return the minimum number of jumps to reach the last index.\n\"\"\"\n\nfrom typing import List\n\n\n# Greedy - Interval\ndef jump(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n == 1:\n        return 0\n\n    reach = 0\n    left, right = 0, 0\n    res = 0\n\n    while right &lt; n - 1:\n        for i in range(left, right + 1):\n            reach = max(reach, i + nums[i])\n\n        left = right + 1\n        right = reach\n        res += 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert jump([2, 3, 1, 1, 4]) == 2\n    assert jump([2, 3, 0, 1, 4]) == 2\n</code></pre>"},{"location":"interview-150/arrays_string/#274-h-index","title":"274. H-Index","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sorting, Counting Sort</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Arrays\ndef hIndex(citations: List[int]) -&gt; int:\n    n = len(citations)\n    cnt = [0 for _ in range(n + 1)]\n\n    for c in citations:\n        cnt[min(c, n)] += 1\n\n    s = 0\n    for i in range(n, -1, -1):\n        s += cnt[i]\n        if s &gt;= i:\n            return i\n\n\nif __name__ == \"__main__\":\n    assert hIndex([3, 0, 6, 1, 5]) == 3\n    assert hIndex([1, 3, 1]) == 1\n    assert hIndex([1, 2, 3, 4, 5]) == 3\n    assert hIndex([0, 0, 0]) == 0\n</code></pre>"},{"location":"interview-150/arrays_string/#380-insert-delete-getrandom-o1","title":"380. Insert Delete GetRandom O(1)","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Design, Randomized</p> </li> </ul> Python <pre><code>import random\n\n\nclass RandomizedSet:\n    def __init__(self):\n        self.nums = []\n        self.pos = {}  # num: idx\n\n    def insert(self, val: int) -&gt; bool:\n        if val in self.pos:\n            return False\n        self.pos[val] = len(self.nums)\n        self.nums.append(val)\n        return True\n\n    def remove(self, val: int) -&gt; bool:\n        if val not in self.pos:\n            return False\n\n        idx = self.pos[val]\n        last_val = self.nums[-1]\n        self.nums[idx] = last_val\n        self.pos[last_val] = idx\n\n        self.nums.pop()\n        del self.pos[val]\n        return True\n\n    def getRandom(self) -&gt; int:\n        return random.choice(self.nums)\n\n\ndef test_RandomizedSet():\n    obj = RandomizedSet()\n    assert obj.insert(1)\n    assert not obj.remove(2)\n    assert obj.insert(2)\n    assert obj.getRandom() in [1, 2]\n    assert obj.remove(1)\n    assert not obj.insert(2)\n    assert obj.getRandom() == 2\n</code></pre>"},{"location":"interview-150/arrays_string/#238-product-of-array-except-self","title":"238. Product of Array Except Self","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Prefix Sum</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Classic **Prefix Sum** problem\n-   Return an array `output` such that `output[i]` is equal to the product of all the elements of `nums` except `nums[i]`.\n\n| Approach           | Time | Space |\n| ------------------ | ---- | ----- |\n| Prefix             | O(n) | O(n)  |\n| Prefix (Optimized) | O(n) | O(1)  |\n\"\"\"\n\nfrom typing import List\n\n\n# Prefix\ndef productExceptSelf(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    prefix = [1 for _ in range(n)]\n    suffix = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        prefix[i] = nums[i - 1] * prefix[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        suffix[i] = nums[i + 1] * suffix[i + 1]\n\n    result = [i * j for i, j in zip(prefix, suffix)]\n\n    return result\n\n\n# Prefix (Optimized)\ndef productExceptSelfOptimized(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    result = [1 for _ in range(n)]\n\n    prefix = 1\n    for i in range(n):\n        result[i] = prefix\n        prefix *= nums[i]\n\n    suffix = 1\n    for i in range(n - 1, -1, -1):\n        result[i] *= suffix\n        suffix *= nums[i]\n\n    return result\n\n\nprint(productExceptSelf([1, 2, 3, 4]))\n# [24, 12, 8, 6]\nprint(productExceptSelfOptimized([1, 2, 3, 4]))\n# [24, 12, 8, 6]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt; &amp;nums) {\n        int n = nums.size();\n        vector&lt;int&gt; prefix(n, 1);\n        vector&lt;int&gt; suffix(n, 1);\n        vector&lt;int&gt; res(n, 1);\n\n        for (int i = 1; i &lt; n; i++) {\n            prefix[i] = prefix[i - 1] * nums[i - 1];\n        }\n\n        for (int i = n - 2; i &gt;= 0; i--) {\n            suffix[i] = suffix[i + 1] * nums[i + 1];\n        }\n\n        for (int i = 0; i &lt; n; i++) {\n            res[i] = prefix[i] * suffix[i];\n        }\n        return res;\n    }\n};\n\nint main() {\n    vector&lt;int&gt; nums = {1, 2, 3, 4};\n    Solution obj;\n    vector&lt;int&gt; result = obj.productExceptSelf(nums);\n    assert(result == vector&lt;int&gt;({24, 12, 8, 6}));\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/arrays_string/#134-gas-station","title":"134. Gas Station","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\nclass canCompleteCircuit:\n    def greedy(self, gas: List[int], cost: List[int]) -&gt; int:\n        \"\"\"\n        Approach: Greedy\n        Time Complexity: O(n)\n        Space Complexity: O(1)\n        \"\"\"\n\n        # edge case\n        if sum(gas) &lt; sum(cost):\n            return -1\n\n        cur_sum = 0\n        start = 0\n\n        for i in range(len(gas)):\n            cur_sum += gas[i] - cost[i]\n\n            if cur_sum &lt; 0:\n                start = i + 1\n                cur_sum = 0\n\n        return start\n\n\nif __name__ == \"__main__\":\n    solution = canCompleteCircuit()\n    gas = [1, 2, 3, 4, 5]\n    cost = [3, 4, 5, 1, 2]\n    assert solution.greedy(gas, cost) == 3\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) {\n        int totalTank = 0, currTank = 0;\n        int start = 0;\n        int n = gas.size();\n\n        for (int i = 0; i &lt; n; i++) {\n            int diff = gas[i] - cost[i];\n            totalTank += diff;\n            currTank += diff;\n\n            if (currTank &lt; 0) {\n                start = i + 1;\n                currTank = 0;\n            }\n        }\n\n        return (totalTank &gt;= 0) ? start : -1;\n    }\n};\n\nint main() {\n    Solution obj;\n    vector&lt;int&gt; gas{1, 2, 3, 4, 5};\n    vector&lt;int&gt; cost{3, 4, 5, 1, 2};\n    int res = obj.canCompleteCircuit(gas, cost);\n    assert(res == 3);\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/arrays_string/#135-candy","title":"135. Candy","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the minimum number of candies you must give.\n\"\"\"\n\nfrom typing import List\n\n\n# Greedy\ndef candy(ratings: List[int]) -&gt; int:\n    # TC: O(n)\n    # SC: O(n)\n    n = len(ratings)\n\n    if n &lt;= 1:\n        return n\n\n    candy = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        if ratings[i] &gt; ratings[i - 1]:\n            candy[i] = candy[i - 1] + 1\n\n    for j in range(n - 2, -1, -1):\n        if ratings[j] &gt; ratings[j + 1]:\n            candy[j] = max(candy[j], candy[j + 1] + 1)\n\n    return sum(candy)\n\n\nratings = [1, 0, 2]\nprint(candy(ratings))  # 5\n</code></pre>"},{"location":"interview-150/arrays_string/#42-trapping-rain-water","title":"42. Trapping Rain Water","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Dynamic Programming, Stack, Monotonic Stack</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- ![42](../../assets/0042.png)\n\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/ZI2z5pq0TqA?si=OEYg01dbmzvmtIwZ\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen&gt;&lt;/iframe&gt;\n\n| Approach   | Time | Space |\n| ---------- | ---- | ----- |\n| DP         | O(N) | O(N)  |\n| Left Right | O(N) | O(1)  |\n| Monotonic  | O(N) | O(N)  |\n\"\"\"\n\nfrom typing import List\n\n\n# DP\ndef trapDP(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    n = len(height)\n    maxLeft, maxRight = [0 for _ in range(n)], [0 for _ in range(n)]\n\n    for i in range(1, n):\n        maxLeft[i] = max(maxLeft[i - 1], height[i - 1])\n\n    for i in range(n - 2, -1, -1):\n        maxRight[i] = max(maxRight[i + 1], height[i + 1])\n\n    res = 0\n    for i in range(n):\n        res += max(0, min(maxLeft[i], maxRight[i]) - height[i])\n\n    return res\n\n\n# Left Right Pointers\ndef trapLR(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    left, right = 0, len(height) - 1\n    maxL, maxR = height[left], height[right]\n    res = 0\n\n    while left &lt; right:\n        if maxL &lt; maxR:\n            left += 1\n            maxL = max(maxL, height[left])\n            res += maxL - height[left]\n        else:\n            right -= 1\n            maxR = max(maxR, height[right])\n            res += maxR - height[right]\n\n    return res\n\n\n# Monotonic Stack\ndef trapStack(height: List[int]) -&gt; int:\n    stack = []\n    total = 0\n\n    for i in range(len(height)):\n        while stack and height[i] &gt; height[stack[-1]]:\n            top = stack.pop()\n            if not stack:\n                break\n            distance = i - stack[-1] - 1\n            bounded_height = min(height[i], height[stack[-1]]) - height[top]\n            total += distance * bounded_height\n        stack.append(i)\n\n    return total\n\n\nheight = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\nprint(trapDP(height))  # 6\nprint(trapLR(height))  # 6\nprint(trapStack(height))  # 6\n</code></pre> <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int trap(vector&lt;int&gt; &amp;height)\n    {\n        if (height.empty())\n            return 0;\n\n        int res = 0;\n        int left = 0, right = height.size() - 1;\n        int maxL = height[left], maxR = height[right];\n\n        while (left &lt; right)\n        {\n            if (maxL &lt; maxR)\n            {\n                left++;\n                maxL = max(maxL, height[left]);\n                res += maxL - height[left];\n            }\n            else\n            {\n                right--;\n                maxR = max(maxR, height[right]);\n                res += maxR - height[right];\n            }\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    vector&lt;int&gt; height = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};\n    Solution solution;\n    cout &lt;&lt; solution.trap(height) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/arrays_string/#13-roman-to-integer","title":"13. Roman to Integer","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Math, String</p> </li> </ul> Python <pre><code>from itertools import pairwise\n\n\n# Arrays\ndef romanToInt(s: str) -&gt; int:\n    ROMAN = {\n        \"I\": 1,\n        \"V\": 5,\n        \"X\": 10,\n        \"L\": 50,\n        \"C\": 100,\n        \"D\": 500,\n        \"M\": 1000,\n    }\n\n    res = 0\n\n    for x, y in pairwise(s):\n        x, y = ROMAN[x], ROMAN[y]\n        res += x if x &gt;= y else -x\n\n    return res + ROMAN[s[-1]]\n\n\nif __name__ == \"__main__\":\n    assert romanToInt(\"III\") == 3\n    assert romanToInt(\"IV\") == 4\n    assert romanToInt(\"IX\") == 9\n    assert romanToInt(\"LVIII\") == 58\n    assert romanToInt(\"MCMXCIV\") == 1994\n    assert romanToInt(\"MMXXIII\") == 2023\n</code></pre>"},{"location":"interview-150/arrays_string/#12-integer-to-roman","title":"12. Integer to Roman","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Math, String</p> </li> </ul> Python <pre><code>def intToRoman(num: int) -&gt; str:\n    mapping = {\n        1000: \"M\",\n        900: \"CM\",\n        500: \"D\",\n        400: \"CD\",\n        100: \"C\",\n        90: \"XC\",\n        50: \"L\",\n        40: \"XL\",\n        10: \"X\",\n        9: \"IX\",\n        5: \"V\",\n        4: \"IV\",\n        1: \"I\",\n    }\n\n    res = \"\"\n    for val, symbol in mapping.items():\n        count = num // val\n        if count:\n            res += symbol * count\n            num -= val * count\n\n    return res\n</code></pre>"},{"location":"interview-150/arrays_string/#58-length-of-last-word","title":"58. Length of Last Word","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String</p> </li> </ul> Python <pre><code>class lengthOfLastWord:\n    def array(self, s: str) -&gt; int:\n        res = 0\n\n        for i in range(len(s) - 1, -1, -1):\n            if s[i] != \" \":\n                res += 1\n            elif s[i] == \" \" and res &gt; 0:\n                return res\n\n        return res\n\n\nif __name__ == \"__main__\":\n    solution = lengthOfLastWord()\n    assert solution.array(\"Hello World\") == 5\n</code></pre>"},{"location":"interview-150/arrays_string/#14-longest-common-prefix","title":"14. Longest Common Prefix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Trie</p> </li> </ul> Python <pre><code>from typing import List\n\n\nclass longestCommonPrefix:\n    def horizontal_scan(self, strs: List[str]) -&gt; str:\n        if not strs:\n            return \"\"\n\n        prefix = strs[0]\n        for i in range(1, len(strs)):\n            while not strs[i].startswith(prefix):\n                prefix = prefix[:-1]\n                if not prefix:\n                    return \"\"\n\n        return prefix\n\n    def vertical_scan(self, strs: List[str]) -&gt; str:\n        if not strs:\n            return \"\"\n\n        for i in range(len(strs[0])):\n            char = strs[0][i]\n            for j in range(1, len(strs)):\n                if i &gt;= len(strs[j]) or strs[j][i] != char:\n                    return strs[0][:i]\n\n        return strs[0]\n\n    def divide_conquer(self, strs: List[str]) -&gt; str:\n        if not strs:\n            return \"\"\n\n        def merge(left, right):\n            n = min(len(left), len(right))\n            for i in range(n):\n                if left[i] != right[i]:\n                    return left[:i]\n            return left[:n]\n\n        def find(strs, start, end):\n            if start == end:\n                return strs[start]\n            mid = start + (end - start) // 2\n            left = find(strs, start, mid)\n            right = find(strs, mid + 1, end)\n            return merge(left, right)\n\n        return find(strs, 0, len(strs) - 1)\n\n    def binary_search(self, strs: List[str]) -&gt; str:\n        if not strs:\n            return \"\"\n\n        def isCommonPrefix(strs, length):\n            prefix = strs[0][:length]\n            return all(s.startswith(prefix) for s in strs)\n\n        minLen = min(len(s) for s in strs)\n        low, high = 0, minLen\n        while low &lt; high:\n            mid = low + (high - low) // 2\n            if isCommonPrefix(strs, mid + 1):\n                low = mid + 1\n            else:\n                high = mid\n\n        return strs[0][:low]\n\n\nif __name__ == \"__main__\":\n    solution = longestCommonPrefix()\n    strs = [\"flower\", \"flow\", \"flight\"]\n    assert solution.horizontal_scan(strs) == \"fl\"\n    assert solution.vertical_scan(strs) == \"fl\"\n    assert solution.divide_conquer(strs) == \"fl\"\n    assert solution.binary_search(strs) == \"fl\"\n</code></pre>"},{"location":"interview-150/arrays_string/#151-reverse-words-in-a-string","title":"151. Reverse Words in a String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String</p> </li> </ul> Python <pre><code>def reverseWords(s: str) -&gt; str:\n    words = s.split()\n\n    left, right = 0, len(words) - 1\n\n    while left &lt; right:\n        words[left], words[right] = words[right], words[left]\n        left += 1\n        right -= 1\n\n    return \" \".join(words)\n\n\ns = \"the sky is blue\"\nprint(reverseWords(s))  # \"blue is sky the\"\n</code></pre>"},{"location":"interview-150/arrays_string/#6-zigzag-conversion","title":"6. Zigzag Conversion","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String</p> </li> </ul>"},{"location":"interview-150/arrays_string/#28-find-the-index-of-the-first-occurrence-in-a-string","title":"28. Find the Index of the First Occurrence in a String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, String Matching</p> </li> </ul> Python <pre><code>from leetpattern.utils import LPS\n\n\n# Brute Force\ndef strStrBF(haystack: str, needle: str) -&gt; int:\n    m, n = len(haystack), len(needle)\n    for i in range(m - n + 1):\n        if haystack[i : i + n] == needle:\n            return i\n    return -1\n\n\n# KMP\ndef strStrKMP(haystack: str, needle: str) -&gt; int:\n    lps = LPS(needle)\n    m, n = len(haystack), len(needle)\n    j = 0\n\n    for i in range(m):\n        while j &gt; 0 and haystack[i] != needle[j]:\n            j = lps[j - 1]\n        if haystack[i] == needle[j]:\n            j += 1\n        if j == n:\n            return i - n + 1\n    return -1\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# | Brute Force| O((m - n) * n)   | O(1)    |\n# | KMP        | O(m + n)         | O(n)    |\n# |------------|------------------|---------|\n\n\nhaystack = \"hello\"\nneedle = \"ll\"\nprint(strStrBF(haystack, needle))  # 2\nprint(strStrKMP(haystack, needle))  # 2\n</code></pre>"},{"location":"interview-150/arrays_string/#68-text-justification","title":"68. Text Justification","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Simulation</p> </li> </ul>"},{"location":"interview-150/backtracking/","title":"Backtracking","text":""},{"location":"interview-150/backtracking/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 17. Letter Combinations of a Phone Number (Medium)</li> <li> 77. Combinations (Medium)</li> <li> 46. Permutations (Medium)</li> <li> 39. Combination Sum (Medium)</li> <li> 52. N-Queens II (Hard)</li> <li> 22. Generate Parentheses (Medium)</li> <li> 79. Word Search (Medium)</li> </ul>"},{"location":"interview-150/backtracking/#17-letter-combinations-of-a-phone-number","title":"17. Letter Combinations of a Phone Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Backtracking</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return all possible letter combinations that the number could represent.\n\n![17](https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png)\n\"\"\"\n\nfrom typing import List\n\n\n# Backtracking\ndef letterCombinations(digits: str) -&gt; List[str]:\n    letter_map = {\n        \"2\": \"abc\",\n        \"3\": \"def\",\n        \"4\": \"ghi\",\n        \"5\": \"jkl\",\n        \"6\": \"mno\",\n        \"7\": \"pqrs\",\n        \"8\": \"tuv\",\n        \"9\": \"wxyz\",\n    }\n\n    n = len(digits)\n    if n == 0:\n        return []\n\n    res = []\n\n    def dfs(idx, path):\n        if idx == n:\n            res.append(path)\n            return None\n\n        letters = letter_map[digits[idx]]\n\n        for i in range(len(letters)):\n            dfs(idx + 1, path + letters[i])\n\n    dfs(0, \"\")\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert letterCombinations(\"23\") == [\n        \"ad\",\n        \"ae\",\n        \"af\",\n        \"bd\",\n        \"be\",\n        \"bf\",\n        \"cd\",\n        \"ce\",\n        \"cf\",\n    ]\n</code></pre>"},{"location":"interview-150/backtracking/#77-combinations","title":"77. Combinations","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Backtracking</p> </li> </ul> Python <pre><code>import itertools\nfrom typing import List\n\n\n# Backtracking\ndef combine(n: int, k: int) -&gt; List[List[int]]:\n    res = []\n\n    def backtrack(start, path):\n        if len(path) == k:\n            res.append(path[:])\n            return None\n\n        for i in range(start, n + 1):\n            path.append(i)\n            backtrack(i + 1, path)\n            path.pop()\n\n    backtrack(1, [])\n\n    return res\n\n\n# itertools\ndef combineItertools(n: int, k: int) -&gt; List[List[int]]:\n    path = itertools.combinations(range(1, n + 1), k)\n    return path\n\n\nprint(combine(4, 2))\n# [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\nprint(list(combineItertools(4, 2)))\n# [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]\n</code></pre>"},{"location":"interview-150/backtracking/#46-permutations","title":"46. Permutations","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Backtracking\ndef permute(nums: List[int]) -&gt; List[List[int]]:\n    n = len(nums)\n    path, res = [], []\n    used = [False for _ in range(n)]\n\n    def dfs(x: int):\n        if x == n:\n            res.append(path[:])\n            return\n\n        for i in range(n):\n            if used[i]:\n                continue\n            used[i] = True\n            path.append(nums[i])\n            dfs(x + 1)\n            path.pop()\n            used[i] = False\n\n    dfs(0)\n\n    return res\n\n\nprint(permute([1, 2, 3]))\n# [[1, 2, 3], [1, 3, 2], [2, 1, 3],\n#  [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n</code></pre>"},{"location":"interview-150/backtracking/#39-combination-sum","title":"39. Combination Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef combinationSum(candidates: List[int], target: int) -&gt; List[List[int]]:\n    n = len(candidates)\n    res, path = [], []\n\n    def dfs(total, start):\n        if total &gt; target:\n            return\n        if total == target:\n            res.append(path.copy())\n            return\n\n        for i in range(start, n):\n            total += candidates[i]\n            path.append(candidates[i])\n            dfs(total, i)\n            total -= candidates[i]\n            path.pop()\n\n    dfs(0, 0)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(combinationSum([2, 3, 5], 8))\n    # [[2, 2, 2, 2], [2, 3, 3], [3, 5]]\n    print(combinationSum([2, 3, 6, 7], 7))\n    # [[2, 2, 3], [7]]\n</code></pre>"},{"location":"interview-150/backtracking/#52-n-queens-ii","title":"52. N-Queens II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Backtracking</p> </li> </ul>"},{"location":"interview-150/backtracking/#22-generate-parentheses","title":"22. Generate Parentheses","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Backtracking</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Backtracking\ndef generateParenthesis1(n: int) -&gt; List[str]:\n    path, res = [], []\n\n    def dfs(openN, closeN):\n        if openN == closeN == n:\n            res.append(\"\".join(path))\n            return\n\n        if openN &lt; n:\n            path.append(\"(\")\n            dfs(openN + 1, closeN)\n            path.pop()\n\n        if closeN &lt; openN:\n            path.append(\")\")\n            dfs(openN, closeN + 1)\n            path.pop()\n\n    dfs(0, 0)\n\n    return res\n\n\n# Backtracking\ndef generateParenthesis2(n: int) -&gt; List[str]:\n    m = n * 2\n    res, path = [], [\"\"] * m\n\n    def dfs(i, left):\n        if i == m:\n            res.append(\"\".join(path))\n            return\n\n        if left &lt; n:\n            path[i] = \"(\"\n            dfs(i + 1, left + 1)\n        if i - left &lt; left:\n            path[i] = \")\"\n            dfs(i + 1, left)\n\n    dfs(0, 0)\n    return res\n\n\nif __name__ == \"__main__\":\n    print(generateParenthesis1(3))\n    # ['((()))', '(()())', '(())()', '()(())', '()()()']\n    print(generateParenthesis2(3))\n    # ['((()))', '(()())', '(())()', '()(())', '()()()']\n</code></pre>"},{"location":"interview-150/backtracking/#79-word-search","title":"79. Word Search","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Backtracking, Depth First Search, Matrix</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef exist(board: List[List[str]], word: str) -&gt; bool:\n    m, n = len(board), len(board[0])\n    path = set()\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n\n    def dfs(r, c, i):\n        if i == len(word):\n            return True\n\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or board[r][c] != word[i] or (r, c) in path:\n            return False\n\n        path.add((r, c))\n\n        for dr, dc in dirs:\n            if dfs(r + dr, c + dc, i + 1):\n                return True\n\n        path.remove((r, c))\n        return False\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, 0):\n                return True\n\n    return False\n\n\nboard = [\n    [\"A\", \"B\", \"C\", \"E\"],\n    [\"S\", \"F\", \"C\", \"S\"],\n    [\"A\", \"D\", \"E\", \"E\"],\n]\nword = \"ABCCED\"\nprint(exist(board, word))  # True\n</code></pre>"},{"location":"interview-150/binary_search/","title":"Binary Search","text":""},{"location":"interview-150/binary_search/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 35. Search Insert Position (Easy)</li> <li> 74. Search a 2D Matrix (Medium)</li> <li> 162. Find Peak Element (Medium)</li> <li> 33. Search in Rotated Sorted Array (Medium)</li> <li> 34. Find First and Last Position of Element in Sorted Array (Medium)</li> <li> 153. Find Minimum in Rotated Sorted Array (Medium)</li> <li> 4. Median of Two Sorted Arrays (Hard)</li> </ul>"},{"location":"interview-150/binary_search/#35-search-insert-position","title":"35. Search Insert Position","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return the index of the target if it is found. If not, return the index where it would be if it were inserted in order.\n\"\"\"\n\nfrom typing import List\n\n\n# Binary Search\ndef searchInsert(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        if nums[mid] &lt; target:\n            left = mid + 1\n        elif nums[mid] &gt; target:\n            right = mid - 1\n        else:\n            return mid\n\n    return left\n\n\nnums = [1, 3, 5, 6]\ntarget = 5\nprint(searchInsert(nums, target))  # 2\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int searchInsert(vector&lt;int&gt;&amp; nums, int target) {\n        int left = 0, right = nums.size() - 1;\n\n        while (left &lt;= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] &lt; target)\n                left = mid + 1;\n            else\n                right = mid - 1;\n        }\n        return left;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; nums = {1, 3, 5, 6};\n    assert(solution.searchInsert(nums, 5) == 2);\n    assert(solution.searchInsert(nums, 2) == 1);\n    assert(solution.searchInsert(nums, 7) == 4);\n    assert(solution.searchInsert(nums, 0) == 0);\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/binary_search/#74-search-a-2d-matrix","title":"74. Search a 2D Matrix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Matrix</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Binary Search\ndef searchMatrix(matrix: List[List[int]], target: int) -&gt; bool:\n    if not matrix or not matrix[0]:\n        return False\n\n    m, n = len(matrix), len(matrix[0])\n    left, right = 0, m * n - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        x = matrix[mid // n][mid % n]\n\n        if x &lt; target:\n            left = mid + 1\n        elif x &gt; target:\n            right = mid - 1\n        else:\n            return True\n\n    return False\n\n\nif __name__ == \"__main__\":\n    matrix = [[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]]\n    target = 3\n    print(searchMatrix(matrix, target))  # True\n</code></pre>"},{"location":"interview-150/binary_search/#162-find-peak-element","title":"162. Find Peak Element","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul>"},{"location":"interview-150/binary_search/#33-search-in-rotated-sorted-array","title":"33. Search in Rotated Sorted Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Binary Search\ndef search(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] == target:\n            return mid\n\n        if nums[left] &lt;= nums[mid]:\n            if nums[left] &lt;= target &lt; nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if nums[mid] &lt; target &lt;= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n    return -1\n\n\nnums = [4, 5, 6, 7, 0, 1, 2]\ntarget = 0\nprint(search(nums, target))  # 4\n</code></pre>"},{"location":"interview-150/binary_search/#34-find-first-and-last-position-of-element-in-sorted-array","title":"34. Find First and Last Position of Element in Sorted Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> PythonCPP <pre><code>from bisect import bisect_left\nfrom typing import List\n\n\nclass searchRange:\n    \"\"\"\n    \u627e lower bound \u548c upper bound\n    \u770b\u7075\u795e\u5bf9\u8fd9\u9053\u9898\u7684\u9898\u89e3\uff0c\u5206\u7c7b\u8ba8\u8bba\u533a\u95f4\u7684\u5199\u6cd5\n    target \u7684 upper bound \u662f target + 1 \u7684 lower bound - 1\n    \u8fd9\u6837\u5c31\u80fd\u7edf\u4e00\u7528 lower bound \u7684\u5199\u6cd5\n    \"\"\"\n\n    # [left, right]\n    def bisect_left_closed(self, nums, target):\n        \"\"\"\n        \u95ed\u533a\u95f4\u5199\u6cd5\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left &lt;= right:\n            mid = left + (right - left) // 2\n            if nums[mid] &lt; target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n\n    # [left, right)\n    def bisect_left_right_open(self, nums, target):\n        \"\"\"\n        \u5de6\u95ed\u53f3\u5f00\u533a\u95f4\u5199\u6cd5\n        \"\"\"\n        left, right = 0, len(nums)\n        while left &lt; right:\n            mid = left + (right - left) // 2\n            if nums[mid] &gt;= target:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\n    # (left, right)\n    def bisect_left_open(self, nums, target):\n        \"\"\"\n        \u63a8\u8350\u5f00\u533a\u95f4\u5199\u6cd5\n        \"\"\"\n        left, right = -1, len(nums)\n        while left + 1 &lt; right:\n            mid = left + (right - left) // 2\n            if nums[mid] &lt; target:\n                left = mid\n            else:\n                right = mid\n        return right\n\n    def search_range(self, nums: List[int], target: int) -&gt; List[int]:\n        # edge case\n        if not nums:\n            return [-1, -1]\n\n        lower = self.bisect_left_closed(nums, target)\n        upper = self.bisect_left_closed(nums, target + 1) - 1\n\n        return [lower, upper] if lower &lt;= upper else [-1, -1]\n\n    def search_range_bisect(self, nums: List[int], target: int) -&gt; List[int]:\n        \"\"\"\u7528 python bisect \u5e93\u51fd\u6570\"\"\"\n        # edge case\n        if not nums:\n            return [-1, -1]\n\n        lower = bisect_left(nums, target)\n        upper = bisect_left(nums, target + 1) - 1\n\n        return [lower, upper] if lower &lt;= upper else [-1, -1]\n\n\nif __name__ == \"__main__\":\n    nums = [5, 7, 7, 8, 8, 10]\n    target = 8\n    sol = searchRange()\n    assert sol.search_range(nums, target) == [3, 4]\n    assert sol.search_range_bisect(nums, target) == [3, 4]\n</code></pre> <pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\n  int bisect_left(vector&lt;int&gt; &amp;nums, int target)\n  {\n    int left = 0, right = (int)nums.size() - 1;\n\n    while (left &lt;= right)\n    {\n      int mid = left + (right - left) / 2;\n      if (nums[mid] &lt; target)\n      {\n        left = mid + 1;\n      }\n      else\n      {\n        right = mid - 1;\n      }\n    }\n    return left;\n  }\n\npublic:\n  vector&lt;int&gt; searchRange(vector&lt;int&gt; &amp;nums, int target)\n  {\n    int left = bisect_left(nums, target);\n    if (left == (int)nums.size() || nums[left] != target)\n    {\n      return {-1, -1};\n    }\n    int right = bisect_left(nums, target + 1) - 1;\n    return {left, right};\n  }\n};\n\nint main()\n{\n  vector&lt;int&gt; nums = {5, 7, 7, 8, 8, 10};\n  int target = 8;\n  Solution s;\n  vector&lt;int&gt; res = s.searchRange(nums, target);\n  cout &lt;&lt; res[0] &lt;&lt; \", \" &lt;&lt; res[1] &lt;&lt; endl;\n  return 0;\n}\n</code></pre>"},{"location":"interview-150/binary_search/#153-find-minimum-in-rotated-sorted-array","title":"153. Find Minimum in Rotated Sorted Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Binary Search\ndef findMin(nums: List[int]) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt; right:\n        mid = left + (right - left) // 2\n        if nums[mid] &gt; nums[right]:\n            left = mid + 1\n        else:\n            right = mid\n\n    return nums[right]\n\n\nnums = [4, 5, 6, 7, 0, 1, 2]\nprint(findMin(nums))  # 0\n</code></pre>"},{"location":"interview-150/binary_search/#4-median-of-two-sorted-arrays","title":"4. Median of Two Sorted Arrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Divide And Conquer</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Brute Force\ndef findMedianSortedArraysBF(nums1: List[int], nums2: List[int]) -&gt; float:\n    nums = sorted(nums1 + nums2)\n    n = len(nums)\n    if n % 2 == 0:\n        return (nums[n // 2 - 1] + nums[n // 2]) / 2\n    else:\n        return nums[n // 2]\n\n\n# Binary Search\ndef findMedianSortedArraysBS(nums1: List[int], nums2: List[int]) -&gt; float:\n    if len(nums1) &gt; len(nums2):\n        nums1, nums2 = nums2, nums1\n\n    m, n = len(nums1), len(nums2)\n    imin, imax, half_len = 0, m, (m + n + 1) // 2\n\n    while imin &lt;= imax:\n        i = (imin + imax) // 2\n        j = half_len - i\n\n        if i &lt; m and nums2[j - 1] &gt; nums1[i]:\n            imin = i + 1\n        elif i &gt; 0 and nums1[i - 1] &gt; nums2[j]:\n            imax = i - 1\n        else:\n            if i == 0:\n                max_of_left = nums2[j - 1]\n            elif j == 0:\n                max_of_left = nums1[i - 1]\n            else:\n                max_of_left = max(nums1[i - 1], nums2[j - 1])\n\n            if (m + n) % 2 == 1:\n                return max_of_left\n\n            if i == m:\n                min_of_right = nums2[j]\n            elif j == n:\n                min_of_right = nums1[i]\n            else:\n                min_of_right = min(nums1[i], nums2[j])\n\n            return (max_of_left + min_of_right) / 2\n\n\n# |--------------|-----------------|--------------|\n# | Approach     | Time            | Space        |\n# |--------------|-----------------|--------------|\n# | Brute Force  | O((n+m)log(n+m))| O(n+m)       |\n# | Binary Search| O(log(min(n,m)))| O(1)         |\n# |--------------|-----------------|--------------|\n\n\nnums1 = [1, 3]\nnums2 = [2]\nprint(findMedianSortedArraysBF(nums1, nums2))  # 2.0\nprint(findMedianSortedArraysBS(nums1, nums2))  # 2.0\n</code></pre>"},{"location":"interview-150/binary_search_tree/","title":"Binary Search Tree","text":""},{"location":"interview-150/binary_search_tree/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 530. Minimum Absolute Difference in BST (Easy)</li> <li> 230. Kth Smallest Element in a BST (Medium)</li> <li> 98. Validate Binary Search Tree (Medium)</li> </ul>"},{"location":"interview-150/binary_search_tree/#530-minimum-absolute-difference-in-bst","title":"530. Minimum Absolute Difference in BST","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Search Tree, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef getMinimumDifference(root: Optional[TreeNode]) -&gt; int:\n    res = float(\"inf\")\n    pre = float(\"-inf\")\n\n    def dfs(node):  # inorder traversal\n        if not node:\n            return\n\n        dfs(node.left)\n\n        nonlocal res, pre\n        res = min(res, node.val - pre)\n        pre = node.val\n\n        if res == 1:  # the minimum possible difference\n            return\n\n        dfs(node.right)\n\n    dfs(root)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    root = [4, 2, 6, 1, 3]\n    root = build(root)\n    print(root)\n    #     __4\n    #    /   \\\n    #   2     6\n    #  / \\\n    # 1   3\n    assert getMinimumDifference(root) == 1\n</code></pre>"},{"location":"interview-150/binary_search_tree/#230-kth-smallest-element-in-a-bst","title":"230. Kth Smallest Element in a BST","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Search Tree, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef kthSmallestRecursive(root: Optional[TreeNode], k: int) -&gt; int:\n    inorder = []\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n    return inorder[k - 1]\n\n\n# Iteratve\ndef kthSmallestIteratve(root: Optional[TreeNode], k: int) -&gt; int:\n    stack = []\n    while True:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        k -= 1\n        if not k:\n            return root.val\n        root = root.right\n\n\nif __name__ == \"__main__\":\n    root = build([3, 1, 4, None, 2])\n    k = 1\n    assert kthSmallestRecursive(root, k) == 1\n    assert kthSmallestIteratve(root, k) == 1\n</code></pre>"},{"location":"interview-150/binary_search_tree/#98-validate-binary-search-tree","title":"98. Validate Binary Search Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Search Tree, Binary Tree</p> </li> </ul> PythonCPP <pre><code>from itertools import pairwise\nfrom math import inf\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef isValidBST1(root: Optional[TreeNode]) -&gt; bool:\n    inorder = []  # inorder traversal\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    for a, b in pairwise(inorder):\n        if a &gt;= b:\n            return False\n\n    return True\n\n\ndef isValidBST2(root: Optional[TreeNode]) -&gt; bool:\n    if not root:\n        return True\n    pre = -inf\n\n    def dfs(node):\n        if not node:\n            return True\n        if not dfs(node.left):\n            return False\n\n        nonlocal pre\n        if node.val &lt;= pre:\n            return False\n        pre = node.val\n\n        return dfs(node.right)\n\n    return dfs(root)\n\n\nif __name__ == \"__main__\":\n    root = [5, 1, 4, None, None, 3, 6]\n    root = build(root)\n    print(root)\n    #   5__\n    #  /   \\\n    # 1     4\n    #      / \\\n    #     3   6\n    assert not isValidBST1(root)  # [1, 5, 3, 4, 6]\n    assert not isValidBST2(root)  # [1, 5, 3, 4, 6]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   private:\n    vector&lt;int&gt; inorder;\n    bool check(vector&lt;int&gt; inorder) {\n        int n = inorder.size();\n        if (n &lt;= 1) return true;\n        for (int i = 1; i &lt; n; i++) {\n            if (inorder[i] &lt;= inorder[i - 1]) return false;\n        }\n        return true;\n    }\n\n   public:\n    bool isValidBST(TreeNode *root) {\n        auto dfs = [&amp;](auto &amp;&amp;self, TreeNode *node) -&gt; void {\n            if (!node) return;\n\n            self(self, node-&gt;left);\n            inorder.push_back(node-&gt;val);\n            self(self, node-&gt;right);\n        };\n\n        dfs(dfs, root);\n\n        return check(inorder);\n    }\n};\n\nint main() {\n    Solution s;\n    TreeNode *root = new TreeNode(2);\n    root-&gt;left = new TreeNode(1);\n    root-&gt;right = new TreeNode(3);\n    assert(s.isValidBST(root) == true);\n\n    root = new TreeNode(5);\n    root-&gt;left = new TreeNode(1);\n    root-&gt;right = new TreeNode(4);\n    root-&gt;right-&gt;left = new TreeNode(3);\n    root-&gt;right-&gt;right = new TreeNode(6);\n    assert(s.isValidBST(root) == false);\n\n    root = new TreeNode(5);\n    root-&gt;left = new TreeNode(4);\n    root-&gt;right = new TreeNode(6);\n    root-&gt;right-&gt;left = new TreeNode(3);\n    root-&gt;right-&gt;right = new TreeNode(7);\n    assert(s.isValidBST(root) == false);\n\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/binary_tree/","title":"Binary Tree","text":""},{"location":"interview-150/binary_tree/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 104. Maximum Depth of Binary Tree (Easy)</li> <li> 100. Same Tree (Easy)</li> <li> 226. Invert Binary Tree (Easy)</li> <li> 101. Symmetric Tree (Easy)</li> <li> 105. Construct Binary Tree from Preorder and Inorder Traversal (Medium)</li> <li> 106. Construct Binary Tree from Inorder and Postorder Traversal (Medium)</li> <li> 117. Populating Next Right Pointers in Each Node II (Medium)</li> <li> 114. Flatten Binary Tree to Linked List (Medium)</li> <li> 112. Path Sum (Easy)</li> <li> 129. Sum Root to Leaf Numbers (Medium)</li> <li> 124. Binary Tree Maximum Path Sum (Hard)</li> <li> 173. Binary Search Tree Iterator (Medium)</li> <li> 222. Count Complete Tree Nodes (Easy)</li> <li> 236. Lowest Common Ancestor of a Binary Tree (Medium)</li> </ul>"},{"location":"interview-150/binary_tree/#104-maximum-depth-of-binary-tree","title":"104. Maximum Depth of Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef maxDepthRecursive(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    left = maxDepthRecursive(root.left)\n    right = maxDepthRecursive(root.right)\n\n    return 1 + max(left, right)\n\n\n# DFS\ndef maxDepthDFS(root: Optional[TreeNode]) -&gt; int:\n    res = 0\n\n    def dfs(node, cnt):\n        if node is None:\n            return\n        cnt += 1\n        nonlocal res\n        res = max(res, cnt)\n\n        dfs(node.left, cnt)\n        dfs(node.right, cnt)\n\n    dfs(root, 0)\n\n    return res\n\n\n# Iterative\ndef maxDepthIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n    res = 0\n\n    while q:\n        res += 1\n        n = len(q)\n\n        for _ in range(n):\n            node = q.popleft()\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    root = [1, 2, 2, 3, 4, None, None, None, None, 5]\n    root = build(root)\n    print(root)\n    #     ____1\n    #    /     \\\n    #   2__     2\n    #  /   \\\n    # 3     4\n    #      /\n    #     5\n    assert maxDepthRecursive(root) == 4\n    assert maxDepthDFS(root) == 4\n    assert maxDepthIterative(root) == 4\n</code></pre>"},{"location":"interview-150/binary_tree/#100-same-tree","title":"100. Same Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# 1. Recursive\ndef isSameTreeRecursive(p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:\n    if not p and not q:\n        return True\n    elif not p or not q:\n        return False\n    elif p.val != q.val:\n        return False\n\n    return isSameTreeRecursive(p.left, q.left) and isSameTreeRecursive(p.right, q.right)\n\n\n# 2. Iterative with queue\ndef isSameTreeIterativeQueue(p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:\n    queue = deque([(p, q)])\n\n    while queue:\n        p, q = queue.popleft()\n\n        if not p and not q:\n            continue\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n\n        queue.append((p.left, q.left))\n        queue.append((p.right, q.right))\n\n    return True\n\n\n# 3. Iterative with stack\ndef isSameTreeIterativeStack(p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:\n    stack = [(p, q)]\n\n    while stack:\n        n1, n2 = stack.pop()\n\n        if not n1 and not n2:\n            continue\n        if not n1 or not n2:\n            return False\n        if n1.val != n2.val:\n            return False\n\n        stack.append((n1.left, n2.left))\n        stack.append((n1.right, n2.right))\n\n    return True\n\n\nif __name__ == \"__main__\":\n    p1 = build([1, 2, 3])\n    q1 = build([1, 2, 3])\n    p2 = build([1, 2])\n    q2 = build([1, None, 2])\n\n    assert isSameTreeRecursive(p1, q1) is True\n    assert isSameTreeRecursive(p2, q2) is False\n    assert isSameTreeIterativeQueue(p1, q1) is True\n    assert isSameTreeIterativeQueue(p2, q2) is False\n    assert isSameTreeIterativeStack(p1, q1) is True\n    assert isSameTreeIterativeStack(p2, q2) is False\n</code></pre>"},{"location":"interview-150/binary_tree/#226-invert-binary-tree","title":"226. Invert Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef invertTreeRecursive(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    root.left, root.right = root.right, root.left\n\n    invertTreeRecursive(root.left)\n    invertTreeRecursive(root.right)\n\n    return root\n\n\n# Iterative\ndef invertTreeIterative(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    stack = [root]\n\n    while stack:\n        node = stack.pop()\n\n        node.left, node.right = node.right, node.left\n        if node.left:\n            stack.append(node.left)\n        if node.right:\n            stack.append(node.right)\n\n    return root\n\n\nroot = build([4, 2, 7, 1, 3, 6, 9])\nprint(root)\n#     __4__\n#    /     \\\n#   2       7\n#  / \\     / \\\n# 1   3   6   9\ninvertedRecursive = invertTreeRecursive(root)\nprint(invertedRecursive)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\nroot = build([4, 2, 7, 1, 3, 6, 9])\ninvertedIterative = invertTreeIterative(root)\nprint(invertedIterative)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\n</code></pre>"},{"location":"interview-150/binary_tree/#101-symmetric-tree","title":"101. Symmetric Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> PythonCPP <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef is_symmetric_recursive(root: Optional[TreeNode]) -&gt; bool:\n    if not root:\n        return True\n\n    def check(left, right):\n        if left is right:\n            return True\n        if not left or not right or left.val != right.val:\n            return False\n        outside = check(left.left, right.right)\n        inside = check(left.right, right.left)\n        return outside and inside\n\n    return check(root.left, root.right)\n\n\n# Iterative\ndef is_symmetric_iterative(root: Optional[TreeNode]) -&gt; bool:\n    if not root:\n        return True\n\n    q = deque()\n    q.append(root.left)\n    q.append(root.right)\n\n    while q:\n        left = q.popleft()\n        right = q.popleft()\n\n        if not left and not right:\n            continue\n\n        if not left or not right or left.val != right.val:\n            return False\n\n        q.append(left.left)\n        q.append(right.right)\n        q.append(left.right)\n        q.append(right.left)\n\n    return True\n\n\nif __name__ == \"__main__\":\n    root = [1, 2, 2, 3, 4, 4, 3]\n    root = build(root)\n    print(root)\n    #     __1__\n    #    /     \\\n    #   2       2\n    #  / \\     / \\\n    # 3   4   4   3\n    assert is_symmetric_recursive(root) is True\n    assert is_symmetric_iterative(root) is True\n</code></pre> <pre><code>#include &lt;iostream&gt;\n\n#include \"include/trees.hpp\"\n\nclass Solution {\n   private:\n    bool dfs(TreeNode *Left, TreeNode *Right) {\n        if (Left == nullptr &amp;&amp; Right == nullptr) return true;\n        if (Left == nullptr || Right == nullptr || Left-&gt;val != Right-&gt;val)\n            return false;\n        return dfs(Left-&gt;left, Right-&gt;right) &amp;&amp; dfs(Left-&gt;right, Right-&gt;left);\n    }\n\n   public:\n    bool isSymmetric(TreeNode *root) {\n        return root == nullptr || dfs(root-&gt;left, root-&gt;right);\n    }\n};\n\nint main() {\n    Solution solution;\n    // Test with a symmetric tree\n    std::vector&lt;int&gt; values = {1, 2, 2, 3, 4, 4, 3};\n    TreeNode *root = TreeUtils::buildTree(values);\n    bool result = solution.isSymmetric(root);\n    std::cout &lt;&lt; \"Is symmetric: \" &lt;&lt; (result ? \"true\" : \"false\") &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/binary_tree/#105-construct-binary-tree-from-preorder-and-inorder-traversal","title":"105. Construct Binary Tree from Preorder and Inorder Traversal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Divide And Conquer, Tree, Binary Tree</p> </li> </ul> PythonCPP <pre><code>from typing import List, Optional\n\nfrom helper import TreeNode\n\n\ndef buildTree(preorder: List[int], inorder: List[int]) -&gt; Optional[TreeNode]:\n    \"\"\"\n    preorder  root left right  1  2  3\n    inorder   left root right  4  5  6\n    \"\"\"\n    if len(preorder) == 0:\n        return None\n\n    root_val = preorder[0]  # 1\n    root = TreeNode(root_val)\n\n    separator_idx = inorder.index(root_val)  # 5\n\n    left_inorder = inorder[:separator_idx]  # 4\n    right_inorder = inorder[separator_idx + 1 :]  # 6\n\n    left_preorder = preorder[1 : 1 + len(left_inorder)]  # 2\n    right_preorder = preorder[1 + len(left_inorder) :]  # 3\n\n    root.left = buildTree(left_preorder, left_inorder)\n    root.right = buildTree(right_preorder, right_inorder)\n\n    return root\n\n\npreorder = [3, 9, 20, 15, 7]\ninorder = [9, 3, 15, 20, 7]\nroot = buildTree(preorder, inorder)\nprint(root)\n#     3\n#    / \\\n#   9  20\n#     /  \\\n#    15   7\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   public:\n    vector&lt;int&gt; preorder;\n    unordered_map&lt;int, int&gt; inorderMap;\n\n    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {\n        this-&gt;preorder = preorder;\n        for (size_t i = 0; i &lt; inorder.size(); i++) {\n            inorderMap[inorder[i]] = i;\n        }\n        return buildSubtree(0, 0, inorder.size() - 1);\n    }\n\n   private:\n    TreeNode* buildSubtree(int rootIndex, int left, int right) {\n        if (left &gt; right) return nullptr;\n\n        TreeNode* root = new TreeNode(preorder[rootIndex]);\n        int inorderIndex = inorderMap[preorder[rootIndex]];\n\n        root-&gt;left = buildSubtree(rootIndex + 1, left, inorderIndex - 1);\n        root-&gt;right = buildSubtree(rootIndex + (inorderIndex - left + 1),\n                                   inorderIndex + 1, right);\n\n        return root;\n    }\n};\n\nint main() {\n    vector&lt;int&gt; preorder = {3, 9, 20, 15, 7};\n    vector&lt;int&gt; inorder = {9, 3, 15, 20, 7};\n    Solution solution;\n    TreeNode* root = solution.buildTree(preorder, inorder);\n    cout &lt;&lt; root-&gt;val &lt;&lt; endl;                // 3\n    cout &lt;&lt; root-&gt;left-&gt;val &lt;&lt; endl;          // 9\n    cout &lt;&lt; root-&gt;right-&gt;val &lt;&lt; endl;         // 20\n    cout &lt;&lt; root-&gt;right-&gt;left-&gt;val &lt;&lt; endl;   // 15\n    cout &lt;&lt; root-&gt;right-&gt;right-&gt;val &lt;&lt; endl;  // 7\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/binary_tree/#106-construct-binary-tree-from-inorder-and-postorder-traversal","title":"106. Construct Binary Tree from Inorder and Postorder Traversal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Divide And Conquer, Tree, Binary Tree</p> </li> </ul> Python <pre><code>from typing import List, Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef buildTree(inorder: List[int], postorder: List[int]) -&gt; Optional[TreeNode]:\n    \"\"\"\n    inorder:    left root  right   1  2  3\n    postorder:  left right root    4  5  6\n    \"\"\"\n\n    if not postorder:\n        return None\n\n    root_val = postorder[-1]  # 6\n    root = TreeNode(root_val)\n\n    separator_idx = inorder.index(root_val)  # 2\n\n    left_inorder = inorder[:separator_idx]  # 1\n    right_inorder = inorder[separator_idx + 1 :]  # 3\n\n    left_postorder = postorder[: len(left_inorder)]  # 4\n    right_postorder = postorder[len(left_inorder) : -1]  # 5\n\n    root.left = buildTree(left_inorder, left_postorder)\n    root.right = buildTree(right_inorder, right_postorder)\n\n    return root\n\n\ninorder = [9, 3, 15, 20, 7]\npostorder = [9, 15, 7, 20, 3]\nroot = buildTree(inorder, postorder)\nprint(root)\n#     3\n#    / \\\n#   9  20\n#     /  \\\n#    15   7\n</code></pre>"},{"location":"interview-150/binary_tree/#117-populating-next-right-pointers-in-each-node-ii","title":"117. Populating Next Right Pointers in Each Node II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import Optional\n\n\nclass Node:\n    def __init__(\n        self,\n        val: int = 0,\n        left: Optional[\"Node\"] = None,\n        right: Optional[\"Node\"] = None,\n        next: Optional[\"Node\"] = None,\n    ):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\n\nclass connect:\n    def level_order(self, root: \"Node\") -&gt; \"Node\":\n        if not root:\n            return None\n\n        q = deque([root])\n\n        while q:\n            size = len(q)\n            prev = None\n\n            for _ in range(size):\n                node = q.popleft()\n\n                if prev:\n                    prev.next = node\n                prev = node\n\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n\n        return root\n\n\nif __name__ == \"__main__\":\n\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    root.right.right = Node(7)\n    #       1\n    #      / \\\n    #     2   3\n    #    / \\   \\\n    #   4   5   7\n\n    solution = connect()\n    root = solution.level_order(root)\n    assert root.next is None\n    assert root.left.next == root.right\n    assert root.right.next is None\n    assert root.left.left.next == root.left.right\n    assert root.left.right.next == root.right.right\n    assert root.right.right.next is None\n    #       1 -&gt; None\n    #      / \\\n    #     2 -&gt; 3 -&gt; None\n    #    / \\    \\\n    #   4 -&gt; 5 -&gt; 7 -&gt; None\n</code></pre>"},{"location":"interview-150/binary_tree/#114-flatten-binary-tree-to-linked-list","title":"114. Flatten Binary Tree to Linked List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Stack, Tree, Depth First Search, Binary Tree</p> </li> </ul> CPP <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   public:\n    void flatten(TreeNode* root) {\n        if (!root) return;\n\n        flatten(root-&gt;left);\n        flatten(root-&gt;right);\n\n        TreeNode* left = root-&gt;left;\n        TreeNode* right = root-&gt;right;\n\n        root-&gt;left = nullptr;\n        root-&gt;right = left;\n\n        TreeNode* curr = root;\n        while (curr-&gt;right) curr = curr-&gt;right;\n        curr-&gt;right = right;\n    }\n};\n\nint main() {\n    Solution sol;\n    TreeNode* root =\n        new TreeNode(1, new TreeNode(2, new TreeNode(3), new TreeNode(4)),\n                     new TreeNode(5, nullptr, new TreeNode(6)));\n    sol.flatten(root);\n\n    TreeNode* cur = root;\n    std::vector&lt;int&gt; expected = {1, 2, 3, 4, 5, 6};\n    for (int val : expected) {\n        assert(cur != nullptr &amp;&amp; cur-&gt;val == val);\n        cur = cur-&gt;right;\n    }\n    assert(cur == nullptr);  // End of list\n\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/binary_tree/#112-path-sum","title":"112. Path Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef hasPathSum(root: Optional[TreeNode], targetSum: int) -&gt; bool:\n    if not root:\n        return False\n\n    if not root.left and not root.right:\n        return root.val == targetSum\n\n    targetSum -= root.val\n\n    return hasPathSum(root.left, targetSum) or hasPathSum(root.right, targetSum)\n\n\nroot = build([5, 4, 8, 11, None, 13, 4, 7, 2, None, None, None, None, None, 1])\nprint(root)\n#          5___\n#         /    \\\n#     ___4     _8\n#    /        /  \\\n#   11       13   4\n#  /  \\            \\\n# 7    2            1\nprint(hasPathSum(root, 22))  # True\n</code></pre>"},{"location":"interview-150/binary_tree/#129-sum-root-to-leaf-numbers","title":"129. Sum Root to Leaf Numbers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\nclass sumNumbers:\n    def dfs(self, root: Optional[TreeNode]) -&gt; int:\n        self.res = 0\n\n        def dfs(node, cur):\n            if not node:\n                return\n\n            cur = cur * 10 + node.val\n\n            if not node.left and not node.right:\n                self.res += cur\n                return\n\n            dfs(node.left, cur)\n            dfs(node.right, cur)\n\n        dfs(root, 0)\n\n        return self.res\n\n\nif __name__ == \"__main__\":\n    root = [1, 2, 3]\n    root = build(root)\n    print(root)\n    #   1\n    #  / \\\n    # 2   3\n    assert sumNumbers().dfs(root) == 25\n</code></pre>"},{"location":"interview-150/binary_tree/#124-binary-tree-maximum-path-sum","title":"124. Binary Tree Maximum Path Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Tree, Depth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef maxPathSum(root: Optional[TreeNode]) -&gt; int:\n    res = float(\"-inf\")\n\n    def dfs(node):\n        if not node:\n            return 0\n\n        leftMax = max(dfs(node.left), 0)\n        rightMax = max(dfs(node.right), 0)\n\n        cur = node.val + leftMax + rightMax\n        nonlocal res\n        res = max(res, cur)\n\n        return node.val + max(leftMax, rightMax)\n\n    dfs(root)\n\n    return res\n\n\nroot = build([-10, 9, 20, None, None, 15, 7])\nprint(root)\n#   -10___\n#  /      \\\n# 9       _20\n#        /   \\\n#       15    7\nprint(maxPathSum(root))  # 42\n</code></pre>"},{"location":"interview-150/binary_tree/#173-binary-search-tree-iterator","title":"173. Binary Search Tree Iterator","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Stack, Tree, Design, Binary Search Tree, Binary Tree, Iterator</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BST\nclass BSTIterator:\n\n    def __init__(self, root: Optional[TreeNode]):\n        self.stack = []\n        self._leftmost_inorder(root)\n\n    def _leftmost_inorder(self, root):\n        while root:\n            self.stack.append(root)\n            root = root.left\n\n    def next(self) -&gt; int:\n        topmost_node = self.stack.pop()\n\n        if topmost_node.right:\n            self._leftmost_inorder(topmost_node.right)\n\n        return topmost_node.val\n\n    def hasNext(self) -&gt; bool:\n        return len(self.stack) &gt; 0\n\n\nroot = build([7, 3, 15, None, None, 9, 20])\nprint(root)\n#   7__\n#  /   \\\n# 3     15\n#      /  \\\n#     9    20\nobj = BSTIterator(root)\nprint(obj.next())  # 3\nprint(obj.next())  # 7\nprint(obj.hasNext())  # True\n</code></pre>"},{"location":"interview-150/binary_tree/#222-count-complete-tree-nodes","title":"222. Count Complete Tree Nodes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Binary Search, Bit Manipulation, Tree, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef countNodesRecursive(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    num = 1 + countNodesRecursive(root.left) + countNodesRecursive(root.right)\n\n    return num\n\n\n# Iterative\ndef countNodesIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n    count = 0\n\n    while q:\n        n = len(q)\n\n        for _ in range(n):\n            node = q.popleft()\n            count += 1\n\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return count\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Recursive  |  O(n)  |  O(n)   |\n# | Iterative  |  O(n)  |  O(n)   |\n# |------------|--------|---------|\n\nroot = [1, 2, 3, 4, 5, 6]\nroot = build(root)\nprint(root)\n#     __1__\n#    /     \\\n#   2       3\n#  / \\     /\n# 4   5   6\nprint(countNodesRecursive(root))  # 6\nprint(countNodesIterative(root))  # 6\n</code></pre>"},{"location":"interview-150/binary_tree/#236-lowest-common-ancestor-of-a-binary-tree","title":"236. Lowest Common Ancestor of a Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul> PythonCPP <pre><code>from typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass LowestCommonAncestor:\n    def lowestCommonAncestor(\n        self, root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n    ) -&gt; \"TreeNode\":\n        if not root or q == root or p == root:\n            return root\n\n        left = self.lowestCommonAncestor(root.left, p, q)\n        right = self.lowestCommonAncestor(root.right, p, q)\n\n        if left and right:\n            return root\n\n        return left or right\n\n\nif __name__ == \"__main__\":\n    root = build([3, 5, 1, 6, 2, 0, 8, None, None, 7, 4])\n    print(root)\n    #     ______3__\n    #    /         \\\n    #   5__         1\n    #  /   \\       / \\\n    # 6     2     0   8\n    #      / \\\n    #     7   4\n    p = root.left  # 5\n    q = root.right  # 1\n    sol = LowestCommonAncestor()\n    print(sol.lowestCommonAncestor(root, p, q))\n    #     ______3__\n    #    /         \\\n    #   5__         1\n    #  /   \\       / \\\n    # 6     2     0   8\n    #      / \\\n    #     7   4\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   public:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if (root == nullptr || root == p || root == q) {\n            return root;\n        }\n\n        TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);\n        TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);\n\n        if (left &amp;&amp; right) {\n            return root;\n        }\n\n        return left ? left : right;\n    }\n};\n\nint main() { return 0; }\n</code></pre>"},{"location":"interview-150/binary_tree_level_order/","title":"Binary Tree Level Order","text":""},{"location":"interview-150/binary_tree_level_order/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 199. Binary Tree Right Side View (Medium)</li> <li> 637. Average of Levels in Binary Tree (Easy)</li> <li> 102. Binary Tree Level Order Traversal (Medium)</li> <li> 103. Binary Tree Zigzag Level Order Traversal (Medium)</li> </ul>"},{"location":"interview-150/binary_tree_level_order/#199-binary-tree-right-side-view","title":"199. Binary Tree Right Side View","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Binary Tree BFS\ndef rightSideViewBFS(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        n = len(q)\n        for i in range(n):\n            node = q.popleft()\n            if i == n - 1:\n                res.append(node.val)\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return res\n\n\n# Binary Tree DFS\ndef rightSideViewDFS(root: Optional[TreeNode]) -&gt; List[int]:\n    \"\"\"\u540e\u5e8f\u904d\u5386\uff0c\u5148\u53f3\u540e\u5de6\uff0c\u9047\u5230\u7684\u7b2c\u4e00\u4e2a\u8282\u70b9\u5c31\u662f\u8be5\u6df1\u5ea6\u7684\u6700\u53f3\u4fa7\u8282\u70b9\"\"\"\n    ans = []\n\n    def dfs(node, depth):\n        if node is None:\n            return\n        if depth == len(ans):  # \u8fd9\u4e2a\u6df1\u5ea6\u9996\u6b21\u9047\u5230\n            ans.append(node.val)\n\n        dfs(node.right, depth + 1)\n        dfs(node.left, depth + 1)\n\n    dfs(root, 0)\n\n    return ans\n\n\nif __name__ == \"__main__\":\n    root = [1, 2, 2, 3, 4, None, 3, None, None, 5]\n    root = build(root)\n    print(root)\n    #     ____1\n    #    /     \\\n    #   2__     2\n    #  /   \\     \\\n    # 3     4     3\n    #      /\n    #     5\n    assert rightSideViewBFS(root) == [1, 2, 3, 5]\n    assert rightSideViewDFS(root) == [1, 2, 3, 5]\n</code></pre>"},{"location":"interview-150/binary_tree_level_order/#637-average-of-levels-in-binary-tree","title":"637. Average of Levels in Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Binary Tree BFS\ndef averageOfLevels(root: Optional[TreeNode]) -&gt; List[float]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        n = len(q)\n        level = 0\n        for _ in range(n):\n            cur = q.popleft()\n            level += cur.val\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(float(level / n))\n\n    return res\n\n\nif __name__ == \"__main__\":\n    root = [3, 9, 20, None, None, 15, 7]\n    root = build(root)\n    print(root)\n    #   3___\n    #  /    \\\n    # 9     _20\n    #      /   \\\n    #     15    7\n    assert averageOfLevels(root) == [3.00000, 14.50000, 11.00000]\n</code></pre>"},{"location":"interview-150/binary_tree_level_order/#102-binary-tree-level-order-traversal","title":"102. Binary Tree Level Order Traversal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef levelOrder(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        level = []\n        size = len(q)\n\n        for _ in range(size):\n            cur = q.popleft()\n            level.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(level)\n\n    return res\n\n\ntree = build([3, 9, 20, None, None, 15, 7])\nprint(tree)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(levelOrder(tree))  # [[3], [9, 20], [15, 7]]\n</code></pre>"},{"location":"interview-150/binary_tree_level_order/#103-binary-tree-zigzag-level-order-traversal","title":"103. Binary Tree Zigzag Level Order Traversal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef zigzagLevelOrder(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        level = []\n        size = len(q)\n\n        for _ in range(size):\n            cur = q.popleft()\n            level.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(level if not len(res) % 2 else level[::-1])\n\n    return res\n\n\nif __name__ == \"__main__\":\n    tree = build([3, 9, 20, None, None, 15, 7])\n    print(tree)\n    #   3___\n    #  /    \\\n    # 9     _20\n    #      /   \\\n    #     15    7\n    assert zigzagLevelOrder(tree) == [[3], [20, 9], [15, 7]]\n</code></pre>"},{"location":"interview-150/bit_manipulation/","title":"Bit Manipulation","text":""},{"location":"interview-150/bit_manipulation/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 67. Add Binary (Easy)</li> <li> 190. Reverse Bits (Easy)</li> <li> 191. Number of 1 Bits (Easy)</li> <li> 136. Single Number (Easy)</li> <li> 137. Single Number II (Medium)</li> <li> 201. Bitwise AND of Numbers Range (Medium)</li> </ul>"},{"location":"interview-150/bit_manipulation/#67-add-binary","title":"67. Add Binary","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String, Bit Manipulation, Simulation</p> </li> </ul>"},{"location":"interview-150/bit_manipulation/#190-reverse-bits","title":"190. Reverse Bits","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Divide And Conquer, Bit Manipulation</p> </li> </ul> Python <pre><code># Bit Manipulation\ndef reverseBits(n: int) -&gt; int:\n    res = 0\n\n    for i in range(32):\n        res = (res &lt;&lt; 1) | (n &amp; 1)\n        n &gt;&gt;= 1\n\n    return res\n\n\nn = 0b00000010100101000001111010011100\nprint(reverseBits(n))  # 964176192\n</code></pre>"},{"location":"interview-150/bit_manipulation/#191-number-of-1-bits","title":"191. Number of 1 Bits","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Divide And Conquer, Bit Manipulation</p> </li> </ul> Python <pre><code># Bit Manipulation\ndef hammingWeight1(n: int) -&gt; int:\n    res = 0\n\n    while n != 0:\n        n = n &amp; (n - 1)  # Unset the rightmost 1-bit\n        res += 1\n\n    return res\n\n\ndef hammingWeight2(n: int) -&gt; int:\n    return bin(n).count(\"1\")\n\n\ndef hammingWeight3(n: int) -&gt; int:\n    def decimalToBinary(n: int) -&gt; str:\n        if n == 0:\n            return \"0\"\n\n        binary = \"\"\n        while n &gt; 0:\n            binary = str(n % 2) + binary\n            n //= 2\n\n        return binary\n\n    binary = decimalToBinary(n)\n\n    return binary.count(\"1\")\n\n\nn = 11\nprint(hammingWeight1(n))  # 3\nprint(hammingWeight2(n))  # 3\n\nn = 47\nprint(bin(n))\n</code></pre>"},{"location":"interview-150/bit_manipulation/#136-single-number","title":"136. Single Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation</p> </li> </ul> Python <pre><code>from functools import reduce\nfrom operator import xor\nfrom typing import List\n\n\n# XOR\ndef singleNumber(nums: List[int]) -&gt; int:\n    res = 0\n    for num in nums:\n        res ^= num\n    return res\n\n\n# XOR\ndef singleNumberXOR(nums: List[int]) -&gt; int:\n    return reduce(xor, nums)\n\n\n# XOR\ndef singleNumberXORLambda(nums: List[int]) -&gt; int:\n    return reduce(lambda x, y: x ^ y, nums)\n\n\nnums = [4, 1, 2, 1, 2]\nprint(singleNumber(nums))  # 4\nprint(singleNumberXOR(nums))  # 4\nprint(singleNumberXORLambda(nums))  # 4\n</code></pre>"},{"location":"interview-150/bit_manipulation/#137-single-number-ii","title":"137. Single Number II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation</p> </li> </ul>"},{"location":"interview-150/bit_manipulation/#201-bitwise-and-of-numbers-range","title":"201. Bitwise AND of Numbers Range","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Bit Manipulation</p> </li> </ul>"},{"location":"interview-150/divide_and_conquer/","title":"Divide and Conquer","text":""},{"location":"interview-150/divide_and_conquer/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 108. Convert Sorted Array to Binary Search Tree (Easy)</li> <li> 148. Sort List (Medium)</li> <li> 427. Construct Quad Tree (Medium)</li> <li> 23. Merge k Sorted Lists (Hard)</li> </ul>"},{"location":"interview-150/divide_and_conquer/#108-convert-sorted-array-to-binary-search-tree","title":"108. Convert Sorted Array to Binary Search Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Divide And Conquer, Tree, Binary Search Tree, Binary Tree</p> </li> </ul> PythonCPP <pre><code>from typing import List, Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef sortedArrayToBST(nums: List[int]) -&gt; Optional[TreeNode]:\n    if len(nums) == 0:\n        return None\n\n    mid = len(nums) // 2\n    root = TreeNode(nums[mid])\n\n    root.left = sortedArrayToBST(nums[:mid])\n    root.right = sortedArrayToBST(nums[mid + 1 :])\n\n    return root\n\n\nnums = [-10, -3, 0, 5, 9]\nroot = sortedArrayToBST(nums)\n#      0\n#     / \\\n#   -3   9\n#   /   /\n# -10  5\n</code></pre> <pre><code>#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   public:\n    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) {\n        if (nums.size() == 0) return nullptr;\n\n        int mid = nums.size() / 2;\n        TreeNode* root = new TreeNode(nums[mid]);\n\n        vector&lt;int&gt; left(nums.begin(), nums.begin() + mid);\n        vector&lt;int&gt; right(nums.begin() + mid + 1, nums.end());\n\n        root-&gt;left = sortedArrayToBST(left);\n        root-&gt;right = sortedArrayToBST(right);\n\n        return root;\n    }\n};\n\nint main() { return 0; }\n</code></pre>"},{"location":"interview-150/divide_and_conquer/#148-sort-list","title":"148. Sort List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Two Pointers, Divide And Conquer, Sorting, Merge Sort</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom leetpattern.utils import ListNode, list_from_array\n\n\n# Linked List\ndef sortListSort(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    nums = []\n\n    while head:\n        nums.append(head.val)\n        head = head.next\n\n    dummy = ListNode()\n    cur = dummy\n    nums.sort()\n\n    for num in nums:\n        cur.next = ListNode(val=num)\n        cur = cur.next\n\n    return dummy.next\n\n\n# Linked List\ndef sortListDivideConquer(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    def middle(node):\n        fast, slow = node, node\n        while fast and fast.next:\n            pre = slow\n            slow = slow.next\n            fast = fast.next.next\n        pre.next = None\n        return slow\n\n    def merge_two_lists(l1, l2):\n        dummy = ListNode()\n        cur = dummy\n        while l1 and l2:\n            if l1.val &lt; l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n            cur = cur.next\n\n        cur.next = l1 if l1 else l2\n        return dummy.next\n\n    if not head or not head.next:\n        return head\n\n    head2 = middle(head)\n    head = sortListDivideConquer(head)\n    head2 = sortListDivideConquer(head2)\n\n    return merge_two_lists(head, head2)\n\n\nhead = list_from_array([4, 2, 1, 3])\nprint(head)  # 4 -&gt; 2 -&gt; 1 -&gt; 3\nprint(sortListSort(head))  # 1 -&gt; 2 -&gt; 3 -&gt; 4\nprint(sortListDivideConquer(head))  # 1 -&gt; 2 -&gt; 3 -&gt; 4\n</code></pre>"},{"location":"interview-150/divide_and_conquer/#427-construct-quad-tree","title":"427. Construct Quad Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Divide And Conquer, Tree, Matrix</p> </li> </ul>"},{"location":"interview-150/divide_and_conquer/#23-merge-k-sorted-lists","title":"23. Merge k Sorted Lists","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Divide And Conquer, Heap Priority Queue, Merge Sort</p> </li> </ul> Python <pre><code>\"\"\"\n-   Prerequisite: 21. Merge Two Sorted Lists\n-   Video explanation: [23. Merge K Sorted Lists - NeetCode](https://youtu.be/q5a5OiGbT6Q?si=SQ2dCvsYQ3LQctPh)\n\"\"\"\n\nimport copy\nimport heapq\nfrom typing import List, Optional\n\nfrom leetpattern.utils import ListNode, list_from_array, list_to_array\n\n\ndef merge_k_lists_divide_conquer(\n    lists: List[Optional[ListNode]],\n) -&gt; Optional[ListNode]:\n    if not lists or len(lists) == 0:\n        return None\n\n    def mergeTwo(l1, l2):\n        dummy = ListNode()\n        cur = dummy\n\n        while l1 and l2:\n            if l1.val &lt; l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n\n            cur = cur.next\n\n        cur.next = l1 if l1 else l2\n\n        return dummy.next\n\n    while len(lists) &gt; 1:\n        merged = []\n\n        for i in range(0, len(lists), 2):\n            l1 = lists[i]\n            l2 = lists[i + 1] if i + 1 &lt; len(lists) else None\n            merged.append(mergeTwo(l1, l2))\n\n        lists = merged\n\n    return lists[0]\n\n\ndef merge_k_lists_heap(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    min_heap = []  # (val, idx, node)\n\n    for idx, head in enumerate(lists):\n        if head:\n            heapq.heappush(min_heap, (head.val, idx, head))\n\n    while min_heap:\n        _, idx, node = heapq.heappop(min_heap)\n        cur.next = node\n        cur = cur.next\n\n        node = node.next\n        if node:\n            heapq.heappush(min_heap, (node.val, idx, node))\n\n    return dummy.next\n\n\ndef test_merge_k_lists() -&gt; None:\n    n1 = list_from_array([1, 4])\n    n2 = list_from_array([1, 3])\n    n3 = list_from_array([2, 6])\n    lists = [n1, n2, n3]\n    lists1 = copy.deepcopy(lists)\n    lists2 = copy.deepcopy(lists)\n    assert (list_to_array(merge_k_lists_divide_conquer(lists1))) == [\n        1,\n        1,\n        2,\n        3,\n        4,\n        6,\n    ]\n    assert (list_to_array(merge_k_lists_heap(lists2))) == [1, 1, 2, 3, 4, 6]\n</code></pre>"},{"location":"interview-150/graph/","title":"Graph","text":""},{"location":"interview-150/graph/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 200. Number of Islands (Medium)</li> <li> 130. Surrounded Regions (Medium)</li> <li> 133. Clone Graph (Medium)</li> <li> 399. Evaluate Division (Medium)</li> <li> 207. Course Schedule (Medium)</li> <li> 210. Course Schedule II (Medium)</li> </ul>"},{"location":"interview-150/graph/#200-number-of-islands","title":"200. Number of Islands","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Union Find, Matrix</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Count the number of islands in a 2D grid.\n-   Method 1: DFS\n-   Method 2: BFS (use a queue to traverse the grid)\n\n-   How to keep track of visited cells?\n\n    1. Mark the visited cell as `0` (or any other value) to avoid revisiting it.\n    2. Use a set to store the visited cells.\n\n-   Steps:\n    1. Init: variables\n    2. DFS/BFS: starting from the cell with `1`, turn all the connected `1`s to `0`.\n    3. Traverse the grid, and if the cell is `1`, increment the count and call DFS/BFS.\n\n![0200](../../assets/0200.jpg)\n\"\"\"\n\nfrom collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef numIslandsDFS(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    res = 0\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] != \"1\":\n            return\n\n        grid[r][c] = \"2\"\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                dfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Set\ndef numIslandsBFS1(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == \"0\"\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\" and (r, c) not in visited:\n                visited.add((r, c))\n                bfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = dr + row, dc + col\n                if nr &lt; 0 or nr &gt;= m or nc &lt; 0 or nc &gt;= n or grid[nr][nc] != \"1\":\n                    continue\n                grid[nr][nc] = \"2\"\n                q.append((nr, nc))\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == \"1\":\n                grid[i][j] = \"2\"\n                bfs(i, j)\n                res += 1\n\n    return res\n\n\ngrid = [\n    [\"1\", \"1\", \"1\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"0\", \"0\", \"0\", \"0\", \"0\"],\n]\n\nprint(numIslandsDFS(deepcopy(grid)))  # 1\nprint(numIslandsBFS1(deepcopy(grid)))  # 1\nprint(numIslandsBFS2(deepcopy(grid)))  # 1\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    // dfs\n    int num_islands_dfs(vector&lt;vector&lt;char&gt;&gt; &amp;grid) {\n        int m = grid.size(), n = grid[0].size();\n        int res = 0;\n\n        // c++23 lambda recursion\n        auto dfs = [&amp;](this auto &amp;&amp;dfs, int r, int c) -&gt; void {\n            if (r &lt; 0 || r &gt;= m || c &lt; 0 || c &gt;= n || grid[r][c] != '1') {\n                return;\n            }\n            grid[r][c] = '0';\n            dfs(r + 1, c);\n            dfs(r - 1, c);\n            dfs(r, c + 1);\n            dfs(r, c - 1);\n        };\n\n        for (int i = 0; i &lt; m; i++) {\n            for (int j = 0; j &lt; n; j++) {\n                if (grid[i][j] == '1') {\n                    res++;\n                    dfs(i, j);\n                }\n            }\n        }\n        return res;\n    }\n\n    // bfs\n    int num_islands_bfs(vector&lt;vector&lt;char&gt;&gt; &amp;grid) {\n        int m = grid.size(), n = grid[0].size();\n        int res = 0;\n        vector&lt;pair&lt;int, int&gt;&gt; dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\n        auto bfs = [&amp;](int r, int c) {\n            queue&lt;pair&lt;int, int&gt;&gt; q;\n            q.push({r, c});\n            grid[r][c] = '0';\n            while (!q.empty()) {\n                auto [cr, cc] = q.front();\n                q.pop();\n                for (auto &amp;[dr, dc] : dirs) {\n                    int nr = cr + dr, nc = cc + dc;\n                    if (nr &gt;= 0 &amp;&amp; nr &lt; m &amp;&amp; nc &gt;= 0 &amp;&amp; nc &lt; n &amp;&amp;\n                        grid[nr][nc] == '1') {\n                        grid[nr][nc] = '0';\n                        q.push({nr, nc});\n                    }\n                }\n            }\n        };\n\n        for (int i = 0; i &lt; m; i++) {\n            for (int j = 0; j &lt; n; j++) {\n                if (grid[i][j] == '1') {\n                    res++;\n                    bfs(i, j);\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;vector&lt;char&gt;&gt; grid = {{'1', '1', '0', '0', '0'},\n                                 {'1', '1', '0', '0', '0'},\n                                 {'0', '0', '1', '0', '0'},\n                                 {'0', '0', '0', '1', '1'}};\n    assert(solution.num_islands_dfs(grid) == 3);\n    grid = {{'1', '1', '0', '0', '0'},\n            {'1', '1', '0', '0', '0'},\n            {'0', '0', '1', '0', '0'},\n            {'0', '0', '0', '1', '1'}};\n    assert(solution.num_islands_bfs(grid) == 3);\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/graph/#130-surrounded-regions","title":"130. Surrounded Regions","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Union Find, Matrix</p> </li> </ul> Python <pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef solveDFS(board: List[List[str]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n    if not board and not board[0]:\n        return None\n\n    m, n = len(board), len(board[0])\n\n    def capture(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or board[r][c] != \"O\":\n            return None\n\n        board[r][c] = \"T\"\n        capture(r + 1, c)\n        capture(r - 1, c)\n        capture(r, c + 1)\n        capture(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\" and (r in [0, m - 1] or c in [0, n - 1]):\n                capture(r, c)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\":\n                board[r][c] = \"X\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"T\":\n                board[r][c] = \"O\"\n\n\n# BFS\ndef solveBFS(board: List[List[str]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n    if not board and not board[0]:\n        return None\n\n    m, n = len(board), len(board[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def capture(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr = row + dr\n                nc = col + dc\n                if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and board[nr][nc] == \"O\":\n                    board[nr][nc] = \"T\"\n                    q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\" and (r in [0, m - 1] or c in [0, n - 1]):\n                board[r][c] = \"T\"\n                capture(r, c)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\":\n                board[r][c] = \"X\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"T\":\n                board[r][c] = \"O\"\n\n\nif __name__ == \"__main__\":\n    board = [\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"O\", \"O\", \"X\"],\n        [\"X\", \"X\", \"O\", \"X\"],\n        [\"X\", \"O\", \"X\", \"X\"],\n    ]\n\n    b = deepcopy(board)\n    solveDFS(b)\n    assert b == [\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"O\", \"X\", \"X\"],\n    ]\n\n    b = deepcopy(board)\n    solveBFS(b)\n    assert b == [\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"O\", \"X\", \"X\"],\n    ]\n</code></pre>"},{"location":"interview-150/graph/#133-clone-graph","title":"133. Clone Graph","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Depth First Search, Breadth First Search, Graph</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import Optional\n\n\nclass Node:\n    def __init__(self, val=0, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\n\nclass CloneGraph:\n    def dfs(self, node: Optional[\"Node\"]) -&gt; Optional[\"Node\"]:\n        hashmap = {}\n\n        def dfs(node):\n            if node in hashmap:\n                return hashmap[node]\n\n            res = Node(node.val)\n            hashmap[node] = res\n\n            for nei in node.neighbors:\n                res.neighbors.append(dfs(nei))\n\n            return res\n\n        return dfs(node) if node else None\n\n    def bfs(self, node: Optional[\"Node\"]) -&gt; Optional[\"Node\"]:\n        if not node:\n            return None\n\n        hashmap = {node: Node(node.val)}\n        q = deque([node])\n\n        while q:\n            cur = q.popleft()\n\n            for nei in cur.neighbors:\n                if nei not in hashmap:\n                    hashmap[nei] = Node(nei.val)\n                    q.append(nei)\n\n                hashmap[cur].neighbors.append(hashmap[nei])\n\n        return hashmap[node]\n</code></pre>"},{"location":"interview-150/graph/#399-evaluate-division","title":"399. Evaluate Division","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Depth First Search, Breadth First Search, Union Find, Graph, Shortest Path</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef calcEquation(\n    equations: List[List[str]], values: List[float], queries: List[List[str]]\n) -&gt; List[float]:\n    graph = defaultdict(dict)\n    for (a, b), v in zip(equations, values):\n        graph[a][b] = v\n        graph[b][a] = 1 / v\n\n    def dfs(a, b, visited):\n        if a not in graph or b not in graph:\n            return -1.0\n\n        if b in graph[a]:\n            return graph[a][b]\n\n        for c in graph[a]:\n            if c not in visited:\n                visited.add(c)\n                d = dfs(c, b, visited)\n                if d != -1.0:\n                    return graph[a][c] * d\n        return -1.0\n\n    result = []\n    for a, b in queries:\n        result.append(dfs(a, b, set()))\n\n    return result\n\n\nequations = [[\"a\", \"b\"], [\"b\", \"c\"]]\nvalues = [2.0, 3.0]\nqueries = [[\"a\", \"c\"], [\"b\", \"a\"], [\"a\", \"e\"], [\"a\", \"a\"], [\"x\", \"x\"]]\nprint(calcEquation(equations, values, queries))  # [6.0, 0.5, -1.0, 1.0, -1.0]\n</code></pre>"},{"location":"interview-150/graph/#207-course-schedule","title":"207. Course Schedule","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Graph, Topological Sort</p> </li> </ul> PythonCPP <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS (Kahn's Algorithm)\ndef canFinishBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    count = 0\n\n    while q:\n        crs = q.popleft()\n        count += 1\n\n        for nxt in graph[crs]:\n            indegree[nxt] -= 1\n\n            if indegree[nxt] == 0:\n                q.append(nxt)\n\n    return count == numCourses\n\n\n# DFS + Set\ndef canFinishDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for crs, pre in prerequisites:\n        graph[crs].append(pre)\n\n    visiting = set()\n\n    def dfs(crs):\n        if crs in visiting:  # cycle detected\n            return False\n        if graph[crs] == []:\n            return True\n\n        visiting.add(crs)\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        visiting.remove(crs)\n        graph[crs] = []\n\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\n# DFS + List\ndef canFinishDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for pre, crs in prerequisites:\n        graph[crs].append(pre)\n\n    # 0: init, 1: visiting, 2: visited\n    status = [0] * numCourses\n\n    def dfs(crs):\n        if status[crs] == 1:  # cycle detected\n            return False\n        if status[crs] == 2:\n            return True\n\n        status[crs] = 1\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        status[crs] = 2\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(canFinishBFS(5, prerequisites))  # True\nprint(canFinishDFS1(5, prerequisites))  # True\nprint(canFinishDFS2(5, prerequisites))  # True\n</code></pre> <pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    // BFS\n    bool canFinishBFS(int numCourses, vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        vector&lt;int&gt; indegree(numCourses, 0);\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n            indegree[pre[0]]++;\n        }\n\n        queue&lt;int&gt; q;\n        for (int i = 0; i &lt; numCourses; i++) {\n            if (indegree[i] == 0) {\n                q.push(i);\n            }\n        }\n\n        int cnt = 0;\n        while (!q.empty()) {\n            int cur = q.front();\n            q.pop();\n            cnt++;\n\n            for (int nxt : graph[cur]) {\n                indegree[nxt]--;\n                if (indegree[nxt] == 0) {\n                    q.push(nxt);\n                }\n            }\n        }\n        return cnt == numCourses;\n    }\n\n    // DFS\n    bool canFinishDFS(int numCourses, vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n        }\n        // 0: not visited, 1: visiting, 2: visited\n        vector&lt;int&gt; state(numCourses, 0);\n\n        function&lt;bool(int)&gt; dfs = [&amp;](int pre) -&gt; bool {\n            state[pre] = 1;  // visiting\n            for (int crs : graph[pre]) {\n                if (state[crs] == 1 || (state[crs] == 0 &amp;&amp; dfs(crs))) {\n                    return true;\n                }\n            }\n            state[pre] = 2;  // visited\n            return false;\n        };\n\n        for (int i = 0; i &lt; numCourses; i++) {\n            if (state[i] == 0 &amp;&amp; dfs(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution sol;\n    vector&lt;vector&lt;int&gt;&gt; prerequisites = {{1, 0}, {2, 1}, {3, 2}, {4, 3},\n                                         {5, 4}, {6, 5}, {7, 6}, {8, 7},\n                                         {9, 8}, {10, 9}};\n    int numCourses = 11;\n    cout &lt;&lt; sol.canFinishBFS(numCourses, prerequisites) &lt;&lt; endl;\n    cout &lt;&lt; sol.canFinishDFS(numCourses, prerequisites) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/graph/#210-course-schedule-ii","title":"210. Course Schedule II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Graph, Topological Sort</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return the ordering of courses you should take to finish all courses. If there are multiple valid answers, return any of them.\n\n![0207](../../assets/0207.png)\n\"\"\"\n\nfrom collections import defaultdict, deque\nfrom typing import List\n\n\n# 1. BFS - Kahn's Algorithm\ndef findOrderBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    order = []\n\n    while q:\n        pre = q.popleft()\n        order.append(pre)\n\n        for crs in graph[pre]:\n            indegree[crs] -= 1\n            if indegree[crs] == 0:\n                q.append(crs)\n\n    return order if len(order) == numCourses else []\n\n\n# 2. DFS + Set\ndef findOrderDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]:\n    adj = defaultdict(list)\n    for crs, pre in prerequisites:\n        adj[crs].append(pre)\n\n    visit, cycle = set(), set()\n    order = []\n\n    def dfs(crs):\n        if crs in cycle:\n            return False\n        if crs in visit:\n            return True\n\n        cycle.add(crs)\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        cycle.remove(crs)\n        visit.add(crs)\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order\n\n\n# 3. DFS + List\ndef findOrderDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]:\n    adj = defaultdict(list)\n    for pre, crs in prerequisites:\n        adj[crs].append(pre)\n\n    # 0: not visited, 1: visiting, 2: visited\n    state = [0] * numCourses\n    order = []\n\n    def dfs(crs):\n        if state[crs] == 1:\n            return False\n        if state[crs] == 2:\n            return True\n\n        state[crs] = 1\n\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        state[crs] = 2\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order[::-1]\n\n\nnumCourses = 5\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(findOrderBFS(numCourses, prerequisites))  # [2, 4, 3, 1, 0]\nprint(findOrderDFS1(numCourses, prerequisites))  # [4, 3, 1, 2, 0]\nprint(findOrderDFS2(numCourses, prerequisites))  # [4, 3, 2, 1, 0]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    // BFS\n    vector&lt;int&gt; findOrderBFS(int numCourses,\n                             vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        vector&lt;int&gt; in_degree(numCourses, 0);\n        vector&lt;int&gt; res;\n\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n            in_degree[pre[0]]++;\n        }\n\n        queue&lt;int&gt; q;\n        for (int i = 0; i &lt; numCourses; i++)\n            if (in_degree[i] == 0) q.push(i);\n\n        while (!q.empty()) {\n            int cur = q.front();\n            q.pop();\n            res.push_back(cur);\n\n            for (int next : graph[cur]) {\n                in_degree[next]--;\n                if (in_degree[next] == 0) q.push(next);\n            }\n        }\n\n        return (int)res.size() == numCourses ? res : vector&lt;int&gt;{};\n    }\n};\n\nint main() {\n    Solution obj;\n    vector&lt;vector&lt;int&gt;&gt; prerequisites{{1, 0}, {2, 0}, {3, 1}, {3, 2}};\n    vector&lt;int&gt; res = obj.findOrderBFS(4, prerequisites);\n    assert((res == vector&lt;int&gt;{0, 1, 2, 3} || res == vector&lt;int&gt;{0, 2, 1, 3}));\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/graph_bfs/","title":"Graph BFS","text":""},{"location":"interview-150/graph_bfs/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 909. Snakes and Ladders (Medium)</li> <li> 433. Minimum Genetic Mutation (Medium)</li> <li> 127. Word Ladder (Hard)</li> </ul>"},{"location":"interview-150/graph_bfs/#909-snakes-and-ladders","title":"909. Snakes and Ladders","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Breadth First Search, Matrix</p> </li> </ul>"},{"location":"interview-150/graph_bfs/#433-minimum-genetic-mutation","title":"433. Minimum Genetic Mutation","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Breadth First Search</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef minMutation(startGene: str, endGene: str, bank: List[str]) -&gt; int:\n    if endGene not in bank:\n        return -1\n\n    bank = set(bank)\n    q = deque([(startGene, 0)])\n\n    while q:\n        gene, step = q.popleft()\n        if gene == endGene:\n            return step\n\n        for i in range(8):\n            for c in \"ACGT\":\n                if gene[i] == c:\n                    continue\n                newGene = gene[:i] + c + gene[i + 1 :]\n                if newGene in bank:\n                    bank.remove(newGene)\n                    q.append((newGene, step + 1))\n    return -1\n\n\nstartGene = \"AACCGGTT\"\nendGene = \"AAACGGTA\"\nbank = [\"AACCGGTA\", \"AACCGCTA\", \"AAACGGTA\"]\nprint(minMutation(startGene, endGene, bank))  # 2\n</code></pre>"},{"location":"interview-150/graph_bfs/#127-word-ladder","title":"127. Word Ladder","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Breadth First Search</p> </li> </ul> Python <pre><code>\"\"\"\n-   The most classic BFS problem.\n-   Return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\n-   Approach: BFS\n-   Time Complexity: O(n * m^2)\n-   Space Complexity: O(n * m)\n\"\"\"\n\nfrom collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef ladderLength(beginWord: str, endWord: str, wordList: List[str]) -&gt; int:\n    if endWord not in wordList:\n        return 0\n\n    n = len(beginWord)\n    graph = defaultdict(list)  # pattern: words\n    wordList.append(beginWord)\n\n    for word in wordList:\n        for i in range(n):\n            pattern = word[:i] + \"*\" + word[i + 1 :]\n            graph[pattern].append(word)\n\n    visited = set([beginWord])\n    q = deque([beginWord])\n    res = 1\n\n    while q:\n        size = len(q)\n        for _ in range(size):\n            word = q.popleft()\n            if word == endWord:\n                return res\n\n            for i in range(n):\n                pattern = word[:i] + \"*\" + word[i + 1 :]\n                for neighbor in graph[pattern]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        q.append(neighbor)\n        res += 1\n\n    return 0\n\n\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]\nprint(ladderLength(beginWord, endWord, wordList))  # 5\n</code></pre>"},{"location":"interview-150/hash_table/","title":"Hash Table","text":""},{"location":"interview-150/hash_table/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 383. Ransom Note (Easy)</li> <li> 205. Isomorphic Strings (Easy)</li> <li> 290. Word Pattern (Easy)</li> <li> 242. Valid Anagram (Easy)</li> <li> 49. Group Anagrams (Medium)</li> <li> 1. Two Sum (Easy)</li> <li> 202. Happy Number (Easy)</li> <li> 219. Contains Duplicate II (Easy)</li> <li> 128. Longest Consecutive Sequence (Medium)</li> </ul>"},{"location":"interview-150/hash_table/#383-ransom-note","title":"383. Ransom Note","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Counting</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return `True` if the ransom note can be constructed from the magazines, otherwise, return `False`.\n\"\"\"\n\nfrom collections import Counter, defaultdict\n\n\n# Array\ndef canConstructArray(ransomNote: str, magazine: str) -&gt; bool:\n    if len(ransomNote) &gt; len(magazine):\n        return False\n\n    record = [0 for _ in range(26)]\n\n    for i in magazine:\n        record[ord(i) - ord(\"a\")] += 1\n\n    for j in ransomNote:\n        record[ord(j) - ord(\"a\")] -= 1\n\n    for i in record:\n        if i &lt; 0:\n            return False\n\n    return True\n\n\n# Dict\ndef canConstructDict(ransomNote: str, magazine: str) -&gt; bool:\n    if len(ransomNote) &gt; len(magazine):\n        return False\n\n    record = defaultdict(int)\n\n    for i in magazine:\n        record[i] += 1\n\n    for j in ransomNote:\n        if j not in record or record[j] == 0:\n            return False\n        record[j] -= 1\n\n    return True\n\n\n# Counter\ndef canConstructCounter(ransomNote: str, magazine: str) -&gt; bool:\n    return not Counter(ransomNote) - Counter(magazine)\n\n\nransomNote = \"aa\"\nmagazine = \"aab\"\nprint(canConstructArray(ransomNote, magazine))  # True\nprint(canConstructDict(ransomNote, magazine))  # True\nprint(canConstructCounter(ransomNote, magazine))  # True\n</code></pre>"},{"location":"interview-150/hash_table/#205-isomorphic-strings","title":"205. Isomorphic Strings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String</p> </li> </ul> CPP <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool isIsomorphic(string s, string t) {\n        if (s.size() != t.size()) return false;\n\n        unordered_map&lt;char, char&gt; map_s2t;\n        unordered_map&lt;char, char&gt; map_t2s;\n\n        for (size_t i = 0; i &lt; s.size(); i++) {\n            char a = s[i];\n            char b = t[i];\n\n            if (map_s2t.count(a) &amp;&amp; map_s2t[a] != b) return false;\n            if (map_t2s.count(b) &amp;&amp; map_t2s[b] != a) return false;\n\n            map_s2t[a] = b;\n            map_t2s[b] = a;\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution sol;\n    assert(sol.isIsomorphic(\"egg\", \"add\") == true);\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/hash_table/#290-word-pattern","title":"290. Word Pattern","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String</p> </li> </ul> PythonCPP <pre><code>def wordPattern(pattern: str, s: str) -&gt; bool:\n    words = s.split()\n    if len(pattern) != len(words):\n        return False\n\n    p2w, w2p = {}, {}\n    for p, w in zip(pattern, words):\n        if (p in p2w and p2w[p] != w) or (w in w2p and w2p[w] != p):\n            return False\n        p2w[p] = w\n        w2p[w] = p\n    return True\n\n\ndef test_wordPattern():\n    assert wordPattern(\"abba\", \"dog cat cat dog\")\n    assert not wordPattern(\"abba\", \"dog cat cat fish\")\n    assert not wordPattern(\"aaaa\", \"dog cat cat dog\")\n    assert not wordPattern(\"abba\", \"dog dog dog dog\")\n    assert wordPattern(\"abc\", \"b c a\")\n    assert not wordPattern(\"abc\", \"b c a a\")\n    assert not wordPattern(\"ab\", \"b b\")\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nbool wordPattern(const string&amp; pattern, const string&amp; s) {\n    vector&lt;string&gt; words;\n    istringstream iss(s);\n    string word;\n    while (iss &gt;&gt; word) {\n        words.push_back(word);\n    }\n    if (pattern.size() != words.size()) return false;\n\n    unordered_map&lt;char, string&gt; p2w;\n    unordered_map&lt;string, char&gt; w2p;\n\n    for (size_t i = 0; i &lt; pattern.size(); ++i) {\n        char p = pattern[i];\n        const string&amp; w = words[i];\n        if ((p2w.count(p) &amp;&amp; p2w[p] != w) || (w2p.count(w) &amp;&amp; w2p[w] != p)) {\n            return false;\n        }\n        p2w[p] = w;\n        w2p[w] = p;\n    }\n    return true;\n}\n\nint main() {\n    assert(wordPattern(\"abba\", \"dog cat cat dog\") == true);\n    assert(wordPattern(\"abba\", \"dog cat cat fish\") == false);\n    assert(wordPattern(\"aaaa\", \"dog cat cat dog\") == false);\n    assert(wordPattern(\"abba\", \"dog dog dog dog\") == false);\n    assert(wordPattern(\"abc\", \"b c a\") == true);\n    assert(wordPattern(\"abc\", \"b c a a\") == false);\n    assert(wordPattern(\"ab\", \"b b\") == false);\n    cout &lt;&lt; \"All test cases pass\" &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/hash_table/#242-valid-anagram","title":"242. Valid Anagram","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sorting</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return true if an input string is an anagram of another string.\n-   An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once, e.g., `listen` is an anagram of `silent`.\n\"\"\"\n\nfrom collections import Counter\n\n\n# Hashmap\ndef isAnagramHash(s: str, t: str) -&gt; bool:\n    \"\"\"Return True if t is an anagram of s, False otherwise.\"\"\"\n    if len(s) != len(t):\n        return False\n\n    count = dict()\n\n    for i in s:\n        if i in count:\n            count[i] += 1\n        else:\n            count[i] = 1\n\n    for j in t:\n        if j in count:\n            count[j] -= 1\n        else:\n            return False\n\n    for count in count.values():\n        if count != 0:\n            return False\n\n    return True\n\n\n# Array\ndef isAnagramArray(s: str, t: str) -&gt; bool:\n    if len(s) != len(t):\n        return False\n\n    count = [0 for _ in range(26)]\n\n    for i in s:\n        count[ord(i) - ord(\"a\")] += 1\n\n    for j in t:\n        count[ord(j) - ord(\"a\")] -= 1\n\n    for i in count:\n        if i != 0:\n            return False\n\n    return True\n\n\n# Counter\ndef isAnagramCounter(s: str, t: str) -&gt; bool:\n    return Counter(s) == Counter(t)\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |   Hashmap   |       O(n)      |     O(1)     |\n# |    Array    |       O(n)      |     O(1)     |\n# |   Counter   |       O(n)      |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\ns = \"anagram\"\nt = \"nagaram\"\nprint(isAnagramHash(s, t))  # True\nprint(isAnagramArray(s, t))  # True\nprint(isAnagramCounter(s, t))  # True\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool isAnagram(string s, string t) {\n        if (s.size() != t.size()) return false;\n\n        vector&lt;int&gt; count(26, 0);\n\n        for (char ch : s) count[ch - 'a']++;\n        for (char ch : t) count[ch - 'a']--;\n        for (int c : count) {\n            if (c != 0) return false;\n        }\n\n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n    assert(solution.isAnagram(\"anagram\", \"nagaram\") == true);\n    assert(solution.isAnagram(\"rat\", \"car\") == false);\n    assert(solution.isAnagram(\"a\", \"ab\") == false);\n    assert(solution.isAnagram(\"a\", \"a\") == true);\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/hash_table/#49-group-anagrams","title":"49. Group Anagrams","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Sorting</p> </li> </ul> PythonCPP <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash - List\ndef groupAnagrams(strs: List[str]) -&gt; List[List[str]]:\n    result = defaultdict(list)\n\n    for s in strs:\n        count = [0] * 26\n        for i in s:\n            count[ord(i) - ord(\"a\")] += 1\n\n        result[tuple(count)].append(s)\n\n    return list(result.values())\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Hash     |     O(n * k)    |     O(n)     |\n# |-------------|-----------------|--------------|\n\n\nstrs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\nprint(groupAnagrams(strs))\n# [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;cassert&gt;\n#include &lt;ranges&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Solution {\n   public:\n    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) {\n        unordered_map&lt;string, vector&lt;string&gt;&gt; map;\n\n        for (string&amp; s : strs) {\n            string sorted = s;\n            ranges::sort(sorted);\n            map[sorted].push_back(s);\n        }\n\n        vector&lt;vector&lt;string&gt;&gt; res;\n\n        for (auto&amp; kv : map) {\n            res.push_back(kv.second);\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;string&gt; strs = {\"eat\", \"tea\", \"tan\"};\n    vector&lt;vector&lt;string&gt;&gt; res = solution.groupAnagrams(strs);\n    assert((res == vector&lt;vector&lt;string&gt;&gt;{{\"eat\", \"tea\"}, {\"tan\"}} ||\n            res == vector&lt;vector&lt;string&gt;&gt;{{\"tan\"}, {\"eat\", \"tea\"}}));\n\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/hash_table/#1-two-sum","title":"1. Two Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return the indices of the two numbers such that they add up to a specific target.\n- Approach: Use a hashmap to store the indices of the numbers.\n- Time Complexity: O(n)\n- Space Complexity: O(n)\n\"\"\"\n\nfrom typing import List\n\n\ndef two_sum(nums: List[int], target: int) -&gt; List[int]:\n    hashmap = {}  # val: idx\n\n    for idx, val in enumerate(nums):\n        if (target - val) in hashmap:\n            return [hashmap[target - val], idx]\n\n        hashmap[val] = idx\n\n    return []\n\n\ndef test_two_sum():\n    assert two_sum([2, 7, 11, 15], 9) == [0, 1]\n    assert two_sum([3, 2, 4], 6) == [1, 2]\n    assert two_sum([3, 3], 6) == [0, 1]\n    assert two_sum([1, 2, 3, 4, 5], 10) == []\n    assert two_sum([-1, -2, -3, -4, -5], -8) == [2, 4]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Solution {\n   public:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {\n        unordered_map&lt;int, int&gt; map;\n\n        for (size_t i = 0; i &lt; nums.size(); i++) {\n            int diff = target - nums[i];\n            if (map.find(diff) != map.end()) {\n                return {map[diff], (int)i};\n            }\n            map[nums[i]] = (int)i;\n        }\n        return {-1, -1};\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; nums = {2, 7, 11, 15};\n    int target = 9;\n    vector&lt;int&gt; result = solution.twoSum(nums, target);\n    assert((result == vector&lt;int&gt;{0, 1}));\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/hash_table/#202-happy-number","title":"202. Happy Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Math, Two Pointers</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return `True` if the number is a happy number, otherwise, return `False`.\n-   A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.\n\"\"\"\n\n\ndef isHappy(n: int) -&gt; bool:\n\n    def getSum(n):\n        sum_of_squares = 0\n        while n:\n            a, b = divmod(n, 10)\n            sum_of_squares += b**2\n            n = a\n        return sum_of_squares\n\n    record = set()\n\n    while True:\n        if n == 1:\n            return True\n\n        if n in record:\n            return False\n        else:\n            record.add(n)\n\n        n = getSum(n)\n\n\nn = 19\nprint(isHappy(n))  # True\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;unordered_set&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int getNext(int n) {\n        int res = 0;\n        while (n) {\n            int mod = n % 10;\n            res += mod * mod;\n            n /= 10;\n        }\n        return res;\n    }\n\n    bool isHappy(int n) {\n        unordered_set&lt;int&gt; seen;\n        while (n != 1) {\n            n = getNext(n);\n            if (seen.find(n) != seen.end()) return false;\n            seen.insert(n);\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution s;\n    assert(s.isHappy(19) == true);\n    assert(s.isHappy(2) == false);\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/hash_table/#219-contains-duplicate-ii","title":"219. Contains Duplicate II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Sliding Window</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\n# Hash\ndef containsNearbyDuplicateHash(nums: List[int], k: int) -&gt; bool:\n    hashmap = {}  # num: last index\n\n    for idx, num in enumerate(nums):\n        if num in hashmap:\n            if idx - hashmap[num] &lt;= k:\n                return True\n\n        hashmap[num] = idx\n\n    return False\n\n\n# Sliding window - Fixed\ndef containsNearbyDuplicateWindow(nums: List[int], k: int) -&gt; bool:\n    window = set()\n    left = 0\n\n    for right in range(len(nums)):\n        if right - left &gt; k:\n            window.remove(nums[left])\n            left += 1\n        if nums[right] in window:\n            return True\n        window.add(nums[right])\n\n    return False\n\n\nnums = [1, 2, 3, 1]\nk = 3\nprint(containsNearbyDuplicateHash(nums, k))  # True\nprint(containsNearbyDuplicateWindow(nums, k))  # True\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;unordered_map&gt;\n#include &lt;unordered_set&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) {\n        unordered_map&lt;int, int&gt; last;\n\n        for (size_t i = 0; i &lt; nums.size(); i++) {\n            int num = nums[i];\n            if (last.contains(num) &amp;&amp; ((int)i - last[num] &lt;= k)) return true;\n            last[num] = i;\n        }\n        return false;\n    }\n    bool containsNearbyDuplicateSlidingWindow(vector&lt;int&gt;&amp; nums, int k) {\n        unordered_set&lt;int&gt; window;\n\n        for (size_t i = 0; i &lt; nums.size(); i++) {\n            if (window.contains(nums[i])) return true;\n            window.insert(nums[i]);\n\n            if ((int)i - k &gt;= 0) {\n                window.erase(nums[i - k]);\n            }\n        }\n        return false;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; nums = {1, 2, 3, 1};\n    assert(solution.containsNearbyDuplicate(nums, 3));\n    assert(solution.containsNearbyDuplicateSlidingWindow(nums, 3));\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/hash_table/#128-longest-consecutive-sequence","title":"128. Longest Consecutive Sequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Union Find</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Set\ndef longestConsecutiveSet(nums: List[int]) -&gt; int:\n    num_set = set(nums)  # O(n)\n    longest = 0\n\n    for n in nums:\n        if (n - 1) not in num_set:  # left boundary\n            length = 1\n\n            while (n + length) in num_set:\n                length += 1\n\n            longest = max(longest, length)\n\n    return longest\n\n\n# Union Find\ndef longestConsecutiveUF(nums: List[int]) -&gt; int:\n    if not nums:\n        return 0\n\n    par = {num: num for num in nums}\n    rank = {num: 1 for num in nums}\n\n    def find(num):\n        p = par[num]\n        while p != par[p]:\n            p = par[p]\n        return p\n\n    def union(num1, num2):\n        p1, p2 = find(num1), find(num2)\n        if p1 == p2:\n            return\n\n        if rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n            rank[p2] += rank[p1]\n        else:\n            par[p2] = p1\n            rank[p1] += rank[p2]\n\n    for num in nums:\n        if num - 1 in par:\n            union(num, num - 1)\n\n    return max(rank.values())\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |  Set       |  O(N)  |  O(N)   |\n# | Union Find |  O(N)  |  O(N)   |\n# |------------|--------|---------|\n\n\nnums = [100, 4, 200, 1, 3, 2]\nprint(longestConsecutiveSet(nums))  # 4\nprint(longestConsecutiveUF(nums))  # 4\n</code></pre>"},{"location":"interview-150/heap/","title":"Heap","text":""},{"location":"interview-150/heap/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 215. Kth Largest Element in an Array (Medium)</li> <li> 502. IPO (Hard)</li> <li> 373. Find K Pairs with Smallest Sums (Medium)</li> <li> 295. Find Median from Data Stream (Hard)</li> </ul>"},{"location":"interview-150/heap/#215-kth-largest-element-in-an-array","title":"215. Kth Largest Element in an Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Divide And Conquer, Sorting, Heap Priority Queue, Quickselect</p> </li> </ul> Python <pre><code>import heapq\nfrom typing import List\n\n\ndef findKthLargest(nums: List[int], k: int) -&gt; int:\n    min_heap = []\n\n    for i, num in enumerate(nums):\n        heapq.heappush(min_heap, num)\n        if i &gt;= k:\n            heapq.heappop(min_heap)\n\n    return min_heap[0]\n\n\nif __name__ == \"__main__\":\n    assert findKthLargest([3, 2, 1, 5, 6, 4], 2) == 5\n</code></pre>"},{"location":"interview-150/heap/#502-ipo","title":"502. IPO","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting, Heap Priority Queue</p> </li> </ul> Python <pre><code>import heapq\nfrom typing import List\n\n\n# Heap - Two Heaps\ndef findMaximizedCapital(k: int, w: int, profits: List[int], capital: List[int]) -&gt; int:\n    \"\"\"\n    Time Complexity: O(k log N)\n    Space Complexity: O(N)\n    \"\"\"\n    if not profits or not capital:\n        return w\n\n    if w &gt;= max(capital) and k &gt;= len(capital):\n        return sum(profits) + w\n\n    max_profit = []\n    min_capital = [(c, p) for c, p in zip(capital, profits)]\n    heapq.heapify(min_capital)\n\n    for _ in range(k):\n        while min_capital and min_capital[0][0] &lt;= w:\n            _, pro = heapq.heappop(min_capital)\n            heapq.heappush(max_profit, -pro)\n\n        if max_profit:\n            w += -heapq.heappop(max_profit)\n\n    return w\n\n\nif __name__ == \"__main__\":\n    k = 2\n    w = 0\n    profits = [1, 2, 3]\n    capital = [0, 1, 1]\n    assert findMaximizedCapital(k, w, profits, capital) == 4\n</code></pre>"},{"location":"interview-150/heap/#373-find-k-pairs-with-smallest-sums","title":"373. Find K Pairs with Smallest Sums","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Heap Priority Queue</p> </li> </ul> Python <pre><code>import heapq\nfrom typing import List\n\n\n# Heap - Merge K Sorted\ndef kSmallestPairs(nums1: List[int], nums2: List[int], k: int) -&gt; List[List[int]]:\n    if not nums1 or not nums2 or k &lt;= 0:\n        return []\n\n    res = []\n    min_heap = []\n\n    for j in range(min(k, len(nums2))):\n        heapq.heappush(min_heap, (nums1[0] + nums2[j], 0, j))\n\n    while k &gt; 0 and min_heap:\n        _, i, j = heapq.heappop(min_heap)\n        res.append([nums1[i], nums2[j]])\n        k -= 1\n\n        if i + 1 &lt; len(nums1):\n            heapq.heappush(min_heap, (nums1[i + 1] + nums2[j], i + 1, j))\n\n    return res\n\n\nif __name__ == \"__main__\":\n    nums1 = [1, 2, 4, 5, 6]\n    nums2 = [3, 5, 7, 9]\n    k = 3\n    assert kSmallestPairs(nums1, nums2, k) == [[1, 3], [2, 3], [1, 5]]\n</code></pre>"},{"location":"interview-150/heap/#295-find-median-from-data-stream","title":"295. Find Median from Data Stream","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, Design, Sorting, Heap Priority Queue, Data Stream</p> </li> </ul> PythonCPP <pre><code>from heapq import heappop, heappush\n\n\nclass MedianFinder:\n\n    def __init__(self):\n        self.minHeap = []\n        self.maxHeap = []\n        self.min_size = 0\n        self.max_size = 0\n\n    def addNum(self, num: int) -&gt; None:\n        heappush(self.maxHeap, -num)\n        heappush(self.minHeap, -heappop(self.maxHeap))\n        self.min_size += 1\n\n        if self.min_size &gt; self.max_size:\n            heappush(self.maxHeap, -heappop(self.minHeap))\n            self.min_size -= 1\n            self.max_size += 1\n\n    def findMedian(self) -&gt; float:\n        if self.min_size == self.max_size:\n            return (-self.maxHeap[0] + self.minHeap[0]) / 2.0\n        return float(-self.maxHeap[0])\n\n\ndef test_median_finder():\n    obj = MedianFinder()\n    obj.addNum(1)\n    obj.addNum(2)\n    assert obj.findMedian() == 1.5\n    obj.addNum(3)\n    assert obj.findMedian() == 2.0\n    obj.addNum(4)\n    assert obj.findMedian() == 2.5\n    obj.addNum(5)\n    assert obj.findMedian() == 3.0\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass MedianFinder {\n   private:\n    priority_queue&lt;int&gt; maxHeap;\n    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;\n    int max_size = 0;\n    int min_size = 0;\n\n   public:\n    MedianFinder() {}\n\n    void addNum(int num) {\n        if (min_size == max_size) {\n            minHeap.push(num);\n            maxHeap.push(minHeap.top());\n            minHeap.pop();\n            max_size++;\n        } else {\n            maxHeap.push(num);\n            minHeap.push(maxHeap.top());\n            maxHeap.pop();\n            min_size++;\n        }\n    }\n\n    double findMedian() {\n        if (min_size == max_size) {\n            return (maxHeap.top() + minHeap.top()) / 2.0;\n        } else {\n            return (double)maxHeap.top();\n        }\n    }\n};\n\nint main() {\n    MedianFinder* obj = new MedianFinder();\n    obj-&gt;addNum(1);\n    obj-&gt;addNum(2);\n    cout &lt;&lt; obj-&gt;findMedian() &lt;&lt; endl;  // 1.5\n    obj-&gt;addNum(3);\n    cout &lt;&lt; obj-&gt;findMedian() &lt;&lt; endl;  // 2\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/intervals/","title":"Intervals","text":""},{"location":"interview-150/intervals/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 228. Summary Ranges (Easy)</li> <li> 56. Merge Intervals (Medium)</li> <li> 57. Insert Interval (Medium)</li> <li> 452. Minimum Number of Arrows to Burst Balloons (Medium)</li> </ul>"},{"location":"interview-150/intervals/#228-summary-ranges","title":"228. Summary Ranges","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Variable Sliding Window\ndef summaryRanges(nums: List[int]) -&gt; List[str]:\n    left, right = 0, 0\n    n = len(nums)\n    res = []\n\n    while left &lt; n:\n        while right + 1 &lt; n and nums[right] + 1 == nums[right + 1]:\n            right += 1\n\n        if left == right:\n            res.append(f\"{nums[left]}\")\n        else:\n            res.append(f\"{nums[left]}-&gt;{nums[right]}\")\n\n        right += 1\n        left = right\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(summaryRanges([0, 1, 2, 4, 5, 7]))\n    # [\"0-&gt;2\", \"4-&gt;5\", \"7\"]\n    print(summaryRanges([0, 2, 3, 4, 6, 8, 9]))\n    # [\"0\", \"2-&gt;4\", \"6\", \"8-&gt;9\"]\n</code></pre>"},{"location":"interview-150/intervals/#56-merge-intervals","title":"56. Merge Intervals","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sorting</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Merge all overlapping intervals.\n\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/44H3cEC2fFM?si=J-Jr_Fg2eDse3-de\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen&gt;&lt;/iframe&gt;\n\"\"\"\n\nfrom typing import List\n\n\n# Intervals\ndef merge(intervals: List[List[int]]) -&gt; List[List[int]]:\n    n = len(intervals)\n    if n &lt;= 1:\n        return intervals\n\n    intervals.sort(key=lambda x: x[0])\n    res = [intervals[0]]\n\n    for i in range(1, n):\n        if intervals[i][0] &lt;= res[-1][1]:\n            res[-1][1] = max(res[-1][1], intervals[i][1])\n        else:\n            res.append(intervals[i])\n\n    return res\n\n\nprint(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))\n# [[1, 6], [8, 10], [15, 18]]\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// Interval\nvector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {\n    sort(intervals.begin(), intervals.end());\n    vector&lt;vector&lt;int&gt;&gt; res;\n\n    for (auto&amp; range : intervals) {\n        if (!res.empty() &amp;&amp; range[0] &lt;= res.back()[1]) {\n            res.back()[1] = max(res.back()[1], range[1]);\n        } else {\n            res.emplace_back(range);\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;vector&lt;int&gt;&gt; intervals = {{1, 3}, {2, 6}, {8, 10}, {15, 18}};\n    vector&lt;vector&lt;int&gt;&gt; res = merge(intervals);\n    for (auto&amp; range : res) {\n        cout &lt;&lt; range[0] &lt;&lt; \", \" &lt;&lt; range[1] &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/intervals/#57-insert-interval","title":"57. Insert Interval","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Interval\ndef insert(intervals: List[List[int]], newInterval: List[int]) -&gt; List[List[int]]:\n    n = len(intervals)\n\n    if n == 0:\n        return [newInterval]\n\n    if newInterval[1] &lt; intervals[0][0]:\n        return [newInterval] + intervals\n\n    if newInterval[0] &gt; intervals[-1][1]:\n        return intervals + [newInterval]\n\n    i = 0\n    result = []\n\n    while i &lt; n and intervals[i][1] &lt; newInterval[0]:\n        result.append(intervals[i])\n        i += 1\n\n    while i &lt; n and intervals[i][0] &lt;= newInterval[1]:\n        newInterval[0] = min(newInterval[0], intervals[i][0])\n        newInterval[1] = max(newInterval[1], intervals[i][1])\n        i += 1\n\n    result.append(newInterval)\n\n    while i &lt; n:\n        result.append(intervals[i])\n        i += 1\n\n    return result\n\n\nintervals = [[1, 3], [6, 9]]\nnewInterval = [2, 5]\nprint(insert(intervals, newInterval))  # [[1, 5], [6, 9]]\n</code></pre>"},{"location":"interview-150/intervals/#452-minimum-number-of-arrows-to-burst-balloons","title":"452. Minimum Number of Arrows to Burst Balloons","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the minimum number of arrows.\n\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/lPmkKnvNPrw?si=P0rkcvTOxRGoFpkG\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen&gt;&lt;/iframe&gt;\n\n-   Differece between two versions\n    1. Start from 1: if there is no overlap, we add one more arrow.\n    2. Start from the number of balloons: if there is overlap, we need to reduce one arrow.\n\"\"\"\n\nfrom typing import List\n\nimport matplotlib.pyplot as plt\n\n\n# Greedy - Interval\ndef findMinArrowShotsGreedy1(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    if n &lt;= 1:\n        return n\n\n    res = 1\n    points.sort(key=lambda x: x[0])\n\n    for i in range(1, n):\n        if points[i][0] &gt; points[i - 1][1]:\n            res += 1\n        else:\n            points[i][1] = min(points[i][1], points[i - 1][1])\n    return res\n\n\n# Greedy - Interval (Neetcode's version)\ndef findMinArrowShotsGreedy2(points: List[List[int]]) -&gt; int:\n    res = len(points)\n    if res == 0:\n        return 0\n\n    points.sort()\n    prev = points[0]\n\n    for i in range(1, len(points)):\n        cur = points[i]\n        if cur[0] &lt;= prev[1]:\n            res -= 1\n            prev = [cur[0], min(prev[1], cur[1])]\n        else:\n            prev = cur\n\n    return res\n\n\n# Greedy - Interval\ndef findMinArrowShotsGreedy3(points: List[List[int]]) -&gt; int:\n    if not points:\n        return 0\n\n    points.sort(key=lambda x: x[1])\n\n    res = 1\n    cur_end = points[0][1]\n\n    for i in range(1, len(points)):\n        if points[i][0] &gt; cur_end:\n            res += 1\n            cur_end = points[i][1]\n\n    return res\n\n\n# Utility\ndef plot(points, i=None):\n    plt.figure(figsize=(8, 4))\n    for idx in range(len(points)):\n        color = \"b\" if idx == i else \"k\"\n        plt.plot(\n            [points[idx][0], points[idx][1]],\n            [idx + 1, idx + 1],\n            f\"{color}o-\",\n            label=f\"Line {idx + 1}\",\n        )\n\n    plt.title(\"Find Min Arrow Shots\")\n    plt.xlabel(\"X-axis\")\n    plt.xlim(0, 17)\n    plt.grid(True)\n    plt.savefig(f\"find_min_arrow_shots_{i}.png\")\n    plt.show()\n\n\n# |------------|-----------|---------|\n# |  Approach  |  Time     |  Space  |\n# |------------|-----------|---------|\n# |  Greedy    |  O(NlogN) |  O(1)   |\n# |------------|-----------|---------|\n\n\npoints = [[10, 16], [2, 8], [1, 6], [7, 12]]\nprint(findMinArrowShotsGreedy1(points))  # 2\nprint(findMinArrowShotsGreedy2(points))  # 2\n</code></pre>"},{"location":"interview-150/kadane_algorithm/","title":"Kadane Algorithm","text":""},{"location":"interview-150/kadane_algorithm/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 53. Maximum Subarray (Medium)</li> <li> 918. Maximum Sum Circular Subarray (Medium)</li> </ul>"},{"location":"interview-150/kadane_algorithm/#53-maximum-subarray","title":"53. Maximum Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Divide And Conquer, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP Kadane\ndef maxSubArrayDP(nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n\n    dp[0] = nums[0]\n    maxSum = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(\n            dp[i - 1] + nums[i],  # continue the previous subarray\n            nums[i],  # start a new subarray\n        )\n        maxSum = max(maxSum, dp[i])\n\n    return maxSum\n\n\n# Greedy\ndef maxSubArrayGreedy(nums: List[int]) -&gt; int:\n    max_sum = nums[0]\n    cur_sum = 0\n\n    for num in nums:\n        cur_sum = max(cur_sum + num, num)\n        max_sum = max(max_sum, cur_sum)\n\n    return max_sum\n\n\n# Prefix Sum\ndef maxSubArrayPrefixSum(nums: List[int]) -&gt; int:\n    prefix_sum = 0\n    prefix_sum_min = 0\n    res = float(\"-inf\")\n\n    for num in nums:\n        prefix_sum += num\n        res = max(res, prefix_sum - prefix_sum_min)\n        prefix_sum_min = min(prefix_sum_min, prefix_sum)\n\n    return res\n\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArrayDP(nums))  # 6\nprint(maxSubArrayGreedy(nums))  # 6\nprint(maxSubArrayPrefixSum(nums))  # 6\n</code></pre>"},{"location":"interview-150/kadane_algorithm/#918-maximum-sum-circular-subarray","title":"918. Maximum Sum Circular Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Divide And Conquer, Dynamic Programming, Queue, Monotonic Queue</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# DP - Kadane\ndef maxSubarraySumCircularKadane(nums: List[int]) -&gt; int:\n    max_sum = min_sum = nums[0]\n    max_cur = min_cur = 0\n    total = 0\n\n    for num in nums:\n        max_cur = max(max_cur + num, num)\n        min_cur = min(min_cur + num, num)\n        total += num\n\n        max_sum = max(max_sum, max_cur)\n        min_sum = min(min_sum, min_cur)\n\n    return max(max_sum, total - min_sum) if max_sum &gt; 0 else max_sum\n\n\n# Monotonic Queue\ndef maxSubarraySumCircularMQ(nums: List[int]) -&gt; int:\n    n = len(nums)\n    prefix_sum = [0] * (2 * n + 1)\n\n    for i in range(1, 2 * n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + nums[(i - 1) % n]\n\n    q = deque([0])\n    max_sum = float(\"-inf\")\n\n    for i in range(1, 2 * n + 1):\n        if q[0] &lt; i - n:\n            q.popleft()\n\n        max_sum = max(max_sum, prefix_sum[i] - prefix_sum[q[0]])\n\n        while q and prefix_sum[q[-1]] &gt;= prefix_sum[i]:\n            q.pop()\n\n        q.append(i)\n\n    return max_sum\n\n\nnums = [1, -2, 3, -2]\nprint(maxSubarraySumCircularKadane(nums))  # 3\nprint(maxSubarraySumCircularMQ(nums))  # 3\n</code></pre>"},{"location":"interview-150/linked_list/","title":"Linked List","text":""},{"location":"interview-150/linked_list/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 141. Linked List Cycle (Easy)</li> <li> 2. Add Two Numbers (Medium)</li> <li> 21. Merge Two Sorted Lists (Easy)</li> <li> 138. Copy List with Random Pointer (Medium)</li> <li> 92. Reverse Linked List II (Medium)</li> <li> 25. Reverse Nodes in k-Group (Hard)</li> <li> 19. Remove Nth Node From End of List (Medium)</li> <li> 82. Remove Duplicates from Sorted List II (Medium)</li> <li> 61. Rotate List (Medium)</li> <li> 86. Partition List (Medium)</li> <li> 146. LRU Cache (Medium)</li> </ul>"},{"location":"interview-150/linked_list/#141-linked-list-cycle","title":"141. Linked List Cycle","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Linked List, Two Pointers</p> </li> </ul> PythonCPP <pre><code>from typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\ndef has_cycle(head: Optional[ListNode]) -&gt; bool:\n    slow, fast = head, head\n\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n        if slow == fast:\n            return True\n\n    return False\n\n\ndef test_has_cycle():\n    ll = LinkedList([3, 2, 0, -4])\n    ll.make_cycle(pos=1)\n    assert has_cycle(ll.head)\n\n    ll = LinkedList([1, 2])\n    ll.make_cycle(pos=0)\n    assert has_cycle(ll.head)\n\n    ll = LinkedList([1, 2, 3, 4, 5])\n    assert not has_cycle(ll.head)\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n\n#include \"include/lists.hpp\"\nusing namespace std;\n\nclass Solution {\n   public:\n    bool has_cycle(ListNode* head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while (fast &amp;&amp; fast-&gt;next) {\n            slow = slow-&gt;next;\n            fast = fast-&gt;next-&gt;next;\n\n            if (fast == slow) return true;\n        }\n        return false;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    ListNode* head = LinkedList::build({3, 2, 0, -4});\n    // create cycle\n    head = LinkedList::make_cycle(head, 1);\n    assert(solution.has_cycle(head) == true);\n    // no cycle\n    ListNode* head2 = LinkedList::build({1, 2});\n    assert(solution.has_cycle(head2) == false);\n    // no cycle\n    ListNode* head3 = LinkedList::build({1});\n    assert(solution.has_cycle(head3) == false);\n\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/linked_list/#2-add-two-numbers","title":"2. Add Two Numbers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Math, Recursion</p> </li> </ul> PythonCPP <pre><code>from typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\ndef add_two_numbers(l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]:\n    \"\"\"Add two numbers represented by linked lists.\"\"\"\n    dummy = ListNode()\n    cur = dummy\n    carry = 0\n\n    while l1 or l2:\n        v1 = l1.val if l1 else 0\n        v2 = l2.val if l2 else 0\n\n        carry, val = divmod(v1 + v2 + carry, 10)\n        cur.next = ListNode(val)\n        cur = cur.next\n\n        if l1:\n            l1 = l1.next\n        if l2:\n            l2 = l2.next\n\n    if carry:\n        cur.next = ListNode(val=carry)\n\n    return dummy.next\n\n\ndef test_add_two_numbers():\n    l1 = LinkedList([2, 4, 3]).head\n    l2 = LinkedList([5, 6, 4]).head\n    added = add_two_numbers(l1, l2)\n    assert LinkedList(added).to_array() == [7, 0, 8]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode* next) : val(x), next(next) {}\n};\n\nclass Solution {\n   public:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode dummy;\n        ListNode* cur = &amp;dummy;\n        int carry = 0;\n\n        while (l1 || l2 || carry) {\n            if (l1) {\n                carry += l1-&gt;val;\n                l1 = l1-&gt;next;\n            }\n            if (l2) {\n                carry += l2-&gt;val;\n                l2 = l2-&gt;next;\n            }\n            cur-&gt;next = new ListNode(carry % 10);\n            cur = cur-&gt;next;\n            carry /= 10;\n        }\n        return dummy.next;\n    }\n};\n\nint main() {\n    Solution sol;\n\n    ListNode* l1 = new ListNode(2, new ListNode(4, new ListNode(3)));\n    ListNode* l2 = new ListNode(5, new ListNode(6, new ListNode(4)));\n    ListNode* result = sol.addTwoNumbers(l1, l2);\n\n    vector&lt;int&gt; expected = {7, 0, 8};\n    for (int val : expected) {\n        assert(result != nullptr &amp;&amp; result-&gt;val == val);\n        result = result-&gt;next;\n    }\n    assert(result == nullptr);  // End of list\n\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/linked_list/#21-merge-two-sorted-lists","title":"21. Merge Two Sorted Lists","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Recursion</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Task: Merge the two linked lists into one sorted list.\n\"\"\"\n\nfrom typing import Optional\n\nfrom leetpattern.utils import ListNode\n\n\n# Linked List\ndef merge_two_lists(\n    list1: Optional[ListNode], list2: Optional[ListNode]\n) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    while list1 and list2:\n        if list1.val &lt; list2.val:\n            cur.next = list1\n            list1 = list1.next\n        else:\n            cur.next = list2\n            list2 = list2.next\n        cur = cur.next\n\n    if list1:\n        cur.next = list1\n    elif list2:\n        cur.next = list2\n\n    return dummy.next\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode* next) : val(x), next(next) {}\n};\n\nclass Solution {\n   public:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        ListNode dummy;\n        ListNode* cur = &amp;dummy;\n\n        while (list1 &amp;&amp; list2) {\n            if (list1-&gt;val &lt; list2-&gt;val) {\n                cur-&gt;next = list1;\n                list1 = list1-&gt;next;\n            } else {\n                cur-&gt;next = list2;\n                list2 = list2-&gt;next;\n            }\n            cur = cur-&gt;next;\n        }\n\n        cur-&gt;next = list1 ? list1 : list2;\n\n        return dummy.next;\n    }\n};\n\nint main() {\n    Solution sol;\n    ListNode* list1 = new ListNode(1, new ListNode(2, new ListNode(4)));\n    ListNode* list2 = new ListNode(1, new ListNode(3, new ListNode(4)));\n    ListNode* merged = sol.mergeTwoLists(list1, list2);\n    vector&lt;int&gt; res;\n    while (merged) {\n        res.push_back(merged-&gt;val);\n        merged = merged-&gt;next;\n    }\n    assert(res == std::vector&lt;int&gt;({1, 1, 2, 3, 4, 4}));\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/linked_list/#138-copy-list-with-random-pointer","title":"138. Copy List with Random Pointer","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Linked List</p> </li> </ul> Python <pre><code>from typing import Optional\n\n\nclass Node:\n    def __init__(self, x: int, next: \"Node\" = None, random: \"Node\" = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\n\ndef copyRandomList(head: \"Optional[Node]\") -&gt; \"Optional[Node]\":\n    if not head:\n        return None\n\n    # Copy nodes and link them together\n    cur = head\n    while cur:\n        new_node = Node(cur.val)\n        new_node.next = cur.next\n        cur.next = new_node\n        cur = new_node.next\n\n    # Copy random pointers\n    cur = head\n    while cur:\n        cur.next.random = cur.random.next if cur.random else None\n        cur = cur.next.next\n\n    # Separate the original and copied lists\n    cur = head\n    new_head = head.next\n    while cur:\n        new_node = cur.next\n        cur.next = new_node.next\n        new_node.next = new_node.next.next if new_node.next else None\n        cur = cur.next\n\n    return new_head\n</code></pre>"},{"location":"interview-150/linked_list/#92-reverse-linked-list-ii","title":"92. Reverse Linked List II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Reverse a linked list from position left to position right. Return the linked list after reversing.\n\"\"\"\n\nfrom typing import Optional\n\nfrom leetpattern.utils import ListNode, list_from_array, list_to_array\n\n\ndef reverseBetween(head: Optional[ListNode], left: int, right: int) -&gt; Optional[ListNode]:\n    dummy = ListNode(next=head)\n    p0 = dummy\n    for _ in range(left - 1):\n        if p0.next is None:\n            break\n        p0 = p0.next\n\n    pre = None\n    cur = p0.next\n    for _ in range(right - left + 1):\n        if not cur:\n            break\n        nxt = cur.next\n        cur.next = pre\n        pre = cur\n        cur = nxt\n\n    if p0.next:\n        p0.next.next = cur\n    p0.next = pre\n\n    return dummy.next\n\n\ndef test_reverse_between():\n    head = list_from_array([1, 2, 3, 4, 5])\n    left = 2\n    right = 4\n    result = reverseBetween(head, left, right)\n    assert list_to_array(result) == [1, 4, 3, 2, 5]\n\n    head = list_from_array([5])\n    left = 1\n    right = 1\n    result = reverseBetween(head, left, right)\n    assert list_to_array(result) == [5]\n\n    head = list_from_array([3, 5])\n    left = 1\n    right = 2\n    result = reverseBetween(head, left, right)\n    assert list_to_array(result) == [5, 3]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode* next) : val(x), next(next) {}\n};\n\nclass Solution {\n   public:\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\n        if (!head || left == right) return head;\n\n        ListNode dummy(0);\n        dummy.next = head;\n        ListNode* p0 = &amp;dummy;\n\n        for (int i = 0; i &lt; left - 1; ++i) {\n            p0 = p0-&gt;next;\n        }\n\n        ListNode* pre = nullptr;\n        ListNode* cur = p0-&gt;next;\n        int count = right - left + 1;\n\n        while (count--) {\n            ListNode* next = cur-&gt;next;\n            cur-&gt;next = pre;\n            pre = cur;\n            cur = next;\n        }\n\n        p0-&gt;next-&gt;next = cur;\n        p0-&gt;next = pre;\n\n        return dummy.next;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    ListNode* head1 = new ListNode(\n        1, new ListNode(2, new ListNode(3, new ListNode(4, new ListNode(5)))));\n    int left1 = 2, right1 = 4;\n    ListNode* result1 = solution.reverseBetween(head1, left1, right1);\n    ListNode* expected1 = new ListNode(\n        1, new ListNode(4, new ListNode(3, new ListNode(2, new ListNode(5)))));\n    for (ListNode *p = result1, *q = expected1; p != nullptr &amp;&amp; q != nullptr;\n         p = p-&gt;next, q = q-&gt;next) {\n        assert(p-&gt;val == q-&gt;val);\n    }\n\n    ListNode* head2 = new ListNode(5);\n    int left2 = 1, right2 = 1;\n    ListNode* result2 = solution.reverseBetween(head2, left2, right2);\n    ListNode* expected2 = new ListNode(5);\n    for (ListNode *p = result2, *q = expected2; p != nullptr &amp;&amp; q != nullptr;\n         p = p-&gt;next, q = q-&gt;next) {\n        assert(p-&gt;val == q-&gt;val);\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/linked_list/#25-reverse-nodes-in-k-group","title":"25. Reverse Nodes in k-Group","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Recursion</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom leetpattern.utils import ListNode, list_from_array, list_to_array\n\n\n# Linked List\ndef reverse_k_group(head: Optional[ListNode], k: int) -&gt; Optional[ListNode]:\n    n = 0\n    cur = head\n    while cur:\n        n += 1\n        cur = cur.next\n\n    p0 = dummy = ListNode(next=head)\n    pre = None\n    cur = head\n\n    while n &gt;= k:\n        n -= k\n        for _ in range(k):\n            nxt = cur.next\n            cur.next = pre\n            pre = cur\n            cur = nxt\n\n        nxt = p0.next\n        nxt.next = cur\n        p0.next = pre\n        p0 = nxt\n\n    return dummy.next\n\n\ndef test_reverse_k_group():\n    head = list_from_array([1, 2, 3, 4, 5])\n    assert list_to_array(reverse_k_group(head, 2)) == [2, 1, 4, 3, 5]\n</code></pre>"},{"location":"interview-150/linked_list/#19-remove-nth-node-from-end-of-list","title":"19. Remove Nth Node From End of List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Two Pointers</p> </li> </ul> Python <pre><code>\"\"\"\n-   Given the `head` of a linked list, remove the `n-th` node from the end of the list and return its head.\n\"\"\"\n\nfrom typing import Optional\n\nfrom leetpattern.utils import ListNode, list_from_array, list_to_array\n\n\n# Linked List\ndef removeNthFromEnd(head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:\n    dummy = ListNode(0, head)\n    fast, slow = dummy, dummy\n\n    for _ in range(n):\n        fast = fast.next\n\n    while fast.next:\n        fast = fast.next\n        slow = slow.next\n\n    slow.next = slow.next.next\n\n    return dummy.next\n\n\ndef test_removeNthFromEnd() -&gt; None:\n    head = list_from_array([1, 2, 3, 4, 5])\n    assert (list_to_array(removeNthFromEnd(head, 2))) == [1, 2, 3, 5]\n</code></pre>"},{"location":"interview-150/linked_list/#82-remove-duplicates-from-sorted-list-ii","title":"82. Remove Duplicates from Sorted List II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Two Pointers</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom leetpattern.utils import ListNode\n\n\n# Linked List\ndef deleteDuplicates(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    dummy = ListNode(0, head)\n    cur = dummy\n\n    while cur.next and cur.next.next:\n        val = cur.next.val\n        if cur.next.next.val == val:\n            while cur.next and cur.next.val == val:\n                cur.next = cur.next.next\n        else:\n            cur = cur.next\n\n    return dummy.next\n\n\nhead = ListNode().create([1, 1, 2, 3, 3, 4, 5])\nprint(deleteDuplicates(head))  # 2 -&gt; 4 -&gt; 5\n</code></pre>"},{"location":"interview-150/linked_list/#61-rotate-list","title":"61. Rotate List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Two Pointers</p> </li> </ul>"},{"location":"interview-150/linked_list/#86-partition-list","title":"86. Partition List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Two Pointers</p> </li> </ul>"},{"location":"interview-150/linked_list/#146-lru-cache","title":"146. LRU Cache","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Linked List, Design, Doubly Linked List</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Design and implement a data structure for **Least Recently Used (LRU) cache**. It should support the following operations: get and put.\n- [lru](https://media.geeksforgeeks.org/wp-content/uploads/20240909142802/Working-of-LRU-Cache-copy-2.webp)\n- ![146](https://miro.medium.com/v2/resize:fit:650/0*fOwBd3z0XtHh7WN1.png)\n\n| Data structure     | Description                   |\n| ------------------ | ----------------------------- |\n| Doubly Linked List | To store the key-value pairs. |\n| Hash Map           | To store the key-node pairs.  |\n\"\"\"\n\nfrom collections import OrderedDict\n\n\n# Doubly Linked List\nclass Node:\n    def __init__(self, key=0, val=0):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.cache = {}\n        self.head = Node()\n        self.tail = Node()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def add_to_last(self, node):\n        self.tail.prev.next = node\n        node.prev = self.tail.prev\n        node.next = self.tail\n        self.tail.prev = node\n\n    def move_to_last(self, node):\n        self.remove(node)\n        self.add_to_last(node)\n\n    def get(self, key: int) -&gt; int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self.move_to_last(node)\n        return node.val\n\n    def put(self, key: int, value: int) -&gt; None:\n        if key in self.cache:\n            node = self.cache[key]\n            node.val = value\n            self.move_to_last(node)\n            return None\n\n        if len(self.cache) == self.cap:\n            del self.cache[self.head.next.key]\n            self.remove(self.head.next)\n\n        node = Node(key=key, val=value)\n        self.cache[key] = node\n        self.add_to_last(node)\n\n\n# OrderedDict\nclass LRUCacheOrderedDict:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.cap = capacity\n\n    def get(self, key: int):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key, last=True)\n        return self.cache[key]\n\n    def put(self, key: int, value: int):\n        if key in self.cache:\n            self.cache.move_to_end(key, last=True)\n        elif len(self.cache) &gt;= self.cap:\n            self.cache.popitem(last=False)\n\n        self.cache[key] = value\n\n\ncache = LRUCache(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\n\ncache = LRUCacheOrderedDict(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\nprint(\"LRU Cache passed\")\nprint(\"LRU Cache Ordered Dict passed\")\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nclass Node {\n   public:\n    int key;\n    int val;\n    Node *prev;\n    Node *next;\n\n    Node(int k = 0, int v = 0) : key(k), val(v), prev(nullptr), next(nullptr) {}\n};\n\nclass LRUCache {\n   private:\n    int cap;\n    unordered_map&lt;int, Node *&gt; cache;\n    Node *head;\n    Node *tail;\n\n    void remove(Node *node) {\n        node-&gt;prev-&gt;next = node-&gt;next;\n        node-&gt;next-&gt;prev = node-&gt;prev;\n    }\n\n    void insert_to_last(Node *node) {\n        tail-&gt;prev-&gt;next = node;\n        node-&gt;prev = tail-&gt;prev;\n        tail-&gt;prev = node;\n        node-&gt;next = tail;\n    }\n\n    void move_to_last(Node *node) {\n        remove(node);\n        insert_to_last(node);\n    }\n\n   public:\n    LRUCache(int capacity) {\n        this-&gt;cap = capacity;\n        head = new Node();\n        tail = new Node();\n        head-&gt;next = tail;\n        tail-&gt;prev = head;\n    }\n\n    int get(int key) {\n        if (cache.find(key) != cache.end()) {\n            Node *node = cache[key];\n            move_to_last(node);\n            return node-&gt;val;\n        }\n        return -1;\n    }\n\n    void put(int key, int value) {\n        if (cache.find(key) != cache.end()) {\n            Node *node = cache[key];\n            node-&gt;val = value;\n            move_to_last(node);\n        } else {\n            Node *newNode = new Node(key, value);\n            cache[key] = newNode;\n            insert_to_last(newNode);\n\n            if ((int)cache.size() &gt; cap) {\n                Node *removed = head-&gt;next;\n                remove(removed);\n                cache.erase(removed-&gt;key);\n                delete removed;\n            }\n        }\n    }\n};\n\nint main() {\n    LRUCache lru(2);\n    lru.put(1, 1);\n    lru.put(2, 2);\n    assert(lru.get(1) == 1);   // returns 1\n    lru.put(3, 3);             // evicts key 2\n    assert(lru.get(2) == -1);  // returns -1 (not found)\n    lru.put(4, 4);             // evicts key 1\n    assert(lru.get(1) == -1);  // returns -1 (not found)\n    assert(lru.get(3) == 3);   // returns 3\n    assert(lru.get(4) == 4);   // returns 4\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/math/","title":"Math","text":""},{"location":"interview-150/math/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 9. Palindrome Number (Easy)</li> <li> 66. Plus One (Easy)</li> <li> 172. Factorial Trailing Zeroes (Medium)</li> <li> 69. Sqrt(x) (Easy)</li> <li> 50. Pow(x, n) (Medium)</li> <li> 149. Max Points on a Line (Hard)</li> </ul>"},{"location":"interview-150/math/#9-palindrome-number","title":"9. Palindrome Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return true if the given number is a palindrome. Otherwise, return false.\n\"\"\"\n\n\n# Reverse\ndef isPalindromeReverse(x: int) -&gt; bool:\n    if x &lt; 0:\n        return False\n\n    return str(x) == str(x)[::-1]\n\n\n# Left Right Pointers\ndef isPalindromeLR(x: int) -&gt; bool:\n    if x &lt; 0:\n        return False\n\n    x = list(str(x))  # 121 -&gt; ['1', '2', '1']\n\n    left, right = 0, len(x) - 1\n\n    while left &lt; right:\n        if x[left] != x[right]:\n            return False\n        left += 1\n        right -= 1\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |  Reverse   |  O(N)  |   O(N)  |\n# | Left Right |  O(N)  |   O(1)  |\n# |------------|--------|---------|\n\n\nx = 121\nprint(isPalindromeReverse(x))  # True\nprint(isPalindromeLR(x))  # True\n</code></pre>"},{"location":"interview-150/math/#66-plus-one","title":"66. Plus One","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\n# Math\ndef plusOne(digits: List[int]) -&gt; List[int]:\n    n = len(digits)\n\n    for i in range(n - 1, -1, -1):\n        if digits[i] &lt; 9:\n            digits[i] += 1\n            return digits\n        else:\n            digits[i] = 0\n\n    return [1] + digits\n\n\ndigits = [4, 3, 2, 1]\nprint(plusOne(digits))  # [4, 3, 2, 2]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) {\n        for (int i = digits.size() - 1; i &gt;= 0; i--) {\n            digits[i]++;\n            if (digits[i] == 10)\n                digits[i] = 0;\n            else\n                return digits;\n        }\n        digits.insert(digits.begin(), 1);\n        return digits;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; digits;\n    digits = {4, 3, 2, 1};\n    assert((solution.plusOne(digits) == vector&lt;int&gt;{4, 3, 2, 2}));\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/math/#172-factorial-trailing-zeroes","title":"172. Factorial Trailing Zeroes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math</p> </li> </ul>"},{"location":"interview-150/math/#69-sqrtx","title":"69. Sqrt(x)","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Binary Search</p> </li> </ul> PythonCPP <pre><code># Left Right Pointers\ndef mySqrt(x: int) -&gt; int:\n    \"\"\"Returns the square root of a number.\"\"\"\n    if x &lt; 2:\n        return x\n\n    left, right = 0, x // 2\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        if mid * mid &lt;= x &lt; (mid + 1) * (mid + 1):\n            return mid\n        elif mid * mid &lt; x:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n\nx = 8\nprint(mySqrt(x))  # 2\n</code></pre> <pre><code>#include &lt;cassert&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int mySqrt(int x) {\n        if (x &lt; 2) return x;\n        int left = 0, right = x / 2;\n        int mid = 0;\n\n        while (left &lt;= right) {\n            mid = left + (right - left) / 2;\n            long long a = 1LL * mid * mid;\n            long long b = 1LL * (mid + 1) * (mid + 1);\n\n            if (a &lt;= x &amp;&amp; x &lt; b) {\n                return mid;\n            } else if (a &lt; x)\n                left = mid + 1;\n            else\n                right = mid - 1;\n        }\n        return right;\n    }\n};\n\nint main() {\n    Solution solution;\n    assert(solution.mySqrt(4) == 2);\n    assert(solution.mySqrt(8) == 2);\n    assert(solution.mySqrt(1999) == 44);\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/math/#50-powx-n","title":"50. Pow(x, n)","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Recursion</p> </li> </ul> Python <pre><code># Iterative\ndef myPowIterative(x: float, n: int) -&gt; float:\n    if n == 0:\n        return 1\n    if n &lt; 0:\n        x = 1 / x\n        n = -n\n\n    result = 1\n    cur = x\n\n    while n &gt; 0:\n        if n % 2 == 1:\n            result *= cur\n\n        cur *= cur\n        n //= 2\n\n    return result\n\n\n# Recursive\ndef myPowRecursive(x: float, n: int) -&gt; float:\n    if n == 0:\n        return 1\n    if n &lt; 0:\n        x = 1 / x\n        n = -n\n\n    if n % 2 == 0:\n        return myPowRecursive(x * x, n // 2)\n    else:\n        return x * myPowRecursive(x * x, n // 2)\n\n\nx = 2.00000\nn = 10\nprint(myPowIterative(x, n))  # 1024.0\nprint(myPowRecursive(x, n))  # 1024.0\n</code></pre>"},{"location":"interview-150/math/#149-max-points-on-a-line","title":"149. Max Points on a Line","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Geometry</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\nclass Solution:\n    def maxPoints(self, points: List[List[int]]) -&gt; int:\n        # edge case\n        n = len(points)\n        if n &lt;= 2:\n            return n\n\n        res = 0\n\n        for i in range(n - 1):\n            x1, y1 = points[i]\n            cnt = defaultdict(int)\n\n            for j in range(i + 1, n):\n                x2, y2 = points[j]\n                g = \"inf\" if x1 == x2 else (y2 - y1) / (x2 - x1)\n                cnt[g] += 1\n\n            res = max(res, 1 + max(cnt.values()))\n\n        return res\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    points = [[1, 1], [3, 2], [5, 3], [4, 1], [2, 3], [1, 4]]\n    assert sol.maxPoints(points) == 4\n</code></pre>"},{"location":"interview-150/matrix/","title":"Matrix","text":""},{"location":"interview-150/matrix/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 36. Valid Sudoku (Medium)</li> <li> 54. Spiral Matrix (Medium)</li> <li> 48. Rotate Image (Medium)</li> <li> 73. Set Matrix Zeroes (Medium)</li> <li> 289. Game of Life (Medium)</li> </ul>"},{"location":"interview-150/matrix/#36-valid-sudoku","title":"36. Valid Sudoku","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Matrix</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Set\ndef isValidSudoku(board: List[List[str]]) -&gt; bool:\n    rows = [set() for _ in range(9)]\n    cols = [set() for _ in range(9)]\n    boxes = [set() for _ in range(9)]\n\n    for i in range(9):\n        for j in range(9):\n            if board[i][j] == \".\":\n                continue\n\n            if board[i][j] in rows[i]:\n                return False\n            rows[i].add(board[i][j])\n\n            if board[i][j] in cols[j]:\n                return False\n            cols[j].add(board[i][j])\n\n            box_index = (i // 3) * 3 + j // 3\n            if board[i][j] in boxes[box_index]:\n                return False\n            boxes[box_index].add(board[i][j])\n\n    return True\n\n\nboard = [\n    [\"5\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],\n    [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n    [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n    [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n    [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n    [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n    [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"],\n    [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n    [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"],\n]\nprint(isValidSudoku(board))  # True\n</code></pre>"},{"location":"interview-150/matrix/#54-spiral-matrix","title":"54. Spiral Matrix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Matrix, Simulation</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return all elements of the matrix in spiral order.\n\"\"\"\n\nfrom typing import List\n\n\n# Array\ndef spiralOrder(matrix: List[List[int]]) -&gt; List[int]:\n    if not matrix or not matrix[0]:\n        return []\n\n    res = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n\n    while top &lt;= bottom and left &lt;= right:\n\n        for i in range(left, right + 1):\n            res.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            res.append(matrix[i][right])\n        right -= 1\n\n        if top &lt;= bottom:\n\n            for i in range(right, left - 1, -1):\n                res.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left &lt;= right:\n\n            for i in range(bottom, top - 1, -1):\n                res.append(matrix[i][left])\n            left += 1\n\n    return res\n\n\n# Math\ndef spiralOrderMath(matrix: List[List[int]]) -&gt; List[int]:\n    dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]]  # Right Down Left Up\n    m, n = len(matrix), len(matrix[0])\n    size = m * n\n    res = []\n    i, j, di = 0, -1, 0\n\n    while len(res) &lt; size:\n        dx, dy = dirs[di]\n        for _ in range(n):\n            i += dx\n            j += dy\n            res.append(matrix[i][j])\n        di = (di + 1) % 4\n        n, m = m - 1, n\n\n    return res\n\n\nprint(spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n# [1, 2, 3, 6, 9, 8, 7, 4, 5]\nprint(spiralOrderMath([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]))\n# [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]\n</code></pre>"},{"location":"interview-150/matrix/#48-rotate-image","title":"48. Rotate Image","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Matrix</p> </li> </ul> Python <pre><code>from copy import deepcopy\nfrom typing import List\n\n\n# Math\ndef rotate1(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    n = len(matrix)\n\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n\n\ndef rotate2(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    n = len(matrix)\n    for i in range(n):\n        for j in range(i, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\n    for i in range(n):\n        matrix[i].reverse()\n\n\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nprint(matrix)\n# [[1, 2, 3],\n#  [4, 5, 6],\n#  [7, 8, 9]]\nmatrix1 = deepcopy(matrix)\nrotate1(matrix1)\nprint(matrix1)\n# [[7, 4, 1],\n#  [8, 5, 2],\n#  [9, 6, 3]]\nmatrix2 = deepcopy(matrix)\nrotate2(matrix2)\nprint(matrix2)\n# [[7, 4, 1],\n#  [8, 5, 2],\n#  [9, 6, 3]]\n</code></pre>"},{"location":"interview-150/matrix/#73-set-matrix-zeroes","title":"73. Set Matrix Zeroes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Matrix</p> </li> </ul> Python <pre><code>from copy import deepcopy\nfrom typing import List\n\n\nclass setZeroes:\n    @staticmethod\n    def matrix(matrix: List[List[int]]) -&gt; None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        # prep\n        m, n = len(matrix), len(matrix[0])\n        rows, cols = set(), set()\n\n        # collect rows and cols\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    rows.add(i)\n                    cols.add(j)\n\n        # work on rows and cols\n        for i in rows:\n            for j in range(n):\n                matrix[i][j] = 0\n\n        for i in range(m):\n            for j in cols:\n                matrix[i][j] = 0\n\n\nif __name__ == \"__main__\":\n    matrix = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]\n    setZeroes.matrix(matrix)\n    assert matrix == [[1, 0, 1], [0, 0, 0], [1, 0, 1]]\n</code></pre>"},{"location":"interview-150/matrix/#289-game-of-life","title":"289. Game of Life","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Matrix, Simulation</p> </li> </ul> Python <pre><code>from typing import List\n\n\nclass gameOfLife:\n    @staticmethod\n    def matrix(board: List[List[int]]) -&gt; None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        0: dead\n        1: alive\n        2: 10: dead -&gt; alive\n        3: 11: alive -&gt; alive\n        \"\"\"\n        dirs = [[0, 1], [0, -1], [1, 1], [1, -1], [-1, 1], [-1, -1], [1, 0], [-1, 0]]\n        m, n = len(board), len(board[0])\n\n        def count_live(r, c):\n            res = 0\n            for dr, dc in dirs:\n                nr, nc = dr + r, dc + c\n                if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and board[nr][nc] &amp; 1:\n                    res += 1\n            return res\n\n        for i in range(m):\n            for j in range(n):\n                cnt = count_live(i, j)\n                if board[i][j] == 1:  # currently alive\n                    if 2 &lt;= cnt &lt;= 3:\n                        board[i][j] = 3  # 11: was alive, stays alive\n                else:  # currently dead\n                    if cnt == 3:\n                        board[i][j] = 2  # 10: was dead, becomes alive\n\n        for i in range(m):\n            for j in range(n):\n                board[i][j] &gt;&gt;= 1\n\n\nif __name__ == \"__main__\":\n    board = [[0, 1, 0], [0, 0, 1], [1, 1, 1], [0, 0, 0]]\n    gameOfLife(board)\n    assert board == [[0, 0, 0], [1, 0, 1], [0, 1, 1], [0, 1, 0]]\n</code></pre>"},{"location":"interview-150/multidimensional_dp/","title":"Multidimensional DP","text":""},{"location":"interview-150/multidimensional_dp/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 120. Triangle (Medium)</li> <li> 64. Minimum Path Sum (Medium)</li> <li> 63. Unique Paths II (Medium)</li> <li> 5. Longest Palindromic Substring (Medium)</li> <li> 97. Interleaving String (Medium)</li> <li> 72. Edit Distance (Medium)</li> <li> 123. Best Time to Buy and Sell Stock III (Hard)</li> <li> 188. Best Time to Buy and Sell Stock IV (Hard)</li> <li> 221. Maximal Square (Medium)</li> </ul>"},{"location":"interview-150/multidimensional_dp/#120-triangle","title":"120. Triangle","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>from functools import cache\nfrom typing import List\n\n\nclass Solution:\n    # Recursive\n    def minimumTotalRecursive(self, triangle: List[List[int]]) -&gt; int:\n        n = len(triangle)\n\n        @cache\n        def dfs(i, j):\n            if i == n - 1:\n                return triangle[i][j]\n            return min(dfs(i + 1, j), dfs(i + 1, j + 1)) + triangle[i][j]\n\n        return dfs(0, 0)\n\n    # Iterative\n    def minimumTotalIterative(self, triangle: List[List[int]]) -&gt; int:\n        for i in range(len(triangle) - 2, -1, -1):\n            for j in range(i + 1):\n                triangle[i][j] += min(triangle[i + 1][j], triangle[i + 1][j + 1])\n        return triangle[0][0]\n\n\nif __name__ == \"__main__\":\n    solution = Solution()\n    triangle = [[2], [3, 4], [6, 5, 7], [4, 1, 8, 3]]\n    assert solution.minimumTotalRecursive(triangle) == 11\n    assert solution.minimumTotalIterative(triangle) == 11\n</code></pre>"},{"location":"interview-150/multidimensional_dp/#64-minimum-path-sum","title":"64. Minimum Path Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Matrix</p> </li> </ul> Python <pre><code>from functools import cache\nfrom typing import List\n\n\n# Iterative\ndef minPathSum(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n\n    # init\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = grid[i][0] + dp[i - 1][0]\n    for j in range(1, n):\n        dp[0][j] = grid[0][j] + dp[0][j - 1]\n\n    # update\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[-1][-1]\n\n\n# Recursive\ndef minPathSumDFS(grid: List[List[int]]) -&gt; int:\n    INF = 10**18\n\n    @cache\n    def dfs(i, j):\n        if i &lt; 0 or j &lt; 0:\n            return INF\n        if i == 0 and j == 0:\n            return grid[i][j]\n        return min(dfs(i, j - 1), dfs(i - 1, j)) + grid[i][j]\n\n    return dfs(len(grid) - 1, len(grid[0]) - 1)\n\n\ngrid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\nprint(minPathSum(grid))  # 7\nprint(minPathSumDFS(grid))  # 7\n</code></pre>"},{"location":"interview-150/multidimensional_dp/#63-unique-paths-ii","title":"63. Unique Paths II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Matrix</p> </li> </ul> Python <pre><code>from functools import cache\nfrom typing import List\n\n\nclass UniquePathsWithObstacles:\n    def memoization(self, obstacleGrid: List[List[int]]) -&gt; int:\n        \"\"\"\n        Approach: DFS with Memoization\n        Time complexity: O(mn).\n        Space complexity: O(mn).\n        \"\"\"\n\n        @cache\n        def dfs(i: int, j: int) -&gt; int:\n            if i &lt; 0 or j &lt; 0 or obstacleGrid[i][j]:\n                return 0\n            if i == 0 and j == 0:\n                return 1\n            return dfs(i - 1, j) + dfs(i, j - 1)\n\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\n        return dfs(m - 1, n - 1)\n\n    def dp_2d(self, obstacleGrid: List[List[int]]) -&gt; int:\n        \"\"\"\n        Approach: 2D Dynamic Programming\n        Time complexity: O(mn).\n        Space complexity: O(mn).\n        \"\"\"\n        # edge cases\n        if obstacleGrid[0][0] == 1 or obstacleGrid[-1][-1] == 1:\n            return 0\n\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\n\n        # init dp\n        dp = [[0] * n for _ in range(m)]\n\n        for i in range(m):\n            if obstacleGrid[i][0] == 0:\n                dp[i][0] = 1\n            else:\n                break\n\n        for j in range(n):\n            if obstacleGrid[0][j] == 0:\n                dp[0][j] = 1\n            else:\n                break\n\n        # update dp\n        for i in range(1, m):\n            for j in range(1, n):\n                if obstacleGrid[i][j] == 1:\n                    continue\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n        return dp[-1][-1]\n\n    def dp_1d(self, obstacleGrid: List[List[int]]) -&gt; int:\n        \"\"\"\n        Approach: 1D Dynamic Programming\n        Time complexity: O(mn).\n        Space complexity: O(n).\n        \"\"\"\n        n = len(obstacleGrid[0])\n        dp = [0] * (n + 1)\n        dp[1] = 1\n\n        for row in obstacleGrid:\n            for j, x in enumerate(row):\n                if x == 0:\n                    dp[j + 1] += dp[j]\n                else:\n                    dp[j + 1] = 0\n        return dp[n]\n\n\nif __name__ == \"__main__\":\n    solution = UniquePathsWithObstacles()\n    obstacleGrid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n    assert solution.dp_2d(obstacleGrid) == 2\n    assert solution.memoization(obstacleGrid) == 2\n    assert solution.dp_1d(obstacleGrid) == 2\n</code></pre>"},{"location":"interview-150/multidimensional_dp/#5-longest-palindromic-substring","title":"5. Longest Palindromic Substring","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Dynamic Programming</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the longest palindromic substring in `s`.\n\"\"\"\n\n\n# DP - Interval\ndef longestPalindromeDP(s: str) -&gt; str:\n    n = len(s)\n    if n &lt;= 1:\n        return s\n\n    start, maxLen = 0, 1\n\n    # Init\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for j in range(1, n):\n        for i in range(j):\n            if s[i] == s[j]:\n                if j - i &lt;= 2:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1]\n\n                if dp[i][j] and j - i + 1 &gt; maxLen:\n                    maxLen = j - i + 1\n                    start = i\n\n    return s[start : start + maxLen]\n\n\n# Expand Around Center\ndef longestPalindromeCenter(s: str) -&gt; str:\n    def expand_around_center(left, right):\n        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n\n    if len(s) &lt;= 1:\n        return s\n\n    start, end = 0, 0\n    for i in range(len(s)):\n        len1 = expand_around_center(i, i)  # odd\n        len2 = expand_around_center(i, i + 1)  # even\n\n        maxLen = max(len1, len2)\n        if maxLen &gt; end - start:\n            start = i - (maxLen - 1) // 2\n            end = i + maxLen // 2\n\n    return s[start : end + 1]\n\n\ns = \"babad\"\nprint(longestPalindromeDP(s))  # \"bab\"\nprint(longestPalindromeCenter(s))  # \"aba\"\n</code></pre>"},{"location":"interview-150/multidimensional_dp/#97-interleaving-string","title":"97. Interleaving String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul> Python <pre><code># DP - 2D\ndef isInterleaveDP(s1: str, s2: str, s3: str) -&gt; bool:\n    m, n, k = len(s1), len(s2), len(s3)\n\n    if m + n != k:\n        return False\n\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    for i in range(1, m + 1):\n        dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n\n    for j in range(1, n + 1):\n        dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (\n                dp[i][j - 1] and s2[j - 1] == s3[i + j - 1]\n            )\n\n    return dp[m][n]\n\n\n# DFS\ndef isInterleaveDFS(s1: str, s2: str, s3: str) -&gt; bool:\n    memo = {}\n\n    def dfs(i, j, k):\n        if i == len(s1) and j == len(s2) and k == len(s3):\n            return True\n\n        if (i, j) in memo:\n            return memo[(i, j)]\n\n        res = False\n\n        if i &lt; len(s1) and k &lt; len(s3) and s1[i] == s3[k]:\n            res |= dfs(i + 1, j, k + 1)\n\n        if j &lt; len(s2) and k &lt; len(s3) and s2[j] == s3[k]:\n            res |= dfs(i, j + 1, k + 1)\n\n        memo[(i, j)] = res\n\n        return res\n\n    return dfs(0, 0, 0)\n\n\ns1 = \"aabcc\"\ns2 = \"dbbca\"\ns3 = \"aadbbbaccc\"\nprint(isInterleaveDP(s1, s2, s3))  # False\nprint(isInterleaveDFS(s1, s2, s3))  # False\n</code></pre>"},{"location":"interview-150/multidimensional_dp/#72-edit-distance","title":"72. Edit Distance","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul> Python <pre><code>from functools import cache\n\n\n# Recursive\ndef minDistanceDFS(word1: str, word2: str) -&gt; int:\n    n, m = len(word1), len(word2)\n\n    @cache\n    def dfs(i: int, j: int) -&gt; int:\n        if i &lt; 0:\n            return j + 1\n        if j &lt; 0:\n            return i + 1\n        if word1[i] == word2[j]:\n            return dfs(i - 1, j - 1)\n\n        return 1 + min(dfs(i - 1, j), dfs(i, j - 1), dfs(i - 1, j - 1))\n\n    return dfs(n - 1, m - 1)\n\n\n# Iterative\ndef minDistanceDP(word1: str, word2: str) -&gt; int:\n    m, n = len(word1), len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]  # no operation\n            else:\n                dp[i][j] = 1 + min(\n                    dp[i - 1][j],  # delete\n                    dp[i][j - 1],  # insert\n                    dp[i - 1][j - 1],  # replace\n                )\n    return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    word1 = \"horse\"\n    word2 = \"ros\"\n    print(minDistanceDFS(word1, word2))  # 3\n    print(minDistanceDP(word1, word2))  # 3\n</code></pre>"},{"location":"interview-150/multidimensional_dp/#123-best-time-to-buy-and-sell-stock-iii","title":"123. Best Time to Buy and Sell Stock III","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# 1. DP\ndef maxProfitDP1(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 5 for _ in range(n)]\n\n    dp[0][0] = 0  # no transaction\n    dp[0][1] = -prices[0]  # buy 1\n    dp[0][2] = 0  # sell 1\n    dp[0][3] = -prices[0]  # buy 2\n    dp[0][4] = 0  # sell 2\n\n    for i in range(1, n):\n        dp[i][0] = dp[i - 1][0]\n        dp[i][1] = max(dp[i - 1][1], -prices[i])\n        dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i])\n        dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i])\n        dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i])\n\n    return dp[-1][4]\n\n\n# 2. DP - Optimized\ndef maxProfitDP2(prices: List[int]) -&gt; int:\n    b1, b2 = float(\"inf\"), float(\"inf\")\n    s1, s2 = 0, 0\n\n    for price in prices:\n        b1 = min(b1, price)\n        s1 = max(s1, price - b1)\n        b2 = min(b2, price - s1)\n        s2 = max(s2, price - b2)\n\n    return s2\n\n\nprices = [3, 3, 5, 0, 0, 3, 1, 4]\nprint(maxProfitDP1(prices))  # 6\nprint(maxProfitDP2(prices))  # 6\n</code></pre>"},{"location":"interview-150/multidimensional_dp/#188-best-time-to-buy-and-sell-stock-iv","title":"188. Best Time to Buy and Sell Stock IV","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP\ndef maxProfit(k: int, prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * (2 * k + 1) for _ in range(n)]\n\n    for j in range(1, 2 * k, 2):\n        dp[0][j] = -prices[0]\n\n    for i in range(1, n):\n        for j in range(0, 2 * k - 1, 2):\n            dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i])\n            dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i])\n\n    return dp[-1][2 * k]\n\n\nk = 2\nprices = [2, 4, 1]\nprint(maxProfit(k, prices))  # 2\n</code></pre>"},{"location":"interview-150/multidimensional_dp/#221-maximal-square","title":"221. Maximal Square","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Matrix</p> </li> </ul>"},{"location":"interview-150/sliding_window/","title":"Sliding Window","text":""},{"location":"interview-150/sliding_window/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 209. Minimum Size Subarray Sum (Medium)</li> <li> 3. Longest Substring Without Repeating Characters (Medium)</li> <li> 30. Substring with Concatenation of All Words (Hard)</li> <li> 76. Minimum Window Substring (Hard)</li> </ul>"},{"location":"interview-150/sliding_window/#209-minimum-size-subarray-sum","title":"209. Minimum Size Subarray Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Sliding Window, Prefix Sum</p> </li> </ul> Python <pre><code>import bisect\nfrom typing import List\n\n\n# Prefix Sum\ndef minSubArrayLenPS(target: int, nums: List[int]) -&gt; int:\n    n = len(nums)\n    prefix_sums = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        prefix_sums[i] = prefix_sums[i - 1] + nums[i - 1]\n\n    minLen = float(\"inf\")\n\n    for i in range(n + 1):\n        new_target = target + prefix_sums[i]\n        bound = bisect.bisect_left(prefix_sums, new_target)\n        if bound != len(prefix_sums):\n            minLen = min(minLen, bound - i)\n\n    return 0 if minLen == float(\"inf\") else minLen\n\n\n# Sliding Window Variable Size\ndef minSubArrayLenSW(target: int, nums: List[int]) -&gt; int:\n    res, cur = float(\"inf\"), 0\n    left = 0\n\n    for right in range(len(nums)):\n        cur += nums[right]\n\n        while cur &gt;= target:\n            res = min(res, right - left + 1)\n            cur -= nums[left]\n            left += 1\n\n    return res if res != float(\"inf\") else 0\n\n\ntarget = 7\nnums = [2, 3, 1, 2, 4, 3]\nprint(minSubArrayLenPS(target, nums))  # 2\nprint(minSubArrayLenSW(target, nums))  # 2\n</code></pre>"},{"location":"interview-150/sliding_window/#3-longest-substring-without-repeating-characters","title":"3. Longest Substring Without Repeating Characters","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Classic variable sliding window problem. Use a set to keep track of the characters in the current window.\n- Return the length of the longest substring without repeating characters.\n- [Template tutorial by \u7075\u5c71\u8336\u827e\u5e9c](https://leetcode.cn/problems/longest-substring-without-repeating-characters/solutions/1959540/xia-biao-zong-suan-cuo-qing-kan-zhe-by-e-iaks)\n\"\"\"\n\nfrom collections import defaultdict\n\n\n# Sliding Window Variable Max - HashMap\ndef lengthOfLongestSubstringHash(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    left = 0\n    cnt = defaultdict(int)\n    res = 0\n\n    for right in range(n):\n        cnt[s[right]] += 1\n\n        while cnt[s[right]] &gt; 1:\n            cnt[s[left]] -= 1\n            left += 1\n\n        res = max(res, right - left + 1)\n\n    return res\n\n\n# Sliding Window Variable Max - Set\ndef lengthOfLongestSubstringSet(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    left = 0\n    res = 0\n    window = set()\n\n    for right in range(n):\n        while left &lt; right and s[right] in window:\n            window.remove(s[left])\n            left += 1\n        window.add(s[right])\n        res = max(res, right - left + 1)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    s = \"abcabcbb\"\n    assert lengthOfLongestSubstringHash(s) == 3\n    assert lengthOfLongestSubstringSet(s) == 3\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;unordered_set&gt;\nusing namespace std;\n\nint lengthOfLongestSubstring(string s) {\n    int n = s.length();\n    int res = 0;\n    int left = 0;\n    unordered_set&lt;char&gt; window;\n\n    for (int right = 0; right &lt; n; right++) {\n        char ch = s[right];\n\n        while (window.find(ch) != window.end()) {\n            window.erase(s[left]);\n            left++;\n        }\n\n        window.insert(ch);\n        res = max(res, right - left + 1);\n    }\n    return (int)res;\n}\n\nint main() {\n    string s = \"abcabcbb\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 3\n    s = \"bbbbb\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 1\n    s = \"pwwkew\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 3\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/sliding_window/#30-substring-with-concatenation-of-all-words","title":"30. Substring with Concatenation of All Words","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul>"},{"location":"interview-150/sliding_window/#76-minimum-window-substring","title":"76. Minimum Window Substring","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> Python <pre><code>from collections import Counter\n\n\ndef minWindow(s: str, t: str) -&gt; str:\n    if not t or not s:\n        return \"\"\n\n    counts = Counter(t)\n    required = len(counts)\n\n    left, right = 0, 0\n    formed = 0\n    window_counts = dict()\n\n    result = float(\"inf\"), None, None\n\n    while right &lt; len(s):\n        char = s[right]\n        window_counts[char] = window_counts.get(char, 0) + 1\n        if char in counts and window_counts[char] == counts[char]:\n            formed += 1\n\n        while left &lt;= right and formed == required:\n            char = s[left]\n            if right - left + 1 &lt; result[0]:\n                result = (right - left + 1, left, right)\n            window_counts[char] -= 1\n            if char in counts and window_counts[char] &lt; counts[char]:\n                formed -= 1\n            left += 1\n\n        right += 1\n\n    return \"\" if result[0] == float(\"inf\") else s[result[1] : result[2] + 1]\n\n\ns = \"ADOBECODEBANC\"\nt = \"ABC\"\nprint(minWindow(s, t))  # BANC\n</code></pre>"},{"location":"interview-150/stack/","title":"Stack","text":""},{"location":"interview-150/stack/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 20. Valid Parentheses (Easy)</li> <li> 71. Simplify Path (Medium)</li> <li> 155. Min Stack (Medium)</li> <li> 150. Evaluate Reverse Polish Notation (Medium)</li> <li> 224. Basic Calculator (Hard)</li> </ul>"},{"location":"interview-150/stack/#20-valid-parentheses","title":"20. Valid Parentheses","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack</p> </li> </ul> PythonCPP <pre><code># Stack\ndef is_valid(s: str) -&gt; bool:\n    if len(s) % 2:\n        return False\n\n    pairs = {\n        \"(\": \")\",\n        \"{\": \"}\",\n        \"[\": \"]\",\n    }\n    stack = []\n    for ch in s:\n        if ch in pairs:\n            stack.append(ch)\n        elif not stack or ch != pairs[stack.pop()]:\n            return False\n\n    return True if not stack else False\n\n\ndef test_is_valid():\n    assert is_valid(\"()[]{}\")\n    assert not is_valid(\"(]\")\n    assert not is_valid(\"([)]\")\n    assert is_valid(\"{[]}\")\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;stack&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool isValid(string s) {\n        unordered_map&lt;char, char&gt; map{{')', '('}, {'}', '{'}, {']', '['}};\n        stack&lt;char&gt; stack;\n        if (s.length() % 2 == 1) return false;\n\n        for (char&amp; ch : s) {\n            if (stack.empty() || map.find(ch) == map.end()) {\n                stack.push(ch);\n            } else {\n                if (map[ch] != stack.top()) {\n                    return false;\n                }\n                stack.pop();\n            }\n        }\n        return stack.empty();\n    }\n};\n\nint main() {\n    Solution s;\n    assert(s.isValid(\"()\") == true);\n    assert(s.isValid(\"()[]{}\") == true);\n    assert(s.isValid(\"(]\") == false);\n    assert(s.isValid(\"([)]\") == false);\n    assert(s.isValid(\"{[]}\") == true);\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/stack/#71-simplify-path","title":"71. Simplify Path","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack</p> </li> </ul> Python <pre><code>def simplify_path_stack(path: str) -&gt; str:\n    if not path:\n        return \"/\"\n\n    stack = []\n\n    for p in path.split(\"/\"):\n        if p == \"\" or p == \".\":\n            continue\n        if p != \"..\":\n            stack.append(p)\n        elif stack:\n            stack.pop()\n    return \"/\" + \"/\".join(stack)\n\n\ndef test_simplify_path_stack():\n    assert simplify_path_stack(\"/home/\") == \"/home\"\n    assert simplify_path_stack(\"/../\") == \"/\"\n    assert simplify_path_stack(\"/home//foo/\") == \"/home/foo\"\n    assert simplify_path_stack(\"/a/./b/../../c/\") == \"/c\"\n</code></pre>"},{"location":"interview-150/stack/#155-min-stack","title":"155. Min Stack","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Stack, Design</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Implement a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\"\"\"\n\n\n# Stack\nclass MinStack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, val: int) -&gt; None:\n        if self.stack:\n            self.stack.append((val, min(val, self.getMin())))\n        else:\n            self.stack.append((val, val))\n\n    def pop(self) -&gt; None:\n        self.stack.pop()\n\n    def top(self) -&gt; int:\n        return self.stack[-1][0]\n\n    def getMin(self) -&gt; int:\n        return self.stack[-1][1]\n\n\nobj = MinStack()\nobj.push(3)\nobj.push(2)\nobj.pop()\nprint(obj.top())  # 3\nprint(obj.getMin())  # 3\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;climits&gt;\n#include &lt;iostream&gt;\n#include &lt;stack&gt;\n#include &lt;utility&gt;\nusing namespace std;\n\nclass MinStack {\n    stack&lt;pair&lt;int, int&gt;&gt; st;\n\n   public:\n    MinStack() { st.emplace(0, INT_MAX); }\n\n    void push(int val) { st.emplace(val, min(getMin(), val)); }\n\n    void pop() { st.pop(); }\n\n    int top() { return st.top().first; }\n\n    int getMin() { return st.top().second; }\n};\n\nint main() {\n    MinStack minStack;\n    minStack.push(-2);\n    minStack.push(0);\n    minStack.push(-3);\n    cout &lt;&lt; minStack.getMin() &lt;&lt; endl;  // -3\n    minStack.pop();\n    cout &lt;&lt; minStack.top() &lt;&lt; endl;     // 0\n    cout &lt;&lt; minStack.getMin() &lt;&lt; endl;  // -2\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/stack/#150-evaluate-reverse-polish-notation","title":"150. Evaluate Reverse Polish Notation","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Stack</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Stack\ndef evalRPN(tokens: List[str]) -&gt; int:\n    stack = []\n\n    for c in tokens:\n        if c == \"+\":\n            stack.append(stack.pop() + stack.pop())\n        elif c == \"-\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(b - a)\n        elif c == \"*\":\n            stack.append(stack.pop() * stack.pop())\n        elif c == \"/\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(int(b / a))\n        else:\n            stack.append(int(c))\n\n    return stack[0]\n\n\ndef test_evalRPN():\n    print(evalRPN([\"2\", \"1\", \"+\", \"3\", \"*\"]))  # 9\n    print(evalRPN([\"4\", \"13\", \"5\", \"/\", \"-\"]))  # 2\n    print(evalRPN([\"18\"]))  # 18\n    print(evalRPN([\"4\", \"3\", \"-\"]))  # 1\n</code></pre>"},{"location":"interview-150/stack/#224-basic-calculator","title":"224. Basic Calculator","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String, Stack, Recursion</p> </li> </ul> Python <pre><code># Stack\ndef calculate(s: str) -&gt; int:\n    stack = []\n    result = 0\n    number = 0\n    sign = 1\n\n    for char in s:\n        if char.isdigit():\n            number = number * 10 + int(char)\n\n        elif char == \"+\":\n            result += sign * number\n            number = 0\n            sign = 1\n        elif char == \"-\":\n            result += sign * number\n            number = 0\n            sign = -1\n\n        elif char == \"(\":\n            stack.append(result)\n            stack.append(sign)\n            result = 0\n            sign = 1\n        elif char == \")\":\n            result += sign * number\n            number = 0\n            result *= stack.pop()  # pop sign\n            result += stack.pop()  # pop previous result\n\n    result += sign * number\n\n    return result\n\n\nprint(calculate(\"(1+(4+5+2)-3)+(6+8)\"))  # 23\n</code></pre>"},{"location":"interview-150/trie/","title":"Trie","text":""},{"location":"interview-150/trie/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 208. Implement Trie (Prefix Tree) (Medium)</li> <li> 211. Design Add and Search Words Data Structure (Medium)</li> <li> 212. Word Search II (Hard)</li> </ul>"},{"location":"interview-150/trie/#208-implement-trie-prefix-tree","title":"208. Implement Trie (Prefix Tree)","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Design, Trie</p> </li> </ul> Python <pre><code>\"\"\"\n### Trie\n\n- A trie is a tree-like data structure whose nodes store the letters of an alphabet.\n\"\"\"\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.endOfWord = None\n\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.endOfWord = True\n\n    def search(self, word: str) -&gt; bool:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return node.endOfWord\n\n    def startsWith(self, prefix: str) -&gt; bool:\n        node = self.root\n\n        for c in prefix:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return True\n\n\n# Your Trie object will be instantiated and called as such:\nobj = Trie()\nobj.insert(\"apple\")\nprint(obj.search(\"word\"))  # False\nprint(obj.startsWith(\"app\"))  # True\n</code></pre>"},{"location":"interview-150/trie/#211-design-add-and-search-words-data-structure","title":"211. Design Add and Search Words Data Structure","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Depth First Search, Design, Trie</p> </li> </ul> Python <pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.word = False\n\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.word = True\n\n    def search(self, word: str) -&gt; bool:\n\n        def dfs(j, root):\n            node = root\n\n            for i in range(j, len(word)):\n                c = word[i]\n\n                if c == \".\":\n                    for child in node.children.values():\n                        if dfs(i + 1, child):\n                            return True\n                    return False\n                else:\n                    if c not in node.children:\n                        return False\n                    node = node.children[c]\n            return node.word\n\n        return dfs(0, self.root)\n\n\n# Your WordDictionary object will be instantiated and called as such:\nobj = WordDictionary()\nobj.addWord(\"word\")\nprint(obj.search(\"word\"))\nprint(obj.search(\"w.rd\"))\n</code></pre>"},{"location":"interview-150/trie/#212-word-search-ii","title":"212. Word Search II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Backtracking, Trie, Matrix</p> </li> </ul> Python <pre><code>from typing import List\n\nfrom leetpattern.utils import Trie\n\n\n# Backtracking + Trie\ndef findWords(board: List[List[str]], words: List[str]) -&gt; List[str]:\n    trie = Trie()\n    for word in words:\n        trie.add_word(word)\n\n    m, n = len(board), len(board[0])\n    result, visit = set(), set()\n\n    def dfs(r, c, node, word):\n        if (\n            r &lt; 0\n            or r &gt;= m\n            or c &lt; 0\n            or c &gt;= n\n            or (r, c) in visit\n            or board[r][c] not in node.children\n        ):\n            return None\n\n        visit.add((r, c))\n\n        node = node.children[board[r][c]]\n        word += board[r][c]\n        if node.is_word:\n            result.add(word)\n\n        dfs(r - 1, c, node, word)\n        dfs(r + 1, c, node, word)\n        dfs(r, c - 1, node, word)\n        dfs(r, c + 1, node, word)\n\n        visit.remove((r, c))\n\n    for r in range(m):\n        for c in range(n):\n            dfs(r, c, trie.root, \"\")\n\n    return list(result)\n\n\ndef test_find_words():\n    board = [\n        [\"o\", \"a\", \"a\", \"n\"],\n        [\"e\", \"t\", \"a\", \"e\"],\n        [\"i\", \"h\", \"k\", \"r\"],\n        [\"i\", \"f\", \"l\", \"v\"],\n    ]\n    words = [\"oath\", \"pea\", \"eat\", \"rain\"]\n    result = findWords(board, words)\n    assert sorted(result) == [\"eat\", \"oath\"]\n</code></pre>"},{"location":"interview-150/two_pointers/","title":"Two Pointers","text":""},{"location":"interview-150/two_pointers/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 125. Valid Palindrome (Easy)</li> <li> 392. Is Subsequence (Easy)</li> <li> 167. Two Sum II - Input Array Is Sorted (Medium)</li> <li> 11. Container With Most Water (Medium)</li> <li> 15. 3Sum (Medium)</li> </ul>"},{"location":"interview-150/two_pointers/#125-valid-palindrome","title":"125. Valid Palindrome","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String</p> </li> </ul> Python <pre><code># List Comprehension\ndef isPalindrome(s: str) -&gt; bool:\n    s = [char.lower() for char in s if char.isalnum()]\n    return s == s[::-1]\n\n\n# Left Right Pointers\ndef isPalindromeLR(s: str) -&gt; bool:\n    left, right = 0, len(s) - 1\n\n    while left &lt; right:\n        while left &lt; right and not s[left].isalnum():\n            left += 1\n        while left &lt; right and not s[right].isalnum():\n            right -= 1\n\n        if s[left].lower() != s[right].lower():\n            return False\n\n        left += 1\n        right -= 1\n\n    return True\n\n\ns = \"A man, a plan, a canal: Panama\"\nprint(isPalindrome(s))  # True\nprint(isPalindromeLR(s))  # True\n</code></pre>"},{"location":"interview-150/two_pointers/#392-is-subsequence","title":"392. Is Subsequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Dynamic Programming</p> </li> </ul> Python <pre><code># DP - LCS\ndef isSubsequenceLCS(s: str, t: str) -&gt; bool:\n    m = len(s)\n    n = len(t)\n\n    if m &gt; n:\n        return False\n\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    length = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = dp[i][j - 1]  # only delete t string\n\n            if length &lt; dp[i][j]:\n                length = dp[i][j]\n\n    return length == m\n\n\n# Two Pointers\ndef isSubsequenceTP(s: str, t: str) -&gt; bool:\n    i, j = 0, 0\n\n    while i &lt; len(s) and j &lt; len(t):\n        if s[i] == t[j]:\n            i += 1\n        j += 1\n\n    return i == len(s)\n\n\ns = \"abc\"\nt = \"ahbgdc\"\nprint(isSubsequenceLCS(s, t))  # True\nprint(isSubsequenceTP(s, t))  # True\n</code></pre>"},{"location":"interview-150/two_pointers/#167-two-sum-ii-input-array-is-sorted","title":"167. Two Sum II - Input Array Is Sorted","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef twoSum(numbers: List[int], target: int) -&gt; List[int]:\n    left, right = 0, len(numbers) - 1\n\n    while left &lt; right:\n        total = numbers[left] + numbers[right]\n\n        if total &gt; target:\n            right -= 1\n        elif total &lt; target:\n            left += 1\n        else:\n            return [left + 1, right + 1]\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nnumbers = [2, 7, 11, 15]\ntarget = 9\nprint(twoSum(numbers, target))  # [1, 2]\n</code></pre>"},{"location":"interview-150/two_pointers/#11-container-with-most-water","title":"11. Container With Most Water","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Greedy</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return the maximum area of water that can be trapped between the vertical lines.\n\n![11](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)\n\"\"\"\n\nfrom typing import List\n\n\n# Brute Force\ndef maxAreaBF(height: List[int]) -&gt; int:\n    max_area = 0\n\n    for i in range(len(height)):\n        for j in range(i + 1, len(height)):\n            h = min(height[i], height[j])\n            w = j - i\n            max_area = max(max_area, h * w)\n\n    return max_area\n\n\n# Left Right Pointers\ndef maxAreaLR(height: List[int]) -&gt; int:\n    left, right = 0, len(height) - 1\n    res = 0\n\n    while left &lt; right:\n        h = min(height[left], height[right])\n        w = right - left\n        res = max(res, h * w)\n\n        if height[left] &lt; height[right]:\n            left += 1\n        else:\n            right -= 1\n\n    return res\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force| O(n^2) |  O(1)   |\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nheight = [1, 8, 6, 2, 5, 4, 8, 3, 7]\nprint(maxAreaBF(height))  # 49\nprint(maxAreaLR(height))  # 49\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint maxArea(vector&lt;int&gt;&amp; height) {\n    int left = 0, right = height.size() - 1;\n    int res = 0;\n\n    while (left &lt; right) {\n        int h = min(height[left], height[right]);\n        int w = right - left;\n        res = max(res, h * w);\n\n        if (height[left] &lt; height[right])\n            left++;\n        else\n            right--;\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; height = {1, 8, 6, 2, 5, 4, 8, 3, 7};\n    cout &lt;&lt; maxArea(height) &lt;&lt; endl;  // 49\n    return 0;\n}\n</code></pre>"},{"location":"interview-150/two_pointers/#15-3sum","title":"15. 3Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Sorting</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef threeSum(nums: List[int]) -&gt; List[List[int]]:\n    nums.sort()\n    res = []\n    n = len(nums)\n\n    for i in range(n - 2):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        left, right = i + 1, n - 1\n\n        while left &lt; right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total &gt; 0:\n                right -= 1\n            elif total &lt; 0:\n                left += 1\n            else:\n                res.append([nums[i], nums[left], nums[right]])\n\n                while left &lt; right and nums[left] == nums[left + 1]:\n                    left += 1\n\n                while left &lt; right and nums[right] == nums[right - 1]:\n                    right -= 1\n\n                left += 1\n                right -= 1\n\n    return res\n\n\nnums = [-1, 0, 1, 2, -1, -4]\nassert threeSum(nums) == [[-1, -1, 2], [-1, 0, 1]]\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {\n    sort(nums.begin(), nums.end());\n    vector&lt;vector&lt;int&gt;&gt; res;\n    int n = nums.size();\n\n    for (int i = 0; i &lt; n - 2; i++) {\n        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) {\n            continue;\n        }\n\n        int left = i + 1, right = n - 1;\n\n        while (left &lt; right) {\n            int total = nums[i] + nums[left] + nums[right];\n\n            if (total &gt; 0)\n                right--;\n            else if (total &lt; 0)\n                left++;\n            else {\n                res.push_back({nums[i], nums[left], nums[right]});\n                while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++;\n                while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--;\n                left++;\n                right--;\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {-1, 0, 1, 2, -1, -4};\n    vector&lt;vector&lt;int&gt;&gt; res = threeSum(nums);\n    for (auto&amp; v : res) {\n        for (int i : v) {\n            cout &lt;&lt; i &lt;&lt; \" \";\n        }\n        cout &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"neetcode-150/1d_dynamic_programming/","title":"1D Dynamic Programming","text":""},{"location":"neetcode-150/1d_dynamic_programming/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 70. Climbing Stairs (Easy)</li> <li> 746. Min Cost Climbing Stairs (Easy)</li> <li> 198. House Robber (Medium)</li> <li> 213. House Robber II (Medium)</li> <li> 5. Longest Palindromic Substring (Medium)</li> <li> 647. Palindromic Substrings (Medium)</li> <li> 91. Decode Ways (Medium)</li> <li> 322. Coin Change (Medium)</li> <li> 152. Maximum Product Subarray (Medium)</li> <li> 139. Word Break (Medium)</li> <li> 300. Longest Increasing Subsequence (Medium)</li> <li> 416. Partition Equal Subset Sum (Medium)</li> </ul>"},{"location":"neetcode-150/1d_dynamic_programming/#70-climbing-stairs","title":"70. Climbing Stairs","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Memoization</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return the number of distinct ways to reach the top of the stairs.\n- `dp[n]` stores the number of distinct ways to reach the `n-th` stair.\n- Formula: `dp[n] = dp[n - 1] + dp[n - 2]`.\n- Initialize `dp[0] = 0`, `dp[1] = 1`, and `dp[2] = 2`.\n\"\"\"\n\nfrom functools import cache\n\n\n# DP\ndef climbStairsDP(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    dp = [i for i in range(n + 1)]\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\n# DP (Optimized)\ndef climbStairsDPOptimized(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    first, second = 1, 2\n\n    for _ in range(3, n + 1):\n        first, second = second, first + second\n\n    return second\n\n\n# Recursion\ndef climbStairsRecursion(n: int) -&gt; int:\n    @cache\n    def dfs(i: int) -&gt; int:\n        if i &lt;= 1:\n            return 1\n        return dfs(i - 1) + dfs(i - 2)\n\n    return dfs(n)\n\n\n# Greedy\ndef climbStairsGreedy(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    p1, p2 = 1, 2\n\n    for _ in range(3, n + 1):\n        p1, p2 = p2, p1 + p2\n\n    return p2\n\n\nif __name__ == \"__main__\":\n    assert climbStairsDP(10) == 89\n    assert climbStairsDPOptimized(10) == 89\n    assert climbStairsRecursion(10) == 89\n    assert climbStairsGreedy(10) == 89\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nint climbStairs(int n) {\n    if (n &lt;= 2) return n;\n    int f1 = 1, f2 = 2;\n    int res;\n\n    int i = 3;\n    while (i &lt;= n) {\n        res = f1 + f2;\n        f1 = f2;\n        f2 = res;\n        i++;\n    }\n    return res;\n}\n\nint main() {\n    assert(climbStairs(2) == 2);\n    assert(climbStairs(5) == 8);\n    assert(climbStairs(10) == 89);\n    return 0;\n}\n</code></pre>"},{"location":"neetcode-150/1d_dynamic_programming/#746-min-cost-climbing-stairs","title":"746. Min Cost Climbing Stairs","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the minimum cost to reach the top of the stairs.\n\n-   `dp[n]` stores the &lt;u&gt;minimum cost&lt;/u&gt; to reach the `n-th` stair.\n-   Formula: `dp[n] = cost[n] + min(dp[n - 1], dp[n - 2])`.\n-   Initialize `dp[0] = cost[0]` and `dp[1] = cost[1]`.\n-   Return `min(dp[-1], dp[-2])`.\n\n-   Example: `cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]`\n\n|  n  | `cost[n]` | `dp[n-2]` | `dp[n-1]` | `dp[n]` |\n| :-: | :-------: | :-------: | :-------: | :-----: |\n|  0  |     1     |     -     |     -     |    1    |\n|  1  |    100    |     -     |     1     |   100   |\n|  2  |     1     |     1     |    100    |    2    |\n|  3  |     1     |    100    |     2     |    3    |\n|  4  |     1     |     2     |     3     |    3    |\n|  5  |    100    |     3     |     3     |   103   |\n|  6  |     1     |     3     |    103    |    4    |\n|  7  |     1     |    103    |     4     |    5    |\n|  8  |    100    |     4     |     5     |   104   |\n|  9  |     1     |     5     |    104    |    6    |\n\"\"\"\n\nfrom typing import List\n\n\ndef minCostClimbingStairs(cost: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(cost))]\n\n    dp[0], dp[1] = cost[0], cost[1]\n\n    for i in range(2, len(cost)):\n        dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]\n    print(dp)\n    return min(dp[-1], dp[-2])\n\n\ncost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]\nprint(minCostClimbingStairs(cost))  # 6\n</code></pre>"},{"location":"neetcode-150/1d_dynamic_programming/#198-house-robber","title":"198. House Robber","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> PythonCPP <pre><code>from functools import cache\nfrom typing import List\n\n\nclass Rob:\n    \"\"\"\n    dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n    \"\"\"\n\n    def incursive(self, nums: List[int]) -&gt; int:\n        \"\"\"\n        time complexity: O(n)\n        space complexity: O(n)\n        \"\"\"\n        n = len(nums)\n        if n &lt;= 2:\n            return max(nums)\n\n        # init\n        dp = [0 for _ in range(n)]\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n        # update\n        for i in range(2, n):\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n        return dp[-1]\n\n    def incursive_optimized(self, nums: List[int]) -&gt; int:\n        \"\"\"\n        time complexity: O(n)\n        space complexity: O(1)\n        \"\"\"\n        f0, f1 = 0, 0\n\n        for num in nums:\n            f0, f1 = f1, max(f1, f0 + num)\n\n        return f1\n\n    def memoization(self, nums: List[int]) -&gt; int:\n        \"\"\"\n        time complexity: O(n)\n        space complexity: O(n)\n        \"\"\"\n        n = len(nums)\n\n        @cache\n        def dp(i: int) -&gt; int:\n            if i &lt; 0:\n                return 0\n            return max(dp(i - 1), dp(i - 2) + nums[i])\n\n        return dp(n - 1)\n\n\nif __name__ == \"__main__\":\n    nums = [2, 7, 9, 3, 1]\n    rob = Rob()\n    assert rob.incursive(nums) == 12\n    assert rob.incursive_optimized(nums) == 12\n    assert rob.memoization(nums) == 12\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint rob(vector&lt;int&gt; &amp;nums) {\n    int prev = 0, cur = 0, temp = 0;\n\n    for (int num : nums) {\n        temp = cur;\n        cur = max(cur, prev + num);\n        prev = temp;\n    }\n    return cur;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {2, 7, 9, 3, 1};\n    cout &lt;&lt; rob(nums) &lt;&lt; endl;  // 12\n    return 0;\n}\n</code></pre>"},{"location":"neetcode-150/1d_dynamic_programming/#213-house-robber-ii","title":"213. House Robber II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return the maximum amount of money that can be robbed from the houses arranged in a circle.\n-   Circular \u2192 Linear: `nums[0]` and `nums[-1]` cannot be robbed together.\n-   Rob from `0` to `n - 2`\n\n|  n  | `nums[n]` | `dp[n-2]` | `dp[n-1]` | `dp[n-2] + nums[n]` | `dp[n]` |\n| :-: | :-------: | :-------: | :-------: | :-----------------: | :-----: |\n|  0  |     2     |     -     |     2     |          -          |    2    |\n|  1  |     7     |     -     |     7     |          -          |    7    |\n|  2  |     9     |     2     |     7     |         11          |   11    |\n|  3  |     3     |     7     |    11     |         10          |   11    |\n\n-   Rob from `1` to `n - 1`\n\n|  n  | `nums[n]` | `dp[n-2]` | `dp[n-1]` | `dp[n-2] + nums[n]` | `dp[n]` |\n| :-: | :-------: | :-------: | :-------: | :-----------------: | :-----: |\n|  1  |     7     |     -     |     -     |          -          |    7    |\n|  2  |     9     |     -     |     7     |          -          |    9    |\n|  3  |     3     |     7     |     9     |         10          |   10    |\n|  4  |     1     |     9     |    10     |         10          |   10    |\n\"\"\"\n\nfrom typing import List\n\n\n# DP\ndef rob(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 3:\n        return max(nums)\n\n    def robLinear(nums: List[int]) -&gt; int:\n        dp = [0 for _ in range(len(nums))]\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n        return dp[-1]\n\n    # circle -&gt; linear\n    a = robLinear(nums[1:])  # 2nd house to the last house\n    b = robLinear(nums[:-1])  # 1st house to the 2nd last house\n\n    return max(a, b)\n\n\nnums = [2, 7, 9, 3, 1]\nprint(rob(nums))  # 11\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// DP\nint robDP(vector&lt;int&gt;&amp; nums) {\n    int n = nums.size();\n    if (n &lt;= 3) return *max_element(nums.begin(), nums.end());\n\n    vector&lt;int&gt; dp1(n, 0), dp2(n, 0);\n\n    dp1[0] = nums[0];\n    dp2[1] = max(nums[0], nums[1]);\n    for (int i = 2; i &lt; n - 1; i++) {\n        dp1[i] = max(dp1[i - 1], dp1[i - 2] + nums[i]);\n    }\n\n    dp2[1] = nums[1];\n    dp2[2] = max(nums[1], nums[2]);\n    for (int i = 3; i &lt; n; i++) {\n        dp1[i] = max(dp1[i - 1], dp1[i - 2] + nums[i]);\n    }\n\n    return max(dp1[n - 2], dp2[n - 1]);\n}\n\n// DP (Space Optimized)\nint robDPOptimized(vector&lt;int&gt;&amp; nums) {\n    int n = nums.size();\n    if (n &lt;= 3) return *max_element(nums.begin(), nums.end());\n\n    int f1 = nums[0];\n    int f2 = max(nums[0], nums[1]);\n    int res1;\n    for (int i = 2; i &lt; n - 1; i++) {\n        res1 = max(f2, f1 + nums[i]);\n        f1 = f2;\n        f2 = res1;\n    }\n\n    f1 = nums[1];\n    f2 = max(nums[1], nums[2]);\n    int res2;\n    for (int i = 3; i &lt; n; i++) {\n        res2 = max(f2, f1 + nums[i]);\n        f1 = f2;\n        f2 = res2;\n    }\n\n    return max(res1, res2);\n}\n\nint main() {\n    vector&lt;int&gt; nums = {2, 3, 2};\n    cout &lt;&lt; robDP(nums) &lt;&lt; endl;           // 3\n    cout &lt;&lt; robDPOptimized(nums) &lt;&lt; endl;  // 3\n\n    nums = {1, 2, 3, 1};\n    cout &lt;&lt; robDP(nums) &lt;&lt; endl;           // 4\n    cout &lt;&lt; robDPOptimized(nums) &lt;&lt; endl;  // 4\n\n    return 0;\n}\n</code></pre>"},{"location":"neetcode-150/1d_dynamic_programming/#5-longest-palindromic-substring","title":"5. Longest Palindromic Substring","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Dynamic Programming</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the longest palindromic substring in `s`.\n\"\"\"\n\n\n# DP - Interval\ndef longestPalindromeDP(s: str) -&gt; str:\n    n = len(s)\n    if n &lt;= 1:\n        return s\n\n    start, maxLen = 0, 1\n\n    # Init\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for j in range(1, n):\n        for i in range(j):\n            if s[i] == s[j]:\n                if j - i &lt;= 2:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1]\n\n                if dp[i][j] and j - i + 1 &gt; maxLen:\n                    maxLen = j - i + 1\n                    start = i\n\n    return s[start : start + maxLen]\n\n\n# Expand Around Center\ndef longestPalindromeCenter(s: str) -&gt; str:\n    def expand_around_center(left, right):\n        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n\n    if len(s) &lt;= 1:\n        return s\n\n    start, end = 0, 0\n    for i in range(len(s)):\n        len1 = expand_around_center(i, i)  # odd\n        len2 = expand_around_center(i, i + 1)  # even\n\n        maxLen = max(len1, len2)\n        if maxLen &gt; end - start:\n            start = i - (maxLen - 1) // 2\n            end = i + maxLen // 2\n\n    return s[start : end + 1]\n\n\ns = \"babad\"\nprint(longestPalindromeDP(s))  # \"bab\"\nprint(longestPalindromeCenter(s))  # \"aba\"\n</code></pre>"},{"location":"neetcode-150/1d_dynamic_programming/#647-palindromic-substrings","title":"647. Palindromic Substrings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Dynamic Programming</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the number of palindromic substrings in `s`.\n-   Bottom-up DP table\n\n|  dp   |  a  |  b  |  b  |  a  |  e  |\n| :---: | :-: | :-: | :-: | :-: | :-: |\n| **a** |  1  |  0  |  0  |  1  |  0  |\n| **b** |  0  |  1  |  1  |  0  |  0  |\n| **b** |  0  |  0  |  1  |  0  |  0  |\n| **a** |  0  |  0  |  0  |  1  |  0  |\n| **e** |  0  |  0  |  0  |  0  |  1  |\n\"\"\"\n\n\ndef countSubstrings(s: str) -&gt; int:\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    res = 0\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i, n):\n            if s[i] == s[j]:\n                if j - i &lt;= 1:\n                    dp[i][j] = 1\n                    res += 1\n                elif dp[i + 1][j - 1]:\n                    dp[i][j] = 1\n                    res += 1\n\n    return res\n\n\nprint(countSubstrings(\"abbae\"))  # 7\n</code></pre>"},{"location":"neetcode-150/1d_dynamic_programming/#91-decode-ways","title":"91. Decode Ways","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul> Python <pre><code># DP\ndef numDecodingsDP(s: str) -&gt; int:\n    if not s or s[0] == \"0\":\n        return 0\n\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for i in range(1, n + 1):\n        # Check single digit decode\n        if s[i - 1] != \"0\":\n            dp[i] += dp[i - 1]\n\n        # Check two digit decode\n        if i &gt; 1 and \"10\" &lt;= s[i - 2 : i] &lt;= \"26\":\n            dp[i] += dp[i - 2]\n\n    return dp[n]\n\n\n# DFS\ndef numDecodingsDFS(s: str) -&gt; int:\n    memo = {}\n\n    def dfs(i):\n        if i == len(s):\n            return 1\n\n        if s[i] == \"0\":\n            return 0\n\n        if i in memo:\n            return memo[i]\n\n        # Single digit decode\n        ways = dfs(i + 1)\n\n        # Two digits decode\n        if i + 1 &lt; len(s) and \"10\" &lt;= s[i : i + 2] &lt;= \"26\":\n            ways += dfs(i + 2)\n\n        memo[i] = ways\n\n        return ways\n\n    return dfs(0)\n\n\ns = \"226\"\nprint(numDecodingsDP(s))  # 3\nprint(numDecodingsDFS(s))  # 3\n</code></pre>"},{"location":"neetcode-150/1d_dynamic_programming/#322-coin-change","title":"322. Coin Change","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Breadth First Search</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef coinChange(coins: List[int], amount: int) -&gt; int:\n    dp = [float(\"inf\") for _ in range(amount + 1)]\n\n    dp[0] = 0\n\n    for i in range(1, amount + 1):\n        for c in coins:\n            if i - c &gt;= 0:\n                dp[i] = min(dp[i], 1 + dp[i - c])\n\n    return dp[amount] if dp[amount] != float(\"inf\") else -1\n\n\ncoins = [1, 2, 5]\namount = 11\nprint(coinChange(coins, amount))  # 3\n</code></pre>"},{"location":"neetcode-150/1d_dynamic_programming/#152-maximum-product-subarray","title":"152. Maximum Product Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxProduct(nums: List[int]) -&gt; int:\n    n = len(nums)\n    dp_max = [0 for _ in range(n)]\n    dp_min = [0 for _ in range(n)]\n\n    dp_max[0] = nums[0]\n    dp_min[0] = nums[0]\n    max_product = nums[0]\n\n    for i in range(1, n):\n        dp_max[i] = max(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n        dp_min[i] = min(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n\n        max_product = max(max_product, dp_max[i])\n\n    return max_product\n\n\nnums = [2, 3, -2, 4]\nprint(maxProduct(nums))  # 6\n</code></pre>"},{"location":"neetcode-150/1d_dynamic_programming/#139-word-break","title":"139. Word Break","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Dynamic Programming, Trie, Memoization</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\n# DP (Unbounded Knapsack)\ndef wordBreak(s: str, wordDict: List[str]) -&gt; bool:\n    n = len(s)\n    dp = [False for _ in range(n + 1)]\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for word in wordDict:\n            m = len(word)\n            if s[i - m : i] == word and dp[i - m]:\n                dp[i] = True\n    return dp[-1]\n\n\ns = \"leetcode\"\nwordDict = [\"leet\", \"code\"]\nprint(wordBreak(s, wordDict))  # True\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;cassert&gt;\n#include &lt;ranges&gt;\n#include &lt;string&gt;\n#include &lt;unordered_set&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) {\n        int max_len = ranges::max(wordDict, {}, &amp;string::length).length();\n        unordered_set&lt;string&gt; words(wordDict.begin(), wordDict.end());\n\n        int n = s.length();\n        vector&lt;int&gt; f(n + 1);\n        f[0] = true;\n        for (int i = 1; i &lt;= n; i++) {\n            for (int j = i - 1; j &gt;= max(i - max_len, 0); j--) {\n                if (f[j] &amp;&amp; words.count(s.substr(j, i - j))) {\n                    f[i] = true;\n                    break;\n                }\n            }\n        }\n        return f[n];\n    }\n};\n\nint main() {\n    Solution solution;\n    string s = \"leetcode\";\n    vector&lt;string&gt; wordDict = {\"leet\", \"code\"};\n    assert(solution.wordBreak(s, wordDict) == true);\n    return 0;\n}\n</code></pre>"},{"location":"neetcode-150/1d_dynamic_programming/#300-longest-increasing-subsequence","title":"300. Longest Increasing Subsequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Dynamic Programming</p> </li> </ul> Python <pre><code>from functools import cache\nfrom typing import List\n\n\n# DP - LIS\ndef lengthOfLISMemo(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return n\n\n    @cache\n    def dfs(i: int) -&gt; int:\n        res = 0\n        for j in range(i):\n            if nums[j] &lt; nums[i]:\n                res = max(res, dfs(j))\n        return res + 1\n\n    return max(dfs(i) for i in range(n))\n\n\n# DP - LIS\ndef lengthOfLISTable(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return n\n\n    dp = [1 for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i):\n            if nums[i] &gt; nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\n\nif __name__ == \"__main__\":\n    assert lengthOfLISMemo([10, 9, 2, 5, 3, 7, 101, 18]) == 4\n    assert lengthOfLISTable([10, 9, 2, 5, 3, 7, 101, 18]) == 4\n    assert lengthOfLISMemo([0, 1, 0, 3, 2, 3]) == 4\n    assert lengthOfLISTable([0, 1, 0, 3, 2, 3]) == 4\n    assert lengthOfLISMemo([7, 7, 7, 7]) == 1\n    assert lengthOfLISTable([7, 7, 7, 7]) == 1\n</code></pre>"},{"location":"neetcode-150/1d_dynamic_programming/#416-partition-equal-subset-sum","title":"416. Partition Equal Subset Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>from functools import cache\nfrom typing import List\n\nfrom leetpattern.utils import knapsack01\n\n\n# Memoization\ndef canPartitionMemoization(nums: List[int]) -&gt; bool:\n    total = sum(nums)\n    n = len(nums)\n\n    if total % 2 == 1 or n &lt;= 1:\n        return False\n\n    @cache\n    def dfs(i, j):\n        if i &lt; 0:\n            return j == 0\n        return j &gt;= nums[i] and dfs(i - 1, j - nums[i]) or dfs(i - 1, j)\n\n    return dfs(n - 1, total // 2)\n\n\n# DP - Knapsack 01\ndef canPartitionTemplate(nums: List[int]) -&gt; bool:\n    total = sum(nums)\n\n    if total % 2 == 1 or len(nums) &lt; 2:\n        return False\n\n    target = total // 2\n\n    return knapsack01(nums, nums, target) == target\n\n\n# DP - Knapsack 01\ndef canPartition(nums: List[int]) -&gt; bool:\n    total = sum(nums)\n\n    if total % 2 == 1 or len(nums) &lt; 2:\n        return False\n\n    target = total // 2\n\n    dp = [0 for _ in range(target + 1)]\n\n    for i in range(len(nums)):\n        for j in range(target, nums[i] - 1, -1):\n            dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])\n\n    return dp[target] == target\n\n\nif __name__ == \"__main__\":\n    nums = [1, 5, 11, 5]\n    print(canPartitionTemplate(nums))  # True\n    print(canPartition(nums))  # True\n    print(canPartitionMemoization(nums))  # True\n</code></pre>"},{"location":"neetcode-150/2d_dynamic_programming/","title":"2D Dynamic_Programming","text":""},{"location":"neetcode-150/2d_dynamic_programming/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 62. Unique Paths (Medium)</li> <li> 1143. Longest Common Subsequence (Medium)</li> <li> 309. Best Time to Buy and Sell Stock with Cooldown (Medium)</li> <li> 518. Coin Change II (Medium)</li> <li> 494. Target Sum (Medium)</li> <li> 97. Interleaving String (Medium)</li> <li> 329. Longest Increasing Path in a Matrix (Hard)</li> <li> 115. Distinct Subsequences (Hard)</li> <li> 72. Edit Distance (Medium)</li> <li> 312. Burst Balloons (Hard)</li> <li> 10. Regular Expression Matching (Hard)</li> </ul>"},{"location":"neetcode-150/2d_dynamic_programming/#62-unique-paths","title":"62. Unique Paths","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Combinatorics</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Count the number of unique paths to reach the bottom-right corner of a `m x n` grid.\n\n![62](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)\n\"\"\"\n\n\n# DP - 2D\ndef uniquePaths(m: int, n: int) -&gt; int:\n    if m == 1 or n == 1:\n        return 1\n\n    dp = [[1] * n for _ in range(m)]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]\n\n\nprint(uniquePaths(m=3, n=7))  # 28\n# [[1, 1, 1,  1,  1,  1,  1],\n#  [1, 2, 3,  4,  5,  6,  7],\n#  [1, 3, 6, 10, 15, 21, 28]]\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint uniquePaths(int m, int n) {\n    vector dp(m, vector&lt;int&gt;(n, 1));\n\n    for (int i = 1; i &lt; m; i++) {\n        for (int j = 1; j &lt; n; j++) {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n\n    return dp[m - 1][n - 1];\n}\n\nint main() {\n    int m = 3, n = 7;\n    cout &lt;&lt; uniquePaths(m, n) &lt;&lt; endl;  // 28\n    return 0;\n}\n</code></pre>"},{"location":"neetcode-150/2d_dynamic_programming/#1143-longest-common-subsequence","title":"1143. Longest Common Subsequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul> Python <pre><code>from functools import cache\n\n\nclass LongestCommonSubsequence:\n    def memoization(self, text1: str, text2: str) -&gt; int:\n        m, n = len(text1), len(text2)\n\n        @cache\n        def dfs(i: int, j: int) -&gt; int:\n            if i &lt; 0 or j &lt; 0:\n                return 0\n            if text1[i] == text2[j]:\n                return dfs(i - 1, j - 1) + 1\n            return max(dfs(i - 1, j), dfs(i, j - 1))\n\n        return dfs(m - 1, n - 1)\n\n    def iterative(self, text1: str, text2: str) -&gt; int:\n        m, n = len(text1), len(text2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for i, x in enumerate(text1):\n            for j, y in enumerate(text2):\n                if x == y:\n                    dp[i + 1][j + 1] = dp[i][j] + 1\n                else:\n                    dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1])\n\n        return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    lcs = LongestCommonSubsequence()\n    assert lcs.memoization(\"abcde\", \"ace\") == 3\n    assert lcs.iterative(\"abcde\", \"ace\") == 3\n    assert lcs.memoization(\"abc\", \"abc\") == 3\n    assert lcs.iterative(\"abc\", \"abc\") == 3\n</code></pre>"},{"location":"neetcode-150/2d_dynamic_programming/#309-best-time-to-buy-and-sell-stock-with-cooldown","title":"309. Best Time to Buy and Sell Stock with Cooldown","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP\ndef maxProfit(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 4 for _ in range(n)]\n\n    dp[0][0] = -prices[0]  # poessess\n    dp[0][1] = 0  # stay sold\n    dp[0][2] = 0  # sell\n    dp[0][3] = 0  # cooldown\n\n    for i in range(1, n):\n        dp[i][0] = max(\n            dp[i - 1][0],  # stay poessess\n            dp[i - 1][1] - prices[i],  # buy after stay sold\n            dp[i - 1][3] - prices[i],  # buy after cooldown\n        )\n        dp[i][1] = max(\n            dp[i - 1][1],  # stay sold\n            dp[i - 1][3],  # stay cooldown\n        )\n        dp[i][2] = dp[i - 1][0] + prices[i]\n        dp[i][3] = dp[i - 1][2]\n\n    return max(dp[-1])\n\n\nprices = [1, 2, 3, 0, 2]\nprint(maxProfit(prices))  # 3\n</code></pre>"},{"location":"neetcode-150/2d_dynamic_programming/#518-coin-change-ii","title":"518. Coin Change II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef change(amount: int, coins: List[int]) -&gt; int:\n    dp = [0 for _ in range(amount + 1)]\n    dp[0] = 1\n\n    for i in range(len(coins)):\n        for j in range(coins[i], amount + 1):\n            dp[j] += dp[j - coins[i]]\n\n    return dp[-1]\n\n\namount = 5\ncoins = [1, 2, 5]\nprint(change(amount, coins))  # 4\n</code></pre>"},{"location":"neetcode-150/2d_dynamic_programming/#494-target-sum","title":"494. Target Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Backtracking</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef findTargetSumWays(nums: List[int], target: int) -&gt; int:\n\n    totalSum = sum(nums)\n\n    if abs(target) &gt; totalSum:\n        return 0\n    if (target + totalSum) % 2 == 1:\n        return 0\n\n    targetSum = (target + totalSum) // 2\n    dp = [0] * (targetSum + 1)\n    dp[0] = 1\n\n    for i in range(len(nums)):\n        for j in range(targetSum, nums[i] - 1, -1):\n            dp[j] += dp[j - nums[i]]\n\n    return dp[targetSum]\n\n\nnums = [1, 1, 1, 1, 1]\ntarget = 3\nprint(findTargetSumWays(nums, target))  # 5\n</code></pre>"},{"location":"neetcode-150/2d_dynamic_programming/#97-interleaving-string","title":"97. Interleaving String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul> Python <pre><code># DP - 2D\ndef isInterleaveDP(s1: str, s2: str, s3: str) -&gt; bool:\n    m, n, k = len(s1), len(s2), len(s3)\n\n    if m + n != k:\n        return False\n\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    for i in range(1, m + 1):\n        dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n\n    for j in range(1, n + 1):\n        dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (\n                dp[i][j - 1] and s2[j - 1] == s3[i + j - 1]\n            )\n\n    return dp[m][n]\n\n\n# DFS\ndef isInterleaveDFS(s1: str, s2: str, s3: str) -&gt; bool:\n    memo = {}\n\n    def dfs(i, j, k):\n        if i == len(s1) and j == len(s2) and k == len(s3):\n            return True\n\n        if (i, j) in memo:\n            return memo[(i, j)]\n\n        res = False\n\n        if i &lt; len(s1) and k &lt; len(s3) and s1[i] == s3[k]:\n            res |= dfs(i + 1, j, k + 1)\n\n        if j &lt; len(s2) and k &lt; len(s3) and s2[j] == s3[k]:\n            res |= dfs(i, j + 1, k + 1)\n\n        memo[(i, j)] = res\n\n        return res\n\n    return dfs(0, 0, 0)\n\n\ns1 = \"aabcc\"\ns2 = \"dbbca\"\ns3 = \"aadbbbaccc\"\nprint(isInterleaveDP(s1, s2, s3))  # False\nprint(isInterleaveDFS(s1, s2, s3))  # False\n</code></pre>"},{"location":"neetcode-150/2d_dynamic_programming/#329-longest-increasing-path-in-a-matrix","title":"329. Longest Increasing Path in a Matrix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Depth First Search, Breadth First Search, Graph, Topological Sort, Memoization, Matrix</p> </li> </ul> Python <pre><code>from collections import deque\nfrom functools import cache\nfrom typing import List\n\n\n# BFS - Topological Sort\ndef longestIncreasingPathBFS(matrix: List[List[int]]) -&gt; int:\n    if not matrix:\n        return 0\n\n    m, n = len(matrix), len(matrix[0])\n    dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    # Calculate indegrees and initialize queue in one pass\n    indegree = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            for dr, dc in dirs:\n                nr, nc = i + dr, j + dc\n                if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and matrix[nr][nc] &gt; matrix[i][j]:\n                    indegree[nr][nc] += 1\n\n    # Start with cells that have no smaller neighbors\n    queue = deque((i, j) for i in range(m) for j in range(n) if indegree[i][j] == 0)\n\n    res = 0\n    while queue:\n        res += 1\n        for _ in range(len(queue)):\n            r, c = queue.popleft()\n            for dr, dc in dirs:\n                nr, nc = r + dr, c + dc\n                if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and matrix[nr][nc] &gt; matrix[r][c]:\n                    indegree[nr][nc] -= 1\n                    if indegree[nr][nc] == 0:\n                        queue.append((nr, nc))\n\n    return res\n\n\n# DP - 2D\ndef longestIncreasingPath(matrix: List[List[int]]) -&gt; int:\n    if not matrix:\n        return 0\n\n    m, n = len(matrix), len(matrix[0])\n    dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    @cache\n    def dfs(r, c):\n        path = 1\n        for dr, dc in dirs:\n            nr, nc = r + dr, c + dc\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and matrix[nr][nc] &gt; matrix[r][c]:\n                path = max(path, dfs(nr, nc) + 1)\n        return path\n\n    res = 0\n    for i in range(m):\n        for j in range(n):\n            res = max(res, dfs(i, j))\n\n    return res\n\n\nif __name__ == \"__main__\":\n    matrix = [[9, 9, 4], [6, 6, 8], [2, 1, 1]]\n    assert longestIncreasingPath(matrix) == 4\n    assert longestIncreasingPathBFS(matrix) == 4\n</code></pre>"},{"location":"neetcode-150/2d_dynamic_programming/#115-distinct-subsequences","title":"115. Distinct Subsequences","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul> Python <pre><code>def numDistinct(s: str, t: str) -&gt; int:\n    m = len(s)\n    n = len(t)\n    dp = [[0] * (n + 1) for _ in range((m + 1))]\n\n    for i in range(m):\n        dp[i][0] = 1\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                # include and exclude s[i-1]\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]  # exclude s[i-1]\n\n    return dp[-1][-1]\n\n\ns = \"rabbbit\"\nt = \"rabbit\"\nprint(numDistinct(s, t))  # 3\n</code></pre>"},{"location":"neetcode-150/2d_dynamic_programming/#72-edit-distance","title":"72. Edit Distance","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul> Python <pre><code>from functools import cache\n\n\n# Recursive\ndef minDistanceDFS(word1: str, word2: str) -&gt; int:\n    n, m = len(word1), len(word2)\n\n    @cache\n    def dfs(i: int, j: int) -&gt; int:\n        if i &lt; 0:\n            return j + 1\n        if j &lt; 0:\n            return i + 1\n        if word1[i] == word2[j]:\n            return dfs(i - 1, j - 1)\n\n        return 1 + min(dfs(i - 1, j), dfs(i, j - 1), dfs(i - 1, j - 1))\n\n    return dfs(n - 1, m - 1)\n\n\n# Iterative\ndef minDistanceDP(word1: str, word2: str) -&gt; int:\n    m, n = len(word1), len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]  # no operation\n            else:\n                dp[i][j] = 1 + min(\n                    dp[i - 1][j],  # delete\n                    dp[i][j - 1],  # insert\n                    dp[i - 1][j - 1],  # replace\n                )\n    return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    word1 = \"horse\"\n    word2 = \"ros\"\n    print(minDistanceDFS(word1, word2))  # 3\n    print(minDistanceDP(word1, word2))  # 3\n</code></pre>"},{"location":"neetcode-150/2d_dynamic_programming/#312-burst-balloons","title":"312. Burst Balloons","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"neetcode-150/2d_dynamic_programming/#10-regular-expression-matching","title":"10. Regular Expression Matching","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Recursion</p> </li> </ul>"},{"location":"neetcode-150/advanced_graphs/","title":"Advanced Graphs","text":""},{"location":"neetcode-150/advanced_graphs/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 332. Reconstruct Itinerary (Hard)</li> <li> 1584. Min Cost to Connect All Points (Medium)</li> <li> 743. Network Delay Time (Medium)</li> <li> 778. Swim in Rising Water (Hard)</li> <li> 269. Alien Dictionary (Hard) \ud83d\udc51</li> <li> 787. Cheapest Flights Within K Stops (Medium)</li> </ul>"},{"location":"neetcode-150/advanced_graphs/#332-reconstruct-itinerary","title":"332. Reconstruct Itinerary","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Graph, Eulerian Circuit</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the itinerary in order that visits every airport exactly once.\n-   The starting airport is `JFK`.\n-   If there are multiple valid itineraries, return the lexicographically smallest one.\n-   Eulerian path: A path that visits every edge exactly once.\n\"\"\"\n\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Hierholzer\ndef findItinerary1(tickets: List[List[str]]) -&gt; List[str]:\n    graph = defaultdict(list)\n    for u, v in sorted(tickets, reverse=True):\n        graph[u].append(v)\n\n    route = []\n\n    def dfs(node):\n        while graph[node]:\n            dest = graph[node].pop()\n            dfs(dest)\n        route.append(node)\n\n    dfs(\"JFK\")\n\n    return route[::-1]\n\n\n# Backtracking\ndef findItinerary2(tickets: List[List[str]]) -&gt; List[str]:\n    graph = defaultdict(list)\n    tickets.sort()\n    for u, v in tickets:\n        graph[u].append(v)\n\n    route = [\"JFK\"]\n\n    def backtraking(node):\n        if len(route) == len(tickets) + 1:\n            return True\n        if node not in graph:\n            return False\n\n        temp = list(graph[node])\n        for i, v in enumerate(temp):\n            graph[node].pop(i)\n            route.append(v)\n\n            if backtraking(v):\n                return True\n\n            graph[node].insert(i, v)\n            route.pop()\n\n        return False\n\n    backtraking(\"JFK\")\n\n    return route\n\n\ntickets = tickets = [\n    [\"JFK\", \"SFO\"],\n    [\"JFK\", \"ATL\"],\n    [\"SFO\", \"ATL\"],\n    [\"ATL\", \"JFK\"],\n    [\"ATL\", \"SFO\"],\n]\nprint(findItinerary1(tickets))\n# ['JFK', 'ATL', 'JFK', 'SFO', 'ATL', 'SFO']\nprint(findItinerary2(tickets))\n# ['JFK', 'ATL', 'JFK', 'SFO', 'ATL', 'SFO']\n</code></pre>"},{"location":"neetcode-150/advanced_graphs/#1584-min-cost-to-connect-all-points","title":"1584. Min Cost to Connect All Points","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Union Find, Graph, Minimum Spanning Tree</p> </li> </ul> Python <pre><code>\"\"\"\n- Tree: a connected acyclic graph\n- Spanning Tree: a subgraph that is a tree and connects all the vertices together\n- Minimum Spanning Tree (MST): a spanning tree with the minimum possible sum of edge weights\n- Prim's Algorithm\n  - Data Structure: Heap\n  - Time Complexity: O(E * logV)\n  - Space Complexity: O(V + E)\n- Kruskal's Algorithm\n  - Union Find\n  - Time Complexity: O(E * logV)\n  - Space Complexity: O(V + E)\n\"\"\"\n\nimport heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minCostConnectPointsPrim(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    graph = defaultdict(list)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            dist = abs(x1 - x2) + abs(y1 - y2)\n            graph[i].append((dist, j))\n            graph[j].append((dist, i))\n\n    cost = 0\n    heap = [(0, 0)]  # (cost, node)\n    visited = set()\n\n    while heap:\n        d1, n1 = heapq.heappop(heap)\n        if n1 in visited:\n            continue\n        visited.add(n1)\n        cost += d1\n\n        for d2, n2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (d2, n2))\n\n    return cost\n\n\n# Kruskal\ndef minCostConnectPointsKruskal(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    par = {i: i for i in range(n)}\n    rank = {i: 0 for i in range(n)}\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 == p2:\n            return False\n\n        if rank[p1] &gt; rank[p2]:\n            par[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n        else:\n            par[p2] = p1\n            rank[p1] += 1\n\n        return True\n\n    heap = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            dist = abs(x1 - x2) + abs(y1 - y2)\n            heapq.heappush(heap, (dist, i, j))\n\n    cost = 0\n    while heap:\n        d, n1, n2 = heapq.heappop(heap)\n        if union(n1, n2):\n            cost += d\n\n    return cost\n\n\nif __name__ == \"__main__\":\n    points = [[0, 0], [2, 2], [3, 10], [5, 2], [7, 0]]\n    print(minCostConnectPointsPrim(points))  # 20\n    print(minCostConnectPointsKruskal(points))  # 20\n</code></pre>"},{"location":"neetcode-150/advanced_graphs/#743-network-delay-time","title":"743. Network Delay Time","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Graph, Heap Priority Queue, Shortest Path</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return the minimum time taken to reach all nodes in a network.\n-   Shortest Path Problem: Find the shortest path between two vertices in a graph.\n-   Dijkstra's Algorithm\n    -   Shortest path algorithm\n    -   Weighted graph (non-negative weights)\n    -   Data Structure: Heap; Hash Set\n    -   Time Complexity: O(E * logV)\n    -   Space Complexity: O(V)\n\"\"\"\n\nimport heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Dijkstra - Set\ndef networkDelayTime1(times: List[List[int]], n: int, k: int) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    heap = [(0, k)]\n    visit = set()\n    t = 0\n\n    while heap:\n        w1, n1 = heapq.heappop(heap)\n        if n1 in visit:\n            continue\n\n        visit.add(n1)\n        t = w1\n\n        for n2, w2 in graph[n1]:\n            heapq.heappush(heap, (w1 + w2, n2))\n\n    return t if len(visit) == n else -1\n\n\n# Dijkstra - Dict\ndef networkDelayTime2(times: List[List[int]], n: int, k: int) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    heap = [(0, k)]\n    dist = defaultdict(int)\n\n    while heap:\n        w1, n1 = heapq.heappop(heap)\n        if n1 in dist:\n            continue\n\n        dist[n1] = w1\n\n        for n2, w2 in graph[n1]:\n            heapq.heappush(heap, (w1 + w2, n2))\n\n    return max(dist.values()) if len(dist) == n else -1\n\n\n# Bellman-Ford\ndef networkDelayTimeBF(times: List[List[int]], n: int, k: int) -&gt; int:\n    delay = {i: float(\"inf\") for i in range(1, n + 1)}\n    delay[k] = 0\n\n    for _ in range(n - 1):\n        for u, v, t in times:\n            delay[v] = min(delay[v], delay[u] + t)\n\n    max_delay = max(delay.values())\n    return max_delay if max_delay &lt; float(\"inf\") else -1\n\n\n# |--------------|-----------|--------|\n# | Approach     | Time      | Space  |\n# |--------------|-----------|--------|\n# | Dijkstra     | O(E*logV) | O(V+E) |\n# | Bellman-Ford | O(E*V)    | O(V)   |\n# |--------------|-----------|--------|\n\nif __name__ == \"__main__\":\n    times = [[2, 1, 1], [2, 3, 1], [3, 4, 1]]\n    n = 4\n    k = 2\n    print(networkDelayTime1(times, n, k))  # 2\n    print(networkDelayTime2(times, n, k))  # 2\n    print(networkDelayTimeBF(times, n, k))  # 2\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;cassert&gt;\n#include &lt;climits&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass NetworkDelayTime {\n   public:\n    // single-source, non-negative weight -&gt; Dijkstra's\n    // https://leetcode.cn/problems/network-delay-time/solutions/2668220/liang-chong-dijkstra-xie-fa-fu-ti-dan-py-ooe8/\n    int dijkstra(vector&lt;vector&lt;int&gt;&gt;&amp; times, int n, int k) {\n        vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; graph(n + 1);\n        for (auto&amp; t : times) {\n            graph[t[0]].push_back({t[1], t[2]});\n        }\n\n        vector&lt;int&gt; dist(n + 1, INT_MAX);\n        // min heap\n        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;,\n                       greater&lt;pair&lt;int, int&gt;&gt;&gt;\n            min_heap;\n\n        dist[k] = 0;\n        min_heap.push({0, k});  // [dist, node]\n\n        while (!min_heap.empty()) {\n            auto [d, u] = min_heap.top();\n            min_heap.pop();\n\n            if (d &gt; dist[u]) continue;  // found the shortest\n\n            for (auto&amp; [v, w] : graph[u]) {\n                if (dist[u] + w &lt; dist[v]) {\n                    dist[v] = dist[u] + w;\n                    min_heap.push({dist[v], v});\n                }\n            }\n        }\n\n        int res = 0;\n        for (int i = 1; i &lt;= n; ++i) {\n            if (dist[i] == INT_MAX) return -1;\n            res = max(res, dist[i]);\n        }\n        return res;\n    }\n\n    // single source -&gt; Bellman-Ford\n    int bellman_ford(vector&lt;vector&lt;int&gt;&gt;&amp; times, int n, int k) {\n        vector&lt;int&gt; dist(n + 1, INT_MAX);\n        dist[k] = 0;\n\n        for (int i = 1; i &lt;= n - 1; i++) {\n            for (auto&amp; edge : times) {\n                int u = edge[0], v = edge[1], t = edge[2];\n                if (dist[u] != INT_MAX &amp;&amp; dist[v] &gt; dist[u] + t) {\n                    dist[v] = dist[u] + t;\n                }\n            }\n        }\n\n        int res = 0;\n        for (int i = 1; i &lt;= n; i++) {\n            if (dist[i] == INT_MAX) return -1;\n            res = max(res, dist[i]);\n        }\n        return res;\n    }\n};\n\nint main() {\n    NetworkDelayTime solution;\n    vector&lt;vector&lt;int&gt;&gt; times = {{2, 1, 1}, {2, 3, 1}, {3, 4, 1}};\n    assert(solution.dijkstra(times, 4, 2) == 2);\n    assert(solution.bellman_ford(times, 4, 2) == 2);\n\n    return 0;\n}\n</code></pre>"},{"location":"neetcode-150/advanced_graphs/#778-swim-in-rising-water","title":"778. Swim in Rising Water","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Depth First Search, Breadth First Search, Union Find, Heap Priority Queue, Matrix</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the minimum time when you can reach the target.\n\n![778](https://assets.leetcode.com/uploads/2021/06/29/swim2-grid-1.jpg)\n\"\"\"\n\nimport heapq\nfrom typing import List\n\n\n# Dijkstra's\ndef swimInWater(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    visited = set()\n    minHeap = [(grid[0][0], 0, 0)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    visited.add((0, 0))\n\n    while minHeap:\n        time, r, c = heapq.heappop(minHeap)\n\n        if r == n - 1 and c == n - 1:\n            return time\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if nr in range(n) and nc in range(n) and (nr, nc) not in visited:\n                visited.add((nr, nc))\n                heapq.heappush(minHeap, (max(time, grid[nr][nc]), nr, nc))\n\n\ngrid = [\n    [0, 1, 2, 3, 4],\n    [24, 23, 22, 21, 5],\n    [12, 13, 14, 15, 16],\n    [11, 17, 18, 19, 20],\n    [10, 9, 8, 7, 6],\n]\nprint(swimInWater(grid))  # 16\n</code></pre>"},{"location":"neetcode-150/advanced_graphs/#269-alien-dictionary","title":"269. Alien Dictionary \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Depth First Search, Breadth First Search, Graph, Topological Sort</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the correct order of characters in the alien language.\n\"\"\"\n\nfrom collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS - Kahn's algorithm (Topological Sort)\ndef alienOrderBFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    indegree = {c: 0 for word in words for c in word}\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                    indegree[w2[j]] += 1\n                break\n\n    q = deque([c for c in indegree if indegree[c] == 0])\n    result = []\n\n    while q:\n        char = q.popleft()\n        result.append(char)\n\n        for neighbor in graph[char]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n\n    return \"\".join(result) if len(result) == len(indegree) else \"\"\n\n\n# DFS - Topological Sort\ndef alienOrderDFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    visited = {}\n    result = []\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                break\n\n    def dfs(c):\n        if c in visited:\n            return visited[c]\n\n        visited[c] = False\n        for neighbor in graph[c]:\n            if not dfs(neighbor):\n                return False\n\n        visited[c] = True\n        result.append(c)\n        return True\n\n    for c in list(graph.keys()):\n        if not dfs(c):\n            return \"\"\n\n    return \"\".join(result[::-1])\n\n\nwords = [\"wrt\", \"wrf\", \"er\", \"ett\", \"rftt\"]\nprint(alienOrderBFS(words))  # wertf\nprint(alienOrderDFS(words))  # wertf\n</code></pre>"},{"location":"neetcode-150/advanced_graphs/#787-cheapest-flights-within-k-stops","title":"787. Cheapest Flights Within K Stops","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Depth First Search, Breadth First Search, Graph, Heap Priority Queue, Shortest Path</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return the cheapest price from `src` to `dst` with at most `K` stops.\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/5eIK3zUdYmE?si=aBR0VbHXTgNuVlGz\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen&gt;&lt;/iframe&gt;\n\"\"\"\n\nimport heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Bellman-Ford\ndef findCheapestPriceBF(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    prices = [float(\"inf\") for _ in range(n)]\n    prices[src] = 0\n\n    for _ in range(k + 1):\n        temp = prices[:]\n        for u, v, w in flights:\n            temp[v] = min(temp[v], prices[u] + w)\n        prices = temp\n\n    return prices[dst] if prices[dst] != float(\"inf\") else -1\n\n\n# Dijkstra\ndef findCheapestPriceDijkstra(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in flights:\n        graph[u].append((v, w))\n\n    heap = [(0, src, 0)]  # (price, city, stops)\n    visited = defaultdict(int)  # {city: stops}\n\n    while heap:\n        price, city, stops = heapq.heappop(heap)\n\n        if city == dst:\n            return price\n\n        if stops &gt; k:\n            continue\n\n        if city in visited and visited[city] &lt;= stops:\n            continue\n\n        visited[city] = stops\n\n        for neighbor, cost in graph[city]:\n            heapq.heappush(heap, (price + cost, neighbor, stops + 1))\n\n    return -1\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |Bellman-Ford|    O(k * E)      |  O(n)   |\n# | Dijkstra   | O(E * log(V))    |  O(n)   |\n# |------------|------------------|---------|\n\n\nn = 4\nflights = [[0, 1, 100], [1, 2, 100], [2, 0, 100], [1, 3, 600], [2, 3, 200]]\nsrc = 0\ndst = 3\nk = 1\nprint(findCheapestPriceBF(n, flights, src, dst, k))  # 700\nprint(findCheapestPriceDijkstra(n, flights, src, dst, k))  # 700\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;climits&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass FindCheapestPrice {\n   public:\n    int bellman_ford(int n, vector&lt;vector&lt;int&gt;&gt;&amp; flights, int src, int dst,\n                     int k) {\n        vector&lt;int&gt; dist(n, INT_MAX);\n        dist[src] = 0;\n\n        for (int i = 0; i &lt;= k; ++i) {\n            vector&lt;int&gt; temp(dist);\n            for (auto&amp; flight : flights) {\n                int u = flight[0], v = flight[1], w = flight[2];\n                if (dist[u] != INT_MAX &amp;&amp; dist[u] + w &lt; temp[v]) {\n                    temp[v] = dist[u] + w;\n                }\n            }\n            dist = temp;\n        }\n        return dist[dst] == INT_MAX ? -1 : dist[dst];\n    }\n\n    int dijkstra(int n, vector&lt;vector&lt;int&gt;&gt;&amp; flights, int src, int dst, int k) {\n        vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; graph(n);\n        for (auto&amp; flight : flights) {\n            graph[flight[0]].push_back({flight[1], flight[2]});\n        }\n        priority_queue&lt;array&lt;int, 3&gt;, vector&lt;array&lt;int, 3&gt;&gt;,\n                       greater&lt;array&lt;int, 3&gt;&gt;&gt;\n            min_heap;\n        min_heap.push({0, src, k + 1});\n\n        while (!min_heap.empty()) {\n            auto [cost, u, stops] = min_heap.top();\n            min_heap.pop();\n            if (u == dst) {\n                return cost;\n            }\n            if (stops &gt; 0) {\n                for (auto&amp; [v, w] : graph[u]) {\n                    min_heap.push({cost + w, v, stops - 1});\n                }\n            }\n        }\n\n        return -1;\n    }\n};\n\nint main() {\n    FindCheapestPrice solution;\n    int n = 4;\n    vector&lt;vector&lt;int&gt;&gt; flights = {\n        {0, 1, 100}, {1, 2, 100}, {2, 0, 100}, {1, 3, 600}, {2, 3, 200}};\n    int src = 0, dst = 3, k = 1;\n    assert(solution.bellman_ford(n, flights, src, dst, k) == 700);\n    assert(solution.dijkstra(n, flights, src, dst, k) == 700);\n\n    return 0;\n}\n</code></pre>"},{"location":"neetcode-150/arrays_hashing/","title":"Arrays Hashing","text":""},{"location":"neetcode-150/arrays_hashing/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 217. Contains Duplicate (Easy)</li> <li> 242. Valid Anagram (Easy)</li> <li> 1. Two Sum (Easy)</li> <li> 49. Group Anagrams (Medium)</li> <li> 347. Top K Frequent Elements (Medium)</li> <li> 271. Encode and Decode Strings (Medium) \ud83d\udc51</li> <li> 238. Product of Array Except Self (Medium)</li> <li> 36. Valid Sudoku (Medium)</li> <li> 128. Longest Consecutive Sequence (Medium)</li> </ul>"},{"location":"neetcode-150/arrays_hashing/#217-contains-duplicate","title":"217. Contains Duplicate","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Sorting</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return True if the array contains any duplicates, otherwise return False.\n\"\"\"\n\nfrom typing import List\n\n\n# Brute Force\ndef containsDuplicateBF(nums: List[int]) -&gt; bool:\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] == nums[j]:\n                return True\n\n    return False\n\n\n# Sort\ndef containsDuplicateSort(nums: List[int]) -&gt; bool:\n    nums.sort()\n\n    for i in range(1, len(nums)):\n        if nums[i] == nums[i - 1]:\n            return True\n\n    return False\n\n\n# Set\ndef containsDuplicateSet(nums: List[int]) -&gt; bool:\n    seen = set()\n\n    for i in nums:\n        if i in seen:\n            return True\n        seen.add(i)\n\n    return False\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# | Brute Force |    O(n^2)       |    O(1)      |\n# |     Sort    |    O(n log n)   |    O(1)      |\n# |     Set     |    O(n)         |    O(n)      |\n# |-------------|-----------------|--------------|\n\nprint(containsDuplicateBF([1, 2, 3, 1]))  # True\nprint(containsDuplicateSort([1, 2, 3, 1]))  # True\nprint(containsDuplicateSet([1, 2, 3, 1]))  # True\n</code></pre>"},{"location":"neetcode-150/arrays_hashing/#242-valid-anagram","title":"242. Valid Anagram","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sorting</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return true if an input string is an anagram of another string.\n-   An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once, e.g., `listen` is an anagram of `silent`.\n\"\"\"\n\nfrom collections import Counter\n\n\n# Hashmap\ndef isAnagramHash(s: str, t: str) -&gt; bool:\n    \"\"\"Return True if t is an anagram of s, False otherwise.\"\"\"\n    if len(s) != len(t):\n        return False\n\n    count = dict()\n\n    for i in s:\n        if i in count:\n            count[i] += 1\n        else:\n            count[i] = 1\n\n    for j in t:\n        if j in count:\n            count[j] -= 1\n        else:\n            return False\n\n    for count in count.values():\n        if count != 0:\n            return False\n\n    return True\n\n\n# Array\ndef isAnagramArray(s: str, t: str) -&gt; bool:\n    if len(s) != len(t):\n        return False\n\n    count = [0 for _ in range(26)]\n\n    for i in s:\n        count[ord(i) - ord(\"a\")] += 1\n\n    for j in t:\n        count[ord(j) - ord(\"a\")] -= 1\n\n    for i in count:\n        if i != 0:\n            return False\n\n    return True\n\n\n# Counter\ndef isAnagramCounter(s: str, t: str) -&gt; bool:\n    return Counter(s) == Counter(t)\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |   Hashmap   |       O(n)      |     O(1)     |\n# |    Array    |       O(n)      |     O(1)     |\n# |   Counter   |       O(n)      |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\ns = \"anagram\"\nt = \"nagaram\"\nprint(isAnagramHash(s, t))  # True\nprint(isAnagramArray(s, t))  # True\nprint(isAnagramCounter(s, t))  # True\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool isAnagram(string s, string t) {\n        if (s.size() != t.size()) return false;\n\n        vector&lt;int&gt; count(26, 0);\n\n        for (char ch : s) count[ch - 'a']++;\n        for (char ch : t) count[ch - 'a']--;\n        for (int c : count) {\n            if (c != 0) return false;\n        }\n\n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n    assert(solution.isAnagram(\"anagram\", \"nagaram\") == true);\n    assert(solution.isAnagram(\"rat\", \"car\") == false);\n    assert(solution.isAnagram(\"a\", \"ab\") == false);\n    assert(solution.isAnagram(\"a\", \"a\") == true);\n    return 0;\n}\n</code></pre>"},{"location":"neetcode-150/arrays_hashing/#1-two-sum","title":"1. Two Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return the indices of the two numbers such that they add up to a specific target.\n- Approach: Use a hashmap to store the indices of the numbers.\n- Time Complexity: O(n)\n- Space Complexity: O(n)\n\"\"\"\n\nfrom typing import List\n\n\ndef two_sum(nums: List[int], target: int) -&gt; List[int]:\n    hashmap = {}  # val: idx\n\n    for idx, val in enumerate(nums):\n        if (target - val) in hashmap:\n            return [hashmap[target - val], idx]\n\n        hashmap[val] = idx\n\n    return []\n\n\ndef test_two_sum():\n    assert two_sum([2, 7, 11, 15], 9) == [0, 1]\n    assert two_sum([3, 2, 4], 6) == [1, 2]\n    assert two_sum([3, 3], 6) == [0, 1]\n    assert two_sum([1, 2, 3, 4, 5], 10) == []\n    assert two_sum([-1, -2, -3, -4, -5], -8) == [2, 4]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Solution {\n   public:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {\n        unordered_map&lt;int, int&gt; map;\n\n        for (size_t i = 0; i &lt; nums.size(); i++) {\n            int diff = target - nums[i];\n            if (map.find(diff) != map.end()) {\n                return {map[diff], (int)i};\n            }\n            map[nums[i]] = (int)i;\n        }\n        return {-1, -1};\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; nums = {2, 7, 11, 15};\n    int target = 9;\n    vector&lt;int&gt; result = solution.twoSum(nums, target);\n    assert((result == vector&lt;int&gt;{0, 1}));\n    return 0;\n}\n</code></pre>"},{"location":"neetcode-150/arrays_hashing/#49-group-anagrams","title":"49. Group Anagrams","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Sorting</p> </li> </ul> PythonCPP <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash - List\ndef groupAnagrams(strs: List[str]) -&gt; List[List[str]]:\n    result = defaultdict(list)\n\n    for s in strs:\n        count = [0] * 26\n        for i in s:\n            count[ord(i) - ord(\"a\")] += 1\n\n        result[tuple(count)].append(s)\n\n    return list(result.values())\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Hash     |     O(n * k)    |     O(n)     |\n# |-------------|-----------------|--------------|\n\n\nstrs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\nprint(groupAnagrams(strs))\n# [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;cassert&gt;\n#include &lt;ranges&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Solution {\n   public:\n    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) {\n        unordered_map&lt;string, vector&lt;string&gt;&gt; map;\n\n        for (string&amp; s : strs) {\n            string sorted = s;\n            ranges::sort(sorted);\n            map[sorted].push_back(s);\n        }\n\n        vector&lt;vector&lt;string&gt;&gt; res;\n\n        for (auto&amp; kv : map) {\n            res.push_back(kv.second);\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;string&gt; strs = {\"eat\", \"tea\", \"tan\"};\n    vector&lt;vector&lt;string&gt;&gt; res = solution.groupAnagrams(strs);\n    assert((res == vector&lt;vector&lt;string&gt;&gt;{{\"eat\", \"tea\"}, {\"tan\"}} ||\n            res == vector&lt;vector&lt;string&gt;&gt;{{\"tan\"}, {\"eat\", \"tea\"}}));\n\n    return 0;\n}\n</code></pre>"},{"location":"neetcode-150/arrays_hashing/#347-top-k-frequent-elements","title":"347. Top K Frequent Elements","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Divide And Conquer, Sorting, Heap Priority Queue, Bucket Sort, Counting, Quickselect</p> </li> </ul> Python <pre><code>import heapq\nfrom collections import Counter\nfrom typing import List\n\n\n# Heap + Counter\ndef topKFrequent(nums: List[int], k: int) -&gt; List[int]:\n    minHeap = []\n\n    for val, freq in Counter(nums).items():\n        if len(minHeap) &lt; k:\n            heapq.heappush(minHeap, (freq, val))\n        else:\n            heapq.heappushpop(minHeap, (freq, val))\n\n    return [i for _, i in minHeap]\n\n\n# Counter (Most Common)\ndef topKFrequentCounter(nums: List[int], k: int) -&gt; List[int]:\n    commons = Counter(nums).most_common(k)\n    return [i for i, _ in commons]\n\n\nnums = [1, 1, 1, 2, 2, 3]\nk = 2\nprint(topKFrequent(nums, k))  # [1, 2]\nprint(topKFrequentCounter(nums, k))  # [1, 2]\n</code></pre>"},{"location":"neetcode-150/arrays_hashing/#271-encode-and-decode-strings","title":"271. Encode and Decode Strings \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Design</p> </li> </ul> Python <pre><code>from typing import List\n\n\nclass Codec:\n    def encode(self, strs: List[str]) -&gt; str:\n        \"\"\"Encodes a list of strings to a single string.\"\"\"\n        encoded = \"\"\n\n        for s in strs:\n            encoded += str(len(s)) + \"#\" + s\n\n        return encoded\n\n    def decode(self, s: str) -&gt; List[str]:\n        \"\"\"Decodes a single string to a list of strings.\"\"\"\n        decoded = []\n        i = 0\n\n        while i &lt; len(s):\n            j = i\n            while s[j] != \"#\":\n                j += 1\n\n            strLen = int(s[i:j])\n            decoded.append(s[j + 1 : j + 1 + strLen])\n            i = j + 1 + strLen\n\n        return decoded\n\n\n# |-------------|-------------|--------------|\n# |   Approach  |    Time     |    Space     |\n# |-------------|-------------|--------------|\n# | Two pointers|    O(n)     |     O(n)     |\n# |-------------|-------------|--------------|\n\n\ncodec = Codec()\nencoded = codec.encode([\"hello\", \"world\"])\nprint(encoded)  # \"5#hello5#world\"\ndecoded = codec.decode(encoded)\nprint(decoded)  # [\"hello\", \"world\"]\n</code></pre>"},{"location":"neetcode-150/arrays_hashing/#238-product-of-array-except-self","title":"238. Product of Array Except Self","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Prefix Sum</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Classic **Prefix Sum** problem\n-   Return an array `output` such that `output[i]` is equal to the product of all the elements of `nums` except `nums[i]`.\n\n| Approach           | Time | Space |\n| ------------------ | ---- | ----- |\n| Prefix             | O(n) | O(n)  |\n| Prefix (Optimized) | O(n) | O(1)  |\n\"\"\"\n\nfrom typing import List\n\n\n# Prefix\ndef productExceptSelf(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    prefix = [1 for _ in range(n)]\n    suffix = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        prefix[i] = nums[i - 1] * prefix[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        suffix[i] = nums[i + 1] * suffix[i + 1]\n\n    result = [i * j for i, j in zip(prefix, suffix)]\n\n    return result\n\n\n# Prefix (Optimized)\ndef productExceptSelfOptimized(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    result = [1 for _ in range(n)]\n\n    prefix = 1\n    for i in range(n):\n        result[i] = prefix\n        prefix *= nums[i]\n\n    suffix = 1\n    for i in range(n - 1, -1, -1):\n        result[i] *= suffix\n        suffix *= nums[i]\n\n    return result\n\n\nprint(productExceptSelf([1, 2, 3, 4]))\n# [24, 12, 8, 6]\nprint(productExceptSelfOptimized([1, 2, 3, 4]))\n# [24, 12, 8, 6]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt; &amp;nums) {\n        int n = nums.size();\n        vector&lt;int&gt; prefix(n, 1);\n        vector&lt;int&gt; suffix(n, 1);\n        vector&lt;int&gt; res(n, 1);\n\n        for (int i = 1; i &lt; n; i++) {\n            prefix[i] = prefix[i - 1] * nums[i - 1];\n        }\n\n        for (int i = n - 2; i &gt;= 0; i--) {\n            suffix[i] = suffix[i + 1] * nums[i + 1];\n        }\n\n        for (int i = 0; i &lt; n; i++) {\n            res[i] = prefix[i] * suffix[i];\n        }\n        return res;\n    }\n};\n\nint main() {\n    vector&lt;int&gt; nums = {1, 2, 3, 4};\n    Solution obj;\n    vector&lt;int&gt; result = obj.productExceptSelf(nums);\n    assert(result == vector&lt;int&gt;({24, 12, 8, 6}));\n    return 0;\n}\n</code></pre>"},{"location":"neetcode-150/arrays_hashing/#36-valid-sudoku","title":"36. Valid Sudoku","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Matrix</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Set\ndef isValidSudoku(board: List[List[str]]) -&gt; bool:\n    rows = [set() for _ in range(9)]\n    cols = [set() for _ in range(9)]\n    boxes = [set() for _ in range(9)]\n\n    for i in range(9):\n        for j in range(9):\n            if board[i][j] == \".\":\n                continue\n\n            if board[i][j] in rows[i]:\n                return False\n            rows[i].add(board[i][j])\n\n            if board[i][j] in cols[j]:\n                return False\n            cols[j].add(board[i][j])\n\n            box_index = (i // 3) * 3 + j // 3\n            if board[i][j] in boxes[box_index]:\n                return False\n            boxes[box_index].add(board[i][j])\n\n    return True\n\n\nboard = [\n    [\"5\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],\n    [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n    [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n    [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n    [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n    [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n    [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"],\n    [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n    [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"],\n]\nprint(isValidSudoku(board))  # True\n</code></pre>"},{"location":"neetcode-150/arrays_hashing/#128-longest-consecutive-sequence","title":"128. Longest Consecutive Sequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Union Find</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Set\ndef longestConsecutiveSet(nums: List[int]) -&gt; int:\n    num_set = set(nums)  # O(n)\n    longest = 0\n\n    for n in nums:\n        if (n - 1) not in num_set:  # left boundary\n            length = 1\n\n            while (n + length) in num_set:\n                length += 1\n\n            longest = max(longest, length)\n\n    return longest\n\n\n# Union Find\ndef longestConsecutiveUF(nums: List[int]) -&gt; int:\n    if not nums:\n        return 0\n\n    par = {num: num for num in nums}\n    rank = {num: 1 for num in nums}\n\n    def find(num):\n        p = par[num]\n        while p != par[p]:\n            p = par[p]\n        return p\n\n    def union(num1, num2):\n        p1, p2 = find(num1), find(num2)\n        if p1 == p2:\n            return\n\n        if rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n            rank[p2] += rank[p1]\n        else:\n            par[p2] = p1\n            rank[p1] += rank[p2]\n\n    for num in nums:\n        if num - 1 in par:\n            union(num, num - 1)\n\n    return max(rank.values())\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |  Set       |  O(N)  |  O(N)   |\n# | Union Find |  O(N)  |  O(N)   |\n# |------------|--------|---------|\n\n\nnums = [100, 4, 200, 1, 3, 2]\nprint(longestConsecutiveSet(nums))  # 4\nprint(longestConsecutiveUF(nums))  # 4\n</code></pre>"},{"location":"neetcode-150/backtracking/","title":"Backtracking","text":""},{"location":"neetcode-150/backtracking/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 78. Subsets (Medium)</li> <li> 39. Combination Sum (Medium)</li> <li> 40. Combination Sum II (Medium)</li> <li> 46. Permutations (Medium)</li> <li> 90. Subsets II (Medium)</li> <li> 79. Word Search (Medium)</li> <li> 131. Palindrome Partitioning (Medium)</li> <li> 17. Letter Combinations of a Phone Number (Medium)</li> <li> 51. N-Queens (Hard)</li> </ul>"},{"location":"neetcode-150/backtracking/#78-subsets","title":"78. Subsets","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking, Bit Manipulation</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Iterative Inclusion Backtracking\ndef subsets_iterative_inclusion(nums: List[int]) -&gt; List[List[int]]:\n    n = len(nums)\n    res, path = [], []\n\n    def dfs(i):\n        res.append(path.copy())\n\n        for j in range(i, n):\n            path.append(nums[j])\n            dfs(j + 1)\n            path.pop()\n\n    dfs(0)\n\n    return res\n\n\n# Binary Decision Backtracking\ndef subsets_binary_decision(nums: List[int]) -&gt; List[List[int]]:\n    n = len(nums)\n    res, path = [], []\n\n    def dfs(i):\n        if i == n:\n            res.append(path.copy())\n            return\n\n        # Exclude\n        dfs(i + 1)\n\n        # Include\n        path.append(nums[i])\n        dfs(i + 1)\n        path.pop()\n\n    dfs(0)\n\n    return res\n\n\nprint(subsets_iterative_inclusion([1, 2, 3]))\n# [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]\nprint(subsets_binary_decision([1, 2, 3]))\n# [[], [3], [2], [2, 3], [1], [1, 3], [1, 2], [1, 2, 3]]\n</code></pre>"},{"location":"neetcode-150/backtracking/#39-combination-sum","title":"39. Combination Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef combinationSum(candidates: List[int], target: int) -&gt; List[List[int]]:\n    n = len(candidates)\n    res, path = [], []\n\n    def dfs(total, start):\n        if total &gt; target:\n            return\n        if total == target:\n            res.append(path.copy())\n            return\n\n        for i in range(start, n):\n            total += candidates[i]\n            path.append(candidates[i])\n            dfs(total, i)\n            total -= candidates[i]\n            path.pop()\n\n    dfs(0, 0)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(combinationSum([2, 3, 5], 8))\n    # [[2, 2, 2, 2], [2, 3, 3], [3, 5]]\n    print(combinationSum([2, 3, 6, 7], 7))\n    # [[2, 2, 3], [7]]\n</code></pre>"},{"location":"neetcode-150/backtracking/#40-combination-sum-ii","title":"40. Combination Sum II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef combinationSum2(candidates: List[int], target: int) -&gt; List[List[int]]:\n    result, path = [], []\n    candidates.sort()\n\n    def backtracking(total, start):\n        if total == target:\n            result.append(path[:])\n            return None\n\n        for i in range(start, len(candidates)):\n\n            if i &gt; start and candidates[i] == candidates[i - 1]:\n                continue\n\n            if total + candidates[i] &gt; target:\n                break\n\n            total += candidates[i]\n            path.append(candidates[i])\n            backtracking(total, i + 1)\n            total -= candidates[i]\n            path.pop()\n\n    backtracking(0, 0)\n\n    return result\n\n\nprint(combinationSum2([10, 1, 2, 7, 6, 1, 5], 8))\n# [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n</code></pre>"},{"location":"neetcode-150/backtracking/#46-permutations","title":"46. Permutations","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Backtracking\ndef permute(nums: List[int]) -&gt; List[List[int]]:\n    n = len(nums)\n    path, res = [], []\n    used = [False for _ in range(n)]\n\n    def dfs(x: int):\n        if x == n:\n            res.append(path[:])\n            return\n\n        for i in range(n):\n            if used[i]:\n                continue\n            used[i] = True\n            path.append(nums[i])\n            dfs(x + 1)\n            path.pop()\n            used[i] = False\n\n    dfs(0)\n\n    return res\n\n\nprint(permute([1, 2, 3]))\n# [[1, 2, 3], [1, 3, 2], [2, 1, 3],\n#  [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n</code></pre>"},{"location":"neetcode-150/backtracking/#90-subsets-ii","title":"90. Subsets II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking, Bit Manipulation</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef subsetsWithDup(nums: List[int]) -&gt; List[List[int]]:\n    path, result = [], []\n    nums.sort()\n\n    def backtracking(startIndex):\n        if path not in result:\n            result.append(path[:])\n\n        for i in range(startIndex, len(nums)):\n            path.append(nums[i])\n            backtracking(i + 1)\n            path.pop()\n\n    backtracking(startIndex=0)\n\n    return result\n\n\nprint(subsetsWithDup([1, 2, 2]))\n# [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]\n</code></pre>"},{"location":"neetcode-150/backtracking/#79-word-search","title":"79. Word Search","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Backtracking, Depth First Search, Matrix</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef exist(board: List[List[str]], word: str) -&gt; bool:\n    m, n = len(board), len(board[0])\n    path = set()\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n\n    def dfs(r, c, i):\n        if i == len(word):\n            return True\n\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or board[r][c] != word[i] or (r, c) in path:\n            return False\n\n        path.add((r, c))\n\n        for dr, dc in dirs:\n            if dfs(r + dr, c + dc, i + 1):\n                return True\n\n        path.remove((r, c))\n        return False\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, 0):\n                return True\n\n    return False\n\n\nboard = [\n    [\"A\", \"B\", \"C\", \"E\"],\n    [\"S\", \"F\", \"C\", \"S\"],\n    [\"A\", \"D\", \"E\", \"E\"],\n]\nword = \"ABCCED\"\nprint(exist(board, word))  # True\n</code></pre>"},{"location":"neetcode-150/backtracking/#131-palindrome-partitioning","title":"131. Palindrome Partitioning","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Backtracking</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Backtracking\ndef partition(s: str) -&gt; List[List[str]]:\n    n = len(s)\n    res, path = [], []\n\n    def dfs(start):\n        if start == n:\n            res.append(path.copy())\n            return\n\n        for end in range(start, n):\n            cur = s[start : end + 1]\n            if cur == cur[::-1]:\n                path.append(cur)\n                dfs(end + 1)\n                path.pop()\n\n    dfs(0)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(partition(\"aab\"))\n    # [['a', 'a', 'b'], ['aa', 'b']]\n</code></pre>"},{"location":"neetcode-150/backtracking/#17-letter-combinations-of-a-phone-number","title":"17. Letter Combinations of a Phone Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Backtracking</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return all possible letter combinations that the number could represent.\n\n![17](https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png)\n\"\"\"\n\nfrom typing import List\n\n\n# Backtracking\ndef letterCombinations(digits: str) -&gt; List[str]:\n    letter_map = {\n        \"2\": \"abc\",\n        \"3\": \"def\",\n        \"4\": \"ghi\",\n        \"5\": \"jkl\",\n        \"6\": \"mno\",\n        \"7\": \"pqrs\",\n        \"8\": \"tuv\",\n        \"9\": \"wxyz\",\n    }\n\n    n = len(digits)\n    if n == 0:\n        return []\n\n    res = []\n\n    def dfs(idx, path):\n        if idx == n:\n            res.append(path)\n            return None\n\n        letters = letter_map[digits[idx]]\n\n        for i in range(len(letters)):\n            dfs(idx + 1, path + letters[i])\n\n    dfs(0, \"\")\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert letterCombinations(\"23\") == [\n        \"ad\",\n        \"ae\",\n        \"af\",\n        \"bd\",\n        \"be\",\n        \"bf\",\n        \"cd\",\n        \"ce\",\n        \"cf\",\n    ]\n</code></pre>"},{"location":"neetcode-150/backtracking/#51-n-queens","title":"51. N-Queens","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking</p> </li> </ul> Python <pre><code>\"\"\"\n- Hard\n- [N-Queens](https://leetcode.com/problems/n-queens/)\n- [N \u7687\u540e](https://leetcode.cn/problems/n-queens/)\n\"\"\"\n\nfrom typing import List\n\n\n# Backtracking\ndef solveNQueens(n: int) -&gt; List[List[str]]:\n    res = []\n    board = [\".\" * n for _ in range(n)]\n\n    def dfs(row):\n        if row == n:\n            res.append(board[:])\n            return None\n        for col in range(n):\n            if is_valid(row, col, board):\n                board[row] = board[row][:col] + \"Q\" + board[row][col + 1 :]\n                dfs(row + 1)\n                board[row] = board[row][:col] + \".\" + board[row][col + 1 :]\n\n    def is_valid(row, col, chessboard):\n        for i in range(row):\n            if chessboard[i][col] == \"Q\":\n                return False\n\n        i, j = row - 1, col - 1\n        while i &gt;= 0 and j &gt;= 0:\n            if chessboard[i][j] == \"Q\":\n                return False\n            i -= 1\n            j -= 1\n\n        i, j = row - 1, col + 1\n        while i &gt;= 0 and j &lt; len(chessboard):\n            if chessboard[i][j] == \"Q\":\n                return False\n            i -= 1\n            j += 1\n\n        return True\n\n    dfs(0)\n\n    return [[\"\".join(row) for row in i] for i in res]\n\n\n# Backtracking\ndef solveNQueens2(n: int) -&gt; List[List[str]]:\n    res = []\n    queens = [0] * n\n    col = [False] * n\n    diag1 = [False] * (n * 2 - 1)\n    diag2 = [False] * (n * 2 - 1)\n\n    def dfs(r: int) -&gt; None:\n        if r == n:\n            res.append([\".\" * c + \"Q\" + \".\" * (n - 1 - c) for c in queens])\n            return\n\n        for c, ok in enumerate(col):\n            if not ok and not diag1[r + c] and not diag2[r - c]:\n                queens[r] = c\n                col[c] = diag1[r + c] = diag2[r - c] = True\n                dfs(r + 1)\n                col[c] = diag1[r + c] = diag2[r - c] = False\n\n    dfs(0)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(solveNQueens(4))\n    # [['.Q..', '...Q', 'Q...', '..Q.'],\n    #  ['..Q.', 'Q...', '...Q', '.Q..']]\n    print(solveNQueens(1))\n    # [['Q']]\n    print(solveNQueens2(4))\n    # [['.Q..', '...Q', 'Q...', '..Q.'],\n    #  ['..Q.', 'Q...', '...Q', '.Q..']]\n    print(solveNQueens2(1))\n    # [['Q']]\n</code></pre>"},{"location":"neetcode-150/binary_search/","title":"Binary Search","text":""},{"location":"neetcode-150/binary_search/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 704. Binary Search (Easy)</li> <li> 74. Search a 2D Matrix (Medium)</li> <li> 875. Koko Eating Bananas (Medium)</li> <li> 153. Find Minimum in Rotated Sorted Array (Medium)</li> <li> 33. Search in Rotated Sorted Array (Medium)</li> <li> 981. Time Based Key-Value Store (Medium)</li> <li> 4. Median of Two Sorted Arrays (Hard)</li> </ul>"},{"location":"neetcode-150/binary_search/#704-binary-search","title":"704. Binary Search","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> Python <pre><code>\"\"\"\n- Implement binary search algorithm.\n\"\"\"\n\nfrom typing import List\n\n\n# Binary Search [left, right]\ndef search(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] &lt; target:\n            left = mid + 1\n        elif nums[mid] &gt; target:\n            right = mid - 1\n        else:\n            return mid\n\n    return -1\n\n\n# Binary Search [left, right)\ndef search_half_open(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums)\n\n    while left &lt; right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] &lt; target:\n            left = mid + 1\n        elif nums[mid] &gt; target:\n            right = mid\n        else:\n            return mid\n\n    return -1\n\n\n# Binary Search (left, right)\ndef search_open_interval(nums: List[int], target: int) -&gt; int:\n    left, right = -1, len(nums)\n\n    while left + 1 &lt; right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] &lt; target:\n            left = mid\n        elif nums[mid] &gt; target:\n            right = mid\n        else:\n            return mid\n\n    return -1\n\n\nif __name__ == \"__main__\":\n    nums = [-1, 0, 3, 5, 9, 12]\n    target = 9\n    assert search(nums, target) == 4\n    assert search_half_open(nums, target) == 4\n    assert search_open_interval(nums, target) == 4\n</code></pre>"},{"location":"neetcode-150/binary_search/#74-search-a-2d-matrix","title":"74. Search a 2D Matrix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Matrix</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Binary Search\ndef searchMatrix(matrix: List[List[int]], target: int) -&gt; bool:\n    if not matrix or not matrix[0]:\n        return False\n\n    m, n = len(matrix), len(matrix[0])\n    left, right = 0, m * n - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        x = matrix[mid // n][mid % n]\n\n        if x &lt; target:\n            left = mid + 1\n        elif x &gt; target:\n            right = mid - 1\n        else:\n            return True\n\n    return False\n\n\nif __name__ == \"__main__\":\n    matrix = [[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]]\n    target = 3\n    print(searchMatrix(matrix, target))  # True\n</code></pre>"},{"location":"neetcode-150/binary_search/#875-koko-eating-bananas","title":"875. Koko Eating Bananas","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> Python <pre><code>from typing import List\n\n\nclass minEatingSpeed:\n    def minEatingSpeed(self, piles: List[int], h: int) -&gt; int:\n        def canEat(piles, k, h):\n            hours = 0\n            for pile in piles:\n                hours += (pile + k - 1) // k\n            return hours &lt;= h\n\n        left, right = 1, max(piles) - 1\n\n        while left &lt;= right:\n            mid = left + (right - left) // 2\n\n            if canEat(piles, mid, h):\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        return left\n\n\nif __name__ == \"__main__\":\n    piles = [3, 6, 7, 11]\n    h = 8\n    sol = minEatingSpeed()\n    assert sol.minEatingSpeed(piles, h) == 4\n</code></pre>"},{"location":"neetcode-150/binary_search/#153-find-minimum-in-rotated-sorted-array","title":"153. Find Minimum in Rotated Sorted Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Binary Search\ndef findMin(nums: List[int]) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt; right:\n        mid = left + (right - left) // 2\n        if nums[mid] &gt; nums[right]:\n            left = mid + 1\n        else:\n            right = mid\n\n    return nums[right]\n\n\nnums = [4, 5, 6, 7, 0, 1, 2]\nprint(findMin(nums))  # 0\n</code></pre>"},{"location":"neetcode-150/binary_search/#33-search-in-rotated-sorted-array","title":"33. Search in Rotated Sorted Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Binary Search\ndef search(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] == target:\n            return mid\n\n        if nums[left] &lt;= nums[mid]:\n            if nums[left] &lt;= target &lt; nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if nums[mid] &lt; target &lt;= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n    return -1\n\n\nnums = [4, 5, 6, 7, 0, 1, 2]\ntarget = 0\nprint(search(nums, target))  # 4\n</code></pre>"},{"location":"neetcode-150/binary_search/#981-time-based-key-value-store","title":"981. Time Based Key-Value Store","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Binary Search, Design</p> </li> </ul> Python <pre><code>from collections import defaultdict\n\n\n# Binary Search\nclass TimeMap:\n\n    def __init__(self):\n        self.keys = defaultdict(list)\n        self.times = dict()\n\n    def set(self, key: str, value: str, timestamp: int) -&gt; None:\n        self.keys[key].append(timestamp)\n        self.times[timestamp] = value\n\n    def get(self, key: str, timestamp: int) -&gt; str:\n        tmp = self.keys[key]\n\n        left, right = 0, len(tmp) - 1\n        while left &lt;= right:\n            mid = left + (right - left) // 2\n            if tmp[mid] &gt; timestamp:\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        return self.times[tmp[right]] if right &gt;= 0 else \"\"\n\n\nobj = TimeMap()\nobj.set(\"foo\", \"bar\", 1)\nprint(obj.get(\"foo\", 1))  # bar\nprint(obj.get(\"foo\", 3))  # bar\nobj.set(\"foo\", \"bar2\", 4)\nprint(obj.get(\"foo\", 4))  # bar2\nprint(obj.get(\"foo\", 5))  # bar2\n</code></pre>"},{"location":"neetcode-150/binary_search/#4-median-of-two-sorted-arrays","title":"4. Median of Two Sorted Arrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Divide And Conquer</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Brute Force\ndef findMedianSortedArraysBF(nums1: List[int], nums2: List[int]) -&gt; float:\n    nums = sorted(nums1 + nums2)\n    n = len(nums)\n    if n % 2 == 0:\n        return (nums[n // 2 - 1] + nums[n // 2]) / 2\n    else:\n        return nums[n // 2]\n\n\n# Binary Search\ndef findMedianSortedArraysBS(nums1: List[int], nums2: List[int]) -&gt; float:\n    if len(nums1) &gt; len(nums2):\n        nums1, nums2 = nums2, nums1\n\n    m, n = len(nums1), len(nums2)\n    imin, imax, half_len = 0, m, (m + n + 1) // 2\n\n    while imin &lt;= imax:\n        i = (imin + imax) // 2\n        j = half_len - i\n\n        if i &lt; m and nums2[j - 1] &gt; nums1[i]:\n            imin = i + 1\n        elif i &gt; 0 and nums1[i - 1] &gt; nums2[j]:\n            imax = i - 1\n        else:\n            if i == 0:\n                max_of_left = nums2[j - 1]\n            elif j == 0:\n                max_of_left = nums1[i - 1]\n            else:\n                max_of_left = max(nums1[i - 1], nums2[j - 1])\n\n            if (m + n) % 2 == 1:\n                return max_of_left\n\n            if i == m:\n                min_of_right = nums2[j]\n            elif j == n:\n                min_of_right = nums1[i]\n            else:\n                min_of_right = min(nums1[i], nums2[j])\n\n            return (max_of_left + min_of_right) / 2\n\n\n# |--------------|-----------------|--------------|\n# | Approach     | Time            | Space        |\n# |--------------|-----------------|--------------|\n# | Brute Force  | O((n+m)log(n+m))| O(n+m)       |\n# | Binary Search| O(log(min(n,m)))| O(1)         |\n# |--------------|-----------------|--------------|\n\n\nnums1 = [1, 3]\nnums2 = [2]\nprint(findMedianSortedArraysBF(nums1, nums2))  # 2.0\nprint(findMedianSortedArraysBS(nums1, nums2))  # 2.0\n</code></pre>"},{"location":"neetcode-150/bit_manipulation/","title":"Bit Manipulation","text":""},{"location":"neetcode-150/bit_manipulation/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 136. Single Number (Easy)</li> <li> 191. Number of 1 Bits (Easy)</li> <li> 338. Counting Bits (Easy)</li> <li> 190. Reverse Bits (Easy)</li> <li> 268. Missing Number (Easy)</li> <li> 371. Sum of Two Integers (Medium)</li> <li> 7. Reverse Integer (Medium)</li> </ul>"},{"location":"neetcode-150/bit_manipulation/#136-single-number","title":"136. Single Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation</p> </li> </ul> Python <pre><code>from functools import reduce\nfrom operator import xor\nfrom typing import List\n\n\n# XOR\ndef singleNumber(nums: List[int]) -&gt; int:\n    res = 0\n    for num in nums:\n        res ^= num\n    return res\n\n\n# XOR\ndef singleNumberXOR(nums: List[int]) -&gt; int:\n    return reduce(xor, nums)\n\n\n# XOR\ndef singleNumberXORLambda(nums: List[int]) -&gt; int:\n    return reduce(lambda x, y: x ^ y, nums)\n\n\nnums = [4, 1, 2, 1, 2]\nprint(singleNumber(nums))  # 4\nprint(singleNumberXOR(nums))  # 4\nprint(singleNumberXORLambda(nums))  # 4\n</code></pre>"},{"location":"neetcode-150/bit_manipulation/#191-number-of-1-bits","title":"191. Number of 1 Bits","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Divide And Conquer, Bit Manipulation</p> </li> </ul> Python <pre><code># Bit Manipulation\ndef hammingWeight1(n: int) -&gt; int:\n    res = 0\n\n    while n != 0:\n        n = n &amp; (n - 1)  # Unset the rightmost 1-bit\n        res += 1\n\n    return res\n\n\ndef hammingWeight2(n: int) -&gt; int:\n    return bin(n).count(\"1\")\n\n\ndef hammingWeight3(n: int) -&gt; int:\n    def decimalToBinary(n: int) -&gt; str:\n        if n == 0:\n            return \"0\"\n\n        binary = \"\"\n        while n &gt; 0:\n            binary = str(n % 2) + binary\n            n //= 2\n\n        return binary\n\n    binary = decimalToBinary(n)\n\n    return binary.count(\"1\")\n\n\nn = 11\nprint(hammingWeight1(n))  # 3\nprint(hammingWeight2(n))  # 3\n\nn = 47\nprint(bin(n))\n</code></pre>"},{"location":"neetcode-150/bit_manipulation/#338-counting-bits","title":"338. Counting Bits","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Bit Manipulation</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Bit Manipulation\ndef countBits(n: int) -&gt; List[int]:\n    bits = [0 for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        bits[i] = bits[i &gt;&gt; 1] + (i &amp; 1)\n\n    return bits\n\n\nn = 5\nprint(countBits(n))  # [0, 1, 1, 2, 1, 2]\n</code></pre>"},{"location":"neetcode-150/bit_manipulation/#190-reverse-bits","title":"190. Reverse Bits","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Divide And Conquer, Bit Manipulation</p> </li> </ul> Python <pre><code># Bit Manipulation\ndef reverseBits(n: int) -&gt; int:\n    res = 0\n\n    for i in range(32):\n        res = (res &lt;&lt; 1) | (n &amp; 1)\n        n &gt;&gt;= 1\n\n    return res\n\n\nn = 0b00000010100101000001111010011100\nprint(reverseBits(n))  # 964176192\n</code></pre>"},{"location":"neetcode-150/bit_manipulation/#268-missing-number","title":"268. Missing Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Math, Binary Search, Bit Manipulation, Sorting</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Math\ndef missingNumberMath(nums: List[int]) -&gt; int:\n    n = len(nums)\n    return (n * (n + 1)) // 2 - sum(nums)\n\n\n# Bit Manipulation (XOR)\ndef missingNumberXOR(nums: List[int]) -&gt; int:\n    n = len(nums)\n\n    for i, num in enumerate(nums):\n        n ^= i ^ num\n\n    return n\n\n\nnums = [3, 0, 1]\nprint(missingNumberMath(nums))  # 2\nprint(missingNumberXOR(nums))  # 2\n</code></pre>"},{"location":"neetcode-150/bit_manipulation/#371-sum-of-two-integers","title":"371. Sum of Two Integers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Bit Manipulation</p> </li> </ul> Python <pre><code># Bit Manipulation\ndef getSum(a: int, b: int) -&gt; int:\n    MASK = 0xFFFFFFFF\n    MAX_INT = 0x7FFFFFFF\n\n    while b != 0:\n        temp = (a ^ b) &amp; MASK\n        b = ((a &amp; b) &lt;&lt; 1) &amp; MASK\n        a = temp\n\n    return a if a &lt;= MAX_INT else ~(a ^ MASK)\n\n\nprint(getSum(1, 2))  # 3\n</code></pre>"},{"location":"neetcode-150/bit_manipulation/#7-reverse-integer","title":"7. Reverse Integer","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math</p> </li> </ul> Python <pre><code># Math\ndef reverse(x: int) -&gt; int:\n    INT_MAX = 2**31 - 1\n\n    sign = -1 if x &lt; 0 else 1\n    x = abs(x)\n    res = 0\n\n    while x != 0:\n        x, pop = divmod(x, 10)\n\n        if res &gt; (INT_MAX - pop) // 10:\n            return 0\n\n        res = res * 10 + pop\n\n    return res * sign\n\n\nprint(reverse(123))  # 321\nprint(reverse(-123))  # -321\n</code></pre>"},{"location":"neetcode-150/graphs/","title":"Graphs","text":""},{"location":"neetcode-150/graphs/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 200. Number of Islands (Medium)</li> <li> 695. Max Area of Island (Medium)</li> <li> 133. Clone Graph (Medium)</li> <li> 286. Walls and Gates (Medium) \ud83d\udc51</li> <li> 994. Rotting Oranges (Medium)</li> <li> 417. Pacific Atlantic Water Flow (Medium)</li> <li> 130. Surrounded Regions (Medium)</li> <li> 207. Course Schedule (Medium)</li> <li> 210. Course Schedule II (Medium)</li> <li> 261. Graph Valid Tree (Medium) \ud83d\udc51</li> <li> 323. Number of Connected Components in an Undirected Graph (Medium) \ud83d\udc51</li> <li> 684. Redundant Connection (Medium)</li> <li> 127. Word Ladder (Hard)</li> </ul>"},{"location":"neetcode-150/graphs/#200-number-of-islands","title":"200. Number of Islands","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Union Find, Matrix</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Count the number of islands in a 2D grid.\n-   Method 1: DFS\n-   Method 2: BFS (use a queue to traverse the grid)\n\n-   How to keep track of visited cells?\n\n    1. Mark the visited cell as `0` (or any other value) to avoid revisiting it.\n    2. Use a set to store the visited cells.\n\n-   Steps:\n    1. Init: variables\n    2. DFS/BFS: starting from the cell with `1`, turn all the connected `1`s to `0`.\n    3. Traverse the grid, and if the cell is `1`, increment the count and call DFS/BFS.\n\n![0200](../../assets/0200.jpg)\n\"\"\"\n\nfrom collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef numIslandsDFS(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    res = 0\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] != \"1\":\n            return\n\n        grid[r][c] = \"2\"\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                dfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Set\ndef numIslandsBFS1(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == \"0\"\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\" and (r, c) not in visited:\n                visited.add((r, c))\n                bfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = dr + row, dc + col\n                if nr &lt; 0 or nr &gt;= m or nc &lt; 0 or nc &gt;= n or grid[nr][nc] != \"1\":\n                    continue\n                grid[nr][nc] = \"2\"\n                q.append((nr, nc))\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == \"1\":\n                grid[i][j] = \"2\"\n                bfs(i, j)\n                res += 1\n\n    return res\n\n\ngrid = [\n    [\"1\", \"1\", \"1\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"0\", \"0\", \"0\", \"0\", \"0\"],\n]\n\nprint(numIslandsDFS(deepcopy(grid)))  # 1\nprint(numIslandsBFS1(deepcopy(grid)))  # 1\nprint(numIslandsBFS2(deepcopy(grid)))  # 1\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    // dfs\n    int num_islands_dfs(vector&lt;vector&lt;char&gt;&gt; &amp;grid) {\n        int m = grid.size(), n = grid[0].size();\n        int res = 0;\n\n        // c++23 lambda recursion\n        auto dfs = [&amp;](this auto &amp;&amp;dfs, int r, int c) -&gt; void {\n            if (r &lt; 0 || r &gt;= m || c &lt; 0 || c &gt;= n || grid[r][c] != '1') {\n                return;\n            }\n            grid[r][c] = '0';\n            dfs(r + 1, c);\n            dfs(r - 1, c);\n            dfs(r, c + 1);\n            dfs(r, c - 1);\n        };\n\n        for (int i = 0; i &lt; m; i++) {\n            for (int j = 0; j &lt; n; j++) {\n                if (grid[i][j] == '1') {\n                    res++;\n                    dfs(i, j);\n                }\n            }\n        }\n        return res;\n    }\n\n    // bfs\n    int num_islands_bfs(vector&lt;vector&lt;char&gt;&gt; &amp;grid) {\n        int m = grid.size(), n = grid[0].size();\n        int res = 0;\n        vector&lt;pair&lt;int, int&gt;&gt; dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\n        auto bfs = [&amp;](int r, int c) {\n            queue&lt;pair&lt;int, int&gt;&gt; q;\n            q.push({r, c});\n            grid[r][c] = '0';\n            while (!q.empty()) {\n                auto [cr, cc] = q.front();\n                q.pop();\n                for (auto &amp;[dr, dc] : dirs) {\n                    int nr = cr + dr, nc = cc + dc;\n                    if (nr &gt;= 0 &amp;&amp; nr &lt; m &amp;&amp; nc &gt;= 0 &amp;&amp; nc &lt; n &amp;&amp;\n                        grid[nr][nc] == '1') {\n                        grid[nr][nc] = '0';\n                        q.push({nr, nc});\n                    }\n                }\n            }\n        };\n\n        for (int i = 0; i &lt; m; i++) {\n            for (int j = 0; j &lt; n; j++) {\n                if (grid[i][j] == '1') {\n                    res++;\n                    bfs(i, j);\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;vector&lt;char&gt;&gt; grid = {{'1', '1', '0', '0', '0'},\n                                 {'1', '1', '0', '0', '0'},\n                                 {'0', '0', '1', '0', '0'},\n                                 {'0', '0', '0', '1', '1'}};\n    assert(solution.num_islands_dfs(grid) == 3);\n    grid = {{'1', '1', '0', '0', '0'},\n            {'1', '1', '0', '0', '0'},\n            {'0', '0', '1', '0', '0'},\n            {'0', '0', '0', '1', '1'}};\n    assert(solution.num_islands_bfs(grid) == 3);\n    return 0;\n}\n</code></pre>"},{"location":"neetcode-150/graphs/#695-max-area-of-island","title":"695. Max Area of Island","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Union Find, Matrix</p> </li> </ul> PythonCPP <pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef maxAreaOfIslandDFS(grid: List[List[int]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] == 0:\n            return 0\n\n        grid[r][c] = 0\n\n        return 1 + dfs(r + 1, c) + dfs(r - 1, c) + dfs(r, c + 1) + dfs(r, c - 1)\n\n    res = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                res = max(res, dfs(i, j))\n    return res\n\n\n# BFS\ndef maxAreaOfIslandBFS1(grid: List[List[int]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        area = 0\n\n        while q:\n            row, col = q.popleft()\n            area += 1\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == 0\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n        return area\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1 and (r, c) not in visited:\n                visited.add((r, c))\n                res = max(res, bfs(r, c))\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        area = 0\n\n        while q:\n            row, col = q.popleft()\n            area += 1\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n\n                if nr &lt; 0 or nr &gt;= m or nc &lt; 0 or nc &gt;= n or grid[nr][nc] == 0:\n                    continue\n\n                q.append((nr, nc))\n                grid[nr][nc] = 0\n\n        return area\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                grid[r][c] = 0\n                res = max(res, bfs(r, c))\n\n    return res\n\n\ngrid = [\n    [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0],\n    [0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],\n]\nprint(maxAreaOfIslandDFS(grid))  # 6\nprint(maxAreaOfIslandBFS1(grid))  # 6\nprint(numIslandsBFS2(grid))  # 6\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int max_area_of_island(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {\n        int m = grid.size(), n = grid[0].size();\n        int res = 0;\n\n        auto dfs = [&amp;](this auto&amp;&amp; dfs, int r, int c) -&gt; int {\n            if (r &lt; 0 || r &gt;= m || c &lt; 0 || c &gt;= n || grid[r][c] != 1) {\n                return 0;\n            }\n            grid[r][c] = 0;\n\n            return 1 + dfs(r + 1, c) + dfs(r - 1, c) + dfs(r, c + 1) +\n                   dfs(r, c - 1);\n        };\n\n        for (int i = 0; i &lt; m; i++) {\n            for (int j = 0; j &lt; n; j++) {\n                if (grid[i][j] == 1) {\n                    int area = dfs(i, j);\n                    res = max(res, area);\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;vector&lt;int&gt;&gt; grid = {{0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},\n                                {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},\n                                {0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},\n                                {0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0},\n                                {0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0},\n                                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0},\n                                {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},\n                                {0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0}};\n    assert(solution.max_area_of_island(grid) == 6);\n    return 0;\n}\n</code></pre>"},{"location":"neetcode-150/graphs/#133-clone-graph","title":"133. Clone Graph","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Depth First Search, Breadth First Search, Graph</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import Optional\n\n\nclass Node:\n    def __init__(self, val=0, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\n\nclass CloneGraph:\n    def dfs(self, node: Optional[\"Node\"]) -&gt; Optional[\"Node\"]:\n        hashmap = {}\n\n        def dfs(node):\n            if node in hashmap:\n                return hashmap[node]\n\n            res = Node(node.val)\n            hashmap[node] = res\n\n            for nei in node.neighbors:\n                res.neighbors.append(dfs(nei))\n\n            return res\n\n        return dfs(node) if node else None\n\n    def bfs(self, node: Optional[\"Node\"]) -&gt; Optional[\"Node\"]:\n        if not node:\n            return None\n\n        hashmap = {node: Node(node.val)}\n        q = deque([node])\n\n        while q:\n            cur = q.popleft()\n\n            for nei in cur.neighbors:\n                if nei not in hashmap:\n                    hashmap[nei] = Node(nei.val)\n                    q.append(nei)\n\n                hashmap[cur].neighbors.append(hashmap[nei])\n\n        return hashmap[node]\n</code></pre>"},{"location":"neetcode-150/graphs/#286-walls-and-gates","title":"286. Walls and Gates \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Breadth First Search, Matrix</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# Multi-Source BFS\ndef wallsAndGates(rooms: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify rooms in-place instead.\n    \"\"\"\n    m, n = len(rooms), len(rooms[0])\n    visited = set()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def addRoom(r, c):\n        if 0 &lt;= r &lt; m and 0 &lt;= c &lt; n and (r, c) not in visited and rooms[r][c] != -1:\n            q.append((r, c))\n            visited.add((r, c))\n\n    q = deque()\n    for r in range(m):\n        for c in range(n):\n            if rooms[r][c] == 0:\n                q.append((r, c))\n                visited.add((r, c))\n\n    dist = 0\n\n    while q:\n        for _ in range(len(q)):\n            r, c = q.popleft()\n            rooms[r][c] = dist\n\n            for dr, dc in directions:\n                addRoom(r + dr, c + dc)\n        dist += 1\n\n\nif __name__ == \"__main__\":\n    rooms = [\n        [2147483647, -1, 0, 2147483647],\n        [2147483647, 2147483647, 2147483647, -1],\n        [2147483647, -1, 2147483647, -1],\n        [0, -1, 2147483647, 2147483647],\n    ]\n    wallsAndGates(rooms)\n    assert rooms == [\n        [3, -1, 0, 1],\n        [2, 2, 1, -1],\n        [1, -1, 2, -1],\n        [0, -1, 3, 4],\n    ]\n</code></pre>"},{"location":"neetcode-150/graphs/#994-rotting-oranges","title":"994. Rotting Oranges","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Breadth First Search, Matrix</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the minimum number of minutes that must elapse until no cell has a fresh orange.\n-   Hint: Multi-source BFS to count the level.\n\n![994](https://assets.leetcode.com/uploads/2019/02/16/oranges.png)\n\"\"\"\n\nfrom collections import deque\nfrom typing import List\n\n\n# BFS\ndef orangesRotting(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    fresh = 0\n    q = deque()\n    dirs = [[1, 0], [0, 1], [0, -1], [-1, 0]]\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 2:\n                q.append([i, j])\n            elif grid[i][j] == 1:\n                fresh += 1\n    res = 0\n\n    while q and fresh &gt; 0:\n        size = len(q)\n        for _ in range(size):\n            r, c = q.popleft()\n            for dr, dc in dirs:\n                nr, nc = dr + r, dc + c\n                if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and grid[nr][nc] == 1:\n                    q.append([nr, nc])\n                    grid[nr][nc] = 2\n                    fresh -= 1\n        res += 1\n\n    return res if fresh == 0 else -1\n\n\ngrid = [[2, 1, 1], [1, 1, 0], [0, 1, 1]]\nassert orangesRotting(grid) == 4\n</code></pre>"},{"location":"neetcode-150/graphs/#417-pacific-atlantic-water-flow","title":"417. Pacific Atlantic Water Flow","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Matrix</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef pacificAtlanticDFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(r, c, visited, prev_height):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or heights[r][c] &lt; prev_height\n            or (r, c) in visited\n        ):\n            return None\n\n        visited.add((r, c))\n        height = heights[r][c]\n        for dr, dc in directions:\n            dfs(dr + r, dc + c, visited, height)\n\n    for c in range(n):\n        dfs(0, c, pac, heights[0][c])\n        dfs(m - 1, c, atl, heights[m - 1][c])\n\n    for r in range(m):\n        dfs(r, 0, pac, heights[r][0])\n        dfs(r, n - 1, atl, heights[r][n - 1])\n\n    return list(pac &amp; atl)\n\n\n# BFS\ndef pacificAtlanticBFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def bfs(r, c, visited):\n        q = deque([(r, c)])\n        visited.add((r, c))\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr in range(m)\n                    and nc in range(n)\n                    and heights[row][col] &lt;= heights[nr][nc]\n                    and (nr, nc) not in visited\n                ):\n                    q.append((nr, nc))\n                    visited.add((nr, nc))\n\n    for c in range(n):\n        bfs(0, c, pac)  # top\n        bfs(m - 1, c, atl)  # bottom\n\n    for r in range(m):\n        bfs(r, 0, pac)  # left\n        bfs(r, n - 1, atl)  # right\n\n    return list(pac &amp; atl)\n\n\nheights = [\n    [1, 2, 2, 3, 5],\n    [3, 2, 3, 4, 4],\n    [2, 4, 5, 3, 1],\n    [6, 7, 1, 4, 5],\n    [5, 1, 1, 2, 4],\n]\nprint(pacificAtlanticDFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\nprint(pacificAtlanticBFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\n</code></pre>"},{"location":"neetcode-150/graphs/#130-surrounded-regions","title":"130. Surrounded Regions","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Union Find, Matrix</p> </li> </ul> Python <pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef solveDFS(board: List[List[str]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n    if not board and not board[0]:\n        return None\n\n    m, n = len(board), len(board[0])\n\n    def capture(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or board[r][c] != \"O\":\n            return None\n\n        board[r][c] = \"T\"\n        capture(r + 1, c)\n        capture(r - 1, c)\n        capture(r, c + 1)\n        capture(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\" and (r in [0, m - 1] or c in [0, n - 1]):\n                capture(r, c)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\":\n                board[r][c] = \"X\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"T\":\n                board[r][c] = \"O\"\n\n\n# BFS\ndef solveBFS(board: List[List[str]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n    if not board and not board[0]:\n        return None\n\n    m, n = len(board), len(board[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def capture(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr = row + dr\n                nc = col + dc\n                if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and board[nr][nc] == \"O\":\n                    board[nr][nc] = \"T\"\n                    q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\" and (r in [0, m - 1] or c in [0, n - 1]):\n                board[r][c] = \"T\"\n                capture(r, c)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\":\n                board[r][c] = \"X\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"T\":\n                board[r][c] = \"O\"\n\n\nif __name__ == \"__main__\":\n    board = [\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"O\", \"O\", \"X\"],\n        [\"X\", \"X\", \"O\", \"X\"],\n        [\"X\", \"O\", \"X\", \"X\"],\n    ]\n\n    b = deepcopy(board)\n    solveDFS(b)\n    assert b == [\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"O\", \"X\", \"X\"],\n    ]\n\n    b = deepcopy(board)\n    solveBFS(b)\n    assert b == [\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"O\", \"X\", \"X\"],\n    ]\n</code></pre>"},{"location":"neetcode-150/graphs/#207-course-schedule","title":"207. Course Schedule","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Graph, Topological Sort</p> </li> </ul> PythonCPP <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS (Kahn's Algorithm)\ndef canFinishBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    count = 0\n\n    while q:\n        crs = q.popleft()\n        count += 1\n\n        for nxt in graph[crs]:\n            indegree[nxt] -= 1\n\n            if indegree[nxt] == 0:\n                q.append(nxt)\n\n    return count == numCourses\n\n\n# DFS + Set\ndef canFinishDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for crs, pre in prerequisites:\n        graph[crs].append(pre)\n\n    visiting = set()\n\n    def dfs(crs):\n        if crs in visiting:  # cycle detected\n            return False\n        if graph[crs] == []:\n            return True\n\n        visiting.add(crs)\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        visiting.remove(crs)\n        graph[crs] = []\n\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\n# DFS + List\ndef canFinishDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for pre, crs in prerequisites:\n        graph[crs].append(pre)\n\n    # 0: init, 1: visiting, 2: visited\n    status = [0] * numCourses\n\n    def dfs(crs):\n        if status[crs] == 1:  # cycle detected\n            return False\n        if status[crs] == 2:\n            return True\n\n        status[crs] = 1\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        status[crs] = 2\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(canFinishBFS(5, prerequisites))  # True\nprint(canFinishDFS1(5, prerequisites))  # True\nprint(canFinishDFS2(5, prerequisites))  # True\n</code></pre> <pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    // BFS\n    bool canFinishBFS(int numCourses, vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        vector&lt;int&gt; indegree(numCourses, 0);\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n            indegree[pre[0]]++;\n        }\n\n        queue&lt;int&gt; q;\n        for (int i = 0; i &lt; numCourses; i++) {\n            if (indegree[i] == 0) {\n                q.push(i);\n            }\n        }\n\n        int cnt = 0;\n        while (!q.empty()) {\n            int cur = q.front();\n            q.pop();\n            cnt++;\n\n            for (int nxt : graph[cur]) {\n                indegree[nxt]--;\n                if (indegree[nxt] == 0) {\n                    q.push(nxt);\n                }\n            }\n        }\n        return cnt == numCourses;\n    }\n\n    // DFS\n    bool canFinishDFS(int numCourses, vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n        }\n        // 0: not visited, 1: visiting, 2: visited\n        vector&lt;int&gt; state(numCourses, 0);\n\n        function&lt;bool(int)&gt; dfs = [&amp;](int pre) -&gt; bool {\n            state[pre] = 1;  // visiting\n            for (int crs : graph[pre]) {\n                if (state[crs] == 1 || (state[crs] == 0 &amp;&amp; dfs(crs))) {\n                    return true;\n                }\n            }\n            state[pre] = 2;  // visited\n            return false;\n        };\n\n        for (int i = 0; i &lt; numCourses; i++) {\n            if (state[i] == 0 &amp;&amp; dfs(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution sol;\n    vector&lt;vector&lt;int&gt;&gt; prerequisites = {{1, 0}, {2, 1}, {3, 2}, {4, 3},\n                                         {5, 4}, {6, 5}, {7, 6}, {8, 7},\n                                         {9, 8}, {10, 9}};\n    int numCourses = 11;\n    cout &lt;&lt; sol.canFinishBFS(numCourses, prerequisites) &lt;&lt; endl;\n    cout &lt;&lt; sol.canFinishDFS(numCourses, prerequisites) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"neetcode-150/graphs/#210-course-schedule-ii","title":"210. Course Schedule II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Graph, Topological Sort</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return the ordering of courses you should take to finish all courses. If there are multiple valid answers, return any of them.\n\n![0207](../../assets/0207.png)\n\"\"\"\n\nfrom collections import defaultdict, deque\nfrom typing import List\n\n\n# 1. BFS - Kahn's Algorithm\ndef findOrderBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    order = []\n\n    while q:\n        pre = q.popleft()\n        order.append(pre)\n\n        for crs in graph[pre]:\n            indegree[crs] -= 1\n            if indegree[crs] == 0:\n                q.append(crs)\n\n    return order if len(order) == numCourses else []\n\n\n# 2. DFS + Set\ndef findOrderDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]:\n    adj = defaultdict(list)\n    for crs, pre in prerequisites:\n        adj[crs].append(pre)\n\n    visit, cycle = set(), set()\n    order = []\n\n    def dfs(crs):\n        if crs in cycle:\n            return False\n        if crs in visit:\n            return True\n\n        cycle.add(crs)\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        cycle.remove(crs)\n        visit.add(crs)\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order\n\n\n# 3. DFS + List\ndef findOrderDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]:\n    adj = defaultdict(list)\n    for pre, crs in prerequisites:\n        adj[crs].append(pre)\n\n    # 0: not visited, 1: visiting, 2: visited\n    state = [0] * numCourses\n    order = []\n\n    def dfs(crs):\n        if state[crs] == 1:\n            return False\n        if state[crs] == 2:\n            return True\n\n        state[crs] = 1\n\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        state[crs] = 2\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order[::-1]\n\n\nnumCourses = 5\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(findOrderBFS(numCourses, prerequisites))  # [2, 4, 3, 1, 0]\nprint(findOrderDFS1(numCourses, prerequisites))  # [4, 3, 1, 2, 0]\nprint(findOrderDFS2(numCourses, prerequisites))  # [4, 3, 2, 1, 0]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    // BFS\n    vector&lt;int&gt; findOrderBFS(int numCourses,\n                             vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        vector&lt;int&gt; in_degree(numCourses, 0);\n        vector&lt;int&gt; res;\n\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n            in_degree[pre[0]]++;\n        }\n\n        queue&lt;int&gt; q;\n        for (int i = 0; i &lt; numCourses; i++)\n            if (in_degree[i] == 0) q.push(i);\n\n        while (!q.empty()) {\n            int cur = q.front();\n            q.pop();\n            res.push_back(cur);\n\n            for (int next : graph[cur]) {\n                in_degree[next]--;\n                if (in_degree[next] == 0) q.push(next);\n            }\n        }\n\n        return (int)res.size() == numCourses ? res : vector&lt;int&gt;{};\n    }\n};\n\nint main() {\n    Solution obj;\n    vector&lt;vector&lt;int&gt;&gt; prerequisites{{1, 0}, {2, 0}, {3, 1}, {3, 2}};\n    vector&lt;int&gt; res = obj.findOrderBFS(4, prerequisites);\n    assert((res == vector&lt;int&gt;{0, 1, 2, 3} || res == vector&lt;int&gt;{0, 2, 1, 3}));\n    return 0;\n}\n</code></pre>"},{"location":"neetcode-150/graphs/#261-graph-valid-tree","title":"261. Graph Valid Tree \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Union Find, Graph</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Graph\ndef validTree(n: int, edges: List[List[int]]) -&gt; bool:\n    if n == 0:\n        return False\n    if len(edges) != n - 1:\n        return False\n\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = set()\n\n    def dfs(node, parent):\n        if node in visited:\n            return False\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor != parent and not dfs(neighbor, node):\n                return False\n        return True\n\n    return dfs(0, -1) and len(visited) == n\n\n\nprint(validTree(5, [[0, 1], [0, 2], [0, 3], [1, 4]]))  # True\nprint(validTree(5, [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]))  # False\n</code></pre>"},{"location":"neetcode-150/graphs/#323-number-of-connected-components-in-an-undirected-graph","title":"323. Number of Connected Components in an Undirected Graph \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Union Find, Graph</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Union Find\ndef countComponents(n: int, edges: List[List[int]]) -&gt; int:\n    uf = UnionFind(n)\n    count = n\n\n    for u, v in edges:\n        count -= uf.union(u, v)\n\n    return count\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(n)}\n        self.rank = {i: 1 for i in range(n)}\n\n    def find(self, n):\n        p = self.par[n]\n        while self.par[p] != p:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return 0\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.par[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.par[p1] = p2\n        else:\n            self.par[p2] = p1\n            self.rank[p1] += 1\n\n        return 1\n\n\nprint(countComponents(5, [[0, 1], [1, 2], [3, 4]]))  # 2\n</code></pre>"},{"location":"neetcode-150/graphs/#684-redundant-connection","title":"684. Redundant Connection","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Union Find, Graph</p> </li> </ul> Python <pre><code>from typing import List\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(1, n + 1)}\n        self.rank = {i: 1 for i in range(1, n + 1)}\n\n    def find(self, n):\n        p = self.par[n]\n        while self.par[p] != p:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return False\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.par[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.par[p1] = p2\n        else:\n            self.par[p2] = p1\n            self.rank[p1] += 1\n\n        return True\n\n\n# Union Find\ndef findRedundantConnectionUF(edges: List[List[int]]) -&gt; List[int]:\n    n = len(edges)\n    uf = UnionFind(n)\n\n    for u, v in edges:\n        if not uf.union(u, v):\n            return (u, v)\n\n\n# DFS\ndef findRedundantConnectionDFS(edges: List[List[int]]) -&gt; List[int]:\n    graph, cycle = {}, {}\n    for a, b in edges:\n        graph.setdefault(a, []).append(b)\n        graph.setdefault(b, []).append(a)\n\n    def dfs(node, parent):\n        if node in cycle:\n            for k in list(cycle.keys()):\n                if k == node:\n                    return True\n                del cycle[k]\n\n        cycle[node] = None\n        for child in graph[node]:\n            if child != parent and dfs(child, node):\n                return True\n        del cycle[node]\n        return False\n\n    dfs(edges[0][0], -1)\n    for a, b in edges[::-1]:\n        if a in cycle and b in cycle:\n            return (a, b)\n\n\nedges = [[1, 2], [1, 3], [2, 3]]\nprint(findRedundantConnectionUF(edges))  # (2, 3)\nprint(findRedundantConnectionDFS(edges))  # (2, 3)\n</code></pre>"},{"location":"neetcode-150/graphs/#127-word-ladder","title":"127. Word Ladder","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Breadth First Search</p> </li> </ul> Python <pre><code>\"\"\"\n-   The most classic BFS problem.\n-   Return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\n-   Approach: BFS\n-   Time Complexity: O(n * m^2)\n-   Space Complexity: O(n * m)\n\"\"\"\n\nfrom collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef ladderLength(beginWord: str, endWord: str, wordList: List[str]) -&gt; int:\n    if endWord not in wordList:\n        return 0\n\n    n = len(beginWord)\n    graph = defaultdict(list)  # pattern: words\n    wordList.append(beginWord)\n\n    for word in wordList:\n        for i in range(n):\n            pattern = word[:i] + \"*\" + word[i + 1 :]\n            graph[pattern].append(word)\n\n    visited = set([beginWord])\n    q = deque([beginWord])\n    res = 1\n\n    while q:\n        size = len(q)\n        for _ in range(size):\n            word = q.popleft()\n            if word == endWord:\n                return res\n\n            for i in range(n):\n                pattern = word[:i] + \"*\" + word[i + 1 :]\n                for neighbor in graph[pattern]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        q.append(neighbor)\n        res += 1\n\n    return 0\n\n\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]\nprint(ladderLength(beginWord, endWord, wordList))  # 5\n</code></pre>"},{"location":"neetcode-150/greedy/","title":"Greedy","text":""},{"location":"neetcode-150/greedy/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 53. Maximum Subarray (Medium)</li> <li> 55. Jump Game (Medium)</li> <li> 45. Jump Game II (Medium)</li> <li> 134. Gas Station (Medium)</li> <li> 846. Hand of Straights (Medium)</li> <li> 1899. Merge Triplets to Form Target Triplet (Medium)</li> <li> 763. Partition Labels (Medium)</li> <li> 678. Valid Parenthesis String (Medium)</li> </ul>"},{"location":"neetcode-150/greedy/#53-maximum-subarray","title":"53. Maximum Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Divide And Conquer, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP Kadane\ndef maxSubArrayDP(nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n\n    dp[0] = nums[0]\n    maxSum = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(\n            dp[i - 1] + nums[i],  # continue the previous subarray\n            nums[i],  # start a new subarray\n        )\n        maxSum = max(maxSum, dp[i])\n\n    return maxSum\n\n\n# Greedy\ndef maxSubArrayGreedy(nums: List[int]) -&gt; int:\n    max_sum = nums[0]\n    cur_sum = 0\n\n    for num in nums:\n        cur_sum = max(cur_sum + num, num)\n        max_sum = max(max_sum, cur_sum)\n\n    return max_sum\n\n\n# Prefix Sum\ndef maxSubArrayPrefixSum(nums: List[int]) -&gt; int:\n    prefix_sum = 0\n    prefix_sum_min = 0\n    res = float(\"-inf\")\n\n    for num in nums:\n        prefix_sum += num\n        res = max(res, prefix_sum - prefix_sum_min)\n        prefix_sum_min = min(prefix_sum_min, prefix_sum)\n\n    return res\n\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArrayDP(nums))  # 6\nprint(maxSubArrayGreedy(nums))  # 6\nprint(maxSubArrayPrefixSum(nums))  # 6\n</code></pre>"},{"location":"neetcode-150/greedy/#55-jump-game","title":"55. Jump Game","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return `True` if you can reach the last index, otherwise `False`.\n\"\"\"\n\nfrom typing import List\n\n\n# Greedy - Interval\ndef canJump(nums: List[int]) -&gt; bool:\n    n = len(nums)\n    reach = 0\n    i = 0\n\n    while reach &gt;= i:\n        if reach &gt;= n - 1:\n            return True\n        reach = max(reach, i + nums[i])\n        i += 1\n\n    return False\n\n\nif __name__ == \"__main__\":\n    assert canJump([2, 3, 1, 1, 4]) is True\n    assert canJump([3, 2, 1, 0, 4]) is False\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool canJump(vector&lt;int&gt;&amp; nums) {\n        int canReach = 0;\n        int n = nums.size();\n\n        for (int i = 0; i &lt; n; i++) {\n            if (i &gt; canReach) return false;\n            canReach = max(canReach, i + nums[i]);\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution obj;\n    vector&lt;int&gt; nums = {2, 3, 1, 1, 4};\n    cout &lt;&lt; obj.canJump(nums) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"neetcode-150/greedy/#45-jump-game-ii","title":"45. Jump Game II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy</p> </li> </ul> Python <pre><code>\"\"\"\n- Return the minimum number of jumps to reach the last index.\n\"\"\"\n\nfrom typing import List\n\n\n# Greedy - Interval\ndef jump(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n == 1:\n        return 0\n\n    reach = 0\n    left, right = 0, 0\n    res = 0\n\n    while right &lt; n - 1:\n        for i in range(left, right + 1):\n            reach = max(reach, i + nums[i])\n\n        left = right + 1\n        right = reach\n        res += 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert jump([2, 3, 1, 1, 4]) == 2\n    assert jump([2, 3, 0, 1, 4]) == 2\n</code></pre>"},{"location":"neetcode-150/greedy/#134-gas-station","title":"134. Gas Station","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\nclass canCompleteCircuit:\n    def greedy(self, gas: List[int], cost: List[int]) -&gt; int:\n        \"\"\"\n        Approach: Greedy\n        Time Complexity: O(n)\n        Space Complexity: O(1)\n        \"\"\"\n\n        # edge case\n        if sum(gas) &lt; sum(cost):\n            return -1\n\n        cur_sum = 0\n        start = 0\n\n        for i in range(len(gas)):\n            cur_sum += gas[i] - cost[i]\n\n            if cur_sum &lt; 0:\n                start = i + 1\n                cur_sum = 0\n\n        return start\n\n\nif __name__ == \"__main__\":\n    solution = canCompleteCircuit()\n    gas = [1, 2, 3, 4, 5]\n    cost = [3, 4, 5, 1, 2]\n    assert solution.greedy(gas, cost) == 3\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) {\n        int totalTank = 0, currTank = 0;\n        int start = 0;\n        int n = gas.size();\n\n        for (int i = 0; i &lt; n; i++) {\n            int diff = gas[i] - cost[i];\n            totalTank += diff;\n            currTank += diff;\n\n            if (currTank &lt; 0) {\n                start = i + 1;\n                currTank = 0;\n            }\n        }\n\n        return (totalTank &gt;= 0) ? start : -1;\n    }\n};\n\nint main() {\n    Solution obj;\n    vector&lt;int&gt; gas{1, 2, 3, 4, 5};\n    vector&lt;int&gt; cost{3, 4, 5, 1, 2};\n    int res = obj.canCompleteCircuit(gas, cost);\n    assert(res == 3);\n    return 0;\n}\n</code></pre>"},{"location":"neetcode-150/greedy/#846-hand-of-straights","title":"846. Hand of Straights","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Greedy, Sorting</p> </li> </ul> Python <pre><code>from collections import Counter\nfrom typing import List\n\n\n# Greedy\ndef isNStraightHand(hand: List[int], groupSize: int) -&gt; bool:\n    if len(hand) % groupSize != 0:\n        return False\n\n    count = Counter(hand)\n\n    while count:\n        minVal = min(count)\n        for i in range(minVal, minVal + groupSize):\n            if count[i] == 0:\n                return False\n            count[i] -= 1\n            if count[i] == 0:\n                del count[i]\n    return True\n\n\nhand = [1, 2, 3, 6, 2, 3, 4, 7, 8]\ngroupSize = 3\nprint(isNStraightHand(hand, groupSize))  # True\n</code></pre>"},{"location":"neetcode-150/greedy/#1899-merge-triplets-to-form-target-triplet","title":"1899. Merge Triplets to Form Target Triplet","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef mergeTriplets(triplets: List[List[int]], target: List[int]) -&gt; bool:\n    can_form = [False, False, False]\n\n    for triplet in triplets:\n        if all(triplet[i] &lt;= target[i] for i in range(3)):\n            for i in range(3):\n                if triplet[i] == target[i]:\n                    can_form[i] = True\n\n    return all(can_form)\n\n\ntriplets = [[2, 5, 3], [1, 8, 4], [1, 7, 5]]\ntarget = [2, 7, 5]\nprint(mergeTriplets(triplets, target))  # True\n</code></pre>"},{"location":"neetcode-150/greedy/#763-partition-labels","title":"763. Partition Labels","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Two Pointers, String, Greedy</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# 1. Hashmap\ndef partitionLabels1(s: str) -&gt; List[int]:\n    hashmap = {}\n\n    for i, j in enumerate(s):\n        if j not in hashmap:\n            hashmap[j] = [i, i]\n        else:\n            hashmap[j][1] = i\n\n    intervals = list(hashmap.values())\n    intervals.sort(key=lambda x: x[0])\n\n    if len(intervals) &lt; 2:\n        return len(intervals)\n\n    res = []\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &lt; intervals[i - 1][1]:\n            intervals[i][1] = max(intervals[i][1], intervals[i - 1][1])\n        else:\n            res.append(intervals[i][0])\n\n    res.append(intervals[-1][1] + 1)\n\n    if len(res) == 1:\n        return res\n    else:\n        for i in range(len(res) - 1, 0, -1):\n            res[i] -= res[i - 1]\n        return res\n\n\n# Single Pass Partitioning\ndef partitionLabels2(s: str) -&gt; List[int]:\n    last = {c: i for i, c in enumerate(s)}\n    res = []\n    start, end = 0, 0\n\n    for i, c in enumerate(s):\n        end = max(end, last[c])\n        if end == i:\n            res.append(end - start + 1)\n            start = i + 1\n\n    return res\n\n\nprint(partitionLabels1(\"abaccd\"))  # [3, 2, 1]\nprint(partitionLabels2(\"abaccd\"))  # [3, 2, 1]\n</code></pre>"},{"location":"neetcode-150/greedy/#678-valid-parenthesis-string","title":"678. Valid Parenthesis String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Stack, Greedy</p> </li> </ul> Python <pre><code># Greedy\ndef checkValidString(s: str) -&gt; bool:\n    min_open, max_open = 0, 0\n\n    for char in s:\n        if char == \"(\":\n            min_open += 1\n            max_open += 1\n        elif char == \")\":\n            min_open = max(min_open - 1, 0)\n            max_open -= 1\n        elif char == \"*\":\n            min_open = max(min_open - 1, 0)\n            max_open += 1\n\n        if max_open &lt; 0:\n            return False\n\n    return min_open == 0\n\n\ns = \"(*))\"\nprint(checkValidString(s))  # True\n</code></pre>"},{"location":"neetcode-150/heap/","title":"Heap","text":""},{"location":"neetcode-150/heap/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 703. Kth Largest Element in a Stream (Easy)</li> <li> 1046. Last Stone Weight (Easy)</li> <li> 973. K Closest Points to Origin (Medium)</li> <li> 215. Kth Largest Element in an Array (Medium)</li> <li> 621. Task Scheduler (Medium)</li> <li> 355. Design Twitter (Medium)</li> <li> 295. Find Median from Data Stream (Hard)</li> </ul>"},{"location":"neetcode-150/heap/#703-kth-largest-element-in-a-stream","title":"703. Kth Largest Element in a Stream","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Design, Binary Search Tree, Heap Priority Queue, Binary Tree, Data Stream</p> </li> </ul> Python <pre><code>import heapq\nfrom typing import List\n\n\n# Heap\nclass KthLargest:\n\n    def __init__(self, k: int, nums: List[int]):\n        self.k = k\n        self.heap = []\n        for num in nums:\n            self.add(num)\n\n    def add(self, val: int) -&gt; int:\n        heapq.heappush(self.heap, val)\n\n        if len(self.heap) &gt; self.k:\n            heapq.heappop(self.heap)\n\n        return self.heap[0]\n\n\nobj = KthLargest(3, [4, 5, 8, 2])\nprint(obj.add(3))  # 4\nprint(obj.add(5))  # 5\nprint(obj.add(10))  # 5\n</code></pre>"},{"location":"neetcode-150/heap/#1046-last-stone-weight","title":"1046. Last Stone Weight","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Heap Priority Queue</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Heap\n    - Time: O(n log n); Space: O(n)\n- 0/1 Knapsack\n    - Time: O(n); Space: O(n)\n\"\"\"\n\nfrom heapq import heapify, heappop, heappush\nfrom typing import List\n\n\n# Heap\ndef lastStoneWeightHeap(stones: List[int]) -&gt; int:\n    maxHeap = [-s for s in stones]\n    heapify(maxHeap)\n\n    while len(maxHeap) &gt; 1:\n        s1 = heappop(maxHeap)\n        s2 = heappop(maxHeap)\n\n        if s1 != s2:\n            heappush(maxHeap, s1 - s2)\n\n    return -maxHeap[0] if maxHeap else 0\n\n\n# 0/1 Knapsack\ndef lastStoneWeightKnapsack(stones: List[int]) -&gt; int:\n    total = sum(stones)\n    target = total // 2\n\n    dp = [0 for _ in range(target + 1)]\n\n    for i in stones:\n        for j in range(target, i - 1, -1):\n            dp[j] = max(dp[j], dp[j - i] + i)\n\n    return total - 2 * dp[target]\n\n\nif __name__ == \"__main__\":\n    stones = [2, 7, 4, 1, 8, 1]\n    assert lastStoneWeightHeap(stones) == 1\n    assert lastStoneWeightKnapsack(stones) == 1\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint lastStoneWeight(vector&lt;int&gt; &amp;stones) {\n    priority_queue&lt;int&gt; maxHeap(stones.begin(), stones.end());\n\n    // Only while there are at least two stones to smash\n    while (maxHeap.size() &gt; 1) {\n        int first = maxHeap.top();\n        maxHeap.pop();\n        int second = maxHeap.top();\n        maxHeap.pop();\n\n        if (first != second) {\n            maxHeap.push(first - second);\n        }\n    }\n\n    return maxHeap.empty() ? 0 : maxHeap.top();\n}\n\nint main() {\n    vector&lt;int&gt; stones = {2, 7, 4, 1, 8, 1};\n    cout &lt;&lt; lastStoneWeight(stones) &lt;&lt; endl;  // 1\n    return 0;\n}\n</code></pre>"},{"location":"neetcode-150/heap/#973-k-closest-points-to-origin","title":"973. K Closest Points to Origin","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Divide And Conquer, Geometry, Sorting, Heap Priority Queue, Quickselect</p> </li> </ul> Python <pre><code>import heapq\nfrom typing import List\n\n\ndef kClosest(points: List[List[int]], k: int) -&gt; List[List[int]]:\n    heap = []\n\n    for x, y in points:\n        dist = -(x**2 + y**2)  # max heap\n        if len(heap) &lt; k:\n            heapq.heappush(heap, (dist, x, y))\n        else:\n            heapq.heappushpop(heap, (dist, x, y))  # push and pop the smallest\n\n    return [[x, y] for (_, x, y) in heap]\n\n\n# Time complexity: O(n * log(k))\n#   - O(log(k)) for heapify\n#   - O(n) for iterating through the input list\n# Space complexity: O(k)\n\npoints = [[1, 3], [-2, 2]]\nk = 1\nprint(kClosest(points, k))  # [[-2, 2]]\n</code></pre>"},{"location":"neetcode-150/heap/#215-kth-largest-element-in-an-array","title":"215. Kth Largest Element in an Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Divide And Conquer, Sorting, Heap Priority Queue, Quickselect</p> </li> </ul> Python <pre><code>import heapq\nfrom typing import List\n\n\ndef findKthLargest(nums: List[int], k: int) -&gt; int:\n    min_heap = []\n\n    for i, num in enumerate(nums):\n        heapq.heappush(min_heap, num)\n        if i &gt;= k:\n            heapq.heappop(min_heap)\n\n    return min_heap[0]\n\n\nif __name__ == \"__main__\":\n    assert findKthLargest([3, 2, 1, 5, 6, 4], 2) == 5\n</code></pre>"},{"location":"neetcode-150/heap/#621-task-scheduler","title":"621. Task Scheduler","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Greedy, Sorting, Heap Priority Queue, Counting</p> </li> </ul> Python <pre><code>import heapq\nfrom collections import Counter, deque\nfrom typing import List\n\n\n# Heap\ndef leastInterval1(tasks: List[str], n: int) -&gt; int:\n    count = Counter(tasks)\n    heap = [-c for c in count.values()]\n    heapq.heapify(heap)\n\n    time = 0\n\n    q = deque()\n\n    while heap or q:\n        time += 1\n\n        if heap:\n            cnt = 1 + heapq.heappop(heap)\n            if cnt:\n                q.append((cnt, time + n))\n\n        if q and q[0][1] == time:\n            heapq.heappush(heap, q.popleft()[0])\n\n    return time\n\n\ndef leastInterval2(tasks: List[str], n: int) -&gt; int:\n    freq = Counter(tasks)\n\n    maxExec = max(freq.values())\n    maxCount = sum(1 for v in freq.values() if v == maxExec)\n\n    return max((maxExec - 1) * (n + 1) + maxCount, len(tasks))\n\n\ntasks = [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\"]\nn = 2\nprint(leastInterval1(tasks, n))  # 8\nprint(leastInterval2(tasks, n))  # 8\n</code></pre>"},{"location":"neetcode-150/heap/#355-design-twitter","title":"355. Design Twitter","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Linked List, Design, Heap Priority Queue</p> </li> </ul> Python <pre><code>\"\"\"\n-   Similar question: [23. Merge K Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/) (Hard)\n\"\"\"\n\nimport heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Design\nclass Twitter:\n\n    def __init__(self):\n        self.tweets = defaultdict(list)\n        self.followees = defaultdict(set)\n        self.time = 0\n\n    def postTweet(self, userId: int, tweetId: int) -&gt; None:\n        self.tweets[userId].append((self.time, tweetId))\n        self.time += 1\n\n    def getNewsFeed(self, userId: int) -&gt; List[int]:\n        news_feed = []\n        news_feed.extend(self.tweets[userId])\n        for followee in self.followees[userId]:\n            news_feed.extend(self.tweets[followee])\n\n        return [tweet for _, tweet in heapq.nlargest(10, news_feed)]\n\n    def follow(self, followerId: int, followeeId: int) -&gt; None:\n        if followerId != followeeId:\n            self.followees[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -&gt; None:\n        if followerId != followeeId:\n            self.followees[followerId].discard(followeeId)\n\n\ntwitter = Twitter()\nprint(twitter.postTweet(1, 5))  # None\nprint(twitter.getNewsFeed(1))  # [5]\nprint(twitter.follow(1, 2))  # None\nprint(twitter.postTweet(2, 6))  # None\nprint(twitter.getNewsFeed(1))  # [6, 5]\nprint(twitter.unfollow(1, 2))  # None\nprint(twitter.getNewsFeed(1))  # [5]\n</code></pre>"},{"location":"neetcode-150/heap/#295-find-median-from-data-stream","title":"295. Find Median from Data Stream","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, Design, Sorting, Heap Priority Queue, Data Stream</p> </li> </ul> PythonCPP <pre><code>from heapq import heappop, heappush\n\n\nclass MedianFinder:\n\n    def __init__(self):\n        self.minHeap = []\n        self.maxHeap = []\n        self.min_size = 0\n        self.max_size = 0\n\n    def addNum(self, num: int) -&gt; None:\n        heappush(self.maxHeap, -num)\n        heappush(self.minHeap, -heappop(self.maxHeap))\n        self.min_size += 1\n\n        if self.min_size &gt; self.max_size:\n            heappush(self.maxHeap, -heappop(self.minHeap))\n            self.min_size -= 1\n            self.max_size += 1\n\n    def findMedian(self) -&gt; float:\n        if self.min_size == self.max_size:\n            return (-self.maxHeap[0] + self.minHeap[0]) / 2.0\n        return float(-self.maxHeap[0])\n\n\ndef test_median_finder():\n    obj = MedianFinder()\n    obj.addNum(1)\n    obj.addNum(2)\n    assert obj.findMedian() == 1.5\n    obj.addNum(3)\n    assert obj.findMedian() == 2.0\n    obj.addNum(4)\n    assert obj.findMedian() == 2.5\n    obj.addNum(5)\n    assert obj.findMedian() == 3.0\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass MedianFinder {\n   private:\n    priority_queue&lt;int&gt; maxHeap;\n    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;\n    int max_size = 0;\n    int min_size = 0;\n\n   public:\n    MedianFinder() {}\n\n    void addNum(int num) {\n        if (min_size == max_size) {\n            minHeap.push(num);\n            maxHeap.push(minHeap.top());\n            minHeap.pop();\n            max_size++;\n        } else {\n            maxHeap.push(num);\n            minHeap.push(maxHeap.top());\n            maxHeap.pop();\n            min_size++;\n        }\n    }\n\n    double findMedian() {\n        if (min_size == max_size) {\n            return (maxHeap.top() + minHeap.top()) / 2.0;\n        } else {\n            return (double)maxHeap.top();\n        }\n    }\n};\n\nint main() {\n    MedianFinder* obj = new MedianFinder();\n    obj-&gt;addNum(1);\n    obj-&gt;addNum(2);\n    cout &lt;&lt; obj-&gt;findMedian() &lt;&lt; endl;  // 1.5\n    obj-&gt;addNum(3);\n    cout &lt;&lt; obj-&gt;findMedian() &lt;&lt; endl;  // 2\n    return 0;\n}\n</code></pre>"},{"location":"neetcode-150/intervals/","title":"Intervals","text":""},{"location":"neetcode-150/intervals/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 57. Insert Interval (Medium)</li> <li> 56. Merge Intervals (Medium)</li> <li> 435. Non-overlapping Intervals (Medium)</li> <li> 252. Meeting Rooms (Easy) \ud83d\udc51</li> <li> 253. Meeting Rooms II (Medium) \ud83d\udc51</li> <li> 1851. Minimum Interval to Include Each Query (Hard)</li> </ul>"},{"location":"neetcode-150/intervals/#57-insert-interval","title":"57. Insert Interval","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Interval\ndef insert(intervals: List[List[int]], newInterval: List[int]) -&gt; List[List[int]]:\n    n = len(intervals)\n\n    if n == 0:\n        return [newInterval]\n\n    if newInterval[1] &lt; intervals[0][0]:\n        return [newInterval] + intervals\n\n    if newInterval[0] &gt; intervals[-1][1]:\n        return intervals + [newInterval]\n\n    i = 0\n    result = []\n\n    while i &lt; n and intervals[i][1] &lt; newInterval[0]:\n        result.append(intervals[i])\n        i += 1\n\n    while i &lt; n and intervals[i][0] &lt;= newInterval[1]:\n        newInterval[0] = min(newInterval[0], intervals[i][0])\n        newInterval[1] = max(newInterval[1], intervals[i][1])\n        i += 1\n\n    result.append(newInterval)\n\n    while i &lt; n:\n        result.append(intervals[i])\n        i += 1\n\n    return result\n\n\nintervals = [[1, 3], [6, 9]]\nnewInterval = [2, 5]\nprint(insert(intervals, newInterval))  # [[1, 5], [6, 9]]\n</code></pre>"},{"location":"neetcode-150/intervals/#56-merge-intervals","title":"56. Merge Intervals","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sorting</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Merge all overlapping intervals.\n\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/44H3cEC2fFM?si=J-Jr_Fg2eDse3-de\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen&gt;&lt;/iframe&gt;\n\"\"\"\n\nfrom typing import List\n\n\n# Intervals\ndef merge(intervals: List[List[int]]) -&gt; List[List[int]]:\n    n = len(intervals)\n    if n &lt;= 1:\n        return intervals\n\n    intervals.sort(key=lambda x: x[0])\n    res = [intervals[0]]\n\n    for i in range(1, n):\n        if intervals[i][0] &lt;= res[-1][1]:\n            res[-1][1] = max(res[-1][1], intervals[i][1])\n        else:\n            res.append(intervals[i])\n\n    return res\n\n\nprint(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))\n# [[1, 6], [8, 10], [15, 18]]\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// Interval\nvector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {\n    sort(intervals.begin(), intervals.end());\n    vector&lt;vector&lt;int&gt;&gt; res;\n\n    for (auto&amp; range : intervals) {\n        if (!res.empty() &amp;&amp; range[0] &lt;= res.back()[1]) {\n            res.back()[1] = max(res.back()[1], range[1]);\n        } else {\n            res.emplace_back(range);\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;vector&lt;int&gt;&gt; intervals = {{1, 3}, {2, 6}, {8, 10}, {15, 18}};\n    vector&lt;vector&lt;int&gt;&gt; res = merge(intervals);\n    for (auto&amp; range : res) {\n        cout &lt;&lt; range[0] &lt;&lt; \", \" &lt;&lt; range[1] &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"neetcode-150/intervals/#435-non-overlapping-intervals","title":"435. Non-overlapping Intervals","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy, Sorting</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef eraseOverlapIntervals(intervals: List[List[int]]) -&gt; int:\n    if len(intervals) &lt;= 1:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n    result = 0\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &gt;= intervals[i - 1][1]:\n            continue\n        else:\n            result += 1\n            intervals[i][1] = min(intervals[i][1], intervals[i - 1][1])\n\n    return result\n\n\nprint(eraseOverlapIntervals([[1, 2], [2, 3], [3, 4], [1, 3]]))  # 1\n</code></pre>"},{"location":"neetcode-150/intervals/#252-meeting-rooms","title":"252. Meeting Rooms \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sorting</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Interval\ndef canAttendMeetings(intervals: List[List[int]]) -&gt; bool:\n    intervals.sort(key=lambda x: x[0])\n    n = len(intervals)\n\n    if n &lt;= 1:\n        return True\n\n    for i in range(1, n):\n        if intervals[i][0] &lt; intervals[i - 1][1]:\n            return False\n\n    return True\n\n\nif __name__ == \"__main__\":\n    intervals = [[0, 30], [5, 10], [15, 20]]\n    assert not canAttendMeetings(intervals)\n</code></pre>"},{"location":"neetcode-150/intervals/#253-meeting-rooms-ii","title":"253. Meeting Rooms II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Greedy, Sorting, Heap Priority Queue, Prefix Sum</p> </li> </ul> Python <pre><code>\"\"\"\n- Given an array of meeting time `intervals` where `intervals[i] = [start_i, end_i]`, return the minimum number of conference rooms required.\n\"\"\"\n\nimport heapq\nfrom typing import List\n\n\n# Heap\ndef minMeetingRooms(intervals: List[List[int]]) -&gt; int:\n    if not intervals:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n    minHeap = [intervals[0][1]]\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &gt;= minHeap[0]:\n            heapq.heappop(minHeap)\n        heapq.heappush(minHeap, intervals[i][1])\n\n    return len(minHeap)\n\n\nif __name__ == \"__main__\":\n    intervals = [[0, 30], [5, 10], [15, 20]]\n    assert minMeetingRooms(intervals) == 2\n</code></pre>"},{"location":"neetcode-150/intervals/#1851-minimum-interval-to-include-each-query","title":"1851. Minimum Interval to Include Each Query","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Line Sweep, Sorting, Heap Priority Queue</p> </li> </ul>"},{"location":"neetcode-150/linked_list/","title":"Linked List","text":""},{"location":"neetcode-150/linked_list/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 206. Reverse Linked List (Easy)</li> <li> 21. Merge Two Sorted Lists (Easy)</li> <li> 143. Reorder List (Medium)</li> <li> 19. Remove Nth Node From End of List (Medium)</li> <li> 138. Copy List with Random Pointer (Medium)</li> <li> 2. Add Two Numbers (Medium)</li> <li> 141. Linked List Cycle (Easy)</li> <li> 287. Find the Duplicate Number (Medium)</li> <li> 146. LRU Cache (Medium)</li> <li> 23. Merge k Sorted Lists (Hard)</li> <li> 25. Reverse Nodes in k-Group (Hard)</li> </ul>"},{"location":"neetcode-150/linked_list/#206-reverse-linked-list","title":"206. Reverse Linked List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Recursion</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\ndef reverse_list_iterative(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    cur = head\n    prev = None\n\n    while cur:\n        temp = cur.next\n        cur.next = prev\n\n        prev = cur\n        cur = temp\n\n    return prev\n\n\ndef reverse_list_recursive(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    def reverse(cur, prev):\n        if not cur:\n            return prev\n\n        temp = cur.next\n        cur.next = prev\n        return reverse(temp, cur)\n\n    return reverse(head, None)\n\n\ndef test_reverse_list():\n    ll = LinkedList([1, 2, 3, 4, 5])\n    ll.head = reverse_list_iterative(ll.head)\n    assert ll.to_array() == [5, 4, 3, 2, 1]\n\n    ll = LinkedList([1, 2, 3, 4, 5])\n    ll.head = reverse_list_recursive(ll.head)\n    assert ll.to_array() == [5, 4, 3, 2, 1]\n</code></pre>"},{"location":"neetcode-150/linked_list/#21-merge-two-sorted-lists","title":"21. Merge Two Sorted Lists","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Recursion</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Task: Merge the two linked lists into one sorted list.\n\"\"\"\n\nfrom typing import Optional\n\nfrom leetpattern.utils import ListNode\n\n\n# Linked List\ndef merge_two_lists(\n    list1: Optional[ListNode], list2: Optional[ListNode]\n) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    while list1 and list2:\n        if list1.val &lt; list2.val:\n            cur.next = list1\n            list1 = list1.next\n        else:\n            cur.next = list2\n            list2 = list2.next\n        cur = cur.next\n\n    if list1:\n        cur.next = list1\n    elif list2:\n        cur.next = list2\n\n    return dummy.next\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode* next) : val(x), next(next) {}\n};\n\nclass Solution {\n   public:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        ListNode dummy;\n        ListNode* cur = &amp;dummy;\n\n        while (list1 &amp;&amp; list2) {\n            if (list1-&gt;val &lt; list2-&gt;val) {\n                cur-&gt;next = list1;\n                list1 = list1-&gt;next;\n            } else {\n                cur-&gt;next = list2;\n                list2 = list2-&gt;next;\n            }\n            cur = cur-&gt;next;\n        }\n\n        cur-&gt;next = list1 ? list1 : list2;\n\n        return dummy.next;\n    }\n};\n\nint main() {\n    Solution sol;\n    ListNode* list1 = new ListNode(1, new ListNode(2, new ListNode(4)));\n    ListNode* list2 = new ListNode(1, new ListNode(3, new ListNode(4)));\n    ListNode* merged = sol.mergeTwoLists(list1, list2);\n    vector&lt;int&gt; res;\n    while (merged) {\n        res.push_back(merged-&gt;val);\n        merged = merged-&gt;next;\n    }\n    assert(res == std::vector&lt;int&gt;({1, 1, 2, 3, 4, 4}));\n    return 0;\n}\n</code></pre>"},{"location":"neetcode-150/linked_list/#143-reorder-list","title":"143. Reorder List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Two Pointers, Stack, Recursion</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\n# Linked List\ndef reorderList(head: Optional[ListNode]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify head in-place instead.\n    \"\"\"\n    if not head or not head.next:\n        return\n\n    # Middle of the linked list\n    slow, fast = head, head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n    # Reverse the second half\n    pre, cur = None, slow\n    while cur:\n        temp = cur.next\n        cur.next = pre\n        pre = cur\n        cur = temp\n\n    # Merge two linked lists\n    first, second = head, pre\n    while second.next:\n        temp1, temp2 = first.next, second.next\n        first.next = second\n        second.next = temp1\n        first, second = temp1, temp2\n\n\ndef test_reorderList():\n    ll = LinkedList([1, 2, 3, 4, 5, 6])\n    assert ll.to_array() == [1, 2, 3, 4, 5, 6]\n    reorderList(ll.head)\n    assert ll.to_array() == [1, 6, 2, 5, 3, 4]\n\n    ll2 = LinkedList([1, 2, 3, 4, 5])\n    assert ll2.to_array() == [1, 2, 3, 4, 5]\n    reorderList(ll2.head)\n    assert ll2.to_array() == [1, 5, 2, 4, 3]\n</code></pre>"},{"location":"neetcode-150/linked_list/#19-remove-nth-node-from-end-of-list","title":"19. Remove Nth Node From End of List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Two Pointers</p> </li> </ul> Python <pre><code>\"\"\"\n-   Given the `head` of a linked list, remove the `n-th` node from the end of the list and return its head.\n\"\"\"\n\nfrom typing import Optional\n\nfrom leetpattern.utils import ListNode, list_from_array, list_to_array\n\n\n# Linked List\ndef removeNthFromEnd(head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:\n    dummy = ListNode(0, head)\n    fast, slow = dummy, dummy\n\n    for _ in range(n):\n        fast = fast.next\n\n    while fast.next:\n        fast = fast.next\n        slow = slow.next\n\n    slow.next = slow.next.next\n\n    return dummy.next\n\n\ndef test_removeNthFromEnd() -&gt; None:\n    head = list_from_array([1, 2, 3, 4, 5])\n    assert (list_to_array(removeNthFromEnd(head, 2))) == [1, 2, 3, 5]\n</code></pre>"},{"location":"neetcode-150/linked_list/#138-copy-list-with-random-pointer","title":"138. Copy List with Random Pointer","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Linked List</p> </li> </ul> Python <pre><code>from typing import Optional\n\n\nclass Node:\n    def __init__(self, x: int, next: \"Node\" = None, random: \"Node\" = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\n\ndef copyRandomList(head: \"Optional[Node]\") -&gt; \"Optional[Node]\":\n    if not head:\n        return None\n\n    # Copy nodes and link them together\n    cur = head\n    while cur:\n        new_node = Node(cur.val)\n        new_node.next = cur.next\n        cur.next = new_node\n        cur = new_node.next\n\n    # Copy random pointers\n    cur = head\n    while cur:\n        cur.next.random = cur.random.next if cur.random else None\n        cur = cur.next.next\n\n    # Separate the original and copied lists\n    cur = head\n    new_head = head.next\n    while cur:\n        new_node = cur.next\n        cur.next = new_node.next\n        new_node.next = new_node.next.next if new_node.next else None\n        cur = cur.next\n\n    return new_head\n</code></pre>"},{"location":"neetcode-150/linked_list/#2-add-two-numbers","title":"2. Add Two Numbers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Math, Recursion</p> </li> </ul> PythonCPP <pre><code>from typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\ndef add_two_numbers(l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]:\n    \"\"\"Add two numbers represented by linked lists.\"\"\"\n    dummy = ListNode()\n    cur = dummy\n    carry = 0\n\n    while l1 or l2:\n        v1 = l1.val if l1 else 0\n        v2 = l2.val if l2 else 0\n\n        carry, val = divmod(v1 + v2 + carry, 10)\n        cur.next = ListNode(val)\n        cur = cur.next\n\n        if l1:\n            l1 = l1.next\n        if l2:\n            l2 = l2.next\n\n    if carry:\n        cur.next = ListNode(val=carry)\n\n    return dummy.next\n\n\ndef test_add_two_numbers():\n    l1 = LinkedList([2, 4, 3]).head\n    l2 = LinkedList([5, 6, 4]).head\n    added = add_two_numbers(l1, l2)\n    assert LinkedList(added).to_array() == [7, 0, 8]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode* next) : val(x), next(next) {}\n};\n\nclass Solution {\n   public:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode dummy;\n        ListNode* cur = &amp;dummy;\n        int carry = 0;\n\n        while (l1 || l2 || carry) {\n            if (l1) {\n                carry += l1-&gt;val;\n                l1 = l1-&gt;next;\n            }\n            if (l2) {\n                carry += l2-&gt;val;\n                l2 = l2-&gt;next;\n            }\n            cur-&gt;next = new ListNode(carry % 10);\n            cur = cur-&gt;next;\n            carry /= 10;\n        }\n        return dummy.next;\n    }\n};\n\nint main() {\n    Solution sol;\n\n    ListNode* l1 = new ListNode(2, new ListNode(4, new ListNode(3)));\n    ListNode* l2 = new ListNode(5, new ListNode(6, new ListNode(4)));\n    ListNode* result = sol.addTwoNumbers(l1, l2);\n\n    vector&lt;int&gt; expected = {7, 0, 8};\n    for (int val : expected) {\n        assert(result != nullptr &amp;&amp; result-&gt;val == val);\n        result = result-&gt;next;\n    }\n    assert(result == nullptr);  // End of list\n\n    return 0;\n}\n</code></pre>"},{"location":"neetcode-150/linked_list/#141-linked-list-cycle","title":"141. Linked List Cycle","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Linked List, Two Pointers</p> </li> </ul> PythonCPP <pre><code>from typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\ndef has_cycle(head: Optional[ListNode]) -&gt; bool:\n    slow, fast = head, head\n\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n        if slow == fast:\n            return True\n\n    return False\n\n\ndef test_has_cycle():\n    ll = LinkedList([3, 2, 0, -4])\n    ll.make_cycle(pos=1)\n    assert has_cycle(ll.head)\n\n    ll = LinkedList([1, 2])\n    ll.make_cycle(pos=0)\n    assert has_cycle(ll.head)\n\n    ll = LinkedList([1, 2, 3, 4, 5])\n    assert not has_cycle(ll.head)\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n\n#include \"include/lists.hpp\"\nusing namespace std;\n\nclass Solution {\n   public:\n    bool has_cycle(ListNode* head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while (fast &amp;&amp; fast-&gt;next) {\n            slow = slow-&gt;next;\n            fast = fast-&gt;next-&gt;next;\n\n            if (fast == slow) return true;\n        }\n        return false;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    ListNode* head = LinkedList::build({3, 2, 0, -4});\n    // create cycle\n    head = LinkedList::make_cycle(head, 1);\n    assert(solution.has_cycle(head) == true);\n    // no cycle\n    ListNode* head2 = LinkedList::build({1, 2});\n    assert(solution.has_cycle(head2) == false);\n    // no cycle\n    ListNode* head3 = LinkedList::build({1});\n    assert(solution.has_cycle(head3) == false);\n\n    return 0;\n}\n</code></pre>"},{"location":"neetcode-150/linked_list/#287-find-the-duplicate-number","title":"287. Find the Duplicate Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Bit Manipulation</p> </li> </ul> Python <pre><code>\"\"\"\n-   Find the duplicate number in an array containing `n + 1` integers where each integer is between `1` and `n` inclusive.\n-   Floyd's Tortoise and Hare (Cycle Detection)\n    -   141. Linked List Cycle\n    -   142. Linked List Cycle II\n-   Time Complexity: O(n)\n-   Space Complexity: O(1)\n\nExample: `nums = [1, 3, 4, 2, 2]`\n\n|  0   |  1   |  2   |  3   |  4   |\n| :--: | :--: | :--: | :--: | :--: |\n|  1   |  3   |  4   |  2   |  2   |\n\n\n\"\"\"\n\nfrom typing import List\n\n\n# Floyd Cycle Detection Algorithm\ndef findDuplicate(nums: List[int]) -&gt; int:\n    fast, slow = nums[0], nums[0]\n\n    while True:\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n        if slow == fast:\n            break\n\n    slow = nums[0]\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[fast]\n\n    return slow\n\n\nnums = [1, 3, 4, 2, 2]\nprint(findDuplicate(nums))  # 2\n</code></pre>"},{"location":"neetcode-150/linked_list/#146-lru-cache","title":"146. LRU Cache","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Linked List, Design, Doubly Linked List</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Design and implement a data structure for **Least Recently Used (LRU) cache**. It should support the following operations: get and put.\n- [lru](https://media.geeksforgeeks.org/wp-content/uploads/20240909142802/Working-of-LRU-Cache-copy-2.webp)\n- ![146](https://miro.medium.com/v2/resize:fit:650/0*fOwBd3z0XtHh7WN1.png)\n\n| Data structure     | Description                   |\n| ------------------ | ----------------------------- |\n| Doubly Linked List | To store the key-value pairs. |\n| Hash Map           | To store the key-node pairs.  |\n\"\"\"\n\nfrom collections import OrderedDict\n\n\n# Doubly Linked List\nclass Node:\n    def __init__(self, key=0, val=0):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.cache = {}\n        self.head = Node()\n        self.tail = Node()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def add_to_last(self, node):\n        self.tail.prev.next = node\n        node.prev = self.tail.prev\n        node.next = self.tail\n        self.tail.prev = node\n\n    def move_to_last(self, node):\n        self.remove(node)\n        self.add_to_last(node)\n\n    def get(self, key: int) -&gt; int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self.move_to_last(node)\n        return node.val\n\n    def put(self, key: int, value: int) -&gt; None:\n        if key in self.cache:\n            node = self.cache[key]\n            node.val = value\n            self.move_to_last(node)\n            return None\n\n        if len(self.cache) == self.cap:\n            del self.cache[self.head.next.key]\n            self.remove(self.head.next)\n\n        node = Node(key=key, val=value)\n        self.cache[key] = node\n        self.add_to_last(node)\n\n\n# OrderedDict\nclass LRUCacheOrderedDict:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.cap = capacity\n\n    def get(self, key: int):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key, last=True)\n        return self.cache[key]\n\n    def put(self, key: int, value: int):\n        if key in self.cache:\n            self.cache.move_to_end(key, last=True)\n        elif len(self.cache) &gt;= self.cap:\n            self.cache.popitem(last=False)\n\n        self.cache[key] = value\n\n\ncache = LRUCache(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\n\ncache = LRUCacheOrderedDict(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\nprint(\"LRU Cache passed\")\nprint(\"LRU Cache Ordered Dict passed\")\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nclass Node {\n   public:\n    int key;\n    int val;\n    Node *prev;\n    Node *next;\n\n    Node(int k = 0, int v = 0) : key(k), val(v), prev(nullptr), next(nullptr) {}\n};\n\nclass LRUCache {\n   private:\n    int cap;\n    unordered_map&lt;int, Node *&gt; cache;\n    Node *head;\n    Node *tail;\n\n    void remove(Node *node) {\n        node-&gt;prev-&gt;next = node-&gt;next;\n        node-&gt;next-&gt;prev = node-&gt;prev;\n    }\n\n    void insert_to_last(Node *node) {\n        tail-&gt;prev-&gt;next = node;\n        node-&gt;prev = tail-&gt;prev;\n        tail-&gt;prev = node;\n        node-&gt;next = tail;\n    }\n\n    void move_to_last(Node *node) {\n        remove(node);\n        insert_to_last(node);\n    }\n\n   public:\n    LRUCache(int capacity) {\n        this-&gt;cap = capacity;\n        head = new Node();\n        tail = new Node();\n        head-&gt;next = tail;\n        tail-&gt;prev = head;\n    }\n\n    int get(int key) {\n        if (cache.find(key) != cache.end()) {\n            Node *node = cache[key];\n            move_to_last(node);\n            return node-&gt;val;\n        }\n        return -1;\n    }\n\n    void put(int key, int value) {\n        if (cache.find(key) != cache.end()) {\n            Node *node = cache[key];\n            node-&gt;val = value;\n            move_to_last(node);\n        } else {\n            Node *newNode = new Node(key, value);\n            cache[key] = newNode;\n            insert_to_last(newNode);\n\n            if ((int)cache.size() &gt; cap) {\n                Node *removed = head-&gt;next;\n                remove(removed);\n                cache.erase(removed-&gt;key);\n                delete removed;\n            }\n        }\n    }\n};\n\nint main() {\n    LRUCache lru(2);\n    lru.put(1, 1);\n    lru.put(2, 2);\n    assert(lru.get(1) == 1);   // returns 1\n    lru.put(3, 3);             // evicts key 2\n    assert(lru.get(2) == -1);  // returns -1 (not found)\n    lru.put(4, 4);             // evicts key 1\n    assert(lru.get(1) == -1);  // returns -1 (not found)\n    assert(lru.get(3) == 3);   // returns 3\n    assert(lru.get(4) == 4);   // returns 4\n    return 0;\n}\n</code></pre>"},{"location":"neetcode-150/linked_list/#23-merge-k-sorted-lists","title":"23. Merge k Sorted Lists","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Divide And Conquer, Heap Priority Queue, Merge Sort</p> </li> </ul> Python <pre><code>\"\"\"\n-   Prerequisite: 21. Merge Two Sorted Lists\n-   Video explanation: [23. Merge K Sorted Lists - NeetCode](https://youtu.be/q5a5OiGbT6Q?si=SQ2dCvsYQ3LQctPh)\n\"\"\"\n\nimport copy\nimport heapq\nfrom typing import List, Optional\n\nfrom leetpattern.utils import ListNode, list_from_array, list_to_array\n\n\ndef merge_k_lists_divide_conquer(\n    lists: List[Optional[ListNode]],\n) -&gt; Optional[ListNode]:\n    if not lists or len(lists) == 0:\n        return None\n\n    def mergeTwo(l1, l2):\n        dummy = ListNode()\n        cur = dummy\n\n        while l1 and l2:\n            if l1.val &lt; l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n\n            cur = cur.next\n\n        cur.next = l1 if l1 else l2\n\n        return dummy.next\n\n    while len(lists) &gt; 1:\n        merged = []\n\n        for i in range(0, len(lists), 2):\n            l1 = lists[i]\n            l2 = lists[i + 1] if i + 1 &lt; len(lists) else None\n            merged.append(mergeTwo(l1, l2))\n\n        lists = merged\n\n    return lists[0]\n\n\ndef merge_k_lists_heap(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    min_heap = []  # (val, idx, node)\n\n    for idx, head in enumerate(lists):\n        if head:\n            heapq.heappush(min_heap, (head.val, idx, head))\n\n    while min_heap:\n        _, idx, node = heapq.heappop(min_heap)\n        cur.next = node\n        cur = cur.next\n\n        node = node.next\n        if node:\n            heapq.heappush(min_heap, (node.val, idx, node))\n\n    return dummy.next\n\n\ndef test_merge_k_lists() -&gt; None:\n    n1 = list_from_array([1, 4])\n    n2 = list_from_array([1, 3])\n    n3 = list_from_array([2, 6])\n    lists = [n1, n2, n3]\n    lists1 = copy.deepcopy(lists)\n    lists2 = copy.deepcopy(lists)\n    assert (list_to_array(merge_k_lists_divide_conquer(lists1))) == [\n        1,\n        1,\n        2,\n        3,\n        4,\n        6,\n    ]\n    assert (list_to_array(merge_k_lists_heap(lists2))) == [1, 1, 2, 3, 4, 6]\n</code></pre>"},{"location":"neetcode-150/linked_list/#25-reverse-nodes-in-k-group","title":"25. Reverse Nodes in k-Group","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Recursion</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom leetpattern.utils import ListNode, list_from_array, list_to_array\n\n\n# Linked List\ndef reverse_k_group(head: Optional[ListNode], k: int) -&gt; Optional[ListNode]:\n    n = 0\n    cur = head\n    while cur:\n        n += 1\n        cur = cur.next\n\n    p0 = dummy = ListNode(next=head)\n    pre = None\n    cur = head\n\n    while n &gt;= k:\n        n -= k\n        for _ in range(k):\n            nxt = cur.next\n            cur.next = pre\n            pre = cur\n            cur = nxt\n\n        nxt = p0.next\n        nxt.next = cur\n        p0.next = pre\n        p0 = nxt\n\n    return dummy.next\n\n\ndef test_reverse_k_group():\n    head = list_from_array([1, 2, 3, 4, 5])\n    assert list_to_array(reverse_k_group(head, 2)) == [2, 1, 4, 3, 5]\n</code></pre>"},{"location":"neetcode-150/math_geometry/","title":"Math Geometry","text":""},{"location":"neetcode-150/math_geometry/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 48. Rotate Image (Medium)</li> <li> 54. Spiral Matrix (Medium)</li> <li> 73. Set Matrix Zeroes (Medium)</li> <li> 202. Happy Number (Easy)</li> <li> 66. Plus One (Easy)</li> <li> 50. Pow(x, n) (Medium)</li> <li> 43. Multiply Strings (Medium)</li> <li> 166. Fraction to Recurring Decimal (Medium)</li> </ul>"},{"location":"neetcode-150/math_geometry/#48-rotate-image","title":"48. Rotate Image","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Matrix</p> </li> </ul> Python <pre><code>from copy import deepcopy\nfrom typing import List\n\n\n# Math\ndef rotate1(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    n = len(matrix)\n\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n\n\ndef rotate2(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    n = len(matrix)\n    for i in range(n):\n        for j in range(i, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\n    for i in range(n):\n        matrix[i].reverse()\n\n\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nprint(matrix)\n# [[1, 2, 3],\n#  [4, 5, 6],\n#  [7, 8, 9]]\nmatrix1 = deepcopy(matrix)\nrotate1(matrix1)\nprint(matrix1)\n# [[7, 4, 1],\n#  [8, 5, 2],\n#  [9, 6, 3]]\nmatrix2 = deepcopy(matrix)\nrotate2(matrix2)\nprint(matrix2)\n# [[7, 4, 1],\n#  [8, 5, 2],\n#  [9, 6, 3]]\n</code></pre>"},{"location":"neetcode-150/math_geometry/#54-spiral-matrix","title":"54. Spiral Matrix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Matrix, Simulation</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return all elements of the matrix in spiral order.\n\"\"\"\n\nfrom typing import List\n\n\n# Array\ndef spiralOrder(matrix: List[List[int]]) -&gt; List[int]:\n    if not matrix or not matrix[0]:\n        return []\n\n    res = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n\n    while top &lt;= bottom and left &lt;= right:\n\n        for i in range(left, right + 1):\n            res.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            res.append(matrix[i][right])\n        right -= 1\n\n        if top &lt;= bottom:\n\n            for i in range(right, left - 1, -1):\n                res.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left &lt;= right:\n\n            for i in range(bottom, top - 1, -1):\n                res.append(matrix[i][left])\n            left += 1\n\n    return res\n\n\n# Math\ndef spiralOrderMath(matrix: List[List[int]]) -&gt; List[int]:\n    dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]]  # Right Down Left Up\n    m, n = len(matrix), len(matrix[0])\n    size = m * n\n    res = []\n    i, j, di = 0, -1, 0\n\n    while len(res) &lt; size:\n        dx, dy = dirs[di]\n        for _ in range(n):\n            i += dx\n            j += dy\n            res.append(matrix[i][j])\n        di = (di + 1) % 4\n        n, m = m - 1, n\n\n    return res\n\n\nprint(spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n# [1, 2, 3, 6, 9, 8, 7, 4, 5]\nprint(spiralOrderMath([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]))\n# [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]\n</code></pre>"},{"location":"neetcode-150/math_geometry/#73-set-matrix-zeroes","title":"73. Set Matrix Zeroes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Matrix</p> </li> </ul> Python <pre><code>from copy import deepcopy\nfrom typing import List\n\n\nclass setZeroes:\n    @staticmethod\n    def matrix(matrix: List[List[int]]) -&gt; None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        # prep\n        m, n = len(matrix), len(matrix[0])\n        rows, cols = set(), set()\n\n        # collect rows and cols\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    rows.add(i)\n                    cols.add(j)\n\n        # work on rows and cols\n        for i in rows:\n            for j in range(n):\n                matrix[i][j] = 0\n\n        for i in range(m):\n            for j in cols:\n                matrix[i][j] = 0\n\n\nif __name__ == \"__main__\":\n    matrix = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]\n    setZeroes.matrix(matrix)\n    assert matrix == [[1, 0, 1], [0, 0, 0], [1, 0, 1]]\n</code></pre>"},{"location":"neetcode-150/math_geometry/#202-happy-number","title":"202. Happy Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Math, Two Pointers</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return `True` if the number is a happy number, otherwise, return `False`.\n-   A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.\n\"\"\"\n\n\ndef isHappy(n: int) -&gt; bool:\n\n    def getSum(n):\n        sum_of_squares = 0\n        while n:\n            a, b = divmod(n, 10)\n            sum_of_squares += b**2\n            n = a\n        return sum_of_squares\n\n    record = set()\n\n    while True:\n        if n == 1:\n            return True\n\n        if n in record:\n            return False\n        else:\n            record.add(n)\n\n        n = getSum(n)\n\n\nn = 19\nprint(isHappy(n))  # True\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;unordered_set&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int getNext(int n) {\n        int res = 0;\n        while (n) {\n            int mod = n % 10;\n            res += mod * mod;\n            n /= 10;\n        }\n        return res;\n    }\n\n    bool isHappy(int n) {\n        unordered_set&lt;int&gt; seen;\n        while (n != 1) {\n            n = getNext(n);\n            if (seen.find(n) != seen.end()) return false;\n            seen.insert(n);\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution s;\n    assert(s.isHappy(19) == true);\n    assert(s.isHappy(2) == false);\n    return 0;\n}\n</code></pre>"},{"location":"neetcode-150/math_geometry/#66-plus-one","title":"66. Plus One","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\n# Math\ndef plusOne(digits: List[int]) -&gt; List[int]:\n    n = len(digits)\n\n    for i in range(n - 1, -1, -1):\n        if digits[i] &lt; 9:\n            digits[i] += 1\n            return digits\n        else:\n            digits[i] = 0\n\n    return [1] + digits\n\n\ndigits = [4, 3, 2, 1]\nprint(plusOne(digits))  # [4, 3, 2, 2]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) {\n        for (int i = digits.size() - 1; i &gt;= 0; i--) {\n            digits[i]++;\n            if (digits[i] == 10)\n                digits[i] = 0;\n            else\n                return digits;\n        }\n        digits.insert(digits.begin(), 1);\n        return digits;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; digits;\n    digits = {4, 3, 2, 1};\n    assert((solution.plusOne(digits) == vector&lt;int&gt;{4, 3, 2, 2}));\n    return 0;\n}\n</code></pre>"},{"location":"neetcode-150/math_geometry/#50-powx-n","title":"50. Pow(x, n)","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Recursion</p> </li> </ul> Python <pre><code># Iterative\ndef myPowIterative(x: float, n: int) -&gt; float:\n    if n == 0:\n        return 1\n    if n &lt; 0:\n        x = 1 / x\n        n = -n\n\n    result = 1\n    cur = x\n\n    while n &gt; 0:\n        if n % 2 == 1:\n            result *= cur\n\n        cur *= cur\n        n //= 2\n\n    return result\n\n\n# Recursive\ndef myPowRecursive(x: float, n: int) -&gt; float:\n    if n == 0:\n        return 1\n    if n &lt; 0:\n        x = 1 / x\n        n = -n\n\n    if n % 2 == 0:\n        return myPowRecursive(x * x, n // 2)\n    else:\n        return x * myPowRecursive(x * x, n // 2)\n\n\nx = 2.00000\nn = 10\nprint(myPowIterative(x, n))  # 1024.0\nprint(myPowRecursive(x, n))  # 1024.0\n</code></pre>"},{"location":"neetcode-150/math_geometry/#43-multiply-strings","title":"43. Multiply Strings","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String, Simulation</p> </li> </ul> Python <pre><code># Math\ndef multiply(num1: str, num2: str) -&gt; str:\n    if num1 == \"0\" or num2 == \"0\":\n        return \"0\"\n\n    m, n = len(num1), len(num2)\n    result = [0 for _ in range(m + n)]\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            mul = int(num1[i]) * int(num2[j])\n            sum = mul + result[i + j + 1]\n\n            result[i + j + 1] = sum % 10\n            result[i + j] += sum // 10\n\n    result_str = \"\".join(map(str, result)).lstrip(\"0\")\n\n    return result_str if result_str else \"0\"\n\n\nnum1 = \"2\"\nnum2 = \"3\"\nprint(multiply(num1, num2))  # \"6\"\n</code></pre>"},{"location":"neetcode-150/math_geometry/#166-fraction-to-recurring-decimal","title":"166. Fraction to Recurring Decimal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Math, String</p> </li> </ul> Python <pre><code># Math\ndef fractionToDecimal(numerator: int, denominator: int) -&gt; str:\n    if numerator == 0:\n        return \"0\"\n\n    res = []\n\n    if (numerator &lt; 0) ^ (denominator &lt; 0):\n        res.append(\"-\")\n\n    numerator, denominator = abs(numerator), abs(denominator)\n\n    # Integer part\n    res.append(str(numerator // denominator))\n    remainder = numerator % denominator\n\n    if remainder == 0:\n        return \"\".join(res)\n\n    res.append(\".\")\n\n    # Dictionary to store remainders and their corresponding indices\n    remainder_map = {}\n\n    while remainder != 0:\n        if remainder in remainder_map:\n            res.insert(remainder_map[remainder], \"(\")\n            res.append(\")\")\n            break\n\n        remainder_map[remainder] = len(res)\n        remainder *= 10\n        res.append(str(remainder // denominator))\n        remainder %= denominator\n\n    return \"\".join(res)\n\n\nnumerator = 4\ndenominator = 333\nprint(fractionToDecimal(numerator, denominator))  # 0.(012)\n</code></pre>"},{"location":"neetcode-150/sliding_window/","title":"Sliding Window","text":""},{"location":"neetcode-150/sliding_window/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 121. Best Time to Buy and Sell Stock (Easy)</li> <li> 3. Longest Substring Without Repeating Characters (Medium)</li> <li> 424. Longest Repeating Character Replacement (Medium)</li> <li> 76. Minimum Window Substring (Hard)</li> <li> 567. Permutation in String (Medium)</li> <li> 239. Sliding Window Maximum (Hard)</li> </ul>"},{"location":"neetcode-150/sliding_window/#121-best-time-to-buy-and-sell-stock","title":"121. Best Time to Buy and Sell Stock","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return the maximum profit that can be achieved from buying on one day and selling on another day.\n\"\"\"\n\nfrom typing import List\n\n\n# Brute Force\ndef maxProfitBF(prices: List[int]) -&gt; int:\n    max_profit = 0\n    n = len(prices)\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_profit = max(max_profit, prices[j] - prices[i])\n\n    return max_profit\n\n\n# DP\ndef maxProfitDP(prices: List[int]) -&gt; int:\n    dp = [[0] * 2 for _ in range(len(prices))]\n    dp[0][0] = -prices[0]  # buy\n    dp[0][1] = 0  # sell\n\n    for i in range(1, len(prices)):\n        dp[i][0] = max(dp[i - 1][0], -prices[i])  # the lowest price to buy\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    max_profit = 0\n    seen_min = prices[0]\n\n    for i in range(1, len(prices)):\n        max_profit = max(max_profit, prices[i] - seen_min)\n        seen_min = min(seen_min, prices[i])\n\n    return max_profit\n\n\n# Fast Slow Pointers\ndef maxProfitFS(prices: List[int]) -&gt; int:\n    max_profit = 0\n    slow, fast = 0, 1\n\n    while fast &lt; len(prices):\n        if prices[fast] &gt; prices[slow]:\n            max_profit = max(max_profit, prices[fast] - prices[slow])\n        else:\n            slow = fast\n        fast += 1\n\n    return max_profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force|  O(n^2)|  O(1)   |\n# | DP         |  O(n)  |  O(n)   |\n# | Greedy     |  O(n)  |  O(1)   |\n# | Fast Slow  |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitBF(prices))  # 5\nprint(maxProfitDP(prices))  # 5\nprint(maxProfitGreedy(prices))  # 5\nprint(maxProfitFS(prices))  # 5\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int maxProfitMemo(vector&lt;int&gt; &amp;prices) {\n        if (prices.size() &lt;= 1) return 0;\n\n        int seen_min = prices[0];\n        int res = 0;\n\n        for (int &amp;price : prices) {\n            res = max(res, price - seen_min);\n            seen_min = min(seen_min, price);\n        }\n        return res;\n    }\n};\n\nint main() {\n    vector&lt;int&gt; prices = {7, 1, 5, 3, 6, 4};\n    Solution obj;\n    cout &lt;&lt; obj.maxProfitMemo(prices) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"neetcode-150/sliding_window/#3-longest-substring-without-repeating-characters","title":"3. Longest Substring Without Repeating Characters","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Classic variable sliding window problem. Use a set to keep track of the characters in the current window.\n- Return the length of the longest substring without repeating characters.\n- [Template tutorial by \u7075\u5c71\u8336\u827e\u5e9c](https://leetcode.cn/problems/longest-substring-without-repeating-characters/solutions/1959540/xia-biao-zong-suan-cuo-qing-kan-zhe-by-e-iaks)\n\"\"\"\n\nfrom collections import defaultdict\n\n\n# Sliding Window Variable Max - HashMap\ndef lengthOfLongestSubstringHash(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    left = 0\n    cnt = defaultdict(int)\n    res = 0\n\n    for right in range(n):\n        cnt[s[right]] += 1\n\n        while cnt[s[right]] &gt; 1:\n            cnt[s[left]] -= 1\n            left += 1\n\n        res = max(res, right - left + 1)\n\n    return res\n\n\n# Sliding Window Variable Max - Set\ndef lengthOfLongestSubstringSet(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    left = 0\n    res = 0\n    window = set()\n\n    for right in range(n):\n        while left &lt; right and s[right] in window:\n            window.remove(s[left])\n            left += 1\n        window.add(s[right])\n        res = max(res, right - left + 1)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    s = \"abcabcbb\"\n    assert lengthOfLongestSubstringHash(s) == 3\n    assert lengthOfLongestSubstringSet(s) == 3\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;unordered_set&gt;\nusing namespace std;\n\nint lengthOfLongestSubstring(string s) {\n    int n = s.length();\n    int res = 0;\n    int left = 0;\n    unordered_set&lt;char&gt; window;\n\n    for (int right = 0; right &lt; n; right++) {\n        char ch = s[right];\n\n        while (window.find(ch) != window.end()) {\n            window.erase(s[left]);\n            left++;\n        }\n\n        window.insert(ch);\n        res = max(res, right - left + 1);\n    }\n    return (int)res;\n}\n\nint main() {\n    string s = \"abcabcbb\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 3\n    s = \"bbbbb\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 1\n    s = \"pwwkew\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 3\n    return 0;\n}\n</code></pre>"},{"location":"neetcode-150/sliding_window/#424-longest-repeating-character-replacement","title":"424. Longest Repeating Character Replacement","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> Python <pre><code>from collections import defaultdict\n\n\n# Sliding Window - Variable\ndef characterReplacement(s: str, k: int) -&gt; int:\n    left = 0\n    maxCount = 0\n    counts = defaultdict(int)\n    maxLen = 0\n\n    for right in range(len(s)):\n        counts[s[right]] += 1\n        maxCount = max(maxCount, counts[s[right]])\n\n        while right - left + 1 - maxCount &gt; k:\n            counts[s[left]] -= 1\n            left += 1\n\n        maxLen = max(maxLen, right - left + 1)\n\n    return maxLen\n\n\ns = \"ABAB\"\nk = 2\nprint(characterReplacement(s, k))  # 4\n</code></pre>"},{"location":"neetcode-150/sliding_window/#76-minimum-window-substring","title":"76. Minimum Window Substring","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> Python <pre><code>from collections import Counter\n\n\ndef minWindow(s: str, t: str) -&gt; str:\n    if not t or not s:\n        return \"\"\n\n    counts = Counter(t)\n    required = len(counts)\n\n    left, right = 0, 0\n    formed = 0\n    window_counts = dict()\n\n    result = float(\"inf\"), None, None\n\n    while right &lt; len(s):\n        char = s[right]\n        window_counts[char] = window_counts.get(char, 0) + 1\n        if char in counts and window_counts[char] == counts[char]:\n            formed += 1\n\n        while left &lt;= right and formed == required:\n            char = s[left]\n            if right - left + 1 &lt; result[0]:\n                result = (right - left + 1, left, right)\n            window_counts[char] -= 1\n            if char in counts and window_counts[char] &lt; counts[char]:\n                formed -= 1\n            left += 1\n\n        right += 1\n\n    return \"\" if result[0] == float(\"inf\") else s[result[1] : result[2] + 1]\n\n\ns = \"ADOBECODEBANC\"\nt = \"ABC\"\nprint(minWindow(s, t))  # BANC\n</code></pre>"},{"location":"neetcode-150/sliding_window/#567-permutation-in-string","title":"567. Permutation in String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Two Pointers, String, Sliding Window</p> </li> </ul> Python <pre><code>def checkInclusion(s1: str, s2: str) -&gt; bool:\n    if len(s1) &gt; len(s2):\n        return False\n\n    count1 = [0] * 26\n    count2 = [0] * 26\n\n    for i in range(len(s1)):\n        count1[ord(s1[i]) - ord(\"a\")] += 1\n        count2[ord(s2[i]) - ord(\"a\")] += 1\n\n    matches = 0\n    for i in range(26):\n        if count1[i] == count2[i]:\n            matches += 1\n\n    l = 0\n    for r in range(len(s1), len(s2)):\n        if matches == 26:\n            return True\n\n        index = ord(s2[r]) - ord(\"a\")\n        count2[index] += 1\n        if count1[index] == count2[index]:\n            matches += 1\n        elif count1[index] + 1 == count2[index]:\n            matches -= 1\n\n        index = ord(s2[l]) - ord(\"a\")\n        count2[index] -= 1\n        if count1[index] == count2[index]:\n            matches += 1\n        elif count1[index] - 1 == count2[index]:\n            matches -= 1\n\n        l += 1\n\n    return matches == 26\n\n\ns1 = \"ab\"\ns2 = \"eidba\"\nprint(checkInclusion(s1, s2))  # True\n</code></pre>"},{"location":"neetcode-150/sliding_window/#239-sliding-window-maximum","title":"239. Sliding Window Maximum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Queue, Sliding Window, Heap Priority Queue, Monotonic Queue</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# Monotonic Queue\ndef maxSlidingWindow(nums: List[int], k: int) -&gt; List[int]:\n    q = deque()\n    res = []\n\n    for i, num in enumerate(nums):\n        if q and q[0] &lt; i - k + 1:\n            q.popleft()\n\n        while q and nums[q[-1]] &lt; num:\n            q.pop()\n\n        q.append(i)\n\n        if i &gt;= k - 1:\n            res.append(nums[q[0]])\n\n    return res\n\n\nnums = [1, 3, -1, -3, 5, 3, 6, 7]\nk = 3\nprint(maxSlidingWindow(nums, k))  # [3, 3, 5, 5, 6, 7]\n</code></pre>"},{"location":"neetcode-150/stack/","title":"Stack","text":""},{"location":"neetcode-150/stack/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 20. Valid Parentheses (Easy)</li> <li> 155. Min Stack (Medium)</li> <li> 150. Evaluate Reverse Polish Notation (Medium)</li> <li> 22. Generate Parentheses (Medium)</li> <li> 739. Daily Temperatures (Medium)</li> <li> 853. Car Fleet (Medium)</li> <li> 84. Largest Rectangle in Histogram (Hard)</li> </ul>"},{"location":"neetcode-150/stack/#20-valid-parentheses","title":"20. Valid Parentheses","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack</p> </li> </ul> PythonCPP <pre><code># Stack\ndef is_valid(s: str) -&gt; bool:\n    if len(s) % 2:\n        return False\n\n    pairs = {\n        \"(\": \")\",\n        \"{\": \"}\",\n        \"[\": \"]\",\n    }\n    stack = []\n    for ch in s:\n        if ch in pairs:\n            stack.append(ch)\n        elif not stack or ch != pairs[stack.pop()]:\n            return False\n\n    return True if not stack else False\n\n\ndef test_is_valid():\n    assert is_valid(\"()[]{}\")\n    assert not is_valid(\"(]\")\n    assert not is_valid(\"([)]\")\n    assert is_valid(\"{[]}\")\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;stack&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool isValid(string s) {\n        unordered_map&lt;char, char&gt; map{{')', '('}, {'}', '{'}, {']', '['}};\n        stack&lt;char&gt; stack;\n        if (s.length() % 2 == 1) return false;\n\n        for (char&amp; ch : s) {\n            if (stack.empty() || map.find(ch) == map.end()) {\n                stack.push(ch);\n            } else {\n                if (map[ch] != stack.top()) {\n                    return false;\n                }\n                stack.pop();\n            }\n        }\n        return stack.empty();\n    }\n};\n\nint main() {\n    Solution s;\n    assert(s.isValid(\"()\") == true);\n    assert(s.isValid(\"()[]{}\") == true);\n    assert(s.isValid(\"(]\") == false);\n    assert(s.isValid(\"([)]\") == false);\n    assert(s.isValid(\"{[]}\") == true);\n    return 0;\n}\n</code></pre>"},{"location":"neetcode-150/stack/#155-min-stack","title":"155. Min Stack","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Stack, Design</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Implement a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\"\"\"\n\n\n# Stack\nclass MinStack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, val: int) -&gt; None:\n        if self.stack:\n            self.stack.append((val, min(val, self.getMin())))\n        else:\n            self.stack.append((val, val))\n\n    def pop(self) -&gt; None:\n        self.stack.pop()\n\n    def top(self) -&gt; int:\n        return self.stack[-1][0]\n\n    def getMin(self) -&gt; int:\n        return self.stack[-1][1]\n\n\nobj = MinStack()\nobj.push(3)\nobj.push(2)\nobj.pop()\nprint(obj.top())  # 3\nprint(obj.getMin())  # 3\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;climits&gt;\n#include &lt;iostream&gt;\n#include &lt;stack&gt;\n#include &lt;utility&gt;\nusing namespace std;\n\nclass MinStack {\n    stack&lt;pair&lt;int, int&gt;&gt; st;\n\n   public:\n    MinStack() { st.emplace(0, INT_MAX); }\n\n    void push(int val) { st.emplace(val, min(getMin(), val)); }\n\n    void pop() { st.pop(); }\n\n    int top() { return st.top().first; }\n\n    int getMin() { return st.top().second; }\n};\n\nint main() {\n    MinStack minStack;\n    minStack.push(-2);\n    minStack.push(0);\n    minStack.push(-3);\n    cout &lt;&lt; minStack.getMin() &lt;&lt; endl;  // -3\n    minStack.pop();\n    cout &lt;&lt; minStack.top() &lt;&lt; endl;     // 0\n    cout &lt;&lt; minStack.getMin() &lt;&lt; endl;  // -2\n    return 0;\n}\n</code></pre>"},{"location":"neetcode-150/stack/#150-evaluate-reverse-polish-notation","title":"150. Evaluate Reverse Polish Notation","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Stack</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Stack\ndef evalRPN(tokens: List[str]) -&gt; int:\n    stack = []\n\n    for c in tokens:\n        if c == \"+\":\n            stack.append(stack.pop() + stack.pop())\n        elif c == \"-\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(b - a)\n        elif c == \"*\":\n            stack.append(stack.pop() * stack.pop())\n        elif c == \"/\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(int(b / a))\n        else:\n            stack.append(int(c))\n\n    return stack[0]\n\n\ndef test_evalRPN():\n    print(evalRPN([\"2\", \"1\", \"+\", \"3\", \"*\"]))  # 9\n    print(evalRPN([\"4\", \"13\", \"5\", \"/\", \"-\"]))  # 2\n    print(evalRPN([\"18\"]))  # 18\n    print(evalRPN([\"4\", \"3\", \"-\"]))  # 1\n</code></pre>"},{"location":"neetcode-150/stack/#22-generate-parentheses","title":"22. Generate Parentheses","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Backtracking</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Backtracking\ndef generateParenthesis1(n: int) -&gt; List[str]:\n    path, res = [], []\n\n    def dfs(openN, closeN):\n        if openN == closeN == n:\n            res.append(\"\".join(path))\n            return\n\n        if openN &lt; n:\n            path.append(\"(\")\n            dfs(openN + 1, closeN)\n            path.pop()\n\n        if closeN &lt; openN:\n            path.append(\")\")\n            dfs(openN, closeN + 1)\n            path.pop()\n\n    dfs(0, 0)\n\n    return res\n\n\n# Backtracking\ndef generateParenthesis2(n: int) -&gt; List[str]:\n    m = n * 2\n    res, path = [], [\"\"] * m\n\n    def dfs(i, left):\n        if i == m:\n            res.append(\"\".join(path))\n            return\n\n        if left &lt; n:\n            path[i] = \"(\"\n            dfs(i + 1, left + 1)\n        if i - left &lt; left:\n            path[i] = \")\"\n            dfs(i + 1, left)\n\n    dfs(0, 0)\n    return res\n\n\nif __name__ == \"__main__\":\n    print(generateParenthesis1(3))\n    # ['((()))', '(()())', '(())()', '()(())', '()()()']\n    print(generateParenthesis2(3))\n    # ['((()))', '(()())', '(())()', '()(())', '()()()']\n</code></pre>"},{"location":"neetcode-150/stack/#739-daily-temperatures","title":"739. Daily Temperatures","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Stack, Monotonic Stack</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return an array `res` such that `res[i]` is the number of days you have to wait after the `ith` day to get a warmer temperature.\n\n| Index | Temp | &gt; stack last | stack                           | result    |\n| ----- | ---- | ------------ | ------------------------------- | --------- |\n| 0     | 73   | False        | `[ [73, 0] ]`                   | 1 - 0 = 1 |\n| 1     | 74   | True         | `[ [74, 1] ]`                   | 2 - 1 = 1 |\n| 2     | 75   | True         | `[ [75, 2] ]`                   | 6 - 2 = 4 |\n| 3     | 71   | False        | `[ [75, 2], [71, 3] ]`          | 5 - 3 = 2 |\n| 4     | 69   | False        | `[ [75, 2], [71, 3], [69, 4] ]` | 5 - 4 = 1 |\n| 5     | 72   | True         | `[ [75, 2], [72, 5] ]`          | 6 - 5 = 1 |\n| 6     | 76   | True         | `[ [76, 6] ]`                   | 0         |\n| 7     | 73   | False        | `[[76, 6], [73, 7]]`            | 0         |\n\"\"\"\n\nfrom typing import List\n\n\n# Monotonic Stack\ndef dailyTemperatures(temperatures: List[int]) -&gt; List[int]:\n    res = [0 for _ in range(len(temperatures))]\n    stack = []  # [temp, index]\n\n    for i, temp in enumerate(temperatures):\n        while stack and temp &gt; stack[-1][0]:\n            _, idx = stack.pop()\n            res[idx] = i - idx\n\n        stack.append([temp, i])\n\n    return res\n\n\nprint(dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73]))\n# [1, 1, 4, 2, 1, 1, 0, 0]\n</code></pre>"},{"location":"neetcode-150/stack/#853-car-fleet","title":"853. Car Fleet","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Stack, Sorting, Monotonic Stack</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Stack\ndef carFleet(target: int, position: List[int], speed: List[int]) -&gt; int:\n    cars = sorted(zip(position, speed), reverse=True)\n    stack = []\n\n    for p, s in cars:\n        time = (target - p) / s\n\n        if not stack or time &gt; stack[-1]:\n            stack.append(time)\n\n    return len(stack)\n\n\nprint(carFleet(12, [10, 8, 0, 5, 3], [2, 4, 1, 1, 3]))  # 3\n</code></pre>"},{"location":"neetcode-150/stack/#84-largest-rectangle-in-histogram","title":"84. Largest Rectangle in Histogram","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Stack, Monotonic Stack</p> </li> </ul> Python <pre><code>from typing import List\n\n\nclass LargestRectangleArea:\n    def monotonic_stack(self, heights: List[int]) -&gt; int:\n        stack = []\n        res = 0\n        n = len(heights)\n\n        for i in range(n + 1):\n            h = heights[i] if i &lt; n else 0\n\n            while stack and h &lt; heights[stack[-1]]:\n                height = heights[stack.pop()]\n                width = i if not stack else i - stack[-1] - 1\n                res = max(res, height * width)\n\n            stack.append(i)\n\n        return res\n\n\nif __name__ == \"__main__\":\n    sol = LargestRectangleArea()\n    assert sol.monotonic_stack([2, 1, 5, 6, 2, 3]) == 10\n    assert sol.monotonic_stack([2, 4]) == 4\n</code></pre>"},{"location":"neetcode-150/trees/","title":"Trees","text":""},{"location":"neetcode-150/trees/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 226. Invert Binary Tree (Easy)</li> <li> 104. Maximum Depth of Binary Tree (Easy)</li> <li> 543. Diameter of Binary Tree (Easy)</li> <li> 110. Balanced Binary Tree (Easy)</li> <li> 100. Same Tree (Easy)</li> <li> 572. Subtree of Another Tree (Easy)</li> <li> 235. Lowest Common Ancestor of a Binary Search Tree (Medium)</li> <li> 102. Binary Tree Level Order Traversal (Medium)</li> <li> 199. Binary Tree Right Side View (Medium)</li> <li> 1448. Count Good Nodes in Binary Tree (Medium)</li> <li> 98. Validate Binary Search Tree (Medium)</li> <li> 230. Kth Smallest Element in a BST (Medium)</li> <li> 105. Construct Binary Tree from Preorder and Inorder Traversal (Medium)</li> <li> 124. Binary Tree Maximum Path Sum (Hard)</li> <li> 297. Serialize and Deserialize Binary Tree (Hard)</li> </ul>"},{"location":"neetcode-150/trees/#226-invert-binary-tree","title":"226. Invert Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef invertTreeRecursive(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    root.left, root.right = root.right, root.left\n\n    invertTreeRecursive(root.left)\n    invertTreeRecursive(root.right)\n\n    return root\n\n\n# Iterative\ndef invertTreeIterative(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    stack = [root]\n\n    while stack:\n        node = stack.pop()\n\n        node.left, node.right = node.right, node.left\n        if node.left:\n            stack.append(node.left)\n        if node.right:\n            stack.append(node.right)\n\n    return root\n\n\nroot = build([4, 2, 7, 1, 3, 6, 9])\nprint(root)\n#     __4__\n#    /     \\\n#   2       7\n#  / \\     / \\\n# 1   3   6   9\ninvertedRecursive = invertTreeRecursive(root)\nprint(invertedRecursive)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\nroot = build([4, 2, 7, 1, 3, 6, 9])\ninvertedIterative = invertTreeIterative(root)\nprint(invertedIterative)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\n</code></pre>"},{"location":"neetcode-150/trees/#104-maximum-depth-of-binary-tree","title":"104. Maximum Depth of Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef maxDepthRecursive(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    left = maxDepthRecursive(root.left)\n    right = maxDepthRecursive(root.right)\n\n    return 1 + max(left, right)\n\n\n# DFS\ndef maxDepthDFS(root: Optional[TreeNode]) -&gt; int:\n    res = 0\n\n    def dfs(node, cnt):\n        if node is None:\n            return\n        cnt += 1\n        nonlocal res\n        res = max(res, cnt)\n\n        dfs(node.left, cnt)\n        dfs(node.right, cnt)\n\n    dfs(root, 0)\n\n    return res\n\n\n# Iterative\ndef maxDepthIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n    res = 0\n\n    while q:\n        res += 1\n        n = len(q)\n\n        for _ in range(n):\n            node = q.popleft()\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    root = [1, 2, 2, 3, 4, None, None, None, None, 5]\n    root = build(root)\n    print(root)\n    #     ____1\n    #    /     \\\n    #   2__     2\n    #  /   \\\n    # 3     4\n    #      /\n    #     5\n    assert maxDepthRecursive(root) == 4\n    assert maxDepthDFS(root) == 4\n    assert maxDepthIterative(root) == 4\n</code></pre>"},{"location":"neetcode-150/trees/#543-diameter-of-binary-tree","title":"543. Diameter of Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul> PythonCPP <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Tree DFS\nclass Solution:\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -&gt; int:\n        self.diameter = 0\n\n        def dfs(node):\n            if not node:\n                return 0\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n            self.diameter = max(self.diameter, left + right)\n\n            return 1 + max(left, right)\n\n        dfs(root)\n\n        return self.diameter\n\n\nroot = build([1, 2, 3, 4, 5])\nprint(root)\n#     __1\n#    /   \\\n#   2     3\n#  / \\\n# 4   5\nobj = Solution()\nprint(obj.diameterOfBinaryTree(root))  # 3\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nint diameterOfBinaryTree(TreeNode* root) {\n    int diameter = 0;\n\n    auto dfs = [&amp;](auto&amp;&amp; self, TreeNode* node) -&gt; int {\n        if (!node) return 0;\n        int left = self(self, node-&gt;left);\n        int right = self(self, node-&gt;right);\n\n        diameter = max(diameter, left + right);\n\n        return 1 + max(left, right);\n    };\n\n    dfs(dfs, root);\n    return diameter;\n}\n\nint main() {\n    // [1, 2, 3, 4, 5]\n    TreeNode* root = new TreeNode(1);\n    root-&gt;left = new TreeNode(2);\n    root-&gt;right = new TreeNode(3);\n    root-&gt;left-&gt;left = new TreeNode(4);\n    root-&gt;left-&gt;right = new TreeNode(5);\n    cout &lt;&lt; diameterOfBinaryTree(root) &lt;&lt; endl;  // 3\n\n    return 0;\n}\n</code></pre>"},{"location":"neetcode-150/trees/#110-balanced-binary-tree","title":"110. Balanced Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef isBalanced(root: Optional[TreeNode]) -&gt; bool:\n    def getHeight(node):\n        if not node:\n            return 0\n\n        # post order\n        leftHeight = getHeight(node.left)\n        rightHeight = getHeight(node.right)\n\n        if leftHeight == -1 or rightHeight == -1:\n            return -1\n\n        if abs(leftHeight - rightHeight) &gt; 1:\n            return -1\n        else:\n            return 1 + max(leftHeight, rightHeight)\n\n    if getHeight(root) != -1:\n        return True\n    else:\n        return False\n\n\nroot = [3, 9, 20, None, None, 15, 7]\nroot = build(root)\nprint(root)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(isBalanced(root))  # True\n</code></pre>"},{"location":"neetcode-150/trees/#100-same-tree","title":"100. Same Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# 1. Recursive\ndef isSameTreeRecursive(p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:\n    if not p and not q:\n        return True\n    elif not p or not q:\n        return False\n    elif p.val != q.val:\n        return False\n\n    return isSameTreeRecursive(p.left, q.left) and isSameTreeRecursive(p.right, q.right)\n\n\n# 2. Iterative with queue\ndef isSameTreeIterativeQueue(p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:\n    queue = deque([(p, q)])\n\n    while queue:\n        p, q = queue.popleft()\n\n        if not p and not q:\n            continue\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n\n        queue.append((p.left, q.left))\n        queue.append((p.right, q.right))\n\n    return True\n\n\n# 3. Iterative with stack\ndef isSameTreeIterativeStack(p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:\n    stack = [(p, q)]\n\n    while stack:\n        n1, n2 = stack.pop()\n\n        if not n1 and not n2:\n            continue\n        if not n1 or not n2:\n            return False\n        if n1.val != n2.val:\n            return False\n\n        stack.append((n1.left, n2.left))\n        stack.append((n1.right, n2.right))\n\n    return True\n\n\nif __name__ == \"__main__\":\n    p1 = build([1, 2, 3])\n    q1 = build([1, 2, 3])\n    p2 = build([1, 2])\n    q2 = build([1, None, 2])\n\n    assert isSameTreeRecursive(p1, q1) is True\n    assert isSameTreeRecursive(p2, q2) is False\n    assert isSameTreeIterativeQueue(p1, q1) is True\n    assert isSameTreeIterativeQueue(p2, q2) is False\n    assert isSameTreeIterativeStack(p1, q1) is True\n    assert isSameTreeIterativeStack(p2, q2) is False\n</code></pre>"},{"location":"neetcode-150/trees/#572-subtree-of-another-tree","title":"572. Subtree of Another Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, String Matching, Binary Tree, Hash Function</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# DFS - Tree\ndef isSubtree(root: Optional[TreeNode], subRoot: Optional[TreeNode]) -&gt; bool:\n    def isSameTree(p, q):\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n\n        return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)\n\n    if not root:\n        return False\n\n    return (\n        isSameTree(root, subRoot)\n        or isSubtree(root.left, subRoot)\n        or isSubtree(root.right, subRoot)\n    )\n\n\n# |------------|---------|----------|\n# | Approach   | Time    | Space    |\n# |------------|---------|----------|\n# | DFS        | O(n * m)| O(n)     |\n# |------------|---------|----------|\n\n\nroot = build([3, 4, 5, 1, 2, None, None, None, None, 0])\nsubRoot = build([4, 1, 2])\nprint(root)\n#     ____3\n#    /     \\\n#   4__     5\n#  /   \\\n# 1     2\n#      /\n#     0\nprint(subRoot)\n#   4\n#  / \\\n# 1   2\nprint(isSubtree(root, subRoot))  # False\n</code></pre>"},{"location":"neetcode-150/trees/#235-lowest-common-ancestor-of-a-binary-search-tree","title":"235. Lowest Common Ancestor of a Binary Search Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Search Tree, Binary Tree</p> </li> </ul> Python <pre><code>from binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef lowestCommonAncestor(root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\") -&gt; \"TreeNode\":\n    while root:\n        if root.val &gt; p.val and root.val &gt; q.val:\n            root = root.left\n        elif root.val &lt; p.val and root.val &lt; q.val:\n            root = root.right\n        else:\n            return root\n\n\nroot = [6, 2, 8, 0, 4, 7, 9, None, None, 3, 5]\nroot = build(root)\np = root.left\nq = root.right\nprint(root)\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\nprint(lowestCommonAncestor(root, p, q))\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\n</code></pre>"},{"location":"neetcode-150/trees/#102-binary-tree-level-order-traversal","title":"102. Binary Tree Level Order Traversal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef levelOrder(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        level = []\n        size = len(q)\n\n        for _ in range(size):\n            cur = q.popleft()\n            level.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(level)\n\n    return res\n\n\ntree = build([3, 9, 20, None, None, 15, 7])\nprint(tree)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(levelOrder(tree))  # [[3], [9, 20], [15, 7]]\n</code></pre>"},{"location":"neetcode-150/trees/#199-binary-tree-right-side-view","title":"199. Binary Tree Right Side View","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Binary Tree BFS\ndef rightSideViewBFS(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        n = len(q)\n        for i in range(n):\n            node = q.popleft()\n            if i == n - 1:\n                res.append(node.val)\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return res\n\n\n# Binary Tree DFS\ndef rightSideViewDFS(root: Optional[TreeNode]) -&gt; List[int]:\n    \"\"\"\u540e\u5e8f\u904d\u5386\uff0c\u5148\u53f3\u540e\u5de6\uff0c\u9047\u5230\u7684\u7b2c\u4e00\u4e2a\u8282\u70b9\u5c31\u662f\u8be5\u6df1\u5ea6\u7684\u6700\u53f3\u4fa7\u8282\u70b9\"\"\"\n    ans = []\n\n    def dfs(node, depth):\n        if node is None:\n            return\n        if depth == len(ans):  # \u8fd9\u4e2a\u6df1\u5ea6\u9996\u6b21\u9047\u5230\n            ans.append(node.val)\n\n        dfs(node.right, depth + 1)\n        dfs(node.left, depth + 1)\n\n    dfs(root, 0)\n\n    return ans\n\n\nif __name__ == \"__main__\":\n    root = [1, 2, 2, 3, 4, None, 3, None, None, 5]\n    root = build(root)\n    print(root)\n    #     ____1\n    #    /     \\\n    #   2__     2\n    #  /   \\     \\\n    # 3     4     3\n    #      /\n    #     5\n    assert rightSideViewBFS(root) == [1, 2, 3, 5]\n    assert rightSideViewDFS(root) == [1, 2, 3, 5]\n</code></pre>"},{"location":"neetcode-150/trees/#1448-count-good-nodes-in-binary-tree","title":"1448. Count Good Nodes in Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import List\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Tree\ndef goodNodes(root: TreeNode) -&gt; int:\n    def dfs(node, max_val):\n        if not node:\n            return 0\n\n        good = 1 if node.val &gt;= max_val else 0\n\n        max_val = max(max_val, node.val)\n\n        good += dfs(node.left, max_val)\n        good += dfs(node.right, max_val)\n\n        return good\n\n    return dfs(root, root.val)\n\n\nroot = build([3, 1, 4, 3, None, 1, 5])\nprint(root)\n#     3__\n#    /   \\\n#   1     4\n#  /     / \\\n# 3     1   5\nprint(goodNodes(root))  # 4\n</code></pre>"},{"location":"neetcode-150/trees/#98-validate-binary-search-tree","title":"98. Validate Binary Search Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Search Tree, Binary Tree</p> </li> </ul> PythonCPP <pre><code>from itertools import pairwise\nfrom math import inf\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef isValidBST1(root: Optional[TreeNode]) -&gt; bool:\n    inorder = []  # inorder traversal\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    for a, b in pairwise(inorder):\n        if a &gt;= b:\n            return False\n\n    return True\n\n\ndef isValidBST2(root: Optional[TreeNode]) -&gt; bool:\n    if not root:\n        return True\n    pre = -inf\n\n    def dfs(node):\n        if not node:\n            return True\n        if not dfs(node.left):\n            return False\n\n        nonlocal pre\n        if node.val &lt;= pre:\n            return False\n        pre = node.val\n\n        return dfs(node.right)\n\n    return dfs(root)\n\n\nif __name__ == \"__main__\":\n    root = [5, 1, 4, None, None, 3, 6]\n    root = build(root)\n    print(root)\n    #   5__\n    #  /   \\\n    # 1     4\n    #      / \\\n    #     3   6\n    assert not isValidBST1(root)  # [1, 5, 3, 4, 6]\n    assert not isValidBST2(root)  # [1, 5, 3, 4, 6]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   private:\n    vector&lt;int&gt; inorder;\n    bool check(vector&lt;int&gt; inorder) {\n        int n = inorder.size();\n        if (n &lt;= 1) return true;\n        for (int i = 1; i &lt; n; i++) {\n            if (inorder[i] &lt;= inorder[i - 1]) return false;\n        }\n        return true;\n    }\n\n   public:\n    bool isValidBST(TreeNode *root) {\n        auto dfs = [&amp;](auto &amp;&amp;self, TreeNode *node) -&gt; void {\n            if (!node) return;\n\n            self(self, node-&gt;left);\n            inorder.push_back(node-&gt;val);\n            self(self, node-&gt;right);\n        };\n\n        dfs(dfs, root);\n\n        return check(inorder);\n    }\n};\n\nint main() {\n    Solution s;\n    TreeNode *root = new TreeNode(2);\n    root-&gt;left = new TreeNode(1);\n    root-&gt;right = new TreeNode(3);\n    assert(s.isValidBST(root) == true);\n\n    root = new TreeNode(5);\n    root-&gt;left = new TreeNode(1);\n    root-&gt;right = new TreeNode(4);\n    root-&gt;right-&gt;left = new TreeNode(3);\n    root-&gt;right-&gt;right = new TreeNode(6);\n    assert(s.isValidBST(root) == false);\n\n    root = new TreeNode(5);\n    root-&gt;left = new TreeNode(4);\n    root-&gt;right = new TreeNode(6);\n    root-&gt;right-&gt;left = new TreeNode(3);\n    root-&gt;right-&gt;right = new TreeNode(7);\n    assert(s.isValidBST(root) == false);\n\n    return 0;\n}\n</code></pre>"},{"location":"neetcode-150/trees/#230-kth-smallest-element-in-a-bst","title":"230. Kth Smallest Element in a BST","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Search Tree, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef kthSmallestRecursive(root: Optional[TreeNode], k: int) -&gt; int:\n    inorder = []\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n    return inorder[k - 1]\n\n\n# Iteratve\ndef kthSmallestIteratve(root: Optional[TreeNode], k: int) -&gt; int:\n    stack = []\n    while True:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        k -= 1\n        if not k:\n            return root.val\n        root = root.right\n\n\nif __name__ == \"__main__\":\n    root = build([3, 1, 4, None, 2])\n    k = 1\n    assert kthSmallestRecursive(root, k) == 1\n    assert kthSmallestIteratve(root, k) == 1\n</code></pre>"},{"location":"neetcode-150/trees/#105-construct-binary-tree-from-preorder-and-inorder-traversal","title":"105. Construct Binary Tree from Preorder and Inorder Traversal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Divide And Conquer, Tree, Binary Tree</p> </li> </ul> PythonCPP <pre><code>from typing import List, Optional\n\nfrom helper import TreeNode\n\n\ndef buildTree(preorder: List[int], inorder: List[int]) -&gt; Optional[TreeNode]:\n    \"\"\"\n    preorder  root left right  1  2  3\n    inorder   left root right  4  5  6\n    \"\"\"\n    if len(preorder) == 0:\n        return None\n\n    root_val = preorder[0]  # 1\n    root = TreeNode(root_val)\n\n    separator_idx = inorder.index(root_val)  # 5\n\n    left_inorder = inorder[:separator_idx]  # 4\n    right_inorder = inorder[separator_idx + 1 :]  # 6\n\n    left_preorder = preorder[1 : 1 + len(left_inorder)]  # 2\n    right_preorder = preorder[1 + len(left_inorder) :]  # 3\n\n    root.left = buildTree(left_preorder, left_inorder)\n    root.right = buildTree(right_preorder, right_inorder)\n\n    return root\n\n\npreorder = [3, 9, 20, 15, 7]\ninorder = [9, 3, 15, 20, 7]\nroot = buildTree(preorder, inorder)\nprint(root)\n#     3\n#    / \\\n#   9  20\n#     /  \\\n#    15   7\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   public:\n    vector&lt;int&gt; preorder;\n    unordered_map&lt;int, int&gt; inorderMap;\n\n    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {\n        this-&gt;preorder = preorder;\n        for (size_t i = 0; i &lt; inorder.size(); i++) {\n            inorderMap[inorder[i]] = i;\n        }\n        return buildSubtree(0, 0, inorder.size() - 1);\n    }\n\n   private:\n    TreeNode* buildSubtree(int rootIndex, int left, int right) {\n        if (left &gt; right) return nullptr;\n\n        TreeNode* root = new TreeNode(preorder[rootIndex]);\n        int inorderIndex = inorderMap[preorder[rootIndex]];\n\n        root-&gt;left = buildSubtree(rootIndex + 1, left, inorderIndex - 1);\n        root-&gt;right = buildSubtree(rootIndex + (inorderIndex - left + 1),\n                                   inorderIndex + 1, right);\n\n        return root;\n    }\n};\n\nint main() {\n    vector&lt;int&gt; preorder = {3, 9, 20, 15, 7};\n    vector&lt;int&gt; inorder = {9, 3, 15, 20, 7};\n    Solution solution;\n    TreeNode* root = solution.buildTree(preorder, inorder);\n    cout &lt;&lt; root-&gt;val &lt;&lt; endl;                // 3\n    cout &lt;&lt; root-&gt;left-&gt;val &lt;&lt; endl;          // 9\n    cout &lt;&lt; root-&gt;right-&gt;val &lt;&lt; endl;         // 20\n    cout &lt;&lt; root-&gt;right-&gt;left-&gt;val &lt;&lt; endl;   // 15\n    cout &lt;&lt; root-&gt;right-&gt;right-&gt;val &lt;&lt; endl;  // 7\n    return 0;\n}\n</code></pre>"},{"location":"neetcode-150/trees/#124-binary-tree-maximum-path-sum","title":"124. Binary Tree Maximum Path Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Tree, Depth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef maxPathSum(root: Optional[TreeNode]) -&gt; int:\n    res = float(\"-inf\")\n\n    def dfs(node):\n        if not node:\n            return 0\n\n        leftMax = max(dfs(node.left), 0)\n        rightMax = max(dfs(node.right), 0)\n\n        cur = node.val + leftMax + rightMax\n        nonlocal res\n        res = max(res, cur)\n\n        return node.val + max(leftMax, rightMax)\n\n    dfs(root)\n\n    return res\n\n\nroot = build([-10, 9, 20, None, None, 15, 7])\nprint(root)\n#   -10___\n#  /      \\\n# 9       _20\n#        /   \\\n#       15    7\nprint(maxPathSum(root))  # 42\n</code></pre>"},{"location":"neetcode-150/trees/#297-serialize-and-deserialize-binary-tree","title":"297. Serialize and Deserialize Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Tree, Depth First Search, Breadth First Search, Design, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BFS\nclass BFS:\n    def serialize(self, root: Optional[TreeNode]) -&gt; str:\n        if not root:\n            return \"\"\n\n        res = []\n        q = deque([root])\n\n        while q:\n            node = q.popleft()\n\n            if node:\n                res.append(str(node.val))\n                q.append(node.left)\n                q.append(node.right)\n            else:\n                res.append(\"null\")\n\n        return \",\".join(res)\n\n    def deserialize(self, data: str) -&gt; Optional[TreeNode]:\n        if not data:\n            return None\n\n        nodes = data.split(\",\")\n        root = TreeNode(int(nodes[0]))\n        q = deque([root])\n        index = 1\n\n        while q:\n            node = q.popleft()\n\n            if nodes[index] != \"null\":\n                node.left = TreeNode(int(nodes[index]))\n                q.append(node.left)\n            index += 1\n\n            if nodes[index] != \"null\":\n                node.right = TreeNode(int(nodes[index]))\n                q.append(node.right)\n            index += 1\n\n        return root\n\n\n# DFS\nclass DFS:\n    def serialize(self, root: Optional[TreeNode]) -&gt; str:\n        def dfs(node):\n            if not node:\n                return [\"null\"]\n            return [str(node.val)] + dfs(node.left) + dfs(node.right)\n\n        return \",\".join(dfs(root))\n\n    def deserialize(self, data: str) -&gt; Optional[TreeNode]:\n        nodes = data.split(\",\")\n        self.index = 0\n\n        def dfs():\n            if nodes[self.index] == \"null\":\n                self.index += 1\n                return None\n\n            node = TreeNode(int(nodes[self.index]))\n            self.index += 1\n\n            node.left = dfs()\n            node.right = dfs()\n\n            return node\n\n        root = dfs()\n        return root\n\n\nroot = build([1, 2, 3, None, None, 4, 5])\nprint(root)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n\nbfs = BFS()\ndata1 = bfs.serialize(root)\nprint(data1)  # \"1,2,3,null,null,4,5,null,null,null,null\"\nroot1 = bfs.deserialize(data1)\nprint(root1)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n\ndfs = DFS()\ndata2 = dfs.serialize(root)\nprint(data2)  # \"1,2,null,null,3,4,null,null,5,null,null\"\nroot2 = dfs.deserialize(data2)\nprint(root2)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n</code></pre>"},{"location":"neetcode-150/tries/","title":"Tries","text":""},{"location":"neetcode-150/tries/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 208. Implement Trie (Prefix Tree) (Medium)</li> <li> 211. Design Add and Search Words Data Structure (Medium)</li> <li> 212. Word Search II (Hard)</li> </ul>"},{"location":"neetcode-150/tries/#208-implement-trie-prefix-tree","title":"208. Implement Trie (Prefix Tree)","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Design, Trie</p> </li> </ul> Python <pre><code>\"\"\"\n### Trie\n\n- A trie is a tree-like data structure whose nodes store the letters of an alphabet.\n\"\"\"\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.endOfWord = None\n\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.endOfWord = True\n\n    def search(self, word: str) -&gt; bool:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return node.endOfWord\n\n    def startsWith(self, prefix: str) -&gt; bool:\n        node = self.root\n\n        for c in prefix:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return True\n\n\n# Your Trie object will be instantiated and called as such:\nobj = Trie()\nobj.insert(\"apple\")\nprint(obj.search(\"word\"))  # False\nprint(obj.startsWith(\"app\"))  # True\n</code></pre>"},{"location":"neetcode-150/tries/#211-design-add-and-search-words-data-structure","title":"211. Design Add and Search Words Data Structure","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Depth First Search, Design, Trie</p> </li> </ul> Python <pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.word = False\n\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.word = True\n\n    def search(self, word: str) -&gt; bool:\n\n        def dfs(j, root):\n            node = root\n\n            for i in range(j, len(word)):\n                c = word[i]\n\n                if c == \".\":\n                    for child in node.children.values():\n                        if dfs(i + 1, child):\n                            return True\n                    return False\n                else:\n                    if c not in node.children:\n                        return False\n                    node = node.children[c]\n            return node.word\n\n        return dfs(0, self.root)\n\n\n# Your WordDictionary object will be instantiated and called as such:\nobj = WordDictionary()\nobj.addWord(\"word\")\nprint(obj.search(\"word\"))\nprint(obj.search(\"w.rd\"))\n</code></pre>"},{"location":"neetcode-150/tries/#212-word-search-ii","title":"212. Word Search II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Backtracking, Trie, Matrix</p> </li> </ul> Python <pre><code>from typing import List\n\nfrom leetpattern.utils import Trie\n\n\n# Backtracking + Trie\ndef findWords(board: List[List[str]], words: List[str]) -&gt; List[str]:\n    trie = Trie()\n    for word in words:\n        trie.add_word(word)\n\n    m, n = len(board), len(board[0])\n    result, visit = set(), set()\n\n    def dfs(r, c, node, word):\n        if (\n            r &lt; 0\n            or r &gt;= m\n            or c &lt; 0\n            or c &gt;= n\n            or (r, c) in visit\n            or board[r][c] not in node.children\n        ):\n            return None\n\n        visit.add((r, c))\n\n        node = node.children[board[r][c]]\n        word += board[r][c]\n        if node.is_word:\n            result.add(word)\n\n        dfs(r - 1, c, node, word)\n        dfs(r + 1, c, node, word)\n        dfs(r, c - 1, node, word)\n        dfs(r, c + 1, node, word)\n\n        visit.remove((r, c))\n\n    for r in range(m):\n        for c in range(n):\n            dfs(r, c, trie.root, \"\")\n\n    return list(result)\n\n\ndef test_find_words():\n    board = [\n        [\"o\", \"a\", \"a\", \"n\"],\n        [\"e\", \"t\", \"a\", \"e\"],\n        [\"i\", \"h\", \"k\", \"r\"],\n        [\"i\", \"f\", \"l\", \"v\"],\n    ]\n    words = [\"oath\", \"pea\", \"eat\", \"rain\"]\n    result = findWords(board, words)\n    assert sorted(result) == [\"eat\", \"oath\"]\n</code></pre>"},{"location":"neetcode-150/two_pointers/","title":"Two Pointers","text":""},{"location":"neetcode-150/two_pointers/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 125. Valid Palindrome (Easy)</li> <li> 167. Two Sum II - Input Array Is Sorted (Medium)</li> <li> 15. 3Sum (Medium)</li> <li> 11. Container With Most Water (Medium)</li> <li> 42. Trapping Rain Water (Hard)</li> </ul>"},{"location":"neetcode-150/two_pointers/#125-valid-palindrome","title":"125. Valid Palindrome","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String</p> </li> </ul> Python <pre><code># List Comprehension\ndef isPalindrome(s: str) -&gt; bool:\n    s = [char.lower() for char in s if char.isalnum()]\n    return s == s[::-1]\n\n\n# Left Right Pointers\ndef isPalindromeLR(s: str) -&gt; bool:\n    left, right = 0, len(s) - 1\n\n    while left &lt; right:\n        while left &lt; right and not s[left].isalnum():\n            left += 1\n        while left &lt; right and not s[right].isalnum():\n            right -= 1\n\n        if s[left].lower() != s[right].lower():\n            return False\n\n        left += 1\n        right -= 1\n\n    return True\n\n\ns = \"A man, a plan, a canal: Panama\"\nprint(isPalindrome(s))  # True\nprint(isPalindromeLR(s))  # True\n</code></pre>"},{"location":"neetcode-150/two_pointers/#167-two-sum-ii-input-array-is-sorted","title":"167. Two Sum II - Input Array Is Sorted","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef twoSum(numbers: List[int], target: int) -&gt; List[int]:\n    left, right = 0, len(numbers) - 1\n\n    while left &lt; right:\n        total = numbers[left] + numbers[right]\n\n        if total &gt; target:\n            right -= 1\n        elif total &lt; target:\n            left += 1\n        else:\n            return [left + 1, right + 1]\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nnumbers = [2, 7, 11, 15]\ntarget = 9\nprint(twoSum(numbers, target))  # [1, 2]\n</code></pre>"},{"location":"neetcode-150/two_pointers/#15-3sum","title":"15. 3Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Sorting</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef threeSum(nums: List[int]) -&gt; List[List[int]]:\n    nums.sort()\n    res = []\n    n = len(nums)\n\n    for i in range(n - 2):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        left, right = i + 1, n - 1\n\n        while left &lt; right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total &gt; 0:\n                right -= 1\n            elif total &lt; 0:\n                left += 1\n            else:\n                res.append([nums[i], nums[left], nums[right]])\n\n                while left &lt; right and nums[left] == nums[left + 1]:\n                    left += 1\n\n                while left &lt; right and nums[right] == nums[right - 1]:\n                    right -= 1\n\n                left += 1\n                right -= 1\n\n    return res\n\n\nnums = [-1, 0, 1, 2, -1, -4]\nassert threeSum(nums) == [[-1, -1, 2], [-1, 0, 1]]\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {\n    sort(nums.begin(), nums.end());\n    vector&lt;vector&lt;int&gt;&gt; res;\n    int n = nums.size();\n\n    for (int i = 0; i &lt; n - 2; i++) {\n        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) {\n            continue;\n        }\n\n        int left = i + 1, right = n - 1;\n\n        while (left &lt; right) {\n            int total = nums[i] + nums[left] + nums[right];\n\n            if (total &gt; 0)\n                right--;\n            else if (total &lt; 0)\n                left++;\n            else {\n                res.push_back({nums[i], nums[left], nums[right]});\n                while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++;\n                while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--;\n                left++;\n                right--;\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {-1, 0, 1, 2, -1, -4};\n    vector&lt;vector&lt;int&gt;&gt; res = threeSum(nums);\n    for (auto&amp; v : res) {\n        for (int i : v) {\n            cout &lt;&lt; i &lt;&lt; \" \";\n        }\n        cout &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"neetcode-150/two_pointers/#11-container-with-most-water","title":"11. Container With Most Water","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Greedy</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return the maximum area of water that can be trapped between the vertical lines.\n\n![11](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)\n\"\"\"\n\nfrom typing import List\n\n\n# Brute Force\ndef maxAreaBF(height: List[int]) -&gt; int:\n    max_area = 0\n\n    for i in range(len(height)):\n        for j in range(i + 1, len(height)):\n            h = min(height[i], height[j])\n            w = j - i\n            max_area = max(max_area, h * w)\n\n    return max_area\n\n\n# Left Right Pointers\ndef maxAreaLR(height: List[int]) -&gt; int:\n    left, right = 0, len(height) - 1\n    res = 0\n\n    while left &lt; right:\n        h = min(height[left], height[right])\n        w = right - left\n        res = max(res, h * w)\n\n        if height[left] &lt; height[right]:\n            left += 1\n        else:\n            right -= 1\n\n    return res\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force| O(n^2) |  O(1)   |\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nheight = [1, 8, 6, 2, 5, 4, 8, 3, 7]\nprint(maxAreaBF(height))  # 49\nprint(maxAreaLR(height))  # 49\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint maxArea(vector&lt;int&gt;&amp; height) {\n    int left = 0, right = height.size() - 1;\n    int res = 0;\n\n    while (left &lt; right) {\n        int h = min(height[left], height[right]);\n        int w = right - left;\n        res = max(res, h * w);\n\n        if (height[left] &lt; height[right])\n            left++;\n        else\n            right--;\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; height = {1, 8, 6, 2, 5, 4, 8, 3, 7};\n    cout &lt;&lt; maxArea(height) &lt;&lt; endl;  // 49\n    return 0;\n}\n</code></pre>"},{"location":"neetcode-150/two_pointers/#42-trapping-rain-water","title":"42. Trapping Rain Water","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Dynamic Programming, Stack, Monotonic Stack</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- ![42](../../assets/0042.png)\n\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/ZI2z5pq0TqA?si=OEYg01dbmzvmtIwZ\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen&gt;&lt;/iframe&gt;\n\n| Approach   | Time | Space |\n| ---------- | ---- | ----- |\n| DP         | O(N) | O(N)  |\n| Left Right | O(N) | O(1)  |\n| Monotonic  | O(N) | O(N)  |\n\"\"\"\n\nfrom typing import List\n\n\n# DP\ndef trapDP(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    n = len(height)\n    maxLeft, maxRight = [0 for _ in range(n)], [0 for _ in range(n)]\n\n    for i in range(1, n):\n        maxLeft[i] = max(maxLeft[i - 1], height[i - 1])\n\n    for i in range(n - 2, -1, -1):\n        maxRight[i] = max(maxRight[i + 1], height[i + 1])\n\n    res = 0\n    for i in range(n):\n        res += max(0, min(maxLeft[i], maxRight[i]) - height[i])\n\n    return res\n\n\n# Left Right Pointers\ndef trapLR(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    left, right = 0, len(height) - 1\n    maxL, maxR = height[left], height[right]\n    res = 0\n\n    while left &lt; right:\n        if maxL &lt; maxR:\n            left += 1\n            maxL = max(maxL, height[left])\n            res += maxL - height[left]\n        else:\n            right -= 1\n            maxR = max(maxR, height[right])\n            res += maxR - height[right]\n\n    return res\n\n\n# Monotonic Stack\ndef trapStack(height: List[int]) -&gt; int:\n    stack = []\n    total = 0\n\n    for i in range(len(height)):\n        while stack and height[i] &gt; height[stack[-1]]:\n            top = stack.pop()\n            if not stack:\n                break\n            distance = i - stack[-1] - 1\n            bounded_height = min(height[i], height[stack[-1]]) - height[top]\n            total += distance * bounded_height\n        stack.append(i)\n\n    return total\n\n\nheight = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\nprint(trapDP(height))  # 6\nprint(trapLR(height))  # 6\nprint(trapStack(height))  # 6\n</code></pre> <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int trap(vector&lt;int&gt; &amp;height)\n    {\n        if (height.empty())\n            return 0;\n\n        int res = 0;\n        int left = 0, right = height.size() - 1;\n        int maxL = height[left], maxR = height[right];\n\n        while (left &lt; right)\n        {\n            if (maxL &lt; maxR)\n            {\n                left++;\n                maxL = max(maxL, height[left]);\n                res += maxL - height[left];\n            }\n            else\n            {\n                right--;\n                maxR = max(maxR, height[right]);\n                res += maxR - height[right];\n            }\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    vector&lt;int&gt; height = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};\n    Solution solution;\n    cout &lt;&lt; solution.trap(height) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"premium-100/arrays_strings/","title":"Arrays Strings","text":""},{"location":"premium-100/arrays_strings/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 624. Maximum Distance in Arrays (Medium)</li> <li> 280. Wiggle Sort (Medium) \ud83d\udc51</li> <li> 1056. Confusing Number (Easy) \ud83d\udc51</li> <li> 1427. Perform String Shifts (Easy) \ud83d\udc51</li> <li> 161. One Edit Distance (Medium) \ud83d\udc51</li> <li> 186. Reverse Words in a String II (Medium) \ud83d\udc51</li> <li> 1055. Shortest Way to Form String (Medium) \ud83d\udc51</li> </ul>"},{"location":"premium-100/arrays_strings/#624-maximum-distance-in-arrays","title":"624. Maximum Distance in Arrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Array\ndef maxDistance(arrays: List[List[int]]) -&gt; int:\n    mn, mx = float(\"inf\"), float(\"-inf\")\n    res = 0\n\n    for arr in arrays:\n        res = max(res, arr[-1] - mn, mx - arr[0])\n        mn = min(mn, arr[0])\n        mx = max(mx, arr[-1])\n\n    return res\n\n\narrays = [[1, 2, 3], [4, 5], [1, 2, 3]]\nprint(maxDistance(arrays))  # 4\n</code></pre>"},{"location":"premium-100/arrays_strings/#280-wiggle-sort","title":"280. Wiggle Sort \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\ndef wiggleSort(nums: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    n = len(nums)\n    for i in range(n - 1):\n        if i % 2 == 0:\n            if nums[i] &gt; nums[i + 1]:\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]\n        else:\n            if nums[i] &lt; nums[i + 1]:\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]\n\n\nnum = [3, 5, 2, 1, 6, 4]\nwiggleSort(num)\nprint(num)  # [3, 5, 1, 6, 2, 4]\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvoid wiggleSort(vector&lt;int&gt;&amp; nums) {\n    int n = nums.size();\n\n    for (int i = 0; i &lt; n - 1; i++) {\n        if (i % 2 == 0) {\n            if (nums[i] &gt; nums[i + 1]) swap(nums[i], nums[i + 1]);\n        } else {\n            if (nums[i] &lt; nums[i + 1]) swap(nums[i], nums[i + 1]);\n        }\n    }\n}\n\nint main() {\n    vector&lt;int&gt; nums = {3, 5, 2, 1, 6, 4};\n    wiggleSort(nums);\n    // 3 5 1 6 2 4\n    for (size_t i = 0; i &lt; nums.size(); i++) {\n        cout &lt;&lt; nums[i] &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"premium-100/arrays_strings/#1056-confusing-number","title":"1056. Confusing Number \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math</p> </li> </ul> PythonCPP <pre><code>def confusingNumber(n: int) -&gt; bool:\n    rotate_map = {\"0\": \"0\", \"1\": \"1\", \"6\": \"9\", \"8\": \"8\", \"9\": \"6\"}\n    original = str(n)\n    rotated = \"\"\n\n    for ch in reversed(original):\n        if ch not in rotate_map:\n            return False\n        rotated += rotate_map[ch]\n\n    return rotated != original\n\n\nif __name__ == \"__main__\":\n    print(confusingNumber(6))  # True\n    print(confusingNumber(89))  # True\n    print(confusingNumber(11))  # False\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool confusingNumber(int n) {\n        static const unordered_map&lt;char, char&gt; rotationMap = {\n            {'0', '0'}, {'1', '1'}, {'6', '9'}, {'8', '8'}, {'9', '6'}};\n\n        string numStr = to_string(n);\n        string rotated;\n        rotated.reserve(numStr.size());\n\n        for (int i = numStr.size() - 1; i &gt;= 0; --i) {\n            char currentDigit = numStr[i];\n\n            auto it = rotationMap.find(currentDigit);\n            if (it == rotationMap.end()) {\n                return false;\n            }\n\n            rotated.push_back(it-&gt;second);\n        }\n\n        return rotated != numStr;\n    }\n};\n\nint main() {\n    Solution sol;\n    cout &lt;&lt; boolalpha;  // Print boolean values as true/false\n    cout &lt;&lt; sol.confusingNumber(6) &lt;&lt; endl;    // true\n    cout &lt;&lt; sol.confusingNumber(89) &lt;&lt; endl;   // true\n    cout &lt;&lt; sol.confusingNumber(11) &lt;&lt; endl;   // false\n    cout &lt;&lt; sol.confusingNumber(25) &lt;&lt; endl;   // false\n    cout &lt;&lt; sol.confusingNumber(916) &lt;&lt; endl;  // true\n    cout &lt;&lt; sol.confusingNumber(101) &lt;&lt; endl;  // false\n\n    return 0;\n}\n</code></pre>"},{"location":"premium-100/arrays_strings/#1427-perform-string-shifts","title":"1427. Perform String Shifts \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, String</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Calculate the net shift direction and amount by combining all operations, then apply a single rotation to the string using slicing.\n\"\"\"\n\nfrom typing import List\n\n\ndef stringShift(s: str, shift: List[List[int]]) -&gt; str:\n    total_shift = 0\n    for direction, amount in shift:\n        if direction == 0:\n            total_shift -= amount\n        else:\n            total_shift += amount\n\n    total_shift %= len(s)\n\n    if total_shift == 0:\n        return s\n\n    if total_shift &gt; 0:\n        return s[-total_shift:] + s[:-total_shift]\n    else:\n        total_shift = abs(total_shift)\n        return s[total_shift:] + s[:total_shift]\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Solution {\n   public:\n    string stringShift(string s, vector&lt;vector&lt;int&gt;&gt;&amp; shift) {\n        int total_shift = 0;\n        for (const auto&amp; op : shift) {\n            if (op[0] == 0) {\n                total_shift -= op[1];\n            } else {\n                total_shift += op[1];\n            }\n        }\n\n        int n = s.length();\n        total_shift =\n            ((total_shift % n) + n) % n;  // Handle negative shift properly\n\n        if (total_shift == 0) {\n            return s;\n        }\n\n        return s.substr(n - total_shift) + s.substr(0, n - total_shift);\n    }\n};\n\nint main() {\n    Solution solution;\n\n    string s1 = \"abc\";\n    vector&lt;vector&lt;int&gt;&gt; shift1 = {{0, 1}, {1, 2}};\n    cout &lt;&lt; \"Input: s = \\\"abc\\\", shift = [[0,1],[1,2]]\" &lt;&lt; endl;\n    cout &lt;&lt; \"Output: \" &lt;&lt; solution.stringShift(s1, shift1) &lt;&lt; endl;\n\n    string s2 = \"abcdefg\";\n    vector&lt;vector&lt;int&gt;&gt; shift2 = {{1, 1}, {1, 1}, {0, 2}, {1, 3}};\n    cout &lt;&lt; \"Input: s = \\\"abcdefg\\\", shift = [[1,1],[1,1],[0,2],[1,3]]\" &lt;&lt; endl;\n    cout &lt;&lt; \"Output: \" &lt;&lt; solution.stringShift(s2, shift2) &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"premium-100/arrays_strings/#161-one-edit-distance","title":"161. One Edit Distance \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String</p> </li> </ul> Python <pre><code>class IsOneEditDistance:\n    def traverse(self, s: str, t: str) -&gt; bool:\n        m, n = len(s), len(t)\n\n        # ensure s is the shorter one\n        if m &gt; n:\n            return self.traverse(t, s)\n\n        # len difference &gt; 1\n        if n - m &gt; 1:\n            return False\n\n        for i in range(m):\n            if s[i] == t[i]:\n                continue\n\n            if m == n:\n                return s[i + 1 :] == t[i + 1 :]\n            else:\n                return s[i:] == t[i + 1 :]\n\n        return m + 1 == n\n\n\nif __name__ == \"__main__\":\n    sol = IsOneEditDistance()\n    assert sol.traverse(\"ab\", \"acb\") is True\n    assert sol.traverse(\"cab\", \"ad\") is False\n    assert sol.traverse(\"1203\", \"1213\") is True\n</code></pre>"},{"location":"premium-100/arrays_strings/#186-reverse-words-in-a-string-ii","title":"186. Reverse Words in a String II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String</p> </li> </ul> Python <pre><code>from typing import List\n\n\nclass reverseWords:\n    def left_right_pointers(self, s: List[str]) -&gt; None:\n        \"\"\"\n        Do not return anything, modify s in-place instead.\n        \"\"\"\n        n = len(s)\n        s.reverse()\n\n        left = 0\n        while left &lt; n:\n            if s[left] == \" \":\n                left += 1\n                continue\n\n            # detect the word boundary\n            right = left\n            while right &lt; n and s[right] != \" \":\n                right += 1\n\n            # reverse the word\n            l, r = left, right - 1\n            while l &lt; r:\n                s[l], s[r] = s[r], s[l]\n                l += 1\n                r -= 1\n\n            left = right\n\n\nif __name__ == \"__main__\":\n    sol = reverseWords()\n    s = [\"t\", \"h\", \"e\", \" \", \"s\", \"k\", \"y\", \" \", \"i\", \"s\"]\n    sol.left_right_pointers(s)\n    assert s == [\"i\", \"s\", \" \", \"s\", \"k\", \"y\", \" \", \"t\", \"h\", \"e\"]\n</code></pre>"},{"location":"premium-100/arrays_strings/#1055-shortest-way-to-form-string","title":"1055. Shortest Way to Form String \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Binary Search, Greedy</p> </li> </ul>"},{"location":"premium-100/backtracking/","title":"Backtracking","text":""},{"location":"premium-100/backtracking/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 247. Strobogrammatic Number II (Medium) \ud83d\udc51</li> <li> 254. Factor Combinations (Medium) \ud83d\udc51</li> <li> 1087. Brace Expansion (Medium) \ud83d\udc51</li> </ul>"},{"location":"premium-100/backtracking/#247-strobogrammatic-number-ii","title":"247. Strobogrammatic Number II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Recursion</p> </li> </ul>"},{"location":"premium-100/backtracking/#254-factor-combinations","title":"254. Factor Combinations \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Backtracking</p> </li> </ul>"},{"location":"premium-100/backtracking/#1087-brace-expansion","title":"1087. Brace Expansion \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Backtracking, Breadth First Search</p> </li> </ul>"},{"location":"premium-100/binary_search/","title":"Binary Search","text":""},{"location":"premium-100/binary_search/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1228. Missing Number In Arithmetic Progression (Easy) \ud83d\udc51</li> <li> 1060. Missing Element in Sorted Array (Medium) \ud83d\udc51</li> <li> 1533. Find the Index of the Large Integer (Medium) \ud83d\udc51</li> <li> 1150. Check If a Number Is Majority Element in a Sorted Array (Easy) \ud83d\udc51</li> <li> 1231. Divide Chocolate (Hard) \ud83d\udc51</li> <li> 644. Maximum Average Subarray II (Hard) \ud83d\udc51</li> </ul>"},{"location":"premium-100/binary_search/#1228-missing-number-in-arithmetic-progression","title":"1228. Missing Number In Arithmetic Progression \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef missingNumber(arr: List[int]) -&gt; int:\n    n = len(arr)\n    s1 = (arr[0] + arr[-1]) * (n + 1) // 2\n    s2 = sum(arr)\n    return s1 - s2\n\n\n# Binary Search\ndef missingNumberBS(arr: List[int]) -&gt; int:\n    n = len(arr)\n    diff = (arr[-1] - arr[0]) // n\n\n    left, right = 0, n - 1\n\n    while left &lt; right:\n        mid = left + (right - left) // 2\n        if arr[mid] == arr[0] + mid * diff:\n            left = mid + 1\n        else:\n            right = mid\n\n    return arr[0] + left * diff\n\n\nif __name__ == \"__main__\":\n    assert missingNumber([5, 7, 11, 13]) == 9\n    assert missingNumber([15, 13, 12]) == 14\n    assert missingNumber([1, 3]) == 2\n    assert missingNumberBS([5, 7, 11, 13]) == 9\n    assert missingNumberBS([15, 13, 12]) == 14\n    assert missingNumberBS([1, 3]) == 2\n</code></pre>"},{"location":"premium-100/binary_search/#1060-missing-element-in-sorted-array","title":"1060. Missing Element in Sorted Array \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul>"},{"location":"premium-100/binary_search/#1533-find-the-index-of-the-large-integer","title":"1533. Find the Index of the Large Integer \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Interactive</p> </li> </ul>"},{"location":"premium-100/binary_search/#1150-check-if-a-number-is-majority-element-in-a-sorted-array","title":"1150. Check If a Number Is Majority Element in a Sorted Array \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul>"},{"location":"premium-100/binary_search/#1231-divide-chocolate","title":"1231. Divide Chocolate \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul>"},{"location":"premium-100/binary_search/#644-maximum-average-subarray-ii","title":"644. Maximum Average Subarray II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Prefix Sum</p> </li> </ul>"},{"location":"premium-100/binary_search_tree/","title":"Binary Search Tree","text":""},{"location":"premium-100/binary_search_tree/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 270. Closest Binary Search Tree Value (Easy) \ud83d\udc51</li> <li> 272. Closest Binary Search Tree Value II (Hard) \ud83d\udc51</li> <li> 255. Verify Preorder Sequence in Binary Search Tree (Medium) \ud83d\udc51</li> <li> 1214. Two Sum BSTs (Medium) \ud83d\udc51</li> <li> 333. Largest BST Subtree (Medium) \ud83d\udc51</li> </ul>"},{"location":"premium-100/binary_search_tree/#270-closest-binary-search-tree-value","title":"270. Closest Binary Search Tree Value \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Binary Search, Tree, Depth First Search, Binary Search Tree, Binary Tree</p> </li> </ul>"},{"location":"premium-100/binary_search_tree/#272-closest-binary-search-tree-value-ii","title":"272. Closest Binary Search Tree Value II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, Stack, Tree, Depth First Search, Binary Search Tree, Heap Priority Queue, Binary Tree</p> </li> </ul>"},{"location":"premium-100/binary_search_tree/#255-verify-preorder-sequence-in-binary-search-tree","title":"255. Verify Preorder Sequence in Binary Search Tree \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Stack, Tree, Binary Search Tree, Recursion, Monotonic Stack, Binary Tree</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# BST\ndef verifyPreorder(preorder: List[int]) -&gt; bool:\n    stack = []\n    low = float(\"-inf\")\n\n    for value in preorder:\n        if value &lt; low:\n            return False\n        while stack and value &gt; stack[-1]:\n            low = stack.pop()\n        stack.append(value)\n\n    return True\n\n\nif __name__ == \"__main__\":\n    assert verifyPreorder([8, 5, 1, 7, 10, 12]) is True\n    assert verifyPreorder([8, 5, 4, 3, 2, 1]) is True\n</code></pre>"},{"location":"premium-100/binary_search_tree/#1214-two-sum-bsts","title":"1214. Two Sum BSTs \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, Binary Search, Stack, Tree, Depth First Search, Binary Search Tree, Binary Tree</p> </li> </ul>"},{"location":"premium-100/binary_search_tree/#333-largest-bst-subtree","title":"333. Largest BST Subtree \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Tree, Depth First Search, Binary Search Tree, Binary Tree</p> </li> </ul>"},{"location":"premium-100/binary_tree/","title":"Binary Tree","text":""},{"location":"premium-100/binary_tree/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 298. Binary Tree Longest Consecutive Sequence (Medium) \ud83d\udc51</li> <li> 549. Binary Tree Longest Consecutive Sequence II (Medium) \ud83d\udc51</li> <li> 250. Count Univalue Subtrees (Medium) \ud83d\udc51</li> <li> 1120. Maximum Average Subtree (Medium) \ud83d\udc51</li> <li> 545. Boundary of Binary Tree (Medium) \ud83d\udc51</li> <li> 366. Find Leaves of Binary Tree (Medium) \ud83d\udc51</li> <li> 314. Binary Tree Vertical Order Traversal (Medium) \ud83d\udc51</li> </ul>"},{"location":"premium-100/binary_tree/#298-binary-tree-longest-consecutive-sequence","title":"298. Binary Tree Longest Consecutive Sequence \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Binary Tree\ndef longestConsecutive(root: Optional[TreeNode]) -&gt; int:\n    res = 0\n\n    def dfs(node):\n        if not node:\n            return 0\n\n        left, right = dfs(node.left), dfs(node.right)\n        cur = 1\n        if node.left and node.left.val == (node.val + 1):\n            cur = max(cur, left + 1)\n        if node.right and node.right.val == (node.val + 1):\n            cur = max(cur, right + 1)\n\n        nonlocal res\n        res = max(res, cur)\n        return cur\n\n    dfs(root)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    root = build([1, 3, 2, 4, None, None, None, 5])\n    print(root)\n    #       1\n    #      / \\\n    #     3   2\n    #    /\n    #   4\n    #  /\n    # 5\n    print(longestConsecutive(root))  # 3\n</code></pre>"},{"location":"premium-100/binary_tree/#549-binary-tree-longest-consecutive-sequence-ii","title":"549. Binary Tree Longest Consecutive Sequence II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"premium-100/binary_tree/#250-count-univalue-subtrees","title":"250. Count Univalue Subtrees \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"premium-100/binary_tree/#1120-maximum-average-subtree","title":"1120. Maximum Average Subtree \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"premium-100/binary_tree/#545-boundary-of-binary-tree","title":"545. Boundary of Binary Tree \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul>"},{"location":"premium-100/binary_tree/#366-find-leaves-of-binary-tree","title":"366. Find Leaves of Binary Tree \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef findLeaves(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    depths = defaultdict(list)\n\n    def dfs(node):\n        if not node:\n            return 0\n        l, r = dfs(node.left), dfs(node.right)\n        depth = 1 + max(l, r)\n        depths[depth].append(node.val)\n        return depth\n\n    dfs(root)\n    return [i for i in depths.values()]\n\n\nif __name__ == \"__main__\":\n    root = build([1, 2, 3, 4, 5])\n    print(root)\n    #     __1\n    #    /   \\\n    #   2     3\n    #  / \\\n    # 4   5\n    print(findLeaves(root))  # [[4, 5, 3], [2], [1]]\n</code></pre>"},{"location":"premium-100/binary_tree/#314-binary-tree-vertical-order-traversal","title":"314. Binary Tree Vertical Order Traversal \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Tree, Depth First Search, Breadth First Search, Sorting, Binary Tree</p> </li> </ul>"},{"location":"premium-100/design/","title":"Design","text":""},{"location":"premium-100/design/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 348. Design Tic-Tac-Toe (Medium) \ud83d\udc51</li> <li> 353. Design Snake Game (Medium) \ud83d\udc51</li> <li> 604. Design Compressed String Iterator (Easy) \ud83d\udc51</li> <li> 271. Encode and Decode Strings (Medium) \ud83d\udc51</li> <li> 281. Zigzag Iterator (Medium) \ud83d\udc51</li> <li> 716. Max Stack (Hard) \ud83d\udc51</li> <li> 1244. Design A Leaderboard (Medium) \ud83d\udc51</li> <li> 428. Serialize and Deserialize N-ary Tree (Hard) \ud83d\udc51</li> <li> 431. Encode N-ary Tree to Binary Tree (Hard) \ud83d\udc51</li> </ul>"},{"location":"premium-100/design/#348-design-tic-tac-toe","title":"348. Design Tic-Tac-Toe \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Design, Matrix, Simulation</p> </li> </ul>"},{"location":"premium-100/design/#353-design-snake-game","title":"353. Design Snake Game \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Design, Queue, Simulation</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\nclass SnakeGame:\n\n    def __init__(self, width: int, height: int, food: List[List[int]]):\n        self.width = width\n        self.height = height\n        self.food = deque(food)\n        self.snake = deque([(0, 0)])  # Snake starts at the top-left corner\n        self.snake_body = set([(0, 0)])  # To quickly check for collisions\n        self.score = 0\n        self.dirs = {\"U\": (-1, 0), \"L\": (0, -1), \"R\": (0, 1), \"D\": (1, 0)}\n\n    def move(self, direction: str) -&gt; int:\n        head = self.snake[0]\n        dx, dy = self.dirs[direction]\n        new_head = (head[0] + dx, head[1] + dy)\n\n        # Check if the new head is out of bounds\n        if not (0 &lt;= new_head[0] &lt; self.height and 0 &lt;= new_head[1] &lt; self.width):\n            return -1\n\n        # Check if the new head collides with the snake body (excluding the tail)\n        if new_head in self.snake_body and new_head != self.snake[-1]:\n            return -1\n\n        # Check if the new head is on a food cell\n        if self.food and self.food[0] == list(new_head):\n            self.food.popleft()\n            self.score += 1\n        else:\n            tail = self.snake.pop()\n            self.snake_body.remove(tail)\n\n        # Add the new head to the snake\n        self.snake.appendleft(new_head)\n        self.snake_body.add(new_head)\n\n        return self.score\n\n\nsnake = SnakeGame(3, 2, [[1, 2], [0, 1]])\nprint(snake.move(\"R\"))  # 0\nprint(snake.move(\"D\"))  # 0\nprint(snake.move(\"R\"))  # 1\nprint(snake.move(\"U\"))  # 1\nprint(snake.move(\"L\"))  # 2\nprint(snake.move(\"U\"))  # -1\n</code></pre>"},{"location":"premium-100/design/#604-design-compressed-string-iterator","title":"604. Design Compressed String Iterator \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Design, Iterator</p> </li> </ul>"},{"location":"premium-100/design/#271-encode-and-decode-strings","title":"271. Encode and Decode Strings \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Design</p> </li> </ul> Python <pre><code>from typing import List\n\n\nclass Codec:\n    def encode(self, strs: List[str]) -&gt; str:\n        \"\"\"Encodes a list of strings to a single string.\"\"\"\n        encoded = \"\"\n\n        for s in strs:\n            encoded += str(len(s)) + \"#\" + s\n\n        return encoded\n\n    def decode(self, s: str) -&gt; List[str]:\n        \"\"\"Decodes a single string to a list of strings.\"\"\"\n        decoded = []\n        i = 0\n\n        while i &lt; len(s):\n            j = i\n            while s[j] != \"#\":\n                j += 1\n\n            strLen = int(s[i:j])\n            decoded.append(s[j + 1 : j + 1 + strLen])\n            i = j + 1 + strLen\n\n        return decoded\n\n\n# |-------------|-------------|--------------|\n# |   Approach  |    Time     |    Space     |\n# |-------------|-------------|--------------|\n# | Two pointers|    O(n)     |     O(n)     |\n# |-------------|-------------|--------------|\n\n\ncodec = Codec()\nencoded = codec.encode([\"hello\", \"world\"])\nprint(encoded)  # \"5#hello5#world\"\ndecoded = codec.decode(encoded)\nprint(decoded)  # [\"hello\", \"world\"]\n</code></pre>"},{"location":"premium-100/design/#281-zigzag-iterator","title":"281. Zigzag Iterator \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Design, Queue, Iterator</p> </li> </ul>"},{"location":"premium-100/design/#716-max-stack","title":"716. Max Stack \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Stack, Design, Doubly Linked List, Ordered Set</p> </li> </ul>"},{"location":"premium-100/design/#1244-design-a-leaderboard","title":"1244. Design A Leaderboard \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Design, Sorting</p> </li> </ul> Python <pre><code>class Leaderboard:\n\n    def __init__(self):\n        self.scores = {}\n\n    def addScore(self, playerId: int, score: int) -&gt; None:\n        if playerId in self.scores:\n            self.scores[playerId] += score\n        else:\n            self.scores[playerId] = score\n\n    def top(self, K: int) -&gt; int:\n        topK = sorted(self.scores.values(), reverse=True)[:K]\n        return sum(topK)\n\n    def reset(self, playerId: int) -&gt; None:\n        if playerId in self.scores:\n            self.scores[playerId] = 0\n\n\nboard = Leaderboard()\nboard.addScore(1, 73)\nboard.addScore(2, 56)\nboard.addScore(3, 39)\nboard.addScore(4, 51)\nprint(board.top(1))  # 73\nboard.reset(1)\nboard.reset(2)\nprint(board.top(2))  # 90\n</code></pre>"},{"location":"premium-100/design/#428-serialize-and-deserialize-n-ary-tree","title":"428. Serialize and Deserialize N-ary Tree \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Tree, Depth First Search, Breadth First Search</p> </li> </ul> Python <pre><code>from typing import List, Optional\n\n\nclass Node(object):\n    def __init__(\n        self,\n        val: Optional[int] = None,\n        children: Optional[List[\"Node\"]] = None,\n    ):\n        if children is None:\n            children = []\n        self.val = val\n        self.children = children\n\n\n# DFS\nclass CodecDFS:\n    def serialize(self, root: \"Node\") -&gt; str:\n        \"\"\"Encodes a tree to a single string.\n\n        :type root: Node\n        :rtype: str\n        \"\"\"\n        if not root:\n            return \"*\"\n\n        data = \"\"\n        data += str(root.val) + \"|\" + str(len(root.children))\n        for child in root.children:\n            data += \"|\" + self.serialize(child)\n        return data\n\n    def deserialize(self, data: str) -&gt; \"Node\":\n        \"\"\"Decodes your encoded data to tree.\n\n        :type data: str\n        :rtype: Node\n        \"\"\"\n        if data == \"*\":\n            return None\n\n        data = data.split(\"|\")[::-1]\n\n        def dfs(data):\n            root = Node(int(data.pop()))\n            size = int(data.pop())\n            for i in range(size):\n                root.children.append(dfs(data))\n            return root\n\n        return dfs(data)\n\n\nif __name__ == \"__main__\":\n    obj = CodecDFS()\n    root = Node(1, [Node(3, [Node(5), Node(6)]), Node(2), Node(4)])\n    data = obj.serialize(root)\n    print(data)  # 1|3|3|2|5|0|6|0|2|0|4|0\n    root = obj.deserialize(data)\n    print(root.val)  # 1\n    print(root.children[0].val)  # 3\n    print(root.children[1].val)  # 2\n    print(root.children[2].val)  # 4\n    print(root.children[0].children[0].val)  # 5\n</code></pre>"},{"location":"premium-100/design/#431-encode-n-ary-tree-to-binary-tree","title":"431. Encode N-ary Tree to Binary Tree \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Design, Binary Tree</p> </li> </ul>"},{"location":"premium-100/dynamic_programming/","title":"Dynamic Programming","text":""},{"location":"premium-100/dynamic_programming/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 276. Paint Fence (Medium) \ud83d\udc51</li> <li> 256. Paint House (Medium) \ud83d\udc51</li> <li> 265. Paint House II (Hard) \ud83d\udc51</li> <li> 651. 4 Keys Keyboard (Medium) \ud83d\udc51</li> <li> 1259. Handshakes That Don't Cross (Hard) \ud83d\udc51</li> </ul>"},{"location":"premium-100/dynamic_programming/#276-paint-fence","title":"276. Paint Fence \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming</p> </li> </ul>"},{"location":"premium-100/dynamic_programming/#256-paint-house","title":"256. Paint House \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"premium-100/dynamic_programming/#265-paint-house-ii","title":"265. Paint House II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul>"},{"location":"premium-100/dynamic_programming/#651-4-keys-keyboard","title":"651. 4 Keys Keyboard \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming</p> </li> </ul>"},{"location":"premium-100/dynamic_programming/#1259-handshakes-that-dont-cross","title":"1259. Handshakes That Don't Cross \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming</p> </li> </ul>"},{"location":"premium-100/graph/","title":"Graph","text":""},{"location":"premium-100/graph/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 277. Find the Celebrity (Medium) \ud83d\udc51</li> <li> 582. Kill Process (Medium) \ud83d\udc51</li> <li> 323. Number of Connected Components in an Undirected Graph (Medium) \ud83d\udc51</li> <li> 1059. All Paths from Source Lead to Destination (Medium) \ud83d\udc51</li> <li> 1236. Web Crawler (Medium) \ud83d\udc51</li> <li> 305. Number of Islands II (Hard) \ud83d\udc51</li> <li> 694. Number of Distinct Islands (Medium) \ud83d\udc51</li> <li> 1136. Parallel Courses (Medium) \ud83d\udc51</li> </ul>"},{"location":"premium-100/graph/#277-find-the-celebrity","title":"277. Find the Celebrity \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, Graph, Interactive</p> </li> </ul>"},{"location":"premium-100/graph/#582-kill-process","title":"582. Kill Process \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Tree, Depth First Search, Breadth First Search</p> </li> </ul> Python <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef killProcess(pid: List[int], ppid: List[int], kill: int) -&gt; List[int]:\n    graph = defaultdict(list)\n\n    for u, v in zip(ppid, pid):\n        graph[u].append(v)\n\n    q = deque([kill])\n    res = []\n\n    while q:\n        cur = q.popleft()\n        res.append(cur)\n        for nxt in graph[cur]:\n            q.append(nxt)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    pid = [1, 3, 10, 5]\n    ppid = [3, 0, 5, 3]\n    kill = 5\n    assert killProcess(pid, ppid, kill) == [5, 10]\n</code></pre>"},{"location":"premium-100/graph/#323-number-of-connected-components-in-an-undirected-graph","title":"323. Number of Connected Components in an Undirected Graph \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Union Find, Graph</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Union Find\ndef countComponents(n: int, edges: List[List[int]]) -&gt; int:\n    uf = UnionFind(n)\n    count = n\n\n    for u, v in edges:\n        count -= uf.union(u, v)\n\n    return count\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(n)}\n        self.rank = {i: 1 for i in range(n)}\n\n    def find(self, n):\n        p = self.par[n]\n        while self.par[p] != p:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return 0\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.par[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.par[p1] = p2\n        else:\n            self.par[p2] = p1\n            self.rank[p1] += 1\n\n        return 1\n\n\nprint(countComponents(5, [[0, 1], [1, 2], [3, 4]]))  # 2\n</code></pre>"},{"location":"premium-100/graph/#1059-all-paths-from-source-lead-to-destination","title":"1059. All Paths from Source Lead to Destination \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Graph, Topological Sort</p> </li> </ul>"},{"location":"premium-100/graph/#1236-web-crawler","title":"1236. Web Crawler \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Depth First Search, Breadth First Search, Interactive</p> </li> </ul>"},{"location":"premium-100/graph/#305-number-of-islands-ii","title":"305. Number of Islands II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Union Find</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef numIslands2(m: int, n: int, positions: List[List[int]]) -&gt; List[int]:\n    parent = defaultdict(tuple)\n    islands = 0\n    result = []\n    visited = set()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def find(node):\n        p = parent[node]\n        while parent[p] != p:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            parent[p1] = p2\n            return True\n        return False\n\n    for r, c in positions:\n        if (r, c) in visited:\n            result.append(islands)\n            continue\n\n        islands += 1\n        parent[(r, c)] = (r, c)\n        visited.add((r, c))\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if (nr, nc) in visited:\n                if union((r, c), (nr, nc)):\n                    islands -= 1\n\n        result.append(islands)\n\n    return result\n\n\nm = 3\nn = 3\npositions = [[0, 0], [0, 1], [1, 2], [2, 1]]\nprint(numIslands2(m, n, positions))  # [1, 1, 2, 3]\n</code></pre>"},{"location":"premium-100/graph/#694-number-of-distinct-islands","title":"694. Number of Distinct Islands \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Depth First Search, Breadth First Search, Union Find, Hash Function</p> </li> </ul> Python <pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# BFS\ndef numDistinctIslandsBFS(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    shapes = set()\n    dirs = [[1, 0], [0, 1], [0, -1], [-1, 0]]\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        shape = set()\n        grid[r][c] = 0\n\n        while q:\n            row, col = q.popleft()\n            shape.add((row - r, col - c))\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and grid[nr][nc] == 1:\n                    q.append((nr, nc))\n                    grid[nr][nc] = 0\n\n        return tuple(shape)\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                shapes.add(bfs(i, j))\n\n    return len(shapes)\n\n\n# DFS\ndef numDistinctIslandsDFS(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n\n    def dfs(r, c, org, shape):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] != 1:\n            return\n\n        grid[r][c] = 0\n        shape.add((r - org[0], c - org[1]))\n\n        dfs(r - 1, c, org, shape)\n        dfs(r + 1, c, org, shape)\n        dfs(r, c - 1, org, shape)\n        dfs(r, c + 1, org, shape)\n\n    shapes = set()\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                org = [i, j]\n                shape = set()\n                dfs(i, j, org, shape)\n                shapes.add(tuple(shape))\n\n    return len(shapes)\n\n\ngrid = [[1, 1, 0, 1, 1], [1, 0, 0, 0, 0], [0, 0, 0, 0, 1], [1, 1, 0, 1, 1]]\nprint(numDistinctIslandsBFS(deepcopy(grid)))  # 3\nprint(numDistinctIslandsDFS(deepcopy(grid)))  # 3\n</code></pre>"},{"location":"premium-100/graph/#1136-parallel-courses","title":"1136. Parallel Courses \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Graph, Topological Sort</p> </li> </ul> Python <pre><code>\"\"\"\n- Return the minimum number of semesters needed to take all courses.\n\n![1136](../../assets/1136.png)\n\"\"\"\n\nfrom collections import deque\nfrom typing import List\n\n\n# Topological Sort\ndef minimumSemesters(n: int, relations: List[List[int]]) -&gt; int:\n    graph = {i: [] for i in range(1, n + 1)}\n    indegree = {i: 0 for i in range(1, n + 1)}\n\n    for pre, nxt in relations:\n        graph[pre].append(nxt)\n        indegree[nxt] += 1\n\n    q = deque([i for i in range(1, n + 1) if indegree[i] == 0])\n    semester = 0\n    done = 0\n\n    while q:\n        semester += 1\n        size = len(q)\n\n        for _ in range(size):\n            pre = q.popleft()\n            done += 1\n\n            for nxt in graph[pre]:\n                indegree[nxt] -= 1\n                if indegree[nxt] == 0:\n                    q.append(nxt)\n\n    return semester if done == n else -1\n\n\nn = 3\nrelations = [[1, 3], [2, 3]]\nprint(minimumSemesters(n, relations))  # 2\n</code></pre>"},{"location":"premium-100/graph_bfs/","title":"Graph BFS","text":""},{"location":"premium-100/graph_bfs/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 490. The Maze (Medium) \ud83d\udc51</li> <li> 505. The Maze II (Medium) \ud83d\udc51</li> <li> 499. The Maze III (Hard) \ud83d\udc51</li> <li> 1197. Minimum Knight Moves (Medium) \ud83d\udc51</li> <li> 286. Walls and Gates (Medium) \ud83d\udc51</li> <li> 317. Shortest Distance from All Buildings (Hard) \ud83d\udc51</li> <li> 269. Alien Dictionary (Hard) \ud83d\udc51</li> </ul>"},{"location":"premium-100/graph_bfs/#490-the-maze","title":"490. The Maze \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Matrix</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef hasPathBFS(maze: List[List[int]], start: List[int], destination: List[int]) -&gt; bool:\n    m, n = len(maze), len(maze[0])\n    dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]]\n    q = deque([start])\n    maze[start[0]][start[1]] = -1\n\n    while q:\n        r, c = q.popleft()\n        if [r, c] == destination:\n            return True\n\n        for dr, dc in dirs:\n            nr, nc = r, c\n\n            while 0 &lt;= nr + dr &lt; m and 0 &lt;= nc + dc &lt; n and maze[nr + dr][nc + dc] != 1:\n                nr += dr\n                nc += dc\n\n            if maze[nr][nc] != -1:\n                q.append([nr, nc])\n                maze[nr][nc] = -1\n\n    return False\n\n\nmaze = [\n    [0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0],\n    [0, 0, 0, 1, 0],\n    [1, 1, 0, 1, 1],\n    [0, 0, 0, 0, 0],\n]\nstart = [0, 4]\ndestination = [4, 4]\nprint(hasPathBFS(maze, start, destination))  # True\n</code></pre>"},{"location":"premium-100/graph_bfs/#505-the-maze-ii","title":"505. The Maze II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Graph, Heap Priority Queue, Matrix, Shortest Path</p> </li> </ul> Python <pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra\ndef shortestDistance(\n    maze: List[List[int]], start: List[int], destination: List[int]\n) -&gt; int:\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    m, n = len(maze), len(maze[0])\n\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    dist[start[0]][start[1]] = 0\n\n    heap = [(0, start[0], start[1])]\n\n    while heap:\n        d, r, c = heapq.heappop(heap)\n\n        if [r, c] == destination:\n            return d\n\n        for dr, dc in directions:\n            nr, nc, nd = r, c, d\n\n            while 0 &lt;= nr + dr &lt; m and 0 &lt;= nc + dc &lt; n and maze[nr + dr][nc + dc] == 0:\n                nr += dr\n                nc += dc\n                nd += 1\n\n            if nd &lt; dist[nr][nc]:\n                dist[nr][nc] = nd\n                heapq.heappush(heap, (nd, nr, nc))\n\n    return -1\n\n\nmaze = [\n    [0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0],\n    [0, 0, 0, 1, 0],\n    [1, 1, 0, 1, 1],\n    [0, 0, 0, 0, 0],\n]\nstart = [0, 4]\ndestination = [4, 4]\nprint(shortestDistance(maze, start, destination))  # 12\n</code></pre>"},{"location":"premium-100/graph_bfs/#499-the-maze-iii","title":"499. The Maze III \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Depth First Search, Breadth First Search, Graph, Heap Priority Queue, Matrix, Shortest Path</p> </li> </ul> Python <pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra\ndef findShortestWay(maze: List[List[int]], ball: List[int], hole: List[int]) -&gt; str:\n    directions = [(-1, 0, \"u\"), (1, 0, \"d\"), (0, -1, \"l\"), (0, 1, \"r\")]\n    m, n = len(maze), len(maze[0])\n\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    dist[ball[0]][ball[1]] = 0\n\n    paths = [[\"\"] * n for _ in range(m)]\n    paths[ball[0]][ball[1]] = \"\"\n\n    heap = [(0, \"\", ball[0], ball[1])]\n\n    while heap:\n        d, path, x, y = heapq.heappop(heap)\n\n        if [x, y] == hole:\n            return path\n\n        for dx, dy, direction in directions:\n            nx, ny, nd = x, y, d\n\n            while 0 &lt;= nx + dx &lt; m and 0 &lt;= ny + dy &lt; n and maze[nx + dx][ny + dy] == 0:\n                nx += dx\n                ny += dy\n                nd += 1\n\n                if [nx, ny] == hole:\n                    break\n\n            new_path = path + direction\n            if nd &lt; dist[nx][ny] or (nd == dist[nx][ny] and new_path &lt; paths[nx][ny]):\n                dist[nx][ny] = nd\n                paths[nx][ny] = new_path\n                heapq.heappush(heap, (nd, new_path, nx, ny))\n\n    return \"impossible\"\n\n\nmaze = [\n    [0, 0, 0, 0, 0],\n    [1, 1, 0, 0, 1],\n    [0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 1],\n    [0, 1, 0, 0, 0],\n]\nball = [4, 3]\nhole = [0, 1]\nprint(findShortestWay(maze, ball, hole))  # \"lul\"\n</code></pre>"},{"location":"premium-100/graph_bfs/#1197-minimum-knight-moves","title":"1197. Minimum Knight Moves \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Breadth First Search</p> </li> </ul>"},{"location":"premium-100/graph_bfs/#286-walls-and-gates","title":"286. Walls and Gates \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Breadth First Search, Matrix</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# Multi-Source BFS\ndef wallsAndGates(rooms: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify rooms in-place instead.\n    \"\"\"\n    m, n = len(rooms), len(rooms[0])\n    visited = set()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def addRoom(r, c):\n        if 0 &lt;= r &lt; m and 0 &lt;= c &lt; n and (r, c) not in visited and rooms[r][c] != -1:\n            q.append((r, c))\n            visited.add((r, c))\n\n    q = deque()\n    for r in range(m):\n        for c in range(n):\n            if rooms[r][c] == 0:\n                q.append((r, c))\n                visited.add((r, c))\n\n    dist = 0\n\n    while q:\n        for _ in range(len(q)):\n            r, c = q.popleft()\n            rooms[r][c] = dist\n\n            for dr, dc in directions:\n                addRoom(r + dr, c + dc)\n        dist += 1\n\n\nif __name__ == \"__main__\":\n    rooms = [\n        [2147483647, -1, 0, 2147483647],\n        [2147483647, 2147483647, 2147483647, -1],\n        [2147483647, -1, 2147483647, -1],\n        [0, -1, 2147483647, 2147483647],\n    ]\n    wallsAndGates(rooms)\n    assert rooms == [\n        [3, -1, 0, 1],\n        [2, 2, 1, -1],\n        [1, -1, 2, -1],\n        [0, -1, 3, 4],\n    ]\n</code></pre>"},{"location":"premium-100/graph_bfs/#317-shortest-distance-from-all-buildings","title":"317. Shortest Distance from All Buildings \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Breadth First Search, Matrix</p> </li> </ul>"},{"location":"premium-100/graph_bfs/#269-alien-dictionary","title":"269. Alien Dictionary \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Depth First Search, Breadth First Search, Graph, Topological Sort</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the correct order of characters in the alien language.\n\"\"\"\n\nfrom collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS - Kahn's algorithm (Topological Sort)\ndef alienOrderBFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    indegree = {c: 0 for word in words for c in word}\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                    indegree[w2[j]] += 1\n                break\n\n    q = deque([c for c in indegree if indegree[c] == 0])\n    result = []\n\n    while q:\n        char = q.popleft()\n        result.append(char)\n\n        for neighbor in graph[char]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n\n    return \"\".join(result) if len(result) == len(indegree) else \"\"\n\n\n# DFS - Topological Sort\ndef alienOrderDFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    visited = {}\n    result = []\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                break\n\n    def dfs(c):\n        if c in visited:\n            return visited[c]\n\n        visited[c] = False\n        for neighbor in graph[c]:\n            if not dfs(neighbor):\n                return False\n\n        visited[c] = True\n        result.append(c)\n        return True\n\n    for c in list(graph.keys()):\n        if not dfs(c):\n            return \"\"\n\n    return \"\".join(result[::-1])\n\n\nwords = [\"wrt\", \"wrf\", \"er\", \"ett\", \"rftt\"]\nprint(alienOrderBFS(words))  # wertf\nprint(alienOrderDFS(words))  # wertf\n</code></pre>"},{"location":"premium-100/hashing/","title":"Hashing","text":""},{"location":"premium-100/hashing/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 760. Find Anagram Mappings (Easy) \ud83d\udc51</li> <li> 266. Palindrome Permutation (Easy) \ud83d\udc51</li> <li> 734. Sentence Similarity (Easy) \ud83d\udc51</li> <li> 1165. Single-Row Keyboard (Easy) \ud83d\udc51</li> <li> 249. Group Shifted Strings (Medium) \ud83d\udc51</li> <li> 1133. Largest Unique Number (Easy) \ud83d\udc51</li> <li> 1426. Counting Elements (Easy) \ud83d\udc51</li> <li> 1198. Find Smallest Common Element in All Rows (Medium) \ud83d\udc51</li> </ul>"},{"location":"premium-100/hashing/#760-find-anagram-mappings","title":"760. Find Anagram Mappings \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef anagramMappings(nums1: List[int], nums2: List[int]) -&gt; List[int]:\n    hashmap = {val: idx for idx, val in enumerate(nums2)}\n\n    return [hashmap[num] for num in nums1]\n\n\nif __name__ == \"__main__\":\n    nums1 = [12, 28, 46, 32, 50]\n    nums2 = [50, 12, 32, 46, 28]\n    print(anagramMappings(nums1, nums2))  # [1, 4, 3, 2, 0]\n    nums1 = [1, 2, 3]\n    nums2 = [3, 2, 1]\n    print(anagramMappings(nums1, nums2))  # [2, 1, 0]\n</code></pre>"},{"location":"premium-100/hashing/#266-palindrome-permutation","title":"266. Palindrome Permutation \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Bit Manipulation</p> </li> </ul> Python <pre><code>from collections import defaultdict\n\n\n# Hash\ndef canPermutePalindromeDict(s: str) -&gt; bool:\n    if len(s) == 1:\n        return True\n\n    count = defaultdict(int)\n\n    for ch in s:\n        if count[ch] == 1:\n            count[ch] = 0\n            continue\n        count[ch] = 1\n\n    return sum(count.values()) &lt;= 1\n\n\n# Set\ndef canPermutePalindromeSet(s: str) -&gt; bool:\n    if len(s) == 1:\n        return True\n\n    seen = set()\n\n    for ch in s:\n        if ch in seen:\n            seen.remove(ch)\n        else:\n            seen.add(ch)\n\n    return len(seen) &lt;= 1\n\n\nassert canPermutePalindromeDict(\"carerac\") is True\nassert canPermutePalindromeSet(\"carerac\") is True\n</code></pre>"},{"location":"premium-100/hashing/#734-sentence-similarity","title":"734. Sentence Similarity \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String</p> </li> </ul> Python <pre><code># Hash Set\ndef areSentencesSimilar(sentence1, sentence2, similarPairs):\n    if len(sentence1) != len(sentence2):\n        return False\n\n    sim = set(map(tuple, similarPairs))\n\n    for i in range(len(sentence1)):\n        s1, s2 = sentence1[i], sentence2[i]\n        if s1 == s2 or (s1, s2) in sim or (s2, s1) in sim:\n            continue\n        return False\n\n    return True\n\n\nif __name__ == \"__main__\":\n    sentence1 = [\"great\", \"acting\", \"skills\"]\n    sentence2 = [\"fine\", \"drama\", \"talent\"]\n    similarPairs = [\n        [\"great\", \"fine\"],\n        [\"drama\", \"acting\"],\n        [\"skills\", \"talent\"],\n    ]\n    print(areSentencesSimilar(sentence1, sentence2, similarPairs))  # True\n</code></pre>"},{"location":"premium-100/hashing/#1165-single-row-keyboard","title":"1165. Single-Row Keyboard \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String</p> </li> </ul> Python <pre><code>def calculateTime(keyboard: str, word: str) -&gt; int:\n    pos = {char: i for i, char in enumerate(keyboard)}\n    cur = 0\n    res = 0\n\n    for ch in word:\n        target = pos[ch]\n        res += abs(target - cur)\n        cur = target\n\n    return res\n\n\nif __name__ == \"__main__\":\n    keyboard = \"pqrstuvwxyzabcdefghijklmno\"\n    word = \"leetcode\"\n    print(calculateTime(keyboard, word))  # 73\n</code></pre>"},{"location":"premium-100/hashing/#249-group-shifted-strings","title":"249. Group Shifted Strings \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String</p> </li> </ul>"},{"location":"premium-100/hashing/#1133-largest-unique-number","title":"1133. Largest Unique Number \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Sorting</p> </li> </ul>"},{"location":"premium-100/hashing/#1426-counting-elements","title":"1426. Counting Elements \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table</p> </li> </ul>"},{"location":"premium-100/hashing/#1198-find-smallest-common-element-in-all-rows","title":"1198. Find Smallest Common Element in All Rows \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Binary Search, Matrix, Counting</p> </li> </ul>"},{"location":"premium-100/heap/","title":"Heap","text":""},{"location":"premium-100/heap/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1086. High Five (Easy) \ud83d\udc51</li> <li> 1167. Minimum Cost to Connect Sticks (Medium) \ud83d\udc51</li> <li> 1057. Campus Bikes (Medium) \ud83d\udc51</li> <li> 358. Rearrange String k Distance Apart (Hard) \ud83d\udc51</li> </ul>"},{"location":"premium-100/heap/#1086-high-five","title":"1086. High Five \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Sorting, Heap Priority Queue</p> </li> </ul> Python <pre><code>from collections import defaultdict\nfrom heapq import heappush, heappushpop\nfrom typing import List\n\n\n# Heap\ndef highFive(items: List[List[int]]) -&gt; List[List[int]]:\n    hashmap = defaultdict(list)  # id: scores\n\n    for idx, score in items:\n        if len(hashmap[idx]) &lt; 5:\n            heappush(hashmap[idx], score)\n        else:\n            heappushpop(hashmap[idx], score)\n\n    res = []\n    for idx in sorted(hashmap.keys()):\n        res.append([idx, sum(hashmap[idx]) // 5])\n    return res\n\n\nif __name__ == \"__main__\":\n    items = [\n        [1, 91],\n        [1, 92],\n        [2, 93],\n        [2, 97],\n        [1, 60],\n        [2, 77],\n        [1, 65],\n        [1, 87],\n        [1, 100],\n        [2, 100],\n        [2, 76],\n    ]\n    assert highFive(items) == [[1, 87], [2, 88]]\n</code></pre>"},{"location":"premium-100/heap/#1167-minimum-cost-to-connect-sticks","title":"1167. Minimum Cost to Connect Sticks \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Heap Priority Queue</p> </li> </ul> Python <pre><code>from heapq import heapify, heappop, heappush\nfrom typing import List\n\n\n# Heap\ndef connectSticks(sticks: List[int]) -&gt; int:\n    n = len(sticks)\n    heapify(sticks)\n    res = 0\n\n    while n &gt; 1:\n        x = heappop(sticks)\n        y = heappop(sticks)\n        res += x + y\n        heappush(sticks, x + y)\n        n -= 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert connectSticks([2, 4, 3]) == 14\n    assert connectSticks([1, 8, 3, 5]) == 30\n    assert connectSticks([5]) == 0\n    assert connectSticks([1, 2, 3, 4, 5]) == 33\n    assert connectSticks([1, 1, 1]) == 5\n</code></pre>"},{"location":"premium-100/heap/#1057-campus-bikes","title":"1057. Campus Bikes \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Greedy, Sorting</p> </li> </ul> Python <pre><code>from heapq import heappop, heappush\nfrom typing import List\n\n\n# Heap\ndef assignBikes(workers: List[List[int]], bikes: List[List[int]]) -&gt; List[int]:\n    dist = []\n    done1, done2 = set(), set()\n    res = [0 for _ in range(len(workers))]\n\n    for i, w in enumerate(workers):\n        for j, b in enumerate(bikes):\n            d = abs(w[0] - b[0]) + abs(w[1] - b[1])\n            heappush(dist, (d, i, j))\n\n    while dist:\n        d, i, j = heappop(dist)\n        if i not in done1 and j not in done2:\n            res[i] = j\n            done1.add(i)\n            done2.add(j)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    workers = [[0, 0], [2, 1]]\n    bikes = [[1, 2], [3, 3]]\n    assert assignBikes(workers, bikes) == [1, 0]\n    workers = [[0, 0], [1, 1], [2, 0]]\n    bikes = [[1, 0], [2, 2], [2, 1]]\n    assert assignBikes(workers, bikes) == [0, 2, 1]\n</code></pre>"},{"location":"premium-100/heap/#358-rearrange-string-k-distance-apart","title":"358. Rearrange String k Distance Apart \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Greedy, Sorting, Heap Priority Queue, Counting</p> </li> </ul>"},{"location":"premium-100/interval/","title":"Interval","text":""},{"location":"premium-100/interval/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 163. Missing Ranges (Easy) \ud83d\udc51</li> <li> 252. Meeting Rooms (Easy) \ud83d\udc51</li> <li> 253. Meeting Rooms II (Medium) \ud83d\udc51</li> <li> 616. Add Bold Tag in String (Medium) \ud83d\udc51</li> <li> 1272. Remove Interval (Medium) \ud83d\udc51</li> </ul>"},{"location":"premium-100/interval/#163-missing-ranges","title":"163. Missing Ranges \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef findMissingRanges(nums: List[int], lower: int, upper: int) -&gt; List[List[int]]:\n    n = len(nums)\n    res = []\n    if n == 0:\n        return [[lower, upper]]\n\n    # start\n    if nums[0] &gt; lower:\n        res.append([lower, nums[0] - 1])\n\n    # middle\n    for i in range(n - 1):\n        if nums[i] + 1 &lt; nums[i + 1]:\n            res.append([nums[i] + 1, nums[i + 1] - 1])\n\n    # end\n    if nums[-1] &lt; upper:\n        res.append([nums[-1] + 1, upper])\n\n    return res\n\n\ndef findMissingRangesCompact(nums: List[int], lower: int, upper: int) -&gt; List[List[int]]:\n    res = []\n\n    for num in nums + [upper + 1]:\n        if num &gt; lower:\n            res.append([lower, num - 1])\n        lower = num + 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    nums = [0, 1, 3, 50, 75]\n    lower = 0\n    upper = 99\n    assert findMissingRanges(nums, lower, upper) == [\n        [2, 2],\n        [4, 49],\n        [51, 74],\n        [76, 99],\n    ]\n    assert findMissingRangesCompact(nums, lower, upper) == [\n        [2, 2],\n        [4, 49],\n        [51, 74],\n        [76, 99],\n    ]\n</code></pre>"},{"location":"premium-100/interval/#252-meeting-rooms","title":"252. Meeting Rooms \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sorting</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Interval\ndef canAttendMeetings(intervals: List[List[int]]) -&gt; bool:\n    intervals.sort(key=lambda x: x[0])\n    n = len(intervals)\n\n    if n &lt;= 1:\n        return True\n\n    for i in range(1, n):\n        if intervals[i][0] &lt; intervals[i - 1][1]:\n            return False\n\n    return True\n\n\nif __name__ == \"__main__\":\n    intervals = [[0, 30], [5, 10], [15, 20]]\n    assert not canAttendMeetings(intervals)\n</code></pre>"},{"location":"premium-100/interval/#253-meeting-rooms-ii","title":"253. Meeting Rooms II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Greedy, Sorting, Heap Priority Queue, Prefix Sum</p> </li> </ul> Python <pre><code>\"\"\"\n- Given an array of meeting time `intervals` where `intervals[i] = [start_i, end_i]`, return the minimum number of conference rooms required.\n\"\"\"\n\nimport heapq\nfrom typing import List\n\n\n# Heap\ndef minMeetingRooms(intervals: List[List[int]]) -&gt; int:\n    if not intervals:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n    minHeap = [intervals[0][1]]\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &gt;= minHeap[0]:\n            heapq.heappop(minHeap)\n        heapq.heappush(minHeap, intervals[i][1])\n\n    return len(minHeap)\n\n\nif __name__ == \"__main__\":\n    intervals = [[0, 30], [5, 10], [15, 20]]\n    assert minMeetingRooms(intervals) == 2\n</code></pre>"},{"location":"premium-100/interval/#616-add-bold-tag-in-string","title":"616. Add Bold Tag in String \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Trie, String Matching</p> </li> </ul>"},{"location":"premium-100/interval/#1272-remove-interval","title":"1272. Remove Interval \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array</p> </li> </ul>"},{"location":"premium-100/linked_list/","title":"Linked List","text":""},{"location":"premium-100/linked_list/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1474. Delete N Nodes After M Nodes of a Linked List (Easy) \ud83d\udc51</li> <li> 708. Insert into a Sorted Circular Linked List (Medium) \ud83d\udc51</li> <li> 369. Plus One Linked List (Medium) \ud83d\udc51</li> <li> 1265. Print Immutable Linked List in Reverse (Medium) \ud83d\udc51</li> </ul>"},{"location":"premium-100/linked_list/#1474-delete-n-nodes-after-m-nodes-of-a-linked-list","title":"1474. Delete N Nodes After M Nodes of a Linked List \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\ndef deleteNodes(head: Optional[ListNode], m: int, n: int) -&gt; Optional[ListNode]:\n    dummy = ListNode(0, head)\n    cur = dummy\n\n    while cur.next:\n        for _ in range(m):\n            if not cur.next:\n                break\n            cur = cur.next\n\n        for _ in range(n):\n            if not cur.next:\n                break\n            cur.next = cur.next.next\n\n    return dummy.next\n\n\ndef test_deleteMiddle():\n    ll = LinkedList(list(range(1, 14)))\n    assert ll.to_array() == list(range(1, 14))\n\n    ll = LinkedList(deleteNodes(ll.head, 2, 3))\n    assert ll.to_array() == [1, 2, 6, 7, 11, 12]\n</code></pre>"},{"location":"premium-100/linked_list/#708-insert-into-a-sorted-circular-linked-list","title":"708. Insert into a Sorted Circular Linked List \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List</p> </li> </ul>"},{"location":"premium-100/linked_list/#369-plus-one-linked-list","title":"369. Plus One Linked List \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Math</p> </li> </ul>"},{"location":"premium-100/linked_list/#1265-print-immutable-linked-list-in-reverse","title":"1265. Print Immutable Linked List in Reverse \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Two Pointers, Stack, Recursion</p> </li> </ul>"},{"location":"premium-100/math/","title":"Math","text":""},{"location":"premium-100/math/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1134. Armstrong Number (Easy) \ud83d\udc51</li> <li> 1180. Count Substrings with Only One Distinct Letter (Easy) \ud83d\udc51</li> <li> 1538. Guess the Majority in a Hidden Array (Medium) \ud83d\udc51</li> <li> 1183. Maximum Number of Ones (Hard) \ud83d\udc51</li> </ul>"},{"location":"premium-100/math/#1134-armstrong-number","title":"1134. Armstrong Number \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math</p> </li> </ul>"},{"location":"premium-100/math/#1180-count-substrings-with-only-one-distinct-letter","title":"1180. Count Substrings with Only One Distinct Letter \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String</p> </li> </ul>"},{"location":"premium-100/math/#1538-guess-the-majority-in-a-hidden-array","title":"1538. Guess the Majority in a Hidden Array \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Interactive</p> </li> </ul>"},{"location":"premium-100/math/#1183-maximum-number-of-ones","title":"1183. Maximum Number of Ones \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Greedy, Sorting, Heap Priority Queue</p> </li> </ul>"},{"location":"premium-100/matrix/","title":"Matrix","text":""},{"location":"premium-100/matrix/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 422. Valid Word Square (Easy) \ud83d\udc51</li> <li> 531. Lonely Pixel I (Medium) \ud83d\udc51</li> <li> 311. Sparse Matrix Multiplication (Medium) \ud83d\udc51</li> <li> 723. Candy Crush (Medium) \ud83d\udc51</li> </ul>"},{"location":"premium-100/matrix/#422-valid-word-square","title":"422. Valid Word Square \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Matrix</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef validWordSquare(words: List[str]) -&gt; bool:\n    n = len(words)\n\n    for i in range(n):\n        for j in range(len(words[i])):\n            if j &gt;= n or i &gt;= len(words[j]) or words[i][j] != words[j][i]:\n                return False\n    return True\n\n\n# Zip\ndef validWordSquareZip(words: List[str]) -&gt; bool:\n    max_len = max(len(word) for word in words)\n    padded_words = [word.ljust(max_len) for word in words]\n    transposed = [\"\".join(col) for col in zip(*padded_words)]\n    return padded_words == transposed\n\n\nif __name__ == \"__main__\":\n    words1 = [\"abcd\", \"bnrt\", \"crmy\", \"dtye\"]\n    assert validWordSquare(words1)\n    assert validWordSquareZip(words1)\n\n    words2 = [\"abcd\", \"bnrt\", \"crm\", \"dt\"]\n    assert validWordSquare(words2)\n    assert validWordSquareZip(words2)\n\n    words3 = [\"ball\", \"area\", \"read\", \"lady\"]\n    assert not validWordSquare(words3)\n    assert not validWordSquareZip(words3)\n</code></pre>"},{"location":"premium-100/matrix/#531-lonely-pixel-i","title":"531. Lonely Pixel I \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Matrix</p> </li> </ul>"},{"location":"premium-100/matrix/#311-sparse-matrix-multiplication","title":"311. Sparse Matrix Multiplication \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Matrix</p> </li> </ul>"},{"location":"premium-100/matrix/#723-candy-crush","title":"723. Candy Crush \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Matrix, Simulation</p> </li> </ul>"},{"location":"premium-100/n-ary_tree/","title":"N-ary Tree","text":""},{"location":"premium-100/n-ary_tree/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1490. Clone N-ary Tree (Medium) \ud83d\udc51</li> <li> 1506. Find Root of N-Ary Tree (Medium) \ud83d\udc51</li> <li> 1522. Diameter of N-Ary Tree (Medium) \ud83d\udc51</li> </ul>"},{"location":"premium-100/n-ary_tree/#1490-clone-n-ary-tree","title":"1490. Clone N-ary Tree \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Tree, Depth First Search, Breadth First Search</p> </li> </ul>"},{"location":"premium-100/n-ary_tree/#1506-find-root-of-n-ary-tree","title":"1506. Find Root of N-Ary Tree \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Bit Manipulation, Tree, Depth First Search</p> </li> </ul>"},{"location":"premium-100/n-ary_tree/#1522-diameter-of-n-ary-tree","title":"1522. Diameter of N-Ary Tree \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search</p> </li> </ul> Python <pre><code>from typing import List, Optional\n\n\nclass Node:\n    def __init__(\n        self,\n        val: Optional[int] = None,\n        children: Optional[List[\"Node\"]] = None,\n    ):\n        self.val = val\n        self.children = children if children is not None else []\n\n\ndef diameter(root: \"Node\") -&gt; int:\n\n    def dfs(node):\n        if not node.children:\n            return 1, 1\n        mx0, mx1 = 0, 0\n        mxf = 0\n        for child in node.children:\n            hl, fl = dfs(child)\n            mxf = max(mxf, fl)\n            if hl &gt; mx1:\n                if hl &lt; mx0:\n                    mx1 = hl\n                else:\n                    mx0, mx1 = hl, mx0\n        return mx0 + 1, max(mxf, mx0 + mx1 + 1)\n\n    return dfs(root)[1] - 1\n\n\nroot = [1, None, 2, None, 3, 4, None, 5, None, 6]\nroot = Node(1)\nroot.children = [Node(2)]\nroot.children[0].children = [Node(3), Node(4)]\nroot.children[0].children[0].children = [Node(5)]\nroot.children[0].children[1].children = [Node(6)]\nprint(diameter(root))  # 4\n</code></pre>"},{"location":"premium-100/queue/","title":"Queue","text":""},{"location":"premium-100/queue/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 346. Moving Average from Data Stream (Easy) \ud83d\udc51</li> <li> 1429. First Unique Number (Medium) \ud83d\udc51</li> </ul>"},{"location":"premium-100/queue/#346-moving-average-from-data-stream","title":"346. Moving Average from Data Stream \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Design, Queue, Data Stream</p> </li> </ul> Python <pre><code>from collections import deque\n\n\n# Deque\nclass MovingAverage:\n    def __init__(self, size: int):\n        self.q = deque()\n        self.cur = 0\n        self.sum = 0\n        self.size = size\n\n    def next(self, val: int) -&gt; float:\n        if self.cur &gt;= self.size:\n            self.sum -= self.q.popleft()\n            self.cur -= 1\n\n        self.q.append(val)\n        self.sum += val\n        self.cur += 1\n\n        return self.sum / self.cur\n\n\nif __name__ == \"__main__\":\n    ma = MovingAverage(3)\n    assert ma.next(1) == 1.0\n    assert ma.next(10) == 5.5\n    assert ma.next(3) == 4.666666666666667\n    assert ma.next(5) == 6.0\n</code></pre>"},{"location":"premium-100/queue/#1429-first-unique-number","title":"1429. First Unique Number \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Design, Queue, Data Stream</p> </li> </ul> Python <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# Deque\nclass FirstUnique:\n\n    def __init__(self, nums: List[int]):\n        self.all = set()\n        self.multi = set()\n\n        for num in nums:\n            if num in self.all:\n                self.multi.add(num)\n            self.all.add(num)\n\n        self.q = deque([i for i in nums if i not in self.multi])\n\n    def showFirstUnique(self) -&gt; int:\n        while self.q and self.q[0] in self.multi:\n            self.q.popleft()\n        return self.q[0] if self.q else -1\n\n    def add(self, value: int) -&gt; None:\n        if value not in self.all:\n            self.all.add(value)\n            self.q.append(value)\n        elif value not in self.multi:\n            self.multi.add(value)\n\n\nif __name__ == \"__main__\":\n    nums = [2, 3, 5]\n    firstUnique = FirstUnique(nums)\n    assert firstUnique.showFirstUnique() == 2\n    firstUnique.add(5)\n    assert firstUnique.showFirstUnique() == 2\n    firstUnique.add(2)\n    assert firstUnique.showFirstUnique() == 3\n    firstUnique.add(3)\n    assert firstUnique.showFirstUnique() == -1\n</code></pre>"},{"location":"premium-100/sliding_window/","title":"Sliding Window","text":""},{"location":"premium-100/sliding_window/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 159. Longest Substring with At Most Two Distinct Characters (Medium) \ud83d\udc51</li> <li> 340. Longest Substring with At Most K Distinct Characters (Medium) \ud83d\udc51</li> <li> 487. Max Consecutive Ones II (Medium) \ud83d\udc51</li> <li> 1100. Find K-Length Substrings With No Repeated Characters (Medium) \ud83d\udc51</li> </ul>"},{"location":"premium-100/sliding_window/#159-longest-substring-with-at-most-two-distinct-characters","title":"159. Longest Substring with At Most Two Distinct Characters \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> Python <pre><code>\"\"\"\n-   Prerequisite: 3. Longest Substring Without Repeating Characters\n\"\"\"\n\nfrom collections import defaultdict\n\n\n# Sliding Window - Variable\ndef lengthOfLongestSubstringTwoDistinct(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 2:\n        return n\n\n    window = defaultdict(int)\n    left, res = 0, 0\n\n    for right in range(n):\n        window[s[right]] += 1\n\n        while len(window) &gt; 2:\n            window[s[left]] -= 1\n            if window[s[left]] == 0:\n                del window[s[left]]\n            left += 1\n\n        res = max(res, right - left + 1)\n\n    return res\n\n\ns = \"ccaabbb\"\nassert lengthOfLongestSubstringTwoDistinct(s) == 5\n</code></pre>"},{"location":"premium-100/sliding_window/#340-longest-substring-with-at-most-k-distinct-characters","title":"340. Longest Substring with At Most K Distinct Characters \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> Python <pre><code>from collections import defaultdict\n\n\n# Sliding Window Variable\ndef lengthOfLongestSubstringKDistinct(s: str, k: int) -&gt; int:\n    n = len(s)\n    if n &lt;= k:\n        return n\n\n    window = defaultdict(int)\n    left, res = 0, 0\n\n    for right in range(n):\n        window[s[right]] += 1\n        while len(window) &gt; k:\n            window[s[left]] -= 1\n            if window[s[left]] == 0:\n                del window[s[left]]\n            left += 1\n        res = max(res, right - left + 1)\n\n    return res\n\n\ns = \"eceba\"\nk = 2\nassert lengthOfLongestSubstringKDistinct(s, k) == 3\n</code></pre>"},{"location":"premium-100/sliding_window/#487-max-consecutive-ones-ii","title":"487. Max Consecutive Ones II \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Sliding Window</p> </li> </ul>"},{"location":"premium-100/sliding_window/#1100-find-k-length-substrings-with-no-repeated-characters","title":"1100. Find K-Length Substrings With No Repeated Characters \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> Python <pre><code>from collections import defaultdict\n\n\n# Sliding Window Fixed Size\ndef numKLenSubstrNoRepeats(s: str, k: int) -&gt; int:\n    n = len(s)\n    if k &gt; n:\n        return 0\n\n    counts = defaultdict(int)\n    res = 0\n\n    for i, ch in enumerate(s):\n        # add to the window\n        counts[ch] += 1\n\n        # form a valid window\n        if i &lt; k - 1:\n            continue\n\n        # update\n        res += 1 if len(counts) == k else 0\n\n        # remove from the window\n        first = i - k + 1\n        counts[s[first]] -= 1\n        if counts[s[first]] == 0:\n            del counts[s[first]]\n\n    return res\n\n\nif __name__ == \"__main__\":\n    s = \"havefunonleetcode\"\n    k = 5\n\n    assert numKLenSubstrNoRepeats(s, k) == 6\n</code></pre>"},{"location":"premium-100/stack/","title":"Stack","text":""},{"location":"premium-100/stack/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 439. Ternary Expression Parser (Medium) \ud83d\udc51</li> <li> 484. Find Permutation (Medium) \ud83d\udc51</li> <li> 772. Basic Calculator III (Hard) \ud83d\udc51</li> </ul>"},{"location":"premium-100/stack/#439-ternary-expression-parser","title":"439. Ternary Expression Parser \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack, Recursion</p> </li> </ul> Python <pre><code># Stack\ndef parseTernary(expression: str) -&gt; str:\n    stack = []\n    i = len(expression) - 1\n\n    while i &gt;= 0:\n        c = expression[i]\n        if stack and stack[-1] == \"?\":\n            stack.pop()  # remove '?'\n            true_val = stack.pop()\n            stack.pop()  # remove ':'\n            false_val = stack.pop()\n            if c == \"T\":\n                stack.append(true_val)\n            else:\n                stack.append(false_val)\n        else:\n            stack.append(c)\n        i -= 1\n\n    return stack[-1]\n\n\nif __name__ == \"__main__\":\n    assert parseTernary(\"T?2:3\") == \"2\"\n    assert parseTernary(\"F?1:T?4:5\") == \"4\"\n    assert parseTernary(\"T?T?F:5:3\") == \"F\"\n</code></pre>"},{"location":"premium-100/stack/#484-find-permutation","title":"484. Find Permutation \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Stack, Greedy</p> </li> </ul>"},{"location":"premium-100/stack/#772-basic-calculator-iii","title":"772. Basic Calculator III \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, String, Stack, Recursion</p> </li> </ul> Python <pre><code># Stack\ndef calculate(s: str) -&gt; int:\n    def helper(index):\n        stack = []\n        num = 0\n        sign = \"+\"\n\n        while index &lt; len(s):\n            char = s[index]\n            if char.isdigit():\n                num = num * 10 + int(char)\n            if char == \"(\":\n                num, index = helper(index + 1)\n            if char in \"+-*/)\" or index == len(s) - 1:\n                if sign == \"+\":\n                    stack.append(num)\n                elif sign == \"-\":\n                    stack.append(-num)\n                elif sign == \"*\":\n                    stack.append(stack.pop() * num)\n                elif sign == \"/\":\n                    stack.append(int(stack.pop() / num))  # \u5411\u96f6\u53d6\u6574\n                num = 0\n                sign = char\n            if char == \")\":\n                break\n            index += 1\n\n        return sum(stack), index\n\n    s = s.replace(\" \", \"\")\n    result, _ = helper(0)\n\n    return result\n\n\ns = \"2*(5+5*2)/3+(6/2+8)\"\nprint(calculate(s))  # 21\n</code></pre>"},{"location":"premium-100/trie/","title":"Trie","text":""},{"location":"premium-100/trie/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 588. Design In-Memory File System (Hard) \ud83d\udc51</li> <li> 642. Design Search Autocomplete System (Hard) \ud83d\udc51</li> </ul>"},{"location":"premium-100/trie/#588-design-in-memory-file-system","title":"588. Design In-Memory File System \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Design, Trie, Sorting</p> </li> </ul> Python <pre><code>from collections import defaultdict\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children = defaultdict(TrieNode)\n        self.content = \"\"\n\n\n# Trie\nclass FileSystem:\n\n    def __init__(self):\n        self.root = TrieNode()\n\n    def ls(self, path: str) -&gt; list:\n        cur = self.root\n\n        if path != \"/\":\n            paths = path.split(\"/\")[1:]\n            for p in paths:\n                cur = cur.children[p]\n        if cur.content:\n            return [path.split(\"/\")[-1]]\n\n        return sorted(cur.children.keys())\n\n    def mkdir(self, path: str) -&gt; None:\n        cur = self.root\n        paths = path.split(\"/\")[1:]\n        for p in paths:\n            cur = cur.children[p]\n\n    def addContentToFile(self, filePath: str, content: str) -&gt; None:\n        cur = self.root\n        paths = filePath.split(\"/\")[1:]\n        for p in paths:\n            cur = cur.children[p]\n        cur.content += content\n\n    def readContentFromFile(self, filePath: str) -&gt; str:\n        cur = self.root\n        paths = filePath.split(\"/\")[1:]\n        for p in paths:\n            cur = cur.children[p]\n        return cur.content\n\n\nobj = FileSystem()\nobj.mkdir(\"/a/b/c\")\nobj.addContentToFile(\"/a/b/c/d\", \"hello\")\nprint(obj.ls(\"/\"))  # [\"a\"]\nprint(obj.readContentFromFile(\"/a/b/c/d\"))  # \"hello\"\n</code></pre>"},{"location":"premium-100/trie/#642-design-search-autocomplete-system","title":"642. Design Search Autocomplete System \ud83d\udc51","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Depth First Search, Design, Trie, Sorting, Heap Priority Queue, Data Stream</p> </li> </ul>"},{"location":"sql-50/advanced_select_and_joins/","title":"Advanced Select and Joins","text":""},{"location":"sql-50/advanced_select_and_joins/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1731. The Number of Employees Which Report to Each Employee (Easy)</li> <li> 1789. Primary Department for Each Employee (Easy)</li> <li> 610. Triangle Judgement (Easy)</li> <li> 180. Consecutive Numbers (Medium)</li> <li> 1164. Product Price at a Given Date (Medium)</li> <li> 1204. Last Person to Fit in the Bus (Medium)</li> <li> 1907. Count Salary Categories (Medium)</li> </ul>"},{"location":"sql-50/advanced_select_and_joins/#1731-the-number-of-employees-which-report-to-each-employee","title":"1731. The Number of Employees Which Report to Each Employee","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul>"},{"location":"sql-50/advanced_select_and_joins/#1789-primary-department-for-each-employee","title":"1789. Primary Department for Each Employee","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul>"},{"location":"sql-50/advanced_select_and_joins/#610-triangle-judgement","title":"610. Triangle Judgement","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul>"},{"location":"sql-50/advanced_select_and_joins/#180-consecutive-numbers","title":"180. Consecutive Numbers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul>"},{"location":"sql-50/advanced_select_and_joins/#1164-product-price-at-a-given-date","title":"1164. Product Price at a Given Date","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul>"},{"location":"sql-50/advanced_select_and_joins/#1204-last-person-to-fit-in-the-bus","title":"1204. Last Person to Fit in the Bus","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul>"},{"location":"sql-50/advanced_select_and_joins/#1907-count-salary-categories","title":"1907. Count Salary Categories","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul>"},{"location":"sql-50/advanced_string_functions_regex_clause/","title":"Advanced String Functions Regex Clause","text":""},{"location":"sql-50/advanced_string_functions_regex_clause/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1667. Fix Names in a Table (Easy)</li> <li> 1527. Patients With a Condition (Easy)</li> <li> 196. Delete Duplicate Emails (Easy)</li> <li> 176. Second Highest Salary (Medium)</li> <li> 1484. Group Sold Products By The Date (Easy)</li> <li> 1327. List the Products Ordered in a Period (Easy)</li> <li> 1517. Find Users With Valid E-Mails (Easy)</li> </ul>"},{"location":"sql-50/advanced_string_functions_regex_clause/#1667-fix-names-in-a-table","title":"1667. Fix Names in a Table","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul>"},{"location":"sql-50/advanced_string_functions_regex_clause/#1527-patients-with-a-condition","title":"1527. Patients With a Condition","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul>"},{"location":"sql-50/advanced_string_functions_regex_clause/#196-delete-duplicate-emails","title":"196. Delete Duplicate Emails","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul>"},{"location":"sql-50/advanced_string_functions_regex_clause/#176-second-highest-salary","title":"176. Second Highest Salary","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul>"},{"location":"sql-50/advanced_string_functions_regex_clause/#1484-group-sold-products-by-the-date","title":"1484. Group Sold Products By The Date","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul>"},{"location":"sql-50/advanced_string_functions_regex_clause/#1327-list-the-products-ordered-in-a-period","title":"1327. List the Products Ordered in a Period","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul>"},{"location":"sql-50/advanced_string_functions_regex_clause/#1517-find-users-with-valid-e-mails","title":"1517. Find Users With Valid E-Mails","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul>"},{"location":"sql-50/basic_aggregate_functions/","title":"Basic Aggregate Functions","text":""},{"location":"sql-50/basic_aggregate_functions/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 620. Not Boring Movies (Easy)</li> <li> 1251. Average Selling Price (Easy)</li> <li> 1075. Project Employees I (Easy)</li> <li> 1633. Percentage of Users Attended a Contest (Easy)</li> <li> 1211. Queries Quality and Percentage (Easy)</li> <li> 1193. Monthly Transactions I (Medium)</li> <li> 1174. Immediate Food Delivery II (Medium)</li> <li> 550. Game Play Analysis IV (Medium)</li> </ul>"},{"location":"sql-50/basic_aggregate_functions/#620-not-boring-movies","title":"620. Not Boring Movies","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul> SQL <pre><code>SELECT\n    id,\n    movie,\n    description,\n    rating\nFROM\n    cinema\nWHERE\n    id % 2 = 1\n    AND LOWER(description) NOT LIKE '%boring%'\nORDER BY\n    rating DESC;\n</code></pre>"},{"location":"sql-50/basic_aggregate_functions/#1251-average-selling-price","title":"1251. Average Selling Price","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul> SQL <pre><code>SELECT\n    p.product_id,\n    COALESCE(\n        ROUND(SUM(p.price * u.units) / SUM(u.units), 2),\n        0\n    ) AS average_price\nFROM\n    prices AS p\nLEFT JOIN unitssold AS u\n    ON\n        p.product_id = u.product_id\n        AND u.purchase_date BETWEEN p.start_date AND p.end_date\nGROUP BY\n    p.product_id;\n</code></pre>"},{"location":"sql-50/basic_aggregate_functions/#1075-project-employees-i","title":"1075. Project Employees I","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul> SQL <pre><code>SELECT\n    p.project_id,\n    ROUND(AVG(e.experience_years), 2) AS average_years\nFROM\n    project AS p\nLEFT JOIN employee AS e ON p.employee_id = e.employee_id\nGROUP BY\n    p.project_id\n</code></pre>"},{"location":"sql-50/basic_aggregate_functions/#1633-percentage-of-users-attended-a-contest","title":"1633. Percentage of Users Attended a Contest","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul> SQL <pre><code>SELECT\n    r.contest_id,\n    ROUND(\n        COUNT(DISTINCT r.user_id) / COUNT(DISTINCT u.user_id) * 100,\n        2\n    ) AS percentage\nFROM\n    users AS u\nCROSS JOIN register AS r\nGROUP BY\n    r.contest_id\nORDER BY\n    percentage DESC,\n    contest_id ASC\n</code></pre>"},{"location":"sql-50/basic_aggregate_functions/#1211-queries-quality-and-percentage","title":"1211. Queries Quality and Percentage","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul> SQLTXT <pre><code>SELECT\n    query_name,\n    ROUND(AVG(rating / POSITION), 2) AS quality,\n    ROUND(SUM(IF(rating &lt; 3, 1, 0)) / COUNT(*) * 100, 2)\n        AS poor_query_percentage\nFROM\n    queries\nWHERE\n    query_name IS NOT NULL\nGROUP BY\n    query_name;\n</code></pre> <pre><code>Input:\nQueries table:\n+------------+-------------------+----------+--------+\n| query_name | result            | position | rating |\n+------------+-------------------+----------+--------+\n| Dog        | Golden Retriever  | 1        | 5      |\n| Dog        | German Shepherd   | 2        | 5      |\n| Dog        | Mule              | 200      | 1      |\n| Cat        | Shirazi           | 5        | 2      |\n| Cat        | Siamese           | 3        | 3      |\n| Cat        | Sphynx            | 7        | 4      |\n+------------+-------------------+----------+--------+\nOutput:\n+------------+---------+-----------------------+\n| query_name | quality | poor_query_percentage |\n+------------+---------+-----------------------+\n| Dog        | 2.50    | 33.33                 |\n| Cat        | 0.66    | 33.33                 |\n+------------+---------+-----------------------+\n</code></pre>"},{"location":"sql-50/basic_aggregate_functions/#1193-monthly-transactions-i","title":"1193. Monthly Transactions I","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul> SQLTXT <pre><code>SELECT\n    country,\n    DATE_FORMAT(trans_date, '%Y-%m') AS month,\n    COUNT(*) AS trans_count,\n    COUNT(IF(state = 'approved', 1, NULL)) AS approved_count,\n    SUM(amount) AS trans_total_amount,\n    SUM(IF(state = 'approved', amount, 0)) AS approved_total_amount\nFROM\n    transactions\nGROUP BY\n    month,\n    country;\n</code></pre> <pre><code>Input:\nTransactions table:\n+------+---------+----------+--------+------------+\n| id   | country | state    | amount | trans_date |\n+------+---------+----------+--------+------------+\n| 121  | US      | approved | 1000   | 2018-12-18 |\n| 122  | US      | declined | 2000   | 2018-12-19 |\n| 123  | US      | approved | 2000   | 2019-01-01 |\n| 124  | DE      | approved | 2000   | 2019-01-07 |\n+------+---------+----------+--------+------------+\nOutput:\n+----------+---------+-------------+----------------+--------------------+-----------------------+\n| month    | country | trans_count | approved_count | trans_total_amount | approved_total_amount |\n+----------+---------+-------------+----------------+--------------------+-----------------------+\n| 2018-12  | US      | 2           | 1              | 3000               | 1000                  |\n| 2019-01  | US      | 1           | 1              | 2000               | 2000                  |\n| 2019-01  | DE      | 1           | 1              | 2000               | 2000                  |\n+----------+---------+-------------+----------------+--------------------+-----------------------+\n</code></pre>"},{"location":"sql-50/basic_aggregate_functions/#1174-immediate-food-delivery-ii","title":"1174. Immediate Food Delivery II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul>"},{"location":"sql-50/basic_aggregate_functions/#550-game-play-analysis-iv","title":"550. Game Play Analysis IV","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul>"},{"location":"sql-50/basic_joins/","title":"Basic Joins","text":""},{"location":"sql-50/basic_joins/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1378. Replace Employee ID With The Unique Identifier (Easy)</li> <li> 1068. Product Sales Analysis I (Easy)</li> <li> 1581. Customer Who Visited but Did Not Make Any Transactions (Easy)</li> <li> 197. Rising Temperature (Easy)</li> <li> 1661. Average Time of Process per Machine (Easy)</li> <li> 577. Employee Bonus (Easy)</li> <li> 1280. Students and Examinations (Easy)</li> <li> 570. Managers with at Least 5 Direct Reports (Medium)</li> <li> 1934. Confirmation Rate (Medium)</li> </ul>"},{"location":"sql-50/basic_joins/#1378-replace-employee-id-with-the-unique-identifier","title":"1378. Replace Employee ID With The Unique Identifier","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul> SQL <pre><code>-- Replace employee id with the unique identifier\nSELECT\n    unique_id,\n    name\nFROM\n    employees\nLEFT JOIN employeeuni ON employees.id = employeeuni.id;\n</code></pre>"},{"location":"sql-50/basic_joins/#1068-product-sales-analysis-i","title":"1068. Product Sales Analysis I","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul> SQL <pre><code>SELECT\n    p.product_name,\n    s.year,\n    s.price\nFROM\n    sales AS s\nLEFT JOIN product AS p ON s.product_id = p.product_id;\n</code></pre>"},{"location":"sql-50/basic_joins/#1581-customer-who-visited-but-did-not-make-any-transactions","title":"1581. Customer Who Visited but Did Not Make Any Transactions","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul> SQL <pre><code>-- 1. Left Join\nSELECT\n    v.customer_id,\n    COUNT(v.visit_id) AS count_no_trans\nFROM\n    visits AS v\nLEFT JOIN transactions AS t ON v.visit_id = t.visit_id\nWHERE\n    t.transaction_id IS NULL\nGROUP BY\n    v.customer_id;\n\n-- 2. Subquery\nSELECT\n    customer_id,\n    COUNT(DISTINCT visit_id) AS count_no_trans\nFROM\n    visits\nWHERE\n    visit_id NOT IN (\n        SELECT visit_id\n        FROM\n            transactions\n    )\nGROUP BY\n    customer_id;\n</code></pre>"},{"location":"sql-50/basic_joins/#197-rising-temperature","title":"197. Rising Temperature","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul> SQL <pre><code>SELECT w1.id\nFROM\n    weather AS w1\nLEFT JOIN weather AS w2 ON w1.recorddate - INTERVAL 1 DAY = w2.recorddate\nWHERE\n    w1.temperature &gt; w2.temperature;\n</code></pre>"},{"location":"sql-50/basic_joins/#1661-average-time-of-process-per-machine","title":"1661. Average Time of Process per Machine","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul> SQL <pre><code>SELECT\n    a1.machine_id,\n    ROUND(AVG(a2.timestamp - a1.timestamp), 3) AS processing_time\n    -- ROUND(SUM(a2.timestamp - a1.timestamp) / COUNT(*), 3) AS processing_time\nFROM\n    activity AS a1\nINNER JOIN activity AS a2\n    ON\n        a1.machine_id = a2.machine_id\n        AND a1.process_id = a2.process_id\n        AND a1.timestamp &lt; a2.timestamp\nGROUP BY\n    a1.machine_id;\n</code></pre>"},{"location":"sql-50/basic_joins/#577-employee-bonus","title":"577. Employee Bonus","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul> SQL <pre><code>-- 1.\nSELECT\n    e.name,\n    b.bonus\nFROM\n    employee AS e\nLEFT JOIN bonus AS b ON e.empid = b.empid\nWHERE\n    b.bonus &lt; 1000\n    OR b.bonus IS NULL;\n\n-- 2.\nSELECT\n    e.name,\n    b.bonus\nFROM\n    employee AS e\nLEFT JOIN bonus AS b ON e.empid = b.empid\nWHERE\n    COALESCE(b.bonus, 0) &lt; 1000;\n</code></pre>"},{"location":"sql-50/basic_joins/#1280-students-and-examinations","title":"1280. Students and Examinations","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul> SQL <pre><code>SELECT\n    st.student_id,\n    st.student_name,\n    su.subject_name,\n    COUNT(ex.student_id) AS attended_exams\nFROM\n    students AS st\nCROSS JOIN subjects AS su\nLEFT JOIN examinations AS ex\n    ON\n        st.student_id = ex.student_id\n        AND su.subject_name = ex.subject_name\nGROUP BY\n    st.student_id,\n    st.student_name,\n    su.subject_name\nORDER BY\n    st.student_id,\n    su.subject_name;\n</code></pre>"},{"location":"sql-50/basic_joins/#570-managers-with-at-least-5-direct-reports","title":"570. Managers with at Least 5 Direct Reports","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul> SQL <pre><code>SELECT e2.name\nFROM\n    employee AS e1\nINNER JOIN employee AS e2 ON e1.managerid = e2.id\nGROUP BY\n    e2.id,\n    e2.name\nHAVING\n    COUNT(e1.id) &gt;= 5;\n</code></pre>"},{"location":"sql-50/basic_joins/#1934-confirmation-rate","title":"1934. Confirmation Rate","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul> SQL <pre><code>SELECT\n    s.user_id,\n    ROUND(\n        SUM(IF(c.action = 'confirmed', 1, 0)) / COUNT(*),\n        2\n    ) AS confirmation_rate\nFROM\n    signups AS s\nLEFT JOIN confirmations AS c ON s.user_id = c.user_id\nGROUP BY\n    s.user_id;\n</code></pre>"},{"location":"sql-50/select/","title":"Select","text":""},{"location":"sql-50/select/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1757. Recyclable and Low Fat Products (Easy)</li> <li> 584. Find Customer Referee (Easy)</li> <li> 595. Big Countries (Easy)</li> <li> 1148. Article Views I (Easy)</li> <li> 1683. Invalid Tweets (Easy)</li> </ul>"},{"location":"sql-50/select/#1757-recyclable-and-low-fat-products","title":"1757. Recyclable and Low Fat Products","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul> SQLTXT <pre><code>SELECT product_id\nFROM\n    products\nWHERE\n    low_fats = 'Y'\n    AND recyclable = 'Y';\n</code></pre> <pre><code>Input:\nProducts table:\n+-------------+----------+------------+\n| product_id  | low_fats | recyclable |\n+-------------+----------+------------+\n| 0           | Y        | N          |\n| 1           | Y        | Y          |\n| 2           | N        | Y          |\n| 3           | Y        | Y          |\n| 4           | N        | N          |\n+-------------+----------+------------+\nOutput:\n+-------------+\n| product_id  |\n+-------------+\n| 1           |\n| 3           |\n+-------------+\n</code></pre>"},{"location":"sql-50/select/#584-find-customer-referee","title":"584. Find Customer Referee","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul> SQL <pre><code>-- 1.\nSELECT NAME\nFROM\n    CUSTOMER\nWHERE\n    REFEREE_ID &lt;&gt; 2\n    OR REFEREE_ID IS NULL;\n\n-- 2.\nSELECT NAME\nFROM\n    CUSTOMER\nWHERE\n    COALESCE(REFEREE_ID, -1) &lt;&gt; 2;\n\n-- 3.\nSELECT NAME\nFROM\n    CUSTOMER\nWHERE\n    COALESCE(REFEREE_ID, -1) &lt;&gt; 2;\n</code></pre>"},{"location":"sql-50/select/#595-big-countries","title":"595. Big Countries","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul> SQL <pre><code>SELECT\n    NAME,\n    POPULATION,\n    AREA\nFROM\n    WORLD\nWHERE\n    POPULATION &gt;= 25000000\n    OR AREA &gt;= 3000000;\n</code></pre>"},{"location":"sql-50/select/#1148-article-views-i","title":"1148. Article Views I","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul> SQL <pre><code>SELECT DISTINCT author_id AS id\nFROM\n    views\nWHERE\n    author_id = viewer_id\nORDER BY\n    id ASC;\n</code></pre>"},{"location":"sql-50/select/#1683-invalid-tweets","title":"1683. Invalid Tweets","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul> SQL <pre><code>SELECT tweet_id\nFROM\n    tweets\nWHERE\n    CHAR_LENGTH(content) &gt; 15;\n</code></pre>"},{"location":"sql-50/sorting_and_grouping/","title":"Sorting and Grouping","text":""},{"location":"sql-50/sorting_and_grouping/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2356. Number of Unique Subjects Taught by Each Teacher (Easy)</li> <li> 1141. User Activity for the Past 30 Days I (Easy)</li> <li> 1070. Product Sales Analysis III (Medium)</li> <li> 596. Classes More Than 5 Students (Easy)</li> <li> 1729. Find Followers Count (Easy)</li> <li> 619. Biggest Single Number (Easy)</li> <li> 1045. Customers Who Bought All Products (Medium)</li> </ul>"},{"location":"sql-50/sorting_and_grouping/#2356-number-of-unique-subjects-taught-by-each-teacher","title":"2356. Number of Unique Subjects Taught by Each Teacher","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul>"},{"location":"sql-50/sorting_and_grouping/#1141-user-activity-for-the-past-30-days-i","title":"1141. User Activity for the Past 30 Days I","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul>"},{"location":"sql-50/sorting_and_grouping/#1070-product-sales-analysis-iii","title":"1070. Product Sales Analysis III","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul>"},{"location":"sql-50/sorting_and_grouping/#596-classes-more-than-5-students","title":"596. Classes More Than 5 Students","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul>"},{"location":"sql-50/sorting_and_grouping/#1729-find-followers-count","title":"1729. Find Followers Count","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul>"},{"location":"sql-50/sorting_and_grouping/#619-biggest-single-number","title":"619. Biggest Single Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul>"},{"location":"sql-50/sorting_and_grouping/#1045-customers-who-bought-all-products","title":"1045. Customers Who Bought All Products","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul>"},{"location":"sql-50/subqueries/","title":"Subqueries","text":""},{"location":"sql-50/subqueries/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1978. Employees Whose Manager Left the Company (Easy)</li> <li> 626. Exchange Seats (Medium)</li> <li> 1341. Movie Rating (Medium)</li> <li> 1321. Restaurant Growth (Medium)</li> <li> 602. Friend Requests II: Who Has the Most Friends (Medium)</li> <li> 585. Investments in 2016 (Medium)</li> <li> 185. Department Top Three Salaries (Hard)</li> </ul>"},{"location":"sql-50/subqueries/#1978-employees-whose-manager-left-the-company","title":"1978. Employees Whose Manager Left the Company","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul>"},{"location":"sql-50/subqueries/#626-exchange-seats","title":"626. Exchange Seats","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul>"},{"location":"sql-50/subqueries/#1341-movie-rating","title":"1341. Movie Rating","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul>"},{"location":"sql-50/subqueries/#1321-restaurant-growth","title":"1321. Restaurant Growth","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul>"},{"location":"sql-50/subqueries/#602-friend-requests-ii-who-has-the-most-friends","title":"602. Friend Requests II: Who Has the Most Friends","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul>"},{"location":"sql-50/subqueries/#585-investments-in-2016","title":"585. Investments in 2016","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul>"},{"location":"sql-50/subqueries/#185-department-top-three-salaries","title":"185. Department Top Three Salaries","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Database</p> </li> </ul>"},{"location":"top-100-liked/arrays/","title":"Arrays","text":""},{"location":"top-100-liked/arrays/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 53. Maximum Subarray (Medium)</li> <li> 56. Merge Intervals (Medium)</li> <li> 189. Rotate Array (Medium)</li> <li> 238. Product of Array Except Self (Medium)</li> <li> 41. First Missing Positive (Hard)</li> </ul>"},{"location":"top-100-liked/arrays/#53-maximum-subarray","title":"53. Maximum Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Divide And Conquer, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP Kadane\ndef maxSubArrayDP(nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n\n    dp[0] = nums[0]\n    maxSum = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(\n            dp[i - 1] + nums[i],  # continue the previous subarray\n            nums[i],  # start a new subarray\n        )\n        maxSum = max(maxSum, dp[i])\n\n    return maxSum\n\n\n# Greedy\ndef maxSubArrayGreedy(nums: List[int]) -&gt; int:\n    max_sum = nums[0]\n    cur_sum = 0\n\n    for num in nums:\n        cur_sum = max(cur_sum + num, num)\n        max_sum = max(max_sum, cur_sum)\n\n    return max_sum\n\n\n# Prefix Sum\ndef maxSubArrayPrefixSum(nums: List[int]) -&gt; int:\n    prefix_sum = 0\n    prefix_sum_min = 0\n    res = float(\"-inf\")\n\n    for num in nums:\n        prefix_sum += num\n        res = max(res, prefix_sum - prefix_sum_min)\n        prefix_sum_min = min(prefix_sum_min, prefix_sum)\n\n    return res\n\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArrayDP(nums))  # 6\nprint(maxSubArrayGreedy(nums))  # 6\nprint(maxSubArrayPrefixSum(nums))  # 6\n</code></pre>"},{"location":"top-100-liked/arrays/#56-merge-intervals","title":"56. Merge Intervals","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Sorting</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Merge all overlapping intervals.\n\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/44H3cEC2fFM?si=J-Jr_Fg2eDse3-de\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen&gt;&lt;/iframe&gt;\n\"\"\"\n\nfrom typing import List\n\n\n# Intervals\ndef merge(intervals: List[List[int]]) -&gt; List[List[int]]:\n    n = len(intervals)\n    if n &lt;= 1:\n        return intervals\n\n    intervals.sort(key=lambda x: x[0])\n    res = [intervals[0]]\n\n    for i in range(1, n):\n        if intervals[i][0] &lt;= res[-1][1]:\n            res[-1][1] = max(res[-1][1], intervals[i][1])\n        else:\n            res.append(intervals[i])\n\n    return res\n\n\nprint(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))\n# [[1, 6], [8, 10], [15, 18]]\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// Interval\nvector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {\n    sort(intervals.begin(), intervals.end());\n    vector&lt;vector&lt;int&gt;&gt; res;\n\n    for (auto&amp; range : intervals) {\n        if (!res.empty() &amp;&amp; range[0] &lt;= res.back()[1]) {\n            res.back()[1] = max(res.back()[1], range[1]);\n        } else {\n            res.emplace_back(range);\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;vector&lt;int&gt;&gt; intervals = {{1, 3}, {2, 6}, {8, 10}, {15, 18}};\n    vector&lt;vector&lt;int&gt;&gt; res = merge(intervals);\n    for (auto&amp; range : res) {\n        cout &lt;&lt; range[0] &lt;&lt; \", \" &lt;&lt; range[1] &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"top-100-liked/arrays/#189-rotate-array","title":"189. Rotate Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Two Pointers</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Rotate array with reversing subarrays\n\"\"\"\n\nfrom typing import List\n\n\n# Array\ndef rotate(nums: List[int], k: int) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n\n    def reverse(i: int, j: int) -&gt; None:\n        while i &lt; j:\n            nums[i], nums[j] = nums[j], nums[i]\n            i += 1\n            j -= 1\n\n    n = len(nums)\n    k %= n\n    reverse(0, n - 1)\n    reverse(0, k - 1)\n    reverse(k, n - 1)\n\n\nnums = [1, 2, 3, 4, 5, 6, 7]\nk = 3\nrotate(nums, k)\nprint(nums)  # [5, 6, 7, 1, 2, 3, 4]\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// Array\nvoid rotate(vector&lt;int&gt;&amp; nums, int k) {\n    k %= nums.size();\n\n    reverse(nums.begin(), nums.end());\n    reverse(nums.begin(), nums.begin() + k);\n    reverse(nums.begin() + k, nums.end());\n}\n\nint main() {\n    vector&lt;int&gt; nums = {1, 2, 3, 4, 5, 6, 7};\n    int k = 3;\n    rotate(nums, k);\n    // [5, 6, 7, 1, 2, 3, 4]\n    for (const auto&amp; num : nums) {\n        cout &lt;&lt; num &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"top-100-liked/arrays/#238-product-of-array-except-self","title":"238. Product of Array Except Self","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Prefix Sum</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Classic **Prefix Sum** problem\n-   Return an array `output` such that `output[i]` is equal to the product of all the elements of `nums` except `nums[i]`.\n\n| Approach           | Time | Space |\n| ------------------ | ---- | ----- |\n| Prefix             | O(n) | O(n)  |\n| Prefix (Optimized) | O(n) | O(1)  |\n\"\"\"\n\nfrom typing import List\n\n\n# Prefix\ndef productExceptSelf(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    prefix = [1 for _ in range(n)]\n    suffix = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        prefix[i] = nums[i - 1] * prefix[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        suffix[i] = nums[i + 1] * suffix[i + 1]\n\n    result = [i * j for i, j in zip(prefix, suffix)]\n\n    return result\n\n\n# Prefix (Optimized)\ndef productExceptSelfOptimized(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    result = [1 for _ in range(n)]\n\n    prefix = 1\n    for i in range(n):\n        result[i] = prefix\n        prefix *= nums[i]\n\n    suffix = 1\n    for i in range(n - 1, -1, -1):\n        result[i] *= suffix\n        suffix *= nums[i]\n\n    return result\n\n\nprint(productExceptSelf([1, 2, 3, 4]))\n# [24, 12, 8, 6]\nprint(productExceptSelfOptimized([1, 2, 3, 4]))\n# [24, 12, 8, 6]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt; &amp;nums) {\n        int n = nums.size();\n        vector&lt;int&gt; prefix(n, 1);\n        vector&lt;int&gt; suffix(n, 1);\n        vector&lt;int&gt; res(n, 1);\n\n        for (int i = 1; i &lt; n; i++) {\n            prefix[i] = prefix[i - 1] * nums[i - 1];\n        }\n\n        for (int i = n - 2; i &gt;= 0; i--) {\n            suffix[i] = suffix[i + 1] * nums[i + 1];\n        }\n\n        for (int i = 0; i &lt; n; i++) {\n            res[i] = prefix[i] * suffix[i];\n        }\n        return res;\n    }\n};\n\nint main() {\n    vector&lt;int&gt; nums = {1, 2, 3, 4};\n    Solution obj;\n    vector&lt;int&gt; result = obj.productExceptSelf(nums);\n    assert(result == vector&lt;int&gt;({24, 12, 8, 6}));\n    return 0;\n}\n</code></pre>"},{"location":"top-100-liked/arrays/#41-first-missing-positive","title":"41. First Missing Positive","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# In-place Hashing\ndef firstMissingPositive(nums: List[int]) -&gt; int:\n    n = len(nums)\n\n    for i in range(n):\n        while 1 &lt;= nums[i] &lt;= n and nums[nums[i] - 1] != nums[i]:\n            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n\n    for i in range(n):\n        if nums[i] != i + 1:\n            return i + 1\n\n    return n + 1\n\n\nif __name__ == \"__main__\":\n    nums = [3, 4, -1, 1]\n    print(firstMissingPositive(nums))  # 2\n</code></pre>"},{"location":"top-100-liked/backtracking/","title":"Backtracking","text":""},{"location":"top-100-liked/backtracking/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 46. Permutations (Medium)</li> <li> 78. Subsets (Medium)</li> <li> 17. Letter Combinations of a Phone Number (Medium)</li> <li> 39. Combination Sum (Medium)</li> <li> 22. Generate Parentheses (Medium)</li> <li> 79. Word Search (Medium)</li> <li> 131. Palindrome Partitioning (Medium)</li> <li> 51. N-Queens (Hard)</li> </ul>"},{"location":"top-100-liked/backtracking/#46-permutations","title":"46. Permutations","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Backtracking\ndef permute(nums: List[int]) -&gt; List[List[int]]:\n    n = len(nums)\n    path, res = [], []\n    used = [False for _ in range(n)]\n\n    def dfs(x: int):\n        if x == n:\n            res.append(path[:])\n            return\n\n        for i in range(n):\n            if used[i]:\n                continue\n            used[i] = True\n            path.append(nums[i])\n            dfs(x + 1)\n            path.pop()\n            used[i] = False\n\n    dfs(0)\n\n    return res\n\n\nprint(permute([1, 2, 3]))\n# [[1, 2, 3], [1, 3, 2], [2, 1, 3],\n#  [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n</code></pre>"},{"location":"top-100-liked/backtracking/#78-subsets","title":"78. Subsets","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking, Bit Manipulation</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Iterative Inclusion Backtracking\ndef subsets_iterative_inclusion(nums: List[int]) -&gt; List[List[int]]:\n    n = len(nums)\n    res, path = [], []\n\n    def dfs(i):\n        res.append(path.copy())\n\n        for j in range(i, n):\n            path.append(nums[j])\n            dfs(j + 1)\n            path.pop()\n\n    dfs(0)\n\n    return res\n\n\n# Binary Decision Backtracking\ndef subsets_binary_decision(nums: List[int]) -&gt; List[List[int]]:\n    n = len(nums)\n    res, path = [], []\n\n    def dfs(i):\n        if i == n:\n            res.append(path.copy())\n            return\n\n        # Exclude\n        dfs(i + 1)\n\n        # Include\n        path.append(nums[i])\n        dfs(i + 1)\n        path.pop()\n\n    dfs(0)\n\n    return res\n\n\nprint(subsets_iterative_inclusion([1, 2, 3]))\n# [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]\nprint(subsets_binary_decision([1, 2, 3]))\n# [[], [3], [2], [2, 3], [1], [1, 3], [1, 2], [1, 2, 3]]\n</code></pre>"},{"location":"top-100-liked/backtracking/#17-letter-combinations-of-a-phone-number","title":"17. Letter Combinations of a Phone Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Backtracking</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return all possible letter combinations that the number could represent.\n\n![17](https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png)\n\"\"\"\n\nfrom typing import List\n\n\n# Backtracking\ndef letterCombinations(digits: str) -&gt; List[str]:\n    letter_map = {\n        \"2\": \"abc\",\n        \"3\": \"def\",\n        \"4\": \"ghi\",\n        \"5\": \"jkl\",\n        \"6\": \"mno\",\n        \"7\": \"pqrs\",\n        \"8\": \"tuv\",\n        \"9\": \"wxyz\",\n    }\n\n    n = len(digits)\n    if n == 0:\n        return []\n\n    res = []\n\n    def dfs(idx, path):\n        if idx == n:\n            res.append(path)\n            return None\n\n        letters = letter_map[digits[idx]]\n\n        for i in range(len(letters)):\n            dfs(idx + 1, path + letters[i])\n\n    dfs(0, \"\")\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert letterCombinations(\"23\") == [\n        \"ad\",\n        \"ae\",\n        \"af\",\n        \"bd\",\n        \"be\",\n        \"bf\",\n        \"cd\",\n        \"ce\",\n        \"cf\",\n    ]\n</code></pre>"},{"location":"top-100-liked/backtracking/#39-combination-sum","title":"39. Combination Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef combinationSum(candidates: List[int], target: int) -&gt; List[List[int]]:\n    n = len(candidates)\n    res, path = [], []\n\n    def dfs(total, start):\n        if total &gt; target:\n            return\n        if total == target:\n            res.append(path.copy())\n            return\n\n        for i in range(start, n):\n            total += candidates[i]\n            path.append(candidates[i])\n            dfs(total, i)\n            total -= candidates[i]\n            path.pop()\n\n    dfs(0, 0)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(combinationSum([2, 3, 5], 8))\n    # [[2, 2, 2, 2], [2, 3, 3], [3, 5]]\n    print(combinationSum([2, 3, 6, 7], 7))\n    # [[2, 2, 3], [7]]\n</code></pre>"},{"location":"top-100-liked/backtracking/#22-generate-parentheses","title":"22. Generate Parentheses","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Backtracking</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Backtracking\ndef generateParenthesis1(n: int) -&gt; List[str]:\n    path, res = [], []\n\n    def dfs(openN, closeN):\n        if openN == closeN == n:\n            res.append(\"\".join(path))\n            return\n\n        if openN &lt; n:\n            path.append(\"(\")\n            dfs(openN + 1, closeN)\n            path.pop()\n\n        if closeN &lt; openN:\n            path.append(\")\")\n            dfs(openN, closeN + 1)\n            path.pop()\n\n    dfs(0, 0)\n\n    return res\n\n\n# Backtracking\ndef generateParenthesis2(n: int) -&gt; List[str]:\n    m = n * 2\n    res, path = [], [\"\"] * m\n\n    def dfs(i, left):\n        if i == m:\n            res.append(\"\".join(path))\n            return\n\n        if left &lt; n:\n            path[i] = \"(\"\n            dfs(i + 1, left + 1)\n        if i - left &lt; left:\n            path[i] = \")\"\n            dfs(i + 1, left)\n\n    dfs(0, 0)\n    return res\n\n\nif __name__ == \"__main__\":\n    print(generateParenthesis1(3))\n    # ['((()))', '(()())', '(())()', '()(())', '()()()']\n    print(generateParenthesis2(3))\n    # ['((()))', '(()())', '(())()', '()(())', '()()()']\n</code></pre>"},{"location":"top-100-liked/backtracking/#79-word-search","title":"79. Word Search","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, String, Backtracking, Depth First Search, Matrix</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef exist(board: List[List[str]], word: str) -&gt; bool:\n    m, n = len(board), len(board[0])\n    path = set()\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n\n    def dfs(r, c, i):\n        if i == len(word):\n            return True\n\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or board[r][c] != word[i] or (r, c) in path:\n            return False\n\n        path.add((r, c))\n\n        for dr, dc in dirs:\n            if dfs(r + dr, c + dc, i + 1):\n                return True\n\n        path.remove((r, c))\n        return False\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, 0):\n                return True\n\n    return False\n\n\nboard = [\n    [\"A\", \"B\", \"C\", \"E\"],\n    [\"S\", \"F\", \"C\", \"S\"],\n    [\"A\", \"D\", \"E\", \"E\"],\n]\nword = \"ABCCED\"\nprint(exist(board, word))  # True\n</code></pre>"},{"location":"top-100-liked/backtracking/#131-palindrome-partitioning","title":"131. Palindrome Partitioning","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Backtracking</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Backtracking\ndef partition(s: str) -&gt; List[List[str]]:\n    n = len(s)\n    res, path = [], []\n\n    def dfs(start):\n        if start == n:\n            res.append(path.copy())\n            return\n\n        for end in range(start, n):\n            cur = s[start : end + 1]\n            if cur == cur[::-1]:\n                path.append(cur)\n                dfs(end + 1)\n                path.pop()\n\n    dfs(0)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(partition(\"aab\"))\n    # [['a', 'a', 'b'], ['aa', 'b']]\n</code></pre>"},{"location":"top-100-liked/backtracking/#51-n-queens","title":"51. N-Queens","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Backtracking</p> </li> </ul> Python <pre><code>\"\"\"\n- Hard\n- [N-Queens](https://leetcode.com/problems/n-queens/)\n- [N \u7687\u540e](https://leetcode.cn/problems/n-queens/)\n\"\"\"\n\nfrom typing import List\n\n\n# Backtracking\ndef solveNQueens(n: int) -&gt; List[List[str]]:\n    res = []\n    board = [\".\" * n for _ in range(n)]\n\n    def dfs(row):\n        if row == n:\n            res.append(board[:])\n            return None\n        for col in range(n):\n            if is_valid(row, col, board):\n                board[row] = board[row][:col] + \"Q\" + board[row][col + 1 :]\n                dfs(row + 1)\n                board[row] = board[row][:col] + \".\" + board[row][col + 1 :]\n\n    def is_valid(row, col, chessboard):\n        for i in range(row):\n            if chessboard[i][col] == \"Q\":\n                return False\n\n        i, j = row - 1, col - 1\n        while i &gt;= 0 and j &gt;= 0:\n            if chessboard[i][j] == \"Q\":\n                return False\n            i -= 1\n            j -= 1\n\n        i, j = row - 1, col + 1\n        while i &gt;= 0 and j &lt; len(chessboard):\n            if chessboard[i][j] == \"Q\":\n                return False\n            i -= 1\n            j += 1\n\n        return True\n\n    dfs(0)\n\n    return [[\"\".join(row) for row in i] for i in res]\n\n\n# Backtracking\ndef solveNQueens2(n: int) -&gt; List[List[str]]:\n    res = []\n    queens = [0] * n\n    col = [False] * n\n    diag1 = [False] * (n * 2 - 1)\n    diag2 = [False] * (n * 2 - 1)\n\n    def dfs(r: int) -&gt; None:\n        if r == n:\n            res.append([\".\" * c + \"Q\" + \".\" * (n - 1 - c) for c in queens])\n            return\n\n        for c, ok in enumerate(col):\n            if not ok and not diag1[r + c] and not diag2[r - c]:\n                queens[r] = c\n                col[c] = diag1[r + c] = diag2[r - c] = True\n                dfs(r + 1)\n                col[c] = diag1[r + c] = diag2[r - c] = False\n\n    dfs(0)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(solveNQueens(4))\n    # [['.Q..', '...Q', 'Q...', '..Q.'],\n    #  ['..Q.', 'Q...', '...Q', '.Q..']]\n    print(solveNQueens(1))\n    # [['Q']]\n    print(solveNQueens2(4))\n    # [['.Q..', '...Q', 'Q...', '..Q.'],\n    #  ['..Q.', 'Q...', '...Q', '.Q..']]\n    print(solveNQueens2(1))\n    # [['Q']]\n</code></pre>"},{"location":"top-100-liked/binary_search/","title":"Binary Search","text":""},{"location":"top-100-liked/binary_search/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 35. Search Insert Position (Easy)</li> <li> 74. Search a 2D Matrix (Medium)</li> <li> 34. Find First and Last Position of Element in Sorted Array (Medium)</li> <li> 33. Search in Rotated Sorted Array (Medium)</li> <li> 153. Find Minimum in Rotated Sorted Array (Medium)</li> <li> 4. Median of Two Sorted Arrays (Hard)</li> </ul>"},{"location":"top-100-liked/binary_search/#35-search-insert-position","title":"35. Search Insert Position","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return the index of the target if it is found. If not, return the index where it would be if it were inserted in order.\n\"\"\"\n\nfrom typing import List\n\n\n# Binary Search\ndef searchInsert(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        if nums[mid] &lt; target:\n            left = mid + 1\n        elif nums[mid] &gt; target:\n            right = mid - 1\n        else:\n            return mid\n\n    return left\n\n\nnums = [1, 3, 5, 6]\ntarget = 5\nprint(searchInsert(nums, target))  # 2\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int searchInsert(vector&lt;int&gt;&amp; nums, int target) {\n        int left = 0, right = nums.size() - 1;\n\n        while (left &lt;= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] &lt; target)\n                left = mid + 1;\n            else\n                right = mid - 1;\n        }\n        return left;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; nums = {1, 3, 5, 6};\n    assert(solution.searchInsert(nums, 5) == 2);\n    assert(solution.searchInsert(nums, 2) == 1);\n    assert(solution.searchInsert(nums, 7) == 4);\n    assert(solution.searchInsert(nums, 0) == 0);\n    return 0;\n}\n</code></pre>"},{"location":"top-100-liked/binary_search/#74-search-a-2d-matrix","title":"74. Search a 2D Matrix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Matrix</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Binary Search\ndef searchMatrix(matrix: List[List[int]], target: int) -&gt; bool:\n    if not matrix or not matrix[0]:\n        return False\n\n    m, n = len(matrix), len(matrix[0])\n    left, right = 0, m * n - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        x = matrix[mid // n][mid % n]\n\n        if x &lt; target:\n            left = mid + 1\n        elif x &gt; target:\n            right = mid - 1\n        else:\n            return True\n\n    return False\n\n\nif __name__ == \"__main__\":\n    matrix = [[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]]\n    target = 3\n    print(searchMatrix(matrix, target))  # True\n</code></pre>"},{"location":"top-100-liked/binary_search/#34-find-first-and-last-position-of-element-in-sorted-array","title":"34. Find First and Last Position of Element in Sorted Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> PythonCPP <pre><code>from bisect import bisect_left\nfrom typing import List\n\n\nclass searchRange:\n    \"\"\"\n    \u627e lower bound \u548c upper bound\n    \u770b\u7075\u795e\u5bf9\u8fd9\u9053\u9898\u7684\u9898\u89e3\uff0c\u5206\u7c7b\u8ba8\u8bba\u533a\u95f4\u7684\u5199\u6cd5\n    target \u7684 upper bound \u662f target + 1 \u7684 lower bound - 1\n    \u8fd9\u6837\u5c31\u80fd\u7edf\u4e00\u7528 lower bound \u7684\u5199\u6cd5\n    \"\"\"\n\n    # [left, right]\n    def bisect_left_closed(self, nums, target):\n        \"\"\"\n        \u95ed\u533a\u95f4\u5199\u6cd5\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left &lt;= right:\n            mid = left + (right - left) // 2\n            if nums[mid] &lt; target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n\n    # [left, right)\n    def bisect_left_right_open(self, nums, target):\n        \"\"\"\n        \u5de6\u95ed\u53f3\u5f00\u533a\u95f4\u5199\u6cd5\n        \"\"\"\n        left, right = 0, len(nums)\n        while left &lt; right:\n            mid = left + (right - left) // 2\n            if nums[mid] &gt;= target:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\n    # (left, right)\n    def bisect_left_open(self, nums, target):\n        \"\"\"\n        \u63a8\u8350\u5f00\u533a\u95f4\u5199\u6cd5\n        \"\"\"\n        left, right = -1, len(nums)\n        while left + 1 &lt; right:\n            mid = left + (right - left) // 2\n            if nums[mid] &lt; target:\n                left = mid\n            else:\n                right = mid\n        return right\n\n    def search_range(self, nums: List[int], target: int) -&gt; List[int]:\n        # edge case\n        if not nums:\n            return [-1, -1]\n\n        lower = self.bisect_left_closed(nums, target)\n        upper = self.bisect_left_closed(nums, target + 1) - 1\n\n        return [lower, upper] if lower &lt;= upper else [-1, -1]\n\n    def search_range_bisect(self, nums: List[int], target: int) -&gt; List[int]:\n        \"\"\"\u7528 python bisect \u5e93\u51fd\u6570\"\"\"\n        # edge case\n        if not nums:\n            return [-1, -1]\n\n        lower = bisect_left(nums, target)\n        upper = bisect_left(nums, target + 1) - 1\n\n        return [lower, upper] if lower &lt;= upper else [-1, -1]\n\n\nif __name__ == \"__main__\":\n    nums = [5, 7, 7, 8, 8, 10]\n    target = 8\n    sol = searchRange()\n    assert sol.search_range(nums, target) == [3, 4]\n    assert sol.search_range_bisect(nums, target) == [3, 4]\n</code></pre> <pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\n  int bisect_left(vector&lt;int&gt; &amp;nums, int target)\n  {\n    int left = 0, right = (int)nums.size() - 1;\n\n    while (left &lt;= right)\n    {\n      int mid = left + (right - left) / 2;\n      if (nums[mid] &lt; target)\n      {\n        left = mid + 1;\n      }\n      else\n      {\n        right = mid - 1;\n      }\n    }\n    return left;\n  }\n\npublic:\n  vector&lt;int&gt; searchRange(vector&lt;int&gt; &amp;nums, int target)\n  {\n    int left = bisect_left(nums, target);\n    if (left == (int)nums.size() || nums[left] != target)\n    {\n      return {-1, -1};\n    }\n    int right = bisect_left(nums, target + 1) - 1;\n    return {left, right};\n  }\n};\n\nint main()\n{\n  vector&lt;int&gt; nums = {5, 7, 7, 8, 8, 10};\n  int target = 8;\n  Solution s;\n  vector&lt;int&gt; res = s.searchRange(nums, target);\n  cout &lt;&lt; res[0] &lt;&lt; \", \" &lt;&lt; res[1] &lt;&lt; endl;\n  return 0;\n}\n</code></pre>"},{"location":"top-100-liked/binary_search/#33-search-in-rotated-sorted-array","title":"33. Search in Rotated Sorted Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Binary Search\ndef search(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] == target:\n            return mid\n\n        if nums[left] &lt;= nums[mid]:\n            if nums[left] &lt;= target &lt; nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if nums[mid] &lt; target &lt;= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n    return -1\n\n\nnums = [4, 5, 6, 7, 0, 1, 2]\ntarget = 0\nprint(search(nums, target))  # 4\n</code></pre>"},{"location":"top-100-liked/binary_search/#153-find-minimum-in-rotated-sorted-array","title":"153. Find Minimum in Rotated Sorted Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Binary Search\ndef findMin(nums: List[int]) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt; right:\n        mid = left + (right - left) // 2\n        if nums[mid] &gt; nums[right]:\n            left = mid + 1\n        else:\n            right = mid\n\n    return nums[right]\n\n\nnums = [4, 5, 6, 7, 0, 1, 2]\nprint(findMin(nums))  # 0\n</code></pre>"},{"location":"top-100-liked/binary_search/#4-median-of-two-sorted-arrays","title":"4. Median of Two Sorted Arrays","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Divide And Conquer</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Brute Force\ndef findMedianSortedArraysBF(nums1: List[int], nums2: List[int]) -&gt; float:\n    nums = sorted(nums1 + nums2)\n    n = len(nums)\n    if n % 2 == 0:\n        return (nums[n // 2 - 1] + nums[n // 2]) / 2\n    else:\n        return nums[n // 2]\n\n\n# Binary Search\ndef findMedianSortedArraysBS(nums1: List[int], nums2: List[int]) -&gt; float:\n    if len(nums1) &gt; len(nums2):\n        nums1, nums2 = nums2, nums1\n\n    m, n = len(nums1), len(nums2)\n    imin, imax, half_len = 0, m, (m + n + 1) // 2\n\n    while imin &lt;= imax:\n        i = (imin + imax) // 2\n        j = half_len - i\n\n        if i &lt; m and nums2[j - 1] &gt; nums1[i]:\n            imin = i + 1\n        elif i &gt; 0 and nums1[i - 1] &gt; nums2[j]:\n            imax = i - 1\n        else:\n            if i == 0:\n                max_of_left = nums2[j - 1]\n            elif j == 0:\n                max_of_left = nums1[i - 1]\n            else:\n                max_of_left = max(nums1[i - 1], nums2[j - 1])\n\n            if (m + n) % 2 == 1:\n                return max_of_left\n\n            if i == m:\n                min_of_right = nums2[j]\n            elif j == n:\n                min_of_right = nums1[i]\n            else:\n                min_of_right = min(nums1[i], nums2[j])\n\n            return (max_of_left + min_of_right) / 2\n\n\n# |--------------|-----------------|--------------|\n# | Approach     | Time            | Space        |\n# |--------------|-----------------|--------------|\n# | Brute Force  | O((n+m)log(n+m))| O(n+m)       |\n# | Binary Search| O(log(min(n,m)))| O(1)         |\n# |--------------|-----------------|--------------|\n\n\nnums1 = [1, 3]\nnums2 = [2]\nprint(findMedianSortedArraysBF(nums1, nums2))  # 2.0\nprint(findMedianSortedArraysBS(nums1, nums2))  # 2.0\n</code></pre>"},{"location":"top-100-liked/binary_tree/","title":"Binary Tree","text":""},{"location":"top-100-liked/binary_tree/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 94. Binary Tree Inorder Traversal (Easy)</li> <li> 104. Maximum Depth of Binary Tree (Easy)</li> <li> 226. Invert Binary Tree (Easy)</li> <li> 101. Symmetric Tree (Easy)</li> <li> 543. Diameter of Binary Tree (Easy)</li> <li> 102. Binary Tree Level Order Traversal (Medium)</li> <li> 108. Convert Sorted Array to Binary Search Tree (Easy)</li> <li> 98. Validate Binary Search Tree (Medium)</li> <li> 230. Kth Smallest Element in a BST (Medium)</li> <li> 199. Binary Tree Right Side View (Medium)</li> <li> 114. Flatten Binary Tree to Linked List (Medium)</li> <li> 105. Construct Binary Tree from Preorder and Inorder Traversal (Medium)</li> <li> 437. Path Sum III (Medium)</li> <li> 236. Lowest Common Ancestor of a Binary Tree (Medium)</li> <li> 124. Binary Tree Maximum Path Sum (Hard)</li> </ul>"},{"location":"top-100-liked/binary_tree/#94-binary-tree-inorder-traversal","title":"94. Binary Tree Inorder Traversal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Stack, Tree, Depth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef inorderTraversalRecursive(root: TreeNode) -&gt; List[int]:\n    res = []\n\n    def dfs(node):\n        if not node:\n            return\n\n        dfs(node.left)\n        res.append(node.val)  # &lt;--\n        dfs(node.right)\n\n    dfs(root)\n\n    return res\n\n\n# Iterative\ndef inorderTraversalIterative(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    stack = []\n    res = []\n    cur = root\n\n    while cur or stack:\n        if cur:\n            stack.append(cur)\n            cur = cur.left\n        else:\n            cur = stack.pop()\n            res.append(cur.val)\n            cur = cur.right\n\n    return res\n\n\ntree = build([0, 1, 2, 3, 4, 5, 6])\nprint(tree)\n#     __0__\n#    /     \\\n#   1       2\n#  / \\     / \\\n# 3   4   5   6\nprint(inorderTraversalRecursive(tree))  # [3, 1, 4, 0, 5, 2, 6]\nprint(inorderTraversalIterative(tree))  # [3, 1, 4, 0, 5, 2, 6]\n</code></pre>"},{"location":"top-100-liked/binary_tree/#104-maximum-depth-of-binary-tree","title":"104. Maximum Depth of Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef maxDepthRecursive(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    left = maxDepthRecursive(root.left)\n    right = maxDepthRecursive(root.right)\n\n    return 1 + max(left, right)\n\n\n# DFS\ndef maxDepthDFS(root: Optional[TreeNode]) -&gt; int:\n    res = 0\n\n    def dfs(node, cnt):\n        if node is None:\n            return\n        cnt += 1\n        nonlocal res\n        res = max(res, cnt)\n\n        dfs(node.left, cnt)\n        dfs(node.right, cnt)\n\n    dfs(root, 0)\n\n    return res\n\n\n# Iterative\ndef maxDepthIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n    res = 0\n\n    while q:\n        res += 1\n        n = len(q)\n\n        for _ in range(n):\n            node = q.popleft()\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    root = [1, 2, 2, 3, 4, None, None, None, None, 5]\n    root = build(root)\n    print(root)\n    #     ____1\n    #    /     \\\n    #   2__     2\n    #  /   \\\n    # 3     4\n    #      /\n    #     5\n    assert maxDepthRecursive(root) == 4\n    assert maxDepthDFS(root) == 4\n    assert maxDepthIterative(root) == 4\n</code></pre>"},{"location":"top-100-liked/binary_tree/#226-invert-binary-tree","title":"226. Invert Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef invertTreeRecursive(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    root.left, root.right = root.right, root.left\n\n    invertTreeRecursive(root.left)\n    invertTreeRecursive(root.right)\n\n    return root\n\n\n# Iterative\ndef invertTreeIterative(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    stack = [root]\n\n    while stack:\n        node = stack.pop()\n\n        node.left, node.right = node.right, node.left\n        if node.left:\n            stack.append(node.left)\n        if node.right:\n            stack.append(node.right)\n\n    return root\n\n\nroot = build([4, 2, 7, 1, 3, 6, 9])\nprint(root)\n#     __4__\n#    /     \\\n#   2       7\n#  / \\     / \\\n# 1   3   6   9\ninvertedRecursive = invertTreeRecursive(root)\nprint(invertedRecursive)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\nroot = build([4, 2, 7, 1, 3, 6, 9])\ninvertedIterative = invertTreeIterative(root)\nprint(invertedIterative)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\n</code></pre>"},{"location":"top-100-liked/binary_tree/#101-symmetric-tree","title":"101. Symmetric Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> PythonCPP <pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef is_symmetric_recursive(root: Optional[TreeNode]) -&gt; bool:\n    if not root:\n        return True\n\n    def check(left, right):\n        if left is right:\n            return True\n        if not left or not right or left.val != right.val:\n            return False\n        outside = check(left.left, right.right)\n        inside = check(left.right, right.left)\n        return outside and inside\n\n    return check(root.left, root.right)\n\n\n# Iterative\ndef is_symmetric_iterative(root: Optional[TreeNode]) -&gt; bool:\n    if not root:\n        return True\n\n    q = deque()\n    q.append(root.left)\n    q.append(root.right)\n\n    while q:\n        left = q.popleft()\n        right = q.popleft()\n\n        if not left and not right:\n            continue\n\n        if not left or not right or left.val != right.val:\n            return False\n\n        q.append(left.left)\n        q.append(right.right)\n        q.append(left.right)\n        q.append(right.left)\n\n    return True\n\n\nif __name__ == \"__main__\":\n    root = [1, 2, 2, 3, 4, 4, 3]\n    root = build(root)\n    print(root)\n    #     __1__\n    #    /     \\\n    #   2       2\n    #  / \\     / \\\n    # 3   4   4   3\n    assert is_symmetric_recursive(root) is True\n    assert is_symmetric_iterative(root) is True\n</code></pre> <pre><code>#include &lt;iostream&gt;\n\n#include \"include/trees.hpp\"\n\nclass Solution {\n   private:\n    bool dfs(TreeNode *Left, TreeNode *Right) {\n        if (Left == nullptr &amp;&amp; Right == nullptr) return true;\n        if (Left == nullptr || Right == nullptr || Left-&gt;val != Right-&gt;val)\n            return false;\n        return dfs(Left-&gt;left, Right-&gt;right) &amp;&amp; dfs(Left-&gt;right, Right-&gt;left);\n    }\n\n   public:\n    bool isSymmetric(TreeNode *root) {\n        return root == nullptr || dfs(root-&gt;left, root-&gt;right);\n    }\n};\n\nint main() {\n    Solution solution;\n    // Test with a symmetric tree\n    std::vector&lt;int&gt; values = {1, 2, 2, 3, 4, 4, 3};\n    TreeNode *root = TreeUtils::buildTree(values);\n    bool result = solution.isSymmetric(root);\n    std::cout &lt;&lt; \"Is symmetric: \" &lt;&lt; (result ? \"true\" : \"false\") &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>"},{"location":"top-100-liked/binary_tree/#543-diameter-of-binary-tree","title":"543. Diameter of Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul> PythonCPP <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Tree DFS\nclass Solution:\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -&gt; int:\n        self.diameter = 0\n\n        def dfs(node):\n            if not node:\n                return 0\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n            self.diameter = max(self.diameter, left + right)\n\n            return 1 + max(left, right)\n\n        dfs(root)\n\n        return self.diameter\n\n\nroot = build([1, 2, 3, 4, 5])\nprint(root)\n#     __1\n#    /   \\\n#   2     3\n#  / \\\n# 4   5\nobj = Solution()\nprint(obj.diameterOfBinaryTree(root))  # 3\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nint diameterOfBinaryTree(TreeNode* root) {\n    int diameter = 0;\n\n    auto dfs = [&amp;](auto&amp;&amp; self, TreeNode* node) -&gt; int {\n        if (!node) return 0;\n        int left = self(self, node-&gt;left);\n        int right = self(self, node-&gt;right);\n\n        diameter = max(diameter, left + right);\n\n        return 1 + max(left, right);\n    };\n\n    dfs(dfs, root);\n    return diameter;\n}\n\nint main() {\n    // [1, 2, 3, 4, 5]\n    TreeNode* root = new TreeNode(1);\n    root-&gt;left = new TreeNode(2);\n    root-&gt;right = new TreeNode(3);\n    root-&gt;left-&gt;left = new TreeNode(4);\n    root-&gt;left-&gt;right = new TreeNode(5);\n    cout &lt;&lt; diameterOfBinaryTree(root) &lt;&lt; endl;  // 3\n\n    return 0;\n}\n</code></pre>"},{"location":"top-100-liked/binary_tree/#102-binary-tree-level-order-traversal","title":"102. Binary Tree Level Order Traversal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef levelOrder(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        level = []\n        size = len(q)\n\n        for _ in range(size):\n            cur = q.popleft()\n            level.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(level)\n\n    return res\n\n\ntree = build([3, 9, 20, None, None, 15, 7])\nprint(tree)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(levelOrder(tree))  # [[3], [9, 20], [15, 7]]\n</code></pre>"},{"location":"top-100-liked/binary_tree/#108-convert-sorted-array-to-binary-search-tree","title":"108. Convert Sorted Array to Binary Search Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Divide And Conquer, Tree, Binary Search Tree, Binary Tree</p> </li> </ul> PythonCPP <pre><code>from typing import List, Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef sortedArrayToBST(nums: List[int]) -&gt; Optional[TreeNode]:\n    if len(nums) == 0:\n        return None\n\n    mid = len(nums) // 2\n    root = TreeNode(nums[mid])\n\n    root.left = sortedArrayToBST(nums[:mid])\n    root.right = sortedArrayToBST(nums[mid + 1 :])\n\n    return root\n\n\nnums = [-10, -3, 0, 5, 9]\nroot = sortedArrayToBST(nums)\n#      0\n#     / \\\n#   -3   9\n#   /   /\n# -10  5\n</code></pre> <pre><code>#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   public:\n    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) {\n        if (nums.size() == 0) return nullptr;\n\n        int mid = nums.size() / 2;\n        TreeNode* root = new TreeNode(nums[mid]);\n\n        vector&lt;int&gt; left(nums.begin(), nums.begin() + mid);\n        vector&lt;int&gt; right(nums.begin() + mid + 1, nums.end());\n\n        root-&gt;left = sortedArrayToBST(left);\n        root-&gt;right = sortedArrayToBST(right);\n\n        return root;\n    }\n};\n\nint main() { return 0; }\n</code></pre>"},{"location":"top-100-liked/binary_tree/#98-validate-binary-search-tree","title":"98. Validate Binary Search Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Search Tree, Binary Tree</p> </li> </ul> PythonCPP <pre><code>from itertools import pairwise\nfrom math import inf\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef isValidBST1(root: Optional[TreeNode]) -&gt; bool:\n    inorder = []  # inorder traversal\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    for a, b in pairwise(inorder):\n        if a &gt;= b:\n            return False\n\n    return True\n\n\ndef isValidBST2(root: Optional[TreeNode]) -&gt; bool:\n    if not root:\n        return True\n    pre = -inf\n\n    def dfs(node):\n        if not node:\n            return True\n        if not dfs(node.left):\n            return False\n\n        nonlocal pre\n        if node.val &lt;= pre:\n            return False\n        pre = node.val\n\n        return dfs(node.right)\n\n    return dfs(root)\n\n\nif __name__ == \"__main__\":\n    root = [5, 1, 4, None, None, 3, 6]\n    root = build(root)\n    print(root)\n    #   5__\n    #  /   \\\n    # 1     4\n    #      / \\\n    #     3   6\n    assert not isValidBST1(root)  # [1, 5, 3, 4, 6]\n    assert not isValidBST2(root)  # [1, 5, 3, 4, 6]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   private:\n    vector&lt;int&gt; inorder;\n    bool check(vector&lt;int&gt; inorder) {\n        int n = inorder.size();\n        if (n &lt;= 1) return true;\n        for (int i = 1; i &lt; n; i++) {\n            if (inorder[i] &lt;= inorder[i - 1]) return false;\n        }\n        return true;\n    }\n\n   public:\n    bool isValidBST(TreeNode *root) {\n        auto dfs = [&amp;](auto &amp;&amp;self, TreeNode *node) -&gt; void {\n            if (!node) return;\n\n            self(self, node-&gt;left);\n            inorder.push_back(node-&gt;val);\n            self(self, node-&gt;right);\n        };\n\n        dfs(dfs, root);\n\n        return check(inorder);\n    }\n};\n\nint main() {\n    Solution s;\n    TreeNode *root = new TreeNode(2);\n    root-&gt;left = new TreeNode(1);\n    root-&gt;right = new TreeNode(3);\n    assert(s.isValidBST(root) == true);\n\n    root = new TreeNode(5);\n    root-&gt;left = new TreeNode(1);\n    root-&gt;right = new TreeNode(4);\n    root-&gt;right-&gt;left = new TreeNode(3);\n    root-&gt;right-&gt;right = new TreeNode(6);\n    assert(s.isValidBST(root) == false);\n\n    root = new TreeNode(5);\n    root-&gt;left = new TreeNode(4);\n    root-&gt;right = new TreeNode(6);\n    root-&gt;right-&gt;left = new TreeNode(3);\n    root-&gt;right-&gt;right = new TreeNode(7);\n    assert(s.isValidBST(root) == false);\n\n    return 0;\n}\n</code></pre>"},{"location":"top-100-liked/binary_tree/#230-kth-smallest-element-in-a-bst","title":"230. Kth Smallest Element in a BST","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Search Tree, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef kthSmallestRecursive(root: Optional[TreeNode], k: int) -&gt; int:\n    inorder = []\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n    return inorder[k - 1]\n\n\n# Iteratve\ndef kthSmallestIteratve(root: Optional[TreeNode], k: int) -&gt; int:\n    stack = []\n    while True:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        k -= 1\n        if not k:\n            return root.val\n        root = root.right\n\n\nif __name__ == \"__main__\":\n    root = build([3, 1, 4, None, 2])\n    k = 1\n    assert kthSmallestRecursive(root, k) == 1\n    assert kthSmallestIteratve(root, k) == 1\n</code></pre>"},{"location":"top-100-liked/binary_tree/#199-binary-tree-right-side-view","title":"199. Binary Tree Right Side View","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Breadth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Binary Tree BFS\ndef rightSideViewBFS(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        n = len(q)\n        for i in range(n):\n            node = q.popleft()\n            if i == n - 1:\n                res.append(node.val)\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return res\n\n\n# Binary Tree DFS\ndef rightSideViewDFS(root: Optional[TreeNode]) -&gt; List[int]:\n    \"\"\"\u540e\u5e8f\u904d\u5386\uff0c\u5148\u53f3\u540e\u5de6\uff0c\u9047\u5230\u7684\u7b2c\u4e00\u4e2a\u8282\u70b9\u5c31\u662f\u8be5\u6df1\u5ea6\u7684\u6700\u53f3\u4fa7\u8282\u70b9\"\"\"\n    ans = []\n\n    def dfs(node, depth):\n        if node is None:\n            return\n        if depth == len(ans):  # \u8fd9\u4e2a\u6df1\u5ea6\u9996\u6b21\u9047\u5230\n            ans.append(node.val)\n\n        dfs(node.right, depth + 1)\n        dfs(node.left, depth + 1)\n\n    dfs(root, 0)\n\n    return ans\n\n\nif __name__ == \"__main__\":\n    root = [1, 2, 2, 3, 4, None, 3, None, None, 5]\n    root = build(root)\n    print(root)\n    #     ____1\n    #    /     \\\n    #   2__     2\n    #  /   \\     \\\n    # 3     4     3\n    #      /\n    #     5\n    assert rightSideViewBFS(root) == [1, 2, 3, 5]\n    assert rightSideViewDFS(root) == [1, 2, 3, 5]\n</code></pre>"},{"location":"top-100-liked/binary_tree/#114-flatten-binary-tree-to-linked-list","title":"114. Flatten Binary Tree to Linked List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Stack, Tree, Depth First Search, Binary Tree</p> </li> </ul> CPP <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   public:\n    void flatten(TreeNode* root) {\n        if (!root) return;\n\n        flatten(root-&gt;left);\n        flatten(root-&gt;right);\n\n        TreeNode* left = root-&gt;left;\n        TreeNode* right = root-&gt;right;\n\n        root-&gt;left = nullptr;\n        root-&gt;right = left;\n\n        TreeNode* curr = root;\n        while (curr-&gt;right) curr = curr-&gt;right;\n        curr-&gt;right = right;\n    }\n};\n\nint main() {\n    Solution sol;\n    TreeNode* root =\n        new TreeNode(1, new TreeNode(2, new TreeNode(3), new TreeNode(4)),\n                     new TreeNode(5, nullptr, new TreeNode(6)));\n    sol.flatten(root);\n\n    TreeNode* cur = root;\n    std::vector&lt;int&gt; expected = {1, 2, 3, 4, 5, 6};\n    for (int val : expected) {\n        assert(cur != nullptr &amp;&amp; cur-&gt;val == val);\n        cur = cur-&gt;right;\n    }\n    assert(cur == nullptr);  // End of list\n\n    return 0;\n}\n</code></pre>"},{"location":"top-100-liked/binary_tree/#105-construct-binary-tree-from-preorder-and-inorder-traversal","title":"105. Construct Binary Tree from Preorder and Inorder Traversal","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Divide And Conquer, Tree, Binary Tree</p> </li> </ul> PythonCPP <pre><code>from typing import List, Optional\n\nfrom helper import TreeNode\n\n\ndef buildTree(preorder: List[int], inorder: List[int]) -&gt; Optional[TreeNode]:\n    \"\"\"\n    preorder  root left right  1  2  3\n    inorder   left root right  4  5  6\n    \"\"\"\n    if len(preorder) == 0:\n        return None\n\n    root_val = preorder[0]  # 1\n    root = TreeNode(root_val)\n\n    separator_idx = inorder.index(root_val)  # 5\n\n    left_inorder = inorder[:separator_idx]  # 4\n    right_inorder = inorder[separator_idx + 1 :]  # 6\n\n    left_preorder = preorder[1 : 1 + len(left_inorder)]  # 2\n    right_preorder = preorder[1 + len(left_inorder) :]  # 3\n\n    root.left = buildTree(left_preorder, left_inorder)\n    root.right = buildTree(right_preorder, right_inorder)\n\n    return root\n\n\npreorder = [3, 9, 20, 15, 7]\ninorder = [9, 3, 15, 20, 7]\nroot = buildTree(preorder, inorder)\nprint(root)\n#     3\n#    / \\\n#   9  20\n#     /  \\\n#    15   7\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   public:\n    vector&lt;int&gt; preorder;\n    unordered_map&lt;int, int&gt; inorderMap;\n\n    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {\n        this-&gt;preorder = preorder;\n        for (size_t i = 0; i &lt; inorder.size(); i++) {\n            inorderMap[inorder[i]] = i;\n        }\n        return buildSubtree(0, 0, inorder.size() - 1);\n    }\n\n   private:\n    TreeNode* buildSubtree(int rootIndex, int left, int right) {\n        if (left &gt; right) return nullptr;\n\n        TreeNode* root = new TreeNode(preorder[rootIndex]);\n        int inorderIndex = inorderMap[preorder[rootIndex]];\n\n        root-&gt;left = buildSubtree(rootIndex + 1, left, inorderIndex - 1);\n        root-&gt;right = buildSubtree(rootIndex + (inorderIndex - left + 1),\n                                   inorderIndex + 1, right);\n\n        return root;\n    }\n};\n\nint main() {\n    vector&lt;int&gt; preorder = {3, 9, 20, 15, 7};\n    vector&lt;int&gt; inorder = {9, 3, 15, 20, 7};\n    Solution solution;\n    TreeNode* root = solution.buildTree(preorder, inorder);\n    cout &lt;&lt; root-&gt;val &lt;&lt; endl;                // 3\n    cout &lt;&lt; root-&gt;left-&gt;val &lt;&lt; endl;          // 9\n    cout &lt;&lt; root-&gt;right-&gt;val &lt;&lt; endl;         // 20\n    cout &lt;&lt; root-&gt;right-&gt;left-&gt;val &lt;&lt; endl;   // 15\n    cout &lt;&lt; root-&gt;right-&gt;right-&gt;val &lt;&lt; endl;  // 7\n    return 0;\n}\n</code></pre>"},{"location":"top-100-liked/binary_tree/#437-path-sum-iii","title":"437. Path Sum III","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul> CPP <pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   public:\n    int pathSum(TreeNode *root, int targetSum) {\n        int res = 0;\n        unordered_map&lt;long long, int&gt; cnt{{0, 1}};\n\n        auto dfs = [&amp;](auto &amp;&amp;self, TreeNode *node, long long cur) {\n            if (!node) return;\n            cur += node-&gt;val;\n\n            if (cnt.find(cur - targetSum) != cnt.end())\n                res += cnt[cur - targetSum];\n\n            cnt[cur]++;\n            self(self, node-&gt;left, cur);\n            self(self, node-&gt;right, cur);\n            cnt[cur]--;\n        };\n\n        dfs(dfs, root, 0);\n        return res;\n    }\n};\n\nint main() {\n    Solution s;\n    {\n        TreeNode *root = new TreeNode(10);\n        root-&gt;left = new TreeNode(5);\n        root-&gt;right = new TreeNode(-3);\n        root-&gt;left-&gt;left = new TreeNode(3);\n        root-&gt;left-&gt;right = new TreeNode(2);\n        root-&gt;right-&gt;right = new TreeNode(11);\n        root-&gt;left-&gt;left-&gt;left = new TreeNode(3);\n        root-&gt;left-&gt;left-&gt;right = new TreeNode(-2);\n        root-&gt;left-&gt;right-&gt;right = new TreeNode(1);\n        cout &lt;&lt; s.pathSum(root, 8) &lt;&lt; endl;  // 3\n    }\n    {\n        TreeNode *root = new TreeNode(5);\n        root-&gt;left = new TreeNode(4);\n        root-&gt;right = new TreeNode(8);\n        root-&gt;left-&gt;left = new TreeNode(11);\n        root-&gt;right-&gt;left = new TreeNode(13);\n        root-&gt;right-&gt;right = new TreeNode(4);\n        root-&gt;left-&gt;left-&gt;left = new TreeNode(7);\n        root-&gt;left-&gt;left-&gt;right = new TreeNode(2);\n        root-&gt;right-&gt;right-&gt;left = new TreeNode(5);\n        root-&gt;right-&gt;right-&gt;right = new TreeNode(1);\n        cout &lt;&lt; s.pathSum(root, 22) &lt;&lt; endl;  // 3\n    }\n    return 0;\n}\n</code></pre>"},{"location":"top-100-liked/binary_tree/#236-lowest-common-ancestor-of-a-binary-tree","title":"236. Lowest Common Ancestor of a Binary Tree","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Tree, Depth First Search, Binary Tree</p> </li> </ul> PythonCPP <pre><code>from typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass LowestCommonAncestor:\n    def lowestCommonAncestor(\n        self, root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n    ) -&gt; \"TreeNode\":\n        if not root or q == root or p == root:\n            return root\n\n        left = self.lowestCommonAncestor(root.left, p, q)\n        right = self.lowestCommonAncestor(root.right, p, q)\n\n        if left and right:\n            return root\n\n        return left or right\n\n\nif __name__ == \"__main__\":\n    root = build([3, 5, 1, 6, 2, 0, 8, None, None, 7, 4])\n    print(root)\n    #     ______3__\n    #    /         \\\n    #   5__         1\n    #  /   \\       / \\\n    # 6     2     0   8\n    #      / \\\n    #     7   4\n    p = root.left  # 5\n    q = root.right  # 1\n    sol = LowestCommonAncestor()\n    print(sol.lowestCommonAncestor(root, p, q))\n    #     ______3__\n    #    /         \\\n    #   5__         1\n    #  /   \\       / \\\n    # 6     2     0   8\n    #      / \\\n    #     7   4\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   public:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if (root == nullptr || root == p || root == q) {\n            return root;\n        }\n\n        TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);\n        TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);\n\n        if (left &amp;&amp; right) {\n            return root;\n        }\n\n        return left ? left : right;\n    }\n};\n\nint main() { return 0; }\n</code></pre>"},{"location":"top-100-liked/binary_tree/#124-binary-tree-maximum-path-sum","title":"124. Binary Tree Maximum Path Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Dynamic Programming, Tree, Depth First Search, Binary Tree</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef maxPathSum(root: Optional[TreeNode]) -&gt; int:\n    res = float(\"-inf\")\n\n    def dfs(node):\n        if not node:\n            return 0\n\n        leftMax = max(dfs(node.left), 0)\n        rightMax = max(dfs(node.right), 0)\n\n        cur = node.val + leftMax + rightMax\n        nonlocal res\n        res = max(res, cur)\n\n        return node.val + max(leftMax, rightMax)\n\n    dfs(root)\n\n    return res\n\n\nroot = build([-10, 9, 20, None, None, 15, 7])\nprint(root)\n#   -10___\n#  /      \\\n# 9       _20\n#        /   \\\n#       15    7\nprint(maxPathSum(root))  # 42\n</code></pre>"},{"location":"top-100-liked/dynamic_programming/","title":"Dynamic Programming","text":""},{"location":"top-100-liked/dynamic_programming/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 70. Climbing Stairs (Easy)</li> <li> 118. Pascal's Triangle (Easy)</li> <li> 198. House Robber (Medium)</li> <li> 279. Perfect Squares (Medium)</li> <li> 322. Coin Change (Medium)</li> <li> 139. Word Break (Medium)</li> <li> 300. Longest Increasing Subsequence (Medium)</li> <li> 152. Maximum Product Subarray (Medium)</li> <li> 416. Partition Equal Subset Sum (Medium)</li> <li> 32. Longest Valid Parentheses (Hard)</li> </ul>"},{"location":"top-100-liked/dynamic_programming/#70-climbing-stairs","title":"70. Climbing Stairs","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Memoization</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return the number of distinct ways to reach the top of the stairs.\n- `dp[n]` stores the number of distinct ways to reach the `n-th` stair.\n- Formula: `dp[n] = dp[n - 1] + dp[n - 2]`.\n- Initialize `dp[0] = 0`, `dp[1] = 1`, and `dp[2] = 2`.\n\"\"\"\n\nfrom functools import cache\n\n\n# DP\ndef climbStairsDP(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    dp = [i for i in range(n + 1)]\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\n# DP (Optimized)\ndef climbStairsDPOptimized(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    first, second = 1, 2\n\n    for _ in range(3, n + 1):\n        first, second = second, first + second\n\n    return second\n\n\n# Recursion\ndef climbStairsRecursion(n: int) -&gt; int:\n    @cache\n    def dfs(i: int) -&gt; int:\n        if i &lt;= 1:\n            return 1\n        return dfs(i - 1) + dfs(i - 2)\n\n    return dfs(n)\n\n\n# Greedy\ndef climbStairsGreedy(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    p1, p2 = 1, 2\n\n    for _ in range(3, n + 1):\n        p1, p2 = p2, p1 + p2\n\n    return p2\n\n\nif __name__ == \"__main__\":\n    assert climbStairsDP(10) == 89\n    assert climbStairsDPOptimized(10) == 89\n    assert climbStairsRecursion(10) == 89\n    assert climbStairsGreedy(10) == 89\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nint climbStairs(int n) {\n    if (n &lt;= 2) return n;\n    int f1 = 1, f2 = 2;\n    int res;\n\n    int i = 3;\n    while (i &lt;= n) {\n        res = f1 + f2;\n        f1 = f2;\n        f2 = res;\n        i++;\n    }\n    return res;\n}\n\nint main() {\n    assert(climbStairs(2) == 2);\n    assert(climbStairs(5) == 8);\n    assert(climbStairs(10) == 89);\n    return 0;\n}\n</code></pre>"},{"location":"top-100-liked/dynamic_programming/#118-pascals-triangle","title":"118. Pascal's Triangle","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <p><pre><code>\"\"\"\n-   Generate the first `numRows` of Pascal's triangle.\n\n```plaintext\n                 numRows\n     1              1\n    1 1             2\n   1 2 1            3\n  1 3 3 1           4\n 1 4 6 4 1          5\n</code></pre> \"\"\"</p> <p>from typing import List</p> <p>def generate(numRows: int) -&gt; List[List[int]]:     dp = [[1] * i for i in range(1, numRows + 1)]</p> <pre><code>if numRows &lt;= 2:\n    return dp\n\nfor i in range(2, numRows):\n    for j in range(1, i):\n        dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n\nreturn dp\n</code></pre> <p>if name == \"main\":     print(generate(numRows=5))     # [[1],     #  [1, 1],     #  [1, 2, 1],     #  [1, 3, 3, 1],     #  [1, 4, 6, 4, 1]]</p> <p>```</p>"},{"location":"top-100-liked/dynamic_programming/#198-house-robber","title":"198. House Robber","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> PythonCPP <pre><code>from functools import cache\nfrom typing import List\n\n\nclass Rob:\n    \"\"\"\n    dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n    \"\"\"\n\n    def incursive(self, nums: List[int]) -&gt; int:\n        \"\"\"\n        time complexity: O(n)\n        space complexity: O(n)\n        \"\"\"\n        n = len(nums)\n        if n &lt;= 2:\n            return max(nums)\n\n        # init\n        dp = [0 for _ in range(n)]\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n        # update\n        for i in range(2, n):\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n        return dp[-1]\n\n    def incursive_optimized(self, nums: List[int]) -&gt; int:\n        \"\"\"\n        time complexity: O(n)\n        space complexity: O(1)\n        \"\"\"\n        f0, f1 = 0, 0\n\n        for num in nums:\n            f0, f1 = f1, max(f1, f0 + num)\n\n        return f1\n\n    def memoization(self, nums: List[int]) -&gt; int:\n        \"\"\"\n        time complexity: O(n)\n        space complexity: O(n)\n        \"\"\"\n        n = len(nums)\n\n        @cache\n        def dp(i: int) -&gt; int:\n            if i &lt; 0:\n                return 0\n            return max(dp(i - 1), dp(i - 2) + nums[i])\n\n        return dp(n - 1)\n\n\nif __name__ == \"__main__\":\n    nums = [2, 7, 9, 3, 1]\n    rob = Rob()\n    assert rob.incursive(nums) == 12\n    assert rob.incursive_optimized(nums) == 12\n    assert rob.memoization(nums) == 12\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint rob(vector&lt;int&gt; &amp;nums) {\n    int prev = 0, cur = 0, temp = 0;\n\n    for (int num : nums) {\n        temp = cur;\n        cur = max(cur, prev + num);\n        prev = temp;\n    }\n    return cur;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {2, 7, 9, 3, 1};\n    cout &lt;&lt; rob(nums) &lt;&lt; endl;  // 12\n    return 0;\n}\n</code></pre>"},{"location":"top-100-liked/dynamic_programming/#279-perfect-squares","title":"279. Perfect Squares","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Breadth First Search</p> </li> </ul> Python <pre><code>import math\n\n\n# DP - Knapsack Unbounded\ndef numSquares(n: int) -&gt; int:\n    dp = [float(\"inf\") for _ in range(n + 1)]\n    dp[0] = 0\n\n    for i in range(1, n + 1):\n        for j in range(1, int(math.sqrt(n)) + 1):\n            dp[i] = min(dp[i], dp[i - j**2] + 1)\n\n    return dp[n]\n\n\nn = 12\nprint(numSquares(n))  # 3\n</code></pre>"},{"location":"top-100-liked/dynamic_programming/#322-coin-change","title":"322. Coin Change","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Breadth First Search</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef coinChange(coins: List[int], amount: int) -&gt; int:\n    dp = [float(\"inf\") for _ in range(amount + 1)]\n\n    dp[0] = 0\n\n    for i in range(1, amount + 1):\n        for c in coins:\n            if i - c &gt;= 0:\n                dp[i] = min(dp[i], 1 + dp[i - c])\n\n    return dp[amount] if dp[amount] != float(\"inf\") else -1\n\n\ncoins = [1, 2, 5]\namount = 11\nprint(coinChange(coins, amount))  # 3\n</code></pre>"},{"location":"top-100-liked/dynamic_programming/#139-word-break","title":"139. Word Break","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Dynamic Programming, Trie, Memoization</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\n# DP (Unbounded Knapsack)\ndef wordBreak(s: str, wordDict: List[str]) -&gt; bool:\n    n = len(s)\n    dp = [False for _ in range(n + 1)]\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for word in wordDict:\n            m = len(word)\n            if s[i - m : i] == word and dp[i - m]:\n                dp[i] = True\n    return dp[-1]\n\n\ns = \"leetcode\"\nwordDict = [\"leet\", \"code\"]\nprint(wordBreak(s, wordDict))  # True\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;cassert&gt;\n#include &lt;ranges&gt;\n#include &lt;string&gt;\n#include &lt;unordered_set&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) {\n        int max_len = ranges::max(wordDict, {}, &amp;string::length).length();\n        unordered_set&lt;string&gt; words(wordDict.begin(), wordDict.end());\n\n        int n = s.length();\n        vector&lt;int&gt; f(n + 1);\n        f[0] = true;\n        for (int i = 1; i &lt;= n; i++) {\n            for (int j = i - 1; j &gt;= max(i - max_len, 0); j--) {\n                if (f[j] &amp;&amp; words.count(s.substr(j, i - j))) {\n                    f[i] = true;\n                    break;\n                }\n            }\n        }\n        return f[n];\n    }\n};\n\nint main() {\n    Solution solution;\n    string s = \"leetcode\";\n    vector&lt;string&gt; wordDict = {\"leet\", \"code\"};\n    assert(solution.wordBreak(s, wordDict) == true);\n    return 0;\n}\n</code></pre>"},{"location":"top-100-liked/dynamic_programming/#300-longest-increasing-subsequence","title":"300. Longest Increasing Subsequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Dynamic Programming</p> </li> </ul> Python <pre><code>from functools import cache\nfrom typing import List\n\n\n# DP - LIS\ndef lengthOfLISMemo(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return n\n\n    @cache\n    def dfs(i: int) -&gt; int:\n        res = 0\n        for j in range(i):\n            if nums[j] &lt; nums[i]:\n                res = max(res, dfs(j))\n        return res + 1\n\n    return max(dfs(i) for i in range(n))\n\n\n# DP - LIS\ndef lengthOfLISTable(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return n\n\n    dp = [1 for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i):\n            if nums[i] &gt; nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\n\nif __name__ == \"__main__\":\n    assert lengthOfLISMemo([10, 9, 2, 5, 3, 7, 101, 18]) == 4\n    assert lengthOfLISTable([10, 9, 2, 5, 3, 7, 101, 18]) == 4\n    assert lengthOfLISMemo([0, 1, 0, 3, 2, 3]) == 4\n    assert lengthOfLISTable([0, 1, 0, 3, 2, 3]) == 4\n    assert lengthOfLISMemo([7, 7, 7, 7]) == 1\n    assert lengthOfLISTable([7, 7, 7, 7]) == 1\n</code></pre>"},{"location":"top-100-liked/dynamic_programming/#152-maximum-product-subarray","title":"152. Maximum Product Subarray","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxProduct(nums: List[int]) -&gt; int:\n    n = len(nums)\n    dp_max = [0 for _ in range(n)]\n    dp_min = [0 for _ in range(n)]\n\n    dp_max[0] = nums[0]\n    dp_min[0] = nums[0]\n    max_product = nums[0]\n\n    for i in range(1, n):\n        dp_max[i] = max(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n        dp_min[i] = min(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n\n        max_product = max(max_product, dp_max[i])\n\n    return max_product\n\n\nnums = [2, 3, -2, 4]\nprint(maxProduct(nums))  # 6\n</code></pre>"},{"location":"top-100-liked/dynamic_programming/#416-partition-equal-subset-sum","title":"416. Partition Equal Subset Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> Python <pre><code>from functools import cache\nfrom typing import List\n\nfrom leetpattern.utils import knapsack01\n\n\n# Memoization\ndef canPartitionMemoization(nums: List[int]) -&gt; bool:\n    total = sum(nums)\n    n = len(nums)\n\n    if total % 2 == 1 or n &lt;= 1:\n        return False\n\n    @cache\n    def dfs(i, j):\n        if i &lt; 0:\n            return j == 0\n        return j &gt;= nums[i] and dfs(i - 1, j - nums[i]) or dfs(i - 1, j)\n\n    return dfs(n - 1, total // 2)\n\n\n# DP - Knapsack 01\ndef canPartitionTemplate(nums: List[int]) -&gt; bool:\n    total = sum(nums)\n\n    if total % 2 == 1 or len(nums) &lt; 2:\n        return False\n\n    target = total // 2\n\n    return knapsack01(nums, nums, target) == target\n\n\n# DP - Knapsack 01\ndef canPartition(nums: List[int]) -&gt; bool:\n    total = sum(nums)\n\n    if total % 2 == 1 or len(nums) &lt; 2:\n        return False\n\n    target = total // 2\n\n    dp = [0 for _ in range(target + 1)]\n\n    for i in range(len(nums)):\n        for j in range(target, nums[i] - 1, -1):\n            dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])\n\n    return dp[target] == target\n\n\nif __name__ == \"__main__\":\n    nums = [1, 5, 11, 5]\n    print(canPartitionTemplate(nums))  # True\n    print(canPartition(nums))  # True\n    print(canPartitionMemoization(nums))  # True\n</code></pre>"},{"location":"top-100-liked/dynamic_programming/#32-longest-valid-parentheses","title":"32. Longest Valid Parentheses","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming, Stack</p> </li> </ul> Python <pre><code># Stack\ndef longestValidParentheses(s: str) -&gt; int:\n    stack = [-1]\n    res = 0\n\n    for i, ch in enumerate(s):\n        if ch == \"(\":\n            stack.append(i)\n        elif ch == \")\":\n            stack.pop()\n            if stack:\n                res = max(res, i - stack[-1])\n            else:\n                stack.append(i)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(longestValidParentheses(\"(()\"))  # 2\n    print(longestValidParentheses(\")()())\"))  # 4\n</code></pre>"},{"location":"top-100-liked/graph/","title":"Graph","text":""},{"location":"top-100-liked/graph/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 200. Number of Islands (Medium)</li> <li> 994. Rotting Oranges (Medium)</li> <li> 207. Course Schedule (Medium)</li> <li> 208. Implement Trie (Prefix Tree) (Medium)</li> </ul>"},{"location":"top-100-liked/graph/#200-number-of-islands","title":"200. Number of Islands","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Depth First Search, Breadth First Search, Union Find, Matrix</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Count the number of islands in a 2D grid.\n-   Method 1: DFS\n-   Method 2: BFS (use a queue to traverse the grid)\n\n-   How to keep track of visited cells?\n\n    1. Mark the visited cell as `0` (or any other value) to avoid revisiting it.\n    2. Use a set to store the visited cells.\n\n-   Steps:\n    1. Init: variables\n    2. DFS/BFS: starting from the cell with `1`, turn all the connected `1`s to `0`.\n    3. Traverse the grid, and if the cell is `1`, increment the count and call DFS/BFS.\n\n![0200](../../assets/0200.jpg)\n\"\"\"\n\nfrom collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef numIslandsDFS(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    res = 0\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] != \"1\":\n            return\n\n        grid[r][c] = \"2\"\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                dfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Set\ndef numIslandsBFS1(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == \"0\"\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\" and (r, c) not in visited:\n                visited.add((r, c))\n                bfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = dr + row, dc + col\n                if nr &lt; 0 or nr &gt;= m or nc &lt; 0 or nc &gt;= n or grid[nr][nc] != \"1\":\n                    continue\n                grid[nr][nc] = \"2\"\n                q.append((nr, nc))\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == \"1\":\n                grid[i][j] = \"2\"\n                bfs(i, j)\n                res += 1\n\n    return res\n\n\ngrid = [\n    [\"1\", \"1\", \"1\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"0\", \"0\", \"0\", \"0\", \"0\"],\n]\n\nprint(numIslandsDFS(deepcopy(grid)))  # 1\nprint(numIslandsBFS1(deepcopy(grid)))  # 1\nprint(numIslandsBFS2(deepcopy(grid)))  # 1\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    // dfs\n    int num_islands_dfs(vector&lt;vector&lt;char&gt;&gt; &amp;grid) {\n        int m = grid.size(), n = grid[0].size();\n        int res = 0;\n\n        // c++23 lambda recursion\n        auto dfs = [&amp;](this auto &amp;&amp;dfs, int r, int c) -&gt; void {\n            if (r &lt; 0 || r &gt;= m || c &lt; 0 || c &gt;= n || grid[r][c] != '1') {\n                return;\n            }\n            grid[r][c] = '0';\n            dfs(r + 1, c);\n            dfs(r - 1, c);\n            dfs(r, c + 1);\n            dfs(r, c - 1);\n        };\n\n        for (int i = 0; i &lt; m; i++) {\n            for (int j = 0; j &lt; n; j++) {\n                if (grid[i][j] == '1') {\n                    res++;\n                    dfs(i, j);\n                }\n            }\n        }\n        return res;\n    }\n\n    // bfs\n    int num_islands_bfs(vector&lt;vector&lt;char&gt;&gt; &amp;grid) {\n        int m = grid.size(), n = grid[0].size();\n        int res = 0;\n        vector&lt;pair&lt;int, int&gt;&gt; dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\n        auto bfs = [&amp;](int r, int c) {\n            queue&lt;pair&lt;int, int&gt;&gt; q;\n            q.push({r, c});\n            grid[r][c] = '0';\n            while (!q.empty()) {\n                auto [cr, cc] = q.front();\n                q.pop();\n                for (auto &amp;[dr, dc] : dirs) {\n                    int nr = cr + dr, nc = cc + dc;\n                    if (nr &gt;= 0 &amp;&amp; nr &lt; m &amp;&amp; nc &gt;= 0 &amp;&amp; nc &lt; n &amp;&amp;\n                        grid[nr][nc] == '1') {\n                        grid[nr][nc] = '0';\n                        q.push({nr, nc});\n                    }\n                }\n            }\n        };\n\n        for (int i = 0; i &lt; m; i++) {\n            for (int j = 0; j &lt; n; j++) {\n                if (grid[i][j] == '1') {\n                    res++;\n                    bfs(i, j);\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;vector&lt;char&gt;&gt; grid = {{'1', '1', '0', '0', '0'},\n                                 {'1', '1', '0', '0', '0'},\n                                 {'0', '0', '1', '0', '0'},\n                                 {'0', '0', '0', '1', '1'}};\n    assert(solution.num_islands_dfs(grid) == 3);\n    grid = {{'1', '1', '0', '0', '0'},\n            {'1', '1', '0', '0', '0'},\n            {'0', '0', '1', '0', '0'},\n            {'0', '0', '0', '1', '1'}};\n    assert(solution.num_islands_bfs(grid) == 3);\n    return 0;\n}\n</code></pre>"},{"location":"top-100-liked/graph/#994-rotting-oranges","title":"994. Rotting Oranges","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Breadth First Search, Matrix</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the minimum number of minutes that must elapse until no cell has a fresh orange.\n-   Hint: Multi-source BFS to count the level.\n\n![994](https://assets.leetcode.com/uploads/2019/02/16/oranges.png)\n\"\"\"\n\nfrom collections import deque\nfrom typing import List\n\n\n# BFS\ndef orangesRotting(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    fresh = 0\n    q = deque()\n    dirs = [[1, 0], [0, 1], [0, -1], [-1, 0]]\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 2:\n                q.append([i, j])\n            elif grid[i][j] == 1:\n                fresh += 1\n    res = 0\n\n    while q and fresh &gt; 0:\n        size = len(q)\n        for _ in range(size):\n            r, c = q.popleft()\n            for dr, dc in dirs:\n                nr, nc = dr + r, dc + c\n                if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and grid[nr][nc] == 1:\n                    q.append([nr, nc])\n                    grid[nr][nc] = 2\n                    fresh -= 1\n        res += 1\n\n    return res if fresh == 0 else -1\n\n\ngrid = [[2, 1, 1], [1, 1, 0], [0, 1, 1]]\nassert orangesRotting(grid) == 4\n</code></pre>"},{"location":"top-100-liked/graph/#207-course-schedule","title":"207. Course Schedule","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Depth First Search, Breadth First Search, Graph, Topological Sort</p> </li> </ul> PythonCPP <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS (Kahn's Algorithm)\ndef canFinishBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    count = 0\n\n    while q:\n        crs = q.popleft()\n        count += 1\n\n        for nxt in graph[crs]:\n            indegree[nxt] -= 1\n\n            if indegree[nxt] == 0:\n                q.append(nxt)\n\n    return count == numCourses\n\n\n# DFS + Set\ndef canFinishDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for crs, pre in prerequisites:\n        graph[crs].append(pre)\n\n    visiting = set()\n\n    def dfs(crs):\n        if crs in visiting:  # cycle detected\n            return False\n        if graph[crs] == []:\n            return True\n\n        visiting.add(crs)\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        visiting.remove(crs)\n        graph[crs] = []\n\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\n# DFS + List\ndef canFinishDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for pre, crs in prerequisites:\n        graph[crs].append(pre)\n\n    # 0: init, 1: visiting, 2: visited\n    status = [0] * numCourses\n\n    def dfs(crs):\n        if status[crs] == 1:  # cycle detected\n            return False\n        if status[crs] == 2:\n            return True\n\n        status[crs] = 1\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        status[crs] = 2\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(canFinishBFS(5, prerequisites))  # True\nprint(canFinishDFS1(5, prerequisites))  # True\nprint(canFinishDFS2(5, prerequisites))  # True\n</code></pre> <pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    // BFS\n    bool canFinishBFS(int numCourses, vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        vector&lt;int&gt; indegree(numCourses, 0);\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n            indegree[pre[0]]++;\n        }\n\n        queue&lt;int&gt; q;\n        for (int i = 0; i &lt; numCourses; i++) {\n            if (indegree[i] == 0) {\n                q.push(i);\n            }\n        }\n\n        int cnt = 0;\n        while (!q.empty()) {\n            int cur = q.front();\n            q.pop();\n            cnt++;\n\n            for (int nxt : graph[cur]) {\n                indegree[nxt]--;\n                if (indegree[nxt] == 0) {\n                    q.push(nxt);\n                }\n            }\n        }\n        return cnt == numCourses;\n    }\n\n    // DFS\n    bool canFinishDFS(int numCourses, vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n        }\n        // 0: not visited, 1: visiting, 2: visited\n        vector&lt;int&gt; state(numCourses, 0);\n\n        function&lt;bool(int)&gt; dfs = [&amp;](int pre) -&gt; bool {\n            state[pre] = 1;  // visiting\n            for (int crs : graph[pre]) {\n                if (state[crs] == 1 || (state[crs] == 0 &amp;&amp; dfs(crs))) {\n                    return true;\n                }\n            }\n            state[pre] = 2;  // visited\n            return false;\n        };\n\n        for (int i = 0; i &lt; numCourses; i++) {\n            if (state[i] == 0 &amp;&amp; dfs(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution sol;\n    vector&lt;vector&lt;int&gt;&gt; prerequisites = {{1, 0}, {2, 1}, {3, 2}, {4, 3},\n                                         {5, 4}, {6, 5}, {7, 6}, {8, 7},\n                                         {9, 8}, {10, 9}};\n    int numCourses = 11;\n    cout &lt;&lt; sol.canFinishBFS(numCourses, prerequisites) &lt;&lt; endl;\n    cout &lt;&lt; sol.canFinishDFS(numCourses, prerequisites) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"top-100-liked/graph/#208-implement-trie-prefix-tree","title":"208. Implement Trie (Prefix Tree)","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Design, Trie</p> </li> </ul> Python <pre><code>\"\"\"\n### Trie\n\n- A trie is a tree-like data structure whose nodes store the letters of an alphabet.\n\"\"\"\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.endOfWord = None\n\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.endOfWord = True\n\n    def search(self, word: str) -&gt; bool:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return node.endOfWord\n\n    def startsWith(self, prefix: str) -&gt; bool:\n        node = self.root\n\n        for c in prefix:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return True\n\n\n# Your Trie object will be instantiated and called as such:\nobj = Trie()\nobj.insert(\"apple\")\nprint(obj.search(\"word\"))  # False\nprint(obj.startsWith(\"app\"))  # True\n</code></pre>"},{"location":"top-100-liked/greedy/","title":"Greedy","text":""},{"location":"top-100-liked/greedy/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 121. Best Time to Buy and Sell Stock (Easy)</li> <li> 55. Jump Game (Medium)</li> <li> 45. Jump Game II (Medium)</li> <li> 763. Partition Labels (Medium)</li> </ul>"},{"location":"top-100-liked/greedy/#121-best-time-to-buy-and-sell-stock","title":"121. Best Time to Buy and Sell Stock","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Return the maximum profit that can be achieved from buying on one day and selling on another day.\n\"\"\"\n\nfrom typing import List\n\n\n# Brute Force\ndef maxProfitBF(prices: List[int]) -&gt; int:\n    max_profit = 0\n    n = len(prices)\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_profit = max(max_profit, prices[j] - prices[i])\n\n    return max_profit\n\n\n# DP\ndef maxProfitDP(prices: List[int]) -&gt; int:\n    dp = [[0] * 2 for _ in range(len(prices))]\n    dp[0][0] = -prices[0]  # buy\n    dp[0][1] = 0  # sell\n\n    for i in range(1, len(prices)):\n        dp[i][0] = max(dp[i - 1][0], -prices[i])  # the lowest price to buy\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    max_profit = 0\n    seen_min = prices[0]\n\n    for i in range(1, len(prices)):\n        max_profit = max(max_profit, prices[i] - seen_min)\n        seen_min = min(seen_min, prices[i])\n\n    return max_profit\n\n\n# Fast Slow Pointers\ndef maxProfitFS(prices: List[int]) -&gt; int:\n    max_profit = 0\n    slow, fast = 0, 1\n\n    while fast &lt; len(prices):\n        if prices[fast] &gt; prices[slow]:\n            max_profit = max(max_profit, prices[fast] - prices[slow])\n        else:\n            slow = fast\n        fast += 1\n\n    return max_profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force|  O(n^2)|  O(1)   |\n# | DP         |  O(n)  |  O(n)   |\n# | Greedy     |  O(n)  |  O(1)   |\n# | Fast Slow  |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitBF(prices))  # 5\nprint(maxProfitDP(prices))  # 5\nprint(maxProfitGreedy(prices))  # 5\nprint(maxProfitFS(prices))  # 5\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int maxProfitMemo(vector&lt;int&gt; &amp;prices) {\n        if (prices.size() &lt;= 1) return 0;\n\n        int seen_min = prices[0];\n        int res = 0;\n\n        for (int &amp;price : prices) {\n            res = max(res, price - seen_min);\n            seen_min = min(seen_min, price);\n        }\n        return res;\n    }\n};\n\nint main() {\n    vector&lt;int&gt; prices = {7, 1, 5, 3, 6, 4};\n    Solution obj;\n    cout &lt;&lt; obj.maxProfitMemo(prices) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"top-100-liked/greedy/#55-jump-game","title":"55. Jump Game","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return `True` if you can reach the last index, otherwise `False`.\n\"\"\"\n\nfrom typing import List\n\n\n# Greedy - Interval\ndef canJump(nums: List[int]) -&gt; bool:\n    n = len(nums)\n    reach = 0\n    i = 0\n\n    while reach &gt;= i:\n        if reach &gt;= n - 1:\n            return True\n        reach = max(reach, i + nums[i])\n        i += 1\n\n    return False\n\n\nif __name__ == \"__main__\":\n    assert canJump([2, 3, 1, 1, 4]) is True\n    assert canJump([3, 2, 1, 0, 4]) is False\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool canJump(vector&lt;int&gt;&amp; nums) {\n        int canReach = 0;\n        int n = nums.size();\n\n        for (int i = 0; i &lt; n; i++) {\n            if (i &gt; canReach) return false;\n            canReach = max(canReach, i + nums[i]);\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution obj;\n    vector&lt;int&gt; nums = {2, 3, 1, 1, 4};\n    cout &lt;&lt; obj.canJump(nums) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"top-100-liked/greedy/#45-jump-game-ii","title":"45. Jump Game II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Greedy</p> </li> </ul> Python <pre><code>\"\"\"\n- Return the minimum number of jumps to reach the last index.\n\"\"\"\n\nfrom typing import List\n\n\n# Greedy - Interval\ndef jump(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n == 1:\n        return 0\n\n    reach = 0\n    left, right = 0, 0\n    res = 0\n\n    while right &lt; n - 1:\n        for i in range(left, right + 1):\n            reach = max(reach, i + nums[i])\n\n        left = right + 1\n        right = reach\n        res += 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert jump([2, 3, 1, 1, 4]) == 2\n    assert jump([2, 3, 0, 1, 4]) == 2\n</code></pre>"},{"location":"top-100-liked/greedy/#763-partition-labels","title":"763. Partition Labels","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Two Pointers, String, Greedy</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# 1. Hashmap\ndef partitionLabels1(s: str) -&gt; List[int]:\n    hashmap = {}\n\n    for i, j in enumerate(s):\n        if j not in hashmap:\n            hashmap[j] = [i, i]\n        else:\n            hashmap[j][1] = i\n\n    intervals = list(hashmap.values())\n    intervals.sort(key=lambda x: x[0])\n\n    if len(intervals) &lt; 2:\n        return len(intervals)\n\n    res = []\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &lt; intervals[i - 1][1]:\n            intervals[i][1] = max(intervals[i][1], intervals[i - 1][1])\n        else:\n            res.append(intervals[i][0])\n\n    res.append(intervals[-1][1] + 1)\n\n    if len(res) == 1:\n        return res\n    else:\n        for i in range(len(res) - 1, 0, -1):\n            res[i] -= res[i - 1]\n        return res\n\n\n# Single Pass Partitioning\ndef partitionLabels2(s: str) -&gt; List[int]:\n    last = {c: i for i, c in enumerate(s)}\n    res = []\n    start, end = 0, 0\n\n    for i, c in enumerate(s):\n        end = max(end, last[c])\n        if end == i:\n            res.append(end - start + 1)\n            start = i + 1\n\n    return res\n\n\nprint(partitionLabels1(\"abaccd\"))  # [3, 2, 1]\nprint(partitionLabels2(\"abaccd\"))  # [3, 2, 1]\n</code></pre>"},{"location":"top-100-liked/hash/","title":"Hash","text":""},{"location":"top-100-liked/hash/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1. Two Sum (Easy)</li> <li> 49. Group Anagrams (Medium)</li> <li> 128. Longest Consecutive Sequence (Medium)</li> </ul>"},{"location":"top-100-liked/hash/#1-two-sum","title":"1. Two Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return the indices of the two numbers such that they add up to a specific target.\n- Approach: Use a hashmap to store the indices of the numbers.\n- Time Complexity: O(n)\n- Space Complexity: O(n)\n\"\"\"\n\nfrom typing import List\n\n\ndef two_sum(nums: List[int], target: int) -&gt; List[int]:\n    hashmap = {}  # val: idx\n\n    for idx, val in enumerate(nums):\n        if (target - val) in hashmap:\n            return [hashmap[target - val], idx]\n\n        hashmap[val] = idx\n\n    return []\n\n\ndef test_two_sum():\n    assert two_sum([2, 7, 11, 15], 9) == [0, 1]\n    assert two_sum([3, 2, 4], 6) == [1, 2]\n    assert two_sum([3, 3], 6) == [0, 1]\n    assert two_sum([1, 2, 3, 4, 5], 10) == []\n    assert two_sum([-1, -2, -3, -4, -5], -8) == [2, 4]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Solution {\n   public:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {\n        unordered_map&lt;int, int&gt; map;\n\n        for (size_t i = 0; i &lt; nums.size(); i++) {\n            int diff = target - nums[i];\n            if (map.find(diff) != map.end()) {\n                return {map[diff], (int)i};\n            }\n            map[nums[i]] = (int)i;\n        }\n        return {-1, -1};\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;int&gt; nums = {2, 7, 11, 15};\n    int target = 9;\n    vector&lt;int&gt; result = solution.twoSum(nums, target);\n    assert((result == vector&lt;int&gt;{0, 1}));\n    return 0;\n}\n</code></pre>"},{"location":"top-100-liked/hash/#49-group-anagrams","title":"49. Group Anagrams","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, String, Sorting</p> </li> </ul> PythonCPP <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash - List\ndef groupAnagrams(strs: List[str]) -&gt; List[List[str]]:\n    result = defaultdict(list)\n\n    for s in strs:\n        count = [0] * 26\n        for i in s:\n            count[ord(i) - ord(\"a\")] += 1\n\n        result[tuple(count)].append(s)\n\n    return list(result.values())\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Hash     |     O(n * k)    |     O(n)     |\n# |-------------|-----------------|--------------|\n\n\nstrs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\nprint(groupAnagrams(strs))\n# [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;cassert&gt;\n#include &lt;ranges&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Solution {\n   public:\n    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) {\n        unordered_map&lt;string, vector&lt;string&gt;&gt; map;\n\n        for (string&amp; s : strs) {\n            string sorted = s;\n            ranges::sort(sorted);\n            map[sorted].push_back(s);\n        }\n\n        vector&lt;vector&lt;string&gt;&gt; res;\n\n        for (auto&amp; kv : map) {\n            res.push_back(kv.second);\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector&lt;string&gt; strs = {\"eat\", \"tea\", \"tan\"};\n    vector&lt;vector&lt;string&gt;&gt; res = solution.groupAnagrams(strs);\n    assert((res == vector&lt;vector&lt;string&gt;&gt;{{\"eat\", \"tea\"}, {\"tan\"}} ||\n            res == vector&lt;vector&lt;string&gt;&gt;{{\"tan\"}, {\"eat\", \"tea\"}}));\n\n    return 0;\n}\n</code></pre>"},{"location":"top-100-liked/hash/#128-longest-consecutive-sequence","title":"128. Longest Consecutive Sequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Union Find</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Set\ndef longestConsecutiveSet(nums: List[int]) -&gt; int:\n    num_set = set(nums)  # O(n)\n    longest = 0\n\n    for n in nums:\n        if (n - 1) not in num_set:  # left boundary\n            length = 1\n\n            while (n + length) in num_set:\n                length += 1\n\n            longest = max(longest, length)\n\n    return longest\n\n\n# Union Find\ndef longestConsecutiveUF(nums: List[int]) -&gt; int:\n    if not nums:\n        return 0\n\n    par = {num: num for num in nums}\n    rank = {num: 1 for num in nums}\n\n    def find(num):\n        p = par[num]\n        while p != par[p]:\n            p = par[p]\n        return p\n\n    def union(num1, num2):\n        p1, p2 = find(num1), find(num2)\n        if p1 == p2:\n            return\n\n        if rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n            rank[p2] += rank[p1]\n        else:\n            par[p2] = p1\n            rank[p1] += rank[p2]\n\n    for num in nums:\n        if num - 1 in par:\n            union(num, num - 1)\n\n    return max(rank.values())\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |  Set       |  O(N)  |  O(N)   |\n# | Union Find |  O(N)  |  O(N)   |\n# |------------|--------|---------|\n\n\nnums = [100, 4, 200, 1, 3, 2]\nprint(longestConsecutiveSet(nums))  # 4\nprint(longestConsecutiveUF(nums))  # 4\n</code></pre>"},{"location":"top-100-liked/heap/","title":"Heap","text":""},{"location":"top-100-liked/heap/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 215. Kth Largest Element in an Array (Medium)</li> <li> 347. Top K Frequent Elements (Medium)</li> <li> 295. Find Median from Data Stream (Hard)</li> </ul>"},{"location":"top-100-liked/heap/#215-kth-largest-element-in-an-array","title":"215. Kth Largest Element in an Array","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Divide And Conquer, Sorting, Heap Priority Queue, Quickselect</p> </li> </ul> Python <pre><code>import heapq\nfrom typing import List\n\n\ndef findKthLargest(nums: List[int], k: int) -&gt; int:\n    min_heap = []\n\n    for i, num in enumerate(nums):\n        heapq.heappush(min_heap, num)\n        if i &gt;= k:\n            heapq.heappop(min_heap)\n\n    return min_heap[0]\n\n\nif __name__ == \"__main__\":\n    assert findKthLargest([3, 2, 1, 5, 6, 4], 2) == 5\n</code></pre>"},{"location":"top-100-liked/heap/#347-top-k-frequent-elements","title":"347. Top K Frequent Elements","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Divide And Conquer, Sorting, Heap Priority Queue, Bucket Sort, Counting, Quickselect</p> </li> </ul> Python <pre><code>import heapq\nfrom collections import Counter\nfrom typing import List\n\n\n# Heap + Counter\ndef topKFrequent(nums: List[int], k: int) -&gt; List[int]:\n    minHeap = []\n\n    for val, freq in Counter(nums).items():\n        if len(minHeap) &lt; k:\n            heapq.heappush(minHeap, (freq, val))\n        else:\n            heapq.heappushpop(minHeap, (freq, val))\n\n    return [i for _, i in minHeap]\n\n\n# Counter (Most Common)\ndef topKFrequentCounter(nums: List[int], k: int) -&gt; List[int]:\n    commons = Counter(nums).most_common(k)\n    return [i for i, _ in commons]\n\n\nnums = [1, 1, 1, 2, 2, 3]\nk = 2\nprint(topKFrequent(nums, k))  # [1, 2]\nprint(topKFrequentCounter(nums, k))  # [1, 2]\n</code></pre>"},{"location":"top-100-liked/heap/#295-find-median-from-data-stream","title":"295. Find Median from Data Stream","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, Design, Sorting, Heap Priority Queue, Data Stream</p> </li> </ul> PythonCPP <pre><code>from heapq import heappop, heappush\n\n\nclass MedianFinder:\n\n    def __init__(self):\n        self.minHeap = []\n        self.maxHeap = []\n        self.min_size = 0\n        self.max_size = 0\n\n    def addNum(self, num: int) -&gt; None:\n        heappush(self.maxHeap, -num)\n        heappush(self.minHeap, -heappop(self.maxHeap))\n        self.min_size += 1\n\n        if self.min_size &gt; self.max_size:\n            heappush(self.maxHeap, -heappop(self.minHeap))\n            self.min_size -= 1\n            self.max_size += 1\n\n    def findMedian(self) -&gt; float:\n        if self.min_size == self.max_size:\n            return (-self.maxHeap[0] + self.minHeap[0]) / 2.0\n        return float(-self.maxHeap[0])\n\n\ndef test_median_finder():\n    obj = MedianFinder()\n    obj.addNum(1)\n    obj.addNum(2)\n    assert obj.findMedian() == 1.5\n    obj.addNum(3)\n    assert obj.findMedian() == 2.0\n    obj.addNum(4)\n    assert obj.findMedian() == 2.5\n    obj.addNum(5)\n    assert obj.findMedian() == 3.0\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass MedianFinder {\n   private:\n    priority_queue&lt;int&gt; maxHeap;\n    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;\n    int max_size = 0;\n    int min_size = 0;\n\n   public:\n    MedianFinder() {}\n\n    void addNum(int num) {\n        if (min_size == max_size) {\n            minHeap.push(num);\n            maxHeap.push(minHeap.top());\n            minHeap.pop();\n            max_size++;\n        } else {\n            maxHeap.push(num);\n            minHeap.push(maxHeap.top());\n            maxHeap.pop();\n            min_size++;\n        }\n    }\n\n    double findMedian() {\n        if (min_size == max_size) {\n            return (maxHeap.top() + minHeap.top()) / 2.0;\n        } else {\n            return (double)maxHeap.top();\n        }\n    }\n};\n\nint main() {\n    MedianFinder* obj = new MedianFinder();\n    obj-&gt;addNum(1);\n    obj-&gt;addNum(2);\n    cout &lt;&lt; obj-&gt;findMedian() &lt;&lt; endl;  // 1.5\n    obj-&gt;addNum(3);\n    cout &lt;&lt; obj-&gt;findMedian() &lt;&lt; endl;  // 2\n    return 0;\n}\n</code></pre>"},{"location":"top-100-liked/linked_list/","title":"Linked List","text":""},{"location":"top-100-liked/linked_list/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 160. Intersection of Two Linked Lists (Easy)</li> <li> 206. Reverse Linked List (Easy)</li> <li> 234. Palindrome Linked List (Easy)</li> <li> 141. Linked List Cycle (Easy)</li> <li> 142. Linked List Cycle II (Medium)</li> <li> 21. Merge Two Sorted Lists (Easy)</li> <li> 2. Add Two Numbers (Medium)</li> <li> 19. Remove Nth Node From End of List (Medium)</li> <li> 24. Swap Nodes in Pairs (Medium)</li> <li> 25. Reverse Nodes in k-Group (Hard)</li> <li> 138. Copy List with Random Pointer (Medium)</li> <li> 148. Sort List (Medium)</li> <li> 23. Merge k Sorted Lists (Hard)</li> <li> 146. LRU Cache (Medium)</li> </ul>"},{"location":"top-100-liked/linked_list/#160-intersection-of-two-linked-lists","title":"160. Intersection of Two Linked Lists","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Linked List, Two Pointers</p> </li> </ul> Python <pre><code>\"\"\"\n-   Find the node at which the intersection of two singly linked lists begins.\n\"\"\"\n\nfrom typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\n# Hash Set\ndef getIntersectionNodeHash(headA: ListNode, headB: ListNode) -&gt; Optional[ListNode]:\n    if not headA or not headB:\n        return None\n\n    visited = set()\n    cur = headA\n    while cur:\n        visited.add(cur)\n        cur = cur.next\n\n    cur = headB\n    while cur:\n        if cur in visited:\n            return cur\n        cur = cur.next\n\n    return None\n\n\n# Two Pointers\ndef getIntersectionNodeTP(headA: ListNode, headB: ListNode) -&gt; Optional[ListNode]:\n    if not headA or not headB:\n        return None\n\n    a, b = headA, headB\n\n    while a != b:\n        a = a.next if a else headB\n        b = b.next if b else headA\n\n    return a\n\n\ndef test_intersection():\n    # Test case 1: Lists with intersection\n    llA = LinkedList([4, 1, 8, 4, 5])\n    llB = LinkedList([5, 6, 1])\n\n    # Create intersection at node with value 8\n    nodeA = llA.head\n    while nodeA and nodeA.val != 8:\n        nodeA = nodeA.next\n\n    # Connect listB to the intersection point\n    llB.head.next.next.next = nodeA\n\n    assert llA.to_array() == [4, 1, 8, 4, 5]\n\n    intersection_hash = getIntersectionNodeHash(llA.head, llB.head)\n    intersection_tp = getIntersectionNodeTP(llA.head, llB.head)\n\n    assert intersection_hash is not None\n    assert intersection_tp is not None\n    assert intersection_hash.val == 8\n    assert intersection_tp.val == 8\n    assert intersection_hash == intersection_tp\n\n    # Test case 2: Lists without intersection\n    llC = LinkedList([2, 6, 4])\n    llD = LinkedList([1, 5])\n\n    intersection_hash = getIntersectionNodeHash(llC.head, llD.head)\n    intersection_tp = getIntersectionNodeTP(llC.head, llD.head)\n\n    assert intersection_hash is None\n    assert intersection_tp is None\n</code></pre>"},{"location":"top-100-liked/linked_list/#206-reverse-linked-list","title":"206. Reverse Linked List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Recursion</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\ndef reverse_list_iterative(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    cur = head\n    prev = None\n\n    while cur:\n        temp = cur.next\n        cur.next = prev\n\n        prev = cur\n        cur = temp\n\n    return prev\n\n\ndef reverse_list_recursive(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    def reverse(cur, prev):\n        if not cur:\n            return prev\n\n        temp = cur.next\n        cur.next = prev\n        return reverse(temp, cur)\n\n    return reverse(head, None)\n\n\ndef test_reverse_list():\n    ll = LinkedList([1, 2, 3, 4, 5])\n    ll.head = reverse_list_iterative(ll.head)\n    assert ll.to_array() == [5, 4, 3, 2, 1]\n\n    ll = LinkedList([1, 2, 3, 4, 5])\n    ll.head = reverse_list_recursive(ll.head)\n    assert ll.to_array() == [5, 4, 3, 2, 1]\n</code></pre>"},{"location":"top-100-liked/linked_list/#234-palindrome-linked-list","title":"234. Palindrome Linked List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Two Pointers, Stack, Recursion</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom leetpattern.utils import ListNode\n\n\n# Linked List\ndef isPalindrome(head: Optional[ListNode]) -&gt; bool:\n    if not head or not head.next:\n        return True\n\n    def middle(node):\n        fast, slow = node, node\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n        return slow\n\n    def reverse(node):\n        cur, pre = node, None\n        while cur:\n            nxt = cur.next\n            cur.next = pre\n            pre = cur\n            cur = nxt\n        return pre\n\n    mid1 = head\n    mid2 = reverse(middle(head))\n\n    while mid2:\n        if mid1.val != mid2.val:\n            return False\n        mid1 = mid1.next\n        mid2 = mid2.next\n\n    return True\n\n\nhead = ListNode().create([1, 2, 2, 1])\nprint(isPalindrome(head))  # True\n</code></pre>"},{"location":"top-100-liked/linked_list/#141-linked-list-cycle","title":"141. Linked List Cycle","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Linked List, Two Pointers</p> </li> </ul> PythonCPP <pre><code>from typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\ndef has_cycle(head: Optional[ListNode]) -&gt; bool:\n    slow, fast = head, head\n\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n        if slow == fast:\n            return True\n\n    return False\n\n\ndef test_has_cycle():\n    ll = LinkedList([3, 2, 0, -4])\n    ll.make_cycle(pos=1)\n    assert has_cycle(ll.head)\n\n    ll = LinkedList([1, 2])\n    ll.make_cycle(pos=0)\n    assert has_cycle(ll.head)\n\n    ll = LinkedList([1, 2, 3, 4, 5])\n    assert not has_cycle(ll.head)\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n\n#include \"include/lists.hpp\"\nusing namespace std;\n\nclass Solution {\n   public:\n    bool has_cycle(ListNode* head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while (fast &amp;&amp; fast-&gt;next) {\n            slow = slow-&gt;next;\n            fast = fast-&gt;next-&gt;next;\n\n            if (fast == slow) return true;\n        }\n        return false;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    ListNode* head = LinkedList::build({3, 2, 0, -4});\n    // create cycle\n    head = LinkedList::make_cycle(head, 1);\n    assert(solution.has_cycle(head) == true);\n    // no cycle\n    ListNode* head2 = LinkedList::build({1, 2});\n    assert(solution.has_cycle(head2) == false);\n    // no cycle\n    ListNode* head3 = LinkedList::build({1});\n    assert(solution.has_cycle(head3) == false);\n\n    return 0;\n}\n</code></pre>"},{"location":"top-100-liked/linked_list/#142-linked-list-cycle-ii","title":"142. Linked List Cycle II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Linked List, Two Pointers</p> </li> </ul> PythonCPP <pre><code>from typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\ndef detectCycle(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    slow, fast = head, head\n\n    while fast and fast.next:\n        fast = fast.next.next\n        slow = slow.next\n\n        if slow == fast:\n            slow = head\n            while slow != fast:\n                slow = slow.next\n                fast = fast.next\n            return slow\n\n    return None\n\n\ndef test_detectCycle():\n    l1 = LinkedList([3, 2, 0, -4])\n    l1.make_cycle(1)\n    assert detectCycle(l1.head).val == 2\n    l2 = LinkedList([3, 2, 0, -4])\n    assert not detectCycle(l2.head)\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nclass Solution {\n   public:\n    ListNode* detectCycle(ListNode* head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while (fast &amp;&amp; fast-&gt;next) {\n            slow = slow-&gt;next;\n            fast = fast-&gt;next-&gt;next;\n\n            if (fast == slow) {\n                slow = head;\n                while (slow != fast) {\n                    slow = slow-&gt;next;\n                    fast = fast-&gt;next;\n                }\n                return slow;\n            }\n        }\n        return nullptr;\n    }\n};\n\nint main() {\n    Solution sol;\n\n    ListNode* head = new ListNode(3);\n    head-&gt;next = new ListNode(2);\n    head-&gt;next-&gt;next = new ListNode(0);\n    head-&gt;next-&gt;next-&gt;next = new ListNode(-4);\n    head-&gt;next-&gt;next-&gt;next-&gt;next = head-&gt;next;  // Create a cycle\n    assert(sol.detectCycle(head) == head-&gt;next);\n\n    ListNode* head2 = new ListNode(1);\n    head2-&gt;next = new ListNode(2);\n    head2-&gt;next-&gt;next = head2;  // Create a cycle\n    assert(sol.detectCycle(head2) == head2);\n\n    ListNode* head3 = new ListNode(1);\n    assert(sol.detectCycle(head3) == nullptr);\n\n    ListNode* head4 = nullptr;\n    assert(sol.detectCycle(head4) == nullptr);\n\n    return 0;\n}\n</code></pre>"},{"location":"top-100-liked/linked_list/#21-merge-two-sorted-lists","title":"21. Merge Two Sorted Lists","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Recursion</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Task: Merge the two linked lists into one sorted list.\n\"\"\"\n\nfrom typing import Optional\n\nfrom leetpattern.utils import ListNode\n\n\n# Linked List\ndef merge_two_lists(\n    list1: Optional[ListNode], list2: Optional[ListNode]\n) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    while list1 and list2:\n        if list1.val &lt; list2.val:\n            cur.next = list1\n            list1 = list1.next\n        else:\n            cur.next = list2\n            list2 = list2.next\n        cur = cur.next\n\n    if list1:\n        cur.next = list1\n    elif list2:\n        cur.next = list2\n\n    return dummy.next\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode* next) : val(x), next(next) {}\n};\n\nclass Solution {\n   public:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        ListNode dummy;\n        ListNode* cur = &amp;dummy;\n\n        while (list1 &amp;&amp; list2) {\n            if (list1-&gt;val &lt; list2-&gt;val) {\n                cur-&gt;next = list1;\n                list1 = list1-&gt;next;\n            } else {\n                cur-&gt;next = list2;\n                list2 = list2-&gt;next;\n            }\n            cur = cur-&gt;next;\n        }\n\n        cur-&gt;next = list1 ? list1 : list2;\n\n        return dummy.next;\n    }\n};\n\nint main() {\n    Solution sol;\n    ListNode* list1 = new ListNode(1, new ListNode(2, new ListNode(4)));\n    ListNode* list2 = new ListNode(1, new ListNode(3, new ListNode(4)));\n    ListNode* merged = sol.mergeTwoLists(list1, list2);\n    vector&lt;int&gt; res;\n    while (merged) {\n        res.push_back(merged-&gt;val);\n        merged = merged-&gt;next;\n    }\n    assert(res == std::vector&lt;int&gt;({1, 1, 2, 3, 4, 4}));\n    return 0;\n}\n</code></pre>"},{"location":"top-100-liked/linked_list/#2-add-two-numbers","title":"2. Add Two Numbers","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Math, Recursion</p> </li> </ul> PythonCPP <pre><code>from typing import Optional\n\nfrom leetpattern.utils import LinkedList, ListNode\n\n\ndef add_two_numbers(l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]:\n    \"\"\"Add two numbers represented by linked lists.\"\"\"\n    dummy = ListNode()\n    cur = dummy\n    carry = 0\n\n    while l1 or l2:\n        v1 = l1.val if l1 else 0\n        v2 = l2.val if l2 else 0\n\n        carry, val = divmod(v1 + v2 + carry, 10)\n        cur.next = ListNode(val)\n        cur = cur.next\n\n        if l1:\n            l1 = l1.next\n        if l2:\n            l2 = l2.next\n\n    if carry:\n        cur.next = ListNode(val=carry)\n\n    return dummy.next\n\n\ndef test_add_two_numbers():\n    l1 = LinkedList([2, 4, 3]).head\n    l2 = LinkedList([5, 6, 4]).head\n    added = add_two_numbers(l1, l2)\n    assert LinkedList(added).to_array() == [7, 0, 8]\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode* next) : val(x), next(next) {}\n};\n\nclass Solution {\n   public:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode dummy;\n        ListNode* cur = &amp;dummy;\n        int carry = 0;\n\n        while (l1 || l2 || carry) {\n            if (l1) {\n                carry += l1-&gt;val;\n                l1 = l1-&gt;next;\n            }\n            if (l2) {\n                carry += l2-&gt;val;\n                l2 = l2-&gt;next;\n            }\n            cur-&gt;next = new ListNode(carry % 10);\n            cur = cur-&gt;next;\n            carry /= 10;\n        }\n        return dummy.next;\n    }\n};\n\nint main() {\n    Solution sol;\n\n    ListNode* l1 = new ListNode(2, new ListNode(4, new ListNode(3)));\n    ListNode* l2 = new ListNode(5, new ListNode(6, new ListNode(4)));\n    ListNode* result = sol.addTwoNumbers(l1, l2);\n\n    vector&lt;int&gt; expected = {7, 0, 8};\n    for (int val : expected) {\n        assert(result != nullptr &amp;&amp; result-&gt;val == val);\n        result = result-&gt;next;\n    }\n    assert(result == nullptr);  // End of list\n\n    return 0;\n}\n</code></pre>"},{"location":"top-100-liked/linked_list/#19-remove-nth-node-from-end-of-list","title":"19. Remove Nth Node From End of List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Two Pointers</p> </li> </ul> Python <pre><code>\"\"\"\n-   Given the `head` of a linked list, remove the `n-th` node from the end of the list and return its head.\n\"\"\"\n\nfrom typing import Optional\n\nfrom leetpattern.utils import ListNode, list_from_array, list_to_array\n\n\n# Linked List\ndef removeNthFromEnd(head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:\n    dummy = ListNode(0, head)\n    fast, slow = dummy, dummy\n\n    for _ in range(n):\n        fast = fast.next\n\n    while fast.next:\n        fast = fast.next\n        slow = slow.next\n\n    slow.next = slow.next.next\n\n    return dummy.next\n\n\ndef test_removeNthFromEnd() -&gt; None:\n    head = list_from_array([1, 2, 3, 4, 5])\n    assert (list_to_array(removeNthFromEnd(head, 2))) == [1, 2, 3, 5]\n</code></pre>"},{"location":"top-100-liked/linked_list/#24-swap-nodes-in-pairs","title":"24. Swap Nodes in Pairs","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Recursion</p> </li> </ul> Python <pre><code>\"\"\"\n-   Given a linked list, swap every two adjacent nodes and return its head.\n\"\"\"\n\nfrom typing import Optional\n\nfrom leetpattern.utils import ListNode, list_from_array, list_to_array\n\n\ndef swap_pairs(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    dummy = ListNode(0, head)\n    n0 = dummy\n    n1 = dummy.next\n\n    while n1 and n1.next:\n        n2 = n1.next\n        n3 = n2.next\n\n        n0.next = n2\n        n2.next = n1\n        n1.next = n3\n\n        n0 = n1\n        n1 = n3\n\n    return dummy.next\n\n\ndef test_swap_pairs():\n    head = list_from_array([1, 2, 3, 4, 5])\n    assert list_to_array(swap_pairs(head)) == [2, 1, 4, 3, 5]\n</code></pre>"},{"location":"top-100-liked/linked_list/#25-reverse-nodes-in-k-group","title":"25. Reverse Nodes in k-Group","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Recursion</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom leetpattern.utils import ListNode, list_from_array, list_to_array\n\n\n# Linked List\ndef reverse_k_group(head: Optional[ListNode], k: int) -&gt; Optional[ListNode]:\n    n = 0\n    cur = head\n    while cur:\n        n += 1\n        cur = cur.next\n\n    p0 = dummy = ListNode(next=head)\n    pre = None\n    cur = head\n\n    while n &gt;= k:\n        n -= k\n        for _ in range(k):\n            nxt = cur.next\n            cur.next = pre\n            pre = cur\n            cur = nxt\n\n        nxt = p0.next\n        nxt.next = cur\n        p0.next = pre\n        p0 = nxt\n\n    return dummy.next\n\n\ndef test_reverse_k_group():\n    head = list_from_array([1, 2, 3, 4, 5])\n    assert list_to_array(reverse_k_group(head, 2)) == [2, 1, 4, 3, 5]\n</code></pre>"},{"location":"top-100-liked/linked_list/#138-copy-list-with-random-pointer","title":"138. Copy List with Random Pointer","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Linked List</p> </li> </ul> Python <pre><code>from typing import Optional\n\n\nclass Node:\n    def __init__(self, x: int, next: \"Node\" = None, random: \"Node\" = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\n\ndef copyRandomList(head: \"Optional[Node]\") -&gt; \"Optional[Node]\":\n    if not head:\n        return None\n\n    # Copy nodes and link them together\n    cur = head\n    while cur:\n        new_node = Node(cur.val)\n        new_node.next = cur.next\n        cur.next = new_node\n        cur = new_node.next\n\n    # Copy random pointers\n    cur = head\n    while cur:\n        cur.next.random = cur.random.next if cur.random else None\n        cur = cur.next.next\n\n    # Separate the original and copied lists\n    cur = head\n    new_head = head.next\n    while cur:\n        new_node = cur.next\n        cur.next = new_node.next\n        new_node.next = new_node.next.next if new_node.next else None\n        cur = cur.next\n\n    return new_head\n</code></pre>"},{"location":"top-100-liked/linked_list/#148-sort-list","title":"148. Sort List","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Two Pointers, Divide And Conquer, Sorting, Merge Sort</p> </li> </ul> Python <pre><code>from typing import Optional\n\nfrom leetpattern.utils import ListNode, list_from_array\n\n\n# Linked List\ndef sortListSort(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    nums = []\n\n    while head:\n        nums.append(head.val)\n        head = head.next\n\n    dummy = ListNode()\n    cur = dummy\n    nums.sort()\n\n    for num in nums:\n        cur.next = ListNode(val=num)\n        cur = cur.next\n\n    return dummy.next\n\n\n# Linked List\ndef sortListDivideConquer(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    def middle(node):\n        fast, slow = node, node\n        while fast and fast.next:\n            pre = slow\n            slow = slow.next\n            fast = fast.next.next\n        pre.next = None\n        return slow\n\n    def merge_two_lists(l1, l2):\n        dummy = ListNode()\n        cur = dummy\n        while l1 and l2:\n            if l1.val &lt; l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n            cur = cur.next\n\n        cur.next = l1 if l1 else l2\n        return dummy.next\n\n    if not head or not head.next:\n        return head\n\n    head2 = middle(head)\n    head = sortListDivideConquer(head)\n    head2 = sortListDivideConquer(head2)\n\n    return merge_two_lists(head, head2)\n\n\nhead = list_from_array([4, 2, 1, 3])\nprint(head)  # 4 -&gt; 2 -&gt; 1 -&gt; 3\nprint(sortListSort(head))  # 1 -&gt; 2 -&gt; 3 -&gt; 4\nprint(sortListDivideConquer(head))  # 1 -&gt; 2 -&gt; 3 -&gt; 4\n</code></pre>"},{"location":"top-100-liked/linked_list/#23-merge-k-sorted-lists","title":"23. Merge k Sorted Lists","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Linked List, Divide And Conquer, Heap Priority Queue, Merge Sort</p> </li> </ul> Python <pre><code>\"\"\"\n-   Prerequisite: 21. Merge Two Sorted Lists\n-   Video explanation: [23. Merge K Sorted Lists - NeetCode](https://youtu.be/q5a5OiGbT6Q?si=SQ2dCvsYQ3LQctPh)\n\"\"\"\n\nimport copy\nimport heapq\nfrom typing import List, Optional\n\nfrom leetpattern.utils import ListNode, list_from_array, list_to_array\n\n\ndef merge_k_lists_divide_conquer(\n    lists: List[Optional[ListNode]],\n) -&gt; Optional[ListNode]:\n    if not lists or len(lists) == 0:\n        return None\n\n    def mergeTwo(l1, l2):\n        dummy = ListNode()\n        cur = dummy\n\n        while l1 and l2:\n            if l1.val &lt; l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n\n            cur = cur.next\n\n        cur.next = l1 if l1 else l2\n\n        return dummy.next\n\n    while len(lists) &gt; 1:\n        merged = []\n\n        for i in range(0, len(lists), 2):\n            l1 = lists[i]\n            l2 = lists[i + 1] if i + 1 &lt; len(lists) else None\n            merged.append(mergeTwo(l1, l2))\n\n        lists = merged\n\n    return lists[0]\n\n\ndef merge_k_lists_heap(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    min_heap = []  # (val, idx, node)\n\n    for idx, head in enumerate(lists):\n        if head:\n            heapq.heappush(min_heap, (head.val, idx, head))\n\n    while min_heap:\n        _, idx, node = heapq.heappop(min_heap)\n        cur.next = node\n        cur = cur.next\n\n        node = node.next\n        if node:\n            heapq.heappush(min_heap, (node.val, idx, node))\n\n    return dummy.next\n\n\ndef test_merge_k_lists() -&gt; None:\n    n1 = list_from_array([1, 4])\n    n2 = list_from_array([1, 3])\n    n3 = list_from_array([2, 6])\n    lists = [n1, n2, n3]\n    lists1 = copy.deepcopy(lists)\n    lists2 = copy.deepcopy(lists)\n    assert (list_to_array(merge_k_lists_divide_conquer(lists1))) == [\n        1,\n        1,\n        2,\n        3,\n        4,\n        6,\n    ]\n    assert (list_to_array(merge_k_lists_heap(lists2))) == [1, 1, 2, 3, 4, 6]\n</code></pre>"},{"location":"top-100-liked/linked_list/#146-lru-cache","title":"146. LRU Cache","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, Linked List, Design, Doubly Linked List</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Design and implement a data structure for **Least Recently Used (LRU) cache**. It should support the following operations: get and put.\n- [lru](https://media.geeksforgeeks.org/wp-content/uploads/20240909142802/Working-of-LRU-Cache-copy-2.webp)\n- ![146](https://miro.medium.com/v2/resize:fit:650/0*fOwBd3z0XtHh7WN1.png)\n\n| Data structure     | Description                   |\n| ------------------ | ----------------------------- |\n| Doubly Linked List | To store the key-value pairs. |\n| Hash Map           | To store the key-node pairs.  |\n\"\"\"\n\nfrom collections import OrderedDict\n\n\n# Doubly Linked List\nclass Node:\n    def __init__(self, key=0, val=0):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.cache = {}\n        self.head = Node()\n        self.tail = Node()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def add_to_last(self, node):\n        self.tail.prev.next = node\n        node.prev = self.tail.prev\n        node.next = self.tail\n        self.tail.prev = node\n\n    def move_to_last(self, node):\n        self.remove(node)\n        self.add_to_last(node)\n\n    def get(self, key: int) -&gt; int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self.move_to_last(node)\n        return node.val\n\n    def put(self, key: int, value: int) -&gt; None:\n        if key in self.cache:\n            node = self.cache[key]\n            node.val = value\n            self.move_to_last(node)\n            return None\n\n        if len(self.cache) == self.cap:\n            del self.cache[self.head.next.key]\n            self.remove(self.head.next)\n\n        node = Node(key=key, val=value)\n        self.cache[key] = node\n        self.add_to_last(node)\n\n\n# OrderedDict\nclass LRUCacheOrderedDict:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.cap = capacity\n\n    def get(self, key: int):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key, last=True)\n        return self.cache[key]\n\n    def put(self, key: int, value: int):\n        if key in self.cache:\n            self.cache.move_to_end(key, last=True)\n        elif len(self.cache) &gt;= self.cap:\n            self.cache.popitem(last=False)\n\n        self.cache[key] = value\n\n\ncache = LRUCache(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\n\ncache = LRUCacheOrderedDict(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\nprint(\"LRU Cache passed\")\nprint(\"LRU Cache Ordered Dict passed\")\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nclass Node {\n   public:\n    int key;\n    int val;\n    Node *prev;\n    Node *next;\n\n    Node(int k = 0, int v = 0) : key(k), val(v), prev(nullptr), next(nullptr) {}\n};\n\nclass LRUCache {\n   private:\n    int cap;\n    unordered_map&lt;int, Node *&gt; cache;\n    Node *head;\n    Node *tail;\n\n    void remove(Node *node) {\n        node-&gt;prev-&gt;next = node-&gt;next;\n        node-&gt;next-&gt;prev = node-&gt;prev;\n    }\n\n    void insert_to_last(Node *node) {\n        tail-&gt;prev-&gt;next = node;\n        node-&gt;prev = tail-&gt;prev;\n        tail-&gt;prev = node;\n        node-&gt;next = tail;\n    }\n\n    void move_to_last(Node *node) {\n        remove(node);\n        insert_to_last(node);\n    }\n\n   public:\n    LRUCache(int capacity) {\n        this-&gt;cap = capacity;\n        head = new Node();\n        tail = new Node();\n        head-&gt;next = tail;\n        tail-&gt;prev = head;\n    }\n\n    int get(int key) {\n        if (cache.find(key) != cache.end()) {\n            Node *node = cache[key];\n            move_to_last(node);\n            return node-&gt;val;\n        }\n        return -1;\n    }\n\n    void put(int key, int value) {\n        if (cache.find(key) != cache.end()) {\n            Node *node = cache[key];\n            node-&gt;val = value;\n            move_to_last(node);\n        } else {\n            Node *newNode = new Node(key, value);\n            cache[key] = newNode;\n            insert_to_last(newNode);\n\n            if ((int)cache.size() &gt; cap) {\n                Node *removed = head-&gt;next;\n                remove(removed);\n                cache.erase(removed-&gt;key);\n                delete removed;\n            }\n        }\n    }\n};\n\nint main() {\n    LRUCache lru(2);\n    lru.put(1, 1);\n    lru.put(2, 2);\n    assert(lru.get(1) == 1);   // returns 1\n    lru.put(3, 3);             // evicts key 2\n    assert(lru.get(2) == -1);  // returns -1 (not found)\n    lru.put(4, 4);             // evicts key 1\n    assert(lru.get(1) == -1);  // returns -1 (not found)\n    assert(lru.get(3) == 3);   // returns 3\n    assert(lru.get(4) == 4);   // returns 4\n    return 0;\n}\n</code></pre>"},{"location":"top-100-liked/matrix/","title":"Matrix","text":""},{"location":"top-100-liked/matrix/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 73. Set Matrix Zeroes (Medium)</li> <li> 54. Spiral Matrix (Medium)</li> <li> 48. Rotate Image (Medium)</li> <li> 240. Search a 2D Matrix II (Medium)</li> </ul>"},{"location":"top-100-liked/matrix/#73-set-matrix-zeroes","title":"73. Set Matrix Zeroes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Matrix</p> </li> </ul> Python <pre><code>from copy import deepcopy\nfrom typing import List\n\n\nclass setZeroes:\n    @staticmethod\n    def matrix(matrix: List[List[int]]) -&gt; None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        # prep\n        m, n = len(matrix), len(matrix[0])\n        rows, cols = set(), set()\n\n        # collect rows and cols\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    rows.add(i)\n                    cols.add(j)\n\n        # work on rows and cols\n        for i in rows:\n            for j in range(n):\n                matrix[i][j] = 0\n\n        for i in range(m):\n            for j in cols:\n                matrix[i][j] = 0\n\n\nif __name__ == \"__main__\":\n    matrix = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]\n    setZeroes.matrix(matrix)\n    assert matrix == [[1, 0, 1], [0, 0, 0], [1, 0, 1]]\n</code></pre>"},{"location":"top-100-liked/matrix/#54-spiral-matrix","title":"54. Spiral Matrix","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Matrix, Simulation</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return all elements of the matrix in spiral order.\n\"\"\"\n\nfrom typing import List\n\n\n# Array\ndef spiralOrder(matrix: List[List[int]]) -&gt; List[int]:\n    if not matrix or not matrix[0]:\n        return []\n\n    res = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n\n    while top &lt;= bottom and left &lt;= right:\n\n        for i in range(left, right + 1):\n            res.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            res.append(matrix[i][right])\n        right -= 1\n\n        if top &lt;= bottom:\n\n            for i in range(right, left - 1, -1):\n                res.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left &lt;= right:\n\n            for i in range(bottom, top - 1, -1):\n                res.append(matrix[i][left])\n            left += 1\n\n    return res\n\n\n# Math\ndef spiralOrderMath(matrix: List[List[int]]) -&gt; List[int]:\n    dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]]  # Right Down Left Up\n    m, n = len(matrix), len(matrix[0])\n    size = m * n\n    res = []\n    i, j, di = 0, -1, 0\n\n    while len(res) &lt; size:\n        dx, dy = dirs[di]\n        for _ in range(n):\n            i += dx\n            j += dy\n            res.append(matrix[i][j])\n        di = (di + 1) % 4\n        n, m = m - 1, n\n\n    return res\n\n\nprint(spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n# [1, 2, 3, 6, 9, 8, 7, 4, 5]\nprint(spiralOrderMath([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]))\n# [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]\n</code></pre>"},{"location":"top-100-liked/matrix/#48-rotate-image","title":"48. Rotate Image","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Math, Matrix</p> </li> </ul> Python <pre><code>from copy import deepcopy\nfrom typing import List\n\n\n# Math\ndef rotate1(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    n = len(matrix)\n\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n\n\ndef rotate2(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    n = len(matrix)\n    for i in range(n):\n        for j in range(i, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\n    for i in range(n):\n        matrix[i].reverse()\n\n\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nprint(matrix)\n# [[1, 2, 3],\n#  [4, 5, 6],\n#  [7, 8, 9]]\nmatrix1 = deepcopy(matrix)\nrotate1(matrix1)\nprint(matrix1)\n# [[7, 4, 1],\n#  [8, 5, 2],\n#  [9, 6, 3]]\nmatrix2 = deepcopy(matrix)\nrotate2(matrix2)\nprint(matrix2)\n# [[7, 4, 1],\n#  [8, 5, 2],\n#  [9, 6, 3]]\n</code></pre>"},{"location":"top-100-liked/matrix/#240-search-a-2d-matrix-ii","title":"240. Search a 2D Matrix II","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Binary Search, Divide And Conquer, Matrix</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Matrix\ndef searchMatrix(matrix: List[List[int]], target: int) -&gt; bool:\n    m, n = len(matrix), len(matrix[0])\n    i, j = 0, n - 1\n\n    while i &lt; m and j &gt;= 0:\n        if matrix[i][j] == target:\n            return True\n        elif matrix[i][j] &lt; target:\n            i += 1\n        else:\n            j -= 1\n\n    return False\n\n\nmatrix = [\n    [1, 4, 7, 11, 15],\n    [2, 5, 8, 12, 19],\n    [3, 6, 9, 16, 22],\n    [10, 13, 14, 17, 24],\n    [18, 21, 23, 26, 30],\n]\ntarget = 20\nprint(searchMatrix(matrix, target))  # False\n</code></pre>"},{"location":"top-100-liked/multi-dimensional_dynamic_programming/","title":"Multi-dimensional Dynamic Programming","text":""},{"location":"top-100-liked/multi-dimensional_dynamic_programming/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 62. Unique Paths (Medium)</li> <li> 64. Minimum Path Sum (Medium)</li> <li> 5. Longest Palindromic Substring (Medium)</li> <li> 1143. Longest Common Subsequence (Medium)</li> <li> 72. Edit Distance (Medium)</li> </ul>"},{"location":"top-100-liked/multi-dimensional_dynamic_programming/#62-unique-paths","title":"62. Unique Paths","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Math, Dynamic Programming, Combinatorics</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Count the number of unique paths to reach the bottom-right corner of a `m x n` grid.\n\n![62](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)\n\"\"\"\n\n\n# DP - 2D\ndef uniquePaths(m: int, n: int) -&gt; int:\n    if m == 1 or n == 1:\n        return 1\n\n    dp = [[1] * n for _ in range(m)]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]\n\n\nprint(uniquePaths(m=3, n=7))  # 28\n# [[1, 1, 1,  1,  1,  1,  1],\n#  [1, 2, 3,  4,  5,  6,  7],\n#  [1, 3, 6, 10, 15, 21, 28]]\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint uniquePaths(int m, int n) {\n    vector dp(m, vector&lt;int&gt;(n, 1));\n\n    for (int i = 1; i &lt; m; i++) {\n        for (int j = 1; j &lt; n; j++) {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n\n    return dp[m - 1][n - 1];\n}\n\nint main() {\n    int m = 3, n = 7;\n    cout &lt;&lt; uniquePaths(m, n) &lt;&lt; endl;  // 28\n    return 0;\n}\n</code></pre>"},{"location":"top-100-liked/multi-dimensional_dynamic_programming/#64-minimum-path-sum","title":"64. Minimum Path Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Dynamic Programming, Matrix</p> </li> </ul> Python <pre><code>from functools import cache\nfrom typing import List\n\n\n# Iterative\ndef minPathSum(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n\n    # init\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = grid[i][0] + dp[i - 1][0]\n    for j in range(1, n):\n        dp[0][j] = grid[0][j] + dp[0][j - 1]\n\n    # update\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[-1][-1]\n\n\n# Recursive\ndef minPathSumDFS(grid: List[List[int]]) -&gt; int:\n    INF = 10**18\n\n    @cache\n    def dfs(i, j):\n        if i &lt; 0 or j &lt; 0:\n            return INF\n        if i == 0 and j == 0:\n            return grid[i][j]\n        return min(dfs(i, j - 1), dfs(i - 1, j)) + grid[i][j]\n\n    return dfs(len(grid) - 1, len(grid[0]) - 1)\n\n\ngrid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\nprint(minPathSum(grid))  # 7\nprint(minPathSumDFS(grid))  # 7\n</code></pre>"},{"location":"top-100-liked/multi-dimensional_dynamic_programming/#5-longest-palindromic-substring","title":"5. Longest Palindromic Substring","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Two Pointers, String, Dynamic Programming</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the longest palindromic substring in `s`.\n\"\"\"\n\n\n# DP - Interval\ndef longestPalindromeDP(s: str) -&gt; str:\n    n = len(s)\n    if n &lt;= 1:\n        return s\n\n    start, maxLen = 0, 1\n\n    # Init\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for j in range(1, n):\n        for i in range(j):\n            if s[i] == s[j]:\n                if j - i &lt;= 2:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1]\n\n                if dp[i][j] and j - i + 1 &gt; maxLen:\n                    maxLen = j - i + 1\n                    start = i\n\n    return s[start : start + maxLen]\n\n\n# Expand Around Center\ndef longestPalindromeCenter(s: str) -&gt; str:\n    def expand_around_center(left, right):\n        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n\n    if len(s) &lt;= 1:\n        return s\n\n    start, end = 0, 0\n    for i in range(len(s)):\n        len1 = expand_around_center(i, i)  # odd\n        len2 = expand_around_center(i, i + 1)  # even\n\n        maxLen = max(len1, len2)\n        if maxLen &gt; end - start:\n            start = i - (maxLen - 1) // 2\n            end = i + maxLen // 2\n\n    return s[start : end + 1]\n\n\ns = \"babad\"\nprint(longestPalindromeDP(s))  # \"bab\"\nprint(longestPalindromeCenter(s))  # \"aba\"\n</code></pre>"},{"location":"top-100-liked/multi-dimensional_dynamic_programming/#1143-longest-common-subsequence","title":"1143. Longest Common Subsequence","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul> Python <pre><code>from functools import cache\n\n\nclass LongestCommonSubsequence:\n    def memoization(self, text1: str, text2: str) -&gt; int:\n        m, n = len(text1), len(text2)\n\n        @cache\n        def dfs(i: int, j: int) -&gt; int:\n            if i &lt; 0 or j &lt; 0:\n                return 0\n            if text1[i] == text2[j]:\n                return dfs(i - 1, j - 1) + 1\n            return max(dfs(i - 1, j), dfs(i, j - 1))\n\n        return dfs(m - 1, n - 1)\n\n    def iterative(self, text1: str, text2: str) -&gt; int:\n        m, n = len(text1), len(text2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for i, x in enumerate(text1):\n            for j, y in enumerate(text2):\n                if x == y:\n                    dp[i + 1][j + 1] = dp[i][j] + 1\n                else:\n                    dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1])\n\n        return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    lcs = LongestCommonSubsequence()\n    assert lcs.memoization(\"abcde\", \"ace\") == 3\n    assert lcs.iterative(\"abcde\", \"ace\") == 3\n    assert lcs.memoization(\"abc\", \"abc\") == 3\n    assert lcs.iterative(\"abc\", \"abc\") == 3\n</code></pre>"},{"location":"top-100-liked/multi-dimensional_dynamic_programming/#72-edit-distance","title":"72. Edit Distance","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Dynamic Programming</p> </li> </ul> Python <pre><code>from functools import cache\n\n\n# Recursive\ndef minDistanceDFS(word1: str, word2: str) -&gt; int:\n    n, m = len(word1), len(word2)\n\n    @cache\n    def dfs(i: int, j: int) -&gt; int:\n        if i &lt; 0:\n            return j + 1\n        if j &lt; 0:\n            return i + 1\n        if word1[i] == word2[j]:\n            return dfs(i - 1, j - 1)\n\n        return 1 + min(dfs(i - 1, j), dfs(i, j - 1), dfs(i - 1, j - 1))\n\n    return dfs(n - 1, m - 1)\n\n\n# Iterative\ndef minDistanceDP(word1: str, word2: str) -&gt; int:\n    m, n = len(word1), len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]  # no operation\n            else:\n                dp[i][j] = 1 + min(\n                    dp[i - 1][j],  # delete\n                    dp[i][j - 1],  # insert\n                    dp[i - 1][j - 1],  # replace\n                )\n    return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    word1 = \"horse\"\n    word2 = \"ros\"\n    print(minDistanceDFS(word1, word2))  # 3\n    print(minDistanceDP(word1, word2))  # 3\n</code></pre>"},{"location":"top-100-liked/sliding_window/","title":"Sliding Window","text":""},{"location":"top-100-liked/sliding_window/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3. Longest Substring Without Repeating Characters (Medium)</li> <li> 438. Find All Anagrams in a String (Medium)</li> </ul>"},{"location":"top-100-liked/sliding_window/#3-longest-substring-without-repeating-characters","title":"3. Longest Substring Without Repeating Characters","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Classic variable sliding window problem. Use a set to keep track of the characters in the current window.\n- Return the length of the longest substring without repeating characters.\n- [Template tutorial by \u7075\u5c71\u8336\u827e\u5e9c](https://leetcode.cn/problems/longest-substring-without-repeating-characters/solutions/1959540/xia-biao-zong-suan-cuo-qing-kan-zhe-by-e-iaks)\n\"\"\"\n\nfrom collections import defaultdict\n\n\n# Sliding Window Variable Max - HashMap\ndef lengthOfLongestSubstringHash(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    left = 0\n    cnt = defaultdict(int)\n    res = 0\n\n    for right in range(n):\n        cnt[s[right]] += 1\n\n        while cnt[s[right]] &gt; 1:\n            cnt[s[left]] -= 1\n            left += 1\n\n        res = max(res, right - left + 1)\n\n    return res\n\n\n# Sliding Window Variable Max - Set\ndef lengthOfLongestSubstringSet(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    left = 0\n    res = 0\n    window = set()\n\n    for right in range(n):\n        while left &lt; right and s[right] in window:\n            window.remove(s[left])\n            left += 1\n        window.add(s[right])\n        res = max(res, right - left + 1)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    s = \"abcabcbb\"\n    assert lengthOfLongestSubstringHash(s) == 3\n    assert lengthOfLongestSubstringSet(s) == 3\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;unordered_set&gt;\nusing namespace std;\n\nint lengthOfLongestSubstring(string s) {\n    int n = s.length();\n    int res = 0;\n    int left = 0;\n    unordered_set&lt;char&gt; window;\n\n    for (int right = 0; right &lt; n; right++) {\n        char ch = s[right];\n\n        while (window.find(ch) != window.end()) {\n            window.erase(s[left]);\n            left++;\n        }\n\n        window.insert(ch);\n        res = max(res, right - left + 1);\n    }\n    return (int)res;\n}\n\nint main() {\n    string s = \"abcabcbb\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 3\n    s = \"bbbbb\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 1\n    s = \"pwwkew\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 3\n    return 0;\n}\n</code></pre>"},{"location":"top-100-liked/sliding_window/#438-find-all-anagrams-in-a-string","title":"438. Find All Anagrams in a String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> Python <pre><code>from typing import List\n\n\n# Sliding Window Fixed Size\ndef findAnagrams(s: str, p: str) -&gt; List[int]:\n    n, k = len(s), len(p)\n    target = [0 for _ in range(26)]\n    for ch in p:\n        target[ord(ch) - ord(\"a\")] += 1\n\n    count = [0 for _ in range(26)]\n    left = 0\n    res = []\n\n    for right in range(n):\n        count[ord(s[right]) - ord(\"a\")] += 1\n        if right &lt; k - 1:\n            continue\n\n        if count == target:\n            res.append(left)\n\n        count[ord(s[left]) - ord(\"a\")] -= 1\n        left += 1\n\n    return res\n\n\ns = \"cbaebabacd\"\np = \"abc\"\nprint(findAnagrams(s, p))  # [0, 6]\n</code></pre>"},{"location":"top-100-liked/stack/","title":"Stack","text":""},{"location":"top-100-liked/stack/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 20. Valid Parentheses (Easy)</li> <li> 155. Min Stack (Medium)</li> <li> 394. Decode String (Medium)</li> <li> 739. Daily Temperatures (Medium)</li> <li> 84. Largest Rectangle in Histogram (Hard)</li> </ul>"},{"location":"top-100-liked/stack/#20-valid-parentheses","title":"20. Valid Parentheses","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack</p> </li> </ul> PythonCPP <pre><code># Stack\ndef is_valid(s: str) -&gt; bool:\n    if len(s) % 2:\n        return False\n\n    pairs = {\n        \"(\": \")\",\n        \"{\": \"}\",\n        \"[\": \"]\",\n    }\n    stack = []\n    for ch in s:\n        if ch in pairs:\n            stack.append(ch)\n        elif not stack or ch != pairs[stack.pop()]:\n            return False\n\n    return True if not stack else False\n\n\ndef test_is_valid():\n    assert is_valid(\"()[]{}\")\n    assert not is_valid(\"(]\")\n    assert not is_valid(\"([)]\")\n    assert is_valid(\"{[]}\")\n</code></pre> <pre><code>#include &lt;cassert&gt;\n#include &lt;stack&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool isValid(string s) {\n        unordered_map&lt;char, char&gt; map{{')', '('}, {'}', '{'}, {']', '['}};\n        stack&lt;char&gt; stack;\n        if (s.length() % 2 == 1) return false;\n\n        for (char&amp; ch : s) {\n            if (stack.empty() || map.find(ch) == map.end()) {\n                stack.push(ch);\n            } else {\n                if (map[ch] != stack.top()) {\n                    return false;\n                }\n                stack.pop();\n            }\n        }\n        return stack.empty();\n    }\n};\n\nint main() {\n    Solution s;\n    assert(s.isValid(\"()\") == true);\n    assert(s.isValid(\"()[]{}\") == true);\n    assert(s.isValid(\"(]\") == false);\n    assert(s.isValid(\"([)]\") == false);\n    assert(s.isValid(\"{[]}\") == true);\n    return 0;\n}\n</code></pre>"},{"location":"top-100-liked/stack/#155-min-stack","title":"155. Min Stack","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Stack, Design</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Implement a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\"\"\"\n\n\n# Stack\nclass MinStack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, val: int) -&gt; None:\n        if self.stack:\n            self.stack.append((val, min(val, self.getMin())))\n        else:\n            self.stack.append((val, val))\n\n    def pop(self) -&gt; None:\n        self.stack.pop()\n\n    def top(self) -&gt; int:\n        return self.stack[-1][0]\n\n    def getMin(self) -&gt; int:\n        return self.stack[-1][1]\n\n\nobj = MinStack()\nobj.push(3)\nobj.push(2)\nobj.pop()\nprint(obj.top())  # 3\nprint(obj.getMin())  # 3\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;climits&gt;\n#include &lt;iostream&gt;\n#include &lt;stack&gt;\n#include &lt;utility&gt;\nusing namespace std;\n\nclass MinStack {\n    stack&lt;pair&lt;int, int&gt;&gt; st;\n\n   public:\n    MinStack() { st.emplace(0, INT_MAX); }\n\n    void push(int val) { st.emplace(val, min(getMin(), val)); }\n\n    void pop() { st.pop(); }\n\n    int top() { return st.top().first; }\n\n    int getMin() { return st.top().second; }\n};\n\nint main() {\n    MinStack minStack;\n    minStack.push(-2);\n    minStack.push(0);\n    minStack.push(-3);\n    cout &lt;&lt; minStack.getMin() &lt;&lt; endl;  // -3\n    minStack.pop();\n    cout &lt;&lt; minStack.top() &lt;&lt; endl;     // 0\n    cout &lt;&lt; minStack.getMin() &lt;&lt; endl;  // -2\n    return 0;\n}\n</code></pre>"},{"location":"top-100-liked/stack/#394-decode-string","title":"394. Decode String","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: String, Stack, Recursion</p> </li> </ul> Python <pre><code># Stack\ndef decodeString(s: str) -&gt; str:\n    stack = []  # (str, int)\n    num = 0\n    res = \"\"\n\n    for c in s:\n        if c.isdigit():\n            num = num * 10 + int(c)\n        elif c == \"[\":\n            stack.append((res, num))\n            res, num = \"\", 0\n        elif c == \"]\":\n            top = stack.pop()\n            res = top[0] + res * top[1]\n        else:\n            res += c\n\n    return res\n\n\ns = \"3[a2[c]]\"\nprint(decodeString(s))  # accaccacc\n</code></pre>"},{"location":"top-100-liked/stack/#739-daily-temperatures","title":"739. Daily Temperatures","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Stack, Monotonic Stack</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return an array `res` such that `res[i]` is the number of days you have to wait after the `ith` day to get a warmer temperature.\n\n| Index | Temp | &gt; stack last | stack                           | result    |\n| ----- | ---- | ------------ | ------------------------------- | --------- |\n| 0     | 73   | False        | `[ [73, 0] ]`                   | 1 - 0 = 1 |\n| 1     | 74   | True         | `[ [74, 1] ]`                   | 2 - 1 = 1 |\n| 2     | 75   | True         | `[ [75, 2] ]`                   | 6 - 2 = 4 |\n| 3     | 71   | False        | `[ [75, 2], [71, 3] ]`          | 5 - 3 = 2 |\n| 4     | 69   | False        | `[ [75, 2], [71, 3], [69, 4] ]` | 5 - 4 = 1 |\n| 5     | 72   | True         | `[ [75, 2], [72, 5] ]`          | 6 - 5 = 1 |\n| 6     | 76   | True         | `[ [76, 6] ]`                   | 0         |\n| 7     | 73   | False        | `[[76, 6], [73, 7]]`            | 0         |\n\"\"\"\n\nfrom typing import List\n\n\n# Monotonic Stack\ndef dailyTemperatures(temperatures: List[int]) -&gt; List[int]:\n    res = [0 for _ in range(len(temperatures))]\n    stack = []  # [temp, index]\n\n    for i, temp in enumerate(temperatures):\n        while stack and temp &gt; stack[-1][0]:\n            _, idx = stack.pop()\n            res[idx] = i - idx\n\n        stack.append([temp, i])\n\n    return res\n\n\nprint(dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73]))\n# [1, 1, 4, 2, 1, 1, 0, 0]\n</code></pre>"},{"location":"top-100-liked/stack/#84-largest-rectangle-in-histogram","title":"84. Largest Rectangle in Histogram","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Stack, Monotonic Stack</p> </li> </ul> Python <pre><code>from typing import List\n\n\nclass LargestRectangleArea:\n    def monotonic_stack(self, heights: List[int]) -&gt; int:\n        stack = []\n        res = 0\n        n = len(heights)\n\n        for i in range(n + 1):\n            h = heights[i] if i &lt; n else 0\n\n            while stack and h &lt; heights[stack[-1]]:\n                height = heights[stack.pop()]\n                width = i if not stack else i - stack[-1] - 1\n                res = max(res, height * width)\n\n            stack.append(i)\n\n        return res\n\n\nif __name__ == \"__main__\":\n    sol = LargestRectangleArea()\n    assert sol.monotonic_stack([2, 1, 5, 6, 2, 3]) == 10\n    assert sol.monotonic_stack([2, 4]) == 4\n</code></pre>"},{"location":"top-100-liked/subarray/","title":"Subarray","text":""},{"location":"top-100-liked/subarray/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 560. Subarray Sum Equals K (Medium)</li> <li> 239. Sliding Window Maximum (Hard)</li> <li> 76. Minimum Window Substring (Hard)</li> </ul>"},{"location":"top-100-liked/subarray/#560-subarray-sum-equals-k","title":"560. Subarray Sum Equals K","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Prefix Sum</p> </li> </ul> PythonCPP <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Prefix Sum\ndef subarraySum(nums: List[int], k: int) -&gt; int:\n    preSums = defaultdict(int)\n    preSums[0] = 1\n    curSum = 0\n    res = 0\n\n    for num in nums:\n        curSum += num\n        res += preSums[curSum - k]\n        preSums[curSum] += 1\n\n    return res\n\n\nnums = [1, 1, 1]\nk = 2\nprint(subarraySum(nums, k))  # 2\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint subarraySum(vector&lt;int&gt;&amp; nums, int k) {\n    int n = nums.size();\n    vector&lt;int&gt; prefixSum(n + 1);\n    for (int i = 0; i &lt; n; i++) {\n        prefixSum[i + 1] = prefixSum[i] + nums[i];\n    }\n\n    int res = 0;\n    unordered_map&lt;int, int&gt; cnt;\n\n    for (int ps : prefixSum) {\n        if (cnt.find(ps - k) != cnt.end()) res += cnt[ps - k];\n        cnt[ps]++;\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {1, 1, 1};\n    int k = 2;\n    cout &lt;&lt; subarraySum(nums, k) &lt;&lt; endl;  // 2\n    return 0;\n}\n</code></pre>"},{"location":"top-100-liked/subarray/#239-sliding-window-maximum","title":"239. Sliding Window Maximum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Queue, Sliding Window, Heap Priority Queue, Monotonic Queue</p> </li> </ul> Python <pre><code>from collections import deque\nfrom typing import List\n\n\n# Monotonic Queue\ndef maxSlidingWindow(nums: List[int], k: int) -&gt; List[int]:\n    q = deque()\n    res = []\n\n    for i, num in enumerate(nums):\n        if q and q[0] &lt; i - k + 1:\n            q.popleft()\n\n        while q and nums[q[-1]] &lt; num:\n            q.pop()\n\n        q.append(i)\n\n        if i &gt;= k - 1:\n            res.append(nums[q[0]])\n\n    return res\n\n\nnums = [1, 3, -1, -3, 5, 3, 6, 7]\nk = 3\nprint(maxSlidingWindow(nums, k))  # [3, 3, 5, 5, 6, 7]\n</code></pre>"},{"location":"top-100-liked/subarray/#76-minimum-window-substring","title":"76. Minimum Window Substring","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Hash Table, String, Sliding Window</p> </li> </ul> Python <pre><code>from collections import Counter\n\n\ndef minWindow(s: str, t: str) -&gt; str:\n    if not t or not s:\n        return \"\"\n\n    counts = Counter(t)\n    required = len(counts)\n\n    left, right = 0, 0\n    formed = 0\n    window_counts = dict()\n\n    result = float(\"inf\"), None, None\n\n    while right &lt; len(s):\n        char = s[right]\n        window_counts[char] = window_counts.get(char, 0) + 1\n        if char in counts and window_counts[char] == counts[char]:\n            formed += 1\n\n        while left &lt;= right and formed == required:\n            char = s[left]\n            if right - left + 1 &lt; result[0]:\n                result = (right - left + 1, left, right)\n            window_counts[char] -= 1\n            if char in counts and window_counts[char] &lt; counts[char]:\n                formed -= 1\n            left += 1\n\n        right += 1\n\n    return \"\" if result[0] == float(\"inf\") else s[result[1] : result[2] + 1]\n\n\ns = \"ADOBECODEBANC\"\nt = \"ABC\"\nprint(minWindow(s, t))  # BANC\n</code></pre>"},{"location":"top-100-liked/techniques/","title":"Techniques","text":""},{"location":"top-100-liked/techniques/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 136. Single Number (Easy)</li> <li> 169. Majority Element (Easy)</li> <li> 75. Sort Colors (Medium)</li> <li> 31. Next Permutation (Medium)</li> <li> 287. Find the Duplicate Number (Medium)</li> </ul>"},{"location":"top-100-liked/techniques/#136-single-number","title":"136. Single Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Bit Manipulation</p> </li> </ul> Python <pre><code>from functools import reduce\nfrom operator import xor\nfrom typing import List\n\n\n# XOR\ndef singleNumber(nums: List[int]) -&gt; int:\n    res = 0\n    for num in nums:\n        res ^= num\n    return res\n\n\n# XOR\ndef singleNumberXOR(nums: List[int]) -&gt; int:\n    return reduce(xor, nums)\n\n\n# XOR\ndef singleNumberXORLambda(nums: List[int]) -&gt; int:\n    return reduce(lambda x, y: x ^ y, nums)\n\n\nnums = [4, 1, 2, 1, 2]\nprint(singleNumber(nums))  # 4\nprint(singleNumberXOR(nums))  # 4\nprint(singleNumberXORLambda(nums))  # 4\n</code></pre>"},{"location":"top-100-liked/techniques/#169-majority-element","title":"169. Majority Element","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Hash Table, Divide And Conquer, Sorting, Counting</p> </li> </ul> Python <pre><code>\"\"\"\n-   Return the majority element in an array. The majority element is the element that appears more than `n // 2` times.\n\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/7pnhv842keE?si=fBYlNfKzdkiLgkF1\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen&gt;&lt;/iframe&gt;\n\n| `num` | `count` | `res` |\n| ----- | ------- | ----- |\n| 2     | 1       | 2     |\n| 2     | 2       | 2     |\n| 1     | 1       | 2     |\n| 1     | 0       | 2     |\n| 1     | 1       | 1     |\n| 2     | 0       | 1     |\n| 2     | 1       | 2     |\n\"\"\"\n\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Hash Map\ndef majorityElementHashMap(nums: List[int]) -&gt; int:\n    n = len(nums)\n    freq = defaultdict(int)\n\n    for num in nums:\n        freq[num] += 1\n        if freq[num] &gt; n // 2:\n            return num\n\n\n# Array - Boyer-Moore Voting Algorithm\ndef majorityElementArray(nums: List[int]) -&gt; int:\n    res = None\n    count = 0\n\n    for num in nums:\n        if count == 0:\n            res = num\n        count += 1 if num == res else -1\n\n    return res\n\n\n# | Algorithm | Time Complexity | Space Complexity |\n# |-----------|-----------------|------------------|\n# | HashMap   | O(N)            | O(N)             |\n# | Array     | O(N)            | O(1)             |\n# |-----------|-----------------|------------------|\n\n\nnums = [2, 2, 1, 1, 1, 2, 2]\nprint(majorityElementArray(nums))  # 2\nprint(majorityElementHashMap(nums))  # 2\n</code></pre>"},{"location":"top-100-liked/techniques/#75-sort-colors","title":"75. Sort Colors","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Sorting</p> </li> </ul> Python <pre><code>from copy import deepcopy\nfrom typing import List\n\n\n# Left Right Pointers\ndef sort_colors_lr_pointers(nums: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    n = len(nums)\n    left = 0\n    for right in range(n):\n        if nums[right] == 0:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n\n    for right in range(left, n):\n        if nums[right] == 1:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n\n\n# Three Pointers\ndef sort_colors_three_pointers(nums: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    cur = 0\n\n    while cur &lt;= right:\n        if nums[cur] == 0:\n            nums[left], nums[cur] = nums[cur], nums[left]\n            left += 1\n            cur += 1\n        elif nums[cur] == 2:\n            nums[right], nums[cur] = nums[cur], nums[right]\n            right -= 1\n        else:\n            cur += 1\n\n\nnums = [2, 0, 2, 1, 1, 0]\nnums1, nums2 = deepcopy(nums), deepcopy(nums)\nsort_colors_lr_pointers(nums1)\nprint(nums1)  # [0, 0, 1, 1, 2, 2]\nsort_colors_three_pointers(nums2)\nprint(nums2)  # [0, 0, 1, 1, 2, 2]\n</code></pre>"},{"location":"top-100-liked/techniques/#31-next-permutation","title":"31. Next Permutation","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers</p> </li> </ul> Python <pre><code>from typing import List\n\n\ndef nextPermutation(nums: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    n = len(nums)\n    i = n - 1\n    while i &gt; 0 and nums[i - 1] &gt;= nums[i]:\n        i -= 1\n    if i != 0:\n        j = n - 1\n        while nums[j] &lt;= nums[i - 1]:\n            j -= 1\n        nums[i - 1], nums[j] = nums[j], nums[i - 1]\n\n    left, right = i, n - 1\n    while left &lt; right:\n        nums[left], nums[right] = nums[right], nums[left]\n        left += 1\n        right -= 1\n\n\nnums = [1, 2, 3]\nnextPermutation(nums)\nprint(nums)  # [1, 3, 2]\nnums = [1, 2, 3, 4, 6, 5]\nnextPermutation(nums)\nprint(nums)  # [1, 2, 3, 5, 4, 6]\n</code></pre>"},{"location":"top-100-liked/techniques/#287-find-the-duplicate-number","title":"287. Find the Duplicate Number","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Binary Search, Bit Manipulation</p> </li> </ul> Python <pre><code>\"\"\"\n-   Find the duplicate number in an array containing `n + 1` integers where each integer is between `1` and `n` inclusive.\n-   Floyd's Tortoise and Hare (Cycle Detection)\n    -   141. Linked List Cycle\n    -   142. Linked List Cycle II\n-   Time Complexity: O(n)\n-   Space Complexity: O(1)\n\nExample: `nums = [1, 3, 4, 2, 2]`\n\n|  0   |  1   |  2   |  3   |  4   |\n| :--: | :--: | :--: | :--: | :--: |\n|  1   |  3   |  4   |  2   |  2   |\n\n\n\"\"\"\n\nfrom typing import List\n\n\n# Floyd Cycle Detection Algorithm\ndef findDuplicate(nums: List[int]) -&gt; int:\n    fast, slow = nums[0], nums[0]\n\n    while True:\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n        if slow == fast:\n            break\n\n    slow = nums[0]\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[fast]\n\n    return slow\n\n\nnums = [1, 3, 4, 2, 2]\nprint(findDuplicate(nums))  # 2\n</code></pre>"},{"location":"top-100-liked/two_pointers/","title":"Two Pointers","text":""},{"location":"top-100-liked/two_pointers/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 283. Move Zeroes (Easy)</li> <li> 11. Container With Most Water (Medium)</li> <li> 15. 3Sum (Medium)</li> <li> 42. Trapping Rain Water (Hard)</li> </ul>"},{"location":"top-100-liked/two_pointers/#283-move-zeroes","title":"283. Move Zeroes","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n-   Move all zeroes to the end of the array while maintaining the relative order of the non-zero elements.\n\"\"\"\n\nfrom typing import List\n\n\ndef moveZeroes(nums: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    fast, slow = 0, 0\n\n    while fast &lt; len(nums):\n        if nums[fast] != 0:\n            nums[slow], nums[fast] = nums[fast], nums[slow]\n            slow += 1\n        fast += 1\n\n\nnums = [0, 1, 0, 3, 12]\nmoveZeroes(nums)\nprint(nums)  # [1, 3, 12, 0, 0]\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvoid moveZeroes(vector&lt;int&gt;&amp; nums) {\n    size_t n = nums.size();\n    size_t fast = 0, slow = 0;\n\n    while (fast &lt; n) {\n        if (nums[fast] != 0) {\n            swap(nums[slow], nums[fast]);\n            slow++;\n        }\n        fast++;\n    }\n}\n\nint main() {\n    vector&lt;int&gt; nums = {0, 1, 0, 3, 12};\n    moveZeroes(nums);\n    // [1, 3, 12, 0, 0]\n    for (size_t i = 0; i &lt; nums.size(); i++) {\n        cout &lt;&lt; nums[i] &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"top-100-liked/two_pointers/#11-container-with-most-water","title":"11. Container With Most Water","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Greedy</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- Return the maximum area of water that can be trapped between the vertical lines.\n\n![11](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)\n\"\"\"\n\nfrom typing import List\n\n\n# Brute Force\ndef maxAreaBF(height: List[int]) -&gt; int:\n    max_area = 0\n\n    for i in range(len(height)):\n        for j in range(i + 1, len(height)):\n            h = min(height[i], height[j])\n            w = j - i\n            max_area = max(max_area, h * w)\n\n    return max_area\n\n\n# Left Right Pointers\ndef maxAreaLR(height: List[int]) -&gt; int:\n    left, right = 0, len(height) - 1\n    res = 0\n\n    while left &lt; right:\n        h = min(height[left], height[right])\n        w = right - left\n        res = max(res, h * w)\n\n        if height[left] &lt; height[right]:\n            left += 1\n        else:\n            right -= 1\n\n    return res\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force| O(n^2) |  O(1)   |\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nheight = [1, 8, 6, 2, 5, 4, 8, 3, 7]\nprint(maxAreaBF(height))  # 49\nprint(maxAreaLR(height))  # 49\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint maxArea(vector&lt;int&gt;&amp; height) {\n    int left = 0, right = height.size() - 1;\n    int res = 0;\n\n    while (left &lt; right) {\n        int h = min(height[left], height[right]);\n        int w = right - left;\n        res = max(res, h * w);\n\n        if (height[left] &lt; height[right])\n            left++;\n        else\n            right--;\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; height = {1, 8, 6, 2, 5, 4, 8, 3, 7};\n    cout &lt;&lt; maxArea(height) &lt;&lt; endl;  // 49\n    return 0;\n}\n</code></pre>"},{"location":"top-100-liked/two_pointers/#15-3sum","title":"15. 3Sum","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Sorting</p> </li> </ul> PythonCPP <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef threeSum(nums: List[int]) -&gt; List[List[int]]:\n    nums.sort()\n    res = []\n    n = len(nums)\n\n    for i in range(n - 2):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        left, right = i + 1, n - 1\n\n        while left &lt; right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total &gt; 0:\n                right -= 1\n            elif total &lt; 0:\n                left += 1\n            else:\n                res.append([nums[i], nums[left], nums[right]])\n\n                while left &lt; right and nums[left] == nums[left + 1]:\n                    left += 1\n\n                while left &lt; right and nums[right] == nums[right - 1]:\n                    right -= 1\n\n                left += 1\n                right -= 1\n\n    return res\n\n\nnums = [-1, 0, 1, 2, -1, -4]\nassert threeSum(nums) == [[-1, -1, 2], [-1, 0, 1]]\n</code></pre> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {\n    sort(nums.begin(), nums.end());\n    vector&lt;vector&lt;int&gt;&gt; res;\n    int n = nums.size();\n\n    for (int i = 0; i &lt; n - 2; i++) {\n        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) {\n            continue;\n        }\n\n        int left = i + 1, right = n - 1;\n\n        while (left &lt; right) {\n            int total = nums[i] + nums[left] + nums[right];\n\n            if (total &gt; 0)\n                right--;\n            else if (total &lt; 0)\n                left++;\n            else {\n                res.push_back({nums[i], nums[left], nums[right]});\n                while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++;\n                while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--;\n                left++;\n                right--;\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {-1, 0, 1, 2, -1, -4};\n    vector&lt;vector&lt;int&gt;&gt; res = threeSum(nums);\n    for (auto&amp; v : res) {\n        for (int i : v) {\n            cout &lt;&lt; i &lt;&lt; \" \";\n        }\n        cout &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"top-100-liked/two_pointers/#42-trapping-rain-water","title":"42. Trapping Rain Water","text":"<ul> <li> <p>LeetCode | \u529b\u6263</p> </li> <li> <p>Tags: Array, Two Pointers, Dynamic Programming, Stack, Monotonic Stack</p> </li> </ul> PythonCPP <pre><code>\"\"\"\n- ![42](../../assets/0042.png)\n\n&lt;iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/ZI2z5pq0TqA?si=OEYg01dbmzvmtIwZ\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen&gt;&lt;/iframe&gt;\n\n| Approach   | Time | Space |\n| ---------- | ---- | ----- |\n| DP         | O(N) | O(N)  |\n| Left Right | O(N) | O(1)  |\n| Monotonic  | O(N) | O(N)  |\n\"\"\"\n\nfrom typing import List\n\n\n# DP\ndef trapDP(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    n = len(height)\n    maxLeft, maxRight = [0 for _ in range(n)], [0 for _ in range(n)]\n\n    for i in range(1, n):\n        maxLeft[i] = max(maxLeft[i - 1], height[i - 1])\n\n    for i in range(n - 2, -1, -1):\n        maxRight[i] = max(maxRight[i + 1], height[i + 1])\n\n    res = 0\n    for i in range(n):\n        res += max(0, min(maxLeft[i], maxRight[i]) - height[i])\n\n    return res\n\n\n# Left Right Pointers\ndef trapLR(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    left, right = 0, len(height) - 1\n    maxL, maxR = height[left], height[right]\n    res = 0\n\n    while left &lt; right:\n        if maxL &lt; maxR:\n            left += 1\n            maxL = max(maxL, height[left])\n            res += maxL - height[left]\n        else:\n            right -= 1\n            maxR = max(maxR, height[right])\n            res += maxR - height[right]\n\n    return res\n\n\n# Monotonic Stack\ndef trapStack(height: List[int]) -&gt; int:\n    stack = []\n    total = 0\n\n    for i in range(len(height)):\n        while stack and height[i] &gt; height[stack[-1]]:\n            top = stack.pop()\n            if not stack:\n                break\n            distance = i - stack[-1] - 1\n            bounded_height = min(height[i], height[stack[-1]]) - height[top]\n            total += distance * bounded_height\n        stack.append(i)\n\n    return total\n\n\nheight = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\nprint(trapDP(height))  # 6\nprint(trapLR(height))  # 6\nprint(trapStack(height))  # 6\n</code></pre> <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int trap(vector&lt;int&gt; &amp;height)\n    {\n        if (height.empty())\n            return 0;\n\n        int res = 0;\n        int left = 0, right = height.size() - 1;\n        int maxL = height[left], maxR = height[right];\n\n        while (left &lt; right)\n        {\n            if (maxL &lt; maxR)\n            {\n                left++;\n                maxL = max(maxL, height[left]);\n                res += maxL - height[left];\n            }\n            else\n            {\n                right--;\n                maxR = max(maxR, height[right]);\n                res += maxR - height[right];\n            }\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    vector&lt;int&gt; height = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};\n    Solution solution;\n    cout &lt;&lt; solution.trap(height) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"}]}