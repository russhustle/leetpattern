{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LeetPattern","text":""},{"location":"array/","title":"Array","text":"<ol> <li>0414 - Third Maximum Number (Easy)</li> <li>0054 - Spiral Matrix (Medium)</li> <li>0059 - Spiral Matrix II (Medium)</li> </ol>"},{"location":"array/#414-third-maximum-number","title":"414. Third Maximum Number","text":"<ul> <li>Return the third maximum number in an array. If the third maximum does not exist, return the maximum number.</li> </ul> <pre><code>from typing import List\n\n\n# 1. Sorting\ndef thirdMaxSort(nums: List[int]) -&gt; int:\n    nums = list(set(nums))\n    nums.sort(reverse=True)\n\n    return nums[2] if len(nums) &gt;= 3 else nums[0]\n\n\n# 2. Compare\ndef thirdMaxCompare(nums: List[int]) -&gt; int:\n    first, second, third = float(\"-inf\"), float(\"-inf\"), float(\"-inf\")\n\n    for num in nums:\n        if num &gt; first:\n            first, second, third = num, first, second\n        elif first &gt; num &gt; second:\n            second, third = num, second\n        elif second &gt; num &gt; third:\n            third = num\n\n    return third if third != float(\"-inf\") else first\n\n\nprint(thirdMaxSort([3, 2, 1]))  # 1\nprint(thirdMaxCompare([3, 2, 1]))  # 1\n</code></pre>"},{"location":"array/#54-spiral-matrix","title":"54. Spiral Matrix","text":"<ul> <li>Return all elements of the matrix in spiral order.</li> </ul> <pre><code>from typing import List\n\n\ndef spiralOrder(matrix: List[List[int]]) -&gt; List[int]:\n    if not matrix or not matrix[0]:\n        return []\n\n    result = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n\n    while top &lt;= bottom and left &lt;= right:\n\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n\n        if top &lt;= bottom:\n\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left &lt;= right:\n\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n\n    return result\n\n\nprint(spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n# [1, 2, 3, 6, 9, 8, 7, 4, 5]\n</code></pre>"},{"location":"array/#59-spiral-matrix-ii","title":"59. Spiral Matrix II","text":"<ul> <li>Return a square matrix filled with elements from 1 to n^2 in spiral order.</li> </ul> <pre><code>from pprint import pprint\nfrom typing import List\n\n\ndef generateMatrix(n: int) -&gt; List[List[int]]:\n    matrix = [[0] * n for _ in range(n)]\n    num = 1\n\n    for layer in range((n + 1) // 2):\n        for i in range(layer, n - layer):\n            matrix[layer][i] = num\n            num += 1\n        for j in range(layer + 1, n - layer):\n            matrix[j][n - 1 - layer] = num\n            num += 1\n        for i in range(n - 2 - layer, layer - 1, -1):\n            matrix[n - 1 - layer][i] = num\n            num += 1\n        for j in range(n - 2 - layer, layer, -1):\n            matrix[j][layer] = num\n            num += 1\n\n    return matrix\n\n\npprint(generateMatrix(5))\n# [[ 1,  2,  3,  4, 5],\n#  [16, 17, 18, 19, 6],\n#  [15, 24, 25, 20, 7],\n#  [14, 23, 22, 21, 8],\n#  [13, 12, 11, 10, 9]]\n</code></pre>"},{"location":"backtracking_board/","title":"Backtracking - Board","text":"<ol> <li>0051 - N-Queens (Hard)</li> <li>0037 - Sudoku Solver (Hard)</li> <li>0079 - Word Search (Medium)</li> <li>0212 - Word Search II (Hard)</li> </ol>"},{"location":"backtracking_board/#51-n-queens","title":"51. N-Queens","text":""},{"location":"backtracking_board/#37-sudoku-solver","title":"37. Sudoku Solver","text":""},{"location":"backtracking_board/#79-word-search","title":"79. Word Search","text":"<pre><code>from typing import List\n\n\ndef exist(board: List[List[str]], word: str) -&gt; bool:\n    m, n = len(board), len(board[0])\n    path = set()\n    directions = ((0, 1), (1, 0), (0, -1), (-1, 0))\n\n    def dfs(r, c, i):\n        if i == len(word):\n            return True\n\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or board[r][c] != word[i]\n            or (r, c) in path\n        ):\n            return False\n\n        path.add((r, c))\n\n        for dr, dc in directions:\n            if dfs(r + dr, c + dc, i + 1):\n                return True\n\n        path.remove((r, c))\n        return False\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, 0):\n                return True\n\n    return False\n\n\nboard = [\n    [\"A\", \"B\", \"C\", \"E\"],\n    [\"S\", \"F\", \"C\", \"S\"],\n    [\"A\", \"D\", \"E\", \"E\"],\n]\nword = \"ABCCED\"\nprint(exist(board, word))  # True\n</code></pre>"},{"location":"backtracking_board/#212-word-search-ii","title":"212. Word Search II","text":"<pre><code>from typing import List\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.isWord = False\n\n    def addWord(self, word):\n        node = self\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.isWord = True\n\n\nclass Solution:\n    def findWords(self, board: List[List[str]], words: List[str]) -&gt; List[str]:\n        root = TrieNode()\n        for w in words:\n            root.addWord(w)\n\n        m, n = len(board), len(board[0])\n        result, visit = set(), set()\n\n        def dfs(r, c, node, word):\n            if (\n                r not in range(m)\n                or c not in range(n)\n                or (r, c) in visit\n                or board[r][c] not in node.children\n            ):\n                return None\n\n            visit.add((r, c))\n\n            node = node.children[board[r][c]]\n            word += board[r][c]\n            if node.isWord:\n                result.add(word)\n\n            dfs(r - 1, c, node, word)\n            dfs(r + 1, c, node, word)\n            dfs(r, c - 1, node, word)\n            dfs(r, c + 1, node, word)\n\n            visit.remove((r, c))\n\n        for r in range(m):\n            for c in range(n):\n                dfs(r, c, root, \"\")\n\n        return list(result)\n\n\n# Your Solution object will be instantiated and called as such:\nobj = Solution()\nprint(\n    obj.findWords(\n        [\n            [\"o\", \"a\", \"a\", \"n\"],\n            [\"e\", \"t\", \"a\", \"e\"],\n            [\"i\", \"h\", \"k\", \"r\"],\n            [\"i\", \"f\", \"l\", \"v\"],\n        ],\n        [\"oath\", \"pea\", \"eat\", \"rain\"],\n    )\n)\n# [\"oath\", \"eat\"]\n</code></pre>"},{"location":"backtracking_combinations/","title":"Backtracking - Combinations","text":"<ol> <li>0077 - Combinations (Medium)</li> <li>0017 - Letter Combinations of a Phone Number (Medium)</li> <li>0039 - Combination Sum (Medium)</li> <li>0040 - Combination Sum II (Medium)</li> <li>0216 - Combination Sum III (Medium)</li> </ol>"},{"location":"backtracking_combinations/#0077-combinations","title":"0077. Combinations","text":"<pre><code>import itertools\nfrom typing import List\n\n\n# 1. Backtracking\ndef combine(n: int, k: int) -&gt; List[List[int]]:\n    path = []\n    result = []\n\n    def backtracking(start):\n        if len(path) == k:\n            result.append(path[:])\n            return None\n\n        for i in range(start, n + 1):\n            path.append(i)\n            backtracking(i + 1)\n            path.pop()\n\n    backtracking(start=1)\n\n    return result\n\n\n# 2. Itertools\ndef combineItertools(n: int, k: int) -&gt; List[List[int]]:\n    path = itertools.combinations(range(1, n + 1), k)\n    return path\n\n\nprint(combine(4, 2))\n# [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\nprint(list(combineItertools(4, 2)))\n# [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]\n</code></pre>"},{"location":"backtracking_combinations/#0017-letter-combinations-of-a-phone-number","title":"0017. Letter Combinations of a Phone Number","text":"<pre><code>from typing import List\n\n\ndef letterCombinations(digits: str) -&gt; List[str]:\n    letterMap = [\n        \"\",  # 0\n        \"\",  # 1\n        \"abc\",  # 2\n        \"def\",  # 3\n        \"ghi\",  # 4\n        \"jkl\",  # 5\n        \"mno\",  # 6\n        \"pqrs\",  # 7\n        \"tuv\",  # 8\n        \"wxyz\",  # 9\n    ]\n    result = []\n\n    def backtracking(index, s):\n        if index == len(digits):\n            result.append(s)\n            return None\n\n        digit = int(digits[index])\n        letters = letterMap[digit]\n\n        for i in range(len(letters)):\n            backtracking(index + 1, s + letters[i])\n\n    if len(digits) == 0:\n        return result\n\n    backtracking(0, \"\")\n\n    return result\n\n\nprint(letterCombinations(\"23\"))\n# ['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf']\n</code></pre>"},{"location":"backtracking_combinations/#0039-combination-sum","title":"0039. Combination Sum","text":"<pre><code>from typing import List\n\n\ndef combinationSum(candidates: List[int], target: int) -&gt; List[List[int]]:\n    result = []\n    path = []\n\n    def backtracking(total, start):\n        if total &gt; target:\n            return None\n        if total == target:\n            result.append(path[:])\n            return None\n\n        for i in range(start, len(candidates)):\n            total += candidates[i]\n            path.append(candidates[i])\n\n            backtracking(total, i)\n\n            total -= candidates[i]\n            path.pop()\n\n    backtracking(0, 0)\n    return result\n\n\nprint(combinationSum([2, 3, 6, 7], 7))  # [[2, 2, 3], [7]]\n</code></pre>"},{"location":"backtracking_combinations/#0040-combination-sum-ii","title":"0040. Combination Sum II","text":"<pre><code>from typing import List\n\n\ndef combinationSum2(candidates: List[int], target: int) -&gt; List[List[int]]:\n    result, path = [], []\n    candidates.sort()\n\n    def backtracking(total, start):\n        if total == target:\n            result.append(path[:])\n            return None\n\n        for i in range(start, len(candidates)):\n\n            if i &gt; start and candidates[i] == candidates[i - 1]:\n                continue\n\n            if total + candidates[i] &gt; target:\n                break\n\n            total += candidates[i]\n            path.append(candidates[i])\n            backtracking(total, i + 1)\n            total -= candidates[i]\n            path.pop()\n\n    backtracking(0, 0)\n\n    return result\n\n\nprint(combinationSum2([10, 1, 2, 7, 6, 1, 5], 8))\n# [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n</code></pre>"},{"location":"backtracking_combinations/#0216-combination-sum-iii","title":"0216. Combination Sum III","text":"<pre><code>import itertools\nfrom typing import List\n\n\n# 1. Backtracking\ndef combinationSum3(k: int, n: int) -&gt; List[List[int]]:\n    path, result = [], []\n\n    def backtracking(start):\n        if len(path) == k and sum(path) == n:\n            result.append(path[:])\n            return\n\n        for i in range(start, 10):\n            path.append(i)\n            backtracking(i + 1)\n            path.pop()\n\n    backtracking(1)\n\n    return result\n\n\n# 2. Itertools\ndef combinationSum3Itertools(k: int, n: int) -&gt; List[List[int]]:\n    combinations = itertools.combinations(range(1, 10), k)\n    result = []\n\n    for i in combinations:\n        if sum(i) == n:\n            result.append(i)\n\n    return result\n\n\nprint(combinationSum3(3, 7))  # [[1, 2, 4]]\nprint(combinationSum3Itertools(3, 7))  # [(1, 2, 4)]\n</code></pre>"},{"location":"backtracking_partitions/","title":"Backtracking - Partitions","text":"<ol> <li>0131 - Palindrome Partitioning (Medium)</li> <li>0093 - Restore IP Addresses (Medium)</li> </ol>"},{"location":"backtracking_partitions/#131-palindrome-partitioning","title":"131. Palindrome Partitioning","text":"<pre><code>from typing import List\n\n\ndef partition(s: str) -&gt; List[List[str]]:\n    path, result = [], []\n\n    def backtracking(startIndex):\n        if startIndex == len(s):\n            result.append(path[:])\n            return None\n\n        for i in range(startIndex, len(s)):\n            if is_palindrome(s, startIndex, i):\n                path.append(s[startIndex : i + 1])\n                backtracking(i + 1)\n                path.pop()\n\n    def is_palindrome(s: str, start, end) -&gt; bool:\n        while start &lt; end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n\n        return True\n\n    backtracking(0)\n\n    return result\n\n\nprint(partition(\"aab\"))  # [['a', 'a', 'b'], ['aa', 'b']]\n</code></pre>"},{"location":"backtracking_partitions/#93-restore-ip-addresses","title":"93. Restore IP Addresses","text":"<pre><code>from typing import List\n\n\ndef restoreIpAddresses(s: str) -&gt; List[str]:\n    result = []\n\n    def backtracking(start_index, point_num, current, result):\n        # stop condition\n        if point_num == 3:\n            if is_valid(s, start_index, len(s) - 1):\n                current += s[start_index:]\n                result.append(current)\n            return\n\n        for i in range(start_index, len(s)):\n            if is_valid(s, start_index, i):\n                sub = s[start_index : i + 1]\n                backtracking(i + 1, point_num + 1, current + sub + \".\", result)\n            else:\n                break\n\n    def is_valid(s, start, end):\n        if start &gt; end:\n            return False\n\n        if s[start] == \"0\" and start != end:\n            return False\n\n        num = 0\n        for i in range(start, end + 1):\n            if not s[i].isdigit():\n                return False\n            num = num * 10 + int(s[i])\n            if num &gt; 255:\n                return False\n        return True\n\n    backtracking(0, 0, \"\", result)\n\n    return result\n\n\nprint(restoreIpAddresses(\"25525511135\"))\n# ['255.255.11.135', '255.255.111.35']\n</code></pre>"},{"location":"backtracking_permutations/","title":"Backtracking - Permutations","text":"<ol> <li>0046 - Permutations (Medium)</li> <li>0047 - Permutations II (Medium)</li> </ol>"},{"location":"backtracking_permutations/#46-permutations","title":"46. Permutations","text":"<pre><code>from typing import List\n\n\ndef permute(nums: List[int]) -&gt; List[List[int]]:\n    path, result = [], []\n    used = [False for _ in range(len(nums))]\n\n    def backtracking():\n        if len(path) == len(nums):\n            result.append(path[:])\n\n        for i in range(len(nums)):\n            if used[i]:\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtracking()\n            path.pop()\n            used[i] = False\n\n    backtracking()\n\n    return result\n\n\nprint(permute([1, 2, 3]))\n# [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n</code></pre>"},{"location":"backtracking_permutations/#47-permutations-ii","title":"47. Permutations II","text":"<pre><code>from typing import List\n\n\ndef permuteUnique(nums: List[int]) -&gt; List[List[int]]:\n    nums.sort()\n    path, result = [], []\n    used = [False for _ in range(len(nums))]\n\n    def backtracking():\n        if len(path) == len(nums):\n            result.append(path[:])\n\n        for i in range(len(nums)):\n            if used[i]:\n                continue\n            if i &gt; 0 and nums[i] == nums[i - 1] and not used[i - 1]:\n                continue\n\n            used[i] = True\n            path.append(nums[i])\n            backtracking()\n            path.pop()\n            used[i] = False\n\n    backtracking()\n\n    return result\n\n\nprint(permuteUnique([1, 1, 2]))\n# [[1, 1, 2], [1, 2, 1], [2, 1, 1]]\n</code></pre>"},{"location":"backtracking_subsets/","title":"Backtracking - Subsets","text":"<ol> <li>0078 - Subsets (Medium)</li> <li>0090 - Subsets II (Medium)</li> <li>0491 - Non-decreasing Subsequences (Medium)</li> </ol>"},{"location":"backtracking_subsets/#78-subsets","title":"78. Subsets","text":"<pre><code>from typing import List\n\n\ndef subsets(nums: List[int]) -&gt; List[List[int]]:\n    path, result = [], []\n\n    def backtracking(startIndex):\n        result.append(path[:])\n\n        for i in range(startIndex, len(nums)):\n            path.append(nums[i])\n            backtracking(i + 1)\n            path.pop()\n\n    backtracking(startIndex=0)\n\n    return result\n\n\nprint(subsets([1, 2, 3]))\n# [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]\n</code></pre>"},{"location":"backtracking_subsets/#90-subsets-ii","title":"90. Subsets II","text":"<pre><code>from typing import List\n\n\ndef subsetsWithDup(nums: List[int]) -&gt; List[List[int]]:\n    path, result = [], []\n    nums.sort()\n\n    def backtracking(startIndex):\n        if path not in result:\n            result.append(path[:])\n\n        for i in range(startIndex, len(nums)):\n            path.append(nums[i])\n            backtracking(i + 1)\n            path.pop()\n\n    backtracking(startIndex=0)\n\n    return result\n\n\nprint(subsetsWithDup([1, 2, 2]))\n# [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]\n</code></pre>"},{"location":"backtracking_subsets/#491-non-decreasing-subsequences","title":"491. Non-decreasing Subsequences","text":"<pre><code>from typing import List\n\n\ndef findSubsequences(nums: List[int]) -&gt; List[List[int]]:\n    path, result = [], []\n\n    def backtracking(startIndex):\n        if len(path) &gt; 1:\n            result.append(path[:])\n\n        used = set()\n        for i in range(startIndex, len(nums)):\n\n            if (path and nums[i] &lt; path[-1]) or nums[i] in used:\n                continue\n\n            used.add(nums[i])\n            path.append(nums[i])\n            backtracking(i + 1)\n            path.pop()\n\n    backtracking(0)\n\n    return result\n\n\nprint(findSubsequences([4, 6, 7, 7]))\n# [[4, 6], [4, 6, 7], [4, 6, 7, 7], [4, 7], [4, 7, 7], [6, 7], [6, 7, 7], [7, 7]]\n</code></pre>"},{"location":"binary_search/","title":"Binary Search","text":"<ol> <li>0704 - Binary Search (Easy)</li> <li>0035 - Search Insert Position (Easy)</li> <li>0278 - First Bad Version (Easy)</li> <li>0034 - Find First and Last Position of Element in Sorted Array (Medium)</li> <li>0367 - Valid Perfect Square (Easy)</li> <li>0875 - Koko Eating Bananas (Medium)</li> <li>1011 - Capacity To Ship Packages Within D Days (Medium)</li> </ol>"},{"location":"binary_search/#bisect-usage","title":"<code>bisect</code> Usage","text":"<pre><code>from bisect import bisect_left, bisect_right, insort_left, insort_right\n\narray = [1, 3, 3, 3, 5, 7, 9, 9, 9]\nx = 3\n\n# 1. bisect_left: find the leftmost index to insert x\nprint(bisect_left(array, x))  # 1\n\n# 2. bisect_right: find the rightmost index to insert x\nprint(bisect_right(array, x))  # 4\n\n# 3. insort_left: insert x into the array at the leftmost index\ninsort_left(array, x)\nprint(array)  # [1, 3, 3, 3, 3, 5, 7, 9, 9, 9]\n\n# 4. insort_right: insert x into the array at the rightmost index\ninsort_right(array, x)\nprint(array)  # [1, 3, 3, 3, 3, 3, 5, 7, 9, 9, 9]\n</code></pre>"},{"location":"binary_search/#704-binary-search","title":"704. Binary Search","text":"<ul> <li>Implement binary search algorithm.</li> </ul> <pre><code>from typing import List\n\n\ndef search(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        middle = left + (right - left) // 2\n\n        if nums[middle] &gt; target:\n            right = middle - 1\n        elif nums[middle] &lt; target:\n            left = middle + 1\n        else:\n            return middle\n\n    return -1\n\n\nnums = [-1, 0, 3, 5, 9, 12]\ntarget = 9\nprint(search(nums, target))  # 4\n</code></pre>"},{"location":"binary_search/#35-search-insert-position","title":"35. Search Insert Position","text":"<ul> <li>Return the index of the target if it is found. If not, return the index where it would be if it were inserted in order.</li> </ul> <pre><code>from typing import List\n\n\ndef searchInsert(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] &gt; target:\n            right = mid - 1\n        elif nums[mid] &lt; target:\n            left = mid + 1\n        else:\n            return mid\n\n    return left\n\n\nnums = [1, 3, 5, 6]\ntarget = 5\nprint(searchInsert(nums, target))  # 2\n</code></pre>"},{"location":"binary_search/#278-first-bad-version","title":"278. First Bad Version","text":"<ul> <li>Find the first bad version given a function <code>isBadVersion</code>.</li> </ul> <pre><code>def firstBadVersion(n: int) -&gt; int:\n    left, right = 1, n\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if isBadVersion(mid):\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return left\n\n\ndef isBadVersion(version: int) -&gt; bool:\n    pass\n</code></pre>"},{"location":"binary_search/#34-find-first-and-last-position-of-element-in-sorted-array","title":"34. Find First and Last Position of Element in Sorted Array","text":"<ul> <li>Find the starting and ending position of a given target value in a sorted array.</li> </ul> <pre><code>from typing import List\n\n\ndef searchRange(nums: List[int], target: int) -&gt; List[int]:\n\n    def binarySearch(nums: List[int], target: int) -&gt; int:\n        left, right = 0, len(nums) - 1\n        while left &lt;= right:\n            middle = left + (right - left) // 2\n            if nums[middle] &gt;= target:\n                right = middle - 1\n            else:\n                left = middle + 1\n        return left\n\n    left = binarySearch(nums, target)\n    right = binarySearch(nums, target + 1) - 1\n\n    if left == len(nums) or nums[left] != target:\n        return [-1, -1]\n    return [left, right]\n\n\nnums = [5, 7, 7, 8, 8, 10]\ntarget = 8\nprint(searchRange(nums, target))\n</code></pre>"},{"location":"binary_search/#367-valid-perfect-square","title":"367. Valid Perfect Square","text":"<ul> <li>Determine if a positive integer is a perfect square without using any built-in library function.</li> </ul> <pre><code>def isPerfectSquare(num: int) -&gt; bool:\n    if num &lt; 2:\n        return True\n\n    left, right = 0, num // 2\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if mid * mid == num:\n            return True\n        elif mid * mid &lt; num:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\n\nnum = 16\nprint(isPerfectSquare(num))\n</code></pre>"},{"location":"binary_search/#875-koko-eating-bananas","title":"875. Koko Eating Bananas","text":"<ul> <li>Koko loves to eat bananas. She wants to eat all the bananas within <code>H</code> hours. Each pile has a number of bananas. The <code>i-th</code> pile has <code>piles[i]</code> bananas. Return the minimum integer <code>K</code> such that she can eat all the bananas within <code>H</code> hours.</li> </ul> <pre><code>from typing import List\n\n\ndef minEatingSpeed(piles: List[int], h: int) -&gt; int:\n    def canEat(piles: List[int], k: int, h: int) -&gt; bool:\n        hours = 0\n        for pile in piles:\n            hours += (pile + k - 1) // k\n        return hours &lt;= h\n\n    left, right = 1, max(piles)\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if canEat(piles, mid, h):\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return left\n\n\npiles = [3, 6, 7, 11]\nh = 8\nprint(minEatingSpeed(piles, h))\n</code></pre>"},{"location":"binary_search/#1011-capacity-to-ship-packages-within-d-days","title":"1011. Capacity To Ship Packages Within D Days","text":"<ul> <li>A conveyor belt has packages that must be shipped from one port to another within <code>D</code> days. The <code>i-th</code> package has a weight of <code>weights[i]</code>. Each day, we load the ship with packages on the conveyor belt. The ship will be loaded with packages up to its capacity. The ship will not be loaded beyond its capacity. Return the least weight capacity of the ship.</li> </ul> <pre><code>from typing import List\n\n\ndef shipWithinDays(weights: List[int], days: int) -&gt; int:\n    def canShip(weights, D, capacity) -&gt; bool:\n        days = 1\n        current_weight = 0\n\n        for weight in weights:\n            if current_weight + weight &gt; capacity:\n                days += 1\n                current_weight = 0\n            current_weight += weight\n\n        return days &lt;= D\n\n    left, right = max(weights), sum(weights)\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        if canShip(weights, days, mid):\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return left\n\n\nweights = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\ndays = 5\nprint(shipWithinDays(weights, days))\n</code></pre>"},{"location":"design/","title":"Design","text":"<ol> <li>0146 - LRU Cache (Medium)</li> <li>0355 - Design Twitter (Medium)</li> <li>0588 - Design a File System (Hard)</li> <li>0460 - LFU Cache (Hard)</li> <li>1166 - Design an In-Memory File System (Hard)</li> <li>0380 - Insert Delete GetRandom O(1) (Medium)</li> <li>0362 - Design Hit Counter (Medium)</li> <li>0297 - Serialize and Deserialize Binary Tree (Hard)</li> <li>0622 - Design Circular Queue (Medium)</li> <li>0353 - Design Snake Game (Medium)</li> <li>1244 - Design A Leaderboard (Medium)</li> </ol>"},{"location":"design/#146-lru-cache","title":"146. LRU Cache","text":"<pre><code>class ListNode:\n    def __init__(self, key=0, val=0):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.head = ListNode()\n        self.tail = ListNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def remove_node(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def add_node_to_last(self, node):\n        self.tail.prev.next = node\n        node.prev = self.tail.prev\n        node.next = self.tail\n        self.tail.prev = node\n\n    def move_node_to_last(self, node):\n        self.remove_node(node)\n        self.add_node_to_last(node)\n\n    def get(self, key: int) -&gt; int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self.move_node_to_last(node)\n        return node.val\n\n    def put(self, key: int, value: int) -&gt; None:\n        if key in self.cache:\n            node = self.cache[key]\n            node.val = value\n            self.move_node_to_last(node)\n            return\n\n        if len(self.cache) == self.capacity:\n            del self.cache[self.head.next.key]\n            self.remove_node(self.head.next)\n\n        node = ListNode(key, value)\n        self.cache[key] = node\n        self.add_node_to_last(node)\n\n\n# Data structure: Doubly linked list + Hash map\n# Time complexity\n#   - get: O(1)\n#   - put: O(1)\n# Space complexity: O(capacity)\n\n\ncache = LRUCache(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\nprint(\"LRU Cache passed\")\n</code></pre>"},{"location":"design/#355-design-twitter","title":"355. Design Twitter","text":""},{"location":"design/#588-design-a-file-system","title":"588. Design a File System","text":""},{"location":"design/#460-lfu-cache","title":"460. LFU Cache","text":""},{"location":"design/#1166-design-an-in-memory-file-system","title":"1166. Design an In-Memory File System","text":""},{"location":"design/#380-insert-delete-getrandom-o1","title":"380. Insert Delete GetRandom O(1)","text":""},{"location":"design/#362-design-hit-counter","title":"362. Design Hit Counter","text":""},{"location":"design/#297-serialize-and-deserialize-binary-tree","title":"297. Serialize and Deserialize Binary Tree","text":""},{"location":"design/#622-design-circular-queue","title":"622. Design Circular Queue","text":""},{"location":"design/#353-design-snake-game","title":"353. Design Snake Game","text":""},{"location":"design/#1244-design-a-leaderboard","title":"1244. Design A Leaderboard","text":""},{"location":"dp_2d/","title":"Dynamic Programming - 2 Dimensional Table","text":"<ol> <li>0118 - Pascal's Triangle (Easy)</li> <li>0119 - Pascal's Triangle II (Easy)</li> <li>0062 - Unique Paths (Medium)</li> <li>0063 - Unique Paths II (Medium)</li> </ol>"},{"location":"dp_2d/#118-pascals-triangle","title":"118. Pascal's Triangle","text":"<ul> <li>Generate the first <code>numRows</code> of Pascal's triangle.</li> </ul> <pre><code>                 numRows    index\n     1              1         0\n    1 1             2         1\n   1 2 1            3         2\n  1 3 3 1           4         3\n 1 4 6 4 1          5         4\n</code></pre> <pre><code>from typing import List\n\n\ndef generate(numRows: int) -&gt; List[List[int]]:\n    dp = [[1] * i for i in range(1, numRows + 1)]\n\n    if numRows &lt;= 2:\n        return dp\n\n    for i in range(2, numRows):\n        for j in range(1, i):\n            dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n\n    return dp\n\n\nprint(generate(numRows=5))\n#     [[1],\n#    [1, 1],\n#   [1, 2, 1],\n#  [1, 3, 3, 1],\n# [1, 4, 6, 4, 1]]\n</code></pre>"},{"location":"dp_2d/#119-pascals-triangle-ii","title":"119. Pascal's Triangle II","text":"<ul> <li>Return the <code>rowIndex</code>th row of Pascal's triangle.</li> </ul> <pre><code>from typing import List\n\n\ndef getRow(rowIndex: int) -&gt; List[int]:\n    # TC: O(n^2)\n    # SC: O(n^2)\n    rowNum = rowIndex + 1\n    dp = [[0] * i for i in range(1, rowNum + 1)]\n\n    for i in range(rowNum):\n        dp[i][0], dp[i][i] = 1, 1\n        for j in range(1, i):\n            dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]\n\n    return dp[rowIndex]\n\n\nprint(getRow(rowIndex=3))  # [1, 3, 3, 1]\n</code></pre>"},{"location":"dp_2d/#62-unique-paths","title":"62. Unique Paths","text":"<ul> <li>Count the number of unique paths to reach the bottom-right corner of a <code>m x n</code> grid.</li> </ul> <pre><code>def uniquePaths(m: int, n: int) -&gt; int:\n    if m == 1 or n == 1:\n        return 1\n\n    dp = [[1] * n] * m\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]\n\n\nprint(uniquePaths(m=3, n=7))  # 28\n</code></pre>"},{"location":"dp_2d/#63-unique-paths-ii","title":"63. Unique Paths II","text":"<ul> <li>Count the number of unique paths to reach the bottom-right corner of a <code>m x n</code> grid with obstacles.</li> </ul> <pre><code>from typing import List\n\n\ndef uniquePathsWithObstacles(obstacleGrid: List[List[int]]) -&gt; int:\n    m = len(obstacleGrid)\n    n = len(obstacleGrid[0])\n\n    if obstacleGrid[0][0] == 1 or obstacleGrid[-1][-1] == 1:\n        return 0\n\n    dp = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n        if obstacleGrid[i][0] == 0:\n            dp[i][0] = 1\n        else:\n            break\n\n    for j in range(n):\n        if obstacleGrid[0][j] == 0:\n            dp[0][j] = 1\n        else:\n            break\n\n    for i in range(1, m):\n        for j in range(1, n):\n            if obstacleGrid[i][j] == 1:\n                continue\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]\n\n\nobstacleGrid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\nprint(uniquePathsWithObstacles(obstacleGrid))  # 2\n</code></pre>"},{"location":"dp_basic/","title":"Dynamic Programming - Basic","text":"<ol> <li>0509 - Fibonacci Number (Easy)</li> <li>0070 - Climbing Stairs (Easy)</li> <li>0746 - Min Cost Climbing Stairs (Easy)</li> <li>0198 - House Robber (Easy)</li> <li>0213 - House Robber II (Medium)</li> <li>0376 - Wiggle Subsequence (Medium)</li> <li>0343 - Integer Break (Medium)</li> <li>1025 - Divisor Game (Easy)</li> </ol>"},{"location":"dp_basic/#dp-resources","title":"DP Resources","text":"<ul> <li>[Leetcode Discuss] Solved all dynamic programming (dp) problems in 7 months</li> </ul>"},{"location":"dp_basic/#steps-to-solve-dp-problems","title":"Steps to Solve DP Problems","text":"<ol> <li>Define the <code>dp</code> array and its meaning.</li> <li>Define the <code>dp</code> formula.</li> <li>Initialize the <code>dp</code> array.</li> <li>Determine the traversal direction.</li> <li>Derive the <code>dp</code> array.</li> </ol>"},{"location":"dp_basic/#509-fibonacci-number","title":"509. Fibonacci Number","text":"<pre><code># DP\ndef fibDP(n: int) -&gt; int:\n    # TC: O(n)\n    # SC: O(n)\n    if n &lt;= 1:\n        return n\n\n    dp = [i for i in range(n + 1)]\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\n# Recursive\ndef fibRecursive(n: int) -&gt; int:\n    # TC: O(2^n)\n    # SC: O(n)\n    if n &lt;= 1:\n        return n\n\n    return fibRecursive(n - 1) + fibRecursive(n - 2)\n\n\nn = 10\nprint(fibDP(n))  # 55\nprint(fibRecursive(n))  # 55\n</code></pre>"},{"location":"dp_basic/#70-climbing-stairs","title":"70. Climbing Stairs","text":"<ul> <li>Return the number of distinct ways to reach the top of the stairs.</li> </ul> <pre><code># DP\ndef climbStairs(n: int) -&gt; int:\n    # TC: O(n), SC: O(n)\n    # dp[n]: the number of ways to reach the n-th step\n    # dp[n] = dp[n-1] + dp[n-2]\n\n    if n &lt;= 1:\n        return n\n\n    dp = [i for i in range(n + 1)]\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\nprint(climbStairs(10))  # 89\n</code></pre>"},{"location":"dp_basic/#746-min-cost-climbing-stairs","title":"746. Min Cost Climbing Stairs","text":"<pre><code>from typing import List\n\n\ndef minCostClimbingStairs(cost: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(cost))]\n\n    dp[0], dp[1] = cost[0], cost[1]\n\n    for i in range(2, len(cost)):\n        dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]\n\n    return min(dp[-1], dp[-2])\n\n\ncost = [10, 15, 20]\nprint(minCostClimbingStairs(cost))  # 15\n</code></pre>"},{"location":"dp_basic/#198-house-robber","title":"198. House Robber","text":"<pre><code>from typing import List\n\n\ndef rob(nums: List[int]) -&gt; int:\n    if len(nums) &lt; 3:\n        return max(nums)\n\n    dp = [0 for _ in range(len(nums))]\n    dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n    for i in range(2, len(nums)):\n        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n    return dp[-1]\n\n\nnums = [2, 7, 9, 3, 1]\nprint(rob(nums))  # 12\n</code></pre>"},{"location":"dp_basic/#213-house-robber-ii","title":"213. House Robber II","text":"<pre><code>from typing import List\n\n\ndef rob(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 3:\n        return max(nums)\n\n    def robLinear(nums: List[int]) -&gt; int:\n        dp = [0 for _ in range(len(nums))]\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n        return dp[-1]\n\n    # circle -&gt; linear\n    a = robLinear(nums[1:])  # 2nd house to the last house\n    b = robLinear(nums[:-1])  # 1st house to the 2nd last house\n\n    return max(a, b)\n\n\nnums = [2, 3, 2]\nprint(rob(nums))  # 3\n</code></pre>"},{"location":"dp_basic/#376-wiggle-subsequence","title":"376. Wiggle Subsequence","text":"<pre><code>from typing import List\n\n\n# DP\ndef wiggleMaxLengthDP(nums: List[int]) -&gt; int:\n    # Time complexity: O(n)\n    # Space complexity: O(n)\n    if len(nums) &lt;= 1:\n        return len(nums)\n\n    up = [0 for _ in range(len(nums))]\n    down = [0 for _ in range(len(nums))]\n\n    up[0], down[0] = 1, 1\n\n    for i in range(1, len(nums)):\n        if nums[i] &gt; nums[i - 1]:\n            up[i] = down[i - 1] + 1\n            down[i] = down[i - 1]\n        elif nums[i] &lt; nums[i - 1]:\n            down[i] = up[i - 1] + 1\n            up[i] = up[i - 1]\n        else:\n            up[i] = up[i - 1]\n            down[i] = down[i - 1]\n\n    return max(up[-1], down[-1])\n\n\n# Greedy\ndef wiggleMaxLengthGreedy(nums: List[int]) -&gt; int:\n    if len(nums) &lt; 2:\n        return len(nums)\n\n    prev_diff = nums[1] - nums[0]\n    count = 2 if prev_diff != 0 else 1\n\n    for i in range(2, len(nums)):\n        diff = nums[i] - nums[i - 1]\n        if (diff &gt; 0 and prev_diff &lt;= 0) or (diff &lt; 0 and prev_diff &gt;= 0):\n            count += 1\n            prev_diff = diff\n\n    return count\n\n\nnums = [1, 7, 4, 9, 2, 5]\nprint(wiggleMaxLengthDP(nums))  # 6\nprint(wiggleMaxLengthGreedy(nums))  # 6\n</code></pre>"},{"location":"dp_basic/#343-integer-break","title":"343. Integer Break","text":"<pre><code>def integerBreak(n: int) -&gt; int:\n    # Time complexity: O(n^2)\n    # Space complexity: O(n)\n\n    dp = [0 for _ in range(n + 1)]\n    dp[2] = 1\n\n    for i in range(3, n + 1):\n        for j in range(1, i + 1):\n            dp[i] = max(dp[i], dp[i - j] * j, (i - j) * j)\n\n    return dp[n]\n\n\nn = 10\nprint(integerBreak(n))  # 36\n</code></pre>"},{"location":"dp_basic/#1025-divisor-game","title":"1025. Divisor Game","text":"<pre><code>def divisorGame(n: int) -&gt; bool:\n    # Time complexity: O(n^2)\n    # Space complexity: O(n)\n\n    if n &lt;= 1:\n        return False\n\n    dp = [False for _ in range(n + 1)]\n\n    for i in range(2, n + 1):\n        for j in range(1, i):\n            if i % j == 0 and not dp[i - j]:\n                dp[i] = True\n                break\n    return dp[n]\n\n\nn = 2\nprint(divisorGame(n))  # True\n</code></pre>"},{"location":"dp_interval/","title":"Dynamic Programming - Interval","text":"<ol> <li>0516 - Longest Palindromic Subsequence (Medium)</li> <li>0647 - Palindromic Substrings (Medium)</li> </ol>"},{"location":"dp_interval/#516-longest-palindromic-subsequence","title":"516. Longest Palindromic Subsequence","text":"<pre><code>def longestPalindromeSubseq(s: str) -&gt; int:\n    dp = [[0] * len(s) for _ in range(len(s))]\n    for i in range(len(s)):\n        dp[i][i] = 1\n\n    for i in range(len(s) - 1, -1, -1):\n        for j in range(i + 1, len(s)):\n\n            if s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])\n\n    return dp[0][-1]\n\n\nprint(longestPalindromeSubseq(\"bbbab\"))  # 4\n</code></pre>"},{"location":"dp_interval/#647-palindromic-substrings","title":"647. Palindromic Substrings","text":"<pre><code>def countSubstrings(s: str) -&gt; int:\n    dp = [[False] * len(s) for _ in range(len(s))]\n    result = 0\n\n    for i in range(len(s) - 1, -1, -1):\n        for j in range(i, len(s)):\n            if s[i] == s[j]:\n                if j - i &lt;= 1:\n                    dp[i][j] = True\n                    result += 1\n                elif dp[i + 1][j - 1]:\n                    dp[i][j] = True\n                    result += 1\n    return result\n\n\nprint(countSubstrings(\"abc\"))  # 3\n</code></pre>"},{"location":"dp_kadane/","title":"Dynamic Programming - Kadane's Algorithm","text":"<ol> <li>0053 - Maximum Subarray (Medium)</li> <li>0152 - Maximum Product Subarray (Medium)</li> <li>0978 - Longest Turbulent Subarray (Medium)</li> <li>1186 - Maximum Subarray Sum with One Deletion (Medium)</li> </ol>"},{"location":"dp_kadane/#53-maximum-subarray","title":"53. Maximum Subarray","text":"<pre><code>from typing import List\n\n\n# DP\ndef maxSubArrayDP(nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n\n    dp[0] = nums[0]\n    maxSum = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(\n            dp[i - 1] + nums[i],  # continue the previous subarray\n            nums[i],  # start a new subarray\n        )\n        maxSum = max(maxSum, dp[i])\n\n    return maxSum\n\n\n# Greedy\ndef maxSubArrayGreedy(nums: List[int]) -&gt; int:\n    maxSum = float(\"-inf\")\n    curSum = 0\n\n    for num in nums:\n        curSum += num\n        maxSum = max(maxSum, curSum)\n        curSum = max(curSum, 0)\n\n    return maxSum\n\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArrayDP(nums))  # 6\nprint(maxSubArrayGreedy(nums))  # 6\n</code></pre>"},{"location":"dp_kadane/#152-maximum-product-subarray","title":"152. Maximum Product Subarray","text":"<pre><code>from typing import List\n\n\ndef maxProduct(nums: List[int]) -&gt; int:\n    n = len(nums)\n    dp_max = [0 for _ in range(n)]\n    dp_min = [0 for _ in range(n)]\n\n    dp_max[0] = nums[0]\n    dp_min[0] = nums[0]\n    max_product = nums[0]\n\n    for i in range(1, n):\n        dp_max[i] = max(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n        dp_min[i] = min(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n\n        max_product = max(max_product, dp_max[i])\n\n    return max_product\n\n\nnums = [2, 3, -2, 4]\nprint(maxProduct(nums))  # 6\n</code></pre>"},{"location":"dp_kadane/#978-longest-turbulent-subarray","title":"978. Longest Turbulent Subarray","text":"<pre><code>from typing import List\n\n\ndef maxTurbulenceSize(arr: List[int]) -&gt; int:\n    n = len(arr)\n    up = [1 for _ in range(n)]\n    down = [1 for _ in range(n)]\n    maxLen = 1\n\n    for i in range(1, n):\n        if arr[i - 1] &lt; arr[i]:\n            up[i] = down[i - 1] + 1\n            down[i] = 1\n        elif arr[i - 1] &gt; arr[i]:\n            down[i] = up[i - 1] + 1\n            up[i] = 1\n        else:\n            up[i] = 1\n            down[i] = 1\n\n        maxLen = max(maxLen, up[i], down[i])\n\n    return maxLen\n\n\narr = [9, 4, 2, 10, 7, 8, 8, 1, 9]\nprint(maxTurbulenceSize(arr))  # 5\n</code></pre>"},{"location":"dp_kadane/#1186-maximum-subarray-sum-with-one-deletion","title":"1186. Maximum Subarray Sum with One Deletion","text":"<pre><code>from typing import List\n\n\ndef maximumSum(arr: List[int]) -&gt; int:\n    # dp0: max sum ending at i without deleting any element\n    # dp1: max sum ending at i with deleting one element\n\n    dp0 = arr[0]\n    dp1 = 0\n    maxSum = dp0\n\n    for i in range(1, len(arr)):\n        dp1 = max(dp1 + arr[i], dp0)  # delete previous element or not\n        dp0 = max(dp0, 0) + arr[i]  # delete current element or not\n        maxSum = max(maxSum, dp0, dp1)  # update result\n\n    return maxSum\n\n\narr = [1, -2, 0, 3]\nprint(maximumSum(arr))  # 4\n</code></pre>"},{"location":"dp_knapsack_01/","title":"Dynamic Programming - 0/1 Knapsack Problem","text":""},{"location":"dp_knapsack_01/#01-knapsack","title":"0/1 Knapsack","text":"<pre><code>from pprint import pprint\nfrom typing import List\n\n\n# 01 Knapsack - Manual Initialization\ndef knapsack01_1(weights: List[int], values: List[int], capacity: int) -&gt; int:\n    n = len(weights)\n\n    # DP table initialization\n    dp = [[0] * (capacity + 1) for _ in range(n)]\n    for j in range(capacity + 1):\n        if weights[0] &lt;= j:\n            dp[0][j] = values[0]\n\n    for i in range(1, n):\n        for j in range(1, capacity + 1):\n            if weights[i] &gt; j:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = max(\n                    dp[i - 1][j],  # skip\n                    dp[i - 1][j - weights[i]] + values[i],  # take\n                )\n\n    return dp[-1][-1]\n\n\n# 01 Knapsack - Zero Initialization\ndef knapsack01_2(weights: List[int], values: List[int], capacity: int) -&gt; int:\n    n = len(weights)\n\n    dp = [[0] * (capacity + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(1, capacity + 1):\n            if weights[i - 1] &gt; j:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = max(\n                    dp[i - 1][j],  # skip\n                    dp[i - 1][j - weights[i - 1]] + values[i - 1],  # take\n                )\n\n    return dp[-1][-1]\n\n\nweights = [1, 4, 1, 2, 12]\nvalues = [2, 10, 1, 2, 4]\ncapacity = 15\n\nprint(knapsack01_1(weights, values, capacity))  # 15\n# [[0, 2, 2, 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2],\n#  [0, 2, 2, 2, 10, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12],\n#  [0, 2, 3, 3, 10, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13],\n#  [0, 2, 3, 4, 10, 12, 13, 14, 15, 15, 15, 15, 15, 15, 15, 15],\n#  [0, 2, 3, 4, 10, 12, 13, 14, 15, 15, 15, 15, 15, 15, 15, 15]]\n\nprint(knapsack01_2(weights, values, capacity))  # 15\n# [[0, 0, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],\n#  [0, 2, 2, 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2],\n#  [0, 2, 2, 2, 10, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12],\n#  [0, 2, 3, 3, 10, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13],\n#  [0, 2, 3, 4, 10, 12, 13, 14, 15, 15, 15, 15, 15, 15, 15, 15],\n#  [0, 2, 3, 4, 10, 12, 13, 14, 15, 15, 15, 15, 15, 15, 15, 15]]\n</code></pre>"},{"location":"dp_knapsack_01/#problems","title":"Problems","text":"<ol> <li>0416 - Partition Equal Subset Sum (Medium)</li> <li>0474 - Ones and Zeroes (Medium)</li> <li>0494 - Target Sum (Medium)</li> <li>1049 - Last Stone Weight II (Medium)</li> </ol>"},{"location":"dp_knapsack_01/#416-partition-equal-subset-sum","title":"416. Partition Equal Subset Sum","text":"<pre><code>from typing import List\n\n\ndef canPartition(nums: List[int]) -&gt; bool:\n    total_sum = sum(nums)\n\n    if total_sum % 2 == 1 or len(nums) &lt; 2:\n        return False\n\n    target = total_sum // 2\n\n    dp = [0 for _ in range(target + 1)]\n\n    for i in range(len(nums)):\n        for j in range(target, nums[i] - 1, -1):\n            dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])\n\n    return dp[target] == target\n\n\nnums = [1, 5, 11, 5]\nprint(canPartition(nums))  # True\n</code></pre>"},{"location":"dp_knapsack_01/#474-ones-and-zeroes","title":"474. Ones and Zeroes","text":"<pre><code>from typing import List\n\n\ndef findMaxForm(strs: List[str], m: int, n: int) -&gt; int:\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for s in strs:\n        zerosNum = s.count(\"0\")\n        onesNum = len(s) - zerosNum\n\n        for i in range(m, zerosNum - 1, -1):\n            for j in range(n, onesNum - 1, -1):\n                dp[i][j] = max(dp[i][j], dp[i - zerosNum][j - onesNum] + 1)\n\n    return dp[m][n]\n\n\nstrs = [\"10\", \"0001\", \"111001\", \"1\", \"0\"]\nm = 5\nn = 3\nprint(findMaxForm(strs, m, n))  # 4\n</code></pre>"},{"location":"dp_knapsack_01/#494-target-sum","title":"494. Target Sum","text":"<pre><code>from typing import List\n\n\ndef findTargetSumWays(nums: List[int], target: int) -&gt; int:\n\n    totalSum = sum(nums)\n\n    if abs(target) &gt; totalSum:\n        return 0\n    if (target + totalSum) % 2 == 1:\n        return 0\n\n    targetSum = (target + totalSum) // 2\n    dp = [0] * (targetSum + 1)\n    dp[0] = 1\n\n    for i in range(len(nums)):\n        for j in range(targetSum, nums[i] - 1, -1):\n            dp[j] += dp[j - nums[i]]\n\n    return dp[targetSum]\n\n\nnums = [1, 1, 1, 1, 1]\ntarget = 3\nprint(findTargetSumWays(nums, target))  # 5\n</code></pre>"},{"location":"dp_knapsack_01/#1049-last-stone-weight-ii","title":"1049. Last Stone Weight II","text":"<pre><code>from typing import List\n\n\ndef lastStoneWeightII(stones: List[int]) -&gt; int:\n    target = sum(stones) // 2\n\n    dp = [0 for _ in range(target + 1)]\n\n    for i in range(len(stones)):\n        for j in range(target, stones[i] - 1, -1):\n            dp[j] = max(dp[j], dp[j - stones[i]] + stones[i])\n\n    result = (sum(stones) - dp[target]) - dp[target]\n\n    return result\n\n\nstones = [2, 7, 4, 1, 8, 1]\nprint(lastStoneWeightII(stones))  # 1\n</code></pre>"},{"location":"dp_knapsack_unbounded/","title":"Dynamic Programming - Unbounded Knapsack Problem","text":"<ol> <li>0139 - Word Break (Medium)</li> <li>0279 - Perfect Squares (Medium)</li> <li>0322 - Coin Change (Medium)</li> <li>0518 - Coin Change 2 (Medium)</li> <li>0377 - Combination Sum IV (Medium)</li> </ol>"},{"location":"dp_knapsack_unbounded/#0139-word-break","title":"0139. Word Break","text":"<pre><code>from typing import List\n\n\ndef wordBreak(s: str, wordDict: List[str]) -&gt; bool:\n    wordSet = set(wordDict)\n    dp = [False] * (len(s) + 1)\n    dp[0] = True\n\n    for i in range(1, len(s) + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in wordSet:\n                dp[i] = True\n                break\n\n    return dp[len(s)]\n\n\ns = \"leetcode\"\nwordDict = [\"leet\", \"code\"]\nprint(wordBreak(s, wordDict))  # True\n</code></pre>"},{"location":"dp_knapsack_unbounded/#0279-perfect-squares","title":"0279. Perfect Squares","text":"<pre><code>import math\n\n\ndef numSquares(n: int) -&gt; int:\n    dp = [float(\"inf\") for _ in range(n + 1)]\n    dp[0] = 0\n\n    for i in range(1, n + 1):\n        for j in range(1, int(math.sqrt(n)) + 1):\n            dp[i] = min(dp[i], dp[i - j**2] + 1)\n\n    return dp[n]\n\n\nn = 12\nprint(numSquares(n))  # 3\n</code></pre>"},{"location":"dp_knapsack_unbounded/#0322-coin-change","title":"0322. Coin Change","text":"<pre><code>from typing import List\n\n\ndef coinChange(coins: List[int], amount: int) -&gt; int:\n    dp = [float(\"inf\") for _ in range(amount + 1)]\n\n    dp[0] = 0\n\n    for i in range(1, amount + 1):\n        for c in coins:\n            if i - c &gt;= 0:\n                dp[i] = min(dp[i], 1 + dp[i - c])\n\n    return dp[amount] if dp[amount] != float(\"inf\") else -1\n\n\ncoins = [1, 2, 5]\namount = 11\nprint(coinChange(coins, amount))  # 3\n</code></pre>"},{"location":"dp_knapsack_unbounded/#0518-coin-change-2","title":"0518. Coin Change 2","text":"<pre><code>from typing import List\n\n\ndef change(amount: int, coins: List[int]) -&gt; int:\n    dp = [0 for _ in range(amount + 1)]\n    dp[0] = 1\n\n    for i in range(len(coins)):\n        for j in range(coins[i], amount + 1):\n            dp[j] += dp[j - coins[i]]\n\n    return dp[-1]\n\n\namount = 5\ncoins = [1, 2, 5]\nprint(change(amount, coins))  # 4\n</code></pre>"},{"location":"dp_knapsack_unbounded/#0377-combination-sum-iv","title":"0377. Combination Sum IV","text":"<pre><code>from typing import List\n\n\ndef combinationSum4(nums: List[int], target: int) -&gt; int:\n    dp = [0 for _ in range(target + 1)]\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for j in range(len(nums)):\n            if i - nums[j] &gt;= 0:\n                dp[i] += dp[i - nums[j]]\n\n        return dp[target]\n\n\nnums = [1, 2, 3]\ntarget = 4\nprint(combinationSum4(nums, target))  # 7\n</code></pre>"},{"location":"dp_lcs/","title":"Dynamic Programming - Longest Common Subsequence","text":"<ol> <li>1143 - Longest Common Subsequence (Medium)</li> <li>0005 - Longest Palindromic Substring (Medium)</li> <li>0072 - Edit Distance (Hard)</li> <li>0115 - Distinct Subsequences (Hard)</li> <li>0392 - Is Subsequence (Easy)</li> <li>0583 - Delete Operation for Two Strings (Medium)</li> <li>0674 - Longest Continuous Increasing Subsequence (Easy)</li> <li>0718 - Maximum Length of Repeated Subarray (Medium)</li> <li>1035 - Uncrossed Lines (Medium)</li> </ol>"},{"location":"dp_lcs/#1143-longest-common-subsequence","title":"1143. Longest Common Subsequence","text":"<pre><code># DP - LCS\ndef longestCommonSubsequence(text1: str, text2: str) -&gt; int:\n    # TC: O(m * n)\n    # SC: O(m * n)\n    m = len(text1)\n    n = len(text2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    length = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i - 1] == text2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])\n            if length &lt; dp[i][j]:\n                length = dp[i][j]\n\n    return length\n\n\ntext1 = \"abcde\"\ntext2 = \"ace\"\nprint(longestCommonSubsequence(text1, text2))  # 3\n</code></pre>"},{"location":"dp_lcs/#5-longest-palindromic-substring","title":"5. Longest Palindromic Substring","text":"<pre><code># DP - LCS\ndef longestPalindrome(s: str) -&gt; str:\n    n = len(s)\n    if n &lt;= 1:\n        return s\n\n    start, maxLen = 0, 1\n    dp = [[False] * n for _ in range(n)]\n\n    for i in range(n):\n        dp[i][i] = True\n\n    for j in range(1, n):\n        for i in range(j):\n            if s[i] == s[j]:\n                if j - i &lt;= 2:\n                    dp[i][j] = True\n                else:\n                    dp[i][j] = dp[i + 1][j - 1]\n\n                if dp[i][j] and j - i + 1 &gt; maxLen:\n                    maxLen = j - i + 1\n                    start = i\n\n    return s[start : start + maxLen]\n\n\ns = \"babad\"\nprint(longestPalindrome(s))  # \"bab\" or \"aba\"\n</code></pre>"},{"location":"dp_lcs/#72-edit-distance","title":"72. Edit Distance","text":"<pre><code>def minDistance(word1: str, word2: str) -&gt; int:\n    m = len(word1)\n    n = len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]  # no operation\n            else:\n                dp[i][j] = 1 + min(\n                    dp[i - 1][j],  # delete\n                    dp[i][j - 1],  # insert\n                    dp[i - 1][j - 1],  # replace\n                )\n    return dp[-1][-1]\n\n\nword1 = \"horse\"\nword2 = \"ros\"\nprint(minDistance(word1, word2))  # 3\n</code></pre>"},{"location":"dp_lcs/#115-distinct-subsequences","title":"115. Distinct Subsequences","text":"<pre><code>def numDistinct(s: str, t: str) -&gt; int:\n    m = len(s)\n    n = len(t)\n    dp = [[0] * (n + 1) for _ in range((m + 1))]\n\n    for i in range(m):\n        dp[i][0] = 1\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                # include and exclude s[i-1]\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]  # exclude s[i-1]\n\n    return dp[-1][-1]\n\n\ns = \"rabbbit\"\nt = \"rabbit\"\nprint(numDistinct(s, t))  # 3\n</code></pre>"},{"location":"dp_lcs/#392-is-subsequence","title":"392. Is Subsequence","text":"<pre><code># DP - LCS\ndef isSubsequenceLCS(s: str, t: str) -&gt; bool:\n    m = len(s)\n    n = len(t)\n\n    if m &gt; n:\n        return False\n\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    length = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = dp[i][j - 1]  # only delete t string\n\n            if length &lt; dp[i][j]:\n                length = dp[i][j]\n\n    return length == m\n\n\n# Two Pointers\ndef isSubsequenceTP(s: str, t: str) -&gt; bool:\n    i, j = 0, 0\n\n    while i &lt; len(s) and j &lt; len(t):\n        if s[i] == t[j]:\n            i += 1\n        j += 1\n\n    return i == len(s)\n\n\ns = \"abc\"\nt = \"ahbgdc\"\nprint(isSubsequenceLCS(s, t))  # True\nprint(isSubsequenceTP(s, t))  # True\n</code></pre>"},{"location":"dp_lcs/#583-delete-operation-for-two-strings","title":"583. Delete Operation for Two Strings","text":"<pre><code># DP - LCS\ndef minDistance1(word1: str, word2: str) -&gt; int:\n    m = len(word1)\n    n = len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]  # no need to delete\n            else:\n                dp[i][j] = min(\n                    dp[i - 1][j] + 1,  # delete word1[i]\n                    dp[i][j - 1] + 1,  # delete word2[j]\n                    dp[i - 1][j - 1] + 2,  # delete both\n                )\n    return dp[-1][-1]\n\n\n# DP - LCS\ndef minDistance2(word1: str, word2: str) -&gt; int:\n    def LCS(word1: str, word2: str) -&gt; int:\n        m = len(word1)\n        n = len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        lcs = 0\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n                if lcs &lt; dp[i][j]:\n                    lcs = dp[i][j]\n        return lcs\n\n    lcs = LCS(word1, word2)\n    return len(word1) + len(word2) - 2 * lcs\n\n\nword1 = \"sea\"\nword2 = \"eat\"\nprint(minDistance1(word1, word2))  # 2\nprint(minDistance2(word1, word2))  # 2\n</code></pre>"},{"location":"dp_lcs/#674-longest-continuous-increasing-subsequence","title":"674. Longest Continuous Increasing Subsequence","text":"<pre><code>from typing import List\n\n\ndef findLengthOfLCIS(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return n\n\n    dp = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        if nums[i] &gt; nums[i - 1]:\n            dp[i] = dp[i - 1] + 1\n\n    return max(dp)\n\n\nprint(findLengthOfLCIS([1, 3, 5, 4, 7]))  # 3\n</code></pre>"},{"location":"dp_lcs/#718-maximum-length-of-repeated-subarray","title":"718. Maximum Length of Repeated Subarray","text":"<pre><code>from typing import List\n\n\ndef findLength(nums1: List[int], nums2: List[int]) -&gt; int:\n    m = len(nums1)\n    n = len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    length = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if nums1[i - 1] == nums2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            if length &lt; dp[i][j]:\n                length = dp[i][j]\n\n    return length\n\n\nprint(findLength([1, 2, 3, 2, 1], [3, 2, 1, 4, 7]))  # 3\n</code></pre>"},{"location":"dp_lcs/#1035-uncrossed-lines","title":"1035. Uncrossed Lines","text":"<pre><code>from typing import List\n\n\ndef maxUncrossedLines(nums1: List[int], nums2: List[int]) -&gt; int:\n    m = len(nums1)\n    n = len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    num = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if nums1[i - 1] == nums2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n            if num &lt; dp[i][j]:\n                num = dp[i][j]\n\n    return num\n\n\nprint(maxUncrossedLines([1, 4, 2], [1, 2, 4]))  # 2\n</code></pre>"},{"location":"dp_lis/","title":"Dynamic Programming - Longest Increasing Subsequence","text":"<ol> <li>0300 - Longest Increasing Subsequence (Medium)</li> <li>0673 - Number of Longest Increasing Subsequence (Medium)</li> <li>0354 - Russian Doll Envelopes (Hard)</li> <li>0960 - Delete Columns to Make Sorted III (Hard)</li> <li>1671 - Minimum Number of Removals to Make Mountain Array (Hard)</li> </ol>"},{"location":"dp_lis/#300-longest-increasing-subsequence","title":"300. Longest Increasing Subsequence","text":"<pre><code>from typing import List\n\n\n# DP - LIS\ndef lengthOfLIS(nums: List[int]) -&gt; int:\n    # TC: O(n^2)\n    # SC: O(n)\n    n = len(nums)\n    if n &lt;= 1:\n        return n\n\n    dp = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] &gt; nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\n\nnums = [10, 9, 2, 5, 3, 7, 101, 18]\nprint(lengthOfLIS(nums))  # 4\n</code></pre>"},{"location":"dp_lis/#673-number-of-longest-increasing-subsequence","title":"673. Number of Longest Increasing Subsequence","text":""},{"location":"dp_lis/#354-russian-doll-envelopes","title":"354. Russian Doll Envelopes","text":""},{"location":"dp_lis/#960-delete-columns-to-make-sorted-iii","title":"960. Delete Columns to Make Sorted III","text":""},{"location":"dp_lis/#1671-minimum-number-of-removals-to-make-mountain-array","title":"1671. Minimum Number of Removals to Make Mountain Array","text":""},{"location":"dp_stock/","title":"Dynamic Programming - Stock","text":"<ol> <li>0121 - Best Time to Buy and Sell Stock (Easy)</li> <li>0122 - Best Time to Buy and Sell Stock II (Medium)</li> <li>0123 - Best Time to Buy and Sell Stock III (Hard)</li> <li>0188 - Best Time to Buy and Sell Stock IV (Hard)</li> <li>0309 - Best Time to Buy and Sell Stock with Cooldown (Medium)</li> <li>0714 - Best Time to Buy and Sell Stock with Transaction Fee (Medium)</li> </ol>"},{"location":"dp_stock/#121-best-time-to-buy-and-sell-stock","title":"121. Best Time to Buy and Sell Stock","text":"<pre><code>from typing import List\n\n\n# 1. Brute Force: O(n^2)\ndef maxProfitBF(prices: List[int]) -&gt; int:\n    # TC: O(n^2)\n    # SC: O(1)\n    maxProfit = 0\n    n = len(prices)\n    for i in range(n):\n        for j in range(i + 1, n):\n            maxProfit = max(maxProfit, prices[j] - prices[i])\n\n    return maxProfit\n\n\n# 2. DP\ndef maxProfitDP(prices: List[int]) -&gt; int:\n    # TC: O(n)\n    # SC: O(n)\n    dp = [[0] * 2 for _ in range(len(prices))]\n    dp[0][0] = -prices[0]  # buy\n    dp[0][1] = 0  # sell\n\n    for i in range(1, len(prices)):\n        dp[i][0] = max(dp[i - 1][0], -prices[i])  # the lowest price to buy\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# 3. Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    # TC: O(n)\n    # SC: O(1)\n    maxProfit = 0\n    seenMin = prices[0]\n\n    for i in range(1, len(prices)):\n        maxProfit = max(maxProfit, prices[i] - seenMin)\n        seenMin = min(seenMin, prices[i])\n\n    return maxProfit\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitBF(prices))  # 5\nprint(maxProfitDP(prices))  # 5\nprint(maxProfitGreedy(prices))  # 5\n</code></pre>"},{"location":"dp_stock/#122-best-time-to-buy-and-sell-stock-ii","title":"122. Best Time to Buy and Sell Stock II","text":"<pre><code>from typing import List\n\n\n# 1. DP\ndef maxProfitDP1(prices: List[int]) -&gt; int:\n    # TC: O(n)\n    # SC: O(n)\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 2 for _ in range(n)]\n    dp[0][0] = -prices[0]\n    dp[0][1] = 0\n\n    for i in range(1, n):\n        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i])\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# 2. DP - Optimized\ndef maxProfitDP2(prices: List[int]) -&gt; int:\n    # TC: O(n)\n    # SC: O(1)\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    hold = -prices[0]\n    profit = 0\n\n    for i in range(1, n):\n        hold = max(hold, profit - prices[i])\n        profit = max(profit, hold + prices[i])\n\n    return profit\n\n\n# 3. Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    # TC: O(n)\n    # SC: O(1)\n    profit = 0\n\n    for i in range(1, len(prices)):\n        profit += max(prices[i] - prices[i - 1], 0)\n\n    return profit\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitDP1(prices))  # 7\nprint(maxProfitDP2(prices))  # 7\nprint(maxProfitGreedy(prices))  # 7\n</code></pre>"},{"location":"dp_stock/#123-best-time-to-buy-and-sell-stock-iii","title":"123. Best Time to Buy and Sell Stock III","text":"<pre><code>from typing import List\n\n\n# 1. DP\ndef maxProfitDP1(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 5 for _ in range(n)]\n\n    dp[0][0] = 0  # no transaction\n    dp[0][1] = -prices[0]  # buy 1\n    dp[0][2] = 0  # sell 1\n    dp[0][3] = -prices[0]  # buy 2\n    dp[0][4] = 0  # sell 2\n\n    for i in range(1, n):\n        dp[i][0] = dp[i - 1][0]\n        dp[i][1] = max(dp[i - 1][1], -prices[i])\n        dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i])\n        dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i])\n        dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i])\n\n    return dp[-1][4]\n\n\n# 2. DP - Optimized\ndef maxProfitDP2(prices: List[int]) -&gt; int:\n    b1, b2 = float(\"inf\"), float(\"inf\")\n    s1, s2 = 0, 0\n\n    for price in prices:\n        b1 = min(b1, price)\n        s1 = max(s1, price - b1)\n        b2 = min(b2, price - s1)\n        s2 = max(s2, price - b2)\n\n    return s2\n\n\nprices = [3, 3, 5, 0, 0, 3, 1, 4]\nprint(maxProfitDP1(prices))  # 6\nprint(maxProfitDP2(prices))  # 6\n</code></pre>"},{"location":"dp_stock/#188-best-time-to-buy-and-sell-stock-iv","title":"188. Best Time to Buy and Sell Stock IV","text":"<pre><code>from typing import List\n\n\n# DP\ndef maxProfit(k: int, prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * (2 * k + 1) for _ in range(n)]\n\n    for j in range(1, 2 * k, 2):\n        dp[0][j] = -prices[0]\n\n    for i in range(1, n):\n        for j in range(0, 2 * k - 1, 2):\n            dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i])\n            dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i])\n\n    return dp[-1][2 * k]\n\n\nk = 2\nprices = [2, 4, 1]\nprint(maxProfit(k, prices))  # 2\n</code></pre>"},{"location":"dp_stock/#309-best-time-to-buy-and-sell-stock-with-cooldown","title":"309. Best Time to Buy and Sell Stock with Cooldown","text":"<pre><code>from typing import List\n\n\n# DP\ndef maxProfit(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 4 for _ in range(n)]\n\n    dp[0][0] = -prices[0]  # poessess\n    dp[0][1] = 0  # stay sold\n    dp[0][2] = 0  # sell\n    dp[0][3] = 0  # cooldown\n\n    for i in range(1, n):\n        dp[i][0] = max(\n            dp[i - 1][0],  # stay poessess\n            dp[i - 1][1] - prices[i],  # buy after stay sold\n            dp[i - 1][3] - prices[i],  # buy after cooldown\n        )\n        dp[i][1] = max(\n            dp[i - 1][1],  # stay sold\n            dp[i - 1][3],  # stay cooldown\n        )\n        dp[i][2] = dp[i - 1][0] + prices[i]\n        dp[i][3] = dp[i - 1][2]\n\n    return max(dp[-1])\n\n\nprices = [1, 2, 3, 0, 2]\nprint(maxProfit(prices))  # 3\n</code></pre>"},{"location":"dp_stock/#714-best-time-to-buy-and-sell-stock-with-transaction-fee","title":"714. Best Time to Buy and Sell Stock with Transaction Fee","text":"<pre><code>from typing import List\n\n\n# 1. DP\ndef maxProfitDP(prices: List[int], fee: int) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 2 for _ in range(n)]\n\n    dp[0][0] = -prices[0] - fee\n    dp[0][1] = 0\n\n    for i in range(1, n):\n        dp[i][0] = max(\n            dp[i - 1][0],  # hold\n            dp[i - 1][1] - prices[i] - fee,  # buy\n        )\n        dp[i][1] = max(\n            dp[i - 1][1],  # hold\n            dp[i - 1][0] + prices[i],  # sell\n        )\n\n    return max(dp[-1])\n\n\n# 2. Greedy\ndef maxProfitGreedy(prices: List[int], fee: int) -&gt; int:\n    n = len(prices)\n    if n == 0:\n        return 0\n\n    buy = prices[0]\n    profit = 0\n\n    for i in range(1, n):\n        if prices[i] &lt; buy:\n            buy = prices[i]\n        elif prices[i] &gt; buy + fee:\n            profit += prices[i] - buy - fee\n            buy = prices[i] - fee\n\n    return profit\n\n\nprices = [1, 3, 2, 8, 4, 9]\nfee = 2\nprint(maxProfitDP(prices, fee))  # 8\nprint(maxProfitGreedy(prices, fee))  # 8\n</code></pre>"},{"location":"fast_slow_pointers/","title":"Fast Slow Pointers","text":"<ol> <li>0027 - Remove Element (Easy)</li> <li>0026 - Remove Duplicates from Sorted Array (Easy)</li> <li>0080 - Remove Duplicates from Sorted Array II (Medium)</li> <li>0283 - Move Zeroes (Easy)</li> <li>1089 - Duplicate Zeros (Easy)</li> <li>0287 - Find the Duplicate Number (Medium)</li> </ol>"},{"location":"fast_slow_pointers/#array-resources","title":"Array Resources","text":"<ul> <li>[Leetcode Discuss] Solved all two pointers problems in 100 days</li> </ul>"},{"location":"fast_slow_pointers/#27-remove-element","title":"27. Remove Element","text":"<ul> <li>Remove all instances of a given value in-place.</li> </ul> <pre><code>from typing import List\n\n\ndef removeElement(nums: List[int], val: int) -&gt; int:\n    fast, slow = 0, 0\n\n    while fast &lt; len(nums):\n        if nums[fast] != val:\n            nums[slow] = nums[fast]\n            slow += 1\n        fast += 1\n\n    return slow\n\n\nnums = [3, 2, 2, 3]\nval = 3\nprint(removeElement(nums, val))  # 2\n</code></pre>"},{"location":"fast_slow_pointers/#26-remove-duplicates-from-sorted-array","title":"26. Remove Duplicates from Sorted Array","text":"<ul> <li>Remove duplicates in-place.</li> </ul> <pre><code>from typing import List\n\n\ndef removeDuplicates(nums: List[int]) -&gt; int:\n    fast, slow = 1, 1\n\n    while fast &lt; len(nums):\n        if nums[fast] != nums[fast - 1]:\n            nums[slow] = nums[fast]\n            slow += 1\n        fast += 1\n\n    return slow\n\n\nnums = [1, 1, 2]\nprint(removeDuplicates(nums))  # 2\n</code></pre>"},{"location":"fast_slow_pointers/#80-remove-duplicates-from-sorted-array-ii","title":"80. Remove Duplicates from Sorted Array II","text":"<ul> <li>Allow at most two duplicates.</li> <li>fast pointer: explore the array</li> <li>slow pointer: point to the position to be replaced</li> </ul> <pre><code>from typing import List\n\n\ndef removeDuplicates(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 2:\n        return len(nums)\n\n    fast, slow = 2, 2\n\n    while fast &lt; len(nums):\n        if nums[fast] != nums[slow - 2]:\n            nums[slow] = nums[fast]\n            slow += 1\n        fast += 1\n\n    return slow\n\n\nnums = [1, 1, 1, 2, 2, 3]\nprint(removeDuplicates(nums))\n</code></pre>"},{"location":"fast_slow_pointers/#283-move-zeroes","title":"283. Move Zeroes","text":"<ul> <li>Move all zeroes to the end of the array while maintaining the relative order of the non-zero elements.</li> </ul> <pre><code>from typing import List\n\n\ndef moveZeroes(nums: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    fast, slow = 0, 0\n\n    while fast &lt; len(nums):\n        if nums[fast] != 0:\n            nums[slow], nums[fast] = nums[fast], nums[slow]\n            slow += 1\n        fast += 1\n\n\nnums = [0, 1, 0, 3, 12]\nmoveZeroes(nums)\nprint(nums)  # [1, 3, 12, 0, 0]\n</code></pre>"},{"location":"fast_slow_pointers/#1089-duplicate-zeros","title":"1089. Duplicate Zeros","text":"<ul> <li>Duplicate each occurrence of zero, shifting the remaining elements to the right.</li> </ul> <pre><code>from typing import List\n\n\ndef duplicateZeros(arr: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify arr in-place instead.\n    \"\"\"\n    n = len(arr)\n    fast, slow = 0, 0\n\n    # First pass: find the position\n    # where the last element would be in the expanded array\n    while fast &lt; n:\n        if arr[slow] == 0:\n            fast += 1\n        slow += 1\n        fast += 1\n\n    slow -= 1\n    fast -= 1\n\n    # Second pass: move elements backwards\n    while slow &gt;= 0:\n        if fast &lt; n:\n            arr[fast] = arr[slow]\n\n        if arr[slow] == 0:\n            fast -= 1\n            if fast &lt; n:\n                arr[fast] = 0\n\n        slow -= 1\n        fast -= 1\n\n\narr = [1, 0, 2, 3, 0, 4, 5, 0]\nduplicateZeros(arr)\nprint(arr)  # [1, 0, 0, 2, 3, 0, 0, 4]\n</code></pre>"},{"location":"fast_slow_pointers/#287-find-the-duplicate-number","title":"287. Find the Duplicate Number","text":"<ul> <li>Find the duplicate number in an array containing <code>n + 1</code> integers where each integer is between <code>1</code> and <code>n</code> inclusive.</li> </ul> <pre><code>from typing import List\n\n\ndef findDuplicate(nums: List[int]) -&gt; int:\n\n    fast, slow = nums[0], nums[0]\n\n    while True:\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n        if slow == fast:\n            break\n\n    slow = nums[0]\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[fast]\n\n    return slow\n\n\n# Time complexity: O(n)\n# Space complexity: O(1)\n\nnums = [1, 3, 4, 2, 2]\nprint(findDuplicate(nums))  # 2\n</code></pre>"},{"location":"graph_bellman_ford/","title":"Graph - Bellman-Ford Algorithm","text":"<ul> <li>The Bellman-Ford algorithm is used to find the shortest path from a source vertex to all other vertices in a weighted graph.</li> <li>It is slower than Dijkstra's algorithm, but it is more versatile, as it is able to handle graphs with negative edge weights.</li> <li>Time Complexity: O(V * E), where V is the number of vertices and E is the number of edges in the graph.</li> <li>Space Complexity: O(V), where V is the number of vertices in the graph.</li> </ul>"},{"location":"graph_bellman_ford/#problems","title":"Problems","text":"<ol> <li>0743 - Network Delay Time (Medium)</li> <li>0787 - Cheapest Flights Within K Stops (Medium)</li> <li>0207 - Course Schedule (Medium)</li> <li>1109 - Corporate Flight Bookings (Medium)</li> </ol>"},{"location":"graph_bellman_ford/#743-network-delay-time","title":"743. Network Delay Time","text":"<ul> <li>Return the minimum time taken to reach all nodes starting from the source node.</li> </ul> <pre><code>from collections import defaultdict\nfrom heapq import heappop, heappush\nfrom typing import List\n\n\n# 1. Dijkstra - Set\ndef networkDelayTime1(times: List[List[int]], n: int, k: int) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    minHeap = [(0, k)]  # (weight, node)\n    visited = set()\n    delay = 0\n\n    while minHeap:\n        cur, u = heappop(minHeap)\n\n        if u in visited:\n            continue\n        visited.add(u)\n\n        delay = max(delay, cur)\n\n        for v, w in graph[u]:\n            if v not in visited:\n                heappush(minHeap, (cur + w, v))\n\n    return delay if len(visited) == n else -1\n\n\n# 2. Dijkstra - Dict\ndef networkDelayTime2(times: List[List[int]], n: int, k: int) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    minHeap = [(0, k)]  # (weight, node)\n    dist = defaultdict(int)\n    dist[k] = 0\n\n    while minHeap:\n        cur, u = heappop(minHeap)\n\n        if cur &gt; dist[u]:\n            continue\n\n        for v, w in graph[u]:\n            path = cur + w\n            if v not in dist or path &lt; dist[v]:\n                dist[v] = path\n                heappush(minHeap, (path, v))\n\n    return max(dist.values()) if len(dist) == n else -1\n\n\n# 3. Bellman-Ford\ndef networkDelayTimeBF(times: List[List[int]], n: int, k: int) -&gt; int:\n    # TC: O(N * E)\n    # SC: O(N)\n\n    dist = [float(\"inf\")] * n\n    dist[k - 1] = 0\n\n    for _ in range(n - 1):\n        for u, v, w in times:\n            if dist[u - 1] + w &lt; dist[v - 1]:\n                dist[v - 1] = dist[u - 1] + w\n\n    if any(d == float(\"inf\") for d in dist):\n        return -1\n\n    return max(dist)\n\n\ntimes = [[2, 1, 1], [2, 3, 1], [3, 4, 1]]\nn = 4\nk = 2\nprint(networkDelayTime1(times, n, k))  # 2\nprint(networkDelayTime2(times, n, k))  # 2\nprint(networkDelayTimeBF(times, n, k))  # 2\n</code></pre>"},{"location":"graph_bellman_ford/#787-cheapest-flights-within-k-stops","title":"787. Cheapest Flights Within K Stops","text":"<ul> <li>Return the cheapest price to reach the destination within K stops.</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# Bellman-Ford\ndef findCheapestPriceBF(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    dist = [float(\"inf\")] * n\n    dist[src] = 0\n\n    for _ in range(k + 1):\n        temp = dist[:]\n        for u, v, w in flights:\n            temp[v] = min(temp[v], dist[u] + w)\n        dist = temp\n\n    return dist[dst] if dist[dst] != float(\"inf\") else -1\n\n\nn = 4\nflights = [[0, 1, 100], [1, 2, 100], [2, 0, 100], [1, 3, 600], [2, 3, 200]]\nsrc = 0\ndst = 3\nk = 1\nprint(findCheapestPriceBF(n, flights, src, dst, k))  # 700\n</code></pre>"},{"location":"graph_bellman_ford/#207-course-schedule","title":"207. Course Schedule","text":"<ul> <li>Return whether it is possible to finish all courses.</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# 1. BFS - Kahn's Algorithm\ndef canFinishBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    adj = defaultdict(list)\n    indegree = [0] * numCourses\n\n    for crs, pre in prerequisites:\n        adj[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    count = 0\n\n    while q:\n        crs = q.popleft()\n        count += 1\n\n        for next in adj[crs]:\n            indegree[next] -= 1\n\n            if indegree[next] == 0:\n                q.append(next)\n\n    return count == numCourses\n\n\n# 2. DFS + Set\ndef canFinishDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    adj = defaultdict(list)\n    for crs, pre in prerequisites:\n        adj[crs].append(pre)\n\n    visited = set()\n\n    def dfs(crs):\n        if crs in visited:  # cycle detected\n            return False\n        if adj[crs] == []:\n            return True\n\n        visited.add(crs)\n\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        visited.remove(crs)\n        adj[crs] = []\n\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\n# 3. DFS + List\ndef canFinishDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    adj = defaultdict(list)\n    for pre, crs in prerequisites:\n        adj[crs].append(pre)\n\n    # 0: not visited, 1: visiting, 2: visited\n    visited = [0] * numCourses\n\n    def dfs(crs):\n        if visited[crs] == 1:  # cycle detected\n            return False\n        if visited[crs] == 2:\n            return True\n\n        visited[crs] = 1\n\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        visited[crs] = 2\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(canFinishBFS(5, prerequisites))  # True\nprint(canFinishDFS1(5, prerequisites))  # True\nprint(canFinishDFS2(5, prerequisites))  # True\n</code></pre>"},{"location":"graph_bellman_ford/#1109-corporate-flight-bookings","title":"1109. Corporate Flight Bookings","text":"<ul> <li>Return the number of seats booked on each flight.</li> </ul>"},{"location":"graph_bfs/","title":"Graph - Breadth First Search","text":"<ol> <li>0994 - Rotting Oranges (Medium)</li> <li>0127 - Word Ladder (Hard)</li> <li>1466 - Reorder Routes to Make All Paths Lead to the City Zero (Medium)</li> <li>0286 - Walls and Gates (Medium)</li> </ol>"},{"location":"graph_bfs/#994-rotting-oranges","title":"994. Rotting Oranges","text":"<ul> <li>Return the minimum number of minutes that must elapse until no cell has a fresh orange.</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\ndef orangesRotting(grid: List[List[int]]) -&gt; int:\n    q = deque()\n    time, fresh = 0, 0\n    m, n = len(grid), len(grid[0])\n    directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                fresh += 1\n            if grid[r][c] == 2:\n                q.append([r, c])\n\n    while q and fresh &gt; 0:\n        for _ in range(len(q)):\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr, nc = row + dr, col + dc\n                if nr in range(m) and nc in range(n) and grid[nr][nc] == 1:\n                    grid[nr][nc] = 2\n                    q.append([nr, nc])\n                    fresh -= 1\n        time += 1\n\n    return time if fresh == 0 else -1\n\n\ngrid = [[2, 1, 1], [1, 1, 0], [0, 1, 1]]\nprint(orangesRotting(grid))\n</code></pre>"},{"location":"graph_bfs/#127-word-ladder","title":"127. Word Ladder","text":"<ul> <li>Return the length of the shortest transformation sequence from <code>beginWord</code> to <code>endWord</code>.</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef ladderLength(beginWord: str, endWord: str, wordList: List[str]) -&gt; int:\n    # TC: O(N * M^2)\n    # SC: O(N * M)\n    # N = len(wordList), M = len(word)\n\n    if endWord not in wordList:\n        return 0\n\n    adj = defaultdict(list)  # {pattern: [word1, word2, ...]}\n    wordList.append(beginWord)\n\n    for word in wordList:\n        for j in range(len(word)):\n            pattern = word[:j] + \"*\" + word[j + 1 :]\n            adj[pattern].append(word)\n\n    visited = set([beginWord])\n    q = deque([beginWord])\n    steps = 1\n\n    while q:\n        for _ in range(len(q)):\n            word = q.popleft()\n            if word == endWord:\n                return steps\n\n            for j in range(len(word)):\n                pattern = word[:j] + \"*\" + word[j + 1 :]\n                for neighbor in adj[pattern]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        q.append(neighbor)\n        steps += 1\n\n    return 0\n\n\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]\nprint(ladderLength(beginWord, endWord, wordList))  # 5\n</code></pre>"},{"location":"graph_bfs/#1466-reorder-routes-to-make-all-paths-lead-to-the-city-zero","title":"1466. Reorder Routes to Make All Paths Lead to the City Zero","text":"<ul> <li>Return the minimum number of connections needed to connect all the cities such that all the roads are used in the right direction.</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef minReorderBFS(n: int, connections: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append((v, 1))  # go\n        graph[v].append((u, 0))  # come\n\n    changes = 0\n    q = deque([(0, -1)])\n\n    while q:\n        node, parent = q.popleft()\n\n        for child, direction in graph[node]:\n            if child != parent:\n                changes += direction\n                q.append((child, node))\n\n    return changes\n\n\n# DFS\ndef minReorderDFS(n: int, connections: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append((v, 1))  # go\n        graph[v].append((u, 0))  # come\n\n    def dfs(node, parent):\n        changes = 0\n        for child, direction in graph[node]:\n            if child != parent:\n                changes += direction + dfs(child, node)\n        return changes\n\n    return dfs(0, -1)\n\n\nn = 5\nconnections = [[1, 0], [1, 2], [3, 2], [3, 4]]\nprint(minReorderBFS(n, connections))  # 2\nprint(minReorderDFS(n, connections))  # 2\n</code></pre>"},{"location":"graph_bfs/#286-walls-and-gates","title":"286. Walls and Gates","text":"<ul> <li>Fill each empty room with the distance to its nearest gate.</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# Multi-source BFS\ndef wallsAndGates(rooms: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify rooms in-place instead.\n    \"\"\"\n    m, n = len(rooms), len(rooms[0])\n    visited = set()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def addRoom(r, c):\n        if (\n            r in range(m)\n            and c in range(n)\n            and (r, c) not in visited\n            and rooms[r][c] != -1\n        ):\n            q.append((r, c))\n            visited.add((r, c))\n\n    q = deque()\n    for r in range(m):\n        for c in range(n):\n            if rooms[r][c] == 0:\n                q.append((r, c))\n                visited.add((r, c))\n\n    dist = 0\n\n    while q:\n        for _ in range(len(q)):\n            r, c = q.popleft()\n            rooms[r][c] = dist\n\n            for dr, dc in directions:\n                addRoom(r + dr, c + dc)\n        dist += 1\n\n\nrooms = [\n    [2147483647, -1, 0, 2147483647],\n    [2147483647, 2147483647, 2147483647, -1],\n    [2147483647, -1, 2147483647, -1],\n    [0, -1, 2147483647, 2147483647],\n]\nwallsAndGates(rooms)\nprint(rooms)\n# [[3, -1, 0,  1],\n#  [2,  2, 1, -1],\n#  [1, -1, 2, -1],\n#  [0, -1, 3,  4]]\n</code></pre>"},{"location":"graph_dfs/","title":"Graph - Depth First Search","text":""},{"location":"graph_dijkstra/","title":"Graph - Dijkstra's Algorithm","text":"<ul> <li>Shortest path algorithm</li> <li>Weighted graph</li> <li>Data Structure: Heap; HashSet</li> <li>Time Complexity: \\(O(E \\log V)\\)</li> <li>Space Complexity: \\(O(V)\\)</li> </ul>"},{"location":"graph_dijkstra/#problems","title":"Problems","text":"<ol> <li>0743 - Network Delay Time (Medium)</li> <li>0778 - Swim in Rising Water (Hard)</li> <li>1631 - Path With Minimum Effort (Medium)</li> <li>0787 - Cheapest Flights Within K Stops (Medium)</li> <li>1514 - Path with Maximum Probability (Medium)</li> <li>0505 - The Maze II (Medium)</li> <li>0499 - The Maze III (Hard)</li> <li>0882 - Reachable Nodes In Subdivided Graph (Hard)</li> <li>1376 - Time Needed to Inform All Employees (Medium)</li> <li>1168 - Optimize Water Distribution in a Village (Hard)</li> <li>1976 - Number of Ways to Arrive at Destination (Hard)</li> </ol>"},{"location":"graph_dijkstra/#743-network-delay-time","title":"743. Network Delay Time","text":"<ul> <li>Return the minimum time taken to reach all nodes in a network.</li> </ul> <pre><code>from collections import defaultdict\nfrom heapq import heappop, heappush\nfrom typing import List\n\n\n# 1. Dijkstra - Set\ndef networkDelayTime1(times: List[List[int]], n: int, k: int) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    minHeap = [(0, k)]  # (weight, node)\n    visited = set()\n    delay = 0\n\n    while minHeap:\n        cur, u = heappop(minHeap)\n\n        if u in visited:\n            continue\n        visited.add(u)\n\n        delay = max(delay, cur)\n\n        for v, w in graph[u]:\n            if v not in visited:\n                heappush(minHeap, (cur + w, v))\n\n    return delay if len(visited) == n else -1\n\n\n# 2. Dijkstra - Dict\ndef networkDelayTime2(times: List[List[int]], n: int, k: int) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    minHeap = [(0, k)]  # (weight, node)\n    dist = defaultdict(int)\n    dist[k] = 0\n\n    while minHeap:\n        cur, u = heappop(minHeap)\n\n        if cur &gt; dist[u]:\n            continue\n\n        for v, w in graph[u]:\n            path = cur + w\n            if v not in dist or path &lt; dist[v]:\n                dist[v] = path\n                heappush(minHeap, (path, v))\n\n    return max(dist.values()) if len(dist) == n else -1\n\n\n# 3. Bellman-Ford\ndef networkDelayTimeBF(times: List[List[int]], n: int, k: int) -&gt; int:\n    # TC: O(N * E)\n    # SC: O(N)\n\n    dist = [float(\"inf\")] * n\n    dist[k - 1] = 0\n\n    for _ in range(n - 1):\n        for u, v, w in times:\n            if dist[u - 1] + w &lt; dist[v - 1]:\n                dist[v - 1] = dist[u - 1] + w\n\n    if any(d == float(\"inf\") for d in dist):\n        return -1\n\n    return max(dist)\n\n\ntimes = [[2, 1, 1], [2, 3, 1], [3, 4, 1]]\nn = 4\nk = 2\nprint(networkDelayTime1(times, n, k))  # 2\nprint(networkDelayTime2(times, n, k))  # 2\nprint(networkDelayTimeBF(times, n, k))  # 2\n</code></pre>"},{"location":"graph_dijkstra/#778-swim-in-rising-water","title":"778. Swim in Rising Water","text":"<ul> <li>Return the minimum time when you can reach the target.</li> </ul> <pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra's\ndef swimInWater(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    visited = set()\n    minHeap = [(grid[0][0], 0, 0)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    visited.add((0, 0))\n\n    while minHeap:\n        time, r, c = heapq.heappop(minHeap)\n\n        if r == n - 1 and c == n - 1:\n            return time\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if nr in range(n) and nc in range(n) and (nr, nc) not in visited:\n                visited.add((nr, nc))\n                heapq.heappush(minHeap, (max(time, grid[nr][nc]), nr, nc))\n\n\ngrid = [\n    [0, 1, 2, 3, 4],\n    [24, 23, 22, 21, 5],\n    [12, 13, 14, 15, 16],\n    [11, 17, 18, 19, 20],\n    [10, 9, 8, 7, 6],\n]\nprint(swimInWater(grid))  # 16\n</code></pre>"},{"location":"graph_dijkstra/#1631-path-with-minimum-effort","title":"1631. Path With Minimum Effort","text":"<ul> <li>Return the minimum effort required to travel from the top-left to the bottom-right corner.</li> </ul>"},{"location":"graph_dijkstra/#787-cheapest-flights-within-k-stops","title":"787. Cheapest Flights Within K Stops","text":"<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# Bellman-Ford\ndef findCheapestPriceBF(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    dist = [float(\"inf\")] * n\n    dist[src] = 0\n\n    for _ in range(k + 1):\n        temp = dist[:]\n        for u, v, w in flights:\n            temp[v] = min(temp[v], dist[u] + w)\n        dist = temp\n\n    return dist[dst] if dist[dst] != float(\"inf\") else -1\n\n\nn = 4\nflights = [[0, 1, 100], [1, 2, 100], [2, 0, 100], [1, 3, 600], [2, 3, 200]]\nsrc = 0\ndst = 3\nk = 1\nprint(findCheapestPriceBF(n, flights, src, dst, k))  # 700\n</code></pre>"},{"location":"graph_dijkstra/#1514-path-with-maximum-probability","title":"1514. Path with Maximum Probability","text":""},{"location":"graph_dijkstra/#505-the-maze-ii","title":"505. The Maze II","text":""},{"location":"graph_dijkstra/#499-the-maze-iii","title":"499. The Maze III","text":""},{"location":"graph_dijkstra/#882-reachable-nodes-in-subdivided-graph","title":"882. Reachable Nodes In Subdivided Graph","text":""},{"location":"graph_dijkstra/#1376-time-needed-to-inform-all-employees","title":"1376. Time Needed to Inform All Employees","text":""},{"location":"graph_dijkstra/#1168-optimize-water-distribution-in-a-village","title":"1168. Optimize Water Distribution in a Village","text":""},{"location":"graph_dijkstra/#1976-number-of-ways-to-arrive-at-destination","title":"1976. Number of Ways to Arrive at Destination","text":""},{"location":"graph_flood_fill/","title":"Graph - Flood Fill","text":"<ol> <li>0733 - Flood Fill (Easy)</li> <li>0200 - Number of Islands (Medium)</li> <li>695 - Max Area of Island (Medium)</li> <li>0463 - Island Perimeter (Easy)</li> <li>0130 - Surrounded Regions (Medium)</li> <li>0417 - Pacific Atlantic Water Flow (Medium)</li> </ol>"},{"location":"graph_flood_fill/#733-flood-fill","title":"733. Flood Fill","text":"<ul> <li>Replace all the pixels of the same color starting from the given pixel.</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# 1. DFS\ndef floodFillDFS(\n    image: List[List[int]], sr: int, sc: int, color: int\n) -&gt; List[List[int]]:\n\n    original = image[sr][sc]\n    m, n = len(image), len(image[0])\n\n    if original == color:\n        return image\n\n    def dfs(r, c):\n        if r not in range(m) or c not in range(n) or image[r][c] != original:\n            return None\n\n        image[r][c] = color\n\n        dfs(r - 1, c)\n        dfs(r + 1, c)\n        dfs(r, c - 1)\n        dfs(r, c + 1)\n\n    dfs(sr, sc)\n\n    return image\n\n\n# 2. BFS\ndef floodFillBFS(\n    image: List[List[int]], sr: int, sc: int, color: int\n) -&gt; List[List[int]]:\n\n    original = image[sr][sc]\n    m, n = len(image), len(image[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    if original == color:\n        return image\n\n    q = deque([(sr, sc)])\n\n    while q:\n        row, col = q.popleft()\n        image[row][col] = color\n\n        for dr, dc in directions:\n            nr = row + dr\n            nc = col + dc\n\n            if nr in range(m) and nc in range(n) and image[nr][nc] == original:\n                q.append((nr, nc))\n\n    return image\n\n\nimage = [[1, 1, 1], [1, 1, 0], [1, 0, 1]]\nsr = 1\nsc = 1\n\nprint(floodFillDFS(image, sr, sc, 2))\n# [[2, 2, 2], [2, 2, 0], [2, 0, 1]]\nprint(floodFillBFS(image, sr, sc, 2))\n# [[2, 2, 2], [2, 2, 0], [2, 0, 1]]\n</code></pre>"},{"location":"graph_flood_fill/#200-number-of-islands","title":"200. Number of Islands","text":"<ul> <li>Count the number of islands in a 2D grid.</li> </ul> <pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# 1. DFS\ndef numIslandsDFS(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n    m, n = len(grid), len(grid[0])\n    islands = 0\n\n    def dfs(r, c):\n        if r not in range(m) or c not in range(n) or grid[r][c] == \"0\":\n            return None\n\n        grid[r][c] = \"0\"\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                dfs(r, c)\n                islands += 1\n\n    return islands\n\n\n# 2. BFS + Set\ndef numIslandsBFS1(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    islands = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr = row + dr\n                nc = col + dc\n                if (\n                    nr in range(m)\n                    and nc in range(n)\n                    and grid[nr][nc] == \"1\"\n                    and (nr, nc) not in visited\n                ):\n                    visited.add((nr, nc))\n                    q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\" and (r, c) not in visited:\n                visited.add((r, c))\n                bfs(r, c)\n                islands += 1\n\n    return islands\n\n\n# 3. BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    islands = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr, nc = row + dr, col + dc\n                if nr in range(m) and nc in range(n) and grid[nr][nc] == \"1\":\n                    q.append((nr, nc))\n                    grid[nr][nc] = \"0\"\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                grid[r][c] = \"0\"\n                bfs(r, c)\n                islands += 1\n\n    return islands\n\n\ngrid = [\n    [\"1\", \"1\", \"1\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"0\", \"0\", \"0\", \"0\", \"0\"],\n]\n\nprint(numIslandsDFS(deepcopy(grid)))  # 1\nprint(numIslandsBFS1(deepcopy(grid)))  # 1\nprint(numIslandsBFS2(deepcopy(grid)))  # 1\n</code></pre>"},{"location":"graph_flood_fill/#695-max-area-of-island","title":"695. Max Area of Island","text":"<ul> <li>Find the maximum area of an island in a 2D grid.</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# 1. DFS\ndef maxAreaOfIslandDFS(grid: List[List[int]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    visited = set()\n    area = 0\n\n    def dfs(r, c):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or grid[r][c] == 0\n            or (r, c) in visited\n        ):\n            return 0\n\n        visited.add((r, c))\n        return (\n            1 + dfs(r - 1, c) + dfs(r + 1, c) + dfs(r, c - 1) + dfs(r, c + 1)\n        )\n\n    for r in range(m):\n        for c in range(n):\n            area = max(area, dfs(r, c))\n\n    return area\n\n\n# 2. BFS\ndef maxAreaOfIslandBFS1(grid: List[List[int]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    area = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        subArea = 0\n\n        while q:\n            row, col = q.popleft()\n            subArea += 1\n\n            for dr, dc in directions:\n                nr = row + dr\n                nc = col + dc\n                if (\n                    nr in range(m)\n                    and nc in range(n)\n                    and grid[nr][nc] == 1\n                    and (nr, nc) not in visited\n                ):\n                    visited.add((nr, nc))\n                    q.append((nr, nc))\n\n        return subArea\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1 and (r, c) not in visited:\n                visited.add((r, c))\n                area = max(area, bfs(r, c))\n\n    return area\n\n\n# 3. BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    area = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        subArea = 0\n\n        while q:\n            row, col = q.popleft()\n            subArea += 1\n\n            for dr, dc in directions:\n                nr = row + dr\n                nc = col + dc\n                if nr in range(m) and nc in range(n) and grid[nr][nc] == 1:\n                    q.append((nr, nc))\n                    grid[nr][nc] = 0\n\n        return subArea\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                grid[r][c] = 0\n                area = max(area, bfs(r, c))\n\n    return area\n\n\ngrid = [\n    [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0],\n    [0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],\n]\nprint(maxAreaOfIslandDFS(grid))  # 6\nprint(maxAreaOfIslandBFS1(grid))  # 6\nprint(numIslandsBFS2(grid))  # 6\n</code></pre>"},{"location":"graph_flood_fill/#463-island-perimeter","title":"463. Island Perimeter","text":"<ul> <li>Calculate the perimeter of an island in a 2D grid.</li> </ul> <pre><code>from typing import List\n\n\n# DFS\ndef islandPerimeterDFS(grid: List[List[int]]) -&gt; int:\n    # TC: O(m * n)\n    # SC: O(m * n)\n\n    visited = set()\n    m, n = len(grid), len(grid[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def dfs(r, c):\n        if (r, c) in visited or grid[r][c] == 0:\n            return 0\n        visited.add((r, c))\n        perimeter = 0\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if nr not in range(m) or nc not in range(n) or grid[nr][nc] == 0:\n                perimeter += 1\n            else:\n                perimeter += dfs(nr, nc)\n\n        return perimeter\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                return dfs(r, c)\n    return 0\n\n\ndef islandPerimeter(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    perimeter = 0\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                perimeter += 4\n\n                if r &gt; 0 and grid[r - 1][c] == 1:\n                    perimeter -= 2\n\n                if c &gt; 0 and grid[r][c - 1] == 1:\n                    perimeter -= 2\n\n    return perimeter\n\n\ngrid = [[0, 1, 0, 0], [1, 1, 1, 0], [0, 1, 0, 0], [1, 1, 0, 0]]\nprint(islandPerimeterDFS(grid))  # 16\nprint(islandPerimeter(grid))  # 16\n</code></pre>"},{"location":"graph_flood_fill/#130-surrounded-regions","title":"130. Surrounded Regions","text":"<ul> <li>Replace all the 'O's with 'X's if surrounded by 'X's.</li> </ul> <pre><code>from collections import deque\nfrom copy import deepcopy\nfrom pprint import pprint\nfrom typing import List\n\n\n# 1. DFS\ndef solveDFS(board: List[List[str]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n    if not board and not board[0]:\n        return None\n\n    m, n = len(board), len(board[0])\n\n    def capture(r, c):\n        if r not in range(m) or c not in range(n) or board[r][c] != \"O\":\n            return None\n\n        board[r][c] = \"T\"\n        capture(r + 1, c)\n        capture(r - 1, c)\n        capture(r, c + 1)\n        capture(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\" and (r in [0, m - 1] or c in [0, n - 1]):\n                capture(r, c)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\":\n                board[r][c] = \"X\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"T\":\n                board[r][c] = \"O\"\n\n\n# 2. BFS\ndef solveBFS(board: List[List[str]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n    if not board and not board[0]:\n        return None\n\n    m, n = len(board), len(board[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def capture(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr = row + dr\n                nc = col + dc\n                if nr in range(m) and nc in range(n) and board[nr][nc] == \"O\":\n                    q.append((nr, nc))\n                    board[nr][nc] = \"T\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\" and (r in [0, m - 1] or c in [0, n - 1]):\n                board[r][c] = \"T\"\n                capture(r, c)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\":\n                board[r][c] = \"X\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"T\":\n                board[r][c] = \"O\"\n\n\nboard = [\n    [\"X\", \"X\", \"X\", \"X\"],\n    [\"X\", \"O\", \"O\", \"X\"],\n    [\"X\", \"X\", \"O\", \"X\"],\n    [\"X\", \"O\", \"X\", \"X\"],\n]\nboard1 = deepcopy(board)\nsolveDFS(board1)\npprint(board1)\n# [['X', 'X', 'X', 'X'],\n#  ['X', 'X', 'X', 'X'],\n#  ['X', 'X', 'X', 'X'],\n#  ['X', 'O', 'X', 'X']]\n\nboard2 = deepcopy(board)\nsolveBFS(board2)\npprint(board2)\n# [['X', 'X', 'X', 'X'],\n#  ['X', 'X', 'X', 'X'],\n#  ['X', 'X', 'X', 'X'],\n#  ['X', 'O', 'X', 'X']]\n</code></pre>"},{"location":"graph_flood_fill/#417-pacific-atlantic-water-flow","title":"417. Pacific Atlantic Water Flow","text":"<ul> <li>Find the list of coordinates where water can flow to both the Pacific and Atlantic oceans.</li> </ul> <pre><code>from collections import deque\nfrom typing import List\n\n\n# 1. DFS\ndef pacificAtlanticDFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n\n    def dfs(r, c, visited, prevHeight):\n        if (\n            (r, c) in visited\n            or r not in range(m)\n            or c not in range(n)\n            or heights[r][c] &lt; prevHeight\n        ):\n            return None\n\n        visited.add((r, c))\n        height = heights[r][c]\n\n        dfs(r + 1, c, visited, height)\n        dfs(r - 1, c, visited, height)\n        dfs(r, c + 1, visited, height)\n        dfs(r, c - 1, visited, height)\n\n    for c in range(n):\n        dfs(0, c, pac, heights[0][c])  # top\n        dfs(m - 1, c, atl, heights[m - 1][c])  # bottom\n\n    for r in range(m):\n        dfs(r, 0, pac, heights[r][0])  # left\n        dfs(r, n - 1, atl, heights[r][n - 1])  # right\n\n    return list(pac &amp; atl)\n\n\n# 2. BFS\ndef pacificAtlanticBFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def bfs(r, c, visited):\n        q = deque([(r, c)])\n        visited.add((r, c))\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr in range(m)\n                    and nc in range(n)\n                    and heights[nr][nc] &lt; heights[row][col]\n                    and (nr, nc) not in visited\n                ):\n                    q.append((nr, nc))\n                    visited.add((nr, nc))\n\n    for c in range(n):\n        bfs(0, c, pac)  # top\n        bfs(m - 1, c, atl)  # bottom\n\n    for r in range(m):\n        bfs(r, 0, pac)  # left\n        bfs(r, n - 1, atl)  # right\n\n    return list(pac &amp; atl)\n\n\nheights = [\n    [1, 2, 2, 3, 5],\n    [3, 2, 3, 4, 4],\n    [2, 4, 5, 3, 1],\n    [6, 7, 1, 4, 5],\n    [5, 1, 1, 2, 4],\n]\nprint(pacificAtlanticDFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\nprint(pacificAtlanticBFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\n</code></pre>"},{"location":"graph_mst/","title":"Graph - Minimum Spanning Tree (MST)","text":"<ol> <li>1584 - Min Cost to Connect All Points (Medium)</li> <li>1135 - Connecting Cities With Minimum Cost (Medium)</li> <li>1168 - Optimize Water Distribution in a Village (Hard)</li> <li>1489 - Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree (Hard)</li> <li>1631 - Path With Minimum Effort (Medium)</li> <li>1192 - Critical Connections in a Network (Hard)</li> <li>1579 - Remove Max Number of Edges to Keep Graph Fully Traversable (Hard)</li> <li>1136 - Parallel Courses (Hard)</li> <li>0924 - Minimize Malware Spread (Hard)</li> <li>1589 - Maximum Sum Obtained of Any Permutation (Medium)</li> </ol>"},{"location":"graph_mst/#1584-min-cost-to-connect-all-points","title":"1584. Min Cost to Connect All Points","text":"<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim's Algorithm\ndef minCostConnectPoints(points: List[List[int]]) -&gt; int:\n    n = len(points)\n\n    graph = defaultdict(list)\n    for i in range(n):\n        x1, y1 = points[i]\n        for j in range(i + 1, n):\n            x2, y2 = points[j]\n            dist = abs(x1 - x2) + abs(y1 - y2)\n            graph[i].append((dist, j))\n            graph[j].append((dist, i))\n\n    cost = 0\n    visit = set()\n    minHeap = [(0, 0)]\n\n    while len(visit) &lt; n:\n        dist, node = heapq.heappop(minHeap)\n        if node in visit:\n            continue\n        visit.add(node)\n        cost += dist\n        for distance, neighbor in graph[node]:\n            if neighbor not in visit:\n                heapq.heappush(minHeap, (distance, neighbor))\n\n    return cost\n\n\npoints = [[0, 0], [2, 2], [3, 10], [5, 2], [7, 0]]\nprint(minCostConnectPoints(points))  # 20\n</code></pre>"},{"location":"graph_mst/#1135-connecting-cities-with-minimum-cost","title":"1135. Connecting Cities With Minimum Cost","text":""},{"location":"graph_mst/#1168-optimize-water-distribution-in-a-village","title":"1168. Optimize Water Distribution in a Village","text":""},{"location":"graph_mst/#1489-find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree","title":"1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree","text":""},{"location":"graph_mst/#1631-path-with-minimum-effort","title":"1631. Path With Minimum Effort","text":""},{"location":"graph_mst/#1192-critical-connections-in-a-network","title":"1192. Critical Connections in a Network","text":""},{"location":"graph_mst/#1579-remove-max-number-of-edges-to-keep-graph-fully-traversable","title":"1579. Remove Max Number of Edges to Keep Graph Fully Traversable","text":""},{"location":"graph_mst/#1136-parallel-courses","title":"1136. Parallel Courses","text":""},{"location":"graph_mst/#0924-minimize-malware-spread","title":"0924. Minimize Malware Spread","text":""},{"location":"graph_mst/#1589-maximum-sum-obtained-of-any-permutation","title":"1589. Maximum Sum Obtained of Any Permutation","text":""},{"location":"graph_topological_sort/","title":"Graph - Topological Sort","text":"<p>Topological Sort</p> <ul> <li>DAG (Directed Acyclic Graph)</li> <li>Time complexity: O(V+E)</li> <li>Space complexity: O(V+E)</li> </ul> <p>Table of Contents</p> <ol> <li>0207 - Course Schedule (Medium)</li> <li>0210 - Course Schedule II (Medium)</li> </ol>"},{"location":"graph_topological_sort/#207-course-schedule","title":"207. Course Schedule","text":"<ul> <li>Return true if it is possible to finish all courses, otherwise return false.</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# 1. BFS - Kahn's Algorithm\ndef canFinishBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    adj = defaultdict(list)\n    indegree = [0] * numCourses\n\n    for crs, pre in prerequisites:\n        adj[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    count = 0\n\n    while q:\n        crs = q.popleft()\n        count += 1\n\n        for next in adj[crs]:\n            indegree[next] -= 1\n\n            if indegree[next] == 0:\n                q.append(next)\n\n    return count == numCourses\n\n\n# 2. DFS + Set\ndef canFinishDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    adj = defaultdict(list)\n    for crs, pre in prerequisites:\n        adj[crs].append(pre)\n\n    visited = set()\n\n    def dfs(crs):\n        if crs in visited:  # cycle detected\n            return False\n        if adj[crs] == []:\n            return True\n\n        visited.add(crs)\n\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        visited.remove(crs)\n        adj[crs] = []\n\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\n# 3. DFS + List\ndef canFinishDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    adj = defaultdict(list)\n    for pre, crs in prerequisites:\n        adj[crs].append(pre)\n\n    # 0: not visited, 1: visiting, 2: visited\n    visited = [0] * numCourses\n\n    def dfs(crs):\n        if visited[crs] == 1:  # cycle detected\n            return False\n        if visited[crs] == 2:\n            return True\n\n        visited[crs] = 1\n\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        visited[crs] = 2\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(canFinishBFS(5, prerequisites))  # True\nprint(canFinishDFS1(5, prerequisites))  # True\nprint(canFinishDFS2(5, prerequisites))  # True\n</code></pre>"},{"location":"graph_topological_sort/#210-course-schedule-ii","title":"210. Course Schedule II","text":"<ul> <li>Return the ordering of courses you should take to finish all courses. If there are multiple valid answers, return any of them.</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# 1. BFS - Kahn's Algorithm\ndef findOrderBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]:\n    adj = defaultdict(list)\n    indegree = [0] * numCourses\n\n    for crs, pre in prerequisites:\n        adj[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    order = []\n\n    while q:\n        crs = q.popleft()\n        order.append(crs)\n\n        for next in adj[crs]:\n            indegree[next] -= 1\n\n            if indegree[next] == 0:\n                q.append(next)\n\n    if len(order) == numCourses:\n        return order\n    else:\n        return []\n\n\n# 2. DFS + Set\ndef findOrderDFS1(\n    numCourses: int, prerequisites: List[List[int]]\n) -&gt; List[int]:\n    adj = defaultdict(list)\n    for crs, pre in prerequisites:\n        adj[crs].append(pre)\n\n    visit, cycle = set(), set()\n    order = []\n\n    def dfs(crs):\n        if crs in cycle:\n            return False\n        if crs in visit:\n            return True\n\n        cycle.add(crs)\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        cycle.remove(crs)\n        visit.add(crs)\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order\n\n\n# 3. DFS + List\ndef findOrderDFS2(\n    numCourses: int, prerequisites: List[List[int]]\n) -&gt; List[int]:\n    adj = defaultdict(list)\n    for pre, crs in prerequisites:\n        adj[crs].append(pre)\n\n    # 0: not visited, 1: visiting, 2: visited\n    state = [0] * numCourses\n    order = []\n\n    def dfs(crs):\n        if state[crs] == 1:\n            return False\n        if state[crs] == 2:\n            return True\n\n        state[crs] = 1\n\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        state[crs] = 2\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order[::-1]\n\n\nnumCourses = 5\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(findOrderBFS(numCourses, prerequisites))  # [2, 4, 3, 1, 0]\nprint(findOrderDFS1(numCourses, prerequisites))  # [4, 3, 1, 2, 0]\nprint(findOrderDFS2(numCourses, prerequisites))  # [4, 3, 2, 1, 0]\n</code></pre>"},{"location":"graph_topological_sort/#bfs","title":"BFS","text":"<ul> <li> <p>\u89e3\u9898\u601d\u8def\uff1a\u8fd9\u9053\u9898\u672c\u8d28\u4e0a\u662f\u4e00\u4e2a\u6709\u5411\u56fe\u7684\u95ee\u9898\uff0c\u9700\u8981\u627e\u51fa\u8fd9\u4e2a\u56fe\u7684\u62d3\u6251\u6392\u5e8f\u3002\u5982\u679c\u56fe\u4e2d\u5b58\u5728\u73af\uff0c\u5219\u6ca1\u6709\u529e\u6cd5\u5b8c\u6210\u6240\u6709\u8bfe\u7a0b\uff0c\u8fd9\u79cd\u60c5\u51b5\u4e0b\u5e94\u8be5\u8fd4\u56de\u4e00\u4e2a\u7a7a\u6570\u7ec4\u3002</p> </li> <li> <p>\u56fe\u7684\u8868\u793a\uff1a\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u90bb\u63a5\u8868\u6765\u8868\u793a\u8fd9\u4e2a\u6709\u5411\u56fe\uff0c\u540c\u65f6\u9700\u8981\u4e00\u4e2a\u6570\u7ec4 indegree \u6765\u8bb0\u5f55\u6bcf\u4e2a\u8282\u70b9\u7684\u5165\u5ea6\u3002</p> </li> <li> <p>\u62d3\u6251\u6392\u5e8f\uff08Kahn \u7b97\u6cd5\uff09\uff1aKahn \u7b97\u6cd5\u662f\u4e00\u79cd\u57fa\u4e8e BFS \u7684\u62d3\u6251\u6392\u5e8f\u7b97\u6cd5\uff1a</p> <ul> <li>\u9996\u5148\u627e\u51fa\u6240\u6709\u5165\u5ea6\u4e3a 0 \u7684\u8282\u70b9\uff0c\u5c06\u5b83\u4eec\u52a0\u5165\u961f\u5217\u3002</li> <li>\u4ece\u961f\u5217\u4e2d\u4f9d\u6b21\u53d6\u51fa\u8282\u70b9\uff0c\u653e\u5165\u7ed3\u679c\u96c6\u4e2d\uff0c\u5e76\u5c06\u8be5\u8282\u70b9\u6307\u5411\u7684\u8282\u70b9\u7684\u5165\u5ea6\u51cf 1\u3002</li> <li>\u5982\u679c\u67d0\u4e2a\u8282\u70b9\u7684\u5165\u5ea6\u51cf\u4e3a 0\uff0c\u5c06\u5176\u52a0\u5165\u961f\u5217\u3002</li> <li>\u91cd\u590d\u4e0a\u8ff0\u8fc7\u7a0b\u76f4\u5230\u961f\u5217\u4e3a\u7a7a\u3002\u5982\u679c\u6700\u7ec8\u7ed3\u679c\u96c6\u4e2d\u7684\u8282\u70b9\u6570\u7b49\u4e8e\u8bfe\u7a0b\u6570\uff0c\u5219\u8fd4\u56de\u7ed3\u679c\u96c6\uff0c\u5426\u5219\u8fd4\u56de\u7a7a\u6570\u7ec4\u3002</li> </ul> </li> <li> <p>\u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(V+E)\uff0c\u5176\u4e2d V \u662f\u8bfe\u7a0b\u6570\u91cf\uff0cE \u662f\u5148\u4fee\u8bfe\u7a0b\u7684\u6570\u91cf\u3002\u6211\u4eec\u9700\u8981\u904d\u5386\u6bcf\u4e2a\u8282\u70b9\u548c\u5b83\u7684\u8fb9\u3002</p> </li> <li>\u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(V+E)\uff0c\u7528\u6765\u5b58\u50a8\u56fe\u7684\u7ed3\u6784\u548c\u5165\u5ea6\u8868\u3002</li> </ul>"},{"location":"graph_union_find/","title":"Union Find (Disjoint Set)","text":"<ol> <li>0547 - Number of Provinces (Medium)</li> <li>0684 - Redundant Connection (Medium)</li> <li>0323 - Number of Connected Components in an Undirected Graph (Medium)</li> <li>0721 - Accounts Merge (Medium)</li> <li>0990 - Satisfiability of Equality Equations (Medium)</li> <li>0952 - Largest Component Size by Common Factor (Hard)</li> <li>0839 - Similar String Groups (Hard)</li> <li>0305 - Number of Islands II (Hard)</li> <li>1202 - Smallest String With Swaps (Medium)</li> <li>0685 - Redundant Connection II (Hard)</li> <li>0399 - Evaluate Division (Medium)</li> </ol>"},{"location":"graph_union_find/#union-find","title":"Union Find","text":"<ol> <li>Path Compression</li> <li>Union by Rank</li> </ol> <pre><code>class UnionFind:\n    def __init__(self, n: int):\n        self.par = list(range(n))\n        self.rank = [1] * n\n\n    def find(self, p):\n        if self.par[p] != p:\n            self.par[p] = self.find(self.par[p])\n        return self.par[p]\n\n    def union(self, n1, n2):\n        p1 = self.find(n1)\n        p2 = self.find(n2)\n\n        if p1 != p2:\n            if self.rank[p1] &gt; self.rank[p2]:\n                self.par[p2] = p1\n            elif self.rank[p1] &lt; self.rank[p2]:\n                self.par[p1] = p2\n            else:\n                self.par[p2] = p1\n                self.rank[p1] += 1\n\n    def connected(self, p, q):\n        return self.find(p) == self.find(q)\n\n\nuf = UnionFind(10)\nuf.union(1, 2)\nuf.union(3, 4)\nuf.union(1, 4)\nuf.union(5, 6)\nprint(uf.connected(2, 3))  # True\nprint(uf.connected(1, 3))  # True\nprint(uf.connected(1, 5))  # False\n</code></pre>"},{"location":"graph_union_find/#547-number-of-provinces","title":"547. Number of Provinces","text":"<pre><code>from typing import List\n\n\ndef findCircleNum(isConnected: List[List[int]]) -&gt; int:\n    n = len(isConnected)\n    par = list(range(n))\n    rank = [1] * n\n\n    def find(p):\n        if par[p] != p:\n            par[p] = find(par[p])\n        return par[p]\n\n    def union(n1, n2):\n        p1 = find(n1)\n        p2 = find(n2)\n\n        if p1 != p2:\n            if rank[p1] &gt; rank[p2]:\n                par[p2] = p1\n            elif rank[p1] &lt; rank[p2]:\n                par[p1] = p2\n            else:\n                par[p2] = p1\n                rank[p1] += 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if isConnected[i][j] == 1:\n                union(i, j)\n\n    provinces = len(set(find(i) for i in range(n)))\n\n    return provinces\n\n\nisConnected = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]\nprint(findCircleNum(isConnected))  # 2\n</code></pre>"},{"location":"graph_union_find/#684-redundant-connection","title":"684. Redundant Connection","text":"<pre><code>from typing import List\n\n\n# 1. Union Find\ndef findRedundantConnectionUF(edges: List[List[int]]) -&gt; List[int]:\n    par = [i for i in range(len(edges) + 1)]\n    rank = [1 for _ in range(len(edges) + 1)]\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]  # path compression\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 == p2:\n            return False\n\n        if rank[p1] &gt; rank[p2]:\n            par[p2] = p1\n            rank[p1] += rank[p2]\n        else:\n            par[p1] = p2\n            rank[p2] += rank[p1]\n\n        return True\n\n    for n1, n2 in edges:\n        if not union(n1, n2):\n            return [n1, n2]\n\n\n# 2. DFS\ndef findRedundantConnectionDFS(edges: List[List[int]]) -&gt; List[int]:\n    adj, cycle = {}, {}\n    for a, b in edges:\n        adj.setdefault(a, []).append(b)\n        adj.setdefault(b, []).append(a)\n\n    def dfs(node, parent):\n        if node in cycle:\n            for k in list(cycle.keys()):\n                if k == node:\n                    return True\n                del cycle[k]\n        cycle[node] = None\n        for child in adj[node]:\n            if child != parent and dfs(child, node):\n                return True\n        del cycle[node]\n        return False\n\n    dfs(edges[0][0], -1)\n    for a, b in edges[::-1]:\n        if a in cycle and b in cycle:\n            return (a, b)\n\n\nedges = [[1, 2], [1, 3], [2, 3]]\nprint(findRedundantConnectionUF(edges))  # [2, 3]\nprint(findRedundantConnectionDFS(edges))  # [2, 3]\n</code></pre>"},{"location":"graph_union_find/#323-number-of-connected-components-in-an-undirected-graph","title":"323. Number of Connected Components in an Undirected Graph","text":"<pre><code>from typing import List\n\n\n# Union Find\ndef countComponents(n: int, edges: List[List[int]]) -&gt; int:\n    parent = [i for i in range(n)]\n    rank = [1 for _ in range(n)]\n\n    def find(node):\n        root = node\n\n        while root != parent[root]:\n            parent[root] = parent[parent[root]]\n            root = parent[root]\n        return root\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 == p2:\n            return 0\n\n        if rank[p2] &gt; rank[p1]:\n            parent[p1] = p2\n            rank[p2] += rank[p1]\n        else:\n            parent[p2] = p1\n            rank[p1] += rank[p2]\n        return 1\n\n    count = n\n    for n1, n2 in edges:\n        count -= union(n1, n2)\n\n    return count\n\n\nprint(countComponents(5, [[0, 1], [1, 2], [3, 4]]))\n</code></pre>"},{"location":"graph_union_find/#721-accounts-merge","title":"721. Accounts Merge","text":"<pre><code>from collections import defaultdict\nfrom typing import List\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n\n    def find(self, p):\n        if self.parent[p] != p:\n            self.parent[p] = self.find(self.parent[p])\n        return self.parent[p]\n\n    def union(self, p, q):\n        rootP = self.find(p)\n        rootQ = self.find(q)\n        if rootP != rootQ:\n            self.parent[rootQ] = rootP\n\n\ndef accountsMerge(accounts: List[List[str]]) -&gt; List[List[str]]:\n    email_to_id = {}\n    uf = UnionFind(len(accounts))\n\n    for i, account in enumerate(accounts):\n        for email in account[1:]:\n            if email in email_to_id:\n                uf.union(i, email_to_id[email])\n            email_to_id[email] = i\n\n    id_to_emails = defaultdict(list)\n    for email, id_ in email_to_id.items():\n        id_to_emails[uf.find(id_)].append(email)\n\n    return [\n        [accounts[id_][0]] + sorted(emails)\n        for id_, emails in id_to_emails.items()\n    ]\n\n\naccounts = [\n    [\"John\", \"johnsmith@mail.com\", \"john_newyork@mail.com\"],\n    [\"John\", \"johnsmith@mail.com\", \"john00@mail.com\"],\n    [\"Mary\", \"mary@mail.com\"],\n    [\"John\", \"johnnybravo@mail.com\"],\n]\n\nprint(accountsMerge(accounts))\n# [['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],\n#  ['Mary', 'mary@mail.com'],\n#  ['John', 'johnnybravo@mail.com']]\n</code></pre>"},{"location":"graph_union_find/#990-satisfiability-of-equality-equations","title":"990. Satisfiability of Equality Equations","text":""},{"location":"graph_union_find/#952-largest-component-size-by-common-factor","title":"952. Largest Component Size by Common Factor","text":""},{"location":"graph_union_find/#839-similar-string-groups","title":"839. Similar String Groups","text":""},{"location":"graph_union_find/#305-number-of-islands-ii","title":"305. Number of Islands II","text":""},{"location":"graph_union_find/#1202-smallest-string-with-swaps","title":"1202. Smallest String With Swaps","text":""},{"location":"graph_union_find/#685-redundant-connection-ii","title":"685. Redundant Connection II","text":""},{"location":"graph_union_find/#399-evaluate-division","title":"399. Evaluate Division","text":""},{"location":"greedy/","title":"Greedy","text":"<ol> <li>0455 - Assign Cookies (Easy)</li> <li>1005 - Maximize Sum Of Array After K Negations (Easy)</li> <li>0860 - Lemonade Change (Easy)</li> <li>2037 - Minimum Number of Moves to Seat Everyone (Easy)</li> <li>0376 - Wiggle Subsequence (Medium)</li> <li>0738 - Monotone Increasing Digits (Medium)</li> <li>0122 - Best Time to Buy and Sell Stock II (Easy)</li> <li>0714 - Best Time to Buy and Sell Stock with Transaction Fee (Medium)</li> <li>0135 - Candy (Hard)</li> <li>0406 - Queue Reconstruction by Height (Medium)</li> <li>3075 - Maximize Happiness of Selected Children (Medium)</li> <li>0945 - Minimum Increment to Make Array Unique (Medium)</li> <li>0053 - Maximum Subarray (Medium)</li> <li>0134 - Gas Station (Medium)</li> <li>0968 - Binary Tree Cameras (Hard)</li> </ol>"},{"location":"greedy/#455-assign-cookies","title":"455. Assign Cookies","text":"<pre><code>from typing import List\n\n\n# Greedy\ndef findContentChildren(g: List[int], s: List[int]) -&gt; int:\n    g.sort()\n    s.sort()\n    i, j = 0, 0\n\n    while i &lt; len(g) and j &lt; len(s):\n        if g[i] &lt;= s[j]:\n            i += 1\n        j += 1\n\n    return i\n\n\ng = [1, 2, 3]\ns = [1, 1]\nprint(findContentChildren(g, s))  # 1\n</code></pre>"},{"location":"greedy/#1005-maximize-sum-of-array-after-k-negations","title":"1005. Maximize Sum Of Array After K Negations","text":"<pre><code>from heapq import heapify, heapreplace\nfrom typing import List\n\n\n# Greedy\ndef largestSumAfterKNegationsGreedy(nums: List[int], k: int) -&gt; int:\n    nums.sort(key=abs, reverse=True)\n\n    for i in range(len(nums)):\n        if nums[i] &lt; 0 and k &gt; 0:\n            nums[i] *= -1\n            k -= 1\n\n    if k % 2:\n        nums[-1] *= -1\n\n    return sum(nums)\n\n\n# Heap\ndef largestSumAfterKNegationsHeap(nums: List[int], k: int) -&gt; int:\n    heapify(nums)\n\n    while k and nums[0] &lt; 0:\n        heapreplace(nums, -nums[0])\n        k -= 1\n\n    if k % 2:\n        heapreplace(nums, -nums[0])\n\n    return sum(nums)\n\n\nprint(largestSumAfterKNegationsGreedy([4, 2, 3], 1))  # 5\nprint(largestSumAfterKNegationsHeap([4, 2, 3], 1))\n</code></pre>"},{"location":"greedy/#860-lemonade-change","title":"860. Lemonade Change","text":"<pre><code>from typing import List\n\n\n# Greedy\ndef lemonadeChange(bills: List[int]) -&gt; bool:\n    hashmap = {5: 0, 10: 0, 20: 0}\n\n    for i in bills:\n        if i == 5:\n            hashmap[5] += 1\n\n        if i == 10:\n            if hashmap[5] &lt; 1:\n                return False\n\n            hashmap[5] -= 1\n            hashmap[10] += 1\n\n        if i == 20:\n            if hashmap[5] &gt;= 1 and hashmap[10] &gt;= 1:\n                hashmap[5] -= 1\n                hashmap[10] -= 1\n                hashmap[20] += 1\n\n            elif hashmap[5] &gt;= 3:\n                hashmap[5] -= 3\n                hashmap[20] += 1\n\n            else:\n                return False\n\n    return True\n\n\nprint(lemonadeChange([5, 5, 5, 10, 20]))  # True\n</code></pre>"},{"location":"greedy/#2037-minimum-number-of-moves-to-seat-everyone","title":"2037. Minimum Number of Moves to Seat Everyone","text":"<pre><code>from typing import List\n\n\n# Greedy\ndef minMovesToSeat(seats: List[int], students: List[int]) -&gt; int:\n    seats.sort()\n    students.sort()\n    moves = 0\n\n    for i, j in zip(seats, students):\n        moves += abs(i - j)\n\n    return moves\n\n\nprint(minMovesToSeat([3, 1, 5], [2, 7, 4]))  # 4\n</code></pre>"},{"location":"greedy/#376-wiggle-subsequence","title":"376. Wiggle Subsequence","text":"<pre><code>from typing import List\n\n\n# DP\ndef wiggleMaxLengthDP(nums: List[int]) -&gt; int:\n    # Time complexity: O(n)\n    # Space complexity: O(n)\n    if len(nums) &lt;= 1:\n        return len(nums)\n\n    up = [0 for _ in range(len(nums))]\n    down = [0 for _ in range(len(nums))]\n\n    up[0], down[0] = 1, 1\n\n    for i in range(1, len(nums)):\n        if nums[i] &gt; nums[i - 1]:\n            up[i] = down[i - 1] + 1\n            down[i] = down[i - 1]\n        elif nums[i] &lt; nums[i - 1]:\n            down[i] = up[i - 1] + 1\n            up[i] = up[i - 1]\n        else:\n            up[i] = up[i - 1]\n            down[i] = down[i - 1]\n\n    return max(up[-1], down[-1])\n\n\n# Greedy\ndef wiggleMaxLengthGreedy(nums: List[int]) -&gt; int:\n    if len(nums) &lt; 2:\n        return len(nums)\n\n    prev_diff = nums[1] - nums[0]\n    count = 2 if prev_diff != 0 else 1\n\n    for i in range(2, len(nums)):\n        diff = nums[i] - nums[i - 1]\n        if (diff &gt; 0 and prev_diff &lt;= 0) or (diff &lt; 0 and prev_diff &gt;= 0):\n            count += 1\n            prev_diff = diff\n\n    return count\n\n\nnums = [1, 7, 4, 9, 2, 5]\nprint(wiggleMaxLengthDP(nums))  # 6\nprint(wiggleMaxLengthGreedy(nums))  # 6\n</code></pre>"},{"location":"greedy/#738-monotone-increasing-digits","title":"738. Monotone Increasing Digits","text":"<pre><code># Greedy\ndef monotoneIncreasingDigits(n: int) -&gt; int:\n    strNum = list(str(n))\n\n    for i in range(len(strNum) - 2, -1, -1):\n        if int(strNum[i]) &gt; int(strNum[i + 1]):\n            strNum[i] = str(int(strNum[i]) - 1)\n            strNum[i + 1 :] = [\"9\"] * (len(strNum) - (i + 1))\n\n    return int(\"\".join(strNum))\n\n\nn = 332\nprint(monotoneIncreasingDigits(n))  # 299\n</code></pre>"},{"location":"greedy/#122-best-time-to-buy-and-sell-stock-ii","title":"122. Best Time to Buy and Sell Stock II","text":"<pre><code>from typing import List\n\n\n# 1. DP\ndef maxProfitDP1(prices: List[int]) -&gt; int:\n    # TC: O(n)\n    # SC: O(n)\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 2 for _ in range(n)]\n    dp[0][0] = -prices[0]\n    dp[0][1] = 0\n\n    for i in range(1, n):\n        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i])\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# 2. DP - Optimized\ndef maxProfitDP2(prices: List[int]) -&gt; int:\n    # TC: O(n)\n    # SC: O(1)\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    hold = -prices[0]\n    profit = 0\n\n    for i in range(1, n):\n        hold = max(hold, profit - prices[i])\n        profit = max(profit, hold + prices[i])\n\n    return profit\n\n\n# 3. Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    # TC: O(n)\n    # SC: O(1)\n    profit = 0\n\n    for i in range(1, len(prices)):\n        profit += max(prices[i] - prices[i - 1], 0)\n\n    return profit\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitDP1(prices))  # 7\nprint(maxProfitDP2(prices))  # 7\nprint(maxProfitGreedy(prices))  # 7\n</code></pre>"},{"location":"greedy/#714-best-time-to-buy-and-sell-stock-with-transaction-fee","title":"714. Best Time to Buy and Sell Stock with Transaction Fee","text":"<pre><code>from typing import List\n\n\n# 1. DP\ndef maxProfitDP(prices: List[int], fee: int) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 2 for _ in range(n)]\n\n    dp[0][0] = -prices[0] - fee\n    dp[0][1] = 0\n\n    for i in range(1, n):\n        dp[i][0] = max(\n            dp[i - 1][0],  # hold\n            dp[i - 1][1] - prices[i] - fee,  # buy\n        )\n        dp[i][1] = max(\n            dp[i - 1][1],  # hold\n            dp[i - 1][0] + prices[i],  # sell\n        )\n\n    return max(dp[-1])\n\n\n# 2. Greedy\ndef maxProfitGreedy(prices: List[int], fee: int) -&gt; int:\n    n = len(prices)\n    if n == 0:\n        return 0\n\n    buy = prices[0]\n    profit = 0\n\n    for i in range(1, n):\n        if prices[i] &lt; buy:\n            buy = prices[i]\n        elif prices[i] &gt; buy + fee:\n            profit += prices[i] - buy - fee\n            buy = prices[i] - fee\n\n    return profit\n\n\nprices = [1, 3, 2, 8, 4, 9]\nfee = 2\nprint(maxProfitDP(prices, fee))  # 8\nprint(maxProfitGreedy(prices, fee))  # 8\n</code></pre>"},{"location":"greedy/#135-candy","title":"135. Candy","text":"<pre><code>from typing import List\n\n\n# Greedy\ndef candy(ratings: List[int]) -&gt; int:\n    # TC: O(n)\n    # SC: O(n)\n    n = len(ratings)\n\n    if n &lt;= 1:\n        return n\n\n    candy = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        if ratings[i] &gt; ratings[i - 1]:\n            candy[i] = candy[i - 1] + 1\n\n    for j in range(n - 2, -1, -1):\n        if ratings[j] &gt; ratings[j + 1]:\n            candy[j] = max(candy[j], candy[j + 1] + 1)\n\n    return sum(candy)\n\n\nratings = [1, 0, 2]\nprint(candy(ratings))  # 5\n</code></pre>"},{"location":"greedy/#406-queue-reconstruction-by-height","title":"406. Queue Reconstruction by Height","text":"<pre><code>from typing import List\n\n\n# Greedy\ndef reconstructQueue(people: List[List[int]]) -&gt; List[List[int]]:\n    queue = []\n    people.sort(key=lambda x: (-x[0], x[1]))\n\n    for i in people:\n        queue.insert(i[1], i)\n\n    return queue\n\n\npeople = [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nprint(reconstructQueue(people))\n# [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]\n</code></pre>"},{"location":"greedy/#3075-maximize-happiness-of-selected-children","title":"3075. Maximize Happiness of Selected Children","text":"<pre><code>from typing import List\n\n\n# Greedy\ndef maximumHappinessSum(happiness: List[int], k: int) -&gt; int:\n    selected = 0\n    happinessScore = 0\n    happiness.sort(reverse=True)\n\n    for score in happiness:\n        if selected == k:\n            return happinessScore\n        happinessScore += max(0, score - selected)\n        selected += 1\n\n    return happinessScore\n\n\nhappiness = [1, 2, 3]\nk = 2\nprint(maximumHappinessSum(happiness, k))  # 4\n</code></pre>"},{"location":"greedy/#945-minimum-increment-to-make-array-unique","title":"945. Minimum Increment to Make Array Unique","text":"<pre><code>from typing import List\n\n\n# Greedy\ndef minIncrementForUnique(nums: List[int]) -&gt; int:\n    nums.sort()\n    moves = 0\n\n    for i in range(1, len(nums)):\n        if nums[i] &lt;= nums[i - 1]:\n            moves += nums[i - 1] + 1 - nums[i]\n            nums[i] = nums[i - 1] + 1\n\n    return moves\n\n\nnums = [1, 2, 2]\nprint(minIncrementForUnique(nums))  # 1\n</code></pre>"},{"location":"greedy/#53-maximum-subarray","title":"53. Maximum Subarray","text":"<pre><code>from typing import List\n\n\n# DP\ndef maxSubArrayDP(nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n\n    dp[0] = nums[0]\n    maxSum = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(\n            dp[i - 1] + nums[i],  # continue the previous subarray\n            nums[i],  # start a new subarray\n        )\n        maxSum = max(maxSum, dp[i])\n\n    return maxSum\n\n\n# Greedy\ndef maxSubArrayGreedy(nums: List[int]) -&gt; int:\n    maxSum = float(\"-inf\")\n    curSum = 0\n\n    for num in nums:\n        curSum += num\n        maxSum = max(maxSum, curSum)\n        curSum = max(curSum, 0)\n\n    return maxSum\n\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArrayDP(nums))  # 6\nprint(maxSubArrayGreedy(nums))  # 6\n</code></pre>"},{"location":"greedy/#134-gas-station","title":"134. Gas Station","text":"<pre><code>from typing import List\n\n\n# Greedy\ndef canCompleteCircuit(gas: List[int], cost: List[int]) -&gt; int:\n    curSum = 0\n    totalSum = 0\n    start = 0\n\n    for i in range(len(gas)):\n        curSum += gas[i] - cost[i]\n        totalSum += gas[i] - cost[i]\n\n        if curSum &lt; 0:\n            start = i + 1\n            curSum = 0\n\n    if totalSum &lt; 0:\n        return -1\n\n    return start\n\n\ngas = [1, 2, 3, 4, 5]\ncost = [3, 4, 5, 1, 2]\nprint(canCompleteCircuit(gas, cost))  # 3\n</code></pre>"},{"location":"greedy/#968-binary-tree-cameras","title":"968. Binary Tree Cameras","text":""},{"location":"greedy_interval/","title":"Greedy Algorithm - Interval Problems","text":"<ol> <li>0055 - Jump Game (Medium)</li> <li>0045 - Jump Game II (Hard)</li> <li>0452 - Minimum Number of Arrows to Burst Balloons (Medium)</li> <li>0435 - Non-overlapping Intervals (Medium)</li> <li>0763 - Partition Labels (Medium)</li> <li>0056 - Merge Intervals (Medium)</li> </ol>"},{"location":"greedy_interval/#0055-jump-game","title":"0055. Jump Game","text":"<pre><code>from typing import List\n\n\n# Greedy\ndef canJump(nums: List[int]) -&gt; bool:\n    n = len(nums)\n    if n &lt;= 1:\n        return True\n\n    maxReachable = 0\n    i = 0\n\n    while i &lt;= maxReachable:\n        maxReachable = max(maxReachable, i + nums[i])\n        if maxReachable &gt;= n - 1:\n            return True\n        i += 1\n\n    return False\n\n\nprint(canJump([2, 3, 1, 1, 4]))  # True\n</code></pre>"},{"location":"greedy_interval/#0045-jump-game-ii","title":"0045. Jump Game II","text":"<pre><code>from typing import List\n\n\ndef jump(nums: List[int]) -&gt; int:\n    if len(nums) == 1:\n        return 0\n\n    cover = 0\n    count = 0\n    i = 0\n\n    while cover &gt;= 0:\n        for i in range(i, cover + 1):\n            cover = max(cover, nums[i] + i)\n            if cover &gt;= len(nums) - 1:\n                return count + 1\n        count += 1\n\n    return count\n\n\nprint(jump([2, 3, 1, 1, 4]))  # 2\n</code></pre>"},{"location":"greedy_interval/#0452-minimum-number-of-arrows-to-burst-balloons","title":"0452. Minimum Number of Arrows to Burst Balloons","text":"<pre><code>from typing import List\n\n\n# Greedy - Interval\ndef findMinArrowShots(points: List[List[int]]) -&gt; int:\n\n    n = len(points)\n    if n == 0:\n        return 0\n\n    points.sort(key=lambda x: x[0])\n    result = 1\n\n    for i in range(1, n):\n        if points[i][0] &gt; points[i - 1][1]:\n            result += 1\n        else:\n            points[i][1] = min(points[i - 1][1], points[i][1])\n\n    return result\n\n\nprint(findMinArrowShots([[10, 16], [2, 8], [1, 6], [7, 12]]))  # 2\n</code></pre>"},{"location":"greedy_interval/#0435-non-overlapping-intervals","title":"0435. Non-overlapping Intervals","text":"<pre><code>from typing import List\n\n\ndef eraseOverlapIntervals(intervals: List[List[int]]) -&gt; int:\n    if len(intervals) &lt;= 1:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n    result = 0\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &gt;= intervals[i - 1][1]:\n            continue\n        else:\n            result += 1\n            intervals[i][1] = min(intervals[i][1], intervals[i - 1][1])\n\n    return result\n\n\nprint(eraseOverlapIntervals([[1, 2], [2, 3], [3, 4], [1, 3]]))  # 1\n</code></pre>"},{"location":"greedy_interval/#0763-partition-labels","title":"0763. Partition Labels","text":"<pre><code>from typing import List\n\n\n# 1. Hashmap\ndef partitionLabels1(s: str) -&gt; List[int]:\n    # Time complexity: O(nlogn)\n    # Space complexity: O(n)\n    hashmap = {}\n\n    for i, j in enumerate(s):\n        if j not in hashmap:\n            hashmap[j] = [i, i]\n        else:\n            hashmap[j][1] = i\n\n    intervals = list(hashmap.values())\n    intervals.sort(key=lambda x: x[0])\n\n    if len(intervals) &lt; 2:\n        return len(intervals)\n\n    result = []\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &lt; intervals[i - 1][1]:\n            intervals[i][1] = max(intervals[i][1], intervals[i - 1][1])\n        else:\n            result.append(intervals[i][0])\n\n    result.append(intervals[-1][1] + 1)\n\n    if len(result) == 1:\n        return result\n    else:\n        for i in range(len(result) - 1, 0, -1):\n            result[i] -= result[i - 1]\n        return result\n\n\n# 2. Single Pass Partitioning\ndef partitionLabels2(s: str) -&gt; List[int]:\n    # Time complexity: O(n)\n    # Space complexity: O(n)\n    last = {c: i for i, c in enumerate(s)}\n\n    start, end = 0, 0\n    result = []\n\n    for i, c in enumerate(s):\n        end = max(end, last[c])\n        if i == end:\n            result.append(end - start + 1)\n            start = i + 1\n\n    return result\n\n\nprint(partitionLabels1(\"abaccd\"))  # [3, 2, 1]\nprint(partitionLabels2(\"abaccd\"))  # [3, 2, 1]\n</code></pre>"},{"location":"greedy_interval/#0056-merge-intervals","title":"0056. Merge Intervals","text":"<pre><code>from typing import List\n\n\ndef merge(intervals: List[List[int]]) -&gt; List[List[int]]:\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &lt;= result[-1][1]:\n            result[-1][1] = max(intervals[i][1], result[-1][1])\n        else:\n            result.append(intervals[i])\n\n    return result\n\n\nprint(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))\n# [[1, 6], [8, 10], [15, 18]]\n</code></pre>"},{"location":"hash_counting/","title":"Hash - Counting","text":"<ol> <li>0242 - Valid Anagram (Easy)</li> <li>0560 - Subarray Sum Equals K (Medium)</li> <li>0049 - Group Anagrams (Medium)</li> <li>0438 - Find All Anagrams in a String (Medium)</li> </ol>"},{"location":"hash_counting/#242-valid-anagram","title":"242. Valid Anagram","text":"<pre><code>from collections import Counter\n\n\n# 1. Hashmap\ndef isAnagramHash(s: str, t: str) -&gt; bool:\n    if len(s) != len(t):\n        return False\n\n    hashmap = dict()\n\n    for i in s:\n        if i in hashmap:\n            hashmap[i] += 1\n        else:\n            hashmap[i] = 1\n\n    for j in t:\n        if j in hashmap:\n            hashmap[j] -= 1\n        else:\n            return False\n\n    for count in hashmap.values():\n        if count != 0:\n            return False\n\n    return True\n\n\n# 2. Array\ndef isAnagramArray(s: str, t: str) -&gt; bool:\n    if len(s) != len(t):\n        return False\n\n    record = [0 for _ in range(26)]\n\n    for i in s:\n        record[ord(i) - ord(\"a\")] += 1\n\n    for j in t:\n        record[ord(j) - ord(\"a\")] -= 1\n\n    for i in record:\n        if i != 0:\n            return False\n\n    return True\n\n\n# 3. Counter\ndef isAnagramCounter(s: str, t: str) -&gt; bool:\n    return Counter(s) == Counter(t)\n\n\ns = \"anagram\"\nt = \"nagaram\"\nprint(isAnagramHash(s, t))  # True\nprint(isAnagramArray(s, t))  # True\nprint(isAnagramCounter(s, t))  # True\n</code></pre>"},{"location":"hash_counting/#560-subarray-sum-equals-k","title":"560. Subarray Sum Equals K","text":"<pre><code>from typing import List\n\n\n# 1. Prefix Sum\ndef subarraySum(nums: List[int], k: int) -&gt; int:\n    prefix_sums = {0: 1}\n    currentSum = 0\n    count = 0\n\n    for num in nums:\n        currentSum += num\n        if (currentSum - k) in prefix_sums:\n            count += prefix_sums[currentSum - k]\n\n        if currentSum in prefix_sums:\n            prefix_sums[currentSum] += 1\n        else:\n            prefix_sums[currentSum] = 1\n\n    return count\n\n\n# 2. Optimized Prefix Sum\ndef subarraySumOptimized(nums: List[int], k: int) -&gt; int:\n    prefixSum = 0\n    count = 0\n    prefix_sums = {0: 1}\n\n    for num in nums:\n        prefixSum += num\n        count += prefix_sums.get(prefixSum - k, 0)\n        prefix_sums[prefixSum] = prefix_sums.get(prefixSum, 0) + 1\n\n    return count\n\n\nnums = [1, 1, 1]\nk = 2\nprint(subarraySum(nums, k))  # 2\nprint(subarraySumOptimized(nums, k))  # 2\n</code></pre>"},{"location":"hash_counting/#49-group-anagrams","title":"49. Group Anagrams","text":"<pre><code>from collections import defaultdict\nfrom typing import List\n\n\ndef groupAnagrams(strs: List[str]) -&gt; List[List[str]]:\n    result = defaultdict(list)\n\n    for s in strs:\n        count = [0] * 26\n        for i in s:\n            count[ord(i) - ord(\"a\")] += 1\n\n        result[tuple(count)].append(s)\n\n    return result.values()\n\n\nstrs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\nprint(groupAnagrams(strs))  # [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n</code></pre>"},{"location":"hash_counting/#438-find-all-anagrams-in-a-string","title":"438. Find All Anagrams in a String","text":"<pre><code>from typing import List\n\n\n# Sliding Window - Variable\ndef findAnagrams(s: str, p: str) -&gt; List[int]:\n    result = []\n    if len(s) &lt; len(p):\n        return result\n\n    countP = [0] * 26\n    for i in p:\n        countP[ord(i) - ord(\"a\")] += 1\n\n    countS = [0] * 26\n    for i in range(len(p)):\n        countS[ord(s[i]) - ord(\"a\")] += 1\n\n    if countS == countP:\n        result.append(0)\n\n    # sliding window\n    for i in range(len(p), len(s)):\n        countS[ord(s[i]) - ord(\"a\")] += 1  # add new character\n        countS[ord(s[i - len(p)]) - ord(\"a\")] -= 1  # remove old character\n        if countS == countP:\n            result.append(i - len(p) + 1)  # append the starting index\n\n    return result\n\n\ns = \"cbaebabacd\"\np = \"abc\"\nprint(findAnagrams(s, p))  # [0, 6]\n</code></pre>"},{"location":"hash_map/","title":"Hash Map","text":"<ol> <li>0383 - Ransom Note (Easy)</li> <li>0350 - Intersection of Two Arrays II (Easy)</li> <li>0001 - Two Sum (Easy)</li> <li>0409 - Longest Palindrome (Easy)</li> <li>1365 - How Many Numbers Are Smaller Than the Current Number (Easy)</li> <li>0202 - Happy Number (Easy)</li> <li>0454 - 4Sum II (Medium)</li> </ol>"},{"location":"hash_map/#383-ransom-note","title":"383. Ransom Note","text":"<ul> <li>Return <code>True</code> if the ransom note can be constructed from the magazines, otherwise, return <code>False</code>.</li> </ul> <pre><code>def canConstruct(ransomNote: str, magazine: str) -&gt; bool:\n    if len(ransomNote) &gt; len(magazine):\n        return False\n\n    record = [0 for _ in range(26)]\n\n    for i in magazine:\n        record[ord(i) - ord(\"a\")] += 1\n\n    for j in ransomNote:\n        record[ord(j) - ord(\"a\")] -= 1\n\n    for i in record:\n        if i &lt; 0:\n            return False\n\n    return True\n\n\nransomNote = \"aa\"\nmagazine = \"aab\"\nprint(canConstruct(ransomNote, magazine))  # True\n</code></pre>"},{"location":"hash_map/#350-intersection-of-two-arrays-ii","title":"350. Intersection of Two Arrays II","text":"<ul> <li>Return the intersection of two arrays.</li> </ul> <pre><code>from collections import defaultdict\nfrom typing import List\n\n\ndef intersect(nums1: List[int], nums2: List[int]) -&gt; List[int]:\n    hashmap = defaultdict(int)\n    result = []\n\n    for i in nums1:\n        hashmap[i] += 1\n\n    for i in nums2:\n        if hashmap[i] &gt; 0:\n            result.append(i)\n            hashmap[i] -= 1\n\n    return result\n\n\nnums1 = [1, 2, 2, 1]\nnums2 = [2, 2]\nprint(intersect(nums1, nums2))  # [2, 2]\n</code></pre>"},{"location":"hash_map/#1-two-sum","title":"1. Two Sum","text":"<ul> <li>Return the indices of the two numbers such that they add up to a specific target.</li> </ul> <pre><code>from typing import List\n\n\ndef twoSum(nums: List[int], target: int) -&gt; List[int]:\n    hashmap = dict()\n\n    for idx, val in enumerate(nums):\n        if (target - val) in hashmap:\n            return [hashmap[target - val], idx]\n        hashmap[val] = idx\n\n\nnums = [2, 7, 11, 15]\ntarget = 18\nprint(twoSum(nums, target))  # [1, 2]\n</code></pre>"},{"location":"hash_map/#409-longest-palindrome","title":"409. Longest Palindrome","text":"<ul> <li>Return the length of the longest palindrome that can be built with the characters in the string.</li> </ul> <pre><code>def longestPalindrome(s: str) -&gt; int:\n    hashmap = dict()\n    result = 0\n\n    for char in s:\n        if char not in hashmap or hashmap[char] == 0:\n            hashmap[char] = 1\n        else:\n            result += 2\n            hashmap[char] = 0\n\n    if any(hashmap.values()):\n        result += 1\n\n    return result\n\n\nprint(longestPalindrome(\"abccccdd\"))  # 7\n</code></pre>"},{"location":"hash_map/#1365-how-many-numbers-are-smaller-than-the-current-number","title":"1365. How Many Numbers Are Smaller Than the Current Number","text":"<ul> <li>For each number in the array, return how many numbers are smaller than it.</li> </ul> <pre><code>from typing import List\n\n\ndef smallerNumbersThanCurrent(nums: List[int]) -&gt; List[int]:\n    sortedNums = sorted(nums)\n\n    hashmap = dict()\n\n    for i, num in enumerate(sortedNums):\n        if num not in hashmap:\n            hashmap[num] = i\n\n    result = []\n    for i in range(len(sortedNums)):\n        result.append(hashmap[nums[i]])\n\n    return result\n\n\nnums = [8, 1, 2, 2, 3]\nprint(smallerNumbersThanCurrent(nums))  # [4, 0, 1, 1, 3]\n</code></pre>"},{"location":"hash_map/#202-happy-number","title":"202. Happy Number","text":"<ul> <li>Return <code>True</code> if the number is a happy number, otherwise, return <code>False</code>.</li> <li>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.</li> </ul> <pre><code>def isHappy(n: int) -&gt; bool:\n\n    def getSum(n):\n        sum_of_squares = 0\n        while n:\n            a, b = divmod(n, 10)\n            sum_of_squares += b**2\n            n = a\n        return sum_of_squares\n\n    record = set()\n\n    while True:\n        if n == 1:\n            return True\n\n        if n in record:\n            return False\n        else:\n            record.add(n)\n\n        n = getSum(n)\n\n\nn = 19\nprint(isHappy(n))  # True\n</code></pre>"},{"location":"hash_map/#454-4sum-ii","title":"454. 4Sum II","text":"<ul> <li>Return the number of tuples <code>(i, j, k, l)</code> such that <code>A[i] + B[j] + C[k] + D[l] == 0</code>.</li> </ul> <pre><code>from collections import defaultdict\nfrom typing import List\n\n\ndef fourSumCount(\n    nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]\n) -&gt; int:\n\n    sumAB = defaultdict(int)\n    result = 0\n\n    for i in nums1:\n        for j in nums2:\n            sumAB[i + j] += 1\n\n    for i in nums3:\n        for j in nums4:\n            if -(i + j) in sumAB:\n                result += sumAB[-(i + j)]\n\n    return result\n\n\nnums1 = [1, 2]\nnums2 = [-2, -1]\nnums3 = [-1, 2]\nnums4 = [0, 2]\nprint(fourSumCount(nums1, nums2, nums3, nums4))  # 2\n</code></pre>"},{"location":"hash_set/","title":"Hash Set","text":"<ol> <li>0349 - Intersection of Two Arrays (Easy)</li> </ol>"},{"location":"hash_set/#349-intersection-of-two-arrays","title":"349. Intersection of Two Arrays","text":"<pre><code>from typing import List\n\n\ndef intersection(nums1: List[int], nums2: List[int]) -&gt; List[int]:\n    return set(nums1) &amp; set(nums2)\n\n\nnums1 = [1, 2, 2, 1]\nnums2 = [2, 2]\nprint(intersection(nums1, nums2))  # {2}\n</code></pre>"},{"location":"heap_merge_k_sorted/","title":"Heap - Merge K Sorted","text":"<ol> <li>0023 - Merge k Sorted Lists (Hard)</li> <li>0373 - Find K Pairs with Smallest Sums (Medium)</li> <li>0378 - Kth Smallest Element in a Sorted Matrix (Medium)</li> </ol>"},{"location":"heap_merge_k_sorted/#23-merge-k-sorted-lists","title":"23. Merge k Sorted Lists","text":""},{"location":"heap_merge_k_sorted/#373-find-k-pairs-with-smallest-sums","title":"373. Find K Pairs with Smallest Sums","text":""},{"location":"heap_merge_k_sorted/#378-kth-smallest-element-in-a-sorted-matrix","title":"378. Kth Smallest Element in a Sorted Matrix","text":""},{"location":"heap_top_k/","title":"Heap - Top K Pattern","text":"<ol> <li>0215 - Kth Largest Element in an Array (Medium)</li> <li>0973 - K Closest Points to Origin (Medium)</li> <li>0347 - Top K Frequent Elements (Medium)</li> <li>0692 - Top K Frequent Words (Medium)</li> <li>0264 - Ugly Number II (Medium)</li> <li>0451 - Sort Characters By Frequency (Medium)</li> <li>703 - Kth Largest Element in a Stream (Easy)</li> <li>0767 - Reorganize String (Medium)</li> <li>0786 - K-th Smallest Prime Fraction (Hard)</li> </ol>"},{"location":"heap_top_k/#to-do-heap","title":"[To Do] Heap","text":"<pre><code>import heapq\n\n# 1. basic heap operations\nheap = []\nheapq.heappush(heap, 3)\nheapq.heappush(heap, 1)\nheapq.heappush(heap, 4)\nheapq.heappush(heap, 2)\n\nprint(heapq.heappop(heap))  # 1\nprint(heap)  # [2, 3, 4]\n</code></pre>"},{"location":"heap_top_k/#215-kth-largest-element-in-an-array","title":"215. Kth Largest Element in an Array","text":"<pre><code>import heapq\nfrom typing import List\n\n\ndef findKthLargest(nums: List[int], k: int) -&gt; int:\n    heap = nums[:k]\n    heapq.heapify(heap)  # min heap\n\n    for num in nums[k:]:\n        if num &gt; heap[0]:\n            heapq.heappop(heap)  # pop the smallest element\n            heapq.heappush(heap, num)  # push the new element\n\n    return heap[0]\n\n\n# Time complexity: O(n * log(k))\n#   - O(log(k)) for heapify\n#   - O(n) for iterating through the input list\n# Space complexity: O(k)\n\nnums = [3, 2, 1, 5, 6, 4]\nk = 2\nprint(findKthLargest(nums, k))  # 5\n</code></pre>"},{"location":"heap_top_k/#973-k-closest-points-to-origin","title":"973. K Closest Points to Origin","text":"<pre><code>import heapq\nfrom typing import List\n\n\ndef kClosest(points: List[List[int]], k: int) -&gt; List[List[int]]:\n    heap = []\n\n    for x, y in points:\n        dist = -(x**2 + y**2)  # max heap\n        if len(heap) &lt; k:\n            heapq.heappush(heap, (dist, x, y))\n        else:\n            heapq.heappushpop(heap, (dist, x, y))  # push and pop the smallest\n\n    return [[x, y] for (_, x, y) in heap]\n\n\n# Time complexity: O(n * log(k))\n#   - O(log(k)) for heapify\n#   - O(n) for iterating through the input list\n# Space complexity: O(k)\n\npoints = [[1, 3], [-2, 2]]\nk = 1\nprint(kClosest(points, k))  # [[-2, 2]]\n</code></pre>"},{"location":"heap_top_k/#347-top-k-frequent-elements","title":"347. Top K Frequent Elements","text":"<pre><code>import heapq\nfrom collections import Counter\nfrom typing import List\n\n\n# Counter\ndef topKFrequent1(nums: List[int], k: int) -&gt; List[int]:\n    heap = []  # min heap\n\n    for val, count in Counter(nums).items():\n        if len(heap) &lt; k:\n            heapq.heappush(heap, (count, val))\n        else:\n            heapq.heappushpop(heap, (count, val))\n\n    return [i for (_, i) in heap]\n\n\n# Dictionary\ndef topKFrequent2(nums: List[int], k: int) -&gt; List[int]:\n    heap = []  # min heap\n    counts = dict()\n\n    for num in nums:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n\n    for val, count in counts.items():\n        if len(heap) &lt; k:\n            heapq.heappush(heap, (count, val))\n        else:\n            heapq.heappushpop(heap, (count, val))\n\n    return [i for (_, i) in heap]\n\n\nnums = [1, 1, 1, 2, 2, 3]\nk = 2\nprint(topKFrequent1(nums, k))  # [2, 1]\nprint(topKFrequent2(nums, k))  # [2, 1]\n</code></pre>"},{"location":"heap_top_k/#692-top-k-frequent-words","title":"692. Top K Frequent Words","text":"<pre><code>import heapq\nfrom collections import Counter\nfrom typing import List\n\n\nclass WordFrequency:\n    def __init__(self, word, freq):\n        self.word = word\n        self.freq = freq\n\n    def __lt__(self, other):\n        # If the frequency is different\n        if self.freq != other.freq:\n            # The word with the lower frequency comes first\n            return self.freq &lt; other.freq\n        else:\n            # The word with the lower alphabetical order comes first\n            return self.word &gt; other.word\n\n\ndef topKFrequent(words: List[str], k: int) -&gt; List[str]:\n    heap = []\n\n    for word, freq in Counter(words).items():\n        heapq.heappush(heap, WordFrequency(word, freq))\n\n        if len(heap) &gt; k:\n            heapq.heappop(heap)\n\n    heap.sort(reverse=True)\n    return [x.word for x in heap]\n\n\nwords = [\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"]\nk = 2\nprint(topKFrequent(words, k))  # [\"i\", \"love\"]\n</code></pre>"},{"location":"heap_top_k/#264-ugly-number-ii","title":"264. Ugly Number II","text":"<pre><code>import heapq\n\n\ndef nthUglyNumber(n: int) -&gt; int:\n    heap = [1]\n    seen = set(heap)\n\n    factors = [2, 3, 5]\n    current = 1\n\n    # Pop the smallest ugly number n times\n    for _ in range(n):\n        current = heapq.heappop(heap)  # Pop the smallest ugly number\n\n        for factor in factors:\n            new = current * factor\n            if new not in seen:\n                seen.add(new)\n                heapq.heappush(heap, new)\n\n    return current\n\n\nprint(nthUglyNumber(10))  # 12\n</code></pre>"},{"location":"heap_top_k/#451-sort-characters-by-frequency","title":"451. Sort Characters By Frequency","text":"<pre><code>import heapq\nfrom collections import Counter\n\n\ndef frequencySort(s: str) -&gt; str:\n    result = \"\"\n\n    # Max Heap\n    heap = [(-freq, val) for val, freq in Counter(s).items()]\n    heapq.heapify(heap)\n\n    while heap:\n        freq, val = heapq.heappop(heap)\n        result += val * -freq\n\n    return result\n\n\nprint(frequencySort(\"tree\"))  # eert\n</code></pre>"},{"location":"heap_top_k/#703-kth-largest-element-in-a-stream","title":"703. Kth Largest Element in a Stream","text":"<pre><code>import heapq\nfrom typing import List\n\n\nclass KthLargest:\n    def __init__(self, k: int, nums: List[int]):\n        self.k = k\n        self.heap = nums\n        heapq.heapify(self.heap)  # min heap\n\n        while len(self.heap) &gt; k:  # keep the heap size to k\n            heapq.heappop(self.heap)\n\n    def add(self, val: int) -&gt; int:\n        if (\n            len(self.heap) &lt; self.k\n        ):  # if heap size is less than k, push the value\n            heapq.heappush(self.heap, val)\n        # if the value is greater than the smallest element in the heap\n        # push the value and pop the smallest element\n        elif val &gt; self.heap[0]:\n            heapq.heappushpop(self.heap, val)\n\n        return self.heap[0]\n\n\nkthLargest = KthLargest(3, [4, 5, 8, 2])\nprint(kthLargest.add(3))  # 4\n</code></pre>"},{"location":"heap_top_k/#767-reorganize-string","title":"767. Reorganize String","text":"<pre><code>import heapq\nfrom collections import Counter\n\n\ndef reorganizeString(s: str) -&gt; str:\n    if not s:\n        return \"\"\n\n    heap = [(-freq, char) for char, freq in Counter(s).items()]  # max heap\n    heapq.heapify(heap)\n\n    result = []\n    prev_count, prev_char = 0, \"\"\n\n    while heap:\n        count, char = heapq.heappop(heap)  # pop the most frequent character\n        result.append(char)  # append the character to the result\n\n        if (\n            prev_count &lt; 0\n        ):  # if the previous character still has remaining count\n            heapq.heappush(heap, (prev_count, prev_char))\n\n        prev_count = (\n            count + 1\n        )  # update the current character's remaining count\n        prev_char = char  # update the current character\n\n    # check if there is any invalid result\n    if len(result) != len(s):\n        return \"\"\n\n    return \"\".join(result)\n\n\nprint(reorganizeString(\"aab\"))\n</code></pre>"},{"location":"heap_top_k/#786-k-th-smallest-prime-fraction","title":"786. K-th Smallest Prime Fraction","text":"<pre><code>import heapq\nfrom typing import List\n\n\ndef kthSmallestPrimeFraction(arr: List[int], k: int) -&gt; List[int]:\n    max_heap = []\n\n    for j in range(1, len(arr)):\n        for i in range(j):\n            heapq.heappush(max_heap, (-arr[i] / arr[j], arr[i], arr[j]))\n\n            if len(max_heap) &gt; k:\n                heapq.heappop(max_heap)\n\n    return [max_heap[0][1], max_heap[0][2]]\n\n\narr = [1, 2, 3, 5]\nk = 3\nprint(kthSmallestPrimeFraction(arr, k))  # [2, 5]\n</code></pre>"},{"location":"heap_two_heaps/","title":"Heap - Two Heaps","text":"<ol> <li>0295 - Find Median from Data Stream (Hard)</li> <li>1046 - Last Stone Weight (Easy)</li> <li>0480 - Sliding Window Median (Hard)</li> <li>0502 - IPO (Hard)</li> </ol>"},{"location":"heap_two_heaps/#295-find-median-from-data-stream","title":"295. Find Median from Data Stream","text":"<pre><code>from heapq import heappop, heappush\n\n\n# Heap - Two Heaps\nclass MedianFinder:\n    def __init__(self):\n        self.max = []\n        self.min = []\n\n    def addNum(self, num: int) -&gt; None:\n        heappush(self.max, -num)\n        heappush(self.min, -heappop(self.max))\n\n        if len(self.min) &gt; len(self.max):\n            heappush(self.max, -heappop(self.min))\n\n    def findMedian(self) -&gt; float:\n        if len(self.max) == len(self.min):\n            return (-self.max[0] + self.min[0]) / 2.0\n        else:\n            return -self.max[0]\n\n\n# TC: O(log n)\n# SC: O(n)\n\nmedian_finder = MedianFinder()\nmedian_finder.addNum(1)\nmedian_finder.addNum(2)\nassert median_finder.findMedian() == 1.5\nmedian_finder.addNum(3)\nassert median_finder.findMedian() == 2\nmedian_finder.addNum(4)\nassert median_finder.findMedian() == 2.5\nmedian_finder.addNum(5)\nassert median_finder.findMedian() == 3\nprint(\"All Passed.\")\n</code></pre>"},{"location":"heap_two_heaps/#1046-last-stone-weight","title":"1046. Last Stone Weight","text":""},{"location":"heap_two_heaps/#480-sliding-window-median","title":"480. Sliding Window Median","text":""},{"location":"heap_two_heaps/#502-ipo","title":"502. IPO","text":"<pre><code>import heapq\nfrom typing import List\n\n\ndef findMaximizedCapital(\n    k: int, w: int, profits: List[int], capital: List[int]\n) -&gt; int:\n    if not profits or not capital:\n        return w\n\n    minHeap = []\n    maxHeap = []\n\n    for i in range(len(profits)):\n        heapq.heappush(minHeap, (capital[i], profits[i]))\n\n    for _ in range(k):\n        while minHeap and minHeap[0][0] &lt;= w:\n            capital, profit = heapq.heappop(minHeap)\n            heapq.heappush(maxHeap, -profit)\n\n        if not maxHeap:\n            break\n\n        w += -heapq.heappop(maxHeap)\n\n    return w\n\n\nk = 2\nw = 0\nprofits = [1, 2, 3]\ncapital = [0, 1, 1]\nprint(findMaximizedCapital(k, w, profits, capital))  # 4\n</code></pre>"},{"location":"left_right_pointers/","title":"Left Right Pointers","text":"<ol> <li>0009 - Palindrome Number (Easy)</li> <li>0015 - 3Sum (Medium)</li> <li>0018 - 4Sum (Medium)</li> <li>0069 - Sqrt(x) (Easy)</li> <li>0088 - Merge Sorted Array (Easy)</li> <li>0977 - Squares of a Sorted Array (Easy)</li> <li>0881 - Boats to Save People (Medium)</li> <li>0075 - Sort Colors (Medium)</li> </ol>"},{"location":"left_right_pointers/#9-palindrome-number","title":"9. Palindrome Number","text":"<pre><code>def isPalindrome(x: int) -&gt; bool:\n    if x &lt; 0:\n        return False\n\n    x = list(str(x))\n\n    left, right = 0, len(x) - 1\n\n    while left &lt; right:\n        if x[left] != x[right]:\n            return False\n        left += 1\n        right -= 1\n\n    return True\n\n\nx = 121\nprint(isPalindrome(x))  # True\n</code></pre>"},{"location":"left_right_pointers/#0015-3sum","title":"0015. 3Sum","text":"<pre><code>from typing import List\n\n\ndef threeSum(nums: List[int]) -&gt; List[List[int]]:\n    nums.sort()  # O(nlogn) Quick Sort\n    result = []\n\n    for i in range(len(nums) - 2):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n        left = i + 1\n        right = len(nums) - 1\n\n        while left &lt; right:\n            triSum = nums[i] + nums[left] + nums[right]\n            if triSum &gt; 0:\n                right -= 1\n            elif triSum &lt; 0:\n                left += 1\n            else:\n                result.append([nums[i], nums[left], nums[right]])\n\n                while left &lt; right and nums[left] == nums[left + 1]:\n                    left += 1\n\n                while left &lt; right and nums[right] == nums[right - 1]:\n                    right -= 1\n\n                left += 1\n                right -= 1\n\n    return result\n\n\n# Time complexity: O(n^2)\n# Space complexity: O(1)\n\nnums = [-1, 0, 1, 2, -1, -4]\nprint(threeSum(nums))\n</code></pre>"},{"location":"left_right_pointers/#18-4sum","title":"18. 4Sum","text":"<pre><code>from typing import List\n\n\ndef fourSum(nums: List[int], target: int) -&gt; List[List[int]]:\n    nums.sort()\n    result = []\n\n    for i in range(len(nums) - 3):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        for j in range(i + 1, len(nums) - 2):\n            if j &gt; i + 1 and nums[j] == nums[j - 1]:\n                continue\n\n            left = j + 1\n            right = len(nums) - 1\n\n            while left &lt; right:\n                total = nums[i] + nums[j] + nums[left] + nums[right]\n\n                if total &gt; target:\n                    right -= 1\n                elif total &lt; target:\n                    left += 1\n                else:\n                    result.append([nums[i], nums[j], nums[left], nums[right]])\n                    while left &lt; right and nums[left] == nums[left + 1]:\n                        left += 1\n                    while left &lt; right and nums[right] == nums[right - 1]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n\n    return result\n\n\nnums = [1, 0, -1, 0, -2, 2]\ntarget = 0\nprint(fourSum(nums, target))\n</code></pre>"},{"location":"left_right_pointers/#69-sqrtx","title":"69. Sqrt(x)","text":"<pre><code>def mySqrt(x: int) -&gt; int:\n    if x &lt; 2:\n        return x\n\n    left, right = 0, x // 2\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        if mid * mid &lt;= x &lt; (mid + 1) * (mid + 1):\n            return mid\n        elif mid * mid &lt; x:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n\nx = 8\nprint(mySqrt(x))\n</code></pre>"},{"location":"left_right_pointers/#88-merge-sorted-array","title":"88. Merge Sorted Array","text":"<pre><code>from typing import List\n\n\ndef merge(nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None:\n    p1, p2 = m - 1, n - 1\n    tail = m + n - 1\n\n    while p1 &gt;= 0 or p2 &gt;= 0:\n        if p1 == -1:\n            nums1[tail] = nums2[p2]\n            p2 -= 1\n        elif p2 == -1:\n            nums1[tail] = nums1[p1]\n            p1 -= 1\n\n        elif nums1[p1] &gt; nums2[p2]:\n            nums1[tail] = nums1[p1]\n            p1 -= 1\n        else:\n            nums1[tail] = nums2[p2]\n            p2 -= 1\n        tail -= 1\n\n\nnums1 = [1, 2, 3, 0, 0, 0]\nm = 3\nnums2 = [2, 5, 6]\nn = 3\nmerge(nums1, m, nums2, n)\nprint(nums1)  # [1, 2, 2, 3, 5, 6]\n</code></pre>"},{"location":"left_right_pointers/#977-squares-of-a-sorted-array","title":"977. Squares of a Sorted Array","text":"<pre><code>from typing import List\n\n\ndef sortedSquares(nums: List[int]) -&gt; List[int]:\n    result = [0 for _ in range(len(nums))]\n\n    left, right, index = 0, len(nums) - 1, len(nums) - 1\n\n    while left &lt;= right:\n        if abs(nums[left]) &gt;= abs(nums[right]):\n            result[index] = nums[left] ** 2\n            left += 1\n        else:\n            result[index] = nums[right] ** 2\n            right -= 1\n        index -= 1\n\n    return result\n\n\nnums = [-4, -1, 0, 3, 10]\nprint(sortedSquares(nums))  # [0, 1, 9, 16, 100]\n</code></pre>"},{"location":"left_right_pointers/#881-boats-to-save-people","title":"881. Boats to Save People","text":"<pre><code>from typing import List\n\n\ndef numRescueBoats(people: List[int], limit: int) -&gt; int:\n    people.sort()\n    left, right = 0, len(people) - 1\n    boats = 0\n\n    while left &lt;= right:\n        if people[left] + people[right] &lt;= limit:\n            left += 1\n        right -= 1\n        boats += 1\n\n    return boats\n\n\npeople = [3, 2, 2, 1]\nlimit = 3\nprint(numRescueBoats(people, limit))\n</code></pre>"},{"location":"left_right_pointers/#75-sort-colors","title":"75. Sort Colors","text":"<pre><code>from typing import List\n\n\ndef sortColors(nums: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    current = 0\n\n    while current &lt;= right:\n        if nums[current] == 0:\n            nums[left], nums[current] = nums[current], nums[left]\n            left += 1\n            current += 1\n        elif nums[current] == 2:\n            nums[right], nums[current] = nums[current], nums[right]\n            right -= 1\n        else:\n            current += 1\n\n\nnums = [2, 0, 2, 1, 1, 0]\nsortColors(nums)\nprint(nums)  # [0, 0, 1, 1, 2, 2]\n</code></pre>"},{"location":"linked_list/","title":"Linked List","text":"<ol> <li>0203 - Remove Linked List Elements (Easy)</li> <li>0707 - Design Linked List (Medium)</li> <li>0206 - Reverse Linked List (Easy)</li> <li>2487 - Remove Nodes From Linked List (Medium)</li> <li>0024 - Swap Nodes in Pairs (Medium)</li> <li>0019 - Remove Nth Node From End of List (Medium)</li> <li>0160 - Intersection of Two Linked Lists (Easy)</li> <li>0141 - Linked List Cycle (Easy)</li> <li>0142 - Linked List Cycle II (Medium)</li> <li>0237 - Delete Node in a Linked List (Easy)</li> <li>2816 - Double a Number Represented as a Linked List (Medium)</li> </ol>"},{"location":"linked_list/#203-remove-linked-list-elements","title":"203. Remove Linked List Elements","text":"<pre><code>from typing import Optional\n\nfrom helper import ListNode\n\n\ndef removeElements(head: Optional[ListNode], val: int) -&gt; Optional[ListNode]:\n    dummy = ListNode(next=head)\n    current = dummy\n\n    while current.next:\n        if current.next.val == val:\n            current.next = current.next.next\n        else:\n            current = current.next\n\n    return dummy.next\n\n\nnums = [1, 2, 6, 3, 4, 5, 6]\nval = 6\nhead = ListNode.create(nums)\nprint(head)\n# 1 -&gt; 2 -&gt; 6 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6\nprint(removeElements(head, val))\n# 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\n</code></pre>"},{"location":"linked_list/#707-design-linked-list","title":"707. Design Linked List","text":"<pre><code>class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass MyLinkedList:\n\n    def __init__(self):\n        self.dummy = ListNode()\n        self.size = 0\n\n    def get(self, index: int) -&gt; int:\n        if index &lt; 0 or index &gt;= self.size:\n            return -1\n\n        current = self.dummy.next\n        for _ in range(index):\n            current = current.next\n\n        return current.val\n\n    def addAtHead(self, val: int) -&gt; None:\n        self.dummy.next = ListNode(val, self.dummy.next)\n        self.size += 1\n\n    def addAtTail(self, val: int) -&gt; None:\n        current = self.dummy\n        while current.next:\n            current = current.next\n        current.next = ListNode(val)\n        self.size += 1\n\n    def addAtIndex(self, index: int, val: int) -&gt; None:\n        if index &lt; 0 or index &gt; self.size:\n            return\n\n        current = self.dummy\n        for i in range(index):\n            current = current.next\n        current.next = ListNode(val, current.next)\n        self.size += 1\n\n    def deleteAtIndex(self, index: int) -&gt; None:\n        if index &lt; 0 or index &gt;= self.size:\n            return\n\n        current = self.dummy\n        for i in range(index):\n            current = current.next\n        current.next = current.next.next\n        self.size -= 1\n\n\nll = MyLinkedList()\nll.addAtHead(1)\nll.addAtTail(3)\nll.addAtIndex(1, 2)\n# 1 -&gt; 2 -&gt; 3\nprint(ll.get(1))  # 2\n</code></pre>"},{"location":"linked_list/#206-reverse-linked-list","title":"206. Reverse Linked List","text":"<pre><code>from typing import Optional\n\nfrom helper import ListNode\n\n\n# 1. Iterative\ndef reverseListIterative(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    cur = head\n    prev = None\n\n    while cur:\n        temp = cur.next\n        cur.next = prev\n\n        prev = cur\n        cur = temp\n\n    return prev\n\n\n# 2. Recursive\ndef reverseListRecursive(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    def reverse(cur, prev=None):\n        if not cur:\n            return prev\n\n        temp = cur.next\n        cur.next = prev\n\n        return reverse(temp, cur)\n\n    return reverse(head)\n\n\nnums = [1, 2, 3, 4, 5]\nhead1 = ListNode.create(nums)\nprint(head1)\n# 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(reverseListIterative(head1))\n# 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1\nhead2 = ListNode.create(nums)\nprint(reverseListRecursive(head2))\n# 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1\n</code></pre>"},{"location":"linked_list/#2487-remove-nodes-from-linked-list","title":"2487. Remove Nodes From Linked List","text":"<pre><code>from typing import Optional\n\nfrom helper import ListNode\n\n\n# 1. Recursive\ndef removeNodesRecursive(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    if not head:\n        return None\n\n    head.next = removeNodesRecursive(head.next)\n\n    if head.next and head.val &lt; head.next.val:\n        return head.next\n\n    return head\n\n\n# 2. Iterative\ndef removeNodesIterative(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    stack = []\n    cur = head\n\n    while cur:\n        # pop all nodes in stack that are smaller than cur\n        while stack and cur.val &gt; stack[-1].val:\n            stack.pop()\n\n        stack.append(cur)\n        cur = cur.next\n\n    # link all nodes in stack\n    dummy = ListNode()\n    cur = dummy\n\n    for node in stack:\n        cur.next = node\n        cur = cur.next\n\n    return dummy.next\n\n\nhead = [5, 2, 13, 3, 8]\nhead1 = ListNode.create(head)\nprint(head1)\n# 5 -&gt; 2 -&gt; 13 -&gt; 3 -&gt; 8\nprint(removeNodesRecursive(head1))\n# 13 -&gt; 8\n\nhead2 = ListNode.create(head)\nprint(removeNodesIterative(head2))\n# 13 -&gt; 8\n</code></pre>"},{"location":"linked_list/#24-swap-nodes-in-pairs","title":"24. Swap Nodes in Pairs","text":"<pre><code>from typing import Optional\n\nfrom helper import ListNode\n\n\ndef swapPairs(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    dummy = ListNode(next=head)\n    cur = dummy\n\n    while cur.next and cur.next.next:\n        temp = cur.next\n        temp1 = cur.next.next.next\n\n        cur.next = cur.next.next\n        cur.next.next = temp\n        temp.next = temp1\n        cur = cur.next.next\n\n    return dummy.next\n\n\nnums = [1, 2, 3, 4, 5]\nhead = ListNode.create(nums)\nprint(head)\n# 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(swapPairs(head))\n# 2 -&gt; 1 -&gt; 4 -&gt; 3 -&gt; 5\n</code></pre>"},{"location":"linked_list/#19-remove-nth-node-from-end-of-list","title":"19. Remove Nth Node From End of List","text":"<pre><code>from typing import Optional\n\nfrom helper import ListNode\n\n\ndef removeNthFromEnd(head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:\n    dummy = ListNode(0, head)\n    fast = slow = dummy\n\n    for _ in range(n + 1):\n        fast = fast.next\n\n    while fast:\n        fast = fast.next\n        slow = slow.next\n\n    slow.next = slow.next.next\n\n    return dummy.next\n\n\nhead = [1, 2, 3, 4, 5]\nn = 2\nhead = ListNode.create(head)\nprint(head)\n# 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(removeNthFromEnd(head, n))\n# 1 -&gt; 2 -&gt; 3 -&gt; 5\n</code></pre>"},{"location":"linked_list/#160-intersection-of-two-linked-lists","title":"160. Intersection of Two Linked Lists","text":"<pre><code>from typing import Optional\n\nfrom helper import ListNode\n\n\ndef getIntersectionNode(\n    headA: ListNode, headB: ListNode\n) -&gt; Optional[ListNode]:\n    if not headA or not headB:\n        return None\n\n    a, b = headA, headB\n\n    while a != b:\n        a = a.next if a else headB\n        b = b.next if b else headA\n\n    return a\n\n\nlistA = [4, 1, 8, 4, 5]\nlistB = [5, 6, 1, 8, 4, 5]\nheadA = ListNode.create(listA)\nprint(headA)\n# 4 -&gt; 1 -&gt; 8 -&gt; 4 -&gt; 5\nheadB = ListNode.create(listB)\nprint(headB)\n# 5 -&gt; 6 -&gt; 1 -&gt; 8 -&gt; 4 -&gt; 5\nprint(getIntersectionNode(headA, headB))\n# 8 -&gt; 4 -&gt; 5\n</code></pre>"},{"location":"linked_list/#141-linked-list-cycle","title":"141. Linked List Cycle","text":"<pre><code>from typing import Optional\n\nfrom helper import ListNode\n\n\ndef hasCycle(head: Optional[ListNode]) -&gt; bool:\n    slow, fast = head, head\n\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n        if slow == fast:\n            return True\n\n    return False\n\n\nprint(hasCycle(ListNode.create([3, 2, 0, -4])))  # False\nprint(hasCycle(ListNode.create([3, 2, 0, -4], 1)))  # True\n</code></pre>"},{"location":"linked_list/#142-linked-list-cycle-ii","title":"142. Linked List Cycle II","text":"<pre><code>from typing import Optional\n\nfrom helper import ListNode\n\n\ndef detectCycle(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    slow, fast = head, head\n\n    while fast and fast.next:\n        fast = fast.next.next\n        slow = slow.next\n\n        if slow == fast:\n            slow = head\n            while slow != fast:\n                slow = slow.next\n                fast = fast.next\n            return slow\n\n    return None\n\n\nhead1 = ListNode.create([3, 2, 0, -4], 1)\nprint(detectCycle(head1).val)  # 2\nhead2 = ListNode.create([3, 2, 0, -4])\nprint(detectCycle(head2))  # None\n</code></pre>"},{"location":"linked_list/#237-delete-node-in-a-linked-list","title":"237. Delete Node in a Linked List","text":"<pre><code>from helper import ListNode\n\n\ndef deleteNode(node: ListNode) -&gt; None:\n    node.val = node.next.val\n    node.next = node.next.next\n\n\nhead = ListNode.create([4, 5, 1, 9])\nnode = head.next\ndeleteNode(node)\nprint(head)  # 4 -&gt; 1 -&gt; 9\n</code></pre>"},{"location":"linked_list/#2816-double-a-number-represented-as-a-linked-list","title":"2816. Double a Number Represented as a Linked List","text":"<pre><code>from typing import Optional\n\nfrom helper import ListNode\n\n\ndef doubleIt(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n\n    def twice(node):\n        if not node:\n            return 0\n        doubled_value = node.val * 2 + twice(node.next)\n        node.val = doubled_value % 10\n        return doubled_value // 10\n\n    carry = twice(head)\n\n    if carry:\n        head = ListNode(val=carry, next=head)\n\n    return head\n\n\nhead = ListNode.create([1, 2, 3, 4])\nprint(head)\n# 1 -&gt; 2 -&gt; 3 -&gt; 4\nprint(doubleIt(head))\n# 2 -&gt; 4 -&gt; 6 -&gt; 8\n</code></pre>"},{"location":"neetcode_150/","title":"Neetcode 150","text":"<ul> <li>Neetcode - YouTube</li> <li>Website</li> </ul>"},{"location":"neetcode_150/#arrays-hashing","title":"Arrays &amp; Hashing","text":"<ol> <li>0217 - Contains Duplicate (Easy)</li> <li>0242 - Valid Anagram (Easy)</li> <li>0001 - Two Sum (Easy)</li> <li>0049 - Group Anagrams (Medium)</li> <li>0347 - Top K Frequent Elements (Medium)</li> <li>0238 - Product of Array Except Self (Medium)</li> <li>0036 - Valid Sudoku (Medium)</li> <li>0271 - Encode and Decode Strings (Medium)</li> <li>0128 - Longest Consecutive Sequence (Hard)</li> </ol>"},{"location":"neetcode_150/#217-contains-duplicate","title":"217. Contains Duplicate","text":"<pre><code>from typing import List\n\n\n# 1.Brute Force\ndef containsDuplicateBF(nums: List[int]) -&gt; bool:\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] == nums[j]:\n                return True\n\n    return False\n\n\n# 2. Sort\ndef containsDuplicateSort(nums: List[int]) -&gt; bool:\n    nums.sort()\n\n    for i in range(1, len(nums)):\n        if nums[i] == nums[i - 1]:\n            return True\n\n    return False\n\n\n# 3.Set\ndef containsDuplicateSet(nums: List[int]) -&gt; bool:\n    seen = set()\n\n    for i in nums:\n        if i in seen:\n            return True\n        seen.add(i)\n\n    return False\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# | Brute Force |    O(n^2)       |    O(1)      |\n# |     Sort    |    O(n log n)   |    O(1)      |\n# |     Set     |    O(n)         |    O(n)      |\n# |-------------|-----------------|--------------|\n\nprint(containsDuplicateBF([1, 2, 3, 1]))  # True\nprint(containsDuplicateSort([1, 2, 3, 1]))  # True\nprint(containsDuplicateSet([1, 2, 3, 1]))  # True\n</code></pre>"},{"location":"neetcode_150/#242-valid-anagram","title":"242. Valid Anagram","text":"<pre><code>from collections import Counter\n\n\n# 1. Hashmap\ndef isAnagramHash(s: str, t: str) -&gt; bool:\n    if len(s) != len(t):\n        return False\n\n    hashmap = dict()\n\n    for i in s:\n        if i in hashmap:\n            hashmap[i] += 1\n        else:\n            hashmap[i] = 1\n\n    for j in t:\n        if j in hashmap:\n            hashmap[j] -= 1\n        else:\n            return False\n\n    for count in hashmap.values():\n        if count != 0:\n            return False\n\n    return True\n\n\n# 2. Array\ndef isAnagramArray(s: str, t: str) -&gt; bool:\n    if len(s) != len(t):\n        return False\n\n    record = [0 for _ in range(26)]\n\n    for i in s:\n        record[ord(i) - ord(\"a\")] += 1\n\n    for j in t:\n        record[ord(j) - ord(\"a\")] -= 1\n\n    for i in record:\n        if i != 0:\n            return False\n\n    return True\n\n\n# 3. Counter\ndef isAnagramCounter(s: str, t: str) -&gt; bool:\n    return Counter(s) == Counter(t)\n\n\ns = \"anagram\"\nt = \"nagaram\"\nprint(isAnagramHash(s, t))  # True\nprint(isAnagramArray(s, t))  # True\nprint(isAnagramCounter(s, t))  # True\n</code></pre>"},{"location":"neetcode_150/#1-two-sum","title":"1. Two Sum","text":"<pre><code>from typing import List\n\n\ndef twoSum(nums: List[int], target: int) -&gt; List[int]:\n    hashmap = dict()\n\n    for idx, val in enumerate(nums):\n        if (target - val) in hashmap:\n            return [hashmap[target - val], idx]\n        hashmap[val] = idx\n\n\nnums = [2, 7, 11, 15]\ntarget = 18\nprint(twoSum(nums, target))  # [1, 2]\n</code></pre>"},{"location":"neetcode_150/#49-group-anagrams","title":"49. Group Anagrams","text":"<pre><code>from collections import defaultdict\nfrom typing import List\n\n\ndef groupAnagrams(strs: List[str]) -&gt; List[List[str]]:\n    result = defaultdict(list)\n\n    for s in strs:\n        count = [0] * 26\n        for i in s:\n            count[ord(i) - ord(\"a\")] += 1\n\n        result[tuple(count)].append(s)\n\n    return result.values()\n\n\nstrs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\nprint(groupAnagrams(strs))  # [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n</code></pre>"},{"location":"neetcode_150/#347-top-k-frequent-elements","title":"347. Top K Frequent Elements","text":"<pre><code>import heapq\nfrom collections import Counter\nfrom typing import List\n\n\n# Counter\ndef topKFrequent1(nums: List[int], k: int) -&gt; List[int]:\n    heap = []  # min heap\n\n    for val, count in Counter(nums).items():\n        if len(heap) &lt; k:\n            heapq.heappush(heap, (count, val))\n        else:\n            heapq.heappushpop(heap, (count, val))\n\n    return [i for (_, i) in heap]\n\n\n# Dictionary\ndef topKFrequent2(nums: List[int], k: int) -&gt; List[int]:\n    heap = []  # min heap\n    counts = dict()\n\n    for num in nums:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n\n    for val, count in counts.items():\n        if len(heap) &lt; k:\n            heapq.heappush(heap, (count, val))\n        else:\n            heapq.heappushpop(heap, (count, val))\n\n    return [i for (_, i) in heap]\n\n\nnums = [1, 1, 1, 2, 2, 3]\nk = 2\nprint(topKFrequent1(nums, k))  # [2, 1]\nprint(topKFrequent2(nums, k))  # [2, 1]\n</code></pre>"},{"location":"neetcode_150/#238-product-of-array-except-self","title":"238. Product of Array Except Self","text":"<pre><code>from typing import List\n\n\ndef productExceptSelf(nums: List[int]) -&gt; List[int]:\n    \"\"\"\n    Time complexity: O(n)\n    Space complexity: O(n)\n    \"\"\"\n    n = len(nums)\n    prefix = [1 for _ in range(n)]\n    suffix = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        prefix[i] = nums[i - 1] * prefix[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        suffix[i] = nums[i + 1] * suffix[i + 1]\n\n    result = [i * j for i, j in zip(prefix, suffix)]\n\n    return result\n\n\n# Space optimized\ndef productExceptSelfOptimized(nums: List[int]) -&gt; List[int]:\n    \"\"\"\n    Time complexity: O(n)\n    Space complexity: O(1)\n    \"\"\"\n    n = len(nums)\n    result = [1] * n\n\n    prefix = 1\n    for i in range(n):\n        result[i] = prefix\n        prefix *= nums[i]\n\n    suffix = 1\n    for i in range(n - 1, -1, -1):\n        result[i] *= suffix\n        suffix *= nums[i]\n\n    return result\n\n\nprint(productExceptSelf([1, 2, 3, 4]))  # [24, 12, 8, 6]\nprint(productExceptSelfOptimized([1, 2, 3, 4]))  # [24, 12, 8, 6]\n</code></pre>"},{"location":"neetcode_150/#36-valid-sudoku","title":"36. Valid Sudoku","text":""},{"location":"neetcode_150/#271-encode-and-decode-strings","title":"271. Encode and Decode Strings","text":""},{"location":"neetcode_150/#128-longest-consecutive-sequence","title":"128. Longest Consecutive Sequence","text":""},{"location":"neetcode_150/#two-pointers","title":"Two Pointers","text":"<p>0125 - Valid Palindrome (Easy) 0167 - Two Sum II - Input array is sorted (Easy) 0015 - 3Sum (Medium) 0011 - Container With Most Water (Medium) 0042 - Trapping Rain Water (Hard)</p>"},{"location":"neetcode_150/#125-valid-palindrome","title":"125. Valid Palindrome","text":""},{"location":"neetcode_150/#167-two-sum-ii-input-array-is-sorted","title":"167. Two Sum II - Input array is sorted","text":""},{"location":"neetcode_150/#15-3sum","title":"15. 3Sum","text":"<pre><code>from typing import List\n\n\ndef threeSum(nums: List[int]) -&gt; List[List[int]]:\n    nums.sort()  # O(nlogn) Quick Sort\n    result = []\n\n    for i in range(len(nums) - 2):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n        left = i + 1\n        right = len(nums) - 1\n\n        while left &lt; right:\n            triSum = nums[i] + nums[left] + nums[right]\n            if triSum &gt; 0:\n                right -= 1\n            elif triSum &lt; 0:\n                left += 1\n            else:\n                result.append([nums[i], nums[left], nums[right]])\n\n                while left &lt; right and nums[left] == nums[left + 1]:\n                    left += 1\n\n                while left &lt; right and nums[right] == nums[right - 1]:\n                    right -= 1\n\n                left += 1\n                right -= 1\n\n    return result\n\n\n# Time complexity: O(n^2)\n# Space complexity: O(1)\n\nnums = [-1, 0, 1, 2, -1, -4]\nprint(threeSum(nums))\n</code></pre>"},{"location":"neetcode_150/#11-container-with-most-water","title":"11. Container With Most Water","text":""},{"location":"neetcode_150/#42-trapping-rain-water","title":"42. Trapping Rain Water","text":"<pre><code>from typing import List\n\n\n# Two Pointers\ndef trapTP(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    left, right = 0, len(height) - 1\n    leftMax, rightMax = 0, 0\n    total = 0\n\n    while left &lt; right:\n        if height[left] &lt; height[right]:\n            if height[left] &gt;= leftMax:\n                leftMax = height[left]\n            else:\n                total += leftMax - height[left]\n            left += 1\n        else:\n            if height[right] &gt;= rightMax:\n                rightMax = height[right]\n            else:\n                total += rightMax - height[right]\n            right -= 1\n\n    return total\n\n\n# Monotonic Stack\ndef trapStack(height: List[int]) -&gt; int:\n    stack = []\n    total = 0\n\n    for i in range(len(height)):\n        while stack and height[i] &gt; height[stack[-1]]:\n            top = stack.pop()\n            if not stack:\n                break\n            distance = i - stack[-1] - 1\n            bounded_height = min(height[i], height[stack[-1]]) - height[top]\n            total += distance * bounded_height\n        stack.append(i)\n\n    return total\n\n\nheight = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\nprint(trapTP(height))  # 6\nprint(trapStack(height))  # 6\n</code></pre>"},{"location":"neetcode_150/#sliding-window","title":"Sliding Window","text":"<ol> <li>0121 - Best Time to Buy and Sell Stock (Easy)</li> <li>0003 - Longest Substring Without Repeating Characters (Medium)</li> <li>0424 - Longest Repeating Character Replacement (Medium)</li> <li>0076 - Minimum Window Substring (Hard)</li> <li>0567 - Permutation in String (Medium)</li> <li>0239 - Sliding Window Maximum (Hard)</li> </ol>"},{"location":"neetcode_150/#121-best-time-to-buy-and-sell-stock","title":"121. Best Time to Buy and Sell Stock","text":"<pre><code>from typing import List\n\n\n# 1. Brute Force: O(n^2)\ndef maxProfitBF(prices: List[int]) -&gt; int:\n    # TC: O(n^2)\n    # SC: O(1)\n    maxProfit = 0\n    n = len(prices)\n    for i in range(n):\n        for j in range(i + 1, n):\n            maxProfit = max(maxProfit, prices[j] - prices[i])\n\n    return maxProfit\n\n\n# 2. DP\ndef maxProfitDP(prices: List[int]) -&gt; int:\n    # TC: O(n)\n    # SC: O(n)\n    dp = [[0] * 2 for _ in range(len(prices))]\n    dp[0][0] = -prices[0]  # buy\n    dp[0][1] = 0  # sell\n\n    for i in range(1, len(prices)):\n        dp[i][0] = max(dp[i - 1][0], -prices[i])  # the lowest price to buy\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# 3. Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    # TC: O(n)\n    # SC: O(1)\n    maxProfit = 0\n    seenMin = prices[0]\n\n    for i in range(1, len(prices)):\n        maxProfit = max(maxProfit, prices[i] - seenMin)\n        seenMin = min(seenMin, prices[i])\n\n    return maxProfit\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitBF(prices))  # 5\nprint(maxProfitDP(prices))  # 5\nprint(maxProfitGreedy(prices))  # 5\n</code></pre>"},{"location":"neetcode_150/#3-longest-substring-without-repeating-characters","title":"3. Longest Substring Without Repeating Characters","text":"<pre><code># Sliding Window - Variable\ndef lengthOfLongestSubstring(s: str) -&gt; int:\n    hashmap = dict()  # char: last index\n    left = 0\n    maxLen = 0\n\n    for right in range(len(s)):\n        if s[right] in hashmap and hashmap[s[right]] &gt;= left:\n            left = hashmap[s[right]] + 1\n\n        hashmap[s[right]] = right\n        maxLen = max(maxLen, right - left + 1)\n\n    return maxLen\n\n\ns = \"abcabcbb\"\nprint(lengthOfLongestSubstring(s))  # 3\n</code></pre>"},{"location":"neetcode_150/#424-longest-repeating-character-replacement","title":"424. Longest Repeating Character Replacement","text":"<pre><code>from collections import defaultdict\n\n\n# Sliding Window - Variable\ndef characterReplacement(s: str, k: int) -&gt; int:\n    left = 0\n    maxCount = 0\n    counts = defaultdict(int)\n    maxLen = 0\n\n    for right in range(len(s)):\n        counts[s[right]] += 1\n        maxCount = max(maxCount, counts[s[right]])\n\n        while right - left + 1 - maxCount &gt; k:\n            counts[s[left]] -= 1\n            left += 1\n\n        maxLen = max(maxLen, right - left + 1)\n\n    return maxLen\n\n\ns = \"ABAB\"\nk = 2\nprint(characterReplacement(s, k))  # 4\n</code></pre>"},{"location":"neetcode_150/#76-minimum-window-substring","title":"76. Minimum Window Substring","text":"<pre><code>from collections import Counter\n\n\ndef minWindow(s: str, t: str) -&gt; str:\n    if not t or not s:\n        return \"\"\n\n    counts = Counter(t)\n    required = len(counts)\n\n    left, right = 0, 0\n    formed = 0\n    window_counts = dict()\n\n    result = float(\"inf\"), None, None\n\n    while right &lt; len(s):\n        char = s[right]\n        window_counts[char] = window_counts.get(char, 0) + 1\n        if char in counts and window_counts[char] == counts[char]:\n            formed += 1\n\n        while left &lt;= right and formed == required:\n            char = s[left]\n            if right - left + 1 &lt; result[0]:\n                result = (right - left + 1, left, right)\n            window_counts[char] -= 1\n            if char in counts and window_counts[char] &lt; counts[char]:\n                formed -= 1\n            left += 1\n\n        right += 1\n\n    return \"\" if result[0] == float(\"inf\") else s[result[1] : result[2] + 1]\n\n\ns = \"ADOBECODEBANC\"\nt = \"ABC\"\nprint(minWindow(s, t))  # BANC\n</code></pre>"},{"location":"neetcode_150/#567-permutation-in-string","title":"567. Permutation in String","text":"<pre><code>def checkInclusion(s1: str, s2: str) -&gt; bool:\n    if len(s1) &gt; len(s2):\n        return False\n\n    count1 = [0] * 26\n    count2 = [0] * 26\n\n    for i in range(len(s1)):\n        count1[ord(s1[i]) - ord(\"a\")] += 1\n        count2[ord(s2[i]) - ord(\"a\")] += 1\n\n    matches = 0\n    for i in range(26):\n        if count1[i] == count2[i]:\n            matches += 1\n\n    l = 0\n    for r in range(len(s1), len(s2)):\n        if matches == 26:\n            return True\n\n        index = ord(s2[r]) - ord(\"a\")\n        count2[index] += 1\n        if count1[index] == count2[index]:\n            matches += 1\n        elif count1[index] + 1 == count2[index]:\n            matches -= 1\n\n        index = ord(s2[l]) - ord(\"a\")\n        count2[index] -= 1\n        if count1[index] == count2[index]:\n            matches += 1\n        elif count1[index] - 1 == count2[index]:\n            matches -= 1\n\n        l += 1\n\n    return matches == 26\n\n\ns1 = \"ab\"\ns2 = \"eidba\"\nprint(checkInclusion(s1, s2))  # True\n</code></pre>"},{"location":"neetcode_150/#stack","title":"Stack","text":"<ol> <li>0020 - Valid Parentheses (Easy)</li> <li>0155 - Min Stack (Easy)</li> <li>0150 - Evaluate Reverse Polish Notation (Medium)</li> <li>0022 - Generate Parentheses (Medium)</li> <li>0739 - Daily Temperatures (Medium)</li> <li>0853 - Car Fleet (Medium)</li> <li>0084 - Largest Rectangle in Histogram (Hard)</li> </ol>"},{"location":"neetcode_150/#20-valid-parentheses","title":"20. Valid Parentheses","text":"<pre><code>def isValid(s: str) -&gt; bool:\n    hashmap = {\n        \")\": \"(\",\n        \"]\": \"[\",\n        \"}\": \"{\",\n    }\n    stack = []\n\n    for c in s:\n        if c in hashmap:\n            if stack and stack[-1] == hashmap[c]:\n                stack.pop()\n            else:\n                return False\n        else:\n            stack.append(c)\n\n    return True if not stack else False\n\n\nprint(isValid(\"()\"))  # True\nprint(isValid(\"()[]{}\"))  # True\nprint(isValid(\"(]\"))  # False\n</code></pre>"},{"location":"neetcode_150/#155-min-stack","title":"155. Min Stack","text":"<pre><code>class MinStack:\n\n    def __init__(self):\n        self.stack = []\n        self.minStack = []\n\n    def push(self, val: int) -&gt; None:\n        self.stack.append(val)\n        val = min(val, self.minStack[-1] if self.minStack else val)\n        self.minStack.append(val)\n\n    def pop(self) -&gt; None:\n        if self.stack:\n            self.stack.pop()\n        if self.minStack:\n            self.minStack.pop()\n\n    def top(self) -&gt; int:\n        return self.stack[-1] if self.stack else None\n\n    def getMin(self) -&gt; int:\n        return self.minStack[-1] if self.minStack else None\n\n\n# Your MinStack object will be instantiated and called as such:\nobj = MinStack()\nobj.push(3)\nobj.push(2)\nobj.pop()\nprint(obj.top())  # 3\nprint(obj.getMin())  # 3\n</code></pre>"},{"location":"neetcode_150/#150-evaluate-reverse-polish-notation","title":"150. Evaluate Reverse Polish Notation","text":"<pre><code>from typing import List\n\n\ndef evalRPN(tokens: List[str]) -&gt; int:\n    stack = []\n\n    for c in tokens:\n        if c == \"+\":\n            stack.append(stack.pop() + stack.pop())\n        elif c == \"-\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(b - a)\n        elif c == \"*\":\n            stack.append(stack.pop() * stack.pop())\n        elif c == \"/\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(int(b / a))\n        else:\n            stack.append(int(c))\n\n    return stack[0]\n\n\nprint(evalRPN([\"2\", \"1\", \"+\", \"3\", \"*\"]))  # 9\nprint(evalRPN([\"4\", \"13\", \"5\", \"/\", \"-\"]))  # 2\nprint(evalRPN([\"18\"]))  # 18\nprint(evalRPN([\"4\", \"3\", \"-\"]))  # 1\n</code></pre>"},{"location":"neetcode_150/#22-generate-parentheses","title":"22. Generate Parentheses","text":"<pre><code>from typing import List\n\n\ndef generateParenthesis(n: int) -&gt; List[str]:\n    stack = []\n    result = []\n\n    def backtrack(openN, closeN):\n        if openN == closeN == n:\n            result.append(\"\".join(stack))\n            return None\n\n        if openN &lt; n:\n            stack.append(\"(\")\n            backtrack(openN + 1, closeN)\n            stack.pop()\n\n        if closeN &lt; openN:\n            stack.append(\")\")\n            backtrack(openN, closeN + 1)\n            stack.pop()\n\n    backtrack(0, 0)\n\n    return result\n\n\nprint(generateParenthesis(3))\n# ['((()))', '(()())', '(())()', '()(())', '()()()']\n</code></pre>"},{"location":"neetcode_150/#739-daily-temperatures","title":"739. Daily Temperatures","text":"<pre><code>from typing import List\n\n\ndef dailyTemperatures(temperatures: List[int]) -&gt; List[int]:\n    result = [0 for _ in range(len(temperatures))]\n    stack = []\n\n    for i, t in enumerate(temperatures):\n        while stack and t &gt; stack[-1][0]:\n            _, stackIdx = stack.pop()\n            result[stackIdx] = i - stackIdx\n        stack.append([t, i])\n\n    return result\n\n\nprint(dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73]))\n# [1, 1, 4, 2, 1, 1, 0, 0]\n</code></pre>"},{"location":"neetcode_150/#853-car-fleet","title":"853. Car Fleet","text":"<pre><code>from typing import List\n\n\ndef carFleet(target: int, position: List[int], speed: List[int]) -&gt; int:\n    cars = sorted(zip(position, speed), reverse=True)\n    stack = []\n\n    for p, s in cars:\n        time = (target - p) / s\n\n        if not stack or time &gt; stack[-1]:\n            stack.append(time)\n\n    return len(stack)\n\n\nprint(carFleet(12, [10, 8, 0, 5, 3], [2, 4, 1, 1, 3]))  # 3\n</code></pre>"},{"location":"neetcode_150/#84-largest-rectangle-in-histogram","title":"84. Largest Rectangle in Histogram","text":"<pre><code>from typing import List\n\n\ndef largestRectangleArea(heights: List[int]) -&gt; int:\n    maxArea = 0\n    stack = []  # pair: (index, height)\n\n    for i, h in enumerate(heights):\n        start = i\n        while stack and stack[-1][1] &gt; h:\n            index, height = stack.pop()\n            maxArea = max(maxArea, height * (i - index))\n            start = index\n        stack.append((start, h))\n\n    for i, h in stack:\n        maxArea = max(maxArea, h * (len(heights) - i))\n\n    return maxArea\n\n\nprint(largestRectangleArea([2, 1, 5, 6, 2, 3]))  # 10\n</code></pre>"},{"location":"neetcode_150/#binary-search","title":"Binary Search","text":"<ol> <li>0704 - Binary Search (Easy)</li> <li>0074 - Search a 2D Matrix (Medium)</li> <li>0875 - Koko Eating Bananas (Medium)</li> <li>0004 - Median of Two Sorted Arrays (Hard)</li> </ol>"},{"location":"neetcode_150/#704-binary-search","title":"704. Binary Search","text":"<pre><code>from typing import List\n\n\ndef search(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        middle = left + (right - left) // 2\n\n        if nums[middle] &gt; target:\n            right = middle - 1\n        elif nums[middle] &lt; target:\n            left = middle + 1\n        else:\n            return middle\n\n    return -1\n\n\nnums = [-1, 0, 3, 5, 9, 12]\ntarget = 9\nprint(search(nums, target))  # 4\n</code></pre>"},{"location":"neetcode_150/#74-search-a-2d-matrix","title":"74. Search a 2D Matrix","text":""},{"location":"neetcode_150/#875-koko-eating-bananas","title":"875. Koko Eating Bananas","text":"<pre><code>from typing import List\n\n\ndef minEatingSpeed(piles: List[int], h: int) -&gt; int:\n    def canEat(piles: List[int], k: int, h: int) -&gt; bool:\n        hours = 0\n        for pile in piles:\n            hours += (pile + k - 1) // k\n        return hours &lt;= h\n\n    left, right = 1, max(piles)\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if canEat(piles, mid, h):\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return left\n\n\npiles = [3, 6, 7, 11]\nh = 8\nprint(minEatingSpeed(piles, h))\n</code></pre>"},{"location":"neetcode_150/#4-median-of-two-sorted-arrays","title":"4. Median of Two Sorted Arrays","text":""},{"location":"neetcode_150/#linked-list","title":"Linked List","text":"<ol> <li>0206 - Reverse Linked List (Easy)</li> <li>0021 - Merge Two Sorted Lists (Easy)</li> <li>0143 - Reorder List (Medium)</li> <li>0019 - Remove Nth Node From End of List (Medium)</li> <li>0138 - Copy List with Random Pointer (Medium)</li> <li>0002 - Add Two Numbers (Medium)</li> <li>0141 - Linked List Cycle (Easy)</li> </ol>"},{"location":"neetcode_150/#206-reverse-linked-list","title":"206. Reverse Linked List","text":"<pre><code>from typing import Optional\n\nfrom helper import ListNode\n\n\n# 1. Iterative\ndef reverseListIterative(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    cur = head\n    prev = None\n\n    while cur:\n        temp = cur.next\n        cur.next = prev\n\n        prev = cur\n        cur = temp\n\n    return prev\n\n\n# 2. Recursive\ndef reverseListRecursive(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    def reverse(cur, prev=None):\n        if not cur:\n            return prev\n\n        temp = cur.next\n        cur.next = prev\n\n        return reverse(temp, cur)\n\n    return reverse(head)\n\n\nnums = [1, 2, 3, 4, 5]\nhead1 = ListNode.create(nums)\nprint(head1)\n# 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(reverseListIterative(head1))\n# 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1\nhead2 = ListNode.create(nums)\nprint(reverseListRecursive(head2))\n# 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1\n</code></pre>"},{"location":"neetcode_150/#21-merge-two-sorted-lists","title":"21. Merge Two Sorted Lists","text":""},{"location":"neetcode_150/#143-reorder-list","title":"143. Reorder List","text":""},{"location":"neetcode_150/#19-remove-nth-node-from-end-of-list","title":"19. Remove Nth Node From End of List","text":"<pre><code>from typing import Optional\n\nfrom helper import ListNode\n\n\ndef removeNthFromEnd(head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:\n    dummy = ListNode(0, head)\n    fast = slow = dummy\n\n    for _ in range(n + 1):\n        fast = fast.next\n\n    while fast:\n        fast = fast.next\n        slow = slow.next\n\n    slow.next = slow.next.next\n\n    return dummy.next\n\n\nhead = [1, 2, 3, 4, 5]\nn = 2\nhead = ListNode.create(head)\nprint(head)\n# 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(removeNthFromEnd(head, n))\n# 1 -&gt; 2 -&gt; 3 -&gt; 5\n</code></pre>"},{"location":"neetcode_150/#138-copy-list-with-random-pointer","title":"138. Copy List with Random Pointer","text":""},{"location":"neetcode_150/#2-add-two-numbers","title":"2. Add Two Numbers","text":""},{"location":"neetcode_150/#141-linked-list-cycle","title":"141. Linked List Cycle","text":"<pre><code>from typing import Optional\n\nfrom helper import ListNode\n\n\ndef hasCycle(head: Optional[ListNode]) -&gt; bool:\n    slow, fast = head, head\n\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n        if slow == fast:\n            return True\n\n    return False\n\n\nprint(hasCycle(ListNode.create([3, 2, 0, -4])))  # False\nprint(hasCycle(ListNode.create([3, 2, 0, -4], 1)))  # True\n</code></pre>"},{"location":"neetcode_150/#trees","title":"Trees","text":"<ol> <li>0226 - Invert Binary Tree (Easy)</li> <li>0104 - Maximum Depth of Binary Tree (Easy)</li> <li>0543 - Diameter of Binary Tree (Easy)</li> <li>0110 - Balanced Binary Tree (Easy)</li> <li>0100 - Same Tree (Easy)</li> <li>0572 - Subtree of Another Tree (Easy)</li> <li>0235 - Lowest Common Ancestor of a Binary Search Tree (Easy)</li> <li>0102 - Binary Tree Level Order Traversal (Medium)</li> <li>0199 - Binary Tree Right Side View (Medium)</li> <li>1448 - Count Good Nodes in Binary Tree (Medium)</li> <li>0098 - Validate Binary Search Tree (Medium)</li> <li>0230 - Kth Smallest Element in a BST (Medium)</li> <li>0105 - Construct Binary Tree from Preorder and Inorder Traversal (Medium)</li> <li>0124 - Binary Tree Maximum Path Sum (Hard)</li> <li>0297 - Serialize and Deserialize Binary Tree (Hard)</li> </ol>"},{"location":"neetcode_150/#226-invert-binary-tree","title":"226. Invert Binary Tree","text":"<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef invertTreeRecursive(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    root.left, root.right = root.right, root.left\n\n    invertTreeRecursive(root.left)\n    invertTreeRecursive(root.right)\n\n    return root\n\n\n# Iterative\ndef invertTreeIterative(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    stack = [root]\n\n    while stack:\n        node = stack.pop()\n\n        node.left, node.right = node.right, node.left\n        if node.left:\n            stack.append(node.left)\n        if node.right:\n            stack.append(node.right)\n\n    return root\n\n\nroot = build([4, 2, 7, 1, 3, 6, 9])\nprint(root)\n#     __4__\n#    /     \\\n#   2       7\n#  / \\     / \\\n# 1   3   6   9\ninvertedRecursive = invertTreeRecursive(root)\nprint(invertedRecursive)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\nroot = build([4, 2, 7, 1, 3, 6, 9])\ninvertedIterative = invertTreeIterative(root)\nprint(invertedIterative)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\n</code></pre>"},{"location":"neetcode_150/#104-maximum-depth-of-binary-tree","title":"104. Maximum Depth of Binary Tree","text":"<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Iterative\ndef maxDepthIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    queue = deque([root])\n    depth = 0\n\n    while queue:\n        depth += 1\n\n        for _ in range(len(queue)):\n            node = queue.popleft()\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n    return depth\n\n\n# Recursive\ndef maxDepthRecursive(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    return 1 + max(maxDepthRecursive(root.left), maxDepthRecursive(root.right))\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n\"\"\"\n    ____1\n   /     \\\n  2__     2\n /   \\\n3     4\n     /\n    5\n\"\"\"\nprint(maxDepthIterative(root))  # 4\nprint(maxDepthRecursive(root))  # 4\n</code></pre>"},{"location":"neetcode_150/#543-diameter-of-binary-tree","title":"543. Diameter of Binary Tree","text":""},{"location":"neetcode_150/#110-balanced-binary-tree","title":"110. Balanced Binary Tree","text":"<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef isBalanced(root: Optional[TreeNode]) -&gt; bool:\n    def getHeight(node):\n        if not node:\n            return 0\n\n        # post order\n        leftHeight = getHeight(node.left)\n        rightHeight = getHeight(node.right)\n\n        if leftHeight == -1 or rightHeight == -1:\n            return -1\n\n        if abs(leftHeight - rightHeight) &gt; 1:\n            return -1\n        else:\n            return 1 + max(leftHeight, rightHeight)\n\n    if getHeight(root) != -1:\n        return True\n    else:\n        return False\n\n\nroot = [3, 9, 20, None, None, 15, 7]\nroot = build(root)\nprint(root)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(isBalanced(root))  # True\n</code></pre>"},{"location":"neetcode_150/#100-same-tree","title":"100. Same Tree","text":"<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# 1. Recursive\ndef isSameTreeRecursive(p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:\n    if not p and not q:\n        return True\n    if not p or not q:\n        return False\n    if p.val != q.val:\n        return False\n\n    return isSameTreeRecursive(p.left, q.left) and isSameTreeRecursive(\n        p.right, q.right\n    )\n\n\n# 2. Iterative with queue\ndef isSameTreeIterativeQueue(\n    p: Optional[TreeNode], q: Optional[TreeNode]\n) -&gt; bool:\n    queue = deque([(p, q)])\n\n    while queue:\n        p, q = queue.popleft()\n\n        if not p and not q:\n            continue\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n\n        queue.append((p.left, q.left))\n        queue.append((p.right, q.right))\n\n    return True\n\n\n# 3. Iterative with stack\ndef isSameTreeIterativeStack(\n    p: Optional[TreeNode], q: Optional[TreeNode]\n) -&gt; bool:\n    stack = [(p, q)]\n\n    while stack:\n        n1, n2 = stack.pop()\n\n        if not n1 and not n2:\n            continue\n        if not n1 or not n2:\n            return False\n        if n1.val != n2.val:\n            return False\n\n        stack.append((n1.left, n2.left))\n        stack.append((n1.right, n2.right))\n\n    return True\n\n\np1 = build([1, 2, 3])\nq1 = build([1, 2, 3])\np2 = build([1, 2])\nq2 = build([1, None, 2])\n\nprint(isSameTreeRecursive(p1, q1))  # True\nprint(isSameTreeRecursive(p2, q2))  # False\nprint(isSameTreeIterativeQueue(p1, q1))  # True\nprint(isSameTreeIterativeQueue(p2, q2))  # False\nprint(isSameTreeIterativeStack(p1, q1))  # True\nprint(isSameTreeIterativeStack(p2, q2))  # False\n</code></pre>"},{"location":"neetcode_150/#572-subtree-of-another-tree","title":"572. Subtree of Another Tree","text":""},{"location":"neetcode_150/#235-lowest-common-ancestor-of-a-binary-search-tree","title":"235. Lowest Common Ancestor of a Binary Search Tree","text":"<pre><code>from binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef lowestCommonAncestor(\n    root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n) -&gt; \"TreeNode\":\n    while root:\n        if root.val &gt; p.val and root.val &gt; q.val:\n            root = root.left\n        elif root.val &lt; p.val and root.val &lt; q.val:\n            root = root.right\n        else:\n            return root\n\n\nroot = [6, 2, 8, 0, 4, 7, 9, None, None, 3, 5]\np = root.left\nq = root.right\nroot = build(root)\nprint(root)\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\nprint(lowestCommonAncestor(root, p, q))\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\n</code></pre>"},{"location":"neetcode_150/#102-binary-tree-level-order-traversal","title":"102. Binary Tree Level Order Traversal","text":"<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef levelOrder(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    queue = deque([root])\n    levels = []\n\n    while queue:\n        level = []\n        size = len(queue)\n\n        for _ in range(size):\n            current = queue.popleft()\n            level.append(current.val)\n\n            if current.left:\n                queue.append(current.left)\n            if current.right:\n                queue.append(current.right)\n\n        levels.append(level)\n\n    return levels\n\n\ntree = build([3, 9, 20, None, None, 15, 7])\nprint(tree)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(levelOrder(tree))  # [[3], [9, 20], [15, 7]]\n</code></pre>"},{"location":"neetcode_150/#199-binary-tree-right-side-view","title":"199. Binary Tree Right Side View","text":"<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef rightSideView(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    queue = deque([root])\n    result = []\n\n    while queue:\n        size = len(queue)\n\n        for i in range(size):\n            current = queue.popleft()\n\n            # rightmost element\n            if i == size - 1:\n                result.append(current.val)\n\n            if current.left:\n                queue.append(current.left)\n            if current.right:\n                queue.append(current.right)\n\n    return result\n\n\nroot = [1, 2, 2, 3, 4, None, 3, None, None, 5]\nroot = build(root)\nprint(root)\n#     ____1\n#    /     \\\n#   2__     2\n#  /   \\     \\\n# 3     4     3\n#      /\n#     5\nprint(rightSideView(root))  # [1, 2, 3, 5]\n</code></pre>"},{"location":"neetcode_150/#1448-count-good-nodes-in-binary-tree","title":"1448. Count Good Nodes in Binary Tree","text":""},{"location":"neetcode_150/#98-validate-binary-search-tree","title":"98. Validate Binary Search Tree","text":"<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef isValidBST(root: Optional[TreeNode]) -&gt; bool:\n\n    inorder = []  # inorder traversal of BST\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    for i in range(1, len(inorder)):\n        if inorder[i] &lt;= inorder[i - 1]:\n            return False\n\n    return True\n\n\nroot = [5, 1, 4, None, None, 3, 6]\nroot = build(root)\nprint(root)\n#   5__\n#  /   \\\n# 1     4\n#      / \\\n#     3   6\nprint(isValidBST(root))  # False\n</code></pre>"},{"location":"neetcode_150/#230-kth-smallest-element-in-a-bst","title":"230. Kth Smallest Element in a BST","text":""},{"location":"neetcode_150/#105-construct-binary-tree-from-preorder-and-inorder-traversal","title":"105. Construct Binary Tree from Preorder and Inorder Traversal","text":"<pre><code>from typing import List, Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef buildTree(preorder: List[int], inorder: List[int]) -&gt; Optional[TreeNode]:\n    \"\"\"\n    preorder  root left right  1  2  3\n    inorder   left root right  4  5  6\n    \"\"\"\n    if len(preorder) == 0:\n        return None\n\n    root_val = preorder[0]  # 1\n    root = TreeNode(root_val)\n\n    separator_idx = inorder.index(root_val)  # 5\n\n    left_inorder = inorder[:separator_idx]  # 4\n    right_inorder = inorder[separator_idx + 1 :]  # 6\n\n    left_preorder = preorder[1 : 1 + len(left_inorder)]  # 2\n    right_preorder = preorder[1 + len(left_inorder) :]  # 3\n\n    root.left = buildTree(left_preorder, left_inorder)\n    root.right = buildTree(right_preorder, right_inorder)\n\n    return root\n\n\npreorder = [3, 9, 20, 15, 7]\ninorder = [9, 3, 15, 20, 7]\nroot = buildTree(preorder, inorder)\nprint(root)\n#     3\n#    / \\\n#   9  20\n#     /  \\\n#    15   7\n</code></pre>"},{"location":"neetcode_150/#124-binary-tree-maximum-path-sum","title":"124. Binary Tree Maximum Path Sum","text":""},{"location":"neetcode_150/#297-serialize-and-deserialize-binary-tree","title":"297. Serialize and Deserialize Binary Tree","text":""},{"location":"neetcode_150/#tries","title":"Tries","text":"<ol> <li>0208 - Implement Trie (Prefix Tree) (Medium)</li> <li>0211 - Add and Search Word - Data structure design (Medium)</li> <li>0212 - Word Search II (Hard)</li> </ol>"},{"location":"neetcode_150/#208-implement-trie-prefix-tree","title":"208. Implement Trie (Prefix Tree)","text":"<pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.endOfWord = None\n\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.endOfWord = True\n\n    def search(self, word: str) -&gt; bool:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return node.endOfWord\n\n    def startsWith(self, prefix: str) -&gt; bool:\n        node = self.root\n\n        for c in prefix:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return True\n\n\n# Your Trie object will be instantiated and called as such:\nobj = Trie()\nobj.insert(\"apple\")\nprint(obj.search(\"word\"))  # False\nprint(obj.startsWith(\"app\"))  # True\n</code></pre>"},{"location":"neetcode_150/#211-add-and-search-word-data-structure-design","title":"211. Add and Search Word - Data structure design","text":"<pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.word = False\n\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.word = True\n\n    def search(self, word: str) -&gt; bool:\n\n        def dfs(j, root):\n            node = root\n\n            for i in range(j, len(word)):\n                c = word[i]\n\n                if c == \".\":\n                    for child in node.children.values():\n                        if dfs(i + 1, child):\n                            return True\n                    return False\n                else:\n                    if c not in node.children:\n                        return False\n                    node = node.children[c]\n            return node.word\n\n        return dfs(0, self.root)\n\n\n# Your WordDictionary object will be instantiated and called as such:\nobj = WordDictionary()\nobj.addWord(\"word\")\nprint(obj.search(\"word\"))\nprint(obj.search(\"w.rd\"))\n</code></pre>"},{"location":"neetcode_150/#212-word-search-ii","title":"212. Word Search II","text":"<pre><code>from typing import List\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.isWord = False\n\n    def addWord(self, word):\n        node = self\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.isWord = True\n\n\nclass Solution:\n    def findWords(self, board: List[List[str]], words: List[str]) -&gt; List[str]:\n        root = TrieNode()\n        for w in words:\n            root.addWord(w)\n\n        m, n = len(board), len(board[0])\n        result, visit = set(), set()\n\n        def dfs(r, c, node, word):\n            if (\n                r not in range(m)\n                or c not in range(n)\n                or (r, c) in visit\n                or board[r][c] not in node.children\n            ):\n                return None\n\n            visit.add((r, c))\n\n            node = node.children[board[r][c]]\n            word += board[r][c]\n            if node.isWord:\n                result.add(word)\n\n            dfs(r - 1, c, node, word)\n            dfs(r + 1, c, node, word)\n            dfs(r, c - 1, node, word)\n            dfs(r, c + 1, node, word)\n\n            visit.remove((r, c))\n\n        for r in range(m):\n            for c in range(n):\n                dfs(r, c, root, \"\")\n\n        return list(result)\n\n\n# Your Solution object will be instantiated and called as such:\nobj = Solution()\nprint(\n    obj.findWords(\n        [\n            [\"o\", \"a\", \"a\", \"n\"],\n            [\"e\", \"t\", \"a\", \"e\"],\n            [\"i\", \"h\", \"k\", \"r\"],\n            [\"i\", \"f\", \"l\", \"v\"],\n        ],\n        [\"oath\", \"pea\", \"eat\", \"rain\"],\n    )\n)\n# [\"oath\", \"eat\"]\n</code></pre>"},{"location":"neetcode_150/#heap-priority-queue","title":"Heap / Priority Queue","text":"<ol> <li>0703 - Kth Largest Element in a Stream (Easy)</li> <li>1046 - Last Stone Weight (Easy)</li> <li>0973 - K Closest Points to Origin (Medium)</li> <li>0621 - Task Scheduler (Medium)</li> <li>0355 - Design Twitter (Medium)</li> <li>0295 - Find Median from Data Stream (Hard)</li> </ol>"},{"location":"neetcode_150/#703-kth-largest-element-in-a-stream","title":"703. Kth Largest Element in a Stream","text":"<pre><code>import heapq\nfrom typing import List\n\n\nclass KthLargest:\n    def __init__(self, k: int, nums: List[int]):\n        self.k = k\n        self.heap = nums\n        heapq.heapify(self.heap)  # min heap\n\n        while len(self.heap) &gt; k:  # keep the heap size to k\n            heapq.heappop(self.heap)\n\n    def add(self, val: int) -&gt; int:\n        if (\n            len(self.heap) &lt; self.k\n        ):  # if heap size is less than k, push the value\n            heapq.heappush(self.heap, val)\n        # if the value is greater than the smallest element in the heap\n        # push the value and pop the smallest element\n        elif val &gt; self.heap[0]:\n            heapq.heappushpop(self.heap, val)\n\n        return self.heap[0]\n\n\nkthLargest = KthLargest(3, [4, 5, 8, 2])\nprint(kthLargest.add(3))  # 4\n</code></pre>"},{"location":"neetcode_150/#1046-last-stone-weight","title":"1046. Last Stone Weight","text":""},{"location":"neetcode_150/#973-k-closest-points-to-origin","title":"973. K Closest Points to Origin","text":"<pre><code>import heapq\nfrom typing import List\n\n\ndef kClosest(points: List[List[int]], k: int) -&gt; List[List[int]]:\n    heap = []\n\n    for x, y in points:\n        dist = -(x**2 + y**2)  # max heap\n        if len(heap) &lt; k:\n            heapq.heappush(heap, (dist, x, y))\n        else:\n            heapq.heappushpop(heap, (dist, x, y))  # push and pop the smallest\n\n    return [[x, y] for (_, x, y) in heap]\n\n\n# Time complexity: O(n * log(k))\n#   - O(log(k)) for heapify\n#   - O(n) for iterating through the input list\n# Space complexity: O(k)\n\npoints = [[1, 3], [-2, 2]]\nk = 1\nprint(kClosest(points, k))  # [[-2, 2]]\n</code></pre>"},{"location":"neetcode_150/#621-task-scheduler","title":"621. Task Scheduler","text":""},{"location":"neetcode_150/#355-design-twitter","title":"355. Design Twitter","text":""},{"location":"neetcode_150/#295-find-median-from-data-stream","title":"295. Find Median from Data Stream","text":"<pre><code>from heapq import heappop, heappush\n\n\n# Heap - Two Heaps\nclass MedianFinder:\n    def __init__(self):\n        self.max = []\n        self.min = []\n\n    def addNum(self, num: int) -&gt; None:\n        heappush(self.max, -num)\n        heappush(self.min, -heappop(self.max))\n\n        if len(self.min) &gt; len(self.max):\n            heappush(self.max, -heappop(self.min))\n\n    def findMedian(self) -&gt; float:\n        if len(self.max) == len(self.min):\n            return (-self.max[0] + self.min[0]) / 2.0\n        else:\n            return -self.max[0]\n\n\n# TC: O(log n)\n# SC: O(n)\n\nmedian_finder = MedianFinder()\nmedian_finder.addNum(1)\nmedian_finder.addNum(2)\nassert median_finder.findMedian() == 1.5\nmedian_finder.addNum(3)\nassert median_finder.findMedian() == 2\nmedian_finder.addNum(4)\nassert median_finder.findMedian() == 2.5\nmedian_finder.addNum(5)\nassert median_finder.findMedian() == 3\nprint(\"All Passed.\")\n</code></pre>"},{"location":"neetcode_150/#backtracking","title":"Backtracking","text":"<ol> <li>0078 - Subsets (Medium)</li> <li>0039 - Combination Sum (Medium)</li> <li>0046 - Permutations (Medium)</li> <li>0079 - Word Search (Medium)</li> <li>0131 - Palindrome Partitioning (Medium)</li> </ol>"},{"location":"neetcode_150/#78-subsets","title":"78. Subsets","text":"<pre><code>from typing import List\n\n\ndef subsets(nums: List[int]) -&gt; List[List[int]]:\n    path, result = [], []\n\n    def backtracking(startIndex):\n        result.append(path[:])\n\n        for i in range(startIndex, len(nums)):\n            path.append(nums[i])\n            backtracking(i + 1)\n            path.pop()\n\n    backtracking(startIndex=0)\n\n    return result\n\n\nprint(subsets([1, 2, 3]))\n# [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]\n</code></pre>"},{"location":"neetcode_150/#39-combination-sum","title":"39. Combination Sum","text":"<pre><code>from typing import List\n\n\ndef combinationSum(candidates: List[int], target: int) -&gt; List[List[int]]:\n    result = []\n    path = []\n\n    def backtracking(total, start):\n        if total &gt; target:\n            return None\n        if total == target:\n            result.append(path[:])\n            return None\n\n        for i in range(start, len(candidates)):\n            total += candidates[i]\n            path.append(candidates[i])\n\n            backtracking(total, i)\n\n            total -= candidates[i]\n            path.pop()\n\n    backtracking(0, 0)\n    return result\n\n\nprint(combinationSum([2, 3, 6, 7], 7))  # [[2, 2, 3], [7]]\n</code></pre>"},{"location":"neetcode_150/#46-permutations","title":"46. Permutations","text":"<pre><code>from typing import List\n\n\ndef permute(nums: List[int]) -&gt; List[List[int]]:\n    path, result = [], []\n    used = [False for _ in range(len(nums))]\n\n    def backtracking():\n        if len(path) == len(nums):\n            result.append(path[:])\n\n        for i in range(len(nums)):\n            if used[i]:\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtracking()\n            path.pop()\n            used[i] = False\n\n    backtracking()\n\n    return result\n\n\nprint(permute([1, 2, 3]))\n# [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n</code></pre>"},{"location":"neetcode_150/#79-word-search","title":"79. Word Search","text":"<pre><code>from typing import List\n\n\ndef exist(board: List[List[str]], word: str) -&gt; bool:\n    m, n = len(board), len(board[0])\n    path = set()\n    directions = ((0, 1), (1, 0), (0, -1), (-1, 0))\n\n    def dfs(r, c, i):\n        if i == len(word):\n            return True\n\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or board[r][c] != word[i]\n            or (r, c) in path\n        ):\n            return False\n\n        path.add((r, c))\n\n        for dr, dc in directions:\n            if dfs(r + dr, c + dc, i + 1):\n                return True\n\n        path.remove((r, c))\n        return False\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, 0):\n                return True\n\n    return False\n\n\nboard = [\n    [\"A\", \"B\", \"C\", \"E\"],\n    [\"S\", \"F\", \"C\", \"S\"],\n    [\"A\", \"D\", \"E\", \"E\"],\n]\nword = \"ABCCED\"\nprint(exist(board, word))  # True\n</code></pre>"},{"location":"neetcode_150/#131-palindrome-partitioning","title":"131. Palindrome Partitioning","text":"<pre><code>from typing import List\n\n\ndef partition(s: str) -&gt; List[List[str]]:\n    path, result = [], []\n\n    def backtracking(startIndex):\n        if startIndex == len(s):\n            result.append(path[:])\n            return None\n\n        for i in range(startIndex, len(s)):\n            if is_palindrome(s, startIndex, i):\n                path.append(s[startIndex : i + 1])\n                backtracking(i + 1)\n                path.pop()\n\n    def is_palindrome(s: str, start, end) -&gt; bool:\n        while start &lt; end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n\n        return True\n\n    backtracking(0)\n\n    return result\n\n\nprint(partition(\"aab\"))  # [['a', 'a', 'b'], ['aa', 'b']]\n</code></pre>"},{"location":"neetcode_150/#graphs","title":"Graphs","text":"<ol> <li>0200 - Number of Islands (Medium)</li> <li>0133 - Clone Graph (Medium)</li> <li>0695 - Max Area of Island (Medium)</li> <li>0417 - Pacific Atlantic Water Flow (Medium)</li> <li>0130 - Surrounded Regions (Medium)</li> <li>0994 - Rotting Oranges (Medium)</li> <li>0207 - Course Schedule (Medium)</li> <li>0210 - Course Schedule II (Medium)</li> <li>0684 - Redundant Connection (Medium)</li> <li>0261 - Graph Valid Tree (Medium)</li> <li>0323 - Number of Connected Components in an Undirected Graph (Medium)</li> <li>0127 - Word Ladder (Medium)</li> </ol>"},{"location":"neetcode_150/#200-number-of-islands","title":"200. Number of Islands","text":"<pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# 1. DFS\ndef numIslandsDFS(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n    m, n = len(grid), len(grid[0])\n    islands = 0\n\n    def dfs(r, c):\n        if r not in range(m) or c not in range(n) or grid[r][c] == \"0\":\n            return None\n\n        grid[r][c] = \"0\"\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                dfs(r, c)\n                islands += 1\n\n    return islands\n\n\n# 2. BFS + Set\ndef numIslandsBFS1(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    islands = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr = row + dr\n                nc = col + dc\n                if (\n                    nr in range(m)\n                    and nc in range(n)\n                    and grid[nr][nc] == \"1\"\n                    and (nr, nc) not in visited\n                ):\n                    visited.add((nr, nc))\n                    q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\" and (r, c) not in visited:\n                visited.add((r, c))\n                bfs(r, c)\n                islands += 1\n\n    return islands\n\n\n# 3. BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    islands = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr, nc = row + dr, col + dc\n                if nr in range(m) and nc in range(n) and grid[nr][nc] == \"1\":\n                    q.append((nr, nc))\n                    grid[nr][nc] = \"0\"\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                grid[r][c] = \"0\"\n                bfs(r, c)\n                islands += 1\n\n    return islands\n\n\ngrid = [\n    [\"1\", \"1\", \"1\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"0\", \"0\", \"0\", \"0\", \"0\"],\n]\n\nprint(numIslandsDFS(deepcopy(grid)))  # 1\nprint(numIslandsBFS1(deepcopy(grid)))  # 1\nprint(numIslandsBFS2(deepcopy(grid)))  # 1\n</code></pre>"},{"location":"neetcode_150/#133-clone-graph","title":"133. Clone Graph","text":"<pre><code>from collections import deque\nfrom typing import Optional\n\n\nclass Node:\n    def __init__(self, val=0, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\n\n# 1. DFS\ndef cloneGraphDFS(node: Optional[\"Node\"]) -&gt; Optional[\"Node\"]:\n    if not node:\n        return None\n\n    cloned = {}  # {old: new}\n\n    def dfs(node):\n        if node in cloned:\n            return cloned[node]\n\n        new = Node(node.val)\n        cloned[node] = new\n\n        for neighbor in node.neighbors:\n            new.neighbors.append(dfs(neighbor))\n\n        return new\n\n    return dfs(node)\n\n\n# 2. BFS\ndef cloneGraphBFS(node: Optional[\"Node\"]) -&gt; Optional[\"Node\"]:\n    if not node:\n        return None\n\n    cloned = {node: Node(node.val)}\n    q = deque([node])\n\n    while q:\n        cur = q.popleft()\n\n        for neighbor in cur.neighbors:\n            if neighbor not in cloned:\n                cloned[neighbor] = Node(neighbor.val)\n                q.append(neighbor)\n\n            cloned[cur].neighbors.append(cloned[neighbor])\n\n    return cloned[node]\n</code></pre>"},{"location":"neetcode_150/#695-max-area-of-island","title":"695. Max Area of Island","text":"<pre><code>from collections import deque\nfrom typing import List\n\n\n# 1. DFS\ndef maxAreaOfIslandDFS(grid: List[List[int]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    visited = set()\n    area = 0\n\n    def dfs(r, c):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or grid[r][c] == 0\n            or (r, c) in visited\n        ):\n            return 0\n\n        visited.add((r, c))\n        return (\n            1 + dfs(r - 1, c) + dfs(r + 1, c) + dfs(r, c - 1) + dfs(r, c + 1)\n        )\n\n    for r in range(m):\n        for c in range(n):\n            area = max(area, dfs(r, c))\n\n    return area\n\n\n# 2. BFS\ndef maxAreaOfIslandBFS1(grid: List[List[int]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    area = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        subArea = 0\n\n        while q:\n            row, col = q.popleft()\n            subArea += 1\n\n            for dr, dc in directions:\n                nr = row + dr\n                nc = col + dc\n                if (\n                    nr in range(m)\n                    and nc in range(n)\n                    and grid[nr][nc] == 1\n                    and (nr, nc) not in visited\n                ):\n                    visited.add((nr, nc))\n                    q.append((nr, nc))\n\n        return subArea\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1 and (r, c) not in visited:\n                visited.add((r, c))\n                area = max(area, bfs(r, c))\n\n    return area\n\n\n# 3. BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    area = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        subArea = 0\n\n        while q:\n            row, col = q.popleft()\n            subArea += 1\n\n            for dr, dc in directions:\n                nr = row + dr\n                nc = col + dc\n                if nr in range(m) and nc in range(n) and grid[nr][nc] == 1:\n                    q.append((nr, nc))\n                    grid[nr][nc] = 0\n\n        return subArea\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                grid[r][c] = 0\n                area = max(area, bfs(r, c))\n\n    return area\n\n\ngrid = [\n    [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0],\n    [0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],\n]\nprint(maxAreaOfIslandDFS(grid))  # 6\nprint(maxAreaOfIslandBFS1(grid))  # 6\nprint(numIslandsBFS2(grid))  # 6\n</code></pre>"},{"location":"neetcode_150/#417-pacific-atlantic-water-flow","title":"417. Pacific Atlantic Water Flow","text":"<pre><code>from collections import deque\nfrom typing import List\n\n\n# 1. DFS\ndef pacificAtlanticDFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n\n    def dfs(r, c, visited, prevHeight):\n        if (\n            (r, c) in visited\n            or r not in range(m)\n            or c not in range(n)\n            or heights[r][c] &lt; prevHeight\n        ):\n            return None\n\n        visited.add((r, c))\n        height = heights[r][c]\n\n        dfs(r + 1, c, visited, height)\n        dfs(r - 1, c, visited, height)\n        dfs(r, c + 1, visited, height)\n        dfs(r, c - 1, visited, height)\n\n    for c in range(n):\n        dfs(0, c, pac, heights[0][c])  # top\n        dfs(m - 1, c, atl, heights[m - 1][c])  # bottom\n\n    for r in range(m):\n        dfs(r, 0, pac, heights[r][0])  # left\n        dfs(r, n - 1, atl, heights[r][n - 1])  # right\n\n    return list(pac &amp; atl)\n\n\n# 2. BFS\ndef pacificAtlanticBFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def bfs(r, c, visited):\n        q = deque([(r, c)])\n        visited.add((r, c))\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr in range(m)\n                    and nc in range(n)\n                    and heights[nr][nc] &lt; heights[row][col]\n                    and (nr, nc) not in visited\n                ):\n                    q.append((nr, nc))\n                    visited.add((nr, nc))\n\n    for c in range(n):\n        bfs(0, c, pac)  # top\n        bfs(m - 1, c, atl)  # bottom\n\n    for r in range(m):\n        bfs(r, 0, pac)  # left\n        bfs(r, n - 1, atl)  # right\n\n    return list(pac &amp; atl)\n\n\nheights = [\n    [1, 2, 2, 3, 5],\n    [3, 2, 3, 4, 4],\n    [2, 4, 5, 3, 1],\n    [6, 7, 1, 4, 5],\n    [5, 1, 1, 2, 4],\n]\nprint(pacificAtlanticDFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\nprint(pacificAtlanticBFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\n</code></pre>"},{"location":"neetcode_150/#130-surrounded-regions","title":"130. Surrounded Regions","text":"<pre><code>from collections import deque\nfrom copy import deepcopy\nfrom pprint import pprint\nfrom typing import List\n\n\n# 1. DFS\ndef solveDFS(board: List[List[str]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n    if not board and not board[0]:\n        return None\n\n    m, n = len(board), len(board[0])\n\n    def capture(r, c):\n        if r not in range(m) or c not in range(n) or board[r][c] != \"O\":\n            return None\n\n        board[r][c] = \"T\"\n        capture(r + 1, c)\n        capture(r - 1, c)\n        capture(r, c + 1)\n        capture(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\" and (r in [0, m - 1] or c in [0, n - 1]):\n                capture(r, c)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\":\n                board[r][c] = \"X\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"T\":\n                board[r][c] = \"O\"\n\n\n# 2. BFS\ndef solveBFS(board: List[List[str]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n    if not board and not board[0]:\n        return None\n\n    m, n = len(board), len(board[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def capture(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr = row + dr\n                nc = col + dc\n                if nr in range(m) and nc in range(n) and board[nr][nc] == \"O\":\n                    q.append((nr, nc))\n                    board[nr][nc] = \"T\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\" and (r in [0, m - 1] or c in [0, n - 1]):\n                board[r][c] = \"T\"\n                capture(r, c)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\":\n                board[r][c] = \"X\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"T\":\n                board[r][c] = \"O\"\n\n\nboard = [\n    [\"X\", \"X\", \"X\", \"X\"],\n    [\"X\", \"O\", \"O\", \"X\"],\n    [\"X\", \"X\", \"O\", \"X\"],\n    [\"X\", \"O\", \"X\", \"X\"],\n]\nboard1 = deepcopy(board)\nsolveDFS(board1)\npprint(board1)\n# [['X', 'X', 'X', 'X'],\n#  ['X', 'X', 'X', 'X'],\n#  ['X', 'X', 'X', 'X'],\n#  ['X', 'O', 'X', 'X']]\n\nboard2 = deepcopy(board)\nsolveBFS(board2)\npprint(board2)\n# [['X', 'X', 'X', 'X'],\n#  ['X', 'X', 'X', 'X'],\n#  ['X', 'X', 'X', 'X'],\n#  ['X', 'O', 'X', 'X']]\n</code></pre>"},{"location":"neetcode_150/#994-rotting-oranges","title":"994. Rotting Oranges","text":"<pre><code>from collections import deque\nfrom typing import List\n\n\ndef orangesRotting(grid: List[List[int]]) -&gt; int:\n    q = deque()\n    time, fresh = 0, 0\n    m, n = len(grid), len(grid[0])\n    directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                fresh += 1\n            if grid[r][c] == 2:\n                q.append([r, c])\n\n    while q and fresh &gt; 0:\n        for _ in range(len(q)):\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr, nc = row + dr, col + dc\n                if nr in range(m) and nc in range(n) and grid[nr][nc] == 1:\n                    grid[nr][nc] = 2\n                    q.append([nr, nc])\n                    fresh -= 1\n        time += 1\n\n    return time if fresh == 0 else -1\n\n\ngrid = [[2, 1, 1], [1, 1, 0], [0, 1, 1]]\nprint(orangesRotting(grid))\n</code></pre>"},{"location":"neetcode_150/#207-course-schedule","title":"207. Course Schedule","text":"<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# 1. BFS - Kahn's Algorithm\ndef canFinishBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    adj = defaultdict(list)\n    indegree = [0] * numCourses\n\n    for crs, pre in prerequisites:\n        adj[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    count = 0\n\n    while q:\n        crs = q.popleft()\n        count += 1\n\n        for next in adj[crs]:\n            indegree[next] -= 1\n\n            if indegree[next] == 0:\n                q.append(next)\n\n    return count == numCourses\n\n\n# 2. DFS + Set\ndef canFinishDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    adj = defaultdict(list)\n    for crs, pre in prerequisites:\n        adj[crs].append(pre)\n\n    visited = set()\n\n    def dfs(crs):\n        if crs in visited:  # cycle detected\n            return False\n        if adj[crs] == []:\n            return True\n\n        visited.add(crs)\n\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        visited.remove(crs)\n        adj[crs] = []\n\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\n# 3. DFS + List\ndef canFinishDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    adj = defaultdict(list)\n    for pre, crs in prerequisites:\n        adj[crs].append(pre)\n\n    # 0: not visited, 1: visiting, 2: visited\n    visited = [0] * numCourses\n\n    def dfs(crs):\n        if visited[crs] == 1:  # cycle detected\n            return False\n        if visited[crs] == 2:\n            return True\n\n        visited[crs] = 1\n\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        visited[crs] = 2\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(canFinishBFS(5, prerequisites))  # True\nprint(canFinishDFS1(5, prerequisites))  # True\nprint(canFinishDFS2(5, prerequisites))  # True\n</code></pre>"},{"location":"neetcode_150/#210-course-schedule-ii","title":"210. Course Schedule II","text":"<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# 1. BFS - Kahn's Algorithm\ndef findOrderBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]:\n    adj = defaultdict(list)\n    indegree = [0] * numCourses\n\n    for crs, pre in prerequisites:\n        adj[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    order = []\n\n    while q:\n        crs = q.popleft()\n        order.append(crs)\n\n        for next in adj[crs]:\n            indegree[next] -= 1\n\n            if indegree[next] == 0:\n                q.append(next)\n\n    if len(order) == numCourses:\n        return order\n    else:\n        return []\n\n\n# 2. DFS + Set\ndef findOrderDFS1(\n    numCourses: int, prerequisites: List[List[int]]\n) -&gt; List[int]:\n    adj = defaultdict(list)\n    for crs, pre in prerequisites:\n        adj[crs].append(pre)\n\n    visit, cycle = set(), set()\n    order = []\n\n    def dfs(crs):\n        if crs in cycle:\n            return False\n        if crs in visit:\n            return True\n\n        cycle.add(crs)\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        cycle.remove(crs)\n        visit.add(crs)\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order\n\n\n# 3. DFS + List\ndef findOrderDFS2(\n    numCourses: int, prerequisites: List[List[int]]\n) -&gt; List[int]:\n    adj = defaultdict(list)\n    for pre, crs in prerequisites:\n        adj[crs].append(pre)\n\n    # 0: not visited, 1: visiting, 2: visited\n    state = [0] * numCourses\n    order = []\n\n    def dfs(crs):\n        if state[crs] == 1:\n            return False\n        if state[crs] == 2:\n            return True\n\n        state[crs] = 1\n\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        state[crs] = 2\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order[::-1]\n\n\nnumCourses = 5\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(findOrderBFS(numCourses, prerequisites))  # [2, 4, 3, 1, 0]\nprint(findOrderDFS1(numCourses, prerequisites))  # [4, 3, 1, 2, 0]\nprint(findOrderDFS2(numCourses, prerequisites))  # [4, 3, 2, 1, 0]\n</code></pre>"},{"location":"neetcode_150/#684-redundant-connection","title":"684. Redundant Connection","text":"<pre><code>from typing import List\n\n\n# 1. Union Find\ndef findRedundantConnectionUF(edges: List[List[int]]) -&gt; List[int]:\n    par = [i for i in range(len(edges) + 1)]\n    rank = [1 for _ in range(len(edges) + 1)]\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]  # path compression\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 == p2:\n            return False\n\n        if rank[p1] &gt; rank[p2]:\n            par[p2] = p1\n            rank[p1] += rank[p2]\n        else:\n            par[p1] = p2\n            rank[p2] += rank[p1]\n\n        return True\n\n    for n1, n2 in edges:\n        if not union(n1, n2):\n            return [n1, n2]\n\n\n# 2. DFS\ndef findRedundantConnectionDFS(edges: List[List[int]]) -&gt; List[int]:\n    adj, cycle = {}, {}\n    for a, b in edges:\n        adj.setdefault(a, []).append(b)\n        adj.setdefault(b, []).append(a)\n\n    def dfs(node, parent):\n        if node in cycle:\n            for k in list(cycle.keys()):\n                if k == node:\n                    return True\n                del cycle[k]\n        cycle[node] = None\n        for child in adj[node]:\n            if child != parent and dfs(child, node):\n                return True\n        del cycle[node]\n        return False\n\n    dfs(edges[0][0], -1)\n    for a, b in edges[::-1]:\n        if a in cycle and b in cycle:\n            return (a, b)\n\n\nedges = [[1, 2], [1, 3], [2, 3]]\nprint(findRedundantConnectionUF(edges))  # [2, 3]\nprint(findRedundantConnectionDFS(edges))  # [2, 3]\n</code></pre>"},{"location":"neetcode_150/#261-graph-valid-tree","title":"261. Graph Valid Tree","text":"<pre><code>from typing import List\n\n\ndef validTree(n: int, edges: List[List[int]]) -&gt; bool:\n    if not n:\n        return True\n\n    if len(edges) != n - 1:\n        return False\n\n    adj = {i: [] for i in range(n)}\n    for n1, n2 in edges:\n        adj[n1].append(n2)\n        adj[n2].append(n1)\n\n    visit = set()\n\n    def dfs(node, parent):\n        if node in visit:\n            return False\n\n        visit.add(node)\n\n        for child in adj[node]:\n            if child == parent:\n                continue\n            if not dfs(child, node):\n                return False\n\n        return True\n\n    return dfs(0, -1) and len(visit) == n\n\n\nprint(validTree(5, [[0, 1], [0, 2], [0, 3], [1, 4]]))  # True\nprint(validTree(5, [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]))  # False\n</code></pre>"},{"location":"neetcode_150/#323-number-of-connected-components-in-an-undirected-graph","title":"323. Number of Connected Components in an Undirected Graph","text":"<pre><code>from typing import List\n\n\n# Union Find\ndef countComponents(n: int, edges: List[List[int]]) -&gt; int:\n    parent = [i for i in range(n)]\n    rank = [1 for _ in range(n)]\n\n    def find(node):\n        root = node\n\n        while root != parent[root]:\n            parent[root] = parent[parent[root]]\n            root = parent[root]\n        return root\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 == p2:\n            return 0\n\n        if rank[p2] &gt; rank[p1]:\n            parent[p1] = p2\n            rank[p2] += rank[p1]\n        else:\n            parent[p2] = p1\n            rank[p1] += rank[p2]\n        return 1\n\n    count = n\n    for n1, n2 in edges:\n        count -= union(n1, n2)\n\n    return count\n\n\nprint(countComponents(5, [[0, 1], [1, 2], [3, 4]]))\n</code></pre>"},{"location":"neetcode_150/#127-word-ladder","title":"127. Word Ladder","text":"<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef ladderLength(beginWord: str, endWord: str, wordList: List[str]) -&gt; int:\n    # TC: O(N * M^2)\n    # SC: O(N * M)\n    # N = len(wordList), M = len(word)\n\n    if endWord not in wordList:\n        return 0\n\n    adj = defaultdict(list)  # {pattern: [word1, word2, ...]}\n    wordList.append(beginWord)\n\n    for word in wordList:\n        for j in range(len(word)):\n            pattern = word[:j] + \"*\" + word[j + 1 :]\n            adj[pattern].append(word)\n\n    visited = set([beginWord])\n    q = deque([beginWord])\n    steps = 1\n\n    while q:\n        for _ in range(len(q)):\n            word = q.popleft()\n            if word == endWord:\n                return steps\n\n            for j in range(len(word)):\n                pattern = word[:j] + \"*\" + word[j + 1 :]\n                for neighbor in adj[pattern]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        q.append(neighbor)\n        steps += 1\n\n    return 0\n\n\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]\nprint(ladderLength(beginWord, endWord, wordList))  # 5\n</code></pre>"},{"location":"neetcode_150/#advanced-graphs","title":"Advanced Graphs","text":"<ol> <li>0269 - Alien Dictionary (Hard)</li> <li>0787 - Cheapest Flights Within K Stops (Medium)</li> <li>0743 - Network Delay Time (Medium)</li> <li>0452 - Minimum Number of Arrows to Burst Balloons (Medium)</li> <li>1514 - Path with Maximum Probability (Medium)</li> <li>1584 - Min Cost to Connect All Points (Medium)</li> <li>0778 - Swim in Rising Water (Hard)</li> <li>1489 - Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree (Hard)</li> <li>0332 - Reconstruct Itinerary (Medium)</li> </ol>"},{"location":"neetcode_150/#269-alien-dictionary","title":"269. Alien Dictionary","text":"<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# 1. BFS\ndef alienOrderBFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    indegree = {c: 0 for word in words for c in word}\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                    indegree[w2[j]] += 1\n                break\n\n    q = deque([c for c in indegree if indegree[c] == 0])\n    result = []\n\n    while q:\n        char = q.popleft()\n        result.append(char)\n\n        for neighbor in graph[char]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n\n    if len(result) == len(indegree):\n        return \"\".join(result)\n    else:\n        return \"\"\n\n\n# 2. DFS\ndef alienOrderDFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    visited = {}\n    result = []\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                break\n\n    def dfs(c):\n        if c in visited:\n            return visited[c]\n\n        visited[c] = False\n        for neighbor in graph[c]:\n            if not dfs(neighbor):\n                return False\n\n        visited[c] = True\n        result.append(c)\n        return True\n\n    for c in list(graph.keys()):\n        if not dfs(c):\n            return \"\"\n\n    return \"\".join(result[::-1])\n\n\nwords = [\"wrt\", \"wrf\", \"er\", \"ett\", \"rftt\"]\nprint(alienOrderBFS(words))  # wertf\nprint(alienOrderDFS(words))  # wrt\n</code></pre>"},{"location":"neetcode_150/#787-cheapest-flights-within-k-stops","title":"787. Cheapest Flights Within K Stops","text":"<ul> <li>Return the cheapest price from <code>src</code> to <code>dst</code> with at most <code>K</code> stops.</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# Bellman-Ford\ndef findCheapestPriceBF(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    dist = [float(\"inf\")] * n\n    dist[src] = 0\n\n    for _ in range(k + 1):\n        temp = dist[:]\n        for u, v, w in flights:\n            temp[v] = min(temp[v], dist[u] + w)\n        dist = temp\n\n    return dist[dst] if dist[dst] != float(\"inf\") else -1\n\n\nn = 4\nflights = [[0, 1, 100], [1, 2, 100], [2, 0, 100], [1, 3, 600], [2, 3, 200]]\nsrc = 0\ndst = 3\nk = 1\nprint(findCheapestPriceBF(n, flights, src, dst, k))  # 700\n</code></pre>"},{"location":"neetcode_150/#743-network-delay-time","title":"743. Network Delay Time","text":"<pre><code>from collections import defaultdict\nfrom heapq import heappop, heappush\nfrom typing import List\n\n\n# 1. Dijkstra - Set\ndef networkDelayTime1(times: List[List[int]], n: int, k: int) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    minHeap = [(0, k)]  # (weight, node)\n    visited = set()\n    delay = 0\n\n    while minHeap:\n        cur, u = heappop(minHeap)\n\n        if u in visited:\n            continue\n        visited.add(u)\n\n        delay = max(delay, cur)\n\n        for v, w in graph[u]:\n            if v not in visited:\n                heappush(minHeap, (cur + w, v))\n\n    return delay if len(visited) == n else -1\n\n\n# 2. Dijkstra - Dict\ndef networkDelayTime2(times: List[List[int]], n: int, k: int) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    minHeap = [(0, k)]  # (weight, node)\n    dist = defaultdict(int)\n    dist[k] = 0\n\n    while minHeap:\n        cur, u = heappop(minHeap)\n\n        if cur &gt; dist[u]:\n            continue\n\n        for v, w in graph[u]:\n            path = cur + w\n            if v not in dist or path &lt; dist[v]:\n                dist[v] = path\n                heappush(minHeap, (path, v))\n\n    return max(dist.values()) if len(dist) == n else -1\n\n\n# 3. Bellman-Ford\ndef networkDelayTimeBF(times: List[List[int]], n: int, k: int) -&gt; int:\n    # TC: O(N * E)\n    # SC: O(N)\n\n    dist = [float(\"inf\")] * n\n    dist[k - 1] = 0\n\n    for _ in range(n - 1):\n        for u, v, w in times:\n            if dist[u - 1] + w &lt; dist[v - 1]:\n                dist[v - 1] = dist[u - 1] + w\n\n    if any(d == float(\"inf\") for d in dist):\n        return -1\n\n    return max(dist)\n\n\ntimes = [[2, 1, 1], [2, 3, 1], [3, 4, 1]]\nn = 4\nk = 2\nprint(networkDelayTime1(times, n, k))  # 2\nprint(networkDelayTime2(times, n, k))  # 2\nprint(networkDelayTimeBF(times, n, k))  # 2\n</code></pre>"},{"location":"neetcode_150/#452-minimum-number-of-arrows-to-burst-balloons","title":"452. Minimum Number of Arrows to Burst Balloons","text":"<pre><code>from typing import List\n\n\n# Greedy - Interval\ndef findMinArrowShots(points: List[List[int]]) -&gt; int:\n\n    n = len(points)\n    if n == 0:\n        return 0\n\n    points.sort(key=lambda x: x[0])\n    result = 1\n\n    for i in range(1, n):\n        if points[i][0] &gt; points[i - 1][1]:\n            result += 1\n        else:\n            points[i][1] = min(points[i - 1][1], points[i][1])\n\n    return result\n\n\nprint(findMinArrowShots([[10, 16], [2, 8], [1, 6], [7, 12]]))  # 2\n</code></pre>"},{"location":"neetcode_150/#1514-path-with-maximum-probability","title":"1514. Path with Maximum Probability","text":""},{"location":"neetcode_150/#1584-min-cost-to-connect-all-points","title":"1584. Min Cost to Connect All Points","text":"<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim's Algorithm\ndef minCostConnectPoints(points: List[List[int]]) -&gt; int:\n    n = len(points)\n\n    graph = defaultdict(list)\n    for i in range(n):\n        x1, y1 = points[i]\n        for j in range(i + 1, n):\n            x2, y2 = points[j]\n            dist = abs(x1 - x2) + abs(y1 - y2)\n            graph[i].append((dist, j))\n            graph[j].append((dist, i))\n\n    cost = 0\n    visit = set()\n    minHeap = [(0, 0)]\n\n    while len(visit) &lt; n:\n        dist, node = heapq.heappop(minHeap)\n        if node in visit:\n            continue\n        visit.add(node)\n        cost += dist\n        for distance, neighbor in graph[node]:\n            if neighbor not in visit:\n                heapq.heappush(minHeap, (distance, neighbor))\n\n    return cost\n\n\npoints = [[0, 0], [2, 2], [3, 10], [5, 2], [7, 0]]\nprint(minCostConnectPoints(points))  # 20\n</code></pre>"},{"location":"neetcode_150/#778-swim-in-rising-water","title":"778. Swim in Rising Water","text":"<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra's\ndef swimInWater(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    visited = set()\n    minHeap = [(grid[0][0], 0, 0)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    visited.add((0, 0))\n\n    while minHeap:\n        time, r, c = heapq.heappop(minHeap)\n\n        if r == n - 1 and c == n - 1:\n            return time\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if nr in range(n) and nc in range(n) and (nr, nc) not in visited:\n                visited.add((nr, nc))\n                heapq.heappush(minHeap, (max(time, grid[nr][nc]), nr, nc))\n\n\ngrid = [\n    [0, 1, 2, 3, 4],\n    [24, 23, 22, 21, 5],\n    [12, 13, 14, 15, 16],\n    [11, 17, 18, 19, 20],\n    [10, 9, 8, 7, 6],\n]\nprint(swimInWater(grid))  # 16\n</code></pre>"},{"location":"neetcode_150/#1489-find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree","title":"1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree","text":""},{"location":"neetcode_150/#332-reconstruct-itinerary","title":"332. Reconstruct Itinerary","text":"<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hierholzer's Algorithm\ndef findItinerary1(tickets: List[List[str]]) -&gt; List[str]:\n    graph = defaultdict(list)\n    for u, v in sorted(tickets, reverse=True):\n        graph[u].append(v)\n\n    route = []\n\n    def dfs(node):\n        while graph[node]:\n            dfs(graph[node].pop())\n        route.append(node)\n\n    dfs(\"JFK\")\n\n    return route[::-1]\n\n\n# DFS + Backtracking\ndef findItinerary2(tickets: List[List[str]]) -&gt; List[str]:\n    graph = defaultdict(list)\n    tickets.sort()\n    for u, v in tickets:\n        graph[u].append(v)\n\n    res = [\"JFK\"]\n\n    def dfs(node):\n        if len(res) == len(tickets) + 1:\n            return True\n        if node not in graph:\n            return False\n\n        temp = list(graph[node])\n        for i, v in enumerate(temp):\n            graph[node].pop(i)\n            res.append(v)\n            if dfs(v):\n                return True\n            graph[node].insert(i, v)\n            res.pop()\n        return False\n\n    dfs(\"JFK\")\n\n    return res\n\n\ntickets = [[\"MUC\", \"LHR\"], [\"JFK\", \"MUC\"], [\"SFO\", \"SJC\"], [\"LHR\", \"SFO\"]]\nprint(findItinerary1(tickets))\n# [\"JFK\", \"MUC\", \"LHR\", \"SFO\", \"SJC\"]\nprint(findItinerary2(tickets))\n# [\"JFK\", \"MUC\", \"LHR\", \"SFO\", \"SJC\"]\n</code></pre>"},{"location":"neetcode_150/#1-d-dynamic-programming","title":"1-D Dynamic Programming","text":"<ol> <li>0070 - Climbing Stairs (Easy)</li> <li>0746 - Min Cost Climbing Stairs (Easy)</li> <li>0198 - House Robber (Easy)</li> <li>0213 - House Robber II (Medium)</li> <li>0005 - Longest Palindromic Substring (Medium)</li> <li>0647 - Palindromic Substrings (Medium)</li> <li>0091 - Decode Ways (Medium)</li> <li>0322 - Coin Change (Medium)</li> <li>0152 - Maximum Product Subarray (Medium)</li> </ol>"},{"location":"neetcode_150/#70-climbing-stairs","title":"70. Climbing Stairs","text":"<pre><code># DP\ndef climbStairs(n: int) -&gt; int:\n    # TC: O(n), SC: O(n)\n    # dp[n]: the number of ways to reach the n-th step\n    # dp[n] = dp[n-1] + dp[n-2]\n\n    if n &lt;= 1:\n        return n\n\n    dp = [i for i in range(n + 1)]\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\nprint(climbStairs(10))  # 89\n</code></pre>"},{"location":"neetcode_150/#746-min-cost-climbing-stairs","title":"746. Min Cost Climbing Stairs","text":"<pre><code>from typing import List\n\n\ndef minCostClimbingStairs(cost: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(cost))]\n\n    dp[0], dp[1] = cost[0], cost[1]\n\n    for i in range(2, len(cost)):\n        dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]\n\n    return min(dp[-1], dp[-2])\n\n\ncost = [10, 15, 20]\nprint(minCostClimbingStairs(cost))  # 15\n</code></pre>"},{"location":"neetcode_150/#198-house-robber","title":"198. House Robber","text":"<pre><code>from typing import List\n\n\ndef rob(nums: List[int]) -&gt; int:\n    if len(nums) &lt; 3:\n        return max(nums)\n\n    dp = [0 for _ in range(len(nums))]\n    dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n    for i in range(2, len(nums)):\n        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n    return dp[-1]\n\n\nnums = [2, 7, 9, 3, 1]\nprint(rob(nums))  # 12\n</code></pre>"},{"location":"neetcode_150/#213-house-robber-ii","title":"213. House Robber II","text":"<pre><code>from typing import List\n\n\ndef rob(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 3:\n        return max(nums)\n\n    def robLinear(nums: List[int]) -&gt; int:\n        dp = [0 for _ in range(len(nums))]\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n        return dp[-1]\n\n    # circle -&gt; linear\n    a = robLinear(nums[1:])  # 2nd house to the last house\n    b = robLinear(nums[:-1])  # 1st house to the 2nd last house\n\n    return max(a, b)\n\n\nnums = [2, 3, 2]\nprint(rob(nums))  # 3\n</code></pre>"},{"location":"neetcode_150/#5-longest-palindromic-substring","title":"5. Longest Palindromic Substring","text":"<pre><code># DP - LCS\ndef longestPalindrome(s: str) -&gt; str:\n    n = len(s)\n    if n &lt;= 1:\n        return s\n\n    start, maxLen = 0, 1\n    dp = [[False] * n for _ in range(n)]\n\n    for i in range(n):\n        dp[i][i] = True\n\n    for j in range(1, n):\n        for i in range(j):\n            if s[i] == s[j]:\n                if j - i &lt;= 2:\n                    dp[i][j] = True\n                else:\n                    dp[i][j] = dp[i + 1][j - 1]\n\n                if dp[i][j] and j - i + 1 &gt; maxLen:\n                    maxLen = j - i + 1\n                    start = i\n\n    return s[start : start + maxLen]\n\n\ns = \"babad\"\nprint(longestPalindrome(s))  # \"bab\" or \"aba\"\n</code></pre>"},{"location":"neetcode_150/#647-palindromic-substrings","title":"647. Palindromic Substrings","text":"<pre><code>def countSubstrings(s: str) -&gt; int:\n    dp = [[False] * len(s) for _ in range(len(s))]\n    result = 0\n\n    for i in range(len(s) - 1, -1, -1):\n        for j in range(i, len(s)):\n            if s[i] == s[j]:\n                if j - i &lt;= 1:\n                    dp[i][j] = True\n                    result += 1\n                elif dp[i + 1][j - 1]:\n                    dp[i][j] = True\n                    result += 1\n    return result\n\n\nprint(countSubstrings(\"abc\"))  # 3\n</code></pre>"},{"location":"neetcode_150/#91-decode-ways","title":"91. Decode Ways","text":""},{"location":"neetcode_150/#322-coin-change","title":"322. Coin Change","text":"<pre><code>from typing import List\n\n\ndef coinChange(coins: List[int], amount: int) -&gt; int:\n    dp = [float(\"inf\") for _ in range(amount + 1)]\n\n    dp[0] = 0\n\n    for i in range(1, amount + 1):\n        for c in coins:\n            if i - c &gt;= 0:\n                dp[i] = min(dp[i], 1 + dp[i - c])\n\n    return dp[amount] if dp[amount] != float(\"inf\") else -1\n\n\ncoins = [1, 2, 5]\namount = 11\nprint(coinChange(coins, amount))  # 3\n</code></pre>"},{"location":"neetcode_150/#152-maximum-product-subarray","title":"152. Maximum Product Subarray","text":"<pre><code>from typing import List\n\n\ndef maxProduct(nums: List[int]) -&gt; int:\n    n = len(nums)\n    dp_max = [0 for _ in range(n)]\n    dp_min = [0 for _ in range(n)]\n\n    dp_max[0] = nums[0]\n    dp_min[0] = nums[0]\n    max_product = nums[0]\n\n    for i in range(1, n):\n        dp_max[i] = max(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n        dp_min[i] = min(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n\n        max_product = max(max_product, dp_max[i])\n\n    return max_product\n\n\nnums = [2, 3, -2, 4]\nprint(maxProduct(nums))  # 6\n</code></pre>"},{"location":"neetcode_150/#2-d-dynamic-programming","title":"2-D Dynamic Programming","text":"<ol> <li>0062 - Unique Paths (Medium)</li> <li>1143 - Longest Common Subsequence (Medium)</li> <li>0309 - Best Time to Buy and Sell Stock with Cooldown (Medium)</li> <li>0518 - Coin Change 2 (Medium)</li> <li>0494 - Target Sum (Medium)</li> <li>0097 - Interleaving String (Hard)</li> <li>0329 - Longest Increasing Path in a Matrix (Hard)</li> </ol>"},{"location":"neetcode_150/#62-unique-paths","title":"62. Unique Paths","text":"<pre><code>def uniquePaths(m: int, n: int) -&gt; int:\n    if m == 1 or n == 1:\n        return 1\n\n    dp = [[1] * n] * m\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]\n\n\nprint(uniquePaths(m=3, n=7))  # 28\n</code></pre>"},{"location":"neetcode_150/#1143-longest-common-subsequence","title":"1143. Longest Common Subsequence","text":"<pre><code># DP - LCS\ndef longestCommonSubsequence(text1: str, text2: str) -&gt; int:\n    # TC: O(m * n)\n    # SC: O(m * n)\n    m = len(text1)\n    n = len(text2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    length = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i - 1] == text2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])\n            if length &lt; dp[i][j]:\n                length = dp[i][j]\n\n    return length\n\n\ntext1 = \"abcde\"\ntext2 = \"ace\"\nprint(longestCommonSubsequence(text1, text2))  # 3\n</code></pre>"},{"location":"neetcode_150/#309-best-time-to-buy-and-sell-stock-with-cooldown","title":"309. Best Time to Buy and Sell Stock with Cooldown","text":"<pre><code>from typing import List\n\n\n# DP\ndef maxProfit(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 4 for _ in range(n)]\n\n    dp[0][0] = -prices[0]  # poessess\n    dp[0][1] = 0  # stay sold\n    dp[0][2] = 0  # sell\n    dp[0][3] = 0  # cooldown\n\n    for i in range(1, n):\n        dp[i][0] = max(\n            dp[i - 1][0],  # stay poessess\n            dp[i - 1][1] - prices[i],  # buy after stay sold\n            dp[i - 1][3] - prices[i],  # buy after cooldown\n        )\n        dp[i][1] = max(\n            dp[i - 1][1],  # stay sold\n            dp[i - 1][3],  # stay cooldown\n        )\n        dp[i][2] = dp[i - 1][0] + prices[i]\n        dp[i][3] = dp[i - 1][2]\n\n    return max(dp[-1])\n\n\nprices = [1, 2, 3, 0, 2]\nprint(maxProfit(prices))  # 3\n</code></pre>"},{"location":"neetcode_150/#518-coin-change-2","title":"518. Coin Change 2","text":"<pre><code>from typing import List\n\n\ndef change(amount: int, coins: List[int]) -&gt; int:\n    dp = [0 for _ in range(amount + 1)]\n    dp[0] = 1\n\n    for i in range(len(coins)):\n        for j in range(coins[i], amount + 1):\n            dp[j] += dp[j - coins[i]]\n\n    return dp[-1]\n\n\namount = 5\ncoins = [1, 2, 5]\nprint(change(amount, coins))  # 4\n</code></pre>"},{"location":"neetcode_150/#494-target-sum","title":"494. Target Sum","text":"<pre><code>from typing import List\n\n\ndef findTargetSumWays(nums: List[int], target: int) -&gt; int:\n\n    totalSum = sum(nums)\n\n    if abs(target) &gt; totalSum:\n        return 0\n    if (target + totalSum) % 2 == 1:\n        return 0\n\n    targetSum = (target + totalSum) // 2\n    dp = [0] * (targetSum + 1)\n    dp[0] = 1\n\n    for i in range(len(nums)):\n        for j in range(targetSum, nums[i] - 1, -1):\n            dp[j] += dp[j - nums[i]]\n\n    return dp[targetSum]\n\n\nnums = [1, 1, 1, 1, 1]\ntarget = 3\nprint(findTargetSumWays(nums, target))  # 5\n</code></pre>"},{"location":"neetcode_150/#97-interleaving-string","title":"97. Interleaving String","text":""},{"location":"neetcode_150/#329-longest-increasing-path-in-a-matrix","title":"329. Longest Increasing Path in a Matrix","text":""},{"location":"neetcode_150/#greedy","title":"Greedy","text":"<ol> <li>0053 - Maximum Subarray (Easy)</li> <li>0055 - Jump Game (Medium)</li> <li>0045 - Jump Game II (Medium)</li> <li>0134 - Gas Station (Medium)</li> <li>0846 - Hand of Straights (Medium)</li> <li>1899 - Merge Triplets to Form Target Triplet (Medium)</li> <li>0763 - Partition Labels (Medium)</li> <li>0678 - Valid Parenthesis String (Medium)</li> </ol>"},{"location":"neetcode_150/#53-maximum-subarray","title":"53. Maximum Subarray","text":"<pre><code>from typing import List\n\n\n# DP\ndef maxSubArrayDP(nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n\n    dp[0] = nums[0]\n    maxSum = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(\n            dp[i - 1] + nums[i],  # continue the previous subarray\n            nums[i],  # start a new subarray\n        )\n        maxSum = max(maxSum, dp[i])\n\n    return maxSum\n\n\n# Greedy\ndef maxSubArrayGreedy(nums: List[int]) -&gt; int:\n    maxSum = float(\"-inf\")\n    curSum = 0\n\n    for num in nums:\n        curSum += num\n        maxSum = max(maxSum, curSum)\n        curSum = max(curSum, 0)\n\n    return maxSum\n\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArrayDP(nums))  # 6\nprint(maxSubArrayGreedy(nums))  # 6\n</code></pre>"},{"location":"neetcode_150/#55-jump-game","title":"55. Jump Game","text":"<pre><code>from typing import List\n\n\n# Greedy\ndef canJump(nums: List[int]) -&gt; bool:\n    n = len(nums)\n    if n &lt;= 1:\n        return True\n\n    maxReachable = 0\n    i = 0\n\n    while i &lt;= maxReachable:\n        maxReachable = max(maxReachable, i + nums[i])\n        if maxReachable &gt;= n - 1:\n            return True\n        i += 1\n\n    return False\n\n\nprint(canJump([2, 3, 1, 1, 4]))  # True\n</code></pre>"},{"location":"neetcode_150/#45-jump-game-ii","title":"45. Jump Game II","text":"<pre><code>from typing import List\n\n\ndef jump(nums: List[int]) -&gt; int:\n    if len(nums) == 1:\n        return 0\n\n    cover = 0\n    count = 0\n    i = 0\n\n    while cover &gt;= 0:\n        for i in range(i, cover + 1):\n            cover = max(cover, nums[i] + i)\n            if cover &gt;= len(nums) - 1:\n                return count + 1\n        count += 1\n\n    return count\n\n\nprint(jump([2, 3, 1, 1, 4]))  # 2\n</code></pre>"},{"location":"neetcode_150/#134-gas-station","title":"134. Gas Station","text":"<pre><code>from typing import List\n\n\n# Greedy\ndef canCompleteCircuit(gas: List[int], cost: List[int]) -&gt; int:\n    curSum = 0\n    totalSum = 0\n    start = 0\n\n    for i in range(len(gas)):\n        curSum += gas[i] - cost[i]\n        totalSum += gas[i] - cost[i]\n\n        if curSum &lt; 0:\n            start = i + 1\n            curSum = 0\n\n    if totalSum &lt; 0:\n        return -1\n\n    return start\n\n\ngas = [1, 2, 3, 4, 5]\ncost = [3, 4, 5, 1, 2]\nprint(canCompleteCircuit(gas, cost))  # 3\n</code></pre>"},{"location":"neetcode_150/#846-hand-of-straights","title":"846. Hand of Straights","text":""},{"location":"neetcode_150/#1899-merge-triplets-to-form-target-triplet","title":"1899. Merge Triplets to Form Target Triplet","text":""},{"location":"neetcode_150/#763-partition-labels","title":"763. Partition Labels","text":"<pre><code>from typing import List\n\n\n# 1. Hashmap\ndef partitionLabels1(s: str) -&gt; List[int]:\n    # Time complexity: O(nlogn)\n    # Space complexity: O(n)\n    hashmap = {}\n\n    for i, j in enumerate(s):\n        if j not in hashmap:\n            hashmap[j] = [i, i]\n        else:\n            hashmap[j][1] = i\n\n    intervals = list(hashmap.values())\n    intervals.sort(key=lambda x: x[0])\n\n    if len(intervals) &lt; 2:\n        return len(intervals)\n\n    result = []\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &lt; intervals[i - 1][1]:\n            intervals[i][1] = max(intervals[i][1], intervals[i - 1][1])\n        else:\n            result.append(intervals[i][0])\n\n    result.append(intervals[-1][1] + 1)\n\n    if len(result) == 1:\n        return result\n    else:\n        for i in range(len(result) - 1, 0, -1):\n            result[i] -= result[i - 1]\n        return result\n\n\n# 2. Single Pass Partitioning\ndef partitionLabels2(s: str) -&gt; List[int]:\n    # Time complexity: O(n)\n    # Space complexity: O(n)\n    last = {c: i for i, c in enumerate(s)}\n\n    start, end = 0, 0\n    result = []\n\n    for i, c in enumerate(s):\n        end = max(end, last[c])\n        if i == end:\n            result.append(end - start + 1)\n            start = i + 1\n\n    return result\n\n\nprint(partitionLabels1(\"abaccd\"))  # [3, 2, 1]\nprint(partitionLabels2(\"abaccd\"))  # [3, 2, 1]\n</code></pre>"},{"location":"neetcode_150/#678-valid-parenthesis-string","title":"678. Valid Parenthesis String","text":""},{"location":"neetcode_150/#intervals","title":"Intervals","text":"<ol> <li>0057 - Insert Interval (Hard)</li> <li>0056 - Merge Intervals (Medium)</li> <li>0435 - Non-overlapping Intervals (Medium)</li> <li>0252 - Meeting Rooms (Easy)</li> <li>0253 - Meeting Rooms II (Medium)</li> </ol>"},{"location":"neetcode_150/#57-insert-interval","title":"57. Insert Interval","text":""},{"location":"neetcode_150/#56-merge-intervals","title":"56. Merge Intervals","text":"<pre><code>from typing import List\n\n\ndef merge(intervals: List[List[int]]) -&gt; List[List[int]]:\n    intervals.sort(key=lambda x: x[0])\n    result = [intervals[0]]\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &lt;= result[-1][1]:\n            result[-1][1] = max(intervals[i][1], result[-1][1])\n        else:\n            result.append(intervals[i])\n\n    return result\n\n\nprint(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))\n# [[1, 6], [8, 10], [15, 18]]\n</code></pre>"},{"location":"neetcode_150/#435-non-overlapping-intervals","title":"435. Non-overlapping Intervals","text":"<pre><code>from typing import List\n\n\ndef eraseOverlapIntervals(intervals: List[List[int]]) -&gt; int:\n    if len(intervals) &lt;= 1:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n    result = 0\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &gt;= intervals[i - 1][1]:\n            continue\n        else:\n            result += 1\n            intervals[i][1] = min(intervals[i][1], intervals[i - 1][1])\n\n    return result\n\n\nprint(eraseOverlapIntervals([[1, 2], [2, 3], [3, 4], [1, 3]]))  # 1\n</code></pre>"},{"location":"neetcode_150/#252-meeting-rooms","title":"252. Meeting Rooms","text":""},{"location":"neetcode_150/#253-meeting-rooms-ii","title":"253. Meeting Rooms II","text":""},{"location":"neetcode_150/#math-geometry","title":"Math &amp; Geometry","text":"<ol> <li>0048 - Rotate Image (Medium)</li> <li>0054 - Spiral Matrix (Medium)</li> <li>0073 - Set Matrix Zeroes (Medium)</li> <li>0202 - Happy Number (Easy)</li> <li>0066 - Plus One (Easy)</li> <li>0050 - Pow(x, n) (Medium)</li> <li>0043 - Multiply Strings (Medium)</li> <li>0166 - Fraction to Recurring Decimal (Medium)</li> </ol>"},{"location":"neetcode_150/#48-rotate-image","title":"48. Rotate Image","text":""},{"location":"neetcode_150/#54-spiral-matrix","title":"54. Spiral Matrix","text":"<pre><code>from typing import List\n\n\ndef spiralOrder(matrix: List[List[int]]) -&gt; List[int]:\n    if not matrix or not matrix[0]:\n        return []\n\n    result = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n\n    while top &lt;= bottom and left &lt;= right:\n\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n\n        if top &lt;= bottom:\n\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left &lt;= right:\n\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n\n    return result\n\n\nprint(spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n# [1, 2, 3, 6, 9, 8, 7, 4, 5]\n</code></pre>"},{"location":"neetcode_150/#73-set-matrix-zeroes","title":"73. Set Matrix Zeroes","text":""},{"location":"neetcode_150/#202-happy-number","title":"202. Happy Number","text":"<pre><code>def isHappy(n: int) -&gt; bool:\n\n    def getSum(n):\n        sum_of_squares = 0\n        while n:\n            a, b = divmod(n, 10)\n            sum_of_squares += b**2\n            n = a\n        return sum_of_squares\n\n    record = set()\n\n    while True:\n        if n == 1:\n            return True\n\n        if n in record:\n            return False\n        else:\n            record.add(n)\n\n        n = getSum(n)\n\n\nn = 19\nprint(isHappy(n))  # True\n</code></pre>"},{"location":"neetcode_150/#66-plus-one","title":"66. Plus One","text":""},{"location":"neetcode_150/#50-powx-n","title":"50. Pow(x, n)","text":""},{"location":"neetcode_150/#43-multiply-strings","title":"43. Multiply Strings","text":""},{"location":"neetcode_150/#166-fraction-to-recurring-decimal","title":"166. Fraction to Recurring Decimal","text":""},{"location":"neetcode_150/#bit-manipulation","title":"Bit Manipulation","text":"<ol> <li>0191 - Number of 1 Bits (Easy)</li> <li>0338 - Counting Bits (Medium)</li> <li>0190 - Reverse Bits (Easy)</li> <li>0268 - Missing Number (Easy)</li> <li>0371 - Sum of Two Integers (Medium)</li> </ol>"},{"location":"neetcode_150/#191-number-of-1-bits","title":"191. Number of 1 Bits","text":""},{"location":"neetcode_150/#338-counting-bits","title":"338. Counting Bits","text":""},{"location":"neetcode_150/#190-reverse-bits","title":"190. Reverse Bits","text":""},{"location":"neetcode_150/#268-missing-number","title":"268. Missing Number","text":""},{"location":"neetcode_150/#371-sum-of-two-integers","title":"371. Sum of Two Integers","text":""},{"location":"prefix_sum/","title":"Prefix Sum","text":"<ol> <li>2574 - Left and Right Sum Difference (easy)</li> <li>1732 - Find the Highest Altitude (easy)</li> <li>0303 - Range Sum Query - Immutable (easy)</li> <li>0304 - Range Sum Query 2D - Immutable (medium)</li> <li>0560 - Subarray Sum Equals K (medium)</li> <li>0238 - Product of Array Except Self (medium)</li> <li>0974 - Subarray Sums Divisible by K (medium)</li> <li>0209 - Minimum Size Subarray Sum (medium)</li> <li>0523 - Continuous Subarray Sum (medium)</li> <li>1248 - Count Number of Nice Subarrays (medium)</li> <li>0325 - Maximum Size Subarray Sum Equals k (medium)</li> <li>0862 - Shortest Subarray with Sum at Least K (hard)</li> <li>1171 - Remove Zero Sum Consecutive Nodes from Linked List (medium)</li> </ol>"},{"location":"prefix_sum/#2574-left-and-right-sum-difference","title":"2574. Left and Right Sum Difference","text":"<pre><code>from typing import List\n\n\n# 1. Left Right Sum\ndef leftRightDifferenceSum(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    left = [0] * n\n    right = [0] * n\n\n    for i in range(1, n):\n        left[i] = left[i - 1] + nums[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        right[i] = right[i + 1] + nums[i + 1]\n\n    return [abs(left[i] - right[i]) for i in range(n)]\n\n\n# 2. Left Right Pointer\ndef leftRightDifferencePointer(nums: List[int]) -&gt; List[int]:\n    left, right = 0, sum(nums)\n    result = []\n\n    for num in nums:\n        right -= num\n        result.append(abs(left - right))\n        left += num\n\n    return result\n\n\nnums = [10, 4, 8, 3]\nprint(leftRightDifferenceSum(nums))  # [15, 1, 11, 22]\nprint(leftRightDifferencePointer(nums))  # [15, 1, 11, 22]\n</code></pre>"},{"location":"prefix_sum/#1732-find-the-highest-altitude","title":"1732. Find the Highest Altitude","text":"<pre><code>from typing import List\n\n\ndef largestAltitude(gain: List[int]) -&gt; int:\n    result, altitude = 0, 0\n\n    for i in gain:\n        altitude += i\n        result = max(result, altitude)\n\n    return result\n\n\ngain = [-5, 1, 5, 0, -7]\nprint(largestAltitude(gain))  # 1\n</code></pre>"},{"location":"prefix_sum/#0303-range-sum-query-immutable","title":"0303. Range Sum Query - Immutable","text":"<pre><code>from typing import List\n\n\nclass NumArray:\n\n    def __init__(self, nums: List[int]):\n        self.prefix_sum = [0 for _ in range(len(nums) + 1)]\n\n        for i in range(1, len(nums) + 1):\n            self.prefix_sum[i] = self.prefix_sum[i - 1] + nums[i - 1]\n\n    def sumRange(self, left: int, right: int) -&gt; int:\n        return self.prefix_sum[right + 1] - self.prefix_sum[left]\n\n\nnums = [-2, 0, 3, -5, 2, -1]\nobj = NumArray(nums)\nassert obj.sumRange(0, 2) == 1\nassert obj.sumRange(2, 5) == -1\nassert obj.sumRange(0, 5) == -3\nprint(\"PASSED\")\n</code></pre>"},{"location":"prefix_sum/#0304-range-sum-query-2d-immutable","title":"0304. Range Sum Query 2D - Immutable","text":"<pre><code>from typing import List\n\n\nclass NumMatrix:\n\n    def __init__(self, matrix: List[List[int]]):\n        m, n = len(matrix), len(matrix[0])\n        if m == 0 or n == 0:\n            return None\n\n        self.sum = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                self.sum[i][j] = (\n                    matrix[i - 1][j - 1]\n                    + self.sum[i - 1][j]\n                    + self.sum[i][j - 1]\n                    - self.sum[i - 1][j - 1]  # to avoid double counting\n                )\n\n    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -&gt; int:\n        return (\n            self.sum[row2 + 1][col2 + 1]\n            - self.sum[row1][col2 + 1]\n            - self.sum[row2 + 1][col1]\n            + self.sum[row1][col1]\n        )\n\n\nmatrix = [\n    [3, 0, 1, 4, 2],\n    [5, 6, 3, 2, 1],\n    [1, 2, 0, 1, 5],\n    [4, 1, 0, 1, 7],\n    [1, 0, 3, 0, 5],\n]\nobj = NumMatrix(matrix)\nassert obj.sumRegion(2, 1, 4, 3) == 8\nassert obj.sumRegion(1, 1, 2, 2) == 11\nassert obj.sumRegion(1, 2, 2, 4) == 12\nprint(\"PASSED\")\n</code></pre>"},{"location":"prefix_sum/#0560-subarray-sum-equals-k","title":"0560. Subarray Sum Equals K","text":"<pre><code>from typing import List\n\n\n# 1. Prefix Sum\ndef subarraySum(nums: List[int], k: int) -&gt; int:\n    prefix_sums = {0: 1}\n    currentSum = 0\n    count = 0\n\n    for num in nums:\n        currentSum += num\n        if (currentSum - k) in prefix_sums:\n            count += prefix_sums[currentSum - k]\n\n        if currentSum in prefix_sums:\n            prefix_sums[currentSum] += 1\n        else:\n            prefix_sums[currentSum] = 1\n\n    return count\n\n\n# 2. Optimized Prefix Sum\ndef subarraySumOptimized(nums: List[int], k: int) -&gt; int:\n    prefixSum = 0\n    count = 0\n    prefix_sums = {0: 1}\n\n    for num in nums:\n        prefixSum += num\n        count += prefix_sums.get(prefixSum - k, 0)\n        prefix_sums[prefixSum] = prefix_sums.get(prefixSum, 0) + 1\n\n    return count\n\n\nnums = [1, 1, 1]\nk = 2\nprint(subarraySum(nums, k))  # 2\nprint(subarraySumOptimized(nums, k))  # 2\n</code></pre>"},{"location":"prefix_sum/#0238-product-of-array-except-self","title":"0238. Product of Array Except Self","text":"<pre><code>from typing import List\n\n\ndef productExceptSelf(nums: List[int]) -&gt; List[int]:\n    \"\"\"\n    Time complexity: O(n)\n    Space complexity: O(n)\n    \"\"\"\n    n = len(nums)\n    prefix = [1 for _ in range(n)]\n    suffix = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        prefix[i] = nums[i - 1] * prefix[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        suffix[i] = nums[i + 1] * suffix[i + 1]\n\n    result = [i * j for i, j in zip(prefix, suffix)]\n\n    return result\n\n\n# Space optimized\ndef productExceptSelfOptimized(nums: List[int]) -&gt; List[int]:\n    \"\"\"\n    Time complexity: O(n)\n    Space complexity: O(1)\n    \"\"\"\n    n = len(nums)\n    result = [1] * n\n\n    prefix = 1\n    for i in range(n):\n        result[i] = prefix\n        prefix *= nums[i]\n\n    suffix = 1\n    for i in range(n - 1, -1, -1):\n        result[i] *= suffix\n        suffix *= nums[i]\n\n    return result\n\n\nprint(productExceptSelf([1, 2, 3, 4]))  # [24, 12, 8, 6]\nprint(productExceptSelfOptimized([1, 2, 3, 4]))  # [24, 12, 8, 6]\n</code></pre>"},{"location":"prefix_sum/#0974-subarray-sums-divisible-by-k","title":"0974. Subarray Sums Divisible by K","text":"<pre><code>from typing import List\n\n\ndef subarraysDivByK_1(nums: List[int], k: int) -&gt; int:\n    mods = {0: 1}\n    prefixSum, result = 0, 0\n\n    for num in nums:\n        prefixSum += num\n        mod = prefixSum % k\n\n        if mod &lt; 0:\n            mod += k\n\n        if mod in mods:\n            result += mods[mod]\n\n        if mod in mods:\n            mods[mod] += 1\n        else:\n            mods[mod] = 1\n\n    return result\n\n\ndef subarraysDivByK_2(nums: List[int], k: int) -&gt; int:\n    mods = {0: 1}\n    prefixSum, result = 0, 0\n\n    for num in nums:\n        prefixSum += num\n        mod = prefixSum % k\n        result += mods.get(mod, 0)\n        mods[mod] = mods.get(mod, 0) + 1\n\n    return result\n\n\nnums = [4, 5, 0, -2, -3, 1]\nk = 5\nprint(subarraysDivByK_1(nums, k))  # 7\nprint(subarraysDivByK_2(nums, k))  # 7\n</code></pre>"},{"location":"prefix_sum/#0209-minimum-size-subarray-sum","title":"0209. Minimum Size Subarray Sum","text":"<pre><code>import bisect\nfrom typing import List\n\n\n# Prefix Sum\ndef minSubArrayLenPS(target: int, nums: List[int]) -&gt; int:\n    n = len(nums)\n    prefix_sums = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        prefix_sums[i] = prefix_sums[i - 1] + nums[i - 1]\n\n    minLen = float(\"inf\")\n\n    for i in range(n + 1):\n        new_target = target + prefix_sums[i]\n        bound = bisect.bisect_left(prefix_sums, new_target)\n        if bound != len(prefix_sums):\n            minLen = min(minLen, bound - i)\n\n    return 0 if minLen == float(\"inf\") else minLen\n\n\n# Sliding window - Fixed\ndef minSubArrayLenSW(target: int, nums: List[int]) -&gt; int:\n    left, right = 0, 0\n    curSum = 0\n    minLen = float(\"inf\")\n\n    while right &lt; len(nums):\n        curSum += nums[right]\n\n        while curSum &gt;= target:\n            minLen = min(minLen, right - left + 1)\n            curSum -= nums[left]\n            left += 1\n\n        right += 1\n\n    return minLen if minLen != float(\"inf\") else 0\n\n\ntarget = 7\nnums = [2, 3, 1, 2, 4, 3]\nprint(minSubArrayLenPS(target, nums))  # 2\nprint(minSubArrayLenSW(target, nums))  # 2\n</code></pre>"},{"location":"prefix_sum/#0523-continuous-subarray-sum","title":"0523. Continuous Subarray Sum","text":""},{"location":"prefix_sum/#1248-count-number-of-nice-subarrays","title":"1248. Count Number of Nice Subarrays","text":""},{"location":"prefix_sum/#0325-maximum-size-subarray-sum-equals-k","title":"0325. Maximum Size Subarray Sum Equals k","text":""},{"location":"prefix_sum/#0862-shortest-subarray-with-sum-at-least-k","title":"0862. Shortest Subarray with Sum at Least K","text":""},{"location":"prefix_sum/#1171-remove-zero-sum-consecutive-nodes-from-linked-list","title":"1171. Remove Zero Sum Consecutive Nodes from Linked List","text":""},{"location":"queue/","title":"Queue","text":"<ol> <li>0232 - Implement Queue using Stacks (Easy)</li> <li>0225 - Implement Stack using Queues (Easy)</li> </ol>"},{"location":"queue/#232-implement-queue-using-stacks","title":"232. Implement Queue using Stacks","text":"<pre><code>class MyQueue:\n    def __init__(self):\n        self.stack_in = []\n        self.stack_out = []\n\n    def push(self, x: int) -&gt; None:\n        self.stack_in.append(x)\n\n    def pop(self) -&gt; int:\n        if self.empty():\n            return None\n\n        if self.stack_out:\n            return self.stack_out.pop()\n        else:\n            for _ in range(len(self.stack_in)):\n                self.stack_out.append(self.stack_in.pop())\n            return self.stack_out.pop()\n\n    def peek(self) -&gt; int:\n        answer = self.pop()\n        self.stack_out.append(answer)\n        return answer\n\n    def empty(self) -&gt; bool:\n        return not (self.stack_in or self.stack_out)\n\n\nobj = MyQueue()\nobj.push(1)\nprint(obj.pop())  # 1\nprint(obj.peek())  # None\nprint(obj.empty())  # False\n</code></pre>"},{"location":"queue/#225-implement-stack-using-queues","title":"225. Implement Stack using Queues","text":""},{"location":"sliding_window_fixed/","title":"Sliding Window - Fixed Size","text":"<ol> <li>0219 - Contains Duplicate II (Easy)</li> <li>0567 - Permutation in String (Medium)</li> <li>0713 - Subarray Product Less Than K (Medium)</li> <li>0209 - Minimum Size Subarray Sum (Medium)</li> <li>0076 - Minimum Window Substring (Hard)</li> </ol>"},{"location":"sliding_window_fixed/#219-contains-duplicate-ii","title":"219. Contains Duplicate II","text":"<pre><code>from typing import List\n\n\n# Sliding window - Fixed\ndef containsNearbyDuplicate(nums: List[int], k: int) -&gt; bool:\n    window = set()\n    left = 0\n\n    for right in range(len(nums)):\n        if right - left &gt; k:\n            window.remove(nums[left])\n            left += 1\n        if nums[right] in window:\n            return True\n        window.add(nums[right])\n\n    return False\n\n\nnums = [1, 2, 3, 1]\nk = 3\nprint(containsNearbyDuplicate(nums, k))  # True\n</code></pre>"},{"location":"sliding_window_fixed/#567-permutation-in-string","title":"567. Permutation in String","text":"<pre><code>def checkInclusion(s1: str, s2: str) -&gt; bool:\n    if len(s1) &gt; len(s2):\n        return False\n\n    count1 = [0] * 26\n    count2 = [0] * 26\n\n    for i in range(len(s1)):\n        count1[ord(s1[i]) - ord(\"a\")] += 1\n        count2[ord(s2[i]) - ord(\"a\")] += 1\n\n    matches = 0\n    for i in range(26):\n        if count1[i] == count2[i]:\n            matches += 1\n\n    l = 0\n    for r in range(len(s1), len(s2)):\n        if matches == 26:\n            return True\n\n        index = ord(s2[r]) - ord(\"a\")\n        count2[index] += 1\n        if count1[index] == count2[index]:\n            matches += 1\n        elif count1[index] + 1 == count2[index]:\n            matches -= 1\n\n        index = ord(s2[l]) - ord(\"a\")\n        count2[index] -= 1\n        if count1[index] == count2[index]:\n            matches += 1\n        elif count1[index] - 1 == count2[index]:\n            matches -= 1\n\n        l += 1\n\n    return matches == 26\n\n\ns1 = \"ab\"\ns2 = \"eidba\"\nprint(checkInclusion(s1, s2))  # True\n</code></pre>"},{"location":"sliding_window_fixed/#713-subarray-product-less-than-k","title":"713. Subarray Product Less Than K","text":"<pre><code>from typing import List\n\n\n# Sliding window - Fixed\ndef numSubarrayProductLessThanK(nums: List[int], k: int) -&gt; int:\n    if k &lt;= 1:\n        return 0\n\n    left = 0\n    product = 1\n    count = 0\n\n    for right in range(len(nums)):\n        product *= nums[right]\n\n        while product &gt;= k:\n            product //= nums[left]\n            left += 1\n\n        count += right - left + 1\n\n    return count\n\n\nnums = [10, 5, 2, 6]\nk = 100\nprint(numSubarrayProductLessThanK(nums, k))  # 8\n</code></pre>"},{"location":"sliding_window_fixed/#209-minimum-size-subarray-sum","title":"209. Minimum Size Subarray Sum","text":"<pre><code>import bisect\nfrom typing import List\n\n\n# Prefix Sum\ndef minSubArrayLenPS(target: int, nums: List[int]) -&gt; int:\n    n = len(nums)\n    prefix_sums = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        prefix_sums[i] = prefix_sums[i - 1] + nums[i - 1]\n\n    minLen = float(\"inf\")\n\n    for i in range(n + 1):\n        new_target = target + prefix_sums[i]\n        bound = bisect.bisect_left(prefix_sums, new_target)\n        if bound != len(prefix_sums):\n            minLen = min(minLen, bound - i)\n\n    return 0 if minLen == float(\"inf\") else minLen\n\n\n# Sliding window - Fixed\ndef minSubArrayLenSW(target: int, nums: List[int]) -&gt; int:\n    left, right = 0, 0\n    curSum = 0\n    minLen = float(\"inf\")\n\n    while right &lt; len(nums):\n        curSum += nums[right]\n\n        while curSum &gt;= target:\n            minLen = min(minLen, right - left + 1)\n            curSum -= nums[left]\n            left += 1\n\n        right += 1\n\n    return minLen if minLen != float(\"inf\") else 0\n\n\ntarget = 7\nnums = [2, 3, 1, 2, 4, 3]\nprint(minSubArrayLenPS(target, nums))  # 2\nprint(minSubArrayLenSW(target, nums))  # 2\n</code></pre>"},{"location":"sliding_window_fixed/#76-minimum-window-substring","title":"76. Minimum Window Substring","text":"<pre><code>from collections import Counter\n\n\ndef minWindow(s: str, t: str) -&gt; str:\n    if not t or not s:\n        return \"\"\n\n    counts = Counter(t)\n    required = len(counts)\n\n    left, right = 0, 0\n    formed = 0\n    window_counts = dict()\n\n    result = float(\"inf\"), None, None\n\n    while right &lt; len(s):\n        char = s[right]\n        window_counts[char] = window_counts.get(char, 0) + 1\n        if char in counts and window_counts[char] == counts[char]:\n            formed += 1\n\n        while left &lt;= right and formed == required:\n            char = s[left]\n            if right - left + 1 &lt; result[0]:\n                result = (right - left + 1, left, right)\n            window_counts[char] -= 1\n            if char in counts and window_counts[char] &lt; counts[char]:\n                formed -= 1\n            left += 1\n\n        right += 1\n\n    return \"\" if result[0] == float(\"inf\") else s[result[1] : result[2] + 1]\n\n\ns = \"ADOBECODEBANC\"\nt = \"ABC\"\nprint(minWindow(s, t))  # BANC\n</code></pre>"},{"location":"sliding_window_variable/","title":"Sliding Window - Variable Size","text":"<ol> <li>0003 - Longest Substring Without Repeating Characters (Medium)</li> <li>0424 - Longest Repeating Character Replacement (Medium)</li> <li>1208 - Get Equal Substrings Within Budget (Medium)</li> <li>1004 - Max Consecutive Ones III (Medium)</li> <li>0438 - Find All Anagrams in a String (Medium)</li> <li>0992 - Subarrays with K Different Integers (Hard)</li> </ol>"},{"location":"sliding_window_variable/#3-longest-substring-without-repeating-characters","title":"3. Longest Substring Without Repeating Characters","text":"<pre><code># Sliding Window - Variable\ndef lengthOfLongestSubstring(s: str) -&gt; int:\n    hashmap = dict()  # char: last index\n    left = 0\n    maxLen = 0\n\n    for right in range(len(s)):\n        if s[right] in hashmap and hashmap[s[right]] &gt;= left:\n            left = hashmap[s[right]] + 1\n\n        hashmap[s[right]] = right\n        maxLen = max(maxLen, right - left + 1)\n\n    return maxLen\n\n\ns = \"abcabcbb\"\nprint(lengthOfLongestSubstring(s))  # 3\n</code></pre>"},{"location":"sliding_window_variable/#424-longest-repeating-character-replacement","title":"424. Longest Repeating Character Replacement","text":"<pre><code>from collections import defaultdict\n\n\n# Sliding Window - Variable\ndef characterReplacement(s: str, k: int) -&gt; int:\n    left = 0\n    maxCount = 0\n    counts = defaultdict(int)\n    maxLen = 0\n\n    for right in range(len(s)):\n        counts[s[right]] += 1\n        maxCount = max(maxCount, counts[s[right]])\n\n        while right - left + 1 - maxCount &gt; k:\n            counts[s[left]] -= 1\n            left += 1\n\n        maxLen = max(maxLen, right - left + 1)\n\n    return maxLen\n\n\ns = \"ABAB\"\nk = 2\nprint(characterReplacement(s, k))  # 4\n</code></pre>"},{"location":"sliding_window_variable/#1208-get-equal-substrings-within-budget","title":"1208. Get Equal Substrings Within Budget","text":"<pre><code># Sliding Window - Variable\ndef equalSubstring(s: str, t: str, maxCost: int) -&gt; int:\n    left = 0\n    maxLen = 0\n    currentCost = 0\n\n    for right in range(len(s)):\n        currentCost += abs(ord(s[right]) - ord(t[right]))\n\n        while currentCost &gt; maxCost:\n            currentCost -= abs(ord(s[left]) - ord(t[left]))\n            left += 1\n\n        maxLen = max(maxLen, right - left + 1)\n\n    return maxLen\n\n\ns = \"abcd\"\nt = \"bcdf\"\nmaxCost = 3\nprint(equalSubstring(s, t, maxCost))  # 3\n</code></pre>"},{"location":"sliding_window_variable/#1004-max-consecutive-ones-iii","title":"1004. Max Consecutive Ones III","text":"<pre><code>from typing import List\n\n\n# Sliding Window - Variable\ndef longestOnes(nums: List[int], k: int) -&gt; int:\n    left = 0\n    maxLen = 0\n    zero_count = 0\n\n    for right in range(len(nums)):\n        if nums[right] == 0:\n            zero_count += 1\n\n        while zero_count &gt; k:\n            if nums[left] == 0:\n                zero_count -= 1\n            left += 1\n\n        maxLen = max(maxLen, right - left + 1)\n\n    return maxLen\n\n\nnums = [1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0]\nk = 2\nprint(longestOnes(nums, k))  # 6\n</code></pre>"},{"location":"sliding_window_variable/#438-find-all-anagrams-in-a-string","title":"438. Find All Anagrams in a String","text":"<pre><code>from typing import List\n\n\n# Sliding Window - Variable\ndef findAnagrams(s: str, p: str) -&gt; List[int]:\n    result = []\n    if len(s) &lt; len(p):\n        return result\n\n    countP = [0] * 26\n    for i in p:\n        countP[ord(i) - ord(\"a\")] += 1\n\n    countS = [0] * 26\n    for i in range(len(p)):\n        countS[ord(s[i]) - ord(\"a\")] += 1\n\n    if countS == countP:\n        result.append(0)\n\n    # sliding window\n    for i in range(len(p), len(s)):\n        countS[ord(s[i]) - ord(\"a\")] += 1  # add new character\n        countS[ord(s[i - len(p)]) - ord(\"a\")] -= 1  # remove old character\n        if countS == countP:\n            result.append(i - len(p) + 1)  # append the starting index\n\n    return result\n\n\ns = \"cbaebabacd\"\np = \"abc\"\nprint(findAnagrams(s, p))  # [0, 6]\n</code></pre>"},{"location":"sliding_window_variable/#992-subarrays-with-k-different-integers","title":"992. Subarrays with K Different Integers","text":"<pre><code>from typing import List\n\n\n# Sliding Window - Variable\ndef subarraysWithKDistinct(nums: List[int], k: int) -&gt; int:\n    def atMost(k: int) -&gt; int:\n        count = 0\n        left = 0\n        freq = {}\n\n        for right in range(len(nums)):\n            if nums[right] not in freq:\n                freq[nums[right]] = 0\n            freq[nums[right]] += 1\n\n            while len(freq) &gt; k:\n                freq[nums[left]] -= 1\n                if freq[nums[left]] == 0:\n                    del freq[nums[left]]\n                left += 1\n\n            count += right - left + 1\n\n        return count\n\n    return atMost(k) - atMost(k - 1)\n\n\nnums = [1, 2, 1, 2, 3]\nk = 2\nprint(subarraysWithKDistinct(nums, k))  # 7\n</code></pre>"},{"location":"stack/","title":"Stack","text":"<ol> <li>1544 - Make The String Great (Easy)</li> <li>0020 - Valid Parentheses (Easy)</li> <li>0155 - Min Stack (Easy)</li> <li>0150 - Evaluate Reverse Polish Notation (Medium)</li> <li>0022 - Generate Parentheses (Medium)</li> <li>0853 - Car Fleet (Medium)</li> </ol>"},{"location":"stack/#1544-make-the-string-great","title":"1544. Make The String Great","text":"<pre><code>def makeGood(s: str) -&gt; str:\n    stack = []\n\n    for i in range(len(s)):\n        if stack and stack[-1] == s[i].swapcase():\n            stack.pop()\n        else:\n            stack.append(s[i])\n    return \"\".join(stack)\n\n\nprint(makeGood(\"leEeetcode\"))  # \"leetcode\"\n</code></pre>"},{"location":"stack/#20-valid-parentheses","title":"20. Valid Parentheses","text":"<pre><code>def isValid(s: str) -&gt; bool:\n    hashmap = {\n        \")\": \"(\",\n        \"]\": \"[\",\n        \"}\": \"{\",\n    }\n    stack = []\n\n    for c in s:\n        if c in hashmap:\n            if stack and stack[-1] == hashmap[c]:\n                stack.pop()\n            else:\n                return False\n        else:\n            stack.append(c)\n\n    return True if not stack else False\n\n\nprint(isValid(\"()\"))  # True\nprint(isValid(\"()[]{}\"))  # True\nprint(isValid(\"(]\"))  # False\n</code></pre>"},{"location":"stack/#155-min-stack","title":"155. Min Stack","text":"<pre><code>class MinStack:\n\n    def __init__(self):\n        self.stack = []\n        self.minStack = []\n\n    def push(self, val: int) -&gt; None:\n        self.stack.append(val)\n        val = min(val, self.minStack[-1] if self.minStack else val)\n        self.minStack.append(val)\n\n    def pop(self) -&gt; None:\n        if self.stack:\n            self.stack.pop()\n        if self.minStack:\n            self.minStack.pop()\n\n    def top(self) -&gt; int:\n        return self.stack[-1] if self.stack else None\n\n    def getMin(self) -&gt; int:\n        return self.minStack[-1] if self.minStack else None\n\n\n# Your MinStack object will be instantiated and called as such:\nobj = MinStack()\nobj.push(3)\nobj.push(2)\nobj.pop()\nprint(obj.top())  # 3\nprint(obj.getMin())  # 3\n</code></pre>"},{"location":"stack/#150-evaluate-reverse-polish-notation","title":"150. Evaluate Reverse Polish Notation","text":"<pre><code>from typing import List\n\n\ndef evalRPN(tokens: List[str]) -&gt; int:\n    stack = []\n\n    for c in tokens:\n        if c == \"+\":\n            stack.append(stack.pop() + stack.pop())\n        elif c == \"-\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(b - a)\n        elif c == \"*\":\n            stack.append(stack.pop() * stack.pop())\n        elif c == \"/\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(int(b / a))\n        else:\n            stack.append(int(c))\n\n    return stack[0]\n\n\nprint(evalRPN([\"2\", \"1\", \"+\", \"3\", \"*\"]))  # 9\nprint(evalRPN([\"4\", \"13\", \"5\", \"/\", \"-\"]))  # 2\nprint(evalRPN([\"18\"]))  # 18\nprint(evalRPN([\"4\", \"3\", \"-\"]))  # 1\n</code></pre>"},{"location":"stack/#22-generate-parentheses","title":"22. Generate Parentheses","text":"<pre><code>from typing import List\n\n\ndef generateParenthesis(n: int) -&gt; List[str]:\n    stack = []\n    result = []\n\n    def backtrack(openN, closeN):\n        if openN == closeN == n:\n            result.append(\"\".join(stack))\n            return None\n\n        if openN &lt; n:\n            stack.append(\"(\")\n            backtrack(openN + 1, closeN)\n            stack.pop()\n\n        if closeN &lt; openN:\n            stack.append(\")\")\n            backtrack(openN, closeN + 1)\n            stack.pop()\n\n    backtrack(0, 0)\n\n    return result\n\n\nprint(generateParenthesis(3))\n# ['((()))', '(()())', '(())()', '()(())', '()()()']\n</code></pre>"},{"location":"stack/#853-car-fleet","title":"853. Car Fleet","text":"<pre><code>from typing import List\n\n\ndef carFleet(target: int, position: List[int], speed: List[int]) -&gt; int:\n    cars = sorted(zip(position, speed), reverse=True)\n    stack = []\n\n    for p, s in cars:\n        time = (target - p) / s\n\n        if not stack or time &gt; stack[-1]:\n            stack.append(time)\n\n    return len(stack)\n\n\nprint(carFleet(12, [10, 8, 0, 5, 3], [2, 4, 1, 1, 3]))  # 3\n</code></pre>"},{"location":"stack_monotonic/","title":"Monotonic Stack","text":"<ol> <li>0739 - Daily Temperatures (Medium)</li> <li>0496 - Next Greater Element I (Easy)</li> <li>0503 - Next Greater Element II (Medium)</li> <li>0084 - Largest Rectangle in Histogram (Hard)</li> <li>0085 - Maximal Rectangle (Hard)</li> <li>0042 - Trapping Rain Water (Hard)</li> <li>0901 - Online Stock Span (Medium)</li> <li>0316 - Remove Duplicate Letters (Medium)</li> <li>0456 - 132 Pattern (Medium)</li> <li>2281 - Sum of Total Strength of Wizards (Hard)</li> </ol>"},{"location":"stack_monotonic/#739-daily-temperatures","title":"739. Daily Temperatures","text":"<pre><code>from typing import List\n\n\ndef dailyTemperatures(temperatures: List[int]) -&gt; List[int]:\n    result = [0 for _ in range(len(temperatures))]\n    stack = []\n\n    for i, t in enumerate(temperatures):\n        while stack and t &gt; stack[-1][0]:\n            _, stackIdx = stack.pop()\n            result[stackIdx] = i - stackIdx\n        stack.append([t, i])\n\n    return result\n\n\nprint(dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73]))\n# [1, 1, 4, 2, 1, 1, 0, 0]\n</code></pre>"},{"location":"stack_monotonic/#496-next-greater-element-i","title":"496. Next Greater Element I","text":"<pre><code>from typing import List\n\n\n# Monotonic Stack\ndef nextGreaterElement(nums1: List[int], nums2: List[int]) -&gt; List[int]:\n    next_greater = {}\n    stack = []\n    result = []\n\n    for num in nums2:\n        while stack and num &gt; stack[-1]:\n            next_greater[stack.pop()] = num\n        stack.append(num)\n\n    for num in nums1:\n        result.append(next_greater.get(num, -1))\n\n    return result\n\n\nnums1 = [4, 1, 2]\nnums2 = [1, 3, 4, 2]\nprint(nextGreaterElement(nums1, nums2))  # [3, -1, -1]\n</code></pre>"},{"location":"stack_monotonic/#503-next-greater-element-ii","title":"503. Next Greater Element II","text":"<pre><code>from typing import List\n\n\n# Monotonic Stack\ndef nextGreaterElements(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    result = [-1] * n\n    stack = []\n\n    for i in range(2 * n):\n        while stack and nums[stack[-1]] &lt; nums[i % n]:\n            result[stack.pop()] = nums[i % n]\n        if i &lt; n:\n            stack.append(i)\n\n    return result\n\n\nnums = [1, 2, 1]\nprint(nextGreaterElements(nums))  # [2, -1, 2]\n</code></pre>"},{"location":"stack_monotonic/#84-largest-rectangle-in-histogram","title":"84. Largest Rectangle in Histogram","text":"<pre><code>from typing import List\n\n\ndef largestRectangleArea(heights: List[int]) -&gt; int:\n    maxArea = 0\n    stack = []  # pair: (index, height)\n\n    for i, h in enumerate(heights):\n        start = i\n        while stack and stack[-1][1] &gt; h:\n            index, height = stack.pop()\n            maxArea = max(maxArea, height * (i - index))\n            start = index\n        stack.append((start, h))\n\n    for i, h in stack:\n        maxArea = max(maxArea, h * (len(heights) - i))\n\n    return maxArea\n\n\nprint(largestRectangleArea([2, 1, 5, 6, 2, 3]))  # 10\n</code></pre>"},{"location":"stack_monotonic/#85-maximal-rectangle","title":"85. Maximal Rectangle","text":""},{"location":"stack_monotonic/#42-trapping-rain-water","title":"42. Trapping Rain Water","text":"<pre><code>from typing import List\n\n\n# Two Pointers\ndef trapTP(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    left, right = 0, len(height) - 1\n    leftMax, rightMax = 0, 0\n    total = 0\n\n    while left &lt; right:\n        if height[left] &lt; height[right]:\n            if height[left] &gt;= leftMax:\n                leftMax = height[left]\n            else:\n                total += leftMax - height[left]\n            left += 1\n        else:\n            if height[right] &gt;= rightMax:\n                rightMax = height[right]\n            else:\n                total += rightMax - height[right]\n            right -= 1\n\n    return total\n\n\n# Monotonic Stack\ndef trapStack(height: List[int]) -&gt; int:\n    stack = []\n    total = 0\n\n    for i in range(len(height)):\n        while stack and height[i] &gt; height[stack[-1]]:\n            top = stack.pop()\n            if not stack:\n                break\n            distance = i - stack[-1] - 1\n            bounded_height = min(height[i], height[stack[-1]]) - height[top]\n            total += distance * bounded_height\n        stack.append(i)\n\n    return total\n\n\nheight = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\nprint(trapTP(height))  # 6\nprint(trapStack(height))  # 6\n</code></pre>"},{"location":"stack_monotonic/#901-online-stock-span","title":"901. Online Stock Span","text":""},{"location":"stack_monotonic/#316-remove-duplicate-letters","title":"316. Remove Duplicate Letters","text":""},{"location":"stack_monotonic/#456-132-pattern","title":"456. 132 Pattern","text":""},{"location":"stack_monotonic/#2281-sum-of-total-strength-of-wizards","title":"2281. Sum of Total Strength of Wizards","text":""},{"location":"string/","title":"String","text":"<ol> <li>0344 - Reverse String (Easy)</li> <li>0541 - Reverse String II (Easy)</li> <li>0151 - Reverse Words in a String (Medium)</li> <li>0058 - Length of Last Word (Easy)</li> <li>0844 - Backspace String Compare (Easy)</li> <li>2185 - Counting Words With a Given Prefix (Easy)</li> <li>2000 - Reverse Prefix of Word (Easy)</li> </ol>"},{"location":"string/#344-reverse-string","title":"344. Reverse String","text":"<ul> <li>Reverse a string in-place.</li> </ul> <pre><code>from typing import List\n\n\ndef reverseString(s: List[str]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify s in-place instead.\n    \"\"\"\n    left, right = 0, len(s) - 1\n\n    while left &lt; right:\n        s[left], s[right] = s[right], s[left]\n        left += 1\n        right -= 1\n\n\ns = [\"h\", \"e\", \"l\", \"l\", \"o\"]\nreverseString(s)\nprint(s)  # ['o', 'l', 'l', 'e', 'h']\n</code></pre>"},{"location":"string/#541-reverse-string-ii","title":"541. Reverse String II","text":"<ul> <li>Reverse the first <code>k</code> characters for every <code>2k</code> characters.</li> </ul> <pre><code>def reverseStr(s: str, k: int) -&gt; str:\n    def reverse_substring(text):\n        left, right = 0, len(text) - 1\n        while left &lt; right:\n            text[left], text[right] = text[right], text[left]\n            left += 1\n            right -= 1\n        return text\n\n    result = list(s)\n\n    for i in range(0, len(s), 2 * k):\n        result[i : i + k] = reverse_substring(result[i : i + k])\n\n    return \"\".join(result)\n\n\ns = \"abcdefg\"\nk = 2\nprint(reverseStr(s, k))  # \"bacdfeg\"\n</code></pre>"},{"location":"string/#151-reverse-words-in-a-string","title":"151. Reverse Words in a String","text":"<ul> <li>Reverse the order of words in a string.</li> </ul> <pre><code>def reverseWords(s: str) -&gt; str:\n    words = s.split()\n\n    left, right = 0, len(words) - 1\n\n    while left &lt; right:\n        words[left], words[right] = words[right], words[left]\n        left += 1\n        right -= 1\n\n    return \" \".join(words)\n\n\ns = \"the sky is blue\"\nprint(reverseWords(s))  # \"blue is sky the\"\n</code></pre>"},{"location":"string/#58-length-of-last-word","title":"58. Length of Last Word","text":"<ul> <li>Find the length of the last word in a string.</li> </ul> <pre><code>def lengthOfLastWord(s: str) -&gt; int:\n    n = 0\n\n    for i in range(len(s) - 1, -1, -1):\n        if s[i] != \" \":\n            n += 1\n        if s[i] == \" \" and n &gt; 0:\n            return n\n\n    return n\n\n\nprint(lengthOfLastWord(\"Hello World\"))  # 5\n</code></pre>"},{"location":"string/#844-backspace-string-compare","title":"844. Backspace String Compare","text":"<ul> <li>Compare two strings that contain backspace characters.</li> </ul> <pre><code>def backspaceCompare(s: str, t: str) -&gt; bool:\n\n    def build(text):\n        stack = []\n\n        for char in text:\n            if char != \"#\":\n                stack.append(char)\n            elif stack:\n                stack.pop()\n\n        return \"\".join(stack)\n\n    return build(s) == build(t)\n\n\nprint(backspaceCompare(\"ab#c\", \"ad#c\"))  # True\n</code></pre>"},{"location":"string/#2185-counting-words-with-a-given-prefix","title":"2185. Counting Words With a Given Prefix","text":"<ul> <li>Count the number of words with a given prefix.</li> </ul> <pre><code>from typing import List\n\n\n# 1\ndef prefixCount1(words: List[str], pref: str) -&gt; int:\n    count = 0\n\n    for word in words:\n        if word.startswith(pref):\n            count += 1\n\n    return count\n\n\n# 2\ndef prefixCount2(words: List[str], pref: str) -&gt; int:\n    count = 0\n\n    for word in words:\n        n = len(pref)\n\n        if len(word) &lt; n:\n            continue\n\n        if word[:n] == pref:\n            count += 1\n\n    return count\n\n\nwords = [\"pay\", \"attention\", \"practice\", \"attend\"]\npref = \"at\"\nprint(prefixCount1(words, pref))  # 2\nprint(prefixCount2(words, pref))  # 2\n</code></pre>"},{"location":"string/#2000-reverse-prefix-of-word","title":"2000. Reverse Prefix of Word","text":"<ul> <li>Reverse the prefix of a word.</li> </ul> <pre><code>def reversePrefix(word: str, ch: str) -&gt; str:\n    if ch not in word:\n        return word\n\n    wordList = list(word)\n    left, right = 0, 0\n\n    for i in range(len(wordList)):\n        if wordList[i] == ch:\n            right = i\n            break\n\n    while left &lt; right:\n        wordList[left], wordList[right] = wordList[right], wordList[left]\n        left += 1\n        right -= 1\n\n    return \"\".join(wordList)\n\n\nword = \"abcdefd\"\nch = \"d\"\nprint(reversePrefix(word, ch))  # \"dcbaefd\"\n</code></pre>"},{"location":"string_kmp/","title":"String - KMP","text":"<ol> <li>0028 - Find the Index of the First Occurrence in a String (Easy)</li> <li>0459 - Repeated Substring Pattern (Easy)</li> <li>0686 - Repeated String Match (Medium)</li> <li>1392 - Longest Happy Prefix (Hard)</li> <li>0214 - Shortest Palindrome (Hard)</li> </ol>"},{"location":"string_kmp/#28-find-the-index-of-the-first-occurrence-in-a-string","title":"28. Find the Index of the First Occurrence in a String","text":"<ul> <li>Find the index of the first occurrence of a substring in a string.</li> </ul> <pre><code>from helper import LPS\n\n\ndef strStr(haystack: str, needle: str) -&gt; int:\n    lps = LPS(needle)\n    m, n = len(haystack), len(needle)\n    j = 0\n\n    for i in range(m):\n        while j &gt; 0 and haystack[i] != needle[j]:\n            j = lps[j - 1]\n        if haystack[i] == needle[j]:\n            j += 1\n        if j == n:\n            return i - n + 1\n    return -1\n\n\nhaystack = \"hello\"\nneedle = \"ll\"\nprint(strStr(haystack, needle))  # 2\n</code></pre>"},{"location":"string_kmp/#459-repeated-substring-pattern","title":"459. Repeated Substring Pattern","text":"<ul> <li>Check if a string can be constructed by repeating a substring.</li> </ul> <pre><code>from helper import LPS\n\n\ndef repeatedSubstringPattern(s: str) -&gt; bool:\n    lps = LPS(s)\n    length = len(s)\n\n    if lps[-1] != 0 and length % (length - lps[-1]) == 0:\n        return True\n\n    return False\n\n\ns = \"abab\"\nprint(repeatedSubstringPattern(s))  # True\n</code></pre>"},{"location":"string_kmp/#686-repeated-string-match","title":"686. Repeated String Match","text":"<ul> <li>Find the minimum number of times a string must be repeated to make another string a substring of it.</li> </ul> <pre><code>import math\n\n\ndef repeatedStringMatch(a: str, b: str) -&gt; int:\n    min_repeat = math.ceil(len(b) / len(a))\n\n    def LPS(pattern):\n        lps = [0] * len(pattern)\n        j = 0\n\n        for i in range(1, len(pattern)):\n            while j &gt; 0 and pattern[i] != pattern[j]:\n                j = lps[j - 1]\n            if pattern[i] == pattern[j]:\n                j += 1\n            lps[i] = j\n\n        return lps\n\n    def kmp(text, pattern):\n        n, m = len(text), len(pattern)\n        lps = LPS(pattern)\n        j = 0\n\n        for i in range(n):\n            while j &gt; 0 and text[i] != pattern[j]:\n                j = lps[j - 1]\n            if text[i] == pattern[j]:\n                j += 1\n            if j == m:\n                return i - j + 1\n        return -1\n\n    for i in range(min_repeat, min_repeat + 2):\n        if kmp(a * i, b) != -1:\n            return i\n    return -1\n\n\nprint(repeatedStringMatch(\"abcd\", \"cdabcdab\"))  # 3\n</code></pre>"},{"location":"string_kmp/#1392-longest-happy-prefix","title":"1392. Longest Happy Prefix","text":"<ul> <li>Find the longest prefix that is also a suffix.</li> </ul> <pre><code>def longestPrefix(s: str) -&gt; str:\n    if len(s) &lt;= 1:\n        return \"\"\n\n    def LPS(pattern):\n        lps = [0 for _ in range(len(pattern))]\n        j = 0\n\n        for i in range(1, len(pattern)):\n            while j &gt; 0 and pattern[i] != pattern[j]:\n                j = lps[j - 1]\n            if pattern[i] == pattern[j]:\n                j += 1\n            lps[i] = j\n\n        return lps\n\n    lps = LPS(s)\n\n    return s[: lps[-1]]\n\n\nprint(longestPrefix(\"ababab\"))  # abab\n</code></pre>"},{"location":"string_kmp/#214-shortest-palindrome","title":"214. Shortest Palindrome","text":"<ul> <li>Find the shortest palindrome that can be constructed by adding characters to the beginning of a string.</li> </ul> <pre><code>def shortestPalindrome(s: str) -&gt; str:\n    if not s:\n        return s\n\n    def LPS(pattern):\n        lps = [0] * len(pattern)\n        j = 0\n\n        for i in range(1, len(pattern)):\n            while j &gt; 0 and pattern[i] != pattern[j]:\n                j = lps[j - 1]\n            if pattern[i] == pattern[j]:\n                j += 1\n            lps[i] = j\n        return lps\n\n    new = s + \"#\" + s[::-1]\n    lps = LPS(new)\n\n    add_len = len(s) - lps[-1]\n\n    return s[::-1][:add_len] + s\n\n\nprint(shortestPalindrome(\"aacecaaa\"))  # aaacecaaa\n</code></pre>"},{"location":"tree_bfs/","title":"Binary Tree - BFS (Level Order Traversal)","text":"<ol> <li>0199 - Binary Tree Right Side View (Medium)</li> <li>0111 - Minimum Depth of Binary Tree (Easy)</li> <li>0104 - Maximum Depth of Binary Tree (Easy)</li> <li>0637 - Average of Levels in Binary Tree (Easy)</li> <li>0429 - N-ary Tree Level Order Traversal (Medium)</li> <li>0515 - Find Largest Value in Each Tree Row (Medium)</li> <li>0116 - Populating Next Right Pointers in Each Node (Medium)</li> <li>0117 - Populating Next Right Pointers in Each Node II (Medium)</li> <li>0513 - Find Bottom Left Tree Value (Medium)</li> </ol>"},{"location":"tree_bfs/#0199-binary-tree-right-side-view","title":"0199. Binary Tree Right Side View","text":"<pre><code>    ____1       &lt;---\n   /     \\\n  2__     2     &lt;--- Look at the rightmost node at each level\n /   \\     \\\n3     4     3   &lt;---\n     /\n    5           &lt;---\n</code></pre> <pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef rightSideView(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    queue = deque([root])\n    result = []\n\n    while queue:\n        size = len(queue)\n\n        for i in range(size):\n            current = queue.popleft()\n\n            # rightmost element\n            if i == size - 1:\n                result.append(current.val)\n\n            if current.left:\n                queue.append(current.left)\n            if current.right:\n                queue.append(current.right)\n\n    return result\n\n\nroot = [1, 2, 2, 3, 4, None, 3, None, None, 5]\nroot = build(root)\nprint(root)\n#     ____1\n#    /     \\\n#   2__     2\n#  /   \\     \\\n# 3     4     3\n#      /\n#     5\nprint(rightSideView(root))  # [1, 2, 3, 5]\n</code></pre>"},{"location":"tree_bfs/#0111-minimum-depth-of-binary-tree","title":"0111. Minimum Depth of Binary Tree","text":"<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Iterative\ndef minDepthIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    queue = deque([root])\n    depth = 0\n\n    while queue:\n        depth += 1\n\n        for _ in range(len(queue)):\n            node = queue.popleft()\n\n            if not node.left and not node.right:\n                return depth\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n\n# Recursive\ndef minDepthRecursive(root):\n    if root is None:\n        return 0\n\n    if root.left is None and root.right is not None:\n        return 1 + minDepthRecursive(root.right)\n    if root.left is not None and root.right is None:\n        return 1 + minDepthRecursive(root.left)\n\n    return 1 + min(minDepthRecursive(root.left), minDepthRecursive(root.right))\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n\"\"\"\n    ____1\n   /     \\\n  2__     2\n /   \\\n3     4\n     /\n    5\n\n\"\"\"\nprint(minDepthIterative(root))  # 2\nprint(minDepthRecursive(root))  # 2\n</code></pre>"},{"location":"tree_bfs/#0104-maximum-depth-of-binary-tree","title":"0104. Maximum Depth of Binary Tree","text":"<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Iterative\ndef maxDepthIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    queue = deque([root])\n    depth = 0\n\n    while queue:\n        depth += 1\n\n        for _ in range(len(queue)):\n            node = queue.popleft()\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n    return depth\n\n\n# Recursive\ndef maxDepthRecursive(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    return 1 + max(maxDepthRecursive(root.left), maxDepthRecursive(root.right))\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n\"\"\"\n    ____1\n   /     \\\n  2__     2\n /   \\\n3     4\n     /\n    5\n\"\"\"\nprint(maxDepthIterative(root))  # 4\nprint(maxDepthRecursive(root))  # 4\n</code></pre>"},{"location":"tree_bfs/#0637-average-of-levels-in-binary-tree","title":"0637. Average of Levels in Binary Tree","text":"<pre><code>from collections import deque\nfrom statistics import mean\nfrom typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef averageOfLevels(root: Optional[TreeNode]) -&gt; List[float]:\n    if not root:\n        return []\n\n    queue = deque([root])\n    result = []\n\n    while queue:\n        level = []\n        size = len(queue)\n\n        for _ in range(size):\n            node = queue.popleft()\n            level.append(node.val)\n\n            if node.left:\n                queue.append(node.left)\n\n            if node.right:\n                queue.append(node.right)\n\n        result.append(mean(level))\n\n    return result\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n\"\"\"\n    ____1\n   /     \\\n  2__     2\n /   \\\n3     4\n     /\n    5\n\"\"\"\nprint(averageOfLevels(root))  # [1, 2, 3.5, 5]\n</code></pre>"},{"location":"tree_bfs/#0429-n-ary-tree-level-order-traversal","title":"0429. N-ary Tree Level Order Traversal","text":"<pre><code>from collections import deque\nfrom typing import List, Optional\n\n\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\n\ndef levelOrder(root: Optional[Node]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    queue = deque([root])\n    result = []\n\n    while queue:\n        level = []\n        size = len(queue)\n\n        for _ in range(size):\n            node = queue.popleft()\n            level.append(node.val)\n\n            for child in node.children:\n                queue.append(child)\n\n        result.append(level)\n\n    return result\n\n\nroot = Node(\n    1,\n    [\n        Node(\n            3,\n            [\n                Node(5, []),\n                Node(6, []),\n            ],\n        ),\n        Node(2, []),\n        Node(4, []),\n    ],\n)\nprint(levelOrder(root))  # [[1], [3, 2, 4], [5, 6]]\n</code></pre>"},{"location":"tree_bfs/#0515-find-largest-value-in-each-tree-row","title":"0515. Find Largest Value in Each Tree Row","text":"<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef largestValues(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    queue = deque([root])\n    result = []\n\n    while queue:\n        levelMax = float(\"-inf\")\n        for _ in range(len(queue)):\n            node = queue.popleft()\n\n            levelMax = max(levelMax, node.val)\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n        result.append(levelMax)\n\n    return result\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n#     ____1\n#    /     \\\n#   2__     2\n#  /   \\\n# 3     4\n#      /\n#     5\nprint(largestValues(root))  # [1, 2, 4, 5]\n</code></pre>"},{"location":"tree_bfs/#0116-populating-next-right-pointers-in-each-node","title":"0116. Populating Next Right Pointers in Each Node","text":"<ul> <li>Perfect Binary Tree</li> </ul> <pre><code>from collections import deque\nfrom typing import Optional\n\n\nclass Node:\n    def __init__(\n        self,\n        val: int = 0,\n        left: \"Node\" = None,\n        right: \"Node\" = None,\n        next: \"Node\" = None,\n    ):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\n\ndef connect(root: \"Optional[Node]\") -&gt; \"Optional[Node]\":\n    if not root:\n        return root\n\n    queue = deque([root])\n\n    while queue:\n        size = len(queue)\n        prev = None\n\n        for _ in range(size):\n            node = queue.popleft()\n\n            if prev:\n                prev.next = node\n            prev = node\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n    return root\n\n\n# Perfect binary tree creation\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.right.left = Node(6)\nroot.right.right = Node(7)\n#     __1__\n#    /     \\\n#   2__     3\n#  /   \\   / \\\n# 4     5 6   7\n\n\n# Connect the nodes\nconnect(root)\n#      __1__ -&gt; None\n#     /     \\\n#   _2_ -&gt;  3 -&gt; None\n#  /   \\   / \\\n# 4 -&gt; 5-&gt;6-&gt; 7 -&gt; None\n\n\nassert root.next is None\nassert root.left.next == root.right\nassert root.left.left.next == root.left.right\nassert root.left.right.next == root.right.left\nassert root.right.left.next == root.right.right\nassert root.right.right.next is None\nprint(\"All tests passed.\")\n</code></pre>"},{"location":"tree_bfs/#0117-populating-next-right-pointers-in-each-node-ii","title":"0117. Populating Next Right Pointers in Each Node II","text":"<pre><code>from collections import deque\n\n\nclass Node:\n    def __init__(\n        self,\n        val: int = 0,\n        left: \"Node\" = None,\n        right: \"Node\" = None,\n        next: \"Node\" = None,\n    ):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\n\ndef connect(root: \"Node\") -&gt; \"Node\":\n    if not root:\n        return root\n\n    queue = deque([root])\n\n    while queue:\n        size = len(queue)\n        prev = None\n\n        for _ in range(size):\n            node = queue.popleft()\n\n            if prev:\n                prev.next = node\n\n            prev = node\n\n            if node.left:\n                queue.append(node.left)\n\n            if node.right:\n                queue.append(node.right)\n\n    return root\n\n\n# Binary tree creation\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.right.right = Node(7)\n#       1\n#      / \\\n#     2   3\n#    / \\   \\\n#   4   5   7\n\n# Connect the nodes\nconnect(root)\n#       1 -&gt; None\n#      / \\\n#     2 -&gt; 3 -&gt; None\n#    / \\    \\\n#   4 -&gt; 5 -&gt; 7 -&gt; None\n\nassert root.next is None\nassert root.left.next == root.right\nassert root.right.next is None\nassert root.left.left.next == root.left.right\nassert root.left.right.next == root.right.right\nassert root.right.right.next is None\n\nprint(\"All tests passed.\")\n</code></pre>"},{"location":"tree_bfs/#0513-find-bottom-left-tree-value","title":"0513. Find Bottom Left Tree Value","text":"<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef findBottomLeftValue(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    queue = deque([root])\n    result = 0\n\n    while queue:\n        size = len(queue)\n\n        for i in range(size):\n            node = queue.popleft()\n            if i == 0:\n                result = node.val\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n    return result\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n#     ____1\n#    /     \\\n#   2__     2\n#  /   \\\n# 3     4\n#      /\n#     5\n\nprint(findBottomLeftValue(root))  # 5\n</code></pre>"},{"location":"tree_bst/","title":"Binary Search Tree","text":"<ol> <li>0700 - Search in a Binary Search Tree (Easy)</li> <li>0098 - Validate Binary Search Tree (Medium)</li> <li>0530 - Minimum Absolute Difference in BST (Easy)</li> <li>0501 - Find Mode in Binary Search Tree (Easy)</li> <li>0235 - Lowest Common Ancestor of a Binary Search Tree (Easy)</li> <li>0701 - Insert into a Binary Search Tree (Medium)</li> <li>0450 - Delete Node in a BST (Medium)</li> <li>0669 - Trim a Binary Search Tree (Medium)</li> <li>0108 - Convert Sorted Array to Binary Search Tree (Easy)</li> <li>0109 - Convert Sorted List to Binary Search Tree (Medium)</li> <li>0538 - Convert BST to Greater Tree (Easy)</li> </ol>"},{"location":"tree_bst/#0700-search-in-a-binary-search-tree","title":"0700. Search in a Binary Search Tree","text":"<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# 1. Recursive\ndef searchBSTRecursive(\n    root: Optional[TreeNode], val: int\n) -&gt; Optional[TreeNode]:\n    if not root:\n        return None\n\n    if root.val &gt; val:\n        return searchBSTRecursive(root.left, val)\n\n    elif root.val &lt; val:\n        return searchBSTRecursive(root.right, val)\n\n    else:\n        return root\n\n\n# 2. Iterative\ndef searchBSTIterative(\n    root: Optional[TreeNode], val: int\n) -&gt; Optional[TreeNode]:\n    while root:\n        if root.val &gt; val:\n            root = root.left\n        elif root.val &lt; val:\n            root = root.right\n        else:\n            return root\n    return None\n\n\nroot = [4, 2, 7, 1, 3]\nval = 2\nroot = build(root)\nprint(root)\n#     __4\n#    /   \\\n#   2     7\n#  / \\\n# 1   3\nprint(searchBSTRecursive(root, val))\n#   2\n#  / \\\n# 1   3\nprint(searchBSTIterative(root, val))\n#   2\n#  / \\\n# 1   3\n</code></pre>"},{"location":"tree_bst/#0098-validate-binary-search-tree","title":"0098. Validate Binary Search Tree","text":"<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef isValidBST(root: Optional[TreeNode]) -&gt; bool:\n\n    inorder = []  # inorder traversal of BST\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    for i in range(1, len(inorder)):\n        if inorder[i] &lt;= inorder[i - 1]:\n            return False\n\n    return True\n\n\nroot = [5, 1, 4, None, None, 3, 6]\nroot = build(root)\nprint(root)\n#   5__\n#  /   \\\n# 1     4\n#      / \\\n#     3   6\nprint(isValidBST(root))  # False\n</code></pre>"},{"location":"tree_bst/#0530-minimum-absolute-difference-in-bst","title":"0530. Minimum Absolute Difference in BST","text":"<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef getMinimumDifference(root: Optional[TreeNode]) -&gt; int:\n\n    inorder = []\n    result = float(\"inf\")\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    for i in range(1, len(inorder)):\n        result = min(result, abs(inorder[i] - inorder[i - 1]))\n\n    return result\n\n\nroot = [4, 2, 6, 1, 3]\nroot = build(root)\nprint(root)\n#     __4\n#    /   \\\n#   2     6\n#  / \\\n# 1   3\nprint(getMinimumDifference(root))  # 1\n</code></pre>"},{"location":"tree_bst/#0501-find-mode-in-binary-search-tree","title":"0501. Find Mode in Binary Search Tree","text":"<pre><code>from typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef findMode(root: Optional[TreeNode]) -&gt; List[int]:\n    hashmap = dict()\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        if node.val not in hashmap:\n            hashmap[node.val] = 1\n        else:\n            hashmap[node.val] += 1\n        dfs(node.right)\n\n    dfs(root)\n    max_counts = max(hashmap.values())\n    result = []\n\n    for key, value in hashmap.items():\n        if value == max_counts:\n            result.append(key)\n\n    return result\n\n\nroot = [1, None, 2, None, None, 2]\nroot = build(root)\nprint(root)\n# 1__\n#    \\\n#     2\n#    /\n#   2\nprint(findMode(root))  # [2]\n</code></pre>"},{"location":"tree_bst/#0235-lowest-common-ancestor-of-a-binary-search-tree","title":"0235. Lowest Common Ancestor of a Binary Search Tree","text":"<pre><code>from binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef lowestCommonAncestor(\n    root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n) -&gt; \"TreeNode\":\n    while root:\n        if root.val &gt; p.val and root.val &gt; q.val:\n            root = root.left\n        elif root.val &lt; p.val and root.val &lt; q.val:\n            root = root.right\n        else:\n            return root\n\n\nroot = [6, 2, 8, 0, 4, 7, 9, None, None, 3, 5]\np = root.left\nq = root.right\nroot = build(root)\nprint(root)\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\nprint(lowestCommonAncestor(root, p, q))\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\n</code></pre>"},{"location":"tree_bst/#0701-insert-into-a-binary-search-tree","title":"0701. Insert into a Binary Search Tree","text":"<pre><code>from typing import Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef insertIntoBST(root: Optional[TreeNode], val: int) -&gt; Optional[TreeNode]:\n    if root is None:\n        return TreeNode(val)\n\n    if root.val &gt; val:\n        root.left = insertIntoBST(root.left, val)\n    if root.val &lt; val:\n        root.right = insertIntoBST(root.right, val)\n\n    return root\n\n\nroot = TreeNode(4)\nroot.left = TreeNode(2)\nroot.right = TreeNode(6)\nroot.left.left = TreeNode(1)\nroot.left.right = TreeNode(3)\n#     __4\n#    /   \\\n#   2     6\n#  / \\\n# 1   3\n\ninsertIntoBST(root, 5)\n#     __4\n#    /   \\\n#   2     6\n#  / \\   /\n# 1   3 5\n</code></pre>"},{"location":"tree_bst/#0450-delete-node-in-a-bst","title":"0450. Delete Node in a BST","text":"<pre><code>from typing import Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef deleteNode(root: Optional[TreeNode], key: int) -&gt; Optional[TreeNode]:\n    if root is None:\n        return root\n\n    if root.val == key:\n        if root.left is None and root.right is None:\n            return None\n        elif root.left is None:\n            return root.right\n        elif root.right is None:\n            return root.left\n        else:\n            cur = root.right\n            while cur.left is not None:\n                cur = cur.left\n            cur.left = root.left\n            return root.right\n\n    if root.val &gt; key:\n        root.left = deleteNode(root.left, key)\n    if root.val &lt; key:\n        root.right = deleteNode(root.right, key)\n\n    return root\n\n\nroot = TreeNode(5)\nroot.left = TreeNode(3)\nroot.right = TreeNode(6)\nroot.left.left = TreeNode(2)\nroot.left.right = TreeNode(4)\nroot.right.right = TreeNode(7)\n#     __5\n#    /   \\\n#   3     6\n#  / \\     \\\n# 2   4     7\n\ndeleteNode(root, 3)\n#     __5\n#    /   \\\n#   4     6\n#  /       \\\n# 2         7\n</code></pre>"},{"location":"tree_bst/#0669-trim-a-binary-search-tree","title":"0669. Trim a Binary Search Tree","text":"<pre><code>from typing import Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef trimBST(\n    root: Optional[TreeNode], low: int, high: int\n) -&gt; Optional[TreeNode]:\n    if root is None:\n        return None\n\n    if root.val &lt; low:\n        return trimBST(root.right, low, high)\n    if root.val &gt; high:\n        return trimBST(root.left, low, high)\n\n    root.left = trimBST(root.left, low, high)\n    root.right = trimBST(root.right, low, high)\n\n    return root\n\n\nroot = TreeNode(3)\nroot.left = TreeNode(0)\nroot.right = TreeNode(4)\nroot.left.right = TreeNode(2)\nroot.left.right.left = TreeNode(1)\n#     __3\n#    /   \\\n#   0     4\n#    \\\n#     2\n#    /\n#   1\n\ntrimBST(root, 1, 3)\n#     __3\n#    /\n#   2\n#  /\n# 1\n</code></pre>"},{"location":"tree_bst/#0108-convert-sorted-array-to-binary-search-tree","title":"0108. Convert Sorted Array to Binary Search Tree","text":"<pre><code>from typing import List, Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef sortedArrayToBST(nums: List[int]) -&gt; Optional[TreeNode]:\n    if len(nums) == 0:\n        return None\n\n    mid = len(nums) // 2\n    root = TreeNode(nums[mid])\n\n    root.left = sortedArrayToBST(nums[:mid])\n    root.right = sortedArrayToBST(nums[mid + 1 :])\n\n    return root\n\n\nnums = [-10, -3, 0, 5, 9]\nroot = sortedArrayToBST(nums)\n#      0\n#     / \\\n#   -3   9\n#   /   /\n# -10  5\n</code></pre>"},{"location":"tree_bst/#0109-convert-sorted-list-to-binary-search-tree","title":"0109. Convert Sorted List to Binary Search Tree","text":"<pre><code>from typing import Optional\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef sortedListToBST(head: Optional[ListNode]) -&gt; Optional[TreeNode]:\n    if not head:\n        return None\n\n    def find_middle(head: ListNode) -&gt; ListNode:\n        prev = None\n        slow = head\n        fast = head\n\n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n\n        if prev:\n            prev.next = None\n\n        return slow\n\n    mid = find_middle(head)\n\n    node = TreeNode(mid.val)\n\n    if head == mid:\n        return node\n\n    node.left = sortedListToBST(head)\n    node.right = sortedListToBST(mid.next)\n\n    return node\n\n\nhead = ListNode(-10)\nhead.next = ListNode(-3)\nhead.next.next = ListNode(0)\nhead.next.next.next = ListNode(5)\nhead.next.next.next.next = ListNode(9)\n\nroot = sortedListToBST(head)\nassert root.val == 0\nassert root.left.val == -3\nassert root.left.left.val == -10\nassert root.right.val == 9\nassert root.right.left.val == 5\nprint(\"All passed\")\n\n#      0\n#     / \\\n#   -3   9\n#   /   /\n# -10  5\n</code></pre>"},{"location":"tree_bst/#0538-convert-bst-to-greater-tree","title":"0538. Convert BST to Greater Tree","text":"<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef convertBST(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    prev = 0\n\n    def dfs(node):\n        if not node:\n            return None\n        nonlocal prev\n\n        dfs(node.right)\n\n        node.val += prev\n        prev = node.val\n\n        dfs(node.left)\n\n    dfs(root)\n\n    return root\n\n\nroot = [4, 1, 6, 0, 2, 5, 7, None, None, None, 3, None, None, None, 8]\nroot = build(root)\nprint(root)\n#     ____4__\n#    /       \\\n#   1         6\n#  / \\       / \\\n# 0   2     5   7\n#      \\         \\\n#       3         8\ngreater_tree = convertBST(root)\nprint(greater_tree)\n#      _______30___\n#     /            \\\n#   _36            _21\n#  /   \\          /   \\\n# 36    35       26    15\n#         \\              \\\n#          33             8\n</code></pre>"},{"location":"tree_common_ancestor/","title":"Common Ancestor of a Binary Tree","text":"<ol> <li>0235 - Lowest Common Ancestor of a Binary Search Tree (Easy)</li> <li>0236 - Lowest Common Ancestor of a Binary Tree (Medium)</li> </ol>"},{"location":"tree_common_ancestor/#235-lowest-common-ancestor-of-a-binary-search-tree","title":"235. Lowest Common Ancestor of a Binary Search Tree","text":"<pre><code>from binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef lowestCommonAncestor(\n    root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n) -&gt; \"TreeNode\":\n    while root:\n        if root.val &gt; p.val and root.val &gt; q.val:\n            root = root.left\n        elif root.val &lt; p.val and root.val &lt; q.val:\n            root = root.right\n        else:\n            return root\n\n\nroot = [6, 2, 8, 0, 4, 7, 9, None, None, 3, 5]\np = root.left\nq = root.right\nroot = build(root)\nprint(root)\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\nprint(lowestCommonAncestor(root, p, q))\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\n</code></pre>"},{"location":"tree_common_ancestor/#236-lowest-common-ancestor-of-a-binary-tree","title":"236. Lowest Common Ancestor of a Binary Tree","text":"<pre><code>from typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef lowestCommonAncestor(\n    root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n) -&gt; \"TreeNode\":\n    if not root or q == root or p == root:\n        return root\n\n    left = lowestCommonAncestor(root.left, p, q)\n    right = lowestCommonAncestor(root.right, p, q)\n\n    if left and right:\n        return root\n\n    return left or right\n\n\nroot = build([3, 5, 1, 6, 2, 0, 8, None, None, 7, 4])\nprint(root)\n#     ______3__\n#    /         \\\n#   5__         1\n#  /   \\       / \\\n# 6     2     0   8\n#      / \\\n#     7   4\np = root.left  # 5\nq = root.right  # 1\nprint(lowestCommonAncestor(root, p, q))  # 3\n#     ______3__\n#    /         \\\n#   5__         1\n#  /   \\       / \\\n# 6     2     0   8\n#      / \\\n#     7   4\nr = root.left.right.right  # 4\nprint(lowestCommonAncestor(root, p, r))  # 5\n#   5__\n#  /   \\\n# 6     2\n#      / \\\n#     7   4\n</code></pre>"},{"location":"tree_feature/","title":"Tree - Feature","text":"<ol> <li>0101 - Symmetric Tree (Easy)</li> <li>0222 - Count Complete Tree Nodes (Medium)</li> <li>0110 - Balanced Binary Tree (Easy)</li> <li>0257 - Binary Tree Paths (Easy)</li> <li>0404 - Sum of Left Leaves (Easy)</li> <li>0112 - Path Sum (Easy)</li> <li>2331 - Evaluate Boolean Binary Tree (Easy)</li> <li>0100 - Same Tree (Easy)</li> </ol>"},{"location":"tree_feature/#101-symmetric-tree","title":"101. Symmetric Tree","text":"<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# 1. Recursive\ndef isSymmetricRecursive(root: Optional[TreeNode]) -&gt; bool:\n    if not root:\n        return True\n\n    def compare(left, right):\n        if left is None and right is not None:\n            return False\n        elif left is not None and right is None:\n            return False\n        elif left is None and right is None:\n            return True\n        elif left.val != right.val:\n            return False\n\n        outside = compare(left.left, right.right)\n        inside = compare(left.right, right.left)\n\n        return outside and inside\n\n    return compare(root.left, root.right)\n\n\n# 2. Iterative\ndef isSymmetricIterative(root: Optional[TreeNode]) -&gt; bool:\n    if not root:\n        return True\n\n    q = deque()\n    q.append(root.left)\n    q.append(root.right)\n\n    while q:\n        leftNode = q.popleft()\n        rightNode = q.popleft()\n\n        if not leftNode and not rightNode:\n            continue\n\n        if not leftNode or not rightNode or leftNode.val != rightNode.val:\n            return False\n\n        q.append(leftNode.left)\n        q.append(rightNode.right)\n        q.append(leftNode.right)\n        q.append(rightNode.left)\n\n    return True\n\n\nroot = [1, 2, 2, 3, 4, 4, 3]\nroot = build(root)\nprint(root)\n#     __1__\n#    /     \\\n#   2       2\n#  / \\     / \\\n# 3   4   4   3\nprint(isSymmetricRecursive(root))  # True\nprint(isSymmetricIterative(root))  # True\n</code></pre>"},{"location":"tree_feature/#222-count-complete-tree-nodes","title":"222. Count Complete Tree Nodes","text":"<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# 1. Recursive\ndef countNodesRecursive(root: Optional[TreeNode]) -&gt; int:\n    # TC: O(n)\n    # SC: O(n)\n    if not root:\n        return 0\n\n    nodeNum = (\n        countNodesRecursive(root.left) + countNodesRecursive(root.right) + 1\n    )\n\n    return nodeNum\n\n\n# 2. Iterative\ndef countNodesIterative(root: Optional[TreeNode]) -&gt; int:\n    # TC: O(n)\n    # SC: O(n)\n\n    if not root:\n        return 0\n\n    q = deque([root])\n    nodeNum = 0\n\n    while q:\n        n = len(q)\n\n        for _ in range(n):\n            node = q.popleft()\n            nodeNum += 1\n\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return nodeNum\n\n\nroot = [1, 2, 3, 4, 5, 6]\nroot = build(root)\nprint(root)\n#     __1__\n#    /     \\\n#   2       3\n#  / \\     /\n# 4   5   6\nprint(countNodesRecursive(root))  # 6\nprint(countNodesIterative(root))  # 6\n</code></pre>"},{"location":"tree_feature/#110-balanced-binary-tree","title":"110. Balanced Binary Tree","text":"<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef isBalanced(root: Optional[TreeNode]) -&gt; bool:\n    def getHeight(node):\n        if not node:\n            return 0\n\n        # post order\n        leftHeight = getHeight(node.left)\n        rightHeight = getHeight(node.right)\n\n        if leftHeight == -1 or rightHeight == -1:\n            return -1\n\n        if abs(leftHeight - rightHeight) &gt; 1:\n            return -1\n        else:\n            return 1 + max(leftHeight, rightHeight)\n\n    if getHeight(root) != -1:\n        return True\n    else:\n        return False\n\n\nroot = [3, 9, 20, None, None, 15, 7]\nroot = build(root)\nprint(root)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(isBalanced(root))  # True\n</code></pre>"},{"location":"tree_feature/#257-binary-tree-paths","title":"257. Binary Tree Paths","text":"<pre><code>from typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef binaryTreePaths(root: Optional[TreeNode]) -&gt; List[str]:\n    if not root:\n        return []\n\n    path = []\n    paths = []\n\n    def dfs(node, path):\n        if not node:\n            return None\n\n        path.append(str(node.val))\n\n        if not node.left and not node.right:\n            paths.append(\"-&gt;\".join(path))\n\n        dfs(node.left, path[:])\n        dfs(node.right, path[:])\n\n    dfs(root, path)\n\n    return paths\n\n\nroot = build([1, 2, 3, None, 5])\nprint(root)\n#   __1\n#  /   \\\n# 2     3\n#  \\\n#   5\nprint(binaryTreePaths(root))  # ['1-&gt;2-&gt;5', '1-&gt;3']\n</code></pre>"},{"location":"tree_feature/#404-sum-of-left-leaves","title":"404. Sum of Left Leaves","text":"<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Iterative\ndef sumOfLeftLeaves(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    stack = [root]\n    sumLL = 0\n\n    while stack:\n        node = stack.pop()\n\n        if node.left and not node.left.left and not node.left.right:\n            sumLL += node.left.val\n\n        if node.right:\n            stack.append(node.right)\n        if node.left:\n            stack.append(node.left)\n\n    return sumLL\n\n\n# Left Leave None:\n#   - node.left is not None\n#   - node.left.left is None\n#   - node.left.right is None\n\nroot = build([3, 9, 20, None, None, 15, 7])\nprint(root)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(sumOfLeftLeaves(root))  # 24\n</code></pre>"},{"location":"tree_feature/#112-path-sum","title":"112. Path Sum","text":"<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef hasPathSum(root: Optional[TreeNode], targetSum: int) -&gt; bool:\n    if not root:\n        return False\n\n    if not root.left and not root.right:\n        return root.val == targetSum\n\n    targetSum -= root.val\n\n    return hasPathSum(root.left, targetSum) or hasPathSum(\n        root.right, targetSum\n    )\n\n\nroot = build([5, 4, 8, 11, None, 13, 4, 7, 2, None, None, None, None, None, 1])\nprint(root)\n#          5___\n#         /    \\\n#     ___4     _8\n#    /        /  \\\n#   11       13   4\n#  /  \\            \\\n# 7    2            1\nprint(hasPathSum(root, 22))  # True\n</code></pre>"},{"location":"tree_feature/#2331-evaluate-boolean-binary-tree","title":"2331. Evaluate Boolean Binary Tree","text":"<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef evaluateTree(root: Optional[TreeNode]) -&gt; bool:\n    if not root.left and not root.right:\n        return root.val\n\n    left = evaluateTree(root.left)\n    right = evaluateTree(root.right)\n\n    if root.val == 2:\n        return left or right\n    elif root.val == 3:\n        return left and right\n\n\nroot = build([2, 1, 3, None, None, 0, 1])\nprint(root)\n#   2__\n#  /   \\\n# 1     3\n#      / \\\n#     0   1\nboolTree = build([\"OR\", \"True\", \"AND\", None, None, \"False\", \"True\"])\nprint(boolTree)\n#    __OR_______\n#   /           \\\n# True        __AND_\n#            /      \\\n#         False     True\nprint(evaluateTree(root))  # 1\n</code></pre>"},{"location":"tree_feature/#100-same-tree","title":"100. Same Tree","text":"<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# 1. Recursive\ndef isSameTreeRecursive(p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:\n    if not p and not q:\n        return True\n    if not p or not q:\n        return False\n    if p.val != q.val:\n        return False\n\n    return isSameTreeRecursive(p.left, q.left) and isSameTreeRecursive(\n        p.right, q.right\n    )\n\n\n# 2. Iterative with queue\ndef isSameTreeIterativeQueue(\n    p: Optional[TreeNode], q: Optional[TreeNode]\n) -&gt; bool:\n    queue = deque([(p, q)])\n\n    while queue:\n        p, q = queue.popleft()\n\n        if not p and not q:\n            continue\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n\n        queue.append((p.left, q.left))\n        queue.append((p.right, q.right))\n\n    return True\n\n\n# 3. Iterative with stack\ndef isSameTreeIterativeStack(\n    p: Optional[TreeNode], q: Optional[TreeNode]\n) -&gt; bool:\n    stack = [(p, q)]\n\n    while stack:\n        n1, n2 = stack.pop()\n\n        if not n1 and not n2:\n            continue\n        if not n1 or not n2:\n            return False\n        if n1.val != n2.val:\n            return False\n\n        stack.append((n1.left, n2.left))\n        stack.append((n1.right, n2.right))\n\n    return True\n\n\np1 = build([1, 2, 3])\nq1 = build([1, 2, 3])\np2 = build([1, 2])\nq2 = build([1, None, 2])\n\nprint(isSameTreeRecursive(p1, q1))  # True\nprint(isSameTreeRecursive(p2, q2))  # False\nprint(isSameTreeIterativeQueue(p1, q1))  # True\nprint(isSameTreeIterativeQueue(p2, q2))  # False\nprint(isSameTreeIterativeStack(p1, q1))  # True\nprint(isSameTreeIterativeStack(p2, q2))  # False\n</code></pre>"},{"location":"tree_modification/","title":"Binary Tree Modification","text":"<ol> <li>0226 - Invert Binary Tree (Easy)</li> <li>0105 - Construct Binary Tree from Preorder and Inorder Traversal (Medium)</li> <li>0106 - Construct Binary Tree from Inorder and Postorder Traversal (Medium)</li> <li>0654 - Maximum Binary Tree (Medium)</li> <li>0617 - Merge Two Binary Trees (Easy)</li> </ol>"},{"location":"tree_modification/#226-invert-binary-tree","title":"226. Invert Binary Tree","text":"<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef invertTreeRecursive(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    root.left, root.right = root.right, root.left\n\n    invertTreeRecursive(root.left)\n    invertTreeRecursive(root.right)\n\n    return root\n\n\n# Iterative\ndef invertTreeIterative(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    stack = [root]\n\n    while stack:\n        node = stack.pop()\n\n        node.left, node.right = node.right, node.left\n        if node.left:\n            stack.append(node.left)\n        if node.right:\n            stack.append(node.right)\n\n    return root\n\n\nroot = build([4, 2, 7, 1, 3, 6, 9])\nprint(root)\n#     __4__\n#    /     \\\n#   2       7\n#  / \\     / \\\n# 1   3   6   9\ninvertedRecursive = invertTreeRecursive(root)\nprint(invertedRecursive)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\nroot = build([4, 2, 7, 1, 3, 6, 9])\ninvertedIterative = invertTreeIterative(root)\nprint(invertedIterative)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\n</code></pre>"},{"location":"tree_modification/#105-construct-binary-tree-from-preorder-and-inorder-traversal","title":"105. Construct Binary Tree from Preorder and Inorder Traversal","text":"<pre><code>from typing import List, Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef buildTree(preorder: List[int], inorder: List[int]) -&gt; Optional[TreeNode]:\n    \"\"\"\n    preorder  root left right  1  2  3\n    inorder   left root right  4  5  6\n    \"\"\"\n    if len(preorder) == 0:\n        return None\n\n    root_val = preorder[0]  # 1\n    root = TreeNode(root_val)\n\n    separator_idx = inorder.index(root_val)  # 5\n\n    left_inorder = inorder[:separator_idx]  # 4\n    right_inorder = inorder[separator_idx + 1 :]  # 6\n\n    left_preorder = preorder[1 : 1 + len(left_inorder)]  # 2\n    right_preorder = preorder[1 + len(left_inorder) :]  # 3\n\n    root.left = buildTree(left_preorder, left_inorder)\n    root.right = buildTree(right_preorder, right_inorder)\n\n    return root\n\n\npreorder = [3, 9, 20, 15, 7]\ninorder = [9, 3, 15, 20, 7]\nroot = buildTree(preorder, inorder)\nprint(root)\n#     3\n#    / \\\n#   9  20\n#     /  \\\n#    15   7\n</code></pre>"},{"location":"tree_modification/#106-construct-binary-tree-from-inorder-and-postorder-traversal","title":"106. Construct Binary Tree from Inorder and Postorder Traversal","text":"<pre><code>from typing import List, Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef buildTree(inorder: List[int], postorder: List[int]) -&gt; Optional[TreeNode]:\n    \"\"\"\n    inorder:    left root  right   1  2  3\n    postorder:  left right root    4  5  6\n    \"\"\"\n\n    if not postorder:\n        return None\n\n    root_val = postorder[-1]  # 6\n    root = TreeNode(root_val)\n\n    separator_idx = inorder.index(root_val)  # 2\n\n    left_inorder = inorder[:separator_idx]  # 1\n    right_inorder = inorder[separator_idx + 1 :]  # 3\n\n    left_postorder = postorder[: len(left_inorder)]  # 4\n    right_postorder = postorder[len(left_inorder) : -1]  # 5\n\n    root.left = buildTree(left_inorder, left_postorder)\n    root.right = buildTree(right_inorder, right_postorder)\n\n    return root\n\n\ninorder = [9, 3, 15, 20, 7]\npostorder = [9, 15, 7, 20, 3]\nroot = buildTree(inorder, postorder)\nprint(root)\n#     3\n#    / \\\n#   9  20\n#     /  \\\n#    15   7\n</code></pre>"},{"location":"tree_modification/#654-maximum-binary-tree","title":"654. Maximum Binary Tree","text":"<pre><code>from typing import List, Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef constructMaximumBinaryTree(nums: List[int]) -&gt; Optional[TreeNode]:\n    if len(nums) == 0:\n        return None\n\n    maximum = max(nums)\n    rootIndex = nums.index(maximum)\n\n    root = TreeNode(maximum)\n\n    left_nums = nums[:rootIndex]\n    right_nums = nums[rootIndex + 1 :]\n\n    root.left = constructMaximumBinaryTree(left_nums)\n    root.right = constructMaximumBinaryTree(right_nums)\n\n    return root\n\n\nnums = [3, 2, 1, 6, 0, 5]\nroot = constructMaximumBinaryTree(nums)\n#     __6__\n#    /     \\\n#   3       5\n#    \\     /\n#     2   0\n#      \\\n#       1\n</code></pre>"},{"location":"tree_modification/#617-merge-two-binary-trees","title":"617. Merge Two Binary Trees","text":"<pre><code>from typing import List, Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef mergeTrees(\n    root1: Optional[TreeNode], root2: Optional[TreeNode]\n) -&gt; Optional[TreeNode]:\n\n    if not root1:\n        return root2\n    if not root2:\n        return root1\n\n    root = TreeNode()\n\n    root.val += root1.val + root2.val\n    root.left = mergeTrees(root1.left, root2.left)\n    root.right = mergeTrees(root1.right, root2.right)\n\n    return root\n\n\nroot1 = TreeNode(1)\nroot1.left = TreeNode(3)\nroot1.right = TreeNode(2)\nroot1.left.left = TreeNode(5)\n#     1\n#    / \\\n#   3   2\n#  /\n# 5\n\nroot2 = TreeNode(2)\nroot2.left = TreeNode(1)\nroot2.right = TreeNode(3)\nroot2.left.right = TreeNode(4)\nroot2.right.right = TreeNode(7)\n#     2\n#    / \\\n#   1   3\n#    \\   \\\n#     4   7\n\nroot = mergeTrees(root1, root2)\n#     3\n#    / \\\n#   4   5\n#  / \\   \\\n# 5   4   7\n</code></pre>"},{"location":"tree_traversal/","title":"Binary Tree Traversal","text":"Traversal Order Method Result Preorder Root, Left, Right DFS or Stack <code>[0, 1, 3, 4, 2, 5, 6]</code> Inorder Left, Root, Right DFS or Stack <code>[3, 1, 4, 0, 5, 2, 6]</code> Postorder Left, Right, Root DFS or Stack <code>[3, 4, 1, 5, 6, 2, 0]</code> Level Order Level by Level BFS with Queue <code>[[0], [1, 2], [3, 4, 5, 6]]</code>"},{"location":"tree_traversal/#leetcode-problems","title":"LeetCode Problems","text":"<ol> <li>0144 - Binary Tree Preorder Traversal (Easy)</li> <li>0094 - Binary Tree Inorder Traversal (Easy)</li> <li>0145 - Binary Tree Postorder Traversal (Easy)</li> <li>0102 - Binary Tree Level Order Traversal (Medium)</li> <li>0107 - Binary Tree Level Order Traversal II (Medium)</li> <li>0103 - Binary Tree Zigzag Level Order Traversal (Medium)</li> </ol>"},{"location":"tree_traversal/#0144-binary-tree-preorder-traversal","title":"0144. Binary Tree Preorder Traversal","text":"<pre><code>from typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef preorderTraversalRecursive(root: Optional[TreeNode]) -&gt; List[int]:\n    preorder = []\n\n    def dfs(node):\n        if not node:\n            return None\n\n        preorder.append(node.val)\n        dfs(node.left)\n        dfs(node.right)\n\n    dfs(root)\n\n    return preorder\n\n\n# Iterative\ndef preorderTraversalIterative(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    stack = [root]\n    preorder = []\n\n    while stack:\n        node = stack.pop()\n        preorder.append(node.val)\n\n        if node.right:\n            stack.append(node.right)\n        if node.left:\n            stack.append(node.left)\n\n    return preorder\n\n\ntree = build([0, 1, 2, 3, 4, 5, 6])\nprint(tree)\n#     __0__\n#    /     \\\n#   1       2\n#  / \\     / \\\n# 3   4   5   6\nprint(preorderTraversalRecursive(tree))  # [0, 1, 3, 4, 2, 5, 6]\nprint(preorderTraversalIterative(tree))  # [0, 1, 3, 4, 2, 5, 6]\n</code></pre>"},{"location":"tree_traversal/#0094-binary-tree-inorder-traversal","title":"0094. Binary Tree Inorder Traversal","text":"<pre><code>from typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef inorderTraversalRecursive(root: TreeNode) -&gt; List[int]:\n    inorder = []\n\n    def dfs(node):\n        if not node:\n            return\n\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    return inorder\n\n\n# Iterative\ndef inorderTraversalIterative(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    stack = []\n    inorder = []\n    current = root\n\n    while current or stack:\n        if current:\n            stack.append(current)\n            current = current.left\n        else:\n            current = stack.pop()\n            inorder.append(current.val)\n            current = current.right\n\n    return inorder\n\n\ntree = build([0, 1, 2, 3, 4, 5, 6])\nprint(tree)\n#     __0__\n#    /     \\\n#   1       2\n#  / \\     / \\\n# 3   4   5   6\nprint(inorderTraversalRecursive(tree))  # [3, 1, 4, 0, 5, 2, 6]\nprint(inorderTraversalIterative(tree))  # [3, 1, 4, 0, 5, 2, 6]\n</code></pre>"},{"location":"tree_traversal/#0145-binary-tree-postorder-traversal","title":"0145. Binary Tree Postorder Traversal","text":"<pre><code>from typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef postorderTraversalRecursive(root: Optional[TreeNode]) -&gt; List[int]:\n    postorder = []\n\n    def dfs(node):\n        if not node:\n            return\n\n        dfs(node.left)\n        dfs(node.right)\n        postorder.append(node.val)\n\n    dfs(root)\n\n    return postorder\n\n\n# Iterative\ndef postorderTraversalIterative(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    postorder = []\n    stack = [root]\n\n    while stack:\n        node = stack.pop()\n        postorder.append(node.val)\n\n        if node.left:\n            stack.append(node.left)\n        if node.right:\n            stack.append(node.right)\n\n    return postorder[::-1]\n\n\ntree = build([0, 1, 2, 3, 4, 5, 6])\nprint(tree)\n#     __0__\n#    /     \\\n#   1       2\n#  / \\     / \\\n# 3   4   5   6\nprint(postorderTraversalRecursive(tree))  # [3, 4, 1, 5, 6, 2, 0]\nprint(postorderTraversalIterative(tree))  # [3, 4, 1, 5, 6, 2, 0]\n</code></pre>"},{"location":"tree_traversal/#0102-binary-tree-level-order-traversal","title":"0102. Binary Tree Level Order Traversal","text":"<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef levelOrder(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    queue = deque([root])\n    levels = []\n\n    while queue:\n        level = []\n        size = len(queue)\n\n        for _ in range(size):\n            current = queue.popleft()\n            level.append(current.val)\n\n            if current.left:\n                queue.append(current.left)\n            if current.right:\n                queue.append(current.right)\n\n        levels.append(level)\n\n    return levels\n\n\ntree = build([3, 9, 20, None, None, 15, 7])\nprint(tree)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(levelOrder(tree))  # [[3], [9, 20], [15, 7]]\n</code></pre>"},{"location":"tree_traversal/#0107-binary-tree-level-order-traversal-ii","title":"0107. Binary Tree Level Order Traversal II","text":"<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef levelOrderBottom(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    levels = []\n    queue = deque([root])\n\n    while queue:\n        level = []\n        n = len(queue)\n\n        for _ in range(n):\n            current = queue.popleft()\n            level.append(current.val)\n\n            if current.left:\n                queue.append(current.left)\n            if current.right:\n                queue.append(current.right)\n\n        levels.append(level)\n\n    return levels[::-1]\n\n\ntree = build([3, 9, 20, None, None, 15, 7])\nprint(tree)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(levelOrderBottom(tree))  # [[15, 7], [9, 20], [3]]\n</code></pre>"},{"location":"tree_traversal/#0103-binary-tree-zigzag-level-order-traversal","title":"0103. Binary Tree Zigzag Level Order Traversal","text":"<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef zigzagLevelOrder(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    q = deque([root])\n    levels = []\n\n    while q:\n        level = []\n        n = len(q)\n\n        for _ in range(n):\n            node = q.popleft()\n            level.append(node.val)\n\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n        levels.append(level if len(levels) % 2 == 0 else level[::-1])\n\n    return levels\n\n\ntree = build([3, 9, 20, None, None, 15, 7])\nprint(tree)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(zigzagLevelOrder(tree))  # [[3], [20, 9], [15, 7]]\n</code></pre>"},{"location":"tree_trie/","title":"Trie (Prefix Tree)","text":"<ol> <li>0208 - Implement Trie (Prefix Tree) (Medium)</li> <li>0211 - Add and Search Word - Data structure design (Medium)</li> <li>0212 - Word Search II (Hard)</li> </ol>"},{"location":"tree_trie/#208-implement-trie-prefix-tree","title":"208. Implement Trie (Prefix Tree)","text":"<pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.endOfWord = None\n\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.endOfWord = True\n\n    def search(self, word: str) -&gt; bool:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return node.endOfWord\n\n    def startsWith(self, prefix: str) -&gt; bool:\n        node = self.root\n\n        for c in prefix:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return True\n\n\n# Your Trie object will be instantiated and called as such:\nobj = Trie()\nobj.insert(\"apple\")\nprint(obj.search(\"word\"))  # False\nprint(obj.startsWith(\"app\"))  # True\n</code></pre>"},{"location":"tree_trie/#211-add-and-search-word-data-structure-design","title":"211. Add and Search Word - Data structure design","text":"<pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.word = False\n\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.word = True\n\n    def search(self, word: str) -&gt; bool:\n\n        def dfs(j, root):\n            node = root\n\n            for i in range(j, len(word)):\n                c = word[i]\n\n                if c == \".\":\n                    for child in node.children.values():\n                        if dfs(i + 1, child):\n                            return True\n                    return False\n                else:\n                    if c not in node.children:\n                        return False\n                    node = node.children[c]\n            return node.word\n\n        return dfs(0, self.root)\n\n\n# Your WordDictionary object will be instantiated and called as such:\nobj = WordDictionary()\nobj.addWord(\"word\")\nprint(obj.search(\"word\"))\nprint(obj.search(\"w.rd\"))\n</code></pre>"},{"location":"tree_trie/#212-word-search-ii","title":"212. Word Search II","text":"<pre><code>from typing import List\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.isWord = False\n\n    def addWord(self, word):\n        node = self\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.isWord = True\n\n\nclass Solution:\n    def findWords(self, board: List[List[str]], words: List[str]) -&gt; List[str]:\n        root = TrieNode()\n        for w in words:\n            root.addWord(w)\n\n        m, n = len(board), len(board[0])\n        result, visit = set(), set()\n\n        def dfs(r, c, node, word):\n            if (\n                r not in range(m)\n                or c not in range(n)\n                or (r, c) in visit\n                or board[r][c] not in node.children\n            ):\n                return None\n\n            visit.add((r, c))\n\n            node = node.children[board[r][c]]\n            word += board[r][c]\n            if node.isWord:\n                result.add(word)\n\n            dfs(r - 1, c, node, word)\n            dfs(r + 1, c, node, word)\n            dfs(r, c - 1, node, word)\n            dfs(r, c + 1, node, word)\n\n            visit.remove((r, c))\n\n        for r in range(m):\n            for c in range(n):\n                dfs(r, c, root, \"\")\n\n        return list(result)\n\n\n# Your Solution object will be instantiated and called as such:\nobj = Solution()\nprint(\n    obj.findWords(\n        [\n            [\"o\", \"a\", \"a\", \"n\"],\n            [\"e\", \"t\", \"a\", \"e\"],\n            [\"i\", \"h\", \"k\", \"r\"],\n            [\"i\", \"f\", \"l\", \"v\"],\n        ],\n        [\"oath\", \"pea\", \"eat\", \"rain\"],\n    )\n)\n# [\"oath\", \"eat\"]\n</code></pre>"}]}