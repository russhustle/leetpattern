{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to \ud83d\ude80LeetPattern","text":"<p>Welcome! This project is dedicated to helping you master coding interviews by breaking down common problem-solving patterns.</p> <p>If you find this resource useful, please consider starring \u2b50\ufe0f the repository on GitHub. Your support helps others discover the project and motivates continued development!</p> <p>\ud83d\udcda Inside, you'll find a curated collection of patterns for tackling LeetCode problems. Use these guides to strengthen your understanding of algorithms and data structures, and to approach interview questions with confidence.</p> <p>\ud83c\udf1f Remember, every expert was once a beginner! Start simple and build your confidence. Why not begin with LeetCode Problem 2235 - it's a perfect warm-up that will get you in the coding mindset. You've got this! \ud83d\udcaa</p>"},{"location":"about/","title":"Meet your Instructor","text":"Hi, I am Sihan. Connect with me on    <p>I've spent my career diving into the world of AI and machine learning, working on everything from optimizing DNN algorithms to deploying AI models on hardware. Right now, I'm at Sony, where I get to play with TensorRT, ONNX, and OpenVINO to create some pretty cool stuff. I\u2019ve built full-stack systems, set up MLOps pipelines, and delivered high-performance models for AI camera chips.</p> <p>Before Sony, I did a bunch of internships and research gigs, working on things like fine-tuning language models and industrial anomaly detection. I also have a Master\u2019s in Electrical and Electronic Engineering from Tokyo Tech, where I focused on self-supervised learning and edge computing.</p> <p>I love tackling tough problems and pushing the boundaries of what AI can do. It's been a fun ride so far, and I'm excited to keep making an impact in the AI world.</p>"},{"location":"content/blind75/","title":"Blind 75","text":""},{"location":"content/blind75/1d_dynamic_programming/","title":"1D Dynamic Programming","text":""},{"location":"content/blind75/1d_dynamic_programming/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 70. Climbing Stairs (Easy)</li> <li> 198. House Robber (Medium)</li> <li> 213. House Robber II (Medium)</li> <li> 5. Longest Palindromic Substring (Medium)</li> <li> 647. Palindromic Substrings (Medium)</li> <li> 91. Decode Ways (Medium)</li> <li> 322. Coin Change (Medium)</li> <li> 152. Maximum Product Subarray (Medium)</li> <li> 139. Word Break (Medium)</li> <li> 300. Longest Increasing Subsequence (Medium)</li> </ul>"},{"location":"content/blind75/1d_dynamic_programming/#70-climbing-stairs","title":"70. Climbing Stairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, dynamic programming, memoization</p> </li> <li>Return the number of distinct ways to reach the top of the stairs.</li> <li><code>dp[n]</code> stores the number of distinct ways to reach the <code>n-th</code> stair.</li> <li>Formula: <code>dp[n] = dp[n - 1] + dp[n - 2]</code>.</li> <li>Initialize <code>dp[0] = 0</code>, <code>dp[1] = 1</code>, and <code>dp[2] = 2</code>.</li> </ul> 70. Climbing Stairs - Python Solution<pre><code>from functools import cache\n\n\n# DP\ndef climbStairsDP(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    dp = [i for i in range(n + 1)]\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\n# DP (Optimized)\ndef climbStairsDPOptimized(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    first, second = 1, 2\n\n    for _ in range(3, n + 1):\n        first, second = second, first + second\n\n    return second\n\n\n# Recursion\ndef climbStairsRecursion(n: int) -&gt; int:\n    @cache\n    def dfs(i: int) -&gt; int:\n        if i &lt;= 1:\n            return 1\n        return dfs(i - 1) + dfs(i - 2)\n\n    return dfs(n)\n\n\n# Greedy\ndef climbStairsGreedy(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    p1, p2 = 1, 2\n\n    for _ in range(3, n + 1):\n        p1, p2 = p2, p1 + p2\n\n    return p2\n\n\nif __name__ == \"__main__\":\n    assert climbStairsDP(10) == 89\n    assert climbStairsDPOptimized(10) == 89\n    assert climbStairsRecursion(10) == 89\n    assert climbStairsGreedy(10) == 89\n</code></pre> 70. Climbing Stairs - C++ Solution<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint climbStairs(int n) {\n    if (n &lt;= 2) return n;\n    int f1 = 1, f2 = 2;\n    int res;\n\n    int i = 3;\n    while (i &lt;= n) {\n        res = f1 + f2;\n        f1 = f2;\n        f2 = res;\n        ++i;\n    }\n    return res;\n}\n\nint main() {\n    cout &lt;&lt; climbStairs(2) &lt;&lt; endl;  // 2\n    cout &lt;&lt; climbStairs(3) &lt;&lt; endl;  // 3\n    cout &lt;&lt; climbStairs(6) &lt;&lt; endl;  // 13\n    return 0;\n}\n</code></pre>"},{"location":"content/blind75/1d_dynamic_programming/#198-house-robber","title":"198. House Robber","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li> <p>Return the maximum amount of money that can be robbed from the houses. No two adjacent houses can be robbed.</p> </li> <li> <p><code>dp[n]</code> stores the maximum amount of money that can be robbed from the first <code>n</code> houses.</p> </li> <li>Formula: <code>dp[n] = max(dp[n - 1], dp[n - 2] + nums[n])</code>.<ul> <li>Skip: <code>dp[n]</code> \u2192 <code>dp[n - 1]</code></li> <li>Rob: <code>dp[n]</code> \u2192 <code>dp[n - 2] + nums[n]</code></li> </ul> </li> <li>Initialize <code>dp[0] = nums[0]</code> and <code>dp[1] = max(nums[0], nums[1])</code>.</li> <li>Return <code>dp[-1]</code>.</li> <li>Example: <code>nums = [2, 7, 9, 3, 1]</code></li> </ul> n <code>nums[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n-2] + nums[n]</code> <code>dp[n]</code> 0 2 - 2 - 2 1 7 - 7 - 7 2 9 2 7 11 11 3 3 7 11 10 11 4 1 11 11 12 12 198. House Robber - Python Solution<pre><code>from typing import List\n\n\n# DP (House Robber)\ndef rob1(nums: List[int]) -&gt; int:\n    if len(nums) &lt; 3:\n        return max(nums)\n\n    dp = [0 for _ in range(len(nums))]\n    dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n    for i in range(2, len(nums)):\n        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n    return dp[-1]\n\n\n# DP (House Robber) Optimized\ndef rob2(nums: List[int]) -&gt; int:\n    f0, f1 = 0, 0\n\n    for num in nums:\n        f0, f1 = f1, max(f1, f0 + num)\n\n    return f1\n\n\nnums = [2, 7, 9, 3, 1]\nprint(rob1(nums))  # 12\nprint(rob2(nums))  # 12\n</code></pre> 198. House Robber - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint rob(vector&lt;int&gt; &amp;nums) {\n    int prev = 0, cur = 0, temp = 0;\n\n    for (int num : nums) {\n        temp = cur;\n        cur = max(cur, prev + num);\n        prev = temp;\n    }\n    return cur;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {2, 7, 9, 3, 1};\n    cout &lt;&lt; rob(nums) &lt;&lt; endl;  // 12\n    return 0;\n}\n</code></pre>"},{"location":"content/blind75/1d_dynamic_programming/#213-house-robber-ii","title":"213. House Robber II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li>Return the maximum amount of money that can be robbed from the houses arranged in a circle.</li> <li>Circular \u2192 Linear: <code>nums[0]</code> and <code>nums[-1]</code> cannot be robbed together.</li> <li>Rob from <code>0</code> to <code>n - 2</code></li> </ul> n <code>nums[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n-2] + nums[n]</code> <code>dp[n]</code> 0 2 - 2 - 2 1 7 - 7 - 7 2 9 2 7 11 11 3 3 7 11 10 11 <ul> <li>Rob from <code>1</code> to <code>n - 1</code></li> </ul> n <code>nums[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n-2] + nums[n]</code> <code>dp[n]</code> 1 7 - - - 7 2 9 - 7 - 9 3 3 7 9 10 10 4 1 9 10 10 10 213. House Robber II - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef rob(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 3:\n        return max(nums)\n\n    def robLinear(nums: List[int]) -&gt; int:\n        dp = [0 for _ in range(len(nums))]\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n        return dp[-1]\n\n    # circle -&gt; linear\n    a = robLinear(nums[1:])  # 2nd house to the last house\n    b = robLinear(nums[:-1])  # 1st house to the 2nd last house\n\n    return max(a, b)\n\n\nnums = [2, 7, 9, 3, 1]\nprint(rob(nums))  # 11\n</code></pre> 213. House Robber II - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// DP\nint robDP(vector&lt;int&gt;&amp; nums) {\n    int n = nums.size();\n    if (n &lt;= 3) return *max_element(nums.begin(), nums.end());\n\n    vector&lt;int&gt; dp1(n, 0), dp2(n, 0);\n\n    dp1[0] = nums[0];\n    dp2[1] = max(nums[0], nums[1]);\n    for (int i = 2; i &lt; n - 1; i++) {\n        dp1[i] = max(dp1[i - 1], dp1[i - 2] + nums[i]);\n    }\n\n    dp2[1] = nums[1];\n    dp2[2] = max(nums[1], nums[2]);\n    for (int i = 3; i &lt; n; i++) {\n        dp1[i] = max(dp1[i - 1], dp1[i - 2] + nums[i]);\n    }\n\n    return max(dp1[n - 2], dp2[n - 1]);\n}\n\n// DP (Space Optimized)\nint robDPOptimized(vector&lt;int&gt;&amp; nums) {\n    int n = nums.size();\n    if (n &lt;= 3) return *max_element(nums.begin(), nums.end());\n\n    int f1 = nums[0];\n    int f2 = max(nums[0], nums[1]);\n    int res1;\n    for (int i = 2; i &lt; n - 1; i++) {\n        res1 = max(f2, f1 + nums[i]);\n        f1 = f2;\n        f2 = res1;\n    }\n\n    f1 = nums[1];\n    f2 = max(nums[1], nums[2]);\n    int res2;\n    for (int i = 3; i &lt; n; i++) {\n        res2 = max(f2, f1 + nums[i]);\n        f1 = f2;\n        f2 = res2;\n    }\n\n    return max(res1, res2);\n}\n\nint main() {\n    vector&lt;int&gt; nums = {2, 3, 2};\n    cout &lt;&lt; robDP(nums) &lt;&lt; endl;           // 3\n    cout &lt;&lt; robDPOptimized(nums) &lt;&lt; endl;  // 3\n\n    nums = {1, 2, 3, 1};\n    cout &lt;&lt; robDP(nums) &lt;&lt; endl;           // 4\n    cout &lt;&lt; robDPOptimized(nums) &lt;&lt; endl;  // 4\n\n    return 0;\n}\n</code></pre>"},{"location":"content/blind75/1d_dynamic_programming/#5-longest-palindromic-substring","title":"5. Longest Palindromic Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string, dynamic programming</p> </li> <li>Return the longest palindromic substring in <code>s</code>.</li> </ul> 5. Longest Palindromic Substring - Python Solution<pre><code># DP - Interval\ndef longestPalindromeDP(s: str) -&gt; str:\n    n = len(s)\n    if n &lt;= 1:\n        return s\n\n    start, maxLen = 0, 1\n\n    # Init\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for j in range(1, n):\n        for i in range(j):\n            if s[i] == s[j]:\n                if j - i &lt;= 2:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1]\n\n                if dp[i][j] and j - i + 1 &gt; maxLen:\n                    maxLen = j - i + 1\n                    start = i\n\n    return s[start : start + maxLen]\n\n\n# Expand Around Center\ndef longestPalindromeCenter(s: str) -&gt; str:\n    def expand_around_center(left, right):\n        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n\n    if len(s) &lt;= 1:\n        return s\n\n    start, end = 0, 0\n    for i in range(len(s)):\n        len1 = expand_around_center(i, i)  # odd\n        len2 = expand_around_center(i, i + 1)  # even\n\n        maxLen = max(len1, len2)\n        if maxLen &gt; end - start:\n            start = i - (maxLen - 1) // 2\n            end = i + maxLen // 2\n\n    return s[start : end + 1]\n\n\ns = \"babad\"\nprint(longestPalindromeDP(s))  # \"bab\"\nprint(longestPalindromeCenter(s))  # \"aba\"\n</code></pre>"},{"location":"content/blind75/1d_dynamic_programming/#647-palindromic-substrings","title":"647. Palindromic Substrings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string, dynamic programming</p> </li> <li>Return the number of palindromic substrings in <code>s</code>.</li> <li>Bottom-up DP table</li> </ul> dp a b b a e a 1 0 0 1 0 b 0 1 1 0 0 b 0 0 1 0 0 a 0 0 0 1 0 e 0 0 0 0 1 647. Palindromic Substrings - Python Solution<pre><code>def countSubstrings(s: str) -&gt; int:\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    res = 0\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i, n):\n            if s[i] == s[j]:\n                if j - i &lt;= 1:\n                    dp[i][j] = 1\n                    res += 1\n                elif dp[i + 1][j - 1]:\n                    dp[i][j] = 1\n                    res += 1\n\n    return res\n\n\nprint(countSubstrings(\"abbae\"))  # 7\n</code></pre>"},{"location":"content/blind75/1d_dynamic_programming/#91-decode-ways","title":"91. Decode Ways","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming 91. Decode Ways - Python Solution<pre><code># DP\ndef numDecodingsDP(s: str) -&gt; int:\n    if not s or s[0] == \"0\":\n        return 0\n\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for i in range(1, n + 1):\n        # Check single digit decode\n        if s[i - 1] != \"0\":\n            dp[i] += dp[i - 1]\n\n        # Check two digit decode\n        if i &gt; 1 and \"10\" &lt;= s[i - 2 : i] &lt;= \"26\":\n            dp[i] += dp[i - 2]\n\n    return dp[n]\n\n\n# DFS\ndef numDecodingsDFS(s: str) -&gt; int:\n    memo = {}\n\n    def dfs(i):\n        if i == len(s):\n            return 1\n\n        if s[i] == \"0\":\n            return 0\n\n        if i in memo:\n            return memo[i]\n\n        # Single digit decode\n        ways = dfs(i + 1)\n\n        # Two digits decode\n        if i + 1 &lt; len(s) and \"10\" &lt;= s[i : i + 2] &lt;= \"26\":\n            ways += dfs(i + 2)\n\n        memo[i] = ways\n\n        return ways\n\n    return dfs(0)\n\n\ns = \"226\"\nprint(numDecodingsDP(s))  # 3\nprint(numDecodingsDFS(s))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/1d_dynamic_programming/#322-coin-change","title":"322. Coin Change","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, breadth first search 322. Coin Change - Python Solution<pre><code>from typing import List\n\n\ndef coinChange(coins: List[int], amount: int) -&gt; int:\n    dp = [float(\"inf\") for _ in range(amount + 1)]\n\n    dp[0] = 0\n\n    for i in range(1, amount + 1):\n        for c in coins:\n            if i - c &gt;= 0:\n                dp[i] = min(dp[i], 1 + dp[i - c])\n\n    return dp[amount] if dp[amount] != float(\"inf\") else -1\n\n\ncoins = [1, 2, 5]\namount = 11\nprint(coinChange(coins, amount))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/1d_dynamic_programming/#152-maximum-product-subarray","title":"152. Maximum Product Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming 152. Maximum Product Subarray - Python Solution<pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxProduct(nums: List[int]) -&gt; int:\n    n = len(nums)\n    dp_max = [0 for _ in range(n)]\n    dp_min = [0 for _ in range(n)]\n\n    dp_max[0] = nums[0]\n    dp_min[0] = nums[0]\n    max_product = nums[0]\n\n    for i in range(1, n):\n        dp_max[i] = max(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n        dp_min[i] = min(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n\n        max_product = max(max_product, dp_max[i])\n\n    return max_product\n\n\nnums = [2, 3, -2, 4]\nprint(maxProduct(nums))  # 6\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/1d_dynamic_programming/#139-word-break","title":"139. Word Break","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, dynamic programming, trie, memoization 139. Word Break - Python Solution<pre><code>from typing import List\n\n\n# DP (Unbounded Knapsack)\ndef wordBreak(s: str, wordDict: List[str]) -&gt; bool:\n    n = len(s)\n    dp = [False for _ in range(n + 1)]\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for word in wordDict:\n            m = len(word)\n            if s[i - m : i] == word and dp[i - m]:\n                dp[i] = True\n    return dp[-1]\n\n\ns = \"leetcode\"\nwordDict = [\"leet\", \"code\"]\nprint(wordBreak(s, wordDict))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/1d_dynamic_programming/#300-longest-increasing-subsequence","title":"300. Longest Increasing Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, dynamic programming 300. Longest Increasing Subsequence - Python Solution<pre><code>from functools import cache\nfrom typing import List\n\n\n# DP - LIS\ndef lengthOfLISMemo(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return n\n\n    @cache\n    def dfs(i: int) -&gt; int:\n        res = 0\n        for j in range(i):\n            if nums[j] &lt; nums[i]:\n                res = max(res, dfs(j))\n        return res + 1\n\n    return max(dfs(i) for i in range(n))\n\n\n# DP - LIS\ndef lengthOfLISTable(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return n\n\n    dp = [1 for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i):\n            if nums[i] &gt; nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\n\nif __name__ == \"__main__\":\n    assert lengthOfLISMemo([10, 9, 2, 5, 3, 7, 101, 18]) == 4\n    assert lengthOfLISTable([10, 9, 2, 5, 3, 7, 101, 18]) == 4\n    assert lengthOfLISMemo([0, 1, 0, 3, 2, 3]) == 4\n    assert lengthOfLISTable([0, 1, 0, 3, 2, 3]) == 4\n    assert lengthOfLISMemo([7, 7, 7, 7]) == 1\n    assert lengthOfLISTable([7, 7, 7, 7]) == 1\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/2d_dynamic_programming/","title":"2D Dynamic Programming","text":""},{"location":"content/blind75/2d_dynamic_programming/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 62. Unique Paths (Medium)</li> <li> 1143. Longest Common Subsequence (Medium)</li> </ul>"},{"location":"content/blind75/2d_dynamic_programming/#62-unique-paths","title":"62. Unique Paths","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, combinatorics</p> </li> <li>Count the number of unique paths to reach the bottom-right corner of a <code>m x n</code> grid.</li> </ul> <p></p> 62. Unique Paths - Python Solution<pre><code># DP - 2D\ndef uniquePaths(m: int, n: int) -&gt; int:\n    if m == 1 or n == 1:\n        return 1\n\n    dp = [[1] * n for _ in range(m)]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]\n\n\nprint(uniquePaths(m=3, n=7))  # 28\n# [[1, 1, 1,  1,  1,  1,  1],\n#  [1, 2, 3,  4,  5,  6,  7],\n#  [1, 3, 6, 10, 15, 21, 28]]\n</code></pre> 62. Unique Paths - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint uniquePaths(int m, int n) {\n    vector dp(m, vector&lt;int&gt;(n, 1));\n\n    for (int i = 1; i &lt; m; i++) {\n        for (int j = 1; j &lt; n; j++) {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n\n    return dp[m - 1][n - 1];\n}\n\nint main() {\n    int m = 3, n = 7;\n    cout &lt;&lt; uniquePaths(m, n) &lt;&lt; endl;  // 28\n    return 0;\n}\n</code></pre>"},{"location":"content/blind75/2d_dynamic_programming/#1143-longest-common-subsequence","title":"1143. Longest Common Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming 1143. Longest Common Subsequence - Python Solution<pre><code>from functools import cache\n\n\n# DP - LCS\ndef longestCommonSubsequenceMemo(text1: str, text2: str) -&gt; int:\n    m, n = len(text1), len(text2)\n\n    @cache\n    def dfs(i: int, j: int) -&gt; int:\n        if i &lt; 0 or j &lt; 0:\n            return 0\n        if text1[i] == text2[j]:\n            return dfs(i - 1, j - 1) + 1\n        return max(dfs(i - 1, j), dfs(i, j - 1))\n\n    return dfs(m - 1, n - 1)\n\n\n# DP - LCS\ndef longestCommonSubsequenceTable(text1: str, text2: str) -&gt; int:\n    m, n = len(text1), len(text2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i - 1] == text2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    assert longestCommonSubsequenceMemo(\"abcde\", \"ace\") == 3\n    assert longestCommonSubsequenceTable(\"abcde\", \"ace\") == 3\n    assert longestCommonSubsequenceMemo(\"abc\", \"abc\") == 3\n    assert longestCommonSubsequenceTable(\"abc\", \"abc\") == 3\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/advanced_graphs/","title":"Advanced Graphs","text":""},{"location":"content/blind75/advanced_graphs/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 269. Alien Dictionary (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/blind75/advanced_graphs/#269-alien-dictionary","title":"269. Alien Dictionary","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, depth first search, breadth first search, graph, topological sort</p> </li> <li>Return the correct order of characters in the alien language.</li> </ul> 269. Alien Dictionary - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS - Kahn's algorithm (Topological Sort)\ndef alienOrderBFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    indegree = {c: 0 for word in words for c in word}\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                    indegree[w2[j]] += 1\n                break\n\n    q = deque([c for c in indegree if indegree[c] == 0])\n    result = []\n\n    while q:\n        char = q.popleft()\n        result.append(char)\n\n        for neighbor in graph[char]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n\n    return \"\".join(result) if len(result) == len(indegree) else \"\"\n\n\n# DFS - Topological Sort\ndef alienOrderDFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    visited = {}\n    result = []\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                break\n\n    def dfs(c):\n        if c in visited:\n            return visited[c]\n\n        visited[c] = False\n        for neighbor in graph[c]:\n            if not dfs(neighbor):\n                return False\n\n        visited[c] = True\n        result.append(c)\n        return True\n\n    for c in list(graph.keys()):\n        if not dfs(c):\n            return \"\"\n\n    return \"\".join(result[::-1])\n\n\nwords = [\"wrt\", \"wrf\", \"er\", \"ett\", \"rftt\"]\nprint(alienOrderBFS(words))  # wertf\nprint(alienOrderDFS(words))  # wertf\n</code></pre>"},{"location":"content/blind75/arrays_hashing/","title":"Arrays Hashing","text":""},{"location":"content/blind75/arrays_hashing/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 217. Contains Duplicate (Easy)</li> <li> 242. Valid Anagram (Easy)</li> <li> 1. Two Sum (Easy)</li> <li> 49. Group Anagrams (Medium)</li> <li> 347. Top K Frequent Elements (Medium)</li> <li> 271. Encode and Decode Strings (Medium) \ud83d\udc51</li> <li> 238. Product of Array Except Self (Medium)</li> <li> 128. Longest Consecutive Sequence (Medium)</li> </ul>"},{"location":"content/blind75/arrays_hashing/#217-contains-duplicate","title":"217. Contains Duplicate","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, sorting</p> </li> <li>Return True if the array contains any duplicates, otherwise return False.</li> </ul> 217. Contains Duplicate - Python Solution<pre><code>from typing import List\n\n\n# Brute Force\ndef containsDuplicateBF(nums: List[int]) -&gt; bool:\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] == nums[j]:\n                return True\n\n    return False\n\n\n# Sort\ndef containsDuplicateSort(nums: List[int]) -&gt; bool:\n    nums.sort()\n\n    for i in range(1, len(nums)):\n        if nums[i] == nums[i - 1]:\n            return True\n\n    return False\n\n\n# Set\ndef containsDuplicateSet(nums: List[int]) -&gt; bool:\n    seen = set()\n\n    for i in nums:\n        if i in seen:\n            return True\n        seen.add(i)\n\n    return False\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# | Brute Force |    O(n^2)       |    O(1)      |\n# |     Sort    |    O(n log n)   |    O(1)      |\n# |     Set     |    O(n)         |    O(n)      |\n# |-------------|-----------------|--------------|\n\nprint(containsDuplicateBF([1, 2, 3, 1]))  # True\nprint(containsDuplicateSort([1, 2, 3, 1]))  # True\nprint(containsDuplicateSet([1, 2, 3, 1]))  # True\n</code></pre>"},{"location":"content/blind75/arrays_hashing/#242-valid-anagram","title":"242. Valid Anagram","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, string, sorting</p> </li> <li>Return true if an input string is an anagram of another string.</li> <li>An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once, e.g., <code>listen</code> is an anagram of <code>silent</code>.</li> </ul> 242. Valid Anagram - Python Solution<pre><code>from collections import Counter\n\n\n# Hashmap\ndef isAnagramHash(s: str, t: str) -&gt; bool:\n    \"\"\"Return True if t is an anagram of s, False otherwise.\"\"\"\n    if len(s) != len(t):\n        return False\n\n    count = dict()\n\n    for i in s:\n        if i in count:\n            count[i] += 1\n        else:\n            count[i] = 1\n\n    for j in t:\n        if j in count:\n            count[j] -= 1\n        else:\n            return False\n\n    for count in count.values():\n        if count != 0:\n            return False\n\n    return True\n\n\n# Array\ndef isAnagramArray(s: str, t: str) -&gt; bool:\n    if len(s) != len(t):\n        return False\n\n    count = [0 for _ in range(26)]\n\n    for i in s:\n        count[ord(i) - ord(\"a\")] += 1\n\n    for j in t:\n        count[ord(j) - ord(\"a\")] -= 1\n\n    for i in count:\n        if i != 0:\n            return False\n\n    return True\n\n\n# Counter\ndef isAnagramCounter(s: str, t: str) -&gt; bool:\n    return Counter(s) == Counter(t)\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |   Hashmap   |       O(n)      |     O(1)     |\n# |    Array    |       O(n)      |     O(1)     |\n# |   Counter   |       O(n)      |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\ns = \"anagram\"\nt = \"nagaram\"\nprint(isAnagramHash(s, t))  # True\nprint(isAnagramArray(s, t))  # True\nprint(isAnagramCounter(s, t))  # True\n</code></pre>"},{"location":"content/blind75/arrays_hashing/#1-two-sum","title":"1. Two Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table</p> </li> <li>Return the indices of the two numbers such that they add up to a specific target.</li> <li>Approach: Use a hashmap to store the indices of the numbers.</li> <li>Time Complexity: O(n)</li> <li>Space Complexity: O(n)</li> </ul> 1. Two Sum - Python Solution<pre><code>from typing import List\n\n\ndef twoSum(nums: List[int], target: int) -&gt; List[int]:\n    hashmap = {}  # val: idx\n\n    for idx, val in enumerate(nums):\n        if (target - val) in hashmap:\n            return [hashmap[target - val], idx]\n\n        hashmap[val] = idx\n\n\nif __name__ == \"__main__\":\n    nums = [2, 7, 11, 15]\n    target = 9\n    assert twoSum(nums, target) == [0, 1]\n</code></pre> 1. Two Sum - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;nums, int target) {\n    unordered_map&lt;int, int&gt; hashmap;\n\n    for (size_t i = 0; i &lt; nums.size(); i++) {\n        int complement = target - nums[i];\n\n        if (hashmap.find(complement) != hashmap.end()) {\n            return {hashmap[complement], (int)i};\n        }\n        hashmap[nums[i]] = (int)i;\n    }\n\n    return {-1, -1};\n}\n\nint main() {\n    vector&lt;int&gt; nums = {2, 7, 11, 15};\n    int target = 9;\n    vector&lt;int&gt; result = twoSum(nums, target);\n    cout &lt;&lt; result[0] &lt;&lt; \", \" &lt;&lt; result[1] &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/blind75/arrays_hashing/#49-group-anagrams","title":"49. Group Anagrams","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, sorting 49. Group Anagrams - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash - List\ndef groupAnagrams(strs: List[str]) -&gt; List[List[str]]:\n    result = defaultdict(list)\n\n    for s in strs:\n        count = [0] * 26\n        for i in s:\n            count[ord(i) - ord(\"a\")] += 1\n\n        result[tuple(count)].append(s)\n\n    return list(result.values())\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Hash     |     O(n * k)    |     O(n)     |\n# |-------------|-----------------|--------------|\n\n\nstrs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\nprint(groupAnagrams(strs))\n# [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/arrays_hashing/#347-top-k-frequent-elements","title":"347. Top K Frequent Elements","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, divide and conquer, sorting, heap priority queue, bucket sort, counting, quickselect 347. Top K Frequent Elements - Python Solution<pre><code>import heapq\nfrom collections import Counter\nfrom typing import List\n\n\n# Heap + Counter\ndef topKFrequent(nums: List[int], k: int) -&gt; List[int]:\n    minHeap = []\n\n    for val, freq in Counter(nums).items():\n        if len(minHeap) &lt; k:\n            heapq.heappush(minHeap, (freq, val))\n        else:\n            heapq.heappushpop(minHeap, (freq, val))\n\n    return [i for _, i in minHeap]\n\n\n# Counter (Most Common)\ndef topKFrequentCounter(nums: List[int], k: int) -&gt; List[int]:\n    commons = Counter(nums).most_common(k)\n    return [i for i, _ in commons]\n\n\nnums = [1, 1, 1, 2, 2, 3]\nk = 2\nprint(topKFrequent(nums, k))  # [1, 2]\nprint(topKFrequentCounter(nums, k))  # [1, 2]\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/arrays_hashing/#271-encode-and-decode-strings","title":"271. Encode and Decode Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, design 271. Encode and Decode Strings - Python Solution<pre><code>from typing import List\n\n\nclass Codec:\n    def encode(self, strs: List[str]) -&gt; str:\n        \"\"\"Encodes a list of strings to a single string.\"\"\"\n        encoded = \"\"\n\n        for s in strs:\n            encoded += str(len(s)) + \"#\" + s\n\n        return encoded\n\n    def decode(self, s: str) -&gt; List[str]:\n        \"\"\"Decodes a single string to a list of strings.\"\"\"\n        decoded = []\n        i = 0\n\n        while i &lt; len(s):\n            j = i\n            while s[j] != \"#\":\n                j += 1\n\n            strLen = int(s[i:j])\n            decoded.append(s[j + 1 : j + 1 + strLen])\n            i = j + 1 + strLen\n\n        return decoded\n\n\n# |-------------|-------------|--------------|\n# |   Approach  |    Time     |    Space     |\n# |-------------|-------------|--------------|\n# | Two pointers|    O(n)     |     O(n)     |\n# |-------------|-------------|--------------|\n\n\ncodec = Codec()\nencoded = codec.encode([\"hello\", \"world\"])\nprint(encoded)  # \"5#hello5#world\"\ndecoded = codec.decode(encoded)\nprint(decoded)  # [\"hello\", \"world\"]\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/arrays_hashing/#238-product-of-array-except-self","title":"238. Product of Array Except Self","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, prefix sum</p> </li> <li>Classic Prefix Sum problem</li> <li>Return an array <code>output</code> such that <code>output[i]</code> is equal to the product of all the elements of <code>nums</code> except <code>nums[i]</code>.</li> </ul> Approach Time Space Prefix O(n) O(n) Prefix (Optimized) O(n) O(1) 238. Product of Array Except Self - Python Solution<pre><code>from typing import List\n\n\n# Prefix\ndef productExceptSelf(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    prefix = [1 for _ in range(n)]\n    suffix = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        prefix[i] = nums[i - 1] * prefix[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        suffix[i] = nums[i + 1] * suffix[i + 1]\n\n    result = [i * j for i, j in zip(prefix, suffix)]\n\n    return result\n\n\n# Prefix (Optimized)\ndef productExceptSelfOptimized(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    result = [1 for _ in range(n)]\n\n    prefix = 1\n    for i in range(n):\n        result[i] = prefix\n        prefix *= nums[i]\n\n    suffix = 1\n    for i in range(n - 1, -1, -1):\n        result[i] *= suffix\n        suffix *= nums[i]\n\n    return result\n\n\nprint(productExceptSelf([1, 2, 3, 4]))\n# [24, 12, 8, 6]\nprint(productExceptSelfOptimized([1, 2, 3, 4]))\n# [24, 12, 8, 6]\n</code></pre> 238. Product of Array Except Self - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\n// Prefix Sum\nclass Solution\n{\npublic:\n    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt; &amp;nums)\n    {\n        int n = nums.size();\n        vector&lt;int&gt; prefix(n, 1);\n        vector&lt;int&gt; suffix(n, 1);\n        vector&lt;int&gt; res(n, 1);\n\n        for (int i = 1; i &lt; n; i++)\n        {\n            prefix[i] = prefix[i - 1] * nums[i - 1];\n        }\n\n        for (int i = n - 2; i &gt;= 0; i--)\n        {\n            suffix[i] = suffix[i + 1] * nums[i + 1];\n        }\n\n        for (int i = 0; i &lt; n; i++)\n        {\n            res[i] = prefix[i] * suffix[i];\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    vector&lt;int&gt; nums = {1, 2, 3, 4};\n    Solution obj;\n    vector&lt;int&gt; result = obj.productExceptSelf(nums);\n\n    for (int i = 0; i &lt; result.size(); i++)\n    {\n        cout &lt;&lt; result[i] &lt;&lt; \"\\n\";\n    }\n    cout &lt;&lt; endl;\n    // 24, 12, 8, 6\n    return 0;\n}\n</code></pre>"},{"location":"content/blind75/arrays_hashing/#128-longest-consecutive-sequence","title":"128. Longest Consecutive Sequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, union find 128. Longest Consecutive Sequence - Python Solution<pre><code>from typing import List\n\n\n# Set\ndef longestConsecutiveSet(nums: List[int]) -&gt; int:\n    num_set = set(nums)  # O(n)\n    longest = 0\n\n    for n in nums:\n        if (n - 1) not in num_set:  # left boundary\n            length = 1\n\n            while (n + length) in num_set:\n                length += 1\n\n            longest = max(longest, length)\n\n    return longest\n\n\n# Union Find\ndef longestConsecutiveUF(nums: List[int]) -&gt; int:\n    if not nums:\n        return 0\n\n    par = {num: num for num in nums}\n    rank = {num: 1 for num in nums}\n\n    def find(num):\n        p = par[num]\n        while p != par[p]:\n            p = par[p]\n        return p\n\n    def union(num1, num2):\n        p1, p2 = find(num1), find(num2)\n        if p1 == p2:\n            return\n\n        if rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n            rank[p2] += rank[p1]\n        else:\n            par[p2] = p1\n            rank[p1] += rank[p2]\n\n    for num in nums:\n        if num - 1 in par:\n            union(num, num - 1)\n\n    return max(rank.values())\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |  Set       |  O(N)  |  O(N)   |\n# | Union Find |  O(N)  |  O(N)   |\n# |------------|--------|---------|\n\n\nnums = [100, 4, 200, 1, 3, 2]\nprint(longestConsecutiveSet(nums))  # 4\nprint(longestConsecutiveUF(nums))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/backtracking/","title":"Backtracking","text":""},{"location":"content/blind75/backtracking/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 39. Combination Sum (Medium)</li> <li> 79. Word Search (Medium)</li> </ul>"},{"location":"content/blind75/backtracking/#39-combination-sum","title":"39. Combination Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking 39. Combination Sum - Python Solution<pre><code>from typing import List\n\n\ndef combinationSum(candidates: List[int], target: int) -&gt; List[List[int]]:\n    n = len(candidates)\n    res, path = [], []\n\n    def dfs(total, start):\n        if total &gt; target:\n            return\n        if total == target:\n            res.append(path.copy())\n            return\n\n        for i in range(start, n):\n            total += candidates[i]\n            path.append(candidates[i])\n            dfs(total, i)\n            total -= candidates[i]\n            path.pop()\n\n    dfs(0, 0)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(combinationSum([2, 3, 5], 8))\n    # [[2, 2, 2, 2], [2, 3, 3], [3, 5]]\n    print(combinationSum([2, 3, 6, 7], 7))\n    # [[2, 2, 3], [7]]\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/backtracking/#79-word-search","title":"79. Word Search","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, backtracking, depth first search, matrix 79. Word Search - Python Solution<pre><code>from typing import List\n\n\ndef exist(board: List[List[str]], word: str) -&gt; bool:\n    m, n = len(board), len(board[0])\n    path = set()\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n\n    def dfs(r, c, i):\n        if i == len(word):\n            return True\n\n        if (\n            r &lt; 0\n            or r &gt;= m\n            or c &lt; 0\n            or c &gt;= n\n            or board[r][c] != word[i]\n            or (r, c) in path\n        ):\n            return False\n\n        path.add((r, c))\n\n        for dr, dc in dirs:\n            if dfs(r + dr, c + dc, i + 1):\n                return True\n\n        path.remove((r, c))\n        return False\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, 0):\n                return True\n\n    return False\n\n\nboard = [\n    [\"A\", \"B\", \"C\", \"E\"],\n    [\"S\", \"F\", \"C\", \"S\"],\n    [\"A\", \"D\", \"E\", \"E\"],\n]\nword = \"ABCCED\"\nprint(exist(board, word))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/binary_search/","title":"Binary Search","text":""},{"location":"content/blind75/binary_search/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 153. Find Minimum in Rotated Sorted Array (Medium)</li> <li> 33. Search in Rotated Sorted Array (Medium)</li> </ul>"},{"location":"content/blind75/binary_search/#153-find-minimum-in-rotated-sorted-array","title":"153. Find Minimum in Rotated Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search 153. Find Minimum in Rotated Sorted Array - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef findMin(nums: List[int]) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt; right:\n        mid = left + (right - left) // 2\n        if nums[mid] &gt; nums[right]:\n            left = mid + 1\n        else:\n            right = mid\n\n    return nums[right]\n\n\nnums = [4, 5, 6, 7, 0, 1, 2]\nprint(findMin(nums))  # 0\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/binary_search/#33-search-in-rotated-sorted-array","title":"33. Search in Rotated Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search 33. Search in Rotated Sorted Array - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef search(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] == target:\n            return mid\n\n        if nums[left] &lt;= nums[mid]:\n            if nums[left] &lt;= target &lt; nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if nums[mid] &lt; target &lt;= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n    return -1\n\n\nnums = [4, 5, 6, 7, 0, 1, 2]\ntarget = 0\nprint(search(nums, target))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/bit_manipulation/","title":"Bit Manipulation","text":""},{"location":"content/blind75/bit_manipulation/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 191. Number of 1 Bits (Easy)</li> <li> 338. Counting Bits (Easy)</li> <li> 190. Reverse Bits (Easy)</li> <li> 268. Missing Number (Easy)</li> <li> 371. Sum of Two Integers (Medium)</li> </ul>"},{"location":"content/blind75/bit_manipulation/#191-number-of-1-bits","title":"191. Number of 1 Bits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: divide and conquer, bit manipulation 191. Number of 1 Bits - Python Solution<pre><code># Bit Manipulation\ndef hammingWeight1(n: int) -&gt; int:\n    res = 0\n\n    while n != 0:\n        n = n &amp; (n - 1)  # Unset the rightmost 1-bit\n        res += 1\n\n    return res\n\n\ndef hammingWeight2(n: int) -&gt; int:\n    return bin(n).count(\"1\")\n\n\ndef hammingWeight3(n: int) -&gt; int:\n    def decimalToBinary(n: int) -&gt; str:\n        if n == 0:\n            return \"0\"\n\n        binary = \"\"\n        while n &gt; 0:\n            binary = str(n % 2) + binary\n            n //= 2\n\n        return binary\n\n    binary = decimalToBinary(n)\n\n    return binary.count(\"1\")\n\n\nn = 11\nprint(hammingWeight1(n))  # 3\nprint(hammingWeight2(n))  # 3\n\nn = 47\nprint(bin(n))\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/bit_manipulation/#338-counting-bits","title":"338. Counting Bits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: dynamic programming, bit manipulation 338. Counting Bits - Python Solution<pre><code>from typing import List\n\n\n# Bit Manipulation\ndef countBits(n: int) -&gt; List[int]:\n    bits = [0 for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        bits[i] = bits[i &gt;&gt; 1] + (i &amp; 1)\n\n    return bits\n\n\nn = 5\nprint(countBits(n))  # [0, 1, 1, 2, 1, 2]\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/bit_manipulation/#190-reverse-bits","title":"190. Reverse Bits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: divide and conquer, bit manipulation 190. Reverse Bits - Python Solution<pre><code># Bit Manipulation\ndef reverseBits(n: int) -&gt; int:\n    res = 0\n\n    for i in range(32):\n        res = (res &lt;&lt; 1) | (n &amp; 1)\n        n &gt;&gt;= 1\n\n    return res\n\n\nn = 0b00000010100101000001111010011100\nprint(reverseBits(n))  # 964176192\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/bit_manipulation/#268-missing-number","title":"268. Missing Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, math, binary search, bit manipulation, sorting 268. Missing Number - Python Solution<pre><code>from typing import List\n\n\n# Math\ndef missingNumberMath(nums: List[int]) -&gt; int:\n    n = len(nums)\n    return (n * (n + 1)) // 2 - sum(nums)\n\n\n# Bit Manipulation (XOR)\ndef missingNumberXOR(nums: List[int]) -&gt; int:\n    n = len(nums)\n\n    for i, num in enumerate(nums):\n        n ^= i ^ num\n\n    return n\n\n\nnums = [3, 0, 1]\nprint(missingNumberMath(nums))  # 2\nprint(missingNumberXOR(nums))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/bit_manipulation/#371-sum-of-two-integers","title":"371. Sum of Two Integers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, bit manipulation 371. Sum of Two Integers - Python Solution<pre><code># Bit Manipulation\ndef getSum(a: int, b: int) -&gt; int:\n    MASK = 0xFFFFFFFF\n    MAX_INT = 0x7FFFFFFF\n\n    while b != 0:\n        temp = (a ^ b) &amp; MASK\n        b = ((a &amp; b) &lt;&lt; 1) &amp; MASK\n        a = temp\n\n    return a if a &lt;= MAX_INT else ~(a ^ MASK)\n\n\nprint(getSum(1, 2))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/graphs/","title":"Graphs","text":""},{"location":"content/blind75/graphs/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 200. Number of Islands (Medium)</li> <li> 133. Clone Graph (Medium)</li> <li> 417. Pacific Atlantic Water Flow (Medium)</li> <li> 207. Course Schedule (Medium)</li> <li> 261. Graph Valid Tree (Medium) \ud83d\udc51</li> <li> 323. Number of Connected Components in an Undirected Graph (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/blind75/graphs/#200-number-of-islands","title":"200. Number of Islands","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix</p> </li> <li>Count the number of islands in a 2D grid.</li> <li>Method 1: DFS</li> <li> <p>Method 2: BFS (use a queue to traverse the grid)</p> </li> <li> <p>How to keep track of visited cells?</p> <ol> <li>Mark the visited cell as <code>0</code> (or any other value) to avoid revisiting it.</li> <li>Use a set to store the visited cells.</li> </ol> </li> <li> <p>Steps:</p> <ol> <li>Init: variables</li> <li>DFS/BFS: starting from the cell with <code>1</code>, turn all the connected <code>1</code>s to <code>0</code>.</li> <li>Traverse the grid, and if the cell is <code>1</code>, increment the count and call DFS/BFS.</li> </ol> </li> </ul> <p></p> 200. Number of Islands - Python Solution<pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef numIslandsDFS(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    res = 0\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] != \"1\":\n            return\n\n        grid[r][c] = \"2\"\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                dfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Set\ndef numIslandsBFS1(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == \"0\"\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\" and (r, c) not in visited:\n                visited.add((r, c))\n                bfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = dr + row, dc + col\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] != \"1\"\n                ):\n                    continue\n                grid[nr][nc] = \"2\"\n                q.append((nr, nc))\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == \"1\":\n                grid[i][j] = \"2\"\n                bfs(i, j)\n                res += 1\n\n    return res\n\n\ngrid = [\n    [\"1\", \"1\", \"1\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"0\", \"0\", \"0\", \"0\", \"0\"],\n]\n\nprint(numIslandsDFS(deepcopy(grid)))  # 1\nprint(numIslandsBFS1(deepcopy(grid)))  # 1\nprint(numIslandsBFS2(deepcopy(grid)))  # 1\n</code></pre> 200. Number of Islands - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\nprivate:\n    void dfs(vector&lt;vector&lt;char&gt;&gt; &amp;grid, int r, int c)\n    {\n        int row = grid.size();\n        int col = grid[0].size();\n\n        if (r &lt; 0 || r &gt;= row || c &lt; 0 || c &gt;= col || grid[r][c] != '1')\n        {\n            return;\n        }\n        grid[r][c] = '0';\n\n        dfs(grid, r - 1, c);\n        dfs(grid, r + 1, c);\n        dfs(grid, r, c - 1);\n        dfs(grid, r, c + 1);\n    }\n\npublic:\n    int numIslands(vector&lt;vector&lt;char&gt;&gt; &amp;grid)\n    {\n        int m = grid.size(), n = grid[0].size();\n        int res = 0;\n        for (int i = 0; i &lt; m; i++)\n        {\n            for (int j = 0; j &lt; n; j++)\n            {\n                if (grid[i][j] == '1')\n                {\n                    res++;\n                    dfs(grid, i, j);\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    Solution s;\n    vector&lt;vector&lt;char&gt;&gt; grid = {\n        {'1', '1', '0', '0', '0'},\n        {'1', '1', '0', '0', '0'},\n        {'0', '0', '1', '0', '0'},\n        {'0', '0', '0', '1', '1'}};\n    cout &lt;&lt; s.numIslands(grid) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/blind75/graphs/#133-clone-graph","title":"133. Clone Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, depth first search, breadth first search, graph 133. Clone Graph - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\n\nclass Node:\n    def __init__(self, val=0, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\n\n# 1. DFS\ndef cloneGraphDFS(node: Optional[\"Node\"]) -&gt; Optional[\"Node\"]:\n    if not node:\n        return None\n\n    cloned = {}  # {old: new}\n\n    def dfs(node):\n        if node in cloned:\n            return cloned[node]\n\n        new = Node(node.val)\n        cloned[node] = new\n\n        for neighbor in node.neighbors:\n            new.neighbors.append(dfs(neighbor))\n\n        return new\n\n    return dfs(node)\n\n\n# 2. BFS\ndef cloneGraphBFS(node: Optional[\"Node\"]) -&gt; Optional[\"Node\"]:\n    if not node:\n        return None\n\n    cloned = {node: Node(node.val)}\n    q = deque([node])\n\n    while q:\n        cur = q.popleft()\n\n        for neighbor in cur.neighbors:\n            if neighbor not in cloned:\n                cloned[neighbor] = Node(neighbor.val)\n                q.append(neighbor)\n\n            cloned[cur].neighbors.append(cloned[neighbor])\n\n    return cloned[node]\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/graphs/#417-pacific-atlantic-water-flow","title":"417. Pacific Atlantic Water Flow","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, matrix 417. Pacific Atlantic Water Flow - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef pacificAtlanticDFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(r, c, visited, prev_height):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or heights[r][c] &lt; prev_height\n            or (r, c) in visited\n        ):\n            return None\n\n        visited.add((r, c))\n        height = heights[r][c]\n        for dr, dc in directions:\n            dfs(dr + r, dc + c, visited, height)\n\n    for c in range(n):\n        dfs(0, c, pac, heights[0][c])\n        dfs(m - 1, c, atl, heights[m - 1][c])\n\n    for r in range(m):\n        dfs(r, 0, pac, heights[r][0])\n        dfs(r, n - 1, atl, heights[r][n - 1])\n\n    return list(pac &amp; atl)\n\n\n# BFS\ndef pacificAtlanticBFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def bfs(r, c, visited):\n        q = deque([(r, c)])\n        visited.add((r, c))\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr in range(m)\n                    and nc in range(n)\n                    and heights[row][col] &lt;= heights[nr][nc]\n                    and (nr, nc) not in visited\n                ):\n                    q.append((nr, nc))\n                    visited.add((nr, nc))\n\n    for c in range(n):\n        bfs(0, c, pac)  # top\n        bfs(m - 1, c, atl)  # bottom\n\n    for r in range(m):\n        bfs(r, 0, pac)  # left\n        bfs(r, n - 1, atl)  # right\n\n    return list(pac &amp; atl)\n\n\nheights = [\n    [1, 2, 2, 3, 5],\n    [3, 2, 3, 4, 4],\n    [2, 4, 5, 3, 1],\n    [6, 7, 1, 4, 5],\n    [5, 1, 1, 2, 4],\n]\nprint(pacificAtlanticDFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\nprint(pacificAtlanticBFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/graphs/#207-course-schedule","title":"207. Course Schedule","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort</p> </li> <li>Return true if it is possible to finish all courses, otherwise return false.</li> <li>Dependency relationships imply the topological sort algorithm.</li> <li>Cycle detection</li> <li>Topological Sort</li> <li>DAG (Directed Acyclic Graph)</li> <li>Time complexity: O(V+E)</li> <li>Space complexity: O(V+E)</li> <li>Prerequisites: Indegree (Look at the problem 1557. Minimum Number of Vertices to Reach All Nodes)<ul> <li>Indegree: Number of incoming edges to a vertex</li> </ul> </li> <li>Applications: task scheduling, course scheduling, build systems, dependency resolution, compiler optimization, etc.</li> </ul> <p></p> <p></p> <p>Course to prerequisites mapping</p> <pre><code>flowchart LR\n    0((0)) --&gt; 1((1))\n    0((0)) --&gt; 2((2))\n    1((1)) --&gt; 3((3))\n    3((3)) --&gt; 4((4))\n    1((1)) --&gt; 4((4))</code></pre> <p>Prerequisites to course mapping</p> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    2((2)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))\n    4((4)) --&gt; 3((3))\n    4((4)) --&gt; 1((1))</code></pre> course 0 0 1 1 3 prerequisite 1 2 3 4 4 index 0 1 2 3 4 in-degree 0 0 0 0 0 <p>Initialize</p> <ul> <li>graph</li> </ul> prerequisite 1 2 3 4 course <code>[0]</code> <code>[0]</code> <code>[1]</code> <code>[1, 3]</code> <ul> <li>in-degree</li> </ul> 0 1 2 3 4 in-degree 2 2 0 1 0 <ul> <li>queue: <code>[2, 4]</code></li> <li>pop <code>2</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))\n    4((4)) --&gt; 3((3))\n    4((4)) --&gt; 1((1))</code></pre> 0 1 2 3 4 in-degree 1 2 0 1 0 <ul> <li>queue: <code>[4]</code></li> <li>pop <code>4</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))</code></pre> 0 1 2 3 4 in-degree 1 1 0 0 0 <ul> <li>queue: <code>[3]</code></li> <li>pop <code>3</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))</code></pre> 0 1 2 3 4 in-degree 1 0 0 0 0 <ul> <li>queue: <code>[1]</code></li> <li>pop <code>1</code> from the queue</li> </ul> <pre><code>flowchart LR\n    0((0))</code></pre> 0 1 2 3 4 in-degree 0 0 0 0 0 <ul> <li>queue: <code>[0]</code></li> <li>pop <code>0</code> from the queue</li> <li>All courses are taken. Return <code>True</code>.</li> </ul> 207. Course Schedule - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS (Kahn's Algorithm)\ndef canFinishBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    count = 0\n\n    while q:\n        crs = q.popleft()\n        count += 1\n\n        for nxt in graph[crs]:\n            indegree[nxt] -= 1\n\n            if indegree[nxt] == 0:\n                q.append(nxt)\n\n    return count == numCourses\n\n\n# DFS + Set\ndef canFinishDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for crs, pre in prerequisites:\n        graph[crs].append(pre)\n\n    visiting = set()\n\n    def dfs(crs):\n        if crs in visiting:  # cycle detected\n            return False\n        if graph[crs] == []:\n            return True\n\n        visiting.add(crs)\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        visiting.remove(crs)\n        graph[crs] = []\n\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\n# DFS + List\ndef canFinishDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for pre, crs in prerequisites:\n        graph[crs].append(pre)\n\n    # 0: init, 1: visiting, 2: visited\n    status = [0] * numCourses\n\n    def dfs(crs):\n        if status[crs] == 1:  # cycle detected\n            return False\n        if status[crs] == 2:\n            return True\n\n        status[crs] = 1\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        status[crs] = 2\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(canFinishBFS(5, prerequisites))  # True\nprint(canFinishDFS1(5, prerequisites))  # True\nprint(canFinishDFS2(5, prerequisites))  # True\n</code></pre> 207. Course Schedule - C++ Solution<pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    // BFS\n    bool canFinishBFS(int numCourses, vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        vector&lt;int&gt; indegree(numCourses, 0);\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n            indegree[pre[0]]++;\n        }\n\n        queue&lt;int&gt; q;\n        for (int i = 0; i &lt; numCourses; i++) {\n            if (indegree[i] == 0) {\n                q.push(i);\n            }\n        }\n\n        int cnt = 0;\n        while (!q.empty()) {\n            int cur = q.front();\n            q.pop();\n            cnt++;\n\n            for (int nxt : graph[cur]) {\n                indegree[nxt]--;\n                if (indegree[nxt] == 0) {\n                    q.push(nxt);\n                }\n            }\n        }\n        return cnt == numCourses;\n    }\n\n    // DFS\n    bool canFinishDFS(int numCourses, vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n        }\n        // 0: not visited, 1: visiting, 2: visited\n        vector&lt;int&gt; state(numCourses, 0);\n\n        function&lt;bool(int)&gt; dfs = [&amp;](int pre) -&gt; bool {\n            state[pre] = 1;  // visiting\n            for (int crs : graph[pre]) {\n                if (state[crs] == 1 || (state[crs] == 0 &amp;&amp; dfs(crs))) {\n                    return true;\n                }\n            }\n            state[pre] = 2;  // visited\n            return false;\n        };\n\n        for (int i = 0; i &lt; numCourses; i++) {\n            if (state[i] == 0 &amp;&amp; dfs(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution sol;\n    vector&lt;vector&lt;int&gt;&gt; prerequisites = {{1, 0}, {2, 1}, {3, 2}, {4, 3},\n                                         {5, 4}, {6, 5}, {7, 6}, {8, 7},\n                                         {9, 8}, {10, 9}};\n    int numCourses = 11;\n    cout &lt;&lt; sol.canFinishBFS(numCourses, prerequisites) &lt;&lt; endl;\n    cout &lt;&lt; sol.canFinishDFS(numCourses, prerequisites) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/blind75/graphs/#261-graph-valid-tree","title":"261. Graph Valid Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph 261. Graph Valid Tree - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Graph\ndef validTree(n: int, edges: List[List[int]]) -&gt; bool:\n    if n == 0:\n        return False\n    if len(edges) != n - 1:\n        return False\n\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = set()\n\n    def dfs(node, parent):\n        if node in visited:\n            return False\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor != parent and not dfs(neighbor, node):\n                return False\n        return True\n\n    return dfs(0, -1) and len(visited) == n\n\n\nprint(validTree(5, [[0, 1], [0, 2], [0, 3], [1, 4]]))  # True\nprint(validTree(5, [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]))  # False\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/graphs/#323-number-of-connected-components-in-an-undirected-graph","title":"323. Number of Connected Components in an Undirected Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph 323. Number of Connected Components in an Undirected Graph - Python Solution<pre><code>from typing import List\n\n\n# Union Find\ndef countComponents(n: int, edges: List[List[int]]) -&gt; int:\n    uf = UnionFind(n)\n    count = n\n\n    for u, v in edges:\n        count -= uf.union(u, v)\n\n    return count\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(n)}\n        self.rank = {i: 1 for i in range(n)}\n\n    def find(self, n):\n        p = self.par[n]\n        while self.par[p] != p:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return 0\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.par[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.par[p1] = p2\n        else:\n            self.par[p2] = p1\n            self.rank[p1] += 1\n\n        return 1\n\n\nprint(countComponents(5, [[0, 1], [1, 2], [3, 4]]))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/greedy/","title":"Greedy","text":""},{"location":"content/blind75/greedy/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 53. Maximum Subarray (Medium)</li> <li> 55. Jump Game (Medium)</li> </ul>"},{"location":"content/blind75/greedy/#53-maximum-subarray","title":"53. Maximum Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, divide and conquer, dynamic programming 53. Maximum Subarray - Python Solution<pre><code>from typing import List\n\n\n# DP Kadane\ndef maxSubArrayDP(nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n\n    dp[0] = nums[0]\n    maxSum = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(\n            dp[i - 1] + nums[i],  # continue the previous subarray\n            nums[i],  # start a new subarray\n        )\n        maxSum = max(maxSum, dp[i])\n\n    return maxSum\n\n\n# Greedy\ndef maxSubArrayGreedy(nums: List[int]) -&gt; int:\n    max_sum = nums[0]\n    cur_sum = 0\n\n    for num in nums:\n        cur_sum = max(cur_sum + num, num)\n        max_sum = max(max_sum, cur_sum)\n\n    return max_sum\n\n\n# Prefix Sum\ndef maxSubArrayPrefixSum(nums: List[int]) -&gt; int:\n    prefix_sum = 0\n    prefix_sum_min = 0\n    res = float(\"-inf\")\n\n    for num in nums:\n        prefix_sum += num\n        res = max(res, prefix_sum - prefix_sum_min)\n        prefix_sum_min = min(prefix_sum_min, prefix_sum)\n\n    return res\n\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArrayDP(nums))  # 6\nprint(maxSubArrayGreedy(nums))  # 6\nprint(maxSubArrayPrefixSum(nums))  # 6\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/greedy/#55-jump-game","title":"55. Jump Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> <li>Return <code>True</code> if you can reach the last index, otherwise <code>False</code>.</li> </ul> 55. Jump Game - Python Solution<pre><code>from typing import List\n\n\n# Greedy - Interval\ndef canJump(nums: List[int]) -&gt; bool:\n    n = len(nums)\n    reach = 0\n    i = 0\n\n    while reach &gt;= i:\n        if reach &gt;= n - 1:\n            return True\n        reach = max(reach, i + nums[i])\n        i += 1\n\n    return False\n\n\nif __name__ == \"__main__\":\n    assert canJump([2, 3, 1, 1, 4]) is True\n    assert canJump([3, 2, 1, 0, 4]) is False\n</code></pre> 55. Jump Game - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool canJump(vector&lt;int&gt;&amp; nums) {\n        int canReach = 0;\n        int n = nums.size();\n\n        for (int i = 0; i &lt; n; i++) {\n            if (i &gt; canReach) return false;\n            canReach = max(canReach, i + nums[i]);\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution obj;\n    vector&lt;int&gt; nums = {2, 3, 1, 1, 4};\n    cout &lt;&lt; obj.canJump(nums) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/blind75/heap/","title":"Heap","text":""},{"location":"content/blind75/heap/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 295. Find Median from Data Stream (Hard)</li> </ul>"},{"location":"content/blind75/heap/#295-find-median-from-data-stream","title":"295. Find Median from Data Stream","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: two pointers, design, sorting, heap priority queue, data stream 295. Find Median from Data Stream - Python Solution<pre><code>from heapq import heappop, heappush\n\n\n# Dual Heaps\nclass MedianFinder:\n\n    def __init__(self):\n        self.minHeap = []\n        self.maxHeap = []\n        self.min_size = 0\n        self.max_size = 0\n\n    def addNum(self, num: int) -&gt; None:\n        heappush(self.maxHeap, -num)\n        heappush(self.minHeap, -heappop(self.maxHeap))\n        self.min_size += 1\n\n        if self.min_size &gt; self.max_size:\n            heappush(self.maxHeap, -heappop(self.minHeap))\n            self.min_size -= 1\n            self.max_size += 1\n\n    def findMedian(self) -&gt; float:\n        if self.min_size == self.max_size:\n            return (-self.maxHeap[0] + self.minHeap[0]) / 2.0\n        return -self.maxHeap[0]\n\n\nobj = MedianFinder()\nobj.addNum(1)\nobj.addNum(2)\nassert obj.findMedian() == 1.5\nobj.addNum(3)\nassert obj.findMedian() == 2\nobj.addNum(4)\nassert obj.findMedian() == 2.5\nobj.addNum(5)\nassert obj.findMedian() == 3\nprint(\"All Passed.\")\n</code></pre></p> </li> </ul> 295. Find Median from Data Stream - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass MedianFinder {\n   private:\n    priority_queue&lt;int&gt; maxHeap;\n    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;\n    int max_size = 0;\n    int min_size = 0;\n\n   public:\n    MedianFinder() {}\n\n    void addNum(int num) {\n        if (min_size == max_size) {\n            minHeap.push(num);\n            maxHeap.push(minHeap.top());\n            minHeap.pop();\n            max_size++;\n        } else {\n            maxHeap.push(num);\n            minHeap.push(maxHeap.top());\n            maxHeap.pop();\n            min_size++;\n        }\n    }\n\n    double findMedian() {\n        if (min_size == max_size) {\n            return (maxHeap.top() + minHeap.top()) / 2.0;\n        } else {\n            return (double)maxHeap.top();\n        }\n    }\n};\n\nint main() {\n    MedianFinder* obj = new MedianFinder();\n    obj-&gt;addNum(1);\n    obj-&gt;addNum(2);\n    cout &lt;&lt; obj-&gt;findMedian() &lt;&lt; endl;  // 1.5\n    obj-&gt;addNum(3);\n    cout &lt;&lt; obj-&gt;findMedian() &lt;&lt; endl;  // 2\n    return 0;\n}\n</code></pre>"},{"location":"content/blind75/intervals/","title":"Intervals","text":""},{"location":"content/blind75/intervals/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 57. Insert Interval (Medium)</li> <li> 56. Merge Intervals (Medium)</li> <li> 252. Meeting Rooms (Easy) \ud83d\udc51</li> <li> 253. Meeting Rooms II (Medium) \ud83d\udc51</li> <li> 254. Factor Combinations (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/blind75/intervals/#57-insert-interval","title":"57. Insert Interval","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array 57. Insert Interval - Python Solution<pre><code>from typing import List\n\n\n# Interval\ndef insert(\n    intervals: List[List[int]], newInterval: List[int]\n) -&gt; List[List[int]]:\n    n = len(intervals)\n\n    if n == 0:\n        return [newInterval]\n\n    if newInterval[1] &lt; intervals[0][0]:\n        return [newInterval] + intervals\n\n    if newInterval[0] &gt; intervals[-1][1]:\n        return intervals + [newInterval]\n\n    i = 0\n    result = []\n\n    while i &lt; n and intervals[i][1] &lt; newInterval[0]:\n        result.append(intervals[i])\n        i += 1\n\n    while i &lt; n and intervals[i][0] &lt;= newInterval[1]:\n        newInterval[0] = min(newInterval[0], intervals[i][0])\n        newInterval[1] = max(newInterval[1], intervals[i][1])\n        i += 1\n\n    result.append(newInterval)\n\n    while i &lt; n:\n        result.append(intervals[i])\n        i += 1\n\n    return result\n\n\nintervals = [[1, 3], [6, 9]]\nnewInterval = [2, 5]\nprint(insert(intervals, newInterval))  # [[1, 5], [6, 9]]\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/intervals/#56-merge-intervals","title":"56. Merge Intervals","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sorting</p> </li> <li>Merge all overlapping intervals.</li> </ul> 56. Merge Intervals - Python Solution<pre><code>from typing import List\n\n\n# Intervals\ndef merge(intervals: List[List[int]]) -&gt; List[List[int]]:\n    n = len(intervals)\n    if n &lt;= 1:\n        return intervals\n\n    intervals.sort(key=lambda x: x[0])\n    res = [intervals[0]]\n\n    for i in range(1, n):\n        if intervals[i][0] &lt;= res[-1][1]:\n            res[-1][1] = max(res[-1][1], intervals[i][1])\n        else:\n            res.append(intervals[i])\n\n    return res\n\n\nprint(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))\n# [[1, 6], [8, 10], [15, 18]]\n</code></pre> 56. Merge Intervals - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// Interval\nvector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {\n    sort(intervals.begin(), intervals.end());\n    vector&lt;vector&lt;int&gt;&gt; res;\n\n    for (auto&amp; range : intervals) {\n        if (!res.empty() &amp;&amp; range[0] &lt;= res.back()[1]) {\n            res.back()[1] = max(res.back()[1], range[1]);\n        } else {\n            res.emplace_back(range);\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;vector&lt;int&gt;&gt; intervals = {{1, 3}, {2, 6}, {8, 10}, {15, 18}};\n    vector&lt;vector&lt;int&gt;&gt; res = merge(intervals);\n    for (auto&amp; range : res) {\n        cout &lt;&lt; range[0] &lt;&lt; \", \" &lt;&lt; range[1] &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"content/blind75/intervals/#252-meeting-rooms","title":"252. Meeting Rooms","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, sorting 252. Meeting Rooms - Python Solution<pre><code>from typing import List\n\n\n# Interval\ndef canAttendMeetings(intervals: List[List[int]]) -&gt; bool:\n    intervals.sort(key=lambda x: x[0])\n    n = len(intervals)\n\n    if n &lt;= 1:\n        return True\n\n    for i in range(1, n):\n        if intervals[i][0] &lt; intervals[i - 1][1]:\n            return False\n\n    return True\n\n\nif __name__ == \"__main__\":\n    intervals = [[0, 30], [5, 10], [15, 20]]\n    assert not canAttendMeetings(intervals)\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/intervals/#253-meeting-rooms-ii","title":"253. Meeting Rooms II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy, sorting, heap priority queue, prefix sum</p> </li> <li>Given an array of meeting time <code>intervals</code> where <code>intervals[i] = [start_i, end_i]</code>, return the minimum number of conference rooms required.</li> </ul> 253. Meeting Rooms II - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Heap\ndef minMeetingRooms(intervals: List[List[int]]) -&gt; int:\n    if not intervals:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n    minHeap = [intervals[0][1]]\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &gt;= minHeap[0]:\n            heapq.heappop(minHeap)\n        heapq.heappush(minHeap, intervals[i][1])\n\n    return len(minHeap)\n\n\nif __name__ == \"__main__\":\n    intervals = [[0, 30], [5, 10], [15, 20]]\n    assert minMeetingRooms(intervals) == 2\n</code></pre>"},{"location":"content/blind75/intervals/#254-factor-combinations","title":"254. Factor Combinations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: backtracking</p> </li> </ul>"},{"location":"content/blind75/linked_list/","title":"Linked List","text":""},{"location":"content/blind75/linked_list/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 206. Reverse Linked List (Easy)</li> <li> 21. Merge Two Sorted Lists (Easy)</li> <li> 143. Reorder List (Medium)</li> <li> 19. Remove Nth Node From End of List (Medium)</li> <li> 141. Linked List Cycle (Easy)</li> <li> 23. Merge k Sorted Lists (Hard)</li> </ul>"},{"location":"content/blind75/linked_list/#206-reverse-linked-list","title":"206. Reverse Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: linked list, recursion</p> </li> <li>Reverse a singly linked list.</li> </ul> <pre><code>graph LR\nA((1)) --&gt; B((2))\nB --&gt; C((3))\nC --&gt; D((4))\nD --&gt; E((5))</code></pre> <pre><code>graph RL\nE((5)) --&gt; D((4))\nD --&gt; C((3))\nC --&gt; B((2))\nB --&gt; A((1))</code></pre> 206. Reverse Linked List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Iterative\ndef reverseListIterative(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    cur = head\n    prev = None\n\n    while cur:\n        temp = cur.next\n        cur.next = prev\n\n        prev = cur\n        cur = temp\n\n    return prev\n\n\n# Recursive\ndef reverseListRecursive(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    def reverse(cur, prev):\n        if not cur:\n            return prev\n\n        temp = cur.next\n        cur.next = prev\n\n        return reverse(temp, cur)\n\n    return reverse(head, None)\n\n\nnums = [1, 2, 3, 4, 5]\nhead1 = ListNode.create(nums)\nprint(head1)\n# 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(reverseListIterative(head1))\n# 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1\nhead2 = ListNode.create(nums)\nprint(reverseListRecursive(head2))\n# 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1\n</code></pre>"},{"location":"content/blind75/linked_list/#21-merge-two-sorted-lists","title":"21. Merge Two Sorted Lists","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: linked list, recursion</p> </li> <li>Merge the two lists into one sorted list.</li> </ul> 21. Merge Two Sorted Lists - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef mergeTwoLists(\n    list1: Optional[ListNode], list2: Optional[ListNode]\n) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    while list1 and list2:\n        if list1.val &lt; list2.val:\n            cur.next = list1\n            list1 = list1.next\n        else:\n            cur.next = list2\n            list2 = list2.next\n        cur = cur.next\n\n    if list1:\n        cur.next = list1\n    elif list2:\n        cur.next = list2\n\n    return dummy.next\n\n\nlist1 = ListNode.create([1, 2, 4])\nlist2 = ListNode.create([1, 3, 4])\nprint(mergeTwoLists(list1, list2))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4\n</code></pre> 21. Merge Two Sorted Lists - C++ Solution<pre><code>struct ListNode {\n    int val;\n    ListNode* next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode* next) : val(x), next(next) {}\n};\n\nclass Solution {\n   public:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        ListNode dummy;\n        ListNode* cur = &amp;dummy;\n\n        while (list1 &amp;&amp; list2) {\n            if (list1-&gt;val &lt; list2-&gt;val) {\n                cur-&gt;next = list1;\n                list1 = list1-&gt;next;\n            } else {\n                cur-&gt;next = list2;\n                list2 = list2-&gt;next;\n            }\n            cur = cur-&gt;next;\n        }\n\n        cur-&gt;next = list1 ? list1 : list2;\n\n        return dummy.next;\n    }\n};\n</code></pre>"},{"location":"content/blind75/linked_list/#143-reorder-list","title":"143. Reorder List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, two pointers, stack, recursion 143. Reorder List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef reorderList(head: Optional[ListNode]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify head in-place instead.\n    \"\"\"\n    if not head or not head.next:\n        return\n\n    # Middle of the linked list\n    slow, fast = head, head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n    # Reverse the second half\n    pre, cur = None, slow\n    while cur:\n        temp = cur.next\n        cur.next = pre\n        pre = cur\n        cur = temp\n\n    # Merge two linked lists\n    first, second = head, pre\n    while second.next:\n        temp1, temp2 = first.next, second.next\n        first.next = second\n        second.next = temp1\n        first, second = temp1, temp2\n\n\nhead = ListNode.create([1, 2, 3, 4, 5, 6])\nprint(head)  # 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6\nreorderList(head)\nprint(head)  # 1 -&gt; 6 -&gt; 2 -&gt; 5 -&gt; 3 -&gt; 4\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/linked_list/#19-remove-nth-node-from-end-of-list","title":"19. Remove Nth Node From End of List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, two pointers</p> </li> <li>Given the <code>head</code> of a linked list, remove the <code>n-th</code> node from the end of the list and return its head.</li> </ul> 19. Remove Nth Node From End of List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef removeNthFromEnd(head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:\n    dummy = ListNode(0, head)\n    fast, slow = dummy, dummy\n\n    for _ in range(n):\n        fast = fast.next\n\n    while fast.next:\n        fast = fast.next\n        slow = slow.next\n\n    slow.next = slow.next.next\n\n    return dummy.next\n\n\nhead = [1, 2, 3, 4, 5]\nn = 2\nhead = ListNode.create(head)\nprint(head)  # 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(removeNthFromEnd(head, n))  # 1 -&gt; 2 -&gt; 3 -&gt; 5\n</code></pre>"},{"location":"content/blind75/linked_list/#141-linked-list-cycle","title":"141. Linked List Cycle","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, linked list, two pointers</p> </li> <li>Determine if a linked list has a cycle in it.</li> </ul> <pre><code>graph LR\n    A((3)) --&gt; B((2))\n    B --&gt; C((0))\n    C --&gt; D((4))</code></pre> <pre><code>graph LR\n    A((3)) --&gt; B((2))\n    B --&gt; C((0))\n    C --&gt; D((4))\n    D --&gt; B</code></pre> 141. Linked List Cycle - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\ndef hasCycle(head: Optional[ListNode]) -&gt; bool:\n    slow, fast = head, head\n\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n        if slow == fast:\n            return True\n\n    return False\n\n\nprint(hasCycle(ListNode.create([3, 2, 0, -4])))  # False\nprint(hasCycle(ListNode.create([3, 2, 0, -4], 1)))  # True\n</code></pre> 141. Linked List Cycle - C++ Solution<pre><code>#include &lt;iostream&gt;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nclass Solution {\n   public:\n    bool hasCycle(ListNode* head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while (fast &amp;&amp; fast-&gt;next) {\n            slow = slow-&gt;next;\n            fast = fast-&gt;next-&gt;next;\n\n            if (fast == slow) return true;\n        }\n        return false;\n    }\n};\n</code></pre>"},{"location":"content/blind75/linked_list/#23-merge-k-sorted-lists","title":"23. Merge k Sorted Lists","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: linked list, divide and conquer, heap priority queue, merge sort</p> </li> <li>Prerequisite: 21. Merge Two Sorted Lists</li> <li>Video explanation: 23. Merge K Sorted Lists - NeetCode</li> </ul> 23. Merge k Sorted Lists - Python Solution<pre><code>import copy\nimport heapq\nfrom typing import List, Optional\n\nfrom template import ListNode\n\n\n# Divide and Conquer\ndef mergeKListsDC(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    if not lists or len(lists) == 0:\n        return None\n\n    def mergeTwo(l1, l2):\n        dummy = ListNode()\n        cur = dummy\n\n        while l1 and l2:\n            if l1.val &lt; l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n\n            cur = cur.next\n\n        cur.next = l1 if l1 else l2\n\n        return dummy.next\n\n    while len(lists) &gt; 1:\n        merged = []\n\n        for i in range(0, len(lists), 2):\n            l1 = lists[i]\n            l2 = lists[i + 1] if i + 1 &lt; len(lists) else None\n            merged.append(mergeTwo(l1, l2))\n\n        lists = merged\n\n    return lists[0]\n\n\n# Heap - Merge k Sorted\ndef mergeKLists(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    minHeap = []  # (val, idx, node)\n\n    for idx, head in enumerate(lists):\n        if head:\n            heapq.heappush(minHeap, (head.val, idx, head))\n\n    while minHeap:\n        _, idx, node = heapq.heappop(minHeap)\n        cur.next = node\n        cur = cur.next\n\n        node = node.next\n        if node:\n            heapq.heappush(minHeap, (node.val, idx, node))\n\n    return dummy.next\n\n\nn1 = ListNode.create([1, 4, 5])\nn2 = ListNode.create([1, 3, 4])\nn3 = ListNode.create([2, 6])\nlists = [n1, n2, n3]\nlists1 = copy.deepcopy(lists)\nlists2 = copy.deepcopy(lists)\nprint(mergeKListsDC(lists1))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6\nprint(mergeKLists(lists2))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6\n</code></pre>"},{"location":"content/blind75/math_geometry/","title":"Math Geometry","text":""},{"location":"content/blind75/math_geometry/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 48. Rotate Image (Medium)</li> <li> 54. Spiral Matrix (Medium)</li> <li> 73. Set Matrix Zeroes (Medium)</li> </ul>"},{"location":"content/blind75/math_geometry/#48-rotate-image","title":"48. Rotate Image","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, matrix 48. Rotate Image - Python Solution<pre><code>from copy import deepcopy\nfrom typing import List\n\n\n# Math\ndef rotate1(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    n = len(matrix)\n\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n\n\ndef rotate2(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    n = len(matrix)\n    for i in range(n):\n        for j in range(i, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\n    for i in range(n):\n        matrix[i].reverse()\n\n\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nprint(matrix)\n# [[1, 2, 3],\n#  [4, 5, 6],\n#  [7, 8, 9]]\nmatrix1 = deepcopy(matrix)\nrotate1(matrix1)\nprint(matrix1)\n# [[7, 4, 1],\n#  [8, 5, 2],\n#  [9, 6, 3]]\nmatrix2 = deepcopy(matrix)\nrotate2(matrix2)\nprint(matrix2)\n# [[7, 4, 1],\n#  [8, 5, 2],\n#  [9, 6, 3]]\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/math_geometry/#54-spiral-matrix","title":"54. Spiral Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, matrix, simulation</p> </li> <li>Return all elements of the matrix in spiral order.</li> </ul> 54. Spiral Matrix - Python Solution<pre><code>from typing import List\n\n\n# Array\ndef spiralOrder(matrix: List[List[int]]) -&gt; List[int]:\n    if not matrix or not matrix[0]:\n        return []\n\n    res = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n\n    while top &lt;= bottom and left &lt;= right:\n\n        for i in range(left, right + 1):\n            res.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            res.append(matrix[i][right])\n        right -= 1\n\n        if top &lt;= bottom:\n\n            for i in range(right, left - 1, -1):\n                res.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left &lt;= right:\n\n            for i in range(bottom, top - 1, -1):\n                res.append(matrix[i][left])\n            left += 1\n\n    return res\n\n\n# Math\ndef spiralOrderMath(matrix: List[List[int]]) -&gt; List[int]:\n    dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]]  # Right Down Left Up\n    m, n = len(matrix), len(matrix[0])\n    size = m * n\n    res = []\n    i, j, di = 0, -1, 0\n\n    while len(res) &lt; size:\n        dx, dy = dirs[di]\n        for _ in range(n):\n            i += dx\n            j += dy\n            res.append(matrix[i][j])\n        di = (di + 1) % 4\n        n, m = m - 1, n\n\n    return res\n\n\nprint(spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n# [1, 2, 3, 6, 9, 8, 7, 4, 5]\nprint(spiralOrderMath([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]))\n# [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]\n</code></pre>"},{"location":"content/blind75/math_geometry/#73-set-matrix-zeroes","title":"73. Set Matrix Zeroes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, matrix 73. Set Matrix Zeroes - Python Solution<pre><code>from copy import deepcopy\nfrom typing import List\n\n\n# Math\ndef setZeroes1(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    m, n = len(matrix), len(matrix[0])\n\n    rows, cols = set(), set()\n\n    for i in range(m):\n        for j in range(n):\n            if matrix[i][j] == 0:\n                rows.add(i)\n                cols.add(j)\n\n    for i in rows:\n        for j in range(n):\n            matrix[i][j] = 0\n\n    for i in range(m):\n        for j in cols:\n            matrix[i][j] = 0\n\n\n# Math - Optimized\ndef setZeroes2(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    m, n = len(matrix), len(matrix[0])\n    row_zero, col_zero = False, False\n\n    for i in range(m):\n        if matrix[i][0] == 0:\n            col_zero = True\n            break\n\n    for j in range(n):\n        if matrix[0][j] == 0:\n            row_zero = True\n            break\n\n    for i in range(1, m):\n        for j in range(1, n):\n            if matrix[i][j] == 0:\n                matrix[i][0] = 0\n                matrix[0][j] = 0\n\n    for i in range(1, m):\n        if matrix[i][0] == 0:\n            for j in range(1, n):\n                matrix[i][j] = 0\n\n    for j in range(1, n):\n        if matrix[0][j] == 0:\n            for i in range(1, m):\n                matrix[i][j] = 0\n\n    if col_zero:\n        for i in range(m):\n            matrix[i][0] = 0\n\n    if row_zero:\n        for j in range(n):\n            matrix[0][j] = 0\n\n\nmatrix = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]\nprint(matrix)\n# [[1, 1, 1],\n#  [1, 0, 1],\n#  [1, 1, 1]]\nmatrix1 = deepcopy(matrix)\nsetZeroes1(matrix1)\nprint(matrix1)\n# [[1, 0, 1],\n#  [0, 0, 0],\n#  [1, 0, 1]]\nmatrix2 = deepcopy(matrix)\nsetZeroes2(matrix2)\nprint(matrix2)\n# [[1, 0, 1],\n#  [0, 0, 0],\n#  [1, 0, 1]]\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/sliding_window/","title":"Sliding Window","text":""},{"location":"content/blind75/sliding_window/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 121. Best Time to Buy and Sell Stock (Easy)</li> <li> 3. Longest Substring Without Repeating Characters (Medium)</li> <li> 424. Longest Repeating Character Replacement (Medium)</li> <li> 76. Minimum Window Substring (Hard)</li> </ul>"},{"location":"content/blind75/sliding_window/#121-best-time-to-buy-and-sell-stock","title":"121. Best Time to Buy and Sell Stock","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li>Return the maximum profit that can be achieved from buying on one day and selling on another day.</li> </ul> 121. Best Time to Buy and Sell Stock - Python Solution<pre><code>from typing import List\n\n\n# Brute Force\ndef maxProfitBF(prices: List[int]) -&gt; int:\n    max_profit = 0\n    n = len(prices)\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_profit = max(max_profit, prices[j] - prices[i])\n\n    return max_profit\n\n\n# DP\ndef maxProfitDP(prices: List[int]) -&gt; int:\n    dp = [[0] * 2 for _ in range(len(prices))]\n    dp[0][0] = -prices[0]  # buy\n    dp[0][1] = 0  # sell\n\n    for i in range(1, len(prices)):\n        dp[i][0] = max(dp[i - 1][0], -prices[i])  # the lowest price to buy\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    max_profit = 0\n    seen_min = prices[0]\n\n    for i in range(1, len(prices)):\n        max_profit = max(max_profit, prices[i] - seen_min)\n        seen_min = min(seen_min, prices[i])\n\n    return max_profit\n\n\n# Fast Slow Pointers\ndef maxProfitFS(prices: List[int]) -&gt; int:\n    max_profit = 0\n    slow, fast = 0, 1\n\n    while fast &lt; len(prices):\n        if prices[fast] &gt; prices[slow]:\n            max_profit = max(max_profit, prices[fast] - prices[slow])\n        else:\n            slow = fast\n        fast += 1\n\n    return max_profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force|  O(n^2)|  O(1)   |\n# | DP         |  O(n)  |  O(n)   |\n# | Greedy     |  O(n)  |  O(1)   |\n# | Fast Slow  |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitBF(prices))  # 5\nprint(maxProfitDP(prices))  # 5\nprint(maxProfitGreedy(prices))  # 5\nprint(maxProfitFS(prices))  # 5\n</code></pre> 121. Best Time to Buy and Sell Stock - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int maxProfit(vector&lt;int&gt; &amp;prices)\n    {\n        if (prices.size() &lt;= 1)\n            return 0;\n\n        int seen_min = prices[0];\n        int res = 0;\n\n        for (int &amp;price : prices)\n        {\n            res = max(res, price - seen_min);\n            seen_min = min(seen_min, price);\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    vector&lt;int&gt; prices = {7, 1, 5, 3, 6, 4};\n    Solution obj;\n    cout &lt;&lt; obj.maxProfit(prices) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/blind75/sliding_window/#3-longest-substring-without-repeating-characters","title":"3. Longest Substring Without Repeating Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> <li>Classic variable sliding window problem. Use a set to keep track of the characters in the current window.</li> <li>Return the length of the longest substring without repeating characters.</li> <li>Template tutorial by \u7075\u5c71\u8336\u827e\u5e9c</li> </ul> 3. Longest Substring Without Repeating Characters - Python Solution<pre><code>from collections import defaultdict\n\n\n# Sliding Window Variable Max - HashMap\ndef lengthOfLongestSubstringHash(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    left = 0\n    cnt = defaultdict(int)\n    res = 0\n\n    for right in range(n):\n        cnt[s[right]] += 1\n\n        while cnt[s[right]] &gt; 1:\n            cnt[s[left]] -= 1\n            left += 1\n\n        res = max(res, right - left + 1)\n\n    return res\n\n\n# Sliding Window Variable Max - Set\ndef lengthOfLongestSubstringSet(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    left = 0\n    res = 0\n    window = set()\n\n    for right in range(n):\n        while left &lt; right and s[right] in window:\n            window.remove(s[left])\n            left += 1\n        window.add(s[right])\n        res = max(res, right - left + 1)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    s = \"abcabcbb\"\n    assert lengthOfLongestSubstringHash(s) == 3\n    assert lengthOfLongestSubstringSet(s) == 3\n</code></pre> 3. Longest Substring Without Repeating Characters - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;unordered_set&gt;\nusing namespace std;\n\nint lengthOfLongestSubstring(string s) {\n    int n = s.length();\n    int res = 0;\n    int left = 0;\n    unordered_set&lt;char&gt; window;\n\n    for (int right = 0; right &lt; n; right++) {\n        char ch = s[right];\n\n        while (window.find(ch) != window.end()) {\n            window.erase(s[left]);\n            left++;\n        }\n\n        window.insert(ch);\n        res = max(res, right - left + 1);\n    }\n    return (int)res;\n}\n\nint main() {\n    string s = \"abcabcbb\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 3\n    s = \"bbbbb\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 1\n    s = \"pwwkew\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 3\n    return 0;\n}\n</code></pre>"},{"location":"content/blind75/sliding_window/#424-longest-repeating-character-replacement","title":"424. Longest Repeating Character Replacement","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window 424. Longest Repeating Character Replacement - Python Solution<pre><code>from collections import defaultdict\n\n\n# Sliding Window - Variable\ndef characterReplacement(s: str, k: int) -&gt; int:\n    left = 0\n    maxCount = 0\n    counts = defaultdict(int)\n    maxLen = 0\n\n    for right in range(len(s)):\n        counts[s[right]] += 1\n        maxCount = max(maxCount, counts[s[right]])\n\n        while right - left + 1 - maxCount &gt; k:\n            counts[s[left]] -= 1\n            left += 1\n\n        maxLen = max(maxLen, right - left + 1)\n\n    return maxLen\n\n\ns = \"ABAB\"\nk = 2\nprint(characterReplacement(s, k))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/sliding_window/#76-minimum-window-substring","title":"76. Minimum Window Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, sliding window 76. Minimum Window Substring - Python Solution<pre><code>from collections import Counter\n\n\ndef minWindow(s: str, t: str) -&gt; str:\n    if not t or not s:\n        return \"\"\n\n    counts = Counter(t)\n    required = len(counts)\n\n    left, right = 0, 0\n    formed = 0\n    window_counts = dict()\n\n    result = float(\"inf\"), None, None\n\n    while right &lt; len(s):\n        char = s[right]\n        window_counts[char] = window_counts.get(char, 0) + 1\n        if char in counts and window_counts[char] == counts[char]:\n            formed += 1\n\n        while left &lt;= right and formed == required:\n            char = s[left]\n            if right - left + 1 &lt; result[0]:\n                result = (right - left + 1, left, right)\n            window_counts[char] -= 1\n            if char in counts and window_counts[char] &lt; counts[char]:\n                formed -= 1\n            left += 1\n\n        right += 1\n\n    return \"\" if result[0] == float(\"inf\") else s[result[1] : result[2] + 1]\n\n\ns = \"ADOBECODEBANC\"\nt = \"ABC\"\nprint(minWindow(s, t))  # BANC\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/stack/","title":"Stack","text":""},{"location":"content/blind75/stack/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 20. Valid Parentheses (Easy)</li> </ul>"},{"location":"content/blind75/stack/#20-valid-parentheses","title":"20. Valid Parentheses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, stack</p> </li> <li>Determine if the input string is valid.</li> <li>Steps for the string <code>()[]{}</code>:</li> </ul> char action stack <code>(</code> push \"(\" <code>)</code> pop \"\" <code>[</code> push \"[\" <code>]</code> pop \"\" <code>{</code> push \"{\" <code>}</code> pop \"\" 20. Valid Parentheses - Python Solution<pre><code># Stack\ndef isValid(s: str) -&gt; bool:\n    hashmap = {\n        \")\": \"(\",\n        \"]\": \"[\",\n        \"}\": \"{\",\n    }\n    stack = []\n\n    for ch in s:\n        if ch in hashmap:\n            if stack and stack[-1] == hashmap[ch]:\n                stack.pop()\n            else:\n                return False\n        else:\n            stack.append(ch)\n\n    return True if not stack else False\n\n\nif __name__ == \"__main__\":\n    assert isValid(\"()[]{}\")\n    assert not isValid(\"(]\")\n    assert not isValid(\"([)]\")\n    assert isValid(\"{[]}\")\n    assert isValid(\"\")\n</code></pre> 20. Valid Parentheses - C++ Solution<pre><code>#include &lt;cassert&gt;\n#include &lt;stack&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool isValid(string s) {\n        unordered_map&lt;char, char&gt; map{{')', '('}, {'}', '{'}, {']', '['}};\n        stack&lt;char&gt; stack;\n        if (s.length() % 2 == 1) return false;\n\n        for (char&amp; ch : s) {\n            if (stack.empty() || map.find(ch) == map.end()) {\n                stack.push(ch);\n            } else {\n                if (map[ch] != stack.top()) {\n                    return false;\n                }\n                stack.pop();\n            }\n        }\n        return stack.empty();\n    }\n};\n\nint main() {\n    Solution s;\n    assert(s.isValid(\"()\") == true);\n    assert(s.isValid(\"()[]{}\") == true);\n    assert(s.isValid(\"(]\") == false);\n    assert(s.isValid(\"([)]\") == false);\n    assert(s.isValid(\"{[]}\") == true);\n    return 0;\n}\n</code></pre>"},{"location":"content/blind75/trees/","title":"Trees","text":""},{"location":"content/blind75/trees/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 226. Invert Binary Tree (Easy)</li> <li> 104. Maximum Depth of Binary Tree (Easy)</li> <li> 100. Same Tree (Easy)</li> <li> 572. Subtree of Another Tree (Easy)</li> <li> 235. Lowest Common Ancestor of a Binary Search Tree (Medium)</li> <li> 102. Binary Tree Level Order Traversal (Medium)</li> <li> 98. Validate Binary Search Tree (Medium)</li> <li> 230. Kth Smallest Element in a BST (Medium)</li> <li> 105. Construct Binary Tree from Preorder and Inorder Traversal (Medium)</li> <li> 124. Binary Tree Maximum Path Sum (Hard)</li> <li> 298. Binary Tree Longest Consecutive Sequence (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/blind75/trees/#226-invert-binary-tree","title":"226. Invert Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 226. Invert Binary Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef invertTreeRecursive(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    root.left, root.right = root.right, root.left\n\n    invertTreeRecursive(root.left)\n    invertTreeRecursive(root.right)\n\n    return root\n\n\n# Iterative\ndef invertTreeIterative(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    stack = [root]\n\n    while stack:\n        node = stack.pop()\n\n        node.left, node.right = node.right, node.left\n        if node.left:\n            stack.append(node.left)\n        if node.right:\n            stack.append(node.right)\n\n    return root\n\n\nroot = build([4, 2, 7, 1, 3, 6, 9])\nprint(root)\n#     __4__\n#    /     \\\n#   2       7\n#  / \\     / \\\n# 1   3   6   9\ninvertedRecursive = invertTreeRecursive(root)\nprint(invertedRecursive)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\nroot = build([4, 2, 7, 1, 3, 6, 9])\ninvertedIterative = invertTreeIterative(root)\nprint(invertedIterative)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/trees/#104-maximum-depth-of-binary-tree","title":"104. Maximum Depth of Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 104. Maximum Depth of Binary Tree - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef maxDepthRecursive(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    left = maxDepthRecursive(root.left)\n    right = maxDepthRecursive(root.right)\n\n    return 1 + max(left, right)\n\n\n# DFS\ndef maxDepthDFS(root: Optional[TreeNode]) -&gt; int:\n    res = 0\n\n    def dfs(node, cnt):\n        if node is None:\n            return\n        cnt += 1\n        nonlocal res\n        res = max(res, cnt)\n\n        dfs(node.left, cnt)\n        dfs(node.right, cnt)\n\n    dfs(root, 0)\n\n    return res\n\n\n# Iterative\ndef maxDepthIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n    res = 0\n\n    while q:\n        res += 1\n        n = len(q)\n\n        for _ in range(n):\n            node = q.popleft()\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    root = [1, 2, 2, 3, 4, None, None, None, None, 5]\n    root = build(root)\n    print(root)\n    #     ____1\n    #    /     \\\n    #   2__     2\n    #  /   \\\n    # 3     4\n    #      /\n    #     5\n    assert maxDepthRecursive(root) == 4\n    assert maxDepthDFS(root) == 4\n    assert maxDepthIterative(root) == 4\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/trees/#100-same-tree","title":"100. Same Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 100. Same Tree - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# 1. Recursive\ndef isSameTreeRecursive(p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:\n    if not p and not q:\n        return True\n    elif not p or not q:\n        return False\n    elif p.val != q.val:\n        return False\n\n    return isSameTreeRecursive(p.left, q.left) and isSameTreeRecursive(\n        p.right, q.right\n    )\n\n\n# 2. Iterative with queue\ndef isSameTreeIterativeQueue(\n    p: Optional[TreeNode], q: Optional[TreeNode]\n) -&gt; bool:\n    queue = deque([(p, q)])\n\n    while queue:\n        p, q = queue.popleft()\n\n        if not p and not q:\n            continue\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n\n        queue.append((p.left, q.left))\n        queue.append((p.right, q.right))\n\n    return True\n\n\n# 3. Iterative with stack\ndef isSameTreeIterativeStack(\n    p: Optional[TreeNode], q: Optional[TreeNode]\n) -&gt; bool:\n    stack = [(p, q)]\n\n    while stack:\n        n1, n2 = stack.pop()\n\n        if not n1 and not n2:\n            continue\n        if not n1 or not n2:\n            return False\n        if n1.val != n2.val:\n            return False\n\n        stack.append((n1.left, n2.left))\n        stack.append((n1.right, n2.right))\n\n    return True\n\n\nif __name__ == \"__main__\":\n    p1 = build([1, 2, 3])\n    q1 = build([1, 2, 3])\n    p2 = build([1, 2])\n    q2 = build([1, None, 2])\n\n    assert isSameTreeRecursive(p1, q1) is True\n    assert isSameTreeRecursive(p2, q2) is False\n    assert isSameTreeIterativeQueue(p1, q1) is True\n    assert isSameTreeIterativeQueue(p2, q2) is False\n    assert isSameTreeIterativeStack(p1, q1) is True\n    assert isSameTreeIterativeStack(p2, q2) is False\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/trees/#572-subtree-of-another-tree","title":"572. Subtree of Another Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, string matching, binary tree, hash function 572. Subtree of Another Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# DFS - Tree\ndef isSubtree(root: Optional[TreeNode], subRoot: Optional[TreeNode]) -&gt; bool:\n    def isSameTree(p, q):\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n\n        return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)\n\n    if not root:\n        return False\n\n    return (\n        isSameTree(root, subRoot)\n        or isSubtree(root.left, subRoot)\n        or isSubtree(root.right, subRoot)\n    )\n\n\n# |------------|---------|----------|\n# | Approach   | Time    | Space    |\n# |------------|---------|----------|\n# | DFS        | O(n * m)| O(n)     |\n# |------------|---------|----------|\n\n\nroot = build([3, 4, 5, 1, 2, None, None, None, None, 0])\nsubRoot = build([4, 1, 2])\nprint(root)\n#     ____3\n#    /     \\\n#   4__     5\n#  /   \\\n# 1     2\n#      /\n#     0\nprint(subRoot)\n#   4\n#  / \\\n# 1   2\nprint(isSubtree(root, subRoot))  # False\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/trees/#235-lowest-common-ancestor-of-a-binary-search-tree","title":"235. Lowest Common Ancestor of a Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree 235. Lowest Common Ancestor of a Binary Search Tree - Python Solution<pre><code>from binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef lowestCommonAncestor(\n    root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n) -&gt; \"TreeNode\":\n    while root:\n        if root.val &gt; p.val and root.val &gt; q.val:\n            root = root.left\n        elif root.val &lt; p.val and root.val &lt; q.val:\n            root = root.right\n        else:\n            return root\n\n\nroot = [6, 2, 8, 0, 4, 7, 9, None, None, 3, 5]\nroot = build(root)\np = root.left\nq = root.right\nprint(root)\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\nprint(lowestCommonAncestor(root, p, q))\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/trees/#102-binary-tree-level-order-traversal","title":"102. Binary Tree Level Order Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, breadth first search, binary tree 102. Binary Tree Level Order Traversal - Python Solution<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef levelOrder(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        level = []\n        size = len(q)\n\n        for _ in range(size):\n            cur = q.popleft()\n            level.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(level)\n\n    return res\n\n\ntree = build([3, 9, 20, None, None, 15, 7])\nprint(tree)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(levelOrder(tree))  # [[3], [9, 20], [15, 7]]\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/trees/#98-validate-binary-search-tree","title":"98. Validate Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree 98. Validate Binary Search Tree - Python Solution<pre><code>from itertools import pairwise\nfrom math import inf\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef isValidBST1(root: Optional[TreeNode]) -&gt; bool:\n    inorder = []  # inorder traversal\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    for a, b in pairwise(inorder):\n        if a &gt;= b:\n            return False\n\n    return True\n\n\ndef isValidBST2(root: Optional[TreeNode]) -&gt; bool:\n    if not root:\n        return True\n    pre = -inf\n\n    def dfs(node):\n        if not node:\n            return True\n        if not dfs(node.left):\n            return False\n\n        nonlocal pre\n        if node.val &lt;= pre:\n            return False\n        pre = node.val\n\n        return dfs(node.right)\n\n    return dfs(root)\n\n\nif __name__ == \"__main__\":\n    root = [5, 1, 4, None, None, 3, 6]\n    root = build(root)\n    print(root)\n    #   5__\n    #  /   \\\n    # 1     4\n    #      / \\\n    #     3   6\n    assert not isValidBST1(root)  # [1, 5, 3, 4, 6]\n    assert not isValidBST2(root)  # [1, 5, 3, 4, 6]\n</code></pre></p> </li> </ul> 98. Validate Binary Search Tree - C++ Solution<pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   private:\n    vector&lt;int&gt; inorder;\n    bool check(vector&lt;int&gt; inorder) {\n        int n = inorder.size();\n        if (n &lt;= 1) return true;\n        for (int i = 1; i &lt; n; i++) {\n            if (inorder[i] &lt;= inorder[i - 1]) return false;\n        }\n        return true;\n    }\n\n   public:\n    bool isValidBST(TreeNode *root) {\n        auto dfs = [&amp;](auto &amp;&amp;self, TreeNode *node) -&gt; void {\n            if (!node) return;\n\n            self(self, node-&gt;left);\n            inorder.push_back(node-&gt;val);\n            self(self, node-&gt;right);\n        };\n\n        dfs(dfs, root);\n\n        return check(inorder);\n    }\n};\n\nint main() {\n    Solution s;\n    TreeNode *root = new TreeNode(2);\n    root-&gt;left = new TreeNode(1);\n    root-&gt;right = new TreeNode(3);\n    assert(s.isValidBST(root) == true);\n\n    root = new TreeNode(5);\n    root-&gt;left = new TreeNode(1);\n    root-&gt;right = new TreeNode(4);\n    root-&gt;right-&gt;left = new TreeNode(3);\n    root-&gt;right-&gt;right = new TreeNode(6);\n    assert(s.isValidBST(root) == false);\n\n    root = new TreeNode(5);\n    root-&gt;left = new TreeNode(4);\n    root-&gt;right = new TreeNode(6);\n    root-&gt;right-&gt;left = new TreeNode(3);\n    root-&gt;right-&gt;right = new TreeNode(7);\n    assert(s.isValidBST(root) == false);\n\n    return 0;\n}\n</code></pre>"},{"location":"content/blind75/trees/#230-kth-smallest-element-in-a-bst","title":"230. Kth Smallest Element in a BST","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree 230. Kth Smallest Element in a BST - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef kthSmallestRecursive(root: Optional[TreeNode], k: int) -&gt; int:\n    inorder = []\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n    return inorder[k - 1]\n\n\n# Iteratve\ndef kthSmallestIteratve(root: Optional[TreeNode], k: int) -&gt; int:\n    stack = []\n    while True:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        k -= 1\n        if not k:\n            return root.val\n        root = root.right\n\n\nif __name__ == \"__main__\":\n    root = build([3, 1, 4, None, 2])\n    k = 1\n    assert kthSmallestRecursive(root, k) == 1\n    assert kthSmallestIteratve(root, k) == 1\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/trees/#105-construct-binary-tree-from-preorder-and-inorder-traversal","title":"105. Construct Binary Tree from Preorder and Inorder Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, divide and conquer, tree, binary tree 105. Construct Binary Tree from Preorder and Inorder Traversal - Python Solution<pre><code>from typing import List, Optional\n\nfrom helper import TreeNode\n\n\ndef buildTree(preorder: List[int], inorder: List[int]) -&gt; Optional[TreeNode]:\n    \"\"\"\n    preorder  root left right  1  2  3\n    inorder   left root right  4  5  6\n    \"\"\"\n    if len(preorder) == 0:\n        return None\n\n    root_val = preorder[0]  # 1\n    root = TreeNode(root_val)\n\n    separator_idx = inorder.index(root_val)  # 5\n\n    left_inorder = inorder[:separator_idx]  # 4\n    right_inorder = inorder[separator_idx + 1 :]  # 6\n\n    left_preorder = preorder[1 : 1 + len(left_inorder)]  # 2\n    right_preorder = preorder[1 + len(left_inorder) :]  # 3\n\n    root.left = buildTree(left_preorder, left_inorder)\n    root.right = buildTree(right_preorder, right_inorder)\n\n    return root\n\n\npreorder = [3, 9, 20, 15, 7]\ninorder = [9, 3, 15, 20, 7]\nroot = buildTree(preorder, inorder)\nprint(root)\n#     3\n#    / \\\n#   9  20\n#     /  \\\n#    15   7\n</code></pre></p> </li> </ul> 105. Construct Binary Tree from Preorder and Inorder Traversal - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   public:\n    vector&lt;int&gt; preorder;\n    unordered_map&lt;int, int&gt; inorderMap;\n\n    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {\n        this-&gt;preorder = preorder;\n        for (size_t i = 0; i &lt; inorder.size(); i++) {\n            inorderMap[inorder[i]] = i;\n        }\n        return buildSubtree(0, 0, inorder.size() - 1);\n    }\n\n   private:\n    TreeNode* buildSubtree(int rootIndex, int left, int right) {\n        if (left &gt; right) return nullptr;\n\n        TreeNode* root = new TreeNode(preorder[rootIndex]);\n        int inorderIndex = inorderMap[preorder[rootIndex]];\n\n        root-&gt;left = buildSubtree(rootIndex + 1, left, inorderIndex - 1);\n        root-&gt;right = buildSubtree(rootIndex + (inorderIndex - left + 1),\n                                   inorderIndex + 1, right);\n\n        return root;\n    }\n};\n\nint main() {\n    vector&lt;int&gt; preorder = {3, 9, 20, 15, 7};\n    vector&lt;int&gt; inorder = {9, 3, 15, 20, 7};\n    Solution solution;\n    TreeNode* root = solution.buildTree(preorder, inorder);\n    cout &lt;&lt; root-&gt;val &lt;&lt; endl;                // 3\n    cout &lt;&lt; root-&gt;left-&gt;val &lt;&lt; endl;          // 9\n    cout &lt;&lt; root-&gt;right-&gt;val &lt;&lt; endl;         // 20\n    cout &lt;&lt; root-&gt;right-&gt;left-&gt;val &lt;&lt; endl;   // 15\n    cout &lt;&lt; root-&gt;right-&gt;right-&gt;val &lt;&lt; endl;  // 7\n    return 0;\n}\n</code></pre>"},{"location":"content/blind75/trees/#124-binary-tree-maximum-path-sum","title":"124. Binary Tree Maximum Path Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, tree, depth first search, binary tree 124. Binary Tree Maximum Path Sum - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef maxPathSum(root: Optional[TreeNode]) -&gt; int:\n    res = float(\"-inf\")\n\n    def dfs(node):\n        if not node:\n            return 0\n\n        leftMax = max(dfs(node.left), 0)\n        rightMax = max(dfs(node.right), 0)\n\n        cur = node.val + leftMax + rightMax\n        nonlocal res\n        res = max(res, cur)\n\n        return node.val + max(leftMax, rightMax)\n\n    dfs(root)\n\n    return res\n\n\nroot = build([-10, 9, 20, None, None, 15, 7])\nprint(root)\n#   -10___\n#  /      \\\n# 9       _20\n#        /   \\\n#       15    7\nprint(maxPathSum(root))  # 42\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/trees/#298-binary-tree-longest-consecutive-sequence","title":"298. Binary Tree Longest Consecutive Sequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree 298. Binary Tree Longest Consecutive Sequence - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Binary Tree\ndef longestConsecutive(root: Optional[TreeNode]) -&gt; int:\n    res = 0\n\n    def dfs(node):\n        if not node:\n            return 0\n\n        left, right = dfs(node.left), dfs(node.right)\n        cur = 1\n        if node.left and node.left.val == (node.val + 1):\n            cur = max(cur, left + 1)\n        if node.right and node.right.val == (node.val + 1):\n            cur = max(cur, right + 1)\n\n        nonlocal res\n        res = max(res, cur)\n        return cur\n\n    dfs(root)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    root = build([1, 3, 2, 4, None, None, None, 5])\n    print(root)\n    #       1\n    #      / \\\n    #     3   2\n    #    /\n    #   4\n    #  /\n    # 5\n    print(longestConsecutive(root))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/tries/","title":"Tries","text":""},{"location":"content/blind75/tries/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 208. Implement Trie (Prefix Tree) (Medium)</li> <li> 212. Word Search II (Hard)</li> <li> 211. Design Add and Search Words Data Structure (Medium)</li> </ul>"},{"location":"content/blind75/tries/#208-implement-trie-prefix-tree","title":"208. Implement Trie (Prefix Tree)","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, design, trie</p> </li> </ul>"},{"location":"content/blind75/tries/#trie","title":"Trie","text":"<ul> <li>A trie is a tree-like data structure whose nodes store the letters of an alphabet.</li> </ul> <pre><code>flowchart TD\nRoot(( ))\nRoot --- C1((\"C\"))\nRoot --- D((D))\nC1 --- A1((\"A\"))\nA1 --- T1((\"T\"))\nA1 --- R1((\"R\"))\nA1 --- N((N))\nRoot --- B1((B))\nB1 --- A2((A))\nA2 --- T2((T))\nA2 --- R2((R))</code></pre> 208. Implement Trie (Prefix Tree) - Python Solution<pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.endOfWord = None\n\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.endOfWord = True\n\n    def search(self, word: str) -&gt; bool:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return node.endOfWord\n\n    def startsWith(self, prefix: str) -&gt; bool:\n        node = self.root\n\n        for c in prefix:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return True\n\n\n# Your Trie object will be instantiated and called as such:\nobj = Trie()\nobj.insert(\"apple\")\nprint(obj.search(\"word\"))  # False\nprint(obj.startsWith(\"app\"))  # True\n</code></pre>"},{"location":"content/blind75/tries/#212-word-search-ii","title":"212. Word Search II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, backtracking, trie, matrix 212. Word Search II - Python Solution<pre><code>from typing import List\n\nfrom template import TrieNode\n\n\n# Backtracking + Trie\ndef findWords(board: List[List[str]], words: List[str]) -&gt; List[str]:\n    root = TrieNode()\n    for word in words:\n        root.addWord(word)\n\n    m, n = len(board), len(board[0])\n    result, visit = set(), set()\n\n    def dfs(r, c, node, word):\n        if (\n            r &lt; 0\n            or r &gt;= m\n            or c &lt; 0\n            or c &gt;= n\n            or (r, c) in visit\n            or board[r][c] not in node.children\n        ):\n            return None\n\n        visit.add((r, c))\n\n        node = node.children[board[r][c]]\n        word += board[r][c]\n        if node.isWord:\n            result.add(word)\n\n        dfs(r - 1, c, node, word)\n        dfs(r + 1, c, node, word)\n        dfs(r, c - 1, node, word)\n        dfs(r, c + 1, node, word)\n\n        visit.remove((r, c))\n\n    for r in range(m):\n        for c in range(n):\n            dfs(r, c, root, \"\")\n\n    return list(result)\n\n\nboard = [\n    [\"o\", \"a\", \"a\", \"n\"],\n    [\"e\", \"t\", \"a\", \"e\"],\n    [\"i\", \"h\", \"k\", \"r\"],\n    [\"i\", \"f\", \"l\", \"v\"],\n]\nwords = [\"oath\", \"pea\", \"eat\", \"rain\"]\nprint(findWords(board, words))\n# ['eat', 'oath']\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/tries/#211-design-add-and-search-words-data-structure","title":"211. Design Add and Search Words Data Structure","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, depth first search, design, trie 211. Design Add and Search Words Data Structure - Python Solution<pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.word = False\n\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.word = True\n\n    def search(self, word: str) -&gt; bool:\n\n        def dfs(j, root):\n            node = root\n\n            for i in range(j, len(word)):\n                c = word[i]\n\n                if c == \".\":\n                    for child in node.children.values():\n                        if dfs(i + 1, child):\n                            return True\n                    return False\n                else:\n                    if c not in node.children:\n                        return False\n                    node = node.children[c]\n            return node.word\n\n        return dfs(0, self.root)\n\n\n# Your WordDictionary object will be instantiated and called as such:\nobj = WordDictionary()\nobj.addWord(\"word\")\nprint(obj.search(\"word\"))\nprint(obj.search(\"w.rd\"))\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/two_pointers/","title":"Two Pointers","text":""},{"location":"content/blind75/two_pointers/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 125. Valid Palindrome (Easy)</li> <li> 15. 3Sum (Medium)</li> <li> 11. Container With Most Water (Medium)</li> </ul>"},{"location":"content/blind75/two_pointers/#125-valid-palindrome","title":"125. Valid Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string 125. Valid Palindrome - Python Solution<pre><code># List Comprehension\ndef isPalindrome(s: str) -&gt; bool:\n    s = [char.lower() for char in s if char.isalnum()]\n    return s == s[::-1]\n\n\n# Left Right Pointers\ndef isPalindromeLR(s: str) -&gt; bool:\n    left, right = 0, len(s) - 1\n\n    while left &lt; right:\n        while left &lt; right and not s[left].isalnum():\n            left += 1\n        while left &lt; right and not s[right].isalnum():\n            right -= 1\n\n        if s[left].lower() != s[right].lower():\n            return False\n\n        left += 1\n        right -= 1\n\n    return True\n\n\ns = \"A man, a plan, a canal: Panama\"\nprint(isPalindrome(s))  # True\nprint(isPalindromeLR(s))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/blind75/two_pointers/#15-3sum","title":"15. 3Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, sorting 15. 3Sum - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef threeSum(nums: List[int]) -&gt; List[List[int]]:\n    nums.sort()\n    res = []\n    n = len(nums)\n\n    for i in range(n - 2):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        left, right = i + 1, n - 1\n\n        while left &lt; right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total &gt; 0:\n                right -= 1\n            elif total &lt; 0:\n                left += 1\n            else:\n                res.append([nums[i], nums[left], nums[right]])\n\n                while left &lt; right and nums[left] == nums[left + 1]:\n                    left += 1\n\n                while left &lt; right and nums[right] == nums[right - 1]:\n                    right -= 1\n\n                left += 1\n                right -= 1\n\n    return res\n\n\nnums = [-1, 0, 1, 2, -1, -4]\nassert threeSum(nums) == [[-1, -1, 2], [-1, 0, 1]]\n</code></pre></p> </li> </ul> 15. 3Sum - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {\n    sort(nums.begin(), nums.end());\n    vector&lt;vector&lt;int&gt;&gt; res;\n    int n = nums.size();\n\n    for (int i = 0; i &lt; n - 2; i++) {\n        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) {\n            continue;\n        }\n\n        int left = i + 1, right = n - 1;\n\n        while (left &lt; right) {\n            int total = nums[i] + nums[left] + nums[right];\n\n            if (total &gt; 0)\n                right--;\n            else if (total &lt; 0)\n                left++;\n            else {\n                res.push_back({nums[i], nums[left], nums[right]});\n                while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++;\n                while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--;\n                left++;\n                right--;\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {-1, 0, 1, 2, -1, -4};\n    vector&lt;vector&lt;int&gt;&gt; res = threeSum(nums);\n    for (auto&amp; v : res) {\n        for (int i : v) {\n            cout &lt;&lt; i &lt;&lt; \" \";\n        }\n        cout &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"content/blind75/two_pointers/#11-container-with-most-water","title":"11. Container With Most Water","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy</p> </li> <li>Return the maximum area of water that can be trapped between the vertical lines.</li> </ul> <p></p> 11. Container With Most Water - Python Solution<pre><code>from typing import List\n\n\n# Brute Force\ndef maxAreaBF(height: List[int]) -&gt; int:\n    max_area = 0\n\n    for i in range(len(height)):\n        for j in range(i + 1, len(height)):\n            h = min(height[i], height[j])\n            w = j - i\n            max_area = max(max_area, h * w)\n\n    return max_area\n\n\n# Left Right Pointers\ndef maxAreaLR(height: List[int]) -&gt; int:\n    left, right = 0, len(height) - 1\n    res = 0\n\n    while left &lt; right:\n        h = min(height[left], height[right])\n        w = right - left\n        res = max(res, h * w)\n\n        if height[left] &lt; height[right]:\n            left += 1\n        else:\n            right -= 1\n\n    return res\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force| O(n^2) |  O(1)   |\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nheight = [1, 8, 6, 2, 5, 4, 8, 3, 7]\nprint(maxAreaBF(height))  # 49\nprint(maxAreaLR(height))  # 49\n</code></pre> 11. Container With Most Water - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint maxArea(vector&lt;int&gt;&amp; height) {\n    int left = 0, right = height.size() - 1;\n    int res = 0;\n\n    while (left &lt; right) {\n        int h = min(height[left], height[right]);\n        int w = right - left;\n        res = max(res, h * w);\n\n        if (height[left] &lt; height[right])\n            left++;\n        else\n            right--;\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; height = {1, 8, 6, 2, 5, 4, 8, 3, 7};\n    cout &lt;&lt; maxArea(height) &lt;&lt; endl;  // 49\n    return 0;\n}\n</code></pre>"},{"location":"content/challenge/","title":"Daily Challenge","text":""},{"location":"content/challenge/2025-03/","title":"2025-03","text":""},{"location":"content/challenge/2025-03/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 131. Palindrome Partitioning (Medium)</li> <li> 132. Palindrome Partitioning II (Hard)</li> <li> 1278. Palindrome Partitioning III (Hard)</li> <li> 1745. Palindrome Partitioning IV (Hard)</li> <li> 1328. Break a Palindrome (Medium)</li> <li> 2588. Count the Number of Beautiful Subarrays (Medium)</li> <li> 2597. The Number of Beautiful Subsets (Medium)</li> <li> 2234. Maximum Total Beauty of the Gardens (Hard)</li> <li> 2070. Most Beautiful Item for Each Query (Medium)</li> <li> 2269. Find the K-Beauty of a Number (Easy)</li> <li> 2012. Sum of Beauty in the Array (Medium)</li> <li> 3305. Count of Substrings Containing Every Vowel and K Consonants I (Medium)</li> <li> 3306. Count of Substrings Containing Every Vowel and K Consonants II (Medium)</li> <li> 3340. Check Balanced String (Easy)</li> <li> 3110. Score of a String (Easy)</li> <li> 2272. Substring With Largest Variance (Hard)</li> <li> 1963. Minimum Number of Swaps to Make the String Balanced (Medium)</li> <li> 2614. Prime In Diagonal (Easy)</li> <li> 2610. Convert an Array Into a 2D Array With Conditions (Medium)</li> <li> 2612. Minimum Reverse Operations (Hard)</li> <li> 2680. Maximum OR (Medium)</li> <li> 2643. Row With Maximum Ones (Easy)</li> <li> 2116. Check if a Parentheses String Can Be Valid (Medium)</li> <li> 2255. Count Prefixes of a Given String (Easy)</li> <li> 2711. Difference of Number of Distinct Values on Diagonals (Medium)</li> <li> 2829. Determine the Minimum Sum of a k-avoiding Array (Medium)</li> <li> 2712. Minimum Cost to Make All Characters Equal (Medium)</li> <li> 2716. Minimize String Length (Easy)</li> <li> 2360. Longest Cycle in a Graph (Hard)</li> <li> 2109. Adding Spaces to a String (Medium)</li> <li> 2278. Percentage of Letter in String (Easy)</li> </ul>"},{"location":"content/challenge/2025-03/#131-palindrome-partitioning","title":"131. Palindrome Partitioning","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming, backtracking 131. Palindrome Partitioning - Python Solution<pre><code>from typing import List\n\n\n# Backtracking\ndef partition(s: str) -&gt; List[List[str]]:\n    n = len(s)\n    res, path = [], []\n\n    def dfs(start):\n        if start == n:\n            res.append(path.copy())\n            return\n\n        for end in range(start, n):\n            cur = s[start : end + 1]\n            if cur == cur[::-1]:\n                path.append(cur)\n                dfs(end + 1)\n                path.pop()\n\n    dfs(0)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(partition(\"aab\"))\n    # [['a', 'a', 'b'], ['aa', 'b']]\n</code></pre></p> </li> </ul>"},{"location":"content/challenge/2025-03/#132-palindrome-partitioning-ii","title":"132. Palindrome Partitioning II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> <li>\u6559\u4f60\u4e00\u6b65\u6b65\u601d\u8003 DP\uff1a\u4ece\u8bb0\u5fc6\u5316\u641c\u7d22\u5230\u9012\u63a8\uff08Python/Java/C++/Go\uff09</li> </ul> 132. Palindrome Partitioning II - Python Solution<pre><code>from functools import cache\n\n\n# Memoization\ndef minCutMemoization(s: str) -&gt; int:\n    @cache\n    def is_palindrome(left, right):\n        if left &gt;= right:\n            return True\n        return s[left] == s[right] and is_palindrome(left + 1, right - 1)\n\n    @cache\n    def dfs(right):\n        if is_palindrome(0, right):\n            return 0\n        res = float(\"inf\")\n        for left in range(1, right + 1):\n            if is_palindrome(left, right):\n                res = min(res, 1 + dfs(left - 1))\n        return res\n\n    return dfs(len(s) - 1)\n\n\n# Tabulation\ndef minCutTabulation(s: str) -&gt; int:\n    n = len(s)\n    is_palindrome = [[True] * n for _ in range(n)]\n\n    for left in range(n - 2, -1, -1):\n        for right in range(left + 1, n):\n            is_palindrome[left][right] = (\n                s[left] == s[right] and is_palindrome[left + 1][right - 1]\n            )\n\n    dp = [0 for _ in range(n)]\n\n    for right, is_pal in enumerate(is_palindrome[0]):\n        if is_pal:\n            continue\n        res = float(\"inf\")\n        for left in range(1, right + 1):\n            if is_palindrome[left][right]:\n                res = min(res, 1 + dp[left - 1])\n        dp[right] = res\n\n    return dp[-1]\n\n\ns = \"aab\"\nprint(minCutMemoization(s))  # 1\nprint(minCutTabulation(s))  # 1\n</code></pre>"},{"location":"content/challenge/2025-03/#1278-palindrome-partitioning-iii","title":"1278. Palindrome Partitioning III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming 1278. Palindrome Partitioning III - Python Solution<pre><code># DP\ndef palindromePartition(s: str, k: int) -&gt; int:\n    n = len(s)\n    min_change = [[0] * n for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        for j in range(i + 1, n):\n            min_change[i][j] = min_change[i + 1][j - 1] + (\n                1 if s[i] != s[j] else 0\n            )\n\n    dp = min_change[0]\n    for i in range(1, k):\n        for right in range(n - k + i, i - 1, -1):\n            dp[right] = min(\n                dp[left - 1] + min_change[left][right]\n                for left in range(i, right + 1)\n            )\n\n    return dp[-1]\n\n\ns = \"aabbc\"\nk = 3\nprint(palindromePartition(s, k))  # 0\n</code></pre></p> </li> </ul>"},{"location":"content/challenge/2025-03/#1745-palindrome-partitioning-iv","title":"1745. Palindrome Partitioning IV","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming 1745. Palindrome Partitioning IV - Python Solution<pre><code># DP\ndef checkPartitioning(s: str) -&gt; bool:\n    def palidrome_partition(s, k):\n        n = len(s)\n        min_change = [[0] * n for _ in range(n)]\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 1, n):\n                min_change[i][j] = min_change[i + 1][j - 1] + (\n                    1 if s[i] != s[j] else 0\n                )\n\n        dp = min_change[0]\n\n        for i in range(1, k):\n            for right in range(n - k + i, i - 1, -1):\n                dp[right] = min(\n                    dp[left - 1] + min_change[left][right]\n                    for left in range(i, right + 1)\n                )\n\n        return dp[-1]\n\n    return palidrome_partition(s, 3) == 0\n\n\ns = \"abcbdd\"\nprint(checkPartitioning(s))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/challenge/2025-03/#1328-break-a-palindrome","title":"1328. Break a Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, greedy 1328. Break a Palindrome - Python Solution<pre><code># Greedy\ndef breakPalindrome(palindrome: str) -&gt; str:\n    n = len(palindrome)\n    if n == 1:\n        return \"\"\n\n    for i in range(n // 2):\n        if palindrome[i] != \"a\":\n            return palindrome[:i] + \"a\" + palindrome[i + 1 :]\n\n    return palindrome[:-1] + \"b\"\n\n\npalindrome = \"abccba\"\nprint(breakPalindrome(palindrome))  # \"aaccba\"\n</code></pre></p> </li> </ul>"},{"location":"content/challenge/2025-03/#2588-count-the-number-of-beautiful-subarrays","title":"2588. Count the Number of Beautiful Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, bit manipulation, prefix sum</p> </li> <li><code>nums = [4, 3, 1, 2, 4]</code></li> <li>In bianry</li> </ul> <pre><code>4 -&gt; 100\n3 -&gt; 011\n1 -&gt; 001\n2 -&gt; 010\n4 -&gt; 100\n</code></pre> 2588. Count the Number of Beautiful Subarrays - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\ndef beautifulSubarrays(nums: List[int]) -&gt; int:\n    res, s = 0, 0\n    cnt = defaultdict(int)\n    cnt[0] = 1\n\n    for x in nums:\n        s ^= x\n        res += cnt[s]\n        cnt[s] += 1\n\n    return res\n\n\nnums = [4, 3, 1, 2, 4]\nprint(beautifulSubarrays(nums))  # 2\n</code></pre>"},{"location":"content/challenge/2025-03/#2597-the-number-of-beautiful-subsets","title":"2597. The Number of Beautiful Subsets","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, dynamic programming, backtracking, sorting, combinatorics 2597. The Number of Beautiful Subsets - C++ Solution<pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Solution {\n   public:\n    int beautifulSubsets(vector&lt;int&gt;&amp; nums, int k) {\n        int res = 0;\n        unordered_map&lt;int, int&gt; cnt;\n\n        auto dfs = [&amp;](auto&amp;&amp; self, int i) -&gt; void {\n            if (i == (int)nums.size()) {\n                res++;\n                return;\n            }\n            self(self, i + 1);  // Skip nums[i]\n            int x = nums[i];\n            if (cnt[x - k] == 0 &amp;&amp; cnt[x + k] == 0) {\n                cnt[x]++;\n                self(self, i + 1);  // Include nums[i]\n                cnt[x]--;           // Backtrack\n            }\n        };\n\n        dfs(dfs, 0);\n\n        return res - 1;\n    }\n};\n\nint main() {\n    Solution sol;\n    vector&lt;int&gt; nums = {1, 2, 3, 4};\n    int k = 1;\n    cout &lt;&lt; sol.beautifulSubsets(nums, k) &lt;&lt; endl;\n    return 0;\n}\n</code></pre></p> </li> </ul>"},{"location":"content/challenge/2025-03/#2234-maximum-total-beauty-of-the-gardens","title":"2234. Maximum Total Beauty of the Gardens","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, binary search, greedy, sorting 2234. Maximum Total Beauty of the Gardens - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nlong long maximumBeauty(vector&lt;int&gt;&amp; flowers, long long newFlowers, int target,\n                        int full, int partial) {\n    int n = flowers.size();\n\n    long long left = newFlowers - 1LL * target * n;\n    for (int&amp; flower : flowers) {\n        flower = min(flower, target);\n        left += flower;\n    }\n\n    if (left == newFlowers) return 1LL * full * n;\n\n    if (left &gt;= 0) {\n        return max(1LL * (target - 1) * partial + 1LL * (n - 1) * full,\n                   1LL * n * full);\n    }\n\n    sort(flowers.begin(), flowers.end());\n    long long res = 0, pre_sum = 0;\n\n    int j = 0;\n    for (int i = 1; i &lt;= n; i++) {\n        left += target - flowers[i - 1];\n        if (left &lt; 0) {\n            continue;\n        }\n\n        while (j &lt; i &amp;&amp; 1LL * flowers[j] * j &lt;= pre_sum + left) {\n            pre_sum += flowers[j];\n            j++;\n        }\n\n        long long avg = (left + pre_sum) / j;\n        long long total_beauty = avg * partial + 1LL * (n - i) * full;\n        res = max(res, total_beauty);\n    }\n\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; flowers = {1, 3, 1, 1};\n    long long newFlowers = 7;\n    int target = 6;\n    int full = 12;\n    int partial = 1;\n    long long res = maximumBeauty(flowers, newFlowers, target, full, partial);\n    cout &lt;&lt; res &lt;&lt; endl;  // 14\n    return 0;\n}\n</code></pre></p> </li> </ul>"},{"location":"content/challenge/2025-03/#2070-most-beautiful-item-for-each-query","title":"2070. Most Beautiful Item for Each Query","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sorting 2070. Most Beautiful Item for Each Query - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;numeric&gt;\n#include &lt;ranges&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;int&gt; maximumBeauty(vector&lt;vector&lt;int&gt;&gt;&amp; items, vector&lt;int&gt;&amp; queries) {\n    ranges::sort(items, {}, [](auto&amp; item) { return item[0]; });\n    vector&lt;int&gt; idx(queries.size());\n    iota(idx.begin(), idx.end(), 0);\n    ranges::sort(idx, {}, [&amp;](int i) { return queries[i]; });\n\n    vector&lt;int&gt; res(queries.size());\n    int max_beauty = 0, j = 0;\n    for (int i : idx) {\n        int q = queries[i];\n        while (j &lt; items.size() &amp;&amp; items[j][0] &lt;= q) {\n            max_beauty = max(max_beauty, items[j][1]);\n            j++;\n        }\n        res[i] = max_beauty;\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;vector&lt;int&gt;&gt; items = {{1, 2}, {2, 4}, {3, 2}, {5, 6}, {3, 5}};\n    vector&lt;int&gt; queries = {1, 2, 3, 4, 5, 6};\n    vector&lt;int&gt; res = maximumBeauty(items, queries);\n    // 2 4 5 5 6 6\n    for (int i : res) {\n        cout &lt;&lt; i &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n    return 0;\n}\n</code></pre></p> </li> </ul>"},{"location":"content/challenge/2025-03/#2269-find-the-k-beauty-of-a-number","title":"2269. Find the K-Beauty of a Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, string, sliding window 2269. Find the K-Beauty of a Number - Python Solution<pre><code>def divisorSubstrings(num: int, k: int) -&gt; int:\n    numStr = str(num)\n    n = len(numStr)\n    res = 0\n\n    for i in range(n - k + 1):\n        x = int(numStr[i : i + k])\n        if x &gt; 0 and num % x == 0:\n            res += 1\n\n    return res\n\n\nnum = 240\nk = 2\nprint(divisorSubstrings(num, k))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/challenge/2025-03/#2012-sum-of-beauty-in-the-array","title":"2012. Sum of Beauty in the Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array 2012. Sum of Beauty in the Array - Python Solution<pre><code>from typing import List\n\n\n# DP Prefix and Suffix Decomposition\ndef sumOfBeauties(nums: List[int]) -&gt; int:\n    n = len(nums)\n    suf_min = [0] * n\n    suf_min[n - 1] = nums[n - 1]\n    for i in range(n - 2, 1, -1):\n        suf_min[i] = min(suf_min[i + 1], nums[i])\n\n    res = 0\n    pre_max = nums[0]\n    for i in range(1, n - 1):\n        x = nums[i]\n        if pre_max &lt; x &lt; suf_min[i + 1]:\n            res += 2\n        elif nums[i - 1] &lt; x &lt; nums[i + 1]:\n            res += 1\n        pre_max = max(pre_max, x)\n\n    return res\n\n\nnums = [2, 4, 6, 4, 5]\nprint(sumOfBeauties(nums))  # 1\n</code></pre></p> </li> </ul>"},{"location":"content/challenge/2025-03/#3305-count-of-substrings-containing-every-vowel-and-k-consonants-i","title":"3305. Count of Substrings Containing Every Vowel and K Consonants I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window 3305. Count of Substrings Containing Every Vowel and K Consonants I - Python Solution<pre><code>from collections import defaultdict\n\n\n# Sliding Window Variable Subarrays Exact\ndef countOfSubstrings(word: str, k: int) -&gt; int:\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\"}\n    n = len(word)\n\n    def count(m: int) -&gt; int:\n        occur = defaultdict(int)\n        valid_vow_cnt, con_cnt = 0, 0\n        left = 0\n        res = 0\n\n        for right in range(n):\n            while left &lt; n and (con_cnt &lt; m or valid_vow_cnt &lt; 5):\n                if word[left] in vowels:\n                    if occur[word[left]] == 0:\n                        valid_vow_cnt += 1\n                    occur[word[left]] += 1\n                else:\n                    con_cnt += 1\n                left += 1\n\n            if con_cnt &gt;= m and valid_vow_cnt == 5:\n                res += n - left + 1\n\n            if word[right] in vowels:\n                occur[word[right]] -= 1\n                if occur[word[right]] == 0:\n                    valid_vow_cnt -= 1\n            else:\n                con_cnt -= 1\n\n        return res\n\n    return count(k) - count(k + 1)\n\n\nword = \"ieaouqqieaouqq\"\nk = 1\nprint(countOfSubstrings(word, k))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/challenge/2025-03/#3306-count-of-substrings-containing-every-vowel-and-k-consonants-ii","title":"3306. Count of Substrings Containing Every Vowel and K Consonants II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window 3306. Count of Substrings Containing Every Vowel and K Consonants II - Python Solution<pre><code>from collections import defaultdict\n\n\n# Sliding Window Variable Subarrays Exact\ndef countOfSubstrings(word: str, k: int) -&gt; int:\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\"}\n    n = len(word)\n\n    def count(m: int) -&gt; int:\n        occur = defaultdict(int)\n        valid_vow_cnt, con_cnt = 0, 0\n        left = 0\n        res = 0\n\n        for right in range(n):\n            while left &lt; n and (con_cnt &lt; m or valid_vow_cnt &lt; 5):\n                if word[left] in vowels:\n                    if occur[word[left]] == 0:\n                        valid_vow_cnt += 1\n                    occur[word[left]] += 1\n                else:\n                    con_cnt += 1\n                left += 1\n\n            if con_cnt &gt;= m and valid_vow_cnt == 5:\n                res += n - left + 1\n\n            if word[right] in vowels:\n                occur[word[right]] -= 1\n                if occur[word[right]] == 0:\n                    valid_vow_cnt -= 1\n            else:\n                con_cnt -= 1\n\n        return res\n\n    return count(k) - count(k + 1)\n\n\nword = \"ieaouqqieaouqq\"\nk = 1\nprint(countOfSubstrings(word, k))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/challenge/2025-03/#3340-check-balanced-string","title":"3340. Check Balanced String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string 3340. Check Balanced String - Python Solution<pre><code>def isBalanced1(num: str) -&gt; bool:\n    nums = [int(c) for c in num]\n    odd = nums[::2]\n    even = nums[1::2]\n\n    return sum(odd) == sum(even)\n\n\ndef isBalanced2(num: str) -&gt; bool:\n    cur = 0\n    n = len(num)\n\n    for i in range(0, n, 2):\n        cur += int(num[i])\n\n    for i in range(1, n, 2):\n        cur -= int(num[i])\n\n    return cur == 0\n\n\nif __name__ == \"__main__\":\n    print(isBalanced1(\"1234\"))  # False\n    print(isBalanced1(\"24123\"))  # True\n    print(isBalanced2(\"1234\"))  # False\n    print(isBalanced2(\"24123\"))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/challenge/2025-03/#3110-score-of-a-string","title":"3110. Score of a String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string 3110. Score of a String - Python Solution<pre><code># Traversal\ndef scoreOfString(s: str) -&gt; int:\n    res = 0\n\n    for i in range(1, len(s)):\n        res += abs(ord(s[i]) - ord(s[i - 1]))\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(scoreOfString(\"hello\"))  # 13\n</code></pre></p> </li> </ul>"},{"location":"content/challenge/2025-03/#2272-substring-with-largest-variance","title":"2272. Substring With Largest Variance","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming 2272. Substring With Largest Variance - Python Solution<pre><code>from itertools import permutations\nfrom math import inf\nfrom string import ascii_lowercase\n\n\n# DP State Machine\ndef largestVariance(s: str) -&gt; int:\n    res = 0\n\n    for a, b in permutations(ascii_lowercase, 2):\n        f0, f1 = 0, -inf\n        for ch in s:\n            if ch == a:\n                f0 = max(f0, 0) + 1\n                f1 += 1\n            elif ch == b:\n                f1 = f0 = max(f0, 0) - 1\n\n            res = max(res, f1)\n    return res\n\n\nif __name__ == \"__main__\":\n    s = \"aababbb\"\n    print(largestVariance(s))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/challenge/2025-03/#1963-minimum-number-of-swaps-to-make-the-string-balanced","title":"1963. Minimum Number of Swaps to Make the String Balanced","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string, stack, greedy 1963. Minimum Number of Swaps to Make the String Balanced - Python Solution<pre><code>def minSwaps(s: str) -&gt; int:\n    res, balance = 0, 0\n\n    for char in s:\n        if char == \"[\":\n            balance += 1\n        elif balance &gt; 0:\n            balance -= 1\n        else:\n            res += 1\n            balance += 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(minSwaps(\"][][\"))  # 1\n    print(minSwaps(\"]]][[[\"))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/challenge/2025-03/#2614-prime-in-diagonal","title":"2614. Prime In Diagonal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, math, matrix, number theory 2614. Prime In Diagonal - Python Solution<pre><code>from math import isqrt\nfrom typing import List\n\n\n# Prime\ndef diagonalPrime(nums: List[List[int]]) -&gt; int:\n    def is_prime(n):\n        if n &lt;= 1:\n            return False\n\n        for i in range(2, isqrt(n) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    res = 0\n    for i, row in enumerate(nums):\n        for x in row[i], row[-1 - i]:\n            if x &gt; res and is_prime(x):\n                res = x\n\n    return res\n\n\nif __name__ == \"__main__\":\n    nums = [[1, 2, 3], [5, 6, 7], [9, 10, 11]]\n    print(diagonalPrime(nums))  # 11\n</code></pre></p> </li> </ul>"},{"location":"content/challenge/2025-03/#2610-convert-an-array-into-a-2d-array-with-conditions","title":"2610. Convert an Array Into a 2D Array With Conditions","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table 2610. Convert an Array Into a 2D Array With Conditions - Python Solution<pre><code>from collections import Counter\nfrom typing import List\n\n\ndef findMatrix(nums: List[int]) -&gt; List[List[int]]:\n    counts = Counter(nums)\n    res = []\n\n    for num, freq in counts.items():\n        while len(res) &lt; freq:\n            res.append([])\n\n        for i in range(freq):\n            res[i].append(num)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    nums = [1, 3, 4, 1, 2, 3, 1]\n    print(findMatrix(nums))\n    # [[1, 3, 4, 2], [1, 3], [1]]\n</code></pre></p> </li> </ul>"},{"location":"content/challenge/2025-03/#2612-minimum-reverse-operations","title":"2612. Minimum Reverse Operations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, breadth first search, ordered set 2612. Minimum Reverse Operations - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\nclass UnionFind:\n    def __init__(self, n: int):\n        self.parent = list(range(n))\n\n    def find(self, n: int) -&gt; int:\n        if self.parent[n] != n:\n            self.parent[n] = self.find(self.parent[n])\n        return self.parent[n]\n\n    def union(self, n1: int, n2: int) -&gt; None:\n        self.parent[self.find(n1)] = self.find(n2)\n\n\ndef minReverseOperations(\n    n: int, p: int, banned: List[int], k: int\n) -&gt; List[int]:\n    indices = UnionFind(n + 2)\n    indices.union(p, p + 2)\n\n    for i in banned:\n        indices.union(i, i + 2)\n\n    res = [-1] * n\n    res[p] = 0\n    q = deque([p])\n\n    while q:\n        i = q.popleft()\n        mn = max(i - k + 1, k - i - 1)\n        mx = min(i + k - 1, n * 2 - k - i - 1)\n        j = indices.find(mn)\n        while j &lt;= mx:\n            res[j] = res[i] + 1\n            q.append(j)\n            indices.union(j, mx + 2)\n            j = indices.find(j + 2)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    n = 4\n    p = 0\n    banned = [1, 2]\n    k = 4\n    print(minReverseOperations(n, p, banned, k))\n    # [0, -1, -1, 1]\n</code></pre></p> </li> </ul>"},{"location":"content/challenge/2025-03/#2680-maximum-or","title":"2680. Maximum OR","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, bit manipulation, prefix sum 2680. Maximum OR - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef maximumOr(nums: List[int], k: int) -&gt; int:\n    \"\"\"Maximum OR of Array After k Operations\n\n    Args:\n        nums (List[int]): provided list of integers\n        k (int): number of operations\n\n    Returns:\n        int: maximum OR of array after k operations\n    \"\"\"\n    n = len(nums)\n    suffix = [0 for _ in range(n)]\n\n    for i in range(n - 2, -1, -1):\n        suffix[i] = suffix[i + 1] | nums[i + 1]\n\n    res, pre = 0, 0\n    for num, suf in zip(nums, suffix):\n        res = max(res, pre | (num &lt;&lt; k) | suf)\n        pre |= num\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(maximumOr(nums=[8, 1, 2], k=2))  # 35\n</code></pre></p> </li> </ul>"},{"location":"content/challenge/2025-03/#2643-row-with-maximum-ones","title":"2643. Row With Maximum Ones","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, matrix 2643. Row With Maximum Ones - Python Solution<pre><code>from typing import List\n\n\ndef rowAndMaximumOnes(mat: List[List[int]]) -&gt; List[int]:\n    \"\"\"Return the index of the row with the maximum number of ones.\"\"\"\n    res = [0, 0]\n    for i, row in enumerate(mat):\n        cnt = sum(row)\n        if cnt &gt; res[1]:\n            res[0], res[1] = i, cnt\n\n    return res\n\n\nif __name__ == \"__main__\":\n    mat = [[0, 0, 0, 1], [0, 1, 1, 1], [1, 1, 1, 1], [0, 0, 0, 0]]\n    print(rowAndMaximumOnes(mat))  # [2, 4]\n</code></pre></p> </li> </ul> 2643. Row With Maximum Ones - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;numeric&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;int&gt; rowAndMaximumOnes(vector&lt;vector&lt;int&gt;&gt;&amp; mat) {\n    vector&lt;int&gt; res = {0, 0};\n\n    for (size_t i = 0; i &lt; mat.size(); i++) {\n        int cnt = accumulate(mat[i].begin(), mat[i].end(), 0);\n        if (cnt &gt; res[1]) {\n            res[0] = (int)i;\n            res[1] = cnt;\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;vector&lt;int&gt;&gt; mat = {\n        {0, 0, 0, 1}, {0, 1, 1, 1}, {1, 1, 1, 1}, {0, 0, 0, 0}};\n    vector&lt;int&gt; res = rowAndMaximumOnes(mat);\n    cout &lt;&lt; res[0] &lt;&lt; \", \" &lt;&lt; res[1] &lt;&lt; endl;  // 2, 4\n    return 0;\n}\n</code></pre>"},{"location":"content/challenge/2025-03/#2116-check-if-a-parentheses-string-can-be-valid","title":"2116. Check if a Parentheses String Can Be Valid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack, greedy 2116. Check if a Parentheses String Can Be Valid - Python Solution<pre><code># Valid Parentheses Strings\ndef canBeValid(s: str, locked: str) -&gt; bool:\n    if len(s) % 2:\n        return False\n\n    mx, mn = 0, 0\n    for ch, lock in zip(s, locked):\n        if lock == \"1\":\n            d = 1 if ch == \"(\" else -1\n            mx += d\n            if mx &lt; 0:\n                return False\n            mn += d\n        else:\n            mx += 1\n            mn -= 1\n\n        if mn &lt; 0:\n            mn = 1\n\n    return mn == 0\n\n\nif __name__ == \"__main__\":\n    s = \"))()))\"\n    locked = \"010100\"\n    print(canBeValid(s, locked))  # True\n</code></pre></p> </li> </ul> 2116. Check if a Parentheses String Can Be Valid - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\n// Valid Parentheses Strings\nbool canBeValid(string s, string locked) {\n    if (s.length() % 2 != 0) {\n        return false;\n    }\n\n    int mx = 0, mn = 0;\n    for (size_t i = 0; i &lt; s.length(); ++i) {\n        char ch = s[i];\n        char lock = locked[i];\n\n        if (lock == '1') {\n            int d = (ch == '(') ? 1 : -1;\n            mx += d;\n            if (mx &lt; 0) {\n                return false;\n            }\n            mn += d;\n        } else {\n            mx += 1;\n            mn -= 1;\n        }\n\n        if (mn &lt; 0) {\n            mn = 1;\n        }\n    }\n\n    return mn == 0;\n}\n\nint main() {\n    string s = \"))()))\";\n    string locked = \"010100\";\n    cout &lt;&lt; (canBeValid(s, locked) ? \"true\" : \"false\") &lt;&lt; endl;  // true\n    return 0;\n}\n</code></pre>"},{"location":"content/challenge/2025-03/#2255-count-prefixes-of-a-given-string","title":"2255. Count Prefixes of a Given String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, string 2255. Count Prefixes of a Given String - Python Solution<pre><code>from typing import List\n\n\ndef countPrefixes(words: List[str], s: str) -&gt; int:\n    res = 0\n    for word in words:\n        if s.startswith(word):\n            res += 1\n    return res\n\n\nif __name__ == \"__main__\":\n    words = [\"a\", \"b\", \"c\", \"ab\", \"bc\", \"abc\"]\n    s = \"abc\"\n    print(countPrefixes(words, s))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/challenge/2025-03/#2711-difference-of-number-of-distinct-values-on-diagonals","title":"2711. Difference of Number of Distinct Values on Diagonals","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, matrix 2711. Difference of Number of Distinct Values on Diagonals - Python Solution<pre><code>from typing import List\n\n\ndef differenceOfDistinctValues(grid: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(grid), len(grid[0])\n    res = [[0] * n for _ in range(m)]\n    st = set()\n\n    for k in range(1, m + n):\n        min_j = max(n - k, 0)\n        max_j = min(m + n - 1 - k, n - 1)\n\n        st.clear()\n        for j in range(min_j, max_j + 1):\n            i = k + j - n\n            res[i][j] = len(st)\n            st.add(grid[i][j])\n\n        st.clear()\n        for j in range(max_j, min_j - 1, -1):\n            i = k + j - n\n            res[i][j] = abs(res[i][j] - len(st))\n            st.add(grid[i][j])\n\n    return res\n\n\nif __name__ == \"__main__\":\n    grid = [[1, 2, 3], [3, 1, 5], [3, 2, 1]]\n    print(differenceOfDistinctValues(grid))\n    # [[1, 1, 0], [1, 0, 1], [0, 1, 1]]\n</code></pre></p> </li> </ul>"},{"location":"content/challenge/2025-03/#2829-determine-the-minimum-sum-of-a-k-avoiding-array","title":"2829. Determine the Minimum Sum of a k-avoiding Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, greedy 2829. Determine the Minimum Sum of a k-avoiding Array - Python Solution<pre><code>def minimumSum(n: int, k: int) -&gt; int:\n    m = min(k // 2, n)\n    return (m * (m + 1) + (k * 2 + n - m - 1) * (n - m)) // 2\n\n\nif __name__ == \"__main__\":\n    n = 5\n    k = 4\n    print(minimumSum(n, k))  # 18\n</code></pre></p> </li> </ul>"},{"location":"content/challenge/2025-03/#2712-minimum-cost-to-make-all-characters-equal","title":"2712. Minimum Cost to Make All Characters Equal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming, greedy 2712. Minimum Cost to Make All Characters Equal - Python Solution<pre><code>def minimumCost(s: str) -&gt; int:\n    n = len(s)\n    res = 0\n    for i in range(1, n):\n        if s[i - 1] != s[i]:\n            res += min(i, n - i)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    s = \"0011\"\n    print(minimumCost(s))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/challenge/2025-03/#2716-minimize-string-length","title":"2716. Minimize String Length","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, string 2716. Minimize String Length - Python Solution<pre><code>def minimizedStringLength(s: str) -&gt; int:\n    return len(set(s))\n\n\nif __name__ == \"__main__\":\n    s = \"aaabc\"\n    print(minimizedStringLength(s))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/challenge/2025-03/#2360-longest-cycle-in-a-graph","title":"2360. Longest Cycle in a Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort 2360. Longest Cycle in a Graph - Python Solution<pre><code>from typing import List\n\n\ndef longestCycle(edges: List[int]) -&gt; int:\n    n = len(edges)\n    res = -1\n    cur = 1\n    vis = [0 for _ in range(n)]\n\n    for i in range(n):\n        start = cur\n        while i != -1 and vis[i] == 0:\n            vis[i] = cur\n            cur += 1\n            i = edges[i]\n        if i != -1 and vis[i] &gt;= start:\n            res = max(res, cur - vis[i])\n\n    return res\n\n\nif __name__ == \"__main__\":\n    edges = [3, 3, 4, 2, 3]\n    print(longestCycle(edges))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/challenge/2025-03/#2109-adding-spaces-to-a-string","title":"2109. Adding Spaces to a String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, string, simulation 2109. Adding Spaces to a String - Python Solution<pre><code>from typing import List\n\n\ndef addSpaces(s: str, spaces: List[int]) -&gt; str:\n    res = []\n    spaces.sort()\n    n = len(spaces)\n    j = 0\n\n    for i, ch in enumerate(s):\n        if j &lt; n and i == spaces[j]:\n            res.append(\" \")\n            j += 1\n        res.append(ch)\n\n    return \"\".join(res)\n\n\nif __name__ == \"__main__\":\n    s = \"LeetcodeHelpsMeLearn\"\n    spaces = [8, 13, 15]\n    print(addSpaces(s, spaces))  # Leetcode Helps Me Learn\n</code></pre></p> </li> </ul>"},{"location":"content/challenge/2025-03/#2278-percentage-of-letter-in-string","title":"2278. Percentage of Letter in String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string 2278. Percentage of Letter in String - Python Solution<pre><code>from collections import Counter\n\n\ndef percentageLetter(s: str, letter: str) -&gt; int:\n    cnt = Counter(s)\n    n = len(s)\n\n    if letter in cnt.keys():\n        return int(cnt[letter] / n * 100)\n\n    return 0\n\n\nif __name__ == \"__main__\":\n    s = \"foobar\"\n    letter = \"o\"\n    print(percentageLetter(s, letter))  # 33\n</code></pre></p> </li> </ul>"},{"location":"content/challenge/2025-04/","title":"2025-04","text":""},{"location":"content/challenge/2025-04/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2140. Solving Questions With Brainpower (Medium)</li> <li> 2873. Maximum Value of an Ordered Triplet I (Easy)</li> <li> 2874. Maximum Value of an Ordered Triplet II (Medium)</li> <li> 1123. Lowest Common Ancestor of Deepest Leaves (Medium)</li> <li> 1863. Sum of All Subset XOR Totals (Easy)</li> </ul>"},{"location":"content/challenge/2025-04/#2140-solving-questions-with-brainpower","title":"2140. Solving Questions With Brainpower","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming 2140. Solving Questions With Brainpower - Python Solution<pre><code>from functools import cache\nfrom typing import List\n\n\n# Memoization\ndef mostPoints(questions: List[List[int]]) -&gt; int:\n    @cache\n    def dfs(i: int) -&gt; int:\n        if i &gt;= len(questions):\n            return 0\n        return max(dfs(i + 1), dfs(i + questions[i][1] + 1) + questions[i][0])\n\n    return dfs(0)\n\n\nif __name__ == \"__main__\":\n    questions = [[3, 2], [4, 3], [4, 4], [2, 5]]\n    print(mostPoints(questions))  # 5\n</code></pre></p> </li> </ul>"},{"location":"content/challenge/2025-04/#2873-maximum-value-of-an-ordered-triplet-i","title":"2873. Maximum Value of an Ordered Triplet I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array 2873. Maximum Value of an Ordered Triplet I - Python Solution<pre><code>from typing import List\n\n\ndef maximumTripletValue(nums: List[int]) -&gt; int:\n    res, max_diff, pre_max = 0, 0, 0\n\n    for num in nums:\n        res = max(res, max_diff * num)\n        max_diff = max(max_diff, pre_max - num)\n        pre_max = max(pre_max, num)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    nums = [12, 6, 1, 2, 7]\n    print(maximumTripletValue(nums))  # 77\n</code></pre></p> </li> </ul>"},{"location":"content/challenge/2025-04/#2874-maximum-value-of-an-ordered-triplet-ii","title":"2874. Maximum Value of an Ordered Triplet II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array 2874. Maximum Value of an Ordered Triplet II - Python Solution<pre><code>from typing import List\n\n\ndef maximumTripletValue(nums: List[int]) -&gt; int:\n    res = 0\n    max_diff = 0\n    max_prev = 0\n\n    for num in nums:\n        res = max(res, max_diff * num)\n        max_diff = max(max_diff, max_prev - num)\n        max_prev = max(max_prev, num)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    nums = [12, 6, 1, 2, 7]\n    print(maximumTripletValue(nums))  # 77\n</code></pre></p> </li> </ul>"},{"location":"content/challenge/2025-04/#1123-lowest-common-ancestor-of-deepest-leaves","title":"1123. Lowest Common Ancestor of Deepest Leaves","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, tree, depth first search, breadth first search, binary tree 1123. Lowest Common Ancestor of Deepest Leaves - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Lowest Common Ancestor\ndef lcaDeepestLeaves(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    res = None\n    max_depth = -1\n\n    def dfs(node, depth) -&gt; int:\n        nonlocal res, max_depth\n        if not node:\n            max_depth = max(max_depth, depth)\n            return depth\n        left_max_depth = dfs(node.left, depth + 1)\n        right_max_depth = dfs(node.right, depth + 1)\n        if left_max_depth == right_max_depth == max_depth:\n            res = node\n        return max(left_max_depth, right_max_depth)\n\n    dfs(root, 0)\n    return res\n\n\nif __name__ == \"__main__\":\n    root = [3, 5, 1, 6, 2, 0, 8, None, None, 7, 4]\n    root = build(root)\n    print(root)\n    #     ______3__\n    #    /         \\\n    #   5__         1\n    #  /   \\       / \\\n    # 6     2     0   8\n    #      / \\\n    #     7   4\n    print(lcaDeepestLeaves(root))  # 2\n    #   2\n    #  / \\\n    # 7   4\n</code></pre></p> </li> </ul>"},{"location":"content/challenge/2025-04/#1863-sum-of-all-subset-xor-totals","title":"1863. Sum of All Subset XOR Totals","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, math, backtracking, bit manipulation, combinatorics, enumeration 1863. Sum of All Subset XOR Totals - Python Solution<pre><code>from functools import reduce\nfrom operator import or_\nfrom typing import List\n\n\ndef subsetXORSum(nums: List[int]) -&gt; int:\n    return reduce(or_, nums) &lt;&lt; (len(nums) - 1)\n\n\nif __name__ == \"__main__\":\n    nums = [5, 1, 6]\n    print(subsetXORSum(nums))  # 28\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/","title":"EndlessCheng \u7075\u8336\u5c71\u827e\u5e9c","text":"<p> (As of 2025 February)</p> <ul> <li>EndlessCheng \u7075\u8336\u5c71\u827e\u5e9c - LeetCode</li> <li>EndlessCheng \u7075\u8336\u5c71\u827e\u5e9c - GitHub</li> <li> <p>\u9898\u5355</p> <ul> <li>\u6ed1\u52a8\u7a97\u53e3\u4e0e\u53cc\u6307\u9488\uff08\u5b9a\u957f/\u4e0d\u5b9a\u957f/\u5355\u5e8f\u5217/\u53cc\u5e8f\u5217/\u4e09\u6307\u9488\uff09</li> <li>\u4e8c\u5206\u7b97\u6cd5\uff08\u4e8c\u5206\u7b54\u6848/\u6700\u5c0f\u5316\u6700\u5927\u503c/\u6700\u5927\u5316\u6700\u5c0f\u503c/\u7b2c K \u5c0f\uff09</li> <li>\u5355\u8c03\u6808\uff08\u57fa\u7840/\u77e9\u5f62\u9762\u79ef/\u8d21\u732e\u6cd5/\u6700\u5c0f\u5b57\u5178\u5e8f\uff09</li> <li>\u7f51\u683c\u56fe\uff08DFS/BFS/\u7efc\u5408\u5e94\u7528\uff09</li> <li>\u4f4d\u8fd0\u7b97\uff08\u57fa\u7840/\u6027\u8d28/\u62c6\u4f4d/\u8bd5\u586b/\u6052\u7b49\u5f0f/\u601d\u7ef4\uff09</li> <li>\u56fe\u8bba\u7b97\u6cd5\uff08DFS/BFS/\u62d3\u6251\u6392\u5e8f/\u6700\u77ed\u8def/\u6700\u5c0f\u751f\u6210\u6811/\u4e8c\u5206\u56fe/\u57fa\u73af\u6811/\u6b27\u62c9\u8def\u5f84\uff09</li> <li>\u52a8\u6001\u89c4\u5212\uff08\u5165\u95e8/\u80cc\u5305/\u72b6\u6001\u673a/\u5212\u5206/\u533a\u95f4/\u72b6\u538b/\u6570\u4f4d/\u6570\u636e\u7ed3\u6784\u4f18\u5316/\u6811\u5f62/\u535a\u5f08/\u6982\u7387\u671f\u671b\uff09</li> <li>\u5e38\u7528\u6570\u636e\u7ed3\u6784\uff08\u524d\u7f00\u548c/\u5dee\u5206/\u6808/\u961f\u5217/\u5806/\u5b57\u5178\u6811/\u5e76\u67e5\u96c6/\u6811\u72b6\u6570\u7ec4/\u7ebf\u6bb5\u6811\uff09</li> <li>\u6570\u5b66\u7b97\u6cd5\uff08\u6570\u8bba/\u7ec4\u5408/\u6982\u7387\u671f\u671b/\u535a\u5f08/\u8ba1\u7b97\u51e0\u4f55/\u968f\u673a\u7b97\u6cd5\uff09</li> <li>\u8d2a\u5fc3\u4e0e\u601d\u7ef4\uff08\u57fa\u672c\u8d2a\u5fc3\u7b56\u7565/\u53cd\u6094/\u533a\u95f4/\u5b57\u5178\u5e8f/\u6570\u5b66/\u601d\u7ef4/\u8111\u7b4b\u6025\u8f6c\u5f2f/\u6784\u9020\uff09</li> <li>\u94fe\u8868\u3001\u4e8c\u53c9\u6811\u4e0e\u4e00\u822c\u6811\uff08\u524d\u540e\u6307\u9488/\u5feb\u6162\u6307\u9488/DFS/BFS/\u76f4\u5f84/LCA\uff09</li> <li>\u5b57\u7b26\u4e32\uff08KMP/Z \u51fd\u6570/Manacher/\u5b57\u7b26\u4e32\u54c8\u5e0c/AC \u81ea\u52a8\u673a/\u540e\u7f00\u6570\u7ec4/\u5b50\u5e8f\u5217\u81ea\u52a8\u673a\uff09</li> </ul> </li> </ul>"},{"location":"content/endlesscheng/#progress","title":"Progress","text":""},{"location":"content/endlesscheng/#sliding-window","title":"Sliding Window","text":"Category Name Progress Sliding Window Sliding Window Fixed Size Basics Sliding Window Sliding Window Fixed Size Advanced Sliding Window Sliding Window Fixed Size Others Sliding Window Sliding Window Variable Max Basics Sliding Window Sliding Window Variable Max Advanced Sliding Window Sliding Window Variable Min Sliding Window Sliding Window Variable Subarrays Longer Sliding Window Sliding Window Variable Subarrays Shorter Sliding Window Sliding Window Variable Subarrays Exact Sliding Window Sliding Window Variable Others Sliding Window One Sequence Two Pointers Opposite Direction Sliding Window One Sequence Two Pointers Same Direction Sliding Window One Sequence Two Pointers Backward Sliding Window One Sequence Two Pointers In-Place Modification Sliding Window Two Sequences Two Pointers Sliding Window Two Sequences Subsequence Checking Sliding Window Three Pointers Sliding Window Grouped Loop"},{"location":"content/endlesscheng/#binary-search","title":"Binary Search","text":"Category Name Progress Binary Search Binary Search Basics Binary Search Binary Search Advanced Binary Search Binary Search Min Answer Binary Search Binary Search Max Answer Binary Search Binary Search Indirect Value Binary Search Binary Search Minimize Max Binary Search Binary Search Maximize Min Binary Search Binary Search Kth Min Max Binary Search Binary Search Others"},{"location":"content/endlesscheng/#monotonic-stack","title":"Monotonic Stack","text":"Category Name Progress Monotonic Stack Monotonic Stack Monotonic Stack Rectangle Monotonic Stack Contribution Method Monotonic Stack Lexicographically Smallest"},{"location":"content/endlesscheng/#grid","title":"Grid","text":"Category Name Progress Grid Grid DFS Grid Grid BFS Grid Grid 01 BFS Grid Grid Applications"},{"location":"content/endlesscheng/#bit","title":"Bit","text":"Category Name Progress Bit Bit Basics Bit Bit XOR Bit Bit AND OR Bit Bit LogTrick Bit Bit Contribution Method Bit Bit Trial and Error Method Bit Bit Identity Law Bit Bit Thinking Problems Bit Bit Others"},{"location":"content/endlesscheng/#graph","title":"Graph","text":"Category Name Progress Graph DFS Basics Graph BFS Basics Graph Topological Sorting Graph Topological Order DP Graph Fundamental Cycle Graph Shortest Path Single Source Dijkstra Graph Shortest Path All Pairs Floyd Graph Minimum Spanning Tree Graph Eulerian Path and Circuit Graph Strongly and Biconnected Components Graph Bipartite Graph Coloring Graph Network Flow Graph Graph Others"},{"location":"content/endlesscheng/#dynamic-programming","title":"Dynamic Programming","text":"Category Name Progress Dynamic Programming DP Climbing Stairs Dynamic Programming DP House Robber Dynamic Programming DP Max Subarray Sum Dynamic Programming DP Grid Basics Dynamic Programming DP Grid Advanced Dynamic Programming DP 0-1 Knapsack Dynamic Programming DP Complete Knapsack Dynamic Programming DP Multiple Knapsack Dynamic Programming DP Grouped Knapsack Dynamic Programming DP LCS Basics Dynamic Programming DP LCS Advanced Dynamic Programming DP LIS Basics Dynamic Programming DP LIS Advanced Dynamic Programming DP Partitioning Feasibility Dynamic Programming DP Optimal Partitioning Dynamic Programming DP Constrained Number of Partitions Dynamic Programming DP Non-Overlapping Intervals Dynamic Programming DP Stock Trading Dynamic Programming DP State Machine Basics Dynamic Programming DP State Machine Advanced Dynamic Programming DP 1D Dynamic Programming DP Valid Subsequence Dynamic Programming DP Matrix Exponentiation Optimized Dynamic Programming DP Subrectangle Dynamic Programming DP Multi-Dimensional Dynamic Programming DP Longest Palindromic Subsequence Dynamic Programming DP Other Interval DP Dynamic Programming DP Permutation Type Adjacent Unrelated Dynamic Programming DP Permutation Type Adjacent Related Dynamic Programming DP Traveling Salesman Problem Dynamic Programming DP Subset State Compression Dynamic Programming DP Other State Compression Dynamic Programming DP Digit Dynamic Programming DP Prefix Sum Dynamic Programming DP Monotonic Stack Dynamic Programming DP Monotonic Queue Dynamic Programming DP Fenwick Tree Segment Tree Dynamic Programming DP Trie Dynamic Programming DP Other Optimized Dynamic Programming DP WQS Binary Search Dynamic Programming Tree DP Tree Diameter Dynamic Programming Tree DP Maximum Independent Set Dynamic Programming Tree DP Minimum Dominating Set Dynamic Programming Tree DP Rerooting DP Dynamic Programming Tree DP Other Dynamic Programming DP Graph Dynamic Programming DP Game Theory Dynamic Programming DP Probability Expectation Dynamic Programming DP Print Solutions Dynamic Programming DP Prefix and Suffix Decomposition Dynamic Programming DP Transform X to Y Dynamic Programming DP Jump Game Dynamic Programming DP Other DP"},{"location":"content/endlesscheng/#data-structure","title":"Data Structure","text":"Category Name Progress Data Structure Enumerate Right Maintain Left Data Structure Enumerate Middle Data Structure Prefix Sum Basics Data Structure Prefix Sum with Hash Table Data Structure Distance Sum Data Structure Prefix XOR Sum Data Structure 1D Prefix Sum Data Structure 2D Prefix Sum Data Structure 1D Difference Array Data Structure 2D Difference Array Data Structure Stack Basics Data Structure Stack Advanced Data Structure Adjacent Elimination Data Structure Valid Parentheses Strings Data Structure Expression Parsing Data Structure Dual Stack Data Structure Queue Basics Data Structure Queue Design Data Structure Deque Data Structure Monotonic Queue Data Structure Monotonic Queue Optimized DP Data Structure Heap Basics Data Structure Heap Advanced Data Structure Heap Rearrange Elements Data Structure Heap Kth Smallest Largest Data Structure Regret Heap Data Structure Lazy Deletion Heap Data Structure Dual Heap Data Structure Trie Basics Data Structure Trie Advanced Data Structure Trie Optimized DP Data Structure XOR Trie Data Structure Union Find Basics Data Structure Union Find Advanced Data Structure GCD Union Find Data Structure Union Find on Arrays Data Structure Union Find Interval Data Structure Edge Weighted Union Find Data Structure Fenwick Tree Data Structure Inversion Count Data Structure Segment Tree Data Structure Lazy Segment Tree Data Structure Dynamic Segment Tree Data Structure Offline Algorithm"},{"location":"content/endlesscheng/#math","title":"Math","text":"Category Name Progress Math Prime Check Math Prime Preprocessing Math Prime Factorization Math Factorial Decomposition Math Factors Math Greatest Common Divisor Math Least Common Multiple Math Coprime Math Modular Arithmetic Math Number Theory Others Math Multiplication Principle Math Combinatorial Counting Math Ball Placement Problems Math Inclusion Exclusion Principle Math Combinatorics Contribution Method Math Probability and Expectation Math Game Theory Math Points and Lines Math Circles Math Rectangles and Polygons Math Convex Hull Math Randomized Algorithms Math Palindromic Numbers Math Integer Partition Math Manhattan Distance Math Polynomial Convolution Math Math Others"},{"location":"content/endlesscheng/#greedy","title":"Greedy","text":"Category Name Progress Greedy Greedy from Smallest Largest Greedy Single Sequence Pairing Greedy Double Sequence Pairing Greedy Greedy from Left Right Greedy Partitioning Greedy Greedy Enumerate then Greedy Greedy Exchange Argument Greedy Adjacent Different Greedy Regret Greedy Greedy Non-Overlapping Intervals Greedy Interval Grouping Greedy Interval Selection Greedy Interval Coverage Greedy Merge Intervals Greedy Other Interval Greedy Greedy Lexicographically Smallest Largest Greedy Palindrome Greedy Greedy Math Greedy Basics Greedy Product Greedy Greedy Sorting Inequality Greedy Basic Inequality Greedy Median Greedy Greedy Inductive Method Greedy Other Math Greedy Greedy From Special to General Greedy Brain Teasers Greedy Reverse Thinking Greedy Equivalent Transformation Greedy Construction Problems Greedy Greedy Others"},{"location":"content/endlesscheng/#linked-list","title":"Linked List","text":"Category Name Progress Linked List Linked List Traversal Linked List Linked List Delete Nodes Linked List Linked List Insert Nodes Linked List Linked List Reverse Linked List Linked List Front Back Pointers Linked List Linked List Fast Slow Pointers Linked List Linked List Double Pointers Linked List Linked Lists Merge Linked List Linked List Divide and Conquer Linked List Linked List Applications Linked List Linked List Others"},{"location":"content/endlesscheng/#binary-tree","title":"Binary Tree","text":"Category Name Progress Binary Tree Binary Tree Traversal Binary Tree Binary Tree Top-Down DFS Binary Tree Binary Tree Bottom-Up DFS Binary Tree Binary Tree Bottom-Up DFS Node Deletion Binary Tree Binary Tree Recursion Binary Tree Binary Tree Diameter Binary Tree Binary Tree Backtracking Binary Tree Binary Tree Lowest Common Ancestor Binary Tree Binary Search Tree Binary Tree Binary Tree Construction Binary Tree Binary Tree Insert Delete Nodes Binary Tree Tree DP Binary Tree Binary Tree BFS Binary Tree Binary Tree Linked List Binary Tree N-ary Tree Binary Tree Binary Tree Others"},{"location":"content/endlesscheng/#general-tree","title":"General Tree","text":"Category Name Progress General Tree General Tree Traversal General Tree General Tree Top-Down DFS General Tree General Tree Bottom-Up DFS General Tree General Tree Recursion General Tree General Tree Diameter General Tree General Tree DFS Timestamp General Tree General Tree Topological Sort General Tree General Tree Lowest Common Ancestor General Tree General Tree Others"},{"location":"content/endlesscheng/#backtracking","title":"Backtracking","text":"Category Name Progress Backtracking Backtracking Basic Backtracking Backtracking Subset Backtracking Backtracking Partition Backtracking Backtracking Combination Backtracking Backtracking Permutation Backtracking Backtracking Exhaustive Search and Pruning Backtracking Backtracking with Duplicates"},{"location":"content/endlesscheng/#string","title":"String","text":"Category Name Progress String String KMP String String Z Function String String Manacher Algorithm String String Hashing String String Minimal Representation String String AC Automaton String String Suffix Array String String Subsequence Automaton"},{"location":"content/endlesscheng/1d_difference_array/","title":"1D Difference Array","text":""},{"location":"content/endlesscheng/1d_difference_array/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2848. Points That Intersect With Cars (Easy)</li> <li> 1893. Check if All the Integers in a Range Are Covered (Easy)</li> <li> 1854. Maximum Population Year (Easy)</li> <li> 2960. Count Tested Devices After Test Operations (Easy)</li> <li> 1094. Car Pooling (Medium)</li> <li> 1109. Corporate Flight Bookings (Medium)</li> <li> 3355. Zero Array Transformation I (Medium)</li> <li> 56. Merge Intervals (Medium)</li> <li> 57. Insert Interval (Medium)</li> <li> 732. My Calendar III (Hard)</li> <li> 2406. Divide Intervals Into Minimum Number of Groups (Medium)</li> <li> 2381. Shifting Letters II (Medium)</li> <li> 3453. Separate Squares I (Medium)</li> <li> 995. Minimum Number of K Consecutive Bit Flips (Hard)</li> <li> 1589. Maximum Sum Obtained of Any Permutation (Medium)</li> <li> 1526. Minimum Number of Increments on Subarrays to Form a Target Array (Hard)</li> <li> 3356. Zero Array Transformation II (Medium)</li> <li> 1943. Describe the Painting (Medium)</li> <li> 3224. Minimum Array Changes to Make Differences Equal (Medium)</li> <li> 2251. Number of Flowers in Full Bloom (Hard)</li> <li> 2772. Apply Operations to Make All Array Elements Equal to Zero (Medium)</li> <li> 3229. Minimum Operations to Make Array Equal to Target (Hard)</li> <li> 798. Smallest Rotation with Highest Score (Hard)</li> <li> 3347. Maximum Frequency of an Element After Performing Operations II (Hard)</li> <li> 2528. Maximize the Minimum Powered City (Hard)</li> <li> 1674. Minimum Moves to Make Array Complementary (Medium)</li> <li> 3362. Zero Array Transformation III (Medium)</li> <li> 3017. Count the Number of Houses at a Certain Distance II (Hard)</li> <li> 253. Meeting Rooms II (Medium) \ud83d\udc51</li> <li> 370. Range Addition (Medium) \ud83d\udc51</li> <li> 1989. Maximum Number of People That Can Be Caught in Tag (Medium) \ud83d\udc51</li> <li> 759. Employee Free Time (Hard) \ud83d\udc51</li> <li> 2021. Brightest Position on Street (Medium) \ud83d\udc51</li> <li> 2015. Average Height of Buildings in Each Segment (Medium) \ud83d\udc51</li> <li> 2237. Count Positions on Street With Required Brightness (Medium) \ud83d\udc51</li> <li> 3009. Maximum Number of Intersections on the Chart (Hard) \ud83d\udc51</li> <li> 3279. Maximum Total Area Occupied by Pistons (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/1d_difference_array/#2848-points-that-intersect-with-cars","title":"2848. Points That Intersect With Cars","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, prefix sum</p> </li> <li>Return the number of points that intersect with cars.</li> </ul> 2848. Points That Intersect With Cars - Python Solution<pre><code>from itertools import accumulate\nfrom typing import List\n\n\n# Differnce Array\ndef numberOfPoints(nums: List[List[int]]) -&gt; int:\n    max_end = max(end for _, end in nums)\n\n    diff = [0] * (max_end + 2)\n\n    for start, end in nums:\n        diff[start] += 1\n        diff[end + 1] -= 1\n\n    return sum(s &gt; 0 for s in accumulate(diff))\n\n\nnums = [[3, 6], [1, 5], [4, 7]]\nprint(numberOfPoints(nums))  # 7\n</code></pre>"},{"location":"content/endlesscheng/1d_difference_array/#1893-check-if-all-the-integers-in-a-range-are-covered","title":"1893. Check if All the Integers in a Range Are Covered","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/1d_difference_array/#1854-maximum-population-year","title":"1854. Maximum Population Year","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, counting, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/1d_difference_array/#2960-count-tested-devices-after-test-operations","title":"2960. Count Tested Devices After Test Operations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, simulation, counting</p> </li> </ul>"},{"location":"content/endlesscheng/1d_difference_array/#1094-car-pooling","title":"1094. Car Pooling","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sorting, heap priority queue, simulation, prefix sum</p> </li> <li>Return <code>False</code> if the total number of passengers at any point is greater than <code>capacity</code>. Otherwise, return <code>True</code>.</li> </ul> 1094. Car Pooling - Python Solution<pre><code>from itertools import accumulate\nfrom typing import List\n\n\n# Difference Array\ndef carPooling1(trips: List[List[int]], capacity: int) -&gt; bool:\n    max_location = 0\n    for trip in trips:\n        max_location = max(max_location, trip[2])\n\n    diff = [0] * (max_location + 1)\n    n = len(diff)\n\n    for num, start, end in trips:\n        diff[start] += num\n        if end &lt; n:\n            diff[end] -= num\n\n    cur = 0\n    for i in range(n):\n        cur += diff[i]\n        if cur &gt; capacity:\n            return False\n\n    return True\n\n\n# Difference Array\ndef carPooling2(trips: List[List[int]], capacity: int) -&gt; bool:\n    diff = [0] * 1001\n\n    for num, start, end in trips:\n        diff[start] += num\n        diff[end] -= num\n\n    return all(s &lt;= capacity for s in accumulate(diff))\n\n\ntrips = [[2, 1, 5], [3, 3, 7]]\ncapacity = 4\nprint(carPooling1(trips, capacity))  # False\nprint(carPooling2(trips, capacity))  # False\n</code></pre>"},{"location":"content/endlesscheng/1d_difference_array/#1109-corporate-flight-bookings","title":"1109. Corporate Flight Bookings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, prefix sum</p> </li> <li>Return the number of seats booked on each flight.</li> </ul> 1109. Corporate Flight Bookings - Python Solution<pre><code>from typing import List\n\n\n# Difference Array\ndef corpFlightBookings(bookings: List[List[int]], n: int) -&gt; List[int]:\n    \"\"\"Return the number of seats booked for each flight.\"\"\"\n    res = [0 for _ in range(n)]\n\n    for i, j, k in bookings:\n        res[i - 1] += k\n        if j &lt; n:\n            res[j] -= k\n\n    for i in range(1, n):\n        res[i] += res[i - 1]\n\n    return res\n\n\nbookings = [[1, 2, 10], [2, 3, 20], [2, 5, 25]]\nn = 5\nprint(corpFlightBookings(bookings, n))  # [10, 55, 45, 25, 25]\n</code></pre>"},{"location":"content/endlesscheng/1d_difference_array/#3355-zero-array-transformation-i","title":"3355. Zero Array Transformation I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/1d_difference_array/#56-merge-intervals","title":"56. Merge Intervals","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sorting</p> </li> <li>Merge all overlapping intervals.</li> </ul> 56. Merge Intervals - Python Solution<pre><code>from typing import List\n\n\n# Intervals\ndef merge(intervals: List[List[int]]) -&gt; List[List[int]]:\n    n = len(intervals)\n    if n &lt;= 1:\n        return intervals\n\n    intervals.sort(key=lambda x: x[0])\n    res = [intervals[0]]\n\n    for i in range(1, n):\n        if intervals[i][0] &lt;= res[-1][1]:\n            res[-1][1] = max(res[-1][1], intervals[i][1])\n        else:\n            res.append(intervals[i])\n\n    return res\n\n\nprint(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))\n# [[1, 6], [8, 10], [15, 18]]\n</code></pre> 56. Merge Intervals - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// Interval\nvector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {\n    sort(intervals.begin(), intervals.end());\n    vector&lt;vector&lt;int&gt;&gt; res;\n\n    for (auto&amp; range : intervals) {\n        if (!res.empty() &amp;&amp; range[0] &lt;= res.back()[1]) {\n            res.back()[1] = max(res.back()[1], range[1]);\n        } else {\n            res.emplace_back(range);\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;vector&lt;int&gt;&gt; intervals = {{1, 3}, {2, 6}, {8, 10}, {15, 18}};\n    vector&lt;vector&lt;int&gt;&gt; res = merge(intervals);\n    for (auto&amp; range : res) {\n        cout &lt;&lt; range[0] &lt;&lt; \", \" &lt;&lt; range[1] &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"content/endlesscheng/1d_difference_array/#57-insert-interval","title":"57. Insert Interval","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array 57. Insert Interval - Python Solution<pre><code>from typing import List\n\n\n# Interval\ndef insert(\n    intervals: List[List[int]], newInterval: List[int]\n) -&gt; List[List[int]]:\n    n = len(intervals)\n\n    if n == 0:\n        return [newInterval]\n\n    if newInterval[1] &lt; intervals[0][0]:\n        return [newInterval] + intervals\n\n    if newInterval[0] &gt; intervals[-1][1]:\n        return intervals + [newInterval]\n\n    i = 0\n    result = []\n\n    while i &lt; n and intervals[i][1] &lt; newInterval[0]:\n        result.append(intervals[i])\n        i += 1\n\n    while i &lt; n and intervals[i][0] &lt;= newInterval[1]:\n        newInterval[0] = min(newInterval[0], intervals[i][0])\n        newInterval[1] = max(newInterval[1], intervals[i][1])\n        i += 1\n\n    result.append(newInterval)\n\n    while i &lt; n:\n        result.append(intervals[i])\n        i += 1\n\n    return result\n\n\nintervals = [[1, 3], [6, 9]]\nnewInterval = [2, 5]\nprint(insert(intervals, newInterval))  # [[1, 5], [6, 9]]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/1d_difference_array/#732-my-calendar-iii","title":"732. My Calendar III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: binary search, design, segment tree, prefix sum, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/1d_difference_array/#2406-divide-intervals-into-minimum-number-of-groups","title":"2406. Divide Intervals Into Minimum Number of Groups","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy, sorting, heap priority queue, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/1d_difference_array/#2381-shifting-letters-ii","title":"2381. Shifting Letters II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/1d_difference_array/#3453-separate-squares-i","title":"3453. Separate Squares I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"content/endlesscheng/1d_difference_array/#995-minimum-number-of-k-consecutive-bit-flips","title":"995. Minimum Number of K Consecutive Bit Flips","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, bit manipulation, queue, sliding window, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/1d_difference_array/#1589-maximum-sum-obtained-of-any-permutation","title":"1589. Maximum Sum Obtained of Any Permutation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting, prefix sum 1589. Maximum Sum Obtained of Any Permutation - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef maxSumRangeQuery(nums: List[int], requests: List[List[int]]) -&gt; int:\n    n = len(nums)\n    freq = [0 for _ in range(n + 1)]\n\n    for start, end in requests:\n        freq[start] += 1\n        if end + 1 &lt; n:\n            freq[end + 1] -= 1\n\n    for i in range(1, n):\n        freq[i] += freq[i - 1]\n\n    freq.pop()\n\n    freq.sort(reverse=True)\n    nums.sort(reverse=True)\n\n    max_sum = 0\n    mod = 10**9 + 7\n\n    for i, j in zip(nums, freq):\n        max_sum += i * j\n        max_sum %= mod\n\n    return max_sum\n\n\nnums = [1, 2, 3, 4, 5]\nrequests = [[1, 3], [0, 1]]\nprint(maxSumRangeQuery(nums, requests))  # 19\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/1d_difference_array/#1526-minimum-number-of-increments-on-subarrays-to-form-a-target-array","title":"1526. Minimum Number of Increments on Subarrays to Form a Target Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, stack, greedy, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/1d_difference_array/#3356-zero-array-transformation-ii","title":"3356. Zero Array Transformation II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/1d_difference_array/#1943-describe-the-painting","title":"1943. Describe the Painting","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, sorting, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/1d_difference_array/#3224-minimum-array-changes-to-make-differences-equal","title":"3224. Minimum Array Changes to Make Differences Equal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/1d_difference_array/#2251-number-of-flowers-in-full-bloom","title":"2251. Number of Flowers in Full Bloom","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, binary search, sorting, prefix sum, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/1d_difference_array/#2772-apply-operations-to-make-all-array-elements-equal-to-zero","title":"2772. Apply Operations to Make All Array Elements Equal to Zero","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/1d_difference_array/#3229-minimum-operations-to-make-array-equal-to-target","title":"3229. Minimum Operations to Make Array Equal to Target","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, stack, greedy, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/1d_difference_array/#798-smallest-rotation-with-highest-score","title":"798. Smallest Rotation with Highest Score","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/1d_difference_array/#3347-maximum-frequency-of-an-element-after-performing-operations-ii","title":"3347. Maximum Frequency of an Element After Performing Operations II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, sliding window, sorting, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/1d_difference_array/#2528-maximize-the-minimum-powered-city","title":"2528. Maximize the Minimum Powered City","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, greedy, queue, sliding window, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/1d_difference_array/#1674-minimum-moves-to-make-array-complementary","title":"1674. Minimum Moves to Make Array Complementary","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/1d_difference_array/#3362-zero-array-transformation-iii","title":"3362. Zero Array Transformation III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting, heap priority queue, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/1d_difference_array/#3017-count-the-number-of-houses-at-a-certain-distance-ii","title":"3017. Count the Number of Houses at a Certain Distance II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: graph, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/1d_difference_array/#253-meeting-rooms-ii","title":"253. Meeting Rooms II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy, sorting, heap priority queue, prefix sum</p> </li> <li>Given an array of meeting time <code>intervals</code> where <code>intervals[i] = [start_i, end_i]</code>, return the minimum number of conference rooms required.</li> </ul> 253. Meeting Rooms II - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Heap\ndef minMeetingRooms(intervals: List[List[int]]) -&gt; int:\n    if not intervals:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n    minHeap = [intervals[0][1]]\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &gt;= minHeap[0]:\n            heapq.heappop(minHeap)\n        heapq.heappush(minHeap, intervals[i][1])\n\n    return len(minHeap)\n\n\nif __name__ == \"__main__\":\n    intervals = [[0, 30], [5, 10], [15, 20]]\n    assert minMeetingRooms(intervals) == 2\n</code></pre>"},{"location":"content/endlesscheng/1d_difference_array/#370-range-addition","title":"370. Range Addition","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, prefix sum</p> </li> <li>Return the final array after applying all the Adition operations.</li> </ul> 370. Range Addition - Python Solution<pre><code>from typing import List\n\n\n# Difference Array\ndef getModifiedArray(length: int, updates: List[List[int]]) -&gt; List[int]:\n    result = [0 for _ in range(length)]\n\n    for start, end, inc in updates:\n        result[start] += inc\n\n        if end + 1 &lt; length:\n            result[end + 1] -= inc\n\n    for i in range(1, length):\n        result[i] += result[i - 1]\n\n    return result\n\n\nlength = 5\nupdates = [[1, 3, 2], [2, 4, 3], [0, 2, -2]]\nprint(getModifiedArray(length, updates))  # [-2, 0, 3, 5, 3]\n</code></pre>"},{"location":"content/endlesscheng/1d_difference_array/#1989-maximum-number-of-people-that-can-be-caught-in-tag","title":"1989. Maximum Number of People That Can Be Caught in Tag","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/1d_difference_array/#759-employee-free-time","title":"759. Employee Free Time","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, sorting, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/1d_difference_array/#2021-brightest-position-on-street","title":"2021. Brightest Position on Street","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sorting, prefix sum, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/1d_difference_array/#2015-average-height-of-buildings-in-each-segment","title":"2015. Average Height of Buildings in Each Segment","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/1d_difference_array/#2237-count-positions-on-street-with-required-brightness","title":"2237. Count Positions on Street With Required Brightness","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/1d_difference_array/#3009-maximum-number-of-intersections-on-the-chart","title":"3009. Maximum Number of Intersections on the Chart","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, binary indexed tree, geometry</p> </li> </ul>"},{"location":"content/endlesscheng/1d_difference_array/#3279-maximum-total-area-occupied-by-pistons","title":"3279. Maximum Total Area Occupied by Pistons","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, string, simulation, counting, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/1d_prefix_sum/","title":"1D Prefix Sum","text":""},{"location":"content/endlesscheng/1d_prefix_sum/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1310. XOR Queries of a Subarray (Medium)</li> <li> 2438. Range Product Queries of Powers (Medium)</li> <li> 1895. Largest Magic Square (Medium)</li> <li> 1878. Get Biggest Three Rhombus Sums in a Grid (Medium)</li> <li> 1031. Maximum Sum of Two Non-Overlapping Subarrays (Medium)</li> <li> 2245. Maximum Trailing Zeros in a Cornered Path (Medium)</li> <li> 1712. Ways to Split Array Into Three Subarrays (Medium)</li> <li> 1862. Sum of Floored Pairs (Hard)</li> <li> 363. Max Sum of Rectangle No Larger Than K (Hard)</li> <li> 2281. Sum of Total Strength of Wizards (Hard)</li> <li> 3445. Maximum Difference Between Even and Odd Frequency II (Hard)</li> <li> 2983. Palindrome Rearrangement Queries (Hard)</li> <li> 2955. Number of Same-End Substrings (Medium) \ud83d\udc51</li> <li> 1788. Maximize the Beauty of the Garden (Hard) \ud83d\udc51</li> <li> 2819. Minimum Relative Loss After Buying Chocolates (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/1d_prefix_sum/#1310-xor-queries-of-a-subarray","title":"1310. XOR Queries of a Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/1d_prefix_sum/#2438-range-product-queries-of-powers","title":"2438. Range Product Queries of Powers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/1d_prefix_sum/#1895-largest-magic-square","title":"1895. Largest Magic Square","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, matrix, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/1d_prefix_sum/#1878-get-biggest-three-rhombus-sums-in-a-grid","title":"1878. Get Biggest Three Rhombus Sums in a Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, sorting, heap priority queue, matrix, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/1d_prefix_sum/#1031-maximum-sum-of-two-non-overlapping-subarrays","title":"1031. Maximum Sum of Two Non-Overlapping Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/1d_prefix_sum/#2245-maximum-trailing-zeros-in-a-cornered-path","title":"2245. Maximum Trailing Zeros in a Cornered Path","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, matrix, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/1d_prefix_sum/#1712-ways-to-split-array-into-three-subarrays","title":"1712. Ways to Split Array Into Three Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/1d_prefix_sum/#1862-sum-of-floored-pairs","title":"1862. Sum of Floored Pairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, binary search, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/1d_prefix_sum/#363-max-sum-of-rectangle-no-larger-than-k","title":"363. Max Sum of Rectangle No Larger Than K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, matrix, prefix sum, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/1d_prefix_sum/#2281-sum-of-total-strength-of-wizards","title":"2281. Sum of Total Strength of Wizards","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, stack, monotonic stack, prefix sum 2281. Sum of Total Strength of Wizards - Python Solution<pre><code>from itertools import accumulate\nfrom typing import List\n\n\n# Monotonic Stack\ndef totalStrength(strength: List[int]) -&gt; int:\n    n = len(strength)\n    left = [-1 for _ in range(n)]\n    right = [n for _ in range(n)]\n    stack = []\n\n    for i, v in enumerate(strength):\n        while stack and strength[stack[-1]] &gt;= v:\n            right[stack.pop()] = i\n        if stack:\n            left[i] = stack[-1]\n        stack.append(i)\n\n    prefix_sum = list(accumulate(accumulate(strength, initial=0), initial=0))\n\n    ans = 0\n    for i, v in enumerate(strength):\n        l, r = left[i] + 1, right[i] - 1\n        tot = (i - l + 1) * (prefix_sum[r + 2] - prefix_sum[i + 1]) - (\n            r - i + 1\n        ) * (prefix_sum[i + 1] - prefix_sum[l])\n        ans += v * tot\n\n    return ans % (10**9 + 7)\n\n\nstrength = [1, 3, 1, 2]\nprint(totalStrength(strength))  # 44\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/1d_prefix_sum/#3445-maximum-difference-between-even-and-odd-frequency-ii","title":"3445. Maximum Difference Between Even and Odd Frequency II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, sliding window, enumeration, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/1d_prefix_sum/#2983-palindrome-rearrangement-queries","title":"2983. Palindrome Rearrangement Queries","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/1d_prefix_sum/#2955-number-of-same-end-substrings","title":"2955. Number of Same-End Substrings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, counting, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/1d_prefix_sum/#1788-maximize-the-beauty-of-the-garden","title":"1788. Maximize the Beauty of the Garden","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, greedy, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/1d_prefix_sum/#2819-minimum-relative-loss-after-buying-chocolates","title":"2819. Minimum Relative Loss After Buying Chocolates","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, sorting, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/2d_difference_array/","title":"2D Difference Array","text":""},{"location":"content/endlesscheng/2d_difference_array/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2536. Increment Submatrices by One (Medium)</li> <li> 850. Rectangle Area II (Hard)</li> <li> 2132. Stamping the Grid (Hard)</li> </ul>"},{"location":"content/endlesscheng/2d_difference_array/#2536-increment-submatrices-by-one","title":"2536. Increment Submatrices by One","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, matrix, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/2d_difference_array/#850-rectangle-area-ii","title":"850. Rectangle Area II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, segment tree, line sweep, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/2d_difference_array/#2132-stamping-the-grid","title":"2132. Stamping the Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, matrix, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/2d_prefix_sum/","title":"2D Prefix Sum","text":""},{"location":"content/endlesscheng/2d_prefix_sum/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 304. Range Sum Query 2D - Immutable (Medium)</li> <li> 1314. Matrix Block Sum (Medium)</li> <li> 3070. Count Submatrices with Top-Left Element and Sum Less Than k (Medium)</li> <li> 1738. Find Kth Largest XOR Coordinate Value (Medium)</li> <li> 3212. Count Submatrices With Equal Frequency of X and Y (Medium)</li> <li> 1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold (Medium)</li> <li> 221. Maximal Square (Medium)</li> <li> 1277. Count Square Submatrices with All Ones (Medium)</li> <li> 1504. Count Submatrices With All Ones (Medium)</li> <li> 1074. Number of Submatrices That Sum to Target (Hard)</li> <li> 3148. Maximum Difference Score in a Grid (Medium)</li> </ul>"},{"location":"content/endlesscheng/2d_prefix_sum/#304-range-sum-query-2d-immutable","title":"304. Range Sum Query 2D - Immutable","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, design, matrix, prefix sum 304. Range Sum Query 2D - Immutable - Python Solution<pre><code>from typing import List\n\n\nclass NumMatrix:\n\n    def __init__(self, matrix: List[List[int]]):\n        m, n = len(matrix), len(matrix[0])\n        if m == 0 or n == 0:\n            return None\n\n        self.sum = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                self.sum[i][j] = (\n                    matrix[i - 1][j - 1]\n                    + self.sum[i - 1][j]\n                    + self.sum[i][j - 1]\n                    - self.sum[i - 1][j - 1]  # to avoid double counting\n                )\n\n    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -&gt; int:\n        return (\n            self.sum[row2 + 1][col2 + 1]\n            - self.sum[row1][col2 + 1]\n            - self.sum[row2 + 1][col1]\n            + self.sum[row1][col1]\n        )\n\n\nmatrix = [\n    [3, 0, 1, 4, 2],\n    [5, 6, 3, 2, 1],\n    [1, 2, 0, 1, 5],\n    [4, 1, 0, 1, 7],\n    [1, 0, 3, 0, 5],\n]\nobj = NumMatrix(matrix)\nassert obj.sumRegion(2, 1, 4, 3) == 8\nassert obj.sumRegion(1, 1, 2, 2) == 11\nassert obj.sumRegion(1, 2, 2, 4) == 12\nprint(\"PASSED\")\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/2d_prefix_sum/#1314-matrix-block-sum","title":"1314. Matrix Block Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, matrix, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/2d_prefix_sum/#3070-count-submatrices-with-top-left-element-and-sum-less-than-k","title":"3070. Count Submatrices with Top-Left Element and Sum Less Than k","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, matrix, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/2d_prefix_sum/#1738-find-kth-largest-xor-coordinate-value","title":"1738. Find Kth Largest XOR Coordinate Value","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, divide and conquer, bit manipulation, sorting, heap priority queue, matrix, prefix sum, quickselect</p> </li> </ul>"},{"location":"content/endlesscheng/2d_prefix_sum/#3212-count-submatrices-with-equal-frequency-of-x-and-y","title":"3212. Count Submatrices With Equal Frequency of X and Y","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, matrix, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/2d_prefix_sum/#1292-maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold","title":"1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, matrix, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/2d_prefix_sum/#221-maximal-square","title":"221. Maximal Square","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/2d_prefix_sum/#1277-count-square-submatrices-with-all-ones","title":"1277. Count Square Submatrices with All Ones","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/2d_prefix_sum/#1504-count-submatrices-with-all-ones","title":"1504. Count Submatrices With All Ones","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, stack, matrix, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/2d_prefix_sum/#1074-number-of-submatrices-that-sum-to-target","title":"1074. Number of Submatrices That Sum to Target","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, matrix, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/2d_prefix_sum/#3148-maximum-difference-score-in-a-grid","title":"3148. Maximum Difference Score in a Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/adjacent_different/","title":"Adjacent Different","text":""},{"location":"content/endlesscheng/adjacent_different/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2335. Minimum Amount of Time to Fill Cups (Easy)</li> <li> 1753. Maximum Score From Removing Stones (Medium)</li> <li> 1054. Distant Barcodes (Medium)</li> <li> 2856. Minimum Array Length After Pair Removals (Medium)</li> <li> 1953. Maximum Number of Weeks for Which You Can Work (Medium)</li> <li> 767. Reorganize String (Medium)</li> <li> 3139. Minimum Cost to Equalize Array (Hard)</li> <li> 621. Task Scheduler (Medium)</li> <li> 358. Rearrange String k Distance Apart (Hard) \ud83d\udc51</li> <li> 984. String Without AAA or BBB (Medium)</li> <li> 1405. Longest Happy String (Medium)</li> </ul>"},{"location":"content/endlesscheng/adjacent_different/#2335-minimum-amount-of-time-to-fill-cups","title":"2335. Minimum Amount of Time to Fill Cups","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, greedy, sorting, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/adjacent_different/#1753-maximum-score-from-removing-stones","title":"1753. Maximum Score From Removing Stones","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, greedy, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/adjacent_different/#1054-distant-barcodes","title":"1054. Distant Barcodes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, greedy, sorting, heap priority queue, counting</p> </li> </ul>"},{"location":"content/endlesscheng/adjacent_different/#2856-minimum-array-length-after-pair-removals","title":"2856. Minimum Array Length After Pair Removals","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, two pointers, binary search, greedy, counting</p> </li> </ul>"},{"location":"content/endlesscheng/adjacent_different/#1953-maximum-number-of-weeks-for-which-you-can-work","title":"1953. Maximum Number of Weeks for Which You Can Work","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/adjacent_different/#767-reorganize-string","title":"767. Reorganize String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, greedy, sorting, heap priority queue, counting 767. Reorganize String - Python Solution<pre><code>import heapq\nfrom collections import Counter\n\n\ndef reorganizeString(s: str) -&gt; str:\n    if not s:\n        return \"\"\n\n    heap = [(-freq, char) for char, freq in Counter(s).items()]  # max heap\n    heapq.heapify(heap)\n\n    result = []\n    prev_count, prev_char = 0, \"\"\n\n    while heap:\n        count, char = heapq.heappop(heap)  # pop the most frequent character\n        result.append(char)  # append the character to the result\n\n        if (\n            prev_count &lt; 0\n        ):  # if the previous character still has remaining count\n            heapq.heappush(heap, (prev_count, prev_char))\n\n        prev_count = (\n            count + 1\n        )  # update the current character's remaining count\n        prev_char = char  # update the current character\n\n    # check if there is any invalid result\n    if len(result) != len(s):\n        return \"\"\n\n    return \"\".join(result)\n\n\nprint(reorganizeString(\"aab\"))\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/adjacent_different/#3139-minimum-cost-to-equalize-array","title":"3139. Minimum Cost to Equalize Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/adjacent_different/#621-task-scheduler","title":"621. Task Scheduler","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, greedy, sorting, heap priority queue, counting 621. Task Scheduler - Python Solution<pre><code>import heapq\nfrom collections import Counter, deque\nfrom typing import List\n\n\n# Heap\ndef leastInterval1(tasks: List[str], n: int) -&gt; int:\n    count = Counter(tasks)\n    heap = [-c for c in count.values()]\n    heapq.heapify(heap)\n\n    time = 0\n\n    q = deque()\n\n    while heap or q:\n        time += 1\n\n        if heap:\n            cnt = 1 + heapq.heappop(heap)\n            if cnt:\n                q.append((cnt, time + n))\n\n        if q and q[0][1] == time:\n            heapq.heappush(heap, q.popleft()[0])\n\n    return time\n\n\ndef leastInterval2(tasks: List[str], n: int) -&gt; int:\n    freq = Counter(tasks)\n\n    maxExec = max(freq.values())\n    maxCount = sum(1 for v in freq.values() if v == maxExec)\n\n    return max((maxExec - 1) * (n + 1) + maxCount, len(tasks))\n\n\ntasks = [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\"]\nn = 2\nprint(leastInterval1(tasks, n))  # 8\nprint(leastInterval2(tasks, n))  # 8\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/adjacent_different/#358-rearrange-string-k-distance-apart","title":"358. Rearrange String k Distance Apart","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, greedy, sorting, heap priority queue, counting</p> </li> </ul>"},{"location":"content/endlesscheng/adjacent_different/#984-string-without-aaa-or-bbb","title":"984. String Without AAA or BBB","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/adjacent_different/#1405-longest-happy-string","title":"1405. Longest Happy String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, greedy, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/adjacent_elimination/","title":"Adjacent Elimination","text":""},{"location":"content/endlesscheng/adjacent_elimination/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2696. Minimum String Length After Removing Substrings (Easy)</li> <li> 1047. Remove All Adjacent Duplicates In String (Easy)</li> <li> 1544. Make The String Great (Easy)</li> <li> 1003. Check If Word Is Valid After Substitutions (Medium)</li> <li> 2216. Minimum Deletions to Make Array Beautiful (Medium)</li> <li> 1209. Remove All Adjacent Duplicates in String II (Medium)</li> <li> 2211. Count Collisions on a Road (Medium)</li> <li> 735. Asteroid Collision (Medium)</li> <li> 1717. Maximum Score From Removing Substrings (Medium)</li> <li> 2197. Replace Non-Coprime Numbers in Array (Hard)</li> <li> 2751. Robot Collisions (Hard)</li> </ul>"},{"location":"content/endlesscheng/adjacent_elimination/#2696-minimum-string-length-after-removing-substrings","title":"2696. Minimum String Length After Removing Substrings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, stack, simulation</p> </li> </ul>"},{"location":"content/endlesscheng/adjacent_elimination/#1047-remove-all-adjacent-duplicates-in-string","title":"1047. Remove All Adjacent Duplicates In String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, stack</p> </li> </ul>"},{"location":"content/endlesscheng/adjacent_elimination/#1544-make-the-string-great","title":"1544. Make The String Great","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, stack</p> </li> <li>Remove all adjacent characters that are the same and have different cases.</li> <li>Steps for the string <code>leEeetcode</code>:</li> </ul> char action stack l push \"l\" e push \"le\" E pop \"l\" e push \"le\" e push \"lee\" t push \"leet\" c push \"leetc\" o push \"leetco\" d push \"leetcod\" e push \"leetcode\" 1544. Make The String Great - Python Solution<pre><code># Stack\ndef makeGood(s: str) -&gt; str:\n    stack = []\n\n    for i in range(len(s)):\n        if stack and stack[-1] == s[i].swapcase():\n            stack.pop()\n        else:\n            stack.append(s[i])\n    return \"\".join(stack)\n\n\nprint(makeGood(\"leEeetcode\"))  # \"leetcode\"\n</code></pre>"},{"location":"content/endlesscheng/adjacent_elimination/#1003-check-if-word-is-valid-after-substitutions","title":"1003. Check If Word Is Valid After Substitutions","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack</p> </li> </ul>"},{"location":"content/endlesscheng/adjacent_elimination/#2216-minimum-deletions-to-make-array-beautiful","title":"2216. Minimum Deletions to Make Array Beautiful","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/adjacent_elimination/#1209-remove-all-adjacent-duplicates-in-string-ii","title":"1209. Remove All Adjacent Duplicates in String II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack</p> </li> </ul>"},{"location":"content/endlesscheng/adjacent_elimination/#2211-count-collisions-on-a-road","title":"2211. Count Collisions on a Road","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack, simulation</p> </li> </ul>"},{"location":"content/endlesscheng/adjacent_elimination/#735-asteroid-collision","title":"735. Asteroid Collision","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, simulation</p> </li> </ul>"},{"location":"content/endlesscheng/adjacent_elimination/#1717-maximum-score-from-removing-substrings","title":"1717. Maximum Score From Removing Substrings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/adjacent_elimination/#2197-replace-non-coprime-numbers-in-array","title":"2197. Replace Non-Coprime Numbers in Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, stack, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/adjacent_elimination/#2751-robot-collisions","title":"2751. Robot Collisions","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, stack, sorting, simulation</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_basic/","title":"Backtracking Basic","text":""},{"location":"content/endlesscheng/backtracking_basic/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 17. Letter Combinations of a Phone Number (Medium)</li> </ul>"},{"location":"content/endlesscheng/backtracking_basic/#17-letter-combinations-of-a-phone-number","title":"17. Letter Combinations of a Phone Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, backtracking</p> </li> <li>Return all possible letter combinations that the number could represent.</li> </ul> <p></p> 17. Letter Combinations of a Phone Number - Python Solution<pre><code>from typing import List\n\n\n# Backtracking\ndef letterCombinations(digits: str) -&gt; List[str]:\n    letter_map = {\n        \"2\": \"abc\",\n        \"3\": \"def\",\n        \"4\": \"ghi\",\n        \"5\": \"jkl\",\n        \"6\": \"mno\",\n        \"7\": \"pqrs\",\n        \"8\": \"tuv\",\n        \"9\": \"wxyz\",\n    }\n\n    n = len(digits)\n    if n == 0:\n        return []\n\n    res = []\n\n    def dfs(idx, path):\n        if idx == n:\n            res.append(path)\n            return None\n\n        letters = letter_map[digits[idx]]\n\n        for i in range(len(letters)):\n            dfs(idx + 1, path + letters[i])\n\n    dfs(0, \"\")\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert letterCombinations(\"23\") == [\n        \"ad\",\n        \"ae\",\n        \"af\",\n        \"bd\",\n        \"be\",\n        \"bf\",\n        \"cd\",\n        \"ce\",\n        \"cf\",\n    ]\n</code></pre>"},{"location":"content/endlesscheng/backtracking_combination/","title":"Backtracking Combination","text":""},{"location":"content/endlesscheng/backtracking_combination/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 77. Combinations (Medium)</li> <li> 216. Combination Sum III (Medium)</li> <li> 22. Generate Parentheses (Medium)</li> <li> 301. Remove Invalid Parentheses (Hard)</li> </ul>"},{"location":"content/endlesscheng/backtracking_combination/#77-combinations","title":"77. Combinations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: backtracking 77. Combinations - Python Solution<pre><code>import itertools\nfrom typing import List\n\n\n# Backtracking\ndef combine(n: int, k: int) -&gt; List[List[int]]:\n    res = []\n\n    def backtrack(start, path):\n        if len(path) == k:\n            res.append(path[:])\n            return None\n\n        for i in range(start, n + 1):\n            path.append(i)\n            backtrack(i + 1, path)\n            path.pop()\n\n    backtrack(1, [])\n\n    return res\n\n\n# itertools\ndef combineItertools(n: int, k: int) -&gt; List[List[int]]:\n    path = itertools.combinations(range(1, n + 1), k)\n    return path\n\n\nprint(combine(4, 2))\n# [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\nprint(list(combineItertools(4, 2)))\n# [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_combination/#216-combination-sum-iii","title":"216. Combination Sum III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking 216. Combination Sum III - Python Solution<pre><code>import itertools\nfrom typing import List\n\n\n# 1. Backtracking\ndef combinationSum3(k: int, n: int) -&gt; List[List[int]]:\n    path, result = [], []\n\n    def backtracking(start):\n        if len(path) == k and sum(path) == n:\n            result.append(path[:])\n            return\n\n        for i in range(start, 10):\n            path.append(i)\n            backtracking(i + 1)\n            path.pop()\n\n    backtracking(1)\n\n    return result\n\n\n# 2. Itertools\ndef combinationSum3Itertools(k: int, n: int) -&gt; List[List[int]]:\n    combinations = itertools.combinations(range(1, 10), k)\n    result = []\n\n    for i in combinations:\n        if sum(i) == n:\n            result.append(i)\n\n    return result\n\n\nprint(combinationSum3(3, 7))  # [[1, 2, 4]]\nprint(combinationSum3Itertools(3, 7))  # [(1, 2, 4)]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_combination/#22-generate-parentheses","title":"22. Generate Parentheses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming, backtracking 22. Generate Parentheses - Python Solution<pre><code>from typing import List\n\n\n# Backtracking\ndef generateParenthesis1(n: int) -&gt; List[str]:\n    path, res = [], []\n\n    def dfs(openN, closeN):\n        if openN == closeN == n:\n            res.append(\"\".join(path))\n            return\n\n        if openN &lt; n:\n            path.append(\"(\")\n            dfs(openN + 1, closeN)\n            path.pop()\n\n        if closeN &lt; openN:\n            path.append(\")\")\n            dfs(openN, closeN + 1)\n            path.pop()\n\n    dfs(0, 0)\n\n    return res\n\n\n# Backtracking\ndef generateParenthesis2(n: int) -&gt; List[str]:\n    m = n * 2\n    res, path = [], [\"\"] * m\n\n    def dfs(i, left):\n        if i == m:\n            res.append(\"\".join(path))\n            return\n\n        if left &lt; n:\n            path[i] = \"(\"\n            dfs(i + 1, left + 1)\n        if i - left &lt; left:\n            path[i] = \")\"\n            dfs(i + 1, left)\n\n    dfs(0, 0)\n    return res\n\n\nif __name__ == \"__main__\":\n    print(generateParenthesis1(3))\n    # ['((()))', '(()())', '(())()', '()(())', '()()()']\n    print(generateParenthesis2(3))\n    # ['((()))', '(()())', '(())()', '()(())', '()()()']\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_combination/#301-remove-invalid-parentheses","title":"301. Remove Invalid Parentheses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, backtracking, breadth first search</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_exhaustive_search_and_pruning/","title":"Backtracking Exhaustive Search and Pruning","text":""},{"location":"content/endlesscheng/backtracking_exhaustive_search_and_pruning/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3211. Generate Binary Strings Without Adjacent Zeros (Medium)</li> <li> 967. Numbers With Same Consecutive Differences (Medium)</li> <li> 1415. The k-th Lexicographical String of All Happy Strings of Length n (Medium)</li> <li> 1219. Path with Maximum Gold (Medium)</li> <li> 79. Word Search (Medium)</li> <li> 980. Unique Paths III (Hard)</li> <li> 1255. Maximum Score Words Formed by Letters (Hard)</li> <li> 473. Matchsticks to Square (Medium)</li> <li> 212. Word Search II (Hard)</li> <li> 37. Sudoku Solver (Hard)</li> <li> 638. Shopping Offers (Medium)</li> <li> 1240. Tiling a Rectangle with the Fewest Squares (Hard)</li> <li> 679. 24 Game (Hard)</li> <li> 282. Expression Add Operators (Hard)</li> <li> 126. Word Ladder II (Hard)</li> <li> 691. Stickers to Spell Word (Hard)</li> <li> 2056. Number of Valid Move Combinations On Chessboard (Hard)</li> <li> 2386. Find the K-Sum of an Array (Hard)</li> <li> 488. Zuma Game (Hard)</li> <li> 2664. The Knight\u2019s Tour (Medium) \ud83d\udc51</li> <li> 247. Strobogrammatic Number II (Medium) \ud83d\udc51</li> <li> 248. Strobogrammatic Number III (Hard) \ud83d\udc51</li> <li> 411. Minimum Unique Word Abbreviation (Hard) \ud83d\udc51</li> <li> 1088. Confusing Number II (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/backtracking_exhaustive_search_and_pruning/#3211-generate-binary-strings-without-adjacent-zeros","title":"3211. Generate Binary Strings Without Adjacent Zeros","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, backtracking, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_exhaustive_search_and_pruning/#967-numbers-with-same-consecutive-differences","title":"967. Numbers With Same Consecutive Differences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: backtracking, breadth first search</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_exhaustive_search_and_pruning/#1415-the-k-th-lexicographical-string-of-all-happy-strings-of-length-n","title":"1415. The k-th Lexicographical String of All Happy Strings of Length n","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, backtracking</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_exhaustive_search_and_pruning/#1219-path-with-maximum-gold","title":"1219. Path with Maximum Gold","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_exhaustive_search_and_pruning/#79-word-search","title":"79. Word Search","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, backtracking, depth first search, matrix 79. Word Search - Python Solution<pre><code>from typing import List\n\n\ndef exist(board: List[List[str]], word: str) -&gt; bool:\n    m, n = len(board), len(board[0])\n    path = set()\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n\n    def dfs(r, c, i):\n        if i == len(word):\n            return True\n\n        if (\n            r &lt; 0\n            or r &gt;= m\n            or c &lt; 0\n            or c &gt;= n\n            or board[r][c] != word[i]\n            or (r, c) in path\n        ):\n            return False\n\n        path.add((r, c))\n\n        for dr, dc in dirs:\n            if dfs(r + dr, c + dc, i + 1):\n                return True\n\n        path.remove((r, c))\n        return False\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, 0):\n                return True\n\n    return False\n\n\nboard = [\n    [\"A\", \"B\", \"C\", \"E\"],\n    [\"S\", \"F\", \"C\", \"S\"],\n    [\"A\", \"D\", \"E\", \"E\"],\n]\nword = \"ABCCED\"\nprint(exist(board, word))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_exhaustive_search_and_pruning/#980-unique-paths-iii","title":"980. Unique Paths III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, backtracking, bit manipulation, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_exhaustive_search_and_pruning/#1255-maximum-score-words-formed-by-letters","title":"1255. Maximum Score Words Formed by Letters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, dynamic programming, backtracking, bit manipulation, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_exhaustive_search_and_pruning/#473-matchsticks-to-square","title":"473. Matchsticks to Square","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, backtracking, bit manipulation, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_exhaustive_search_and_pruning/#212-word-search-ii","title":"212. Word Search II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, backtracking, trie, matrix 212. Word Search II - Python Solution<pre><code>from typing import List\n\nfrom template import TrieNode\n\n\n# Backtracking + Trie\ndef findWords(board: List[List[str]], words: List[str]) -&gt; List[str]:\n    root = TrieNode()\n    for word in words:\n        root.addWord(word)\n\n    m, n = len(board), len(board[0])\n    result, visit = set(), set()\n\n    def dfs(r, c, node, word):\n        if (\n            r &lt; 0\n            or r &gt;= m\n            or c &lt; 0\n            or c &gt;= n\n            or (r, c) in visit\n            or board[r][c] not in node.children\n        ):\n            return None\n\n        visit.add((r, c))\n\n        node = node.children[board[r][c]]\n        word += board[r][c]\n        if node.isWord:\n            result.add(word)\n\n        dfs(r - 1, c, node, word)\n        dfs(r + 1, c, node, word)\n        dfs(r, c - 1, node, word)\n        dfs(r, c + 1, node, word)\n\n        visit.remove((r, c))\n\n    for r in range(m):\n        for c in range(n):\n            dfs(r, c, root, \"\")\n\n    return list(result)\n\n\nboard = [\n    [\"o\", \"a\", \"a\", \"n\"],\n    [\"e\", \"t\", \"a\", \"e\"],\n    [\"i\", \"h\", \"k\", \"r\"],\n    [\"i\", \"f\", \"l\", \"v\"],\n]\nwords = [\"oath\", \"pea\", \"eat\", \"rain\"]\nprint(findWords(board, words))\n# ['eat', 'oath']\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_exhaustive_search_and_pruning/#37-sudoku-solver","title":"37. Sudoku Solver","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, backtracking, matrix</p> </li> <li>Sudoku Solver</li> <li>\u89e3\u6570\u72ec</li> <li>Hard</li> </ul> 37. Sudoku Solver - Python Solution<pre><code>from pprint import pprint\nfrom typing import List\n\n\n# Backtracking - Board\ndef solveSudoku(board: List[List[str]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n\n    def backtracking(board: List[List[str]]) -&gt; bool:\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] != \".\":\n                    continue\n                for k in range(1, 10):\n                    if is_valid(i, j, k, board):\n                        board[i][j] = str(k)\n                        if backtracking(board):\n                            return True\n                        board[i][j] = \".\"\n                return False\n        return True\n\n    def is_valid(row: int, col: int, val: int, board: List[List[str]]) -&gt; bool:\n        for i in range(9):\n            if board[row][i] == str(val):\n                return False\n        for j in range(9):\n            if board[j][col] == str(val):\n                return False\n        start_row = (row // 3) * 3\n        start_col = (col // 3) * 3\n        for i in range(start_row, start_row + 3):\n            for j in range(start_col, start_col + 3):\n                if board[i][j] == str(val):\n                    return False\n        return True\n\n    backtracking(board)\n\n\nboard = [\n    [\"5\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],\n    [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n    [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n    [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n    [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n    [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n    [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"],\n    [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n    [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"],\n]\n\nsolveSudoku(board)\npprint(board)\n# [['5', '3', '4', '6', '7', '8', '9', '1', '2'],\n#  ['6', '7', '2', '1', '9', '5', '3', '4', '8'],\n#  ['1', '9', '8', '3', '4', '2', '5', '6', '7'],\n#  ['8', '5', '9', '7', '6', '1', '4', '2', '3'],\n#  ['4', '2', '6', '8', '5', '3', '7', '9', '1'],\n#  ['7', '1', '3', '9', '2', '4', '8', '5', '6'],\n#  ['9', '6', '1', '5', '3', '7', '2', '8', '4'],\n#  ['2', '8', '7', '4', '1', '9', '6', '3', '5'],\n#  ['3', '4', '5', '2', '8', '6', '1', '7', '9']]\n</code></pre>"},{"location":"content/endlesscheng/backtracking_exhaustive_search_and_pruning/#638-shopping-offers","title":"638. Shopping Offers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, backtracking, bit manipulation, memoization, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_exhaustive_search_and_pruning/#1240-tiling-a-rectangle-with-the-fewest-squares","title":"1240. Tiling a Rectangle with the Fewest Squares","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: backtracking</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_exhaustive_search_and_pruning/#679-24-game","title":"679. 24 Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, backtracking</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_exhaustive_search_and_pruning/#282-expression-add-operators","title":"282. Expression Add Operators","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, string, backtracking</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_exhaustive_search_and_pruning/#126-word-ladder-ii","title":"126. Word Ladder II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, backtracking, breadth first search</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_exhaustive_search_and_pruning/#691-stickers-to-spell-word","title":"691. Stickers to Spell Word","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, string, dynamic programming, backtracking, bit manipulation, memoization, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_exhaustive_search_and_pruning/#2056-number-of-valid-move-combinations-on-chessboard","title":"2056. Number of Valid Move Combinations On Chessboard","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, backtracking, simulation</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_exhaustive_search_and_pruning/#2386-find-the-k-sum-of-an-array","title":"2386. Find the K-Sum of an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, sorting, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_exhaustive_search_and_pruning/#488-zuma-game","title":"488. Zuma Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming, stack, breadth first search, memoization</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_exhaustive_search_and_pruning/#2664-the-knights-tour","title":"2664. The Knight\u2019s Tour","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_exhaustive_search_and_pruning/#247-strobogrammatic-number-ii","title":"247. Strobogrammatic Number II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, recursion</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_exhaustive_search_and_pruning/#248-strobogrammatic-number-iii","title":"248. Strobogrammatic Number III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, recursion</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_exhaustive_search_and_pruning/#411-minimum-unique-word-abbreviation","title":"411. Minimum Unique Word Abbreviation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, backtracking, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_exhaustive_search_and_pruning/#1088-confusing-number-ii","title":"1088. Confusing Number II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, backtracking</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_partition/","title":"Backtracking Partition","text":""},{"location":"content/endlesscheng/backtracking_partition/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 131. Palindrome Partitioning (Medium)</li> <li> 2698. Find the Punishment Number of an Integer (Medium)</li> <li> 1593. Split a String Into the Max Number of Unique Substrings (Medium)</li> <li> 1849. Splitting a String Into Descending Consecutive Values (Medium)</li> <li> 306. Additive Number (Medium)</li> <li> 842. Split Array into Fibonacci Sequence (Medium)</li> <li> 93. Restore IP Addresses (Medium)</li> <li> 816. Ambiguous Coordinates (Medium)</li> <li> 140. Word Break II (Hard)</li> <li> 291. Word Pattern II (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/backtracking_partition/#131-palindrome-partitioning","title":"131. Palindrome Partitioning","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming, backtracking 131. Palindrome Partitioning - Python Solution<pre><code>from typing import List\n\n\n# Backtracking\ndef partition(s: str) -&gt; List[List[str]]:\n    n = len(s)\n    res, path = [], []\n\n    def dfs(start):\n        if start == n:\n            res.append(path.copy())\n            return\n\n        for end in range(start, n):\n            cur = s[start : end + 1]\n            if cur == cur[::-1]:\n                path.append(cur)\n                dfs(end + 1)\n                path.pop()\n\n    dfs(0)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(partition(\"aab\"))\n    # [['a', 'a', 'b'], ['aa', 'b']]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_partition/#2698-find-the-punishment-number-of-an-integer","title":"2698. Find the Punishment Number of an Integer","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, backtracking</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_partition/#1593-split-a-string-into-the-max-number-of-unique-substrings","title":"1593. Split a String Into the Max Number of Unique Substrings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, backtracking</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_partition/#1849-splitting-a-string-into-descending-consecutive-values","title":"1849. Splitting a String Into Descending Consecutive Values","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, backtracking</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_partition/#306-additive-number","title":"306. Additive Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, backtracking</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_partition/#842-split-array-into-fibonacci-sequence","title":"842. Split Array into Fibonacci Sequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, backtracking</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_partition/#93-restore-ip-addresses","title":"93. Restore IP Addresses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, backtracking 93. Restore IP Addresses - Python Solution<pre><code>from typing import List\n\n\ndef restoreIpAddresses(s: str) -&gt; List[str]:\n    result = []\n\n    def backtracking(start_index, point_num, current, result):\n        # stop condition\n        if point_num == 3:\n            if is_valid(s, start_index, len(s) - 1):\n                current += s[start_index:]\n                result.append(current)\n            return\n\n        for i in range(start_index, len(s)):\n            if is_valid(s, start_index, i):\n                sub = s[start_index : i + 1]\n                backtracking(i + 1, point_num + 1, current + sub + \".\", result)\n            else:\n                break\n\n    def is_valid(s, start, end):\n        if start &gt; end:\n            return False\n\n        if s[start] == \"0\" and start != end:\n            return False\n\n        num = 0\n        for i in range(start, end + 1):\n            if not s[i].isdigit():\n                return False\n            num = num * 10 + int(s[i])\n            if num &gt; 255:\n                return False\n        return True\n\n    backtracking(0, 0, \"\", result)\n\n    return result\n\n\nprint(restoreIpAddresses(\"25525511135\"))\n# ['255.255.11.135', '255.255.111.35']\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_partition/#816-ambiguous-coordinates","title":"816. Ambiguous Coordinates","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, backtracking, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_partition/#140-word-break-ii","title":"140. Word Break II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, string, dynamic programming, backtracking, trie, memoization</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_partition/#291-word-pattern-ii","title":"291. Word Pattern II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, backtracking</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_permutation/","title":"Backtracking Permutation","text":""},{"location":"content/endlesscheng/backtracking_permutation/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 46. Permutations (Medium)</li> <li> 3376. Minimum Time to Break Locks I (Medium)</li> <li> 51. N-Queens (Hard)</li> <li> 52. N-Queens II (Hard)</li> <li> 2850. Minimum Moves to Spread Stones Over Grid (Medium)</li> <li> 1718. Construct the Lexicographically Largest Valid Sequence (Medium)</li> <li> 1307. Verbal Arithmetic Puzzle (Hard)</li> <li> 2014. Longest Subsequence Repeated k Times (Hard)</li> <li> 267. Palindrome Permutation II (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/backtracking_permutation/#46-permutations","title":"46. Permutations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking 46. Permutations - Python Solution<pre><code>from typing import List\n\n\n# Backtracking\ndef permute(nums: List[int]) -&gt; List[List[int]]:\n    n = len(nums)\n    path, res = [], []\n    used = [False for _ in range(n)]\n\n    def dfs(x: int):\n        if x == n:\n            res.append(path[:])\n            return\n\n        for i in range(n):\n            if used[i]:\n                continue\n            used[i] = True\n            path.append(nums[i])\n            dfs(x + 1)\n            path.pop()\n            used[i] = False\n\n    dfs(0)\n\n    return res\n\n\nprint(permute([1, 2, 3]))\n# [[1, 2, 3], [1, 3, 2], [2, 1, 3],\n#  [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_permutation/#3376-minimum-time-to-break-locks-i","title":"3376. Minimum Time to Break Locks I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, backtracking, bit manipulation, depth first search, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_permutation/#51-n-queens","title":"51. N-Queens","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, backtracking</p> </li> <li>Hard</li> <li>N-Queens</li> <li>N \u7687\u540e</li> </ul> 51. N-Queens - Python Solution<pre><code>from typing import List\n\n\n# Backtracking\ndef solveNQueens(n: int) -&gt; List[List[str]]:\n    res = []\n    board = [\".\" * n for _ in range(n)]\n\n    def dfs(row):\n        if row == n:\n            res.append(board[:])\n            return None\n        for col in range(n):\n            if is_valid(row, col, board):\n                board[row] = board[row][:col] + \"Q\" + board[row][col + 1 :]\n                dfs(row + 1)\n                board[row] = board[row][:col] + \".\" + board[row][col + 1 :]\n\n    def is_valid(row, col, chessboard):\n        for i in range(row):\n            if chessboard[i][col] == \"Q\":\n                return False\n\n        i, j = row - 1, col - 1\n        while i &gt;= 0 and j &gt;= 0:\n            if chessboard[i][j] == \"Q\":\n                return False\n            i -= 1\n            j -= 1\n\n        i, j = row - 1, col + 1\n        while i &gt;= 0 and j &lt; len(chessboard):\n            if chessboard[i][j] == \"Q\":\n                return False\n            i -= 1\n            j += 1\n\n        return True\n\n    dfs(0)\n\n    return [[\"\".join(row) for row in i] for i in res]\n\n\n# Backtracking\ndef solveNQueens2(n: int) -&gt; List[List[str]]:\n    res = []\n    queens = [0] * n\n    col = [False] * n\n    diag1 = [False] * (n * 2 - 1)\n    diag2 = [False] * (n * 2 - 1)\n\n    def dfs(r: int) -&gt; None:\n        if r == n:\n            res.append([\".\" * c + \"Q\" + \".\" * (n - 1 - c) for c in queens])\n            return\n\n        for c, ok in enumerate(col):\n            if not ok and not diag1[r + c] and not diag2[r - c]:\n                queens[r] = c\n                col[c] = diag1[r + c] = diag2[r - c] = True\n                dfs(r + 1)\n                col[c] = diag1[r + c] = diag2[r - c] = False\n\n    dfs(0)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(solveNQueens(4))\n    # [['.Q..', '...Q', 'Q...', '..Q.'],\n    #  ['..Q.', 'Q...', '...Q', '.Q..']]\n    print(solveNQueens(1))\n    # [['Q']]\n    print(solveNQueens2(4))\n    # [['.Q..', '...Q', 'Q...', '..Q.'],\n    #  ['..Q.', 'Q...', '...Q', '.Q..']]\n    print(solveNQueens2(1))\n    # [['Q']]\n</code></pre>"},{"location":"content/endlesscheng/backtracking_permutation/#52-n-queens-ii","title":"52. N-Queens II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: backtracking</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_permutation/#2850-minimum-moves-to-spread-stones-over-grid","title":"2850. Minimum Moves to Spread Stones Over Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, breadth first search, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_permutation/#1718-construct-the-lexicographically-largest-valid-sequence","title":"1718. Construct the Lexicographically Largest Valid Sequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_permutation/#1307-verbal-arithmetic-puzzle","title":"1307. Verbal Arithmetic Puzzle","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, string, backtracking</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_permutation/#2014-longest-subsequence-repeated-k-times","title":"2014. Longest Subsequence Repeated k Times","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, backtracking, greedy, counting, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_permutation/#267-palindrome-permutation-ii","title":"267. Palindrome Permutation II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, backtracking</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_subset/","title":"Backtracking Subset","text":""},{"location":"content/endlesscheng/backtracking_subset/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 78. Subsets (Medium)</li> <li> 784. Letter Case Permutation (Medium)</li> <li> 1286. Iterator for Combination (Medium)</li> <li> 494. Target Sum (Medium)</li> <li> 2397. Maximum Rows Covered by Columns (Medium)</li> <li> 1239. Maximum Length of a Concatenated String with Unique Characters (Medium)</li> <li> 2212. Maximum Points in an Archery Competition (Medium)</li> <li> 1255. Maximum Score Words Formed by Letters (Hard)</li> <li> 2151. Maximum Good People Based on Statements (Hard)</li> <li> 2597. The Number of Beautiful Subsets (Medium)</li> <li> 2959. Number of Possible Sets of Closing Branches (Hard)</li> <li> 1601. Maximum Number of Achievable Transfer Requests (Hard)</li> <li> 1617. Count Subtrees With Max Distance Between Cities (Hard)</li> <li> 320. Generalized Abbreviation (Medium) \ud83d\udc51</li> <li> 254. Factor Combinations (Medium) \ud83d\udc51</li> <li> 39. Combination Sum (Medium)</li> </ul>"},{"location":"content/endlesscheng/backtracking_subset/#78-subsets","title":"78. Subsets","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking, bit manipulation 78. Subsets - Python Solution<pre><code>from typing import List\n\n\n# Iterative Inclusion Backtracking\ndef subsets_iterative_inclusion(nums: List[int]) -&gt; List[List[int]]:\n    n = len(nums)\n    res, path = [], []\n\n    def dfs(i):\n        res.append(path.copy())\n\n        for j in range(i, n):\n            path.append(nums[j])\n            dfs(j + 1)\n            path.pop()\n\n    dfs(0)\n\n    return res\n\n\n# Binary Decision Backtracking\ndef subsets_binary_decision(nums: List[int]) -&gt; List[List[int]]:\n    n = len(nums)\n    res, path = [], []\n\n    def dfs(i):\n        if i == n:\n            res.append(path.copy())\n            return\n\n        # Exclude\n        dfs(i + 1)\n\n        # Include\n        path.append(nums[i])\n        dfs(i + 1)\n        path.pop()\n\n    dfs(0)\n\n    return res\n\n\nprint(subsets_iterative_inclusion([1, 2, 3]))\n# [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]\nprint(subsets_binary_decision([1, 2, 3]))\n# [[], [3], [2], [2, 3], [1], [1, 3], [1, 2], [1, 2, 3]]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_subset/#784-letter-case-permutation","title":"784. Letter Case Permutation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, backtracking, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_subset/#1286-iterator-for-combination","title":"1286. Iterator for Combination","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, backtracking, design, iterator</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_subset/#494-target-sum","title":"494. Target Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, backtracking 494. Target Sum - Python Solution<pre><code>from typing import List\n\n\ndef findTargetSumWays(nums: List[int], target: int) -&gt; int:\n\n    totalSum = sum(nums)\n\n    if abs(target) &gt; totalSum:\n        return 0\n    if (target + totalSum) % 2 == 1:\n        return 0\n\n    targetSum = (target + totalSum) // 2\n    dp = [0] * (targetSum + 1)\n    dp[0] = 1\n\n    for i in range(len(nums)):\n        for j in range(targetSum, nums[i] - 1, -1):\n            dp[j] += dp[j - nums[i]]\n\n    return dp[targetSum]\n\n\nnums = [1, 1, 1, 1, 1]\ntarget = 3\nprint(findTargetSumWays(nums, target))  # 5\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_subset/#2397-maximum-rows-covered-by-columns","title":"2397. Maximum Rows Covered by Columns","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking, bit manipulation, matrix, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_subset/#1239-maximum-length-of-a-concatenated-string-with-unique-characters","title":"1239. Maximum Length of a Concatenated String with Unique Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, backtracking, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_subset/#2212-maximum-points-in-an-archery-competition","title":"2212. Maximum Points in an Archery Competition","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking, bit manipulation, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_subset/#1255-maximum-score-words-formed-by-letters","title":"1255. Maximum Score Words Formed by Letters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, dynamic programming, backtracking, bit manipulation, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_subset/#2151-maximum-good-people-based-on-statements","title":"2151. Maximum Good People Based on Statements","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, backtracking, bit manipulation, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_subset/#2597-the-number-of-beautiful-subsets","title":"2597. The Number of Beautiful Subsets","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, dynamic programming, backtracking, sorting, combinatorics 2597. The Number of Beautiful Subsets - C++ Solution<pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Solution {\n   public:\n    int beautifulSubsets(vector&lt;int&gt;&amp; nums, int k) {\n        int res = 0;\n        unordered_map&lt;int, int&gt; cnt;\n\n        auto dfs = [&amp;](auto&amp;&amp; self, int i) -&gt; void {\n            if (i == (int)nums.size()) {\n                res++;\n                return;\n            }\n            self(self, i + 1);  // Skip nums[i]\n            int x = nums[i];\n            if (cnt[x - k] == 0 &amp;&amp; cnt[x + k] == 0) {\n                cnt[x]++;\n                self(self, i + 1);  // Include nums[i]\n                cnt[x]--;           // Backtrack\n            }\n        };\n\n        dfs(dfs, 0);\n\n        return res - 1;\n    }\n};\n\nint main() {\n    Solution sol;\n    vector&lt;int&gt; nums = {1, 2, 3, 4};\n    int k = 1;\n    cout &lt;&lt; sol.beautifulSubsets(nums, k) &lt;&lt; endl;\n    return 0;\n}\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_subset/#2959-number-of-possible-sets-of-closing-branches","title":"2959. Number of Possible Sets of Closing Branches","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: bit manipulation, graph, heap priority queue, enumeration, shortest path</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_subset/#1601-maximum-number-of-achievable-transfer-requests","title":"1601. Maximum Number of Achievable Transfer Requests","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, backtracking, bit manipulation, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_subset/#1617-count-subtrees-with-max-distance-between-cities","title":"1617. Count Subtrees With Max Distance Between Cities","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, bit manipulation, tree, enumeration, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_subset/#320-generalized-abbreviation","title":"320. Generalized Abbreviation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, backtracking, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_subset/#254-factor-combinations","title":"254. Factor Combinations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: backtracking</p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_subset/#39-combination-sum","title":"39. Combination Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking 39. Combination Sum - Python Solution<pre><code>from typing import List\n\n\ndef combinationSum(candidates: List[int], target: int) -&gt; List[List[int]]:\n    n = len(candidates)\n    res, path = [], []\n\n    def dfs(total, start):\n        if total &gt; target:\n            return\n        if total == target:\n            res.append(path.copy())\n            return\n\n        for i in range(start, n):\n            total += candidates[i]\n            path.append(candidates[i])\n            dfs(total, i)\n            total -= candidates[i]\n            path.pop()\n\n    dfs(0, 0)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(combinationSum([2, 3, 5], 8))\n    # [[2, 2, 2, 2], [2, 3, 3], [3, 5]]\n    print(combinationSum([2, 3, 6, 7], 7))\n    # [[2, 2, 3], [7]]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_with_duplicates/","title":"Backtracking with Duplicates","text":""},{"location":"content/endlesscheng/backtracking_with_duplicates/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 90. Subsets II (Medium)</li> <li> 40. Combination Sum II (Medium)</li> <li> 491. Non-decreasing Subsequences (Medium)</li> <li> 47. Permutations II (Medium)</li> <li> 1079. Letter Tile Possibilities (Medium)</li> </ul>"},{"location":"content/endlesscheng/backtracking_with_duplicates/#90-subsets-ii","title":"90. Subsets II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking, bit manipulation 90. Subsets II - Python Solution<pre><code>from typing import List\n\n\ndef subsetsWithDup(nums: List[int]) -&gt; List[List[int]]:\n    path, result = [], []\n    nums.sort()\n\n    def backtracking(startIndex):\n        if path not in result:\n            result.append(path[:])\n\n        for i in range(startIndex, len(nums)):\n            path.append(nums[i])\n            backtracking(i + 1)\n            path.pop()\n\n    backtracking(startIndex=0)\n\n    return result\n\n\nprint(subsetsWithDup([1, 2, 2]))\n# [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_with_duplicates/#40-combination-sum-ii","title":"40. Combination Sum II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking 40. Combination Sum II - Python Solution<pre><code>from typing import List\n\n\ndef combinationSum2(candidates: List[int], target: int) -&gt; List[List[int]]:\n    result, path = [], []\n    candidates.sort()\n\n    def backtracking(total, start):\n        if total == target:\n            result.append(path[:])\n            return None\n\n        for i in range(start, len(candidates)):\n\n            if i &gt; start and candidates[i] == candidates[i - 1]:\n                continue\n\n            if total + candidates[i] &gt; target:\n                break\n\n            total += candidates[i]\n            path.append(candidates[i])\n            backtracking(total, i + 1)\n            total -= candidates[i]\n            path.pop()\n\n    backtracking(0, 0)\n\n    return result\n\n\nprint(combinationSum2([10, 1, 2, 7, 6, 1, 5], 8))\n# [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_with_duplicates/#491-non-decreasing-subsequences","title":"491. Non-decreasing Subsequences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, backtracking, bit manipulation 491. Non-decreasing Subsequences - Python Solution<pre><code>from typing import List\n\n\ndef findSubsequences(nums: List[int]) -&gt; List[List[int]]:\n    path, result = [], []\n\n    def backtracking(startIndex):\n        if len(path) &gt; 1:\n            result.append(path[:])\n\n        used = set()\n        for i in range(startIndex, len(nums)):\n\n            if (path and nums[i] &lt; path[-1]) or nums[i] in used:\n                continue\n\n            used.add(nums[i])\n            path.append(nums[i])\n            backtracking(i + 1)\n            path.pop()\n\n    backtracking(0)\n\n    return result\n\n\nprint(findSubsequences([4, 6, 7, 7]))\n# [[4, 6], [4, 6, 7], [4, 6, 7, 7], [4, 7], [4, 7, 7], [6, 7], [6, 7, 7], [7, 7]]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_with_duplicates/#47-permutations-ii","title":"47. Permutations II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking, sorting 47. Permutations II - Python Solution<pre><code>from typing import List\n\n\ndef permuteUnique(nums: List[int]) -&gt; List[List[int]]:\n    nums.sort()\n    path, result = [], []\n    used = [False for _ in range(len(nums))]\n\n    def backtracking():\n        if len(path) == len(nums):\n            result.append(path[:])\n\n        for i in range(len(nums)):\n            if used[i]:\n                continue\n            if i &gt; 0 and nums[i] == nums[i - 1] and not used[i - 1]:\n                continue\n\n            used[i] = True\n            path.append(nums[i])\n            backtracking()\n            path.pop()\n            used[i] = False\n\n    backtracking()\n\n    return result\n\n\nprint(permuteUnique([1, 1, 2]))\n# [[1, 1, 2], [1, 2, 1], [2, 1, 1]]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/backtracking_with_duplicates/#1079-letter-tile-possibilities","title":"1079. Letter Tile Possibilities","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, backtracking, counting</p> </li> </ul>"},{"location":"content/endlesscheng/ball_placement_problems/","title":"Ball Placement Problems","text":""},{"location":"content/endlesscheng/ball_placement_problems/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1641. Count Sorted Vowel Strings (Medium)</li> <li> 1621. Number of Sets of K Non-Overlapping Line Segments (Medium)</li> <li> 920. Number of Music Playlists (Hard)</li> <li> 1735. Count Ways to Make Array With Product (Hard)</li> <li> 2338. Count the Number of Ideal Arrays (Hard)</li> </ul>"},{"location":"content/endlesscheng/ball_placement_problems/#1641-count-sorted-vowel-strings","title":"1641. Count Sorted Vowel Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, combinatorics</p> </li> </ul>"},{"location":"content/endlesscheng/ball_placement_problems/#1621-number-of-sets-of-k-non-overlapping-line-segments","title":"1621. Number of Sets of K Non-Overlapping Line Segments","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, combinatorics</p> </li> </ul>"},{"location":"content/endlesscheng/ball_placement_problems/#920-number-of-music-playlists","title":"920. Number of Music Playlists","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, dynamic programming, combinatorics</p> </li> </ul>"},{"location":"content/endlesscheng/ball_placement_problems/#1735-count-ways-to-make-array-with-product","title":"1735. Count Ways to Make Array With Product","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, dynamic programming, combinatorics, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/ball_placement_problems/#2338-count-the-number-of-ideal-arrays","title":"2338. Count the Number of Ideal Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, dynamic programming, combinatorics, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/basic_inequality/","title":"Basic Inequality","text":""},{"location":"content/endlesscheng/basic_inequality/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3081. Replace Question Marks in String to Minimize Its Value (Medium)</li> <li> 1969. Minimum Non-Zero Product of the Array Elements (Medium)</li> <li> 2939. Maximum Xor Product (Medium)</li> <li> 2897. Apply Operations on Array to Maximize Sum of Squares (Hard)</li> </ul>"},{"location":"content/endlesscheng/basic_inequality/#3081-replace-question-marks-in-string-to-minimize-its-value","title":"3081. Replace Question Marks in String to Minimize Its Value","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, greedy, sorting, heap priority queue, counting</p> </li> </ul>"},{"location":"content/endlesscheng/basic_inequality/#1969-minimum-non-zero-product-of-the-array-elements","title":"1969. Minimum Non-Zero Product of the Array Elements","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, greedy, recursion</p> </li> </ul>"},{"location":"content/endlesscheng/basic_inequality/#2939-maximum-xor-product","title":"2939. Maximum Xor Product","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, greedy, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/basic_inequality/#2897-apply-operations-on-array-to-maximize-sum-of-squares","title":"2897. Apply Operations on Array to Maximize Sum of Squares","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, greedy, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bfs_basics/","title":"BFS Basics","text":""},{"location":"content/endlesscheng/bfs_basics/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3243. Shortest Distance After Road Addition Queries I (Medium)</li> <li> 1311. Get Watched Videos by Your Friends (Medium)</li> <li> 1129. Shortest Path with Alternating Colors (Medium)</li> <li> 1298. Maximum Candies You Can Get from Boxes (Hard)</li> <li> 2039. The Time When the Network Becomes Idle (Medium)</li> <li> 2608. Shortest Cycle in a Graph (Hard)</li> <li> 815. Bus Routes (Hard)</li> </ul>"},{"location":"content/endlesscheng/bfs_basics/#3243-shortest-distance-after-road-addition-queries-i","title":"3243. Shortest Distance After Road Addition Queries I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, breadth first search, graph</p> </li> <li><code>n=5</code>, <code>queries = [[2,4],[0,2],[0,4]]</code></li> <li></li> <li></li> <li></li> <li>Output: <code>[3,2,1]</code></li> </ul> 3243. Shortest Distance After Road Addition Queries I - Python Solution<pre><code>from collections import deque\nfrom itertools import count\nfrom typing import List\n\n\n# BFS\ndef shortestDistanceAfterQueries(\n    n: int, queries: List[List[int]]\n) -&gt; List[int]:\n    g = [[] for _ in range(n)]\n    for i in range(n - 1):\n        g[i].append(i + 1)\n\n    vis = [-1 for _ in range(n)]\n\n    def bfs(i: int) -&gt; int:\n        q = deque([0])\n        for step in count(1):\n            tmp = q\n            q = deque()\n            for x in tmp:\n                for y in g[x]:\n                    if y == n - 1:\n                        return step\n                    if vis[y] != i:\n                        vis[y] = i\n                        q.append(y)\n        return -1\n\n    res = [0] * len(queries)\n    for i, (l, r) in enumerate(queries):\n        g[l].append(r)\n        res[i] = bfs(i)\n\n    return res\n\n\nn = 5\nqueries = [[2, 4], [0, 2], [0, 4]]\nprint(shortestDistanceAfterQueries(n, queries))  # [3, 2, 1]\n</code></pre>"},{"location":"content/endlesscheng/bfs_basics/#1311-get-watched-videos-by-your-friends","title":"1311. Get Watched Videos by Your Friends","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, breadth first search, graph, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/bfs_basics/#1129-shortest-path-with-alternating-colors","title":"1129. Shortest Path with Alternating Colors","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: breadth first search, graph 1129. Shortest Path with Alternating Colors - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef shortestAlternatingPaths(\n    n: int, redEdges: List[List[int]], blueEdges: List[List[int]]\n) -&gt; List[int]:\n    red_graph = defaultdict(list)\n    blue_graph = defaultdict(list)\n\n    for u, v in redEdges:\n        red_graph[u].append(v)\n    for u, v in blueEdges:\n        blue_graph[u].append(v)\n\n    answer = [-1 for _ in range(n)]\n    q = deque([(0, 0, 0), (0, 0, 1)])  # (node, distance, color)\n    visited = set()\n\n    while q:\n        node, dist, color = q.popleft()\n        if (node, color) in visited:\n            continue\n        visited.add((node, color))\n        if answer[node] == -1:\n            answer[node] = dist\n        if color == 0:\n            for neighbor in blue_graph[node]:\n                q.append((neighbor, dist + 1, 1))\n        else:\n            for neighbor in red_graph[node]:\n                q.append((neighbor, dist + 1, 0))\n\n    return answer\n\n\nn = 3\nred_edges = [[0, 1], [1, 2]]\nblue_edges = []\nprint(shortestAlternatingPaths(n, red_edges, blue_edges))  # [0, 1, -1]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/bfs_basics/#1298-maximum-candies-you-can-get-from-boxes","title":"1298. Maximum Candies You Can Get from Boxes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, breadth first search, graph</p> </li> </ul>"},{"location":"content/endlesscheng/bfs_basics/#2039-the-time-when-the-network-becomes-idle","title":"2039. The Time When the Network Becomes Idle","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, breadth first search, graph</p> </li> </ul>"},{"location":"content/endlesscheng/bfs_basics/#2608-shortest-cycle-in-a-graph","title":"2608. Shortest Cycle in a Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: breadth first search, graph</p> </li> </ul>"},{"location":"content/endlesscheng/bfs_basics/#815-bus-routes","title":"815. Bus Routes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, breadth first search 815. Bus Routes - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef numBusesToDestination(\n    routes: List[List[int]], source: int, target: int\n) -&gt; int:\n    if source == target:\n        return 0\n\n    graph = defaultdict(set)  # {stop: buses}\n    for buses, route in enumerate(routes):\n        for stop in route:\n            graph[stop].add(buses)\n\n    q = deque([(source, 0)])  # (stop, bus)\n    visited_stops = set([source])\n    visited_buses = set()\n\n    while q:\n        stop, bus = q.popleft()\n\n        if stop == target:\n            return bus\n\n        for buses in graph[stop]:\n            if buses not in visited_buses:\n                visited_buses.add(buses)\n                for next_stop in routes[buses]:\n                    if next_stop not in visited_stops:\n                        visited_stops.add(next_stop)\n                        q.append((next_stop, bus + 1))\n\n    return -1\n\n\nroutes = [[1, 2, 7], [3, 6, 7]]\nsource = 1\ntarget = 6\nprint(numBusesToDestination(routes, source, target))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_advanced/","title":"Binary Search Advanced","text":""},{"location":"content/endlesscheng/binary_search_advanced/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2300. Successful Pairs of Spells and Potions (Medium)</li> <li> 1385. Find the Distance Value Between Two Arrays (Easy)</li> <li> 2389. Longest Subsequence With Limited Sum (Easy)</li> <li> 1170. Compare Strings by Frequency of the Smallest Character (Medium)</li> <li> 2080. Range Frequency Queries (Medium)</li> <li> 2563. Count the Number of Fair Pairs (Medium)</li> <li> 2070. Most Beautiful Item for Each Query (Medium)</li> <li> 981. Time Based Key-Value Store (Medium)</li> <li> 1146. Snapshot Array (Medium)</li> <li> 658. Find K Closest Elements (Medium)</li> <li> 1818. Minimum Absolute Sum Difference (Medium)</li> <li> 911. Online Election (Medium)</li> <li> 1182. Shortest Distance to Target Color (Medium) \ud83d\udc51</li> <li> 2819. Minimum Relative Loss After Buying Chocolates (Hard) \ud83d\udc51</li> <li> 1287. Element Appearing More Than 25% In Sorted Array (Easy)</li> <li> 1150. Check If a Number Is Majority Element in a Sorted Array (Easy) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/binary_search_advanced/#2300-successful-pairs-of-spells-and-potions","title":"2300. Successful Pairs of Spells and Potions","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, sorting 2300. Successful Pairs of Spells and Potions - Python Solution<pre><code>import bisect\nfrom typing import List\n\n\n# Binary Search\ndef successfulPairs(\n    spells: List[int], potions: List[int], success: int\n) -&gt; List[int]:\n    potions.sort()\n    res = []\n    n = len(potions)\n\n    for spell in spells:\n        target = (success + spell - 1) // spell\n        index = bisect.bisect_left(potions, target)\n        res.append(n - index)\n\n    return res\n\n\nspells = [5, 1, 3]\npotions = [1, 2, 3, 4, 5]\nsuccess = 7\nprint(successfulPairs(spells, potions, success))  # [4, 0, 3]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_advanced/#1385-find-the-distance-value-between-two-arrays","title":"1385. Find the Distance Value Between Two Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers, binary search, sorting 1385. Find the Distance Value Between Two Arrays - Python Solution<pre><code>from bisect import bisect_left\nfrom typing import List\n\n\n# Binary Search\ndef findTheDistanceValue(arr1: List[int], arr2: List[int], d: int) -&gt; int:\n    arr2.sort()\n    res = 0\n\n    for x in arr1:\n        i = bisect_left(arr2, x - d)\n        if i == len(arr2) or arr2[i] &gt; x + d:\n            res += 1\n\n    return res\n\n\narr1 = [4, 5, 8]\narr2 = [10, 9, 1, 8]\nd = 2\nprint(findTheDistanceValue(arr1, arr2, d))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_advanced/#2389-longest-subsequence-with-limited-sum","title":"2389. Longest Subsequence With Limited Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, binary search, greedy, sorting, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_advanced/#1170-compare-strings-by-frequency-of-the-smallest-character","title":"1170. Compare Strings by Frequency of the Smallest Character","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, binary search, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_advanced/#2080-range-frequency-queries","title":"2080. Range Frequency Queries","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, binary search, design, segment tree 2080. Range Frequency Queries - Python Solution<pre><code>from bisect import bisect_left, bisect_right\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Binary Search\nclass RangeFreqQuery:\n    def __init__(self, arr: List[int]):\n        self.freq = defaultdict(list)\n        for idx, val in enumerate(arr):\n            self.freq[val].append(idx)\n\n    def query(self, left: int, right: int, value: int) -&gt; int:\n        idxs = self.freq[value]\n        return bisect_right(idxs, right) - bisect_left(idxs, left)\n\n\narr = [1, 3, 1, 2, 4, 1, 3, 2, 1]\nrfq = RangeFreqQuery(arr)\nprint(rfq.query(0, 4, 1))  # 2\nprint(rfq.query(2, 8, 1))  # 3\nprint(rfq.query(0, 8, 3))  # 2\nprint(rfq.query(4, 7, 2))  # 1\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_advanced/#2563-count-the-number-of-fair-pairs","title":"2563. Count the Number of Fair Pairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_advanced/#2070-most-beautiful-item-for-each-query","title":"2070. Most Beautiful Item for Each Query","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sorting 2070. Most Beautiful Item for Each Query - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;numeric&gt;\n#include &lt;ranges&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;int&gt; maximumBeauty(vector&lt;vector&lt;int&gt;&gt;&amp; items, vector&lt;int&gt;&amp; queries) {\n    ranges::sort(items, {}, [](auto&amp; item) { return item[0]; });\n    vector&lt;int&gt; idx(queries.size());\n    iota(idx.begin(), idx.end(), 0);\n    ranges::sort(idx, {}, [&amp;](int i) { return queries[i]; });\n\n    vector&lt;int&gt; res(queries.size());\n    int max_beauty = 0, j = 0;\n    for (int i : idx) {\n        int q = queries[i];\n        while (j &lt; items.size() &amp;&amp; items[j][0] &lt;= q) {\n            max_beauty = max(max_beauty, items[j][1]);\n            j++;\n        }\n        res[i] = max_beauty;\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;vector&lt;int&gt;&gt; items = {{1, 2}, {2, 4}, {3, 2}, {5, 6}, {3, 5}};\n    vector&lt;int&gt; queries = {1, 2, 3, 4, 5, 6};\n    vector&lt;int&gt; res = maximumBeauty(items, queries);\n    // 2 4 5 5 6 6\n    for (int i : res) {\n        cout &lt;&lt; i &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n    return 0;\n}\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_advanced/#981-time-based-key-value-store","title":"981. Time Based Key-Value Store","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, binary search, design 981. Time Based Key-Value Store - Python Solution<pre><code>from collections import defaultdict\n\n\n# Binary Search\nclass TimeMap:\n\n    def __init__(self):\n        self.keys = defaultdict(list)\n        self.times = dict()\n\n    def set(self, key: str, value: str, timestamp: int) -&gt; None:\n        self.keys[key].append(timestamp)\n        self.times[timestamp] = value\n\n    def get(self, key: str, timestamp: int) -&gt; str:\n        tmp = self.keys[key]\n\n        left, right = 0, len(tmp) - 1\n        while left &lt;= right:\n            mid = left + (right - left) // 2\n            if tmp[mid] &gt; timestamp:\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        return self.times[tmp[right]] if right &gt;= 0 else \"\"\n\n\nobj = TimeMap()\nobj.set(\"foo\", \"bar\", 1)\nprint(obj.get(\"foo\", 1))  # bar\nprint(obj.get(\"foo\", 3))  # bar\nobj.set(\"foo\", \"bar2\", 4)\nprint(obj.get(\"foo\", 4))  # bar2\nprint(obj.get(\"foo\", 5))  # bar2\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_advanced/#1146-snapshot-array","title":"1146. Snapshot Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, binary search, design</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_advanced/#658-find-k-closest-elements","title":"658. Find K Closest Elements","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, sliding window, sorting, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_advanced/#1818-minimum-absolute-sum-difference","title":"1818. Minimum Absolute Sum Difference","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sorting, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_advanced/#911-online-election","title":"911. Online Election","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, binary search, design</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_advanced/#1182-shortest-distance-to-target-color","title":"1182. Shortest Distance to Target Color","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_advanced/#2819-minimum-relative-loss-after-buying-chocolates","title":"2819. Minimum Relative Loss After Buying Chocolates","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, sorting, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_advanced/#1287-element-appearing-more-than-25-in-sorted-array","title":"1287. Element Appearing More Than 25% In Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array 1287. Element Appearing More Than 25% In Sorted Array - Python Solution<pre><code>from bisect import bisect_left, bisect_right\nfrom typing import List\n\n\n# Binary Search\ndef findSpecialInteger(arr: List[int]) -&gt; int:\n    n = len(arr)\n    span = n // 4 + 1\n\n    for i in range(0, n, span):\n        left = bisect_left(arr, arr[i])\n        right = bisect_right(arr, arr[i])\n        if right - left &gt;= span:\n            return arr[i]\n\n    return -1\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_advanced/#1150-check-if-a-number-is-majority-element-in-a-sorted-array","title":"1150. Check If a Number Is Majority Element in a Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_basics/","title":"Binary Search Basics","text":""},{"location":"content/endlesscheng/binary_search_basics/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 34. Find First and Last Position of Element in Sorted Array (Medium)</li> <li> 35. Search Insert Position (Easy)</li> <li> 704. Binary Search (Easy)</li> <li> 744. Find Smallest Letter Greater Than Target (Easy)</li> <li> 2529. Maximum Count of Positive Integer and Negative Integer (Easy)</li> </ul>"},{"location":"content/endlesscheng/binary_search_basics/#34-find-first-and-last-position-of-element-in-sorted-array","title":"34. Find First and Last Position of Element in Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> <li>Find the starting and ending position of a given target value in a sorted array.</li> </ul> 34. Find First and Last Position of Element in Sorted Array - Python Solution<pre><code>from bisect import bisect_left\nfrom typing import List\n\n\n# Binary Search\ndef searchRangeBS(nums: List[int], target: int) -&gt; List[int]:\n    def bisect_left(nums, target):\n        left, right = 0, len(nums) - 1\n        while left &lt;= right:\n            mid = left + (right - left) // 2\n            if nums[mid] &lt; target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n\n    left = bisect_left(nums, target)\n    right = bisect_left(nums, target + 1) - 1\n\n    if left &lt;= right:\n        return [left, right]\n\n    return [-1, -1]\n\n\n# Bisect\ndef searchRangeBSBisect(nums: List[int], target: int) -&gt; List[int]:\n    if not nums:\n        return [-1, -1]\n\n    left = bisect_left(nums, target)\n    right = bisect_left(nums, target + 1) - 1\n\n    return [left, right] if left &lt;= right else [-1, -1]\n\n\nnums = [5, 7, 7, 8, 8, 10]\ntarget = 8\nprint(searchRangeBS(nums, target))  # [3, 4]\nprint(searchRangeBSBisect(nums, target))  # [3, 4]\n</code></pre> 34. Find First and Last Position of Element in Sorted Array - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\n  int bisect_left(vector&lt;int&gt; &amp;nums, int target)\n  {\n    int left = 0, right = (int)nums.size() - 1;\n\n    while (left &lt;= right)\n    {\n      int mid = left + (right - left) / 2;\n      if (nums[mid] &lt; target)\n      {\n        left = mid + 1;\n      }\n      else\n      {\n        right = mid - 1;\n      }\n    }\n    return left;\n  }\n\npublic:\n  vector&lt;int&gt; searchRange(vector&lt;int&gt; &amp;nums, int target)\n  {\n    int left = bisect_left(nums, target);\n    if (left == (int)nums.size() || nums[left] != target)\n    {\n      return {-1, -1};\n    }\n    int right = bisect_left(nums, target + 1) - 1;\n    return {left, right};\n  }\n};\n\nint main()\n{\n  vector&lt;int&gt; nums = {5, 7, 7, 8, 8, 10};\n  int target = 8;\n  Solution s;\n  vector&lt;int&gt; res = s.searchRange(nums, target);\n  cout &lt;&lt; res[0] &lt;&lt; \", \" &lt;&lt; res[1] &lt;&lt; endl;\n  return 0;\n}\n</code></pre>"},{"location":"content/endlesscheng/binary_search_basics/#35-search-insert-position","title":"35. Search Insert Position","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, binary search</p> </li> <li>Return the index of the target if it is found. If not, return the index where it would be if it were inserted in order.</li> </ul> 35. Search Insert Position - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef searchInsert(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        if nums[mid] &lt; target:\n            left = mid + 1\n        elif nums[mid] &gt; target:\n            right = mid - 1\n        else:\n            return mid\n\n    return left\n\n\nnums = [1, 3, 5, 6]\ntarget = 5\nprint(searchInsert(nums, target))  # 2\n</code></pre>"},{"location":"content/endlesscheng/binary_search_basics/#704-binary-search","title":"704. Binary Search","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, binary search</p> </li> <li>Implement binary search algorithm.</li> </ul> 704. Binary Search - Python Solution<pre><code>from typing import List\n\n\n# Binary Search [left, right]\ndef search(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] &lt; target:\n            left = mid + 1\n        elif nums[mid] &gt; target:\n            right = mid - 1\n        else:\n            return mid\n\n    return -1\n\n\n# Binary Search [left, right)\ndef search_half_open(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums)\n\n    while left &lt; right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] &lt; target:\n            left = mid + 1\n        elif nums[mid] &gt; target:\n            right = mid\n        else:\n            return mid\n\n    return -1\n\n\n# Binary Search (left, right)\ndef search_open_interval(nums: List[int], target: int) -&gt; int:\n    left, right = -1, len(nums)\n\n    while left + 1 &lt; right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] &lt; target:\n            left = mid\n        elif nums[mid] &gt; target:\n            right = mid\n        else:\n            return mid\n\n    return -1\n\n\nif __name__ == \"__main__\":\n    nums = [-1, 0, 3, 5, 9, 12]\n    target = 9\n    assert search(nums, target) == 4\n    assert search_half_open(nums, target) == 4\n    assert search_open_interval(nums, target) == 4\n</code></pre>"},{"location":"content/endlesscheng/binary_search_basics/#744-find-smallest-letter-greater-than-target","title":"744. Find Smallest Letter Greater Than Target","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, binary search 744. Find Smallest Letter Greater Than Target - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef nextGreatestLetter(letters: List[str], target: str) -&gt; str:\n    left, right = 0, len(letters)\n\n    while left &lt; right:\n        mid = left + (right - left) // 2\n        if letters[mid] &gt; target:\n            right = mid\n        else:\n            left = mid + 1\n\n    return letters[left] if left &lt; len(letters) else letters[0]\n\n\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"a\"\nprint(nextGreatestLetter(letters, target))  # c\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_basics/#2529-maximum-count-of-positive-integer-and-negative-integer","title":"2529. Maximum Count of Positive Integer and Negative Integer","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, binary search, counting 2529. Maximum Count of Positive Integer and Negative Integer - Python Solution<pre><code>from bisect import bisect_left, bisect_right\nfrom typing import List\n\n\n# Binary Search\ndef maximumCount(nums: List[int]) -&gt; int:\n    pos = bisect_left(nums, 0)\n    neg = len(nums) - bisect_right(nums, 0)\n\n    return max(pos, neg)\n\n\nnums = [-2, -1, -1, 1, 2, 3]\nprint(maximumCount(nums))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_indirect_value/","title":"Binary Search Indirect Value","text":""},{"location":"content/endlesscheng/binary_search_indirect_value/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3143. Maximum Points Inside the Square (Medium)</li> <li> 1648. Sell Diminishing-Valued Colored Balls (Medium)</li> </ul>"},{"location":"content/endlesscheng/binary_search_indirect_value/#3143-maximum-points-inside-the-square","title":"3143. Maximum Points Inside the Square","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, binary search, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_indirect_value/#1648-sell-diminishing-valued-colored-balls","title":"1648. Sell Diminishing-Valued Colored Balls","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, binary search, greedy, sorting, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_kth_min_max/","title":"Binary Search Kth Min Max","text":""},{"location":"content/endlesscheng/binary_search_kth_min_max/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 668. Kth Smallest Number in Multiplication Table (Hard)</li> <li> 378. Kth Smallest Element in a Sorted Matrix (Medium)</li> <li> 719. Find K-th Smallest Pair Distance (Hard)</li> <li> 878. Nth Magical Number (Hard)</li> <li> 1201. Ugly Number III (Medium)</li> <li> 793. Preimage Size of Factorial Zeroes Function (Hard)</li> <li> 373. Find K Pairs with Smallest Sums (Medium)</li> <li> 1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows (Hard)</li> <li> 786. K-th Smallest Prime Fraction (Medium)</li> <li> 3116. Kth Smallest Amount With Single Denomination Combination (Hard)</li> <li> 3134. Find the Median of the Uniqueness Array (Hard)</li> <li> 2040. Kth Smallest Product of Two Sorted Arrays (Hard)</li> <li> 2386. Find the K-Sum of an Array (Hard)</li> <li> 1508. Range Sum of Sorted Subarray Sums (Medium)</li> <li> 1918. Kth Smallest Subarray Sum (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/binary_search_kth_min_max/#668-kth-smallest-number-in-multiplication-table","title":"668. Kth Smallest Number in Multiplication Table","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, binary search</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_kth_min_max/#378-kth-smallest-element-in-a-sorted-matrix","title":"378. Kth Smallest Element in a Sorted Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sorting, heap priority queue, matrix</p> </li> <li>Given an <code>n x n</code> matrix where each of the rows and columns are sorted in ascending order, return the <code>k-th</code> smallest element in the matrix.</li> </ul> 378. Kth Smallest Element in a Sorted Matrix - Python Solution<pre><code>from heapq import heapify, heappop, heappush\nfrom typing import List\n\n\n# Heap - Merge K Sorted\ndef kthSmallestHeap(matrix: List[List[int]], k: int) -&gt; int:\n    n = len(matrix)\n    heap = [(matrix[i][0], i, 0) for i in range(n)]\n    heapify(heap)\n\n    for _ in range(k - 1):\n        _, row, col = heappop(heap)\n\n        if col + 1 &lt; n:\n            heappush(heap, (matrix[row][col + 1], row, col + 1))\n\n    return heappop(heap)[0]\n\n\n# Binary Search\ndef kthSmallestBinarySearch(matrix: List[List[int]], k: int) -&gt; int:\n    n = len(matrix)\n\n    def check(mid):\n        i, j = n - 1, 0\n        num = 0\n\n        while i &gt;= 0 and j &lt; n:\n            if matrix[i][j] &lt;= mid:\n                num += i + 1\n                j += 1\n            else:\n                i -= 1\n\n        return num &gt;= k\n\n    left, right = matrix[0][0], matrix[-1][-1]\n\n    while left &lt; right:\n        mid = (left + right) // 2\n        if check(mid):\n            right = mid\n        else:\n            left = mid + 1\n\n    return left\n\n\nmatrix = [[1, 5, 9], [10, 11, 13], [12, 13, 15]]\nk = 8\n\nprint(kthSmallestHeap(matrix, k))  # 13\nprint(kthSmallestBinarySearch(matrix, k))  # 13\n</code></pre>"},{"location":"content/endlesscheng/binary_search_kth_min_max/#719-find-k-th-smallest-pair-distance","title":"719. Find K-th Smallest Pair Distance","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, binary search, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_kth_min_max/#878-nth-magical-number","title":"878. Nth Magical Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, binary search</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_kth_min_max/#1201-ugly-number-iii","title":"1201. Ugly Number III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, binary search, combinatorics, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_kth_min_max/#793-preimage-size-of-factorial-zeroes-function","title":"793. Preimage Size of Factorial Zeroes Function","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, binary search</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_kth_min_max/#373-find-k-pairs-with-smallest-sums","title":"373. Find K Pairs with Smallest Sums","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, heap priority queue 373. Find K Pairs with Smallest Sums - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Heap - Merge K Sorted\ndef kSmallestPairs(\n    nums1: List[int], nums2: List[int], k: int\n) -&gt; List[List[int]]:\n    if not nums1 or not nums2 or k &lt;= 0:\n        return []\n\n    res = []\n    min_heap = []\n\n    for j in range(min(k, len(nums2))):\n        heapq.heappush(min_heap, (nums1[0] + nums2[j], 0, j))\n\n    while k &gt; 0 and min_heap:\n        _, i, j = heapq.heappop(min_heap)\n        res.append([nums1[i], nums2[j]])\n        k -= 1\n\n        if i + 1 &lt; len(nums1):\n            heapq.heappush(min_heap, (nums1[i + 1] + nums2[j], i + 1, j))\n\n    return res\n\n\nif __name__ == \"__main__\":\n    nums1 = [1, 2, 4, 5, 6]\n    nums2 = [3, 5, 7, 9]\n    k = 3\n    assert kSmallestPairs(nums1, nums2, k) == [[1, 3], [2, 3], [1, 5]]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_kth_min_max/#1439-find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows","title":"1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, heap priority queue, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_kth_min_max/#786-k-th-smallest-prime-fraction","title":"786. K-th Smallest Prime Fraction","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, sorting, heap priority queue 786. K-th Smallest Prime Fraction - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\ndef kthSmallestPrimeFraction(arr: List[int], k: int) -&gt; List[int]:\n    max_heap = []\n\n    for j in range(1, len(arr)):\n        for i in range(j):\n            heapq.heappush(max_heap, (-arr[i] / arr[j], arr[i], arr[j]))\n\n            if len(max_heap) &gt; k:\n                heapq.heappop(max_heap)\n\n    return [max_heap[0][1], max_heap[0][2]]\n\n\narr = [1, 2, 3, 5]\nk = 3\nprint(kthSmallestPrimeFraction(arr, k))  # [2, 5]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_kth_min_max/#3116-kth-smallest-amount-with-single-denomination-combination","title":"3116. Kth Smallest Amount With Single Denomination Combination","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, binary search, bit manipulation, combinatorics, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_kth_min_max/#3134-find-the-median-of-the-uniqueness-array","title":"3134. Find the Median of the Uniqueness Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, binary search, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_kth_min_max/#2040-kth-smallest-product-of-two-sorted-arrays","title":"2040. Kth Smallest Product of Two Sorted Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_kth_min_max/#2386-find-the-k-sum-of-an-array","title":"2386. Find the K-Sum of an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, sorting, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_kth_min_max/#1508-range-sum-of-sorted-subarray-sums","title":"1508. Range Sum of Sorted Subarray Sums","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_kth_min_max/#1918-kth-smallest-subarray-sum","title":"1918. Kth Smallest Subarray Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_max_answer/","title":"Binary Search Max Answer","text":""},{"location":"content/endlesscheng/binary_search_max_answer/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 275. H-Index II (Medium)</li> <li> 2226. Maximum Candies Allocated to K Children (Medium)</li> <li> 2982. Find Longest Special Substring That Occurs Thrice II (Medium)</li> <li> 2576. Find the Maximum Number of Marked Indices (Medium)</li> <li> 1898. Maximum Number of Removable Characters (Medium)</li> <li> 1802. Maximum Value at a Given Index in a Bounded Array (Medium)</li> <li> 1642. Furthest Building You Can Reach (Medium)</li> <li> 2861. Maximum Number of Alloys (Medium)</li> <li> 3007. Maximum Number That Sum of the Prices Is Less Than or Equal to K (Medium)</li> <li> 2141. Maximum Running Time of N Computers (Hard)</li> <li> 2258. Escape the Spreading Fire (Hard)</li> <li> 2071. Maximum Number of Tasks You Can Assign (Hard)</li> <li> 1618. Maximum Font to Fit a Sentence in a Screen (Medium) \ud83d\udc51</li> <li> 1891. Cutting Ribbons (Medium) \ud83d\udc51</li> <li> 2137. Pour Water Between Buckets to Make Water Levels Equal (Medium) \ud83d\udc51</li> <li> 644. Maximum Average Subarray II (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/binary_search_max_answer/#275-h-index-ii","title":"275. H-Index II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> <li>Hint: logarithmic time -- binary search</li> </ul> 275. H-Index II - Python Solution<pre><code>from typing import List\n\n\n# Binary Search Max Answer\ndef hIndex(citations: List[int]) -&gt; int:\n    n = len(citations)\n    left, right = 0, n - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if citations[mid] &gt;= n - mid:\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return n - left\n\n\nif __name__ == \"__main__\":\n    citations = [0, 1, 3, 5, 6]\n    assert hIndex(citations) == 3\n</code></pre>"},{"location":"content/endlesscheng/binary_search_max_answer/#2226-maximum-candies-allocated-to-k-children","title":"2226. Maximum Candies Allocated to K Children","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search 2226. Maximum Candies Allocated to K Children - Python Solution<pre><code>from typing import List\n\n\n# Binary Search Max Answer\ndef maximumCandies(candies: List[int], k: int) -&gt; int:\n    def check(low):\n        return sum(c // low for c in candies) &gt;= k\n\n    left, right = 0, max(candies) + 1\n    while left + 1 &lt; right:\n        mid = left + (right - left) // 2\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n\n    return left\n\n\n# Binary Search Max Answer - Optimized\ndef maximumCandiesOptimized(candies: List[int], k: int) -&gt; int:\n    def check(low):\n        return sum(c // low for c in candies) &gt;= k\n\n    # Use the minimum of max(candies) and sum(candies) // k to limit the search space\n    left, right = 0, min(max(candies), sum(candies) // k) + 1\n\n    while left + 1 &lt; right:\n        mid = left + (right - left) // 2\n        if check(mid):\n            left = mid\n        else:\n            right = mid\n\n    return left\n\n\nif __name__ == \"__main__\":\n    candies = [5, 8, 6]\n    k = 3\n    assert maximumCandies(candies, k) == 5\n    assert maximumCandiesOptimized(candies, k) == 5\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_max_answer/#2982-find-longest-special-substring-that-occurs-thrice-ii","title":"2982. Find Longest Special Substring That Occurs Thrice II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, binary search, sliding window, counting</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_max_answer/#2576-find-the-maximum-number-of-marked-indices","title":"2576. Find the Maximum Number of Marked Indices","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, greedy, sorting 2576. Find the Maximum Number of Marked Indices - Python Solution<pre><code>from typing import List\n\n\n# Fast Slow Pointers\ndef maxNumOfMarkedIndices(nums: List[int]) -&gt; int:\n    nums.sort()\n    n = len(nums)\n    slow, fast = 0, n // 2\n    count = 0\n\n    while slow &lt; n // 2 and fast &lt; n:\n        if nums[fast] &gt;= 2 * nums[slow]:\n            count += 2\n            slow += 1\n        fast += 1\n\n    return count\n\n\nnums = [3, 5, 2, 4]\nprint(maxNumOfMarkedIndices(nums))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_max_answer/#1898-maximum-number-of-removable-characters","title":"1898. Maximum Number of Removable Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, string, binary search</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_max_answer/#1802-maximum-value-at-a-given-index-in-a-bounded-array","title":"1802. Maximum Value at a Given Index in a Bounded Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: binary search, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_max_answer/#1642-furthest-building-you-can-reach","title":"1642. Furthest Building You Can Reach","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_max_answer/#2861-maximum-number-of-alloys","title":"2861. Maximum Number of Alloys","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_max_answer/#3007-maximum-number-that-sum-of-the-prices-is-less-than-or-equal-to-k","title":"3007. Maximum Number That Sum of the Prices Is Less Than or Equal to K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: binary search, dynamic programming, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_max_answer/#2141-maximum-running-time-of-n-computers","title":"2141. Maximum Running Time of N Computers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_max_answer/#2258-escape-the-spreading-fire","title":"2258. Escape the Spreading Fire","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, breadth first search, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_max_answer/#2071-maximum-number-of-tasks-you-can-assign","title":"2071. Maximum Number of Tasks You Can Assign","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, greedy, queue, sorting, monotonic queue</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_max_answer/#1618-maximum-font-to-fit-a-sentence-in-a-screen","title":"1618. Maximum Font to Fit a Sentence in a Screen","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, binary search, interactive</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_max_answer/#1891-cutting-ribbons","title":"1891. Cutting Ribbons","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_max_answer/#2137-pour-water-between-buckets-to-make-water-levels-equal","title":"2137. Pour Water Between Buckets to Make Water Levels Equal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_max_answer/#644-maximum-average-subarray-ii","title":"644. Maximum Average Subarray II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_maximize_min/","title":"Binary Search Maximize Min","text":""},{"location":"content/endlesscheng/binary_search_maximize_min/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3281. Maximize Score of Numbers in Ranges (Medium)</li> <li> 2517. Maximum Tastiness of Candy Basket (Medium)</li> <li> 1552. Magnetic Force Between Two Balls (Medium)</li> <li> 2812. Find the Safest Path in a Grid (Medium)</li> <li> 2528. Maximize the Minimum Powered City (Hard)</li> <li> 3449. Maximize the Minimum Game Score (Hard)</li> <li> 1102. Path With Maximum Minimum Value (Medium) \ud83d\udc51</li> <li> 1231. Divide Chocolate (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/binary_search_maximize_min/#3281-maximize-score-of-numbers-in-ranges","title":"3281. Maximize Score of Numbers in Ranges","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_maximize_min/#2517-maximum-tastiness-of-candy-basket","title":"2517. Maximum Tastiness of Candy Basket","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_maximize_min/#1552-magnetic-force-between-two-balls","title":"1552. Magnetic Force Between Two Balls","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_maximize_min/#2812-find-the-safest-path-in-a-grid","title":"2812. Find the Safest Path in a Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, breadth first search, union find, heap priority queue, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_maximize_min/#2528-maximize-the-minimum-powered-city","title":"2528. Maximize the Minimum Powered City","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, greedy, queue, sliding window, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_maximize_min/#3449-maximize-the-minimum-game-score","title":"3449. Maximize the Minimum Game Score","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_maximize_min/#1102-path-with-maximum-minimum-value","title":"1102. Path With Maximum Minimum Value","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, depth first search, breadth first search, union find, heap priority queue, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_maximize_min/#1231-divide-chocolate","title":"1231. Divide Chocolate","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_min_answer/","title":"Binary Search Min Answer","text":""},{"location":"content/endlesscheng/binary_search_min_answer/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1283. Find the Smallest Divisor Given a Threshold (Medium)</li> <li> 2187. Minimum Time to Complete Trips (Medium)</li> <li> 1870. Minimum Speed to Arrive on Time (Medium)</li> <li> 1011. Capacity To Ship Packages Within D Days (Medium)</li> <li> 875. Koko Eating Bananas (Medium)</li> <li> 3296. Minimum Number of Seconds to Make Mountain Height Zero (Medium)</li> <li> 475. Heaters (Medium)</li> <li> 2594. Minimum Time to Repair Cars (Medium)</li> <li> 1482. Minimum Number of Days to Make m Bouquets (Medium)</li> <li> 3048. Earliest Second to Mark Indices I (Medium)</li> <li> 2604. Minimum Time to Eat All Grains (Hard) \ud83d\udc51</li> <li> 2702. Minimum Operations to Make Numbers Non-positive (Hard) \ud83d\udc51</li> <li> 3453. Separate Squares I (Medium)</li> </ul>"},{"location":"content/endlesscheng/binary_search_min_answer/#1283-find-the-smallest-divisor-given-a-threshold","title":"1283. Find the Smallest Divisor Given a Threshold","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> <li>\u4e8c\u5206\u7b54\u6848\u7684\u5173\u952e\u662f\u627e\u5230\u5355\u8c03\u6027\uff0c\u7136\u540e\u5206\u6790\u51fa\u5224\u65ad\u6761\u4ef6</li> </ul> 1283. Find the Smallest Divisor Given a Threshold - Python Solution<pre><code>from typing import List\n\n\n# Binary Search Min Answer\ndef smallestDivisor(nums: List[int], threshold: int) -&gt; int:\n    left, right = 0, max(nums)\n\n    while left + 1 &lt; right:\n        mid = left + (right - left) // 2\n        if sum((x - 1) // mid for x in nums) &lt;= threshold - len(nums):\n            right = mid\n        else:\n            left = mid\n\n    return right\n\n\nif __name__ == \"__main__\":\n    nums = [1, 2, 5, 9]\n    threshold = 6\n    assert smallestDivisor(nums, threshold) == 5\n</code></pre>"},{"location":"content/endlesscheng/binary_search_min_answer/#2187-minimum-time-to-complete-trips","title":"2187. Minimum Time to Complete Trips","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> <li>Left: always insufficient trips</li> <li>Right: always sufficient trips</li> </ul> 2187. Minimum Time to Complete Trips - Python Solution<pre><code>from typing import List\n\n\n# Binary Search Min Answer\ndef minimumTime(time: List[int], totalTrips: int) -&gt; int:\n    min_t = min(time)\n    left = min_t - 1\n    right = min_t * totalTrips\n\n    while left + 1 &lt; right:\n        mid = left + (right - left) // 2\n        if sum(mid // t for t in time) &gt;= totalTrips:\n            right = mid\n        else:\n            left = mid\n\n    return right\n\n\nif __name__ == \"__main__\":\n    time = [1, 2, 3]\n    totalTrips = 5\n    assert minimumTime(time, totalTrips) == 3\n</code></pre>"},{"location":"content/endlesscheng/binary_search_min_answer/#1870-minimum-speed-to-arrive-on-time","title":"1870. Minimum Speed to Arrive on Time","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search 1870. Minimum Speed to Arrive on Time - Python Solution<pre><code>import math\nfrom typing import List\n\n\n# Binary Search\ndef minSpeedOnTime(dist: List[int], hour: float) -&gt; int:\n    if hour &lt; len(dist) - 1:\n        return -1\n\n    def time_needed(speed):\n        total_time = 0\n        for i in range(len(dist) - 1):\n            total_time += math.ceil(dist[i] / speed)\n        total_time += dist[-1] / speed\n        return total_time\n\n    left, right = 1, 10**7\n    result = -1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        if time_needed(mid) &lt;= hour:\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return result\n\n\ndist = [1, 3, 2]\nhour = 6\nprint(minSpeedOnTime(dist, hour))  # 1\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_min_answer/#1011-capacity-to-ship-packages-within-d-days","title":"1011. Capacity To Ship Packages Within D Days","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> <li>A conveyor belt has packages that must be shipped from one port to another within <code>D</code> days. The <code>i-th</code> package has a weight of <code>weights[i]</code>. Each day, we load the ship with packages on the conveyor belt. The ship will be loaded with packages up to its capacity. The ship will not be loaded beyond its capacity. Return the least weight capacity of the ship.</li> </ul> 1011. Capacity To Ship Packages Within D Days - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef shipWithinDays(weights: List[int], days: int) -&gt; int:\n\n    def canShip(weights, D, capacity):\n        days = 1\n        current_weight = 0\n\n        for weight in weights:\n            if current_weight + weight &gt; capacity:\n                days += 1\n                current_weight = 0\n            current_weight += weight\n\n        return days &lt;= D\n\n    left, right = max(weights), sum(weights)\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if canShip(weights, days, mid):\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return left\n\n\nweights = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\ndays = 5\nprint(shipWithinDays(weights, days))  # 15\n</code></pre>"},{"location":"content/endlesscheng/binary_search_min_answer/#875-koko-eating-bananas","title":"875. Koko Eating Bananas","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> <li>Koko loves to eat bananas. She wants to eat all the bananas within <code>H</code> hours. Each pile has a number of bananas. The <code>i-th</code> pile has <code>piles[i]</code> bananas. Return the minimum integer <code>K</code> such that she can eat all the bananas within <code>H</code> hours.</li> </ul> 875. Koko Eating Bananas - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef minEatingSpeed(piles: List[int], h: int) -&gt; int:\n    def canEat(piles, k, h):\n        hours = 0\n        for pile in piles:\n            hours += (pile + k - 1) // k\n        return hours &lt;= h\n\n    left, right = 1, max(piles)\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if canEat(piles, mid, h):\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return left\n\n\npiles = [3, 6, 7, 11]\nh = 8\nprint(minEatingSpeed(piles, h))  # 4\n</code></pre>"},{"location":"content/endlesscheng/binary_search_min_answer/#3296-minimum-number-of-seconds-to-make-mountain-height-zero","title":"3296. Minimum Number of Seconds to Make Mountain Height Zero","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, binary search, greedy, heap priority queue 3296. Minimum Number of Seconds to Make Mountain Height Zero - Python Solution<pre><code>from bisect import bisect_left\nfrom heapq import heapify, heapreplace\nfrom math import isqrt\nfrom typing import List\n\n\n# Min Heap\ndef minNumberOfSecondsMinHeap(\n    mountainHeight: int, workerTimes: List[int]\n) -&gt; int:\n    minHeap = [(t, t, t) for t in workerTimes]\n    heapify(minHeap)\n\n    for _ in range(mountainHeight):\n        nxt, delta, base = minHeap[0]\n        heapreplace(\n            minHeap,\n            (\n                nxt + delta + base,\n                delta + base,\n                base,\n            ),\n        )\n    return nxt\n\n\n# Binary Search Min Answer\ndef minNumberOfSecondsBinarySearchMin(\n    mountainHeight: int, workerTimes: List[int]\n) -&gt; int:\n    def check(m: int) -&gt; bool:\n        left_h = mountainHeight\n        for t in workerTimes:\n            left_h -= (isqrt(m // t * 8 + 1) - 1) // 2\n            if left_h &lt;= 0:\n                return True\n        return False\n\n    max_t = max(workerTimes)\n    h = (mountainHeight - 1) // len(workerTimes) + 1\n    return bisect_left(range(max_t * h * (h + 1) // 2), True, 1, key=check)\n\n\nif __name__ == \"__main__\":\n    mountainHeight = 4\n    workerTimes = [2, 1, 1]\n    assert minNumberOfSecondsMinHeap(mountainHeight, workerTimes) == 3\n    assert minNumberOfSecondsBinarySearchMin(mountainHeight, workerTimes) == 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_min_answer/#475-heaters","title":"475. Heaters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, sorting 475. Heaters - Python Solution<pre><code>from bisect import bisect_left, bisect_right\nfrom math import inf\nfrom typing import List\n\n\n# Left Right Pointers\ndef findRadiusLR(houses: List[int], heaters: List[int]) -&gt; int:\n    heaters = heaters + [-inf, inf]\n    houses.sort()\n    heaters.sort()\n    i, j, res = 0, 0, 0\n\n    while i &lt; len(houses):\n        cur = inf\n        while heaters[j] &lt;= houses[i]:\n            cur = houses[i] - heaters[j]\n            j += 1\n        cur = min(cur, heaters[j] - houses[i])\n        res = max(cur, res)\n        i += 1\n        j -= 1\n\n    return res\n\n\n# Binary Search Min Answer\ndef findRadiusBS(houses: List[int], heaters: List[int]) -&gt; int:\n    houses.sort()\n    heaters.sort()\n\n    def closest(house):\n        left = bisect_right(heaters, house) - 1\n        d1 = abs(heaters[left] - house) if left &gt;= 0 else inf\n\n        right = bisect_left(heaters, house)\n        d2 = abs(heaters[right] - house) if right &lt; len(heaters) else inf\n\n        return min(d1, d2)\n\n    return max(closest(house) for house in houses)\n\n\nif __name__ == \"__main__\":\n    houses = [1, 2, 3]\n    heaters = [2]\n    assert findRadiusLR(houses, heaters) == 1\n    assert findRadiusBS(houses, heaters) == 1\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_min_answer/#2594-minimum-time-to-repair-cars","title":"2594. Minimum Time to Repair Cars","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search 2594. Minimum Time to Repair Cars - Python Solution<pre><code>from math import isqrt\nfrom typing import List\n\n\n# Binary Search Min Answer\ndef repairCars(ranks: List[int], cars: int) -&gt; int:\n    left, right = 0, max(ranks) * cars * cars\n\n    while left + 1 &lt; right:\n        mid = left + (right - left) // 2\n        if sum(isqrt(mid // rank) for rank in ranks) &gt;= cars:\n            right = mid\n        else:\n            left = mid\n    return right\n\n\nif __name__ == \"__main__\":\n    ranks = [4, 2, 3, 1]\n    cars = 10\n    assert repairCars(ranks, cars) == 16\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_min_answer/#1482-minimum-number-of-days-to-make-m-bouquets","title":"1482. Minimum Number of Days to Make m Bouquets","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search 1482. Minimum Number of Days to Make m Bouquets - Python Solution<pre><code>from typing import List\n\n\n# Binary Search Min Answer\ndef minDays(bloomDay: List[int], m: int, k: int) -&gt; int:\n    n = len(bloomDay)\n    if m * k &gt; n:\n        return -1\n\n    def canMake(day: int) -&gt; bool:\n        bouquets = 0\n        flowers = 0\n        for bloom in bloomDay:\n            if bloom &lt;= day:\n                flowers += 1\n                if flowers == k:\n                    bouquets += 1\n                    flowers = 0\n            else:\n                flowers = 0\n        return bouquets &gt;= m\n\n    left, right = min(bloomDay), max(bloomDay)\n    res = -1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        if canMake(mid):\n            res = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    bloomDay = [1, 10, 3, 10, 2]\n    m = 3\n    k = 1\n    assert minDays(bloomDay, m, k) == 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_min_answer/#3048-earliest-second-to-mark-indices-i","title":"3048. Earliest Second to Mark Indices I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search 3048. Earliest Second to Mark Indices I - Python Solution<pre><code>from bisect import bisect_left\nfrom typing import List\n\n\n# Binary Search Min Answer\ndef earliestSecondToMarkIndices(\n    nums: List[int], changeIndices: List[int]\n) -&gt; int:\n    n, m = len(nums), len(changeIndices)\n    if n &gt; m:\n        return -1\n\n    def check(mx: int) -&gt; bool:\n        last_t = [-1] * n\n        for t, idx in enumerate(changeIndices[:mx]):\n            last_t[idx - 1] = t\n        if -1 in last_t:\n            return False\n\n        cnt = 0\n        for i, idx in enumerate(changeIndices[:mx]):\n            idx -= 1\n            if i == last_t[idx]:\n                if nums[idx] &gt; cnt:\n                    return False\n                cnt -= nums[idx]\n            else:\n                cnt += 1\n        return True\n\n    left = n + sum(nums)\n    res = left + bisect_left(range(left, m + 1), True, key=check)\n    return -1 if res &gt; m else res\n\n\nif __name__ == \"__main__\":\n    nums = [2, 2, 0]\n    changeIndices = [2, 2, 2, 2, 3, 2, 2, 1]\n    assert earliestSecondToMarkIndices(nums, changeIndices) == 8\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_min_answer/#2604-minimum-time-to-eat-all-grains","title":"2604. Minimum Time to Eat All Grains","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, binary search, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_min_answer/#2702-minimum-operations-to-make-numbers-non-positive","title":"2702. Minimum Operations to Make Numbers Non-positive","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_min_answer/#3453-separate-squares-i","title":"3453. Separate Squares I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_minimize_max/","title":"Binary Search Minimize Max","text":""},{"location":"content/endlesscheng/binary_search_minimize_max/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 410. Split Array Largest Sum (Hard)</li> <li> 2064. Minimized Maximum of Products Distributed to Any Store (Medium)</li> <li> 1760. Minimum Limit of Balls in a Bag (Medium)</li> <li> 1631. Path With Minimum Effort (Medium)</li> <li> 2439. Minimize Maximum of Array (Medium)</li> <li> 2560. House Robber IV (Medium)</li> <li> 778. Swim in Rising Water (Hard)</li> <li> 2616. Minimize the Maximum Difference of Pairs (Medium)</li> <li> 3419. Minimize the Maximum Edge Weight of Graph (Medium)</li> <li> 2513. Minimize the Maximum of Two Arrays (Medium)</li> <li> 3399. Smallest Substring With Identical Characters II (Hard)</li> <li> 774. Minimize Max Distance to Gas Station (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/binary_search_minimize_max/#410-split-array-largest-sum","title":"410. Split Array Largest Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, dynamic programming, greedy, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_minimize_max/#2064-minimized-maximum-of-products-distributed-to-any-store","title":"2064. Minimized Maximum of Products Distributed to Any Store","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_minimize_max/#1760-minimum-limit-of-balls-in-a-bag","title":"1760. Minimum Limit of Balls in a Bag","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_minimize_max/#1631-path-with-minimum-effort","title":"1631. Path With Minimum Effort","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, depth first search, breadth first search, union find, heap priority queue, matrix</p> </li> <li>Return the minimum effort required to travel from the top-left to the bottom-right corner.</li> </ul> 1631. Path With Minimum Effort - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Prim\ndef minimumEffortPath(heights: List[List[int]]) -&gt; int:\n    m, n = len(heights), len(heights[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * n for _ in range(m)]\n    heap = [(0, 0, 0)]  # (effort, row, col)\n\n    while heap:\n        effort, r, c = heapq.heappop(heap)\n\n        if visited[r][c]:\n            continue\n\n        if r == m - 1 and c == n - 1:\n            return effort\n\n        visited[r][c] = True\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and not visited[nr][nc]:\n                updated = max(effort, abs(heights[r][c] - heights[nr][nc]))\n                heapq.heappush(heap, (updated, nr, nc))\n\n    return -1\n\n\nheights = [[1, 2, 2], [3, 8, 2], [5, 3, 5]]\nprint(minimumEffortPath(heights))  # 2\n</code></pre>"},{"location":"content/endlesscheng/binary_search_minimize_max/#2439-minimize-maximum-of-array","title":"2439. Minimize Maximum of Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, dynamic programming, greedy, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_minimize_max/#2560-house-robber-iv","title":"2560. House Robber IV","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_minimize_max/#778-swim-in-rising-water","title":"778. Swim in Rising Water","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, depth first search, breadth first search, union find, heap priority queue, matrix</p> </li> <li>Return the minimum time when you can reach the target.</li> </ul> <p></p> 778. Swim in Rising Water - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra's\ndef swimInWater(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    visited = set()\n    minHeap = [(grid[0][0], 0, 0)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    visited.add((0, 0))\n\n    while minHeap:\n        time, r, c = heapq.heappop(minHeap)\n\n        if r == n - 1 and c == n - 1:\n            return time\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if nr in range(n) and nc in range(n) and (nr, nc) not in visited:\n                visited.add((nr, nc))\n                heapq.heappush(minHeap, (max(time, grid[nr][nc]), nr, nc))\n\n\ngrid = [\n    [0, 1, 2, 3, 4],\n    [24, 23, 22, 21, 5],\n    [12, 13, 14, 15, 16],\n    [11, 17, 18, 19, 20],\n    [10, 9, 8, 7, 6],\n]\nprint(swimInWater(grid))  # 16\n</code></pre>"},{"location":"content/endlesscheng/binary_search_minimize_max/#2616-minimize-the-maximum-difference-of-pairs","title":"2616. Minimize the Maximum Difference of Pairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_minimize_max/#3419-minimize-the-maximum-edge-weight-of-graph","title":"3419. Minimize the Maximum Edge Weight of Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: binary search, depth first search, breadth first search, graph, shortest path</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_minimize_max/#2513-minimize-the-maximum-of-two-arrays","title":"2513. Minimize the Maximum of Two Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, binary search, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_minimize_max/#3399-smallest-substring-with-identical-characters-ii","title":"3399. Smallest Substring With Identical Characters II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, binary search</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_minimize_max/#774-minimize-max-distance-to-gas-station","title":"774. Minimize Max Distance to Gas Station","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_others/","title":"Binary Search Others","text":""},{"location":"content/endlesscheng/binary_search_others/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 69. Sqrt(x) (Easy)</li> <li> 74. Search a 2D Matrix (Medium)</li> <li> 240. Search a 2D Matrix II (Medium)</li> <li> 2476. Closest Nodes Queries in a Binary Search Tree (Medium)</li> <li> 278. First Bad Version (Easy)</li> <li> 374. Guess Number Higher or Lower (Easy)</li> <li> 162. Find Peak Element (Medium)</li> <li> 1901. Find a Peak Element II (Medium)</li> <li> 852. Peak Index in a Mountain Array (Medium)</li> <li> 1095. Find in Mountain Array (Hard)</li> <li> 153. Find Minimum in Rotated Sorted Array (Medium)</li> <li> 154. Find Minimum in Rotated Sorted Array II (Hard)</li> <li> 33. Search in Rotated Sorted Array (Medium)</li> <li> 81. Search in Rotated Sorted Array II (Medium)</li> <li> 222. Count Complete Tree Nodes (Easy)</li> <li> 1539. Kth Missing Positive Number (Easy)</li> <li> 540. Single Element in a Sorted Array (Medium)</li> <li> 4. Median of Two Sorted Arrays (Hard)</li> <li> 1064. Fixed Point (Easy) \ud83d\udc51</li> <li> 702. Search in a Sorted Array of Unknown Size (Medium) \ud83d\udc51</li> <li> 2936. Number of Equal Numbers Blocks (Medium) \ud83d\udc51</li> <li> 1060. Missing Element in Sorted Array (Medium) \ud83d\udc51</li> <li> 1198. Find Smallest Common Element in All Rows (Medium) \ud83d\udc51</li> <li> 1428. Leftmost Column with at Least a One (Medium) \ud83d\udc51</li> <li> 1533. Find the Index of the Large Integer (Medium) \ud83d\udc51</li> <li> 2387. Median of a Row Wise Sorted Matrix (Medium) \ud83d\udc51</li> <li> 302. Smallest Rectangle Enclosing Black Pixels (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/binary_search_others/#69-sqrtx","title":"69. Sqrt(x)","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, binary search 69. Sqrt(x) - Python Solution<pre><code># Left Right Pointers\ndef mySqrt(x: int) -&gt; int:\n    \"\"\"Returns the square root of a number.\"\"\"\n    if x &lt; 2:\n        return x\n\n    left, right = 0, x // 2\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        if mid * mid &lt;= x &lt; (mid + 1) * (mid + 1):\n            return mid\n        elif mid * mid &lt; x:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n\nx = 8\nprint(mySqrt(x))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_others/#74-search-a-2d-matrix","title":"74. Search a 2D Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, matrix 74. Search a 2D Matrix - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef searchMatrix(matrix: List[List[int]], target: int) -&gt; bool:\n    if not matrix or not matrix[0]:\n        return False\n\n    m, n = len(matrix), len(matrix[0])\n    left, right = 0, m * n - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        x = matrix[mid // n][mid % n]\n\n        if x &lt; target:\n            left = mid + 1\n        elif x &gt; target:\n            right = mid - 1\n        else:\n            return True\n\n    return False\n\n\nif __name__ == \"__main__\":\n    matrix = [[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]]\n    target = 3\n    print(searchMatrix(matrix, target))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_others/#240-search-a-2d-matrix-ii","title":"240. Search a 2D Matrix II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, divide and conquer, matrix 240. Search a 2D Matrix II - Python Solution<pre><code>from typing import List\n\n\n# Matrix\ndef searchMatrix(matrix: List[List[int]], target: int) -&gt; bool:\n    m, n = len(matrix), len(matrix[0])\n    i, j = 0, n - 1\n\n    while i &lt; m and j &gt;= 0:\n        if matrix[i][j] == target:\n            return True\n        elif matrix[i][j] &lt; target:\n            i += 1\n        else:\n            j -= 1\n\n    return False\n\n\nmatrix = [\n    [1, 4, 7, 11, 15],\n    [2, 5, 8, 12, 19],\n    [3, 6, 9, 16, 22],\n    [10, 13, 14, 17, 24],\n    [18, 21, 23, 26, 30],\n]\ntarget = 20\nprint(searchMatrix(matrix, target))  # False\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_others/#2476-closest-nodes-queries-in-a-binary-search-tree","title":"2476. Closest Nodes Queries in a Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, tree, depth first search, binary search tree, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_others/#278-first-bad-version","title":"278. First Bad Version","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: binary search, interactive</p> </li> <li>Find the first bad version given a function <code>isBadVersion</code>.</li> </ul> 278. First Bad Version - Python Solution<pre><code># Binary Search\ndef firstBadVersion(n: int) -&gt; int:\n    left, right = 1, n\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if isBadVersion(mid):\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return left\n\n\ndef isBadVersion(version: int) -&gt; bool:\n    pass\n</code></pre>"},{"location":"content/endlesscheng/binary_search_others/#374-guess-number-higher-or-lower","title":"374. Guess Number Higher or Lower","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: binary search, interactive</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_others/#162-find-peak-element","title":"162. Find Peak Element","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_others/#1901-find-a-peak-element-ii","title":"1901. Find a Peak Element II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_others/#852-peak-index-in-a-mountain-array","title":"852. Peak Index in a Mountain Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_others/#1095-find-in-mountain-array","title":"1095. Find in Mountain Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, interactive</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_others/#153-find-minimum-in-rotated-sorted-array","title":"153. Find Minimum in Rotated Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search 153. Find Minimum in Rotated Sorted Array - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef findMin(nums: List[int]) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt; right:\n        mid = left + (right - left) // 2\n        if nums[mid] &gt; nums[right]:\n            left = mid + 1\n        else:\n            right = mid\n\n    return nums[right]\n\n\nnums = [4, 5, 6, 7, 0, 1, 2]\nprint(findMin(nums))  # 0\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_others/#154-find-minimum-in-rotated-sorted-array-ii","title":"154. Find Minimum in Rotated Sorted Array II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_others/#33-search-in-rotated-sorted-array","title":"33. Search in Rotated Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search 33. Search in Rotated Sorted Array - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef search(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] == target:\n            return mid\n\n        if nums[left] &lt;= nums[mid]:\n            if nums[left] &lt;= target &lt; nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if nums[mid] &lt; target &lt;= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n    return -1\n\n\nnums = [4, 5, 6, 7, 0, 1, 2]\ntarget = 0\nprint(search(nums, target))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_others/#81-search-in-rotated-sorted-array-ii","title":"81. Search in Rotated Sorted Array II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_others/#222-count-complete-tree-nodes","title":"222. Count Complete Tree Nodes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: binary search, bit manipulation, tree, binary tree 222. Count Complete Tree Nodes - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef countNodesRecursive(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    num = 1 + countNodesRecursive(root.left) + countNodesRecursive(root.right)\n\n    return num\n\n\n# Iterative\ndef countNodesIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n    count = 0\n\n    while q:\n        n = len(q)\n\n        for _ in range(n):\n            node = q.popleft()\n            count += 1\n\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return count\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Recursive  |  O(n)  |  O(n)   |\n# | Iterative  |  O(n)  |  O(n)   |\n# |------------|--------|---------|\n\nroot = [1, 2, 3, 4, 5, 6]\nroot = build(root)\nprint(root)\n#     __1__\n#    /     \\\n#   2       3\n#  / \\     /\n# 4   5   6\nprint(countNodesRecursive(root))  # 6\nprint(countNodesIterative(root))  # 6\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_others/#1539-kth-missing-positive-number","title":"1539. Kth Missing Positive Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_others/#540-single-element-in-a-sorted-array","title":"540. Single Element in a Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_others/#4-median-of-two-sorted-arrays","title":"4. Median of Two Sorted Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, divide and conquer 4. Median of Two Sorted Arrays - Python Solution<pre><code>from typing import List\n\n\n# Brute Force\ndef findMedianSortedArraysBF(nums1: List[int], nums2: List[int]) -&gt; float:\n    nums = sorted(nums1 + nums2)\n    n = len(nums)\n    if n % 2 == 0:\n        return (nums[n // 2 - 1] + nums[n // 2]) / 2\n    else:\n        return nums[n // 2]\n\n\n# Binary Search\ndef findMedianSortedArraysBS(nums1: List[int], nums2: List[int]) -&gt; float:\n    if len(nums1) &gt; len(nums2):\n        nums1, nums2 = nums2, nums1\n\n    m, n = len(nums1), len(nums2)\n    imin, imax, half_len = 0, m, (m + n + 1) // 2\n\n    while imin &lt;= imax:\n        i = (imin + imax) // 2\n        j = half_len - i\n\n        if i &lt; m and nums2[j - 1] &gt; nums1[i]:\n            imin = i + 1\n        elif i &gt; 0 and nums1[i - 1] &gt; nums2[j]:\n            imax = i - 1\n        else:\n            if i == 0:\n                max_of_left = nums2[j - 1]\n            elif j == 0:\n                max_of_left = nums1[i - 1]\n            else:\n                max_of_left = max(nums1[i - 1], nums2[j - 1])\n\n            if (m + n) % 2 == 1:\n                return max_of_left\n\n            if i == m:\n                min_of_right = nums2[j]\n            elif j == n:\n                min_of_right = nums1[i]\n            else:\n                min_of_right = min(nums1[i], nums2[j])\n\n            return (max_of_left + min_of_right) / 2\n\n\n# |--------------|-----------------|--------------|\n# | Approach     | Time            | Space        |\n# |--------------|-----------------|--------------|\n# | Brute Force  | O((n+m)log(n+m))| O(n+m)       |\n# | Binary Search| O(log(min(n,m)))| O(1)         |\n# |--------------|-----------------|--------------|\n\n\nnums1 = [1, 3]\nnums2 = [2]\nprint(findMedianSortedArraysBF(nums1, nums2))  # 2.0\nprint(findMedianSortedArraysBS(nums1, nums2))  # 2.0\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_others/#1064-fixed-point","title":"1064. Fixed Point","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_others/#702-search-in-a-sorted-array-of-unknown-size","title":"702. Search in a Sorted Array of Unknown Size","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, interactive</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_others/#2936-number-of-equal-numbers-blocks","title":"2936. Number of Equal Numbers Blocks","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, interactive</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_others/#1060-missing-element-in-sorted-array","title":"1060. Missing Element in Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_others/#1198-find-smallest-common-element-in-all-rows","title":"1198. Find Smallest Common Element in All Rows","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, binary search, matrix, counting</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_others/#1428-leftmost-column-with-at-least-a-one","title":"1428. Leftmost Column with at Least a One","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, matrix, interactive</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_others/#1533-find-the-index-of-the-large-integer","title":"1533. Find the Index of the Large Integer","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, interactive</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_others/#2387-median-of-a-row-wise-sorted-matrix","title":"2387. Median of a Row Wise Sorted Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_others/#302-smallest-rectangle-enclosing-black-pixels","title":"302. Smallest Rectangle Enclosing Black Pixels","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, depth first search, breadth first search, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_tree/","title":"Binary Search Tree","text":""},{"location":"content/endlesscheng/binary_search_tree/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 98. Validate Binary Search Tree (Medium)</li> <li> 230. Kth Smallest Element in a BST (Medium)</li> <li> 501. Find Mode in Binary Search Tree (Easy)</li> <li> 99. Recover Binary Search Tree (Medium)</li> <li> 700. Search in a Binary Search Tree (Easy)</li> <li> 530. Minimum Absolute Difference in BST (Easy)</li> <li> 783. Minimum Distance Between BST Nodes (Easy)</li> <li> 1305. All Elements in Two Binary Search Trees (Medium)</li> <li> 938. Range Sum of BST (Easy)</li> <li> 897. Increasing Order Search Tree (Easy)</li> <li> 2476. Closest Nodes Queries in a Binary Search Tree (Medium)</li> <li> 653. Two Sum IV - Input is a BST (Easy)</li> <li> 1373. Maximum Sum BST in Binary Tree (Hard)</li> <li> 1932. Merge BSTs to Create Single BST (Hard)</li> <li> 285. Inorder Successor in BST (Medium) \ud83d\udc51</li> <li> 510. Inorder Successor in BST II (Medium) \ud83d\udc51</li> <li> 270. Closest Binary Search Tree Value (Easy) \ud83d\udc51</li> <li> 272. Closest Binary Search Tree Value II (Hard) \ud83d\udc51</li> <li> 255. Verify Preorder Sequence in Binary Search Tree (Medium) \ud83d\udc51</li> <li> 1902. Depth of BST Given Insertion Order (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/binary_search_tree/#98-validate-binary-search-tree","title":"98. Validate Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree 98. Validate Binary Search Tree - Python Solution<pre><code>from itertools import pairwise\nfrom math import inf\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef isValidBST1(root: Optional[TreeNode]) -&gt; bool:\n    inorder = []  # inorder traversal\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    for a, b in pairwise(inorder):\n        if a &gt;= b:\n            return False\n\n    return True\n\n\ndef isValidBST2(root: Optional[TreeNode]) -&gt; bool:\n    if not root:\n        return True\n    pre = -inf\n\n    def dfs(node):\n        if not node:\n            return True\n        if not dfs(node.left):\n            return False\n\n        nonlocal pre\n        if node.val &lt;= pre:\n            return False\n        pre = node.val\n\n        return dfs(node.right)\n\n    return dfs(root)\n\n\nif __name__ == \"__main__\":\n    root = [5, 1, 4, None, None, 3, 6]\n    root = build(root)\n    print(root)\n    #   5__\n    #  /   \\\n    # 1     4\n    #      / \\\n    #     3   6\n    assert not isValidBST1(root)  # [1, 5, 3, 4, 6]\n    assert not isValidBST2(root)  # [1, 5, 3, 4, 6]\n</code></pre></p> </li> </ul> 98. Validate Binary Search Tree - C++ Solution<pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   private:\n    vector&lt;int&gt; inorder;\n    bool check(vector&lt;int&gt; inorder) {\n        int n = inorder.size();\n        if (n &lt;= 1) return true;\n        for (int i = 1; i &lt; n; i++) {\n            if (inorder[i] &lt;= inorder[i - 1]) return false;\n        }\n        return true;\n    }\n\n   public:\n    bool isValidBST(TreeNode *root) {\n        auto dfs = [&amp;](auto &amp;&amp;self, TreeNode *node) -&gt; void {\n            if (!node) return;\n\n            self(self, node-&gt;left);\n            inorder.push_back(node-&gt;val);\n            self(self, node-&gt;right);\n        };\n\n        dfs(dfs, root);\n\n        return check(inorder);\n    }\n};\n\nint main() {\n    Solution s;\n    TreeNode *root = new TreeNode(2);\n    root-&gt;left = new TreeNode(1);\n    root-&gt;right = new TreeNode(3);\n    assert(s.isValidBST(root) == true);\n\n    root = new TreeNode(5);\n    root-&gt;left = new TreeNode(1);\n    root-&gt;right = new TreeNode(4);\n    root-&gt;right-&gt;left = new TreeNode(3);\n    root-&gt;right-&gt;right = new TreeNode(6);\n    assert(s.isValidBST(root) == false);\n\n    root = new TreeNode(5);\n    root-&gt;left = new TreeNode(4);\n    root-&gt;right = new TreeNode(6);\n    root-&gt;right-&gt;left = new TreeNode(3);\n    root-&gt;right-&gt;right = new TreeNode(7);\n    assert(s.isValidBST(root) == false);\n\n    return 0;\n}\n</code></pre>"},{"location":"content/endlesscheng/binary_search_tree/#230-kth-smallest-element-in-a-bst","title":"230. Kth Smallest Element in a BST","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree 230. Kth Smallest Element in a BST - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef kthSmallestRecursive(root: Optional[TreeNode], k: int) -&gt; int:\n    inorder = []\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n    return inorder[k - 1]\n\n\n# Iteratve\ndef kthSmallestIteratve(root: Optional[TreeNode], k: int) -&gt; int:\n    stack = []\n    while True:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        k -= 1\n        if not k:\n            return root.val\n        root = root.right\n\n\nif __name__ == \"__main__\":\n    root = build([3, 1, 4, None, 2])\n    k = 1\n    assert kthSmallestRecursive(root, k) == 1\n    assert kthSmallestIteratve(root, k) == 1\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_tree/#501-find-mode-in-binary-search-tree","title":"501. Find Mode in Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree 501. Find Mode in Binary Search Tree - Python Solution<pre><code>from typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef findMode(root: Optional[TreeNode]) -&gt; List[int]:\n    hashmap = dict()\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        if node.val not in hashmap:\n            hashmap[node.val] = 1\n        else:\n            hashmap[node.val] += 1\n        dfs(node.right)\n\n    dfs(root)\n    max_counts = max(hashmap.values())\n    result = []\n\n    for key, value in hashmap.items():\n        if value == max_counts:\n            result.append(key)\n\n    return result\n\n\nroot = [1, None, 2, None, None, 2]\nroot = build(root)\nprint(root)\n# 1__\n#    \\\n#     2\n#    /\n#   2\nprint(findMode(root))  # [2]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_tree/#99-recover-binary-search-tree","title":"99. Recover Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_tree/#700-search-in-a-binary-search-tree","title":"700. Search in a Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, binary search tree, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_tree/#binary-search-tree_1","title":"Binary Search Tree","text":"<ol> <li>Binary Tree</li> <li>Left subtree of a node contains only nodes with keys less than the node's key</li> <li>Right subtree of a node contains only nodes with keys greater than the node's key</li> <li>The left and right subtree each must also be a binary search tree</li> <li>There must be no duplicate nodes</li> <li>Inorder traversal of a BST gives a sorted list of keys</li> </ol> <pre><code>graph TD\n4((4)) --- 2((2))\n4 --- 7((7))\n2 --- 1((1))\n2 --- 3((3))</code></pre> 700. Search in a Binary Search Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# 1. Recursive\ndef searchBSTRecursive(\n    root: Optional[TreeNode], val: int\n) -&gt; Optional[TreeNode]:\n    if not root:\n        return None\n\n    if root.val &gt; val:\n        return searchBSTRecursive(root.left, val)\n\n    elif root.val &lt; val:\n        return searchBSTRecursive(root.right, val)\n\n    else:\n        return root\n\n\n# 2. Iterative\ndef searchBSTIterative(\n    root: Optional[TreeNode], val: int\n) -&gt; Optional[TreeNode]:\n    while root:\n        if root.val &gt; val:\n            root = root.left\n        elif root.val &lt; val:\n            root = root.right\n        else:\n            return root\n    return None\n\n\nroot = [4, 2, 7, 1, 3]\nval = 2\nroot = build(root)\nprint(root)\n#     __4\n#    /   \\\n#   2     7\n#  / \\\n# 1   3\nprint(searchBSTRecursive(root, val))\n#   2\n#  / \\\n# 1   3\nprint(searchBSTIterative(root, val))\n#   2\n#  / \\\n# 1   3\n</code></pre>"},{"location":"content/endlesscheng/binary_search_tree/#530-minimum-absolute-difference-in-bst","title":"530. Minimum Absolute Difference in BST","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary search tree, binary tree 530. Minimum Absolute Difference in BST - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef getMinimumDifference(root: Optional[TreeNode]) -&gt; int:\n    res = float(\"inf\")\n    pre = float(\"-inf\")\n\n    def dfs(node):  # inorder traversal\n        if not node:\n            return\n\n        dfs(node.left)\n\n        nonlocal res, pre\n        res = min(res, node.val - pre)\n        pre = node.val\n\n        if res == 1:  # the minimum possible difference\n            return\n\n        dfs(node.right)\n\n    dfs(root)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    root = [4, 2, 6, 1, 3]\n    root = build(root)\n    print(root)\n    #     __4\n    #    /   \\\n    #   2     6\n    #  / \\\n    # 1   3\n    assert getMinimumDifference(root) == 1\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_tree/#783-minimum-distance-between-bst-nodes","title":"783. Minimum Distance Between BST Nodes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary search tree, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_tree/#1305-all-elements-in-two-binary-search-trees","title":"1305. All Elements in Two Binary Search Trees","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, sorting, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_tree/#938-range-sum-of-bst","title":"938. Range Sum of BST","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_tree/#897-increasing-order-search-tree","title":"897. Increasing Order Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: stack, tree, depth first search, binary search tree, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_tree/#2476-closest-nodes-queries-in-a-binary-search-tree","title":"2476. Closest Nodes Queries in a Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, tree, depth first search, binary search tree, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_tree/#653-two-sum-iv-input-is-a-bst","title":"653. Two Sum IV - Input is a BST","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, two pointers, tree, depth first search, breadth first search, binary search tree, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_tree/#1373-maximum-sum-bst-in-binary-tree","title":"1373. Maximum Sum BST in Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, tree, depth first search, binary search tree, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_tree/#1932-merge-bsts-to-create-single-bst","title":"1932. Merge BSTs to Create Single BST","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, binary search, tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_tree/#285-inorder-successor-in-bst","title":"285. Inorder Successor in BST","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_tree/#510-inorder-successor-in-bst-ii","title":"510. Inorder Successor in BST II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, binary search tree, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_tree/#270-closest-binary-search-tree-value","title":"270. Closest Binary Search Tree Value","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: binary search, tree, depth first search, binary search tree, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_tree/#272-closest-binary-search-tree-value-ii","title":"272. Closest Binary Search Tree Value II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: two pointers, stack, tree, depth first search, binary search tree, heap priority queue, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_tree/#255-verify-preorder-sequence-in-binary-search-tree","title":"255. Verify Preorder Sequence in Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, tree, binary search tree, recursion, monotonic stack, binary tree 255. Verify Preorder Sequence in Binary Search Tree - Python Solution<pre><code>from typing import List\n\n\n# BST\ndef verifyPreorder(preorder: List[int]) -&gt; bool:\n    stack = []\n    low = float(\"-inf\")\n\n    for value in preorder:\n        if value &lt; low:\n            return False\n        while stack and value &gt; stack[-1]:\n            low = stack.pop()\n        stack.append(value)\n\n    return True\n\n\nif __name__ == \"__main__\":\n    assert verifyPreorder([8, 5, 1, 7, 10, 12]) is True\n    assert verifyPreorder([8, 5, 4, 3, 2, 1]) is True\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_search_tree/#1902-depth-of-bst-given-insertion-order","title":"1902. Depth of BST Given Insertion Order","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, tree, binary search tree, binary tree, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_backtracking/","title":"Binary Tree Backtracking","text":""},{"location":"content/endlesscheng/binary_tree_backtracking/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 257. Binary Tree Paths (Easy)</li> <li> 113. Path Sum II (Medium)</li> <li> 437. Path Sum III (Medium)</li> </ul>"},{"location":"content/endlesscheng/binary_tree_backtracking/#257-binary-tree-paths","title":"257. Binary Tree Paths","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, backtracking, tree, depth first search, binary tree 257. Binary Tree Paths - Python Solution<pre><code>from typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef binaryTreePaths(root: Optional[TreeNode]) -&gt; List[str]:\n    res = []\n\n    def dfs(node, path):\n        if not node:\n            return\n        path += str(node.val)\n\n        if not node.left and not node.right:\n            res.append(path)\n            return\n\n        path += \"-&gt;\"\n\n        dfs(node.left, path)\n        dfs(node.right, path)\n\n    dfs(root, \"\")\n\n    return res\n\n\nroot = build([1, 2, 3, None, 5])\nprint(root)\n#   __1\n#  /   \\\n# 2     3\n#  \\\n#   5\nprint(binaryTreePaths(root))  # ['1-&gt;2-&gt;5', '1-&gt;3']\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_backtracking/#113-path-sum-ii","title":"113. Path Sum II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: backtracking, tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_backtracking/#437-path-sum-iii","title":"437. Path Sum III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree 437. Path Sum III - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   public:\n    int pathSum(TreeNode *root, int targetSum) {\n        int res = 0;\n        unordered_map&lt;long long, int&gt; cnt{{0, 1}};\n\n        auto dfs = [&amp;](auto &amp;&amp;self, TreeNode *node, long long cur) {\n            if (!node) return;\n            cur += node-&gt;val;\n\n            if (cnt.find(cur - targetSum) != cnt.end())\n                res += cnt[cur - targetSum];\n\n            cnt[cur]++;\n            self(self, node-&gt;left, cur);\n            self(self, node-&gt;right, cur);\n            cnt[cur]--;\n        };\n\n        dfs(dfs, root, 0);\n        return res;\n    }\n};\n\nint main() {\n    Solution s;\n    {\n        TreeNode *root = new TreeNode(10);\n        root-&gt;left = new TreeNode(5);\n        root-&gt;right = new TreeNode(-3);\n        root-&gt;left-&gt;left = new TreeNode(3);\n        root-&gt;left-&gt;right = new TreeNode(2);\n        root-&gt;right-&gt;right = new TreeNode(11);\n        root-&gt;left-&gt;left-&gt;left = new TreeNode(3);\n        root-&gt;left-&gt;left-&gt;right = new TreeNode(-2);\n        root-&gt;left-&gt;right-&gt;right = new TreeNode(1);\n        cout &lt;&lt; s.pathSum(root, 8) &lt;&lt; endl;  // 3\n    }\n    {\n        TreeNode *root = new TreeNode(5);\n        root-&gt;left = new TreeNode(4);\n        root-&gt;right = new TreeNode(8);\n        root-&gt;left-&gt;left = new TreeNode(11);\n        root-&gt;right-&gt;left = new TreeNode(13);\n        root-&gt;right-&gt;right = new TreeNode(4);\n        root-&gt;left-&gt;left-&gt;left = new TreeNode(7);\n        root-&gt;left-&gt;left-&gt;right = new TreeNode(2);\n        root-&gt;right-&gt;right-&gt;left = new TreeNode(5);\n        root-&gt;right-&gt;right-&gt;right = new TreeNode(1);\n        cout &lt;&lt; s.pathSum(root, 22) &lt;&lt; endl;  // 3\n    }\n    return 0;\n}\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bfs/","title":"Binary Tree BFS","text":""},{"location":"content/endlesscheng/binary_tree_bfs/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 102. Binary Tree Level Order Traversal (Medium)</li> <li> 103. Binary Tree Zigzag Level Order Traversal (Medium)</li> <li> 107. Binary Tree Level Order Traversal II (Medium)</li> <li> 199. Binary Tree Right Side View (Medium)</li> <li> 513. Find Bottom Left Tree Value (Medium)</li> <li> 515. Find Largest Value in Each Tree Row (Medium)</li> <li> 637. Average of Levels in Binary Tree (Easy)</li> <li> 1161. Maximum Level Sum of a Binary Tree (Medium)</li> <li> 993. Cousins in Binary Tree (Easy)</li> <li> 2583. Kth Largest Sum in a Binary Tree (Medium)</li> <li> 1302. Deepest Leaves Sum (Medium)</li> <li> 2415. Reverse Odd Levels of Binary Tree (Medium)</li> <li> 1609. Even Odd Tree (Medium)</li> <li> 623. Add One Row to Tree (Medium)</li> <li> 2471. Minimum Number of Operations to Sort a Binary Tree by Level (Medium)</li> <li> 863. All Nodes Distance K in Binary Tree (Medium)</li> <li> 2641. Cousins in Binary Tree II (Medium)</li> <li> 919. Complete Binary Tree Inserter (Medium)</li> <li> 331. Verify Preorder Serialization of a Binary Tree (Medium)</li> <li> 958. Check Completeness of a Binary Tree (Medium)</li> <li> 662. Maximum Width of Binary Tree (Medium)</li> <li> 3157. Find the Level of Tree with Minimum Sum (Medium) \ud83d\udc51</li> <li> 1602. Find Nearest Right Node in Binary Tree (Medium) \ud83d\udc51</li> <li> 742. Closest Leaf in a Binary Tree (Medium) \ud83d\udc51</li> <li> 1660. Correct a Binary Tree (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/binary_tree_bfs/#102-binary-tree-level-order-traversal","title":"102. Binary Tree Level Order Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, breadth first search, binary tree 102. Binary Tree Level Order Traversal - Python Solution<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef levelOrder(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        level = []\n        size = len(q)\n\n        for _ in range(size):\n            cur = q.popleft()\n            level.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(level)\n\n    return res\n\n\ntree = build([3, 9, 20, None, None, 15, 7])\nprint(tree)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(levelOrder(tree))  # [[3], [9, 20], [15, 7]]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bfs/#103-binary-tree-zigzag-level-order-traversal","title":"103. Binary Tree Zigzag Level Order Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, breadth first search, binary tree 103. Binary Tree Zigzag Level Order Traversal - Python Solution<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef zigzagLevelOrder(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        level = []\n        size = len(q)\n\n        for _ in range(size):\n            cur = q.popleft()\n            level.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(level if not len(res) % 2 else level[::-1])\n\n    return res\n\n\nif __name__ == \"__main__\":\n    tree = build([3, 9, 20, None, None, 15, 7])\n    print(tree)\n    #   3___\n    #  /    \\\n    # 9     _20\n    #      /   \\\n    #     15    7\n    assert zigzagLevelOrder(tree) == [[3], [20, 9], [15, 7]]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bfs/#107-binary-tree-level-order-traversal-ii","title":"107. Binary Tree Level Order Traversal II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, breadth first search, binary tree 107. Binary Tree Level Order Traversal II - Python Solution<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef levelOrderBottom(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    res = []\n    q = deque([root])\n\n    while q:\n        level = []\n        n = len(q)\n\n        for _ in range(n):\n            cur = q.popleft()\n            level.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(level)\n\n    return res[::-1]\n\n\ntree = build([3, 9, 20, None, None, 15, 7])\nprint(tree)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(levelOrderBottom(tree))  # [[15, 7], [9, 20], [3]]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bfs/#199-binary-tree-right-side-view","title":"199. Binary Tree Right Side View","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 199. Binary Tree Right Side View - Python Solution<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Binary Tree BFS\ndef rightSideViewBFS(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        n = len(q)\n        for i in range(n):\n            node = q.popleft()\n            if i == n - 1:\n                res.append(node.val)\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return res\n\n\n# Binary Tree DFS\ndef rightSideViewDFS(root: Optional[TreeNode]) -&gt; List[int]:\n    \"\"\"\u540e\u5e8f\u904d\u5386\uff0c\u5148\u53f3\u540e\u5de6\uff0c\u9047\u5230\u7684\u7b2c\u4e00\u4e2a\u8282\u70b9\u5c31\u662f\u8be5\u6df1\u5ea6\u7684\u6700\u53f3\u4fa7\u8282\u70b9\"\"\"\n    ans = []\n\n    def dfs(node, depth):\n        if node is None:\n            return\n        if depth == len(ans):  # \u8fd9\u4e2a\u6df1\u5ea6\u9996\u6b21\u9047\u5230\n            ans.append(node.val)\n\n        dfs(node.right, depth + 1)\n        dfs(node.left, depth + 1)\n\n    dfs(root, 0)\n\n    return ans\n\n\nif __name__ == \"__main__\":\n    root = [1, 2, 2, 3, 4, None, 3, None, None, 5]\n    root = build(root)\n    print(root)\n    #     ____1\n    #    /     \\\n    #   2__     2\n    #  /   \\     \\\n    # 3     4     3\n    #      /\n    #     5\n    assert rightSideViewBFS(root) == [1, 2, 3, 5]\n    assert rightSideViewDFS(root) == [1, 2, 3, 5]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bfs/#513-find-bottom-left-tree-value","title":"513. Find Bottom Left Tree Value","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 513. Find Bottom Left Tree Value - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef findBottomLeftValue(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    queue = deque([root])\n    result = 0\n\n    while queue:\n        size = len(queue)\n\n        for i in range(size):\n            node = queue.popleft()\n            if i == 0:\n                result = node.val\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n    return result\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n#     ____1\n#    /     \\\n#   2__     2\n#  /   \\\n# 3     4\n#      /\n#     5\n\nprint(findBottomLeftValue(root))  # 5\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bfs/#515-find-largest-value-in-each-tree-row","title":"515. Find Largest Value in Each Tree Row","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 515. Find Largest Value in Each Tree Row - Python Solution<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef largestValues(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    queue = deque([root])\n    result = []\n\n    while queue:\n        levelMax = float(\"-inf\")\n        for _ in range(len(queue)):\n            node = queue.popleft()\n\n            levelMax = max(levelMax, node.val)\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n        result.append(levelMax)\n\n    return result\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n#     ____1\n#    /     \\\n#   2__     2\n#  /   \\\n# 3     4\n#      /\n#     5\nprint(largestValues(root))  # [1, 2, 4, 5]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bfs/#637-average-of-levels-in-binary-tree","title":"637. Average of Levels in Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 637. Average of Levels in Binary Tree - Python Solution<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Binary Tree BFS\ndef averageOfLevels(root: Optional[TreeNode]) -&gt; List[float]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        n = len(q)\n        level = 0\n        for _ in range(n):\n            cur = q.popleft()\n            level += cur.val\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(float(level / n))\n\n    return res\n\n\nif __name__ == \"__main__\":\n    root = [3, 9, 20, None, None, 15, 7]\n    root = build(root)\n    print(root)\n    #   3___\n    #  /    \\\n    # 9     _20\n    #      /   \\\n    #     15    7\n    assert averageOfLevels(root) == [3.00000, 14.50000, 11.00000]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bfs/#1161-maximum-level-sum-of-a-binary-tree","title":"1161. Maximum Level Sum of a Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 1161. Maximum Level Sum of a Binary Tree - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BFS\ndef maxLevelSum(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n    res = 0\n    maxSum = float(\"-inf\")\n    level = 1\n\n    while q:\n        n = len(q)\n        curSum = 0\n\n        for _ in range(n):\n            node = q.popleft()\n            curSum += node.val\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n        if curSum &gt; maxSum:\n            maxSum = curSum\n            res = level\n        level += 1\n\n    return res\n\n\nroot = [1, 7, 0, 7, -8, None, None]\nroot = build(root)\nprint(root)\n#     ___1\n#    /    \\\n#   7      0\n#  / \\\n# 7   -8\nprint(maxLevelSum(root))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bfs/#993-cousins-in-binary-tree","title":"993. Cousins in Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 993. Cousins in Binary Tree - Python Solution<pre><code>from collections import deque\nfrom math import inf\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef is_cousins_bfs(root: Optional[TreeNode], x: int, y: int) -&gt; bool:\n    if not root:\n        return False\n\n    q = deque([(root, inf)])\n\n    while q:\n        size = len(q)\n        p1, p2 = None, None\n\n        for _ in range(size):\n            cur, par = q.popleft()\n            val = cur.val\n            if x == val:\n                p1 = par\n            if y == val:\n                p2 = par\n\n            if cur.left:\n                q.append((cur.left, val))\n            if cur.right:\n                q.append((cur.right, val))\n\n        # Check if both found at same level\n        if p1 and p2:\n            return p1 != p2  # Same level, different parents\n        elif p1 or p2:\n            return False  # Only one found at this level\n\n    return False\n\n\nif __name__ == \"__main__\":\n    root = build([1, 2, 3, None, 4, None, 5])\n    assert is_cousins_bfs(root, 5, 4)\n    root = build([1, 2, 3, None, 4])\n    assert not is_cousins_bfs(root, 2, 3)\n    root = build([1, 2, 3, 4])\n    assert not is_cousins_bfs(root, 4, 3)\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bfs/#2583-kth-largest-sum-in-a-binary-tree","title":"2583. Kth Largest Sum in a Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, breadth first search, sorting, binary tree 2583. Kth Largest Sum in a Binary Tree - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BFS\ndef kthLargestLevelSum(root: Optional[TreeNode], k: int) -&gt; int:\n    if not root:\n        return 0\n    sums = []\n    q = deque([root])\n\n    while q:\n        size = len(q)\n        level = 0\n        for _ in range(size):\n            node = q.popleft()\n            level += node.val\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n        sums.append(level)\n\n    if len(sums) &lt; k:\n        return -1\n\n    sums.sort()\n    return sums[-k]\n\n\nroot = [5, 8, 9, 2, 1, 3, 7, 4, 6]\nroot = build(root)\nk = 2\nprint(kthLargestLevelSum(root, k))  # 13\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bfs/#1302-deepest-leaves-sum","title":"1302. Deepest Leaves Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 1302. Deepest Leaves Sum - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BFS\ndef deepestLeavesSum(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n\n    while q:\n        n = len(q)\n        res = 0\n        for _ in range(n):\n            node = q.popleft()\n            res += node.val\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return res\n\n\nroot = [1, 2, 3, 4, 5, None, 6, 7, None, None, None, None, None, 8]\nroot = build(root)\nprint(root)\n#       __1\n#      /   \\\n#     2     3__\n#    / \\       \\\n#   4   5       6\n#  /           /\n# 7           8\nprint(deepestLeavesSum(root))  # 15\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bfs/#2415-reverse-odd-levels-of-binary-tree","title":"2415. Reverse Odd Levels of Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 2415. Reverse Odd Levels of Binary Tree - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef reverseOddLevels(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return None\n\n    q = deque([root])\n    level = -1\n\n    while q:\n        size = len(q)\n        nodes = []\n        level += 1\n\n        for _ in range(size):\n            node = q.popleft()\n            nodes.append(node)\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n        if level % 2 == 1:\n            i, j = 0, len(nodes) - 1\n            while i &lt; j:\n                nodes[i].val, nodes[j].val = nodes[j].val, nodes[i].val\n                i += 1\n                j -= 1\n\n    return root\n\n\nif __name__ == \"__main__\":\n    root = build([2, 3, 5, 8, 13, 21, 34])\n    print(root)\n    #     ___2___\n    #    /       \\\n    #   3        _5\n    #  / \\      /  \\\n    # 8   13   21   34\n    print(reverseOddLevels(root))\n    #     ___2___\n    #    /       \\\n    #   5        _3\n    #  / \\      /  \\\n    # 8   13   21   34\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bfs/#1609-even-odd-tree","title":"1609. Even Odd Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, breadth first search, binary tree 1609. Even Odd Tree - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef isEvenOddTree(root: Optional[TreeNode]) -&gt; bool:\n    if not root:\n        return True\n\n    q = deque([root])\n    level = 0\n\n    while q:\n        size = len(q)\n        prev = None\n\n        for _ in range(size):\n            node = q.popleft()\n\n            if level % 2 == 0:\n                if node.val % 2 == 0:\n                    return False\n                if prev and node.val &lt;= prev:\n                    return False\n            else:\n                if node.val % 2 == 1:\n                    return False\n                if prev and node.val &gt;= prev:\n                    return False\n\n            prev = node.val\n\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n        level += 1\n\n    return True\n\n\nif __name__ == \"__main__\":\n    root = build([5, 4, 2, 3, 3, 7])\n    print(root)\n    #     __5__\n    #    /     \\\n    #   4       2\n    #  / \\     /\n    # 3   3   7\n    assert isEvenOddTree(root) is False\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bfs/#623-add-one-row-to-tree","title":"623. Add One Row to Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 623. Add One Row to Tree - Python Solution<pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BFS\ndef addOneRow_bfs(\n    root: Optional[TreeNode], val: int, depth: int\n) -&gt; Optional[TreeNode]:\n    if not root:\n        return None\n\n    if depth == 1:\n        new = TreeNode(val)\n        new.left = root\n        return new\n\n    q = deque([root])\n    cur = 1\n\n    while q:\n        size = len(q)\n        for _ in range(size):\n            node = q.popleft()\n\n            if cur == depth - 1:\n                old_left, old_right = node.left, node.right\n                node.left, node.right = TreeNode(val), TreeNode(val)\n                node.left.left = old_left\n                node.right.right = old_right\n            else:\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n        cur += 1\n\n    return root\n\n\n# DFS\ndef addOneRow_dfs(\n    root: Optional[TreeNode], val: int, depth: int\n) -&gt; Optional[TreeNode]:\n    if depth == 1:\n        new = TreeNode(val)\n        new.left = root\n        return new\n\n    def dfs(node, cur):\n        if not node:\n            return\n        if cur == depth - 1:\n            old_left, old_right = node.left, node.right\n            node.left = TreeNode(val, old_left, None)\n            node.right = TreeNode(val, None, old_right)\n        else:\n            dfs(node.left, cur + 1)\n            dfs(node.right, cur + 1)\n\n    dfs(root, 1)\n\n    return root\n\n\nif __name__ == \"__main__\":\n    root = build([4, 2, 6, 3, 1, 5])\n    print(root)\n    #     __4__\n    #    /     \\\n    #   2       6\n    #  / \\     /\n    # 3   1   5\n    print(addOneRow_bfs(deepcopy(root), 1, 2))\n    #         4\n    #        / \\\n    #     __1   1__\n    #    /         \\\n    #   2           6\n    #  / \\         /\n    # 3   1       5\n    print(addOneRow_dfs(deepcopy(root), 1, 2))\n    #         4\n    #        / \\\n    #     __1   1__\n    #    /         \\\n    #   2           6\n    #  / \\         /\n    # 3   1       5\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bfs/#2471-minimum-number-of-operations-to-sort-a-binary-tree-by-level","title":"2471. Minimum Number of Operations to Sort a Binary Tree by Level","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, breadth first search, binary tree 2471. Minimum Number of Operations to Sort a Binary Tree by Level - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef _min_swaps_to_sort(nums):\n    \"\"\"\n    Calculate the minimum number of swaps to sort the array.\n    Method: Permutation Cycle\n    \"\"\"\n    n = len(nums)\n    arr = [(num, i) for i, num in enumerate(nums)]\n    arr.sort(key=lambda x: x[0])\n\n    visited = [False] * n\n    res = 0\n\n    for i in range(n):\n        if visited[i] or arr[i][1] == i:\n            continue\n\n        cycle_len = 0\n        j = i\n        while not visited[j]:\n            visited[j] = True\n            j = arr[j][1]\n            cycle_len += 1\n\n        if cycle_len &gt; 1:\n            res += cycle_len - 1\n\n    return res\n\n\ndef minimumOperations_bfs(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    res = 0\n    q = deque([root])\n\n    while q:\n        size = len(q)\n        level = []\n        for _ in range(size):\n            node = q.popleft()\n            level.append(node.val)\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n        res += _min_swaps_to_sort(level)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    root = build([1, 4, 3, 7, 6, 8, 5, None, None, None, None, 9, None, 10])\n    print(root)\n    #     __1____\n    #    /       \\\n    #   4         3___\n    #  / \\       /    \\\n    # 7   6     8     _5\n    #          /     /\n    #         9     10\n    assert minimumOperations_bfs(root) == 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bfs/#863-all-nodes-distance-k-in-binary-tree","title":"863. All Nodes Distance K in Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, tree, depth first search, breadth first search, binary tree 863. All Nodes Distance K in Binary Tree - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BFS\ndef distanceK(root: TreeNode, target: TreeNode, k: int) -&gt; List[int]:\n    parent = dict()\n\n    def dfs(node, par=None):\n        if node:\n            parent[node] = par\n            dfs(node.left, node)\n            dfs(node.right, node)\n\n    dfs(root)\n\n    q = deque([(target, 0)])\n    seen = set([target])\n\n    while q:\n        node, dist = q.popleft()\n\n        if dist == k:\n            return [node.val] + [node.val for node, _ in q]\n\n        for nei in (node.left, node.right, parent[node]):\n            if nei and nei not in seen:\n                seen.add(nei)\n                q.append((nei, dist + 1))\n\n    return []\n\n\nroot = build([3, 5, 1, 6, 2, 0, 8, None, None, 7, 4])\nprint(root)\n#     ______3__\n#    /         \\\n#   5__         1\n#  /   \\       / \\\n# 6     2     0   8\n#      / \\\n#     7   4\ntarget = root.left\nk = 2\nprint(distanceK(root, target, k))  # [7, 4, 1]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bfs/#2641-cousins-in-binary-tree-ii","title":"2641. Cousins in Binary Tree II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, tree, depth first search, breadth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bfs/#919-complete-binary-tree-inserter","title":"919. Complete Binary Tree Inserter","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, breadth first search, design, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bfs/#331-verify-preorder-serialization-of-a-binary-tree","title":"331. Verify Preorder Serialization of a Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack, tree, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bfs/#958-check-completeness-of-a-binary-tree","title":"958. Check Completeness of a Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, breadth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bfs/#662-maximum-width-of-binary-tree","title":"662. Maximum Width of Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bfs/#3157-find-the-level-of-tree-with-minimum-sum","title":"3157. Find the Level of Tree with Minimum Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bfs/#1602-find-nearest-right-node-in-binary-tree","title":"1602. Find Nearest Right Node in Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, breadth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bfs/#742-closest-leaf-in-a-binary-tree","title":"742. Closest Leaf in a Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bfs/#1660-correct-a-binary-tree","title":"1660. Correct a Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, tree, depth first search, breadth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bottom-up_dfs/","title":"Binary Tree Bottom-Up DFS","text":""},{"location":"content/endlesscheng/binary_tree_bottom-up_dfs/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 104. Maximum Depth of Binary Tree (Easy)</li> <li> 111. Minimum Depth of Binary Tree (Easy)</li> <li> 965. Univalued Binary Tree (Easy)</li> <li> 100. Same Tree (Easy)</li> <li> 101. Symmetric Tree (Easy)</li> <li> 951. Flip Equivalent Binary Trees (Medium)</li> <li> 1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree (Easy)</li> <li> 110. Balanced Binary Tree (Easy)</li> <li> 226. Invert Binary Tree (Easy)</li> <li> 617. Merge Two Binary Trees (Easy)</li> <li> 2331. Evaluate Boolean Binary Tree (Easy)</li> <li> 508. Most Frequent Subtree Sum (Medium)</li> <li> 563. Binary Tree Tilt (Easy)</li> <li> 606. Construct String from Binary Tree (Medium)</li> <li> 2265. Count Nodes Equal to Average of Subtree (Medium)</li> <li> 1026. Maximum Difference Between Node and Ancestor (Medium)</li> <li> 3319. K-th Largest Perfect Subtree Size in Binary Tree (Medium)</li> <li> 1339. Maximum Product of Splitted Binary Tree (Medium)</li> <li> 1372. Longest ZigZag Path in a Binary Tree (Medium)</li> <li> 1145. Binary Tree Coloring Game (Medium)</li> <li> 572. Subtree of Another Tree (Easy)</li> <li> 1530. Number of Good Leaf Nodes Pairs (Medium)</li> <li> 298. Binary Tree Longest Consecutive Sequence (Medium) \ud83d\udc51</li> <li> 250. Count Univalue Subtrees (Medium) \ud83d\udc51</li> <li> 1973. Count Nodes Equal to Sum of Descendants (Medium) \ud83d\udc51</li> <li> 663. Equal Tree Partition (Medium) \ud83d\udc51</li> <li> 1120. Maximum Average Subtree (Medium) \ud83d\udc51</li> <li> 2792. Count Nodes That Are Great Enough (Hard) \ud83d\udc51</li> <li> 333. Largest BST Subtree (Medium) \ud83d\udc51</li> <li> 366. Find Leaves of Binary Tree (Medium) \ud83d\udc51</li> <li> 156. Binary Tree Upside Down (Medium) \ud83d\udc51</li> <li> 1612. Check If Two Expression Trees are Equivalent (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/binary_tree_bottom-up_dfs/#104-maximum-depth-of-binary-tree","title":"104. Maximum Depth of Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 104. Maximum Depth of Binary Tree - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef maxDepthRecursive(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    left = maxDepthRecursive(root.left)\n    right = maxDepthRecursive(root.right)\n\n    return 1 + max(left, right)\n\n\n# DFS\ndef maxDepthDFS(root: Optional[TreeNode]) -&gt; int:\n    res = 0\n\n    def dfs(node, cnt):\n        if node is None:\n            return\n        cnt += 1\n        nonlocal res\n        res = max(res, cnt)\n\n        dfs(node.left, cnt)\n        dfs(node.right, cnt)\n\n    dfs(root, 0)\n\n    return res\n\n\n# Iterative\ndef maxDepthIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n    res = 0\n\n    while q:\n        res += 1\n        n = len(q)\n\n        for _ in range(n):\n            node = q.popleft()\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    root = [1, 2, 2, 3, 4, None, None, None, None, 5]\n    root = build(root)\n    print(root)\n    #     ____1\n    #    /     \\\n    #   2__     2\n    #  /   \\\n    # 3     4\n    #      /\n    #     5\n    assert maxDepthRecursive(root) == 4\n    assert maxDepthDFS(root) == 4\n    assert maxDepthIterative(root) == 4\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bottom-up_dfs/#111-minimum-depth-of-binary-tree","title":"111. Minimum Depth of Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 111. Minimum Depth of Binary Tree - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Iterative\ndef minDepthIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n    res = 0\n\n    while q:\n        res += 1\n\n        for _ in range(len(q)):\n            node = q.popleft()\n\n            if not node.left and not node.right:\n                return res\n\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n\n# Recursive\ndef minDepthRecursive(root: Optional[TreeNode]) -&gt; int:\n    if root is None:\n        return 0\n\n    if root.left is None and root.right is not None:\n        return 1 + minDepthRecursive(root.right)\n    if root.left is not None and root.right is None:\n        return 1 + minDepthRecursive(root.left)\n\n    return 1 + min(minDepthRecursive(root.left), minDepthRecursive(root.right))\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n\"\"\"\n    ____1\n   /     \\\n  2__     2\n /   \\\n3     4\n     /\n    5\n\n\"\"\"\nprint(minDepthIterative(root))  # 2\nprint(minDepthRecursive(root))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bottom-up_dfs/#965-univalued-binary-tree","title":"965. Univalued Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bottom-up_dfs/#100-same-tree","title":"100. Same Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 100. Same Tree - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# 1. Recursive\ndef isSameTreeRecursive(p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:\n    if not p and not q:\n        return True\n    elif not p or not q:\n        return False\n    elif p.val != q.val:\n        return False\n\n    return isSameTreeRecursive(p.left, q.left) and isSameTreeRecursive(\n        p.right, q.right\n    )\n\n\n# 2. Iterative with queue\ndef isSameTreeIterativeQueue(\n    p: Optional[TreeNode], q: Optional[TreeNode]\n) -&gt; bool:\n    queue = deque([(p, q)])\n\n    while queue:\n        p, q = queue.popleft()\n\n        if not p and not q:\n            continue\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n\n        queue.append((p.left, q.left))\n        queue.append((p.right, q.right))\n\n    return True\n\n\n# 3. Iterative with stack\ndef isSameTreeIterativeStack(\n    p: Optional[TreeNode], q: Optional[TreeNode]\n) -&gt; bool:\n    stack = [(p, q)]\n\n    while stack:\n        n1, n2 = stack.pop()\n\n        if not n1 and not n2:\n            continue\n        if not n1 or not n2:\n            return False\n        if n1.val != n2.val:\n            return False\n\n        stack.append((n1.left, n2.left))\n        stack.append((n1.right, n2.right))\n\n    return True\n\n\nif __name__ == \"__main__\":\n    p1 = build([1, 2, 3])\n    q1 = build([1, 2, 3])\n    p2 = build([1, 2])\n    q2 = build([1, None, 2])\n\n    assert isSameTreeRecursive(p1, q1) is True\n    assert isSameTreeRecursive(p2, q2) is False\n    assert isSameTreeIterativeQueue(p1, q1) is True\n    assert isSameTreeIterativeQueue(p2, q2) is False\n    assert isSameTreeIterativeStack(p1, q1) is True\n    assert isSameTreeIterativeStack(p2, q2) is False\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bottom-up_dfs/#101-symmetric-tree","title":"101. Symmetric Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 101. Symmetric Tree - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef is_symmetric_recursive(root: Optional[TreeNode]) -&gt; bool:\n    if not root:\n        return True\n\n    def check(left, right):\n        if left is right:\n            return True\n        if not left or not right or left.val != right.val:\n            return False\n        outside = check(left.left, right.right)\n        inside = check(left.right, right.left)\n        return outside and inside\n\n    return check(root.left, root.right)\n\n\n# Iterative\ndef is_symmetric_iterative(root: Optional[TreeNode]) -&gt; bool:\n    if not root:\n        return True\n\n    q = deque()\n    q.append(root.left)\n    q.append(root.right)\n\n    while q:\n        left = q.popleft()\n        right = q.popleft()\n\n        if not left and not right:\n            continue\n\n        if not left or not right or left.val != right.val:\n            return False\n\n        q.append(left.left)\n        q.append(right.right)\n        q.append(left.right)\n        q.append(right.left)\n\n    return True\n\n\nif __name__ == \"__main__\":\n    root = [1, 2, 2, 3, 4, 4, 3]\n    root = build(root)\n    print(root)\n    #     __1__\n    #    /     \\\n    #   2       2\n    #  / \\     / \\\n    # 3   4   4   3\n    assert is_symmetric_recursive(root) is True\n    assert is_symmetric_iterative(root) is True\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bottom-up_dfs/#951-flip-equivalent-binary-trees","title":"951. Flip Equivalent Binary Trees","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bottom-up_dfs/#1379-find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree","title":"1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bottom-up_dfs/#110-balanced-binary-tree","title":"110. Balanced Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, binary tree 110. Balanced Binary Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef isBalanced(root: Optional[TreeNode]) -&gt; bool:\n    def getHeight(node):\n        if not node:\n            return 0\n\n        # post order\n        leftHeight = getHeight(node.left)\n        rightHeight = getHeight(node.right)\n\n        if leftHeight == -1 or rightHeight == -1:\n            return -1\n\n        if abs(leftHeight - rightHeight) &gt; 1:\n            return -1\n        else:\n            return 1 + max(leftHeight, rightHeight)\n\n    if getHeight(root) != -1:\n        return True\n    else:\n        return False\n\n\nroot = [3, 9, 20, None, None, 15, 7]\nroot = build(root)\nprint(root)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(isBalanced(root))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bottom-up_dfs/#226-invert-binary-tree","title":"226. Invert Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 226. Invert Binary Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef invertTreeRecursive(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    root.left, root.right = root.right, root.left\n\n    invertTreeRecursive(root.left)\n    invertTreeRecursive(root.right)\n\n    return root\n\n\n# Iterative\ndef invertTreeIterative(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    stack = [root]\n\n    while stack:\n        node = stack.pop()\n\n        node.left, node.right = node.right, node.left\n        if node.left:\n            stack.append(node.left)\n        if node.right:\n            stack.append(node.right)\n\n    return root\n\n\nroot = build([4, 2, 7, 1, 3, 6, 9])\nprint(root)\n#     __4__\n#    /     \\\n#   2       7\n#  / \\     / \\\n# 1   3   6   9\ninvertedRecursive = invertTreeRecursive(root)\nprint(invertedRecursive)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\nroot = build([4, 2, 7, 1, 3, 6, 9])\ninvertedIterative = invertTreeIterative(root)\nprint(invertedIterative)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bottom-up_dfs/#617-merge-two-binary-trees","title":"617. Merge Two Binary Trees","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 617. Merge Two Binary Trees - Python Solution<pre><code>from typing import List, Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef mergeTrees(\n    root1: Optional[TreeNode], root2: Optional[TreeNode]\n) -&gt; Optional[TreeNode]:\n\n    if not root1:\n        return root2\n    if not root2:\n        return root1\n\n    root = TreeNode()\n\n    root.val += root1.val + root2.val\n    root.left = mergeTrees(root1.left, root2.left)\n    root.right = mergeTrees(root1.right, root2.right)\n\n    return root\n\n\nroot1 = TreeNode(1)\nroot1.left = TreeNode(3)\nroot1.right = TreeNode(2)\nroot1.left.left = TreeNode(5)\n#     1\n#    / \\\n#   3   2\n#  /\n# 5\n\nroot2 = TreeNode(2)\nroot2.left = TreeNode(1)\nroot2.right = TreeNode(3)\nroot2.left.right = TreeNode(4)\nroot2.right.right = TreeNode(7)\n#     2\n#    / \\\n#   1   3\n#    \\   \\\n#     4   7\n\nroot = mergeTrees(root1, root2)\n#     3\n#    / \\\n#   4   5\n#  / \\   \\\n# 5   4   7\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bottom-up_dfs/#2331-evaluate-boolean-binary-tree","title":"2331. Evaluate Boolean Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, binary tree 2331. Evaluate Boolean Binary Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef evaluateTree(root: Optional[TreeNode]) -&gt; bool:\n    if not root.left and not root.right:\n        return root.val\n\n    left = evaluateTree(root.left)\n    right = evaluateTree(root.right)\n\n    if root.val == 2:\n        return left or right\n    elif root.val == 3:\n        return left and right\n\n\nroot = build([2, 1, 3, None, None, 0, 1])\nprint(root)\n#   2__\n#  /   \\\n# 1     3\n#      / \\\n#     0   1\nboolTree = build([\"OR\", \"True\", \"AND\", None, None, \"False\", \"True\"])\nprint(boolTree)\n#    __OR_______\n#   /           \\\n# True        __AND_\n#            /      \\\n#         False     True\nprint(evaluateTree(root))  # 1\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bottom-up_dfs/#508-most-frequent-subtree-sum","title":"508. Most Frequent Subtree Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bottom-up_dfs/#563-binary-tree-tilt","title":"563. Binary Tree Tilt","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bottom-up_dfs/#606-construct-string-from-binary-tree","title":"606. Construct String from Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bottom-up_dfs/#2265-count-nodes-equal-to-average-of-subtree","title":"2265. Count Nodes Equal to Average of Subtree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bottom-up_dfs/#1026-maximum-difference-between-node-and-ancestor","title":"1026. Maximum Difference Between Node and Ancestor","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bottom-up_dfs/#3319-k-th-largest-perfect-subtree-size-in-binary-tree","title":"3319. K-th Largest Perfect Subtree Size in Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, sorting, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bottom-up_dfs/#1339-maximum-product-of-splitted-binary-tree","title":"1339. Maximum Product of Splitted Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bottom-up_dfs/#1372-longest-zigzag-path-in-a-binary-tree","title":"1372. Longest ZigZag Path in a Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming, tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bottom-up_dfs/#1145-binary-tree-coloring-game","title":"1145. Binary Tree Coloring Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bottom-up_dfs/#572-subtree-of-another-tree","title":"572. Subtree of Another Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, string matching, binary tree, hash function 572. Subtree of Another Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# DFS - Tree\ndef isSubtree(root: Optional[TreeNode], subRoot: Optional[TreeNode]) -&gt; bool:\n    def isSameTree(p, q):\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n\n        return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)\n\n    if not root:\n        return False\n\n    return (\n        isSameTree(root, subRoot)\n        or isSubtree(root.left, subRoot)\n        or isSubtree(root.right, subRoot)\n    )\n\n\n# |------------|---------|----------|\n# | Approach   | Time    | Space    |\n# |------------|---------|----------|\n# | DFS        | O(n * m)| O(n)     |\n# |------------|---------|----------|\n\n\nroot = build([3, 4, 5, 1, 2, None, None, None, None, 0])\nsubRoot = build([4, 1, 2])\nprint(root)\n#     ____3\n#    /     \\\n#   4__     5\n#  /   \\\n# 1     2\n#      /\n#     0\nprint(subRoot)\n#   4\n#  / \\\n# 1   2\nprint(isSubtree(root, subRoot))  # False\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bottom-up_dfs/#1530-number-of-good-leaf-nodes-pairs","title":"1530. Number of Good Leaf Nodes Pairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bottom-up_dfs/#298-binary-tree-longest-consecutive-sequence","title":"298. Binary Tree Longest Consecutive Sequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree 298. Binary Tree Longest Consecutive Sequence - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Binary Tree\ndef longestConsecutive(root: Optional[TreeNode]) -&gt; int:\n    res = 0\n\n    def dfs(node):\n        if not node:\n            return 0\n\n        left, right = dfs(node.left), dfs(node.right)\n        cur = 1\n        if node.left and node.left.val == (node.val + 1):\n            cur = max(cur, left + 1)\n        if node.right and node.right.val == (node.val + 1):\n            cur = max(cur, right + 1)\n\n        nonlocal res\n        res = max(res, cur)\n        return cur\n\n    dfs(root)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    root = build([1, 3, 2, 4, None, None, None, 5])\n    print(root)\n    #       1\n    #      / \\\n    #     3   2\n    #    /\n    #   4\n    #  /\n    # 5\n    print(longestConsecutive(root))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bottom-up_dfs/#250-count-univalue-subtrees","title":"250. Count Univalue Subtrees","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bottom-up_dfs/#1973-count-nodes-equal-to-sum-of-descendants","title":"1973. Count Nodes Equal to Sum of Descendants","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bottom-up_dfs/#663-equal-tree-partition","title":"663. Equal Tree Partition","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bottom-up_dfs/#1120-maximum-average-subtree","title":"1120. Maximum Average Subtree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bottom-up_dfs/#2792-count-nodes-that-are-great-enough","title":"2792. Count Nodes That Are Great Enough","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: divide and conquer, tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bottom-up_dfs/#333-largest-bst-subtree","title":"333. Largest BST Subtree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming, tree, depth first search, binary search tree, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bottom-up_dfs/#366-find-leaves-of-binary-tree","title":"366. Find Leaves of Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree 366. Find Leaves of Binary Tree - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef findLeaves(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    depths = defaultdict(list)\n\n    def dfs(node):\n        if not node:\n            return 0\n        l, r = dfs(node.left), dfs(node.right)\n        depth = 1 + max(l, r)\n        depths[depth].append(node.val)\n        return depth\n\n    dfs(root)\n    return [i for i in depths.values()]\n\n\nif __name__ == \"__main__\":\n    root = build([1, 2, 3, 4, 5])\n    print(root)\n    #     __1\n    #    /   \\\n    #   2     3\n    #  / \\\n    # 4   5\n    print(findLeaves(root))  # [[4, 5, 3], [2], [1]]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bottom-up_dfs/#156-binary-tree-upside-down","title":"156. Binary Tree Upside Down","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bottom-up_dfs/#1612-check-if-two-expression-trees-are-equivalent","title":"1612. Check If Two Expression Trees are Equivalent","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, tree, depth first search, binary tree, counting</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bottom-up_dfs_node_deletion/","title":"Binary Tree Bottom-Up DFS Node Deletion","text":""},{"location":"content/endlesscheng/binary_tree_bottom-up_dfs_node_deletion/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 814. Binary Tree Pruning (Medium)</li> <li> 1325. Delete Leaves With a Given Value (Medium)</li> <li> 1110. Delete Nodes And Return Forest (Medium)</li> </ul>"},{"location":"content/endlesscheng/binary_tree_bottom-up_dfs_node_deletion/#814-binary-tree-pruning","title":"814. Binary Tree Pruning","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bottom-up_dfs_node_deletion/#1325-delete-leaves-with-a-given-value","title":"1325. Delete Leaves With a Given Value","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_bottom-up_dfs_node_deletion/#1110-delete-nodes-and-return-forest","title":"1110. Delete Nodes And Return Forest","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_construction/","title":"Binary Tree Construction","text":""},{"location":"content/endlesscheng/binary_tree_construction/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 108. Convert Sorted Array to Binary Search Tree (Easy)</li> <li> 654. Maximum Binary Tree (Medium)</li> <li> 998. Maximum Binary Tree II (Medium)</li> <li> 1008. Construct Binary Search Tree from Preorder Traversal (Medium)</li> <li> 1382. Balance a Binary Search Tree (Medium)</li> <li> 2196. Create Binary Tree From Descriptions (Medium)</li> <li> 105. Construct Binary Tree from Preorder and Inorder Traversal (Medium)</li> <li> 106. Construct Binary Tree from Inorder and Postorder Traversal (Medium)</li> <li> 889. Construct Binary Tree from Preorder and Postorder Traversal (Medium)</li> <li> 1028. Recover a Tree From Preorder Traversal (Hard)</li> <li> 536. Construct Binary Tree from String (Medium) \ud83d\udc51</li> <li> 1628. Design an Expression Tree With Evaluate Function (Medium) \ud83d\udc51</li> <li> 1597. Build Binary Expression Tree From Infix Expression (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/binary_tree_construction/#108-convert-sorted-array-to-binary-search-tree","title":"108. Convert Sorted Array to Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, divide and conquer, tree, binary search tree, binary tree 108. Convert Sorted Array to Binary Search Tree - Python Solution<pre><code>from typing import List, Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef sortedArrayToBST(nums: List[int]) -&gt; Optional[TreeNode]:\n    if len(nums) == 0:\n        return None\n\n    mid = len(nums) // 2\n    root = TreeNode(nums[mid])\n\n    root.left = sortedArrayToBST(nums[:mid])\n    root.right = sortedArrayToBST(nums[mid + 1 :])\n\n    return root\n\n\nnums = [-10, -3, 0, 5, 9]\nroot = sortedArrayToBST(nums)\n#      0\n#     / \\\n#   -3   9\n#   /   /\n# -10  5\n</code></pre></p> </li> </ul> 108. Convert Sorted Array to Binary Search Tree - C++ Solution<pre><code>#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   public:\n    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) {\n        if (nums.size() == 0) return nullptr;\n\n        int mid = nums.size() / 2;\n        TreeNode* root = new TreeNode(nums[mid]);\n\n        vector&lt;int&gt; left(nums.begin(), nums.begin() + mid);\n        vector&lt;int&gt; right(nums.begin() + mid + 1, nums.end());\n\n        root-&gt;left = sortedArrayToBST(left);\n        root-&gt;right = sortedArrayToBST(right);\n\n        return root;\n    }\n};\n\nint main() { return 0; }\n</code></pre>"},{"location":"content/endlesscheng/binary_tree_construction/#654-maximum-binary-tree","title":"654. Maximum Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, divide and conquer, stack, tree, monotonic stack, binary tree 654. Maximum Binary Tree - Python Solution<pre><code>from typing import List, Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef constructMaximumBinaryTree(nums: List[int]) -&gt; Optional[TreeNode]:\n    if len(nums) == 0:\n        return None\n\n    maximum = max(nums)\n    rootIndex = nums.index(maximum)\n\n    root = TreeNode(maximum)\n\n    left_nums = nums[:rootIndex]\n    right_nums = nums[rootIndex + 1 :]\n\n    root.left = constructMaximumBinaryTree(left_nums)\n    root.right = constructMaximumBinaryTree(right_nums)\n\n    return root\n\n\nnums = [3, 2, 1, 6, 0, 5]\nroot = constructMaximumBinaryTree(nums)\n#     __6__\n#    /     \\\n#   3       5\n#    \\     /\n#     2   0\n#      \\\n#       1\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_construction/#998-maximum-binary-tree-ii","title":"998. Maximum Binary Tree II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_construction/#1008-construct-binary-search-tree-from-preorder-traversal","title":"1008. Construct Binary Search Tree from Preorder Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, tree, binary search tree, monotonic stack, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_construction/#1382-balance-a-binary-search-tree","title":"1382. Balance a Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: divide and conquer, greedy, tree, depth first search, binary search tree, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_construction/#2196-create-binary-tree-from-descriptions","title":"2196. Create Binary Tree From Descriptions","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, tree, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_construction/#105-construct-binary-tree-from-preorder-and-inorder-traversal","title":"105. Construct Binary Tree from Preorder and Inorder Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, divide and conquer, tree, binary tree 105. Construct Binary Tree from Preorder and Inorder Traversal - Python Solution<pre><code>from typing import List, Optional\n\nfrom helper import TreeNode\n\n\ndef buildTree(preorder: List[int], inorder: List[int]) -&gt; Optional[TreeNode]:\n    \"\"\"\n    preorder  root left right  1  2  3\n    inorder   left root right  4  5  6\n    \"\"\"\n    if len(preorder) == 0:\n        return None\n\n    root_val = preorder[0]  # 1\n    root = TreeNode(root_val)\n\n    separator_idx = inorder.index(root_val)  # 5\n\n    left_inorder = inorder[:separator_idx]  # 4\n    right_inorder = inorder[separator_idx + 1 :]  # 6\n\n    left_preorder = preorder[1 : 1 + len(left_inorder)]  # 2\n    right_preorder = preorder[1 + len(left_inorder) :]  # 3\n\n    root.left = buildTree(left_preorder, left_inorder)\n    root.right = buildTree(right_preorder, right_inorder)\n\n    return root\n\n\npreorder = [3, 9, 20, 15, 7]\ninorder = [9, 3, 15, 20, 7]\nroot = buildTree(preorder, inorder)\nprint(root)\n#     3\n#    / \\\n#   9  20\n#     /  \\\n#    15   7\n</code></pre></p> </li> </ul> 105. Construct Binary Tree from Preorder and Inorder Traversal - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   public:\n    vector&lt;int&gt; preorder;\n    unordered_map&lt;int, int&gt; inorderMap;\n\n    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {\n        this-&gt;preorder = preorder;\n        for (size_t i = 0; i &lt; inorder.size(); i++) {\n            inorderMap[inorder[i]] = i;\n        }\n        return buildSubtree(0, 0, inorder.size() - 1);\n    }\n\n   private:\n    TreeNode* buildSubtree(int rootIndex, int left, int right) {\n        if (left &gt; right) return nullptr;\n\n        TreeNode* root = new TreeNode(preorder[rootIndex]);\n        int inorderIndex = inorderMap[preorder[rootIndex]];\n\n        root-&gt;left = buildSubtree(rootIndex + 1, left, inorderIndex - 1);\n        root-&gt;right = buildSubtree(rootIndex + (inorderIndex - left + 1),\n                                   inorderIndex + 1, right);\n\n        return root;\n    }\n};\n\nint main() {\n    vector&lt;int&gt; preorder = {3, 9, 20, 15, 7};\n    vector&lt;int&gt; inorder = {9, 3, 15, 20, 7};\n    Solution solution;\n    TreeNode* root = solution.buildTree(preorder, inorder);\n    cout &lt;&lt; root-&gt;val &lt;&lt; endl;                // 3\n    cout &lt;&lt; root-&gt;left-&gt;val &lt;&lt; endl;          // 9\n    cout &lt;&lt; root-&gt;right-&gt;val &lt;&lt; endl;         // 20\n    cout &lt;&lt; root-&gt;right-&gt;left-&gt;val &lt;&lt; endl;   // 15\n    cout &lt;&lt; root-&gt;right-&gt;right-&gt;val &lt;&lt; endl;  // 7\n    return 0;\n}\n</code></pre>"},{"location":"content/endlesscheng/binary_tree_construction/#106-construct-binary-tree-from-inorder-and-postorder-traversal","title":"106. Construct Binary Tree from Inorder and Postorder Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, divide and conquer, tree, binary tree 106. Construct Binary Tree from Inorder and Postorder Traversal - Python Solution<pre><code>from typing import List, Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef buildTree(inorder: List[int], postorder: List[int]) -&gt; Optional[TreeNode]:\n    \"\"\"\n    inorder:    left root  right   1  2  3\n    postorder:  left right root    4  5  6\n    \"\"\"\n\n    if not postorder:\n        return None\n\n    root_val = postorder[-1]  # 6\n    root = TreeNode(root_val)\n\n    separator_idx = inorder.index(root_val)  # 2\n\n    left_inorder = inorder[:separator_idx]  # 1\n    right_inorder = inorder[separator_idx + 1 :]  # 3\n\n    left_postorder = postorder[: len(left_inorder)]  # 4\n    right_postorder = postorder[len(left_inorder) : -1]  # 5\n\n    root.left = buildTree(left_inorder, left_postorder)\n    root.right = buildTree(right_inorder, right_postorder)\n\n    return root\n\n\ninorder = [9, 3, 15, 20, 7]\npostorder = [9, 15, 7, 20, 3]\nroot = buildTree(inorder, postorder)\nprint(root)\n#     3\n#    / \\\n#   9  20\n#     /  \\\n#    15   7\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_construction/#889-construct-binary-tree-from-preorder-and-postorder-traversal","title":"889. Construct Binary Tree from Preorder and Postorder Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, divide and conquer, tree, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_construction/#1028-recover-a-tree-from-preorder-traversal","title":"1028. Recover a Tree From Preorder Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_construction/#536-construct-binary-tree-from-string","title":"536. Construct Binary Tree from String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack, tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_construction/#1628-design-an-expression-tree-with-evaluate-function","title":"1628. Design an Expression Tree With Evaluate Function","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, stack, tree, design, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_construction/#1597-build-binary-expression-tree-from-infix-expression","title":"1597. Build Binary Expression Tree From Infix Expression","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, stack, tree, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_diameter/","title":"Binary Tree Diameter","text":""},{"location":"content/endlesscheng/binary_tree_diameter/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 543. Diameter of Binary Tree (Easy)</li> <li> 687. Longest Univalue Path (Medium)</li> <li> 124. Binary Tree Maximum Path Sum (Hard)</li> <li> 2385. Amount of Time for Binary Tree to Be Infected (Medium)</li> <li> 549. Binary Tree Longest Consecutive Sequence II (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/binary_tree_diameter/#543-diameter-of-binary-tree","title":"543. Diameter of Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, binary tree 543. Diameter of Binary Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Tree DFS\nclass Solution:\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -&gt; int:\n        self.diameter = 0\n\n        def dfs(node):\n            if not node:\n                return 0\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n            self.diameter = max(self.diameter, left + right)\n\n            return 1 + max(left, right)\n\n        dfs(root)\n\n        return self.diameter\n\n\nroot = build([1, 2, 3, 4, 5])\nprint(root)\n#     __1\n#    /   \\\n#   2     3\n#  / \\\n# 4   5\nobj = Solution()\nprint(obj.diameterOfBinaryTree(root))  # 3\n</code></pre></p> </li> </ul> 543. Diameter of Binary Tree - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nint diameterOfBinaryTree(TreeNode* root) {\n    int diameter = 0;\n\n    auto dfs = [&amp;](auto&amp;&amp; self, TreeNode* node) -&gt; int {\n        if (!node) return 0;\n        int left = self(self, node-&gt;left);\n        int right = self(self, node-&gt;right);\n\n        diameter = max(diameter, left + right);\n\n        return 1 + max(left, right);\n    };\n\n    dfs(dfs, root);\n    return diameter;\n}\n\nint main() {\n    // [1, 2, 3, 4, 5]\n    TreeNode* root = new TreeNode(1);\n    root-&gt;left = new TreeNode(2);\n    root-&gt;right = new TreeNode(3);\n    root-&gt;left-&gt;left = new TreeNode(4);\n    root-&gt;left-&gt;right = new TreeNode(5);\n    cout &lt;&lt; diameterOfBinaryTree(root) &lt;&lt; endl;  // 3\n\n    return 0;\n}\n</code></pre>"},{"location":"content/endlesscheng/binary_tree_diameter/#687-longest-univalue-path","title":"687. Longest Univalue Path","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_diameter/#124-binary-tree-maximum-path-sum","title":"124. Binary Tree Maximum Path Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, tree, depth first search, binary tree 124. Binary Tree Maximum Path Sum - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef maxPathSum(root: Optional[TreeNode]) -&gt; int:\n    res = float(\"-inf\")\n\n    def dfs(node):\n        if not node:\n            return 0\n\n        leftMax = max(dfs(node.left), 0)\n        rightMax = max(dfs(node.right), 0)\n\n        cur = node.val + leftMax + rightMax\n        nonlocal res\n        res = max(res, cur)\n\n        return node.val + max(leftMax, rightMax)\n\n    dfs(root)\n\n    return res\n\n\nroot = build([-10, 9, 20, None, None, 15, 7])\nprint(root)\n#   -10___\n#  /      \\\n# 9       _20\n#        /   \\\n#       15    7\nprint(maxPathSum(root))  # 42\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_diameter/#2385-amount-of-time-for-binary-tree-to-be-infected","title":"2385. Amount of Time for Binary Tree to Be Infected","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, tree, depth first search, breadth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_diameter/#549-binary-tree-longest-consecutive-sequence-ii","title":"549. Binary Tree Longest Consecutive Sequence II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_insert_delete_nodes/","title":"Binary Tree Insert Delete Nodes","text":""},{"location":"content/endlesscheng/binary_tree_insert_delete_nodes/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 701. Insert into a Binary Search Tree (Medium)</li> <li> 450. Delete Node in a BST (Medium)</li> <li> 669. Trim a Binary Search Tree (Medium)</li> <li> 776. Split BST (Medium) \ud83d\udc51</li> <li> 1666. Change the Root of a Binary Tree (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/binary_tree_insert_delete_nodes/#701-insert-into-a-binary-search-tree","title":"701. Insert into a Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, binary search tree, binary tree 701. Insert into a Binary Search Tree - Python Solution<pre><code>from typing import Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef insertIntoBST(root: Optional[TreeNode], val: int) -&gt; Optional[TreeNode]:\n    if root is None:\n        return TreeNode(val)\n\n    if root.val &gt; val:\n        root.left = insertIntoBST(root.left, val)\n    if root.val &lt; val:\n        root.right = insertIntoBST(root.right, val)\n\n    return root\n\n\nroot = TreeNode(4)\nroot.left = TreeNode(2)\nroot.right = TreeNode(6)\nroot.left.left = TreeNode(1)\nroot.left.right = TreeNode(3)\n#     __4\n#    /   \\\n#   2     6\n#  / \\\n# 1   3\n\ninsertIntoBST(root, 5)\n#     __4\n#    /   \\\n#   2     6\n#  / \\   /\n# 1   3 5\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_insert_delete_nodes/#450-delete-node-in-a-bst","title":"450. Delete Node in a BST","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, binary search tree, binary tree 450. Delete Node in a BST - Python Solution<pre><code>from typing import Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef deleteNode(root: Optional[TreeNode], key: int) -&gt; Optional[TreeNode]:\n    if root is None:\n        return root\n\n    if root.val == key:\n        if root.left is None and root.right is None:\n            return None\n        elif root.left is None:\n            return root.right\n        elif root.right is None:\n            return root.left\n        else:\n            cur = root.right\n            while cur.left is not None:\n                cur = cur.left\n            cur.left = root.left\n            return root.right\n\n    if root.val &gt; key:\n        root.left = deleteNode(root.left, key)\n    if root.val &lt; key:\n        root.right = deleteNode(root.right, key)\n\n    return root\n\n\nroot = TreeNode(5)\nroot.left = TreeNode(3)\nroot.right = TreeNode(6)\nroot.left.left = TreeNode(2)\nroot.left.right = TreeNode(4)\nroot.right.right = TreeNode(7)\n#     __5\n#    /   \\\n#   3     6\n#  / \\     \\\n# 2   4     7\n\ndeleteNode(root, 3)\n#     __5\n#    /   \\\n#   4     6\n#  /       \\\n# 2         7\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_insert_delete_nodes/#669-trim-a-binary-search-tree","title":"669. Trim a Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree 669. Trim a Binary Search Tree - Python Solution<pre><code>from typing import Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef trimBST(\n    root: Optional[TreeNode], low: int, high: int\n) -&gt; Optional[TreeNode]:\n    if root is None:\n        return None\n\n    if root.val &lt; low:\n        return trimBST(root.right, low, high)\n    if root.val &gt; high:\n        return trimBST(root.left, low, high)\n\n    root.left = trimBST(root.left, low, high)\n    root.right = trimBST(root.right, low, high)\n\n    return root\n\n\nroot = TreeNode(3)\nroot.left = TreeNode(0)\nroot.right = TreeNode(4)\nroot.left.right = TreeNode(2)\nroot.left.right.left = TreeNode(1)\n#     __3\n#    /   \\\n#   0     4\n#    \\\n#     2\n#    /\n#   1\n\ntrimBST(root, 1, 3)\n#     __3\n#    /\n#   2\n#  /\n# 1\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_insert_delete_nodes/#776-split-bst","title":"776. Split BST","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, binary search tree, recursion, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_insert_delete_nodes/#1666-change-the-root-of-a-binary-tree","title":"1666. Change the Root of a Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_linked_list/","title":"Binary Tree Linked List","text":""},{"location":"content/endlesscheng/binary_tree_linked_list/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 114. Flatten Binary Tree to Linked List (Medium)</li> <li> 1367. Linked List in Binary Tree (Medium)</li> <li> 109. Convert Sorted List to Binary Search Tree (Medium)</li> <li> 116. Populating Next Right Pointers in Each Node (Medium)</li> <li> 117. Populating Next Right Pointers in Each Node II (Medium)</li> <li> 426. Convert Binary Search Tree to Sorted Doubly Linked List (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/binary_tree_linked_list/#114-flatten-binary-tree-to-linked-list","title":"114. Flatten Binary Tree to Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, stack, tree, depth first search, binary tree 114. Flatten Binary Tree to Linked List - C++ Solution<pre><code>struct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n    TreeNode* head;\n\n   public:\n    void flatten(TreeNode* root) {\n        if (!root) return;\n\n        flatten(root-&gt;right);\n        flatten(root-&gt;left);\n        root-&gt;left = nullptr;\n        root-&gt;right = head;\n        head = root;\n    }\n};\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_linked_list/#1367-linked-list-in-binary-tree","title":"1367. Linked List in Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_linked_list/#109-convert-sorted-list-to-binary-search-tree","title":"109. Convert Sorted List to Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, divide and conquer, tree, binary search tree, binary tree </p> </li> </ul> 109. Convert Sorted List to Binary Search Tree - Python Solution<pre><code>from typing import Optional\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef sortedListToBST(head: Optional[ListNode]) -&gt; Optional[TreeNode]:\n    if not head:\n        return None\n\n    def find_mid(head: ListNode) -&gt; ListNode:\n        prev = None\n        slow = head\n        fast = head\n\n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n\n        if prev:\n            prev.next = None\n\n        return slow\n\n    mid = find_mid(head)\n\n    node = TreeNode(mid.val)\n\n    if head == mid:\n        return node\n\n    node.left = sortedListToBST(head)\n    node.right = sortedListToBST(mid.next)\n\n    return node\n\n\nhead = ListNode(-10)\nhead.next = ListNode(-3)\nhead.next.next = ListNode(0)\nhead.next.next.next = ListNode(5)\nhead.next.next.next.next = ListNode(9)\n\nroot = sortedListToBST(head)\nassert root.val == 0\nassert root.left.val == -3\nassert root.left.left.val == -10\nassert root.right.val == 9\nassert root.right.left.val == 5\nprint(\"All passed\")\n\n#      0\n#     / \\\n#   -3   9\n#   /   /\n# -10  5\n</code></pre>"},{"location":"content/endlesscheng/binary_tree_linked_list/#116-populating-next-right-pointers-in-each-node","title":"116. Populating Next Right Pointers in Each Node","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, tree, depth first search, breadth first search, binary tree</p> </li> <li>Perfect Binary Tree</li> </ul> 116. Populating Next Right Pointers in Each Node - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\n\nclass Node:\n    def __init__(\n        self,\n        val: int = 0,\n        left: \"Node\" = None,\n        right: \"Node\" = None,\n        next: \"Node\" = None,\n    ):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\n\ndef connect(root: \"Optional[Node]\") -&gt; \"Optional[Node]\":\n    if not root:\n        return root\n\n    queue = deque([root])\n\n    while queue:\n        size = len(queue)\n        prev = None\n\n        for _ in range(size):\n            node = queue.popleft()\n\n            if prev:\n                prev.next = node\n            prev = node\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n    return root\n\n\n# Perfect binary tree creation\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.right.left = Node(6)\nroot.right.right = Node(7)\n#     __1__\n#    /     \\\n#   2__     3\n#  /   \\   / \\\n# 4     5 6   7\n\n\n# Connect the nodes\nconnect(root)\n#      __1__ -&gt; None\n#     /     \\\n#   _2_ -&gt;  3 -&gt; None\n#  /   \\   / \\\n# 4 -&gt; 5-&gt;6-&gt; 7 -&gt; None\n\n\nassert root.next is None\nassert root.left.next == root.right\nassert root.left.left.next == root.left.right\nassert root.left.right.next == root.right.left\nassert root.right.left.next == root.right.right\nassert root.right.right.next is None\nprint(\"All tests passed.\")\n</code></pre>"},{"location":"content/endlesscheng/binary_tree_linked_list/#117-populating-next-right-pointers-in-each-node-ii","title":"117. Populating Next Right Pointers in Each Node II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, tree, depth first search, breadth first search, binary tree 117. Populating Next Right Pointers in Each Node II - Python Solution<pre><code>from collections import deque\n\n\nclass Node:\n    def __init__(\n        self,\n        val: int = 0,\n        left: \"Node\" = None,\n        right: \"Node\" = None,\n        next: \"Node\" = None,\n    ):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\n\ndef connect(root: \"Node\") -&gt; \"Node\":\n    if not root:\n        return root\n\n    queue = deque([root])\n\n    while queue:\n        size = len(queue)\n        prev = None\n\n        for _ in range(size):\n            node = queue.popleft()\n\n            if prev:\n                prev.next = node\n\n            prev = node\n\n            if node.left:\n                queue.append(node.left)\n\n            if node.right:\n                queue.append(node.right)\n\n    return root\n\n\n# Binary tree creation\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.right.right = Node(7)\n#       1\n#      / \\\n#     2   3\n#    / \\   \\\n#   4   5   7\n\n# Connect the nodes\nconnect(root)\n#       1 -&gt; None\n#      / \\\n#     2 -&gt; 3 -&gt; None\n#    / \\    \\\n#   4 -&gt; 5 -&gt; 7 -&gt; None\n\nassert root.next is None\nassert root.left.next == root.right\nassert root.right.next is None\nassert root.left.left.next == root.left.right\nassert root.left.right.next == root.right.right\nassert root.right.right.next is None\n\nprint(\"All tests passed.\")\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_linked_list/#426-convert-binary-search-tree-to-sorted-doubly-linked-list","title":"426. Convert Binary Search Tree to Sorted Doubly Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, stack, tree, depth first search, binary search tree, binary tree, doubly linked list</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_lowest_common_ancestor/","title":"Binary Tree Lowest Common Ancestor","text":""},{"location":"content/endlesscheng/binary_tree_lowest_common_ancestor/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 235. Lowest Common Ancestor of a Binary Search Tree (Medium)</li> <li> 236. Lowest Common Ancestor of a Binary Tree (Medium)</li> <li> 1123. Lowest Common Ancestor of Deepest Leaves (Medium)</li> <li> 2096. Step-By-Step Directions From a Binary Tree Node to Another (Medium)</li> <li> 1740. Find Distance in a Binary Tree (Medium) \ud83d\udc51</li> <li> 1644. Lowest Common Ancestor of a Binary Tree II (Medium) \ud83d\udc51</li> <li> 1650. Lowest Common Ancestor of a Binary Tree III (Medium) \ud83d\udc51</li> <li> 1676. Lowest Common Ancestor of a Binary Tree IV (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/binary_tree_lowest_common_ancestor/#235-lowest-common-ancestor-of-a-binary-search-tree","title":"235. Lowest Common Ancestor of a Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree 235. Lowest Common Ancestor of a Binary Search Tree - Python Solution<pre><code>from binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef lowestCommonAncestor(\n    root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n) -&gt; \"TreeNode\":\n    while root:\n        if root.val &gt; p.val and root.val &gt; q.val:\n            root = root.left\n        elif root.val &lt; p.val and root.val &lt; q.val:\n            root = root.right\n        else:\n            return root\n\n\nroot = [6, 2, 8, 0, 4, 7, 9, None, None, 3, 5]\nroot = build(root)\np = root.left\nq = root.right\nprint(root)\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\nprint(lowestCommonAncestor(root, p, q))\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_lowest_common_ancestor/#236-lowest-common-ancestor-of-a-binary-tree","title":"236. Lowest Common Ancestor of a Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree 236. Lowest Common Ancestor of a Binary Tree - Python Solution<pre><code>from typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef lowestCommonAncestor(\n    root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n) -&gt; \"TreeNode\":\n    if not root or q == root or p == root:\n        return root\n\n    left = lowestCommonAncestor(root.left, p, q)\n    right = lowestCommonAncestor(root.right, p, q)\n\n    if left and right:\n        return root\n\n    return left or right\n\n\nroot = build([3, 5, 1, 6, 2, 0, 8, None, None, 7, 4])\nprint(root)\n#     ______3__\n#    /         \\\n#   5__         1\n#  /   \\       / \\\n# 6     2     0   8\n#      / \\\n#     7   4\np = root.left  # 5\nq = root.right  # 1\nprint(lowestCommonAncestor(root, p, q))  # 3\n#     ______3__\n#    /         \\\n#   5__         1\n#  /   \\       / \\\n# 6     2     0   8\n#      / \\\n#     7   4\nr = root.left.right.right  # 4\nprint(lowestCommonAncestor(root, p, r))  # 5\n#   5__\n#  /   \\\n# 6     2\n#      / \\\n#     7   4\n</code></pre></p> </li> </ul> 236. Lowest Common Ancestor of a Binary Tree - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   public:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if (root == nullptr || root == p || root == q) {\n            return root;\n        }\n\n        TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);\n        TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);\n\n        if (left &amp;&amp; right) {\n            return root;\n        }\n\n        return left ? left : right;\n    }\n};\n\nint main() { return 0; }\n</code></pre>"},{"location":"content/endlesscheng/binary_tree_lowest_common_ancestor/#1123-lowest-common-ancestor-of-deepest-leaves","title":"1123. Lowest Common Ancestor of Deepest Leaves","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, tree, depth first search, breadth first search, binary tree 1123. Lowest Common Ancestor of Deepest Leaves - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Lowest Common Ancestor\ndef lcaDeepestLeaves(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    res = None\n    max_depth = -1\n\n    def dfs(node, depth) -&gt; int:\n        nonlocal res, max_depth\n        if not node:\n            max_depth = max(max_depth, depth)\n            return depth\n        left_max_depth = dfs(node.left, depth + 1)\n        right_max_depth = dfs(node.right, depth + 1)\n        if left_max_depth == right_max_depth == max_depth:\n            res = node\n        return max(left_max_depth, right_max_depth)\n\n    dfs(root, 0)\n    return res\n\n\nif __name__ == \"__main__\":\n    root = [3, 5, 1, 6, 2, 0, 8, None, None, 7, 4]\n    root = build(root)\n    print(root)\n    #     ______3__\n    #    /         \\\n    #   5__         1\n    #  /   \\       / \\\n    # 6     2     0   8\n    #      / \\\n    #     7   4\n    print(lcaDeepestLeaves(root))  # 2\n    #   2\n    #  / \\\n    # 7   4\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_lowest_common_ancestor/#2096-step-by-step-directions-from-a-binary-tree-node-to-another","title":"2096. Step-By-Step Directions From a Binary Tree Node to Another","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_lowest_common_ancestor/#1740-find-distance-in-a-binary-tree","title":"1740. Find Distance in a Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, tree, depth first search, breadth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_lowest_common_ancestor/#1644-lowest-common-ancestor-of-a-binary-tree-ii","title":"1644. Lowest Common Ancestor of a Binary Tree II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_lowest_common_ancestor/#1650-lowest-common-ancestor-of-a-binary-tree-iii","title":"1650. Lowest Common Ancestor of a Binary Tree III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, two pointers, tree, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_lowest_common_ancestor/#1676-lowest-common-ancestor-of-a-binary-tree-iv","title":"1676. Lowest Common Ancestor of a Binary Tree IV","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_others/","title":"Binary Tree Others","text":""},{"location":"content/endlesscheng/binary_tree_others/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 297. Serialize and Deserialize Binary Tree (Hard)</li> <li> 449. Serialize and Deserialize BST (Medium)</li> <li> 652. Find Duplicate Subtrees (Medium)</li> <li> 173. Binary Search Tree Iterator (Medium)</li> <li> 1261. Find Elements in a Contaminated Binary Tree (Medium)</li> <li> 1104. Path In Zigzag Labelled Binary Tree (Medium)</li> <li> 987. Vertical Order Traversal of a Binary Tree (Hard)</li> <li> 655. Print Binary Tree (Medium)</li> <li> 979. Distribute Coins in Binary Tree (Medium)</li> <li> 222. Count Complete Tree Nodes (Easy)</li> <li> 2049. Count Nodes With the Highest Score (Medium)</li> <li> 2673. Make Costs of Paths Equal in a Binary Tree (Medium)</li> <li> 2509. Cycle Length Queries in a Tree (Hard)</li> <li> 2458. Height of Binary Tree After Subtree Removal Queries (Hard)</li> <li> 314. Binary Tree Vertical Order Traversal (Medium) \ud83d\udc51</li> <li> 666. Path Sum IV (Medium) \ud83d\udc51</li> <li> 1586. Binary Search Tree Iterator II (Medium) \ud83d\udc51</li> <li> 2773. Height of Special Binary Tree (Medium) \ud83d\udc51</li> <li> 1485. Clone Binary Tree With Random Pointer (Medium) \ud83d\udc51</li> <li> 2445. Number of Nodes With Value One (Medium) \ud83d\udc51</li> <li> 431. Encode N-ary Tree to Binary Tree (Hard) \ud83d\udc51</li> <li> 2005. Subtree Removal Game with Fibonacci Tree (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/binary_tree_others/#297-serialize-and-deserialize-binary-tree","title":"297. Serialize and Deserialize Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, tree, depth first search, breadth first search, design, binary tree 297. Serialize and Deserialize Binary Tree - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BFS\nclass BFS:\n    def serialize(self, root: Optional[TreeNode]) -&gt; str:\n        if not root:\n            return \"\"\n\n        res = []\n        q = deque([root])\n\n        while q:\n            node = q.popleft()\n\n            if node:\n                res.append(str(node.val))\n                q.append(node.left)\n                q.append(node.right)\n            else:\n                res.append(\"null\")\n\n        return \",\".join(res)\n\n    def deserialize(self, data: str) -&gt; Optional[TreeNode]:\n        if not data:\n            return None\n\n        nodes = data.split(\",\")\n        root = TreeNode(int(nodes[0]))\n        q = deque([root])\n        index = 1\n\n        while q:\n            node = q.popleft()\n\n            if nodes[index] != \"null\":\n                node.left = TreeNode(int(nodes[index]))\n                q.append(node.left)\n            index += 1\n\n            if nodes[index] != \"null\":\n                node.right = TreeNode(int(nodes[index]))\n                q.append(node.right)\n            index += 1\n\n        return root\n\n\n# DFS\nclass DFS:\n    def serialize(self, root: Optional[TreeNode]) -&gt; str:\n        def dfs(node):\n            if not node:\n                return [\"null\"]\n            return [str(node.val)] + dfs(node.left) + dfs(node.right)\n\n        return \",\".join(dfs(root))\n\n    def deserialize(self, data: str) -&gt; Optional[TreeNode]:\n        nodes = data.split(\",\")\n        self.index = 0\n\n        def dfs():\n            if nodes[self.index] == \"null\":\n                self.index += 1\n                return None\n\n            node = TreeNode(int(nodes[self.index]))\n            self.index += 1\n\n            node.left = dfs()\n            node.right = dfs()\n\n            return node\n\n        root = dfs()\n        return root\n\n\nroot = build([1, 2, 3, None, None, 4, 5])\nprint(root)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n\nbfs = BFS()\ndata1 = bfs.serialize(root)\nprint(data1)  # \"1,2,3,null,null,4,5,null,null,null,null\"\nroot1 = bfs.deserialize(data1)\nprint(root1)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n\ndfs = DFS()\ndata2 = dfs.serialize(root)\nprint(data2)  # \"1,2,null,null,3,4,null,null,5,null,null\"\nroot2 = dfs.deserialize(data2)\nprint(root2)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_others/#449-serialize-and-deserialize-bst","title":"449. Serialize and Deserialize BST","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, tree, depth first search, breadth first search, design, binary search tree, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_others/#652-find-duplicate-subtrees","title":"652. Find Duplicate Subtrees","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_others/#173-binary-search-tree-iterator","title":"173. Binary Search Tree Iterator","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: stack, tree, design, binary search tree, binary tree, iterator 173. Binary Search Tree Iterator - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BST\nclass BSTIterator:\n\n    def __init__(self, root: Optional[TreeNode]):\n        self.stack = []\n        self._leftmost_inorder(root)\n\n    def _leftmost_inorder(self, root):\n        while root:\n            self.stack.append(root)\n            root = root.left\n\n    def next(self) -&gt; int:\n        topmost_node = self.stack.pop()\n\n        if topmost_node.right:\n            self._leftmost_inorder(topmost_node.right)\n\n        return topmost_node.val\n\n    def hasNext(self) -&gt; bool:\n        return len(self.stack) &gt; 0\n\n\nroot = build([7, 3, 15, None, None, 9, 20])\nprint(root)\n#   7__\n#  /   \\\n# 3     15\n#      /  \\\n#     9    20\nobj = BSTIterator(root)\nprint(obj.next())  # 3\nprint(obj.next())  # 7\nprint(obj.hasNext())  # True\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_others/#1261-find-elements-in-a-contaminated-binary-tree","title":"1261. Find Elements in a Contaminated Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, tree, depth first search, breadth first search, design, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_others/#1104-path-in-zigzag-labelled-binary-tree","title":"1104. Path In Zigzag Labelled Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, tree, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_others/#987-vertical-order-traversal-of-a-binary-tree","title":"987. Vertical Order Traversal of a Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, tree, depth first search, breadth first search, sorting, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_others/#655-print-binary-tree","title":"655. Print Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_others/#979-distribute-coins-in-binary-tree","title":"979. Distribute Coins in Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_others/#222-count-complete-tree-nodes","title":"222. Count Complete Tree Nodes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: binary search, bit manipulation, tree, binary tree 222. Count Complete Tree Nodes - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef countNodesRecursive(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    num = 1 + countNodesRecursive(root.left) + countNodesRecursive(root.right)\n\n    return num\n\n\n# Iterative\ndef countNodesIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n    count = 0\n\n    while q:\n        n = len(q)\n\n        for _ in range(n):\n            node = q.popleft()\n            count += 1\n\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return count\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Recursive  |  O(n)  |  O(n)   |\n# | Iterative  |  O(n)  |  O(n)   |\n# |------------|--------|---------|\n\nroot = [1, 2, 3, 4, 5, 6]\nroot = build(root)\nprint(root)\n#     __1__\n#    /     \\\n#   2       3\n#  / \\     /\n# 4   5   6\nprint(countNodesRecursive(root))  # 6\nprint(countNodesIterative(root))  # 6\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_others/#2049-count-nodes-with-the-highest-score","title":"2049. Count Nodes With the Highest Score","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_others/#2673-make-costs-of-paths-equal-in-a-binary-tree","title":"2673. Make Costs of Paths Equal in a Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy, tree, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_others/#2509-cycle-length-queries-in-a-tree","title":"2509. Cycle Length Queries in a Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, tree, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_others/#2458-height-of-binary-tree-after-subtree-removal-queries","title":"2458. Height of Binary Tree After Subtree Removal Queries","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, tree, depth first search, breadth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_others/#314-binary-tree-vertical-order-traversal","title":"314. Binary Tree Vertical Order Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, tree, depth first search, breadth first search, sorting, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_others/#666-path-sum-iv","title":"666. Path Sum IV","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_others/#1586-binary-search-tree-iterator-ii","title":"1586. Binary Search Tree Iterator II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: stack, tree, design, binary search tree, binary tree, iterator 1586. Binary Search Tree Iterator II - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BST\nclass BSTIterator:\n    def __init__(self, root: Optional[TreeNode]):\n        self.nodes = self._inorder(root)\n        self.index = -1\n        self.size = len(self.nodes)\n\n    def _inorder(self, node):\n        if not node:\n            return []\n        return (\n            self._inorder(node.left) + [node.val] + self._inorder(node.right)\n        )\n\n    def hasNext(self) -&gt; bool:\n        return self.index &lt; self.size - 1\n\n    def next(self) -&gt; int:\n        self.index += 1\n        return self.nodes[min(self.index, self.size - 1)]\n\n    def hasPrev(self) -&gt; bool:\n        return self.index &gt; 0\n\n    def prev(self) -&gt; int:\n        self.index -= 1\n        return self.nodes[max(self.index, 0)]\n\n\nroot = build([7, 3, 15, None, None, 9, 20])\nprint(root)\n#   7__\n#  /   \\\n# 3     15\n#      /  \\\n#     9    20\nobj = BSTIterator(root)\nprint(obj.next())  # 3\nprint(obj.next())  # 7\nprint(obj.hasNext())  # True\nprint(obj.prev())  # 3\nprint(obj.prev())  # None\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_others/#2773-height-of-special-binary-tree","title":"2773. Height of Special Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_others/#1485-clone-binary-tree-with-random-pointer","title":"1485. Clone Binary Tree With Random Pointer","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, tree, depth first search, breadth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_others/#2445-number-of-nodes-with-value-one","title":"2445. Number of Nodes With Value One","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_others/#431-encode-n-ary-tree-to-binary-tree","title":"431. Encode N-ary Tree to Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, design, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_others/#2005-subtree-removal-game-with-fibonacci-tree","title":"2005. Subtree Removal Game with Fibonacci Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, dynamic programming, tree, binary tree, game theory</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_recursion/","title":"Binary Tree Recursion","text":""},{"location":"content/endlesscheng/binary_tree_recursion/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 538. Convert BST to Greater Tree (Medium)</li> <li> 1038. Binary Search Tree to Greater Sum Tree (Medium)</li> <li> 865. Smallest Subtree with all the Deepest Nodes (Medium)</li> <li> 1080. Insufficient Nodes in Root to Leaf Paths (Medium)</li> </ul>"},{"location":"content/endlesscheng/binary_tree_recursion/#538-convert-bst-to-greater-tree","title":"538. Convert BST to Greater Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree </p> </li> </ul> 538. Convert BST to Greater Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef convertBST(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    prev = 0\n\n    def dfs(node):\n        if not node:\n            return None\n        nonlocal prev\n\n        dfs(node.right)\n\n        node.val += prev\n        prev = node.val\n\n        dfs(node.left)\n\n    dfs(root)\n\n    return root\n\n\nroot = [4, 1, 6, 0, 2, 5, 7, None, None, None, 3, None, None, None, 8]\nroot = build(root)\nprint(root)\n#     ____4__\n#    /       \\\n#   1         6\n#  / \\       / \\\n# 0   2     5   7\n#      \\         \\\n#       3         8\ngreater_tree = convertBST(root)\nprint(greater_tree)\n#      _______30___\n#     /            \\\n#   _36            _21\n#  /   \\          /   \\\n# 36    35       26    15\n#         \\              \\\n#          33             8\n</code></pre>"},{"location":"content/endlesscheng/binary_tree_recursion/#1038-binary-search-tree-to-greater-sum-tree","title":"1038. Binary Search Tree to Greater Sum Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_recursion/#865-smallest-subtree-with-all-the-deepest-nodes","title":"865. Smallest Subtree with all the Deepest Nodes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, tree, depth first search, breadth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_recursion/#1080-insufficient-nodes-in-root-to-leaf-paths","title":"1080. Insufficient Nodes in Root to Leaf Paths","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_top-down_dfs/","title":"Binary Tree Top-Down DFS","text":""},{"location":"content/endlesscheng/binary_tree_top-down_dfs/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 104. Maximum Depth of Binary Tree (Easy)</li> <li> 111. Minimum Depth of Binary Tree (Easy)</li> <li> 112. Path Sum (Easy)</li> <li> 129. Sum Root to Leaf Numbers (Medium)</li> <li> 199. Binary Tree Right Side View (Medium)</li> <li> 1448. Count Good Nodes in Binary Tree (Medium)</li> <li> 1457. Pseudo-Palindromic Paths in a Binary Tree (Medium)</li> <li> 1315. Sum of Nodes with Even-Valued Grandparent (Medium)</li> <li> 988. Smallest String Starting From Leaf (Medium)</li> <li> 1026. Maximum Difference Between Node and Ancestor (Medium)</li> <li> 1022. Sum of Root To Leaf Binary Numbers (Easy)</li> <li> 623. Add One Row to Tree (Medium)</li> <li> 1372. Longest ZigZag Path in a Binary Tree (Medium)</li> <li> 971. Flip Binary Tree To Match Preorder Traversal (Medium)</li> <li> 2689. Extract Kth Character From The Rope Tree (Easy) \ud83d\udc51</li> <li> 298. Binary Tree Longest Consecutive Sequence (Medium) \ud83d\udc51</li> <li> 1430. Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree (Medium) \ud83d\udc51</li> <li> 545. Boundary of Binary Tree (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/binary_tree_top-down_dfs/#104-maximum-depth-of-binary-tree","title":"104. Maximum Depth of Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 104. Maximum Depth of Binary Tree - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef maxDepthRecursive(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    left = maxDepthRecursive(root.left)\n    right = maxDepthRecursive(root.right)\n\n    return 1 + max(left, right)\n\n\n# DFS\ndef maxDepthDFS(root: Optional[TreeNode]) -&gt; int:\n    res = 0\n\n    def dfs(node, cnt):\n        if node is None:\n            return\n        cnt += 1\n        nonlocal res\n        res = max(res, cnt)\n\n        dfs(node.left, cnt)\n        dfs(node.right, cnt)\n\n    dfs(root, 0)\n\n    return res\n\n\n# Iterative\ndef maxDepthIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n    res = 0\n\n    while q:\n        res += 1\n        n = len(q)\n\n        for _ in range(n):\n            node = q.popleft()\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    root = [1, 2, 2, 3, 4, None, None, None, None, 5]\n    root = build(root)\n    print(root)\n    #     ____1\n    #    /     \\\n    #   2__     2\n    #  /   \\\n    # 3     4\n    #      /\n    #     5\n    assert maxDepthRecursive(root) == 4\n    assert maxDepthDFS(root) == 4\n    assert maxDepthIterative(root) == 4\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_top-down_dfs/#111-minimum-depth-of-binary-tree","title":"111. Minimum Depth of Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 111. Minimum Depth of Binary Tree - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Iterative\ndef minDepthIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n    res = 0\n\n    while q:\n        res += 1\n\n        for _ in range(len(q)):\n            node = q.popleft()\n\n            if not node.left and not node.right:\n                return res\n\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n\n# Recursive\ndef minDepthRecursive(root: Optional[TreeNode]) -&gt; int:\n    if root is None:\n        return 0\n\n    if root.left is None and root.right is not None:\n        return 1 + minDepthRecursive(root.right)\n    if root.left is not None and root.right is None:\n        return 1 + minDepthRecursive(root.left)\n\n    return 1 + min(minDepthRecursive(root.left), minDepthRecursive(root.right))\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n\"\"\"\n    ____1\n   /     \\\n  2__     2\n /   \\\n3     4\n     /\n    5\n\n\"\"\"\nprint(minDepthIterative(root))  # 2\nprint(minDepthRecursive(root))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_top-down_dfs/#112-path-sum","title":"112. Path Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 112. Path Sum - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef hasPathSum(root: Optional[TreeNode], targetSum: int) -&gt; bool:\n    if not root:\n        return False\n\n    if not root.left and not root.right:\n        return root.val == targetSum\n\n    targetSum -= root.val\n\n    return hasPathSum(root.left, targetSum) or hasPathSum(\n        root.right, targetSum\n    )\n\n\nroot = build([5, 4, 8, 11, None, 13, 4, 7, 2, None, None, None, None, None, 1])\nprint(root)\n#          5___\n#         /    \\\n#     ___4     _8\n#    /        /  \\\n#   11       13   4\n#  /  \\            \\\n# 7    2            1\nprint(hasPathSum(root, 22))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_top-down_dfs/#129-sum-root-to-leaf-numbers","title":"129. Sum Root to Leaf Numbers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree 129. Sum Root to Leaf Numbers - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -&gt; int:\n        self.res = 0\n\n        def dfs(node, cur):\n            if not node:\n                return\n            cur = cur * 10 + node.val\n            if not node.left and not node.right:\n                self.res += cur\n                return\n            dfs(node.left, cur)\n            dfs(node.right, cur)\n\n        dfs(root, 0)\n\n        return self.res\n\n\nroot = [1, 2, 3]\nroot = build(root)\nprint(root)\n#   1\n#  / \\\n# 2   3\nprint(Solution().sumNumbers(root))  # 25\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_top-down_dfs/#199-binary-tree-right-side-view","title":"199. Binary Tree Right Side View","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 199. Binary Tree Right Side View - Python Solution<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Binary Tree BFS\ndef rightSideViewBFS(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        n = len(q)\n        for i in range(n):\n            node = q.popleft()\n            if i == n - 1:\n                res.append(node.val)\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return res\n\n\n# Binary Tree DFS\ndef rightSideViewDFS(root: Optional[TreeNode]) -&gt; List[int]:\n    \"\"\"\u540e\u5e8f\u904d\u5386\uff0c\u5148\u53f3\u540e\u5de6\uff0c\u9047\u5230\u7684\u7b2c\u4e00\u4e2a\u8282\u70b9\u5c31\u662f\u8be5\u6df1\u5ea6\u7684\u6700\u53f3\u4fa7\u8282\u70b9\"\"\"\n    ans = []\n\n    def dfs(node, depth):\n        if node is None:\n            return\n        if depth == len(ans):  # \u8fd9\u4e2a\u6df1\u5ea6\u9996\u6b21\u9047\u5230\n            ans.append(node.val)\n\n        dfs(node.right, depth + 1)\n        dfs(node.left, depth + 1)\n\n    dfs(root, 0)\n\n    return ans\n\n\nif __name__ == \"__main__\":\n    root = [1, 2, 2, 3, 4, None, 3, None, None, 5]\n    root = build(root)\n    print(root)\n    #     ____1\n    #    /     \\\n    #   2__     2\n    #  /   \\     \\\n    # 3     4     3\n    #      /\n    #     5\n    assert rightSideViewBFS(root) == [1, 2, 3, 5]\n    assert rightSideViewDFS(root) == [1, 2, 3, 5]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_top-down_dfs/#1448-count-good-nodes-in-binary-tree","title":"1448. Count Good Nodes in Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 1448. Count Good Nodes in Binary Tree - Python Solution<pre><code>from typing import List\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Tree\ndef goodNodes(root: TreeNode) -&gt; int:\n    def dfs(node, max_val):\n        if not node:\n            return 0\n\n        good = 1 if node.val &gt;= max_val else 0\n\n        max_val = max(max_val, node.val)\n\n        good += dfs(node.left, max_val)\n        good += dfs(node.right, max_val)\n\n        return good\n\n    return dfs(root, root.val)\n\n\nroot = build([3, 1, 4, 3, None, 1, 5])\nprint(root)\n#     3__\n#    /   \\\n#   1     4\n#  /     / \\\n# 3     1   5\nprint(goodNodes(root))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_top-down_dfs/#1457-pseudo-palindromic-paths-in-a-binary-tree","title":"1457. Pseudo-Palindromic Paths in a Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: bit manipulation, tree, depth first search, breadth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_top-down_dfs/#1315-sum-of-nodes-with-even-valued-grandparent","title":"1315. Sum of Nodes with Even-Valued Grandparent","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_top-down_dfs/#988-smallest-string-starting-from-leaf","title":"988. Smallest String Starting From Leaf","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, backtracking, tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_top-down_dfs/#1026-maximum-difference-between-node-and-ancestor","title":"1026. Maximum Difference Between Node and Ancestor","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_top-down_dfs/#1022-sum-of-root-to-leaf-binary-numbers","title":"1022. Sum of Root To Leaf Binary Numbers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_top-down_dfs/#623-add-one-row-to-tree","title":"623. Add One Row to Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 623. Add One Row to Tree - Python Solution<pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BFS\ndef addOneRow_bfs(\n    root: Optional[TreeNode], val: int, depth: int\n) -&gt; Optional[TreeNode]:\n    if not root:\n        return None\n\n    if depth == 1:\n        new = TreeNode(val)\n        new.left = root\n        return new\n\n    q = deque([root])\n    cur = 1\n\n    while q:\n        size = len(q)\n        for _ in range(size):\n            node = q.popleft()\n\n            if cur == depth - 1:\n                old_left, old_right = node.left, node.right\n                node.left, node.right = TreeNode(val), TreeNode(val)\n                node.left.left = old_left\n                node.right.right = old_right\n            else:\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n        cur += 1\n\n    return root\n\n\n# DFS\ndef addOneRow_dfs(\n    root: Optional[TreeNode], val: int, depth: int\n) -&gt; Optional[TreeNode]:\n    if depth == 1:\n        new = TreeNode(val)\n        new.left = root\n        return new\n\n    def dfs(node, cur):\n        if not node:\n            return\n        if cur == depth - 1:\n            old_left, old_right = node.left, node.right\n            node.left = TreeNode(val, old_left, None)\n            node.right = TreeNode(val, None, old_right)\n        else:\n            dfs(node.left, cur + 1)\n            dfs(node.right, cur + 1)\n\n    dfs(root, 1)\n\n    return root\n\n\nif __name__ == \"__main__\":\n    root = build([4, 2, 6, 3, 1, 5])\n    print(root)\n    #     __4__\n    #    /     \\\n    #   2       6\n    #  / \\     /\n    # 3   1   5\n    print(addOneRow_bfs(deepcopy(root), 1, 2))\n    #         4\n    #        / \\\n    #     __1   1__\n    #    /         \\\n    #   2           6\n    #  / \\         /\n    # 3   1       5\n    print(addOneRow_dfs(deepcopy(root), 1, 2))\n    #         4\n    #        / \\\n    #     __1   1__\n    #    /         \\\n    #   2           6\n    #  / \\         /\n    # 3   1       5\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_top-down_dfs/#1372-longest-zigzag-path-in-a-binary-tree","title":"1372. Longest ZigZag Path in a Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming, tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_top-down_dfs/#971-flip-binary-tree-to-match-preorder-traversal","title":"971. Flip Binary Tree To Match Preorder Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_top-down_dfs/#2689-extract-kth-character-from-the-rope-tree","title":"2689. Extract Kth Character From The Rope Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_top-down_dfs/#298-binary-tree-longest-consecutive-sequence","title":"298. Binary Tree Longest Consecutive Sequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree 298. Binary Tree Longest Consecutive Sequence - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Binary Tree\ndef longestConsecutive(root: Optional[TreeNode]) -&gt; int:\n    res = 0\n\n    def dfs(node):\n        if not node:\n            return 0\n\n        left, right = dfs(node.left), dfs(node.right)\n        cur = 1\n        if node.left and node.left.val == (node.val + 1):\n            cur = max(cur, left + 1)\n        if node.right and node.right.val == (node.val + 1):\n            cur = max(cur, right + 1)\n\n        nonlocal res\n        res = max(res, cur)\n        return cur\n\n    dfs(root)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    root = build([1, 3, 2, 4, None, None, None, 5])\n    print(root)\n    #       1\n    #      / \\\n    #     3   2\n    #    /\n    #   4\n    #  /\n    # 5\n    print(longestConsecutive(root))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_top-down_dfs/#1430-check-if-a-string-is-a-valid-sequence-from-root-to-leaves-path-in-a-binary-tree","title":"1430. Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_top-down_dfs/#545-boundary-of-binary-tree","title":"545. Boundary of Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_traversal/","title":"Binary Tree Traversal","text":""},{"location":"content/endlesscheng/binary_tree_traversal/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 144. Binary Tree Preorder Traversal (Easy)</li> <li> 94. Binary Tree Inorder Traversal (Easy)</li> <li> 145. Binary Tree Postorder Traversal (Easy)</li> <li> 872. Leaf-Similar Trees (Easy)</li> <li> 404. Sum of Left Leaves (Easy)</li> <li> 671. Second Minimum Node In a Binary Tree (Easy)</li> <li> 1469. Find All The Lonely Nodes (Easy) \ud83d\udc51</li> <li> 1214. Two Sum BSTs (Medium) \ud83d\udc51</li> <li> 2764. Is Array a Preorder of Some \u200cBinary Tree (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/binary_tree_traversal/#144-binary-tree-preorder-traversal","title":"144. Binary Tree Preorder Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: stack, tree, depth first search, binary tree </p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_traversal/#example-1","title":"Example 1","text":"<pre><code>graph TD\nA(( ))\nB(( ))\nC(( ))\nD(( ))\nE(( ))\nF(( ))\nG(( ))\nA --- B\nA --- E\nB --- C\nB --- D\nE --- F\nE --- G</code></pre> <p>Pre-order Traversal</p> <pre><code>graph TD\n0((0))\n1((1))\n2((2))\n3((3))\n4((4))\n5((5))\n6((6))\n0 --- 1\n0 --- 4\n1 --- 2\n1 --- 3\n4 --- 5\n4 --- 6</code></pre> <p>In-order Traversal</p> <pre><code>graph TD\n0((0))\n1((1))\n2((2))\n3((3))\n4((4))\n5((5))\n6((6))\n3 --- 1\n3 --- 5\n1 --- 0\n1 --- 2\n5 --- 4\n5 --- 6</code></pre> <p>Post-order Traversal</p> <pre><code>graph TD\n0((0))\n1((1))\n2((2))\n3((3))\n4((4))\n5((5))\n6((6))\n6 --- 2\n6 --- 5\n2 --- 0\n2 --- 1\n5 --- 3\n5 --- 4</code></pre> <p>Level Order Traversal</p> <pre><code>graph TD\n0((0))\n1((1))\n2((1))\n3((2))\n4((2))\n5((2))\n6((2))\n0 --- 1\n0 --- 2\n1 --- 3\n1 --- 4\n2 --- 5\n2 --- 6</code></pre>"},{"location":"content/endlesscheng/binary_tree_traversal/#example-2","title":"Example 2","text":"<pre><code>graph TD\n0((0))\n1((1))\n2((2))\n3((3))\n4((4))\n5((5))\n6((6))\n0 --- 1\n0 --- 2\n1 --- 3\n1 --- 4\n2 --- 5\n2 --- 6</code></pre> Traversal Order Method Result Preorder Root, Left, Right DFS or Stack <code>[0, 1, 3, 4, 2, 5, 6]</code> Inorder Left, Root, Right DFS or Stack <code>[3, 1, 4, 0, 5, 2, 6]</code> Postorder Left, Right, Root DFS or Stack <code>[3, 4, 1, 5, 6, 2, 0]</code> Level Order Level by Level BFS with Queue <code>[[0], [1, 2], [3, 4, 5, 6]]</code> 144. Binary Tree Preorder Traversal - Python Solution<pre><code>from typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef preorderTraversalRecursive(root: Optional[TreeNode]) -&gt; List[int]:\n    res = []\n\n    def dfs(node):\n        if not node:\n            return None\n\n        res.append(node.val)  # &lt;--\n        dfs(node.left)\n        dfs(node.right)\n\n    dfs(root)\n\n    return res\n\n\n# Iterative\ndef preorderTraversalIterative(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    stack = [root]\n    res = []\n\n    while stack:\n        node = stack.pop()\n        res.append(node.val)\n\n        if node.right:\n            stack.append(node.right)\n        if node.left:\n            stack.append(node.left)\n\n    return res\n\n\ntree = build([0, 1, 2, 3, 4, 5, 6])\nprint(tree)\n#     __0__\n#    /     \\\n#   1       2\n#  / \\     / \\\n# 3   4   5   6\nprint(preorderTraversalRecursive(tree))  # [0, 1, 3, 4, 2, 5, 6]\nprint(preorderTraversalIterative(tree))  # [0, 1, 3, 4, 2, 5, 6]\n</code></pre>"},{"location":"content/endlesscheng/binary_tree_traversal/#94-binary-tree-inorder-traversal","title":"94. Binary Tree Inorder Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: stack, tree, depth first search, binary tree 94. Binary Tree Inorder Traversal - Python Solution<pre><code>from typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef inorderTraversalRecursive(root: TreeNode) -&gt; List[int]:\n    res = []\n\n    def dfs(node):\n        if not node:\n            return\n\n        dfs(node.left)\n        res.append(node.val)  # &lt;--\n        dfs(node.right)\n\n    dfs(root)\n\n    return res\n\n\n# Iterative\ndef inorderTraversalIterative(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    stack = []\n    res = []\n    cur = root\n\n    while cur or stack:\n        if cur:\n            stack.append(cur)\n            cur = cur.left\n        else:\n            cur = stack.pop()\n            res.append(cur.val)\n            cur = cur.right\n\n    return res\n\n\ntree = build([0, 1, 2, 3, 4, 5, 6])\nprint(tree)\n#     __0__\n#    /     \\\n#   1       2\n#  / \\     / \\\n# 3   4   5   6\nprint(inorderTraversalRecursive(tree))  # [3, 1, 4, 0, 5, 2, 6]\nprint(inorderTraversalIterative(tree))  # [3, 1, 4, 0, 5, 2, 6]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_traversal/#145-binary-tree-postorder-traversal","title":"145. Binary Tree Postorder Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: stack, tree, depth first search, binary tree 145. Binary Tree Postorder Traversal - Python Solution<pre><code>from typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef postorderTraversalRecursive(root: Optional[TreeNode]) -&gt; List[int]:\n    res = []\n\n    def dfs(node):\n        if not node:\n            return\n\n        dfs(node.left)\n        dfs(node.right)\n        res.append(node.val)  # &lt;--\n\n    dfs(root)\n\n    return res\n\n\n# Iterative\ndef postorderTraversalIterative(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    res = []\n    stack = [root]\n\n    while stack:\n        node = stack.pop()\n        res.append(node.val)\n\n        if node.left:\n            stack.append(node.left)\n        if node.right:\n            stack.append(node.right)\n\n    return res[::-1]\n\n\ntree = build([0, 1, 2, 3, 4, 5, 6])\nprint(tree)\n#     __0__\n#    /     \\\n#   1       2\n#  / \\     / \\\n# 3   4   5   6\nprint(postorderTraversalRecursive(tree))  # [3, 4, 1, 5, 6, 2, 0]\nprint(postorderTraversalIterative(tree))  # [3, 4, 1, 5, 6, 2, 0]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_traversal/#872-leaf-similar-trees","title":"872. Leaf-Similar Trees","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, binary tree 872. Leaf-Similar Trees - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Tree\ndef leafSimilar(root1: Optional[TreeNode], root2: Optional[TreeNode]) -&gt; bool:\n\n    def dfs(node, leaf):\n        if not node:\n            return\n        if not node.left and not node.right:\n            leaf.append(node.val)\n        dfs(node.left, leaf)\n        dfs(node.right, leaf)\n\n    leaf1, leaf2 = [], []\n    dfs(root1, leaf1)\n    dfs(root2, leaf2)\n\n    return leaf1 == leaf2\n\n\nroot1 = [3, 5, 1, 6, 2, 9, 8, None, None, 7, 4]\nroot2 = [3, 5, 1, 6, 7, 4, 2, None, None, None, None, None, None, 9, 8]\nroot1 = build(root1)\n\nroot2 = build(root2)\nprint(root1)\n#     ______3__\n#    /         \\\n#   5__         1\n#  /   \\       / \\\n# 6     2     9   8\n#      / \\\n#     7   4\nprint(root2)\n#     __3__\n#    /     \\\n#   5       1__\n#  / \\     /   \\\n# 6   7   4     2\n#              / \\\n#             9   8\nprint(leafSimilar(root1, root2))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_traversal/#404-sum-of-left-leaves","title":"404. Sum of Left Leaves","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 404. Sum of Left Leaves - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Iterative\ndef sumOfLeftLeaves(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    stack = [root]\n    sumLL = 0\n\n    while stack:\n        node = stack.pop()\n\n        if node.left and not node.left.left and not node.left.right:\n            sumLL += node.left.val\n\n        if node.right:\n            stack.append(node.right)\n        if node.left:\n            stack.append(node.left)\n\n    return sumLL\n\n\n# Left Leave None:\n#   - node.left is not None\n#   - node.left.left is None\n#   - node.left.right is None\n\nroot = build([3, 9, 20, None, None, 15, 7])\nprint(root)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(sumOfLeftLeaves(root))  # 24\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_traversal/#671-second-minimum-node-in-a-binary-tree","title":"671. Second Minimum Node In a Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_traversal/#1469-find-all-the-lonely-nodes","title":"1469. Find All The Lonely Nodes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 1469. Find All The Lonely Nodes - Python Solution<pre><code>from typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Binary Tree Traversal\ndef getLonelyNodes(root: Optional[TreeNode]) -&gt; List[int]:\n    res = []\n\n    def dfs(node):\n        if not node:\n            return False\n\n        left = dfs(node.left)\n        right = dfs(node.right)\n        if left and not right:\n            res.append(node.left.val)\n        if not left and right:\n            res.append(node.right.val)\n\n        return True\n\n    dfs(root)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    root = build([1, 2, 3, None, 4])\n    print(root)\n    #    __1\n    #  /   \\\n    # 2     3\n    #  \\\n    #   4\n    assert getLonelyNodes(root) == [4]\n\n    root = build([7, 1, 4, 6, None, 5, 3, None, None, None, None, None, 2])\n    print(root)\n    #     7____\n    #    /     \\\n    #   1     __4\n    #  /     /   \\\n    # 6     5     3\n    #        \\\n    #         2\n    assert getLonelyNodes(root) == [6, 2]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_traversal/#1214-two-sum-bsts","title":"1214. Two Sum BSTs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, binary search, stack, tree, depth first search, binary search tree, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/binary_tree_traversal/#2764-is-array-a-preorder-of-some-binary-tree","title":"2764. Is Array a Preorder of Some \u200cBinary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: stack, tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/bipartite_graph_coloring/","title":"Bipartite Graph Coloring","text":""},{"location":"content/endlesscheng/bipartite_graph_coloring/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 785. Is Graph Bipartite? (Medium)</li> <li> 886. Possible Bipartition (Medium)</li> </ul>"},{"location":"content/endlesscheng/bipartite_graph_coloring/#785-is-graph-bipartite","title":"785. Is Graph Bipartite?","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> <li>Determine if a graph is bipartite.</li> </ul> <p>How to group</p> Uncolored Color 1 Color 2 Operation Method 1 -1 0 1 <code>1 - color</code> Method 2 0 1 -1 <code>-color</code> 785. Is Graph Bipartite? - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef isBipartiteBFS(graph: List[List[int]]) -&gt; bool:\n    n = len(graph)\n    # -1: not colored; 0: blue; 1: red\n    color = [-1 for _ in range(n)]\n\n    def bfs(node):\n        q = deque([node])\n        color[node] = 0\n\n        while q:\n            cur = q.popleft()\n\n            for neighbor in graph[cur]:\n                if color[neighbor] == -1:\n                    color[neighbor] = 1 - color[cur]\n                    q.append(neighbor)\n                elif color[neighbor] == color[cur]:\n                    return False\n        return True\n\n    for i in range(n):\n        if color[i] == -1:\n            if not bfs(i):\n                return False\n\n    return True\n\n\n# DFS\ndef isBipartiteDFS(graph: List[List[int]]) -&gt; bool:\n    n = len(graph)\n    # -1: not colored; 0: blue; 1: red\n    color = [-1] * n\n\n    def dfs(node, c):\n        color[node] = c\n        for neighbor in graph[node]:\n            if color[neighbor] == -1:\n                if not dfs(neighbor, 1 - c):\n                    return False\n            elif color[neighbor] == c:\n                return False\n        return True\n\n    for i in range(n):\n        if color[i] == -1:\n            if not dfs(i, 0):\n                return False\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |    BFS     | O(V+E) |  O(V)   |\n# |    DFS     | O(V+E) |  O(V)   |\n# |------------|--------|---------|\n\n\ngraph = [[1, 2, 3], [0, 2], [0, 1, 3], [0, 2]]\nprint(isBipartiteBFS(graph))  # False\nprint(isBipartiteDFS(graph))  # False\n</code></pre>"},{"location":"content/endlesscheng/bipartite_graph_coloring/#886-possible-bipartition","title":"886. Possible Bipartition","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> <li>Determine if a graph can be divided into two groups such that no two nodes of the same group are connected.</li> </ul> 886. Possible Bipartition - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef possibleBipartitionBFS(n: int, dislikes: List[List[int]]) -&gt; bool:\n    group = {i: -1 for i in range(1, n + 1)}\n\n    # Undirected graph\n    graph = {i: [] for i in range(1, n + 1)}\n    for i, j in dislikes:\n        graph[i].append(j)\n        graph[j].append(i)\n\n    def bfs(person):\n        q = deque([person])\n        group[person] = 0\n\n        while q:\n            cur = q.popleft()\n\n            for neighbor in graph[cur]:\n                if group[neighbor] == -1:\n                    group[neighbor] = 1 - group[cur]\n                    q.append(neighbor)\n                elif group[neighbor] == group[cur]:\n                    return False\n        return True\n\n    for i in range(1, n + 1):\n        if group[i] == -1:\n            if not bfs(i):\n                return False\n    return True\n\n\n# DFS\ndef possibleBipartitionDFS(n: int, dislikes: List[List[int]]) -&gt; bool:\n    group = {i: -1 for i in range(1, n + 1)}\n    graph = {i: [] for i in range(1, n + 1)}\n    for i, j in dislikes:\n        graph[i].append(j)\n        graph[j].append(i)\n\n    def dfs(person, g):\n        group[person] = g\n\n        for neighbor in graph[person]:\n            if group[neighbor] == -1:\n                if not dfs(neighbor, 1 - g):\n                    return False\n            elif group[neighbor] == g:\n                return False\n\n        return True\n\n    for i in range(1, n + 1):\n        if group[i] == -1:\n            if not dfs(i, 0):\n                return False\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |    BFS     | O(V+E) |  O(V+E) |\n# |    DFS     | O(V+E) |  O(V+E) |\n# |------------|--------|---------|\n\n\nn = 4\ndislikes = [[1, 2], [1, 3], [2, 4]]\nprint(possibleBipartitionBFS(n, dislikes))  # True\nprint(possibleBipartitionDFS(n, dislikes))  # True\n</code></pre>"},{"location":"content/endlesscheng/bit_and_or/","title":"Bit AND OR","text":""},{"location":"content/endlesscheng/bit_and_or/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2980. Check if Bitwise OR Has Trailing Zeros (Easy)</li> <li> 1318. Minimum Flips to Make a OR b Equal to c (Medium)</li> <li> 2419. Longest Subarray With Maximum Bitwise AND (Medium)</li> <li> 2871. Split Array Into Maximum Number of Subarrays (Medium)</li> <li> 2401. Longest Nice Subarray (Medium)</li> <li> 2680. Maximum OR (Medium)</li> <li> 3133. Minimum Array End (Medium)</li> <li> 3108. Minimum Cost Walk in Weighted Graph (Hard)</li> <li> 3117. Minimum Sum of Values by Dividing Array (Hard)</li> <li> 3125. Maximum Number That Makes Result of Bitwise AND Zero (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/bit_and_or/#2980-check-if-bitwise-or-has-trailing-zeros","title":"2980. Check if Bitwise OR Has Trailing Zeros","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_and_or/#1318-minimum-flips-to-make-a-or-b-equal-to-c","title":"1318. Minimum Flips to Make a OR b Equal to c","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_and_or/#2419-longest-subarray-with-maximum-bitwise-and","title":"2419. Longest Subarray With Maximum Bitwise AND","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation, brainteaser</p> </li> </ul>"},{"location":"content/endlesscheng/bit_and_or/#2871-split-array-into-maximum-number-of-subarrays","title":"2871. Split Array Into Maximum Number of Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_and_or/#2401-longest-nice-subarray","title":"2401. Longest Nice Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/bit_and_or/#2680-maximum-or","title":"2680. Maximum OR","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, bit manipulation, prefix sum 2680. Maximum OR - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef maximumOr(nums: List[int], k: int) -&gt; int:\n    \"\"\"Maximum OR of Array After k Operations\n\n    Args:\n        nums (List[int]): provided list of integers\n        k (int): number of operations\n\n    Returns:\n        int: maximum OR of array after k operations\n    \"\"\"\n    n = len(nums)\n    suffix = [0 for _ in range(n)]\n\n    for i in range(n - 2, -1, -1):\n        suffix[i] = suffix[i + 1] | nums[i + 1]\n\n    res, pre = 0, 0\n    for num, suf in zip(nums, suffix):\n        res = max(res, pre | (num &lt;&lt; k) | suf)\n        pre |= num\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(maximumOr(nums=[8, 1, 2], k=2))  # 35\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/bit_and_or/#3133-minimum-array-end","title":"3133. Minimum Array End","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_and_or/#3108-minimum-cost-walk-in-weighted-graph","title":"3108. Minimum Cost Walk in Weighted Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, bit manipulation, union find, graph</p> </li> </ul>"},{"location":"content/endlesscheng/bit_and_or/#3117-minimum-sum-of-values-by-dividing-array","title":"3117. Minimum Sum of Values by Dividing Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, dynamic programming, bit manipulation, segment tree, queue</p> </li> </ul>"},{"location":"content/endlesscheng/bit_and_or/#3125-maximum-number-that-makes-result-of-bitwise-and-zero","title":"3125. Maximum Number That Makes Result of Bitwise AND Zero","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/bit_basics/","title":"Bit Basics","text":""},{"location":"content/endlesscheng/bit_basics/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3370. Smallest Number With All Set Bits (Easy)</li> <li> 3226. Number of Bit Changes to Make Two Integers Equal (Easy)</li> <li> 1356. Sort Integers by The Number of 1 Bits (Easy)</li> <li> 461. Hamming Distance (Easy)</li> <li> 2220. Minimum Bit Flips to Convert Number (Easy)</li> <li> 476. Number Complement (Easy)</li> <li> 1009. Complement of Base 10 Integer (Easy)</li> <li> 868. Binary Gap (Easy)</li> <li> 3211. Generate Binary Strings Without Adjacent Zeros (Medium)</li> <li> 2917. Find the K-or of an Array (Easy)</li> <li> 693. Binary Number with Alternating Bits (Easy)</li> <li> 2657. Find the Prefix Common Array of Two Arrays (Medium)</li> <li> 231. Power of Two (Easy)</li> <li> 342. Power of Four (Easy)</li> <li> 191. Number of 1 Bits (Easy)</li> <li> 2595. Number of Even and Odd Bits (Easy)</li> <li> 338. Counting Bits (Easy)</li> </ul>"},{"location":"content/endlesscheng/bit_basics/#3370-smallest-number-with-all-set-bits","title":"3370. Smallest Number With All Set Bits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_basics/#3226-number-of-bit-changes-to-make-two-integers-equal","title":"3226. Number of Bit Changes to Make Two Integers Equal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_basics/#1356-sort-integers-by-the-number-of-1-bits","title":"1356. Sort Integers by The Number of 1 Bits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, bit manipulation, sorting, counting</p> </li> </ul>"},{"location":"content/endlesscheng/bit_basics/#461-hamming-distance","title":"461. Hamming Distance","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_basics/#2220-minimum-bit-flips-to-convert-number","title":"2220. Minimum Bit Flips to Convert Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_basics/#476-number-complement","title":"476. Number Complement","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_basics/#1009-complement-of-base-10-integer","title":"1009. Complement of Base 10 Integer","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_basics/#868-binary-gap","title":"868. Binary Gap","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_basics/#3211-generate-binary-strings-without-adjacent-zeros","title":"3211. Generate Binary Strings Without Adjacent Zeros","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, backtracking, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_basics/#2917-find-the-k-or-of-an-array","title":"2917. Find the K-or of an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_basics/#693-binary-number-with-alternating-bits","title":"693. Binary Number with Alternating Bits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_basics/#2657-find-the-prefix-common-array-of-two-arrays","title":"2657. Find the Prefix Common Array of Two Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_basics/#231-power-of-two","title":"231. Power of Two","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, bit manipulation, recursion</p> </li> </ul>"},{"location":"content/endlesscheng/bit_basics/#342-power-of-four","title":"342. Power of Four","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, bit manipulation, recursion</p> </li> </ul>"},{"location":"content/endlesscheng/bit_basics/#191-number-of-1-bits","title":"191. Number of 1 Bits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: divide and conquer, bit manipulation 191. Number of 1 Bits - Python Solution<pre><code># Bit Manipulation\ndef hammingWeight1(n: int) -&gt; int:\n    res = 0\n\n    while n != 0:\n        n = n &amp; (n - 1)  # Unset the rightmost 1-bit\n        res += 1\n\n    return res\n\n\ndef hammingWeight2(n: int) -&gt; int:\n    return bin(n).count(\"1\")\n\n\ndef hammingWeight3(n: int) -&gt; int:\n    def decimalToBinary(n: int) -&gt; str:\n        if n == 0:\n            return \"0\"\n\n        binary = \"\"\n        while n &gt; 0:\n            binary = str(n % 2) + binary\n            n //= 2\n\n        return binary\n\n    binary = decimalToBinary(n)\n\n    return binary.count(\"1\")\n\n\nn = 11\nprint(hammingWeight1(n))  # 3\nprint(hammingWeight2(n))  # 3\n\nn = 47\nprint(bin(n))\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/bit_basics/#2595-number-of-even-and-odd-bits","title":"2595. Number of Even and Odd Bits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: bit manipulation</p> </li> <li>Topic: Bit Manipulation</li> <li>Difficulty: Easy</li> </ul> <p>You are given a positive integer n. Let even denote the number of even indices in the binary representation of n with value 1. Let odd denote the number of odd indices in the binary representation of n with value 1. Note that bits are indexed from right to left in the binary representation of a number. Return the array [even, odd].</p>"},{"location":"content/endlesscheng/bit_basics/#338-counting-bits","title":"338. Counting Bits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: dynamic programming, bit manipulation 338. Counting Bits - Python Solution<pre><code>from typing import List\n\n\n# Bit Manipulation\ndef countBits(n: int) -&gt; List[int]:\n    bits = [0 for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        bits[i] = bits[i &gt;&gt; 1] + (i &amp; 1)\n\n    return bits\n\n\nn = 5\nprint(countBits(n))  # [0, 1, 1, 2, 1, 2]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/bit_contribution_method/","title":"Bit Contribution Method","text":""},{"location":"content/endlesscheng/bit_contribution_method/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 477. Total Hamming Distance (Medium)</li> <li> 1863. Sum of All Subset XOR Totals (Easy)</li> <li> 2425. Bitwise XOR of All Pairings (Medium)</li> <li> 2275. Largest Combination With Bitwise AND Greater Than Zero (Medium)</li> <li> 1835. Find XOR Sum of All Pairs Bitwise AND (Hard)</li> <li> 2505. Bitwise OR of All Subsequence Sums (Medium) \ud83d\udc51</li> <li> 3153. Sum of Digit Differences of All Pairs (Medium)</li> </ul>"},{"location":"content/endlesscheng/bit_contribution_method/#477-total-hamming-distance","title":"477. Total Hamming Distance","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_contribution_method/#1863-sum-of-all-subset-xor-totals","title":"1863. Sum of All Subset XOR Totals","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, math, backtracking, bit manipulation, combinatorics, enumeration 1863. Sum of All Subset XOR Totals - Python Solution<pre><code>from functools import reduce\nfrom operator import or_\nfrom typing import List\n\n\ndef subsetXORSum(nums: List[int]) -&gt; int:\n    return reduce(or_, nums) &lt;&lt; (len(nums) - 1)\n\n\nif __name__ == \"__main__\":\n    nums = [5, 1, 6]\n    print(subsetXORSum(nums))  # 28\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/bit_contribution_method/#2425-bitwise-xor-of-all-pairings","title":"2425. Bitwise XOR of All Pairings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation, brainteaser</p> </li> </ul>"},{"location":"content/endlesscheng/bit_contribution_method/#2275-largest-combination-with-bitwise-and-greater-than-zero","title":"2275. Largest Combination With Bitwise AND Greater Than Zero","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, bit manipulation, counting</p> </li> </ul>"},{"location":"content/endlesscheng/bit_contribution_method/#1835-find-xor-sum-of-all-pairs-bitwise-and","title":"1835. Find XOR Sum of All Pairs Bitwise AND","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_contribution_method/#2505-bitwise-or-of-all-subsequence-sums","title":"2505. Bitwise OR of All Subsequence Sums","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, bit manipulation, brainteaser</p> </li> </ul>"},{"location":"content/endlesscheng/bit_contribution_method/#3153-sum-of-digit-differences-of-all-pairs","title":"3153. Sum of Digit Differences of All Pairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, counting</p> </li> </ul>"},{"location":"content/endlesscheng/bit_identity_law/","title":"Bit Identity Law","text":""},{"location":"content/endlesscheng/bit_identity_law/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1835. Find XOR Sum of All Pairs Bitwise AND (Hard)</li> <li> 2354. Number of Excellent Pairs (Hard)</li> </ul>"},{"location":"content/endlesscheng/bit_identity_law/#1835-find-xor-sum-of-all-pairs-bitwise-and","title":"1835. Find XOR Sum of All Pairs Bitwise AND","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_identity_law/#2354-number-of-excellent-pairs","title":"2354. Number of Excellent Pairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, binary search, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_logtrick/","title":"Bit LogTrick","text":""},{"location":"content/endlesscheng/bit_logtrick/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3097. Shortest Subarray With OR at Least K II (Medium)</li> <li> 2411. Smallest Subarrays With Maximum Bitwise OR (Medium)</li> <li> 3209. Number of Subarrays With AND Value of K (Hard)</li> <li> 3171. Find Subarray With Bitwise OR Closest to K (Hard)</li> <li> 1521. Find a Value of a Mysterious Function Closest to Target (Hard)</li> <li> 898. Bitwise ORs of Subarrays (Medium)</li> </ul>"},{"location":"content/endlesscheng/bit_logtrick/#3097-shortest-subarray-with-or-at-least-k-ii","title":"3097. Shortest Subarray With OR at Least K II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/bit_logtrick/#2411-smallest-subarrays-with-maximum-bitwise-or","title":"2411. Smallest Subarrays With Maximum Bitwise OR","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, bit manipulation, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/bit_logtrick/#3209-number-of-subarrays-with-and-value-of-k","title":"3209. Number of Subarrays With AND Value of K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, bit manipulation, segment tree</p> </li> </ul>"},{"location":"content/endlesscheng/bit_logtrick/#3171-find-subarray-with-bitwise-or-closest-to-k","title":"3171. Find Subarray With Bitwise OR Closest to K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, bit manipulation, segment tree</p> </li> </ul>"},{"location":"content/endlesscheng/bit_logtrick/#1521-find-a-value-of-a-mysterious-function-closest-to-target","title":"1521. Find a Value of a Mysterious Function Closest to Target","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, bit manipulation, segment tree</p> </li> </ul>"},{"location":"content/endlesscheng/bit_logtrick/#898-bitwise-ors-of-subarrays","title":"898. Bitwise ORs of Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_others/","title":"Bit Others","text":""},{"location":"content/endlesscheng/bit_others/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 136. Single Number (Easy)</li> <li> 287. Find the Duplicate Number (Medium)</li> <li> 260. Single Number III (Medium)</li> <li> 2965. Find Missing and Repeated Values (Easy)</li> <li> 137. Single Number II (Medium)</li> <li> 645. Set Mismatch (Easy)</li> <li> 190. Reverse Bits (Easy)</li> <li> 371. Sum of Two Integers (Medium)</li> <li> 201. Bitwise AND of Numbers Range (Medium)</li> <li> 2154. Keep Multiplying Found Values by Two (Easy)</li> <li> 2044. Count Number of Maximum Bitwise-OR Subsets (Medium)</li> <li> 2438. Range Product Queries of Powers (Medium)</li> <li> 1680. Concatenation of Consecutive Binary Numbers (Medium)</li> <li> 1261. Find Elements in a Contaminated Binary Tree (Medium)</li> <li> 89. Gray Code (Medium)</li> <li> 1238. Circular Permutation in Binary Representation (Medium)</li> <li> 982. Triples with Bitwise AND Equal To Zero (Hard)</li> <li> 3307. Find the K-th Character in String Game II (Hard)</li> <li> 1611. Minimum One Bit Operations to Make Integers Zero (Hard)</li> <li> 751. IP to CIDR (Medium) \ud83d\udc51</li> <li> 3141. Maximum Hamming Distances (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/bit_others/#136-single-number","title":"136. Single Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, bit manipulation 136. Single Number - Python Solution<pre><code>from functools import reduce\nfrom operator import xor\nfrom typing import List\n\n\n# XOR\ndef singleNumber(nums: List[int]) -&gt; int:\n    res = 0\n    for num in nums:\n        res ^= num\n    return res\n\n\n# XOR\ndef singleNumberXOR(nums: List[int]) -&gt; int:\n    return reduce(xor, nums)\n\n\n# XOR\ndef singleNumberXORLambda(nums: List[int]) -&gt; int:\n    return reduce(lambda x, y: x ^ y, nums)\n\n\nnums = [4, 1, 2, 1, 2]\nprint(singleNumber(nums))  # 4\nprint(singleNumberXOR(nums))  # 4\nprint(singleNumberXORLambda(nums))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/bit_others/#287-find-the-duplicate-number","title":"287. Find the Duplicate Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, bit manipulation</p> </li> <li>Find the duplicate number in an array containing <code>n + 1</code> integers where each integer is between <code>1</code> and <code>n</code> inclusive.</li> <li>Floyd's Tortoise and Hare (Cycle Detection)<ul> <li> <ol> <li>Linked List Cycle</li> </ol> </li> <li> <ol> <li>Linked List Cycle II</li> </ol> </li> </ul> </li> <li>Time Complexity: O(n)</li> <li>Space Complexity: O(1)</li> </ul> <p>Example: <code>nums = [1, 3, 4, 2, 2]</code></p> 0 1 2 3 4 1 3 4 2 2 <pre><code>graph LR\n0((0)) --&gt; 1((1))\n1 --&gt; 3((3))\n2((2))--&gt; 4((4))\n3 --&gt; 2\n4 --&gt; 2</code></pre> 287. Find the Duplicate Number - Python Solution<pre><code>from typing import List\n\n\n# Floyd Cycle Detection Algorithm\ndef findDuplicate(nums: List[int]) -&gt; int:\n    fast, slow = nums[0], nums[0]\n\n    while True:\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n        if slow == fast:\n            break\n\n    slow = nums[0]\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[fast]\n\n    return slow\n\n\nnums = [1, 3, 4, 2, 2]\nprint(findDuplicate(nums))  # 2\n</code></pre>"},{"location":"content/endlesscheng/bit_others/#260-single-number-iii","title":"260. Single Number III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_others/#2965-find-missing-and-repeated-values","title":"2965. Find Missing and Repeated Values","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, math, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/bit_others/#137-single-number-ii","title":"137. Single Number II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_others/#645-set-mismatch","title":"645. Set Mismatch","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, bit manipulation, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/bit_others/#190-reverse-bits","title":"190. Reverse Bits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: divide and conquer, bit manipulation 190. Reverse Bits - Python Solution<pre><code># Bit Manipulation\ndef reverseBits(n: int) -&gt; int:\n    res = 0\n\n    for i in range(32):\n        res = (res &lt;&lt; 1) | (n &amp; 1)\n        n &gt;&gt;= 1\n\n    return res\n\n\nn = 0b00000010100101000001111010011100\nprint(reverseBits(n))  # 964176192\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/bit_others/#371-sum-of-two-integers","title":"371. Sum of Two Integers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, bit manipulation 371. Sum of Two Integers - Python Solution<pre><code># Bit Manipulation\ndef getSum(a: int, b: int) -&gt; int:\n    MASK = 0xFFFFFFFF\n    MAX_INT = 0x7FFFFFFF\n\n    while b != 0:\n        temp = (a ^ b) &amp; MASK\n        b = ((a &amp; b) &lt;&lt; 1) &amp; MASK\n        a = temp\n\n    return a if a &lt;= MAX_INT else ~(a ^ MASK)\n\n\nprint(getSum(1, 2))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/bit_others/#201-bitwise-and-of-numbers-range","title":"201. Bitwise AND of Numbers Range","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_others/#2154-keep-multiplying-found-values-by-two","title":"2154. Keep Multiplying Found Values by Two","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, sorting, simulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_others/#2044-count-number-of-maximum-bitwise-or-subsets","title":"2044. Count Number of Maximum Bitwise-OR Subsets","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking, bit manipulation, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/bit_others/#2438-range-product-queries-of-powers","title":"2438. Range Product Queries of Powers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/bit_others/#1680-concatenation-of-consecutive-binary-numbers","title":"1680. Concatenation of Consecutive Binary Numbers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, bit manipulation, simulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_others/#1261-find-elements-in-a-contaminated-binary-tree","title":"1261. Find Elements in a Contaminated Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, tree, depth first search, breadth first search, design, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/bit_others/#89-gray-code","title":"89. Gray Code","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, backtracking, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_others/#1238-circular-permutation-in-binary-representation","title":"1238. Circular Permutation in Binary Representation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, backtracking, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_others/#982-triples-with-bitwise-and-equal-to-zero","title":"982. Triples with Bitwise AND Equal To Zero","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_others/#3307-find-the-k-th-character-in-string-game-ii","title":"3307. Find the K-th Character in String Game II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, bit manipulation, recursion</p> </li> </ul>"},{"location":"content/endlesscheng/bit_others/#1611-minimum-one-bit-operations-to-make-integers-zero","title":"1611. Minimum One Bit Operations to Make Integers Zero","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, bit manipulation, memoization</p> </li> </ul>"},{"location":"content/endlesscheng/bit_others/#751-ip-to-cidr","title":"751. IP to CIDR","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_others/#3141-maximum-hamming-distances","title":"3141. Maximum Hamming Distances","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, bit manipulation, breadth first search</p> </li> </ul>"},{"location":"content/endlesscheng/bit_thinking_problems/","title":"Bit Thinking Problems","text":""},{"location":"content/endlesscheng/bit_thinking_problems/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2546. Apply Bitwise Operations to Make Strings Equal (Medium)</li> <li> 1558. Minimum Numbers of Function Calls to Make Target Array (Medium)</li> <li> 2571. Minimum Operations to Reduce an Integer to 0 (Medium)</li> <li> 3315. Construct the Minimum Bitwise Array II (Medium)</li> <li> 2568. Minimum Impossible OR (Medium)</li> <li> 2509. Cycle Length Queries in a Tree (Hard)</li> <li> 2939. Maximum Xor Product (Medium)</li> <li> 2749. Minimum Operations to Make the Integer Zero (Medium)</li> <li> 2835. Minimum Operations to Form Subsequence With Target Sum (Hard)</li> <li> 2897. Apply Operations on Array to Maximize Sum of Squares (Hard)</li> <li> 810. Chalkboard XOR Game (Hard)</li> <li> 3064. Guess the Number Using Bitwise Questions I (Medium) \ud83d\udc51</li> <li> 3094. Guess the Number Using Bitwise Questions II (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/bit_thinking_problems/#2546-apply-bitwise-operations-to-make-strings-equal","title":"2546. Apply Bitwise Operations to Make Strings Equal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_thinking_problems/#1558-minimum-numbers-of-function-calls-to-make-target-array","title":"1558. Minimum Numbers of Function Calls to Make Target Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_thinking_problems/#2571-minimum-operations-to-reduce-an-integer-to-0","title":"2571. Minimum Operations to Reduce an Integer to 0","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming, greedy, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_thinking_problems/#3315-construct-the-minimum-bitwise-array-ii","title":"3315. Construct the Minimum Bitwise Array II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_thinking_problems/#2568-minimum-impossible-or","title":"2568. Minimum Impossible OR","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation, brainteaser</p> </li> </ul>"},{"location":"content/endlesscheng/bit_thinking_problems/#2509-cycle-length-queries-in-a-tree","title":"2509. Cycle Length Queries in a Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, tree, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/bit_thinking_problems/#2939-maximum-xor-product","title":"2939. Maximum Xor Product","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, greedy, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_thinking_problems/#2749-minimum-operations-to-make-the-integer-zero","title":"2749. Minimum Operations to Make the Integer Zero","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: bit manipulation, brainteaser, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/bit_thinking_problems/#2835-minimum-operations-to-form-subsequence-with-target-sum","title":"2835. Minimum Operations to Form Subsequence With Target Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_thinking_problems/#2897-apply-operations-on-array-to-maximize-sum-of-squares","title":"2897. Apply Operations on Array to Maximize Sum of Squares","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, greedy, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_thinking_problems/#810-chalkboard-xor-game","title":"810. Chalkboard XOR Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, bit manipulation, brainteaser, game theory</p> </li> </ul>"},{"location":"content/endlesscheng/bit_thinking_problems/#3064-guess-the-number-using-bitwise-questions-i","title":"3064. Guess the Number Using Bitwise Questions I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: bit manipulation, interactive</p> </li> </ul>"},{"location":"content/endlesscheng/bit_thinking_problems/#3094-guess-the-number-using-bitwise-questions-ii","title":"3094. Guess the Number Using Bitwise Questions II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: bit manipulation, interactive</p> </li> </ul>"},{"location":"content/endlesscheng/bit_trial_and_error_method/","title":"Bit Trial and Error Method","text":""},{"location":"content/endlesscheng/bit_trial_and_error_method/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3007. Maximum Number That Sum of the Prices Is Less Than or Equal to K (Medium)</li> <li> 421. Maximum XOR of Two Numbers in an Array (Medium)</li> <li> 2935. Maximum Strong Pair XOR II (Hard)</li> <li> 3145. Find Products of Elements of Big Array (Hard)</li> <li> 3022. Minimize OR of Remaining Elements Using Operations (Hard)</li> <li> 3287. Find the Maximum Sequence Value of Array (Hard)</li> </ul>"},{"location":"content/endlesscheng/bit_trial_and_error_method/#3007-maximum-number-that-sum-of-the-prices-is-less-than-or-equal-to-k","title":"3007. Maximum Number That Sum of the Prices Is Less Than or Equal to K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: binary search, dynamic programming, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_trial_and_error_method/#421-maximum-xor-of-two-numbers-in-an-array","title":"421. Maximum XOR of Two Numbers in an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, bit manipulation, trie</p> </li> </ul>"},{"location":"content/endlesscheng/bit_trial_and_error_method/#2935-maximum-strong-pair-xor-ii","title":"2935. Maximum Strong Pair XOR II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, bit manipulation, trie, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/bit_trial_and_error_method/#3145-find-products-of-elements-of-big-array","title":"3145. Find Products of Elements of Big Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_trial_and_error_method/#3022-minimize-or-of-remaining-elements-using-operations","title":"3022. Minimize OR of Remaining Elements Using Operations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_trial_and_error_method/#3287-find-the-maximum-sequence-value-of-array","title":"3287. Find the Maximum Sequence Value of Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_xor/","title":"Bit XOR","text":""},{"location":"content/endlesscheng/bit_xor/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1486. XOR Operation in an Array (Easy)</li> <li> 1720. Decode XORed Array (Easy)</li> <li> 2433. Find The Original Array of Prefix Xor (Medium)</li> <li> 1310. XOR Queries of a Subarray (Medium)</li> <li> 2683. Neighboring Bitwise XOR (Medium)</li> <li> 1829. Maximum XOR for Each Query (Medium)</li> <li> 2997. Minimum Number of Operations to Make Array XOR Equal to K (Medium)</li> <li> 1442. Count Triplets That Can Form Two Arrays of Equal XOR (Medium)</li> <li> 2429. Minimize XOR (Medium)</li> <li> 2527. Find Xor-Beauty of Array (Medium)</li> <li> 2317. Maximum XOR After Operations  (Medium)</li> <li> 2588. Count the Number of Beautiful Subarrays (Medium)</li> <li> 2564. Substring XOR Queries (Medium)</li> <li> 1734. Decode XORed Permutation (Medium)</li> <li> 2857. Count Pairs of Points With Distance k (Medium)</li> <li> 1803. Count Pairs With XOR in a Range (Hard)</li> <li> 3215. Count Triplets with Even XOR Set Bits II (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/bit_xor/#1486-xor-operation-in-an-array","title":"1486. XOR Operation in an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_xor/#1720-decode-xored-array","title":"1720. Decode XORed Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_xor/#2433-find-the-original-array-of-prefix-xor","title":"2433. Find The Original Array of Prefix Xor","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_xor/#1310-xor-queries-of-a-subarray","title":"1310. XOR Queries of a Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/bit_xor/#2683-neighboring-bitwise-xor","title":"2683. Neighboring Bitwise XOR","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_xor/#1829-maximum-xor-for-each-query","title":"1829. Maximum XOR for Each Query","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/bit_xor/#2997-minimum-number-of-operations-to-make-array-xor-equal-to-k","title":"2997. Minimum Number of Operations to Make Array XOR Equal to K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_xor/#1442-count-triplets-that-can-form-two-arrays-of-equal-xor","title":"1442. Count Triplets That Can Form Two Arrays of Equal XOR","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, bit manipulation, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/bit_xor/#2429-minimize-xor","title":"2429. Minimize XOR","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: greedy, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_xor/#2527-find-xor-beauty-of-array","title":"2527. Find Xor-Beauty of Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_xor/#2317-maximum-xor-after-operations","title":"2317. Maximum XOR After Operations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_xor/#2588-count-the-number-of-beautiful-subarrays","title":"2588. Count the Number of Beautiful Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, bit manipulation, prefix sum</p> </li> <li><code>nums = [4, 3, 1, 2, 4]</code></li> <li>In bianry</li> </ul> <pre><code>4 -&gt; 100\n3 -&gt; 011\n1 -&gt; 001\n2 -&gt; 010\n4 -&gt; 100\n</code></pre> 2588. Count the Number of Beautiful Subarrays - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\ndef beautifulSubarrays(nums: List[int]) -&gt; int:\n    res, s = 0, 0\n    cnt = defaultdict(int)\n    cnt[0] = 1\n\n    for x in nums:\n        s ^= x\n        res += cnt[s]\n        cnt[s] += 1\n\n    return res\n\n\nnums = [4, 3, 1, 2, 4]\nprint(beautifulSubarrays(nums))  # 2\n</code></pre>"},{"location":"content/endlesscheng/bit_xor/#2564-substring-xor-queries","title":"2564. Substring XOR Queries","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_xor/#1734-decode-xored-permutation","title":"1734. Decode XORed Permutation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_xor/#2857-count-pairs-of-points-with-distance-k","title":"2857. Count Pairs of Points With Distance k","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/bit_xor/#1803-count-pairs-with-xor-in-a-range","title":"1803. Count Pairs With XOR in a Range","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, bit manipulation, trie</p> </li> </ul>"},{"location":"content/endlesscheng/bit_xor/#3215-count-triplets-with-even-xor-set-bits-ii","title":"3215. Count Triplets with Even XOR Set Bits II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/brain_teasers/","title":"Brain Teasers","text":""},{"location":"content/endlesscheng/brain_teasers/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2733. Neither Minimum nor Maximum (Easy)</li> <li> 1903. Largest Odd Number in String (Easy)</li> <li> 2549. Count Distinct Numbers on Board (Easy)</li> <li> 3432. Count Partitions with Even Sum Difference (Easy)</li> <li> 2396. Strictly Palindromic Number (Medium)</li> <li> 1689. Partitioning Into Minimum Number Of Deci-Binary Numbers (Medium)</li> <li> 598. Range Addition II (Easy)</li> <li> 521. Longest Uncommon Subsequence I (Easy)</li> <li> 3227. Vowels Game in a String (Medium)</li> <li> 2419. Longest Subarray With Maximum Bitwise AND (Medium)</li> <li> 3424. Minimum Cost to Make Arrays Identical (Medium)</li> <li> 1992. Find All Groups of Farmland (Medium)</li> <li> 1007. Minimum Domino Rotations For Equal Row (Medium)</li> <li> 2811. Check if it is Possible to Split Array (Medium)</li> <li> 2211. Count Collisions on a Road (Medium)</li> <li> 3207. Maximum Points After Enemy Battles (Medium)</li> <li> 2546. Apply Bitwise Operations to Make Strings Equal (Medium)</li> <li> 1503. Last Moment Before All Ants Fall Out of a Plank (Medium)</li> <li> 2860. Happy Students (Medium)</li> <li> 1332. Remove Palindromic Subsequences (Easy)</li> <li> 1975. Maximum Matrix Sum (Medium)</li> <li> 1145. Binary Tree Coloring Game (Medium)</li> <li> 1297. Maximum Number of Occurrences of a Substring (Medium)</li> <li> 3282. Reach End of Array With Max Score (Medium)</li> <li> 2332. The Latest Time to Catch a Bus (Medium)</li> <li> 2680. Maximum OR (Medium)</li> <li> 2731. Movement of Robots (Medium)</li> <li> 2556. Disconnect Path in a Binary Matrix by at Most One Flip (Medium)</li> <li> 3125. Maximum Number That Makes Result of Bitwise AND Zero (Medium) \ud83d\udc51</li> <li> 1794. Count Pairs of Equal Substrings With Minimum Difference (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/brain_teasers/#2733-neither-minimum-nor-maximum","title":"2733. Neither Minimum nor Maximum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/brain_teasers/#1903-largest-odd-number-in-string","title":"1903. Largest Odd Number in String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, string, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/brain_teasers/#2549-count-distinct-numbers-on-board","title":"2549. Count Distinct Numbers on Board","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, math, simulation</p> </li> </ul>"},{"location":"content/endlesscheng/brain_teasers/#3432-count-partitions-with-even-sum-difference","title":"3432. Count Partitions with Even Sum Difference","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, math, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/brain_teasers/#2396-strictly-palindromic-number","title":"2396. Strictly Palindromic Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, two pointers, brainteaser</p> </li> </ul>"},{"location":"content/endlesscheng/brain_teasers/#1689-partitioning-into-minimum-number-of-deci-binary-numbers","title":"1689. Partitioning Into Minimum Number Of Deci-Binary Numbers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/brain_teasers/#598-range-addition-ii","title":"598. Range Addition II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, math</p> </li> </ul>"},{"location":"content/endlesscheng/brain_teasers/#521-longest-uncommon-subsequence-i","title":"521. Longest Uncommon Subsequence I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string</p> </li> </ul>"},{"location":"content/endlesscheng/brain_teasers/#3227-vowels-game-in-a-string","title":"3227. Vowels Game in a String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, string, brainteaser, game theory</p> </li> </ul>"},{"location":"content/endlesscheng/brain_teasers/#2419-longest-subarray-with-maximum-bitwise-and","title":"2419. Longest Subarray With Maximum Bitwise AND","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation, brainteaser</p> </li> </ul>"},{"location":"content/endlesscheng/brain_teasers/#3424-minimum-cost-to-make-arrays-identical","title":"3424. Minimum Cost to Make Arrays Identical","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/brain_teasers/#1992-find-all-groups-of-farmland","title":"1992. Find All Groups of Farmland","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/brain_teasers/#1007-minimum-domino-rotations-for-equal-row","title":"1007. Minimum Domino Rotations For Equal Row","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/brain_teasers/#2811-check-if-it-is-possible-to-split-array","title":"2811. Check if it is Possible to Split Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/brain_teasers/#2211-count-collisions-on-a-road","title":"2211. Count Collisions on a Road","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack, simulation</p> </li> </ul>"},{"location":"content/endlesscheng/brain_teasers/#3207-maximum-points-after-enemy-battles","title":"3207. Maximum Points After Enemy Battles","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/brain_teasers/#2546-apply-bitwise-operations-to-make-strings-equal","title":"2546. Apply Bitwise Operations to Make Strings Equal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/brain_teasers/#1503-last-moment-before-all-ants-fall-out-of-a-plank","title":"1503. Last Moment Before All Ants Fall Out of a Plank","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, brainteaser, simulation</p> </li> </ul>"},{"location":"content/endlesscheng/brain_teasers/#2860-happy-students","title":"2860. Happy Students","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sorting, enumeration 2860. Happy Students - Python Solution<pre><code>from typing import List\n\n\n# Sort\ndef countWays(nums: List[int]) -&gt; int:\n    nums.sort()\n    n = len(nums)\n    count = 0\n\n    if nums[0] &gt; 0:\n        count += 1\n\n    for x in range(1, n):\n        if nums[x - 1] &lt; x &lt; nums[x]:\n            count += 1\n\n    if nums[n - 1] &lt; n:\n        count += 1\n\n    return count\n\n\nnums = [6, 0, 3, 3, 6, 7, 2, 7]\nprint(countWays(nums))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/brain_teasers/#1332-remove-palindromic-subsequences","title":"1332. Remove Palindromic Subsequences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string</p> </li> </ul>"},{"location":"content/endlesscheng/brain_teasers/#1975-maximum-matrix-sum","title":"1975. Maximum Matrix Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/brain_teasers/#1145-binary-tree-coloring-game","title":"1145. Binary Tree Coloring Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/brain_teasers/#1297-maximum-number-of-occurrences-of-a-substring","title":"1297. Maximum Number of Occurrences of a Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/brain_teasers/#3282-reach-end-of-array-with-max-score","title":"3282. Reach End of Array With Max Score","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/brain_teasers/#2332-the-latest-time-to-catch-a-bus","title":"2332. The Latest Time to Catch a Bus","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/brain_teasers/#2680-maximum-or","title":"2680. Maximum OR","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, bit manipulation, prefix sum 2680. Maximum OR - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef maximumOr(nums: List[int], k: int) -&gt; int:\n    \"\"\"Maximum OR of Array After k Operations\n\n    Args:\n        nums (List[int]): provided list of integers\n        k (int): number of operations\n\n    Returns:\n        int: maximum OR of array after k operations\n    \"\"\"\n    n = len(nums)\n    suffix = [0 for _ in range(n)]\n\n    for i in range(n - 2, -1, -1):\n        suffix[i] = suffix[i + 1] | nums[i + 1]\n\n    res, pre = 0, 0\n    for num, suf in zip(nums, suffix):\n        res = max(res, pre | (num &lt;&lt; k) | suf)\n        pre |= num\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(maximumOr(nums=[8, 1, 2], k=2))  # 35\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/brain_teasers/#2731-movement-of-robots","title":"2731. Movement of Robots","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, brainteaser, sorting, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/brain_teasers/#2556-disconnect-path-in-a-binary-matrix-by-at-most-one-flip","title":"2556. Disconnect Path in a Binary Matrix by at Most One Flip","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, depth first search, breadth first search, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/brain_teasers/#3125-maximum-number-that-makes-result-of-bitwise-and-zero","title":"3125. Maximum Number That Makes Result of Bitwise AND Zero","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/brain_teasers/#1794-count-pairs-of-equal-substrings-with-minimum-difference","title":"1794. Count Pairs of Equal Substrings With Minimum Difference","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/circles/","title":"Circles","text":""},{"location":"content/endlesscheng/circles/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1401. Circle and Rectangle Overlapping (Medium)</li> <li> 1453. Maximum Number of Darts Inside of a Circular Dartboard (Hard)</li> <li> 3235. Check if the Rectangle Corner Is Reachable (Hard)</li> <li> 1924. Erect the Fence II (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/circles/#1401-circle-and-rectangle-overlapping","title":"1401. Circle and Rectangle Overlapping","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, geometry</p> </li> </ul>"},{"location":"content/endlesscheng/circles/#1453-maximum-number-of-darts-inside-of-a-circular-dartboard","title":"1453. Maximum Number of Darts Inside of a Circular Dartboard","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, geometry</p> </li> </ul>"},{"location":"content/endlesscheng/circles/#3235-check-if-the-rectangle-corner-is-reachable","title":"3235. Check if the Rectangle Corner Is Reachable","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, depth first search, breadth first search, union find, geometry</p> </li> </ul>"},{"location":"content/endlesscheng/circles/#1924-erect-the-fence-ii","title":"1924. Erect the Fence II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, geometry</p> </li> </ul>"},{"location":"content/endlesscheng/combinatorial_counting/","title":"Combinatorial Counting","text":""},{"location":"content/endlesscheng/combinatorial_counting/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 62. Unique Paths (Medium)</li> <li> 357. Count Numbers with Unique Digits (Medium)</li> <li> 1175. Prime Arrangements (Easy)</li> <li> 3179. Find the N-th Value After K Seconds (Medium)</li> <li> 1359. Count All Valid Pickup and Delivery Options (Hard)</li> <li> 2400. Number of Ways to Reach a Position After Exactly k Steps (Medium)</li> <li> 2514. Count Anagrams (Hard)</li> <li> 3154. Find Number of Ways to Reach the K-th Stair (Hard)</li> <li> 1643. Kth Smallest Instructions (Hard)</li> <li> 2842. Count K-Subsequences of a String With Maximum Beauty (Hard)</li> <li> 1569. Number of Ways to Reorder Array to Get Same BST (Hard)</li> <li> 3405. Count the Number of Arrays with K Matching Adjacent Elements (Hard)</li> <li> 1866. Number of Ways to Rearrange Sticks With K Sticks Visible (Hard)</li> <li> 1467. Probability of a Two Boxes Having The Same Number of Distinct Balls (Hard)</li> <li> 3272. Find the Count of Good Integers (Hard)</li> <li> 3317. Find the Number of Possible Ways for an Event (Hard)</li> <li> 1916. Count Ways to Build Rooms in an Ant Colony (Hard)</li> <li> 3343. Count Number of Balanced Permutations (Hard)</li> <li> 1830. Minimum Number of Operations to Make String Sorted (Hard)</li> <li> 2954. Count the Number of Infection Sequences (Hard)</li> <li> 3395. Subsequences with a Unique Middle Mode I (Hard)</li> <li> 1575. Count All Possible Routes (Hard)</li> <li> 3251. Find the Count of Monotonic Pairs II (Hard)</li> <li> 2539. Count the Number of Good Subsequences (Medium) \ud83d\udc51</li> <li> 634. Find the Derangement of An Array (Medium) \ud83d\udc51</li> <li> 1692. Count Ways to Distribute Candies (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/combinatorial_counting/#62-unique-paths","title":"62. Unique Paths","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, combinatorics</p> </li> <li>Count the number of unique paths to reach the bottom-right corner of a <code>m x n</code> grid.</li> </ul> <p></p> 62. Unique Paths - Python Solution<pre><code># DP - 2D\ndef uniquePaths(m: int, n: int) -&gt; int:\n    if m == 1 or n == 1:\n        return 1\n\n    dp = [[1] * n for _ in range(m)]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]\n\n\nprint(uniquePaths(m=3, n=7))  # 28\n# [[1, 1, 1,  1,  1,  1,  1],\n#  [1, 2, 3,  4,  5,  6,  7],\n#  [1, 3, 6, 10, 15, 21, 28]]\n</code></pre> 62. Unique Paths - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint uniquePaths(int m, int n) {\n    vector dp(m, vector&lt;int&gt;(n, 1));\n\n    for (int i = 1; i &lt; m; i++) {\n        for (int j = 1; j &lt; n; j++) {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n\n    return dp[m - 1][n - 1];\n}\n\nint main() {\n    int m = 3, n = 7;\n    cout &lt;&lt; uniquePaths(m, n) &lt;&lt; endl;  // 28\n    return 0;\n}\n</code></pre>"},{"location":"content/endlesscheng/combinatorial_counting/#357-count-numbers-with-unique-digits","title":"357. Count Numbers with Unique Digits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, backtracking</p> </li> </ul>"},{"location":"content/endlesscheng/combinatorial_counting/#1175-prime-arrangements","title":"1175. Prime Arrangements","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math</p> </li> </ul>"},{"location":"content/endlesscheng/combinatorial_counting/#3179-find-the-n-th-value-after-k-seconds","title":"3179. Find the N-th Value After K Seconds","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, simulation, combinatorics, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/combinatorial_counting/#1359-count-all-valid-pickup-and-delivery-options","title":"1359. Count All Valid Pickup and Delivery Options","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, dynamic programming, combinatorics</p> </li> </ul>"},{"location":"content/endlesscheng/combinatorial_counting/#2400-number-of-ways-to-reach-a-position-after-exactly-k-steps","title":"2400. Number of Ways to Reach a Position After Exactly k Steps","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, combinatorics</p> </li> </ul>"},{"location":"content/endlesscheng/combinatorial_counting/#2514-count-anagrams","title":"2514. Count Anagrams","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, math, string, combinatorics, counting</p> </li> </ul>"},{"location":"content/endlesscheng/combinatorial_counting/#3154-find-number-of-ways-to-reach-the-k-th-stair","title":"3154. Find Number of Ways to Reach the K-th Stair","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, dynamic programming, bit manipulation, memoization, combinatorics</p> </li> </ul>"},{"location":"content/endlesscheng/combinatorial_counting/#1643-kth-smallest-instructions","title":"1643. Kth Smallest Instructions","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, dynamic programming, combinatorics</p> </li> </ul>"},{"location":"content/endlesscheng/combinatorial_counting/#2842-count-k-subsequences-of-a-string-with-maximum-beauty","title":"2842. Count K-Subsequences of a String With Maximum Beauty","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, math, string, greedy, combinatorics</p> </li> </ul>"},{"location":"content/endlesscheng/combinatorial_counting/#1569-number-of-ways-to-reorder-array-to-get-same-bst","title":"1569. Number of Ways to Reorder Array to Get Same BST","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, divide and conquer, dynamic programming, tree, union find, binary search tree, memoization, combinatorics, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/combinatorial_counting/#3405-count-the-number-of-arrays-with-k-matching-adjacent-elements","title":"3405. Count the Number of Arrays with K Matching Adjacent Elements","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, combinatorics</p> </li> </ul>"},{"location":"content/endlesscheng/combinatorial_counting/#1866-number-of-ways-to-rearrange-sticks-with-k-sticks-visible","title":"1866. Number of Ways to Rearrange Sticks With K Sticks Visible","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, dynamic programming, combinatorics</p> </li> </ul>"},{"location":"content/endlesscheng/combinatorial_counting/#1467-probability-of-a-two-boxes-having-the-same-number-of-distinct-balls","title":"1467. Probability of a Two Boxes Having The Same Number of Distinct Balls","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, dynamic programming, backtracking, combinatorics, probability and statistics</p> </li> </ul>"},{"location":"content/endlesscheng/combinatorial_counting/#3272-find-the-count-of-good-integers","title":"3272. Find the Count of Good Integers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, math, combinatorics, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/combinatorial_counting/#3317-find-the-number-of-possible-ways-for-an-event","title":"3317. Find the Number of Possible Ways for an Event","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, dynamic programming, combinatorics</p> </li> </ul>"},{"location":"content/endlesscheng/combinatorial_counting/#1916-count-ways-to-build-rooms-in-an-ant-colony","title":"1916. Count Ways to Build Rooms in an Ant Colony","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, dynamic programming, tree, graph, topological sort, combinatorics</p> </li> </ul>"},{"location":"content/endlesscheng/combinatorial_counting/#3343-count-number-of-balanced-permutations","title":"3343. Count Number of Balanced Permutations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, string, dynamic programming, combinatorics</p> </li> </ul>"},{"location":"content/endlesscheng/combinatorial_counting/#1830-minimum-number-of-operations-to-make-string-sorted","title":"1830. Minimum Number of Operations to Make String Sorted","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, string, combinatorics</p> </li> </ul>"},{"location":"content/endlesscheng/combinatorial_counting/#2954-count-the-number-of-infection-sequences","title":"2954. Count the Number of Infection Sequences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, combinatorics</p> </li> </ul>"},{"location":"content/endlesscheng/combinatorial_counting/#3395-subsequences-with-a-unique-middle-mode-i","title":"3395. Subsequences with a Unique Middle Mode I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, math, combinatorics</p> </li> </ul>"},{"location":"content/endlesscheng/combinatorial_counting/#1575-count-all-possible-routes","title":"1575. Count All Possible Routes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, memoization</p> </li> </ul>"},{"location":"content/endlesscheng/combinatorial_counting/#3251-find-the-count-of-monotonic-pairs-ii","title":"3251. Find the Count of Monotonic Pairs II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, dynamic programming, combinatorics, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/combinatorial_counting/#2539-count-the-number-of-good-subsequences","title":"2539. Count the Number of Good Subsequences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, math, string, combinatorics, counting</p> </li> </ul>"},{"location":"content/endlesscheng/combinatorial_counting/#634-find-the-derangement-of-an-array","title":"634. Find the Derangement of An Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, combinatorics</p> </li> </ul>"},{"location":"content/endlesscheng/combinatorial_counting/#1692-count-ways-to-distribute-candies","title":"1692. Count Ways to Distribute Candies","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/combinatorics_contribution_method/","title":"Combinatorics Contribution Method","text":""},{"location":"content/endlesscheng/combinatorics_contribution_method/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2063. Vowels of All Substrings (Medium)</li> <li> 1588. Sum of All Odd Length Subarrays (Easy)</li> <li> 2681. Power of Heroes (Hard)</li> <li> 891. Sum of Subsequence Widths (Hard)</li> <li> 3428. Maximum and Minimum Sums of at Most Size K Subsequences (Medium)</li> <li> 3426. Manhattan Distances of All Arrangements of Pieces (Hard)</li> <li> 2763. Sum of Imbalance Numbers of All Subarrays (Hard)</li> <li> 979. Distribute Coins in Binary Tree (Medium)</li> <li> 2477. Minimum Fuel Cost to Report to the Capital (Medium)</li> </ul>"},{"location":"content/endlesscheng/combinatorics_contribution_method/#2063-vowels-of-all-substrings","title":"2063. Vowels of All Substrings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, string, dynamic programming, combinatorics</p> </li> </ul>"},{"location":"content/endlesscheng/combinatorics_contribution_method/#1588-sum-of-all-odd-length-subarrays","title":"1588. Sum of All Odd Length Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, math, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/combinatorics_contribution_method/#2681-power-of-heroes","title":"2681. Power of Heroes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, dynamic programming, sorting, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/combinatorics_contribution_method/#891-sum-of-subsequence-widths","title":"891. Sum of Subsequence Widths","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/combinatorics_contribution_method/#3428-maximum-and-minimum-sums-of-at-most-size-k-subsequences","title":"3428. Maximum and Minimum Sums of at Most Size K Subsequences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, dynamic programming, sorting, combinatorics</p> </li> </ul>"},{"location":"content/endlesscheng/combinatorics_contribution_method/#3426-manhattan-distances-of-all-arrangements-of-pieces","title":"3426. Manhattan Distances of All Arrangements of Pieces","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, combinatorics</p> </li> </ul>"},{"location":"content/endlesscheng/combinatorics_contribution_method/#2763-sum-of-imbalance-numbers-of-all-subarrays","title":"2763. Sum of Imbalance Numbers of All Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/combinatorics_contribution_method/#979-distribute-coins-in-binary-tree","title":"979. Distribute Coins in Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/combinatorics_contribution_method/#2477-minimum-fuel-cost-to-report-to-the-capital","title":"2477. Minimum Fuel Cost to Report to the Capital","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, graph</p> </li> </ul>"},{"location":"content/endlesscheng/construction_problems/","title":"Construction Problems","text":""},{"location":"content/endlesscheng/construction_problems/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 942. DI String Match (Easy)</li> <li> 1968. Array With Elements Not Equal to Average of Neighbors (Medium)</li> <li> 1253. Reconstruct a 2-Row Binary Matrix (Medium)</li> <li> 2182. Construct String With Repeat Limit (Medium)</li> <li> 969. Pancake Sorting (Medium)</li> <li> 1605. Find Valid Matrix Given Row and Column Sums (Medium)</li> <li> 2375. Construct Smallest Number From DI String (Medium)</li> <li> 324. Wiggle Sort II (Medium)</li> <li> 667. Beautiful Arrangement II (Medium)</li> <li> 2122. Recover the Original Array (Hard)</li> <li> 932. Beautiful Array (Medium)</li> <li> 3311. Construct 2D Grid Matching Graph Layout (Hard)</li> <li> 2573. Find the String with LCP (Hard)</li> <li> 1982. Find Array Given Subset Sums (Hard)</li> <li> 280. Wiggle Sort (Medium) \ud83d\udc51</li> <li> 484. Find Permutation (Medium) \ud83d\udc51</li> <li> 1980. Find Unique Binary String (Medium)</li> </ul>"},{"location":"content/endlesscheng/construction_problems/#942-di-string-match","title":"942. DI String Match","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers, string, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/construction_problems/#1968-array-with-elements-not-equal-to-average-of-neighbors","title":"1968. Array With Elements Not Equal to Average of Neighbors","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/construction_problems/#1253-reconstruct-a-2-row-binary-matrix","title":"1253. Reconstruct a 2-Row Binary Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/construction_problems/#2182-construct-string-with-repeat-limit","title":"2182. Construct String With Repeat Limit","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, greedy, heap priority queue, counting</p> </li> </ul>"},{"location":"content/endlesscheng/construction_problems/#969-pancake-sorting","title":"969. Pancake Sorting","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/construction_problems/#1605-find-valid-matrix-given-row-and-column-sums","title":"1605. Find Valid Matrix Given Row and Column Sums","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/construction_problems/#2375-construct-smallest-number-from-di-string","title":"2375. Construct Smallest Number From DI String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, backtracking, stack, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/construction_problems/#324-wiggle-sort-ii","title":"324. Wiggle Sort II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, divide and conquer, greedy, sorting, quickselect</p> </li> </ul>"},{"location":"content/endlesscheng/construction_problems/#667-beautiful-arrangement-ii","title":"667. Beautiful Arrangement II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math</p> </li> </ul>"},{"location":"content/endlesscheng/construction_problems/#2122-recover-the-original-array","title":"2122. Recover the Original Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, two pointers, sorting, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/construction_problems/#932-beautiful-array","title":"932. Beautiful Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, divide and conquer</p> </li> </ul>"},{"location":"content/endlesscheng/construction_problems/#3311-construct-2d-grid-matching-graph-layout","title":"3311. Construct 2D Grid Matching Graph Layout","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, graph, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/construction_problems/#2573-find-the-string-with-lcp","title":"2573. Find the String with LCP","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, dynamic programming, greedy, union find, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/construction_problems/#1982-find-array-given-subset-sums","title":"1982. Find Array Given Subset Sums","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, divide and conquer</p> </li> </ul>"},{"location":"content/endlesscheng/construction_problems/#280-wiggle-sort","title":"280. Wiggle Sort","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting 280. Wiggle Sort - Python Solution<pre><code>from typing import List\n\n\ndef wiggleSort(nums: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    n = len(nums)\n    for i in range(n - 1):\n        if i % 2 == 0:\n            if nums[i] &gt; nums[i + 1]:\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]\n        else:\n            if nums[i] &lt; nums[i + 1]:\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]\n\n\nnum = [3, 5, 2, 1, 6, 4]\nwiggleSort(num)\nprint(num)  # [3, 5, 1, 6, 2, 4]\n</code></pre></p> </li> </ul> 280. Wiggle Sort - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvoid wiggleSort(vector&lt;int&gt;&amp; nums) {\n    int n = nums.size();\n\n    for (int i = 0; i &lt; n - 1; i++) {\n        if (i % 2 == 0) {\n            if (nums[i] &gt; nums[i + 1]) swap(nums[i], nums[i + 1]);\n        } else {\n            if (nums[i] &lt; nums[i + 1]) swap(nums[i], nums[i + 1]);\n        }\n    }\n}\n\nint main() {\n    vector&lt;int&gt; nums = {3, 5, 2, 1, 6, 4};\n    wiggleSort(nums);\n    // 3 5 1 6 2 4\n    for (size_t i = 0; i &lt; nums.size(); i++) {\n        cout &lt;&lt; nums[i] &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/endlesscheng/construction_problems/#484-find-permutation","title":"484. Find Permutation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, stack, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/construction_problems/#1980-find-unique-binary-string","title":"1980. Find Unique Binary String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, backtracking</p> </li> </ul>"},{"location":"content/endlesscheng/contribution_method/","title":"Contribution Method","text":""},{"location":"content/endlesscheng/contribution_method/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 907. Sum of Subarray Minimums (Medium)</li> <li> 2104. Sum of Subarray Ranges (Medium)</li> <li> 1856. Maximum Subarray Min-Product (Medium)</li> <li> 2818. Apply Operations to Maximize Score (Hard)</li> <li> 2281. Sum of Total Strength of Wizards (Hard)</li> <li> 3359. Find Sorted Submatrices With Maximum Element at Most K (Hard) \ud83d\udc51</li> <li> 2334. Subarray With Elements Greater Than Varying Threshold (Hard)</li> </ul>"},{"location":"content/endlesscheng/contribution_method/#907-sum-of-subarray-minimums","title":"907. Sum of Subarray Minimums","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, stack, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/contribution_method/#2104-sum-of-subarray-ranges","title":"2104. Sum of Subarray Ranges","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/contribution_method/#1856-maximum-subarray-min-product","title":"1856. Maximum Subarray Min-Product","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, monotonic stack, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/contribution_method/#2818-apply-operations-to-maximize-score","title":"2818. Apply Operations to Maximize Score","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, stack, greedy, sorting, monotonic stack, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/contribution_method/#2281-sum-of-total-strength-of-wizards","title":"2281. Sum of Total Strength of Wizards","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, stack, monotonic stack, prefix sum 2281. Sum of Total Strength of Wizards - Python Solution<pre><code>from itertools import accumulate\nfrom typing import List\n\n\n# Monotonic Stack\ndef totalStrength(strength: List[int]) -&gt; int:\n    n = len(strength)\n    left = [-1 for _ in range(n)]\n    right = [n for _ in range(n)]\n    stack = []\n\n    for i, v in enumerate(strength):\n        while stack and strength[stack[-1]] &gt;= v:\n            right[stack.pop()] = i\n        if stack:\n            left[i] = stack[-1]\n        stack.append(i)\n\n    prefix_sum = list(accumulate(accumulate(strength, initial=0), initial=0))\n\n    ans = 0\n    for i, v in enumerate(strength):\n        l, r = left[i] + 1, right[i] - 1\n        tot = (i - l + 1) * (prefix_sum[r + 2] - prefix_sum[i + 1]) - (\n            r - i + 1\n        ) * (prefix_sum[i + 1] - prefix_sum[l])\n        ans += v * tot\n\n    return ans % (10**9 + 7)\n\n\nstrength = [1, 3, 1, 2]\nprint(totalStrength(strength))  # 44\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/contribution_method/#3359-find-sorted-submatrices-with-maximum-element-at-most-k","title":"3359. Find Sorted Submatrices With Maximum Element at Most K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, stack, matrix, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/contribution_method/#2334-subarray-with-elements-greater-than-varying-threshold","title":"2334. Subarray With Elements Greater Than Varying Threshold","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, stack, union find, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/convex_hull/","title":"Convex Hull","text":""},{"location":"content/endlesscheng/convex_hull/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 587. Erect the Fence (Hard)</li> </ul>"},{"location":"content/endlesscheng/convex_hull/#587-erect-the-fence","title":"587. Erect the Fence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, geometry</p> </li> </ul>"},{"location":"content/endlesscheng/coprime/","title":"Coprime","text":""},{"location":"content/endlesscheng/coprime/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2748. Number of Beautiful Pairs (Easy)</li> <li> 1447. Simplified Fractions (Medium)</li> <li> 1766. Tree of Coprimes (Hard)</li> <li> 3411. Maximum Subarray With Equal Products (Easy)</li> </ul>"},{"location":"content/endlesscheng/coprime/#2748-number-of-beautiful-pairs","title":"2748. Number of Beautiful Pairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, math, counting, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/coprime/#1447-simplified-fractions","title":"1447. Simplified Fractions","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, string, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/coprime/#1766-tree-of-coprimes","title":"1766. Tree of Coprimes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, tree, depth first search, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/coprime/#3411-maximum-subarray-with-equal-products","title":"3411. Maximum Subarray With Equal Products","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, math, sliding window, enumeration, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/deque/","title":"Deque","text":""},{"location":"content/endlesscheng/deque/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2810. Faulty Keyboard (Easy)</li> </ul>"},{"location":"content/endlesscheng/deque/#2810-faulty-keyboard","title":"2810. Faulty Keyboard","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, simulation</p> </li> </ul>"},{"location":"content/endlesscheng/dfs_basics/","title":"DFS Basics","text":""},{"location":"content/endlesscheng/dfs_basics/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 547. Number of Provinces (Medium)</li> <li> 1971. Find if Path Exists in Graph (Easy)</li> <li> 797. All Paths From Source to Target (Medium)</li> <li> 841. Keys and Rooms (Medium)</li> <li> 2316. Count Unreachable Pairs of Nodes in an Undirected Graph (Medium)</li> <li> 1319. Number of Operations to Make Network Connected (Medium)</li> <li> 2492. Minimum Score of a Path Between Two Cities (Medium)</li> <li> 3387. Maximize Amount After Two Days of Conversions (Medium)</li> <li> 3310. Remove Methods From Project (Medium)</li> <li> 2685. Count the Number of Complete Components (Medium)</li> <li> 2192. All Ancestors of a Node in a Directed Acyclic Graph (Medium)</li> <li> 924. Minimize Malware Spread (Hard)</li> <li> 2101. Detonate the Maximum Bombs (Medium)</li> <li> 721. Accounts Merge (Medium)</li> <li> 207. Course Schedule (Medium)</li> <li> 802. Find Eventual Safe States (Medium)</li> <li> 928. Minimize Malware Spread II (Hard)</li> <li> 2092. Find All People With Secret (Hard)</li> <li> 3108. Minimum Cost Walk in Weighted Graph (Hard)</li> <li> 261. Graph Valid Tree (Medium) \ud83d\udc51</li> <li> 323. Number of Connected Components in an Undirected Graph (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/dfs_basics/#547-number-of-provinces","title":"547. Number of Provinces","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> <li>Return the number of provinces.</li> </ul>"},{"location":"content/endlesscheng/dfs_basics/#union-find","title":"Union Find","text":"<ul> <li>Find by Path Compression</li> <li>Union by Rank</li> <li>Time Complexity: O(log(n))</li> <li>Space Complexity: O(n)</li> </ul> template/union_find.py 547. Number of Provinces - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\nfrom template import UnionFind\n\n\n# DFS (Adjacency Matrix)\ndef findCircleNumDFSMatrix(isConnected: List[List[int]]) -&gt; int:\n    n = len(isConnected)\n    visited = set()\n\n    def dfs(node):\n        if node in visited:\n            return\n        visited.add(node)\n        for neighbor in range(n):\n            if node != neighbor and isConnected[node][neighbor] == 1:\n                dfs(neighbor)\n\n    res = 0\n    for i in range(n):\n        if i not in visited:\n            dfs(i)\n            res += 1\n\n    return res\n\n\n# DFS (Adjacency List)\ndef findCircleNumDFSList(isConnected: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    n = len(isConnected)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if isConnected[i][j] == 1:\n                graph[i].append(j)\n                graph[j].append(i)\n\n    visited = set()\n\n    def dfs(node):\n        if node in visited:\n            return\n        visited.add(node)\n        for neighbor in graph[node]:\n            dfs(neighbor)\n\n    res = 0\n    for i in range(n):\n        if i not in visited:\n            dfs(i)\n            res += 1\n\n    return res\n\n\n# BFS (Adjacency Matrix)\ndef findCircleNumBFS(isConnected: List[List[int]]) -&gt; int:\n    n = len(isConnected)\n    visited = set()\n    q = deque()\n    res = 0\n\n    for i in range(n):\n        if i not in visited:\n            res += 1\n\n            q.append(i)\n            while q:\n                node = q.popleft()\n                visited.add(node)\n                for node, val in enumerate(isConnected[node]):\n                    if val == 1 and node not in visited:\n                        q.append(node)\n                        visited.add(node)\n\n    return res\n\n\n# Union Find\ndef findCircleNumUF(isConnected: List[List[int]]) -&gt; int:\n    n = len(isConnected)\n    uf = UnionFind(n)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if isConnected[i][j] == 1:\n                uf.union(i, j)\n\n    res = len(set(uf.find(i) for i in range(n)))\n\n    return res\n\n\n# Union Find\ndef findCircleNum(isConnected: List[List[int]]) -&gt; int:\n    n = len(isConnected)\n    par = {i: i for i in range(n)}\n    rank = {i: 0 for i in range(n)}\n\n    def find(n):\n        p = par[n]\n        while par[p] != p:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 == p2:\n            return None\n\n        if rank[p1] &gt; rank[p2]:\n            par[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n        else:\n            par[p2] = p1\n            rank[p1] += 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if isConnected[i][j] == 1:\n                union(i, j)\n\n    res = len(set(find(i) for i in range(n)))\n\n    return res\n\n\nisConnected = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]\nprint(findCircleNumDFSList(isConnected))  # 2\nprint(findCircleNumDFSMatrix(isConnected))  # 2\nprint(findCircleNumBFS(isConnected))  # 2\nprint(findCircleNum(isConnected))  # 2\nprint(findCircleNumUF(isConnected))  # 2\n</code></pre>"},{"location":"content/endlesscheng/dfs_basics/#1971-find-if-path-exists-in-graph","title":"1971. Find if Path Exists in Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph 1971. Find if Path Exists in Graph - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# DFS (Adjacency List)\ndef validPathDFS(\n    n: int, edges: List[List[int]], source: int, destination: int\n) -&gt; bool:\n    if not edges and source != destination:\n        return False\n\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = set()\n\n    def dfs(node):\n        if node == destination:\n            return True\n\n        visited.add(node)\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n\n        return False\n\n    return dfs(source)\n\n\nn = 3\nedges = [[0, 1], [1, 2], [2, 0]]\nsource = 0\ndestination = 2\nprint(validPathDFS(n, edges, source, destination))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dfs_basics/#797-all-paths-from-source-to-target","title":"797. All Paths From Source to Target","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: backtracking, depth first search, breadth first search, graph 797. All Paths From Source to Target - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS (Backtracking)\ndef allPathsSourceTargetDFS(graph: List[List[int]]) -&gt; List[List[int]]:\n    res = []\n    n = len(graph)\n\n    def dfs(node, path):\n        if node == n - 1:\n            res.append(path.copy())\n            return None\n\n        for nei in graph[node]:\n            path.append(nei)\n            dfs(nei, path)\n            path.pop()\n\n    dfs(0, [0])\n\n    return res\n\n\n# BFS\ndef allPathsSourceTargetBFS(graph: List[List[int]]) -&gt; List[List[int]]:\n    n = len(graph)\n    res = []\n    q = deque([(0, [0])])\n\n    while q:\n        node, path = q.popleft()\n\n        if node == n - 1:\n            res.append(path)\n\n        for nei in graph[node]:\n            q.append((nei, path + [nei]))\n\n    return res\n\n\ngraph = [[1, 2], [3], [3], []]\nprint(allPathsSourceTargetDFS(graph))  # [[0, 1, 3], [0, 2, 3]]\nprint(allPathsSourceTargetBFS(graph))  # [[0, 1, 3], [0, 2, 3]]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dfs_basics/#841-keys-and-rooms","title":"841. Keys and Rooms","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph 841. Keys and Rooms - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef canVisitAllRoomsDFS(rooms: List[List[int]]) -&gt; bool:\n    n = len(rooms)\n    visited = [False for _ in range(n)]\n\n    def dfs(room):\n        visited[room] = True\n        for key in rooms[room]:\n            if not visited[key]:\n                dfs(key)\n\n    dfs(0)\n\n    return all(visited)\n\n\n# BFS\ndef canVisitAllRoomsBFS(rooms):\n    n = len(rooms)\n    visited = [False for _ in range(n)]\n    q = deque([0])\n    visited[0] = True\n\n    while q:\n        room = q.popleft()\n        for key in rooms[room]:\n            if not visited[key]:\n                visited[key] = True\n                q.append(key)\n\n    return all(visited)\n\n\nrooms = [[1, 3], [3, 0, 1], [2], [0]]\nprint(canVisitAllRoomsDFS(rooms))  # False\nprint(canVisitAllRoomsBFS(rooms))  # False\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dfs_basics/#2316-count-unreachable-pairs-of-nodes-in-an-undirected-graph","title":"2316. Count Unreachable Pairs of Nodes in an Undirected Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph 2316. Count Unreachable Pairs of Nodes in an Undirected Graph - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# DFS (Adjacency List)\ndef countPairsList1(n: int, edges: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = set()\n\n    def dfs(node):\n        visited.add(node)\n        size = 1\n\n        for nei in graph[node]:\n            if nei not in visited:\n                size += dfs(nei)\n\n        return size\n\n    res = 0\n    for i in range(n):\n        if i not in visited:\n            size = dfs(i)\n            res += size * (n - size)\n\n    return res // 2\n\n\n# DFS(Adjacency List)\ndef countPairsList2(n: int, edges: List[List[int]]) -&gt; int:\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = [False for _ in range(n)]\n\n    def dfs(node):\n        visited[node] = True\n        size = 1\n        for nei in graph[node]:\n            if not visited[nei]:\n                size += dfs(nei)\n        return size\n\n    res, total = 0, 0\n    for i in range(n):\n        if not visited[i]:\n            size = dfs(i)\n            res += size * total\n            total += size\n\n    return res\n\n\nn = 7\nedges = [[0, 2], [0, 5], [2, 4], [1, 6], [5, 4]]\nprint(countPairsList1(n, edges))  # 14\nprint(countPairsList2(n, edges))  # 14\n</code></pre></p> </li> </ul> 2316. Count Unreachable Pairs of Nodes in an Undirected Graph - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;unordered_set&gt;\n#include &lt;functional&gt;\nusing namespace std;\n\nclass Solution\n{\npublic:\n    long long countPairs(int n, vector&lt;vector&lt;int&gt;&gt; &amp;edges)\n    {\n        unordered_map&lt;int, unordered_set&lt;int&gt;&gt; graph;\n        for (const auto &amp;edge : edges)\n        {\n            graph[edge[0]].insert(edge[1]);\n            graph[edge[1]].insert(edge[0]);\n        }\n\n        unordered_set&lt;int&gt; visited;\n\n        function&lt;int(int)&gt; dfs = [&amp;](int node) -&gt; int\n        {\n            if (visited.count(node))\n            {\n                return 0;\n            }\n            visited.insert(node);\n            int count = 1;\n            for (const auto &amp;neighbor : graph[node])\n            {\n                if (!visited.count(neighbor))\n                {\n                    count += dfs(neighbor);\n                }\n            }\n            return count;\n        };\n\n        long long res = 0;\n        long long total = n;\n\n        for (int i = 0; i &lt; n; ++i)\n        {\n            if (!visited.count(i))\n            {\n                int count = dfs(i);\n                res += count * (total - count);\n            }\n        }\n        return res / 2;\n    }\n};\n\nint main()\n{\n    Solution s;\n    vector&lt;vector&lt;int&gt;&gt; edges = {{0, 2}, {0, 5}, {2, 4}, {1, 6}, {5, 4}};\n    cout &lt;&lt; s.countPairs(7, edges) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/endlesscheng/dfs_basics/#1319-number-of-operations-to-make-network-connected","title":"1319. Number of Operations to Make Network Connected","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> <li>Return the minimum number of operations needed to make all computers connected.</li> </ul> <p></p> 1319. Number of Operations to Make Network Connected - Python Solution<pre><code>\"\"\"\nEdge case: If the number of connections is less than n - 1, it is impossible to connect all the computers.\n\"\"\"\n\nfrom collections import defaultdict, deque\nfrom typing import List\n\n\n# DFS\ndef makeConnectedDFS(n: int, connections: List[List[int]]) -&gt; int:\n    if len(connections) &lt; n - 1:\n        return -1\n\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = set()\n    component_count = 0\n\n    def dfs(node):\n        for i in graph[node]:\n            if i not in visited:\n                visited.add(i)\n                dfs(i)\n\n    for i in range(n):\n        if i not in visited:\n            visited.add(i)\n            dfs(i)\n            component_count += 1\n\n    return component_count - 1\n\n\n# BFS\ndef makeConnectedBFS(n: int, connections: List[List[int]]) -&gt; int:\n    if len(connections) &lt; n - 1:\n        return -1\n\n    visited = set()\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def bfs(node):\n        q = deque([node])\n        while q:\n            cur = q.popleft()\n            for nxt in graph[cur]:\n                if nxt not in visited:\n                    q.append(nxt)\n                    visited.add(nxt)\n\n    component_count = 0\n    for i in range(n):\n        if i not in visited:\n            visited.add(i)\n            bfs(i)\n            component_count += 1\n\n    return component_count - 1\n\n\nn = 4\nconnections = [[0, 1], [0, 2], [1, 2]]\nprint(makeConnectedDFS(n, connections))  # 1\nprint(makeConnectedBFS(n, connections))  # 1\n</code></pre>"},{"location":"content/endlesscheng/dfs_basics/#2492-minimum-score-of-a-path-between-two-cities","title":"2492. Minimum Score of a Path Between Two Cities","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph 2492. Minimum Score of a Path Between Two Cities - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# DFS\ndef minScoreDFS(n: int, roads: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n\n    res = float(\"inf\")\n    visited = set([1])\n\n    def dfs(node):\n        nonlocal res\n        for nxt, dist in graph[node]:\n            res = min(res, dist)\n            if nxt not in visited:\n                visited.add(nxt)\n                dfs(nxt)\n\n    dfs(1)\n\n    return res\n\n\nn = 4\nroads = [[1, 2, 9], [2, 3, 6], [2, 4, 5], [1, 4, 7]]\nprint(minScoreDFS(n, roads))  # 5\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dfs_basics/#3387-maximize-amount-after-two-days-of-conversions","title":"3387. Maximize Amount After Two Days of Conversions","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, depth first search, breadth first search, graph 3387. Maximize Amount After Two Days of Conversions - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# DFS\ndef maxAmount(\n    initialCurrency: str,\n    pairs1: List[List[str]],\n    rates1: List[float],\n    pairs2: List[List[str]],\n    rates2: List[float],\n) -&gt; float:\n\n    def cal_amount(pairs, rates, initialCurrency):\n        graph = defaultdict(list)\n\n        for (u, v), r in zip(pairs, rates):\n            graph[u].append((v, r))\n            graph[v].append((u, 1.0 / r))\n\n        amount = {}\n\n        def dfs(x, cur):\n            amount[x] = cur\n            for to, rate in graph[x]:\n                if to not in amount:\n                    dfs(to, cur * rate)\n\n        dfs(initialCurrency, 1.0)\n\n        return amount\n\n    day1 = cal_amount(pairs1, rates1, initialCurrency)\n    day2 = cal_amount(pairs2, rates2, initialCurrency)\n\n    return max(day1.get(x, 0.0) / a2 for x, a2 in day2.items())\n\n\nif __name__ == \"__main__\":\n    initialCurrency = \"EUR\"\n    pairs1 = [[\"EUR\", \"USD\"], [\"USD\", \"JPY\"]]\n    rates1 = [2.0, 3.0]\n    pairs2 = [[\"JPY\", \"USD\"], [\"USD\", \"CHF\"], [\"CHF\", \"EUR\"]]\n    rates2 = [4.0, 5.0, 6.0]\n\n    assert maxAmount(initialCurrency, pairs1, rates1, pairs2, rates2) == 720.0\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dfs_basics/#3310-remove-methods-from-project","title":"3310. Remove Methods From Project","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph</p> </li> </ul>"},{"location":"content/endlesscheng/dfs_basics/#2685-count-the-number-of-complete-components","title":"2685. Count the Number of Complete Components","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> </ul>"},{"location":"content/endlesscheng/dfs_basics/#2192-all-ancestors-of-a-node-in-a-directed-acyclic-graph","title":"2192. All Ancestors of a Node in a Directed Acyclic Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort</p> </li> </ul>"},{"location":"content/endlesscheng/dfs_basics/#924-minimize-malware-spread","title":"924. Minimize Malware Spread","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, depth first search, breadth first search, union find, graph 924. Minimize Malware Spread - Python Solution<pre><code>from typing import List\n\n\n# Coloring\ndef minMalwareSpread(graph: List[List[int]], initial: List[int]) -&gt; int:\n    n = len(graph)\n    initial = set(initial)\n\n    def dfs(x):\n        visited.add(x)\n        mark[x] = 1\n        if x in initial:\n            v.append(x)\n        for nxt in range(n):\n            if graph[x][nxt] and nxt != x and not mark[nxt]:\n                dfs(nxt)\n\n    ans = min(initial)\n    mx = 0\n    mark = [0] * n\n    for i in range(n):\n        if not mark[i]:\n            visited = set()\n            v = []\n            dfs(i)\n            if len(v) == 1 and (\n                len(visited) &gt; mx or len(visited) == mx and v[0] &lt; ans\n            ):\n                ans, mx = v[0], len(visited)\n    return ans\n\n\ngraph = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]\ninitial = [0, 1]\nprint(minMalwareSpread(graph, initial))  # 0\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dfs_basics/#2101-detonate-the-maximum-bombs","title":"2101. Detonate the Maximum Bombs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, depth first search, breadth first search, graph, geometry</p> </li> </ul>"},{"location":"content/endlesscheng/dfs_basics/#721-accounts-merge","title":"721. Accounts Merge","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, depth first search, breadth first search, union find, sorting 721. Accounts Merge - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef accountsMerge(accounts: List[List[str]]) -&gt; List[List[str]]:\n    parent = defaultdict(str)\n    rank = defaultdict(int)\n    email_to_name = defaultdict(str)\n    merged_accounts = defaultdict(list)\n\n    def find(n):\n        p = parent[n]\n        while p != parent[p]:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    for account in accounts:\n        name = account[0]\n        first_email = account[1]\n\n        for email in account[1:]:\n            if email not in parent:\n                parent[email] = email\n                rank[email] = 1\n            email_to_name[email] = name\n            union(first_email, email)\n\n    for email in parent:\n        root_email = find(email)\n        merged_accounts[root_email].append(email)\n\n    result = []\n    for root_email, emails in merged_accounts.items():\n        result.append([email_to_name[root_email]] + sorted(emails))\n\n    return result\n\n\naccounts = [\n    [\"John\", \"johnsmith@mail.com\", \"john_newyork@mail.com\"],\n    [\"John\", \"johnsmith@mail.com\", \"john00@mail.com\"],\n    [\"Mary\", \"mary@mail.com\"],\n    [\"John\", \"johnnybravo@mail.com\"],\n]\nprint(accountsMerge(accounts))\n# [['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],\n# ['Mary', 'mary@mail.com'],\n# ['John', 'johnnybravo@mail.com']]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dfs_basics/#207-course-schedule","title":"207. Course Schedule","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort</p> </li> <li>Return true if it is possible to finish all courses, otherwise return false.</li> <li>Dependency relationships imply the topological sort algorithm.</li> <li>Cycle detection</li> <li>Topological Sort</li> <li>DAG (Directed Acyclic Graph)</li> <li>Time complexity: O(V+E)</li> <li>Space complexity: O(V+E)</li> <li>Prerequisites: Indegree (Look at the problem 1557. Minimum Number of Vertices to Reach All Nodes)<ul> <li>Indegree: Number of incoming edges to a vertex</li> </ul> </li> <li>Applications: task scheduling, course scheduling, build systems, dependency resolution, compiler optimization, etc.</li> </ul> <p></p> <p></p> <p>Course to prerequisites mapping</p> <pre><code>flowchart LR\n    0((0)) --&gt; 1((1))\n    0((0)) --&gt; 2((2))\n    1((1)) --&gt; 3((3))\n    3((3)) --&gt; 4((4))\n    1((1)) --&gt; 4((4))</code></pre> <p>Prerequisites to course mapping</p> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    2((2)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))\n    4((4)) --&gt; 3((3))\n    4((4)) --&gt; 1((1))</code></pre> course 0 0 1 1 3 prerequisite 1 2 3 4 4 index 0 1 2 3 4 in-degree 0 0 0 0 0 <p>Initialize</p> <ul> <li>graph</li> </ul> prerequisite 1 2 3 4 course <code>[0]</code> <code>[0]</code> <code>[1]</code> <code>[1, 3]</code> <ul> <li>in-degree</li> </ul> 0 1 2 3 4 in-degree 2 2 0 1 0 <ul> <li>queue: <code>[2, 4]</code></li> <li>pop <code>2</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))\n    4((4)) --&gt; 3((3))\n    4((4)) --&gt; 1((1))</code></pre> 0 1 2 3 4 in-degree 1 2 0 1 0 <ul> <li>queue: <code>[4]</code></li> <li>pop <code>4</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))</code></pre> 0 1 2 3 4 in-degree 1 1 0 0 0 <ul> <li>queue: <code>[3]</code></li> <li>pop <code>3</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))</code></pre> 0 1 2 3 4 in-degree 1 0 0 0 0 <ul> <li>queue: <code>[1]</code></li> <li>pop <code>1</code> from the queue</li> </ul> <pre><code>flowchart LR\n    0((0))</code></pre> 0 1 2 3 4 in-degree 0 0 0 0 0 <ul> <li>queue: <code>[0]</code></li> <li>pop <code>0</code> from the queue</li> <li>All courses are taken. Return <code>True</code>.</li> </ul> 207. Course Schedule - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS (Kahn's Algorithm)\ndef canFinishBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    count = 0\n\n    while q:\n        crs = q.popleft()\n        count += 1\n\n        for nxt in graph[crs]:\n            indegree[nxt] -= 1\n\n            if indegree[nxt] == 0:\n                q.append(nxt)\n\n    return count == numCourses\n\n\n# DFS + Set\ndef canFinishDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for crs, pre in prerequisites:\n        graph[crs].append(pre)\n\n    visiting = set()\n\n    def dfs(crs):\n        if crs in visiting:  # cycle detected\n            return False\n        if graph[crs] == []:\n            return True\n\n        visiting.add(crs)\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        visiting.remove(crs)\n        graph[crs] = []\n\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\n# DFS + List\ndef canFinishDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for pre, crs in prerequisites:\n        graph[crs].append(pre)\n\n    # 0: init, 1: visiting, 2: visited\n    status = [0] * numCourses\n\n    def dfs(crs):\n        if status[crs] == 1:  # cycle detected\n            return False\n        if status[crs] == 2:\n            return True\n\n        status[crs] = 1\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        status[crs] = 2\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(canFinishBFS(5, prerequisites))  # True\nprint(canFinishDFS1(5, prerequisites))  # True\nprint(canFinishDFS2(5, prerequisites))  # True\n</code></pre> 207. Course Schedule - C++ Solution<pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    // BFS\n    bool canFinishBFS(int numCourses, vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        vector&lt;int&gt; indegree(numCourses, 0);\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n            indegree[pre[0]]++;\n        }\n\n        queue&lt;int&gt; q;\n        for (int i = 0; i &lt; numCourses; i++) {\n            if (indegree[i] == 0) {\n                q.push(i);\n            }\n        }\n\n        int cnt = 0;\n        while (!q.empty()) {\n            int cur = q.front();\n            q.pop();\n            cnt++;\n\n            for (int nxt : graph[cur]) {\n                indegree[nxt]--;\n                if (indegree[nxt] == 0) {\n                    q.push(nxt);\n                }\n            }\n        }\n        return cnt == numCourses;\n    }\n\n    // DFS\n    bool canFinishDFS(int numCourses, vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n        }\n        // 0: not visited, 1: visiting, 2: visited\n        vector&lt;int&gt; state(numCourses, 0);\n\n        function&lt;bool(int)&gt; dfs = [&amp;](int pre) -&gt; bool {\n            state[pre] = 1;  // visiting\n            for (int crs : graph[pre]) {\n                if (state[crs] == 1 || (state[crs] == 0 &amp;&amp; dfs(crs))) {\n                    return true;\n                }\n            }\n            state[pre] = 2;  // visited\n            return false;\n        };\n\n        for (int i = 0; i &lt; numCourses; i++) {\n            if (state[i] == 0 &amp;&amp; dfs(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution sol;\n    vector&lt;vector&lt;int&gt;&gt; prerequisites = {{1, 0}, {2, 1}, {3, 2}, {4, 3},\n                                         {5, 4}, {6, 5}, {7, 6}, {8, 7},\n                                         {9, 8}, {10, 9}};\n    int numCourses = 11;\n    cout &lt;&lt; sol.canFinishBFS(numCourses, prerequisites) &lt;&lt; endl;\n    cout &lt;&lt; sol.canFinishDFS(numCourses, prerequisites) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/endlesscheng/dfs_basics/#802-find-eventual-safe-states","title":"802. Find Eventual Safe States","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort 802. Find Eventual Safe States - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# Topological Sort\ndef eventualSafeNodesTS(graph: List[List[int]]) -&gt; List[int]:\n    n = len(graph)\n    reverse_graph = defaultdict(list)\n    indegree = [0 for _ in range(n)]\n    safe = [False for _ in range(n)]\n\n    for u in range(n):\n        for v in graph[u]:\n            reverse_graph[v].append(u)\n        indegree[u] = len(graph[u])\n\n    q = deque([i for i in range(n) if indegree[i] == 0])\n\n    while q:\n        node = q.popleft()\n        safe[node] = True\n\n        for neighbor in reverse_graph[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n\n    return [i for i in range(n) if safe[i]]\n\n\n# DFS\ndef eventualSafeNodesDFS(graph: List[List[int]]) -&gt; List[int]:\n    n = len(graph)\n    state = [0 for _ in range(n)]  # 0: unvisited, 1: visiting, 2: visited\n\n    def dfs(node):\n        if state[node] &gt; 0:\n            return state[node] == 2\n        state[node] = 1\n        for neighbor in graph[node]:\n            if state[neighbor] == 1 or not dfs(neighbor):\n                return False\n        state[node] = 2\n        return True\n\n    return [i for i in range(n) if dfs(i)]\n\n\ngraph = [[1, 2], [2, 3], [5], [0], [5], [], []]\nprint(eventualSafeNodesTS(graph))  # [2, 4, 5, 6]\nprint(eventualSafeNodesDFS(graph))  # [2, 4, 5, 6]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dfs_basics/#928-minimize-malware-spread-ii","title":"928. Minimize Malware Spread II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, depth first search, breadth first search, union find, graph</p> </li> </ul>"},{"location":"content/endlesscheng/dfs_basics/#2092-find-all-people-with-secret","title":"2092. Find All People With Secret","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/dfs_basics/#3108-minimum-cost-walk-in-weighted-graph","title":"3108. Minimum Cost Walk in Weighted Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, bit manipulation, union find, graph</p> </li> </ul>"},{"location":"content/endlesscheng/dfs_basics/#261-graph-valid-tree","title":"261. Graph Valid Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph 261. Graph Valid Tree - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Graph\ndef validTree(n: int, edges: List[List[int]]) -&gt; bool:\n    if n == 0:\n        return False\n    if len(edges) != n - 1:\n        return False\n\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = set()\n\n    def dfs(node, parent):\n        if node in visited:\n            return False\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor != parent and not dfs(neighbor, node):\n                return False\n        return True\n\n    return dfs(0, -1) and len(visited) == n\n\n\nprint(validTree(5, [[0, 1], [0, 2], [0, 3], [1, 4]]))  # True\nprint(validTree(5, [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]))  # False\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dfs_basics/#323-number-of-connected-components-in-an-undirected-graph","title":"323. Number of Connected Components in an Undirected Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph 323. Number of Connected Components in an Undirected Graph - Python Solution<pre><code>from typing import List\n\n\n# Union Find\ndef countComponents(n: int, edges: List[List[int]]) -&gt; int:\n    uf = UnionFind(n)\n    count = n\n\n    for u, v in edges:\n        count -= uf.union(u, v)\n\n    return count\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(n)}\n        self.rank = {i: 1 for i in range(n)}\n\n    def find(self, n):\n        p = self.par[n]\n        while self.par[p] != p:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return 0\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.par[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.par[p1] = p2\n        else:\n            self.par[p2] = p1\n            self.rank[p1] += 1\n\n        return 1\n\n\nprint(countComponents(5, [[0, 1], [1, 2], [3, 4]]))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/distance_sum/","title":"Distance Sum","text":""},{"location":"content/endlesscheng/distance_sum/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1685. Sum of Absolute Differences in a Sorted Array (Medium)</li> <li> 2615. Sum of Distances (Medium)</li> <li> 2602. Minimum Operations to Make All Array Elements Equal (Medium)</li> <li> 2968. Apply Operations to Maximize Frequency Score (Hard)</li> <li> 1703. Minimum Adjacent Swaps for K Consecutive Ones (Hard)</li> <li> 3086. Minimum Moves to Pick K Ones (Hard)</li> <li> 3422. Minimum Operations to Make Subarray Elements Equal (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/distance_sum/#1685-sum-of-absolute-differences-in-a-sorted-array","title":"1685. Sum of Absolute Differences in a Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, prefix sum 1685. Sum of Absolute Differences in a Sorted Array - Python Solution<pre><code>from typing import List\n\n\n# Prefix Sum\ndef getSumAbsoluteDifferences(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    totalSum = sum(nums)\n    prefixSum = 0\n    res = [0 for _ in range(n)]\n\n    for i in range(n):\n        leftSum = prefixSum\n        rightSum = totalSum - prefixSum - nums[i]\n\n        leftCount = i\n        rightCount = n - i - 1\n\n        res[i] = (nums[i] * leftCount - leftSum) + (\n            rightSum - nums[i] * rightCount\n        )\n        prefixSum += nums[i]\n\n    return res\n\n\nnums = [1, 4, 6, 8, 10]\nprint(getSumAbsoluteDifferences(nums))  # [24, 15, 13, 15, 21]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/distance_sum/#2615-sum-of-distances","title":"2615. Sum of Distances","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/distance_sum/#2602-minimum-operations-to-make-all-array-elements-equal","title":"2602. Minimum Operations to Make All Array Elements Equal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sorting, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/distance_sum/#2968-apply-operations-to-maximize-frequency-score","title":"2968. Apply Operations to Maximize Frequency Score","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, sliding window, sorting, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/distance_sum/#1703-minimum-adjacent-swaps-for-k-consecutive-ones","title":"1703. Minimum Adjacent Swaps for K Consecutive Ones","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sliding window, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/distance_sum/#3086-minimum-moves-to-pick-k-ones","title":"3086. Minimum Moves to Pick K Ones","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sliding window, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/distance_sum/#3422-minimum-operations-to-make-subarray-elements-equal","title":"3422. Minimum Operations to Make Subarray Elements Equal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, sliding window, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/double_sequence_pairing/","title":"Double Sequence Pairing","text":""},{"location":"content/endlesscheng/double_sequence_pairing/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2037. Minimum Number of Moves to Seat Everyone (Easy)</li> <li> 455. Assign Cookies (Easy)</li> <li> 2410. Maximum Matching of Players With Trainers (Medium)</li> <li> 1433. Check If a String Can Break Another String (Medium)</li> <li> 870. Advantage Shuffle (Medium)</li> <li> 826. Most Profit Assigning Work (Medium)</li> <li> 2449. Minimum Number of Operations to Make Arrays Similar (Hard)</li> <li> 1889. Minimum Space Wasted From Packaging (Hard)</li> <li> 2561. Rearranging Fruits (Hard)</li> <li> 2323. Find Minimum Time to Finish All Jobs II (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/double_sequence_pairing/#2037-minimum-number-of-moves-to-seat-everyone","title":"2037. Minimum Number of Moves to Seat Everyone","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, greedy, sorting, counting sort</p> </li> <li>Return the minimum number of moves needed to seat everyone.</li> </ul> 2037. Minimum Number of Moves to Seat Everyone - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef minMovesToSeat(seats: List[int], students: List[int]) -&gt; int:\n    seats.sort()\n    students.sort()\n    moves = 0\n\n    for i, j in zip(seats, students):\n        moves += abs(i - j)\n\n    return moves\n\n\nprint(minMovesToSeat([3, 1, 5], [2, 7, 4]))  # 4\n</code></pre>"},{"location":"content/endlesscheng/double_sequence_pairing/#455-assign-cookies","title":"455. Assign Cookies","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers, greedy, sorting</p> </li> <li>Return the maximum number of your content children that can be satisfied.</li> </ul> 455. Assign Cookies - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef findContentChildren(g: List[int], s: List[int]) -&gt; int:\n    g.sort()\n    s.sort()\n    i, j = 0, 0\n\n    while i &lt; len(g) and j &lt; len(s):\n        if g[i] &lt;= s[j]:\n            i += 1\n        j += 1\n\n    return i\n\n\n# |-------------|-------------|--------------|\n# |   Approach  |    Time     |    Space     |\n# |-------------|-------------|--------------|\n# |   Greedy    | O(N * logN) |    O(1)      |\n# |-------------|-------------|--------------|\n\n\ng = [1, 2, 3]\ns = [1, 1]\nprint(findContentChildren(g, s))  # 1\n</code></pre>"},{"location":"content/endlesscheng/double_sequence_pairing/#2410-maximum-matching-of-players-with-trainers","title":"2410. Maximum Matching of Players With Trainers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/double_sequence_pairing/#1433-check-if-a-string-can-break-another-string","title":"1433. Check If a String Can Break Another String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/double_sequence_pairing/#870-advantage-shuffle","title":"870. Advantage Shuffle","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/double_sequence_pairing/#826-most-profit-assigning-work","title":"826. Most Profit Assigning Work","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/double_sequence_pairing/#2449-minimum-number-of-operations-to-make-arrays-similar","title":"2449. Minimum Number of Operations to Make Arrays Similar","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/double_sequence_pairing/#1889-minimum-space-wasted-from-packaging","title":"1889. Minimum Space Wasted From Packaging","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, sorting, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/double_sequence_pairing/#2561-rearranging-fruits","title":"2561. Rearranging Fruits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, greedy 2561. Rearranging Fruits - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\ndef minCost(basket1: List[int], basket2: List[int]) -&gt; int:\n    cnt = defaultdict(int)\n    for x, y in zip(basket1, basket2):\n        cnt[x] += 1\n        cnt[y] -= 1\n\n    a, b = [], []\n    for x, c in cnt.items():\n        if c % 2:\n            return -1\n\n        if c &gt; 0:\n            a.extend([x] * (c // 2))\n        else:\n            b.extend([x] * (-c // 2))\n\n    a.sort()\n    b.sort(reverse=True)\n    mn = min(cnt)\n\n    return sum(min(x, y, mn * 2) for x, y in zip(a, b))\n\n\nif __name__ == \"__main__\":\n    basket1 = [4, 2, 2, 2]\n    basket2 = [1, 4, 1, 2]\n    assert minCost(basket1, basket2) == 1\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/double_sequence_pairing/#2323-find-minimum-time-to-finish-all-jobs-ii","title":"2323. Find Minimum Time to Finish All Jobs II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/dp_0-1_knapsack/","title":"DP 0-1 Knapsack","text":""},{"location":"content/endlesscheng/dp_0-1_knapsack/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2915. Length of the Longest Subsequence That Sums to Target (Medium)</li> <li> 416. Partition Equal Subset Sum (Medium)</li> <li> 494. Target Sum (Medium)</li> <li> 2787. Ways to Express an Integer as Sum of Powers (Medium)</li> <li> 3180. Maximum Total Reward Using Operations I (Medium)</li> <li> 474. Ones and Zeroes (Medium)</li> <li> 1049. Last Stone Weight II (Medium)</li> <li> 1774. Closest Dessert Cost (Medium)</li> <li> 879. Profitable Schemes (Hard)</li> <li> 3082. Find the Sum of the Power of All Subsequences (Hard)</li> <li> 956. Tallest Billboard (Hard)</li> <li> 2518. Number of Great Partitions (Hard)</li> <li> 2742. Painting the Walls (Hard)</li> <li> 3287. Find the Maximum Sequence Value of Array (Hard)</li> <li> 2291. Maximum Profit From Trading Stocks (Medium) \ud83d\udc51</li> <li> 2431. Maximize Total Tastiness of Purchased Fruits (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/dp_0-1_knapsack/#2915-length-of-the-longest-subsequence-that-sums-to-target","title":"2915. Length of the Longest Subsequence That Sums to Target","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_0-1_knapsack/#416-partition-equal-subset-sum","title":"416. Partition Equal Subset Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming 416. Partition Equal Subset Sum - Python Solution<pre><code>from functools import cache\nfrom typing import List\n\nfrom template import knapsack01\n\n\n# Memoization\ndef canPartitionMemoization(nums: List[int]) -&gt; bool:\n    total = sum(nums)\n    n = len(nums)\n\n    if total % 2 == 1 or n &lt;= 1:\n        return False\n\n    @cache\n    def dfs(i, j):\n        if i &lt; 0:\n            return j == 0\n        return j &gt;= nums[i] and dfs(i - 1, j - nums[i]) or dfs(i - 1, j)\n\n    return dfs(n - 1, total // 2)\n\n\n# DP - Knapsack 01\ndef canPartitionTemplate(nums: List[int]) -&gt; bool:\n    total = sum(nums)\n\n    if total % 2 == 1 or len(nums) &lt; 2:\n        return False\n\n    target = total // 2\n\n    return knapsack01(nums, nums, target) == target\n\n\n# DP - Knapsack 01\ndef canPartition(nums: List[int]) -&gt; bool:\n    total = sum(nums)\n\n    if total % 2 == 1 or len(nums) &lt; 2:\n        return False\n\n    target = total // 2\n\n    dp = [0 for _ in range(target + 1)]\n\n    for i in range(len(nums)):\n        for j in range(target, nums[i] - 1, -1):\n            dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])\n\n    return dp[target] == target\n\n\nif __name__ == \"__main__\":\n    nums = [1, 5, 11, 5]\n    print(canPartitionTemplate(nums))  # True\n    print(canPartition(nums))  # True\n    print(canPartitionMemoization(nums))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_0-1_knapsack/#494-target-sum","title":"494. Target Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, backtracking 494. Target Sum - Python Solution<pre><code>from typing import List\n\n\ndef findTargetSumWays(nums: List[int], target: int) -&gt; int:\n\n    totalSum = sum(nums)\n\n    if abs(target) &gt; totalSum:\n        return 0\n    if (target + totalSum) % 2 == 1:\n        return 0\n\n    targetSum = (target + totalSum) // 2\n    dp = [0] * (targetSum + 1)\n    dp[0] = 1\n\n    for i in range(len(nums)):\n        for j in range(targetSum, nums[i] - 1, -1):\n            dp[j] += dp[j - nums[i]]\n\n    return dp[targetSum]\n\n\nnums = [1, 1, 1, 1, 1]\ntarget = 3\nprint(findTargetSumWays(nums, target))  # 5\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_0-1_knapsack/#2787-ways-to-express-an-integer-as-sum-of-powers","title":"2787. Ways to Express an Integer as Sum of Powers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_0-1_knapsack/#3180-maximum-total-reward-using-operations-i","title":"3180. Maximum Total Reward Using Operations I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_0-1_knapsack/#474-ones-and-zeroes","title":"474. Ones and Zeroes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, dynamic programming 474. Ones and Zeroes - Python Solution<pre><code>from typing import List\n\n\ndef findMaxForm(strs: List[str], m: int, n: int) -&gt; int:\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for s in strs:\n        zerosNum = s.count(\"0\")\n        onesNum = len(s) - zerosNum\n\n        for i in range(m, zerosNum - 1, -1):\n            for j in range(n, onesNum - 1, -1):\n                dp[i][j] = max(dp[i][j], dp[i - zerosNum][j - onesNum] + 1)\n\n    return dp[m][n]\n\n\nstrs = [\"10\", \"0001\", \"111001\", \"1\", \"0\"]\nm = 5\nn = 3\nprint(findMaxForm(strs, m, n))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_0-1_knapsack/#1049-last-stone-weight-ii","title":"1049. Last Stone Weight II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming 1049. Last Stone Weight II - Python Solution<pre><code>from typing import List\n\n\ndef lastStoneWeightII(stones: List[int]) -&gt; int:\n    target = sum(stones) // 2\n\n    dp = [0 for _ in range(target + 1)]\n\n    for i in range(len(stones)):\n        for j in range(target, stones[i] - 1, -1):\n            dp[j] = max(dp[j], dp[j - stones[i]] + stones[i])\n\n    result = (sum(stones) - dp[target]) - dp[target]\n\n    return result\n\n\nstones = [2, 7, 4, 1, 8, 1]\nprint(lastStoneWeightII(stones))  # 1\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_0-1_knapsack/#1774-closest-dessert-cost","title":"1774. Closest Dessert Cost","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, backtracking</p> </li> </ul>"},{"location":"content/endlesscheng/dp_0-1_knapsack/#879-profitable-schemes","title":"879. Profitable Schemes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_0-1_knapsack/#3082-find-the-sum-of-the-power-of-all-subsequences","title":"3082. Find the Sum of the Power of All Subsequences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_0-1_knapsack/#956-tallest-billboard","title":"956. Tallest Billboard","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_0-1_knapsack/#2518-number-of-great-partitions","title":"2518. Number of Great Partitions","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_0-1_knapsack/#2742-painting-the-walls","title":"2742. Painting the Walls","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_0-1_knapsack/#3287-find-the-maximum-sequence-value-of-array","title":"3287. Find the Maximum Sequence Value of Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/dp_0-1_knapsack/#2291-maximum-profit-from-trading-stocks","title":"2291. Maximum Profit From Trading Stocks","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_0-1_knapsack/#2431-maximize-total-tastiness-of-purchased-fruits","title":"2431. Maximize Total Tastiness of Purchased Fruits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_1d/","title":"DP 1D","text":""},{"location":"content/endlesscheng/dp_1d/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2944. Minimum Number of Coins for Fruits (Medium)</li> <li> 2140. Solving Questions With Brainpower (Medium)</li> <li> 983. Minimum Cost For Tickets (Medium)</li> <li> 2901. Longest Unequal Adjacent Groups Subsequence II (Medium)</li> <li> 3144. Minimum Substring Partition of Equal Character Frequency (Medium)</li> <li> 871. Minimum Number of Refueling Stops (Hard)</li> <li> 2896. Apply Operations to Make Two Strings Equal (Medium)</li> <li> 2167. Minimum Time to Remove All Cars Containing Illegal Goods (Hard)</li> <li> 2188. Minimum Time to Finish the Race (Hard)</li> <li> 3389. Minimum Operations to Make Character Frequencies Equal (Hard)</li> <li> 3205. Maximum Array Hopping Score I (Medium) \ud83d\udc51</li> <li> 1259. Handshakes That Don't Cross (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/dp_1d/#2944-minimum-number-of-coins-for-fruits","title":"2944. Minimum Number of Coins for Fruits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, queue, heap priority queue, monotonic queue</p> </li> </ul>"},{"location":"content/endlesscheng/dp_1d/#2140-solving-questions-with-brainpower","title":"2140. Solving Questions With Brainpower","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming 2140. Solving Questions With Brainpower - Python Solution<pre><code>from functools import cache\nfrom typing import List\n\n\n# Memoization\ndef mostPoints(questions: List[List[int]]) -&gt; int:\n    @cache\n    def dfs(i: int) -&gt; int:\n        if i &gt;= len(questions):\n            return 0\n        return max(dfs(i + 1), dfs(i + questions[i][1] + 1) + questions[i][0])\n\n    return dfs(0)\n\n\nif __name__ == \"__main__\":\n    questions = [[3, 2], [4, 3], [4, 4], [2, 5]]\n    print(mostPoints(questions))  # 5\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_1d/#983-minimum-cost-for-tickets","title":"983. Minimum Cost For Tickets","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming 983. Minimum Cost For Tickets - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef mincostTickets(days: List[int], costs: List[int]) -&gt; int:\n    last = days[-1]\n    dayset = set(days)\n    dp = [0 for _ in range(last + 1)]\n\n    for i in range(1, last + 1):\n        if i not in dayset:\n            dp[i] = dp[i - 1]\n        else:\n            dp[i] = min(\n                dp[i - 1] + costs[0],\n                dp[max(0, i - 7)] + costs[1],\n                dp[max(0, i - 30)] + costs[2],\n            )\n\n    return dp[last]\n\n\ndays = [1, 4, 6, 7, 8, 20]\ncosts = [2, 7, 15]\nprint(mincostTickets(days, costs))  # 11\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_1d/#2901-longest-unequal-adjacent-groups-subsequence-ii","title":"2901. Longest Unequal Adjacent Groups Subsequence II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_1d/#3144-minimum-substring-partition-of-equal-character-frequency","title":"3144. Minimum Substring Partition of Equal Character Frequency","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, dynamic programming, counting</p> </li> </ul>"},{"location":"content/endlesscheng/dp_1d/#871-minimum-number-of-refueling-stops","title":"871. Minimum Number of Refueling Stops","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, greedy, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/dp_1d/#2896-apply-operations-to-make-two-strings-equal","title":"2896. Apply Operations to Make Two Strings Equal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_1d/#2167-minimum-time-to-remove-all-cars-containing-illegal-goods","title":"2167. Minimum Time to Remove All Cars Containing Illegal Goods","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_1d/#2188-minimum-time-to-finish-the-race","title":"2188. Minimum Time to Finish the Race","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_1d/#3389-minimum-operations-to-make-character-frequencies-equal","title":"3389. Minimum Operations to Make Character Frequencies Equal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, dynamic programming, counting, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/dp_1d/#3205-maximum-array-hopping-score-i","title":"3205. Maximum Array Hopping Score I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, stack, greedy, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/dp_1d/#1259-handshakes-that-dont-cross","title":"1259. Handshakes That Don't Cross","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_climbing_stairs/","title":"DP Climbing Stairs","text":""},{"location":"content/endlesscheng/dp_climbing_stairs/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 70. Climbing Stairs (Easy)</li> <li> 746. Min Cost Climbing Stairs (Easy)</li> <li> 377. Combination Sum IV (Medium)</li> <li> 2466. Count Ways To Build Good Strings (Medium)</li> <li> 2266. Count Number of Texts (Medium)</li> <li> 2533. Number of Good Binary Strings (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/dp_climbing_stairs/#70-climbing-stairs","title":"70. Climbing Stairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, dynamic programming, memoization</p> </li> <li>Return the number of distinct ways to reach the top of the stairs.</li> <li><code>dp[n]</code> stores the number of distinct ways to reach the <code>n-th</code> stair.</li> <li>Formula: <code>dp[n] = dp[n - 1] + dp[n - 2]</code>.</li> <li>Initialize <code>dp[0] = 0</code>, <code>dp[1] = 1</code>, and <code>dp[2] = 2</code>.</li> </ul> 70. Climbing Stairs - Python Solution<pre><code>from functools import cache\n\n\n# DP\ndef climbStairsDP(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    dp = [i for i in range(n + 1)]\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\n# DP (Optimized)\ndef climbStairsDPOptimized(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    first, second = 1, 2\n\n    for _ in range(3, n + 1):\n        first, second = second, first + second\n\n    return second\n\n\n# Recursion\ndef climbStairsRecursion(n: int) -&gt; int:\n    @cache\n    def dfs(i: int) -&gt; int:\n        if i &lt;= 1:\n            return 1\n        return dfs(i - 1) + dfs(i - 2)\n\n    return dfs(n)\n\n\n# Greedy\ndef climbStairsGreedy(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    p1, p2 = 1, 2\n\n    for _ in range(3, n + 1):\n        p1, p2 = p2, p1 + p2\n\n    return p2\n\n\nif __name__ == \"__main__\":\n    assert climbStairsDP(10) == 89\n    assert climbStairsDPOptimized(10) == 89\n    assert climbStairsRecursion(10) == 89\n    assert climbStairsGreedy(10) == 89\n</code></pre> 70. Climbing Stairs - C++ Solution<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint climbStairs(int n) {\n    if (n &lt;= 2) return n;\n    int f1 = 1, f2 = 2;\n    int res;\n\n    int i = 3;\n    while (i &lt;= n) {\n        res = f1 + f2;\n        f1 = f2;\n        f2 = res;\n        ++i;\n    }\n    return res;\n}\n\nint main() {\n    cout &lt;&lt; climbStairs(2) &lt;&lt; endl;  // 2\n    cout &lt;&lt; climbStairs(3) &lt;&lt; endl;  // 3\n    cout &lt;&lt; climbStairs(6) &lt;&lt; endl;  // 13\n    return 0;\n}\n</code></pre>"},{"location":"content/endlesscheng/dp_climbing_stairs/#746-min-cost-climbing-stairs","title":"746. Min Cost Climbing Stairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li> <p>Return the minimum cost to reach the top of the stairs.</p> </li> <li> <p><code>dp[n]</code> stores the minimum cost to reach the <code>n-th</code> stair.</p> </li> <li>Formula: <code>dp[n] = cost[n] + min(dp[n - 1], dp[n - 2])</code>.</li> <li>Initialize <code>dp[0] = cost[0]</code> and <code>dp[1] = cost[1]</code>.</li> <li> <p>Return <code>min(dp[-1], dp[-2])</code>.</p> </li> <li> <p>Example: <code>cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</code></p> </li> </ul> n <code>cost[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n]</code> 0 1 - - 1 1 100 - 1 100 2 1 1 100 2 3 1 100 2 3 4 1 2 3 3 5 100 3 3 103 6 1 3 103 4 7 1 103 4 5 8 100 4 5 104 9 1 5 104 6 746. Min Cost Climbing Stairs - Python Solution<pre><code>from typing import List\n\n\ndef minCostClimbingStairs(cost: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(cost))]\n\n    dp[0], dp[1] = cost[0], cost[1]\n\n    for i in range(2, len(cost)):\n        dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]\n    print(dp)\n    return min(dp[-1], dp[-2])\n\n\ncost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]\nprint(minCostClimbingStairs(cost))  # 6\n</code></pre>"},{"location":"content/endlesscheng/dp_climbing_stairs/#377-combination-sum-iv","title":"377. Combination Sum IV","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming 377. Combination Sum IV - Python Solution<pre><code>from typing import List\n\n\ndef combinationSum4(nums: List[int], target: int) -&gt; int:\n    dp = [0 for _ in range(target + 1)]\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for j in range(len(nums)):\n            if i - nums[j] &gt;= 0:\n                dp[i] += dp[i - nums[j]]\n\n        return dp[target]\n\n\nnums = [1, 2, 3]\ntarget = 4\nprint(combinationSum4(nums, target))  # 7\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_climbing_stairs/#2466-count-ways-to-build-good-strings","title":"2466. Count Ways To Build Good Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_climbing_stairs/#2266-count-number-of-texts","title":"2266. Count Number of Texts","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, math, string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_climbing_stairs/#2533-number-of-good-binary-strings","title":"2533. Number of Good Binary Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_complete_knapsack/","title":"DP Complete Knapsack","text":""},{"location":"content/endlesscheng/dp_complete_knapsack/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 322. Coin Change (Medium)</li> <li> 518. Coin Change II (Medium)</li> <li> 279. Perfect Squares (Medium)</li> <li> 1449. Form Largest Integer With Digits That Add up to Target (Hard)</li> <li> 3183. The Number of Ways to Make the Sum (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/dp_complete_knapsack/#322-coin-change","title":"322. Coin Change","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, breadth first search 322. Coin Change - Python Solution<pre><code>from typing import List\n\n\ndef coinChange(coins: List[int], amount: int) -&gt; int:\n    dp = [float(\"inf\") for _ in range(amount + 1)]\n\n    dp[0] = 0\n\n    for i in range(1, amount + 1):\n        for c in coins:\n            if i - c &gt;= 0:\n                dp[i] = min(dp[i], 1 + dp[i - c])\n\n    return dp[amount] if dp[amount] != float(\"inf\") else -1\n\n\ncoins = [1, 2, 5]\namount = 11\nprint(coinChange(coins, amount))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_complete_knapsack/#518-coin-change-ii","title":"518. Coin Change II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming 518. Coin Change II - Python Solution<pre><code>from typing import List\n\n\ndef change(amount: int, coins: List[int]) -&gt; int:\n    dp = [0 for _ in range(amount + 1)]\n    dp[0] = 1\n\n    for i in range(len(coins)):\n        for j in range(coins[i], amount + 1):\n            dp[j] += dp[j - coins[i]]\n\n    return dp[-1]\n\n\namount = 5\ncoins = [1, 2, 5]\nprint(change(amount, coins))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_complete_knapsack/#279-perfect-squares","title":"279. Perfect Squares","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, breadth first search 279. Perfect Squares - Python Solution<pre><code>import math\n\n\n# DP - Knapsack Unbounded\ndef numSquares(n: int) -&gt; int:\n    dp = [float(\"inf\") for _ in range(n + 1)]\n    dp[0] = 0\n\n    for i in range(1, n + 1):\n        for j in range(1, int(math.sqrt(n)) + 1):\n            dp[i] = min(dp[i], dp[i - j**2] + 1)\n\n    return dp[n]\n\n\nn = 12\nprint(numSquares(n))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_complete_knapsack/#1449-form-largest-integer-with-digits-that-add-up-to-target","title":"1449. Form Largest Integer With Digits That Add up to Target","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_complete_knapsack/#3183-the-number-of-ways-to-make-the-sum","title":"3183. The Number of Ways to Make the Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_constrained_number_of_partitions/","title":"DP Constrained Number of Partitions","text":""},{"location":"content/endlesscheng/dp_constrained_number_of_partitions/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 410. Split Array Largest Sum (Hard)</li> <li> 813. Largest Sum of Averages (Medium)</li> <li> 1278. Palindrome Partitioning III (Hard)</li> <li> 1745. Palindrome Partitioning IV (Hard)</li> <li> 1335. Minimum Difficulty of a Job Schedule (Hard)</li> <li> 1473. Paint House III (Hard)</li> <li> 2209. Minimum White Tiles After Covering With Carpets (Hard)</li> <li> 1478. Allocate Mailboxes (Hard)</li> <li> 1959. Minimum Total Space Wasted With K Resizing Operations (Medium)</li> <li> 2478. Number of Beautiful Partitions (Hard)</li> <li> 3077. Maximum Strength of K Disjoint Subarrays (Hard)</li> <li> 2911. Minimum Changes to Make K Semi-palindromes (Hard)</li> <li> 3117. Minimum Sum of Values by Dividing Array (Hard)</li> </ul>"},{"location":"content/endlesscheng/dp_constrained_number_of_partitions/#410-split-array-largest-sum","title":"410. Split Array Largest Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, dynamic programming, greedy, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/dp_constrained_number_of_partitions/#813-largest-sum-of-averages","title":"813. Largest Sum of Averages","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/dp_constrained_number_of_partitions/#1278-palindrome-partitioning-iii","title":"1278. Palindrome Partitioning III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming 1278. Palindrome Partitioning III - Python Solution<pre><code># DP\ndef palindromePartition(s: str, k: int) -&gt; int:\n    n = len(s)\n    min_change = [[0] * n for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        for j in range(i + 1, n):\n            min_change[i][j] = min_change[i + 1][j - 1] + (\n                1 if s[i] != s[j] else 0\n            )\n\n    dp = min_change[0]\n    for i in range(1, k):\n        for right in range(n - k + i, i - 1, -1):\n            dp[right] = min(\n                dp[left - 1] + min_change[left][right]\n                for left in range(i, right + 1)\n            )\n\n    return dp[-1]\n\n\ns = \"aabbc\"\nk = 3\nprint(palindromePartition(s, k))  # 0\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_constrained_number_of_partitions/#1745-palindrome-partitioning-iv","title":"1745. Palindrome Partitioning IV","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming 1745. Palindrome Partitioning IV - Python Solution<pre><code># DP\ndef checkPartitioning(s: str) -&gt; bool:\n    def palidrome_partition(s, k):\n        n = len(s)\n        min_change = [[0] * n for _ in range(n)]\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 1, n):\n                min_change[i][j] = min_change[i + 1][j - 1] + (\n                    1 if s[i] != s[j] else 0\n                )\n\n        dp = min_change[0]\n\n        for i in range(1, k):\n            for right in range(n - k + i, i - 1, -1):\n                dp[right] = min(\n                    dp[left - 1] + min_change[left][right]\n                    for left in range(i, right + 1)\n                )\n\n        return dp[-1]\n\n    return palidrome_partition(s, 3) == 0\n\n\ns = \"abcbdd\"\nprint(checkPartitioning(s))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_constrained_number_of_partitions/#1335-minimum-difficulty-of-a-job-schedule","title":"1335. Minimum Difficulty of a Job Schedule","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_constrained_number_of_partitions/#1473-paint-house-iii","title":"1473. Paint House III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_constrained_number_of_partitions/#2209-minimum-white-tiles-after-covering-with-carpets","title":"2209. Minimum White Tiles After Covering With Carpets","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/dp_constrained_number_of_partitions/#1478-allocate-mailboxes","title":"1478. Allocate Mailboxes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, dynamic programming, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/dp_constrained_number_of_partitions/#1959-minimum-total-space-wasted-with-k-resizing-operations","title":"1959. Minimum Total Space Wasted With K Resizing Operations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_constrained_number_of_partitions/#2478-number-of-beautiful-partitions","title":"2478. Number of Beautiful Partitions","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_constrained_number_of_partitions/#3077-maximum-strength-of-k-disjoint-subarrays","title":"3077. Maximum Strength of K Disjoint Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/dp_constrained_number_of_partitions/#2911-minimum-changes-to-make-k-semi-palindromes","title":"2911. Minimum Changes to Make K Semi-palindromes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: two pointers, string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_constrained_number_of_partitions/#3117-minimum-sum-of-values-by-dividing-array","title":"3117. Minimum Sum of Values by Dividing Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, dynamic programming, bit manipulation, segment tree, queue</p> </li> </ul>"},{"location":"content/endlesscheng/dp_digit/","title":"DP Digit","text":""},{"location":"content/endlesscheng/dp_digit/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2719. Count of Integers (Hard)</li> <li> 1742. Maximum Number of Balls in a Box (Easy)</li> <li> 2843.   Count Symmetric Integers (Easy)</li> <li> 788. Rotated Digits (Medium)</li> <li> 902. Numbers At Most N Given Digit Set (Hard)</li> <li> 600. Non-negative Integers without Consecutive Ones (Hard)</li> <li> 2376. Count Special Integers (Hard)</li> <li> 1012. Numbers With Repeated Digits (Hard)</li> <li> 357. Count Numbers with Unique Digits (Medium)</li> <li> 2827. Number of Beautiful Integers in the Range (Hard)</li> <li> 2999. Count the Number of Powerful Integers (Hard)</li> <li> 2801. Count Stepping Numbers in Range (Hard)</li> <li> 3352. Count K-Reducible Numbers Less Than N (Hard)</li> <li> 1397. Find All Good Strings (Hard)</li> <li> 3348. Smallest Divisible Digit Product II (Hard)</li> <li> 1215. Stepping Numbers (Medium) \ud83d\udc51</li> <li> 1067. Digit Count in Range (Hard) \ud83d\udc51</li> <li> 3032. Count Numbers With Unique Digits II (Easy) \ud83d\udc51</li> <li> 233. Number of Digit One (Hard)</li> <li> 3007. Maximum Number That Sum of the Prices Is Less Than or Equal to K (Medium)</li> </ul>"},{"location":"content/endlesscheng/dp_digit/#2719-count-of-integers","title":"2719. Count of Integers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_digit/#1742-maximum-number-of-balls-in-a-box","title":"1742. Maximum Number of Balls in a Box","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, math, counting</p> </li> </ul>"},{"location":"content/endlesscheng/dp_digit/#2843-count-symmetric-integers","title":"2843.   Count Symmetric Integers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/dp_digit/#788-rotated-digits","title":"788. Rotated Digits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_digit/#902-numbers-at-most-n-given-digit-set","title":"902. Numbers At Most N Given Digit Set","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, string, binary search, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_digit/#600-non-negative-integers-without-consecutive-ones","title":"600. Non-negative Integers without Consecutive Ones","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_digit/#2376-count-special-integers","title":"2376. Count Special Integers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_digit/#1012-numbers-with-repeated-digits","title":"1012. Numbers With Repeated Digits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_digit/#357-count-numbers-with-unique-digits","title":"357. Count Numbers with Unique Digits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, backtracking</p> </li> </ul>"},{"location":"content/endlesscheng/dp_digit/#2827-number-of-beautiful-integers-in-the-range","title":"2827. Number of Beautiful Integers in the Range","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_digit/#2999-count-the-number-of-powerful-integers","title":"2999. Count the Number of Powerful Integers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_digit/#2801-count-stepping-numbers-in-range","title":"2801. Count Stepping Numbers in Range","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_digit/#3352-count-k-reducible-numbers-less-than-n","title":"3352. Count K-Reducible Numbers Less Than N","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, string, dynamic programming, combinatorics</p> </li> </ul>"},{"location":"content/endlesscheng/dp_digit/#1397-find-all-good-strings","title":"1397. Find All Good Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming, string matching</p> </li> </ul>"},{"location":"content/endlesscheng/dp_digit/#3348-smallest-divisible-digit-product-ii","title":"3348. Smallest Divisible Digit Product II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, string, backtracking, greedy, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/dp_digit/#1215-stepping-numbers","title":"1215. Stepping Numbers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, backtracking, breadth first search</p> </li> </ul>"},{"location":"content/endlesscheng/dp_digit/#1067-digit-count-in-range","title":"1067. Digit Count in Range","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_digit/#3032-count-numbers-with-unique-digits-ii","title":"3032. Count Numbers With Unique Digits II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, math, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_digit/#233-number-of-digit-one","title":"233. Number of Digit One","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, dynamic programming, recursion</p> </li> </ul>"},{"location":"content/endlesscheng/dp_digit/#3007-maximum-number-that-sum-of-the-prices-is-less-than-or-equal-to-k","title":"3007. Maximum Number That Sum of the Prices Is Less Than or Equal to K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: binary search, dynamic programming, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/dp_fenwick_tree_segment_tree/","title":"DP Fenwick Tree Segment Tree","text":""},{"location":"content/endlesscheng/dp_fenwick_tree_segment_tree/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1626. Best Team With No Conflicts (Medium)</li> <li> 2407. Longest Increasing Subsequence II (Hard)</li> <li> 2770. Maximum Number of Jumps to Reach the Last Index (Medium)</li> <li> 2926. Maximum Balanced Subsequence Sum (Hard)</li> <li> 2916. Subarrays Distinct Element Sum of Squares II (Hard)</li> <li> 3410. Maximize Subarray Sum After Removing All Occurrences of One Element (Hard)</li> </ul>"},{"location":"content/endlesscheng/dp_fenwick_tree_segment_tree/#1626-best-team-with-no-conflicts","title":"1626. Best Team With No Conflicts","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, sorting 1626. Best Team With No Conflicts - Python Solution<pre><code>from typing import List\n\n\n# DP - LIS\ndef bestTeamScore(scores: List[int], ages: List[int]) -&gt; int:\n    n = len(scores)\n    pairs = sorted(zip(scores, ages))  # sort\n    dp = [0 for _ in range(n)]\n\n    # LIS\n    for i in range(n):\n        for j in range(i):\n            if pairs[i][1] &gt;= pairs[j][1]:\n                dp[i] = max(dp[i], dp[j])\n        dp[i] += pairs[i][0]\n\n    return max(dp)\n\n\nif __name__ == \"__main__\":\n    assert bestTeamScore([1, 3, 5, 10, 15], [1, 2, 3, 4, 5]) == 34\n    assert bestTeamScore([4, 5, 6, 5], [2, 1, 2, 1]) == 16\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_fenwick_tree_segment_tree/#2407-longest-increasing-subsequence-ii","title":"2407. Longest Increasing Subsequence II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, divide and conquer, dynamic programming, binary indexed tree, segment tree, queue, monotonic queue</p> </li> </ul>"},{"location":"content/endlesscheng/dp_fenwick_tree_segment_tree/#2770-maximum-number-of-jumps-to-reach-the-last-index","title":"2770. Maximum Number of Jumps to Reach the Last Index","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_fenwick_tree_segment_tree/#2926-maximum-balanced-subsequence-sum","title":"2926. Maximum Balanced Subsequence Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, dynamic programming, binary indexed tree, segment tree</p> </li> </ul>"},{"location":"content/endlesscheng/dp_fenwick_tree_segment_tree/#2916-subarrays-distinct-element-sum-of-squares-ii","title":"2916. Subarrays Distinct Element Sum of Squares II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, binary indexed tree, segment tree</p> </li> </ul>"},{"location":"content/endlesscheng/dp_fenwick_tree_segment_tree/#3410-maximize-subarray-sum-after-removing-all-occurrences-of-one-element","title":"3410. Maximize Subarray Sum After Removing All Occurrences of One Element","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, segment tree</p> </li> </ul>"},{"location":"content/endlesscheng/dp_game_theory/","title":"DP Game Theory","text":""},{"location":"content/endlesscheng/dp_game_theory/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1025. Divisor Game (Easy)</li> <li> 877. Stone Game (Medium)</li> <li> 486. Predict the Winner (Medium)</li> <li> 1510. Stone Game IV (Hard)</li> <li> 1690. Stone Game VII (Medium)</li> <li> 1406. Stone Game III (Hard)</li> <li> 1140. Stone Game II (Medium)</li> <li> 1563. Stone Game V (Hard)</li> <li> 464. Can I Win (Medium)</li> <li> 1872. Stone Game VIII (Hard)</li> <li> 913. Cat and Mouse (Hard)</li> <li> 1728. Cat and Mouse II (Hard)</li> <li> 294. Flip Game II (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/dp_game_theory/#1025-divisor-game","title":"1025. Divisor Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, dynamic programming, brainteaser, game theory</p> </li> <li>Return <code>True</code> if Alice wins the game, assuming both players play optimally.</li> <li><code>dp[n]</code> stores the result of the game when the number is <code>n</code>.</li> <li>Initialize <code>dp[1] = False</code>.</li> </ul> 1025. Divisor Game - Python Solution<pre><code># DP\ndef divisorGameDP(n: int) -&gt; bool:\n    if n &lt;= 1:\n        return False\n\n    dp = [False for _ in range(n + 1)]\n\n    for i in range(2, n + 1):\n        for j in range(1, i):\n            if i % j == 0 and not dp[i - j]:\n                dp[i] = True\n                break\n\n    return dp[n]\n\n\n# Math\ndef divisorGameDPMath(n: int) -&gt; bool:\n    return n % 2 == 0\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |  DP         |      O(n^2)     |    O(n)      |\n# |  Math       |      O(1)       |    O(1)      |\n# |-------------|-----------------|--------------|\n\nn = 2\nprint(divisorGameDP(n))  # True\nprint(divisorGameDPMath(n))  # True\n</code></pre>"},{"location":"content/endlesscheng/dp_game_theory/#877-stone-game","title":"877. Stone Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, dynamic programming, game theory</p> </li> </ul>"},{"location":"content/endlesscheng/dp_game_theory/#486-predict-the-winner","title":"486. Predict the Winner","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, dynamic programming, recursion, game theory</p> </li> </ul>"},{"location":"content/endlesscheng/dp_game_theory/#1510-stone-game-iv","title":"1510. Stone Game IV","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, dynamic programming, game theory</p> </li> </ul>"},{"location":"content/endlesscheng/dp_game_theory/#1690-stone-game-vii","title":"1690. Stone Game VII","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, dynamic programming, game theory</p> </li> </ul>"},{"location":"content/endlesscheng/dp_game_theory/#1406-stone-game-iii","title":"1406. Stone Game III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, dynamic programming, game theory</p> </li> </ul>"},{"location":"content/endlesscheng/dp_game_theory/#1140-stone-game-ii","title":"1140. Stone Game II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, dynamic programming, prefix sum, game theory</p> </li> </ul>"},{"location":"content/endlesscheng/dp_game_theory/#1563-stone-game-v","title":"1563. Stone Game V","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, dynamic programming, game theory</p> </li> </ul>"},{"location":"content/endlesscheng/dp_game_theory/#464-can-i-win","title":"464. Can I Win","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, bit manipulation, memoization, game theory, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_game_theory/#1872-stone-game-viii","title":"1872. Stone Game VIII","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, dynamic programming, prefix sum, game theory</p> </li> </ul>"},{"location":"content/endlesscheng/dp_game_theory/#913-cat-and-mouse","title":"913. Cat and Mouse","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, dynamic programming, graph, topological sort, memoization, game theory</p> </li> </ul>"},{"location":"content/endlesscheng/dp_game_theory/#1728-cat-and-mouse-ii","title":"1728. Cat and Mouse II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, dynamic programming, graph, topological sort, memoization, matrix, game theory</p> </li> </ul>"},{"location":"content/endlesscheng/dp_game_theory/#294-flip-game-ii","title":"294. Flip Game II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, backtracking, memoization, game theory</p> </li> </ul>"},{"location":"content/endlesscheng/dp_graph/","title":"DP Graph","text":""},{"location":"content/endlesscheng/dp_graph/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3243. Shortest Distance After Road Addition Queries I (Medium)</li> <li> 787. Cheapest Flights Within K Stops (Medium)</li> <li> 1786. Number of Restricted Paths From First to Last Node (Medium)</li> <li> 2050. Parallel Courses III (Hard)</li> <li> 1976. Number of Ways to Arrive at Destination (Medium)</li> <li> 1857. Largest Color Value in a Directed Graph (Hard)</li> <li> 1928. Minimum Cost to Reach Destination in Time (Hard)</li> <li> 913. Cat and Mouse (Hard)</li> <li> 1728. Cat and Mouse II (Hard)</li> <li> 1548. The Most Similar Path in a Graph (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/dp_graph/#3243-shortest-distance-after-road-addition-queries-i","title":"3243. Shortest Distance After Road Addition Queries I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, breadth first search, graph</p> </li> <li><code>n=5</code>, <code>queries = [[2,4],[0,2],[0,4]]</code></li> <li></li> <li></li> <li></li> <li>Output: <code>[3,2,1]</code></li> </ul> 3243. Shortest Distance After Road Addition Queries I - Python Solution<pre><code>from collections import deque\nfrom itertools import count\nfrom typing import List\n\n\n# BFS\ndef shortestDistanceAfterQueries(\n    n: int, queries: List[List[int]]\n) -&gt; List[int]:\n    g = [[] for _ in range(n)]\n    for i in range(n - 1):\n        g[i].append(i + 1)\n\n    vis = [-1 for _ in range(n)]\n\n    def bfs(i: int) -&gt; int:\n        q = deque([0])\n        for step in count(1):\n            tmp = q\n            q = deque()\n            for x in tmp:\n                for y in g[x]:\n                    if y == n - 1:\n                        return step\n                    if vis[y] != i:\n                        vis[y] = i\n                        q.append(y)\n        return -1\n\n    res = [0] * len(queries)\n    for i, (l, r) in enumerate(queries):\n        g[l].append(r)\n        res[i] = bfs(i)\n\n    return res\n\n\nn = 5\nqueries = [[2, 4], [0, 2], [0, 4]]\nprint(shortestDistanceAfterQueries(n, queries))  # [3, 2, 1]\n</code></pre>"},{"location":"content/endlesscheng/dp_graph/#787-cheapest-flights-within-k-stops","title":"787. Cheapest Flights Within K Stops","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming, depth first search, breadth first search, graph, heap priority queue, shortest path</p> </li> <li>Return the cheapest price from <code>src</code> to <code>dst</code> with at most <code>K</code> stops.</li> </ul> <pre><code>graph TD\n0((0))\n1((1))\n2((2))\n3((3))\n0 --&gt; |100| 1\n1 --&gt; |600| 3\n1 --&gt; |100| 2\n2 --&gt; |100| 0\n2 --&gt; |200| 3</code></pre> 787. Cheapest Flights Within K Stops - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Bellman-Ford\ndef findCheapestPriceBF(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    prices = [float(\"inf\") for _ in range(n)]\n    prices[src] = 0\n\n    for _ in range(k + 1):\n        temp = prices[:]\n        for u, v, w in flights:\n            temp[v] = min(temp[v], prices[u] + w)\n        prices = temp\n\n    return prices[dst] if prices[dst] != float(\"inf\") else -1\n\n\n# Dijkstra\ndef findCheapestPriceDijkstra(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in flights:\n        graph[u].append((v, w))\n\n    heap = [(0, src, 0)]  # (price, city, stops)\n    visited = defaultdict(int)  # {city: stops}\n\n    while heap:\n        price, city, stops = heapq.heappop(heap)\n\n        if city == dst:\n            return price\n\n        if stops &gt; k:\n            continue\n\n        if city in visited and visited[city] &lt;= stops:\n            continue\n\n        visited[city] = stops\n\n        for neighbor, cost in graph[city]:\n            heapq.heappush(heap, (price + cost, neighbor, stops + 1))\n\n    return -1\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |Bellman-Ford|    O(k * E)      |  O(n)   |\n# | Dijkstra   | O(E * log(V))    |  O(n)   |\n# |------------|------------------|---------|\n\n\nn = 4\nflights = [[0, 1, 100], [1, 2, 100], [2, 0, 100], [1, 3, 600], [2, 3, 200]]\nsrc = 0\ndst = 3\nk = 1\nprint(findCheapestPriceBF(n, flights, src, dst, k))  # 700\nprint(findCheapestPriceDijkstra(n, flights, src, dst, k))  # 700\n</code></pre>"},{"location":"content/endlesscheng/dp_graph/#1786-number-of-restricted-paths-from-first-to-last-node","title":"1786. Number of Restricted Paths From First to Last Node","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming, graph, topological sort, heap priority queue, shortest path</p> </li> </ul>"},{"location":"content/endlesscheng/dp_graph/#2050-parallel-courses-iii","title":"2050. Parallel Courses III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, graph, topological sort</p> </li> </ul>"},{"location":"content/endlesscheng/dp_graph/#1976-number-of-ways-to-arrive-at-destination","title":"1976. Number of Ways to Arrive at Destination","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming, graph, topological sort, shortest path 1976. Number of Ways to Arrive at Destination - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra\ndef countPaths(n: int, roads: List[List[int]]) -&gt; int:\n    mod = 10**9 + 7\n    graph = [[] for _ in range(n)]\n    for u, v, w in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n\n    dist = [float(\"inf\") for _ in range(n)]\n    dist[0] = 0\n    count = [0 for _ in range(n)]\n    count[0] = 1\n\n    heap = [(0, 0)]\n\n    while heap:\n        d, u = heapq.heappop(heap)\n        if d &gt; dist[u]:\n            continue\n\n        for v, w in graph[u]:\n            if dist[u] + w &lt; dist[v]:\n                dist[v] = dist[u] + w\n                count[v] = count[u]\n                heapq.heappush(heap, (dist[v], v))\n            elif dist[u] + w == dist[v]:\n                count[v] += count[u]\n                count[v] %= mod\n\n    return count[-1]\n\n\nn = 7\nroads = [\n    [0, 6, 7],\n    [0, 1, 2],\n    [1, 2, 3],\n    [1, 3, 3],\n    [6, 3, 3],\n    [3, 5, 1],\n    [6, 5, 1],\n    [2, 5, 1],\n    [0, 4, 5],\n    [4, 6, 2],\n]\nprint(countPaths(n, roads))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_graph/#1857-largest-color-value-in-a-directed-graph","title":"1857. Largest Color Value in a Directed Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, dynamic programming, graph, topological sort, memoization, counting 1857. Largest Color Value in a Directed Graph - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# Topological Sort\ndef largestPathValue(colors: str, edges: List[List[int]]) -&gt; int:\n    n = len(colors)\n    graph = defaultdict(list)\n    indegree = [0 for _ in range(n)]\n\n    for u, v in edges:\n        graph[u].append(v)\n        indegree[v] += 1\n\n    q = deque([i for i in range(n) if indegree[i] == 0])\n\n    dp = [[0] * 26 for _ in range(n)]\n\n    for i in range(n):\n        dp[i][ord(colors[i]) - ord(\"a\")] = 1\n\n    processed, max_color = 0, 0\n\n    while q:\n        n1 = q.popleft()\n        processed += 1\n        max_color = max(max_color, max(dp[n1]))\n\n        for n2 in graph[n1]:\n            indegree[n2] -= 1\n            for i in range(26):\n                dp[n2][i] = max(\n                    dp[n2][i],\n                    dp[n1][i] + (1 if i == ord(colors[n2]) - ord(\"a\") else 0),\n                )\n            if indegree[n2] == 0:\n                q.append(n2)\n\n    return max_color if processed == n else -1\n\n\ncolors = \"abaca\"\nedges = [[0, 1], [0, 2], [2, 3], [3, 4]]\nprint(largestPathValue(colors, edges))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_graph/#1928-minimum-cost-to-reach-destination-in-time","title":"1928. Minimum Cost to Reach Destination in Time","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, graph</p> </li> </ul>"},{"location":"content/endlesscheng/dp_graph/#913-cat-and-mouse","title":"913. Cat and Mouse","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, dynamic programming, graph, topological sort, memoization, game theory</p> </li> </ul>"},{"location":"content/endlesscheng/dp_graph/#1728-cat-and-mouse-ii","title":"1728. Cat and Mouse II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, dynamic programming, graph, topological sort, memoization, matrix, game theory</p> </li> </ul>"},{"location":"content/endlesscheng/dp_graph/#1548-the-most-similar-path-in-a-graph","title":"1548. The Most Similar Path in a Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, graph</p> </li> </ul>"},{"location":"content/endlesscheng/dp_grid_advanced/","title":"DP Grid Advanced","text":""},{"location":"content/endlesscheng/dp_grid_advanced/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1594. Maximum Non Negative Product in a Matrix (Medium)</li> <li> 1301. Number of Paths with Max Score (Hard)</li> <li> 2435. Paths in Matrix Whose Sum Is Divisible by K (Hard)</li> <li> 174. Dungeon Game (Hard)</li> <li> 329. Longest Increasing Path in a Matrix (Hard)</li> <li> 2328. Number of Increasing Paths in a Grid (Hard)</li> <li> 2267.  Check if There Is a Valid Parentheses String Path (Hard)</li> <li> 1937. Maximum Number of Points with Cost (Medium)</li> <li> 3363. Find the Maximum Number of Fruits Collected (Hard)</li> <li> 1463. Cherry Pickup II (Hard)</li> <li> 741. Cherry Pickup (Hard)</li> <li> 3459. Length of Longest V-Shaped Diagonal Segment (Hard)</li> <li> 2510. Check if There is a Path With Equal Number of 0's And 1's (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/dp_grid_advanced/#1594-maximum-non-negative-product-in-a-matrix","title":"1594. Maximum Non Negative Product in a Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/dp_grid_advanced/#1301-number-of-paths-with-max-score","title":"1301. Number of Paths with Max Score","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/dp_grid_advanced/#2435-paths-in-matrix-whose-sum-is-divisible-by-k","title":"2435. Paths in Matrix Whose Sum Is Divisible by K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/dp_grid_advanced/#174-dungeon-game","title":"174. Dungeon Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/dp_grid_advanced/#329-longest-increasing-path-in-a-matrix","title":"329. Longest Increasing Path in a Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, depth first search, breadth first search, graph, topological sort, memoization, matrix 329. Longest Increasing Path in a Matrix - Python Solution<pre><code>from collections import deque\nfrom functools import cache\nfrom typing import List\n\n\n# BFS - Topological Sort\ndef longestIncreasingPathBFS(matrix: List[List[int]]) -&gt; int:\n    if not matrix:\n        return 0\n\n    m, n = len(matrix), len(matrix[0])\n    dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    # Calculate indegrees and initialize queue in one pass\n    indegree = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            for dr, dc in dirs:\n                nr, nc = i + dr, j + dc\n                if (\n                    0 &lt;= nr &lt; m\n                    and 0 &lt;= nc &lt; n\n                    and matrix[nr][nc] &gt; matrix[i][j]\n                ):\n                    indegree[nr][nc] += 1\n\n    # Start with cells that have no smaller neighbors\n    queue = deque(\n        (i, j) for i in range(m) for j in range(n) if indegree[i][j] == 0\n    )\n\n    res = 0\n    while queue:\n        res += 1\n        for _ in range(len(queue)):\n            r, c = queue.popleft()\n            for dr, dc in dirs:\n                nr, nc = r + dr, c + dc\n                if (\n                    0 &lt;= nr &lt; m\n                    and 0 &lt;= nc &lt; n\n                    and matrix[nr][nc] &gt; matrix[r][c]\n                ):\n                    indegree[nr][nc] -= 1\n                    if indegree[nr][nc] == 0:\n                        queue.append((nr, nc))\n\n    return res\n\n\n# DP - 2D\ndef longestIncreasingPath(matrix: List[List[int]]) -&gt; int:\n    if not matrix:\n        return 0\n\n    m, n = len(matrix), len(matrix[0])\n    dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    @cache\n    def dfs(r, c):\n        path = 1\n        for dr, dc in dirs:\n            nr, nc = r + dr, c + dc\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and matrix[nr][nc] &gt; matrix[r][c]:\n                path = max(path, dfs(nr, nc) + 1)\n        return path\n\n    res = 0\n    for i in range(m):\n        for j in range(n):\n            res = max(res, dfs(i, j))\n\n    return res\n\n\nif __name__ == \"__main__\":\n    matrix = [[9, 9, 4], [6, 6, 8], [2, 1, 1]]\n    assert longestIncreasingPath(matrix) == 4\n    assert longestIncreasingPathBFS(matrix) == 4\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_grid_advanced/#2328-number-of-increasing-paths-in-a-grid","title":"2328. Number of Increasing Paths in a Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, depth first search, breadth first search, graph, topological sort, memoization, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/dp_grid_advanced/#2267-check-if-there-is-a-valid-parentheses-string-path","title":"2267.  Check if There Is a Valid Parentheses String Path","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/dp_grid_advanced/#1937-maximum-number-of-points-with-cost","title":"1937. Maximum Number of Points with Cost","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/dp_grid_advanced/#3363-find-the-maximum-number-of-fruits-collected","title":"3363. Find the Maximum Number of Fruits Collected","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/dp_grid_advanced/#1463-cherry-pickup-ii","title":"1463. Cherry Pickup II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/dp_grid_advanced/#741-cherry-pickup","title":"741. Cherry Pickup","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/dp_grid_advanced/#3459-length-of-longest-v-shaped-diagonal-segment","title":"3459. Length of Longest V-Shaped Diagonal Segment","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, memoization, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/dp_grid_advanced/#2510-check-if-there-is-a-path-with-equal-number-of-0s-and-1s","title":"2510. Check if There is a Path With Equal Number of 0's And 1's","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/dp_grid_basics/","title":"DP Grid Basics","text":""},{"location":"content/endlesscheng/dp_grid_basics/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 64. Minimum Path Sum (Medium)</li> <li> 62. Unique Paths (Medium)</li> <li> 63. Unique Paths II (Medium)</li> <li> 120. Triangle (Medium)</li> <li> 3393. Count Paths With the Given XOR Value (Medium)</li> <li> 931. Minimum Falling Path Sum (Medium)</li> <li> 2684. Maximum Number of Moves in a Grid (Medium)</li> <li> 2304. Minimum Path Cost in a Grid (Medium)</li> <li> 1289. Minimum Falling Path Sum II (Hard)</li> <li> 3418. Maximum Amount of Money Robot Can Earn (Medium)</li> </ul>"},{"location":"content/endlesscheng/dp_grid_basics/#64-minimum-path-sum","title":"64. Minimum Path Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, matrix 64. Minimum Path Sum - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef minPathSum(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = grid[i][0] + dp[i - 1][0]\n    for j in range(1, n):\n        dp[0][j] = grid[0][j] + dp[0][j - 1]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[-1][-1]\n\n\ngrid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\nprint(minPathSum(grid))  # 7\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_grid_basics/#62-unique-paths","title":"62. Unique Paths","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, combinatorics</p> </li> <li>Count the number of unique paths to reach the bottom-right corner of a <code>m x n</code> grid.</li> </ul> <p></p> 62. Unique Paths - Python Solution<pre><code># DP - 2D\ndef uniquePaths(m: int, n: int) -&gt; int:\n    if m == 1 or n == 1:\n        return 1\n\n    dp = [[1] * n for _ in range(m)]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]\n\n\nprint(uniquePaths(m=3, n=7))  # 28\n# [[1, 1, 1,  1,  1,  1,  1],\n#  [1, 2, 3,  4,  5,  6,  7],\n#  [1, 3, 6, 10, 15, 21, 28]]\n</code></pre> 62. Unique Paths - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint uniquePaths(int m, int n) {\n    vector dp(m, vector&lt;int&gt;(n, 1));\n\n    for (int i = 1; i &lt; m; i++) {\n        for (int j = 1; j &lt; n; j++) {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n\n    return dp[m - 1][n - 1];\n}\n\nint main() {\n    int m = 3, n = 7;\n    cout &lt;&lt; uniquePaths(m, n) &lt;&lt; endl;  // 28\n    return 0;\n}\n</code></pre>"},{"location":"content/endlesscheng/dp_grid_basics/#63-unique-paths-ii","title":"63. Unique Paths II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, matrix</p> </li> <li>Count the number of unique paths to reach the bottom-right corner of a <code>m x n</code> grid with obstacles.</li> </ul> <p></p> 63. Unique Paths II - Python Solution<pre><code>from typing import List\n\n\n# DP - 2D\ndef uniquePathsWithObstacles(obstacleGrid: List[List[int]]) -&gt; int:\n    if obstacleGrid[0][0] == 1 or obstacleGrid[-1][-1] == 1:\n        return 0\n\n    m, n = len(obstacleGrid), len(obstacleGrid[0])\n    dp = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n        if obstacleGrid[i][0] == 0:\n            dp[i][0] = 1\n        else:\n            break\n\n    for j in range(n):\n        if obstacleGrid[0][j] == 0:\n            dp[0][j] = 1\n        else:\n            break\n\n    for i in range(1, m):\n        for j in range(1, n):\n            if obstacleGrid[i][j] == 1:\n                continue\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]\n\n\nobstacleGrid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\nprint(uniquePathsWithObstacles(obstacleGrid))  # 2\n# [[1, 1, 1],\n#  [1, 0, 1],\n#  [1, 1, 2]]\n</code></pre>"},{"location":"content/endlesscheng/dp_grid_basics/#120-triangle","title":"120. Triangle","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_grid_basics/#3393-count-paths-with-the-given-xor-value","title":"3393. Count Paths With the Given XOR Value","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, bit manipulation, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/dp_grid_basics/#931-minimum-falling-path-sum","title":"931. Minimum Falling Path Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/dp_grid_basics/#2684-maximum-number-of-moves-in-a-grid","title":"2684. Maximum Number of Moves in a Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, matrix 2684. Maximum Number of Moves in a Grid - Python Solution<pre><code>from typing import List\n\n\n# DFS\ndef maxMovesDFS(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    res = 0\n\n    def dfs(r, c):\n        nonlocal res\n        res = max(res, c)\n        if res == n - 1:\n            return\n\n        for k in r - 1, r, r + 1:\n            if 0 &lt;= k &lt; m and grid[k][c + 1] &gt; grid[r][c]:\n                dfs(k, c + 1)\n        grid[r][c] = 0\n\n    for i in range(m):\n        dfs(i, 0)\n\n    return res\n\n\ngrid = [[2, 4, 3, 5], [5, 4, 9, 3], [3, 4, 2, 11], [10, 9, 13, 15]]\nprint(maxMovesDFS(grid))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_grid_basics/#2304-minimum-path-cost-in-a-grid","title":"2304. Minimum Path Cost in a Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/dp_grid_basics/#1289-minimum-falling-path-sum-ii","title":"1289. Minimum Falling Path Sum II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/dp_grid_basics/#3418-maximum-amount-of-money-robot-can-earn","title":"3418. Maximum Amount of Money Robot Can Earn","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/dp_grouped_knapsack/","title":"DP Grouped Knapsack","text":""},{"location":"content/endlesscheng/dp_grouped_knapsack/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1155. Number of Dice Rolls With Target Sum (Medium)</li> <li> 1981. Minimize the Difference Between Target and Chosen Elements (Medium)</li> <li> 2218. Maximum Value of K Coins From Piles (Hard)</li> </ul>"},{"location":"content/endlesscheng/dp_grouped_knapsack/#1155-number-of-dice-rolls-with-target-sum","title":"1155. Number of Dice Rolls With Target Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_grouped_knapsack/#1981-minimize-the-difference-between-target-and-chosen-elements","title":"1981. Minimize the Difference Between Target and Chosen Elements","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/dp_grouped_knapsack/#2218-maximum-value-of-k-coins-from-piles","title":"2218. Maximum Value of K Coins From Piles","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/dp_house_robber/","title":"DP House Robber","text":""},{"location":"content/endlesscheng/dp_house_robber/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 198. House Robber (Medium)</li> <li> 740. Delete and Earn (Medium)</li> <li> 2320. Count Number of Ways to Place Houses (Medium)</li> <li> 213. House Robber II (Medium)</li> <li> 3186. Maximum Total Damage With Spell Casting (Medium)</li> </ul>"},{"location":"content/endlesscheng/dp_house_robber/#198-house-robber","title":"198. House Robber","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li> <p>Return the maximum amount of money that can be robbed from the houses. No two adjacent houses can be robbed.</p> </li> <li> <p><code>dp[n]</code> stores the maximum amount of money that can be robbed from the first <code>n</code> houses.</p> </li> <li>Formula: <code>dp[n] = max(dp[n - 1], dp[n - 2] + nums[n])</code>.<ul> <li>Skip: <code>dp[n]</code> \u2192 <code>dp[n - 1]</code></li> <li>Rob: <code>dp[n]</code> \u2192 <code>dp[n - 2] + nums[n]</code></li> </ul> </li> <li>Initialize <code>dp[0] = nums[0]</code> and <code>dp[1] = max(nums[0], nums[1])</code>.</li> <li>Return <code>dp[-1]</code>.</li> <li>Example: <code>nums = [2, 7, 9, 3, 1]</code></li> </ul> n <code>nums[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n-2] + nums[n]</code> <code>dp[n]</code> 0 2 - 2 - 2 1 7 - 7 - 7 2 9 2 7 11 11 3 3 7 11 10 11 4 1 11 11 12 12 198. House Robber - Python Solution<pre><code>from typing import List\n\n\n# DP (House Robber)\ndef rob1(nums: List[int]) -&gt; int:\n    if len(nums) &lt; 3:\n        return max(nums)\n\n    dp = [0 for _ in range(len(nums))]\n    dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n    for i in range(2, len(nums)):\n        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n    return dp[-1]\n\n\n# DP (House Robber) Optimized\ndef rob2(nums: List[int]) -&gt; int:\n    f0, f1 = 0, 0\n\n    for num in nums:\n        f0, f1 = f1, max(f1, f0 + num)\n\n    return f1\n\n\nnums = [2, 7, 9, 3, 1]\nprint(rob1(nums))  # 12\nprint(rob2(nums))  # 12\n</code></pre> 198. House Robber - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint rob(vector&lt;int&gt; &amp;nums) {\n    int prev = 0, cur = 0, temp = 0;\n\n    for (int num : nums) {\n        temp = cur;\n        cur = max(cur, prev + num);\n        prev = temp;\n    }\n    return cur;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {2, 7, 9, 3, 1};\n    cout &lt;&lt; rob(nums) &lt;&lt; endl;  // 12\n    return 0;\n}\n</code></pre>"},{"location":"content/endlesscheng/dp_house_robber/#740-delete-and-earn","title":"740. Delete and Earn","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, dynamic programming 740. Delete and Earn - Python Solution<pre><code>from typing import List\n\n\n# DP (House Robber)\ndef deleteAndEarn(nums: List[int]) -&gt; int:\n    def rob(nums):\n        f0, f1 = 0, 0\n        for x in nums:\n            f0, f1 = f1, max(f1, f0 + x)\n        return f1\n\n    res = [0 for _ in range(max(nums) + 1)]\n\n    for x in nums:\n        res[x] += x\n\n    return rob(res)\n\n\nnums = [2, 2, 3, 3, 3, 4]\nprint(deleteAndEarn(nums))  # 9\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_house_robber/#2320-count-number-of-ways-to-place-houses","title":"2320. Count Number of Ways to Place Houses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_house_robber/#213-house-robber-ii","title":"213. House Robber II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li>Return the maximum amount of money that can be robbed from the houses arranged in a circle.</li> <li>Circular \u2192 Linear: <code>nums[0]</code> and <code>nums[-1]</code> cannot be robbed together.</li> <li>Rob from <code>0</code> to <code>n - 2</code></li> </ul> n <code>nums[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n-2] + nums[n]</code> <code>dp[n]</code> 0 2 - 2 - 2 1 7 - 7 - 7 2 9 2 7 11 11 3 3 7 11 10 11 <ul> <li>Rob from <code>1</code> to <code>n - 1</code></li> </ul> n <code>nums[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n-2] + nums[n]</code> <code>dp[n]</code> 1 7 - - - 7 2 9 - 7 - 9 3 3 7 9 10 10 4 1 9 10 10 10 213. House Robber II - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef rob(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 3:\n        return max(nums)\n\n    def robLinear(nums: List[int]) -&gt; int:\n        dp = [0 for _ in range(len(nums))]\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n        return dp[-1]\n\n    # circle -&gt; linear\n    a = robLinear(nums[1:])  # 2nd house to the last house\n    b = robLinear(nums[:-1])  # 1st house to the 2nd last house\n\n    return max(a, b)\n\n\nnums = [2, 7, 9, 3, 1]\nprint(rob(nums))  # 11\n</code></pre> 213. House Robber II - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// DP\nint robDP(vector&lt;int&gt;&amp; nums) {\n    int n = nums.size();\n    if (n &lt;= 3) return *max_element(nums.begin(), nums.end());\n\n    vector&lt;int&gt; dp1(n, 0), dp2(n, 0);\n\n    dp1[0] = nums[0];\n    dp2[1] = max(nums[0], nums[1]);\n    for (int i = 2; i &lt; n - 1; i++) {\n        dp1[i] = max(dp1[i - 1], dp1[i - 2] + nums[i]);\n    }\n\n    dp2[1] = nums[1];\n    dp2[2] = max(nums[1], nums[2]);\n    for (int i = 3; i &lt; n; i++) {\n        dp1[i] = max(dp1[i - 1], dp1[i - 2] + nums[i]);\n    }\n\n    return max(dp1[n - 2], dp2[n - 1]);\n}\n\n// DP (Space Optimized)\nint robDPOptimized(vector&lt;int&gt;&amp; nums) {\n    int n = nums.size();\n    if (n &lt;= 3) return *max_element(nums.begin(), nums.end());\n\n    int f1 = nums[0];\n    int f2 = max(nums[0], nums[1]);\n    int res1;\n    for (int i = 2; i &lt; n - 1; i++) {\n        res1 = max(f2, f1 + nums[i]);\n        f1 = f2;\n        f2 = res1;\n    }\n\n    f1 = nums[1];\n    f2 = max(nums[1], nums[2]);\n    int res2;\n    for (int i = 3; i &lt; n; i++) {\n        res2 = max(f2, f1 + nums[i]);\n        f1 = f2;\n        f2 = res2;\n    }\n\n    return max(res1, res2);\n}\n\nint main() {\n    vector&lt;int&gt; nums = {2, 3, 2};\n    cout &lt;&lt; robDP(nums) &lt;&lt; endl;           // 3\n    cout &lt;&lt; robDPOptimized(nums) &lt;&lt; endl;  // 3\n\n    nums = {1, 2, 3, 1};\n    cout &lt;&lt; robDP(nums) &lt;&lt; endl;           // 4\n    cout &lt;&lt; robDPOptimized(nums) &lt;&lt; endl;  // 4\n\n    return 0;\n}\n</code></pre>"},{"location":"content/endlesscheng/dp_house_robber/#3186-maximum-total-damage-with-spell-casting","title":"3186. Maximum Total Damage With Spell Casting","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, two pointers, binary search, dynamic programming, sorting, counting</p> </li> </ul>"},{"location":"content/endlesscheng/dp_jump_game/","title":"DP Jump Game","text":""},{"location":"content/endlesscheng/dp_jump_game/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1306. Jump Game III (Medium)</li> <li> 2770. Maximum Number of Jumps to Reach the Last Index (Medium)</li> <li> 403. Frog Jump (Hard)</li> <li> 1340. Jump Game V (Hard)</li> <li> 1871. Jump Game VII (Medium)</li> <li> 1696. Jump Game VI (Medium)</li> <li> 975. Odd Even Jump (Hard)</li> <li> 1654. Minimum Jumps to Reach Home (Medium)</li> <li> 656. Coin Path (Hard) \ud83d\udc51</li> <li> 2297. Jump Game VIII (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/dp_jump_game/#1306-jump-game-iii","title":"1306. Jump Game III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search 1306. Jump Game III - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef canReach(arr: List[int], start: int) -&gt; bool:\n    n = len(arr)\n    visited = [False for _ in range(n)]\n    q = deque([start])\n\n    while q:\n        i = q.popleft()\n\n        if arr[i] == 0:\n            return True\n\n        visited[i] = True\n\n        for j in [i - arr[i], i + arr[i]]:\n            if j in range(n) and not visited[j]:\n                q.append(j)\n\n    return False\n\n\narr = [4, 2, 3, 0, 3, 1, 2]\nstart = 5\nprint(canReach(arr, start))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_jump_game/#2770-maximum-number-of-jumps-to-reach-the-last-index","title":"2770. Maximum Number of Jumps to Reach the Last Index","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_jump_game/#403-frog-jump","title":"403. Frog Jump","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_jump_game/#1340-jump-game-v","title":"1340. Jump Game V","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/dp_jump_game/#1871-jump-game-vii","title":"1871. Jump Game VII","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming, sliding window, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/dp_jump_game/#1696-jump-game-vi","title":"1696. Jump Game VI","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, queue, heap priority queue, monotonic queue</p> </li> </ul>"},{"location":"content/endlesscheng/dp_jump_game/#975-odd-even-jump","title":"975. Odd Even Jump","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, stack, monotonic stack, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/dp_jump_game/#1654-minimum-jumps-to-reach-home","title":"1654. Minimum Jumps to Reach Home","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, breadth first search</p> </li> </ul>"},{"location":"content/endlesscheng/dp_jump_game/#656-coin-path","title":"656. Coin Path","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_jump_game/#2297-jump-game-viii","title":"2297. Jump Game VIII","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, stack, graph, monotonic stack, shortest path</p> </li> </ul>"},{"location":"content/endlesscheng/dp_lcs_advanced/","title":"DP LCS Advanced","text":""},{"location":"content/endlesscheng/dp_lcs_advanced/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3290. Maximum Multiplication Score (Medium)</li> <li> 115. Distinct Subsequences (Hard)</li> <li> 3316. Find Maximum Removals From Source String (Medium)</li> <li> 1639. Number of Ways to Form a Target String Given a Dictionary (Hard)</li> <li> 97. Interleaving String (Medium)</li> <li> 1092. Shortest Common Supersequence  (Hard)</li> <li> 44. Wildcard Matching (Hard)</li> <li> 10. Regular Expression Matching (Hard)</li> </ul>"},{"location":"content/endlesscheng/dp_lcs_advanced/#3290-maximum-multiplication-score","title":"3290. Maximum Multiplication Score","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_lcs_advanced/#115-distinct-subsequences","title":"115. Distinct Subsequences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming 115. Distinct Subsequences - Python Solution<pre><code>def numDistinct(s: str, t: str) -&gt; int:\n    m = len(s)\n    n = len(t)\n    dp = [[0] * (n + 1) for _ in range((m + 1))]\n\n    for i in range(m):\n        dp[i][0] = 1\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                # include and exclude s[i-1]\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]  # exclude s[i-1]\n\n    return dp[-1][-1]\n\n\ns = \"rabbbit\"\nt = \"rabbit\"\nprint(numDistinct(s, t))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_lcs_advanced/#3316-find-maximum-removals-from-source-string","title":"3316. Find Maximum Removals From Source String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, two pointers, string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_lcs_advanced/#1639-number-of-ways-to-form-a-target-string-given-a-dictionary","title":"1639. Number of Ways to Form a Target String Given a Dictionary","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_lcs_advanced/#97-interleaving-string","title":"97. Interleaving String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming 97. Interleaving String - Python Solution<pre><code># DP - 2D\ndef isInterleaveDP(s1: str, s2: str, s3: str) -&gt; bool:\n    m, n, k = len(s1), len(s2), len(s3)\n\n    if m + n != k:\n        return False\n\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    for i in range(1, m + 1):\n        dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n\n    for j in range(1, n + 1):\n        dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (\n                dp[i][j - 1] and s2[j - 1] == s3[i + j - 1]\n            )\n\n    return dp[m][n]\n\n\n# DFS\ndef isInterleaveDFS(s1: str, s2: str, s3: str) -&gt; bool:\n    memo = {}\n\n    def dfs(i, j, k):\n        if i == len(s1) and j == len(s2) and k == len(s3):\n            return True\n\n        if (i, j) in memo:\n            return memo[(i, j)]\n\n        res = False\n\n        if i &lt; len(s1) and k &lt; len(s3) and s1[i] == s3[k]:\n            res |= dfs(i + 1, j, k + 1)\n\n        if j &lt; len(s2) and k &lt; len(s3) and s2[j] == s3[k]:\n            res |= dfs(i, j + 1, k + 1)\n\n        memo[(i, j)] = res\n\n        return res\n\n    return dfs(0, 0, 0)\n\n\ns1 = \"aabcc\"\ns2 = \"dbbca\"\ns3 = \"aadbbbaccc\"\nprint(isInterleaveDP(s1, s2, s3))  # False\nprint(isInterleaveDFS(s1, s2, s3))  # False\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_lcs_advanced/#1092-shortest-common-supersequence","title":"1092. Shortest Common Supersequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_lcs_advanced/#44-wildcard-matching","title":"44. Wildcard Matching","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming, greedy, recursion</p> </li> </ul>"},{"location":"content/endlesscheng/dp_lcs_advanced/#10-regular-expression-matching","title":"10. Regular Expression Matching","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming, recursion</p> </li> </ul>"},{"location":"content/endlesscheng/dp_lcs_basics/","title":"DP LCS Basics","text":""},{"location":"content/endlesscheng/dp_lcs_basics/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1143. Longest Common Subsequence (Medium)</li> <li> 583. Delete Operation for Two Strings (Medium)</li> <li> 712. Minimum ASCII Delete Sum for Two Strings (Medium)</li> <li> 72. Edit Distance (Medium)</li> <li> 1035. Uncrossed Lines (Medium)</li> <li> 1458. Max Dot Product of Two Subsequences (Hard)</li> </ul>"},{"location":"content/endlesscheng/dp_lcs_basics/#1143-longest-common-subsequence","title":"1143. Longest Common Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming 1143. Longest Common Subsequence - Python Solution<pre><code>from functools import cache\n\n\n# DP - LCS\ndef longestCommonSubsequenceMemo(text1: str, text2: str) -&gt; int:\n    m, n = len(text1), len(text2)\n\n    @cache\n    def dfs(i: int, j: int) -&gt; int:\n        if i &lt; 0 or j &lt; 0:\n            return 0\n        if text1[i] == text2[j]:\n            return dfs(i - 1, j - 1) + 1\n        return max(dfs(i - 1, j), dfs(i, j - 1))\n\n    return dfs(m - 1, n - 1)\n\n\n# DP - LCS\ndef longestCommonSubsequenceTable(text1: str, text2: str) -&gt; int:\n    m, n = len(text1), len(text2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i - 1] == text2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    assert longestCommonSubsequenceMemo(\"abcde\", \"ace\") == 3\n    assert longestCommonSubsequenceTable(\"abcde\", \"ace\") == 3\n    assert longestCommonSubsequenceMemo(\"abc\", \"abc\") == 3\n    assert longestCommonSubsequenceTable(\"abc\", \"abc\") == 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_lcs_basics/#583-delete-operation-for-two-strings","title":"583. Delete Operation for Two Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming 583. Delete Operation for Two Strings - Python Solution<pre><code># DP - LCS\ndef minDistance1(word1: str, word2: str) -&gt; int:\n    m = len(word1)\n    n = len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]  # no need to delete\n            else:\n                dp[i][j] = min(\n                    dp[i - 1][j] + 1,  # delete word1[i]\n                    dp[i][j - 1] + 1,  # delete word2[j]\n                    dp[i - 1][j - 1] + 2,  # delete both\n                )\n    return dp[-1][-1]\n\n\n# DP - LCS\ndef minDistance2(word1: str, word2: str) -&gt; int:\n    def LCS(word1: str, word2: str) -&gt; int:\n        m = len(word1)\n        n = len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        lcs = 0\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n                if lcs &lt; dp[i][j]:\n                    lcs = dp[i][j]\n        return lcs\n\n    lcs = LCS(word1, word2)\n    return len(word1) + len(word2) - 2 * lcs\n\n\nword1 = \"sea\"\nword2 = \"eat\"\nprint(minDistance1(word1, word2))  # 2\nprint(minDistance2(word1, word2))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_lcs_basics/#712-minimum-ascii-delete-sum-for-two-strings","title":"712. Minimum ASCII Delete Sum for Two Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_lcs_basics/#72-edit-distance","title":"72. Edit Distance","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming 72. Edit Distance - Python Solution<pre><code>from functools import cache\n\n\n# Recursive\ndef minDistanceDFS(word1: str, word2: str) -&gt; int:\n    n, m = len(word1), len(word2)\n\n    @cache\n    def dfs(i: int, j: int) -&gt; int:\n        if i &lt; 0:\n            return j + 1\n        if j &lt; 0:\n            return i + 1\n        if word1[i] == word2[j]:\n            return dfs(i - 1, j - 1)\n\n        return 1 + min(dfs(i - 1, j), dfs(i, j - 1), dfs(i - 1, j - 1))\n\n    return dfs(n - 1, m - 1)\n\n\n# Iterative\ndef minDistanceDP(word1: str, word2: str) -&gt; int:\n    m, n = len(word1), len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]  # no operation\n            else:\n                dp[i][j] = 1 + min(\n                    dp[i - 1][j],  # delete\n                    dp[i][j - 1],  # insert\n                    dp[i - 1][j - 1],  # replace\n                )\n    return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    word1 = \"horse\"\n    word2 = \"ros\"\n    print(minDistanceDFS(word1, word2))  # 3\n    print(minDistanceDP(word1, word2))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_lcs_basics/#1035-uncrossed-lines","title":"1035. Uncrossed Lines","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming 1035. Uncrossed Lines - Python Solution<pre><code>from typing import List\n\n\ndef maxUncrossedLines(nums1: List[int], nums2: List[int]) -&gt; int:\n    m = len(nums1)\n    n = len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    num = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if nums1[i - 1] == nums2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n            if num &lt; dp[i][j]:\n                num = dp[i][j]\n\n    return num\n\n\nprint(maxUncrossedLines([1, 4, 2], [1, 2, 4]))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_lcs_basics/#1458-max-dot-product-of-two-subsequences","title":"1458. Max Dot Product of Two Subsequences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_lis_advanced/","title":"DP LIS Advanced","text":""},{"location":"content/endlesscheng/dp_lis_advanced/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1626. Best Team With No Conflicts (Medium)</li> <li> 673. Number of Longest Increasing Subsequence (Medium)</li> <li> 354. Russian Doll Envelopes (Hard)</li> <li> 1691. Maximum Height by Stacking Cuboids  (Hard)</li> <li> 960. Delete Columns to Make Sorted III (Hard)</li> <li> 2407. Longest Increasing Subsequence II (Hard)</li> <li> 1187. Make Array Strictly Increasing (Hard)</li> <li> 1713. Minimum Operations to Make a Subsequence (Hard)</li> <li> 3288. Length of the Longest Increasing Path (Hard)</li> <li> 368. Largest Divisible Subset (Medium)</li> </ul>"},{"location":"content/endlesscheng/dp_lis_advanced/#1626-best-team-with-no-conflicts","title":"1626. Best Team With No Conflicts","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, sorting 1626. Best Team With No Conflicts - Python Solution<pre><code>from typing import List\n\n\n# DP - LIS\ndef bestTeamScore(scores: List[int], ages: List[int]) -&gt; int:\n    n = len(scores)\n    pairs = sorted(zip(scores, ages))  # sort\n    dp = [0 for _ in range(n)]\n\n    # LIS\n    for i in range(n):\n        for j in range(i):\n            if pairs[i][1] &gt;= pairs[j][1]:\n                dp[i] = max(dp[i], dp[j])\n        dp[i] += pairs[i][0]\n\n    return max(dp)\n\n\nif __name__ == \"__main__\":\n    assert bestTeamScore([1, 3, 5, 10, 15], [1, 2, 3, 4, 5]) == 34\n    assert bestTeamScore([4, 5, 6, 5], [2, 1, 2, 1]) == 16\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_lis_advanced/#673-number-of-longest-increasing-subsequence","title":"673. Number of Longest Increasing Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, binary indexed tree, segment tree 673. Number of Longest Increasing Subsequence - Python Solution<pre><code>from typing import List\n\n\n# DP - LIS\ndef findNumberOfLIS(nums: List[int]) -&gt; int:\n    if not nums:\n        return 0\n\n    n = len(nums)\n    dp = [1 for _ in range(n)]\n    counts = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] &gt; nums[j]:\n                if dp[j] + 1 &gt; dp[i]:\n                    dp[i] = dp[j] + 1\n                    counts[i] = counts[j]\n                elif dp[j] + 1 == dp[i]:\n                    counts[i] += counts[j]\n\n    longest = max(dp)\n    return sum(c for i, c in enumerate(counts) if dp[i] == longest)\n\n\nnums = [1, 3, 5, 4, 7]\nprint(findNumberOfLIS(nums))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_lis_advanced/#354-russian-doll-envelopes","title":"354. Russian Doll Envelopes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, dynamic programming, sorting 354. Russian Doll Envelopes - Python Solution<pre><code>from typing import List\n\n\n# DP - LIS\ndef maxEnvelopes(envelopes: List[List[int]]) -&gt; int:\n    envelopes.sort(key=lambda x: (x[0], -x[1]))\n    dp = []\n\n    for w, h in envelopes:\n        left, right = 0, len(dp)\n        while left &lt; right:\n            mid = left + (right - left) // 2\n            if dp[mid][1] &lt; h:\n                left = mid + 1\n            else:\n                right = mid\n        if right == len(dp):\n            dp.append((w, h))\n        else:\n            dp[right] = (w, h)\n\n    return len(dp)\n\n\nenvelopes = [[5, 4], [6, 4], [6, 7], [2, 3]]\nprint(maxEnvelopes(envelopes))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_lis_advanced/#1691-maximum-height-by-stacking-cuboids","title":"1691. Maximum Height by Stacking Cuboids","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/dp_lis_advanced/#960-delete-columns-to-make-sorted-iii","title":"960. Delete Columns to Make Sorted III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, dynamic programming 960. Delete Columns to Make Sorted III - Python Solution<pre><code>from typing import List\n\n\n# DP - LIS\ndef minDeletionSize(strs: List[str]) -&gt; int:\n    if not strs:\n        return 0\n\n    n = len(strs[0])\n    dp = [1 for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i):\n            if all(row[j] &lt;= row[i] for row in strs):\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return n - max(dp)\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_lis_advanced/#2407-longest-increasing-subsequence-ii","title":"2407. Longest Increasing Subsequence II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, divide and conquer, dynamic programming, binary indexed tree, segment tree, queue, monotonic queue</p> </li> </ul>"},{"location":"content/endlesscheng/dp_lis_advanced/#1187-make-array-strictly-increasing","title":"1187. Make Array Strictly Increasing","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, dynamic programming, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/dp_lis_advanced/#1713-minimum-operations-to-make-a-subsequence","title":"1713. Minimum Operations to Make a Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, binary search, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/dp_lis_advanced/#3288-length-of-the-longest-increasing-path","title":"3288. Length of the Longest Increasing Path","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/dp_lis_advanced/#368-largest-divisible-subset","title":"368. Largest Divisible Subset","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, dynamic programming, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/dp_lis_basics/","title":"DP LIS Basics","text":""},{"location":"content/endlesscheng/dp_lis_basics/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 300. Longest Increasing Subsequence (Medium)</li> <li> 2826. Sorting Three Groups (Medium)</li> <li> 1671. Minimum Number of Removals to Make Mountain Array (Hard)</li> <li> 1964. Find the Longest Valid Obstacle Course at Each Position (Hard)</li> <li> 2111. Minimum Operations to Make the Array K-Increasing (Hard)</li> </ul>"},{"location":"content/endlesscheng/dp_lis_basics/#300-longest-increasing-subsequence","title":"300. Longest Increasing Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, dynamic programming 300. Longest Increasing Subsequence - Python Solution<pre><code>from functools import cache\nfrom typing import List\n\n\n# DP - LIS\ndef lengthOfLISMemo(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return n\n\n    @cache\n    def dfs(i: int) -&gt; int:\n        res = 0\n        for j in range(i):\n            if nums[j] &lt; nums[i]:\n                res = max(res, dfs(j))\n        return res + 1\n\n    return max(dfs(i) for i in range(n))\n\n\n# DP - LIS\ndef lengthOfLISTable(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return n\n\n    dp = [1 for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i):\n            if nums[i] &gt; nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\n\nif __name__ == \"__main__\":\n    assert lengthOfLISMemo([10, 9, 2, 5, 3, 7, 101, 18]) == 4\n    assert lengthOfLISTable([10, 9, 2, 5, 3, 7, 101, 18]) == 4\n    assert lengthOfLISMemo([0, 1, 0, 3, 2, 3]) == 4\n    assert lengthOfLISTable([0, 1, 0, 3, 2, 3]) == 4\n    assert lengthOfLISMemo([7, 7, 7, 7]) == 1\n    assert lengthOfLISTable([7, 7, 7, 7]) == 1\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_lis_basics/#2826-sorting-three-groups","title":"2826. Sorting Three Groups","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, dynamic programming 2826. Sorting Three Groups - Python Solution<pre><code>from functools import cache\nfrom typing import List\n\n\n# DP - LIS\ndef minimumOperationsMemo(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return 0\n\n    @cache\n    def dfs(i):\n        res = 0\n        for j in range(i):\n            if nums[i] &gt;= nums[j]:\n                res = max(res, dfs(j))\n        return res + 1\n\n    LIS = max(dfs(i) for i in range(n))\n\n    return n - LIS\n\n\n# DP - LIS\ndef minimumOperationsTable(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return 0\n\n    dp = [1 for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i):\n            if nums[i] &gt;= nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return n - max(dp)\n\n\n# DP - LIS\ndef minimumOperationsTableOptimized(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return 0\n\n    dp = [0 for _ in range(4)]\n\n    for num in nums:\n        dp[num] += 1\n        dp[2] = max(dp[2], dp[1])\n        dp[3] = max(dp[3], dp[2])\n\n    return n - dp[3]\n\n\nif __name__ == \"__main__\":\n    assert minimumOperationsMemo([2, 1, 3, 2, 1]) == 3\n    assert minimumOperationsTable([2, 1, 3, 2, 1]) == 3\n    assert minimumOperationsTableOptimized([2, 1, 3, 2, 1]) == 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_lis_basics/#1671-minimum-number-of-removals-to-make-mountain-array","title":"1671. Minimum Number of Removals to Make Mountain Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, dynamic programming, greedy 1671. Minimum Number of Removals to Make Mountain Array - Python Solution<pre><code>from typing import List\n\n\n# DP - LIS\ndef minimumMountainRemovals(nums: List[int]) -&gt; int:\n    n = len(nums)\n    lis = [1 for _ in range(n)]\n    lds = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] &gt; nums[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    for i in range(n - 2, -1, -1):\n        for j in range(n - 1, i, -1):\n            if nums[i] &gt; nums[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    maxLen = 0\n    for i in range(1, n - 1):\n        if lis[i] &gt; 1 and lds[i] &gt; 1:\n            maxLen = max(maxLen, lis[i] + lds[i] - 1)\n\n    return n - maxLen\n\n\nnums = [2, 1, 1, 5, 6, 2, 3, 1]\nprint(minimumMountainRemovals(nums))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_lis_basics/#1964-find-the-longest-valid-obstacle-course-at-each-position","title":"1964. Find the Longest Valid Obstacle Course at Each Position","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, binary indexed tree</p> </li> </ul>"},{"location":"content/endlesscheng/dp_lis_basics/#2111-minimum-operations-to-make-the-array-k-increasing","title":"2111. Minimum Operations to Make the Array K-Increasing","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"content/endlesscheng/dp_longest_palindromic_subsequence/","title":"DP Longest Palindromic Subsequence","text":""},{"location":"content/endlesscheng/dp_longest_palindromic_subsequence/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 516. Longest Palindromic Subsequence (Medium)</li> <li> 730. Count Different Palindromic Subsequences (Hard)</li> <li> 1312. Minimum Insertion Steps to Make a String Palindrome (Hard)</li> <li> 1771. Maximize Palindrome Length From Subsequences (Hard)</li> <li> 1682. Longest Palindromic Subsequence II (Medium) \ud83d\udc51</li> <li> 1216. Valid Palindrome III (Hard) \ud83d\udc51</li> <li> 1246. Palindrome Removal (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/dp_longest_palindromic_subsequence/#516-longest-palindromic-subsequence","title":"516. Longest Palindromic Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> <li>Return the length of the longest palindromic subsequence in <code>s</code>.</li> <li>Bottom-up DP table</li> </ul> dp b b b a b b 1 2 3 3 4 b 0 1 2 2 3 <code>dp[i][j]</code> b 0 0 1 1 <code>dp[i+1][j-1]</code> 2 a 0 0 0 1 1 b 0 0 0 0 1 516. Longest Palindromic Subsequence - Python Solution<pre><code>def longestPalindromeSubseq(s: str) -&gt; int:\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            if s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])\n\n    return dp[0][-1]\n\n\nprint(longestPalindromeSubseq(\"bbbab\"))  # 4\n</code></pre>"},{"location":"content/endlesscheng/dp_longest_palindromic_subsequence/#730-count-different-palindromic-subsequences","title":"730. Count Different Palindromic Subsequences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_longest_palindromic_subsequence/#1312-minimum-insertion-steps-to-make-a-string-palindrome","title":"1312. Minimum Insertion Steps to Make a String Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_longest_palindromic_subsequence/#1771-maximize-palindrome-length-from-subsequences","title":"1771. Maximize Palindrome Length From Subsequences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_longest_palindromic_subsequence/#1682-longest-palindromic-subsequence-ii","title":"1682. Longest Palindromic Subsequence II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_longest_palindromic_subsequence/#1216-valid-palindrome-iii","title":"1216. Valid Palindrome III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_longest_palindromic_subsequence/#1246-palindrome-removal","title":"1246. Palindrome Removal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_matrix_exponentiation_optimized/","title":"DP Matrix Exponentiation Optimized","text":""},{"location":"content/endlesscheng/dp_matrix_exponentiation_optimized/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 70. Climbing Stairs (Easy)</li> <li> 509. Fibonacci Number (Easy)</li> <li> 1137. N-th Tribonacci Number (Easy)</li> <li> 1220. Count Vowels Permutation (Hard)</li> <li> 552. Student Attendance Record II (Hard)</li> <li> 935. Knight Dialer (Medium)</li> <li> 790. Domino and Tromino Tiling (Medium)</li> <li> 3337. Total Characters in String After Transformations II (Hard)</li> <li> 2851. String Transformation (Hard)</li> <li> 2912. Number of Ways to Reach Destination in the Grid (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/dp_matrix_exponentiation_optimized/#70-climbing-stairs","title":"70. Climbing Stairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, dynamic programming, memoization</p> </li> <li>Return the number of distinct ways to reach the top of the stairs.</li> <li><code>dp[n]</code> stores the number of distinct ways to reach the <code>n-th</code> stair.</li> <li>Formula: <code>dp[n] = dp[n - 1] + dp[n - 2]</code>.</li> <li>Initialize <code>dp[0] = 0</code>, <code>dp[1] = 1</code>, and <code>dp[2] = 2</code>.</li> </ul> 70. Climbing Stairs - Python Solution<pre><code>from functools import cache\n\n\n# DP\ndef climbStairsDP(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    dp = [i for i in range(n + 1)]\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\n# DP (Optimized)\ndef climbStairsDPOptimized(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    first, second = 1, 2\n\n    for _ in range(3, n + 1):\n        first, second = second, first + second\n\n    return second\n\n\n# Recursion\ndef climbStairsRecursion(n: int) -&gt; int:\n    @cache\n    def dfs(i: int) -&gt; int:\n        if i &lt;= 1:\n            return 1\n        return dfs(i - 1) + dfs(i - 2)\n\n    return dfs(n)\n\n\n# Greedy\ndef climbStairsGreedy(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    p1, p2 = 1, 2\n\n    for _ in range(3, n + 1):\n        p1, p2 = p2, p1 + p2\n\n    return p2\n\n\nif __name__ == \"__main__\":\n    assert climbStairsDP(10) == 89\n    assert climbStairsDPOptimized(10) == 89\n    assert climbStairsRecursion(10) == 89\n    assert climbStairsGreedy(10) == 89\n</code></pre> 70. Climbing Stairs - C++ Solution<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint climbStairs(int n) {\n    if (n &lt;= 2) return n;\n    int f1 = 1, f2 = 2;\n    int res;\n\n    int i = 3;\n    while (i &lt;= n) {\n        res = f1 + f2;\n        f1 = f2;\n        f2 = res;\n        ++i;\n    }\n    return res;\n}\n\nint main() {\n    cout &lt;&lt; climbStairs(2) &lt;&lt; endl;  // 2\n    cout &lt;&lt; climbStairs(3) &lt;&lt; endl;  // 3\n    cout &lt;&lt; climbStairs(6) &lt;&lt; endl;  // 13\n    return 0;\n}\n</code></pre>"},{"location":"content/endlesscheng/dp_matrix_exponentiation_optimized/#509-fibonacci-number","title":"509. Fibonacci Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, dynamic programming, recursion, memoization</p> </li> <li>Return the <code>n-th</code> Fibonacci number.</li> <li><code>dp[n]</code> stores the <code>n-th</code> Fibonacci number.</li> <li>Formula: <code>dp[n] = dp[n - 1] + dp[n - 2]</code>.</li> <li>Initialize <code>dp[0] = 0</code> and <code>dp[1] = 1</code>.</li> </ul> n <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n]</code> 0 - - 0 1 - 0 1 2 0 1 1 3 1 1 2 4 1 2 3 5 2 3 5 6 3 5 8 7 5 8 13 8 8 13 21 9 13 21 34 10 21 34 55 509. Fibonacci Number - Python Solution<pre><code>from functools import cache\n\n\n# DP\ndef fibDP(n: int) -&gt; int:\n    if n &lt;= 1:\n        return n\n\n    dp = [i for i in range(n + 1)]\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\n# DP (Optimized)\ndef fibDPOptimized(n: int) -&gt; int:\n    if n &lt;= 1:\n        return n\n\n    n1, n2 = 0, 1\n    for _ in range(2, n + 1):\n        n1, n2 = n2, n1 + n2\n\n    return n2\n\n\n# Recursive\n@cache\ndef fibRecursive(n: int) -&gt; int:\n    if n &lt;= 1:\n        return n\n\n    return fibRecursive(n - 1) + fibRecursive(n - 2)\n\n\nn = 10\nprint(fibDP(n))  # 55\nprint(fibDPOptimized(n))  # 55\nprint(fibRecursive(n))  # 55\n</code></pre>"},{"location":"content/endlesscheng/dp_matrix_exponentiation_optimized/#1137-n-th-tribonacci-number","title":"1137. N-th Tribonacci Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, dynamic programming, memoization</p> </li> </ul>"},{"location":"content/endlesscheng/dp_matrix_exponentiation_optimized/#1220-count-vowels-permutation","title":"1220. Count Vowels Permutation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_matrix_exponentiation_optimized/#552-student-attendance-record-ii","title":"552. Student Attendance Record II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_matrix_exponentiation_optimized/#935-knight-dialer","title":"935. Knight Dialer","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_matrix_exponentiation_optimized/#790-domino-and-tromino-tiling","title":"790. Domino and Tromino Tiling","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_matrix_exponentiation_optimized/#3337-total-characters-in-string-after-transformations-ii","title":"3337. Total Characters in String After Transformations II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, math, string, dynamic programming, counting</p> </li> </ul>"},{"location":"content/endlesscheng/dp_matrix_exponentiation_optimized/#2851-string-transformation","title":"2851. String Transformation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, string, dynamic programming, string matching</p> </li> </ul>"},{"location":"content/endlesscheng/dp_matrix_exponentiation_optimized/#2912-number-of-ways-to-reach-destination-in-the-grid","title":"2912. Number of Ways to Reach Destination in the Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, dynamic programming, combinatorics</p> </li> </ul>"},{"location":"content/endlesscheng/dp_max_subarray_sum/","title":"DP Max Subarray Sum","text":""},{"location":"content/endlesscheng/dp_max_subarray_sum/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 53. Maximum Subarray (Medium)</li> <li> 2606. Find the Substring With Maximum Cost (Medium)</li> <li> 1749. Maximum Absolute Sum of Any Subarray (Medium)</li> <li> 1191. K-Concatenation Maximum Sum (Medium)</li> <li> 918. Maximum Sum Circular Subarray (Medium)</li> <li> 2321. Maximum Score Of Spliced Array (Hard)</li> <li> 152. Maximum Product Subarray (Medium)</li> </ul>"},{"location":"content/endlesscheng/dp_max_subarray_sum/#53-maximum-subarray","title":"53. Maximum Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, divide and conquer, dynamic programming 53. Maximum Subarray - Python Solution<pre><code>from typing import List\n\n\n# DP Kadane\ndef maxSubArrayDP(nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n\n    dp[0] = nums[0]\n    maxSum = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(\n            dp[i - 1] + nums[i],  # continue the previous subarray\n            nums[i],  # start a new subarray\n        )\n        maxSum = max(maxSum, dp[i])\n\n    return maxSum\n\n\n# Greedy\ndef maxSubArrayGreedy(nums: List[int]) -&gt; int:\n    max_sum = nums[0]\n    cur_sum = 0\n\n    for num in nums:\n        cur_sum = max(cur_sum + num, num)\n        max_sum = max(max_sum, cur_sum)\n\n    return max_sum\n\n\n# Prefix Sum\ndef maxSubArrayPrefixSum(nums: List[int]) -&gt; int:\n    prefix_sum = 0\n    prefix_sum_min = 0\n    res = float(\"-inf\")\n\n    for num in nums:\n        prefix_sum += num\n        res = max(res, prefix_sum - prefix_sum_min)\n        prefix_sum_min = min(prefix_sum_min, prefix_sum)\n\n    return res\n\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArrayDP(nums))  # 6\nprint(maxSubArrayGreedy(nums))  # 6\nprint(maxSubArrayPrefixSum(nums))  # 6\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_max_subarray_sum/#2606-find-the-substring-with-maximum-cost","title":"2606. Find the Substring With Maximum Cost","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_max_subarray_sum/#1749-maximum-absolute-sum-of-any-subarray","title":"1749. Maximum Absolute Sum of Any Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_max_subarray_sum/#1191-k-concatenation-maximum-sum","title":"1191. K-Concatenation Maximum Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_max_subarray_sum/#918-maximum-sum-circular-subarray","title":"918. Maximum Sum Circular Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, divide and conquer, dynamic programming, queue, monotonic queue 918. Maximum Sum Circular Subarray - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# DP - Kadane\ndef maxSubarraySumCircularKadane(nums: List[int]) -&gt; int:\n    max_sum = min_sum = nums[0]\n    max_cur = min_cur = 0\n    total = 0\n\n    for num in nums:\n        max_cur = max(max_cur + num, num)\n        min_cur = min(min_cur + num, num)\n        total += num\n\n        max_sum = max(max_sum, max_cur)\n        min_sum = min(min_sum, min_cur)\n\n    return max(max_sum, total - min_sum) if max_sum &gt; 0 else max_sum\n\n\n# Monotonic Queue\ndef maxSubarraySumCircularMQ(nums: List[int]) -&gt; int:\n    n = len(nums)\n    prefix_sum = [0] * (2 * n + 1)\n\n    for i in range(1, 2 * n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + nums[(i - 1) % n]\n\n    q = deque([0])\n    max_sum = float(\"-inf\")\n\n    for i in range(1, 2 * n + 1):\n        if q[0] &lt; i - n:\n            q.popleft()\n\n        max_sum = max(max_sum, prefix_sum[i] - prefix_sum[q[0]])\n\n        while q and prefix_sum[q[-1]] &gt;= prefix_sum[i]:\n            q.pop()\n\n        q.append(i)\n\n    return max_sum\n\n\nnums = [1, -2, 3, -2]\nprint(maxSubarraySumCircularKadane(nums))  # 3\nprint(maxSubarraySumCircularMQ(nums))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_max_subarray_sum/#2321-maximum-score-of-spliced-array","title":"2321. Maximum Score Of Spliced Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_max_subarray_sum/#152-maximum-product-subarray","title":"152. Maximum Product Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming 152. Maximum Product Subarray - Python Solution<pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxProduct(nums: List[int]) -&gt; int:\n    n = len(nums)\n    dp_max = [0 for _ in range(n)]\n    dp_min = [0 for _ in range(n)]\n\n    dp_max[0] = nums[0]\n    dp_min[0] = nums[0]\n    max_product = nums[0]\n\n    for i in range(1, n):\n        dp_max[i] = max(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n        dp_min[i] = min(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n\n        max_product = max(max_product, dp_max[i])\n\n    return max_product\n\n\nnums = [2, 3, -2, 4]\nprint(maxProduct(nums))  # 6\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_monotonic_queue/","title":"DP Monotonic Queue","text":""},{"location":"content/endlesscheng/dp_monotonic_queue/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2944. Minimum Number of Coins for Fruits (Medium)</li> <li> 1696. Jump Game VI (Medium)</li> <li> 1425. Constrained Subsequence Sum (Hard)</li> <li> 375. Guess Number Higher or Lower II (Medium)</li> <li> 1687. Delivering Boxes from Storage to Ports (Hard)</li> <li> 2463. Minimum Total Distance Traveled (Hard)</li> <li> 3117. Minimum Sum of Values by Dividing Array (Hard)</li> <li> 2945. Find Maximum Non-decreasing Array Length (Hard)</li> <li> 2969. Minimum Number of Coins for Fruits II (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/dp_monotonic_queue/#2944-minimum-number-of-coins-for-fruits","title":"2944. Minimum Number of Coins for Fruits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, queue, heap priority queue, monotonic queue</p> </li> </ul>"},{"location":"content/endlesscheng/dp_monotonic_queue/#1696-jump-game-vi","title":"1696. Jump Game VI","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, queue, heap priority queue, monotonic queue</p> </li> </ul>"},{"location":"content/endlesscheng/dp_monotonic_queue/#1425-constrained-subsequence-sum","title":"1425. Constrained Subsequence Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, queue, sliding window, heap priority queue, monotonic queue</p> </li> </ul>"},{"location":"content/endlesscheng/dp_monotonic_queue/#375-guess-number-higher-or-lower-ii","title":"375. Guess Number Higher or Lower II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, game theory</p> </li> </ul>"},{"location":"content/endlesscheng/dp_monotonic_queue/#1687-delivering-boxes-from-storage-to-ports","title":"1687. Delivering Boxes from Storage to Ports","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, segment tree, queue, heap priority queue, prefix sum, monotonic queue</p> </li> </ul>"},{"location":"content/endlesscheng/dp_monotonic_queue/#2463-minimum-total-distance-traveled","title":"2463. Minimum Total Distance Traveled","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/dp_monotonic_queue/#3117-minimum-sum-of-values-by-dividing-array","title":"3117. Minimum Sum of Values by Dividing Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, dynamic programming, bit manipulation, segment tree, queue</p> </li> </ul>"},{"location":"content/endlesscheng/dp_monotonic_queue/#2945-find-maximum-non-decreasing-array-length","title":"2945. Find Maximum Non-decreasing Array Length","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, dynamic programming, stack, queue, monotonic stack, monotonic queue</p> </li> </ul>"},{"location":"content/endlesscheng/dp_monotonic_queue/#2969-minimum-number-of-coins-for-fruits-ii","title":"2969. Minimum Number of Coins for Fruits II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, queue, heap priority queue, monotonic queue</p> </li> </ul>"},{"location":"content/endlesscheng/dp_monotonic_stack/","title":"DP Monotonic Stack","text":""},{"location":"content/endlesscheng/dp_monotonic_stack/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1335. Minimum Difficulty of a Job Schedule (Hard)</li> <li> 2866. Beautiful Towers II (Medium)</li> <li> 2617. Minimum Number of Visited Cells in a Grid (Hard)</li> <li> 2355. Maximum Number of Books You Can Take (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/dp_monotonic_stack/#1335-minimum-difficulty-of-a-job-schedule","title":"1335. Minimum Difficulty of a Job Schedule","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_monotonic_stack/#2866-beautiful-towers-ii","title":"2866. Beautiful Towers II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/dp_monotonic_stack/#2617-minimum-number-of-visited-cells-in-a-grid","title":"2617. Minimum Number of Visited Cells in a Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, stack, breadth first search, union find, heap priority queue, matrix, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/dp_monotonic_stack/#2355-maximum-number-of-books-you-can-take","title":"2355. Maximum Number of Books You Can Take","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, stack, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/","title":"DP Multi-Dimensional","text":""},{"location":"content/endlesscheng/dp_multi-dimensional/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2400. Number of Ways to Reach a Position After Exactly k Steps (Medium)</li> <li> 1824. Minimum Sideway Jumps (Medium)</li> <li> 3332. Maximum Points Tourist Can Earn (Medium)</li> <li> 2370. Longest Ideal Subsequence (Medium)</li> <li> 3176. Find the Maximum Length of a Good Subsequence I (Medium)</li> <li> 1269. Number of Ways to Stay in the Same Place After Some Steps (Hard)</li> <li> 3250. Find the Count of Monotonic Pairs I (Hard)</li> <li> 3218. Minimum Cost for Cutting Cake I (Medium)</li> <li> 3122. Minimum Number of Operations to Satisfy Conditions (Medium)</li> <li> 576. Out of Boundary Paths (Medium)</li> <li> 403. Frog Jump (Hard)</li> <li> 1223. Dice Roll Simulation (Hard)</li> <li> 1320. Minimum Distance to Type a Word Using Two Fingers (Hard)</li> <li> 3366. Minimum Array Sum (Medium)</li> <li> 1575. Count All Possible Routes (Hard)</li> <li> 3154. Find Number of Ways to Reach the K-th Stair (Hard)</li> <li> 2318. Number of Distinct Roll Sequences (Hard)</li> <li> 1444. Number of Ways of Cutting a Pizza (Hard)</li> <li> 3320. Count The Number of Winning Sequences (Hard)</li> <li> 3429. Paint House IV (Medium)</li> <li> 1420. Build Array Where You Can Find The Maximum Exactly K Comparisons (Hard)</li> <li> 3193. Count the Number of Inversions (Hard)</li> <li> 629. K Inverse Pairs Array (Hard)</li> <li> 1079. Letter Tile Possibilities (Medium)</li> <li> 1866. Number of Ways to Rearrange Sticks With K Sticks Visible (Hard)</li> <li> 2312. Selling Pieces of Wood (Hard)</li> <li> 3177. Find the Maximum Length of a Good Subsequence II (Hard)</li> <li> 1884. Egg Drop With 2 Eggs and N Floors (Medium)</li> <li> 887. Super Egg Drop (Hard)</li> <li> 3448. Count Substrings Divisible By Last Digit (Hard)</li> <li> 514. Freedom Trail (Hard)</li> <li> 3336. Find the Number of Subsequences With Equal GCD (Hard)</li> <li> 1388. Pizza With 3n Slices (Hard)</li> <li> 1900. The Earliest and Latest Rounds Where Players Compete (Hard)</li> <li> 1883. Minimum Skips to Arrive at Meeting On Time (Hard)</li> <li> 3343. Count Number of Balanced Permutations (Hard)</li> <li> 3441. Minimum Cost Good Caption (Hard)</li> <li> 3225. Maximum Score From Grid Operations (Hard)</li> <li> 256. Paint House (Medium) \ud83d\udc51</li> <li> 265. Paint House II (Hard) \ud83d\udc51</li> <li> 3339. Find the Number of K-Even Arrays (Medium) \ud83d\udc51</li> <li> 568. Maximum Vacation Days (Hard) \ud83d\udc51</li> <li> 1692. Count Ways to Distribute Candies (Hard) \ud83d\udc51</li> <li> 2143. Choose Numbers From Two Arrays in Range (Hard) \ud83d\udc51</li> <li> 3269. Constructing Two Increasing Arrays (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#2400-number-of-ways-to-reach-a-position-after-exactly-k-steps","title":"2400. Number of Ways to Reach a Position After Exactly k Steps","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, combinatorics</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#1824-minimum-sideway-jumps","title":"1824. Minimum Sideway Jumps","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#3332-maximum-points-tourist-can-earn","title":"3332. Maximum Points Tourist Can Earn","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#2370-longest-ideal-subsequence","title":"2370. Longest Ideal Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#3176-find-the-maximum-length-of-a-good-subsequence-i","title":"3176. Find the Maximum Length of a Good Subsequence I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, dynamic programming 3176. Find the Maximum Length of a Good Subsequence I - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# DP\ndef maximumLength(nums: List[int], k: int) -&gt; int:\n    frequency = defaultdict(lambda: [0 for _ in range(k + 1)])\n    dp = [0 for _ in range(k + 1)]\n\n    for num in nums:\n        f = frequency[num]\n        for j in range(k, -1, -1):\n            f[j] += 1\n            if j &gt; 0:\n                f[j] = max(f[j], dp[j - 1] + 1)\n            dp[j] = max(f[j], dp[j])\n\n    return dp[-1]\n\n\nnums = [1, 2, 1, 1, 3]\nk = 2\nprint(maximumLength(nums, k))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#1269-number-of-ways-to-stay-in-the-same-place-after-some-steps","title":"1269. Number of Ways to Stay in the Same Place After Some Steps","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#3250-find-the-count-of-monotonic-pairs-i","title":"3250. Find the Count of Monotonic Pairs I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, dynamic programming, combinatorics, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#3218-minimum-cost-for-cutting-cake-i","title":"3218. Minimum Cost for Cutting Cake I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#3122-minimum-number-of-operations-to-satisfy-conditions","title":"3122. Minimum Number of Operations to Satisfy Conditions","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#576-out-of-boundary-paths","title":"576. Out of Boundary Paths","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#403-frog-jump","title":"403. Frog Jump","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#1223-dice-roll-simulation","title":"1223. Dice Roll Simulation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#1320-minimum-distance-to-type-a-word-using-two-fingers","title":"1320. Minimum Distance to Type a Word Using Two Fingers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#3366-minimum-array-sum","title":"3366. Minimum Array Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#1575-count-all-possible-routes","title":"1575. Count All Possible Routes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, memoization</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#3154-find-number-of-ways-to-reach-the-k-th-stair","title":"3154. Find Number of Ways to Reach the K-th Stair","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, dynamic programming, bit manipulation, memoization, combinatorics</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#2318-number-of-distinct-roll-sequences","title":"2318. Number of Distinct Roll Sequences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, memoization</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#1444-number-of-ways-of-cutting-a-pizza","title":"1444. Number of Ways of Cutting a Pizza","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, memoization, matrix, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#3320-count-the-number-of-winning-sequences","title":"3320. Count The Number of Winning Sequences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#3429-paint-house-iv","title":"3429. Paint House IV","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#1420-build-array-where-you-can-find-the-maximum-exactly-k-comparisons","title":"1420. Build Array Where You Can Find The Maximum Exactly K Comparisons","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#3193-count-the-number-of-inversions","title":"3193. Count the Number of Inversions","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#629-k-inverse-pairs-array","title":"629. K Inverse Pairs Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#1079-letter-tile-possibilities","title":"1079. Letter Tile Possibilities","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, backtracking, counting</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#1866-number-of-ways-to-rearrange-sticks-with-k-sticks-visible","title":"1866. Number of Ways to Rearrange Sticks With K Sticks Visible","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, dynamic programming, combinatorics</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#2312-selling-pieces-of-wood","title":"2312. Selling Pieces of Wood","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, memoization</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#3177-find-the-maximum-length-of-a-good-subsequence-ii","title":"3177. Find the Maximum Length of a Good Subsequence II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, dynamic programming 3177. Find the Maximum Length of a Good Subsequence II - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# DP\ndef maximumLength(nums: List[int], k: int) -&gt; int:\n    count = [defaultdict(int) for _ in range(k + 1)]\n    result = [0 for _ in range(k + 1)]\n\n    for num in nums:\n        for c in range(k, -1, -1):\n            count[c][num] = (\n                max(count[c][num], result[c - 1] if c &gt; 0 else 0) + 1\n            )\n            result[c] = max(result[c], count[c][num])\n\n    return max(result)\n\n\nnums = [1, 2, 1, 1, 3]\nk = 2\nprint(maximumLength(nums, k))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#1884-egg-drop-with-2-eggs-and-n-floors","title":"1884. Egg Drop With 2 Eggs and N Floors","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#887-super-egg-drop","title":"887. Super Egg Drop","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, binary search, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#3448-count-substrings-divisible-by-last-digit","title":"3448. Count Substrings Divisible By Last Digit","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#514-freedom-trail","title":"514. Freedom Trail","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming, depth first search, breadth first search</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#3336-find-the-number-of-subsequences-with-equal-gcd","title":"3336. Find the Number of Subsequences With Equal GCD","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, dynamic programming, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#1388-pizza-with-3n-slices","title":"1388. Pizza With 3n Slices","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, greedy, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#1900-the-earliest-and-latest-rounds-where-players-compete","title":"1900. The Earliest and Latest Rounds Where Players Compete","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, memoization</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#1883-minimum-skips-to-arrive-at-meeting-on-time","title":"1883. Minimum Skips to Arrive at Meeting On Time","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#3343-count-number-of-balanced-permutations","title":"3343. Count Number of Balanced Permutations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, string, dynamic programming, combinatorics</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#3441-minimum-cost-good-caption","title":"3441. Minimum Cost Good Caption","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#3225-maximum-score-from-grid-operations","title":"3225. Maximum Score From Grid Operations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, matrix, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#256-paint-house","title":"256. Paint House","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#265-paint-house-ii","title":"265. Paint House II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#3339-find-the-number-of-k-even-arrays","title":"3339. Find the Number of K-Even Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#568-maximum-vacation-days","title":"568. Maximum Vacation Days","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#1692-count-ways-to-distribute-candies","title":"1692. Count Ways to Distribute Candies","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#2143-choose-numbers-from-two-arrays-in-range","title":"2143. Choose Numbers From Two Arrays in Range","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multi-dimensional/#3269-constructing-two-increasing-arrays","title":"3269. Constructing Two Increasing Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multiple_knapsack/","title":"DP Multiple Knapsack","text":""},{"location":"content/endlesscheng/dp_multiple_knapsack/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2585. Number of Ways to Earn Points (Hard)</li> <li> 3333. Find the Original Typed String II (Hard)</li> <li> 2902. Count of Sub-Multisets With Bounded Sum (Hard)</li> </ul>"},{"location":"content/endlesscheng/dp_multiple_knapsack/#2585-number-of-ways-to-earn-points","title":"2585. Number of Ways to Earn Points","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multiple_knapsack/#3333-find-the-original-typed-string-ii","title":"3333. Find the Original Typed String II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/dp_multiple_knapsack/#2902-count-of-sub-multisets-with-bounded-sum","title":"2902. Count of Sub-Multisets With Bounded Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, dynamic programming, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/dp_non-overlapping_intervals/","title":"DP Non-Overlapping Intervals","text":""},{"location":"content/endlesscheng/dp_non-overlapping_intervals/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2830. Maximize the Profit as the Salesman (Medium)</li> <li> 2008. Maximum Earnings From Taxi (Medium)</li> <li> 2054. Two Best Non-Overlapping Events (Medium)</li> <li> 1235. Maximum Profit in Job Scheduling (Hard)</li> <li> 1751. Maximum Number of Events That Can Be Attended II (Hard)</li> <li> 3414. Maximum Score of Non-overlapping Intervals (Hard)</li> </ul>"},{"location":"content/endlesscheng/dp_non-overlapping_intervals/#2830-maximize-the-profit-as-the-salesman","title":"2830. Maximize the Profit as the Salesman","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, binary search, dynamic programming, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/dp_non-overlapping_intervals/#2008-maximum-earnings-from-taxi","title":"2008. Maximum Earnings From Taxi","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, binary search, dynamic programming, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/dp_non-overlapping_intervals/#2054-two-best-non-overlapping-events","title":"2054. Two Best Non-Overlapping Events","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, dynamic programming, sorting, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/dp_non-overlapping_intervals/#1235-maximum-profit-in-job-scheduling","title":"1235. Maximum Profit in Job Scheduling","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, dynamic programming, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/dp_non-overlapping_intervals/#1751-maximum-number-of-events-that-can-be-attended-ii","title":"1751. Maximum Number of Events That Can Be Attended II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, dynamic programming, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/dp_non-overlapping_intervals/#3414-maximum-score-of-non-overlapping-intervals","title":"3414. Maximum Score of Non-overlapping Intervals","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, dynamic programming, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/dp_optimal_partitioning/","title":"DP Optimal Partitioning","text":""},{"location":"content/endlesscheng/dp_optimal_partitioning/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 132. Palindrome Partitioning II (Hard)</li> <li> 2707. Extra Characters in a String (Medium)</li> <li> 3196. Maximize Total Cost of Alternating Subarrays (Medium)</li> <li> 2767. Partition String Into Minimum Beautiful Substrings (Medium)</li> <li> 91. Decode Ways (Medium)</li> <li> 639. Decode Ways II (Hard)</li> <li> 1043. Partition Array for Maximum Sum (Medium)</li> <li> 1416. Restore The Array (Hard)</li> <li> 2472. Maximum Number of Non-overlapping Palindrome Substrings (Hard)</li> <li> 1105. Filling Bookcase Shelves (Medium)</li> <li> 2547. Minimum Cost to Split an Array (Hard)</li> <li> 2430. Maximum Deletions on a String (Hard)</li> <li> 2463. Minimum Total Distance Traveled (Hard)</li> <li> 2977. Minimum Cost to Convert String II (Hard)</li> <li> 3441. Minimum Cost Good Caption (Hard)</li> <li> 2052. Minimum Cost to Separate Sentence Into Rows (Medium) \ud83d\udc51</li> <li> 2464. Minimum Subarrays in a Valid Split (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/dp_optimal_partitioning/#132-palindrome-partitioning-ii","title":"132. Palindrome Partitioning II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> <li>\u6559\u4f60\u4e00\u6b65\u6b65\u601d\u8003 DP\uff1a\u4ece\u8bb0\u5fc6\u5316\u641c\u7d22\u5230\u9012\u63a8\uff08Python/Java/C++/Go\uff09</li> </ul> 132. Palindrome Partitioning II - Python Solution<pre><code>from functools import cache\n\n\n# Memoization\ndef minCutMemoization(s: str) -&gt; int:\n    @cache\n    def is_palindrome(left, right):\n        if left &gt;= right:\n            return True\n        return s[left] == s[right] and is_palindrome(left + 1, right - 1)\n\n    @cache\n    def dfs(right):\n        if is_palindrome(0, right):\n            return 0\n        res = float(\"inf\")\n        for left in range(1, right + 1):\n            if is_palindrome(left, right):\n                res = min(res, 1 + dfs(left - 1))\n        return res\n\n    return dfs(len(s) - 1)\n\n\n# Tabulation\ndef minCutTabulation(s: str) -&gt; int:\n    n = len(s)\n    is_palindrome = [[True] * n for _ in range(n)]\n\n    for left in range(n - 2, -1, -1):\n        for right in range(left + 1, n):\n            is_palindrome[left][right] = (\n                s[left] == s[right] and is_palindrome[left + 1][right - 1]\n            )\n\n    dp = [0 for _ in range(n)]\n\n    for right, is_pal in enumerate(is_palindrome[0]):\n        if is_pal:\n            continue\n        res = float(\"inf\")\n        for left in range(1, right + 1):\n            if is_palindrome[left][right]:\n                res = min(res, 1 + dp[left - 1])\n        dp[right] = res\n\n    return dp[-1]\n\n\ns = \"aab\"\nprint(minCutMemoization(s))  # 1\nprint(minCutTabulation(s))  # 1\n</code></pre>"},{"location":"content/endlesscheng/dp_optimal_partitioning/#2707-extra-characters-in-a-string","title":"2707. Extra Characters in a String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, dynamic programming, trie</p> </li> </ul>"},{"location":"content/endlesscheng/dp_optimal_partitioning/#3196-maximize-total-cost-of-alternating-subarrays","title":"3196. Maximize Total Cost of Alternating Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_optimal_partitioning/#2767-partition-string-into-minimum-beautiful-substrings","title":"2767. Partition String Into Minimum Beautiful Substrings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, dynamic programming, backtracking</p> </li> </ul>"},{"location":"content/endlesscheng/dp_optimal_partitioning/#91-decode-ways","title":"91. Decode Ways","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming 91. Decode Ways - Python Solution<pre><code># DP\ndef numDecodingsDP(s: str) -&gt; int:\n    if not s or s[0] == \"0\":\n        return 0\n\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for i in range(1, n + 1):\n        # Check single digit decode\n        if s[i - 1] != \"0\":\n            dp[i] += dp[i - 1]\n\n        # Check two digit decode\n        if i &gt; 1 and \"10\" &lt;= s[i - 2 : i] &lt;= \"26\":\n            dp[i] += dp[i - 2]\n\n    return dp[n]\n\n\n# DFS\ndef numDecodingsDFS(s: str) -&gt; int:\n    memo = {}\n\n    def dfs(i):\n        if i == len(s):\n            return 1\n\n        if s[i] == \"0\":\n            return 0\n\n        if i in memo:\n            return memo[i]\n\n        # Single digit decode\n        ways = dfs(i + 1)\n\n        # Two digits decode\n        if i + 1 &lt; len(s) and \"10\" &lt;= s[i : i + 2] &lt;= \"26\":\n            ways += dfs(i + 2)\n\n        memo[i] = ways\n\n        return ways\n\n    return dfs(0)\n\n\ns = \"226\"\nprint(numDecodingsDP(s))  # 3\nprint(numDecodingsDFS(s))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_optimal_partitioning/#639-decode-ways-ii","title":"639. Decode Ways II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_optimal_partitioning/#1043-partition-array-for-maximum-sum","title":"1043. Partition Array for Maximum Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_optimal_partitioning/#1416-restore-the-array","title":"1416. Restore The Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_optimal_partitioning/#2472-maximum-number-of-non-overlapping-palindrome-substrings","title":"2472. Maximum Number of Non-overlapping Palindrome Substrings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: two pointers, string, dynamic programming, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/dp_optimal_partitioning/#1105-filling-bookcase-shelves","title":"1105. Filling Bookcase Shelves","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_optimal_partitioning/#2547-minimum-cost-to-split-an-array","title":"2547. Minimum Cost to Split an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, dynamic programming, counting</p> </li> </ul>"},{"location":"content/endlesscheng/dp_optimal_partitioning/#2430-maximum-deletions-on-a-string","title":"2430. Maximum Deletions on a String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming, rolling hash, string matching, hash function</p> </li> </ul>"},{"location":"content/endlesscheng/dp_optimal_partitioning/#2463-minimum-total-distance-traveled","title":"2463. Minimum Total Distance Traveled","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/dp_optimal_partitioning/#2977-minimum-cost-to-convert-string-ii","title":"2977. Minimum Cost to Convert String II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, dynamic programming, graph, trie, shortest path</p> </li> </ul>"},{"location":"content/endlesscheng/dp_optimal_partitioning/#3441-minimum-cost-good-caption","title":"3441. Minimum Cost Good Caption","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_optimal_partitioning/#2052-minimum-cost-to-separate-sentence-into-rows","title":"2052. Minimum Cost to Separate Sentence Into Rows","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_optimal_partitioning/#2464-minimum-subarrays-in-a-valid-split","title":"2464. Minimum Subarrays in a Valid Split","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, dynamic programming, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_dp/","title":"DP Other DP","text":""},{"location":"content/endlesscheng/dp_other_dp/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1387. Sort Integers by The Power Value (Medium)</li> <li> 823. Binary Trees With Factors (Medium)</li> <li> 940. Distinct Subsequences II (Hard)</li> <li> 135. Candy (Hard)</li> <li> 650. 2 Keys Keyboard (Medium)</li> <li> 638. Shopping Offers (Medium)</li> <li> 467. Unique Substrings in Wraparound String (Medium)</li> <li> 2262. Total Appeal of A String (Hard)</li> <li> 828. Count Unique Characters of All Substrings of a Given String (Hard)</li> <li> 2746. Decremental String Concatenation (Medium)</li> <li> 2930. Number of Strings Which Can Be Rearranged to Contain Substring (Medium)</li> <li> 1569. Number of Ways to Reorder Array to Get Same BST (Hard)</li> <li> 818. Race Car (Hard)</li> <li> 920. Number of Music Playlists (Hard)</li> <li> 1388. Pizza With 3n Slices (Hard)</li> <li> 1987. Number of Unique Good Subsequences (Hard)</li> <li> 903. Valid Permutations for DI Sequence (Hard)</li> <li> 1896. Minimum Cost to Change the Final Value of Expression (Hard)</li> <li> 1531. String Compression II (Hard)</li> <li> 964. Least Operators to Express Number (Hard)</li> <li> 1787. Make the XOR of All Segments Equal to Zero (Hard)</li> <li> 2060. Check if an Original String Exists Given Two Encoded Strings (Hard)</li> <li> 2809. Minimum Time to Make Array Sum At Most x (Hard)</li> <li> 3299. Sum of Consecutive Subsequences (Hard) \ud83d\udc51</li> <li> 2189. Number of Ways to Build House of Cards (Medium) \ud83d\udc51</li> <li> 2597. The Number of Beautiful Subsets (Medium)</li> <li> 2638. Count the Number of K-Free Subsets (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/dp_other_dp/#1387-sort-integers-by-the-power-value","title":"1387. Sort Integers by The Power Value","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming, memoization, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_dp/#823-binary-trees-with-factors","title":"823. Binary Trees With Factors","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, dynamic programming, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_dp/#940-distinct-subsequences-ii","title":"940. Distinct Subsequences II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_dp/#135-candy","title":"135. Candy","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy</p> </li> <li>Return the minimum number of candies you must give.</li> </ul> 135. Candy - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef candy(ratings: List[int]) -&gt; int:\n    # TC: O(n)\n    # SC: O(n)\n    n = len(ratings)\n\n    if n &lt;= 1:\n        return n\n\n    candy = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        if ratings[i] &gt; ratings[i - 1]:\n            candy[i] = candy[i - 1] + 1\n\n    for j in range(n - 2, -1, -1):\n        if ratings[j] &gt; ratings[j + 1]:\n            candy[j] = max(candy[j], candy[j + 1] + 1)\n\n    return sum(candy)\n\n\nratings = [1, 0, 2]\nprint(candy(ratings))  # 5\n</code></pre>"},{"location":"content/endlesscheng/dp_other_dp/#650-2-keys-keyboard","title":"650. 2 Keys Keyboard","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_dp/#638-shopping-offers","title":"638. Shopping Offers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, backtracking, bit manipulation, memoization, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_dp/#467-unique-substrings-in-wraparound-string","title":"467. Unique Substrings in Wraparound String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_dp/#2262-total-appeal-of-a-string","title":"2262. Total Appeal of A String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_dp/#828-count-unique-characters-of-all-substrings-of-a-given-string","title":"828. Count Unique Characters of All Substrings of a Given String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_dp/#2746-decremental-string-concatenation","title":"2746. Decremental String Concatenation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_dp/#2930-number-of-strings-which-can-be-rearranged-to-contain-substring","title":"2930. Number of Strings Which Can Be Rearranged to Contain Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, combinatorics</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_dp/#1569-number-of-ways-to-reorder-array-to-get-same-bst","title":"1569. Number of Ways to Reorder Array to Get Same BST","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, divide and conquer, dynamic programming, tree, union find, binary search tree, memoization, combinatorics, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_dp/#818-race-car","title":"818. Race Car","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_dp/#920-number-of-music-playlists","title":"920. Number of Music Playlists","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, dynamic programming, combinatorics</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_dp/#1388-pizza-with-3n-slices","title":"1388. Pizza With 3n Slices","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, greedy, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_dp/#1987-number-of-unique-good-subsequences","title":"1987. Number of Unique Good Subsequences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_dp/#903-valid-permutations-for-di-sequence","title":"903. Valid Permutations for DI Sequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_dp/#1896-minimum-cost-to-change-the-final-value-of-expression","title":"1896. Minimum Cost to Change the Final Value of Expression","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, string, dynamic programming, stack</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_dp/#1531-string-compression-ii","title":"1531. String Compression II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_dp/#964-least-operators-to-express-number","title":"964. Least Operators to Express Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, dynamic programming, memoization</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_dp/#1787-make-the-xor-of-all-segments-equal-to-zero","title":"1787. Make the XOR of All Segments Equal to Zero","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_dp/#2060-check-if-an-original-string-exists-given-two-encoded-strings","title":"2060. Check if an Original String Exists Given Two Encoded Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_dp/#2809-minimum-time-to-make-array-sum-at-most-x","title":"2809. Minimum Time to Make Array Sum At Most x","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_dp/#3299-sum-of-consecutive-subsequences","title":"3299. Sum of Consecutive Subsequences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_dp/#2189-number-of-ways-to-build-house-of-cards","title":"2189. Number of Ways to Build House of Cards","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_dp/#2597-the-number-of-beautiful-subsets","title":"2597. The Number of Beautiful Subsets","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, dynamic programming, backtracking, sorting, combinatorics 2597. The Number of Beautiful Subsets - C++ Solution<pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Solution {\n   public:\n    int beautifulSubsets(vector&lt;int&gt;&amp; nums, int k) {\n        int res = 0;\n        unordered_map&lt;int, int&gt; cnt;\n\n        auto dfs = [&amp;](auto&amp;&amp; self, int i) -&gt; void {\n            if (i == (int)nums.size()) {\n                res++;\n                return;\n            }\n            self(self, i + 1);  // Skip nums[i]\n            int x = nums[i];\n            if (cnt[x - k] == 0 &amp;&amp; cnt[x + k] == 0) {\n                cnt[x]++;\n                self(self, i + 1);  // Include nums[i]\n                cnt[x]--;           // Backtrack\n            }\n        };\n\n        dfs(dfs, 0);\n\n        return res - 1;\n    }\n};\n\nint main() {\n    Solution sol;\n    vector&lt;int&gt; nums = {1, 2, 3, 4};\n    int k = 1;\n    cout &lt;&lt; sol.beautifulSubsets(nums, k) &lt;&lt; endl;\n    return 0;\n}\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_dp/#2638-count-the-number-of-k-free-subsets","title":"2638. Count the Number of K-Free Subsets","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, dynamic programming, sorting, combinatorics</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_interval_dp/","title":"DP Other Interval DP","text":""},{"location":"content/endlesscheng/dp_other_interval_dp/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 5. Longest Palindromic Substring (Medium)</li> <li> 647. Palindromic Substrings (Medium)</li> <li> 3040. Maximum Number of Operations With the Same Score II (Medium)</li> <li> 375. Guess Number Higher or Lower II (Medium)</li> <li> 1130. Minimum Cost Tree From Leaf Values (Medium)</li> <li> 96. Unique Binary Search Trees (Medium)</li> <li> 1770. Maximum Score from Performing Multiplication Operations (Hard)</li> <li> 1547. Minimum Cost to Cut a Stick (Hard)</li> <li> 1039. Minimum Score Triangulation of Polygon (Medium)</li> <li> 1000. Minimum Cost to Merge Stones (Hard)</li> <li> 2019. The Score of Students Solving Math Expression (Hard)</li> <li> 3277. Maximum XOR Score Subarray Queries (Hard)</li> <li> 87. Scramble String (Hard)</li> <li> 312. Burst Balloons (Hard)</li> <li> 664. Strange Printer (Hard)</li> <li> 546. Remove Boxes (Hard)</li> <li> 471. Encode String with Shortest Length (Hard) \ud83d\udc51</li> <li> 3018. Maximum Number of Removal Queries That Can Be Processed I (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/dp_other_interval_dp/#5-longest-palindromic-substring","title":"5. Longest Palindromic Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string, dynamic programming</p> </li> <li>Return the longest palindromic substring in <code>s</code>.</li> </ul> 5. Longest Palindromic Substring - Python Solution<pre><code># DP - Interval\ndef longestPalindromeDP(s: str) -&gt; str:\n    n = len(s)\n    if n &lt;= 1:\n        return s\n\n    start, maxLen = 0, 1\n\n    # Init\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for j in range(1, n):\n        for i in range(j):\n            if s[i] == s[j]:\n                if j - i &lt;= 2:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1]\n\n                if dp[i][j] and j - i + 1 &gt; maxLen:\n                    maxLen = j - i + 1\n                    start = i\n\n    return s[start : start + maxLen]\n\n\n# Expand Around Center\ndef longestPalindromeCenter(s: str) -&gt; str:\n    def expand_around_center(left, right):\n        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n\n    if len(s) &lt;= 1:\n        return s\n\n    start, end = 0, 0\n    for i in range(len(s)):\n        len1 = expand_around_center(i, i)  # odd\n        len2 = expand_around_center(i, i + 1)  # even\n\n        maxLen = max(len1, len2)\n        if maxLen &gt; end - start:\n            start = i - (maxLen - 1) // 2\n            end = i + maxLen // 2\n\n    return s[start : end + 1]\n\n\ns = \"babad\"\nprint(longestPalindromeDP(s))  # \"bab\"\nprint(longestPalindromeCenter(s))  # \"aba\"\n</code></pre>"},{"location":"content/endlesscheng/dp_other_interval_dp/#647-palindromic-substrings","title":"647. Palindromic Substrings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string, dynamic programming</p> </li> <li>Return the number of palindromic substrings in <code>s</code>.</li> <li>Bottom-up DP table</li> </ul> dp a b b a e a 1 0 0 1 0 b 0 1 1 0 0 b 0 0 1 0 0 a 0 0 0 1 0 e 0 0 0 0 1 647. Palindromic Substrings - Python Solution<pre><code>def countSubstrings(s: str) -&gt; int:\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    res = 0\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i, n):\n            if s[i] == s[j]:\n                if j - i &lt;= 1:\n                    dp[i][j] = 1\n                    res += 1\n                elif dp[i + 1][j - 1]:\n                    dp[i][j] = 1\n                    res += 1\n\n    return res\n\n\nprint(countSubstrings(\"abbae\"))  # 7\n</code></pre>"},{"location":"content/endlesscheng/dp_other_interval_dp/#3040-maximum-number-of-operations-with-the-same-score-ii","title":"3040. Maximum Number of Operations With the Same Score II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, memoization</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_interval_dp/#375-guess-number-higher-or-lower-ii","title":"375. Guess Number Higher or Lower II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, game theory</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_interval_dp/#1130-minimum-cost-tree-from-leaf-values","title":"1130. Minimum Cost Tree From Leaf Values","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, stack, greedy, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_interval_dp/#96-unique-binary-search-trees","title":"96. Unique Binary Search Trees","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, tree, binary search tree, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_interval_dp/#1770-maximum-score-from-performing-multiplication-operations","title":"1770. Maximum Score from Performing Multiplication Operations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_interval_dp/#1547-minimum-cost-to-cut-a-stick","title":"1547. Minimum Cost to Cut a Stick","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_interval_dp/#1039-minimum-score-triangulation-of-polygon","title":"1039. Minimum Score Triangulation of Polygon","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_interval_dp/#1000-minimum-cost-to-merge-stones","title":"1000. Minimum Cost to Merge Stones","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_interval_dp/#2019-the-score-of-students-solving-math-expression","title":"2019. The Score of Students Solving Math Expression","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, string, dynamic programming, stack, memoization</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_interval_dp/#3277-maximum-xor-score-subarray-queries","title":"3277. Maximum XOR Score Subarray Queries","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_interval_dp/#87-scramble-string","title":"87. Scramble String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_interval_dp/#312-burst-balloons","title":"312. Burst Balloons","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_interval_dp/#664-strange-printer","title":"664. Strange Printer","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_interval_dp/#546-remove-boxes","title":"546. Remove Boxes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, memoization</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_interval_dp/#471-encode-string-with-shortest-length","title":"471. Encode String with Shortest Length","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_interval_dp/#3018-maximum-number-of-removal-queries-that-can-be-processed-i","title":"3018. Maximum Number of Removal Queries That Can Be Processed I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_optimized/","title":"DP Other Optimized","text":""},{"location":"content/endlesscheng/dp_other_optimized/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1937. Maximum Number of Points with Cost (Medium)</li> <li> 2713. Maximum Strictly Increasing Cells in a Matrix (Hard)</li> <li> 3181. Maximum Total Reward Using Operations II (Hard)</li> <li> 2267.  Check if There Is a Valid Parentheses String Path (Hard)</li> <li> 3213. Construct String with Minimum Cost (Hard)</li> <li> 3292. Minimum Number of Valid Strings to Form Target II (Hard)</li> <li> 2263. Make Array Non-decreasing or Non-increasing (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/dp_other_optimized/#1937-maximum-number-of-points-with-cost","title":"1937. Maximum Number of Points with Cost","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_optimized/#2713-maximum-strictly-increasing-cells-in-a-matrix","title":"2713. Maximum Strictly Increasing Cells in a Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, binary search, dynamic programming, memoization, sorting, matrix, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_optimized/#3181-maximum-total-reward-using-operations-ii","title":"3181. Maximum Total Reward Using Operations II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_optimized/#2267-check-if-there-is-a-valid-parentheses-string-path","title":"2267.  Check if There Is a Valid Parentheses String Path","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_optimized/#3213-construct-string-with-minimum-cost","title":"3213. Construct String with Minimum Cost","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, dynamic programming, suffix array</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_optimized/#3292-minimum-number-of-valid-strings-to-form-target-ii","title":"3292. Minimum Number of Valid Strings to Form Target II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, binary search, dynamic programming, segment tree, rolling hash, string matching, hash function</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_optimized/#2263-make-array-non-decreasing-or-non-increasing","title":"2263. Make Array Non-decreasing or Non-increasing","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_state_compression/","title":"DP Other State Compression","text":""},{"location":"content/endlesscheng/dp_other_state_compression/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 698. Partition to K Equal Sum Subsets (Medium)</li> <li> 1411. Number of Ways to Paint N \u00d7 3 Grid (Hard)</li> <li> 2002. Maximum Product of the Length of Two Palindromic Subsequences (Medium)</li> <li> 473. Matchsticks to Square (Medium)</li> <li> 1931. Painting a Grid With Three Different Colors (Hard)</li> <li> 1125. Smallest Sufficient Team (Hard)</li> <li> 1434. Number of Ways to Wear Different Hats to Each Other (Hard)</li> <li> 464. Can I Win (Medium)</li> <li> 691. Stickers to Spell Word (Hard)</li> <li> 3276. Select Cells in Grid With Maximum Score (Hard)</li> <li> 1595. Minimum Cost to Connect Two Groups of Points (Hard)</li> <li> 1815. Maximum Number of Groups Getting Fresh Donuts (Hard)</li> <li> 1659. Maximize Grid Happiness (Hard)</li> <li> 351. Android Unlock Patterns (Medium) \ud83d\udc51</li> <li> 2184. Number of Ways to Build Sturdy Brick Wall (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/dp_other_state_compression/#698-partition-to-k-equal-sum-subsets","title":"698. Partition to K Equal Sum Subsets","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, backtracking, bit manipulation, memoization, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_state_compression/#1411-number-of-ways-to-paint-n-3-grid","title":"1411. Number of Ways to Paint N \u00d7 3 Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_state_compression/#2002-maximum-product-of-the-length-of-two-palindromic-subsequences","title":"2002. Maximum Product of the Length of Two Palindromic Subsequences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming, backtracking, bit manipulation, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_state_compression/#473-matchsticks-to-square","title":"473. Matchsticks to Square","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, backtracking, bit manipulation, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_state_compression/#1931-painting-a-grid-with-three-different-colors","title":"1931. Painting a Grid With Three Different Colors","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_state_compression/#1125-smallest-sufficient-team","title":"1125. Smallest Sufficient Team","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, bit manipulation, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_state_compression/#1434-number-of-ways-to-wear-different-hats-to-each-other","title":"1434. Number of Ways to Wear Different Hats to Each Other","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, bit manipulation, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_state_compression/#464-can-i-win","title":"464. Can I Win","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, bit manipulation, memoization, game theory, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_state_compression/#691-stickers-to-spell-word","title":"691. Stickers to Spell Word","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, string, dynamic programming, backtracking, bit manipulation, memoization, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_state_compression/#3276-select-cells-in-grid-with-maximum-score","title":"3276. Select Cells in Grid With Maximum Score","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, bit manipulation, matrix, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_state_compression/#1595-minimum-cost-to-connect-two-groups-of-points","title":"1595. Minimum Cost to Connect Two Groups of Points","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, bit manipulation, matrix, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_state_compression/#1815-maximum-number-of-groups-getting-fresh-donuts","title":"1815. Maximum Number of Groups Getting Fresh Donuts","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, bit manipulation, memoization, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_state_compression/#1659-maximize-grid-happiness","title":"1659. Maximize Grid Happiness","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, bit manipulation, memoization, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_state_compression/#351-android-unlock-patterns","title":"351. Android Unlock Patterns","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming, backtracking, bit manipulation, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_other_state_compression/#2184-number-of-ways-to-build-sturdy-brick-wall","title":"2184. Number of Ways to Build Sturdy Brick Wall","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, bit manipulation, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_partitioning_feasibility/","title":"DP Partitioning Feasibility","text":""},{"location":"content/endlesscheng/dp_partitioning_feasibility/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2369. Check if There is a Valid Partition For The Array (Medium)</li> <li> 139. Word Break (Medium)</li> </ul>"},{"location":"content/endlesscheng/dp_partitioning_feasibility/#2369-check-if-there-is-a-valid-partition-for-the-array","title":"2369. Check if There is a Valid Partition For The Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_partitioning_feasibility/#139-word-break","title":"139. Word Break","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, dynamic programming, trie, memoization 139. Word Break - Python Solution<pre><code>from typing import List\n\n\n# DP (Unbounded Knapsack)\ndef wordBreak(s: str, wordDict: List[str]) -&gt; bool:\n    n = len(s)\n    dp = [False for _ in range(n + 1)]\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for word in wordDict:\n            m = len(word)\n            if s[i - m : i] == word and dp[i - m]:\n                dp[i] = True\n    return dp[-1]\n\n\ns = \"leetcode\"\nwordDict = [\"leet\", \"code\"]\nprint(wordBreak(s, wordDict))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_permutation_type_adjacent_related/","title":"DP Permutation Type Adjacent Related","text":""},{"location":"content/endlesscheng/dp_permutation_type_adjacent_related/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 996. Number of Squareful Arrays (Hard)</li> <li> 2741. Special Permutations (Medium)</li> <li> 1681. Minimum Incompatibility (Hard)</li> <li> 3283. Maximum Number of Moves to Kill All Pawns (Hard)</li> <li> 3149. Find the Minimum Cost Array Permutation (Hard)</li> </ul>"},{"location":"content/endlesscheng/dp_permutation_type_adjacent_related/#996-number-of-squareful-arrays","title":"996. Number of Squareful Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, math, dynamic programming, backtracking, bit manipulation, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_permutation_type_adjacent_related/#2741-special-permutations","title":"2741. Special Permutations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, bit manipulation, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_permutation_type_adjacent_related/#1681-minimum-incompatibility","title":"1681. Minimum Incompatibility","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, bit manipulation, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_permutation_type_adjacent_related/#3283-maximum-number-of-moves-to-kill-all-pawns","title":"3283. Maximum Number of Moves to Kill All Pawns","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, bit manipulation, breadth first search, game theory, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_permutation_type_adjacent_related/#3149-find-the-minimum-cost-array-permutation","title":"3149. Find the Minimum Cost Array Permutation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, bit manipulation, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_permutation_type_adjacent_unrelated/","title":"DP Permutation Type Adjacent Unrelated","text":""},{"location":"content/endlesscheng/dp_permutation_type_adjacent_unrelated/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 526. Beautiful Arrangement (Medium)</li> <li> 3376. Minimum Time to Break Locks I (Medium)</li> <li> 1879. Minimum XOR Sum of Two Arrays (Hard)</li> <li> 2850. Minimum Moves to Spread Stones Over Grid (Medium)</li> <li> 1947. Maximum Compatibility Score Sum (Medium)</li> <li> 1799. Maximize Score After N Operations (Hard)</li> <li> 2172. Maximum AND Sum of Array (Hard)</li> <li> 2992. Number of Self-Divisible Permutations (Medium) \ud83d\udc51</li> <li> 2403. Minimum Time to Kill All Monsters (Hard) \ud83d\udc51</li> <li> 1066. Campus Bikes II (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/dp_permutation_type_adjacent_unrelated/#526-beautiful-arrangement","title":"526. Beautiful Arrangement","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, backtracking, bit manipulation, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_permutation_type_adjacent_unrelated/#3376-minimum-time-to-break-locks-i","title":"3376. Minimum Time to Break Locks I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, backtracking, bit manipulation, depth first search, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_permutation_type_adjacent_unrelated/#1879-minimum-xor-sum-of-two-arrays","title":"1879. Minimum XOR Sum of Two Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, bit manipulation, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_permutation_type_adjacent_unrelated/#2850-minimum-moves-to-spread-stones-over-grid","title":"2850. Minimum Moves to Spread Stones Over Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, breadth first search, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/dp_permutation_type_adjacent_unrelated/#1947-maximum-compatibility-score-sum","title":"1947. Maximum Compatibility Score Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, backtracking, bit manipulation, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_permutation_type_adjacent_unrelated/#1799-maximize-score-after-n-operations","title":"1799. Maximize Score After N Operations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, dynamic programming, backtracking, bit manipulation, number theory, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_permutation_type_adjacent_unrelated/#2172-maximum-and-sum-of-array","title":"2172. Maximum AND Sum of Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, bit manipulation, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_permutation_type_adjacent_unrelated/#2992-number-of-self-divisible-permutations","title":"2992. Number of Self-Divisible Permutations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, backtracking, bit manipulation, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_permutation_type_adjacent_unrelated/#2403-minimum-time-to-kill-all-monsters","title":"2403. Minimum Time to Kill All Monsters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, bit manipulation, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_permutation_type_adjacent_unrelated/#1066-campus-bikes-ii","title":"1066. Campus Bikes II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, backtracking, bit manipulation, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/","title":"DP Prefix and Suffix Decomposition","text":""},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 724. Find Pivot Index (Easy)</li> <li> 1991. Find the Middle Index in Array (Easy)</li> <li> 2270. Number of Ways to Split Array (Medium)</li> <li> 2256. Minimum Average Difference (Medium)</li> <li> 1422. Maximum Score After Splitting a String (Easy)</li> <li> 1493. Longest Subarray of 1's After Deleting One Element (Medium)</li> <li> 845. Longest Mountain in Array (Medium)</li> <li> 2012. Sum of Beauty in the Array (Medium)</li> <li> 2909. Minimum Sum of Mountain Triplets II (Medium)</li> <li> 2483. Minimum Penalty for a Shop (Medium)</li> <li> 1525. Number of Good Ways to Split a String (Medium)</li> <li> 3354. Make Array Elements Equal to Zero (Easy)</li> <li> 2874. Maximum Value of an Ordered Triplet II (Medium)</li> <li> 123. Best Time to Buy and Sell Stock III (Hard)</li> <li> 2222. Number of Ways to Select Buildings (Medium)</li> <li> 1031. Maximum Sum of Two Non-Overlapping Subarrays (Medium)</li> <li> 689. Maximum Sum of 3 Non-Overlapping Subarrays (Hard)</li> <li> 2420. Find All Good Indices (Medium)</li> <li> 2100. Find Good Days to Rob the Bank (Medium)</li> <li> 926. Flip String to Monotone Increasing (Medium)</li> <li> 334. Increasing Triplet Subsequence (Medium)</li> <li> 2712. Minimum Cost to Make All Characters Equal (Medium)</li> <li> 1653. Minimum Deletions to Make String Balanced (Medium)</li> <li> 1186. Maximum Subarray Sum with One Deletion (Medium)</li> <li> 42. Trapping Rain Water (Hard)</li> <li> 2711. Difference of Number of Distinct Values on Diagonals (Medium)</li> <li> 1477. Find Two Non-overlapping Sub-arrays Each With Target Sum (Medium)</li> <li> 2680. Maximum OR (Medium)</li> <li> 1671. Minimum Number of Removals to Make Mountain Array (Hard)</li> <li> 1888. Minimum Number of Flips to Make the Binary String Alternating (Medium)</li> <li> 238. Product of Array Except Self (Medium)</li> <li> 2906. Construct Product Matrix (Medium)</li> <li> 3334. Find the Maximum Factor Score of Array (Medium)</li> <li> 2167. Minimum Time to Remove All Cars Containing Illegal Goods (Hard)</li> <li> 2484. Count Palindromic Subsequences (Hard)</li> <li> 2163. Minimum Difference in Sums After Removal of Elements (Hard)</li> <li> 2565. Subsequence With the Minimum Score (Hard)</li> <li> 1995. Count Special Quadruplets (Easy)</li> <li> 2552. Count Increasing Quadruplets (Hard)</li> <li> 3302. Find the Lexicographically Smallest Valid Sequence (Medium)</li> <li> 3404. Count Special Subsequences (Medium)</li> <li> 3303. Find the Occurrence of First Almost Equal Substring (Hard)</li> <li> 3287. Find the Maximum Sequence Value of Array (Hard)</li> <li> 3257. Maximum Value Sum by Placing Three Rooks II (Hard)</li> <li> 3410. Maximize Subarray Sum After Removing All Occurrences of One Element (Hard)</li> <li> 3003. Maximize the Number of Partitions After Operations (Hard)</li> <li> 487. Max Consecutive Ones II (Medium) \ud83d\udc51</li> <li> 1746. Maximum Subarray Sum After One Operation (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#724-find-pivot-index","title":"724. Find Pivot Index","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#1991-find-the-middle-index-in-array","title":"1991. Find the Middle Index in Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#2270-number-of-ways-to-split-array","title":"2270. Number of Ways to Split Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#2256-minimum-average-difference","title":"2256. Minimum Average Difference","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#1422-maximum-score-after-splitting-a-string","title":"1422. Maximum Score After Splitting a String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#1493-longest-subarray-of-1s-after-deleting-one-element","title":"1493. Longest Subarray of 1's After Deleting One Element","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, sliding window 1493. Longest Subarray of 1's After Deleting One Element - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window Variable Max\ndef longestSubarray(nums: List[int]) -&gt; int:\n    zeroCount = 0\n    res = 0\n    left = 0\n\n    for right in range(len(nums)):\n        if nums[right] == 0:\n            zeroCount += 1\n\n        while zeroCount &gt; 1:\n            if nums[left] == 0:\n                zeroCount -= 1\n            left += 1\n\n        res = max(res, right - left)\n\n    return res\n\n\nnums = [1, 1, 0, 1]\nprint(longestSubarray(nums))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#845-longest-mountain-in-array","title":"845. Longest Mountain in Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, dynamic programming, enumeration 845. Longest Mountain in Array - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef longestMountain(arr: List[int]) -&gt; int:\n    n = len(arr)\n    res = 0\n    left = 0\n\n    while left &lt; n:\n        right = left\n\n        if right &lt; n - 1 and arr[right] &lt; arr[right + 1]:\n            while right &lt; n - 1 and arr[right] &lt; arr[right + 1]:\n                right += 1\n\n            if right &lt; n - 1 and arr[right] &gt; arr[right + 1]:\n                while right &lt; n - 1 and arr[right] &gt; arr[right + 1]:\n                    right += 1\n                res = max(res, right - left + 1)\n\n        left = max(right, left + 1)\n\n    return res\n\n\narr = [2, 1, 4, 7, 3, 2, 5]\nprint(longestMountain(arr))  # 5\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#2012-sum-of-beauty-in-the-array","title":"2012. Sum of Beauty in the Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array 2012. Sum of Beauty in the Array - Python Solution<pre><code>from typing import List\n\n\n# DP Prefix and Suffix Decomposition\ndef sumOfBeauties(nums: List[int]) -&gt; int:\n    n = len(nums)\n    suf_min = [0] * n\n    suf_min[n - 1] = nums[n - 1]\n    for i in range(n - 2, 1, -1):\n        suf_min[i] = min(suf_min[i + 1], nums[i])\n\n    res = 0\n    pre_max = nums[0]\n    for i in range(1, n - 1):\n        x = nums[i]\n        if pre_max &lt; x &lt; suf_min[i + 1]:\n            res += 2\n        elif nums[i - 1] &lt; x &lt; nums[i + 1]:\n            res += 1\n        pre_max = max(pre_max, x)\n\n    return res\n\n\nnums = [2, 4, 6, 4, 5]\nprint(sumOfBeauties(nums))  # 1\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#2909-minimum-sum-of-mountain-triplets-ii","title":"2909. Minimum Sum of Mountain Triplets II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#2483-minimum-penalty-for-a-shop","title":"2483. Minimum Penalty for a Shop","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#1525-number-of-good-ways-to-split-a-string","title":"1525. Number of Good Ways to Split a String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, dynamic programming, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#3354-make-array-elements-equal-to-zero","title":"3354. Make Array Elements Equal to Zero","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, simulation, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#2874-maximum-value-of-an-ordered-triplet-ii","title":"2874. Maximum Value of an Ordered Triplet II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array 2874. Maximum Value of an Ordered Triplet II - Python Solution<pre><code>from typing import List\n\n\ndef maximumTripletValue(nums: List[int]) -&gt; int:\n    res = 0\n    max_diff = 0\n    max_prev = 0\n\n    for num in nums:\n        res = max(res, max_diff * num)\n        max_diff = max(max_diff, max_prev - num)\n        max_prev = max(max_prev, num)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    nums = [12, 6, 1, 2, 7]\n    print(maximumTripletValue(nums))  # 77\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#123-best-time-to-buy-and-sell-stock-iii","title":"123. Best Time to Buy and Sell Stock III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming 123. Best Time to Buy and Sell Stock III - Python Solution<pre><code>from typing import List\n\n\n# 1. DP\ndef maxProfitDP1(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 5 for _ in range(n)]\n\n    dp[0][0] = 0  # no transaction\n    dp[0][1] = -prices[0]  # buy 1\n    dp[0][2] = 0  # sell 1\n    dp[0][3] = -prices[0]  # buy 2\n    dp[0][4] = 0  # sell 2\n\n    for i in range(1, n):\n        dp[i][0] = dp[i - 1][0]\n        dp[i][1] = max(dp[i - 1][1], -prices[i])\n        dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i])\n        dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i])\n        dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i])\n\n    return dp[-1][4]\n\n\n# 2. DP - Optimized\ndef maxProfitDP2(prices: List[int]) -&gt; int:\n    b1, b2 = float(\"inf\"), float(\"inf\")\n    s1, s2 = 0, 0\n\n    for price in prices:\n        b1 = min(b1, price)\n        s1 = max(s1, price - b1)\n        b2 = min(b2, price - s1)\n        s2 = max(s2, price - b2)\n\n    return s2\n\n\nprices = [3, 3, 5, 0, 0, 3, 1, 4]\nprint(maxProfitDP1(prices))  # 6\nprint(maxProfitDP2(prices))  # 6\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#2222-number-of-ways-to-select-buildings","title":"2222. Number of Ways to Select Buildings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#1031-maximum-sum-of-two-non-overlapping-subarrays","title":"1031. Maximum Sum of Two Non-Overlapping Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#689-maximum-sum-of-3-non-overlapping-subarrays","title":"689. Maximum Sum of 3 Non-Overlapping Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#2420-find-all-good-indices","title":"2420. Find All Good Indices","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#2100-find-good-days-to-rob-the-bank","title":"2100. Find Good Days to Rob the Bank","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#926-flip-string-to-monotone-increasing","title":"926. Flip String to Monotone Increasing","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#334-increasing-triplet-subsequence","title":"334. Increasing Triplet Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#2712-minimum-cost-to-make-all-characters-equal","title":"2712. Minimum Cost to Make All Characters Equal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming, greedy 2712. Minimum Cost to Make All Characters Equal - Python Solution<pre><code>def minimumCost(s: str) -&gt; int:\n    n = len(s)\n    res = 0\n    for i in range(1, n):\n        if s[i - 1] != s[i]:\n            res += min(i, n - i)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    s = \"0011\"\n    print(minimumCost(s))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#1653-minimum-deletions-to-make-string-balanced","title":"1653. Minimum Deletions to Make String Balanced","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming, stack</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#1186-maximum-subarray-sum-with-one-deletion","title":"1186. Maximum Subarray Sum with One Deletion","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li>\u7075\u795e\uff1a\u6559\u4f60\u4e00\u6b65\u6b65\u601d\u8003\u52a8\u6001\u89c4\u5212 - \u4ece\u8bb0\u5fc6\u5316\u641c\u7d22\u5230\u9012\u63a8)</li> </ul> 1186. Maximum Subarray Sum with One Deletion - Python Solution<pre><code>from functools import cache\nfrom math import inf\nfrom typing import List\n\n\n# DP - Kadane\ndef maximumSum(arr: List[int]) -&gt; int:\n    dp0 = arr[0]\n    dp1 = 0\n    res = dp0\n\n    for i in range(1, len(arr)):\n        dp1 = max(dp1 + arr[i], dp0)  # delete previous element or not\n        dp0 = max(dp0, 0) + arr[i]  # delete current element or not\n        res = max(res, dp0, dp1)  # update result\n\n    return res\n\n\n# DP - Memoization\ndef maximumSumMemo(arr: List[int]) -&gt; int:\n    @cache\n    def dfs(i: int, j: int) -&gt; int:\n        if i &lt; 0:\n            return -inf\n        if j == 0:\n            return max(dfs(i - 1, 0), 0) + arr[i]\n        return max(dfs(i - 1, 1) + arr[i], dfs(i - 1, 0))\n\n    return max(max(dfs(i, 0), dfs(i, 1)) for i in range(len(arr)))\n\n\nif __name__ == \"__main__\":\n    arr = [1, -2, 0, 3]\n    assert maximumSum(arr) == 4\n    assert maximumSumMemo(arr) == 4\n</code></pre>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#42-trapping-rain-water","title":"42. Trapping Rain Water","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, dynamic programming, stack, monotonic stack</p> </li> <li></li> </ul> Approach Time Space DP O(N) O(N) Left Right O(N) O(1) Monotonic O(N) O(N) 42. Trapping Rain Water - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef trapDP(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    n = len(height)\n    maxLeft, maxRight = [0 for _ in range(n)], [0 for _ in range(n)]\n\n    for i in range(1, n):\n        maxLeft[i] = max(maxLeft[i - 1], height[i - 1])\n\n    for i in range(n - 2, -1, -1):\n        maxRight[i] = max(maxRight[i + 1], height[i + 1])\n\n    res = 0\n    for i in range(n):\n        res += max(0, min(maxLeft[i], maxRight[i]) - height[i])\n\n    return res\n\n\n# Left Right Pointers\ndef trapLR(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    left, right = 0, len(height) - 1\n    maxL, maxR = height[left], height[right]\n    res = 0\n\n    while left &lt; right:\n        if maxL &lt; maxR:\n            left += 1\n            maxL = max(maxL, height[left])\n            res += maxL - height[left]\n        else:\n            right -= 1\n            maxR = max(maxR, height[right])\n            res += maxR - height[right]\n\n    return res\n\n\n# Monotonic Stack\ndef trapStack(height: List[int]) -&gt; int:\n    stack = []\n    total = 0\n\n    for i in range(len(height)):\n        while stack and height[i] &gt; height[stack[-1]]:\n            top = stack.pop()\n            if not stack:\n                break\n            distance = i - stack[-1] - 1\n            bounded_height = min(height[i], height[stack[-1]]) - height[top]\n            total += distance * bounded_height\n        stack.append(i)\n\n    return total\n\n\nheight = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\nprint(trapDP(height))  # 6\nprint(trapLR(height))  # 6\nprint(trapStack(height))  # 6\n</code></pre> 42. Trapping Rain Water - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int trap(vector&lt;int&gt; &amp;height)\n    {\n        if (height.empty())\n            return 0;\n\n        int res = 0;\n        int left = 0, right = height.size() - 1;\n        int maxL = height[left], maxR = height[right];\n\n        while (left &lt; right)\n        {\n            if (maxL &lt; maxR)\n            {\n                left++;\n                maxL = max(maxL, height[left]);\n                res += maxL - height[left];\n            }\n            else\n            {\n                right--;\n                maxR = max(maxR, height[right]);\n                res += maxR - height[right];\n            }\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    vector&lt;int&gt; height = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};\n    Solution solution;\n    cout &lt;&lt; solution.trap(height) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#2711-difference-of-number-of-distinct-values-on-diagonals","title":"2711. Difference of Number of Distinct Values on Diagonals","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, matrix 2711. Difference of Number of Distinct Values on Diagonals - Python Solution<pre><code>from typing import List\n\n\ndef differenceOfDistinctValues(grid: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(grid), len(grid[0])\n    res = [[0] * n for _ in range(m)]\n    st = set()\n\n    for k in range(1, m + n):\n        min_j = max(n - k, 0)\n        max_j = min(m + n - 1 - k, n - 1)\n\n        st.clear()\n        for j in range(min_j, max_j + 1):\n            i = k + j - n\n            res[i][j] = len(st)\n            st.add(grid[i][j])\n\n        st.clear()\n        for j in range(max_j, min_j - 1, -1):\n            i = k + j - n\n            res[i][j] = abs(res[i][j] - len(st))\n            st.add(grid[i][j])\n\n    return res\n\n\nif __name__ == \"__main__\":\n    grid = [[1, 2, 3], [3, 1, 5], [3, 2, 1]]\n    print(differenceOfDistinctValues(grid))\n    # [[1, 1, 0], [1, 0, 1], [0, 1, 1]]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#1477-find-two-non-overlapping-sub-arrays-each-with-target-sum","title":"1477. Find Two Non-overlapping Sub-arrays Each With Target Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, binary search, dynamic programming, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#2680-maximum-or","title":"2680. Maximum OR","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, bit manipulation, prefix sum 2680. Maximum OR - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef maximumOr(nums: List[int], k: int) -&gt; int:\n    \"\"\"Maximum OR of Array After k Operations\n\n    Args:\n        nums (List[int]): provided list of integers\n        k (int): number of operations\n\n    Returns:\n        int: maximum OR of array after k operations\n    \"\"\"\n    n = len(nums)\n    suffix = [0 for _ in range(n)]\n\n    for i in range(n - 2, -1, -1):\n        suffix[i] = suffix[i + 1] | nums[i + 1]\n\n    res, pre = 0, 0\n    for num, suf in zip(nums, suffix):\n        res = max(res, pre | (num &lt;&lt; k) | suf)\n        pre |= num\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(maximumOr(nums=[8, 1, 2], k=2))  # 35\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#1671-minimum-number-of-removals-to-make-mountain-array","title":"1671. Minimum Number of Removals to Make Mountain Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, dynamic programming, greedy 1671. Minimum Number of Removals to Make Mountain Array - Python Solution<pre><code>from typing import List\n\n\n# DP - LIS\ndef minimumMountainRemovals(nums: List[int]) -&gt; int:\n    n = len(nums)\n    lis = [1 for _ in range(n)]\n    lds = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] &gt; nums[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    for i in range(n - 2, -1, -1):\n        for j in range(n - 1, i, -1):\n            if nums[i] &gt; nums[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    maxLen = 0\n    for i in range(1, n - 1):\n        if lis[i] &gt; 1 and lds[i] &gt; 1:\n            maxLen = max(maxLen, lis[i] + lds[i] - 1)\n\n    return n - maxLen\n\n\nnums = [2, 1, 1, 5, 6, 2, 3, 1]\nprint(minimumMountainRemovals(nums))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#1888-minimum-number-of-flips-to-make-the-binary-string-alternating","title":"1888. Minimum Number of Flips to Make the Binary String Alternating","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming, greedy, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#238-product-of-array-except-self","title":"238. Product of Array Except Self","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, prefix sum</p> </li> <li>Classic Prefix Sum problem</li> <li>Return an array <code>output</code> such that <code>output[i]</code> is equal to the product of all the elements of <code>nums</code> except <code>nums[i]</code>.</li> </ul> Approach Time Space Prefix O(n) O(n) Prefix (Optimized) O(n) O(1) 238. Product of Array Except Self - Python Solution<pre><code>from typing import List\n\n\n# Prefix\ndef productExceptSelf(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    prefix = [1 for _ in range(n)]\n    suffix = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        prefix[i] = nums[i - 1] * prefix[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        suffix[i] = nums[i + 1] * suffix[i + 1]\n\n    result = [i * j for i, j in zip(prefix, suffix)]\n\n    return result\n\n\n# Prefix (Optimized)\ndef productExceptSelfOptimized(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    result = [1 for _ in range(n)]\n\n    prefix = 1\n    for i in range(n):\n        result[i] = prefix\n        prefix *= nums[i]\n\n    suffix = 1\n    for i in range(n - 1, -1, -1):\n        result[i] *= suffix\n        suffix *= nums[i]\n\n    return result\n\n\nprint(productExceptSelf([1, 2, 3, 4]))\n# [24, 12, 8, 6]\nprint(productExceptSelfOptimized([1, 2, 3, 4]))\n# [24, 12, 8, 6]\n</code></pre> 238. Product of Array Except Self - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\n// Prefix Sum\nclass Solution\n{\npublic:\n    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt; &amp;nums)\n    {\n        int n = nums.size();\n        vector&lt;int&gt; prefix(n, 1);\n        vector&lt;int&gt; suffix(n, 1);\n        vector&lt;int&gt; res(n, 1);\n\n        for (int i = 1; i &lt; n; i++)\n        {\n            prefix[i] = prefix[i - 1] * nums[i - 1];\n        }\n\n        for (int i = n - 2; i &gt;= 0; i--)\n        {\n            suffix[i] = suffix[i + 1] * nums[i + 1];\n        }\n\n        for (int i = 0; i &lt; n; i++)\n        {\n            res[i] = prefix[i] * suffix[i];\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    vector&lt;int&gt; nums = {1, 2, 3, 4};\n    Solution obj;\n    vector&lt;int&gt; result = obj.productExceptSelf(nums);\n\n    for (int i = 0; i &lt; result.size(); i++)\n    {\n        cout &lt;&lt; result[i] &lt;&lt; \"\\n\";\n    }\n    cout &lt;&lt; endl;\n    // 24, 12, 8, 6\n    return 0;\n}\n</code></pre>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#2906-construct-product-matrix","title":"2906. Construct Product Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, matrix, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#3334-find-the-maximum-factor-score-of-array","title":"3334. Find the Maximum Factor Score of Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#2167-minimum-time-to-remove-all-cars-containing-illegal-goods","title":"2167. Minimum Time to Remove All Cars Containing Illegal Goods","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#2484-count-palindromic-subsequences","title":"2484. Count Palindromic Subsequences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#2163-minimum-difference-in-sums-after-removal-of-elements","title":"2163. Minimum Difference in Sums After Removal of Elements","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#2565-subsequence-with-the-minimum-score","title":"2565. Subsequence With the Minimum Score","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: two pointers, string, binary search</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#1995-count-special-quadruplets","title":"1995. Count Special Quadruplets","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#2552-count-increasing-quadruplets","title":"2552. Count Increasing Quadruplets","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, binary indexed tree, enumeration, prefix sum 2552. Count Increasing Quadruplets - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef countQuadruplets(nums: List[int]) -&gt; int:\n    n = len(nums)\n    great = [[0] * (n + 1) for _ in range(n)]\n    less = [0 for _ in range(n + 1)]\n\n    for k in range(n - 2, 1, -1):\n        great[k] = great[k + 1].copy()\n        for x in range(1, nums[k + 1]):\n            great[k][x] += 1\n\n    ans = 0\n\n    for j in range(1, n - 1):\n        for x in range(nums[j - 1] + 1, n + 1):\n            less[x] += 1\n        for k in range(j + 1, n - 1):\n            if nums[j] &gt; nums[k]:\n                ans += less[nums[k]] * great[k][nums[j]]\n    return ans\n\n\nnums = [1, 3, 2, 4, 5]\nprint(countQuadruplets(nums))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#3302-find-the-lexicographically-smallest-valid-sequence","title":"3302. Find the Lexicographically Smallest Valid Sequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string, dynamic programming, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#3404-count-special-subsequences","title":"3404. Count Special Subsequences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#3303-find-the-occurrence-of-first-almost-equal-substring","title":"3303. Find the Occurrence of First Almost Equal Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, string matching</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#3287-find-the-maximum-sequence-value-of-array","title":"3287. Find the Maximum Sequence Value of Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#3257-maximum-value-sum-by-placing-three-rooks-ii","title":"3257. Maximum Value Sum by Placing Three Rooks II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, matrix, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#3410-maximize-subarray-sum-after-removing-all-occurrences-of-one-element","title":"3410. Maximize Subarray Sum After Removing All Occurrences of One Element","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, segment tree</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#3003-maximize-the-number-of-partitions-after-operations","title":"3003. Maximize the Number of Partitions After Operations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming, bit manipulation, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#487-max-consecutive-ones-ii","title":"487. Max Consecutive Ones II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_and_suffix_decomposition/#1746-maximum-subarray-sum-after-one-operation","title":"1746. Maximum Subarray Sum After One Operation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_sum/","title":"DP Prefix Sum","text":""},{"location":"content/endlesscheng/dp_prefix_sum/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2327. Number of People Aware of a Secret (Medium)</li> <li> 1871. Jump Game VII (Medium)</li> <li> 1997. First Day Where You Have Been in All the Rooms (Medium)</li> <li> 3251. Find the Count of Monotonic Pairs II (Hard)</li> <li> 2478. Number of Beautiful Partitions (Hard)</li> <li> 837. New 21 Game (Medium)</li> <li> 2463. Minimum Total Distance Traveled (Hard)</li> <li> 3333. Find the Original Typed String II (Hard)</li> <li> 2902. Count of Sub-Multisets With Bounded Sum (Hard)</li> <li> 629. K Inverse Pairs Array (Hard)</li> <li> 1977. Number of Ways to Separate Numbers (Hard)</li> <li> 3130. Find All Possible Stable Binary Arrays II (Hard)</li> </ul>"},{"location":"content/endlesscheng/dp_prefix_sum/#2327-number-of-people-aware-of-a-secret","title":"2327. Number of People Aware of a Secret","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming, queue, simulation</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_sum/#1871-jump-game-vii","title":"1871. Jump Game VII","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming, sliding window, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_sum/#1997-first-day-where-you-have-been-in-all-the-rooms","title":"1997. First Day Where You Have Been in All the Rooms","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_sum/#3251-find-the-count-of-monotonic-pairs-ii","title":"3251. Find the Count of Monotonic Pairs II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, dynamic programming, combinatorics, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_sum/#2478-number-of-beautiful-partitions","title":"2478. Number of Beautiful Partitions","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_sum/#837-new-21-game","title":"837. New 21 Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, sliding window, probability and statistics</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_sum/#2463-minimum-total-distance-traveled","title":"2463. Minimum Total Distance Traveled","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_sum/#3333-find-the-original-typed-string-ii","title":"3333. Find the Original Typed String II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_sum/#2902-count-of-sub-multisets-with-bounded-sum","title":"2902. Count of Sub-Multisets With Bounded Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, dynamic programming, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_sum/#629-k-inverse-pairs-array","title":"629. K Inverse Pairs Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_sum/#1977-number-of-ways-to-separate-numbers","title":"1977. Number of Ways to Separate Numbers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming, suffix array</p> </li> </ul>"},{"location":"content/endlesscheng/dp_prefix_sum/#3130-find-all-possible-stable-binary-arrays-ii","title":"3130. Find All Possible Stable Binary Arrays II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/dp_print_solutions/","title":"DP Print Solutions","text":""},{"location":"content/endlesscheng/dp_print_solutions/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 368. Largest Divisible Subset (Medium)</li> <li> 1449. Form Largest Integer With Digits That Add up to Target (Hard)</li> <li> 1092. Shortest Common Supersequence  (Hard)</li> <li> 943. Find the Shortest Superstring (Hard)</li> <li> 1125. Smallest Sufficient Team (Hard)</li> <li> 3260. Find the Largest Palindrome Divisible by K (Hard)</li> <li> 3149. Find the Minimum Cost Array Permutation (Hard)</li> <li> 3441. Minimum Cost Good Caption (Hard)</li> <li> 3348. Smallest Divisible Digit Product II (Hard)</li> <li> 656. Coin Path (Hard) \ud83d\udc51</li> <li> 471. Encode String with Shortest Length (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/dp_print_solutions/#368-largest-divisible-subset","title":"368. Largest Divisible Subset","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, dynamic programming, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/dp_print_solutions/#1449-form-largest-integer-with-digits-that-add-up-to-target","title":"1449. Form Largest Integer With Digits That Add up to Target","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_print_solutions/#1092-shortest-common-supersequence","title":"1092. Shortest Common Supersequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_print_solutions/#943-find-the-shortest-superstring","title":"943. Find the Shortest Superstring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, dynamic programming, bit manipulation, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_print_solutions/#1125-smallest-sufficient-team","title":"1125. Smallest Sufficient Team","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, bit manipulation, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_print_solutions/#3260-find-the-largest-palindrome-divisible-by-k","title":"3260. Find the Largest Palindrome Divisible by K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, string, dynamic programming, greedy, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/dp_print_solutions/#3149-find-the-minimum-cost-array-permutation","title":"3149. Find the Minimum Cost Array Permutation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, bit manipulation, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_print_solutions/#3441-minimum-cost-good-caption","title":"3441. Minimum Cost Good Caption","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_print_solutions/#3348-smallest-divisible-digit-product-ii","title":"3348. Smallest Divisible Digit Product II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, string, backtracking, greedy, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/dp_print_solutions/#656-coin-path","title":"656. Coin Path","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_print_solutions/#471-encode-string-with-shortest-length","title":"471. Encode String with Shortest Length","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_probability_expectation/","title":"DP Probability Expectation","text":""},{"location":"content/endlesscheng/dp_probability_expectation/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 688. Knight Probability in Chessboard (Medium)</li> <li> 837. New 21 Game (Medium)</li> <li> 1467. Probability of a Two Boxes Having The Same Number of Distinct Balls (Hard)</li> <li> 808. Soup Servings (Medium)</li> <li> 1230. Toss Strange Coins (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/dp_probability_expectation/#688-knight-probability-in-chessboard","title":"688. Knight Probability in Chessboard","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_probability_expectation/#837-new-21-game","title":"837. New 21 Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, sliding window, probability and statistics</p> </li> </ul>"},{"location":"content/endlesscheng/dp_probability_expectation/#1467-probability-of-a-two-boxes-having-the-same-number-of-distinct-balls","title":"1467. Probability of a Two Boxes Having The Same Number of Distinct Balls","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, dynamic programming, backtracking, combinatorics, probability and statistics</p> </li> </ul>"},{"location":"content/endlesscheng/dp_probability_expectation/#808-soup-servings","title":"808. Soup Servings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, probability and statistics</p> </li> </ul>"},{"location":"content/endlesscheng/dp_probability_expectation/#1230-toss-strange-coins","title":"1230. Toss Strange Coins","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, dynamic programming, probability and statistics</p> </li> </ul>"},{"location":"content/endlesscheng/dp_state_machine_advanced/","title":"DP State Machine Advanced","text":""},{"location":"content/endlesscheng/dp_state_machine_advanced/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1262. Greatest Sum Divisible by Three (Medium)</li> <li> 1363. Largest Multiple of Three (Hard)</li> <li> 2771. Longest Non-decreasing Subarray From Two Arrays (Medium)</li> <li> 1594. Maximum Non Negative Product in a Matrix (Medium)</li> <li> 3196. Maximize Total Cost of Alternating Subarrays (Medium)</li> <li> 935. Knight Dialer (Medium)</li> <li> 1537. Get the Maximum Score (Hard)</li> <li> 2919. Minimum Increment Operations to Make Array Beautiful (Medium)</li> <li> 801. Minimum Swaps To Make Sequences Increasing (Hard)</li> <li> 3434. Maximum Frequency After Subarray Operation (Medium)</li> <li> 1955. Count Number of Special Subsequences (Hard)</li> <li> 3068. Find the Maximum Sum of Node Values (Hard)</li> <li> 2272. Substring With Largest Variance (Hard)</li> <li> 276. Paint Fence (Medium) \ud83d\udc51</li> <li> 1746. Maximum Subarray Sum After One Operation (Medium) \ud83d\udc51</li> <li> 2036. Maximum Alternating Subarray Sum (Medium) \ud83d\udc51</li> <li> 2361. Minimum Costs Using the Train Line (Hard) \ud83d\udc51</li> <li> 3269. Constructing Two Increasing Arrays (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/dp_state_machine_advanced/#1262-greatest-sum-divisible-by-three","title":"1262. Greatest Sum Divisible by Three","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/dp_state_machine_advanced/#1363-largest-multiple-of-three","title":"1363. Largest Multiple of Three","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/dp_state_machine_advanced/#2771-longest-non-decreasing-subarray-from-two-arrays","title":"2771. Longest Non-decreasing Subarray From Two Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_state_machine_advanced/#1594-maximum-non-negative-product-in-a-matrix","title":"1594. Maximum Non Negative Product in a Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/dp_state_machine_advanced/#3196-maximize-total-cost-of-alternating-subarrays","title":"3196. Maximize Total Cost of Alternating Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_state_machine_advanced/#935-knight-dialer","title":"935. Knight Dialer","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_state_machine_advanced/#1537-get-the-maximum-score","title":"1537. Get the Maximum Score","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, dynamic programming, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/dp_state_machine_advanced/#2919-minimum-increment-operations-to-make-array-beautiful","title":"2919. Minimum Increment Operations to Make Array Beautiful","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_state_machine_advanced/#801-minimum-swaps-to-make-sequences-increasing","title":"801. Minimum Swaps To Make Sequences Increasing","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_state_machine_advanced/#3434-maximum-frequency-after-subarray-operation","title":"3434. Maximum Frequency After Subarray Operation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, dynamic programming, greedy, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/dp_state_machine_advanced/#1955-count-number-of-special-subsequences","title":"1955. Count Number of Special Subsequences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_state_machine_advanced/#3068-find-the-maximum-sum-of-node-values","title":"3068. Find the Maximum Sum of Node Values","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, greedy, bit manipulation, tree, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/dp_state_machine_advanced/#2272-substring-with-largest-variance","title":"2272. Substring With Largest Variance","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming 2272. Substring With Largest Variance - Python Solution<pre><code>from itertools import permutations\nfrom math import inf\nfrom string import ascii_lowercase\n\n\n# DP State Machine\ndef largestVariance(s: str) -&gt; int:\n    res = 0\n\n    for a, b in permutations(ascii_lowercase, 2):\n        f0, f1 = 0, -inf\n        for ch in s:\n            if ch == a:\n                f0 = max(f0, 0) + 1\n                f1 += 1\n            elif ch == b:\n                f1 = f0 = max(f0, 0) - 1\n\n            res = max(res, f1)\n    return res\n\n\nif __name__ == \"__main__\":\n    s = \"aababbb\"\n    print(largestVariance(s))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_state_machine_advanced/#276-paint-fence","title":"276. Paint Fence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_state_machine_advanced/#1746-maximum-subarray-sum-after-one-operation","title":"1746. Maximum Subarray Sum After One Operation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_state_machine_advanced/#2036-maximum-alternating-subarray-sum","title":"2036. Maximum Alternating Subarray Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_state_machine_advanced/#2361-minimum-costs-using-the-train-line","title":"2361. Minimum Costs Using the Train Line","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_state_machine_advanced/#3269-constructing-two-increasing-arrays","title":"3269. Constructing Two Increasing Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_state_machine_basics/","title":"DP State Machine Basics","text":""},{"location":"content/endlesscheng/dp_state_machine_basics/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3259. Maximum Energy Boost From Two Drinks (Medium)</li> <li> 2222. Number of Ways to Select Buildings (Medium)</li> <li> 1567. Maximum Length of Subarray With Positive Product (Medium)</li> <li> 2708. Maximum Strength of a Group (Medium)</li> <li> 2826. Sorting Three Groups (Medium)</li> <li> 2786. Visit Array Positions to Maximize Score (Medium)</li> <li> 1911. Maximum Alternating Subsequence Sum (Medium)</li> <li> 376. Wiggle Subsequence (Medium)</li> <li> 1186. Maximum Subarray Sum with One Deletion (Medium)</li> </ul>"},{"location":"content/endlesscheng/dp_state_machine_basics/#3259-maximum-energy-boost-from-two-drinks","title":"3259. Maximum Energy Boost From Two Drinks","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_state_machine_basics/#2222-number-of-ways-to-select-buildings","title":"2222. Number of Ways to Select Buildings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/dp_state_machine_basics/#1567-maximum-length-of-subarray-with-positive-product","title":"1567. Maximum Length of Subarray With Positive Product","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/dp_state_machine_basics/#2708-maximum-strength-of-a-group","title":"2708. Maximum Strength of a Group","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, backtracking, greedy, bit manipulation, sorting, enumeration 2708. Maximum Strength of a Group - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef maxStrength(nums: List[int]) -&gt; int:\n    if not nums:\n        return 0\n\n    cur_min, cur_max = nums[0], nums[0]\n\n    for i, num in enumerate(nums):\n        if i == 0:\n            continue\n\n        temp_min = min(cur_min, num, num * cur_min, num * cur_max)\n        temp_max = max(cur_max, num, num * cur_min, num * cur_max)\n        cur_min, cur_max = temp_min, temp_max\n\n    return cur_max\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |  DP        |  O(N)  |  O(1)   |\n# |------------|--------|---------|\n\n\nnums = [3, -1, -5, 2, 5, -9]\nprint(maxStrength(nums))  # 1350\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_state_machine_basics/#2826-sorting-three-groups","title":"2826. Sorting Three Groups","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, dynamic programming 2826. Sorting Three Groups - Python Solution<pre><code>from functools import cache\nfrom typing import List\n\n\n# DP - LIS\ndef minimumOperationsMemo(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return 0\n\n    @cache\n    def dfs(i):\n        res = 0\n        for j in range(i):\n            if nums[i] &gt;= nums[j]:\n                res = max(res, dfs(j))\n        return res + 1\n\n    LIS = max(dfs(i) for i in range(n))\n\n    return n - LIS\n\n\n# DP - LIS\ndef minimumOperationsTable(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return 0\n\n    dp = [1 for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i):\n            if nums[i] &gt;= nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return n - max(dp)\n\n\n# DP - LIS\ndef minimumOperationsTableOptimized(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return 0\n\n    dp = [0 for _ in range(4)]\n\n    for num in nums:\n        dp[num] += 1\n        dp[2] = max(dp[2], dp[1])\n        dp[3] = max(dp[3], dp[2])\n\n    return n - dp[3]\n\n\nif __name__ == \"__main__\":\n    assert minimumOperationsMemo([2, 1, 3, 2, 1]) == 3\n    assert minimumOperationsTable([2, 1, 3, 2, 1]) == 3\n    assert minimumOperationsTableOptimized([2, 1, 3, 2, 1]) == 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_state_machine_basics/#2786-visit-array-positions-to-maximize-score","title":"2786. Visit Array Positions to Maximize Score","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_state_machine_basics/#1911-maximum-alternating-subsequence-sum","title":"1911. Maximum Alternating Subsequence Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_state_machine_basics/#376-wiggle-subsequence","title":"376. Wiggle Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> <li>Return the length of the longest wiggle subsequence.</li> <li><code>up[n]</code> stores the length of the longest wiggle subsequence ending at <code>n</code> with a rising wiggle.</li> <li><code>down[n]</code> stores the length of the longest wiggle subsequence ending at <code>n</code> with a falling wiggle.</li> <li>Initialize <code>up[0] = 1</code> and <code>down[0] = 1</code>.</li> <li>Example: <code>nums = [1, 7, 4, 9, 2, 5]</code></li> </ul> <code>nums[n]</code> <code>nums[n-1]</code> <code>up[n-1]</code> <code>down[n-1]</code> <code>up[n]</code> <code>down[n]</code> 1 - - - 1 1 7 1 1 1 2 1 4 7 2 1 2 3 9 4 2 3 4 3 2 9 4 3 4 5 5 2 4 5 6 5 376. Wiggle Subsequence - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef wiggleMaxLengthDP(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 1:\n        return len(nums)\n\n    up = [0 for _ in range(len(nums))]\n    down = [0 for _ in range(len(nums))]\n\n    up[0], down[0] = 1, 1\n\n    for i in range(1, len(nums)):\n        if nums[i] &gt; nums[i - 1]:\n            up[i] = down[i - 1] + 1\n            down[i] = down[i - 1]\n        elif nums[i] &lt; nums[i - 1]:\n            down[i] = up[i - 1] + 1\n            up[i] = up[i - 1]\n        else:\n            up[i] = up[i - 1]\n            down[i] = down[i - 1]\n\n    return max(up[-1], down[-1])\n\n\n# Greedy\ndef wiggleMaxLengthGreedy(nums: List[int]) -&gt; int:\n    if len(nums) &lt; 2:\n        return len(nums)\n\n    prev_diff = nums[1] - nums[0]\n    count = 2 if prev_diff != 0 else 1\n\n    for i in range(2, len(nums)):\n        diff = nums[i] - nums[i - 1]\n        if (diff &gt; 0 and prev_diff &lt;= 0) or (diff &lt; 0 and prev_diff &gt;= 0):\n            count += 1\n            prev_diff = diff\n\n    return count\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    DP       |      O(n)       |     O(n)     |\n# |  Greedy     |      O(n)       |     O(1)     |\n# |-------------|-----------------|--------------|\n\nnums = [1, 7, 4, 9, 2, 5]\nprint(wiggleMaxLengthDP(nums))  # 6\nprint(wiggleMaxLengthGreedy(nums))  # 6\n</code></pre>"},{"location":"content/endlesscheng/dp_state_machine_basics/#1186-maximum-subarray-sum-with-one-deletion","title":"1186. Maximum Subarray Sum with One Deletion","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li>\u7075\u795e\uff1a\u6559\u4f60\u4e00\u6b65\u6b65\u601d\u8003\u52a8\u6001\u89c4\u5212 - \u4ece\u8bb0\u5fc6\u5316\u641c\u7d22\u5230\u9012\u63a8)</li> </ul> 1186. Maximum Subarray Sum with One Deletion - Python Solution<pre><code>from functools import cache\nfrom math import inf\nfrom typing import List\n\n\n# DP - Kadane\ndef maximumSum(arr: List[int]) -&gt; int:\n    dp0 = arr[0]\n    dp1 = 0\n    res = dp0\n\n    for i in range(1, len(arr)):\n        dp1 = max(dp1 + arr[i], dp0)  # delete previous element or not\n        dp0 = max(dp0, 0) + arr[i]  # delete current element or not\n        res = max(res, dp0, dp1)  # update result\n\n    return res\n\n\n# DP - Memoization\ndef maximumSumMemo(arr: List[int]) -&gt; int:\n    @cache\n    def dfs(i: int, j: int) -&gt; int:\n        if i &lt; 0:\n            return -inf\n        if j == 0:\n            return max(dfs(i - 1, 0), 0) + arr[i]\n        return max(dfs(i - 1, 1) + arr[i], dfs(i - 1, 0))\n\n    return max(max(dfs(i, 0), dfs(i, 1)) for i in range(len(arr)))\n\n\nif __name__ == \"__main__\":\n    arr = [1, -2, 0, 3]\n    assert maximumSum(arr) == 4\n    assert maximumSumMemo(arr) == 4\n</code></pre>"},{"location":"content/endlesscheng/dp_stock_trading/","title":"DP Stock Trading","text":""},{"location":"content/endlesscheng/dp_stock_trading/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 121. Best Time to Buy and Sell Stock (Easy)</li> <li> 122. Best Time to Buy and Sell Stock II (Medium)</li> <li> 123. Best Time to Buy and Sell Stock III (Hard)</li> <li> 188. Best Time to Buy and Sell Stock IV (Hard)</li> <li> 309. Best Time to Buy and Sell Stock with Cooldown (Medium)</li> <li> 714. Best Time to Buy and Sell Stock with Transaction Fee (Medium)</li> </ul>"},{"location":"content/endlesscheng/dp_stock_trading/#121-best-time-to-buy-and-sell-stock","title":"121. Best Time to Buy and Sell Stock","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li>Return the maximum profit that can be achieved from buying on one day and selling on another day.</li> </ul> 121. Best Time to Buy and Sell Stock - Python Solution<pre><code>from typing import List\n\n\n# Brute Force\ndef maxProfitBF(prices: List[int]) -&gt; int:\n    max_profit = 0\n    n = len(prices)\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_profit = max(max_profit, prices[j] - prices[i])\n\n    return max_profit\n\n\n# DP\ndef maxProfitDP(prices: List[int]) -&gt; int:\n    dp = [[0] * 2 for _ in range(len(prices))]\n    dp[0][0] = -prices[0]  # buy\n    dp[0][1] = 0  # sell\n\n    for i in range(1, len(prices)):\n        dp[i][0] = max(dp[i - 1][0], -prices[i])  # the lowest price to buy\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    max_profit = 0\n    seen_min = prices[0]\n\n    for i in range(1, len(prices)):\n        max_profit = max(max_profit, prices[i] - seen_min)\n        seen_min = min(seen_min, prices[i])\n\n    return max_profit\n\n\n# Fast Slow Pointers\ndef maxProfitFS(prices: List[int]) -&gt; int:\n    max_profit = 0\n    slow, fast = 0, 1\n\n    while fast &lt; len(prices):\n        if prices[fast] &gt; prices[slow]:\n            max_profit = max(max_profit, prices[fast] - prices[slow])\n        else:\n            slow = fast\n        fast += 1\n\n    return max_profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force|  O(n^2)|  O(1)   |\n# | DP         |  O(n)  |  O(n)   |\n# | Greedy     |  O(n)  |  O(1)   |\n# | Fast Slow  |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitBF(prices))  # 5\nprint(maxProfitDP(prices))  # 5\nprint(maxProfitGreedy(prices))  # 5\nprint(maxProfitFS(prices))  # 5\n</code></pre> 121. Best Time to Buy and Sell Stock - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int maxProfit(vector&lt;int&gt; &amp;prices)\n    {\n        if (prices.size() &lt;= 1)\n            return 0;\n\n        int seen_min = prices[0];\n        int res = 0;\n\n        for (int &amp;price : prices)\n        {\n            res = max(res, price - seen_min);\n            seen_min = min(seen_min, price);\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    vector&lt;int&gt; prices = {7, 1, 5, 3, 6, 4};\n    Solution obj;\n    cout &lt;&lt; obj.maxProfit(prices) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/endlesscheng/dp_stock_trading/#122-best-time-to-buy-and-sell-stock-ii","title":"122. Best Time to Buy and Sell Stock II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> <li>Return the maximum profit you can achieve.</li> </ul> 122. Best Time to Buy and Sell Stock II - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef maxProfitDP1(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 2 for _ in range(n)]\n    dp[0][0] = -prices[0]\n    dp[0][1] = 0\n\n    for i in range(1, n):\n        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i])\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# DP - Optimized\ndef maxProfitDP2(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    hold = -prices[0]\n    profit = 0\n\n    for i in range(1, n):\n        hold = max(hold, profit - prices[i])\n        profit = max(profit, hold + prices[i])\n\n    return profit\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    profit = 0\n\n    for i in range(1, len(prices)):\n        profit += max(prices[i] - prices[i - 1], 0)\n\n    return profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |     DP1    |  O(n)  |   O(n)  |\n# |     DP2    |  O(n)  |   O(1)  |\n# |   Greedy   |  O(n)  |   O(1)  |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitDP1(prices))  # 7\nprint(maxProfitDP2(prices))  # 7\nprint(maxProfitGreedy(prices))  # 7\n</code></pre>"},{"location":"content/endlesscheng/dp_stock_trading/#123-best-time-to-buy-and-sell-stock-iii","title":"123. Best Time to Buy and Sell Stock III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming 123. Best Time to Buy and Sell Stock III - Python Solution<pre><code>from typing import List\n\n\n# 1. DP\ndef maxProfitDP1(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 5 for _ in range(n)]\n\n    dp[0][0] = 0  # no transaction\n    dp[0][1] = -prices[0]  # buy 1\n    dp[0][2] = 0  # sell 1\n    dp[0][3] = -prices[0]  # buy 2\n    dp[0][4] = 0  # sell 2\n\n    for i in range(1, n):\n        dp[i][0] = dp[i - 1][0]\n        dp[i][1] = max(dp[i - 1][1], -prices[i])\n        dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i])\n        dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i])\n        dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i])\n\n    return dp[-1][4]\n\n\n# 2. DP - Optimized\ndef maxProfitDP2(prices: List[int]) -&gt; int:\n    b1, b2 = float(\"inf\"), float(\"inf\")\n    s1, s2 = 0, 0\n\n    for price in prices:\n        b1 = min(b1, price)\n        s1 = max(s1, price - b1)\n        b2 = min(b2, price - s1)\n        s2 = max(s2, price - b2)\n\n    return s2\n\n\nprices = [3, 3, 5, 0, 0, 3, 1, 4]\nprint(maxProfitDP1(prices))  # 6\nprint(maxProfitDP2(prices))  # 6\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_stock_trading/#188-best-time-to-buy-and-sell-stock-iv","title":"188. Best Time to Buy and Sell Stock IV","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming 188. Best Time to Buy and Sell Stock IV - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef maxProfit(k: int, prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * (2 * k + 1) for _ in range(n)]\n\n    for j in range(1, 2 * k, 2):\n        dp[0][j] = -prices[0]\n\n    for i in range(1, n):\n        for j in range(0, 2 * k - 1, 2):\n            dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i])\n            dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i])\n\n    return dp[-1][2 * k]\n\n\nk = 2\nprices = [2, 4, 1]\nprint(maxProfit(k, prices))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_stock_trading/#309-best-time-to-buy-and-sell-stock-with-cooldown","title":"309. Best Time to Buy and Sell Stock with Cooldown","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming 309. Best Time to Buy and Sell Stock with Cooldown - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef maxProfit(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 4 for _ in range(n)]\n\n    dp[0][0] = -prices[0]  # poessess\n    dp[0][1] = 0  # stay sold\n    dp[0][2] = 0  # sell\n    dp[0][3] = 0  # cooldown\n\n    for i in range(1, n):\n        dp[i][0] = max(\n            dp[i - 1][0],  # stay poessess\n            dp[i - 1][1] - prices[i],  # buy after stay sold\n            dp[i - 1][3] - prices[i],  # buy after cooldown\n        )\n        dp[i][1] = max(\n            dp[i - 1][1],  # stay sold\n            dp[i - 1][3],  # stay cooldown\n        )\n        dp[i][2] = dp[i - 1][0] + prices[i]\n        dp[i][3] = dp[i - 1][2]\n\n    return max(dp[-1])\n\n\nprices = [1, 2, 3, 0, 2]\nprint(maxProfit(prices))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_stock_trading/#714-best-time-to-buy-and-sell-stock-with-transaction-fee","title":"714. Best Time to Buy and Sell Stock with Transaction Fee","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> <li>Return the maximum profit you can achieve with the given transaction fee.</li> </ul> 714. Best Time to Buy and Sell Stock with Transaction Fee - Python Solution<pre><code>from typing import List\n\n\n# 1. DP\ndef maxProfitDP(prices: List[int], fee: int) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 2 for _ in range(n)]\n\n    dp[0][0] = -prices[0] - fee\n    dp[0][1] = 0\n\n    for i in range(1, n):\n        dp[i][0] = max(\n            dp[i - 1][0],  # hold\n            dp[i - 1][1] - prices[i] - fee,  # buy\n        )\n        dp[i][1] = max(\n            dp[i - 1][1],  # hold\n            dp[i - 1][0] + prices[i],  # sell\n        )\n\n    return max(dp[-1])\n\n\n# 2. Greedy\ndef maxProfitGreedy(prices: List[int], fee: int) -&gt; int:\n    n = len(prices)\n    if n == 0:\n        return 0\n\n    buy = prices[0]\n    profit = 0\n\n    for i in range(1, n):\n        if prices[i] &lt; buy:\n            buy = prices[i]\n        elif prices[i] &gt; buy + fee:\n            profit += prices[i] - buy - fee\n            buy = prices[i] - fee\n\n    return profit\n\n\nprices = [1, 3, 2, 8, 4, 9]\nfee = 2\nprint(maxProfitDP(prices, fee))  # 8\nprint(maxProfitGreedy(prices, fee))  # 8\n</code></pre>"},{"location":"content/endlesscheng/dp_subrectangle/","title":"DP Subrectangle","text":""},{"location":"content/endlesscheng/dp_subrectangle/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3148. Maximum Difference Score in a Grid (Medium)</li> <li> 221. Maximal Square (Medium)</li> <li> 1277. Count Square Submatrices with All Ones (Medium)</li> <li> 2088. Count Fertile Pyramids in a Land (Hard)</li> <li> 3197. Find the Minimum Area to Cover All Ones II (Hard)</li> </ul>"},{"location":"content/endlesscheng/dp_subrectangle/#3148-maximum-difference-score-in-a-grid","title":"3148. Maximum Difference Score in a Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/dp_subrectangle/#221-maximal-square","title":"221. Maximal Square","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/dp_subrectangle/#1277-count-square-submatrices-with-all-ones","title":"1277. Count Square Submatrices with All Ones","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/dp_subrectangle/#2088-count-fertile-pyramids-in-a-land","title":"2088. Count Fertile Pyramids in a Land","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/dp_subrectangle/#3197-find-the-minimum-area-to-cover-all-ones-ii","title":"3197. Find the Minimum Area to Cover All Ones II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, matrix, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/dp_subset_state_compression/","title":"DP Subset State Compression","text":""},{"location":"content/endlesscheng/dp_subset_state_compression/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2305. Fair Distribution of Cookies (Medium)</li> <li> 1986. Minimum Number of Work Sessions to Finish the Tasks (Medium)</li> <li> 1723. Find Minimum Time to Finish All Jobs (Hard)</li> <li> 1655. Distribute Repeating Integers (Hard)</li> <li> 1349. Maximum Students Taking Exam (Hard)</li> <li> 1681. Minimum Incompatibility (Hard)</li> <li> 3444. Minimum Increments for Target Multiples in an Array (Hard)</li> <li> 2572. Count the Number of Square-Free Subsets (Medium)</li> <li> 1994. The Number of Good Subsets (Hard)</li> <li> 1494. Parallel Courses II (Hard)</li> <li> 465. Optimal Account Balancing (Hard) \ud83d\udc51</li> <li> 2152. Minimum Number of Lines to Cover Points (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/dp_subset_state_compression/#2305-fair-distribution-of-cookies","title":"2305. Fair Distribution of Cookies","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, backtracking, bit manipulation, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_subset_state_compression/#1986-minimum-number-of-work-sessions-to-finish-the-tasks","title":"1986. Minimum Number of Work Sessions to Finish the Tasks","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, backtracking, bit manipulation, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_subset_state_compression/#1723-find-minimum-time-to-finish-all-jobs","title":"1723. Find Minimum Time to Finish All Jobs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, backtracking, bit manipulation, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_subset_state_compression/#1655-distribute-repeating-integers","title":"1655. Distribute Repeating Integers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, backtracking, bit manipulation, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_subset_state_compression/#1349-maximum-students-taking-exam","title":"1349. Maximum Students Taking Exam","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, bit manipulation, matrix, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_subset_state_compression/#1681-minimum-incompatibility","title":"1681. Minimum Incompatibility","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, bit manipulation, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_subset_state_compression/#3444-minimum-increments-for-target-multiples-in-an-array","title":"3444. Minimum Increments for Target Multiples in an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, dynamic programming, bit manipulation, number theory, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_subset_state_compression/#2572-count-the-number-of-square-free-subsets","title":"2572. Count the Number of Square-Free Subsets","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, dynamic programming, bit manipulation, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_subset_state_compression/#1994-the-number-of-good-subsets","title":"1994. The Number of Good Subsets","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, dynamic programming, bit manipulation, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_subset_state_compression/#1494-parallel-courses-ii","title":"1494. Parallel Courses II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, bit manipulation, graph, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_subset_state_compression/#465-optimal-account-balancing","title":"465. Optimal Account Balancing","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, backtracking, bit manipulation, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_subset_state_compression/#2152-minimum-number-of-lines-to-cover-points","title":"2152. Minimum Number of Lines to Cover Points","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, dynamic programming, backtracking, bit manipulation, geometry, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_transform_x_to_y/","title":"DP Transform X to Y","text":""},{"location":"content/endlesscheng/dp_transform_x_to_y/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 397. Integer Replacement (Medium)</li> <li> 2998. Minimum Number of Operations to Make X and Y Equal (Medium)</li> <li> 2059. Minimum Operations to Convert Number (Medium)</li> <li> 991. Broken Calculator (Medium)</li> <li> 1553. Minimum Number of Days to Eat N Oranges (Hard)</li> <li> 3377. Digit Operations to Make Two Integers Equal (Medium)</li> </ul>"},{"location":"content/endlesscheng/dp_transform_x_to_y/#397-integer-replacement","title":"397. Integer Replacement","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming, greedy, bit manipulation, memoization</p> </li> </ul>"},{"location":"content/endlesscheng/dp_transform_x_to_y/#2998-minimum-number-of-operations-to-make-x-and-y-equal","title":"2998. Minimum Number of Operations to Make X and Y Equal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming, breadth first search, memoization</p> </li> </ul>"},{"location":"content/endlesscheng/dp_transform_x_to_y/#2059-minimum-operations-to-convert-number","title":"2059. Minimum Operations to Convert Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, breadth first search</p> </li> </ul>"},{"location":"content/endlesscheng/dp_transform_x_to_y/#991-broken-calculator","title":"991. Broken Calculator","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/dp_transform_x_to_y/#1553-minimum-number-of-days-to-eat-n-oranges","title":"1553. Minimum Number of Days to Eat N Oranges","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, memoization</p> </li> </ul>"},{"location":"content/endlesscheng/dp_transform_x_to_y/#3377-digit-operations-to-make-two-integers-equal","title":"3377. Digit Operations to Make Two Integers Equal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, graph, heap priority queue, number theory, shortest path</p> </li> </ul>"},{"location":"content/endlesscheng/dp_traveling_salesman_problem/","title":"DP Traveling Salesman Problem","text":""},{"location":"content/endlesscheng/dp_traveling_salesman_problem/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 943. Find the Shortest Superstring (Hard)</li> <li> 847. Shortest Path Visiting All Nodes (Hard)</li> <li> 2247. Maximum Cost of Trip With K Highways (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/dp_traveling_salesman_problem/#943-find-the-shortest-superstring","title":"943. Find the Shortest Superstring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, dynamic programming, bit manipulation, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_traveling_salesman_problem/#847-shortest-path-visiting-all-nodes","title":"847. Shortest Path Visiting All Nodes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, bit manipulation, breadth first search, graph, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_traveling_salesman_problem/#2247-maximum-cost-of-trip-with-k-highways","title":"2247. Maximum Cost of Trip With K Highways","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, bit manipulation, graph, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/dp_trie/","title":"DP Trie","text":""},{"location":"content/endlesscheng/dp_trie/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 139. Word Break (Medium)</li> <li> 140. Word Break II (Hard)</li> <li> 472. Concatenated Words (Hard)</li> <li> 2977. Minimum Cost to Convert String II (Hard)</li> </ul>"},{"location":"content/endlesscheng/dp_trie/#139-word-break","title":"139. Word Break","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, dynamic programming, trie, memoization 139. Word Break - Python Solution<pre><code>from typing import List\n\n\n# DP (Unbounded Knapsack)\ndef wordBreak(s: str, wordDict: List[str]) -&gt; bool:\n    n = len(s)\n    dp = [False for _ in range(n + 1)]\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for word in wordDict:\n            m = len(word)\n            if s[i - m : i] == word and dp[i - m]:\n                dp[i] = True\n    return dp[-1]\n\n\ns = \"leetcode\"\nwordDict = [\"leet\", \"code\"]\nprint(wordBreak(s, wordDict))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_trie/#140-word-break-ii","title":"140. Word Break II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, string, dynamic programming, backtracking, trie, memoization</p> </li> </ul>"},{"location":"content/endlesscheng/dp_trie/#472-concatenated-words","title":"472. Concatenated Words","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, dynamic programming, depth first search, trie</p> </li> </ul>"},{"location":"content/endlesscheng/dp_trie/#2977-minimum-cost-to-convert-string-ii","title":"2977. Minimum Cost to Convert String II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, dynamic programming, graph, trie, shortest path</p> </li> </ul>"},{"location":"content/endlesscheng/dp_valid_subsequence/","title":"DP Valid Subsequence","text":""},{"location":"content/endlesscheng/dp_valid_subsequence/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2501. Longest Square Streak in an Array (Medium)</li> <li> 1218. Longest Arithmetic Subsequence of Given Difference (Medium)</li> <li> 1027. Longest Arithmetic Subsequence (Medium)</li> <li> 873. Length of Longest Fibonacci Subsequence (Medium)</li> <li> 3202. Find the Maximum Length of Valid Subsequence II (Medium)</li> <li> 446. Arithmetic Slices II - Subsequence (Hard)</li> <li> 3351. Sum of Good Subsequences (Hard)</li> <li> 3041. Maximize Consecutive Elements in an Array After Modification (Hard)</li> <li> 3409. Longest Subsequence With Decreasing Adjacent Difference (Medium)</li> <li> 3098. Find the Sum of Subsequence Powers (Hard)</li> <li> 1048. Longest String Chain (Medium)</li> </ul>"},{"location":"content/endlesscheng/dp_valid_subsequence/#2501-longest-square-streak-in-an-array","title":"2501. Longest Square Streak in an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, binary search, dynamic programming, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/dp_valid_subsequence/#1218-longest-arithmetic-subsequence-of-given-difference","title":"1218. Longest Arithmetic Subsequence of Given Difference","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_valid_subsequence/#1027-longest-arithmetic-subsequence","title":"1027. Longest Arithmetic Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, binary search, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_valid_subsequence/#873-length-of-longest-fibonacci-subsequence","title":"873. Length of Longest Fibonacci Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_valid_subsequence/#3202-find-the-maximum-length-of-valid-subsequence-ii","title":"3202. Find the Maximum Length of Valid Subsequence II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_valid_subsequence/#446-arithmetic-slices-ii-subsequence","title":"446. Arithmetic Slices II - Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_valid_subsequence/#3351-sum-of-good-subsequences","title":"3351. Sum of Good Subsequences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_valid_subsequence/#3041-maximize-consecutive-elements-in-an-array-after-modification","title":"3041. Maximize Consecutive Elements in an Array After Modification","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/dp_valid_subsequence/#3409-longest-subsequence-with-decreasing-adjacent-difference","title":"3409. Longest Subsequence With Decreasing Adjacent Difference","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/dp_valid_subsequence/#3098-find-the-sum-of-subsequence-powers","title":"3098. Find the Sum of Subsequence Powers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/dp_valid_subsequence/#1048-longest-string-chain","title":"1048. Longest String Chain","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, two pointers, string, dynamic programming, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/dp_wqs_binary_search/","title":"DP WQS Binary Search","text":""},{"location":"content/endlesscheng/dp_wqs_binary_search/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 188. Best Time to Buy and Sell Stock IV (Hard)</li> <li> 2209. Minimum White Tiles After Covering With Carpets (Hard)</li> </ul>"},{"location":"content/endlesscheng/dp_wqs_binary_search/#188-best-time-to-buy-and-sell-stock-iv","title":"188. Best Time to Buy and Sell Stock IV","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming 188. Best Time to Buy and Sell Stock IV - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef maxProfit(k: int, prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * (2 * k + 1) for _ in range(n)]\n\n    for j in range(1, 2 * k, 2):\n        dp[0][j] = -prices[0]\n\n    for i in range(1, n):\n        for j in range(0, 2 * k - 1, 2):\n            dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i])\n            dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i])\n\n    return dp[-1][2 * k]\n\n\nk = 2\nprices = [2, 4, 1]\nprint(maxProfit(k, prices))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dp_wqs_binary_search/#2209-minimum-white-tiles-after-covering-with-carpets","title":"2209. Minimum White Tiles After Covering With Carpets","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/dual_heap/","title":"Dual Heap","text":""},{"location":"content/endlesscheng/dual_heap/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2102. Sequentially Ordinal Rank Tracker (Hard)</li> <li> 295. Find Median from Data Stream (Hard)</li> <li> 480. Sliding Window Median (Hard)</li> <li> 1825. Finding MK Average (Hard)</li> <li> 3013. Divide an Array Into Subarrays With Minimum Cost II (Hard)</li> <li> 3321. Find X-Sum of All K-Long Subarrays II (Hard)</li> <li> 3369. Design an Array Statistics Tracker  (Hard) \ud83d\udc51</li> <li> 3422. Minimum Operations to Make Subarray Elements Equal (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/dual_heap/#2102-sequentially-ordinal-rank-tracker","title":"2102. Sequentially Ordinal Rank Tracker","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: design, heap priority queue, data stream, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/dual_heap/#295-find-median-from-data-stream","title":"295. Find Median from Data Stream","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: two pointers, design, sorting, heap priority queue, data stream 295. Find Median from Data Stream - Python Solution<pre><code>from heapq import heappop, heappush\n\n\n# Dual Heaps\nclass MedianFinder:\n\n    def __init__(self):\n        self.minHeap = []\n        self.maxHeap = []\n        self.min_size = 0\n        self.max_size = 0\n\n    def addNum(self, num: int) -&gt; None:\n        heappush(self.maxHeap, -num)\n        heappush(self.minHeap, -heappop(self.maxHeap))\n        self.min_size += 1\n\n        if self.min_size &gt; self.max_size:\n            heappush(self.maxHeap, -heappop(self.minHeap))\n            self.min_size -= 1\n            self.max_size += 1\n\n    def findMedian(self) -&gt; float:\n        if self.min_size == self.max_size:\n            return (-self.maxHeap[0] + self.minHeap[0]) / 2.0\n        return -self.maxHeap[0]\n\n\nobj = MedianFinder()\nobj.addNum(1)\nobj.addNum(2)\nassert obj.findMedian() == 1.5\nobj.addNum(3)\nassert obj.findMedian() == 2\nobj.addNum(4)\nassert obj.findMedian() == 2.5\nobj.addNum(5)\nassert obj.findMedian() == 3\nprint(\"All Passed.\")\n</code></pre></p> </li> </ul> 295. Find Median from Data Stream - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass MedianFinder {\n   private:\n    priority_queue&lt;int&gt; maxHeap;\n    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;\n    int max_size = 0;\n    int min_size = 0;\n\n   public:\n    MedianFinder() {}\n\n    void addNum(int num) {\n        if (min_size == max_size) {\n            minHeap.push(num);\n            maxHeap.push(minHeap.top());\n            minHeap.pop();\n            max_size++;\n        } else {\n            maxHeap.push(num);\n            minHeap.push(maxHeap.top());\n            maxHeap.pop();\n            min_size++;\n        }\n    }\n\n    double findMedian() {\n        if (min_size == max_size) {\n            return (maxHeap.top() + minHeap.top()) / 2.0;\n        } else {\n            return (double)maxHeap.top();\n        }\n    }\n};\n\nint main() {\n    MedianFinder* obj = new MedianFinder();\n    obj-&gt;addNum(1);\n    obj-&gt;addNum(2);\n    cout &lt;&lt; obj-&gt;findMedian() &lt;&lt; endl;  // 1.5\n    obj-&gt;addNum(3);\n    cout &lt;&lt; obj-&gt;findMedian() &lt;&lt; endl;  // 2\n    return 0;\n}\n</code></pre>"},{"location":"content/endlesscheng/dual_heap/#480-sliding-window-median","title":"480. Sliding Window Median","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, sliding window, heap priority queue 480. Sliding Window Median - Python Solution<pre><code>import heapq\nfrom typing import List\n\nfrom sortedcontainers import SortedList\n\n\n# Heap - Two Heaps\ndef medianSlidingWindow1(nums: List[int], k: int) -&gt; List[float]:\n    min_heap, max_heap = [], []\n\n    for i in range(k):\n        heapq.heappush(min_heap, (nums[i], i))\n    for i in range(k // 2):\n        n, idx = heapq.heappop(min_heap)\n        heapq.heappush(max_heap, (-n, idx))\n\n    res = [\n        (\n            (min_heap[0][0] - max_heap[0][0]) / 2\n            if k % 2 == 0\n            else min_heap[0][0] * 1.0\n        )\n    ]\n\n    for i in range(k, len(nums)):\n        if nums[i] &lt; min_heap[0][0]:\n            heapq.heappush(max_heap, (-nums[i], i))\n\n            if nums[i - k] &gt;= min_heap[0][0]:\n                n, idx = heapq.heappop(max_heap)\n                heapq.heappush(min_heap, (-n, idx))\n        else:\n            heapq.heappush(min_heap, (nums[i], i))\n\n            if nums[i - k] &lt;= min_heap[0][0]:\n                n, idx = heapq.heappop(min_heap)\n                heapq.heappush(max_heap, (-n, idx))\n\n        while min_heap and min_heap[0][1] &lt;= i - k:\n            heapq.heappop(min_heap)\n        while max_heap and max_heap[0][1] &lt;= i - k:\n            heapq.heappop(max_heap)\n\n        res.append(\n            (min_heap[0][0] - max_heap[0][0]) / 2\n            if k % 2 == 0\n            else min_heap[0][0] * 1.0\n        )\n\n    return res\n\n\n# Sorted List\ndef medianSlidingWindow2(nums: List[int], k: int) -&gt; List[float]:\n    window = SortedList()\n    res = []\n\n    for i in range(len(nums)):\n        window.add(nums[i])\n\n        if len(window) == k:\n            if k % 2 == 1:\n                res.append(window[k // 2])\n            else:\n                res.append((window[k // 2 - 1] + window[k // 2]) / 2.0)\n\n            window.remove(nums[i - k + 1])\n\n    return res\n\n\nnums = [1, 2, 3, 4, 2, 3, 1, 4, 2]\nk = 3\nprint(medianSlidingWindow1(nums, k))\nprint(medianSlidingWindow2(nums, k))\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/dual_heap/#1825-finding-mk-average","title":"1825. Finding MK Average","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: design, queue, heap priority queue, data stream, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/dual_heap/#3013-divide-an-array-into-subarrays-with-minimum-cost-ii","title":"3013. Divide an Array Into Subarrays With Minimum Cost II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, sliding window, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/dual_heap/#3321-find-x-sum-of-all-k-long-subarrays-ii","title":"3321. Find X-Sum of All K-Long Subarrays II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, sliding window, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/dual_heap/#3369-design-an-array-statistics-tracker","title":"3369. Design an Array Statistics Tracker","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, binary search, design, queue, heap priority queue, data stream, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/dual_heap/#3422-minimum-operations-to-make-subarray-elements-equal","title":"3422. Minimum Operations to Make Subarray Elements Equal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, sliding window, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/dual_stack/","title":"Dual Stack","text":""},{"location":"content/endlesscheng/dual_stack/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2296. Design a Text Editor (Hard)</li> </ul>"},{"location":"content/endlesscheng/dual_stack/#2296-design-a-text-editor","title":"2296. Design a Text Editor","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: linked list, string, stack, design, simulation, doubly linked list</p> </li> </ul>"},{"location":"content/endlesscheng/dynamic_segment_tree/","title":"Dynamic Segment Tree","text":""},{"location":"content/endlesscheng/dynamic_segment_tree/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 699. Falling Squares (Hard)</li> <li> 715. Range Module (Hard)</li> <li> 729. My Calendar I (Medium)</li> <li> 731. My Calendar II (Medium)</li> <li> 732. My Calendar III (Hard)</li> <li> 2276. Count Integers in Intervals (Hard)</li> <li> 2770. Maximum Number of Jumps to Reach the Last Index (Medium)</li> </ul>"},{"location":"content/endlesscheng/dynamic_segment_tree/#699-falling-squares","title":"699. Falling Squares","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, segment tree, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/dynamic_segment_tree/#715-range-module","title":"715. Range Module","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: design, segment tree, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/dynamic_segment_tree/#729-my-calendar-i","title":"729. My Calendar I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, design, segment tree, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/dynamic_segment_tree/#731-my-calendar-ii","title":"731. My Calendar II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, design, segment tree, prefix sum, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/dynamic_segment_tree/#732-my-calendar-iii","title":"732. My Calendar III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: binary search, design, segment tree, prefix sum, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/dynamic_segment_tree/#2276-count-integers-in-intervals","title":"2276. Count Integers in Intervals","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: design, segment tree, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/dynamic_segment_tree/#2770-maximum-number-of-jumps-to-reach-the-last-index","title":"2770. Maximum Number of Jumps to Reach the Last Index","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/edge_weighted_union_find/","title":"Edge Weighted Union Find","text":""},{"location":"content/endlesscheng/edge_weighted_union_find/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 399. Evaluate Division (Medium)</li> <li> 2307. Check for Contradictions in Equations (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/edge_weighted_union_find/#399-evaluate-division","title":"399. Evaluate Division","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, depth first search, breadth first search, union find, graph, shortest path 399. Evaluate Division - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef calcEquation(\n    equations: List[List[str]], values: List[float], queries: List[List[str]]\n) -&gt; List[float]:\n    graph = defaultdict(dict)\n    for (a, b), v in zip(equations, values):\n        graph[a][b] = v\n        graph[b][a] = 1 / v\n\n    def dfs(a, b, visited):\n        if a not in graph or b not in graph:\n            return -1.0\n\n        if b in graph[a]:\n            return graph[a][b]\n\n        for c in graph[a]:\n            if c not in visited:\n                visited.add(c)\n                d = dfs(c, b, visited)\n                if d != -1.0:\n                    return graph[a][c] * d\n        return -1.0\n\n    result = []\n    for a, b in queries:\n        result.append(dfs(a, b, set()))\n\n    return result\n\n\nequations = [[\"a\", \"b\"], [\"b\", \"c\"]]\nvalues = [2.0, 3.0]\nqueries = [[\"a\", \"c\"], [\"b\", \"a\"], [\"a\", \"e\"], [\"a\", \"a\"], [\"x\", \"x\"]]\nprint(calcEquation(equations, values, queries))  # [6.0, 0.5, -1.0, 1.0, -1.0]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/edge_weighted_union_find/#2307-check-for-contradictions-in-equations","title":"2307. Check for Contradictions in Equations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, depth first search, union find, graph</p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_middle/","title":"Enumerate Middle","text":""},{"location":"content/endlesscheng/enumerate_middle/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2909. Minimum Sum of Mountain Triplets II (Medium)</li> <li> 1930. Unique Length-3 Palindromic Subsequences (Medium)</li> <li> 3128. Right Triangles (Medium)</li> <li> 2874. Maximum Value of an Ordered Triplet II (Medium)</li> <li> 447. Number of Boomerangs (Medium)</li> <li> 456. 132 Pattern (Medium)</li> <li> 3067. Count Pairs of Connectable Servers in a Weighted Tree Network (Medium)</li> <li> 3455. Shortest Matching Substring (Hard)</li> <li> 2242. Maximum Score of a Node Sequence (Hard)</li> <li> 2867. Count Valid Paths in a Tree (Hard)</li> <li> 2552. Count Increasing Quadruplets (Hard)</li> <li> 3257. Maximum Value Sum by Placing Three Rooks II (Hard)</li> <li> 3073. Maximum Increasing Triplet Value (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/enumerate_middle/#2909-minimum-sum-of-mountain-triplets-ii","title":"2909. Minimum Sum of Mountain Triplets II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array</p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_middle/#1930-unique-length-3-palindromic-subsequences","title":"1930. Unique Length-3 Palindromic Subsequences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, bit manipulation, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_middle/#3128-right-triangles","title":"3128. Right Triangles","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, combinatorics, counting</p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_middle/#2874-maximum-value-of-an-ordered-triplet-ii","title":"2874. Maximum Value of an Ordered Triplet II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array 2874. Maximum Value of an Ordered Triplet II - Python Solution<pre><code>from typing import List\n\n\ndef maximumTripletValue(nums: List[int]) -&gt; int:\n    res = 0\n    max_diff = 0\n    max_prev = 0\n\n    for num in nums:\n        res = max(res, max_diff * num)\n        max_diff = max(max_diff, max_prev - num)\n        max_prev = max(max_prev, num)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    nums = [12, 6, 1, 2, 7]\n    print(maximumTripletValue(nums))  # 77\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_middle/#447-number-of-boomerangs","title":"447. Number of Boomerangs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math</p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_middle/#456-132-pattern","title":"456. 132 Pattern","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, stack, monotonic stack, ordered set 456. 132 Pattern - Python Solution<pre><code>from typing import List\n\n\n# Monotonic Stack\ndef find132pattern(nums: List[int]) -&gt; bool:\n    n = len(nums)\n    if n &lt; 3:\n        return False\n\n    stack = []\n    second_max = float(\"-inf\")\n\n    for i in range(n - 1, -1, -1):\n        if nums[i] &lt; second_max:\n            return True\n\n        while stack and stack[-1] &lt; nums[i]:\n            second_max = stack.pop()\n\n        stack.append(nums[i])\n\n    return False\n\n\nnums = [-1, 3, 2, 0]\nprint(find132pattern(nums))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_middle/#3067-count-pairs-of-connectable-servers-in-a-weighted-tree-network","title":"3067. Count Pairs of Connectable Servers in a Weighted Tree Network","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, tree, depth first search</p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_middle/#3455-shortest-matching-substring","title":"3455. Shortest Matching Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: two pointers, string, binary search, string matching</p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_middle/#2242-maximum-score-of-a-node-sequence","title":"2242. Maximum Score of a Node Sequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, graph, sorting, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_middle/#2867-count-valid-paths-in-a-tree","title":"2867. Count Valid Paths in a Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, dynamic programming, tree, depth first search, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_middle/#2552-count-increasing-quadruplets","title":"2552. Count Increasing Quadruplets","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, binary indexed tree, enumeration, prefix sum 2552. Count Increasing Quadruplets - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef countQuadruplets(nums: List[int]) -&gt; int:\n    n = len(nums)\n    great = [[0] * (n + 1) for _ in range(n)]\n    less = [0 for _ in range(n + 1)]\n\n    for k in range(n - 2, 1, -1):\n        great[k] = great[k + 1].copy()\n        for x in range(1, nums[k + 1]):\n            great[k][x] += 1\n\n    ans = 0\n\n    for j in range(1, n - 1):\n        for x in range(nums[j - 1] + 1, n + 1):\n            less[x] += 1\n        for k in range(j + 1, n - 1):\n            if nums[j] &gt; nums[k]:\n                ans += less[nums[k]] * great[k][nums[j]]\n    return ans\n\n\nnums = [1, 3, 2, 4, 5]\nprint(countQuadruplets(nums))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_middle/#3257-maximum-value-sum-by-placing-three-rooks-ii","title":"3257. Maximum Value Sum by Placing Three Rooks II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, matrix, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_middle/#3073-maximum-increasing-triplet-value","title":"3073. Maximum Increasing Triplet Value","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_right_maintain_left/","title":"Enumerate Right Maintain Left","text":""},{"location":"content/endlesscheng/enumerate_right_maintain_left/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1. Two Sum (Easy)</li> <li> 1512. Number of Good Pairs (Easy)</li> <li> 2001. Number of Pairs of Interchangeable Rectangles (Medium)</li> <li> 219. Contains Duplicate II (Easy)</li> <li> 121. Best Time to Buy and Sell Stock (Easy)</li> <li> 624. Maximum Distance in Arrays (Medium)</li> <li> 2815. Max Pair Sum in an Array (Easy)</li> <li> 2342. Max Sum of a Pair With Equal Sum of Digits (Medium)</li> <li> 1679. Max Number of K-Sum Pairs (Medium)</li> <li> 2260. Minimum Consecutive Cards to Pick Up (Medium)</li> <li> 1010. Pairs of Songs With Total Durations Divisible by 60 (Medium)</li> <li> 3185. Count Pairs That Form a Complete Day II (Medium)</li> <li> 2506. Count Pairs Of Similar Strings (Easy)</li> <li> 2748. Number of Beautiful Pairs (Easy)</li> <li> 2874. Maximum Value of an Ordered Triplet II (Medium)</li> <li> 1014. Best Sightseeing Pair (Medium)</li> <li> 1814. Count Nice Pairs in an Array (Medium)</li> <li> 2905. Find Indices With Index and Value Difference II (Medium)</li> <li> 1031. Maximum Sum of Two Non-Overlapping Subarrays (Medium)</li> <li> 2555. Maximize Win From Two Segments (Medium)</li> <li> 1995. Count Special Quadruplets (Easy)</li> <li> 3404. Count Special Subsequences (Medium)</li> <li> 3267. Count Almost Equal Pairs II (Hard)</li> <li> 1214. Two Sum BSTs (Medium) \ud83d\udc51</li> <li> 2964. Number of Divisible Triplet Sums (Medium) \ud83d\udc51</li> <li> 2441. Largest Positive Integer That Exists With Its Negative (Easy)</li> <li> 454. 4Sum II (Medium)</li> <li> 3371. Identify the Largest Outlier in an Array (Medium)</li> </ul>"},{"location":"content/endlesscheng/enumerate_right_maintain_left/#1-two-sum","title":"1. Two Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table</p> </li> <li>Return the indices of the two numbers such that they add up to a specific target.</li> <li>Approach: Use a hashmap to store the indices of the numbers.</li> <li>Time Complexity: O(n)</li> <li>Space Complexity: O(n)</li> </ul> 1. Two Sum - Python Solution<pre><code>from typing import List\n\n\ndef twoSum(nums: List[int], target: int) -&gt; List[int]:\n    hashmap = {}  # val: idx\n\n    for idx, val in enumerate(nums):\n        if (target - val) in hashmap:\n            return [hashmap[target - val], idx]\n\n        hashmap[val] = idx\n\n\nif __name__ == \"__main__\":\n    nums = [2, 7, 11, 15]\n    target = 9\n    assert twoSum(nums, target) == [0, 1]\n</code></pre> 1. Two Sum - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;nums, int target) {\n    unordered_map&lt;int, int&gt; hashmap;\n\n    for (size_t i = 0; i &lt; nums.size(); i++) {\n        int complement = target - nums[i];\n\n        if (hashmap.find(complement) != hashmap.end()) {\n            return {hashmap[complement], (int)i};\n        }\n        hashmap[nums[i]] = (int)i;\n    }\n\n    return {-1, -1};\n}\n\nint main() {\n    vector&lt;int&gt; nums = {2, 7, 11, 15};\n    int target = 9;\n    vector&lt;int&gt; result = twoSum(nums, target);\n    cout &lt;&lt; result[0] &lt;&lt; \", \" &lt;&lt; result[1] &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/endlesscheng/enumerate_right_maintain_left/#1512-number-of-good-pairs","title":"1512. Number of Good Pairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, math, counting 1512. Number of Good Pairs - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash\ndef numIdenticalPairs(nums: List[int]) -&gt; int:\n    res = 0\n    counts = defaultdict(int)  # num: count\n\n    for num in nums:\n        res += counts[num]\n        counts[num] += 1\n\n    return res\n\n\nnums = [1, 2, 3, 1, 1, 3]\nprint(numIdenticalPairs(nums))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_right_maintain_left/#2001-number-of-pairs-of-interchangeable-rectangles","title":"2001. Number of Pairs of Interchangeable Rectangles","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, counting, number theory 2001. Number of Pairs of Interchangeable Rectangles - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash\ndef interchangeableRectangles(rectangles: List[List[int]]) -&gt; int:\n    res = 0\n    counts = defaultdict(int)\n\n    for w, h in rectangles:\n        ratio = w / h\n        res += counts[ratio]\n        counts[ratio] += 1\n\n    return res\n\n\nrectangles = [[4, 8], [3, 6], [10, 20], [15, 30]]\nprint(interchangeableRectangles(rectangles))  # 6\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_right_maintain_left/#219-contains-duplicate-ii","title":"219. Contains Duplicate II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, sliding window 219. Contains Duplicate II - Python Solution<pre><code>from typing import List\n\n\n# Hash\ndef containsNearbyDuplicateHash(nums: List[int], k: int) -&gt; bool:\n    hashmap = {}  # num: last index\n\n    for idx, num in enumerate(nums):\n        if num in hashmap:\n            if idx - hashmap[num] &lt;= k:\n                return True\n\n        hashmap[num] = idx\n\n    return False\n\n\n# Sliding window - Fixed\ndef containsNearbyDuplicateWindow(nums: List[int], k: int) -&gt; bool:\n    window = set()\n    left = 0\n\n    for right in range(len(nums)):\n        if right - left &gt; k:\n            window.remove(nums[left])\n            left += 1\n        if nums[right] in window:\n            return True\n        window.add(nums[right])\n\n    return False\n\n\nnums = [1, 2, 3, 1]\nk = 3\nprint(containsNearbyDuplicateHash(nums, k))  # True\nprint(containsNearbyDuplicateWindow(nums, k))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_right_maintain_left/#121-best-time-to-buy-and-sell-stock","title":"121. Best Time to Buy and Sell Stock","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li>Return the maximum profit that can be achieved from buying on one day and selling on another day.</li> </ul> 121. Best Time to Buy and Sell Stock - Python Solution<pre><code>from typing import List\n\n\n# Brute Force\ndef maxProfitBF(prices: List[int]) -&gt; int:\n    max_profit = 0\n    n = len(prices)\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_profit = max(max_profit, prices[j] - prices[i])\n\n    return max_profit\n\n\n# DP\ndef maxProfitDP(prices: List[int]) -&gt; int:\n    dp = [[0] * 2 for _ in range(len(prices))]\n    dp[0][0] = -prices[0]  # buy\n    dp[0][1] = 0  # sell\n\n    for i in range(1, len(prices)):\n        dp[i][0] = max(dp[i - 1][0], -prices[i])  # the lowest price to buy\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    max_profit = 0\n    seen_min = prices[0]\n\n    for i in range(1, len(prices)):\n        max_profit = max(max_profit, prices[i] - seen_min)\n        seen_min = min(seen_min, prices[i])\n\n    return max_profit\n\n\n# Fast Slow Pointers\ndef maxProfitFS(prices: List[int]) -&gt; int:\n    max_profit = 0\n    slow, fast = 0, 1\n\n    while fast &lt; len(prices):\n        if prices[fast] &gt; prices[slow]:\n            max_profit = max(max_profit, prices[fast] - prices[slow])\n        else:\n            slow = fast\n        fast += 1\n\n    return max_profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force|  O(n^2)|  O(1)   |\n# | DP         |  O(n)  |  O(n)   |\n# | Greedy     |  O(n)  |  O(1)   |\n# | Fast Slow  |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitBF(prices))  # 5\nprint(maxProfitDP(prices))  # 5\nprint(maxProfitGreedy(prices))  # 5\nprint(maxProfitFS(prices))  # 5\n</code></pre> 121. Best Time to Buy and Sell Stock - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int maxProfit(vector&lt;int&gt; &amp;prices)\n    {\n        if (prices.size() &lt;= 1)\n            return 0;\n\n        int seen_min = prices[0];\n        int res = 0;\n\n        for (int &amp;price : prices)\n        {\n            res = max(res, price - seen_min);\n            seen_min = min(seen_min, price);\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    vector&lt;int&gt; prices = {7, 1, 5, 3, 6, 4};\n    Solution obj;\n    cout &lt;&lt; obj.maxProfit(prices) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/endlesscheng/enumerate_right_maintain_left/#624-maximum-distance-in-arrays","title":"624. Maximum Distance in Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy 624. Maximum Distance in Arrays - Python Solution<pre><code>from typing import List\n\n\n# Array\ndef maxDistance(arrays: List[List[int]]) -&gt; int:\n    mn, mx = float(\"inf\"), float(\"-inf\")\n    res = 0\n\n    for arr in arrays:\n        res = max(res, arr[-1] - mn, mx - arr[0])\n        mn = min(mn, arr[0])\n        mx = max(mx, arr[-1])\n\n    return res\n\n\narrays = [[1, 2, 3], [4, 5], [1, 2, 3]]\nprint(maxDistance(arrays))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_right_maintain_left/#2815-max-pair-sum-in-an-array","title":"2815. Max Pair Sum in an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table 2815. Max Pair Sum in an Array - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash\ndef maxSumHash(nums: List[int]) -&gt; int:\n    def find(num):\n        res = 0\n        while num != 0:\n            num, carry = divmod(num, 10)\n            res = max(res, carry)\n        return res\n\n    freqs = defaultdict(list)\n\n    for num in nums:\n        x = find(num)\n        freqs[x].append(num)\n\n    res = -1\n    for vals in freqs.values():\n        if len(vals) &gt; 1:\n            vals = sorted(vals, reverse=True)\n            res = max(res, sum(vals[:2]))\n\n    return res\n\n\n# Array\ndef maxSumArray(nums: List[int]) -&gt; int:\n    res = -1\n    max_val = [float(\"-inf\") for _ in range(10)]\n\n    for num in nums:\n        maxDigit = max(map(int, str(num)))\n        res = max(res, num + max_val[maxDigit])\n        max_val[maxDigit] = max(max_val[maxDigit], num)\n\n    return res\n\n\nnums = [2536, 1613, 3366, 162]\nprint(maxSumHash(nums))  # 5902\nprint(maxSumArray(nums))  # 5902\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_right_maintain_left/#2342-max-sum-of-a-pair-with-equal-sum-of-digits","title":"2342. Max Sum of a Pair With Equal Sum of Digits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, sorting, heap priority queue 2342. Max Sum of a Pair With Equal Sum of Digits - Python Solution<pre><code>from typing import List\n\n\n# Enumerate Right Maintain Left\ndef maximumSum(nums: List[int]) -&gt; int:\n    def digits_sum(num):\n        res = 0\n        while num:\n            num, carry = divmod(num, 10)\n            res += carry\n        return res\n\n    hashmap = {}  # digit sum: largest num\n    res = -1\n\n    for num in nums:\n        ds = digits_sum(num)\n\n        if ds not in hashmap:\n            hashmap[ds] = num\n        else:\n            res = max(res, num + hashmap[ds])\n            hashmap[ds] = max(hashmap[ds], num)\n\n    return res\n\n\nnums = [18, 43, 36, 13, 7]\nprint(maximumSum(nums))  # 54\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_right_maintain_left/#1679-max-number-of-k-sum-pairs","title":"1679. Max Number of K-Sum Pairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, two pointers, sorting 1679. Max Number of K-Sum Pairs - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Enumerate Right Maintain Left\ndef maxOperations(nums: List[int], k: int) -&gt; int:\n    counts = defaultdict(int)\n\n    res = 0\n    for num in nums:\n        if num &gt;= k:\n            continue\n\n        j = k - num\n        if j in counts:\n            res += 1\n            counts[j] -= 1\n            if counts[j] == 0:\n                del counts[j]\n        else:\n            counts[num] += 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert maxOperations([1, 2, 3, 4], 5) == 2\n    assert maxOperations([3, 1, 3, 4, 3], 6) == 1\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_right_maintain_left/#2260-minimum-consecutive-cards-to-pick-up","title":"2260. Minimum Consecutive Cards to Pick Up","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, sliding window 2260. Minimum Consecutive Cards to Pick Up - Python Solution<pre><code>from typing import List\n\n\n# Enumerate Right Maintain Left\ndef minimumCardPickup(cards: List[int]) -&gt; int:\n    n = len(cards)\n    res = n + 1\n    last = {}\n\n    for idx, card in enumerate(cards):\n        if card in last:\n            res = min(res, idx - last[card] + 1)\n        last[card] = idx\n\n    return res if res != n + 1 else -1\n\n\nif __name__ == \"__main__\":\n    assert minimumCardPickup([1, 2, 3, 4, 5]) == -1\n    assert minimumCardPickup([1, 2, 3, 2, 3]) == 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_right_maintain_left/#1010-pairs-of-songs-with-total-durations-divisible-by-60","title":"1010. Pairs of Songs With Total Durations Divisible by 60","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, counting 1010. Pairs of Songs With Total Durations Divisible by 60 - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Enumerate Right Maintain Left\ndef numPairsDivisibleBy60(time: List[int]) -&gt; int:\n    if not time or len(time) &lt; 2:\n        return 0\n\n    count = defaultdict(int)\n    res = 0\n    time = [t % 60 for t in time]\n\n    for t in time:\n        if t == 0:\n            res += count[0]\n        else:\n            res += count[60 - t]\n        count[t] += 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert numPairsDivisibleBy60([30, 20, 150, 100, 40]) == 3\n    assert numPairsDivisibleBy60([60, 60, 60]) == 3\n    assert numPairsDivisibleBy60([10, 50, 30, 20, 40]) == 2\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_right_maintain_left/#3185-count-pairs-that-form-a-complete-day-ii","title":"3185. Count Pairs That Form a Complete Day II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, counting</p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_right_maintain_left/#2506-count-pairs-of-similar-strings","title":"2506. Count Pairs Of Similar Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, string, bit manipulation, counting</p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_right_maintain_left/#2748-number-of-beautiful-pairs","title":"2748. Number of Beautiful Pairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, math, counting, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_right_maintain_left/#2874-maximum-value-of-an-ordered-triplet-ii","title":"2874. Maximum Value of an Ordered Triplet II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array 2874. Maximum Value of an Ordered Triplet II - Python Solution<pre><code>from typing import List\n\n\ndef maximumTripletValue(nums: List[int]) -&gt; int:\n    res = 0\n    max_diff = 0\n    max_prev = 0\n\n    for num in nums:\n        res = max(res, max_diff * num)\n        max_diff = max(max_diff, max_prev - num)\n        max_prev = max(max_prev, num)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    nums = [12, 6, 1, 2, 7]\n    print(maximumTripletValue(nums))  # 77\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_right_maintain_left/#1014-best-sightseeing-pair","title":"1014. Best Sightseeing Pair","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming 1014. Best Sightseeing Pair - Python Solution<pre><code>from typing import List\n\n\n# Enumeate Right Maintain Left\ndef maxScoreSightseeingPair(values: List[int]) -&gt; int:\n    max_i = values[0] + 0\n    res = 0\n\n    for j in range(1, len(values)):\n        res = max(res, max_i + values[j] - j)\n        max_i = max(max_i, values[j] + j)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert maxScoreSightseeingPair([8, 1, 5, 2, 6]) == 11\n    assert maxScoreSightseeingPair([1, 2]) == 2\n    assert maxScoreSightseeingPair([1, 3, 5]) == 7\n    assert maxScoreSightseeingPair([1, 2, 3, 4, 5]) == 8\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_right_maintain_left/#1814-count-nice-pairs-in-an-array","title":"1814. Count Nice Pairs in an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, counting 1814. Count Nice Pairs in an Array - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Enumerate Right Maintain Left\ndef countNicePairs(nums: List[int]) -&gt; int:\n    rev = lambda n: int(str(n)[::-1])\n    cnt = defaultdict(int)\n    MOD = 10**9 + 7\n    res = 0\n\n    for num in nums:\n        cnt[num - rev(num)] += 1\n\n    for i in cnt.values():\n        res += i * (i - 1) // 2  # math.comb(i, 2)\n\n    return res % MOD\n\n\nif __name__ == \"__main__\":\n    assert countNicePairs([42, 11, 1, 97]) == 2\n    assert countNicePairs([13, 10, 35, 24, 76]) == 4\n    assert countNicePairs([100, 200, 300]) == 0\n    assert countNicePairs([123, 321, 456, 654]) == 2\n    assert countNicePairs([12, 21, 34, 43]) == 2\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_right_maintain_left/#2905-find-indices-with-index-and-value-difference-ii","title":"2905. Find Indices With Index and Value Difference II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers</p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_right_maintain_left/#1031-maximum-sum-of-two-non-overlapping-subarrays","title":"1031. Maximum Sum of Two Non-Overlapping Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_right_maintain_left/#2555-maximize-win-from-two-segments","title":"2555. Maximize Win From Two Segments","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sliding window 2555. Maximize Win From Two Segments - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window - Variable\ndef maximizeWin(prizePositions: List[int], k: int) -&gt; int:\n    n = len(prizePositions)\n\n    if 2 * k &gt;= prizePositions[-1] - prizePositions[0]:\n        return n\n\n    ans = left = 0\n    mx = [0] * (n + 1)\n\n    for right, p in enumerate(prizePositions):\n        while p - prizePositions[left] &gt; k:\n            left += 1\n        ans = max(ans, mx[left] + right - left + 1)\n        mx[right + 1] = max(mx[right], right - left + 1)\n\n    return ans\n\n\nprizePositions = [1, 1, 2, 2, 3, 3, 5]\nk = 2\nprint(maximizeWin(prizePositions, k))  # 7\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_right_maintain_left/#1995-count-special-quadruplets","title":"1995. Count Special Quadruplets","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_right_maintain_left/#3404-count-special-subsequences","title":"3404. Count Special Subsequences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_right_maintain_left/#3267-count-almost-equal-pairs-ii","title":"3267. Count Almost Equal Pairs II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, sorting, counting, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_right_maintain_left/#1214-two-sum-bsts","title":"1214. Two Sum BSTs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, binary search, stack, tree, depth first search, binary search tree, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_right_maintain_left/#2964-number-of-divisible-triplet-sums","title":"2964. Number of Divisible Triplet Sums","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table</p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_right_maintain_left/#2441-largest-positive-integer-that-exists-with-its-negative","title":"2441. Largest Positive Integer That Exists With Its Negative","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, two pointers, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_right_maintain_left/#454-4sum-ii","title":"454. 4Sum II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table</p> </li> <li>Return the number of tuples <code>(i, j, k, l)</code> such that <code>A[i] + B[j] + C[k] + D[l] == 0</code>.</li> </ul> 454. 4Sum II - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\ndef fourSumCount(\n    nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]\n) -&gt; int:\n\n    sumAB = defaultdict(int)\n    result = 0\n\n    for i in nums1:\n        for j in nums2:\n            sumAB[i + j] += 1\n\n    for i in nums3:\n        for j in nums4:\n            if -(i + j) in sumAB:\n                result += sumAB[-(i + j)]\n\n    return result\n\n\nnums1 = [1, 2]\nnums2 = [-2, -1]\nnums3 = [-1, 2]\nnums4 = [0, 2]\nprint(fourSumCount(nums1, nums2, nums3, nums4))  # 2\n</code></pre>"},{"location":"content/endlesscheng/enumerate_right_maintain_left/#3371-identify-the-largest-outlier-in-an-array","title":"3371. Identify the Largest Outlier in an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, counting, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_then_greedy/","title":"Enumerate then Greedy","text":""},{"location":"content/endlesscheng/enumerate_then_greedy/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2171. Removing Minimum Number of Magic Beans (Medium)</li> <li> 3085. Minimum Deletions to Make String K-Special (Medium)</li> <li> 1727. Largest Submatrix With Rearrangements (Medium)</li> <li> 2749. Minimum Operations to Make the Integer Zero (Medium)</li> <li> 2910. Minimum Number of Groups to Create a Valid Assignment (Medium)</li> <li> 2234. Maximum Total Beauty of the Gardens (Hard)</li> </ul>"},{"location":"content/endlesscheng/enumerate_then_greedy/#2171-removing-minimum-number-of-magic-beans","title":"2171. Removing Minimum Number of Magic Beans","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting, enumeration, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_then_greedy/#3085-minimum-deletions-to-make-string-k-special","title":"3085. Minimum Deletions to Make String K-Special","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, greedy, sorting, counting</p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_then_greedy/#1727-largest-submatrix-with-rearrangements","title":"1727. Largest Submatrix With Rearrangements","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_then_greedy/#2749-minimum-operations-to-make-the-integer-zero","title":"2749. Minimum Operations to Make the Integer Zero","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: bit manipulation, brainteaser, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_then_greedy/#2910-minimum-number-of-groups-to-create-a-valid-assignment","title":"2910. Minimum Number of Groups to Create a Valid Assignment","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/enumerate_then_greedy/#2234-maximum-total-beauty-of-the-gardens","title":"2234. Maximum Total Beauty of the Gardens","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, binary search, greedy, sorting 2234. Maximum Total Beauty of the Gardens - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nlong long maximumBeauty(vector&lt;int&gt;&amp; flowers, long long newFlowers, int target,\n                        int full, int partial) {\n    int n = flowers.size();\n\n    long long left = newFlowers - 1LL * target * n;\n    for (int&amp; flower : flowers) {\n        flower = min(flower, target);\n        left += flower;\n    }\n\n    if (left == newFlowers) return 1LL * full * n;\n\n    if (left &gt;= 0) {\n        return max(1LL * (target - 1) * partial + 1LL * (n - 1) * full,\n                   1LL * n * full);\n    }\n\n    sort(flowers.begin(), flowers.end());\n    long long res = 0, pre_sum = 0;\n\n    int j = 0;\n    for (int i = 1; i &lt;= n; i++) {\n        left += target - flowers[i - 1];\n        if (left &lt; 0) {\n            continue;\n        }\n\n        while (j &lt; i &amp;&amp; 1LL * flowers[j] * j &lt;= pre_sum + left) {\n            pre_sum += flowers[j];\n            j++;\n        }\n\n        long long avg = (left + pre_sum) / j;\n        long long total_beauty = avg * partial + 1LL * (n - i) * full;\n        res = max(res, total_beauty);\n    }\n\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; flowers = {1, 3, 1, 1};\n    long long newFlowers = 7;\n    int target = 6;\n    int full = 12;\n    int partial = 1;\n    long long res = maximumBeauty(flowers, newFlowers, target, full, partial);\n    cout &lt;&lt; res &lt;&lt; endl;  // 14\n    return 0;\n}\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/equivalent_transformation/","title":"Equivalent Transformation","text":""},{"location":"content/endlesscheng/equivalent_transformation/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3375. Minimum Operations to Make Array Values Equal to K (Easy)</li> <li> 2914. Minimum Number of Changes to Make Binary String Beautiful (Medium)</li> <li> 3365. Rearrange K Substrings to Form Target String (Medium)</li> <li> 1657. Determine if Two Strings Are Close (Medium)</li> <li> 2551. Put Marbles in Bags (Hard)</li> <li> 1585. Check If String Is Transformable With Substring Sort Operations (Hard)</li> <li> 1040. Moving Stones Until Consecutive II (Medium)</li> <li> 249. Group Shifted Strings (Medium) \ud83d\udc51</li> <li> 49. Group Anagrams (Medium)</li> <li> 1183. Maximum Number of Ones (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/equivalent_transformation/#3375-minimum-operations-to-make-array-values-equal-to-k","title":"3375. Minimum Operations to Make Array Values Equal to K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table</p> </li> </ul>"},{"location":"content/endlesscheng/equivalent_transformation/#2914-minimum-number-of-changes-to-make-binary-string-beautiful","title":"2914. Minimum Number of Changes to Make Binary String Beautiful","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string</p> </li> </ul>"},{"location":"content/endlesscheng/equivalent_transformation/#3365-rearrange-k-substrings-to-form-target-string","title":"3365. Rearrange K Substrings to Form Target String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/equivalent_transformation/#1657-determine-if-two-strings-are-close","title":"1657. Determine if Two Strings Are Close","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sorting, counting</p> </li> </ul>"},{"location":"content/endlesscheng/equivalent_transformation/#2551-put-marbles-in-bags","title":"2551. Put Marbles in Bags","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sorting, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/equivalent_transformation/#1585-check-if-string-is-transformable-with-substring-sort-operations","title":"1585. Check If String Is Transformable With Substring Sort Operations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/equivalent_transformation/#1040-moving-stones-until-consecutive-ii","title":"1040. Moving Stones Until Consecutive II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, two pointers, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/equivalent_transformation/#249-group-shifted-strings","title":"249. Group Shifted Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string</p> </li> </ul>"},{"location":"content/endlesscheng/equivalent_transformation/#49-group-anagrams","title":"49. Group Anagrams","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, sorting 49. Group Anagrams - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash - List\ndef groupAnagrams(strs: List[str]) -&gt; List[List[str]]:\n    result = defaultdict(list)\n\n    for s in strs:\n        count = [0] * 26\n        for i in s:\n            count[ord(i) - ord(\"a\")] += 1\n\n        result[tuple(count)].append(s)\n\n    return list(result.values())\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Hash     |     O(n * k)    |     O(n)     |\n# |-------------|-----------------|--------------|\n\n\nstrs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\nprint(groupAnagrams(strs))\n# [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/equivalent_transformation/#1183-maximum-number-of-ones","title":"1183. Maximum Number of Ones","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, greedy, sorting, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/eulerian_path_and_circuit/","title":"Eulerian Path and Circuit","text":""},{"location":"content/endlesscheng/eulerian_path_and_circuit/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 332. Reconstruct Itinerary (Hard)</li> <li> 753. Cracking the Safe (Hard)</li> <li> 2097. Valid Arrangement of Pairs (Hard)</li> </ul>"},{"location":"content/endlesscheng/eulerian_path_and_circuit/#332-reconstruct-itinerary","title":"332. Reconstruct Itinerary","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: depth first search, graph, eulerian circuit</p> </li> <li>Return the itinerary in order that visits every airport exactly once.</li> <li>The starting airport is <code>JFK</code>.</li> <li>If there are multiple valid itineraries, return the lexicographically smallest one.</li> <li>Eulerian path: A path that visits every edge exactly once.</li> </ul> <pre><code>graph TD\nJFK((JFK))\nSFO((SFO))\nATL((ATL))\nJFK --&gt; SFO\nSFO --&gt; ATL\nATL --&gt; JFK\nJFK --&gt; ATL\nATL --&gt; SFO</code></pre> 332. Reconstruct Itinerary - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hierholzer\ndef findItinerary1(tickets: List[List[str]]) -&gt; List[str]:\n    graph = defaultdict(list)\n    for u, v in sorted(tickets, reverse=True):\n        graph[u].append(v)\n\n    route = []\n\n    def dfs(node):\n        while graph[node]:\n            dest = graph[node].pop()\n            dfs(dest)\n        route.append(node)\n\n    dfs(\"JFK\")\n\n    return route[::-1]\n\n\n# Backtracking\ndef findItinerary2(tickets: List[List[str]]) -&gt; List[str]:\n    graph = defaultdict(list)\n    tickets.sort()\n    for u, v in tickets:\n        graph[u].append(v)\n\n    route = [\"JFK\"]\n\n    def backtraking(node):\n        if len(route) == len(tickets) + 1:\n            return True\n        if node not in graph:\n            return False\n\n        temp = list(graph[node])\n        for i, v in enumerate(temp):\n            graph[node].pop(i)\n            route.append(v)\n\n            if backtraking(v):\n                return True\n\n            graph[node].insert(i, v)\n            route.pop()\n\n        return False\n\n    backtraking(\"JFK\")\n\n    return route\n\n\ntickets = tickets = [\n    [\"JFK\", \"SFO\"],\n    [\"JFK\", \"ATL\"],\n    [\"SFO\", \"ATL\"],\n    [\"ATL\", \"JFK\"],\n    [\"ATL\", \"SFO\"],\n]\nprint(findItinerary1(tickets))\n# ['JFK', 'ATL', 'JFK', 'SFO', 'ATL', 'SFO']\nprint(findItinerary2(tickets))\n# ['JFK', 'ATL', 'JFK', 'SFO', 'ATL', 'SFO']\n</code></pre>"},{"location":"content/endlesscheng/eulerian_path_and_circuit/#753-cracking-the-safe","title":"753. Cracking the Safe","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: depth first search, graph, eulerian circuit</p> </li> </ul>"},{"location":"content/endlesscheng/eulerian_path_and_circuit/#2097-valid-arrangement-of-pairs","title":"2097. Valid Arrangement of Pairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: depth first search, graph, eulerian circuit</p> </li> </ul>"},{"location":"content/endlesscheng/exchange_argument/","title":"Exchange Argument","text":""},{"location":"content/endlesscheng/exchange_argument/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2895. Minimum Processing Time (Medium)</li> <li> 3457. Eat Pizzas! (Medium)</li> <li> 1665. Minimum Initial Energy to Finish Tasks (Hard)</li> <li> 3273. Minimum Amount of Damage Dealt to Bob (Hard)</li> <li> 2136. Earliest Possible Day of Full Bloom (Hard)</li> <li> 179. Largest Number (Medium)</li> <li> 3309. Maximum Possible Number by Binary Concatenation (Medium)</li> </ul>"},{"location":"content/endlesscheng/exchange_argument/#2895-minimum-processing-time","title":"2895. Minimum Processing Time","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/exchange_argument/#3457-eat-pizzas","title":"3457. Eat Pizzas!","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/exchange_argument/#1665-minimum-initial-energy-to-finish-tasks","title":"1665. Minimum Initial Energy to Finish Tasks","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/exchange_argument/#3273-minimum-amount-of-damage-dealt-to-bob","title":"3273. Minimum Amount of Damage Dealt to Bob","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/exchange_argument/#2136-earliest-possible-day-of-full-bloom","title":"2136. Earliest Possible Day of Full Bloom","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/exchange_argument/#179-largest-number","title":"179. Largest Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, greedy, sorting 179. Largest Number - Python Solution<pre><code>from functools import cmp_to_key\nfrom typing import List\n\n\n# Greedy\ndef largestNumber(nums: List[int]) -&gt; str:\n    strs = map(str, nums)\n\n    def cmp(a, b):\n        if a + b == b + a:\n            return 0\n        elif a + b &gt; b + a:\n            return 1\n        else:\n            return -1\n\n    strs = sorted(strs, key=cmp_to_key(cmp), reverse=True)\n\n    return \"\".join(strs) if strs[0] != \"0\" else \"0\"\n\n\nnums = [3, 30, 34, 5, 9]\nprint(largestNumber(nums))  # 9534330\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/exchange_argument/#3309-maximum-possible-number-by-binary-concatenation","title":"3309. Maximum Possible Number by Binary Concatenation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/expression_parsing/","title":"Expression Parsing","text":""},{"location":"content/endlesscheng/expression_parsing/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 150. Evaluate Reverse Polish Notation (Medium)</li> <li> 1006. Clumsy Factorial (Medium)</li> <li> 224. Basic Calculator (Hard)</li> <li> 227. Basic Calculator II (Medium)</li> <li> 726. Number of Atoms (Hard)</li> <li> 1106. Parsing A Boolean Expression (Hard)</li> <li> 591. Tag Validator (Hard)</li> <li> 736. Parse Lisp Expression (Hard)</li> <li> 1096. Brace Expansion II (Hard)</li> <li> 1896. Minimum Cost to Change the Final Value of Expression (Hard)</li> <li> 770. Basic Calculator IV (Hard)</li> <li> 439. Ternary Expression Parser (Medium) \ud83d\udc51</li> <li> 772. Basic Calculator III (Hard) \ud83d\udc51</li> <li> 1087. Brace Expansion (Medium) \ud83d\udc51</li> <li> 1597. Build Binary Expression Tree From Infix Expression (Hard) \ud83d\udc51</li> <li> 1628. Design an Expression Tree With Evaluate Function (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/expression_parsing/#150-evaluate-reverse-polish-notation","title":"150. Evaluate Reverse Polish Notation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, stack</p> </li> <li>Steps for the list <code>[\"2\", \"1\", \"+\", \"3\", \"*\"]</code>:</li> </ul> token action stack <code>2</code> push <code>[2]</code> <code>1</code> push <code>[2, 1]</code> <code>+</code> pop <code>[3]</code> <code>3</code> push <code>[3, 3]</code> <code>*</code> pop <code>[9]</code> 150. Evaluate Reverse Polish Notation - Python Solution<pre><code>from typing import List\n\n\n# Stack\ndef evalRPN(tokens: List[str]) -&gt; int:\n    stack = []\n\n    for c in tokens:\n        if c == \"+\":\n            stack.append(stack.pop() + stack.pop())\n        elif c == \"-\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(b - a)\n        elif c == \"*\":\n            stack.append(stack.pop() * stack.pop())\n        elif c == \"/\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(int(b / a))\n        else:\n            stack.append(int(c))\n\n    return stack[0]\n\n\nprint(evalRPN([\"2\", \"1\", \"+\", \"3\", \"*\"]))  # 9\nprint(evalRPN([\"4\", \"13\", \"5\", \"/\", \"-\"]))  # 2\nprint(evalRPN([\"18\"]))  # 18\nprint(evalRPN([\"4\", \"3\", \"-\"]))  # 1\n</code></pre>"},{"location":"content/endlesscheng/expression_parsing/#1006-clumsy-factorial","title":"1006. Clumsy Factorial","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, stack, simulation</p> </li> </ul>"},{"location":"content/endlesscheng/expression_parsing/#224-basic-calculator","title":"224. Basic Calculator","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, string, stack, recursion 224. Basic Calculator - Python Solution<pre><code># Stack\ndef calculate(s: str) -&gt; int:\n    stack = []\n    result = 0\n    number = 0\n    sign = 1\n\n    for char in s:\n        if char.isdigit():\n            number = number * 10 + int(char)\n\n        elif char == \"+\":\n            result += sign * number\n            number = 0\n            sign = 1\n        elif char == \"-\":\n            result += sign * number\n            number = 0\n            sign = -1\n\n        elif char == \"(\":\n            stack.append(result)\n            stack.append(sign)\n            result = 0\n            sign = 1\n        elif char == \")\":\n            result += sign * number\n            number = 0\n            result *= stack.pop()  # pop sign\n            result += stack.pop()  # pop previous result\n\n    result += sign * number\n\n    return result\n\n\nprint(calculate(\"(1+(4+5+2)-3)+(6+8)\"))  # 23\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/expression_parsing/#227-basic-calculator-ii","title":"227. Basic Calculator II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, string, stack 227. Basic Calculator II - Python Solution<pre><code># Stack\ndef calculate(s: str) -&gt; int:\n    stack = []\n    num = 0\n    sign = \"+\"\n\n    for index, char in enumerate(s):\n        if char.isdigit():\n            num = num * 10 + int(char)\n\n        if char in \"+-*/\" or index == len(s) - 1:\n            if sign == \"+\":\n                stack.append(num)\n            elif sign == \"-\":\n                stack.append(-num)\n            elif sign == \"*\":\n                stack.append(stack.pop() * num)\n            elif sign == \"/\":\n                stack.append(int(stack.pop() / num))\n            sign = char\n            num = 0\n\n    return sum(stack)\n\n\ns = \"3+2*2\"\nprint(calculate(s))  # 7\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/expression_parsing/#726-number-of-atoms","title":"726. Number of Atoms","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, stack, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/expression_parsing/#1106-parsing-a-boolean-expression","title":"1106. Parsing A Boolean Expression","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, stack, recursion</p> </li> </ul>"},{"location":"content/endlesscheng/expression_parsing/#591-tag-validator","title":"591. Tag Validator","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, stack</p> </li> </ul>"},{"location":"content/endlesscheng/expression_parsing/#736-parse-lisp-expression","title":"736. Parse Lisp Expression","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, stack, recursion</p> </li> </ul>"},{"location":"content/endlesscheng/expression_parsing/#1096-brace-expansion-ii","title":"1096. Brace Expansion II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, backtracking, stack, breadth first search</p> </li> </ul>"},{"location":"content/endlesscheng/expression_parsing/#1896-minimum-cost-to-change-the-final-value-of-expression","title":"1896. Minimum Cost to Change the Final Value of Expression","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, string, dynamic programming, stack</p> </li> </ul>"},{"location":"content/endlesscheng/expression_parsing/#770-basic-calculator-iv","title":"770. Basic Calculator IV","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, math, string, stack, recursion 770. Basic Calculator IV - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Stack\nclass Solution:\n    def __init__(self):\n        self.operators = set([\"+\", \"-\", \"*\"])\n\n    def basicCalculatorIV(\n        self, expression: str, evalvars: List[str], evalints: List[int]\n    ) -&gt; List[str]:\n        evalmap = dict(zip(evalvars, evalints))\n        tokens = self.parse_expression(expression)\n        result_terms = self.evaluate(tokens, evalmap)\n        return self.format_result(result_terms)\n\n    def parse_expression(self, expression):\n        tokens = []\n        i = 0\n        while i &lt; len(expression):\n            if expression[i].isalnum():  # Variable or digit\n                start = i\n                while i &lt; len(expression) and (\n                    expression[i].isalnum() or expression[i] == \"_\"\n                ):\n                    i += 1\n                tokens.append(expression[start:i])\n            elif expression[i] in self.operators or expression[i] in \"()\":\n                tokens.append(expression[i])\n                i += 1\n            elif expression[i] == \" \":\n                i += 1  # skip whitespace\n        return tokens\n\n    def evaluate(self, tokens, evalmap):\n        def apply_operator(op, b, a):\n            if op == \"+\":\n                return self.add_terms(a, b)\n            elif op == \"-\":\n                return self.add_terms(a, self.negate_terms(b))\n            elif op == \"*\":\n                return self.multiply_terms(a, b)\n\n        def process_token(token):\n            if token.isalnum():\n                if token in evalmap:\n                    stack.append({(): evalmap[token]})\n                elif token.isdigit():\n                    stack.append({(): int(token)})\n                else:\n                    stack.append({(token,): 1})\n            elif token == \"(\":\n                ops.append(token)\n            elif token == \")\":\n                while ops and ops[-1] != \"(\":\n                    operate()\n                ops.pop()\n            else:\n                while (\n                    ops\n                    and ops[-1] in precedence\n                    and precedence[ops[-1]] &gt;= precedence[token]\n                ):\n                    operate()\n                ops.append(token)\n\n        def operate():\n            if len(stack) &lt; 2 or not ops:\n                return\n            b = stack.pop()\n            a = stack.pop()\n            op = ops.pop()\n            stack.append(apply_operator(op, b, a))\n\n        stack = []\n        ops = []\n        precedence = {\"+\": 1, \"-\": 1, \"*\": 2}\n\n        for token in tokens:\n            process_token(token)\n\n        while ops:\n            operate()\n        return self.combine_terms(stack[-1])\n\n    def add_terms(self, a, b):\n        result = defaultdict(int, a)\n        for term, coef in b.items():\n            result[term] += coef\n        return dict(result)\n\n    def negate_terms(self, a):\n        return {term: -coef for term, coef in a.items()}\n\n    def multiply_terms(self, a, b):\n        result = defaultdict(int)\n        for term1, coef1 in a.items():\n            for term2, coef2 in b.items():\n                new_term = tuple(sorted(term1 + term2))\n                result[new_term] += coef1 * coef2\n        return dict(result)\n\n    def combine_terms(self, terms):\n        result = defaultdict(int)\n        for term, coef in terms.items():\n            if coef != 0:\n                result[term] = coef\n        return dict(result)\n\n    def format_result(self, result_terms):\n        result = []\n        for term in sorted(result_terms.keys(), key=lambda x: (-len(x), x)):\n            coef = result_terms[term]\n            if coef != 0:\n                term_str = \"*\".join(term)\n                if term_str:\n                    result.append(f\"{coef}*{term_str}\")\n                else:\n                    result.append(str(coef))\n        return result\n\n\ncalculator = Solution()\nexpression = \"e + 8 - a + 5\"\nevalvars = [\"e\"]\nevalints = [1]\nprint(calculator.basicCalculatorIV(expression, evalvars, evalints))\n# ['-1*a', '14']\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/expression_parsing/#439-ternary-expression-parser","title":"439. Ternary Expression Parser","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack, recursion 439. Ternary Expression Parser - Python Solution<pre><code># Stack\ndef parseTernary(expression: str) -&gt; str:\n    stack = []\n    i = len(expression) - 1\n\n    while i &gt;= 0:\n        c = expression[i]\n        if stack and stack[-1] == \"?\":\n            stack.pop()  # remove '?'\n            true_val = stack.pop()\n            stack.pop()  # remove ':'\n            false_val = stack.pop()\n            if c == \"T\":\n                stack.append(true_val)\n            else:\n                stack.append(false_val)\n        else:\n            stack.append(c)\n        i -= 1\n\n    return stack[-1]\n\n\nif __name__ == \"__main__\":\n    assert parseTernary(\"T?2:3\") == \"2\"\n    assert parseTernary(\"F?1:T?4:5\") == \"4\"\n    assert parseTernary(\"T?T?F:5:3\") == \"F\"\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/expression_parsing/#772-basic-calculator-iii","title":"772. Basic Calculator III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, string, stack, recursion 772. Basic Calculator III - Python Solution<pre><code># Stack\ndef calculate(s: str) -&gt; int:\n    def helper(index):\n        stack = []\n        num = 0\n        sign = \"+\"\n\n        while index &lt; len(s):\n            char = s[index]\n            if char.isdigit():\n                num = num * 10 + int(char)\n            if char == \"(\":\n                num, index = helper(index + 1)\n            if char in \"+-*/)\" or index == len(s) - 1:\n                if sign == \"+\":\n                    stack.append(num)\n                elif sign == \"-\":\n                    stack.append(-num)\n                elif sign == \"*\":\n                    stack.append(stack.pop() * num)\n                elif sign == \"/\":\n                    stack.append(int(stack.pop() / num))  # \u5411\u96f6\u53d6\u6574\n                num = 0\n                sign = char\n            if char == \")\":\n                break\n            index += 1\n\n        return sum(stack), index\n\n    s = s.replace(\" \", \"\")\n    result, _ = helper(0)\n\n    return result\n\n\ns = \"2*(5+5*2)/3+(6/2+8)\"\nprint(calculate(s))  # 21\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/expression_parsing/#1087-brace-expansion","title":"1087. Brace Expansion","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, backtracking, breadth first search</p> </li> </ul>"},{"location":"content/endlesscheng/expression_parsing/#1597-build-binary-expression-tree-from-infix-expression","title":"1597. Build Binary Expression Tree From Infix Expression","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, stack, tree, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/expression_parsing/#1628-design-an-expression-tree-with-evaluate-function","title":"1628. Design an Expression Tree With Evaluate Function","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, stack, tree, design, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/factorial_decomposition/","title":"Factorial Decomposition","text":""},{"location":"content/endlesscheng/factorial_decomposition/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 172. Factorial Trailing Zeroes (Medium)</li> <li> 793. Preimage Size of Factorial Zeroes Function (Hard)</li> </ul>"},{"location":"content/endlesscheng/factorial_decomposition/#172-factorial-trailing-zeroes","title":"172. Factorial Trailing Zeroes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math</p> </li> </ul>"},{"location":"content/endlesscheng/factorial_decomposition/#793-preimage-size-of-factorial-zeroes-function","title":"793. Preimage Size of Factorial Zeroes Function","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, binary search</p> </li> </ul>"},{"location":"content/endlesscheng/factors/","title":"Factors","text":""},{"location":"content/endlesscheng/factors/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2427. Number of Common Factors (Easy)</li> <li> 1952. Three Divisors (Easy)</li> <li> 1492. The kth Factor of n (Medium)</li> <li> 507. Perfect Number (Easy)</li> <li> 1390. Four Divisors (Medium)</li> <li> 1362. Closest Divisors (Medium)</li> <li> 829. Consecutive Numbers Sum (Hard)</li> <li> 3447. Assign Elements to Groups with Constraints (Medium)</li> <li> 3164. Find the Number of Good Pairs II (Medium)</li> <li> 952. Largest Component Size by Common Factor (Hard)</li> <li> 1627. Graph Connectivity With Threshold (Hard)</li> <li> 2198. Number of Single Divisor Triplets (Medium) \ud83d\udc51</li> <li> 625. Minimum Factorization (Medium) \ud83d\udc51</li> <li> 2847. Smallest Number With Given Digit Product (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/factors/#2427-number-of-common-factors","title":"2427. Number of Common Factors","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, enumeration, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/factors/#1952-three-divisors","title":"1952. Three Divisors","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, enumeration, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/factors/#1492-the-kth-factor-of-n","title":"1492. The kth Factor of n","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/factors/#507-perfect-number","title":"507. Perfect Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math</p> </li> </ul>"},{"location":"content/endlesscheng/factors/#1390-four-divisors","title":"1390. Four Divisors","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math</p> </li> </ul>"},{"location":"content/endlesscheng/factors/#1362-closest-divisors","title":"1362. Closest Divisors","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math</p> </li> </ul>"},{"location":"content/endlesscheng/factors/#829-consecutive-numbers-sum","title":"829. Consecutive Numbers Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/factors/#3447-assign-elements-to-groups-with-constraints","title":"3447. Assign Elements to Groups with Constraints","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table</p> </li> </ul>"},{"location":"content/endlesscheng/factors/#3164-find-the-number-of-good-pairs-ii","title":"3164. Find the Number of Good Pairs II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table</p> </li> </ul>"},{"location":"content/endlesscheng/factors/#952-largest-component-size-by-common-factor","title":"952. Largest Component Size by Common Factor","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, math, union find, number theory 952. Largest Component Size by Common Factor - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef largestComponentSize(nums: List[int]) -&gt; int:\n    par = {i: i for i in nums}\n    rank = {i: 0 for i in nums}\n\n    def find(n):\n        p = par[n]\n        while par[p] != p:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            if rank[p1] &gt; rank[p2]:\n                par[p2] = p1\n            elif rank[p1] &lt; rank[p2]:\n                par[p1] = p2\n            else:\n                par[p2] = p1\n                rank[p1] += 1\n\n    def prime_factors(n):\n        \"\"\"Return the prime factors of n.\"\"\"\n        i = 2\n        factors = set()\n        while i * i &lt;= n:\n            while (n % i) == 0:\n                factors.add(i)\n                n //= i\n            i += 1\n        if n &gt; 1:\n            factors.add(n)\n        return factors\n\n    factor_map = defaultdict(list)  # factor -&gt; [nums]\n    for num in nums:\n        factors = prime_factors(num)\n        for factor in factors:\n            factor_map[factor].append(num)\n\n    for factor, group in factor_map.items():\n        for i in range(1, len(group)):\n            union(group[0], group[i])\n\n    sizes = defaultdict(int)  # component root -&gt; size\n    for num in nums:\n        root = find(num)\n        sizes[root] += 1\n\n    return max(sizes.values())\n\n\nnums = [20, 50, 9, 63]\nprint(largestComponentSize(nums))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/factors/#1627-graph-connectivity-with-threshold","title":"1627. Graph Connectivity With Threshold","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, union find, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/factors/#2198-number-of-single-divisor-triplets","title":"2198. Number of Single Divisor Triplets","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math</p> </li> </ul>"},{"location":"content/endlesscheng/factors/#625-minimum-factorization","title":"625. Minimum Factorization","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/factors/#2847-smallest-number-with-given-digit-product","title":"2847. Smallest Number With Given Digit Product","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/fenwick_tree/","title":"Fenwick Tree","text":""},{"location":"content/endlesscheng/fenwick_tree/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 307. Range Sum Query - Mutable (Medium)</li> <li> 3072. Distribute Elements Into Two Arrays II (Hard)</li> <li> 3187. Peaks in Array (Hard)</li> <li> 1649. Create Sorted Array through Instructions (Hard)</li> <li> 1626. Best Team With No Conflicts (Medium)</li> <li> 1409. Queries on a Permutation With Key (Medium)</li> <li> 2250. Count Number of Rectangles Containing Each Point (Medium)</li> <li> 2179. Count Good Triplets in an Array (Hard)</li> <li> 1395. Count Number of Teams (Medium)</li> <li> 2659. Make Array Empty (Hard)</li> <li> 2653. Sliding Subarray Beauty (Medium)</li> <li> 1505. Minimum Possible Integer After at Most K Adjacent Swaps On Digits (Hard)</li> <li> 2926. Maximum Balanced Subsequence Sum (Hard)</li> <li> 2736. Maximum Sum Queries (Hard)</li> <li> 3382. Maximum Area Rectangle With Point Constraints II (Hard)</li> <li> 3245. Alternating Groups III (Hard)</li> <li> 1756. Design Most Recently Used Queue (Medium) \ud83d\udc51</li> <li> 2519. Count the Number of K-Big Indices (Hard) \ud83d\udc51</li> <li> 2613. Beautiful Pairs (Hard) \ud83d\udc51</li> <li> 2921. Maximum Profitable Triplets With Increasing Prices II (Hard) \ud83d\udc51</li> <li> 308. Range Sum Query 2D - Mutable (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/fenwick_tree/#307-range-sum-query-mutable","title":"307. Range Sum Query - Mutable","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, design, binary indexed tree, segment tree</p> </li> </ul>"},{"location":"content/endlesscheng/fenwick_tree/#3072-distribute-elements-into-two-arrays-ii","title":"3072. Distribute Elements Into Two Arrays II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary indexed tree, segment tree, simulation</p> </li> </ul>"},{"location":"content/endlesscheng/fenwick_tree/#3187-peaks-in-array","title":"3187. Peaks in Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary indexed tree, segment tree</p> </li> </ul>"},{"location":"content/endlesscheng/fenwick_tree/#1649-create-sorted-array-through-instructions","title":"1649. Create Sorted Array through Instructions","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, divide and conquer, binary indexed tree, segment tree, merge sort, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/fenwick_tree/#1626-best-team-with-no-conflicts","title":"1626. Best Team With No Conflicts","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, sorting 1626. Best Team With No Conflicts - Python Solution<pre><code>from typing import List\n\n\n# DP - LIS\ndef bestTeamScore(scores: List[int], ages: List[int]) -&gt; int:\n    n = len(scores)\n    pairs = sorted(zip(scores, ages))  # sort\n    dp = [0 for _ in range(n)]\n\n    # LIS\n    for i in range(n):\n        for j in range(i):\n            if pairs[i][1] &gt;= pairs[j][1]:\n                dp[i] = max(dp[i], dp[j])\n        dp[i] += pairs[i][0]\n\n    return max(dp)\n\n\nif __name__ == \"__main__\":\n    assert bestTeamScore([1, 3, 5, 10, 15], [1, 2, 3, 4, 5]) == 34\n    assert bestTeamScore([4, 5, 6, 5], [2, 1, 2, 1]) == 16\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/fenwick_tree/#1409-queries-on-a-permutation-with-key","title":"1409. Queries on a Permutation With Key","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary indexed tree, simulation</p> </li> </ul>"},{"location":"content/endlesscheng/fenwick_tree/#2250-count-number-of-rectangles-containing-each-point","title":"2250. Count Number of Rectangles Containing Each Point","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, binary indexed tree, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/fenwick_tree/#2179-count-good-triplets-in-an-array","title":"2179. Count Good Triplets in an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, divide and conquer, binary indexed tree, segment tree, merge sort, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/fenwick_tree/#1395-count-number-of-teams","title":"1395. Count Number of Teams","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, binary indexed tree, segment tree</p> </li> </ul>"},{"location":"content/endlesscheng/fenwick_tree/#2659-make-array-empty","title":"2659. Make Array Empty","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, greedy, binary indexed tree, segment tree, sorting, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/fenwick_tree/#2653-sliding-subarray-beauty","title":"2653. Sliding Subarray Beauty","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/fenwick_tree/#1505-minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits","title":"1505. Minimum Possible Integer After at Most K Adjacent Swaps On Digits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, greedy, binary indexed tree, segment tree</p> </li> </ul>"},{"location":"content/endlesscheng/fenwick_tree/#2926-maximum-balanced-subsequence-sum","title":"2926. Maximum Balanced Subsequence Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, dynamic programming, binary indexed tree, segment tree</p> </li> </ul>"},{"location":"content/endlesscheng/fenwick_tree/#2736-maximum-sum-queries","title":"2736. Maximum Sum Queries","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, stack, binary indexed tree, segment tree, sorting, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/fenwick_tree/#3382-maximum-area-rectangle-with-point-constraints-ii","title":"3382. Maximum Area Rectangle With Point Constraints II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, binary indexed tree, segment tree, geometry, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/fenwick_tree/#3245-alternating-groups-iii","title":"3245. Alternating Groups III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary indexed tree</p> </li> </ul>"},{"location":"content/endlesscheng/fenwick_tree/#1756-design-most-recently-used-queue","title":"1756. Design Most Recently Used Queue","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, stack, design, binary indexed tree, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/fenwick_tree/#2519-count-the-number-of-k-big-indices","title":"2519. Count the Number of K-Big Indices","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, divide and conquer, binary indexed tree, segment tree, merge sort, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/fenwick_tree/#2613-beautiful-pairs","title":"2613. Beautiful Pairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, divide and conquer, geometry, sorting, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/fenwick_tree/#2921-maximum-profitable-triplets-with-increasing-prices-ii","title":"2921. Maximum Profitable Triplets With Increasing Prices II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary indexed tree, segment tree</p> </li> </ul>"},{"location":"content/endlesscheng/fenwick_tree/#308-range-sum-query-2d-mutable","title":"308. Range Sum Query 2D - Mutable","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, design, binary indexed tree, segment tree, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/from_special_to_general/","title":"From Special to General","text":""},{"location":"content/endlesscheng/from_special_to_general/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2745. Construct the Longest New String (Medium)</li> <li> 2611. Mice and Cheese (Medium)</li> <li> 1029. Two City Scheduling (Medium)</li> <li> 2645. Minimum Additions to Make Valid String (Medium)</li> <li> 2202. Maximize the Topmost Element After K Moves (Medium)</li> <li> 2568. Minimum Impossible OR (Medium)</li> <li> 1702. Maximum Binary String After Change (Medium)</li> <li> 3012. Minimize Length of Array Using Operations (Medium)</li> <li> 1526. Minimum Number of Increments on Subarrays to Form a Target Array (Hard)</li> <li> 2350. Shortest Impossible Sequence of Rolls (Hard)</li> <li> 517. Super Washing Machines (Hard)</li> <li> 2499. Minimum Total Cost to Make Arrays Unequal (Hard)</li> <li> 3357. Minimize the Maximum Adjacent Element Difference (Hard)</li> </ul>"},{"location":"content/endlesscheng/from_special_to_general/#2745-construct-the-longest-new-string","title":"2745. Construct the Longest New String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, greedy, brainteaser</p> </li> </ul>"},{"location":"content/endlesscheng/from_special_to_general/#2611-mice-and-cheese","title":"2611. Mice and Cheese","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/from_special_to_general/#1029-two-city-scheduling","title":"1029. Two City Scheduling","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/from_special_to_general/#2645-minimum-additions-to-make-valid-string","title":"2645. Minimum Additions to Make Valid String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming, stack, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/from_special_to_general/#2202-maximize-the-topmost-element-after-k-moves","title":"2202. Maximize the Topmost Element After K Moves","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/from_special_to_general/#2568-minimum-impossible-or","title":"2568. Minimum Impossible OR","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation, brainteaser</p> </li> </ul>"},{"location":"content/endlesscheng/from_special_to_general/#1702-maximum-binary-string-after-change","title":"1702. Maximum Binary String After Change","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/from_special_to_general/#3012-minimize-length-of-array-using-operations","title":"3012. Minimize Length of Array Using Operations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, greedy, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/from_special_to_general/#1526-minimum-number-of-increments-on-subarrays-to-form-a-target-array","title":"1526. Minimum Number of Increments on Subarrays to Form a Target Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, stack, greedy, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/from_special_to_general/#2350-shortest-impossible-sequence-of-rolls","title":"2350. Shortest Impossible Sequence of Rolls","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/from_special_to_general/#517-super-washing-machines","title":"517. Super Washing Machines","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/from_special_to_general/#2499-minimum-total-cost-to-make-arrays-unequal","title":"2499. Minimum Total Cost to Make Arrays Unequal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, greedy, counting</p> </li> </ul>"},{"location":"content/endlesscheng/from_special_to_general/#3357-minimize-the-maximum-adjacent-element-difference","title":"3357. Minimize the Maximum Adjacent Element Difference","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/fundamental_cycle/","title":"Fundamental Cycle","text":""},{"location":"content/endlesscheng/fundamental_cycle/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2359. Find Closest Node to Given Two Nodes (Medium)</li> <li> 2360. Longest Cycle in a Graph (Hard)</li> <li> 684. Redundant Connection (Medium)</li> <li> 685. Redundant Connection II (Hard)</li> <li> 2876. Count Visited Nodes in a Directed Graph (Hard)</li> <li> 2127. Maximum Employees to Be Invited to a Meeting (Hard)</li> <li> 2836. Maximize Value of Function in a Ball Passing Game (Hard)</li> <li> 2204. Distance to a Cycle in Undirected Graph (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/fundamental_cycle/#2359-find-closest-node-to-given-two-nodes","title":"2359. Find Closest Node to Given Two Nodes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, graph</p> </li> </ul>"},{"location":"content/endlesscheng/fundamental_cycle/#2360-longest-cycle-in-a-graph","title":"2360. Longest Cycle in a Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort 2360. Longest Cycle in a Graph - Python Solution<pre><code>from typing import List\n\n\ndef longestCycle(edges: List[int]) -&gt; int:\n    n = len(edges)\n    res = -1\n    cur = 1\n    vis = [0 for _ in range(n)]\n\n    for i in range(n):\n        start = cur\n        while i != -1 and vis[i] == 0:\n            vis[i] = cur\n            cur += 1\n            i = edges[i]\n        if i != -1 and vis[i] &gt;= start:\n            res = max(res, cur - vis[i])\n\n    return res\n\n\nif __name__ == \"__main__\":\n    edges = [3, 3, 4, 2, 3]\n    print(longestCycle(edges))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/fundamental_cycle/#684-redundant-connection","title":"684. Redundant Connection","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph 684. Redundant Connection - Python Solution<pre><code>from typing import List\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(1, n + 1)}\n        self.rank = {i: 1 for i in range(1, n + 1)}\n\n    def find(self, n):\n        p = self.par[n]\n        while self.par[p] != p:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return False\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.par[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.par[p1] = p2\n        else:\n            self.par[p2] = p1\n            self.rank[p1] += 1\n\n        return True\n\n\n# Union Find\ndef findRedundantConnectionUF(edges: List[List[int]]) -&gt; List[int]:\n    n = len(edges)\n    uf = UnionFind(n)\n\n    for u, v in edges:\n        if not uf.union(u, v):\n            return (u, v)\n\n\n# DFS\ndef findRedundantConnectionDFS(edges: List[List[int]]) -&gt; List[int]:\n    graph, cycle = {}, {}\n    for a, b in edges:\n        graph.setdefault(a, []).append(b)\n        graph.setdefault(b, []).append(a)\n\n    def dfs(node, parent):\n        if node in cycle:\n            for k in list(cycle.keys()):\n                if k == node:\n                    return True\n                del cycle[k]\n\n        cycle[node] = None\n        for child in graph[node]:\n            if child != parent and dfs(child, node):\n                return True\n        del cycle[node]\n        return False\n\n    dfs(edges[0][0], -1)\n    for a, b in edges[::-1]:\n        if a in cycle and b in cycle:\n            return (a, b)\n\n\nedges = [[1, 2], [1, 3], [2, 3]]\nprint(findRedundantConnectionUF(edges))  # (2, 3)\nprint(findRedundantConnectionDFS(edges))  # (2, 3)\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/fundamental_cycle/#685-redundant-connection-ii","title":"685. Redundant Connection II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph 685. Redundant Connection II - Python Solution<pre><code>from typing import List\n\n\n# Union Find\ndef findRedundantDirectedConnectionUF(edges: List[List[int]]) -&gt; List[int]:\n    n = len(edges)\n    uf = UnionFind(n + 1)\n    parent = list(range(n + 1))\n    candidates = []\n\n    for u, v in edges:\n        if parent[v] != v:\n            candidates.append([parent[v], v])\n            candidates.append([u, v])\n        else:\n            parent[v] = u\n\n    if not candidates:\n        for u, v in edges:\n            if not uf.union(u, v):\n                return [u, v]\n\n    for u, v in edges:\n        if [u, v] == candidates[1]:\n            continue\n        if not uf.union(u, v):\n            return candidates[0]\n\n    return candidates[1]\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(1, n + 1)}\n\n    def find(self, n):\n        p = self.par[n]\n        while p != self.par[p]:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n        if p1 == p2:\n            return False\n        self.par[p1] = p2\n        return True\n\n\nedges = [[1, 2], [1, 3], [2, 3]]\nprint(findRedundantDirectedConnectionUF(edges))\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/fundamental_cycle/#2876-count-visited-nodes-in-a-directed-graph","title":"2876. Count Visited Nodes in a Directed Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, graph, memoization</p> </li> </ul>"},{"location":"content/endlesscheng/fundamental_cycle/#2127-maximum-employees-to-be-invited-to-a-meeting","title":"2127. Maximum Employees to Be Invited to a Meeting","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: depth first search, graph, topological sort</p> </li> </ul>"},{"location":"content/endlesscheng/fundamental_cycle/#2836-maximize-value-of-function-in-a-ball-passing-game","title":"2836. Maximize Value of Function in a Ball Passing Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/fundamental_cycle/#2204-distance-to-a-cycle-in-undirected-graph","title":"2204. Distance to a Cycle in Undirected Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> </ul>"},{"location":"content/endlesscheng/game_theory/","title":"Game Theory","text":""},{"location":"content/endlesscheng/game_theory/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 292. Nim Game (Easy)</li> <li> 1025. Divisor Game (Easy)</li> <li> 3227. Vowels Game in a String (Medium)</li> <li> 2038. Remove Colored Pieces if Both Neighbors are the Same Color (Medium)</li> <li> 877. Stone Game (Medium)</li> <li> 1510. Stone Game IV (Hard)</li> <li> 486. Predict the Winner (Medium)</li> <li> 1690. Stone Game VII (Medium)</li> <li> 1686. Stone Game VI (Medium)</li> <li> 1927. Sum Game (Medium)</li> <li> 1406. Stone Game III (Hard)</li> <li> 1140. Stone Game II (Medium)</li> <li> 1563. Stone Game V (Hard)</li> <li> 464. Can I Win (Medium)</li> <li> 2029. Stone Game IX (Medium)</li> <li> 810. Chalkboard XOR Game (Hard)</li> <li> 1872. Stone Game VIII (Hard)</li> <li> 913. Cat and Mouse (Hard)</li> <li> 1728. Cat and Mouse II (Hard)</li> <li> 294. Flip Game II (Medium) \ud83d\udc51</li> <li> 1908. Game of Nim (Medium) \ud83d\udc51</li> <li> 2005. Subtree Removal Game with Fibonacci Tree (Hard) \ud83d\udc51</li> <li> 2868. The Wording Game (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/game_theory/#292-nim-game","title":"292. Nim Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, brainteaser, game theory</p> </li> </ul>"},{"location":"content/endlesscheng/game_theory/#1025-divisor-game","title":"1025. Divisor Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, dynamic programming, brainteaser, game theory</p> </li> <li>Return <code>True</code> if Alice wins the game, assuming both players play optimally.</li> <li><code>dp[n]</code> stores the result of the game when the number is <code>n</code>.</li> <li>Initialize <code>dp[1] = False</code>.</li> </ul> 1025. Divisor Game - Python Solution<pre><code># DP\ndef divisorGameDP(n: int) -&gt; bool:\n    if n &lt;= 1:\n        return False\n\n    dp = [False for _ in range(n + 1)]\n\n    for i in range(2, n + 1):\n        for j in range(1, i):\n            if i % j == 0 and not dp[i - j]:\n                dp[i] = True\n                break\n\n    return dp[n]\n\n\n# Math\ndef divisorGameDPMath(n: int) -&gt; bool:\n    return n % 2 == 0\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |  DP         |      O(n^2)     |    O(n)      |\n# |  Math       |      O(1)       |    O(1)      |\n# |-------------|-----------------|--------------|\n\nn = 2\nprint(divisorGameDP(n))  # True\nprint(divisorGameDPMath(n))  # True\n</code></pre>"},{"location":"content/endlesscheng/game_theory/#3227-vowels-game-in-a-string","title":"3227. Vowels Game in a String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, string, brainteaser, game theory</p> </li> </ul>"},{"location":"content/endlesscheng/game_theory/#2038-remove-colored-pieces-if-both-neighbors-are-the-same-color","title":"2038. Remove Colored Pieces if Both Neighbors are the Same Color","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, string, greedy, game theory</p> </li> </ul>"},{"location":"content/endlesscheng/game_theory/#877-stone-game","title":"877. Stone Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, dynamic programming, game theory</p> </li> </ul>"},{"location":"content/endlesscheng/game_theory/#1510-stone-game-iv","title":"1510. Stone Game IV","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, dynamic programming, game theory</p> </li> </ul>"},{"location":"content/endlesscheng/game_theory/#486-predict-the-winner","title":"486. Predict the Winner","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, dynamic programming, recursion, game theory</p> </li> </ul>"},{"location":"content/endlesscheng/game_theory/#1690-stone-game-vii","title":"1690. Stone Game VII","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, dynamic programming, game theory</p> </li> </ul>"},{"location":"content/endlesscheng/game_theory/#1686-stone-game-vi","title":"1686. Stone Game VI","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, greedy, sorting, heap priority queue, game theory</p> </li> </ul>"},{"location":"content/endlesscheng/game_theory/#1927-sum-game","title":"1927. Sum Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, string, greedy, game theory</p> </li> </ul>"},{"location":"content/endlesscheng/game_theory/#1406-stone-game-iii","title":"1406. Stone Game III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, dynamic programming, game theory</p> </li> </ul>"},{"location":"content/endlesscheng/game_theory/#1140-stone-game-ii","title":"1140. Stone Game II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, dynamic programming, prefix sum, game theory</p> </li> </ul>"},{"location":"content/endlesscheng/game_theory/#1563-stone-game-v","title":"1563. Stone Game V","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, dynamic programming, game theory</p> </li> </ul>"},{"location":"content/endlesscheng/game_theory/#464-can-i-win","title":"464. Can I Win","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, bit manipulation, memoization, game theory, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/game_theory/#2029-stone-game-ix","title":"2029. Stone Game IX","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, greedy, counting, game theory</p> </li> </ul>"},{"location":"content/endlesscheng/game_theory/#810-chalkboard-xor-game","title":"810. Chalkboard XOR Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, bit manipulation, brainteaser, game theory</p> </li> </ul>"},{"location":"content/endlesscheng/game_theory/#1872-stone-game-viii","title":"1872. Stone Game VIII","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, dynamic programming, prefix sum, game theory</p> </li> </ul>"},{"location":"content/endlesscheng/game_theory/#913-cat-and-mouse","title":"913. Cat and Mouse","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, dynamic programming, graph, topological sort, memoization, game theory</p> </li> </ul>"},{"location":"content/endlesscheng/game_theory/#1728-cat-and-mouse-ii","title":"1728. Cat and Mouse II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, dynamic programming, graph, topological sort, memoization, matrix, game theory</p> </li> </ul>"},{"location":"content/endlesscheng/game_theory/#294-flip-game-ii","title":"294. Flip Game II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, backtracking, memoization, game theory</p> </li> </ul>"},{"location":"content/endlesscheng/game_theory/#1908-game-of-nim","title":"1908. Game of Nim","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, dynamic programming, bit manipulation, brainteaser, game theory</p> </li> </ul>"},{"location":"content/endlesscheng/game_theory/#2005-subtree-removal-game-with-fibonacci-tree","title":"2005. Subtree Removal Game with Fibonacci Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, dynamic programming, tree, binary tree, game theory</p> </li> </ul>"},{"location":"content/endlesscheng/game_theory/#2868-the-wording-game","title":"2868. The Wording Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, two pointers, string, greedy, game theory</p> </li> </ul>"},{"location":"content/endlesscheng/gcd_union_find/","title":"GCD Union Find","text":""},{"location":"content/endlesscheng/gcd_union_find/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2709. Greatest Common Divisor Traversal (Hard)</li> <li> 1627. Graph Connectivity With Threshold (Hard)</li> <li> 952. Largest Component Size by Common Factor (Hard)</li> <li> 1998. GCD Sort of an Array (Hard)</li> <li> 3378. Count Connected Components in LCM Graph (Hard)</li> </ul>"},{"location":"content/endlesscheng/gcd_union_find/#2709-greatest-common-divisor-traversal","title":"2709. Greatest Common Divisor Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, union find, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/gcd_union_find/#1627-graph-connectivity-with-threshold","title":"1627. Graph Connectivity With Threshold","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, union find, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/gcd_union_find/#952-largest-component-size-by-common-factor","title":"952. Largest Component Size by Common Factor","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, math, union find, number theory 952. Largest Component Size by Common Factor - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef largestComponentSize(nums: List[int]) -&gt; int:\n    par = {i: i for i in nums}\n    rank = {i: 0 for i in nums}\n\n    def find(n):\n        p = par[n]\n        while par[p] != p:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            if rank[p1] &gt; rank[p2]:\n                par[p2] = p1\n            elif rank[p1] &lt; rank[p2]:\n                par[p1] = p2\n            else:\n                par[p2] = p1\n                rank[p1] += 1\n\n    def prime_factors(n):\n        \"\"\"Return the prime factors of n.\"\"\"\n        i = 2\n        factors = set()\n        while i * i &lt;= n:\n            while (n % i) == 0:\n                factors.add(i)\n                n //= i\n            i += 1\n        if n &gt; 1:\n            factors.add(n)\n        return factors\n\n    factor_map = defaultdict(list)  # factor -&gt; [nums]\n    for num in nums:\n        factors = prime_factors(num)\n        for factor in factors:\n            factor_map[factor].append(num)\n\n    for factor, group in factor_map.items():\n        for i in range(1, len(group)):\n            union(group[0], group[i])\n\n    sizes = defaultdict(int)  # component root -&gt; size\n    for num in nums:\n        root = find(num)\n        sizes[root] += 1\n\n    return max(sizes.values())\n\n\nnums = [20, 50, 9, 63]\nprint(largestComponentSize(nums))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/gcd_union_find/#1998-gcd-sort-of-an-array","title":"1998. GCD Sort of an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, union find, sorting, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/gcd_union_find/#3378-count-connected-components-in-lcm-graph","title":"3378. Count Connected Components in LCM Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, math, union find, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/general_tree_bottom-up_dfs/","title":"General Tree Bottom-Up DFS","text":""},{"location":"content/endlesscheng/general_tree_bottom-up_dfs/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3249. Count the Number of Good Nodes (Medium)</li> <li> 1519. Number of Nodes in the Sub-Tree With the Same Label (Medium)</li> <li> 2872. Maximum Number of K-Divisible Components (Hard)</li> <li> 2477. Minimum Fuel Cost to Report to the Capital (Medium)</li> <li> 2973. Find Number of Coins to Place in Tree Nodes (Hard)</li> <li> 2440. Create Components With Same Value (Hard)</li> <li> 1273. Delete Tree Nodes (Medium) \ud83d\udc51</li> <li> 3004. Maximum Subtree of the Same Color (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/general_tree_bottom-up_dfs/#3249-count-the-number-of-good-nodes","title":"3249. Count the Number of Good Nodes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search</p> </li> </ul>"},{"location":"content/endlesscheng/general_tree_bottom-up_dfs/#1519-number-of-nodes-in-the-sub-tree-with-the-same-label","title":"1519. Number of Nodes in the Sub-Tree With the Same Label","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, tree, depth first search, breadth first search, counting</p> </li> </ul>"},{"location":"content/endlesscheng/general_tree_bottom-up_dfs/#2872-maximum-number-of-k-divisible-components","title":"2872. Maximum Number of K-Divisible Components","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: tree, depth first search</p> </li> </ul>"},{"location":"content/endlesscheng/general_tree_bottom-up_dfs/#2477-minimum-fuel-cost-to-report-to-the-capital","title":"2477. Minimum Fuel Cost to Report to the Capital","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, graph</p> </li> </ul>"},{"location":"content/endlesscheng/general_tree_bottom-up_dfs/#2973-find-number-of-coins-to-place-in-tree-nodes","title":"2973. Find Number of Coins to Place in Tree Nodes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, tree, depth first search, sorting, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/general_tree_bottom-up_dfs/#2440-create-components-with-same-value","title":"2440. Create Components With Same Value","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, tree, depth first search, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/general_tree_bottom-up_dfs/#1273-delete-tree-nodes","title":"1273. Delete Tree Nodes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, tree, depth first search, breadth first search</p> </li> </ul>"},{"location":"content/endlesscheng/general_tree_bottom-up_dfs/#3004-maximum-subtree-of-the-same-color","title":"3004. Maximum Subtree of the Same Color","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, tree, depth first search</p> </li> </ul>"},{"location":"content/endlesscheng/general_tree_dfs_timestamp/","title":"General Tree DFS Timestamp","text":""},{"location":"content/endlesscheng/general_tree_dfs_timestamp/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2322. Minimum Score After Removals on a Tree (Hard)</li> <li> 3327. Check if DFS Strings Are Palindromes (Hard)</li> </ul>"},{"location":"content/endlesscheng/general_tree_dfs_timestamp/#2322-minimum-score-after-removals-on-a-tree","title":"2322. Minimum Score After Removals on a Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, bit manipulation, tree, depth first search</p> </li> </ul>"},{"location":"content/endlesscheng/general_tree_dfs_timestamp/#3327-check-if-dfs-strings-are-palindromes","title":"3327. Check if DFS Strings Are Palindromes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, string, tree, depth first search, hash function</p> </li> </ul>"},{"location":"content/endlesscheng/general_tree_diameter/","title":"General Tree Diameter","text":""},{"location":"content/endlesscheng/general_tree_diameter/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2246. Longest Path With Different Adjacent Characters (Hard)</li> <li> 3203. Find Minimum Diameter After Merging Two Trees (Hard)</li> <li> 1617. Count Subtrees With Max Distance Between Cities (Hard)</li> <li> 2538. Difference Between Maximum and Minimum Price Sum (Hard)</li> <li> 1245. Tree Diameter (Medium) \ud83d\udc51</li> <li> 3313. Find the Last Marked Nodes in Tree (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/general_tree_diameter/#2246-longest-path-with-different-adjacent-characters","title":"2246. Longest Path With Different Adjacent Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, tree, depth first search, graph, topological sort</p> </li> </ul>"},{"location":"content/endlesscheng/general_tree_diameter/#3203-find-minimum-diameter-after-merging-two-trees","title":"3203. Find Minimum Diameter After Merging Two Trees","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, graph</p> </li> </ul>"},{"location":"content/endlesscheng/general_tree_diameter/#1617-count-subtrees-with-max-distance-between-cities","title":"1617. Count Subtrees With Max Distance Between Cities","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, bit manipulation, tree, enumeration, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/general_tree_diameter/#2538-difference-between-maximum-and-minimum-price-sum","title":"2538. Difference Between Maximum and Minimum Price Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, tree, depth first search</p> </li> </ul>"},{"location":"content/endlesscheng/general_tree_diameter/#1245-tree-diameter","title":"1245. Tree Diameter","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, graph, topological sort 1245. Tree Diameter - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# Tree Diameter\ndef treeDiameter(edges: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = {0}\n    q = deque([0])\n    cur = 0\n\n    while q:\n        size = len(q)\n        for _ in range(size):\n            cur = q.popleft()\n            for nxt in graph[cur]:\n                if nxt not in visited:\n                    q.append(nxt)\n                    visited.add(nxt)\n\n    visited = {cur}\n    q = deque([cur])\n    res = -1\n\n    while q:\n        size = len(q)\n        for _ in range(size):\n            cur = q.popleft()\n            for nxt in graph[cur]:\n                if nxt not in visited:\n                    q.append(nxt)\n                    visited.add(nxt)\n        res += 1\n\n    return res\n\n\nedges = [[0, 1], [1, 2], [2, 3], [1, 4], [4, 5]]\nassert treeDiameter(edges) == 4\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/general_tree_diameter/#3313-find-the-last-marked-nodes-in-tree","title":"3313. Find the Last Marked Nodes in Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: tree, depth first search</p> </li> </ul>"},{"location":"content/endlesscheng/general_tree_lowest_common_ancestor/","title":"General Tree Lowest Common Ancestor","text":""},{"location":"content/endlesscheng/general_tree_lowest_common_ancestor/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1483. Kth Ancestor of a Tree Node (Hard)</li> <li> 2846. Minimum Edge Weight Equilibrium Queries in a Tree (Hard)</li> <li> 2277. Closest Node to Path in Tree (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/general_tree_lowest_common_ancestor/#1483-kth-ancestor-of-a-tree-node","title":"1483. Kth Ancestor of a Tree Node","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: binary search, dynamic programming, tree, depth first search, breadth first search, design</p> </li> </ul>"},{"location":"content/endlesscheng/general_tree_lowest_common_ancestor/#2846-minimum-edge-weight-equilibrium-queries-in-a-tree","title":"2846. Minimum Edge Weight Equilibrium Queries in a Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, tree, graph, strongly connected component</p> </li> </ul>"},{"location":"content/endlesscheng/general_tree_lowest_common_ancestor/#2277-closest-node-to-path-in-tree","title":"2277. Closest Node to Path in Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, tree, depth first search, breadth first search</p> </li> </ul>"},{"location":"content/endlesscheng/general_tree_others/","title":"General Tree Others","text":""},{"location":"content/endlesscheng/general_tree_others/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2003. Smallest Missing Genetic Value in Each Subtree (Hard)</li> <li> 2867. Count Valid Paths in a Tree (Hard)</li> <li> 2421. Number of Good Paths (Hard)</li> <li> 1719. Number Of Ways To Reconstruct A Tree (Hard)</li> <li> 2479. Maximum XOR of Two Non-Overlapping Subtrees (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/general_tree_others/#2003-smallest-missing-genetic-value-in-each-subtree","title":"2003. Smallest Missing Genetic Value in Each Subtree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, tree, depth first search, union find</p> </li> </ul>"},{"location":"content/endlesscheng/general_tree_others/#2867-count-valid-paths-in-a-tree","title":"2867. Count Valid Paths in a Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, dynamic programming, tree, depth first search, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/general_tree_others/#2421-number-of-good-paths","title":"2421. Number of Good Paths","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, tree, union find, graph, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/general_tree_others/#1719-number-of-ways-to-reconstruct-a-tree","title":"1719. Number Of Ways To Reconstruct A Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: tree, graph</p> </li> </ul>"},{"location":"content/endlesscheng/general_tree_others/#2479-maximum-xor-of-two-non-overlapping-subtrees","title":"2479. Maximum XOR of Two Non-Overlapping Subtrees","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: tree, depth first search, graph, trie</p> </li> </ul>"},{"location":"content/endlesscheng/general_tree_recursion/","title":"General Tree Recursion","text":""},{"location":"content/endlesscheng/general_tree_recursion/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3331. Find Subtree Sizes After Changes (Medium)</li> </ul>"},{"location":"content/endlesscheng/general_tree_recursion/#3331-find-subtree-sizes-after-changes","title":"3331. Find Subtree Sizes After Changes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, tree, depth first search</p> </li> </ul>"},{"location":"content/endlesscheng/general_tree_top-down_dfs/","title":"General Tree Top-Down DFS","text":""},{"location":"content/endlesscheng/general_tree_top-down_dfs/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1376. Time Needed to Inform All Employees (Medium)</li> <li> 1443. Minimum Time to Collect All Apples in a Tree (Medium)</li> <li> 1377. Frog Position After T Seconds (Hard)</li> <li> 3067. Count Pairs of Connectable Servers in a Weighted Tree Network (Medium)</li> <li> 3372. Maximize the Number of Target Nodes After Connecting Trees I (Medium)</li> <li> 2467. Most Profitable Path in a Tree (Medium)</li> <li> 3373. Maximize the Number of Target Nodes After Connecting Trees II (Hard)</li> <li> 1766. Tree of Coprimes (Hard)</li> <li> 3425. Longest Special Path (Hard)</li> <li> 2791. Count Paths That Can Form a Palindrome in a Tree (Hard)</li> </ul>"},{"location":"content/endlesscheng/general_tree_top-down_dfs/#1376-time-needed-to-inform-all-employees","title":"1376. Time Needed to Inform All Employees","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search 1376. Time Needed to Inform All Employees - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# DFS\ndef numOfMinutesDFS(\n    n: int, headID: int, manager: List[int], informTime: List[int]\n) -&gt; int:\n    graph = defaultdict(list)\n    for i in range(n):\n        if manager[i] != -1:\n            graph[manager[i]].append(i)\n\n    def dfs(node):\n        time = 0\n        for sub in graph[node]:\n            time = max(time, dfs(sub))\n        return time + informTime[node]\n\n    return dfs(headID)\n\n\n# BFS\ndef numOfMinutesBFS(\n    n: int, headID: int, manager: List[int], informTime: List[int]\n) -&gt; int:\n    graph = defaultdict(list)\n    for i in range(n):\n        if manager[i] != -1:\n            graph[manager[i]].append(i)\n\n    q = deque([(headID, 0)])\n    max_time = 0\n\n    while q:\n        node, time = q.popleft()\n        max_time = max(max_time, time)\n        for sub in graph[node]:\n            q.append((sub, time + informTime[node]))\n\n    return max_time\n\n\nn = 6\nheadID = 2\nmanager = [2, 2, -1, 2, 2, 2]\ninformTime = [0, 0, 1, 0, 0, 0]\nprint(numOfMinutesDFS(n, headID, manager, informTime))  # 1\nprint(numOfMinutesBFS(n, headID, manager, informTime))  # 1\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/general_tree_top-down_dfs/#1443-minimum-time-to-collect-all-apples-in-a-tree","title":"1443. Minimum Time to Collect All Apples in a Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, tree, depth first search, breadth first search</p> </li> </ul>"},{"location":"content/endlesscheng/general_tree_top-down_dfs/#1377-frog-position-after-t-seconds","title":"1377. Frog Position After T Seconds","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, graph</p> </li> </ul>"},{"location":"content/endlesscheng/general_tree_top-down_dfs/#3067-count-pairs-of-connectable-servers-in-a-weighted-tree-network","title":"3067. Count Pairs of Connectable Servers in a Weighted Tree Network","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, tree, depth first search</p> </li> </ul>"},{"location":"content/endlesscheng/general_tree_top-down_dfs/#3372-maximize-the-number-of-target-nodes-after-connecting-trees-i","title":"3372. Maximize the Number of Target Nodes After Connecting Trees I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search 3372. Maximize the Number of Target Nodes After Connecting Trees I - Python Solution<pre><code>from typing import Callable, List, Tuple\n\n\ndef maxTargetNodes(\n    edges1: List[List[int]], edges2: List[List[int]], k: int\n) -&gt; List[int]:\n    n = len(edges1) + 1\n    m = len(edges2) + 1\n\n    def calc_tree(\n        edges: List[List[int]], k: int\n    ) -&gt; Tuple[int, Callable[[int, int, int], int]]:\n        g = [[] for _ in range(len(edges) + 1)]\n        for x, y in edges:\n            g[x].append(y)\n            g[y].append(x)\n\n        diameter = 0\n\n        def dfs_diameter(x: int, fa: int) -&gt; int:\n            nonlocal diameter\n            max_len = 0\n            for y in g[x]:\n                if y != fa:\n                    sub_len = dfs_diameter(y, x) + 1\n                    diameter = max(diameter, max_len + sub_len)\n                    max_len = max(max_len, sub_len)\n            return max_len\n\n        dfs_diameter(0, -1)\n\n        def dfs(x: int, fa: int, d: int) -&gt; int:\n            if d &gt; k:\n                return 0\n            cnt = 1\n            for y in g[x]:\n                if y != fa:\n                    cnt += dfs(y, x, d + 1)\n            return cnt\n\n        return diameter, dfs\n\n    max2 = 0\n    if k:\n        diameter, dfs = calc_tree(edges2, k - 1)\n        if diameter &lt; k:\n            max2 = m  # All nodes in the second tree are target nodes\n        else:\n            max2 = max(dfs(i, -1, 0) for i in range(m))\n\n    diameter, dfs = calc_tree(edges1, k)\n    if diameter &lt;= k:\n        return [n + max2] * n  # All nodes in the first tree are target nodes\n    return [dfs(i, -1, 0) + max2 for i in range(n)]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/general_tree_top-down_dfs/#2467-most-profitable-path-in-a-tree","title":"2467. Most Profitable Path in a Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, tree, depth first search, breadth first search, graph</p> </li> </ul>"},{"location":"content/endlesscheng/general_tree_top-down_dfs/#3373-maximize-the-number-of-target-nodes-after-connecting-trees-ii","title":"3373. Maximize the Number of Target Nodes After Connecting Trees II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search</p> </li> </ul>"},{"location":"content/endlesscheng/general_tree_top-down_dfs/#1766-tree-of-coprimes","title":"1766. Tree of Coprimes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, tree, depth first search, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/general_tree_top-down_dfs/#3425-longest-special-path","title":"3425. Longest Special Path","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, tree, depth first search, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/general_tree_top-down_dfs/#2791-count-paths-that-can-form-a-palindrome-in-a-tree","title":"2791. Count Paths That Can Form a Palindrome in a Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, bit manipulation, tree, depth first search, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/general_tree_topological_sort/","title":"General Tree Topological Sort","text":""},{"location":"content/endlesscheng/general_tree_topological_sort/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 310. Minimum Height Trees (Medium)</li> <li> 2603. Collect Coins in a Tree (Hard)</li> </ul>"},{"location":"content/endlesscheng/general_tree_topological_sort/#310-minimum-height-trees","title":"310. Minimum Height Trees","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort 310. Minimum Height Trees - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\ndef findMinHeightTrees(n: int, edges: List[List[int]]) -&gt; List[int]:\n    if n == 1:\n        return [0]\n\n    graph = {i: set() for i in range(n)}\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    q = deque([i for i in range(n) if len(graph[i]) == 1])\n    remaining = n\n\n    while remaining &gt; 2:\n        size = len(q)\n        remaining -= size\n\n        for _ in range(size):\n            cur = q.popleft()\n            nei = graph[cur].pop()\n            graph[nei].remove(cur)\n\n            if len(graph[nei]) == 1:\n                q.append(nei)\n\n    return list(q)\n\n\nn = 6\nedges = [[3, 0], [3, 1], [3, 2], [3, 4], [5, 4]]\nprint(findMinHeightTrees(n, edges))  # [3, 4]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/general_tree_topological_sort/#2603-collect-coins-in-a-tree","title":"2603. Collect Coins in a Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, tree, graph, topological sort</p> </li> </ul>"},{"location":"content/endlesscheng/general_tree_traversal/","title":"General Tree Traversal","text":""},{"location":"content/endlesscheng/general_tree_traversal/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2368. Reachable Nodes With Restrictions (Medium)</li> <li> 1466. Reorder Routes to Make All Paths Lead to the City Zero (Medium)</li> <li> 582. Kill Process (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/general_tree_traversal/#2368-reachable-nodes-with-restrictions","title":"2368. Reachable Nodes With Restrictions","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, tree, depth first search, breadth first search, union find, graph</p> </li> </ul>"},{"location":"content/endlesscheng/general_tree_traversal/#1466-reorder-routes-to-make-all-paths-lead-to-the-city-zero","title":"1466. Reorder Routes to Make All Paths Lead to the City Zero","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph</p> </li> <li></li> </ul> 1466. Reorder Routes to Make All Paths Lead to the City Zero - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef minReorderBFS(n: int, connections: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append((v, 1))  # go\n        graph[v].append((u, 0))  # come\n\n    changes = 0\n    q = deque([(0, -1)])\n\n    while q:\n        n1, d1 = q.popleft()\n\n        for n2, d2 in graph[n1]:\n            if n2 != d1:\n                changes += d2\n                q.append((n2, n1))\n\n    return changes\n\n\n# DFS\ndef minReorderDFS(n: int, connections: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append((v, 1))  # go\n        graph[v].append((u, 0))  # come\n\n    def dfs(n1, d1):\n        changes = 0\n        for n2, d2 in graph[n1]:\n            if n2 != d1:\n                changes += d2 + dfs(n2, n1)\n        return changes\n\n    return dfs(0, -1)\n\n\nn = 5\nconnections = [[1, 0], [1, 2], [3, 2], [3, 4]]\nprint(minReorderBFS(n, connections))  # 2\nprint(minReorderDFS(n, connections))  # 2\n</code></pre>"},{"location":"content/endlesscheng/general_tree_traversal/#582-kill-process","title":"582. Kill Process","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, tree, depth first search, breadth first search 582. Kill Process - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef killProcess(pid: List[int], ppid: List[int], kill: int) -&gt; List[int]:\n    graph = defaultdict(list)\n\n    for u, v in zip(ppid, pid):\n        graph[u].append(v)\n\n    q = deque([kill])\n    res = []\n\n    while q:\n        cur = q.popleft()\n        res.append(cur)\n        for nxt in graph[cur]:\n            q.append(nxt)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    pid = [1, 3, 10, 5]\n    ppid = [3, 0, 5, 3]\n    kill = 5\n    assert killProcess(pid, ppid, kill) == [5, 10]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/graph_others/","title":"Graph Others","text":""},{"location":"content/endlesscheng/graph_others/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1042. Flower Planting With No Adjacent (Medium)</li> <li> 1761. Minimum Degree of a Connected Trio in a Graph (Hard)</li> <li> 2508. Add Edges to Make Degrees of All Nodes Even (Hard)</li> <li> 1579. Remove Max Number of Edges to Keep Graph Fully Traversable (Hard)</li> <li> 2065. Maximum Path Quality of a Graph (Hard)</li> <li> 1697. Checking Existence of Edge Length Limited Paths (Hard)</li> <li> 2242. Maximum Score of a Node Sequence (Hard)</li> <li> 2493. Divide Nodes Into the Maximum Number of Groups (Hard)</li> <li> 1782. Count Pairs Of Nodes (Hard)</li> <li> 3435. Frequencies of Shortest Supersequences (Hard)</li> <li> 277. Find the Celebrity (Medium) \ud83d\udc51</li> <li> 1724. Checking Existence of Edge Length Limited Paths II (Hard) \ud83d\udc51</li> <li> 2077. Paths in Maze That Lead to Same Room (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/graph_others/#1042-flower-planting-with-no-adjacent","title":"1042. Flower Planting With No Adjacent","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph</p> </li> </ul>"},{"location":"content/endlesscheng/graph_others/#1761-minimum-degree-of-a-connected-trio-in-a-graph","title":"1761. Minimum Degree of a Connected Trio in a Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: graph</p> </li> </ul>"},{"location":"content/endlesscheng/graph_others/#2508-add-edges-to-make-degrees-of-all-nodes-even","title":"2508. Add Edges to Make Degrees of All Nodes Even","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, graph</p> </li> </ul>"},{"location":"content/endlesscheng/graph_others/#1579-remove-max-number-of-edges-to-keep-graph-fully-traversable","title":"1579. Remove Max Number of Edges to Keep Graph Fully Traversable","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: union find, graph</p> </li> <li>Return the maximum number of edges you can remove so that the graph remains fully traversable.</li> </ul> <p></p> 1579. Remove Max Number of Edges to Keep Graph Fully Traversable - Python Solution<pre><code>from typing import List\n\n\n# Kruskal\ndef maxNumEdgesToRemove(n: int, edges: List[List[int]]) -&gt; int:\n    alice, bob = UnionFind(n), UnionFind(n)\n    visited = 0\n\n    for t, u, v in edges:\n        if t == 3:\n            if alice.union(u, v) | bob.union(u, v):\n                visited += 1\n\n    for t, u, v in edges:\n        if t == 1:\n            if alice.union(u, v):\n                visited += 1\n        elif t == 2:\n            if bob.union(u, v):\n                visited += 1\n\n    if alice.components &gt; 1 or bob.components &gt; 1:\n        return -1\n\n    return len(edges) - visited\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = {i: i for i in range(1, n + 1)}\n        self.rank = {i: 0 for i in range(1, n + 1)}\n        self.components = n\n\n    def find(self, n):\n        p = self.parent[n]\n        while self.parent[p] != p:\n            self.parent[p] = self.parent[self.parent[p]]\n            p = self.parent[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return False\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.parent[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.parent[p1] = p2\n        else:\n            self.parent[p2] = p1\n            self.rank[p1] += 1\n\n        self.components -= 1\n\n        return True\n\n\nn = 4\nedges = [[3, 1, 2], [3, 2, 3], [1, 1, 3], [1, 2, 4], [1, 1, 2], [2, 3, 4]]\nprint(maxNumEdgesToRemove(n, edges))  # 2\n</code></pre>"},{"location":"content/endlesscheng/graph_others/#2065-maximum-path-quality-of-a-graph","title":"2065. Maximum Path Quality of a Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, backtracking, graph</p> </li> </ul>"},{"location":"content/endlesscheng/graph_others/#1697-checking-existence-of-edge-length-limited-paths","title":"1697. Checking Existence of Edge Length Limited Paths","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, union find, graph, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/graph_others/#2242-maximum-score-of-a-node-sequence","title":"2242. Maximum Score of a Node Sequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, graph, sorting, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/graph_others/#2493-divide-nodes-into-the-maximum-number-of-groups","title":"2493. Divide Nodes Into the Maximum Number of Groups","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> </ul>"},{"location":"content/endlesscheng/graph_others/#1782-count-pairs-of-nodes","title":"1782. Count Pairs Of Nodes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, binary search, graph, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/graph_others/#3435-frequencies-of-shortest-supersequences","title":"3435. Frequencies of Shortest Supersequences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, bit manipulation, graph, topological sort, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/graph_others/#277-find-the-celebrity","title":"277. Find the Celebrity","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, graph, interactive</p> </li> </ul>"},{"location":"content/endlesscheng/graph_others/#1724-checking-existence-of-edge-length-limited-paths-ii","title":"1724. Checking Existence of Edge Length Limited Paths II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: union find, graph, minimum spanning tree</p> </li> </ul>"},{"location":"content/endlesscheng/graph_others/#2077-paths-in-maze-that-lead-to-same-room","title":"2077. Paths in Maze That Lead to Same Room","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: graph</p> </li> </ul>"},{"location":"content/endlesscheng/greatest_common_divisor/","title":"Greatest Common Divisor","text":""},{"location":"content/endlesscheng/greatest_common_divisor/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1979. Find Greatest Common Divisor of Array (Easy)</li> <li> 2807. Insert Greatest Common Divisors in Linked List (Medium)</li> <li> 914. X of a Kind in a Deck of Cards (Easy)</li> <li> 1071. Greatest Common Divisor of Strings (Easy)</li> <li> 2344. Minimum Deletions to Make Array Divisible (Hard)</li> <li> 365. Water and Jug Problem (Medium)</li> <li> 858. Mirror Reflection (Medium)</li> <li> 2654. Minimum Number of Operations to Make All Array Elements Equal to 1 (Medium)</li> <li> 1250. Check If It Is a Good Array (Hard)</li> <li> 149. Max Points on a Line (Hard)</li> <li> 2607. Make K-Subarray Sums Equal (Medium)</li> <li> 2447. Number of Subarrays With GCD Equal to K (Medium)</li> <li> 2543. Check if Point Is Reachable (Hard)</li> <li> 2183. Count Array Pairs Divisible by K (Hard)</li> <li> 3312. Sorted GCD Pair Queries (Hard)</li> <li> 1819. Number of Different Subsequences GCDs (Hard)</li> <li> 2436. Minimum Split Into Subarrays With GCD Greater Than One (Medium) \ud83d\udc51</li> <li> 2464. Minimum Subarrays in a Valid Split (Medium) \ud83d\udc51</li> <li> 2941. Maximum GCD-Sum of a Subarray (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/greatest_common_divisor/#1979-find-greatest-common-divisor-of-array","title":"1979. Find Greatest Common Divisor of Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, math, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/greatest_common_divisor/#2807-insert-greatest-common-divisors-in-linked-list","title":"2807. Insert Greatest Common Divisors in Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, math, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/greatest_common_divisor/#914-x-of-a-kind-in-a-deck-of-cards","title":"914. X of a Kind in a Deck of Cards","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, math, counting, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/greatest_common_divisor/#1071-greatest-common-divisor-of-strings","title":"1071. Greatest Common Divisor of Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, string</p> </li> </ul>"},{"location":"content/endlesscheng/greatest_common_divisor/#2344-minimum-deletions-to-make-array-divisible","title":"2344. Minimum Deletions to Make Array Divisible","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, sorting, heap priority queue, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/greatest_common_divisor/#365-water-and-jug-problem","title":"365. Water and Jug Problem","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, depth first search, breadth first search</p> </li> </ul>"},{"location":"content/endlesscheng/greatest_common_divisor/#858-mirror-reflection","title":"858. Mirror Reflection","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, geometry, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/greatest_common_divisor/#2654-minimum-number-of-operations-to-make-all-array-elements-equal-to-1","title":"2654. Minimum Number of Operations to Make All Array Elements Equal to 1","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/greatest_common_divisor/#1250-check-if-it-is-a-good-array","title":"1250. Check If It Is a Good Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/greatest_common_divisor/#149-max-points-on-a-line","title":"149. Max Points on a Line","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, math, geometry 149. Max Points on a Line - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# GCD\ndef maxPoints(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    if n &lt;= 2:\n        return n\n\n    res = 0\n\n    for i in range(n - 1):\n        x1, y1 = points[i]\n        cnt = defaultdict(int)\n\n        for j in range(i + 1, n):\n            x2, y2 = points[j]\n            g = \"inf\" if x1 == x2 else (y2 - y1) / (x2 - x1)\n            cnt[g] += 1\n\n        res = max(res, 1 + max(cnt.values()))\n\n    return res\n\n\npoints = [[1, 1], [3, 2], [5, 3], [4, 1], [2, 3], [1, 4]]\nprint(maxPoints(points))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/greatest_common_divisor/#2607-make-k-subarray-sums-equal","title":"2607. Make K-Subarray Sums Equal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, greedy, sorting, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/greatest_common_divisor/#2447-number-of-subarrays-with-gcd-equal-to-k","title":"2447. Number of Subarrays With GCD Equal to K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/greatest_common_divisor/#2543-check-if-point-is-reachable","title":"2543. Check if Point Is Reachable","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/greatest_common_divisor/#2183-count-array-pairs-divisible-by-k","title":"2183. Count Array Pairs Divisible by K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/greatest_common_divisor/#3312-sorted-gcd-pair-queries","title":"3312. Sorted GCD Pair Queries","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, math, binary search, combinatorics, counting, number theory, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/greatest_common_divisor/#1819-number-of-different-subsequences-gcds","title":"1819. Number of Different Subsequences GCDs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, counting, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/greatest_common_divisor/#2436-minimum-split-into-subarrays-with-gcd-greater-than-one","title":"2436. Minimum Split Into Subarrays With GCD Greater Than One","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, dynamic programming, greedy, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/greatest_common_divisor/#2464-minimum-subarrays-in-a-valid-split","title":"2464. Minimum Subarrays in a Valid Split","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, dynamic programming, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/greatest_common_divisor/#2941-maximum-gcd-sum-of-a-subarray","title":"2941. Maximum GCD-Sum of a Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, binary search, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_left_right/","title":"Greedy from Left Right","text":""},{"location":"content/endlesscheng/greedy_from_left_right/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3402. Minimum Operations to Make Columns Strictly Increasing (Easy)</li> <li> 3191. Minimum Operations to Make Binary Array Elements Equal to One I (Medium)</li> <li> 1827. Minimum Operations to Make the Array Increasing (Easy)</li> <li> 2027. Minimum Moves to Convert String (Easy)</li> <li> 605. Can Place Flowers (Easy)</li> <li> 3111. Minimum Rectangles to Cover Points (Medium)</li> <li> 2957. Remove Adjacent Almost-Equal Characters (Medium)</li> <li> 3192. Minimum Operations to Make Binary Array Elements Equal to One II (Medium)</li> <li> 2789. Largest Element in an Array after Merge Operations (Medium)</li> <li> 1529. Minimum Suffix Flips (Medium)</li> <li> 1144. Decrease Elements To Make Array Zigzag (Medium)</li> <li> 3228. Maximum Number of Operations to Move Ones to the End (Medium)</li> <li> 2086. Minimum Number of Food Buckets to Feed the Hamsters (Medium)</li> <li> 2571. Minimum Operations to Reduce an Integer to 0 (Medium)</li> <li> 2712. Minimum Cost to Make All Characters Equal (Medium)</li> <li> 3326. Minimum Division Operations to Make Array Non Decreasing (Medium)</li> <li> 1536. Minimum Swaps to Arrange a Binary Grid (Medium)</li> <li> 2673. Make Costs of Paths Equal in a Binary Tree (Medium)</li> <li> 861. Score After Flipping Matrix (Medium)</li> <li> 955. Delete Columns to Make Sorted II (Medium)</li> <li> 2366. Minimum Replacements to Sort the Array (Hard)</li> <li> 2193. Minimum Number of Moves to Make Palindrome (Hard)</li> <li> 2528. Maximize the Minimum Powered City (Hard)</li> <li> 3449. Maximize the Minimum Game Score (Hard)</li> <li> 2422. Merge Operations to Turn Array Into a Palindrome (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/greedy_from_left_right/#3402-minimum-operations-to-make-columns-strictly-increasing","title":"3402. Minimum Operations to Make Columns Strictly Increasing","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, greedy, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_left_right/#3191-minimum-operations-to-make-binary-array-elements-equal-to-one-i","title":"3191. Minimum Operations to Make Binary Array Elements Equal to One I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation, queue, sliding window, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_left_right/#1827-minimum-operations-to-make-the-array-increasing","title":"1827. Minimum Operations to Make the Array Increasing","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_left_right/#2027-minimum-moves-to-convert-string","title":"2027. Minimum Moves to Convert String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_left_right/#605-can-place-flowers","title":"605. Can Place Flowers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_left_right/#3111-minimum-rectangles-to-cover-points","title":"3111. Minimum Rectangles to Cover Points","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_left_right/#2957-remove-adjacent-almost-equal-characters","title":"2957. Remove Adjacent Almost-Equal Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_left_right/#3192-minimum-operations-to-make-binary-array-elements-equal-to-one-ii","title":"3192. Minimum Operations to Make Binary Array Elements Equal to One II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_left_right/#2789-largest-element-in-an-array-after-merge-operations","title":"2789. Largest Element in an Array after Merge Operations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_left_right/#1529-minimum-suffix-flips","title":"1529. Minimum Suffix Flips","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_left_right/#1144-decrease-elements-to-make-array-zigzag","title":"1144. Decrease Elements To Make Array Zigzag","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_left_right/#3228-maximum-number-of-operations-to-move-ones-to-the-end","title":"3228. Maximum Number of Operations to Move Ones to the End","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, greedy, counting</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_left_right/#2086-minimum-number-of-food-buckets-to-feed-the-hamsters","title":"2086. Minimum Number of Food Buckets to Feed the Hamsters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_left_right/#2571-minimum-operations-to-reduce-an-integer-to-0","title":"2571. Minimum Operations to Reduce an Integer to 0","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming, greedy, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_left_right/#2712-minimum-cost-to-make-all-characters-equal","title":"2712. Minimum Cost to Make All Characters Equal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming, greedy 2712. Minimum Cost to Make All Characters Equal - Python Solution<pre><code>def minimumCost(s: str) -&gt; int:\n    n = len(s)\n    res = 0\n    for i in range(1, n):\n        if s[i - 1] != s[i]:\n            res += min(i, n - i)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    s = \"0011\"\n    print(minimumCost(s))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_left_right/#3326-minimum-division-operations-to-make-array-non-decreasing","title":"3326. Minimum Division Operations to Make Array Non Decreasing","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, greedy, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_left_right/#1536-minimum-swaps-to-arrange-a-binary-grid","title":"1536. Minimum Swaps to Arrange a Binary Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_left_right/#2673-make-costs-of-paths-equal-in-a-binary-tree","title":"2673. Make Costs of Paths Equal in a Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy, tree, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_left_right/#861-score-after-flipping-matrix","title":"861. Score After Flipping Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, bit manipulation, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_left_right/#955-delete-columns-to-make-sorted-ii","title":"955. Delete Columns to Make Sorted II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_left_right/#2366-minimum-replacements-to-sort-the-array","title":"2366. Minimum Replacements to Sort the Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_left_right/#2193-minimum-number-of-moves-to-make-palindrome","title":"2193. Minimum Number of Moves to Make Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: two pointers, string, greedy, binary indexed tree</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_left_right/#2528-maximize-the-minimum-powered-city","title":"2528. Maximize the Minimum Powered City","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, greedy, queue, sliding window, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_left_right/#3449-maximize-the-minimum-game-score","title":"3449. Maximize the Minimum Game Score","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_left_right/#2422-merge-operations-to-turn-array-into-a-palindrome","title":"2422. Merge Operations to Turn Array Into a Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_smallest_largest/","title":"Greedy from Smallest Largest","text":""},{"location":"content/endlesscheng/greedy_from_smallest_largest/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3074. Apple Redistribution into Boxes (Easy)</li> <li> 2279. Maximum Bags With Full Capacity of Rocks (Medium)</li> <li> 1833. Maximum Ice Cream Bars (Medium)</li> <li> 1005. Maximize Sum Of Array After K Negations (Easy)</li> <li> 1481. Least Number of Unique Integers after K Removals (Medium)</li> <li> 1403. Minimum Subsequence in Non-Increasing Order (Easy)</li> <li> 3010. Divide an Array Into Subarrays With Minimum Cost I (Easy)</li> <li> 1338. Reduce Array Size to The Half (Medium)</li> <li> 1710. Maximum Units on a Truck (Easy)</li> <li> 3075. Maximize Happiness of Selected Children (Medium)</li> <li> 2554. Maximum Number of Integers to Choose From a Range I (Medium)</li> <li> 2126. Destroying Asteroids (Medium)</li> <li> 2587. Rearrange Array to Maximize Prefix Score (Medium)</li> <li> 976. Largest Perimeter Triangle (Easy)</li> <li> 1561. Maximum Number of Coins You Can Get (Medium)</li> <li> 3301. Maximize the Total Height of Unique Towers (Medium)</li> <li> 945. Minimum Increment to Make Array Unique (Medium)</li> <li> 1846. Maximum Element After Decreasing and Rearranging (Medium)</li> <li> 1647. Minimum Deletions to Make Character Frequencies Unique (Medium)</li> <li> 2971. Find Polygon With the Largest Perimeter (Medium)</li> <li> 2178. Maximum Split of Positive Even Integers (Medium)</li> <li> 2567. Minimum Score by Changing Two Elements (Medium)</li> <li> 1509. Minimum Difference Between Largest and Smallest Value in Three Moves (Medium)</li> <li> 3397. Maximum Number of Distinct Elements After Operations (Medium)</li> <li> 3457. Eat Pizzas! (Medium)</li> <li> 1262. Greatest Sum Divisible by Three (Medium)</li> <li> 948. Bag of Tokens (Medium)</li> <li> 1775. Equal Sum Arrays With Minimum Number of Operations (Medium)</li> <li> 2333. Minimum Sum of Squared Difference (Medium)</li> <li> 3440. Reschedule Meetings for Maximum Free Time II (Medium)</li> <li> 2141. Maximum Running Time of N Computers (Hard)</li> <li> 1196. How Many Apples Can You Put into the Basket (Easy) \ud83d\udc51</li> <li> 2214. Minimum Health to Beat Game (Medium) \ud83d\udc51</li> <li> 2098. Subsequence of Size K With the Largest Even Sum (Medium) \ud83d\udc51</li> <li> 2548. Maximum Price to Fill a Bag (Medium) \ud83d\udc51</li> <li> 3119. Maximum Number of Potholes That Can Be Fixed (Medium) \ud83d\udc51</li> <li> 2557. Maximum Number of Integers to Choose From a Range II (Medium) \ud83d\udc51</li> <li> 624. Maximum Distance in Arrays (Medium)</li> <li> 910. Smallest Range II (Medium)</li> <li> 2835. Minimum Operations to Form Subsequence With Target Sum (Hard)</li> <li> 3366. Minimum Array Sum (Medium)</li> </ul>"},{"location":"content/endlesscheng/greedy_from_smallest_largest/#3074-apple-redistribution-into-boxes","title":"3074. Apple Redistribution into Boxes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, greedy, sorting 3074. Apple Redistribution into Boxes - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef minimumBoxes(apple: List[int], capacity: List[int]) -&gt; int:\n    target = sum(apple)\n    capacity.sort(reverse=True)\n    res = 0\n\n    for box in capacity:\n        res += 1\n        target -= box\n        if target &lt;= 0:\n            break\n\n    return res\n\n\napple = [1, 3, 2]\ncapacity = [4, 3, 1, 5, 2]\nassert minimumBoxes(apple, capacity) == 2\n</code></pre></p> </li> </ul> 3074. Apple Redistribution into Boxes - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;numeric&gt;\n#include &lt;algorithm&gt;\n#include &lt;functional&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int minimumBoxes(vector&lt;int&gt; &amp;apple, vector&lt;int&gt; &amp;capacity)\n    {\n        int s = accumulate(apple.begin(), apple.end(), 0);\n        sort(capacity.begin(), capacity.end(), greater&lt;int&gt;());\n\n        int i = 0;\n        while (s &gt; 0)\n        {\n            s -= capacity[i++];\n        }\n        return i;\n    }\n};\n\nint main()\n{\n    Solution s;\n    vector&lt;int&gt; apple = {1, 3, 2};\n    vector&lt;int&gt; capacity = {4, 3, 1, 5, 2};\n    cout &lt;&lt; s.minimumBoxes(apple, capacity) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/endlesscheng/greedy_from_smallest_largest/#2279-maximum-bags-with-full-capacity-of-rocks","title":"2279. Maximum Bags With Full Capacity of Rocks","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_smallest_largest/#1833-maximum-ice-cream-bars","title":"1833. Maximum Ice Cream Bars","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting, counting sort</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_smallest_largest/#1005-maximize-sum-of-array-after-k-negations","title":"1005. Maximize Sum Of Array After K Negations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> <li>Return the maximum sum of the array after changing at most <code>k</code> elements.</li> </ul> 1005. Maximize Sum Of Array After K Negations - Python Solution<pre><code>from heapq import heapify, heapreplace\nfrom typing import List\n\n\n# Greedy\ndef largestSumAfterKNegationsGreedy(nums: List[int], k: int) -&gt; int:\n    nums.sort(key=abs, reverse=True)\n\n    for i in range(len(nums)):\n        if nums[i] &lt; 0 and k &gt; 0:\n            nums[i] *= -1\n            k -= 1\n\n    if k % 2:\n        nums[-1] *= -1\n\n    return sum(nums)\n\n\n# Heap\ndef largestSumAfterKNegationsHeap(nums: List[int], k: int) -&gt; int:\n    heapify(nums)\n\n    while k and nums[0] &lt; 0:\n        heapreplace(nums, -nums[0])\n        k -= 1\n\n    if k % 2:\n        heapreplace(nums, -nums[0])\n\n    return sum(nums)\n\n\nprint(largestSumAfterKNegationsGreedy([4, 2, 3], 1))  # 5\nprint(largestSumAfterKNegationsHeap([4, 2, 3], 1))\n</code></pre>"},{"location":"content/endlesscheng/greedy_from_smallest_largest/#1481-least-number-of-unique-integers-after-k-removals","title":"1481. Least Number of Unique Integers after K Removals","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, greedy, sorting, counting</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_smallest_largest/#1403-minimum-subsequence-in-non-increasing-order","title":"1403. Minimum Subsequence in Non-Increasing Order","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_smallest_largest/#3010-divide-an-array-into-subarrays-with-minimum-cost-i","title":"3010. Divide an Array Into Subarrays With Minimum Cost I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, sorting, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_smallest_largest/#1338-reduce-array-size-to-the-half","title":"1338. Reduce Array Size to The Half","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, greedy, sorting, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_smallest_largest/#1710-maximum-units-on-a-truck","title":"1710. Maximum Units on a Truck","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_smallest_largest/#3075-maximize-happiness-of-selected-children","title":"3075. Maximize Happiness of Selected Children","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting 3075. Maximize Happiness of Selected Children - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef maximumHappinessSum(happiness: List[int], k: int) -&gt; int:\n    selected = 0\n    happinessScore = 0\n    happiness.sort(reverse=True)\n\n    for score in happiness:\n        if selected == k:\n            return happinessScore\n        happinessScore += max(0, score - selected)\n        selected += 1\n\n    return happinessScore\n\n\nhappiness = [1, 2, 3]\nk = 2\nprint(maximumHappinessSum(happiness, k))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_smallest_largest/#2554-maximum-number-of-integers-to-choose-from-a-range-i","title":"2554. Maximum Number of Integers to Choose From a Range I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, binary search, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_smallest_largest/#2126-destroying-asteroids","title":"2126. Destroying Asteroids","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_smallest_largest/#2587-rearrange-array-to-maximize-prefix-score","title":"2587. Rearrange Array to Maximize Prefix Score","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_smallest_largest/#976-largest-perimeter-triangle","title":"976. Largest Perimeter Triangle","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, math, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_smallest_largest/#1561-maximum-number-of-coins-you-can-get","title":"1561. Maximum Number of Coins You Can Get","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, greedy, sorting, game theory</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_smallest_largest/#3301-maximize-the-total-height-of-unique-towers","title":"3301. Maximize the Total Height of Unique Towers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_smallest_largest/#945-minimum-increment-to-make-array-unique","title":"945. Minimum Increment to Make Array Unique","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting, counting 945. Minimum Increment to Make Array Unique - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef minIncrementForUnique(nums: List[int]) -&gt; int:\n    nums.sort()\n    moves = 0\n\n    for i in range(1, len(nums)):\n        if nums[i] &lt;= nums[i - 1]:\n            moves += nums[i - 1] + 1 - nums[i]\n            nums[i] = nums[i - 1] + 1\n\n    return moves\n\n\nnums = [1, 2, 2]\nprint(minIncrementForUnique(nums))  # 1\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_smallest_largest/#1846-maximum-element-after-decreasing-and-rearranging","title":"1846. Maximum Element After Decreasing and Rearranging","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_smallest_largest/#1647-minimum-deletions-to-make-character-frequencies-unique","title":"1647. Minimum Deletions to Make Character Frequencies Unique","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_smallest_largest/#2971-find-polygon-with-the-largest-perimeter","title":"2971. Find Polygon With the Largest Perimeter","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_smallest_largest/#2178-maximum-split-of-positive-even-integers","title":"2178. Maximum Split of Positive Even Integers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, backtracking, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_smallest_largest/#2567-minimum-score-by-changing-two-elements","title":"2567. Minimum Score by Changing Two Elements","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_smallest_largest/#1509-minimum-difference-between-largest-and-smallest-value-in-three-moves","title":"1509. Minimum Difference Between Largest and Smallest Value in Three Moves","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_smallest_largest/#3397-maximum-number-of-distinct-elements-after-operations","title":"3397. Maximum Number of Distinct Elements After Operations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_smallest_largest/#3457-eat-pizzas","title":"3457. Eat Pizzas!","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_smallest_largest/#1262-greatest-sum-divisible-by-three","title":"1262. Greatest Sum Divisible by Three","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_smallest_largest/#948-bag-of-tokens","title":"948. Bag of Tokens","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_smallest_largest/#1775-equal-sum-arrays-with-minimum-number-of-operations","title":"1775. Equal Sum Arrays With Minimum Number of Operations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, greedy, counting</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_smallest_largest/#2333-minimum-sum-of-squared-difference","title":"2333. Minimum Sum of Squared Difference","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, greedy, sorting, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_smallest_largest/#3440-reschedule-meetings-for-maximum-free-time-ii","title":"3440. Reschedule Meetings for Maximum Free Time II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_smallest_largest/#2141-maximum-running-time-of-n-computers","title":"2141. Maximum Running Time of N Computers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_smallest_largest/#1196-how-many-apples-can-you-put-into-the-basket","title":"1196. How Many Apples Can You Put into the Basket","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_smallest_largest/#2214-minimum-health-to-beat-game","title":"2214. Minimum Health to Beat Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_smallest_largest/#2098-subsequence-of-size-k-with-the-largest-even-sum","title":"2098. Subsequence of Size K With the Largest Even Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_smallest_largest/#2548-maximum-price-to-fill-a-bag","title":"2548. Maximum Price to Fill a Bag","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_smallest_largest/#3119-maximum-number-of-potholes-that-can-be-fixed","title":"3119. Maximum Number of Potholes That Can Be Fixed","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_smallest_largest/#2557-maximum-number-of-integers-to-choose-from-a-range-ii","title":"2557. Maximum Number of Integers to Choose From a Range II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_smallest_largest/#624-maximum-distance-in-arrays","title":"624. Maximum Distance in Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy 624. Maximum Distance in Arrays - Python Solution<pre><code>from typing import List\n\n\n# Array\ndef maxDistance(arrays: List[List[int]]) -&gt; int:\n    mn, mx = float(\"inf\"), float(\"-inf\")\n    res = 0\n\n    for arr in arrays:\n        res = max(res, arr[-1] - mn, mx - arr[0])\n        mn = min(mn, arr[0])\n        mx = max(mx, arr[-1])\n\n    return res\n\n\narrays = [[1, 2, 3], [4, 5], [1, 2, 3]]\nprint(maxDistance(arrays))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_smallest_largest/#910-smallest-range-ii","title":"910. Smallest Range II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_smallest_largest/#2835-minimum-operations-to-form-subsequence-with-target-sum","title":"2835. Minimum Operations to Form Subsequence With Target Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_from_smallest_largest/#3366-minimum-array-sum","title":"3366. Minimum Array Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_others/","title":"Greedy Others","text":""},{"location":"content/endlesscheng/greedy_others/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2740. Find the Value of the Partition (Medium)</li> <li> 1033. Moving Stones Until Consecutive (Medium)</li> <li> 1864. Minimum Number of Swaps to Make the Binary String Alternating (Medium)</li> <li> 1899. Merge Triplets to Form Target Triplet (Medium)</li> <li> 2498. Frog Jump II (Medium)</li> <li> 134. Gas Station (Medium)</li> <li> 2311. Longest Binary Subsequence Less Than or Equal to K (Medium)</li> <li> 3443. Maximum Manhattan Distance After K Changes (Medium)</li> <li> 3002. Maximum Size of a Set After Removals (Medium)</li> <li> 2412. Minimum Money Required Before Transactions (Hard)</li> <li> 659. Split Array into Consecutive Subsequences (Medium)</li> <li> 2732. Find a Good Subset of the Matrix (Hard)</li> <li> 2790. Maximum Number of Groups With Increasing Length (Hard)</li> <li> 782. Transform to Chessboard (Hard)</li> <li> 420. Strong Password Checker (Hard)</li> <li> 2753. Count Houses in a Circular Street II (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/greedy_others/#2740-find-the-value-of-the-partition","title":"2740. Find the Value of the Partition","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_others/#1033-moving-stones-until-consecutive","title":"1033. Moving Stones Until Consecutive","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, brainteaser</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_others/#1864-minimum-number-of-swaps-to-make-the-binary-string-alternating","title":"1864. Minimum Number of Swaps to Make the Binary String Alternating","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_others/#1899-merge-triplets-to-form-target-triplet","title":"1899. Merge Triplets to Form Target Triplet","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy 1899. Merge Triplets to Form Target Triplet - Python Solution<pre><code>from typing import List\n\n\ndef mergeTriplets(triplets: List[List[int]], target: List[int]) -&gt; bool:\n    can_form = [False, False, False]\n\n    for triplet in triplets:\n        if all(triplet[i] &lt;= target[i] for i in range(3)):\n            for i in range(3):\n                if triplet[i] == target[i]:\n                    can_form[i] = True\n\n    return all(can_form)\n\n\ntriplets = [[2, 5, 3], [1, 8, 4], [1, 7, 5]]\ntarget = [2, 7, 5]\nprint(mergeTriplets(triplets, target))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/greedy_others/#2498-frog-jump-ii","title":"2498. Frog Jump II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_others/#134-gas-station","title":"134. Gas Station","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy 134. Gas Station - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef canCompleteCircuit(gas: List[int], cost: List[int]) -&gt; int:\n    curSum = 0\n    totalSum = 0\n    start = 0\n\n    for i in range(len(gas)):\n        curSum += gas[i] - cost[i]\n        totalSum += gas[i] - cost[i]\n\n        if curSum &lt; 0:\n            start = i + 1\n            curSum = 0\n\n    if totalSum &lt; 0:\n        return -1\n\n    return start\n\n\ngas = [1, 2, 3, 4, 5]\ncost = [3, 4, 5, 1, 2]\nprint(canCompleteCircuit(gas, cost))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/greedy_others/#2311-longest-binary-subsequence-less-than-or-equal-to-k","title":"2311. Longest Binary Subsequence Less Than or Equal to K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming, greedy, memoization</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_others/#3443-maximum-manhattan-distance-after-k-changes","title":"3443. Maximum Manhattan Distance After K Changes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, math, string, counting</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_others/#3002-maximum-size-of-a-set-after-removals","title":"3002. Maximum Size of a Set After Removals","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_others/#2412-minimum-money-required-before-transactions","title":"2412. Minimum Money Required Before Transactions","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_others/#659-split-array-into-consecutive-subsequences","title":"659. Split Array into Consecutive Subsequences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, greedy, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_others/#2732-find-a-good-subset-of-the-matrix","title":"2732. Find a Good Subset of the Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, bit manipulation, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_others/#2790-maximum-number-of-groups-with-increasing-length","title":"2790. Maximum Number of Groups With Increasing Length","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, binary search, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_others/#782-transform-to-chessboard","title":"782. Transform to Chessboard","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, bit manipulation, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_others/#420-strong-password-checker","title":"420. Strong Password Checker","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, greedy, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/greedy_others/#2753-count-houses-in-a-circular-street-ii","title":"2753. Count Houses in a Circular Street II","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> </ul>"},{"location":"content/endlesscheng/grid_01_bfs/","title":"Grid 01 BFS","text":""},{"location":"content/endlesscheng/grid_01_bfs/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1368. Minimum Cost to Make at Least One Valid Path in a Grid (Hard)</li> <li> 2290. Minimum Obstacle Removal to Reach Corner (Hard)</li> <li> 3286. Find a Safe Walk Through a Grid (Medium)</li> <li> 1824. Minimum Sideway Jumps (Medium)</li> </ul>"},{"location":"content/endlesscheng/grid_01_bfs/#1368-minimum-cost-to-make-at-least-one-valid-path-in-a-grid","title":"1368. Minimum Cost to Make at Least One Valid Path in a Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, breadth first search, graph, heap priority queue, matrix, shortest path</p> </li> </ul>"},{"location":"content/endlesscheng/grid_01_bfs/#2290-minimum-obstacle-removal-to-reach-corner","title":"2290. Minimum Obstacle Removal to Reach Corner","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, breadth first search, graph, heap priority queue, matrix, shortest path</p> </li> </ul>"},{"location":"content/endlesscheng/grid_01_bfs/#3286-find-a-safe-walk-through-a-grid","title":"3286. Find a Safe Walk Through a Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, breadth first search, graph, heap priority queue, matrix, shortest path</p> </li> </ul>"},{"location":"content/endlesscheng/grid_01_bfs/#1824-minimum-sideway-jumps","title":"1824. Minimum Sideway Jumps","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/grid_applications/","title":"Grid Applications","text":""},{"location":"content/endlesscheng/grid_applications/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1631. Path With Minimum Effort (Medium)</li> <li> 778. Swim in Rising Water (Hard)</li> <li> 329. Longest Increasing Path in a Matrix (Hard)</li> <li> 1036. Escape a Large Maze (Hard)</li> <li> 864. Shortest Path to Get All Keys (Hard)</li> <li> 1263. Minimum Moves to Move a Box to Their Target Location (Hard)</li> <li> 2258. Escape the Spreading Fire (Hard)</li> <li> 2556. Disconnect Path in a Binary Matrix by at Most One Flip (Medium)</li> <li> 2577. Minimum Time to Visit a Cell In a Grid (Hard)</li> <li> 2617. Minimum Number of Visited Cells in a Grid (Hard)</li> <li> 694. Number of Distinct Islands (Medium) \ud83d\udc51</li> <li> 711. Number of Distinct Islands II (Hard) \ud83d\udc51</li> <li> 1102. Path With Maximum Minimum Value (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/grid_applications/#1631-path-with-minimum-effort","title":"1631. Path With Minimum Effort","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, depth first search, breadth first search, union find, heap priority queue, matrix</p> </li> <li>Return the minimum effort required to travel from the top-left to the bottom-right corner.</li> </ul> 1631. Path With Minimum Effort - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Prim\ndef minimumEffortPath(heights: List[List[int]]) -&gt; int:\n    m, n = len(heights), len(heights[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * n for _ in range(m)]\n    heap = [(0, 0, 0)]  # (effort, row, col)\n\n    while heap:\n        effort, r, c = heapq.heappop(heap)\n\n        if visited[r][c]:\n            continue\n\n        if r == m - 1 and c == n - 1:\n            return effort\n\n        visited[r][c] = True\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and not visited[nr][nc]:\n                updated = max(effort, abs(heights[r][c] - heights[nr][nc]))\n                heapq.heappush(heap, (updated, nr, nc))\n\n    return -1\n\n\nheights = [[1, 2, 2], [3, 8, 2], [5, 3, 5]]\nprint(minimumEffortPath(heights))  # 2\n</code></pre>"},{"location":"content/endlesscheng/grid_applications/#778-swim-in-rising-water","title":"778. Swim in Rising Water","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, depth first search, breadth first search, union find, heap priority queue, matrix</p> </li> <li>Return the minimum time when you can reach the target.</li> </ul> <p></p> 778. Swim in Rising Water - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra's\ndef swimInWater(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    visited = set()\n    minHeap = [(grid[0][0], 0, 0)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    visited.add((0, 0))\n\n    while minHeap:\n        time, r, c = heapq.heappop(minHeap)\n\n        if r == n - 1 and c == n - 1:\n            return time\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if nr in range(n) and nc in range(n) and (nr, nc) not in visited:\n                visited.add((nr, nc))\n                heapq.heappush(minHeap, (max(time, grid[nr][nc]), nr, nc))\n\n\ngrid = [\n    [0, 1, 2, 3, 4],\n    [24, 23, 22, 21, 5],\n    [12, 13, 14, 15, 16],\n    [11, 17, 18, 19, 20],\n    [10, 9, 8, 7, 6],\n]\nprint(swimInWater(grid))  # 16\n</code></pre>"},{"location":"content/endlesscheng/grid_applications/#329-longest-increasing-path-in-a-matrix","title":"329. Longest Increasing Path in a Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, depth first search, breadth first search, graph, topological sort, memoization, matrix 329. Longest Increasing Path in a Matrix - Python Solution<pre><code>from collections import deque\nfrom functools import cache\nfrom typing import List\n\n\n# BFS - Topological Sort\ndef longestIncreasingPathBFS(matrix: List[List[int]]) -&gt; int:\n    if not matrix:\n        return 0\n\n    m, n = len(matrix), len(matrix[0])\n    dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    # Calculate indegrees and initialize queue in one pass\n    indegree = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            for dr, dc in dirs:\n                nr, nc = i + dr, j + dc\n                if (\n                    0 &lt;= nr &lt; m\n                    and 0 &lt;= nc &lt; n\n                    and matrix[nr][nc] &gt; matrix[i][j]\n                ):\n                    indegree[nr][nc] += 1\n\n    # Start with cells that have no smaller neighbors\n    queue = deque(\n        (i, j) for i in range(m) for j in range(n) if indegree[i][j] == 0\n    )\n\n    res = 0\n    while queue:\n        res += 1\n        for _ in range(len(queue)):\n            r, c = queue.popleft()\n            for dr, dc in dirs:\n                nr, nc = r + dr, c + dc\n                if (\n                    0 &lt;= nr &lt; m\n                    and 0 &lt;= nc &lt; n\n                    and matrix[nr][nc] &gt; matrix[r][c]\n                ):\n                    indegree[nr][nc] -= 1\n                    if indegree[nr][nc] == 0:\n                        queue.append((nr, nc))\n\n    return res\n\n\n# DP - 2D\ndef longestIncreasingPath(matrix: List[List[int]]) -&gt; int:\n    if not matrix:\n        return 0\n\n    m, n = len(matrix), len(matrix[0])\n    dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    @cache\n    def dfs(r, c):\n        path = 1\n        for dr, dc in dirs:\n            nr, nc = r + dr, c + dc\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and matrix[nr][nc] &gt; matrix[r][c]:\n                path = max(path, dfs(nr, nc) + 1)\n        return path\n\n    res = 0\n    for i in range(m):\n        for j in range(n):\n            res = max(res, dfs(i, j))\n\n    return res\n\n\nif __name__ == \"__main__\":\n    matrix = [[9, 9, 4], [6, 6, 8], [2, 1, 1]]\n    assert longestIncreasingPath(matrix) == 4\n    assert longestIncreasingPathBFS(matrix) == 4\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/grid_applications/#1036-escape-a-large-maze","title":"1036. Escape a Large Maze","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, depth first search, breadth first search</p> </li> </ul>"},{"location":"content/endlesscheng/grid_applications/#864-shortest-path-to-get-all-keys","title":"864. Shortest Path to Get All Keys","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, bit manipulation, breadth first search, matrix 864. Shortest Path to Get All Keys - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef shortestPathAllKeys(grid: List[str]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    q = deque()\n    visited = set()\n    total = 0\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"@\":\n                q.append((r, c, 0, 0))\n                visited.add((r, c, 0))\n            if grid[r][c].islower():\n                total += 1\n\n    while q:\n        r, c, keys, steps = q.popleft()\n\n        if keys == (1 &lt;&lt; total) - 1:\n            return steps\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n:\n                cell = grid[nr][nc]\n\n                if cell == \"#\":\n                    continue\n\n                new_keys = keys\n                if cell.islower():\n                    new_keys |= 1 &lt;&lt; (ord(cell) - ord(\"a\"))\n\n                if cell.isupper() and not (\n                    keys &amp; (1 &lt;&lt; (ord(cell) - ord(\"A\")))\n                ):\n                    continue\n\n                if (nr, nc, new_keys) not in visited:\n                    visited.add((nr, nc, new_keys))\n                    q.append((nr, nc, new_keys, steps + 1))\n\n    return -1\n\n\ngrid = [\"@.a..\", \"###.#\", \"b.A.B\"]\nprint(shortestPathAllKeys(grid))  # 8\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/grid_applications/#1263-minimum-moves-to-move-a-box-to-their-target-location","title":"1263. Minimum Moves to Move a Box to Their Target Location","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, breadth first search, heap priority queue, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/grid_applications/#2258-escape-the-spreading-fire","title":"2258. Escape the Spreading Fire","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, breadth first search, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/grid_applications/#2556-disconnect-path-in-a-binary-matrix-by-at-most-one-flip","title":"2556. Disconnect Path in a Binary Matrix by at Most One Flip","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, depth first search, breadth first search, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/grid_applications/#2577-minimum-time-to-visit-a-cell-in-a-grid","title":"2577. Minimum Time to Visit a Cell In a Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, breadth first search, graph, heap priority queue, matrix, shortest path</p> </li> </ul>"},{"location":"content/endlesscheng/grid_applications/#2617-minimum-number-of-visited-cells-in-a-grid","title":"2617. Minimum Number of Visited Cells in a Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, stack, breadth first search, union find, heap priority queue, matrix, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/grid_applications/#694-number-of-distinct-islands","title":"694. Number of Distinct Islands","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, depth first search, breadth first search, union find, hash function 694. Number of Distinct Islands - Python Solution<pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# BFS\ndef numDistinctIslandsBFS(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    shapes = set()\n    dirs = [[1, 0], [0, 1], [0, -1], [-1, 0]]\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        shape = set()\n        grid[r][c] = 0\n\n        while q:\n            row, col = q.popleft()\n            shape.add((row - r, col - c))\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and grid[nr][nc] == 1:\n                    q.append((nr, nc))\n                    grid[nr][nc] = 0\n\n        return tuple(shape)\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                shapes.add(bfs(i, j))\n\n    return len(shapes)\n\n\n# DFS\ndef numDistinctIslandsDFS(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n\n    def dfs(r, c, org, shape):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] != 1:\n            return\n\n        grid[r][c] = 0\n        shape.add((r - org[0], c - org[1]))\n\n        dfs(r - 1, c, org, shape)\n        dfs(r + 1, c, org, shape)\n        dfs(r, c - 1, org, shape)\n        dfs(r, c + 1, org, shape)\n\n    shapes = set()\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                org = [i, j]\n                shape = set()\n                dfs(i, j, org, shape)\n                shapes.add(tuple(shape))\n\n    return len(shapes)\n\n\ngrid = [[1, 1, 0, 1, 1], [1, 0, 0, 0, 0], [0, 0, 0, 0, 1], [1, 1, 0, 1, 1]]\nprint(numDistinctIslandsBFS(deepcopy(grid)))  # 3\nprint(numDistinctIslandsDFS(deepcopy(grid)))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/grid_applications/#711-number-of-distinct-islands-ii","title":"711. Number of Distinct Islands II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, depth first search, breadth first search, union find, hash function</p> </li> </ul>"},{"location":"content/endlesscheng/grid_applications/#1102-path-with-maximum-minimum-value","title":"1102. Path With Maximum Minimum Value","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, depth first search, breadth first search, union find, heap priority queue, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/grid_bfs/","title":"Grid BFS","text":""},{"location":"content/endlesscheng/grid_bfs/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1926. Nearest Exit from Entrance in Maze (Medium)</li> <li> 1091. Shortest Path in Binary Matrix (Medium)</li> <li> 1162. As Far from Land as Possible (Medium)</li> <li> 542. 01 Matrix (Medium)</li> <li> 994. Rotting Oranges (Medium)</li> <li> 1765. Map of Highest Peak (Medium)</li> <li> 934. Shortest Bridge (Medium)</li> <li> 2146. K Highest Ranked Items Within a Price Range (Medium)</li> <li> 1293. Shortest Path in a Grid with Obstacles Elimination (Hard)</li> <li> 909. Snakes and Ladders (Medium)</li> <li> 1210. Minimum Moves to Reach Target with Rotations (Hard)</li> <li> 675. Cut Off Trees for Golf Event (Hard)</li> <li> 749. Contain Virus (Hard)</li> <li> 1730. Shortest Path to Get Food (Medium) \ud83d\udc51</li> <li> 286. Walls and Gates (Medium) \ud83d\udc51</li> <li> 490. The Maze (Medium) \ud83d\udc51</li> <li> 505. The Maze II (Medium) \ud83d\udc51</li> <li> 499. The Maze III (Hard) \ud83d\udc51</li> <li> 317. Shortest Distance from All Buildings (Hard) \ud83d\udc51</li> <li> 2814. Minimum Time Takes to Reach Destination Without Drowning (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/grid_bfs/#1926-nearest-exit-from-entrance-in-maze","title":"1926. Nearest Exit from Entrance in Maze","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, breadth first search, matrix 1926. Nearest Exit from Entrance in Maze - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef nearestExit(maze: List[List[str]], entrance: List[int]) -&gt; int:\n    m, n = len(maze), len(maze[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque([(entrance[0], entrance[1], 0)])\n    maze[entrance[0]][entrance[1]] = \"+\"\n\n    while q:\n        r, c, steps = q.popleft()\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and maze[nr][nc] == \".\":\n                if nr in [0, m - 1] or nc in [0, n - 1]:\n                    return steps + 1\n                q.append((nr, nc, steps + 1))\n                maze[nr][nc] = \"+\"\n\n    return -1\n\n\nmaze = [[\"+\", \"+\", \".\", \"+\"], [\".\", \".\", \".\", \"+\"], [\"+\", \"+\", \"+\", \".\"]]\nentrance = [1, 2]\nprint(nearestExit(maze, entrance))  # 1\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/grid_bfs/#1091-shortest-path-in-binary-matrix","title":"1091. Shortest Path in Binary Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, breadth first search, matrix 1091. Shortest Path in Binary Matrix - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    if grid[0][0] == 1 or grid[n - 1][n - 1] == 1:\n        return -1\n    if n == 1:\n        return 1\n\n    directions = [\n        (0, 1),\n        (1, 0),\n        (0, -1),\n        (-1, 0),\n        (1, 1),\n        (-1, -1),\n        (1, -1),\n        (-1, 1),\n    ]\n    q = deque([(0, 0, 1)])  # (row, column, distance)\n    grid[0][0] = 1\n\n    while q:\n        r, c, d = q.popleft()\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 &lt;= nr &lt; n and 0 &lt;= nc &lt; n and grid[nr][nc] == 0:\n                if nr == nc == n - 1:\n                    return d + 1\n                q.append((nr, nc, d + 1))\n                grid[nr][nc] = 1\n\n    return -1\n\n\ngrid = [[0, 0, 0], [1, 1, 0], [1, 1, 0]]\nprint(shortestPathBinaryMatrix(grid))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/grid_bfs/#1162-as-far-from-land-as-possible","title":"1162. As Far from Land as Possible","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, breadth first search, matrix 1162. As Far from Land as Possible - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef maxDistance(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    res = -1\n    dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]]\n\n    q = deque([[i, j] for i in range(n) for j in range(n) if grid[i][j] == 1])\n\n    if len(q) == (n**2):\n        return res\n\n    while q:\n        size = len(q)\n        for _ in range(size):\n            r, c = q.popleft()\n            for dr, dc in dirs:\n                nr, nc = dr + r, dc + c\n                if 0 &lt;= nr &lt; n and 0 &lt;= nc &lt; n and grid[nr][nc] == 0:\n                    grid[nr][nc] = 1\n                    q.append([nr, nc])\n        res += 1\n\n    return res\n\n\ngrid = [[1, 0, 0], [0, 0, 0], [0, 0, 0]]\nprint(maxDistance(grid))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/grid_bfs/#542-01-matrix","title":"542. 01 Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, breadth first search, matrix 542. 01 Matrix - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef updateMatrix(mat: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(mat), len(mat[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    q = deque()\n\n    for i in range(m):\n        for j in range(n):\n            if mat[i][j] == 0:\n                dist[i][j] = 0\n                q.append((i, j))\n\n    while q:\n        r, c = q.popleft()\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and dist[nr][nc] &gt; dist[r][c] + 1:\n                dist[nr][nc] = dist[r][c] + 1\n                q.append((nr, nc))\n\n    return dist\n\n\nmat = [[0, 0, 0], [0, 1, 0], [1, 1, 1]]\nprint(updateMatrix(mat))\n# [[0, 0, 0], [0, 1, 0], [1, 2, 1]]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/grid_bfs/#994-rotting-oranges","title":"994. Rotting Oranges","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, breadth first search, matrix</p> </li> <li>Return the minimum number of minutes that must elapse until no cell has a fresh orange.</li> <li>Hint: Multi-source BFS to count the level.</li> </ul> <p></p> 994. Rotting Oranges - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef orangesRotting(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    fresh = 0\n    q = deque()\n    dirs = [[1, 0], [0, 1], [0, -1], [-1, 0]]\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 2:\n                q.append([i, j])\n            elif grid[i][j] == 1:\n                fresh += 1\n    res = 0\n\n    while q and fresh &gt; 0:\n        size = len(q)\n        for _ in range(size):\n            r, c = q.popleft()\n            for dr, dc in dirs:\n                nr, nc = dr + r, dc + c\n                if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and grid[nr][nc] == 1:\n                    q.append([nr, nc])\n                    grid[nr][nc] = 2\n                    fresh -= 1\n        res += 1\n\n    return res if fresh == 0 else -1\n\n\ngrid = [[2, 1, 1], [1, 1, 0], [0, 1, 1]]\nassert orangesRotting(grid) == 4\n</code></pre>"},{"location":"content/endlesscheng/grid_bfs/#1765-map-of-highest-peak","title":"1765. Map of Highest Peak","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, breadth first search, matrix 1765. Map of Highest Peak - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS (Multi-Source BFS)\ndef highestPeak(isWater: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(isWater), len(isWater[0])\n    dirs = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n    q = deque()\n\n    for i in range(m):\n        for j in range(n):\n            if isWater[i][j]:\n                q.append((i, j))\n                isWater[i][j] = 0\n            else:\n                isWater[i][j] = -1\n\n    height = 1\n    while q:\n        size = len(q)\n        for _ in range(size):\n            r, c = q.popleft()\n            for dr, dc in dirs:\n                nr, nc = dr + r, dc + c\n                if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and isWater[nr][nc] == -1:\n                    isWater[nr][nc] = height\n                    q.append((nr, nc))\n        height += 1\n\n    return isWater\n\n\nisWater = [[0, 0, 1], [1, 0, 0], [0, 0, 0]]\nprint(highestPeak(isWater))\n# [[1, 1, 0], [0, 1, 1], [1, 2, 2]]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/grid_bfs/#934-shortest-bridge","title":"934. Shortest Bridge","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, matrix 934. Shortest Bridge - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS + DFS; Coloring\ndef shortestBridge(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(r, c, queue):\n        grid[r][c] = 2\n        queue.append((r, c))\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if nr in range(n) and nc in range(n) and grid[nr][nc] == 1:\n                dfs(nr, nc, queue)\n\n    q = deque()\n    found = False\n    for r in range(n):\n        if found:\n            break\n        for c in range(n):\n            if grid[r][c] == 1:\n                dfs(r, c, q)\n                found = True\n                break\n\n    steps = 0\n    while q:\n        m = len(q)\n        for _ in range(m):\n            r, c = q.popleft()\n            for dr, dc in directions:\n                nr, nc = r + dr, c + dc\n                if nr in range(n) and nc in range(n):\n                    if grid[nr][nc] == 1:\n                        return steps\n                    elif grid[nr][nc] == 0:\n                        grid[nr][nc] = 2\n                        q.append((nr, nc))\n        steps += 1\n\n    return -1\n\n\ngrid = [\n    [1, 1, 1, 1, 1],\n    [1, 0, 0, 0, 1],\n    [1, 0, 1, 0, 1],\n    [1, 0, 0, 0, 1],\n    [1, 1, 1, 1, 1],\n]\nprint(shortestBridge(grid))  # 1\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/grid_bfs/#2146-k-highest-ranked-items-within-a-price-range","title":"2146. K Highest Ranked Items Within a Price Range","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, breadth first search, sorting, heap priority queue, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/grid_bfs/#1293-shortest-path-in-a-grid-with-obstacles-elimination","title":"1293. Shortest Path in a Grid with Obstacles Elimination","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, breadth first search, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/grid_bfs/#909-snakes-and-ladders","title":"909. Snakes and Ladders","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, breadth first search, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/grid_bfs/#1210-minimum-moves-to-reach-target-with-rotations","title":"1210. Minimum Moves to Reach Target with Rotations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, breadth first search, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/grid_bfs/#675-cut-off-trees-for-golf-event","title":"675. Cut Off Trees for Golf Event","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, breadth first search, heap priority queue, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/grid_bfs/#749-contain-virus","title":"749. Contain Virus","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, matrix, simulation</p> </li> </ul>"},{"location":"content/endlesscheng/grid_bfs/#1730-shortest-path-to-get-food","title":"1730. Shortest Path to Get Food","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, breadth first search, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/grid_bfs/#286-walls-and-gates","title":"286. Walls and Gates","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, breadth first search, matrix 286. Walls and Gates - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# Multi-Source BFS\ndef wallsAndGates(rooms: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify rooms in-place instead.\n    \"\"\"\n    m, n = len(rooms), len(rooms[0])\n    visited = set()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def addRoom(r, c):\n        if (\n            0 &lt;= r &lt; m\n            and 0 &lt;= c &lt; n\n            and (r, c) not in visited\n            and rooms[r][c] != -1\n        ):\n            q.append((r, c))\n            visited.add((r, c))\n\n    q = deque()\n    for r in range(m):\n        for c in range(n):\n            if rooms[r][c] == 0:\n                q.append((r, c))\n                visited.add((r, c))\n\n    dist = 0\n\n    while q:\n        for _ in range(len(q)):\n            r, c = q.popleft()\n            rooms[r][c] = dist\n\n            for dr, dc in directions:\n                addRoom(r + dr, c + dc)\n        dist += 1\n\n\nif __name__ == \"__main__\":\n    rooms = [\n        [2147483647, -1, 0, 2147483647],\n        [2147483647, 2147483647, 2147483647, -1],\n        [2147483647, -1, 2147483647, -1],\n        [0, -1, 2147483647, 2147483647],\n    ]\n    wallsAndGates(rooms)\n    assert rooms == [\n        [3, -1, 0, 1],\n        [2, 2, 1, -1],\n        [1, -1, 2, -1],\n        [0, -1, 3, 4],\n    ]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/grid_bfs/#490-the-maze","title":"490. The Maze","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, matrix 490. The Maze - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef hasPathBFS(\n    maze: List[List[int]], start: List[int], destination: List[int]\n) -&gt; bool:\n    m, n = len(maze), len(maze[0])\n    dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]]\n    q = deque([start])\n    maze[start[0]][start[1]] = -1\n\n    while q:\n        r, c = q.popleft()\n        if [r, c] == destination:\n            return True\n\n        for dr, dc in dirs:\n            nr, nc = r, c\n\n            while (\n                0 &lt;= nr + dr &lt; m\n                and 0 &lt;= nc + dc &lt; n\n                and maze[nr + dr][nc + dc] != 1\n            ):\n                nr += dr\n                nc += dc\n\n            if maze[nr][nc] != -1:\n                q.append([nr, nc])\n                maze[nr][nc] = -1\n\n    return False\n\n\nmaze = [\n    [0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0],\n    [0, 0, 0, 1, 0],\n    [1, 1, 0, 1, 1],\n    [0, 0, 0, 0, 0],\n]\nstart = [0, 4]\ndestination = [4, 4]\nprint(hasPathBFS(maze, start, destination))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/grid_bfs/#505-the-maze-ii","title":"505. The Maze II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, graph, heap priority queue, matrix, shortest path 505. The Maze II - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra\ndef shortestDistance(\n    maze: List[List[int]], start: List[int], destination: List[int]\n) -&gt; int:\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    m, n = len(maze), len(maze[0])\n\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    dist[start[0]][start[1]] = 0\n\n    heap = [(0, start[0], start[1])]\n\n    while heap:\n        d, r, c = heapq.heappop(heap)\n\n        if [r, c] == destination:\n            return d\n\n        for dr, dc in directions:\n            nr, nc, nd = r, c, d\n\n            while (\n                0 &lt;= nr + dr &lt; m\n                and 0 &lt;= nc + dc &lt; n\n                and maze[nr + dr][nc + dc] == 0\n            ):\n                nr += dr\n                nc += dc\n                nd += 1\n\n            if nd &lt; dist[nr][nc]:\n                dist[nr][nc] = nd\n                heapq.heappush(heap, (nd, nr, nc))\n\n    return -1\n\n\nmaze = [\n    [0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0],\n    [0, 0, 0, 1, 0],\n    [1, 1, 0, 1, 1],\n    [0, 0, 0, 0, 0],\n]\nstart = [0, 4]\ndestination = [4, 4]\nprint(shortestDistance(maze, start, destination))  # 12\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/grid_bfs/#499-the-maze-iii","title":"499. The Maze III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, depth first search, breadth first search, graph, heap priority queue, matrix, shortest path 499. The Maze III - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra\ndef findShortestWay(\n    maze: List[List[int]], ball: List[int], hole: List[int]\n) -&gt; str:\n    directions = [(-1, 0, \"u\"), (1, 0, \"d\"), (0, -1, \"l\"), (0, 1, \"r\")]\n    m, n = len(maze), len(maze[0])\n\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    dist[ball[0]][ball[1]] = 0\n\n    paths = [[\"\"] * n for _ in range(m)]\n    paths[ball[0]][ball[1]] = \"\"\n\n    heap = [(0, \"\", ball[0], ball[1])]\n\n    while heap:\n        d, path, x, y = heapq.heappop(heap)\n\n        if [x, y] == hole:\n            return path\n\n        for dx, dy, direction in directions:\n            nx, ny, nd = x, y, d\n\n            while (\n                0 &lt;= nx + dx &lt; m\n                and 0 &lt;= ny + dy &lt; n\n                and maze[nx + dx][ny + dy] == 0\n            ):\n                nx += dx\n                ny += dy\n                nd += 1\n\n                if [nx, ny] == hole:\n                    break\n\n            new_path = path + direction\n            if nd &lt; dist[nx][ny] or (\n                nd == dist[nx][ny] and new_path &lt; paths[nx][ny]\n            ):\n                dist[nx][ny] = nd\n                paths[nx][ny] = new_path\n                heapq.heappush(heap, (nd, new_path, nx, ny))\n\n    return \"impossible\"\n\n\nmaze = [\n    [0, 0, 0, 0, 0],\n    [1, 1, 0, 0, 1],\n    [0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 1],\n    [0, 1, 0, 0, 0],\n]\nball = [4, 3]\nhole = [0, 1]\nprint(findShortestWay(maze, ball, hole))  # \"lul\"\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/grid_bfs/#317-shortest-distance-from-all-buildings","title":"317. Shortest Distance from All Buildings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, breadth first search, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/grid_bfs/#2814-minimum-time-takes-to-reach-destination-without-drowning","title":"2814. Minimum Time Takes to Reach Destination Without Drowning","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, breadth first search, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/grid_dfs/","title":"Grid DFS","text":""},{"location":"content/endlesscheng/grid_dfs/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 200. Number of Islands (Medium)</li> <li> 695. Max Area of Island (Medium)</li> <li> 463. Island Perimeter (Easy)</li> <li> 2658. Maximum Number of Fish in a Grid (Medium)</li> <li> 1034. Coloring A Border (Medium)</li> <li> 1020. Number of Enclaves (Medium)</li> <li> 2684. Maximum Number of Moves in a Grid (Medium)</li> <li> 1254. Number of Closed Islands (Medium)</li> <li> 130. Surrounded Regions (Medium)</li> <li> 1905. Count Sub Islands (Medium)</li> <li> 1391. Check if There is a Valid Path in a Grid (Medium)</li> <li> 417. Pacific Atlantic Water Flow (Medium)</li> <li> 529. Minesweeper (Medium)</li> <li> 1559. Detect Cycles in 2D Grid (Medium)</li> <li> 827. Making A Large Island (Hard)</li> <li> 305. Number of Islands II (Hard) \ud83d\udc51</li> <li> 2061. Number of Spaces Cleaning Robot Cleaned (Medium) \ud83d\udc51</li> <li> 2852. Sum of Remoteness of All Cells (Medium) \ud83d\udc51</li> <li> 489. Robot Room Cleaner (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/grid_dfs/#200-number-of-islands","title":"200. Number of Islands","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix</p> </li> <li>Count the number of islands in a 2D grid.</li> <li>Method 1: DFS</li> <li> <p>Method 2: BFS (use a queue to traverse the grid)</p> </li> <li> <p>How to keep track of visited cells?</p> <ol> <li>Mark the visited cell as <code>0</code> (or any other value) to avoid revisiting it.</li> <li>Use a set to store the visited cells.</li> </ol> </li> <li> <p>Steps:</p> <ol> <li>Init: variables</li> <li>DFS/BFS: starting from the cell with <code>1</code>, turn all the connected <code>1</code>s to <code>0</code>.</li> <li>Traverse the grid, and if the cell is <code>1</code>, increment the count and call DFS/BFS.</li> </ol> </li> </ul> <p></p> 200. Number of Islands - Python Solution<pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef numIslandsDFS(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    res = 0\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] != \"1\":\n            return\n\n        grid[r][c] = \"2\"\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                dfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Set\ndef numIslandsBFS1(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == \"0\"\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\" and (r, c) not in visited:\n                visited.add((r, c))\n                bfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = dr + row, dc + col\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] != \"1\"\n                ):\n                    continue\n                grid[nr][nc] = \"2\"\n                q.append((nr, nc))\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == \"1\":\n                grid[i][j] = \"2\"\n                bfs(i, j)\n                res += 1\n\n    return res\n\n\ngrid = [\n    [\"1\", \"1\", \"1\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"0\", \"0\", \"0\", \"0\", \"0\"],\n]\n\nprint(numIslandsDFS(deepcopy(grid)))  # 1\nprint(numIslandsBFS1(deepcopy(grid)))  # 1\nprint(numIslandsBFS2(deepcopy(grid)))  # 1\n</code></pre> 200. Number of Islands - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\nprivate:\n    void dfs(vector&lt;vector&lt;char&gt;&gt; &amp;grid, int r, int c)\n    {\n        int row = grid.size();\n        int col = grid[0].size();\n\n        if (r &lt; 0 || r &gt;= row || c &lt; 0 || c &gt;= col || grid[r][c] != '1')\n        {\n            return;\n        }\n        grid[r][c] = '0';\n\n        dfs(grid, r - 1, c);\n        dfs(grid, r + 1, c);\n        dfs(grid, r, c - 1);\n        dfs(grid, r, c + 1);\n    }\n\npublic:\n    int numIslands(vector&lt;vector&lt;char&gt;&gt; &amp;grid)\n    {\n        int m = grid.size(), n = grid[0].size();\n        int res = 0;\n        for (int i = 0; i &lt; m; i++)\n        {\n            for (int j = 0; j &lt; n; j++)\n            {\n                if (grid[i][j] == '1')\n                {\n                    res++;\n                    dfs(grid, i, j);\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    Solution s;\n    vector&lt;vector&lt;char&gt;&gt; grid = {\n        {'1', '1', '0', '0', '0'},\n        {'1', '1', '0', '0', '0'},\n        {'0', '0', '1', '0', '0'},\n        {'0', '0', '0', '1', '1'}};\n    cout &lt;&lt; s.numIslands(grid) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/endlesscheng/grid_dfs/#695-max-area-of-island","title":"695. Max Area of Island","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix 695. Max Area of Island - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef maxAreaOfIslandDFS(grid: List[List[int]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] == 0:\n            return 0\n\n        grid[r][c] = 0\n\n        return (\n            1 + dfs(r + 1, c) + dfs(r - 1, c) + dfs(r, c + 1) + dfs(r, c - 1)\n        )\n\n    res = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                res = max(res, dfs(i, j))\n    return res\n\n\n# BFS\ndef maxAreaOfIslandBFS1(grid: List[List[int]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        area = 0\n\n        while q:\n            row, col = q.popleft()\n            area += 1\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == 0\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n        return area\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1 and (r, c) not in visited:\n                visited.add((r, c))\n                res = max(res, bfs(r, c))\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        area = 0\n\n        while q:\n            row, col = q.popleft()\n            area += 1\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n\n                if nr &lt; 0 or nr &gt;= m or nc &lt; 0 or nc &gt;= n or grid[nr][nc] == 0:\n                    continue\n\n                q.append((nr, nc))\n                grid[nr][nc] = 0\n\n        return area\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                grid[r][c] = 0\n                res = max(res, bfs(r, c))\n\n    return res\n\n\ngrid = [\n    [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0],\n    [0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],\n]\nprint(maxAreaOfIslandDFS(grid))  # 6\nprint(maxAreaOfIslandBFS1(grid))  # 6\nprint(numIslandsBFS2(grid))  # 6\n</code></pre></p> </li> </ul> 695. Max Area of Island - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {\n        int m = grid.size(), n = grid[0].size();\n        int res = 0;\n\n        auto dfs = [&amp;](auto&amp;&amp; self, int r, int c) -&gt; int {\n            if (r &lt; 0 || r &gt;= m || c &lt; 0 || c &gt;= n || grid[r][c] != 1) {\n                return 0;\n            }\n            grid[r][c] = 0;\n\n            return 1 + self(self, r - 1, c) + self(self, r, c - 1) +\n                   self(self, r + 1, c) + self(self, r, c + 1);\n        };\n        for (int i = 0; i &lt; m; i++) {\n            for (int j = 0; j &lt; n; j++) {\n                if (grid[i][j] == 1) {\n                    int area = dfs(dfs, i, j);\n                    res = max(res, area);\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution s;\n    vector&lt;vector&lt;int&gt;&gt; grid = {{0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},\n                                {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},\n                                {0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},\n                                {0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0},\n                                {0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0},\n                                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0},\n                                {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},\n                                {0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0}};\n    cout &lt;&lt; s.maxAreaOfIsland(grid) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/endlesscheng/grid_dfs/#463-island-perimeter","title":"463. Island Perimeter","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, matrix 463. Island Perimeter - Python Solution<pre><code>from typing import List\n\n\n# DFS\ndef islandPerimeterDFS(grid: List[List[int]]) -&gt; int:\n    # TC: O(m * n)\n    # SC: O(m * n)\n\n    visited = set()\n    m, n = len(grid), len(grid[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def dfs(r, c):\n        if (r, c) in visited or grid[r][c] == 0:\n            return 0\n        visited.add((r, c))\n        perimeter = 0\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if nr not in range(m) or nc not in range(n) or grid[nr][nc] == 0:\n                perimeter += 1\n            else:\n                perimeter += dfs(nr, nc)\n\n        return perimeter\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                return dfs(r, c)\n    return 0\n\n\ndef islandPerimeter(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    perimeter = 0\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                perimeter += 4\n\n                if r &gt; 0 and grid[r - 1][c] == 1:\n                    perimeter -= 2\n\n                if c &gt; 0 and grid[r][c - 1] == 1:\n                    perimeter -= 2\n\n    return perimeter\n\n\ngrid = [[0, 1, 0, 0], [1, 1, 1, 0], [0, 1, 0, 0], [1, 1, 0, 0]]\nprint(islandPerimeterDFS(grid))  # 16\nprint(islandPerimeter(grid))  # 16\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/grid_dfs/#2658-maximum-number-of-fish-in-a-grid","title":"2658. Maximum Number of Fish in a Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix 2658. Maximum Number of Fish in a Grid - Python Solution<pre><code>from typing import List\n\n\n# Grid DFS\ndef findMaxFish(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    res = 0\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] == 0:\n            return 0\n        val = grid[r][c]\n        grid[r][c] = 0\n\n        return (\n            val + dfs(r - 1, c) + dfs(r + 1, c) + dfs(r, c - 1) + dfs(r, c + 1)\n        )\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                res = max(res, dfs(i, j))\n\n    return res\n\n\ngrid = [[0, 2, 1, 0], [4, 0, 0, 3], [1, 0, 0, 4], [0, 3, 2, 0]]\nprint(findMaxFish(grid))  # 7\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/grid_dfs/#1034-coloring-a-border","title":"1034. Coloring A Border","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, matrix 1034. Coloring A Border - Python Solution<pre><code>from typing import List\n\n\n# Grid DFS\ndef colorBorder(\n    grid: List[List[int]], row: int, col: int, color: int\n) -&gt; List[List[int]]:\n\n    dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]]\n    m, n = len(grid), len(grid[0])\n    org = grid[row][col]\n    visited = set()\n    borders = set()\n\n    def dfs(r, c):\n        if (r, c) in visited:\n            return\n\n        visited.add((r, c))\n\n        is_border = False\n        for dr, dc in dirs:\n            nr, nc = dr + r, dc + c\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n:\n                if grid[nr][nc] == org:\n                    dfs(nr, nc)\n                elif (nr, nc) not in visited:\n                    is_border = True\n            else:\n                is_border = True\n\n        if is_border:\n            borders.add((r, c))\n\n    dfs(row, col)\n\n    for r, c in borders:\n        grid[r][c] = color\n\n    return grid\n\n\ngrid = [[1, 2, 2], [2, 3, 2]]\nrow = 0\ncol = 1\ncolor = 3\nprint(colorBorder(grid, row, col, color))  # [[1, 3, 3], [2, 3, 3]]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/grid_dfs/#1020-number-of-enclaves","title":"1020. Number of Enclaves","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix 1020. Number of Enclaves - Python Solution<pre><code>from typing import List\n\n\n# DFS\ndef numEnclaves(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    visited = set()\n\n    def dfs(r, c):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or grid[r][c] == 0\n            or (r, c) in visited\n        ):\n            return\n\n        grid[r][c] = 0\n        visited.add((r, c))\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if (\n                (r in [0, m - 1] or c in [0, n - 1])\n                and grid[r][c] == 1\n                and (r, c) not in visited\n            ):\n                dfs(r, c)\n\n    count = 0\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1 and (r, c) not in visited:\n                count += 1\n\n    return count\n\n\ngrid = [[0, 0, 0, 0], [1, 0, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0]]\nprint(numEnclaves(grid))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/grid_dfs/#2684-maximum-number-of-moves-in-a-grid","title":"2684. Maximum Number of Moves in a Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, matrix 2684. Maximum Number of Moves in a Grid - Python Solution<pre><code>from typing import List\n\n\n# DFS\ndef maxMovesDFS(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    res = 0\n\n    def dfs(r, c):\n        nonlocal res\n        res = max(res, c)\n        if res == n - 1:\n            return\n\n        for k in r - 1, r, r + 1:\n            if 0 &lt;= k &lt; m and grid[k][c + 1] &gt; grid[r][c]:\n                dfs(k, c + 1)\n        grid[r][c] = 0\n\n    for i in range(m):\n        dfs(i, 0)\n\n    return res\n\n\ngrid = [[2, 4, 3, 5], [5, 4, 9, 3], [3, 4, 2, 11], [10, 9, 13, 15]]\nprint(maxMovesDFS(grid))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/grid_dfs/#1254-number-of-closed-islands","title":"1254. Number of Closed Islands","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix 1254. Number of Closed Islands - Python Solution<pre><code>from typing import List\n\n\n# DFS\ndef closedIsland(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    visited = set()\n\n    def dfs(r, c):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or grid[r][c] == 1\n            or (r, c) in visited\n        ):\n            return\n\n        grid[r][c] = 1\n        visited.add((r, c))\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if (\n                (r in [0, m - 1] or c in [0, n - 1])\n                and grid[r][c] == 0\n                and (r, c) not in visited\n            ):\n                dfs(r, c)\n\n    island = 0\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 0 and (r, c) not in visited:\n                island += 1\n                dfs(r, c)\n\n    return island\n\n\ngrid = [\n    [1, 1, 1, 1, 1, 1, 1, 0],\n    [1, 0, 0, 0, 0, 1, 1, 0],\n    [1, 0, 1, 0, 1, 1, 1, 0],\n    [1, 0, 0, 0, 0, 1, 0, 1],\n    [1, 1, 1, 1, 1, 1, 1, 0],\n]\nprint(closedIsland(grid))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/grid_dfs/#130-surrounded-regions","title":"130. Surrounded Regions","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix 130. Surrounded Regions - Python Solution<pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef solveDFS(board: List[List[str]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n    if not board and not board[0]:\n        return None\n\n    m, n = len(board), len(board[0])\n\n    def capture(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or board[r][c] != \"O\":\n            return None\n\n        board[r][c] = \"T\"\n        capture(r + 1, c)\n        capture(r - 1, c)\n        capture(r, c + 1)\n        capture(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\" and (r in [0, m - 1] or c in [0, n - 1]):\n                capture(r, c)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\":\n                board[r][c] = \"X\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"T\":\n                board[r][c] = \"O\"\n\n\n# BFS\ndef solveBFS(board: List[List[str]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n    if not board and not board[0]:\n        return None\n\n    m, n = len(board), len(board[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def capture(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr = row + dr\n                nc = col + dc\n                if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and board[nr][nc] == \"O\":\n                    board[nr][nc] = \"T\"\n                    q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\" and (r in [0, m - 1] or c in [0, n - 1]):\n                board[r][c] = \"T\"\n                capture(r, c)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\":\n                board[r][c] = \"X\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"T\":\n                board[r][c] = \"O\"\n\n\nif __name__ == \"__main__\":\n    board = [\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"O\", \"O\", \"X\"],\n        [\"X\", \"X\", \"O\", \"X\"],\n        [\"X\", \"O\", \"X\", \"X\"],\n    ]\n\n    b = deepcopy(board)\n    solveDFS(b)\n    assert b == [\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"O\", \"X\", \"X\"],\n    ]\n\n    b = deepcopy(board)\n    solveBFS(b)\n    assert b == [\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"O\", \"X\", \"X\"],\n    ]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/grid_dfs/#1905-count-sub-islands","title":"1905. Count Sub Islands","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix 1905. Count Sub Islands - Python Solution<pre><code>from typing import List\n\n\n# DFS\ndef countSubIslandsDFS(grid1: List[List[int]], grid2: List[List[int]]) -&gt; int:\n    m, n = len(grid2), len(grid2[0])\n    dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n\n    def dfs(r, c, valid):\n        grid2[r][c] = 0\n        if grid1[r][c] == 0:\n            valid = False\n        for dr, dc in dirs:\n            nr, nc = dr + r, dc + c\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and grid2[nr][nc] == 1:\n                valid = dfs(nr, nc, valid)\n        return valid\n\n    res = 0\n\n    for i in range(m):\n        for j in range(n):\n            if grid2[i][j] == 1:\n                if dfs(i, j, True):\n                    res += 1\n\n    return res\n\n\ngrid1 = [\n    [1, 1, 1, 0, 0],\n    [0, 1, 1, 1, 1],\n    [0, 0, 0, 0, 0],\n    [1, 0, 0, 0, 0],\n    [1, 1, 0, 1, 1],\n]\ngrid2 = [\n    [1, 1, 1, 0, 0],\n    [0, 0, 1, 1, 1],\n    [0, 1, 0, 0, 0],\n    [1, 0, 1, 1, 0],\n    [0, 1, 0, 1, 0],\n]\nprint(countSubIslandsDFS(grid1, grid2))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/grid_dfs/#1391-check-if-there-is-a-valid-path-in-a-grid","title":"1391. Check if There is a Valid Path in a Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/grid_dfs/#417-pacific-atlantic-water-flow","title":"417. Pacific Atlantic Water Flow","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, matrix 417. Pacific Atlantic Water Flow - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef pacificAtlanticDFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(r, c, visited, prev_height):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or heights[r][c] &lt; prev_height\n            or (r, c) in visited\n        ):\n            return None\n\n        visited.add((r, c))\n        height = heights[r][c]\n        for dr, dc in directions:\n            dfs(dr + r, dc + c, visited, height)\n\n    for c in range(n):\n        dfs(0, c, pac, heights[0][c])\n        dfs(m - 1, c, atl, heights[m - 1][c])\n\n    for r in range(m):\n        dfs(r, 0, pac, heights[r][0])\n        dfs(r, n - 1, atl, heights[r][n - 1])\n\n    return list(pac &amp; atl)\n\n\n# BFS\ndef pacificAtlanticBFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def bfs(r, c, visited):\n        q = deque([(r, c)])\n        visited.add((r, c))\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr in range(m)\n                    and nc in range(n)\n                    and heights[row][col] &lt;= heights[nr][nc]\n                    and (nr, nc) not in visited\n                ):\n                    q.append((nr, nc))\n                    visited.add((nr, nc))\n\n    for c in range(n):\n        bfs(0, c, pac)  # top\n        bfs(m - 1, c, atl)  # bottom\n\n    for r in range(m):\n        bfs(r, 0, pac)  # left\n        bfs(r, n - 1, atl)  # right\n\n    return list(pac &amp; atl)\n\n\nheights = [\n    [1, 2, 2, 3, 5],\n    [3, 2, 3, 4, 4],\n    [2, 4, 5, 3, 1],\n    [6, 7, 1, 4, 5],\n    [5, 1, 1, 2, 4],\n]\nprint(pacificAtlanticDFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\nprint(pacificAtlanticBFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/grid_dfs/#529-minesweeper","title":"529. Minesweeper","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/grid_dfs/#1559-detect-cycles-in-2d-grid","title":"1559. Detect Cycles in 2D Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/grid_dfs/#827-making-a-large-island","title":"827. Making A Large Island","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix 827. Making A Large Island - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Flood Fill\ndef largestIsland(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    areas = defaultdict(int)  # {index: area}\n    index = 2\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(r, c, index):\n        area = 1\n        grid[r][c] = index\n        for dr, dc in dirs:\n            nr, nc = r + dr, c + dc\n            if 0 &lt;= nr &lt; n and 0 &lt;= nc &lt; n and grid[nr][nc] == 1:\n                area += dfs(nr, nc, index)\n        return area\n\n    for r in range(n):\n        for c in range(n):\n            if grid[r][c] == 1:\n                areas[index] = dfs(r, c, index)\n                index += 1\n\n    if not areas:\n        return 1\n\n    res = max(areas.values())\n\n    for r in range(n):\n        for c in range(n):\n            if grid[r][c] == 0:\n                connected = set()\n                area = 1\n                for dr, dc in dirs:\n                    nr, nc = r + dr, c + dc\n                    if 0 &lt;= nr &lt; n and 0 &lt;= nc &lt; n and grid[nr][nc] &gt; 1:\n                        connected.add(grid[nr][nc])\n\n                for island in connected:\n                    area += areas[island]\n                res = max(res, area)\n\n    return res\n\n\ngrid = [[1, 0], [0, 1]]\nprint(largestIsland(grid))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/grid_dfs/#305-number-of-islands-ii","title":"305. Number of Islands II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, union find 305. Number of Islands II - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef numIslands2(m: int, n: int, positions: List[List[int]]) -&gt; List[int]:\n    parent = defaultdict(tuple)\n    islands = 0\n    result = []\n    visited = set()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def find(node):\n        p = parent[node]\n        while parent[p] != p:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            parent[p1] = p2\n            return True\n        return False\n\n    for r, c in positions:\n        if (r, c) in visited:\n            result.append(islands)\n            continue\n\n        islands += 1\n        parent[(r, c)] = (r, c)\n        visited.add((r, c))\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if (nr, nc) in visited:\n                if union((r, c), (nr, nc)):\n                    islands -= 1\n\n        result.append(islands)\n\n    return result\n\n\nm = 3\nn = 3\npositions = [[0, 0], [0, 1], [1, 2], [2, 1]]\nprint(numIslands2(m, n, positions))  # [1, 1, 2, 3]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/grid_dfs/#2061-number-of-spaces-cleaning-robot-cleaned","title":"2061. Number of Spaces Cleaning Robot Cleaned","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, matrix, simulation</p> </li> </ul>"},{"location":"content/endlesscheng/grid_dfs/#2852-sum-of-remoteness-of-all-cells","title":"2852. Sum of Remoteness of All Cells","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, depth first search, breadth first search, union find, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/grid_dfs/#489-robot-room-cleaner","title":"489. Robot Room Cleaner","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: backtracking, interactive</p> </li> </ul>"},{"location":"content/endlesscheng/grouped_loop/","title":"Grouped Loop","text":""},{"location":"content/endlesscheng/grouped_loop/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1446. Consecutive Characters (Easy)</li> <li> 1869. Longer Contiguous Segments of Ones than Zeros (Easy)</li> <li> 2414. Length of the Longest Alphabetical Continuous Substring (Medium)</li> <li> 3456. Find Special Substring of Length K (Easy)</li> <li> 1957. Delete Characters to Make Fancy String (Easy)</li> <li> 674. Longest Continuous Increasing Subsequence (Easy)</li> <li> 978. Longest Turbulent Subarray (Medium)</li> <li> 2110. Number of Smooth Descent Periods of a Stock (Medium)</li> <li> 228. Summary Ranges (Easy)</li> <li> 2760. Longest Even Odd Subarray With Threshold (Easy)</li> <li> 1887. Reduction Operations to Make the Array Elements Equal (Medium)</li> <li> 845. Longest Mountain in Array (Medium)</li> <li> 2038. Remove Colored Pieces if Both Neighbors are the Same Color (Medium)</li> <li> 1759. Count Number of Homogenous Substrings (Medium)</li> <li> 3011. Find if Array Can Be Sorted (Medium)</li> <li> 1578. Minimum Time to Make Rope Colorful (Medium)</li> <li> 1839. Longest Substring Of All Vowels in Order (Medium)</li> <li> 2765. Longest Alternating Subarray (Easy)</li> <li> 3255. Find the Power of K-Size Subarrays II (Medium)</li> <li> 3350. Adjacent Increasing Subarrays Detection II (Medium)</li> <li> 3105. Longest Strictly Increasing or Strictly Decreasing Subarray (Easy)</li> <li> 467. Unique Substrings in Wraparound String (Medium)</li> <li> 2948. Make Lexicographically Smallest Array by Swapping Elements (Medium)</li> <li> 2593. Find Score of an Array After Marking All Elements (Medium)</li> <li> 2393. Count Strictly Increasing Subarrays (Medium) \ud83d\udc51</li> <li> 2436. Minimum Split Into Subarrays With GCD Greater Than One (Medium) \ud83d\udc51</li> <li> 2495. Number of Subarrays Having Even Product (Medium) \ud83d\udc51</li> <li> 3063. Linked List Frequency (Easy) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/grouped_loop/#1446-consecutive-characters","title":"1446. Consecutive Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string</p> </li> </ul>"},{"location":"content/endlesscheng/grouped_loop/#1869-longer-contiguous-segments-of-ones-than-zeros","title":"1869. Longer Contiguous Segments of Ones than Zeros","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string</p> </li> </ul>"},{"location":"content/endlesscheng/grouped_loop/#2414-length-of-the-longest-alphabetical-continuous-substring","title":"2414. Length of the Longest Alphabetical Continuous Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string</p> </li> </ul>"},{"location":"content/endlesscheng/grouped_loop/#3456-find-special-substring-of-length-k","title":"3456. Find Special Substring of Length K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string</p> </li> </ul>"},{"location":"content/endlesscheng/grouped_loop/#1957-delete-characters-to-make-fancy-string","title":"1957. Delete Characters to Make Fancy String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string</p> </li> </ul>"},{"location":"content/endlesscheng/grouped_loop/#674-longest-continuous-increasing-subsequence","title":"674. Longest Continuous Increasing Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array 674. Longest Continuous Increasing Subsequence - Python Solution<pre><code>from typing import List\n\n\ndef findLengthOfLCIS(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return n\n\n    dp = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        if nums[i] &gt; nums[i - 1]:\n            dp[i] = dp[i - 1] + 1\n\n    return max(dp)\n\n\nprint(findLengthOfLCIS([1, 3, 5, 4, 7]))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/grouped_loop/#978-longest-turbulent-subarray","title":"978. Longest Turbulent Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, sliding window 978. Longest Turbulent Subarray - Python Solution<pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxTurbulenceSize(arr: List[int]) -&gt; int:\n    n = len(arr)\n    up = [1 for _ in range(n)]\n    down = [1 for _ in range(n)]\n    maxLen = 1\n\n    for i in range(1, n):\n        if arr[i - 1] &lt; arr[i]:\n            up[i] = down[i - 1] + 1\n            down[i] = 1\n        elif arr[i - 1] &gt; arr[i]:\n            down[i] = up[i - 1] + 1\n            up[i] = 1\n        else:\n            up[i] = 1\n            down[i] = 1\n\n        maxLen = max(maxLen, up[i], down[i])\n\n    return maxLen\n\n\narr = [9, 4, 2, 10, 7, 8, 8, 1, 9]\nprint(maxTurbulenceSize(arr))  # 5\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/grouped_loop/#2110-number-of-smooth-descent-periods-of-a-stock","title":"2110. Number of Smooth Descent Periods of a Stock","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/grouped_loop/#228-summary-ranges","title":"228. Summary Ranges","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array 228. Summary Ranges - Python Solution<pre><code>from typing import List\n\n\n# Variable Sliding Window\ndef summaryRanges(nums: List[int]) -&gt; List[str]:\n    left, right = 0, 0\n    n = len(nums)\n    res = []\n\n    while left &lt; n:\n        while right + 1 &lt; n and nums[right] + 1 == nums[right + 1]:\n            right += 1\n\n        if left == right:\n            res.append(f\"{nums[left]}\")\n        else:\n            res.append(f\"{nums[left]}-&gt;{nums[right]}\")\n\n        right += 1\n        left = right\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(summaryRanges([0, 1, 2, 4, 5, 7]))\n    # [\"0-&gt;2\", \"4-&gt;5\", \"7\"]\n    print(summaryRanges([0, 2, 3, 4, 6, 8, 9]))\n    # [\"0\", \"2-&gt;4\", \"6\", \"8-&gt;9\"]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/grouped_loop/#2760-longest-even-odd-subarray-with-threshold","title":"2760. Longest Even Odd Subarray With Threshold","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/grouped_loop/#1887-reduction-operations-to-make-the-array-elements-equal","title":"1887. Reduction Operations to Make the Array Elements Equal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/grouped_loop/#845-longest-mountain-in-array","title":"845. Longest Mountain in Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, dynamic programming, enumeration 845. Longest Mountain in Array - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef longestMountain(arr: List[int]) -&gt; int:\n    n = len(arr)\n    res = 0\n    left = 0\n\n    while left &lt; n:\n        right = left\n\n        if right &lt; n - 1 and arr[right] &lt; arr[right + 1]:\n            while right &lt; n - 1 and arr[right] &lt; arr[right + 1]:\n                right += 1\n\n            if right &lt; n - 1 and arr[right] &gt; arr[right + 1]:\n                while right &lt; n - 1 and arr[right] &gt; arr[right + 1]:\n                    right += 1\n                res = max(res, right - left + 1)\n\n        left = max(right, left + 1)\n\n    return res\n\n\narr = [2, 1, 4, 7, 3, 2, 5]\nprint(longestMountain(arr))  # 5\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/grouped_loop/#2038-remove-colored-pieces-if-both-neighbors-are-the-same-color","title":"2038. Remove Colored Pieces if Both Neighbors are the Same Color","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, string, greedy, game theory</p> </li> </ul>"},{"location":"content/endlesscheng/grouped_loop/#1759-count-number-of-homogenous-substrings","title":"1759. Count Number of Homogenous Substrings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, string</p> </li> </ul>"},{"location":"content/endlesscheng/grouped_loop/#3011-find-if-array-can-be-sorted","title":"3011. Find if Array Can Be Sorted","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/grouped_loop/#1578-minimum-time-to-make-rope-colorful","title":"1578. Minimum Time to Make Rope Colorful","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, dynamic programming, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/grouped_loop/#1839-longest-substring-of-all-vowels-in-order","title":"1839. Longest Substring Of All Vowels in Order","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/grouped_loop/#2765-longest-alternating-subarray","title":"2765. Longest Alternating Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/grouped_loop/#3255-find-the-power-of-k-size-subarrays-ii","title":"3255. Find the Power of K-Size Subarrays II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/grouped_loop/#3350-adjacent-increasing-subarrays-detection-ii","title":"3350. Adjacent Increasing Subarrays Detection II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"content/endlesscheng/grouped_loop/#3105-longest-strictly-increasing-or-strictly-decreasing-subarray","title":"3105. Longest Strictly Increasing or Strictly Decreasing Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array</p> </li> </ul>"},{"location":"content/endlesscheng/grouped_loop/#467-unique-substrings-in-wraparound-string","title":"467. Unique Substrings in Wraparound String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/grouped_loop/#2948-make-lexicographically-smallest-array-by-swapping-elements","title":"2948. Make Lexicographically Smallest Array by Swapping Elements","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, union find, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/grouped_loop/#2593-find-score-of-an-array-after-marking-all-elements","title":"2593. Find Score of an Array After Marking All Elements","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, sorting, heap priority queue, simulation</p> </li> </ul>"},{"location":"content/endlesscheng/grouped_loop/#2393-count-strictly-increasing-subarrays","title":"2393. Count Strictly Increasing Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/grouped_loop/#2436-minimum-split-into-subarrays-with-gcd-greater-than-one","title":"2436. Minimum Split Into Subarrays With GCD Greater Than One","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, dynamic programming, greedy, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/grouped_loop/#2495-number-of-subarrays-having-even-product","title":"2495. Number of Subarrays Having Even Product","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/grouped_loop/#3063-linked-list-frequency","title":"3063. Linked List Frequency","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, linked list, counting</p> </li> </ul>"},{"location":"content/endlesscheng/heap_advanced/","title":"Heap Advanced","text":""},{"location":"content/endlesscheng/heap_advanced/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 23. Merge k Sorted Lists (Hard)</li> <li> 355. Design Twitter (Medium)</li> <li> 502. IPO (Hard)</li> <li> 1705. Maximum Number of Eaten Apples (Medium)</li> <li> 778. Swim in Rising Water (Hard)</li> <li> 1631. Path With Minimum Effort (Medium)</li> <li> 1354. Construct Target Array With Multiple Sums (Hard)</li> <li> 1353. Maximum Number of Events That Can Be Attended (Medium)</li> <li> 1235. Maximum Profit in Job Scheduling (Hard)</li> <li> 632. Smallest Range Covering Elements from K Lists (Hard)</li> <li> 2542. Maximum Subsequence Score (Medium)</li> <li> 1383. Maximum Performance of a Team (Hard)</li> <li> 2503. Maximum Number of Points From Grid Queries (Hard)</li> <li> 2163. Minimum Difference in Sums After Removal of Elements (Hard)</li> <li> 857. Minimum Cost to Hire K Workers (Hard)</li> <li> 1606. Find Servers That Handled Most Number of Requests (Hard)</li> <li> 1851. Minimum Interval to Include Each Query (Hard)</li> <li> 218. The Skyline Problem (Hard)</li> <li> 407. Trapping Rain Water II (Hard)</li> <li> 2940. Find Building Where Alice and Bob Can Meet (Hard)</li> <li> 3399. Smallest Substring With Identical Characters II (Hard)</li> <li> 2589. Minimum Time to Complete All Tasks (Hard)</li> <li> 3266. Final Array State After K Multiplication Operations II (Hard)</li> <li> 1675. Minimize Deviation in Array (Hard)</li> <li> 2617. Minimum Number of Visited Cells in a Grid (Hard)</li> <li> 2532. Time to Cross a Bridge (Hard)</li> <li> 1199. Minimum Time to Build Blocks (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/heap_advanced/#23-merge-k-sorted-lists","title":"23. Merge k Sorted Lists","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: linked list, divide and conquer, heap priority queue, merge sort</p> </li> <li>Prerequisite: 21. Merge Two Sorted Lists</li> <li>Video explanation: 23. Merge K Sorted Lists - NeetCode</li> </ul> 23. Merge k Sorted Lists - Python Solution<pre><code>import copy\nimport heapq\nfrom typing import List, Optional\n\nfrom template import ListNode\n\n\n# Divide and Conquer\ndef mergeKListsDC(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    if not lists or len(lists) == 0:\n        return None\n\n    def mergeTwo(l1, l2):\n        dummy = ListNode()\n        cur = dummy\n\n        while l1 and l2:\n            if l1.val &lt; l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n\n            cur = cur.next\n\n        cur.next = l1 if l1 else l2\n\n        return dummy.next\n\n    while len(lists) &gt; 1:\n        merged = []\n\n        for i in range(0, len(lists), 2):\n            l1 = lists[i]\n            l2 = lists[i + 1] if i + 1 &lt; len(lists) else None\n            merged.append(mergeTwo(l1, l2))\n\n        lists = merged\n\n    return lists[0]\n\n\n# Heap - Merge k Sorted\ndef mergeKLists(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    minHeap = []  # (val, idx, node)\n\n    for idx, head in enumerate(lists):\n        if head:\n            heapq.heappush(minHeap, (head.val, idx, head))\n\n    while minHeap:\n        _, idx, node = heapq.heappop(minHeap)\n        cur.next = node\n        cur = cur.next\n\n        node = node.next\n        if node:\n            heapq.heappush(minHeap, (node.val, idx, node))\n\n    return dummy.next\n\n\nn1 = ListNode.create([1, 4, 5])\nn2 = ListNode.create([1, 3, 4])\nn3 = ListNode.create([2, 6])\nlists = [n1, n2, n3]\nlists1 = copy.deepcopy(lists)\nlists2 = copy.deepcopy(lists)\nprint(mergeKListsDC(lists1))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6\nprint(mergeKLists(lists2))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6\n</code></pre>"},{"location":"content/endlesscheng/heap_advanced/#355-design-twitter","title":"355. Design Twitter","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, linked list, design, heap priority queue</p> </li> <li>Similar question: 23. Merge K Sorted Lists (Hard)</li> </ul> 355. Design Twitter - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Design\nclass Twitter:\n\n    def __init__(self):\n        self.tweets = defaultdict(list)\n        self.followees = defaultdict(set)\n        self.time = 0\n\n    def postTweet(self, userId: int, tweetId: int) -&gt; None:\n        self.tweets[userId].append((self.time, tweetId))\n        self.time += 1\n\n    def getNewsFeed(self, userId: int) -&gt; List[int]:\n        news_feed = []\n        news_feed.extend(self.tweets[userId])\n        for followee in self.followees[userId]:\n            news_feed.extend(self.tweets[followee])\n\n        return [tweet for _, tweet in heapq.nlargest(10, news_feed)]\n\n    def follow(self, followerId: int, followeeId: int) -&gt; None:\n        if followerId != followeeId:\n            self.followees[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -&gt; None:\n        if followerId != followeeId:\n            self.followees[followerId].discard(followeeId)\n\n\ntwitter = Twitter()\nprint(twitter.postTweet(1, 5))  # None\nprint(twitter.getNewsFeed(1))  # [5]\nprint(twitter.follow(1, 2))  # None\nprint(twitter.postTweet(2, 6))  # None\nprint(twitter.getNewsFeed(1))  # [6, 5]\nprint(twitter.unfollow(1, 2))  # None\nprint(twitter.getNewsFeed(1))  # [5]\n</code></pre>"},{"location":"content/endlesscheng/heap_advanced/#502-ipo","title":"502. IPO","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sorting, heap priority queue 502. IPO - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Heap - Two Heaps\ndef findMaximizedCapital(\n    k: int, w: int, profits: List[int], capital: List[int]\n) -&gt; int:\n    \"\"\"\n    Time Complexity: O(k log N)\n    Space Complexity: O(N)\n    \"\"\"\n    if not profits or not capital:\n        return w\n\n    if w &gt;= max(capital) and k &gt;= len(capital):\n        return sum(profits) + w\n\n    max_profit = []\n    min_capital = [(c, p) for c, p in zip(capital, profits)]\n    heapq.heapify(min_capital)\n\n    for _ in range(k):\n        while min_capital and min_capital[0][0] &lt;= w:\n            _, pro = heapq.heappop(min_capital)\n            heapq.heappush(max_profit, -pro)\n\n        if max_profit:\n            w += -heapq.heappop(max_profit)\n\n    return w\n\n\nif __name__ == \"__main__\":\n    k = 2\n    w = 0\n    profits = [1, 2, 3]\n    capital = [0, 1, 1]\n    assert findMaximizedCapital(k, w, profits, capital) == 4\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/heap_advanced/#1705-maximum-number-of-eaten-apples","title":"1705. Maximum Number of Eaten Apples","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/heap_advanced/#778-swim-in-rising-water","title":"778. Swim in Rising Water","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, depth first search, breadth first search, union find, heap priority queue, matrix</p> </li> <li>Return the minimum time when you can reach the target.</li> </ul> <p></p> 778. Swim in Rising Water - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra's\ndef swimInWater(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    visited = set()\n    minHeap = [(grid[0][0], 0, 0)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    visited.add((0, 0))\n\n    while minHeap:\n        time, r, c = heapq.heappop(minHeap)\n\n        if r == n - 1 and c == n - 1:\n            return time\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if nr in range(n) and nc in range(n) and (nr, nc) not in visited:\n                visited.add((nr, nc))\n                heapq.heappush(minHeap, (max(time, grid[nr][nc]), nr, nc))\n\n\ngrid = [\n    [0, 1, 2, 3, 4],\n    [24, 23, 22, 21, 5],\n    [12, 13, 14, 15, 16],\n    [11, 17, 18, 19, 20],\n    [10, 9, 8, 7, 6],\n]\nprint(swimInWater(grid))  # 16\n</code></pre>"},{"location":"content/endlesscheng/heap_advanced/#1631-path-with-minimum-effort","title":"1631. Path With Minimum Effort","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, depth first search, breadth first search, union find, heap priority queue, matrix</p> </li> <li>Return the minimum effort required to travel from the top-left to the bottom-right corner.</li> </ul> 1631. Path With Minimum Effort - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Prim\ndef minimumEffortPath(heights: List[List[int]]) -&gt; int:\n    m, n = len(heights), len(heights[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * n for _ in range(m)]\n    heap = [(0, 0, 0)]  # (effort, row, col)\n\n    while heap:\n        effort, r, c = heapq.heappop(heap)\n\n        if visited[r][c]:\n            continue\n\n        if r == m - 1 and c == n - 1:\n            return effort\n\n        visited[r][c] = True\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and not visited[nr][nc]:\n                updated = max(effort, abs(heights[r][c] - heights[nr][nc]))\n                heapq.heappush(heap, (updated, nr, nc))\n\n    return -1\n\n\nheights = [[1, 2, 2], [3, 8, 2], [5, 3, 5]]\nprint(minimumEffortPath(heights))  # 2\n</code></pre>"},{"location":"content/endlesscheng/heap_advanced/#1354-construct-target-array-with-multiple-sums","title":"1354. Construct Target Array With Multiple Sums","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/heap_advanced/#1353-maximum-number-of-events-that-can-be-attended","title":"1353. Maximum Number of Events That Can Be Attended","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/heap_advanced/#1235-maximum-profit-in-job-scheduling","title":"1235. Maximum Profit in Job Scheduling","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, dynamic programming, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/heap_advanced/#632-smallest-range-covering-elements-from-k-lists","title":"632. Smallest Range Covering Elements from K Lists","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, greedy, sliding window, sorting, heap priority queue 632. Smallest Range Covering Elements from K Lists - Python Solution<pre><code>from heapq import heapify, heapreplace\nfrom math import inf\nfrom typing import List\n\n\n# Heap\ndef smallestRange(nums: List[List[int]]) -&gt; List[int]:\n    heap = [(arr[0], i, 0) for i, arr in enumerate(nums)]\n    heapify(heap)\n\n    res_l = heap[0][0]\n    res_r = right = max(arr[0] for arr in nums)\n\n    while heap[0][2] + 1 &lt; len(nums[heap[0][1]]):\n        _, i, j = heap[0]\n        x = nums[i][j + 1]\n        heapreplace(heap, (x, i, j + 1))\n        right = max(right, x)\n        left = heap[0][0]\n        if right - left &lt; res_r - res_l:\n            res_l, res_r = left, right\n\n    return [res_l, res_r]\n\n\n# Sliding Window Variable Min\ndef smallestRangeSliding(nums: List[List[int]]) -&gt; List[int]:\n    pairs = sorted((x, i) for (i, arr) in enumerate(nums) for x in arr)\n    res_l, res_r = -inf, inf\n    empty = len(nums)\n    cnt = [0] * empty\n    left = 0\n\n    for r, i in pairs:\n        if cnt[i] == 0:\n            empty -= 1\n        cnt[i] += 1\n        while empty == 0:\n            l, i = pairs[left]\n            if r - l &lt; res_r - res_l:\n                res_l, res_r = l, r\n            cnt[i] -= 1\n            if cnt[i] == 0:\n                empty += 1\n            left += 1\n\n    return [res_l, res_r]\n\n\nif __name__ == \"__main__\":\n    nums = [[4, 10, 15, 24, 26], [0, 9, 12, 20], [5, 18, 22, 30]]\n    assert smallestRange(nums) == [20, 24]\n    assert smallestRangeSliding(nums) == [20, 24]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/heap_advanced/#2542-maximum-subsequence-score","title":"2542. Maximum Subsequence Score","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/heap_advanced/#1383-maximum-performance-of-a-team","title":"1383. Maximum Performance of a Team","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sorting, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/heap_advanced/#2503-maximum-number-of-points-from-grid-queries","title":"2503. Maximum Number of Points From Grid Queries","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, breadth first search, union find, sorting, heap priority queue, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/heap_advanced/#2163-minimum-difference-in-sums-after-removal-of-elements","title":"2163. Minimum Difference in Sums After Removal of Elements","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/heap_advanced/#857-minimum-cost-to-hire-k-workers","title":"857. Minimum Cost to Hire K Workers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sorting, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/heap_advanced/#1606-find-servers-that-handled-most-number-of-requests","title":"1606. Find Servers That Handled Most Number of Requests","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, heap priority queue, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/heap_advanced/#1851-minimum-interval-to-include-each-query","title":"1851. Minimum Interval to Include Each Query","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, line sweep, sorting, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/heap_advanced/#218-the-skyline-problem","title":"218. The Skyline Problem","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, divide and conquer, binary indexed tree, segment tree, line sweep, heap priority queue, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/heap_advanced/#407-trapping-rain-water-ii","title":"407. Trapping Rain Water II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, breadth first search, heap priority queue, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/heap_advanced/#2940-find-building-where-alice-and-bob-can-meet","title":"2940. Find Building Where Alice and Bob Can Meet","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, stack, binary indexed tree, segment tree, heap priority queue, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/heap_advanced/#3399-smallest-substring-with-identical-characters-ii","title":"3399. Smallest Substring With Identical Characters II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, binary search</p> </li> </ul>"},{"location":"content/endlesscheng/heap_advanced/#2589-minimum-time-to-complete-all-tasks","title":"2589. Minimum Time to Complete All Tasks","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, stack, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/heap_advanced/#3266-final-array-state-after-k-multiplication-operations-ii","title":"3266. Final Array State After K Multiplication Operations II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, heap priority queue, simulation</p> </li> </ul>"},{"location":"content/endlesscheng/heap_advanced/#1675-minimize-deviation-in-array","title":"1675. Minimize Deviation in Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, heap priority queue, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/heap_advanced/#2617-minimum-number-of-visited-cells-in-a-grid","title":"2617. Minimum Number of Visited Cells in a Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, stack, breadth first search, union find, heap priority queue, matrix, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/heap_advanced/#2532-time-to-cross-a-bridge","title":"2532. Time to Cross a Bridge","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, heap priority queue, simulation</p> </li> </ul>"},{"location":"content/endlesscheng/heap_advanced/#1199-minimum-time-to-build-blocks","title":"1199. Minimum Time to Build Blocks","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, greedy, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/heap_basics/","title":"Heap Basics","text":""},{"location":"content/endlesscheng/heap_basics/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1046. Last Stone Weight (Easy)</li> <li> 3264. Final Array State After K Multiplication Operations I (Easy)</li> <li> 2558. Take Gifts From the Richest Pile (Easy)</li> <li> 2336. Smallest Number in Infinite Set (Medium)</li> <li> 2530. Maximal Score After Applying K Operations (Medium)</li> <li> 3066. Minimum Operations to Exceed Threshold Value II (Medium)</li> <li> 1962. Remove Stones to Minimize the Total (Medium)</li> <li> 703. Kth Largest Element in a Stream (Easy)</li> <li> 3275. K-th Nearest Obstacle Queries (Medium)</li> <li> 2208. Minimum Operations to Halve Array Sum (Medium)</li> <li> 2233. Maximum Product After K Increments (Medium)</li> <li> 3296. Minimum Number of Seconds to Make Mountain Height Zero (Medium)</li> <li> 1942. The Number of the Smallest Unoccupied Chair (Medium)</li> <li> 1801. Number of Orders in the Backlog (Medium)</li> <li> 2406. Divide Intervals Into Minimum Number of Groups (Medium)</li> <li> 2462. Total Cost to Hire K Workers (Medium)</li> <li> 1834. Single-Threaded CPU (Medium)</li> <li> 3408. Design Task Manager (Medium)</li> <li> 1792. Maximum Average Pass Ratio (Medium)</li> <li> 2931. Maximum Spending After Buying Items (Hard)</li> <li> 1882. Process Tasks Using Servers (Medium)</li> <li> 2402. Meeting Rooms III (Hard)</li> <li> 253. Meeting Rooms II (Medium) \ud83d\udc51</li> <li> 1167. Minimum Cost to Connect Sticks (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/heap_basics/#1046-last-stone-weight","title":"1046. Last Stone Weight","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, heap priority queue</p> </li> <li>Heap<ul> <li>Time: O(n log n); Space: O(n)</li> </ul> </li> <li>0/1 Knapsack<ul> <li>Time: O(n); Space: O(n)</li> </ul> </li> </ul> 1046. Last Stone Weight - Python Solution<pre><code>from heapq import heapify, heappop, heappush\nfrom typing import List\n\n\n# Heap\ndef lastStoneWeightHeap(stones: List[int]) -&gt; int:\n    maxHeap = [-s for s in stones]\n    heapify(maxHeap)\n\n    while len(maxHeap) &gt; 1:\n        s1 = heappop(maxHeap)\n        s2 = heappop(maxHeap)\n\n        if s1 != s2:\n            heappush(maxHeap, s1 - s2)\n\n    return -maxHeap[0] if maxHeap else 0\n\n\n# 0/1 Knapsack\ndef lastStoneWeightKnapsack(stones: List[int]) -&gt; int:\n    total = sum(stones)\n    target = total // 2\n\n    dp = [0 for _ in range(target + 1)]\n\n    for i in stones:\n        for j in range(target, i - 1, -1):\n            dp[j] = max(dp[j], dp[j - i] + i)\n\n    return total - 2 * dp[target]\n\n\nif __name__ == \"__main__\":\n    stones = [2, 7, 4, 1, 8, 1]\n    assert lastStoneWeightHeap(stones) == 1\n    assert lastStoneWeightKnapsack(stones) == 1\n</code></pre> 1046. Last Stone Weight - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;queue&gt;\n\nusing namespace std;\n\nint lastStoneWeight(vector&lt;int&gt; &amp;stones)\n{\n    priority_queue&lt;int&gt; maxHeap(stones.begin(), stones.end());\n\n    while (maxHeap.size() &gt;= 1)\n    {\n        int first = maxHeap.top();\n        maxHeap.pop();\n        int second = maxHeap.top();\n        maxHeap.pop();\n\n        if (first != second)\n        {\n            maxHeap.push(first - second);\n        }\n    }\n\n    return maxHeap.empty() ? 0 : maxHeap.top();\n}\n\nint main()\n{\n    vector&lt;int&gt; stones = {2, 7, 4, 1, 8, 1};\n    cout &lt;&lt; lastStoneWeight(stones) &lt;&lt; endl; // 1\n    return 0;\n}\n</code></pre>"},{"location":"content/endlesscheng/heap_basics/#3264-final-array-state-after-k-multiplication-operations-i","title":"3264. Final Array State After K Multiplication Operations I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, math, heap priority queue, simulation 3264. Final Array State After K Multiplication Operations I - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Brute Force\ndef getFinalStateBF(nums: List[int], k: int, multiplier: int) -&gt; List[int]:\n    for _ in range(k):\n        minNum = min(nums)\n        idx = nums.index(minNum)\n        nums[idx] *= multiplier\n\n    return nums\n\n\n# Heap\ndef getFinalStateHeap(nums: List[int], k: int, multiplier: int) -&gt; List[int]:\n    minHeap = []\n    for idx, num in enumerate(nums):\n        heapq.heappush(minHeap, (num, idx))\n\n    for _ in range(k):\n        num, idx = heapq.heappop(minHeap)\n        nums[idx] = num * multiplier\n        heapq.heappush(minHeap, (nums[idx], idx))\n\n    return nums\n\n\nk = 5\nmultiplier = 2\nprint(getFinalStateBF([2, 1, 3, 5, 6], k, multiplier))  # [8, 4, 6, 5, 6]\nprint(getFinalStateHeap([2, 1, 3, 5, 6], k, multiplier))  # [8, 4, 6, 5, 6]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/heap_basics/#2558-take-gifts-from-the-richest-pile","title":"2558. Take Gifts From the Richest Pile","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, heap priority queue, simulation 2558. Take Gifts From the Richest Pile - Python Solution<pre><code>from heapq import heapify, heappop, heappush\nfrom math import isqrt\nfrom typing import List\n\n\n# Heap\ndef pickGifts(gifts: List[int], k: int) -&gt; int:\n    maxHeap = [-g for g in gifts]\n    heapify(maxHeap)\n\n    for _ in range(k):\n        cur = heappop(maxHeap)\n\n        if cur == -1:\n            heappush(maxHeap, cur)\n            break\n\n        heappush(maxHeap, -isqrt(-cur))\n\n    return sum(-i for i in maxHeap)\n\n\nif __name__ == \"__main__\":\n    assert pickGifts([25, 64, 9, 4, 100], 4) == 29\n    assert pickGifts([1, 1, 1, 1], 4) == 0\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/heap_basics/#2336-smallest-number-in-infinite-set","title":"2336. Smallest Number in Infinite Set","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, design, heap priority queue, ordered set 2336. Smallest Number in Infinite Set - Python Solution<pre><code>from heapq import heappop, heappush\n\n\n# Heap\nclass SmallestInfiniteSet:\n    def __init__(self):\n        self.cur_min = 1\n        self.added = set()\n        self.min_heap = []\n\n    def popSmallest(self) -&gt; int:\n        if self.min_heap:\n            res = heappop(self.min_heap)\n            self.added.remove(res)\n            return res\n\n        res = self.cur_min\n        self.cur_min += 1\n        return res\n\n    def addBack(self, num: int) -&gt; None:\n        if num &lt; self.cur_min and num not in self.added:\n            self.added.add(num)\n            heappush(self.min_heap, num)\n\n\nif __name__ == \"__main__\":\n    sis = SmallestInfiniteSet()\n    assert sis.popSmallest() == 1\n    sis.addBack(2)\n    assert sis.popSmallest() == 2\n    assert sis.popSmallest() == 3\n    sis.addBack(1)\n    assert sis.popSmallest() == 1\n    assert sis.popSmallest() == 4\n    sis.addBack(3)\n    assert sis.popSmallest() == 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/heap_basics/#2530-maximal-score-after-applying-k-operations","title":"2530. Maximal Score After Applying K Operations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, heap priority queue 2530. Maximal Score After Applying K Operations - Python Solution<pre><code>from heapq import heapify, heappop, heappush\nfrom math import ceil\nfrom typing import List\n\n\n# Heap\ndef maxKelements(nums: List[int], k: int) -&gt; int:\n    res = 0\n    maxHeap = [-n for n in nums]\n    heapify(maxHeap)\n\n    while k &gt; 0:\n        cur = -heappop(maxHeap)\n        res += cur\n        heappush(maxHeap, -ceil(cur / 3))\n        k -= 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert maxKelements([10, 10, 10, 10, 10], 5) == 50\n    assert maxKelements([1, 10, 3, 3, 3], 3) == 17\n    assert maxKelements([1, 2, 3, 4, 5], 5) == 16\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/heap_basics/#3066-minimum-operations-to-exceed-threshold-value-ii","title":"3066. Minimum Operations to Exceed Threshold Value II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, heap priority queue, simulation 3066. Minimum Operations to Exceed Threshold Value II - Python Solution<pre><code>from heapq import heapify, heappop, heappush\nfrom typing import List\n\n\n# Heap\ndef minOperations(nums: List[int], k: int) -&gt; int:\n    heapify(nums)\n    res = 0\n\n    while nums[0] &lt; k:\n        x = heappop(nums)\n        y = heappop(nums)\n        heappush(nums, x * 2 + y)\n        res += 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert minOperations([2, 11, 10, 1, 3], 10) == 2\n    assert minOperations([1, 1, 2, 4, 9], 20) == 4\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/heap_basics/#1962-remove-stones-to-minimize-the-total","title":"1962. Remove Stones to Minimize the Total","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, heap priority queue 1962. Remove Stones to Minimize the Total - Python Solution<pre><code>from heapq import heapify, heapreplace\nfrom typing import List\n\n\n# Heap\ndef minStoneSum(piles: List[int], k: int) -&gt; int:\n    maxHeap = [-p for p in piles]\n    heapify(maxHeap)\n\n    for _ in range(k):\n        heapreplace(maxHeap, maxHeap[0] // 2)\n\n    return -sum(maxHeap)\n\n\nif __name__ == \"__main__\":\n    assert minStoneSum([5, 4, 9], 2) == 12\n    assert minStoneSum([4, 3, 6, 7], 3) == 12\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/heap_basics/#703-kth-largest-element-in-a-stream","title":"703. Kth Largest Element in a Stream","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, design, binary search tree, heap priority queue, binary tree, data stream 703. Kth Largest Element in a Stream - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Heap\nclass KthLargest:\n\n    def __init__(self, k: int, nums: List[int]):\n        self.k = k\n        self.heap = []\n        for num in nums:\n            self.add(num)\n\n    def add(self, val: int) -&gt; int:\n        heapq.heappush(self.heap, val)\n\n        if len(self.heap) &gt; self.k:\n            heapq.heappop(self.heap)\n\n        return self.heap[0]\n\n\nobj = KthLargest(3, [4, 5, 8, 2])\nprint(obj.add(3))  # 4\nprint(obj.add(5))  # 5\nprint(obj.add(10))  # 5\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/heap_basics/#3275-k-th-nearest-obstacle-queries","title":"3275. K-th Nearest Obstacle Queries","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, heap priority queue 3275. K-th Nearest Obstacle Queries - Python Solution<pre><code>from heapq import heappop, heappush\nfrom typing import List\n\n\n# Heap\ndef resultsArray(queries: List[List[int]], k: int) -&gt; List[int]:\n    n = len(queries)\n    res = [-1 for _ in range(n)]\n    maxHeap = []\n\n    for i in range(n):\n        dist = abs(queries[i][0]) + abs(queries[i][1])\n        heappush(maxHeap, -dist)\n\n        if i &lt; k - 1:\n            continue\n\n        while len(maxHeap) &gt; k:\n            heappop(maxHeap)\n\n        res[i] = -maxHeap[0]\n\n    return res\n\n\nif __name__ == \"__main__\":\n    queries = [[1, 2], [3, 4], [2, 3], [-3, 0]]\n    k = 2\n    assert resultsArray(queries, k) == [-1, 7, 5, 3]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/heap_basics/#2208-minimum-operations-to-halve-array-sum","title":"2208. Minimum Operations to Halve Array Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, heap priority queue 2208. Minimum Operations to Halve Array Sum - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\ndef halveArray(nums: List[int]) -&gt; int:\n    if not nums:\n        return 0\n\n    res = 0\n    cur_sum = sum(nums)\n    target = cur_sum / 2\n\n    max_heap = [-num for num in nums]  # max heap\n    heapq.heapify(max_heap)\n\n    while cur_sum &gt; target:\n        mx = -heapq.heappop(max_heap)\n        new = mx / 2\n        heapq.heappush(max_heap, -new)\n        cur_sum -= new\n        res += 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert halveArray([5, 19, 8, 1]) == 3\n    assert halveArray([3, 8, 20]) == 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/heap_basics/#2233-maximum-product-after-k-increments","title":"2233. Maximum Product After K Increments","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/heap_basics/#3296-minimum-number-of-seconds-to-make-mountain-height-zero","title":"3296. Minimum Number of Seconds to Make Mountain Height Zero","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, binary search, greedy, heap priority queue 3296. Minimum Number of Seconds to Make Mountain Height Zero - Python Solution<pre><code>from bisect import bisect_left\nfrom heapq import heapify, heapreplace\nfrom math import isqrt\nfrom typing import List\n\n\n# Min Heap\ndef minNumberOfSecondsMinHeap(\n    mountainHeight: int, workerTimes: List[int]\n) -&gt; int:\n    minHeap = [(t, t, t) for t in workerTimes]\n    heapify(minHeap)\n\n    for _ in range(mountainHeight):\n        nxt, delta, base = minHeap[0]\n        heapreplace(\n            minHeap,\n            (\n                nxt + delta + base,\n                delta + base,\n                base,\n            ),\n        )\n    return nxt\n\n\n# Binary Search Min Answer\ndef minNumberOfSecondsBinarySearchMin(\n    mountainHeight: int, workerTimes: List[int]\n) -&gt; int:\n    def check(m: int) -&gt; bool:\n        left_h = mountainHeight\n        for t in workerTimes:\n            left_h -= (isqrt(m // t * 8 + 1) - 1) // 2\n            if left_h &lt;= 0:\n                return True\n        return False\n\n    max_t = max(workerTimes)\n    h = (mountainHeight - 1) // len(workerTimes) + 1\n    return bisect_left(range(max_t * h * (h + 1) // 2), True, 1, key=check)\n\n\nif __name__ == \"__main__\":\n    mountainHeight = 4\n    workerTimes = [2, 1, 1]\n    assert minNumberOfSecondsMinHeap(mountainHeight, workerTimes) == 3\n    assert minNumberOfSecondsBinarySearchMin(mountainHeight, workerTimes) == 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/heap_basics/#1942-the-number-of-the-smallest-unoccupied-chair","title":"1942. The Number of the Smallest Unoccupied Chair","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/heap_basics/#1801-number-of-orders-in-the-backlog","title":"1801. Number of Orders in the Backlog","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, heap priority queue, simulation</p> </li> </ul>"},{"location":"content/endlesscheng/heap_basics/#2406-divide-intervals-into-minimum-number-of-groups","title":"2406. Divide Intervals Into Minimum Number of Groups","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy, sorting, heap priority queue, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/heap_basics/#2462-total-cost-to-hire-k-workers","title":"2462. Total Cost to Hire K Workers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, heap priority queue, simulation</p> </li> </ul>"},{"location":"content/endlesscheng/heap_basics/#1834-single-threaded-cpu","title":"1834. Single-Threaded CPU","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sorting, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/heap_basics/#3408-design-task-manager","title":"3408. Design Task Manager","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, design, heap priority queue, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/heap_basics/#1792-maximum-average-pass-ratio","title":"1792. Maximum Average Pass Ratio","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/heap_basics/#2931-maximum-spending-after-buying-items","title":"2931. Maximum Spending After Buying Items","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sorting, heap priority queue, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/heap_basics/#1882-process-tasks-using-servers","title":"1882. Process Tasks Using Servers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/heap_basics/#2402-meeting-rooms-iii","title":"2402. Meeting Rooms III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, sorting, heap priority queue, simulation</p> </li> </ul>"},{"location":"content/endlesscheng/heap_basics/#253-meeting-rooms-ii","title":"253. Meeting Rooms II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy, sorting, heap priority queue, prefix sum</p> </li> <li>Given an array of meeting time <code>intervals</code> where <code>intervals[i] = [start_i, end_i]</code>, return the minimum number of conference rooms required.</li> </ul> 253. Meeting Rooms II - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Heap\ndef minMeetingRooms(intervals: List[List[int]]) -&gt; int:\n    if not intervals:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n    minHeap = [intervals[0][1]]\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &gt;= minHeap[0]:\n            heapq.heappop(minHeap)\n        heapq.heappush(minHeap, intervals[i][1])\n\n    return len(minHeap)\n\n\nif __name__ == \"__main__\":\n    intervals = [[0, 30], [5, 10], [15, 20]]\n    assert minMeetingRooms(intervals) == 2\n</code></pre>"},{"location":"content/endlesscheng/heap_basics/#1167-minimum-cost-to-connect-sticks","title":"1167. Minimum Cost to Connect Sticks","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, heap priority queue 1167. Minimum Cost to Connect Sticks - Python Solution<pre><code>from heapq import heapify, heappop, heappush\nfrom typing import List\n\n\n# Heap\ndef connectSticks(sticks: List[int]) -&gt; int:\n    n = len(sticks)\n    heapify(sticks)\n    res = 0\n\n    while n &gt; 1:\n        x = heappop(sticks)\n        y = heappop(sticks)\n        res += x + y\n        heappush(sticks, x + y)\n        n -= 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert connectSticks([2, 4, 3]) == 14\n    assert connectSticks([1, 8, 3, 5]) == 30\n    assert connectSticks([5]) == 0\n    assert connectSticks([1, 2, 3, 4, 5]) == 33\n    assert connectSticks([1, 1, 1]) == 5\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/heap_kth_smallest_largest/","title":"Heap Kth Smallest Largest","text":""},{"location":"content/endlesscheng/heap_kth_smallest_largest/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 264. Ugly Number II (Medium)</li> <li> 378. Kth Smallest Element in a Sorted Matrix (Medium)</li> <li> 373. Find K Pairs with Smallest Sums (Medium)</li> <li> 1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows (Hard)</li> <li> 786. K-th Smallest Prime Fraction (Medium)</li> <li> 2386. Find the K-Sum of an Array (Hard)</li> </ul>"},{"location":"content/endlesscheng/heap_kth_smallest_largest/#264-ugly-number-ii","title":"264. Ugly Number II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, math, dynamic programming, heap priority queue 264. Ugly Number II - Python Solution<pre><code>import heapq\n\n\ndef nthUglyNumber(n: int) -&gt; int:\n    heap = [1]\n    seen = set(heap)\n\n    factors = [2, 3, 5]\n    current = 1\n\n    # Pop the smallest ugly number n times\n    for _ in range(n):\n        current = heapq.heappop(heap)  # Pop the smallest ugly number\n\n        for factor in factors:\n            new = current * factor\n            if new not in seen:\n                seen.add(new)\n                heapq.heappush(heap, new)\n\n    return current\n\n\nprint(nthUglyNumber(10))  # 12\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/heap_kth_smallest_largest/#378-kth-smallest-element-in-a-sorted-matrix","title":"378. Kth Smallest Element in a Sorted Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sorting, heap priority queue, matrix</p> </li> <li>Given an <code>n x n</code> matrix where each of the rows and columns are sorted in ascending order, return the <code>k-th</code> smallest element in the matrix.</li> </ul> 378. Kth Smallest Element in a Sorted Matrix - Python Solution<pre><code>from heapq import heapify, heappop, heappush\nfrom typing import List\n\n\n# Heap - Merge K Sorted\ndef kthSmallestHeap(matrix: List[List[int]], k: int) -&gt; int:\n    n = len(matrix)\n    heap = [(matrix[i][0], i, 0) for i in range(n)]\n    heapify(heap)\n\n    for _ in range(k - 1):\n        _, row, col = heappop(heap)\n\n        if col + 1 &lt; n:\n            heappush(heap, (matrix[row][col + 1], row, col + 1))\n\n    return heappop(heap)[0]\n\n\n# Binary Search\ndef kthSmallestBinarySearch(matrix: List[List[int]], k: int) -&gt; int:\n    n = len(matrix)\n\n    def check(mid):\n        i, j = n - 1, 0\n        num = 0\n\n        while i &gt;= 0 and j &lt; n:\n            if matrix[i][j] &lt;= mid:\n                num += i + 1\n                j += 1\n            else:\n                i -= 1\n\n        return num &gt;= k\n\n    left, right = matrix[0][0], matrix[-1][-1]\n\n    while left &lt; right:\n        mid = (left + right) // 2\n        if check(mid):\n            right = mid\n        else:\n            left = mid + 1\n\n    return left\n\n\nmatrix = [[1, 5, 9], [10, 11, 13], [12, 13, 15]]\nk = 8\n\nprint(kthSmallestHeap(matrix, k))  # 13\nprint(kthSmallestBinarySearch(matrix, k))  # 13\n</code></pre>"},{"location":"content/endlesscheng/heap_kth_smallest_largest/#373-find-k-pairs-with-smallest-sums","title":"373. Find K Pairs with Smallest Sums","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, heap priority queue 373. Find K Pairs with Smallest Sums - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Heap - Merge K Sorted\ndef kSmallestPairs(\n    nums1: List[int], nums2: List[int], k: int\n) -&gt; List[List[int]]:\n    if not nums1 or not nums2 or k &lt;= 0:\n        return []\n\n    res = []\n    min_heap = []\n\n    for j in range(min(k, len(nums2))):\n        heapq.heappush(min_heap, (nums1[0] + nums2[j], 0, j))\n\n    while k &gt; 0 and min_heap:\n        _, i, j = heapq.heappop(min_heap)\n        res.append([nums1[i], nums2[j]])\n        k -= 1\n\n        if i + 1 &lt; len(nums1):\n            heapq.heappush(min_heap, (nums1[i + 1] + nums2[j], i + 1, j))\n\n    return res\n\n\nif __name__ == \"__main__\":\n    nums1 = [1, 2, 4, 5, 6]\n    nums2 = [3, 5, 7, 9]\n    k = 3\n    assert kSmallestPairs(nums1, nums2, k) == [[1, 3], [2, 3], [1, 5]]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/heap_kth_smallest_largest/#1439-find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows","title":"1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, heap priority queue, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/heap_kth_smallest_largest/#786-k-th-smallest-prime-fraction","title":"786. K-th Smallest Prime Fraction","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, sorting, heap priority queue 786. K-th Smallest Prime Fraction - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\ndef kthSmallestPrimeFraction(arr: List[int], k: int) -&gt; List[int]:\n    max_heap = []\n\n    for j in range(1, len(arr)):\n        for i in range(j):\n            heapq.heappush(max_heap, (-arr[i] / arr[j], arr[i], arr[j]))\n\n            if len(max_heap) &gt; k:\n                heapq.heappop(max_heap)\n\n    return [max_heap[0][1], max_heap[0][2]]\n\n\narr = [1, 2, 3, 5]\nk = 3\nprint(kthSmallestPrimeFraction(arr, k))  # [2, 5]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/heap_kth_smallest_largest/#2386-find-the-k-sum-of-an-array","title":"2386. Find the K-Sum of an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, sorting, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/heap_rearrange_elements/","title":"Heap Rearrange Elements","text":""},{"location":"content/endlesscheng/heap_rearrange_elements/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 984. String Without AAA or BBB (Medium)</li> <li> 767. Reorganize String (Medium)</li> <li> 1054. Distant Barcodes (Medium)</li> <li> 1953. Maximum Number of Weeks for Which You Can Work (Medium)</li> <li> 1405. Longest Happy String (Medium)</li> <li> 3081. Replace Question Marks in String to Minimize Its Value (Medium)</li> <li> 621. Task Scheduler (Medium)</li> <li> 358. Rearrange String k Distance Apart (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/heap_rearrange_elements/#984-string-without-aaa-or-bbb","title":"984. String Without AAA or BBB","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/heap_rearrange_elements/#767-reorganize-string","title":"767. Reorganize String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, greedy, sorting, heap priority queue, counting 767. Reorganize String - Python Solution<pre><code>import heapq\nfrom collections import Counter\n\n\ndef reorganizeString(s: str) -&gt; str:\n    if not s:\n        return \"\"\n\n    heap = [(-freq, char) for char, freq in Counter(s).items()]  # max heap\n    heapq.heapify(heap)\n\n    result = []\n    prev_count, prev_char = 0, \"\"\n\n    while heap:\n        count, char = heapq.heappop(heap)  # pop the most frequent character\n        result.append(char)  # append the character to the result\n\n        if (\n            prev_count &lt; 0\n        ):  # if the previous character still has remaining count\n            heapq.heappush(heap, (prev_count, prev_char))\n\n        prev_count = (\n            count + 1\n        )  # update the current character's remaining count\n        prev_char = char  # update the current character\n\n    # check if there is any invalid result\n    if len(result) != len(s):\n        return \"\"\n\n    return \"\".join(result)\n\n\nprint(reorganizeString(\"aab\"))\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/heap_rearrange_elements/#1054-distant-barcodes","title":"1054. Distant Barcodes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, greedy, sorting, heap priority queue, counting</p> </li> </ul>"},{"location":"content/endlesscheng/heap_rearrange_elements/#1953-maximum-number-of-weeks-for-which-you-can-work","title":"1953. Maximum Number of Weeks for Which You Can Work","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/heap_rearrange_elements/#1405-longest-happy-string","title":"1405. Longest Happy String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, greedy, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/heap_rearrange_elements/#3081-replace-question-marks-in-string-to-minimize-its-value","title":"3081. Replace Question Marks in String to Minimize Its Value","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, greedy, sorting, heap priority queue, counting</p> </li> </ul>"},{"location":"content/endlesscheng/heap_rearrange_elements/#621-task-scheduler","title":"621. Task Scheduler","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, greedy, sorting, heap priority queue, counting 621. Task Scheduler - Python Solution<pre><code>import heapq\nfrom collections import Counter, deque\nfrom typing import List\n\n\n# Heap\ndef leastInterval1(tasks: List[str], n: int) -&gt; int:\n    count = Counter(tasks)\n    heap = [-c for c in count.values()]\n    heapq.heapify(heap)\n\n    time = 0\n\n    q = deque()\n\n    while heap or q:\n        time += 1\n\n        if heap:\n            cnt = 1 + heapq.heappop(heap)\n            if cnt:\n                q.append((cnt, time + n))\n\n        if q and q[0][1] == time:\n            heapq.heappush(heap, q.popleft()[0])\n\n    return time\n\n\ndef leastInterval2(tasks: List[str], n: int) -&gt; int:\n    freq = Counter(tasks)\n\n    maxExec = max(freq.values())\n    maxCount = sum(1 for v in freq.values() if v == maxExec)\n\n    return max((maxExec - 1) * (n + 1) + maxCount, len(tasks))\n\n\ntasks = [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\"]\nn = 2\nprint(leastInterval1(tasks, n))  # 8\nprint(leastInterval2(tasks, n))  # 8\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/heap_rearrange_elements/#358-rearrange-string-k-distance-apart","title":"358. Rearrange String k Distance Apart","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, greedy, sorting, heap priority queue, counting</p> </li> </ul>"},{"location":"content/endlesscheng/inclusion_exclusion_principle/","title":"Inclusion Exclusion Principle","text":""},{"location":"content/endlesscheng/inclusion_exclusion_principle/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2652. Sum Multiples (Easy)</li> <li> 878. Nth Magical Number (Hard)</li> <li> 1201. Ugly Number III (Medium)</li> <li> 2928. Distribute Candies Among Children I (Easy)</li> <li> 2929. Distribute Candies Among Children II (Medium)</li> <li> 2930. Number of Strings Which Can Be Rearranged to Contain Substring (Medium)</li> <li> 2513. Minimize the Maximum of Two Arrays (Medium)</li> <li> 3116. Kth Smallest Amount With Single Denomination Combination (Hard)</li> <li> 3130. Find All Possible Stable Binary Arrays II (Hard)</li> <li> 3336. Find the Number of Subsequences With Equal GCD (Hard)</li> <li> 2927. Distribute Candies Among Children III (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/inclusion_exclusion_principle/#2652-sum-multiples","title":"2652. Sum Multiples","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math</p> </li> </ul>"},{"location":"content/endlesscheng/inclusion_exclusion_principle/#878-nth-magical-number","title":"878. Nth Magical Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, binary search</p> </li> </ul>"},{"location":"content/endlesscheng/inclusion_exclusion_principle/#1201-ugly-number-iii","title":"1201. Ugly Number III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, binary search, combinatorics, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/inclusion_exclusion_principle/#2928-distribute-candies-among-children-i","title":"2928. Distribute Candies Among Children I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, combinatorics, enumeration 2928. Distribute Candies Among Children I - Python Solution<pre><code>def distributeCandies(n: int, limit: int) -&gt; int:\n    def c2(n: int) -&gt; int:\n        return n * (n - 1) // 2 if n &gt; 1 else 0\n\n    return (\n        c2(n + 2)\n        - 3 * c2(n - limit + 1)\n        + 3 * c2(n - 2 * limit)\n        - c2(n - 3 * limit - 1)\n    )\n\n\nif __name__ == \"__main__\":\n    assert distributeCandies(5, 2) == 3\n    assert distributeCandies(3, 3) == 10\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/inclusion_exclusion_principle/#2929-distribute-candies-among-children-ii","title":"2929. Distribute Candies Among Children II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, combinatorics, enumeration 2929. Distribute Candies Among Children II - Python Solution<pre><code>def distributeCandies(n: int, limit: int) -&gt; int:\n    def c2(n: int) -&gt; int:\n        return n * (n - 1) // 2 if n &gt; 1 else 0\n\n    return (\n        c2(n + 2)\n        - 3 * c2(n - limit + 1)\n        + 3 * c2(n - 2 * limit)\n        - c2(n - 3 * limit - 1)\n    )\n\n\nif __name__ == \"__main__\":\n    assert distributeCandies(5, 2) == 3\n    assert distributeCandies(3, 3) == 10\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/inclusion_exclusion_principle/#2930-number-of-strings-which-can-be-rearranged-to-contain-substring","title":"2930. Number of Strings Which Can Be Rearranged to Contain Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, combinatorics</p> </li> </ul>"},{"location":"content/endlesscheng/inclusion_exclusion_principle/#2513-minimize-the-maximum-of-two-arrays","title":"2513. Minimize the Maximum of Two Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, binary search, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/inclusion_exclusion_principle/#3116-kth-smallest-amount-with-single-denomination-combination","title":"3116. Kth Smallest Amount With Single Denomination Combination","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, binary search, bit manipulation, combinatorics, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/inclusion_exclusion_principle/#3130-find-all-possible-stable-binary-arrays-ii","title":"3130. Find All Possible Stable Binary Arrays II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/inclusion_exclusion_principle/#3336-find-the-number-of-subsequences-with-equal-gcd","title":"3336. Find the Number of Subsequences With Equal GCD","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, dynamic programming, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/inclusion_exclusion_principle/#2927-distribute-candies-among-children-iii","title":"2927. Distribute Candies Among Children III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, combinatorics 2927. Distribute Candies Among Children III - Python Solution<pre><code>def distributeCandies(n: int, limit: int) -&gt; int:\n    def c2(n: int) -&gt; int:\n        return n * (n - 1) // 2 if n &gt; 1 else 0\n\n    return (\n        c2(n + 2)\n        - 3 * c2(n - limit + 1)\n        + 3 * c2(n - 2 * limit)\n        - c2(n - 3 * limit - 1)\n    )\n\n\nif __name__ == \"__main__\":\n    assert distributeCandies(5, 2) == 3\n    assert distributeCandies(3, 3) == 10\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/inductive_method/","title":"Inductive Method","text":""},{"location":"content/endlesscheng/inductive_method/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2952. Minimum Number of Coins to be Added (Medium)</li> <li> 330. Patching Array (Hard)</li> <li> 1798. Maximum Number of Consecutive Values You Can Make (Medium)</li> </ul>"},{"location":"content/endlesscheng/inductive_method/#2952-minimum-number-of-coins-to-be-added","title":"2952. Minimum Number of Coins to be Added","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/inductive_method/#330-patching-array","title":"330. Patching Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/inductive_method/#1798-maximum-number-of-consecutive-values-you-can-make","title":"1798. Maximum Number of Consecutive Values You Can Make","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/integer_partition/","title":"Integer Partition","text":""},{"location":"content/endlesscheng/integer_partition/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 343. Integer Break (Medium)</li> <li> 1808. Maximize Number of Nice Divisors (Hard)</li> </ul>"},{"location":"content/endlesscheng/integer_partition/#343-integer-break","title":"343. Integer Break","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming</p> </li> <li>Return the maximum product of the integer after breaking it into at least two positive integers.</li> <li><code>dp[i]</code> stores the maximum product of the integer <code>i</code>.</li> <li>Formula: <code>dp[i] = max(dp[i - j] * j, (i - j) * j)</code></li> <li>Time Complexity: O(n^2)</li> <li>Space Complexity: O(n)</li> </ul> dp 3 4 5 6 7 8 2 2*1=2 2*2=4 2*3=6 2*4=8 2*5=10 2*6=12 dp[2]=1 1*1=1 1*2=2 1*3=3 1*4=4 1*5=5 1*6=6 3 3*1=3 3*2=6 3*3=9 3*4=12 3*5=15 dp[3]=2 2*1=2 2*2=4 2*3=6 2*4=8 2*5=10 4 4*1=4 4*2=8 4*3=12 4*4=16 dp[4]=4 4*1=4 4*2=8 4*3=12 4*4=16 5 5*1=5 5*2=10 5*3=15 dp[5]=6 6*1=6 6*2=12 6*3=18 6 6*1=6 6*2=12 dp[6]=9 9*1=9 9*2=18 7 7*1=7 dp[7]=12 12*1=12 <code>dp[n]</code> 2 4 6 9 12 18 343. Integer Break - Python Solution<pre><code>def integerBreak(n: int) -&gt; int:\n    dp = [0 for _ in range(n + 1)]\n    dp[2] = 1\n\n    for i in range(3, n + 1):\n        for j in range(2, i):\n            dp[i] = max(dp[i], dp[i - j] * j, (i - j) * j)\n\n    return dp[n]\n\n\nif __name__ == \"__main__\":\n    print(integerBreak(8))  # 18\n</code></pre>"},{"location":"content/endlesscheng/integer_partition/#1808-maximize-number-of-nice-divisors","title":"1808. Maximize Number of Nice Divisors","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, recursion, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/interval_coverage/","title":"Interval Coverage","text":""},{"location":"content/endlesscheng/interval_coverage/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 45. Jump Game II (Medium)</li> <li> 1024. Video Stitching (Medium)</li> <li> 1326. Minimum Number of Taps to Open to Water a Garden (Hard)</li> </ul>"},{"location":"content/endlesscheng/interval_coverage/#45-jump-game-ii","title":"45. Jump Game II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> <li>Return the minimum number of jumps to reach the last index.</li> </ul> 45. Jump Game II - Python Solution<pre><code>from typing import List\n\n\n# Greedy - Interval\ndef jump(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n == 1:\n        return 0\n\n    reach = 0\n    left, right = 0, 0\n    res = 0\n\n    while right &lt; n - 1:\n        for i in range(left, right + 1):\n            reach = max(reach, i + nums[i])\n\n        left = right + 1\n        right = reach\n        res += 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert jump([2, 3, 1, 1, 4]) == 2\n    assert jump([2, 3, 0, 1, 4]) == 2\n</code></pre>"},{"location":"content/endlesscheng/interval_coverage/#1024-video-stitching","title":"1024. Video Stitching","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/interval_coverage/#1326-minimum-number-of-taps-to-open-to-water-a-garden","title":"1326. Minimum Number of Taps to Open to Water a Garden","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/interval_grouping/","title":"Interval Grouping","text":""},{"location":"content/endlesscheng/interval_grouping/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2406. Divide Intervals Into Minimum Number of Groups (Medium)</li> <li> 253. Meeting Rooms II (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/interval_grouping/#2406-divide-intervals-into-minimum-number-of-groups","title":"2406. Divide Intervals Into Minimum Number of Groups","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy, sorting, heap priority queue, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/interval_grouping/#253-meeting-rooms-ii","title":"253. Meeting Rooms II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy, sorting, heap priority queue, prefix sum</p> </li> <li>Given an array of meeting time <code>intervals</code> where <code>intervals[i] = [start_i, end_i]</code>, return the minimum number of conference rooms required.</li> </ul> 253. Meeting Rooms II - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Heap\ndef minMeetingRooms(intervals: List[List[int]]) -&gt; int:\n    if not intervals:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n    minHeap = [intervals[0][1]]\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &gt;= minHeap[0]:\n            heapq.heappop(minHeap)\n        heapq.heappush(minHeap, intervals[i][1])\n\n    return len(minHeap)\n\n\nif __name__ == \"__main__\":\n    intervals = [[0, 30], [5, 10], [15, 20]]\n    assert minMeetingRooms(intervals) == 2\n</code></pre>"},{"location":"content/endlesscheng/interval_selection/","title":"Interval Selection","text":""},{"location":"content/endlesscheng/interval_selection/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 452. Minimum Number of Arrows to Burst Balloons (Medium)</li> <li> 757. Set Intersection Size At Least Two (Hard)</li> </ul>"},{"location":"content/endlesscheng/interval_selection/#452-minimum-number-of-arrows-to-burst-balloons","title":"452. Minimum Number of Arrows to Burst Balloons","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> <li>Return the minimum number of arrows.</li> </ul> <ul> <li>Differece between two versions<ol> <li>Start from 1: if there is no overlap, we add one more arrow.</li> <li>Start from the number of balloons: if there is overlap, we need to reduce one arrow.</li> </ol> </li> </ul> 452. Minimum Number of Arrows to Burst Balloons - Python Solution<pre><code>from typing import List\n\nimport matplotlib.pyplot as plt\n\n\n# Greedy - Interval\ndef findMinArrowShotsGreedy1(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    if n &lt;= 1:\n        return n\n\n    res = 1\n    points.sort(key=lambda x: x[0])\n\n    for i in range(1, n):\n        if points[i][0] &gt; points[i - 1][1]:\n            res += 1\n        else:\n            points[i][1] = min(points[i][1], points[i - 1][1])\n    return res\n\n\n# Greedy - Interval (Neetcode's version)\ndef findMinArrowShotsGreedy2(points: List[List[int]]) -&gt; int:\n    res = len(points)\n    if res == 0:\n        return 0\n\n    points.sort()\n    prev = points[0]\n\n    for i in range(1, len(points)):\n        cur = points[i]\n        if cur[0] &lt;= prev[1]:\n            res -= 1\n            prev = [cur[0], min(prev[1], cur[1])]\n        else:\n            prev = cur\n\n    return res\n\n\n# Greedy - Interval\ndef findMinArrowShotsGreedy3(points: List[List[int]]) -&gt; int:\n    if not points:\n        return 0\n\n    points.sort(key=lambda x: x[1])\n\n    res = 1\n    cur_end = points[0][1]\n\n    for i in range(1, len(points)):\n        if points[i][0] &gt; cur_end:\n            res += 1\n            cur_end = points[i][1]\n\n    return res\n\n\n# Utility\ndef plot(points, i=None):\n    plt.figure(figsize=(8, 4))\n    for idx in range(len(points)):\n        color = \"b\" if idx == i else \"k\"\n        plt.plot(\n            [points[idx][0], points[idx][1]],\n            [idx + 1, idx + 1],\n            f\"{color}o-\",\n            label=f\"Line {idx + 1}\",\n        )\n\n    plt.title(\"Find Min Arrow Shots\")\n    plt.xlabel(\"X-axis\")\n    plt.xlim(0, 17)\n    plt.grid(True)\n    plt.savefig(f\"find_min_arrow_shots_{i}.png\")\n    plt.show()\n\n\n# |------------|-----------|---------|\n# |  Approach  |  Time     |  Space  |\n# |------------|-----------|---------|\n# |  Greedy    |  O(NlogN) |  O(1)   |\n# |------------|-----------|---------|\n\n\npoints = [[10, 16], [2, 8], [1, 6], [7, 12]]\nprint(findMinArrowShotsGreedy1(points))  # 2\nprint(findMinArrowShotsGreedy2(points))  # 2\n</code></pre>"},{"location":"content/endlesscheng/interval_selection/#757-set-intersection-size-at-least-two","title":"757. Set Intersection Size At Least Two","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/inversion_count/","title":"Inversion Count","text":""},{"location":"content/endlesscheng/inversion_count/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 315. Count of Smaller Numbers After Self (Hard)</li> <li> 493. Reverse Pairs (Hard)</li> <li> 327. Count of Range Sum (Hard)</li> <li> 2426. Number of Pairs Satisfying Inequality (Hard)</li> <li> 1850. Minimum Adjacent Swaps to Reach the Kth Smallest Number (Medium)</li> <li> 2193. Minimum Number of Moves to Make Palindrome (Hard)</li> <li> 1885. Count Pairs in Two Arrays (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/inversion_count/#315-count-of-smaller-numbers-after-self","title":"315. Count of Smaller Numbers After Self","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, divide and conquer, binary indexed tree, segment tree, merge sort, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/inversion_count/#493-reverse-pairs","title":"493. Reverse Pairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, divide and conquer, binary indexed tree, segment tree, merge sort, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/inversion_count/#327-count-of-range-sum","title":"327. Count of Range Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, divide and conquer, binary indexed tree, segment tree, merge sort, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/inversion_count/#2426-number-of-pairs-satisfying-inequality","title":"2426. Number of Pairs Satisfying Inequality","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, divide and conquer, binary indexed tree, segment tree, merge sort, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/inversion_count/#1850-minimum-adjacent-swaps-to-reach-the-kth-smallest-number","title":"1850. Minimum Adjacent Swaps to Reach the Kth Smallest Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/inversion_count/#2193-minimum-number-of-moves-to-make-palindrome","title":"2193. Minimum Number of Moves to Make Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: two pointers, string, greedy, binary indexed tree</p> </li> </ul>"},{"location":"content/endlesscheng/inversion_count/#1885-count-pairs-in-two-arrays","title":"1885. Count Pairs in Two Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/lazy_deletion_heap/","title":"Lazy Deletion Heap","text":""},{"location":"content/endlesscheng/lazy_deletion_heap/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2349. Design a Number Container System (Medium)</li> <li> 2353. Design a Food Rating System (Medium)</li> <li> 3092. Most Frequent IDs (Medium)</li> <li> 2034. Stock Price Fluctuation  (Medium)</li> <li> 1172. Dinner Plate Stacks (Hard)</li> </ul>"},{"location":"content/endlesscheng/lazy_deletion_heap/#2349-design-a-number-container-system","title":"2349. Design a Number Container System","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, design, heap priority queue, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/lazy_deletion_heap/#2353-design-a-food-rating-system","title":"2353. Design a Food Rating System","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, design, heap priority queue, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/lazy_deletion_heap/#3092-most-frequent-ids","title":"3092. Most Frequent IDs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, heap priority queue, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/lazy_deletion_heap/#2034-stock-price-fluctuation","title":"2034. Stock Price Fluctuation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, design, heap priority queue, data stream, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/lazy_deletion_heap/#1172-dinner-plate-stacks","title":"1172. Dinner Plate Stacks","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, stack, design, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/lazy_segment_tree/","title":"Lazy Segment Tree","text":""},{"location":"content/endlesscheng/lazy_segment_tree/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2589. Minimum Time to Complete All Tasks (Hard)</li> <li> 2569. Handling Sum Queries After Update (Hard)</li> <li> 1622. Fancy Sequence (Hard)</li> <li> 850. Rectangle Area II (Hard)</li> <li> 3454. Separate Squares II (Hard)</li> <li> 2916. Subarrays Distinct Element Sum of Squares II (Hard)</li> </ul>"},{"location":"content/endlesscheng/lazy_segment_tree/#2589-minimum-time-to-complete-all-tasks","title":"2589. Minimum Time to Complete All Tasks","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, stack, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/lazy_segment_tree/#2569-handling-sum-queries-after-update","title":"2569. Handling Sum Queries After Update","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, segment tree</p> </li> </ul>"},{"location":"content/endlesscheng/lazy_segment_tree/#1622-fancy-sequence","title":"1622. Fancy Sequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, design, segment tree</p> </li> </ul>"},{"location":"content/endlesscheng/lazy_segment_tree/#850-rectangle-area-ii","title":"850. Rectangle Area II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, segment tree, line sweep, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/lazy_segment_tree/#3454-separate-squares-ii","title":"3454. Separate Squares II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, segment tree, line sweep</p> </li> </ul>"},{"location":"content/endlesscheng/lazy_segment_tree/#2916-subarrays-distinct-element-sum-of-squares-ii","title":"2916. Subarrays Distinct Element Sum of Squares II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, binary indexed tree, segment tree</p> </li> </ul>"},{"location":"content/endlesscheng/least_common_multiple/","title":"Least Common Multiple","text":""},{"location":"content/endlesscheng/least_common_multiple/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2413. Smallest Even Multiple (Easy)</li> <li> 3334. Find the Maximum Factor Score of Array (Medium)</li> <li> 2197. Replace Non-Coprime Numbers in Array (Hard)</li> <li> 2470. Number of Subarrays With LCM Equal to K (Medium)</li> </ul>"},{"location":"content/endlesscheng/least_common_multiple/#2413-smallest-even-multiple","title":"2413. Smallest Even Multiple","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/least_common_multiple/#3334-find-the-maximum-factor-score-of-array","title":"3334. Find the Maximum Factor Score of Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/least_common_multiple/#2197-replace-non-coprime-numbers-in-array","title":"2197. Replace Non-Coprime Numbers in Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, stack, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/least_common_multiple/#2470-number-of-subarrays-with-lcm-equal-to-k","title":"2470. Number of Subarrays With LCM Equal to K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/lexicographically_smallest/","title":"Lexicographically Smallest","text":""},{"location":"content/endlesscheng/lexicographically_smallest/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 402. Remove K Digits (Medium)</li> <li> 1673. Find the Most Competitive Subsequence (Medium)</li> <li> 316. Remove Duplicate Letters (Medium)</li> <li> 1081. Smallest Subsequence of Distinct Characters (Medium)</li> <li> 321. Create Maximum Number (Hard)</li> <li> 2030. Smallest K-Length Subsequence With Occurrences of a Letter (Hard)</li> </ul>"},{"location":"content/endlesscheng/lexicographically_smallest/#402-remove-k-digits","title":"402. Remove K Digits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack, greedy, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/lexicographically_smallest/#1673-find-the-most-competitive-subsequence","title":"1673. Find the Most Competitive Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, greedy, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/lexicographically_smallest/#316-remove-duplicate-letters","title":"316. Remove Duplicate Letters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack, greedy, monotonic stack 316. Remove Duplicate Letters - Python Solution<pre><code># Monotonic Stack\ndef removeDuplicateLetters(s: str) -&gt; str:\n    stack = []\n    seen = set()\n    last = {c: i for i, c in enumerate(s)}\n\n    for i, c in enumerate(s):\n        if c not in seen:\n            while stack and c &lt; stack[-1] and i &lt; last[stack[-1]]:\n                seen.discard(stack.pop())\n            seen.add(c)\n            stack.append(c)\n\n    return \"\".join(stack)\n\n\ns = \"cbacdcbc\"\nprint(removeDuplicateLetters(s))  # acdb\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/lexicographically_smallest/#1081-smallest-subsequence-of-distinct-characters","title":"1081. Smallest Subsequence of Distinct Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack, greedy, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/lexicographically_smallest/#321-create-maximum-number","title":"321. Create Maximum Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, stack, greedy, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/lexicographically_smallest/#2030-smallest-k-length-subsequence-with-occurrences-of-a-letter","title":"2030. Smallest K-Length Subsequence With Occurrences of a Letter","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, stack, greedy, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/lexicographically_smallest_largest/","title":"Lexicographically Smallest Largest","text":""},{"location":"content/endlesscheng/lexicographically_smallest_largest/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1323. Maximum 69 Number (Easy)</li> <li> 3216. Lexicographically Smallest String After a Swap (Easy)</li> <li> 2697. Lexicographically Smallest Palindrome (Easy)</li> <li> 1881. Maximum Value after Insertion (Medium)</li> <li> 2734. Lexicographically Smallest String After Substring Operation (Medium)</li> <li> 1946. Largest Number After Mutating Substring (Medium)</li> <li> 1663. Smallest String With A Given Numeric Value (Medium)</li> <li> 1328. Break a Palindrome (Medium)</li> <li> 2259. Remove Digit From Number to Maximize Result (Easy)</li> <li> 2566. Maximum Difference by Remapping a Digit (Easy)</li> <li> 670. Maximum Swap (Medium)</li> <li> 3106. Lexicographically Smallest String After Operations With Constraint (Medium)</li> <li> 1053. Previous Permutation With One Swap (Medium)</li> <li> 2375. Construct Smallest Number From DI String (Medium)</li> <li> 2182. Construct String With Repeat Limit (Medium)</li> <li> 738. Monotone Increasing Digits (Medium)</li> <li> 3403. Find the Lexicographically Largest String From the Box I (Medium)</li> <li> 3170. Lexicographically Minimum String After Removing Stars (Medium)</li> <li> 1363. Largest Multiple of Three (Hard)</li> <li> 1754. Largest Merge Of Two Strings (Medium)</li> <li> 1202. Smallest String With Swaps (Medium)</li> <li> 2434. Using a Robot to Print the Lexicographically Smallest String (Medium)</li> <li> 1625. Lexicographically Smallest String After Applying Operations (Medium)</li> <li> 2948. Make Lexicographically Smallest Array by Swapping Elements (Medium)</li> <li> 564. Find the Closest Palindrome (Hard)</li> <li> 1505. Minimum Possible Integer After at Most K Adjacent Swaps On Digits (Hard)</li> <li> 2663. Lexicographically Smallest Beautiful String (Hard)</li> <li> 3302. Find the Lexicographically Smallest Valid Sequence (Medium)</li> <li> 555. Split Concatenated Strings (Medium) \ud83d\udc51</li> <li> 3088. Make String Anti-palindrome (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/lexicographically_smallest_largest/#1323-maximum-69-number","title":"1323. Maximum 69 Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/lexicographically_smallest_largest/#3216-lexicographically-smallest-string-after-a-swap","title":"3216. Lexicographically Smallest String After a Swap","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/lexicographically_smallest_largest/#2697-lexicographically-smallest-palindrome","title":"2697. Lexicographically Smallest Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string, greedy 2697. Lexicographically Smallest Palindrome - Python Solution<pre><code>def makeSmallestPalindrome(s: str) -&gt; str:\n    n = len(s)\n    s = list(s)\n    left, right = 0, n - 1\n\n    while left &lt; right:\n        if s[left] &lt; s[right]:\n            s[right] = s[left]\n        elif s[left] &gt; s[right]:\n            s[left] = s[right]\n        left += 1\n        right -= 1\n\n    return \"\".join(s)\n\n\ns = \"egcfe\"\nprint(makeSmallestPalindrome(s))  # \"efcfe\"\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/lexicographically_smallest_largest/#1881-maximum-value-after-insertion","title":"1881. Maximum Value after Insertion","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/lexicographically_smallest_largest/#2734-lexicographically-smallest-string-after-substring-operation","title":"2734. Lexicographically Smallest String After Substring Operation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/lexicographically_smallest_largest/#1946-largest-number-after-mutating-substring","title":"1946. Largest Number After Mutating Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/lexicographically_smallest_largest/#1663-smallest-string-with-a-given-numeric-value","title":"1663. Smallest String With A Given Numeric Value","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/lexicographically_smallest_largest/#1328-break-a-palindrome","title":"1328. Break a Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, greedy 1328. Break a Palindrome - Python Solution<pre><code># Greedy\ndef breakPalindrome(palindrome: str) -&gt; str:\n    n = len(palindrome)\n    if n == 1:\n        return \"\"\n\n    for i in range(n // 2):\n        if palindrome[i] != \"a\":\n            return palindrome[:i] + \"a\" + palindrome[i + 1 :]\n\n    return palindrome[:-1] + \"b\"\n\n\npalindrome = \"abccba\"\nprint(breakPalindrome(palindrome))  # \"aaccba\"\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/lexicographically_smallest_largest/#2259-remove-digit-from-number-to-maximize-result","title":"2259. Remove Digit From Number to Maximize Result","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, greedy, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/lexicographically_smallest_largest/#2566-maximum-difference-by-remapping-a-digit","title":"2566. Maximum Difference by Remapping a Digit","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/lexicographically_smallest_largest/#670-maximum-swap","title":"670. Maximum Swap","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/lexicographically_smallest_largest/#3106-lexicographically-smallest-string-after-operations-with-constraint","title":"3106. Lexicographically Smallest String After Operations With Constraint","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/lexicographically_smallest_largest/#1053-previous-permutation-with-one-swap","title":"1053. Previous Permutation With One Swap","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/lexicographically_smallest_largest/#2375-construct-smallest-number-from-di-string","title":"2375. Construct Smallest Number From DI String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, backtracking, stack, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/lexicographically_smallest_largest/#2182-construct-string-with-repeat-limit","title":"2182. Construct String With Repeat Limit","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, greedy, heap priority queue, counting</p> </li> </ul>"},{"location":"content/endlesscheng/lexicographically_smallest_largest/#738-monotone-increasing-digits","title":"738. Monotone Increasing Digits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, greedy</p> </li> <li>Return the largest number that is less than or equal to <code>n</code> with monotone increasing digits.</li> </ul> 738. Monotone Increasing Digits - Python Solution<pre><code># Greedy\ndef monotoneIncreasingDigits(n: int) -&gt; int:\n    strNum = list(str(n))\n\n    for i in range(len(strNum) - 2, -1, -1):\n        if int(strNum[i]) &gt; int(strNum[i + 1]):\n            strNum[i] = str(int(strNum[i]) - 1)\n            strNum[i + 1 :] = [\"9\"] * (len(strNum) - (i + 1))\n\n    return int(\"\".join(strNum))\n\n\nn = 332\nprint(monotoneIncreasingDigits(n))  # 299\n</code></pre>"},{"location":"content/endlesscheng/lexicographically_smallest_largest/#3403-find-the-lexicographically-largest-string-from-the-box-i","title":"3403. Find the Lexicographically Largest String From the Box I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string, enumeration 3403. Find the Lexicographically Largest String From the Box I - Python Solution<pre><code># Lexicographically Smallest/Largest\ndef answerString(word: str, numFriends: int) -&gt; str:\n    if numFriends == 1:\n        return word\n\n    n = len(word)\n    return max(word[i : i + n - numFriends + 1] for i in range(n))\n\n\nif __name__ == \"__main__\":\n    assert answerString(\"dbca\", 2) == \"dbc\"\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/lexicographically_smallest_largest/#3170-lexicographically-minimum-string-after-removing-stars","title":"3170. Lexicographically Minimum String After Removing Stars","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, stack, greedy, heap priority queue 3170. Lexicographically Minimum String After Removing Stars - Python Solution<pre><code>from itertools import chain\n\n\n# Stack\ndef clearStars(s: str) -&gt; str:\n    stacks = [[] for _ in range(26)]\n    for i, c in enumerate(s):\n        if c != \"*\":\n            stacks[ord(c) - ord(\"a\")].append(i)\n            continue\n\n        for st in stacks:\n            if st:\n                st.pop()\n                break\n    return \"\".join(s[i] for i in sorted(chain.from_iterable(stacks)))\n\n\nif __name__ == \"__main__\":\n    assert clearStars(\"aaba*\") == \"aab\"\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/lexicographically_smallest_largest/#1363-largest-multiple-of-three","title":"1363. Largest Multiple of Three","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/lexicographically_smallest_largest/#1754-largest-merge-of-two-strings","title":"1754. Largest Merge Of Two Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/lexicographically_smallest_largest/#1202-smallest-string-with-swaps","title":"1202. Smallest String With Swaps","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, depth first search, breadth first search, union find, sorting 1202. Smallest String With Swaps - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef smallestStringWithSwaps(s: str, pairs: List[List[int]]) -&gt; str:\n    n = len(s)\n    par = list(range(n))\n    components = defaultdict(list)\n\n    def find(node):\n        p = par[node]\n        while par[p] != p:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 != p2:\n            par[p1] = p2\n\n    for index, j in pairs:\n        union(index, j)\n\n    for index in range(n):\n        components[find(index)].append(index)\n\n    res = list(s)\n    for indices in components.values():\n        chars = sorted([s[index] for index in indices])\n        for index, char in zip(indices, chars):\n            res[index] = char\n\n    return \"\".join(res)\n\n\ns = \"dcab\"\npairs = [[0, 3], [1, 2]]\nprint(smallestStringWithSwaps(s, pairs))  # \"bacd\"\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/lexicographically_smallest_largest/#2434-using-a-robot-to-print-the-lexicographically-smallest-string","title":"2434. Using a Robot to Print the Lexicographically Smallest String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, stack, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/lexicographically_smallest_largest/#1625-lexicographically-smallest-string-after-applying-operations","title":"1625. Lexicographically Smallest String After Applying Operations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, depth first search, breadth first search, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/lexicographically_smallest_largest/#2948-make-lexicographically-smallest-array-by-swapping-elements","title":"2948. Make Lexicographically Smallest Array by Swapping Elements","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, union find, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/lexicographically_smallest_largest/#564-find-the-closest-palindrome","title":"564. Find the Closest Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, string</p> </li> </ul>"},{"location":"content/endlesscheng/lexicographically_smallest_largest/#1505-minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits","title":"1505. Minimum Possible Integer After at Most K Adjacent Swaps On Digits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, greedy, binary indexed tree, segment tree</p> </li> </ul>"},{"location":"content/endlesscheng/lexicographically_smallest_largest/#2663-lexicographically-smallest-beautiful-string","title":"2663. Lexicographically Smallest Beautiful String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/lexicographically_smallest_largest/#3302-find-the-lexicographically-smallest-valid-sequence","title":"3302. Find the Lexicographically Smallest Valid Sequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string, dynamic programming, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/lexicographically_smallest_largest/#555-split-concatenated-strings","title":"555. Split Concatenated Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/lexicographically_smallest_largest/#3088-make-string-anti-palindrome","title":"3088. Make String Anti-palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, greedy, sorting, counting sort</p> </li> </ul>"},{"location":"content/endlesscheng/linked_list_applications/","title":"Linked List Applications","text":""},{"location":"content/endlesscheng/linked_list_applications/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1019. Next Greater Node In Linked List (Medium)</li> <li> 1171. Remove Zero Sum Consecutive Nodes from Linked List (Medium)</li> <li> 707. Design Linked List (Medium)</li> <li> 146. LRU Cache (Medium)</li> <li> 460. LFU Cache (Hard)</li> <li> 432. All O`one Data Structure (Hard)</li> <li> 1206. Design Skiplist (Hard)</li> </ul>"},{"location":"content/endlesscheng/linked_list_applications/#1019-next-greater-node-in-linked-list","title":"1019. Next Greater Node In Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, linked list, stack, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/linked_list_applications/#1171-remove-zero-sum-consecutive-nodes-from-linked-list","title":"1171. Remove Zero Sum Consecutive Nodes from Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, linked list 1171. Remove Zero Sum Consecutive Nodes from Linked List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Prefix Sum\ndef removeZeroSumSublists(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    dummy = ListNode(0)\n    dummy.next = head\n    cur = head\n    prefix_sum = 0\n    seen = {0: dummy}\n\n    while cur:\n        prefix_sum += cur.val\n        if prefix_sum in seen:\n            node = seen[prefix_sum].next\n            temp_sum = prefix_sum\n            while node != cur:\n                temp_sum += node.val\n                del seen[temp_sum]\n                node = node.next\n            seen[prefix_sum].next = cur.next\n        else:\n            seen[prefix_sum] = cur\n        cur = cur.next\n\n    return dummy.next\n\n\nhead = ListNode().create([1, 2, -3, 3, 1])\nprint(removeZeroSumSublists(head))  # 3 -&gt; 1\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/linked_list_applications/#707-design-linked-list","title":"707. Design Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, design</p> </li> <li>Design your implementation of the linked list. You can choose to use a singly or doubly linked list.</li> </ul> 707. Design Linked List - Python Solution<pre><code>class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass MyLinkedList:\n\n    def __init__(self):\n        self.dummy = ListNode()\n        self.size = 0\n\n    def get(self, index: int) -&gt; int:\n        if index &lt; 0 or index &gt;= self.size:\n            return -1\n\n        current = self.dummy.next\n        for _ in range(index):\n            current = current.next\n\n        return current.val\n\n    def addAtHead(self, val: int) -&gt; None:\n        self.dummy.next = ListNode(val, self.dummy.next)\n        self.size += 1\n\n    def addAtTail(self, val: int) -&gt; None:\n        current = self.dummy\n        while current.next:\n            current = current.next\n        current.next = ListNode(val)\n        self.size += 1\n\n    def addAtIndex(self, index: int, val: int) -&gt; None:\n        if index &lt; 0 or index &gt; self.size:\n            return\n\n        current = self.dummy\n        for i in range(index):\n            current = current.next\n        current.next = ListNode(val, current.next)\n        self.size += 1\n\n    def deleteAtIndex(self, index: int) -&gt; None:\n        if index &lt; 0 or index &gt;= self.size:\n            return\n\n        current = self.dummy\n        for i in range(index):\n            current = current.next\n        current.next = current.next.next\n        self.size -= 1\n\n\nll = MyLinkedList()\nll.addAtHead(1)\nll.addAtTail(3)\nll.addAtIndex(1, 2)  # 1 -&gt; 2 -&gt; 3\nprint(ll.get(1))  # 2\n</code></pre>"},{"location":"content/endlesscheng/linked_list_applications/#146-lru-cache","title":"146. LRU Cache","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, linked list, design, doubly linked list</p> </li> <li>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.</li> <li>lru</li> <li></li> </ul> Data structure Description Doubly Linked List To store the key-value pairs. Hash Map To store the key-node pairs. 146. LRU Cache - Python Solution<pre><code>from collections import OrderedDict\n\n\n# Doubly Linked List\nclass Node:\n    def __init__(self, key=0, val=0):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.cache = {}\n        self.head = Node()\n        self.tail = Node()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def add_to_last(self, node):\n        self.tail.prev.next = node\n        node.prev = self.tail.prev\n        node.next = self.tail\n        self.tail.prev = node\n\n    def move_to_last(self, node):\n        self.remove(node)\n        self.add_to_last(node)\n\n    def get(self, key: int) -&gt; int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self.move_to_last(node)\n        return node.val\n\n    def put(self, key: int, value: int) -&gt; None:\n        if key in self.cache:\n            node = self.cache[key]\n            node.val = value\n            self.move_to_last(node)\n            return None\n\n        if len(self.cache) == self.cap:\n            del self.cache[self.head.next.key]\n            self.remove(self.head.next)\n\n        node = Node(key=key, val=value)\n        self.cache[key] = node\n        self.add_to_last(node)\n\n\n# OrderedDict\nclass LRUCacheOrderedDict:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.cap = capacity\n\n    def get(self, key: int):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key, last=True)\n        return self.cache[key]\n\n    def put(self, key: int, value: int):\n        if key in self.cache:\n            self.cache.move_to_end(key, last=True)\n        elif len(self.cache) &gt;= self.cap:\n            self.cache.popitem(last=False)\n\n        self.cache[key] = value\n\n\ncache = LRUCache(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\n\ncache = LRUCacheOrderedDict(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\nprint(\"LRU Cache passed\")\nprint(\"LRU Cache Ordered Dict passed\")\n</code></pre> 146. LRU Cache - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nclass Node {\n   public:\n    int key;\n    int val;\n    Node *prev;\n    Node *next;\n\n    Node(int k = 0, int v = 0) : key(k), val(v), prev(nullptr), next(nullptr) {}\n};\n\nclass LRUCache {\n   private:\n    int cap;\n    unordered_map&lt;int, Node *&gt; cache;\n    Node *head;\n    Node *tail;\n\n    void remove(Node *node) {\n        node-&gt;prev-&gt;next = node-&gt;next;\n        node-&gt;next-&gt;prev = node-&gt;prev;\n    }\n\n    void insert_to_last(Node *node) {\n        tail-&gt;prev-&gt;next = node;\n        node-&gt;prev = tail-&gt;prev;\n        tail-&gt;prev = node;\n        node-&gt;next = tail;\n    }\n\n    void move_to_last(Node *node) {\n        remove(node);\n        insert_to_last(node);\n    }\n\n   public:\n    LRUCache(int capacity) {\n        this-&gt;cap = capacity;\n        head = new Node();\n        tail = new Node();\n        head-&gt;next = tail;\n        tail-&gt;prev = head;\n    }\n\n    int get(int key) {\n        if (cache.find(key) != cache.end()) {\n            Node *node = cache[key];\n            move_to_last(node);\n            return node-&gt;val;\n        }\n        return -1;\n    }\n\n    void put(int key, int value) {\n        if (cache.find(key) != cache.end()) {\n            Node *node = cache[key];\n            node-&gt;val = value;\n            move_to_last(node);\n        } else {\n            Node *newNode = new Node(key, value);\n            cache[key] = newNode;\n            insert_to_last(newNode);\n\n            if ((int)cache.size() &gt; cap) {\n                Node *removed = head-&gt;next;\n                remove(removed);\n                cache.erase(removed-&gt;key);\n                delete removed;\n            }\n        }\n    }\n};\n\nint main() {\n    LRUCache lru(2);\n    lru.put(1, 1);\n    lru.put(2, 2);\n    cout &lt;&lt; lru.get(1) &lt;&lt; endl;  // 1\n    lru.put(3, 3);\n    cout &lt;&lt; lru.get(2) &lt;&lt; endl;  // -1\n    lru.put(4, 4);\n    cout &lt;&lt; lru.get(1) &lt;&lt; endl;  // -1\n    cout &lt;&lt; lru.get(3) &lt;&lt; endl;  // 3\n    cout &lt;&lt; lru.get(4) &lt;&lt; endl;  // 4\n    return 0;\n}\n</code></pre>"},{"location":"content/endlesscheng/linked_list_applications/#460-lfu-cache","title":"460. LFU Cache","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, linked list, design, doubly linked list 460. LFU Cache - Python Solution<pre><code>from collections import OrderedDict, defaultdict\n\n\nclass LFUCache:\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        # key -&gt; [val, freq]\n        self.key_to_val_freq = {}\n        # freq -&gt; OrderedDict of keys\n        self.freq_to_keys = defaultdict(OrderedDict)\n        self.min_freq = 0\n\n    def remove_least_frequent(self):\n\n        lfu_key, _ = self.freq_to_keys[self.min_freq].popitem(last=False)\n        del self.key_to_val_freq[lfu_key]\n\n        # If the frequency list is empty after removal, delete it\n        if not self.freq_to_keys[self.min_freq]:\n            del self.freq_to_keys[self.min_freq]\n\n    def update_freq(self, key):\n        \"\"\"Updates the frequency of an existing key.\"\"\"\n        value, freq = self.key_to_val_freq[key]\n\n        # Remove key from current frequency group\n        del self.freq_to_keys[freq][key]\n        if not self.freq_to_keys[freq]:\n            del self.freq_to_keys[freq]\n            if self.min_freq == freq:\n                self.min_freq += 1\n\n        # Update key frequency\n        new_freq = freq + 1\n        self.key_to_val_freq[key] = [value, new_freq]\n        self.freq_to_keys[new_freq][key] = None\n\n    def add_new_key(self, key, value):\n        if len(self.key_to_val_freq) &gt;= self.cap:\n            self.remove_least_frequent()\n\n        # Insert the new key with frequency 1\n        self.key_to_val_freq[key] = [value, 1]\n        self.freq_to_keys[1][key] = None\n        self.min_freq = 1\n\n    def get(self, key: int) -&gt; int:\n        if key not in self.key_to_val_freq:\n            return -1\n        self.update_freq(key)\n        return self.key_to_val_freq[key][0]\n\n    def put(self, key: int, value: int) -&gt; None:\n        if self.cap == 0:\n            return\n\n        if key in self.key_to_val_freq:\n            self.key_to_val_freq[key][0] = value\n            self.update_freq(key)\n        else:\n            self.add_new_key(key, value)\n\n\nlfu = LFUCache(2)\nlfu.put(1, 1)\nlfu.put(2, 2)\nprint(lfu.get(1))  # 1\nlfu.put(3, 3)\nprint(lfu.get(2))  # -1\nprint(lfu.get(3))  # 3\nlfu.put(4, 4)\nprint(lfu.get(1))  # -1\nprint(lfu.get(3))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/linked_list_applications/#432-all-oone-data-structure","title":"432. All O`one Data Structure","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, linked list, design, doubly linked list</p> </li> </ul>"},{"location":"content/endlesscheng/linked_list_applications/#1206-design-skiplist","title":"1206. Design Skiplist","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: linked list, design</p> </li> </ul>"},{"location":"content/endlesscheng/linked_list_delete_nodes/","title":"Linked List Delete Nodes","text":""},{"location":"content/endlesscheng/linked_list_delete_nodes/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 203. Remove Linked List Elements (Easy)</li> <li> 3217. Delete Nodes From Linked List Present in Array (Medium)</li> <li> 83. Remove Duplicates from Sorted List (Easy)</li> <li> 82. Remove Duplicates from Sorted List II (Medium)</li> <li> 237. Delete Node in a Linked List (Medium)</li> <li> 1669. Merge In Between Linked Lists (Medium)</li> <li> 2487. Remove Nodes From Linked List (Medium)</li> <li> 1836. Remove Duplicates From an Unsorted Linked List (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/linked_list_delete_nodes/#203-remove-linked-list-elements","title":"203. Remove Linked List Elements","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: linked list, recursion</p> </li> <li> <p>Remove all elements from a linked list of integers that have value <code>val</code>.</p> </li> <li> <p>Before</p> </li> </ul> <pre><code>graph LR\nA((1)) --&gt; B((2))\nB --&gt; C((6))\nC --&gt; D((3))\nD --&gt; E((4))\nE --&gt; F((5))\nF --&gt; G((6))\nG --&gt; H((None))</code></pre> <ul> <li>After</li> </ul> <pre><code>graph LR\nA((1)) --&gt; B((2))\nB -.-&gt; C((6))\nC -.-&gt; D((3))\nD --&gt; E((4))\nE --&gt; F((5))\nF -.-&gt; G((6))\nB --&gt; D((3))\nF --&gt; I((None))</code></pre> 203. Remove Linked List Elements - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Iterative\ndef removeElements(head: Optional[ListNode], val: int) -&gt; Optional[ListNode]:\n    dummy = ListNode(0)\n    dummy.next = head\n    cur = dummy\n\n    while cur.next:\n        if cur.next.val == val:\n            cur.next = cur.next.next\n        else:\n            cur = cur.next\n\n    return dummy.next\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |  Iterative  |      O(N)       |    O(1)      |\n# |-------------|-----------------|--------------|\n\n\nnums = [1, 2, 6, 3, 4, 5, 6]\nval = 6\nhead = ListNode.create(nums)\nprint(head)\n# 1 -&gt; 2 -&gt; 6 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6\nprint(removeElements(head, val))\n# 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\n</code></pre>"},{"location":"content/endlesscheng/linked_list_delete_nodes/#3217-delete-nodes-from-linked-list-present-in-array","title":"3217. Delete Nodes From Linked List Present in Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, linked list 3217. Delete Nodes From Linked List Present in Array - Python Solution<pre><code>from typing import List, Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef modifiedList(\n    nums: List[int], head: Optional[ListNode]\n) -&gt; Optional[ListNode]:\n    numSet = set(nums)\n    dummy = ListNode(0, head)\n    cur = dummy\n\n    while cur.next:\n        if cur.next.val in numSet:\n            cur.next = cur.next.next\n        else:\n            cur = cur.next\n\n    return dummy.next\n\n\nnums = [1, 2, 3]\nhead = ListNode().create([1, 2, 3, 4, 5])\nprint(modifiedList(nums, head))  # 4 -&gt; 5\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/linked_list_delete_nodes/#83-remove-duplicates-from-sorted-list","title":"83. Remove Duplicates from Sorted List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: linked list 83. Remove Duplicates from Sorted List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef deleteDuplicates(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    if not head:\n        return None\n\n    cur = head\n    while cur.next:\n        if cur.next.val == cur.val:\n            cur.next = cur.next.next\n        else:\n            cur = cur.next\n\n    return head\n\n\nhead = ListNode().create([1, 1, 2, 3, 3])\nprint(deleteDuplicates(head))  # 1 -&gt; 2 -&gt; 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/linked_list_delete_nodes/#82-remove-duplicates-from-sorted-list-ii","title":"82. Remove Duplicates from Sorted List II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, two pointers 82. Remove Duplicates from Sorted List II - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef deleteDuplicates(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    dummy = ListNode(0, head)\n    cur = dummy\n\n    while cur.next and cur.next.next:\n        val = cur.next.val\n        if cur.next.next.val == val:\n            while cur.next and cur.next.val == val:\n                cur.next = cur.next.next\n        else:\n            cur = cur.next\n\n    return dummy.next\n\n\nhead = ListNode().create([1, 1, 2, 3, 3, 4, 5])\nprint(deleteDuplicates(head))  # 2 -&gt; 4 -&gt; 5\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/linked_list_delete_nodes/#237-delete-node-in-a-linked-list","title":"237. Delete Node in a Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list</p> </li> <li>Delete a node in a singly linked list. You are given only the node to be deleted.</li> </ul> 237. Delete Node in a Linked List - Python Solution<pre><code>from template import ListNode\n\n\ndef deleteNode(node: ListNode) -&gt; None:\n    node.val = node.next.val\n    node.next = node.next.next\n\n\nhead = ListNode.create([4, 5, 1, 9])\nnode = head.next\ndeleteNode(node)\nprint(head)  # 4 -&gt; 1 -&gt; 9\n</code></pre>"},{"location":"content/endlesscheng/linked_list_delete_nodes/#1669-merge-in-between-linked-lists","title":"1669. Merge In Between Linked Lists","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list</p> </li> </ul>"},{"location":"content/endlesscheng/linked_list_delete_nodes/#2487-remove-nodes-from-linked-list","title":"2487. Remove Nodes From Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, stack, recursion, monotonic stack</p> </li> <li>Remove all nodes from a linked list that have a value greater than <code>maxValue</code>.</li> </ul> 2487. Remove Nodes From Linked List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Recursive\ndef removeNodesRecursive(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    if not head:\n        return None\n\n    head.next = removeNodesRecursive(head.next)\n\n    if head.next and head.val &lt; head.next.val:\n        return head.next\n\n    return head\n\n\n# Iterative\ndef removeNodesIterative(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    stack = []\n    cur = head\n\n    while cur:\n        # pop all nodes in stack that are smaller than cur\n        while stack and cur.val &gt; stack[-1].val:\n            stack.pop()\n\n        stack.append(cur)\n        cur = cur.next\n\n    # link all nodes in stack\n    dummy = ListNode()\n    cur = dummy\n\n    for node in stack:\n        cur.next = node\n        cur = cur.next\n\n    return dummy.next\n\n\nhead = [5, 2, 13, 3, 8]\nhead1 = ListNode.create(head)\nprint(head1)  # 5 -&gt; 2 -&gt; 13 -&gt; 3 -&gt; 8\nprint(removeNodesRecursive(head1))  # 13 -&gt; 8\nhead2 = ListNode.create(head)\nprint(removeNodesIterative(head2))  # 13 -&gt; 8\n</code></pre>"},{"location":"content/endlesscheng/linked_list_delete_nodes/#1836-remove-duplicates-from-an-unsorted-linked-list","title":"1836. Remove Duplicates From an Unsorted Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, linked list</p> </li> </ul>"},{"location":"content/endlesscheng/linked_list_divide_and_conquer/","title":"Linked List Divide and Conquer","text":""},{"location":"content/endlesscheng/linked_list_divide_and_conquer/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 23. Merge k Sorted Lists (Hard)</li> <li> 148. Sort List (Medium)</li> </ul>"},{"location":"content/endlesscheng/linked_list_divide_and_conquer/#23-merge-k-sorted-lists","title":"23. Merge k Sorted Lists","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: linked list, divide and conquer, heap priority queue, merge sort</p> </li> <li>Prerequisite: 21. Merge Two Sorted Lists</li> <li>Video explanation: 23. Merge K Sorted Lists - NeetCode</li> </ul> 23. Merge k Sorted Lists - Python Solution<pre><code>import copy\nimport heapq\nfrom typing import List, Optional\n\nfrom template import ListNode\n\n\n# Divide and Conquer\ndef mergeKListsDC(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    if not lists or len(lists) == 0:\n        return None\n\n    def mergeTwo(l1, l2):\n        dummy = ListNode()\n        cur = dummy\n\n        while l1 and l2:\n            if l1.val &lt; l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n\n            cur = cur.next\n\n        cur.next = l1 if l1 else l2\n\n        return dummy.next\n\n    while len(lists) &gt; 1:\n        merged = []\n\n        for i in range(0, len(lists), 2):\n            l1 = lists[i]\n            l2 = lists[i + 1] if i + 1 &lt; len(lists) else None\n            merged.append(mergeTwo(l1, l2))\n\n        lists = merged\n\n    return lists[0]\n\n\n# Heap - Merge k Sorted\ndef mergeKLists(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    minHeap = []  # (val, idx, node)\n\n    for idx, head in enumerate(lists):\n        if head:\n            heapq.heappush(minHeap, (head.val, idx, head))\n\n    while minHeap:\n        _, idx, node = heapq.heappop(minHeap)\n        cur.next = node\n        cur = cur.next\n\n        node = node.next\n        if node:\n            heapq.heappush(minHeap, (node.val, idx, node))\n\n    return dummy.next\n\n\nn1 = ListNode.create([1, 4, 5])\nn2 = ListNode.create([1, 3, 4])\nn3 = ListNode.create([2, 6])\nlists = [n1, n2, n3]\nlists1 = copy.deepcopy(lists)\nlists2 = copy.deepcopy(lists)\nprint(mergeKListsDC(lists1))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6\nprint(mergeKLists(lists2))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6\n</code></pre>"},{"location":"content/endlesscheng/linked_list_divide_and_conquer/#148-sort-list","title":"148. Sort List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, two pointers, divide and conquer, sorting, merge sort 148. Sort List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef sortListSort(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    nums = []\n\n    while head:\n        nums.append(head.val)\n        head = head.next\n\n    dummy = ListNode()\n    cur = dummy\n    nums.sort()\n\n    for num in nums:\n        cur.next = ListNode(val=num)\n        cur = cur.next\n\n    return dummy.next\n\n\n# Linked List\ndef sortListDivideConquer(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    def middle(node):\n        fast, slow = node, node\n        while fast and fast.next:\n            pre = slow\n            slow = slow.next\n            fast = fast.next.next\n        pre.next = None\n        return slow\n\n    def merge_two_lists(l1, l2):\n        dummy = ListNode()\n        cur = dummy\n        while l1 and l2:\n            if l1.val &lt; l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n            cur = cur.next\n\n        cur.next = l1 if l1 else l2\n        return dummy.next\n\n    if not head or not head.next:\n        return head\n\n    head2 = middle(head)\n    head = sortListDivideConquer(head)\n    head2 = sortListDivideConquer(head2)\n\n    return merge_two_lists(head, head2)\n\n\nhead = ListNode().create([4, 2, 1, 3])\nprint(head)  # 4 -&gt; 2 -&gt; 1 -&gt; 3\nprint(sortListSort(head))  # 1 -&gt; 2 -&gt; 3 -&gt; 4\nprint(sortListDivideConquer(head))  # 1 -&gt; 2 -&gt; 3 -&gt; 4\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/linked_list_double_pointers/","title":"Linked List Double Pointers","text":""},{"location":"content/endlesscheng/linked_list_double_pointers/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 328. Odd Even Linked List (Medium)</li> <li> 86. Partition List (Medium)</li> <li> 160. Intersection of Two Linked Lists (Easy)</li> </ul>"},{"location":"content/endlesscheng/linked_list_double_pointers/#328-odd-even-linked-list","title":"328. Odd Even Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list</p> </li> </ul>"},{"location":"content/endlesscheng/linked_list_double_pointers/#86-partition-list","title":"86. Partition List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, two pointers</p> </li> </ul>"},{"location":"content/endlesscheng/linked_list_double_pointers/#160-intersection-of-two-linked-lists","title":"160. Intersection of Two Linked Lists","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, linked list, two pointers</p> </li> <li>Find the node at which the intersection of two singly linked lists begins.</li> </ul> <pre><code>graph LR\n    a1((a1)) --&gt; a2((a2))\n    a2 --&gt; c1((c1))\n    b1((b1)) --&gt; b2((b2))\n    b2 --&gt; b3((b3))\n    b3 --&gt; c1\n    c1 --&gt; c2((c2))\n    c2 --&gt; c3((c3))</code></pre> 160. Intersection of Two Linked Lists - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Hash Set\ndef getIntersectionNodeHash(\n    headA: ListNode, headB: ListNode\n) -&gt; Optional[ListNode]:\n    if not headA or not headB:\n        return None\n\n    visited = set()\n    cur = headA\n    while cur:\n        visited.add(cur)\n        cur = cur.next\n\n    cur = headB\n    while cur:\n        if cur in visited:\n            return cur\n        cur = cur.next\n\n    return None\n\n\n# Two Pointers\ndef getIntersectionNodeTP(\n    headA: ListNode, headB: ListNode\n) -&gt; Optional[ListNode]:\n    if not headA or not headB:\n        return None\n\n    a, b = headA, headB\n\n    while a != b:\n        a = a.next if a else headB\n        b = b.next if b else headA\n\n    return a\n\n\nlistA = [4, 1, 8, 4, 5]\nlistB = [5, 6, 1, 8, 4, 5]\nheadA = ListNode.create(listA)\nprint(headA)\n# 4 -&gt; 1 -&gt; 8 -&gt; 4 -&gt; 5\nheadB = ListNode.create(listB)\nprint(headB)\n# 5 -&gt; 6 -&gt; 1 -&gt; 8 -&gt; 4 -&gt; 5\n\nheadA.intersect(headB, 8)\n\nprint(getIntersectionNodeHash(headA, headB))\n# 8 -&gt; 4 -&gt; 5\nprint(getIntersectionNodeTP(headA, headB))\n# 8 -&gt; 4 -&gt; 5\n</code></pre>"},{"location":"content/endlesscheng/linked_list_fast_slow_pointers/","title":"Linked List Fast Slow Pointers","text":""},{"location":"content/endlesscheng/linked_list_fast_slow_pointers/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 876. Middle of the Linked List (Easy)</li> <li> 2095. Delete the Middle Node of a Linked List (Medium)</li> <li> 234. Palindrome Linked List (Easy)</li> <li> 2130. Maximum Twin Sum of a Linked List (Medium)</li> <li> 143. Reorder List (Medium)</li> <li> 141. Linked List Cycle (Easy)</li> <li> 142. Linked List Cycle II (Medium)</li> <li> 457. Circular Array Loop (Medium)</li> <li> 2674. Split a Circular Linked List (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/linked_list_fast_slow_pointers/#876-middle-of-the-linked-list","title":"876. Middle of the Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: linked list, two pointers 876. Middle of the Linked List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef middleNode(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    fast, slow = head, head\n\n    while fast and fast.next:\n        fast = fast.next.next\n        slow = slow.next\n\n    return slow\n\n\nprint(middleNode(ListNode.create([1, 2, 3, 4, 5])))\n# 3 -&gt; 4 -&gt; 5\nprint(middleNode(ListNode.create([1, 2, 3, 4, 5, 6])))\n# 4 -&gt; 5 -&gt; 6\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/linked_list_fast_slow_pointers/#2095-delete-the-middle-node-of-a-linked-list","title":"2095. Delete the Middle Node of a Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, two pointers 2095. Delete the Middle Node of a Linked List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef deleteMiddle(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    fast, slow = head, head\n    dummy = ListNode(0, head)\n    cur = dummy\n\n    while fast and fast.next:\n        fast = fast.next.next\n        cur = cur.next\n        slow = slow.next\n\n    cur.next = slow.next\n\n    return dummy.next\n\n\nnode = ListNode.create([1, 2, 3, 4, 5])\nprint(deleteMiddle(node))\n# 1 -&gt; 2 -&gt; 4 -&gt; 5\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/linked_list_fast_slow_pointers/#234-palindrome-linked-list","title":"234. Palindrome Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: linked list, two pointers, stack, recursion 234. Palindrome Linked List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef isPalindrome(head: Optional[ListNode]) -&gt; bool:\n    if not head or not head.next:\n        return True\n\n    def middle(node):\n        fast, slow = node, node\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n        return slow\n\n    def reverse(node):\n        cur, pre = node, None\n        while cur:\n            nxt = cur.next\n            cur.next = pre\n            pre = cur\n            cur = nxt\n        return pre\n\n    mid1 = head\n    mid2 = reverse(middle(head))\n\n    while mid2:\n        if mid1.val != mid2.val:\n            return False\n        mid1 = mid1.next\n        mid2 = mid2.next\n\n    return True\n\n\nhead = ListNode().create([1, 2, 2, 1])\nprint(isPalindrome(head))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/linked_list_fast_slow_pointers/#2130-maximum-twin-sum-of-a-linked-list","title":"2130. Maximum Twin Sum of a Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, two pointers, stack 2130. Maximum Twin Sum of a Linked List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef pairSum(head: Optional[ListNode]) -&gt; int:\n    def middle(node):\n        fast, slow = node, node\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n        return slow\n\n    def reverse(node):\n        cur, pre = node, None\n        while cur:\n            nxt = cur.next\n            cur.next = pre\n            pre = cur\n            cur = nxt\n        return pre\n\n    list1 = head\n    list2 = reverse(middle(head))\n    res = float(\"-inf\")\n\n    while list2:\n        res = max(res, list1.val + list2.val)\n        list1 = list1.next\n        list2 = list2.next\n\n    return res\n\n\nnode = ListNode().create([4, 2, 2, 3])\nprint(pairSum(node))  # 7\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/linked_list_fast_slow_pointers/#143-reorder-list","title":"143. Reorder List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, two pointers, stack, recursion 143. Reorder List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef reorderList(head: Optional[ListNode]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify head in-place instead.\n    \"\"\"\n    if not head or not head.next:\n        return\n\n    # Middle of the linked list\n    slow, fast = head, head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n    # Reverse the second half\n    pre, cur = None, slow\n    while cur:\n        temp = cur.next\n        cur.next = pre\n        pre = cur\n        cur = temp\n\n    # Merge two linked lists\n    first, second = head, pre\n    while second.next:\n        temp1, temp2 = first.next, second.next\n        first.next = second\n        second.next = temp1\n        first, second = temp1, temp2\n\n\nhead = ListNode.create([1, 2, 3, 4, 5, 6])\nprint(head)  # 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6\nreorderList(head)\nprint(head)  # 1 -&gt; 6 -&gt; 2 -&gt; 5 -&gt; 3 -&gt; 4\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/linked_list_fast_slow_pointers/#141-linked-list-cycle","title":"141. Linked List Cycle","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, linked list, two pointers</p> </li> <li>Determine if a linked list has a cycle in it.</li> </ul> <pre><code>graph LR\n    A((3)) --&gt; B((2))\n    B --&gt; C((0))\n    C --&gt; D((4))</code></pre> <pre><code>graph LR\n    A((3)) --&gt; B((2))\n    B --&gt; C((0))\n    C --&gt; D((4))\n    D --&gt; B</code></pre> 141. Linked List Cycle - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\ndef hasCycle(head: Optional[ListNode]) -&gt; bool:\n    slow, fast = head, head\n\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n        if slow == fast:\n            return True\n\n    return False\n\n\nprint(hasCycle(ListNode.create([3, 2, 0, -4])))  # False\nprint(hasCycle(ListNode.create([3, 2, 0, -4], 1)))  # True\n</code></pre> 141. Linked List Cycle - C++ Solution<pre><code>#include &lt;iostream&gt;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nclass Solution {\n   public:\n    bool hasCycle(ListNode* head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while (fast &amp;&amp; fast-&gt;next) {\n            slow = slow-&gt;next;\n            fast = fast-&gt;next-&gt;next;\n\n            if (fast == slow) return true;\n        }\n        return false;\n    }\n};\n</code></pre>"},{"location":"content/endlesscheng/linked_list_fast_slow_pointers/#142-linked-list-cycle-ii","title":"142. Linked List Cycle II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, linked list, two pointers</p> </li> <li>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>None</code>.</li> </ul> <pre><code>graph LR\nA[3] --&gt; B[2]\nB --&gt; C[0]\nC --&gt; D[-4]\nD --&gt; B</code></pre> 142. Linked List Cycle II - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\ndef detectCycle(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    slow, fast = head, head\n\n    while fast and fast.next:\n        fast = fast.next.next\n        slow = slow.next\n\n        if slow == fast:\n            slow = head\n            while slow != fast:\n                slow = slow.next\n                fast = fast.next\n            return slow\n\n    return None\n\n\nhead1 = ListNode.create([3, 2, 0, -4], 1)\nprint(detectCycle(head1).val)  # 2\nhead2 = ListNode.create([3, 2, 0, -4])\nprint(detectCycle(head2))  # None\n</code></pre> 142. Linked List Cycle II - C++ Solution<pre><code>#include &lt;iostream&gt;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nclass Solution {\n   public:\n    ListNode* detectCycle(ListNode* head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while (fast &amp;&amp; fast-&gt;next) {\n            slow = slow-&gt;next;\n            fast = fast-&gt;next-&gt;next;\n\n            if (fast == slow) {\n                slow = head;\n                while (slow != fast) {\n                    slow = slow-&gt;next;\n                    fast = fast-&gt;next;\n                }\n                return slow;\n            }\n        }\n        return nullptr;\n    }\n};\n</code></pre>"},{"location":"content/endlesscheng/linked_list_fast_slow_pointers/#457-circular-array-loop","title":"457. Circular Array Loop","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, two pointers</p> </li> </ul>"},{"location":"content/endlesscheng/linked_list_fast_slow_pointers/#2674-split-a-circular-linked-list","title":"2674. Split a Circular Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, two pointers</p> </li> </ul>"},{"location":"content/endlesscheng/linked_list_front_back_pointers/","title":"Linked List Front Back Pointers","text":""},{"location":"content/endlesscheng/linked_list_front_back_pointers/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 19. Remove Nth Node From End of List (Medium)</li> <li> 61. Rotate List (Medium)</li> <li> 1721. Swapping Nodes in a Linked List (Medium)</li> <li> 1474. Delete N Nodes After M Nodes of a Linked List (Easy) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/linked_list_front_back_pointers/#19-remove-nth-node-from-end-of-list","title":"19. Remove Nth Node From End of List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, two pointers</p> </li> <li>Given the <code>head</code> of a linked list, remove the <code>n-th</code> node from the end of the list and return its head.</li> </ul> 19. Remove Nth Node From End of List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef removeNthFromEnd(head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:\n    dummy = ListNode(0, head)\n    fast, slow = dummy, dummy\n\n    for _ in range(n):\n        fast = fast.next\n\n    while fast.next:\n        fast = fast.next\n        slow = slow.next\n\n    slow.next = slow.next.next\n\n    return dummy.next\n\n\nhead = [1, 2, 3, 4, 5]\nn = 2\nhead = ListNode.create(head)\nprint(head)  # 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(removeNthFromEnd(head, n))  # 1 -&gt; 2 -&gt; 3 -&gt; 5\n</code></pre>"},{"location":"content/endlesscheng/linked_list_front_back_pointers/#61-rotate-list","title":"61. Rotate List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, two pointers</p> </li> </ul>"},{"location":"content/endlesscheng/linked_list_front_back_pointers/#1721-swapping-nodes-in-a-linked-list","title":"1721. Swapping Nodes in a Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, two pointers</p> </li> </ul>"},{"location":"content/endlesscheng/linked_list_front_back_pointers/#1474-delete-n-nodes-after-m-nodes-of-a-linked-list","title":"1474. Delete N Nodes After M Nodes of a Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: linked list 1474. Delete N Nodes After M Nodes of a Linked List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef deleteNodes(\n    head: Optional[ListNode], m: int, n: int\n) -&gt; Optional[ListNode]:\n    dummy = ListNode(0, head)\n    cur = dummy\n\n    while cur.next:\n        for _ in range(m):\n            if not cur.next:\n                break\n            cur = cur.next\n\n        for _ in range(n):\n            if not cur.next:\n                break\n            cur.next = cur.next.next\n\n    return dummy.next\n\n\nif __name__ == \"__main__\":\n    head = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\n    m = 2\n    n = 3\n    head = ListNode.create(head)\n    print(head)\n    # 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; 8 -&gt; 9 -&gt; 10 -&gt; 11 -&gt; 12 -&gt; 13\n    head = deleteNodes(head, m, n)\n    print(head)\n    # 1 -&gt; 2 -&gt; 6 -&gt; 7 -&gt; 11 -&gt; 12\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/linked_list_insert_nodes/","title":"Linked List Insert Nodes","text":""},{"location":"content/endlesscheng/linked_list_insert_nodes/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2807. Insert Greatest Common Divisors in Linked List (Medium)</li> <li> 147. Insertion Sort List (Medium)</li> <li> 708. Insert into a Sorted Circular Linked List (Medium) \ud83d\udc51</li> <li> 2046. Sort Linked List Already Sorted Using Absolute Values (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/linked_list_insert_nodes/#2807-insert-greatest-common-divisors-in-linked-list","title":"2807. Insert Greatest Common Divisors in Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, math, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/linked_list_insert_nodes/#147-insertion-sort-list","title":"147. Insertion Sort List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/linked_list_insert_nodes/#708-insert-into-a-sorted-circular-linked-list","title":"708. Insert into a Sorted Circular Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list</p> </li> </ul>"},{"location":"content/endlesscheng/linked_list_insert_nodes/#2046-sort-linked-list-already-sorted-using-absolute-values","title":"2046. Sort Linked List Already Sorted Using Absolute Values","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, two pointers, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/linked_list_others/","title":"Linked List Others","text":""},{"location":"content/endlesscheng/linked_list_others/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 138. Copy List with Random Pointer (Medium)</li> <li> 382. Linked List Random Node (Medium)</li> <li> 430. Flatten a Multilevel Doubly Linked List (Medium)</li> <li> 1265. Print Immutable Linked List in Reverse (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/linked_list_others/#138-copy-list-with-random-pointer","title":"138. Copy List with Random Pointer","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, linked list 138. Copy List with Random Pointer - Python Solution<pre><code>from typing import Optional\n\n\nclass Node:\n    def __init__(self, x: int, next: \"Node\" = None, random: \"Node\" = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\n\ndef copyRandomList(head: \"Optional[Node]\") -&gt; \"Optional[Node]\":\n    if not head:\n        return None\n\n    # Copy nodes and link them together\n    cur = head\n    while cur:\n        new_node = Node(cur.val)\n        new_node.next = cur.next\n        cur.next = new_node\n        cur = new_node.next\n\n    # Copy random pointers\n    cur = head\n    while cur:\n        cur.next.random = cur.random.next if cur.random else None\n        cur = cur.next.next\n\n    # Separate the original and copied lists\n    cur = head\n    new_head = head.next\n    while cur:\n        new_node = cur.next\n        cur.next = new_node.next\n        new_node.next = new_node.next.next if new_node.next else None\n        cur = cur.next\n\n    return new_head\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/linked_list_others/#382-linked-list-random-node","title":"382. Linked List Random Node","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, math, reservoir sampling, randomized</p> </li> </ul>"},{"location":"content/endlesscheng/linked_list_others/#430-flatten-a-multilevel-doubly-linked-list","title":"430. Flatten a Multilevel Doubly Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, depth first search, doubly linked list</p> </li> </ul>"},{"location":"content/endlesscheng/linked_list_others/#1265-print-immutable-linked-list-in-reverse","title":"1265. Print Immutable Linked List in Reverse","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, two pointers, stack, recursion</p> </li> </ul>"},{"location":"content/endlesscheng/linked_list_reverse/","title":"Linked List Reverse","text":""},{"location":"content/endlesscheng/linked_list_reverse/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 206. Reverse Linked List (Easy)</li> <li> 92. Reverse Linked List II (Medium)</li> <li> 24. Swap Nodes in Pairs (Medium)</li> <li> 25. Reverse Nodes in k-Group (Hard)</li> <li> 2074. Reverse Nodes in Even Length Groups (Medium)</li> </ul>"},{"location":"content/endlesscheng/linked_list_reverse/#206-reverse-linked-list","title":"206. Reverse Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: linked list, recursion</p> </li> <li>Reverse a singly linked list.</li> </ul> <pre><code>graph LR\nA((1)) --&gt; B((2))\nB --&gt; C((3))\nC --&gt; D((4))\nD --&gt; E((5))</code></pre> <pre><code>graph RL\nE((5)) --&gt; D((4))\nD --&gt; C((3))\nC --&gt; B((2))\nB --&gt; A((1))</code></pre> 206. Reverse Linked List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Iterative\ndef reverseListIterative(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    cur = head\n    prev = None\n\n    while cur:\n        temp = cur.next\n        cur.next = prev\n\n        prev = cur\n        cur = temp\n\n    return prev\n\n\n# Recursive\ndef reverseListRecursive(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    def reverse(cur, prev):\n        if not cur:\n            return prev\n\n        temp = cur.next\n        cur.next = prev\n\n        return reverse(temp, cur)\n\n    return reverse(head, None)\n\n\nnums = [1, 2, 3, 4, 5]\nhead1 = ListNode.create(nums)\nprint(head1)\n# 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(reverseListIterative(head1))\n# 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1\nhead2 = ListNode.create(nums)\nprint(reverseListRecursive(head2))\n# 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1\n</code></pre>"},{"location":"content/endlesscheng/linked_list_reverse/#92-reverse-linked-list-ii","title":"92. Reverse Linked List II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list</p> </li> <li>Reverse a linked list from position left to position right. Return the linked list after reversing.</li> </ul> <pre><code>graph LR\nA((1)) --&gt; B((2))\nB --&gt; C((3))\nC --&gt; D((4))\nD --&gt; E((5))</code></pre> <pre><code>graph LR\nA((1)) --&gt; B((4))\nB --&gt; C((3))\nC --&gt; D((2))\nD --&gt; E((5))</code></pre> 92. Reverse Linked List II - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef reverseBetween(\n    head: Optional[ListNode], left: int, right: int\n) -&gt; Optional[ListNode]:\n    dummy = ListNode(next=head)\n    p0 = dummy\n    for _ in range(left - 1):\n        p0 = p0.next\n\n    pre = None\n    cur = p0.next\n    for _ in range(right - left + 1):\n        nxt = cur.next\n        cur.next = pre\n        pre = cur\n        cur = nxt\n\n    p0.next.next = cur\n    p0.next = pre\n\n    return dummy.next\n\n\nhead = ListNode().create([1, 2, 3, 4, 5])\nleft = 2\nright = 4\nprint(reverseBetween(head, left, right))\n# 1 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 5\n</code></pre>"},{"location":"content/endlesscheng/linked_list_reverse/#24-swap-nodes-in-pairs","title":"24. Swap Nodes in Pairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, recursion</p> </li> <li>Given a linked list, swap every two adjacent nodes and return its head.</li> </ul> 24. Swap Nodes in Pairs - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef swapPairs(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    dummy = ListNode(0, head)\n    n0 = dummy\n    n1 = dummy.next\n\n    while n1 and n1.next:\n        n2 = n1.next\n        n3 = n2.next\n\n        n0.next = n2\n        n2.next = n1\n        n1.next = n3\n\n        n0 = n1\n        n1 = n3\n\n    return dummy.next\n\n\nnums = [1, 2, 3, 4, 5]\nhead = ListNode.create(nums)\nprint(head)\n# 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(swapPairs(head))\n# 2 -&gt; 1 -&gt; 4 -&gt; 3 -&gt; 5\n</code></pre>"},{"location":"content/endlesscheng/linked_list_reverse/#25-reverse-nodes-in-k-group","title":"25. Reverse Nodes in k-Group","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: linked list, recursion 25. Reverse Nodes in k-Group - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef reverseKGroup(head: Optional[ListNode], k: int) -&gt; Optional[ListNode]:\n    n = 0\n    cur = head\n    while cur:\n        n += 1\n        cur = cur.next\n\n    p0 = dummy = ListNode(next=head)\n    pre = None\n    cur = head\n\n    while n &gt;= k:\n        n -= k\n        for _ in range(k):\n            nxt = cur.next\n            cur.next = pre\n            pre = cur\n            cur = nxt\n\n        nxt = p0.next\n        nxt.next = cur\n        p0.next = pre\n        p0 = nxt\n\n    return dummy.next\n\n\nif __name__ == \"__main__\":\n    head = [1, 2, 3, 4, 5]\n    k = 2\n    head = ListNode.create(head)\n    print(head)  # 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\n    print(reverseKGroup(head, k))  # 2 -&gt; 1 -&gt; 4 -&gt; 3 -&gt; 5\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/linked_list_reverse/#2074-reverse-nodes-in-even-length-groups","title":"2074. Reverse Nodes in Even Length Groups","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list</p> </li> </ul>"},{"location":"content/endlesscheng/linked_list_traversal/","title":"Linked List Traversal","text":""},{"location":"content/endlesscheng/linked_list_traversal/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1290. Convert Binary Number in a Linked List to Integer (Easy)</li> <li> 2058. Find the Minimum and Maximum Number of Nodes Between Critical Points (Medium)</li> <li> 2181. Merge Nodes in Between Zeros (Medium)</li> <li> 725. Split Linked List in Parts (Medium)</li> <li> 817. Linked List Components (Medium)</li> <li> 3062. Winner of the Linked List Game (Easy) \ud83d\udc51</li> <li> 3063. Linked List Frequency (Easy) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/linked_list_traversal/#1290-convert-binary-number-in-a-linked-list-to-integer","title":"1290. Convert Binary Number in a Linked List to Integer","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: linked list, math 1290. Convert Binary Number in a Linked List to Integer - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef getDecimalValue(head: Optional[ListNode]) -&gt; int:\n    res = 0\n\n    while head:\n        res = res * 2 + head.val\n        head = head.next\n\n    return res\n\n\nnode = ListNode().create([1, 0, 1])\nprint(node)  # 1 -&gt; 0 -&gt; 1\nprint(getDecimalValue(node))  # 5\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/linked_list_traversal/#2058-find-the-minimum-and-maximum-number-of-nodes-between-critical-points","title":"2058. Find the Minimum and Maximum Number of Nodes Between Critical Points","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list 2058. Find the Minimum and Maximum Number of Nodes Between Critical Points - Python Solution<pre><code>from typing import List, Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef nodesBetweenCriticalPoints(head: Optional[ListNode]) -&gt; List[int]:\n    pre = head.val\n    cur = head.next\n    idx = 0\n    count = 0\n    res = []\n    mn = float(\"inf\")\n\n    while cur.next:\n        idx += 1\n        val = cur.val\n        if pre &gt; val and val &lt; cur.next.val:\n            res.append(idx)\n            count += 1\n        elif pre &lt; val and val &gt; cur.next.val:\n            res.append(idx)\n            count += 1\n\n        if count &gt;= 2:\n            mn = min(mn, res[-1] - res[-2])\n        pre = val\n        cur = cur.next\n\n    if count &gt;= 2:\n        return [mn, res[-1] - res[0]]\n    else:\n        return [-1, -1]\n\n\nnode = ListNode().create([5, 3, 1, 2, 5, 1, 2])\nprint(nodesBetweenCriticalPoints(node))  # [1, 3]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/linked_list_traversal/#2181-merge-nodes-in-between-zeros","title":"2181. Merge Nodes in Between Zeros","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, simulation 2181. Merge Nodes in Between Zeros - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef mergeNodes(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    head = head.next\n    temp = 0\n\n    while head.next:\n        if head.val == 0:\n            cur.next = ListNode(temp)\n            cur = cur.next\n            temp = 0\n        else:\n            temp += head.val\n\n        head = head.next\n\n    if temp != 0:\n        cur.next = ListNode(temp)\n\n    return dummy.next\n\n\nroot = ListNode.create([0, 3, 1, 0, 4, 5, 2, 0])\nprint(root)  # 0 -&gt; 3 -&gt; 1 -&gt; 0 -&gt; 4 -&gt; 5 -&gt; 2 -&gt; 0\nprint(mergeNodes(root))  # 4 -&gt; 11\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/linked_list_traversal/#725-split-linked-list-in-parts","title":"725. Split Linked List in Parts","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list</p> </li> </ul>"},{"location":"content/endlesscheng/linked_list_traversal/#817-linked-list-components","title":"817. Linked List Components","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, linked list 817. Linked List Components - Python Solution<pre><code>from typing import List, Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef numComponents(head: Optional[ListNode], nums: List[int]) -&gt; int:\n    numSet = set(nums)\n    res = 0\n\n    while head:\n        if head.val in numSet:\n            while head and head.val in numSet:\n                head = head.next\n            res += 1\n        else:\n            head = head.next\n\n    return res\n\n\nhead = ListNode().create([0, 1, 2, 3, 4])\nnums = [0, 3, 1, 4]\nprint(numComponents(head, nums))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/linked_list_traversal/#3062-winner-of-the-linked-list-game","title":"3062. Winner of the Linked List Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: linked list</p> </li> </ul>"},{"location":"content/endlesscheng/linked_list_traversal/#3063-linked-list-frequency","title":"3063. Linked List Frequency","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, linked list, counting</p> </li> </ul>"},{"location":"content/endlesscheng/linked_lists_merge/","title":"Linked Lists Merge","text":""},{"location":"content/endlesscheng/linked_lists_merge/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2. Add Two Numbers (Medium)</li> <li> 445. Add Two Numbers II (Medium)</li> <li> 2816. Double a Number Represented as a Linked List (Medium)</li> <li> 21. Merge Two Sorted Lists (Easy)</li> <li> 369. Plus One Linked List (Medium) \ud83d\udc51</li> <li> 1634. Add Two Polynomials Represented as Linked Lists (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/linked_lists_merge/#2-add-two-numbers","title":"2. Add Two Numbers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, math, recursion</p> </li> <li>Represent the sum of two numbers as a linked list.</li> </ul> 2. Add Two Numbers - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef addTwoNumbers(\n    l1: Optional[ListNode], l2: Optional[ListNode]\n) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n    carry = 0\n\n    while l1 or l2:\n        v1 = l1.val if l1 else 0\n        v2 = l2.val if l2 else 0\n\n        carry, val = divmod(v1 + v2 + carry, 10)\n        cur.next = ListNode(val)\n        cur = cur.next\n\n        if l1:\n            l1 = l1.next\n        if l2:\n            l2 = l2.next\n\n    if carry:\n        cur.next = ListNode(val=carry)\n\n    return dummy.next\n\n\nl1 = ListNode.create([2, 4, 3])\nl2 = ListNode.create([5, 6, 4])\nprint(addTwoNumbers(l1, l2))  # 7 -&gt; 0 -&gt; 8\n</code></pre> 2. Add Two Numbers - C++ Solution<pre><code>struct ListNode {\n    int val;\n    ListNode* next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode* next) : val(x), next(next) {}\n};\n\nclass Solution {\n   public:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode dummy;\n        ListNode* cur = &amp;dummy;\n        int carry = 0;\n\n        while (l1 || l2 || carry) {\n            if (l1) {\n                carry += l1-&gt;val;\n                l1 = l1-&gt;next;\n            }\n            if (l2) {\n                carry += l2-&gt;val;\n                l2 = l2-&gt;next;\n            }\n            cur-&gt;next = new ListNode(carry % 10);\n            cur = cur-&gt;next;\n            carry /= 10;\n        }\n        return dummy.next;\n    }\n};\n</code></pre>"},{"location":"content/endlesscheng/linked_lists_merge/#445-add-two-numbers-ii","title":"445. Add Two Numbers II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, math, stack</p> </li> </ul>"},{"location":"content/endlesscheng/linked_lists_merge/#2816-double-a-number-represented-as-a-linked-list","title":"2816. Double a Number Represented as a Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, math, stack</p> </li> <li>Given a number represented as a linked list, double it and return the resulting linked list.</li> </ul> 2816. Double a Number Represented as a Linked List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\ndef doubleIt(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n\n    def twice(node):\n        if not node:\n            return 0\n        doubled_value = node.val * 2 + twice(node.next)\n        node.val = doubled_value % 10\n        return doubled_value // 10\n\n    carry = twice(head)\n\n    if carry:\n        head = ListNode(val=carry, next=head)\n\n    return head\n\n\nhead = ListNode.create([1, 2, 3, 4])\nprint(head)\n# 1 -&gt; 2 -&gt; 3 -&gt; 4\nprint(doubleIt(head))\n# 2 -&gt; 4 -&gt; 6 -&gt; 8\n</code></pre>"},{"location":"content/endlesscheng/linked_lists_merge/#21-merge-two-sorted-lists","title":"21. Merge Two Sorted Lists","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: linked list, recursion</p> </li> <li>Merge the two lists into one sorted list.</li> </ul> 21. Merge Two Sorted Lists - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef mergeTwoLists(\n    list1: Optional[ListNode], list2: Optional[ListNode]\n) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    while list1 and list2:\n        if list1.val &lt; list2.val:\n            cur.next = list1\n            list1 = list1.next\n        else:\n            cur.next = list2\n            list2 = list2.next\n        cur = cur.next\n\n    if list1:\n        cur.next = list1\n    elif list2:\n        cur.next = list2\n\n    return dummy.next\n\n\nlist1 = ListNode.create([1, 2, 4])\nlist2 = ListNode.create([1, 3, 4])\nprint(mergeTwoLists(list1, list2))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4\n</code></pre> 21. Merge Two Sorted Lists - C++ Solution<pre><code>struct ListNode {\n    int val;\n    ListNode* next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode* next) : val(x), next(next) {}\n};\n\nclass Solution {\n   public:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        ListNode dummy;\n        ListNode* cur = &amp;dummy;\n\n        while (list1 &amp;&amp; list2) {\n            if (list1-&gt;val &lt; list2-&gt;val) {\n                cur-&gt;next = list1;\n                list1 = list1-&gt;next;\n            } else {\n                cur-&gt;next = list2;\n                list2 = list2-&gt;next;\n            }\n            cur = cur-&gt;next;\n        }\n\n        cur-&gt;next = list1 ? list1 : list2;\n\n        return dummy.next;\n    }\n};\n</code></pre>"},{"location":"content/endlesscheng/linked_lists_merge/#369-plus-one-linked-list","title":"369. Plus One Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, math</p> </li> </ul>"},{"location":"content/endlesscheng/linked_lists_merge/#1634-add-two-polynomials-represented-as-linked-lists","title":"1634. Add Two Polynomials Represented as Linked Lists","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, math, two pointers</p> </li> </ul>"},{"location":"content/endlesscheng/manhattan_distance/","title":"Manhattan Distance","text":""},{"location":"content/endlesscheng/manhattan_distance/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3443. Maximum Manhattan Distance After K Changes (Medium)</li> <li> 1131. Maximum of Absolute Value Expression (Medium)</li> <li> 3102. Minimize Manhattan Distances (Hard)</li> <li> 1330. Reverse Subarray To Maximize Array Value (Hard)</li> <li> 1956. Minimum Time For K Virus Variants to Spread (Hard) \ud83d\udc51</li> <li> 2613. Beautiful Pairs (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/manhattan_distance/#3443-maximum-manhattan-distance-after-k-changes","title":"3443. Maximum Manhattan Distance After K Changes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, math, string, counting</p> </li> </ul>"},{"location":"content/endlesscheng/manhattan_distance/#1131-maximum-of-absolute-value-expression","title":"1131. Maximum of Absolute Value Expression","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math</p> </li> </ul>"},{"location":"content/endlesscheng/manhattan_distance/#3102-minimize-manhattan-distances","title":"3102. Minimize Manhattan Distances","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, geometry, sorting, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/manhattan_distance/#1330-reverse-subarray-to-maximize-array-value","title":"1330. Reverse Subarray To Maximize Array Value","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/manhattan_distance/#1956-minimum-time-for-k-virus-variants-to-spread","title":"1956. Minimum Time For K Virus Variants to Spread","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, binary search, geometry, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/manhattan_distance/#2613-beautiful-pairs","title":"2613. Beautiful Pairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, divide and conquer, geometry, sorting, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/math_greedy_basics/","title":"Math Greedy Basics","text":""},{"location":"content/endlesscheng/math_greedy_basics/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2160. Minimum Sum of Four Digit Number After Splitting Digits (Easy)</li> <li> 2578. Split With Minimum Sum (Easy)</li> <li> 2244. Minimum Rounds to Complete All Tasks (Medium)</li> <li> 2870. Minimum Number of Operations to Make Array Empty (Medium)</li> <li> 1217. Minimum Cost to Move Chips to The Same Position (Easy)</li> <li> 3091. Apply Operations to Make Sum of Array Greater Than or Equal to k (Medium)</li> <li> 397. Integer Replacement (Medium)</li> </ul>"},{"location":"content/endlesscheng/math_greedy_basics/#2160-minimum-sum-of-four-digit-number-after-splitting-digits","title":"2160. Minimum Sum of Four Digit Number After Splitting Digits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/math_greedy_basics/#2578-split-with-minimum-sum","title":"2578. Split With Minimum Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/math_greedy_basics/#2244-minimum-rounds-to-complete-all-tasks","title":"2244. Minimum Rounds to Complete All Tasks","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, greedy, counting</p> </li> </ul>"},{"location":"content/endlesscheng/math_greedy_basics/#2870-minimum-number-of-operations-to-make-array-empty","title":"2870. Minimum Number of Operations to Make Array Empty","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, greedy, counting</p> </li> </ul>"},{"location":"content/endlesscheng/math_greedy_basics/#1217-minimum-cost-to-move-chips-to-the-same-position","title":"1217. Minimum Cost to Move Chips to The Same Position","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, math, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/math_greedy_basics/#3091-apply-operations-to-make-sum-of-array-greater-than-or-equal-to-k","title":"3091. Apply Operations to Make Sum of Array Greater Than or Equal to k","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, greedy, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/math_greedy_basics/#397-integer-replacement","title":"397. Integer Replacement","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming, greedy, bit manipulation, memoization</p> </li> </ul>"},{"location":"content/endlesscheng/math_others/","title":"Math Others","text":""},{"location":"content/endlesscheng/math_others/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1523. Count Odd Numbers in an Interval Range (Easy)</li> <li> 2829. Determine the Minimum Sum of a k-avoiding Array (Medium)</li> <li> 2579. Count Total Number of Colored Cells (Medium)</li> <li> 2834. Find the Minimum Possible Sum of a Beautiful Array (Medium)</li> <li> 1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K (Medium)</li> <li> 319. Bulb Switcher (Medium)</li> <li> 1780. Check if Number is a Sum of Powers of Three (Medium)</li> <li> 3091. Apply Operations to Make Sum of Array Greater Than or Equal to k (Medium)</li> <li> 2310. Sum of Numbers With Units Digit K (Medium)</li> <li> 2844. Minimum Operations to Make a Special Number (Medium)</li> <li> 2541. Minimum Operations to Make Array Equal II (Medium)</li> <li> 2195. Append K Integers With Minimal Sum (Medium)</li> <li> 2457. Minimum Addition to Make Integer Beautiful (Medium)</li> <li> 1017. Convert to Base -2 (Medium)</li> <li> 1954. Minimum Garden Perimeter to Collect Enough Apples (Medium)</li> <li> 1073. Adding Two Negabinary Numbers (Medium)</li> <li> 1823. Find the Winner of the Circular Game (Medium)</li> <li> 166. Fraction to Recurring Decimal (Medium)</li> <li> 3012. Minimize Length of Array Using Operations (Medium)</li> <li> 483. Smallest Good Base (Hard)</li> <li> 972. Equal Rational Numbers (Hard)</li> <li> 1862. Sum of Floored Pairs (Hard)</li> <li> 1739. Building Boxes (Hard)</li> <li> 2443. Sum of Number and Its Reverse (Medium)</li> <li> 1806. Minimum Number of Operations to Reinitialize a Permutation (Medium)</li> <li> 458. Poor Pigs (Hard)</li> <li> 60. Permutation Sequence (Hard)</li> <li> 2117. Abbreviating the Product of a Range (Hard)</li> <li> 660. Remove 9 (Hard) \ud83d\udc51</li> <li> 2979. Most Expensive Item That Can Not Be Bought (Medium) \ud83d\udc51</li> <li> 2647. Color the Triangle Red (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/math_others/#1523-count-odd-numbers-in-an-interval-range","title":"1523. Count Odd Numbers in an Interval Range","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math</p> </li> </ul>"},{"location":"content/endlesscheng/math_others/#2829-determine-the-minimum-sum-of-a-k-avoiding-array","title":"2829. Determine the Minimum Sum of a k-avoiding Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, greedy 2829. Determine the Minimum Sum of a k-avoiding Array - Python Solution<pre><code>def minimumSum(n: int, k: int) -&gt; int:\n    m = min(k // 2, n)\n    return (m * (m + 1) + (k * 2 + n - m - 1) * (n - m)) // 2\n\n\nif __name__ == \"__main__\":\n    n = 5\n    k = 4\n    print(minimumSum(n, k))  # 18\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/math_others/#2579-count-total-number-of-colored-cells","title":"2579. Count Total Number of Colored Cells","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math</p> </li> </ul>"},{"location":"content/endlesscheng/math_others/#2834-find-the-minimum-possible-sum-of-a-beautiful-array","title":"2834. Find the Minimum Possible Sum of a Beautiful Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/math_others/#1414-find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k","title":"1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/math_others/#319-bulb-switcher","title":"319. Bulb Switcher","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, brainteaser</p> </li> </ul>"},{"location":"content/endlesscheng/math_others/#1780-check-if-number-is-a-sum-of-powers-of-three","title":"1780. Check if Number is a Sum of Powers of Three","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math</p> </li> </ul>"},{"location":"content/endlesscheng/math_others/#3091-apply-operations-to-make-sum-of-array-greater-than-or-equal-to-k","title":"3091. Apply Operations to Make Sum of Array Greater Than or Equal to k","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, greedy, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/math_others/#2310-sum-of-numbers-with-units-digit-k","title":"2310. Sum of Numbers With Units Digit K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, greedy, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/math_others/#2844-minimum-operations-to-make-a-special-number","title":"2844. Minimum Operations to Make a Special Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, string, greedy, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/math_others/#2541-minimum-operations-to-make-array-equal-ii","title":"2541. Minimum Operations to Make Array Equal II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/math_others/#2195-append-k-integers-with-minimal-sum","title":"2195. Append K Integers With Minimal Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/math_others/#2457-minimum-addition-to-make-integer-beautiful","title":"2457. Minimum Addition to Make Integer Beautiful","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/math_others/#1017-convert-to-base-2","title":"1017. Convert to Base -2","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math</p> </li> </ul>"},{"location":"content/endlesscheng/math_others/#1954-minimum-garden-perimeter-to-collect-enough-apples","title":"1954. Minimum Garden Perimeter to Collect Enough Apples","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, binary search</p> </li> </ul>"},{"location":"content/endlesscheng/math_others/#1073-adding-two-negabinary-numbers","title":"1073. Adding Two Negabinary Numbers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math</p> </li> </ul>"},{"location":"content/endlesscheng/math_others/#1823-find-the-winner-of-the-circular-game","title":"1823. Find the Winner of the Circular Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, recursion, queue, simulation</p> </li> </ul>"},{"location":"content/endlesscheng/math_others/#166-fraction-to-recurring-decimal","title":"166. Fraction to Recurring Decimal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, math, string 166. Fraction to Recurring Decimal - Python Solution<pre><code># Math\ndef fractionToDecimal(numerator: int, denominator: int) -&gt; str:\n    if numerator == 0:\n        return \"0\"\n\n    res = []\n\n    if (numerator &lt; 0) ^ (denominator &lt; 0):\n        res.append(\"-\")\n\n    numerator, denominator = abs(numerator), abs(denominator)\n\n    # Integer part\n    res.append(str(numerator // denominator))\n    remainder = numerator % denominator\n\n    if remainder == 0:\n        return \"\".join(res)\n\n    res.append(\".\")\n\n    # Dictionary to store remainders and their corresponding indices\n    remainder_map = {}\n\n    while remainder != 0:\n        if remainder in remainder_map:\n            res.insert(remainder_map[remainder], \"(\")\n            res.append(\")\")\n            break\n\n        remainder_map[remainder] = len(res)\n        remainder *= 10\n        res.append(str(remainder // denominator))\n        remainder %= denominator\n\n    return \"\".join(res)\n\n\nnumerator = 4\ndenominator = 333\nprint(fractionToDecimal(numerator, denominator))  # 0.(012)\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/math_others/#3012-minimize-length-of-array-using-operations","title":"3012. Minimize Length of Array Using Operations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, greedy, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/math_others/#483-smallest-good-base","title":"483. Smallest Good Base","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, binary search</p> </li> </ul>"},{"location":"content/endlesscheng/math_others/#972-equal-rational-numbers","title":"972. Equal Rational Numbers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, string</p> </li> </ul>"},{"location":"content/endlesscheng/math_others/#1862-sum-of-floored-pairs","title":"1862. Sum of Floored Pairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, binary search, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/math_others/#1739-building-boxes","title":"1739. Building Boxes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, binary search, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/math_others/#2443-sum-of-number-and-its-reverse","title":"2443. Sum of Number and Its Reverse","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/math_others/#1806-minimum-number-of-operations-to-reinitialize-a-permutation","title":"1806. Minimum Number of Operations to Reinitialize a Permutation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, simulation</p> </li> </ul>"},{"location":"content/endlesscheng/math_others/#458-poor-pigs","title":"458. Poor Pigs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, dynamic programming, combinatorics</p> </li> </ul>"},{"location":"content/endlesscheng/math_others/#60-permutation-sequence","title":"60. Permutation Sequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, recursion</p> </li> </ul>"},{"location":"content/endlesscheng/math_others/#2117-abbreviating-the-product-of-a-range","title":"2117. Abbreviating the Product of a Range","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math</p> </li> </ul>"},{"location":"content/endlesscheng/math_others/#660-remove-9","title":"660. Remove 9","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math</p> </li> </ul>"},{"location":"content/endlesscheng/math_others/#2979-most-expensive-item-that-can-not-be-bought","title":"2979. Most Expensive Item That Can Not Be Bought","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/math_others/#2647-color-the-triangle-red","title":"2647. Color the Triangle Red","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math</p> </li> </ul>"},{"location":"content/endlesscheng/median_greedy/","title":"Median Greedy","text":""},{"location":"content/endlesscheng/median_greedy/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 462. Minimum Moves to Equal Array Elements II (Medium)</li> <li> 2033. Minimum Operations to Make a Uni-Value Grid (Medium)</li> <li> 2448. Minimum Cost to Make Array Equal (Hard)</li> <li> 2607. Make K-Subarray Sums Equal (Medium)</li> <li> 2967. Minimum Cost to Make Array Equalindromic (Medium)</li> <li> 1478. Allocate Mailboxes (Hard)</li> <li> 2968. Apply Operations to Maximize Frequency Score (Hard)</li> <li> 1703. Minimum Adjacent Swaps for K Consecutive Ones (Hard)</li> <li> 3086. Minimum Moves to Pick K Ones (Hard)</li> <li> 3441. Minimum Cost Good Caption (Hard)</li> <li> 296. Best Meeting Point (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/median_greedy/#462-minimum-moves-to-equal-array-elements-ii","title":"462. Minimum Moves to Equal Array Elements II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/median_greedy/#2033-minimum-operations-to-make-a-uni-value-grid","title":"2033. Minimum Operations to Make a Uni-Value Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, sorting, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/median_greedy/#2448-minimum-cost-to-make-array-equal","title":"2448. Minimum Cost to Make Array Equal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, greedy, sorting, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/median_greedy/#2607-make-k-subarray-sums-equal","title":"2607. Make K-Subarray Sums Equal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, greedy, sorting, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/median_greedy/#2967-minimum-cost-to-make-array-equalindromic","title":"2967. Minimum Cost to Make Array Equalindromic","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, binary search, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/median_greedy/#1478-allocate-mailboxes","title":"1478. Allocate Mailboxes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, dynamic programming, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/median_greedy/#2968-apply-operations-to-maximize-frequency-score","title":"2968. Apply Operations to Maximize Frequency Score","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, sliding window, sorting, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/median_greedy/#1703-minimum-adjacent-swaps-for-k-consecutive-ones","title":"1703. Minimum Adjacent Swaps for K Consecutive Ones","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sliding window, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/median_greedy/#3086-minimum-moves-to-pick-k-ones","title":"3086. Minimum Moves to Pick K Ones","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sliding window, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/median_greedy/#3441-minimum-cost-good-caption","title":"3441. Minimum Cost Good Caption","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/median_greedy/#296-best-meeting-point","title":"296. Best Meeting Point","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, sorting, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/merge_intervals/","title":"Merge Intervals","text":""},{"location":"content/endlesscheng/merge_intervals/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 56. Merge Intervals (Medium)</li> <li> 57. Insert Interval (Medium)</li> <li> 55. Jump Game (Medium)</li> <li> 763. Partition Labels (Medium)</li> <li> 3169. Count Days Without Meetings (Medium)</li> <li> 2580. Count Ways to Group Overlapping Ranges (Medium)</li> <li> 3394. Check if Grid can be Cut into Sections (Medium)</li> <li> 2963. Count the Number of Good Partitions (Hard)</li> <li> 2584. Split the Array to Make Coprime Products (Hard)</li> <li> 616. Add Bold Tag in String (Medium) \ud83d\udc51</li> <li> 758. Bold Words in String (Medium) \ud83d\udc51</li> <li> 3323. Minimize Connected Groups by Inserting Interval (Medium) \ud83d\udc51</li> <li> 759. Employee Free Time (Hard) \ud83d\udc51</li> <li> 2655. Find Maximal Uncovered Ranges (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/merge_intervals/#56-merge-intervals","title":"56. Merge Intervals","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sorting</p> </li> <li>Merge all overlapping intervals.</li> </ul> 56. Merge Intervals - Python Solution<pre><code>from typing import List\n\n\n# Intervals\ndef merge(intervals: List[List[int]]) -&gt; List[List[int]]:\n    n = len(intervals)\n    if n &lt;= 1:\n        return intervals\n\n    intervals.sort(key=lambda x: x[0])\n    res = [intervals[0]]\n\n    for i in range(1, n):\n        if intervals[i][0] &lt;= res[-1][1]:\n            res[-1][1] = max(res[-1][1], intervals[i][1])\n        else:\n            res.append(intervals[i])\n\n    return res\n\n\nprint(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))\n# [[1, 6], [8, 10], [15, 18]]\n</code></pre> 56. Merge Intervals - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// Interval\nvector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {\n    sort(intervals.begin(), intervals.end());\n    vector&lt;vector&lt;int&gt;&gt; res;\n\n    for (auto&amp; range : intervals) {\n        if (!res.empty() &amp;&amp; range[0] &lt;= res.back()[1]) {\n            res.back()[1] = max(res.back()[1], range[1]);\n        } else {\n            res.emplace_back(range);\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;vector&lt;int&gt;&gt; intervals = {{1, 3}, {2, 6}, {8, 10}, {15, 18}};\n    vector&lt;vector&lt;int&gt;&gt; res = merge(intervals);\n    for (auto&amp; range : res) {\n        cout &lt;&lt; range[0] &lt;&lt; \", \" &lt;&lt; range[1] &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"content/endlesscheng/merge_intervals/#57-insert-interval","title":"57. Insert Interval","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array 57. Insert Interval - Python Solution<pre><code>from typing import List\n\n\n# Interval\ndef insert(\n    intervals: List[List[int]], newInterval: List[int]\n) -&gt; List[List[int]]:\n    n = len(intervals)\n\n    if n == 0:\n        return [newInterval]\n\n    if newInterval[1] &lt; intervals[0][0]:\n        return [newInterval] + intervals\n\n    if newInterval[0] &gt; intervals[-1][1]:\n        return intervals + [newInterval]\n\n    i = 0\n    result = []\n\n    while i &lt; n and intervals[i][1] &lt; newInterval[0]:\n        result.append(intervals[i])\n        i += 1\n\n    while i &lt; n and intervals[i][0] &lt;= newInterval[1]:\n        newInterval[0] = min(newInterval[0], intervals[i][0])\n        newInterval[1] = max(newInterval[1], intervals[i][1])\n        i += 1\n\n    result.append(newInterval)\n\n    while i &lt; n:\n        result.append(intervals[i])\n        i += 1\n\n    return result\n\n\nintervals = [[1, 3], [6, 9]]\nnewInterval = [2, 5]\nprint(insert(intervals, newInterval))  # [[1, 5], [6, 9]]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/merge_intervals/#55-jump-game","title":"55. Jump Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> <li>Return <code>True</code> if you can reach the last index, otherwise <code>False</code>.</li> </ul> 55. Jump Game - Python Solution<pre><code>from typing import List\n\n\n# Greedy - Interval\ndef canJump(nums: List[int]) -&gt; bool:\n    n = len(nums)\n    reach = 0\n    i = 0\n\n    while reach &gt;= i:\n        if reach &gt;= n - 1:\n            return True\n        reach = max(reach, i + nums[i])\n        i += 1\n\n    return False\n\n\nif __name__ == \"__main__\":\n    assert canJump([2, 3, 1, 1, 4]) is True\n    assert canJump([3, 2, 1, 0, 4]) is False\n</code></pre> 55. Jump Game - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool canJump(vector&lt;int&gt;&amp; nums) {\n        int canReach = 0;\n        int n = nums.size();\n\n        for (int i = 0; i &lt; n; i++) {\n            if (i &gt; canReach) return false;\n            canReach = max(canReach, i + nums[i]);\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution obj;\n    vector&lt;int&gt; nums = {2, 3, 1, 1, 4};\n    cout &lt;&lt; obj.canJump(nums) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/endlesscheng/merge_intervals/#763-partition-labels","title":"763. Partition Labels","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, two pointers, string, greedy 763. Partition Labels - Python Solution<pre><code>from typing import List\n\n\n# 1. Hashmap\ndef partitionLabels1(s: str) -&gt; List[int]:\n    hashmap = {}\n\n    for i, j in enumerate(s):\n        if j not in hashmap:\n            hashmap[j] = [i, i]\n        else:\n            hashmap[j][1] = i\n\n    intervals = list(hashmap.values())\n    intervals.sort(key=lambda x: x[0])\n\n    if len(intervals) &lt; 2:\n        return len(intervals)\n\n    res = []\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &lt; intervals[i - 1][1]:\n            intervals[i][1] = max(intervals[i][1], intervals[i - 1][1])\n        else:\n            res.append(intervals[i][0])\n\n    res.append(intervals[-1][1] + 1)\n\n    if len(res) == 1:\n        return res\n    else:\n        for i in range(len(res) - 1, 0, -1):\n            res[i] -= res[i - 1]\n        return res\n\n\n# Single Pass Partitioning\ndef partitionLabels2(s: str) -&gt; List[int]:\n    last = {c: i for i, c in enumerate(s)}\n    res = []\n    start, end = 0, 0\n\n    for i, c in enumerate(s):\n        end = max(end, last[c])\n        if end == i:\n            res.append(end - start + 1)\n            start = i + 1\n\n    return res\n\n\nprint(partitionLabels1(\"abaccd\"))  # [3, 2, 1]\nprint(partitionLabels2(\"abaccd\"))  # [3, 2, 1]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/merge_intervals/#3169-count-days-without-meetings","title":"3169. Count Days Without Meetings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/merge_intervals/#2580-count-ways-to-group-overlapping-ranges","title":"2580. Count Ways to Group Overlapping Ranges","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/merge_intervals/#3394-check-if-grid-can-be-cut-into-sections","title":"3394. Check if Grid can be Cut into Sections","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/merge_intervals/#2963-count-the-number-of-good-partitions","title":"2963. Count the Number of Good Partitions","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, math, combinatorics</p> </li> </ul>"},{"location":"content/endlesscheng/merge_intervals/#2584-split-the-array-to-make-coprime-products","title":"2584. Split the Array to Make Coprime Products","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, math, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/merge_intervals/#616-add-bold-tag-in-string","title":"616. Add Bold Tag in String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, trie, string matching</p> </li> </ul>"},{"location":"content/endlesscheng/merge_intervals/#758-bold-words-in-string","title":"758. Bold Words in String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, trie, string matching</p> </li> </ul>"},{"location":"content/endlesscheng/merge_intervals/#3323-minimize-connected-groups-by-inserting-interval","title":"3323. Minimize Connected Groups by Inserting Interval","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sliding window, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/merge_intervals/#759-employee-free-time","title":"759. Employee Free Time","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, sorting, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/merge_intervals/#2655-find-maximal-uncovered-ranges","title":"2655. Find Maximal Uncovered Ranges","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/minimum_spanning_tree/","title":"Minimum Spanning Tree","text":""},{"location":"content/endlesscheng/minimum_spanning_tree/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1584. Min Cost to Connect All Points (Medium)</li> <li> 1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree (Hard)</li> <li> 1135. Connecting Cities With Minimum Cost (Medium) \ud83d\udc51</li> <li> 1168. Optimize Water Distribution in a Village (Hard) \ud83d\udc51</li> <li> 3219. Minimum Cost for Cutting Cake II (Hard)</li> </ul>"},{"location":"content/endlesscheng/minimum_spanning_tree/#1584-min-cost-to-connect-all-points","title":"1584. Min Cost to Connect All Points","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, union find, graph, minimum spanning tree</p> </li> <li>Tree: a connected acyclic graph</li> <li>Spanning Tree: a subgraph that is a tree and connects all the vertices together</li> <li>Minimum Spanning Tree (MST): a spanning tree with the minimum possible sum of edge weights</li> <li>Prim's Algorithm</li> <li>Data Structure: Heap</li> <li>Time Complexity: O(E * logV)</li> <li>Space Complexity: O(V + E)</li> <li>Kruskal's Algorithm</li> <li>Union Find</li> <li>Time Complexity: O(E * logV)</li> <li>Space Complexity: O(V + E)</li> </ul> 1584. Min Cost to Connect All Points - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minCostConnectPointsPrim(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    graph = defaultdict(list)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            dist = abs(x1 - x2) + abs(y1 - y2)\n            graph[i].append((dist, j))\n            graph[j].append((dist, i))\n\n    cost = 0\n    heap = [(0, 0)]  # (cost, node)\n    visited = set()\n\n    while heap:\n        d1, n1 = heapq.heappop(heap)\n        if n1 in visited:\n            continue\n        visited.add(n1)\n        cost += d1\n\n        for d2, n2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (d2, n2))\n\n    return cost\n\n\n# Kruskal\ndef minCostConnectPointsKruskal(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    par = {i: i for i in range(n)}\n    rank = {i: 0 for i in range(n)}\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 == p2:\n            return False\n\n        if rank[p1] &gt; rank[p2]:\n            par[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n        else:\n            par[p2] = p1\n            rank[p1] += 1\n\n        return True\n\n    heap = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            dist = abs(x1 - x2) + abs(y1 - y2)\n            heapq.heappush(heap, (dist, i, j))\n\n    cost = 0\n    while heap:\n        d, n1, n2 = heapq.heappop(heap)\n        if union(n1, n2):\n            cost += d\n\n    return cost\n\n\nif __name__ == \"__main__\":\n    points = [[0, 0], [2, 2], [3, 10], [5, 2], [7, 0]]\n    print(minCostConnectPointsPrim(points))  # 20\n    print(minCostConnectPointsKruskal(points))  # 20\n</code></pre>"},{"location":"content/endlesscheng/minimum_spanning_tree/#1489-find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree","title":"1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: union find, graph, sorting, minimum spanning tree, strongly connected component 1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree - Python Solution<pre><code>from typing import List\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [1 for _ in range(n)]\n        self.part = n\n\n    def find(self, n):\n        p = self.parent[n]\n        while p != self.parent[p]:\n            self.parent[p] = self.parent[self.parent[p]]\n            p = self.parent[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return False\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.parent[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.parent[p1] = p2\n        else:\n            self.parent[p2] = p1\n            self.rank[p1] += 1\n\n        self.part -= 1\n        return True\n\n\n# Kruskal\ndef findCriticalAndPseudoCriticalEdges(\n    n: int, edges: List[List[int]]\n) -&gt; List[List[int]]:\n    m = len(edges)\n\n    # Add index to edges\n    lst = list(range(m))\n    lst.sort(key=lambda x: edges[x][2])\n\n    # Calculate minimum cost\n    min_cost = 0\n    uf = UnionFind(n)\n    for i in lst:\n        x, y, cost = edges[i]\n        if uf.union(x, y):\n            min_cost += cost\n\n    # Calculate key edges\n    key = set()\n    for i in lst:\n        cur_cost = 0\n        uf = UnionFind(n)\n        for j in lst:\n            if j != i:\n                x, y, cost = edges[j]\n                if uf.union(x, y):\n                    cur_cost += cost\n        if cur_cost &gt; min_cost or uf.part != 1:\n            key.add(i)\n\n    # Calculate fake edges\n    fake = set()\n    for i in lst:\n        if i not in key:\n            cur_cost = edges[i][2]\n            uf = UnionFind(n)\n            uf.union(edges[i][0], edges[i][1])\n            for j in lst:\n                x, y, cost = edges[j]\n                if uf.union(x, y):\n                    cur_cost += cost\n            if cur_cost == min_cost and uf.part == 1:\n                fake.add(i)\n\n    return [sorted(list(key)), sorted(list(fake))]\n\n\nn = 5\nedges = [\n    [0, 1, 1],\n    [1, 2, 1],\n    [2, 3, 2],\n    [0, 3, 2],\n    [0, 4, 3],\n    [3, 4, 3],\n    [1, 4, 6],\n]\nprint(findCriticalAndPseudoCriticalEdges(n, edges))\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/minimum_spanning_tree/#1135-connecting-cities-with-minimum-cost","title":"1135. Connecting Cities With Minimum Cost","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: union find, graph, heap priority queue, minimum spanning tree 1135. Connecting Cities With Minimum Cost - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minimumCost(n: int, connections: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, c in connections:\n        graph[u].append((c, v))\n        graph[v].append((c, u))\n\n    cost = 0\n    heap = [(0, 1)]  # (cost, node)\n    visited = set()\n\n    while heap:\n        c1, n1 = heapq.heappop(heap)\n\n        if n1 in visited:\n            continue\n\n        visited.add(n1)\n\n        cost += c1\n\n        for c2, n2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (c2, n2))\n\n    return cost if len(visited) == n else -1\n\n\nn = 3\nconnections = [[1, 2, 5], [1, 3, 6], [2, 3, 1]]\nprint(minimumCost(n, connections))  # 6\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/minimum_spanning_tree/#1168-optimize-water-distribution-in-a-village","title":"1168. Optimize Water Distribution in a Village","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: union find, graph, heap priority queue, minimum spanning tree</p> </li> <li> <p></p> </li> <li> <p></p> </li> </ul> 1168. Optimize Water Distribution in a Village - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minCostToSupplyWater1(\n    n: int, wells: List[int], pipes: List[List[int]]\n) -&gt; int:\n    graph = defaultdict(list)\n\n    for h1, h2, cost in pipes:\n        graph[h1].append((h2, cost))\n        graph[h2].append((h1, cost))\n\n    # Add the cost of the wells to the graph (house 0)\n    for i in range(n):\n        graph[0].append((i + 1, wells[i]))\n        graph[i + 1].append((0, wells[i]))\n\n    visited = set([0])\n    heap = [(cost, dest) for dest, cost in graph[0]]\n    heapq.heapify(heap)\n\n    cost = 0\n\n    while heap:\n        c1, n1 = heapq.heappop(heap)\n        if n1 in visited:\n            continue\n        visited.add(n1)\n        cost += c1\n\n        for n2, c2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (c2, n2))\n\n    return cost\n\n\n# Kruskal\ndef minCostToSupplyWater2(\n    n: int, wells: List[int], pipes: List[List[int]]\n) -&gt; int:\n    par = list(range(n + 1))\n    rank = [0] * (n + 1)\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            if rank[p1] &lt; rank[p2]:\n                par[p1] = p2\n            elif rank[p1] &gt; rank[p2]:\n                par[p2] = p1\n            else:\n                par[p1] = p2\n                rank[p2] += 1\n            return True\n        return False\n\n    graph = [(c, 0, i + 1) for i, c in enumerate(wells)]\n    for h1, h2, c in pipes:\n        graph.append((c, h1, h2))\n\n    graph.sort()\n\n    cost = 0\n\n    for c, h1, h2 in graph:\n        if union(h1, h2):\n            cost += c\n\n    return cost\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |    Prim    | O((V + E) log V) | O(V + E)|\n# |  Kruskal   |     O(E log E)   | O(V + E)|\n# |------------|------------------|---------|\n\n\nn = 3\nwells = [1, 2, 2]\npipes = [[1, 2, 1], [2, 3, 1]]\nprint(minCostToSupplyWater1(n, wells, pipes))  # 3\nprint(minCostToSupplyWater2(n, wells, pipes))  # 3\n</code></pre>"},{"location":"content/endlesscheng/minimum_spanning_tree/#3219-minimum-cost-for-cutting-cake-ii","title":"3219. Minimum Cost for Cutting Cake II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/modular_arithmetic/","title":"Modular Arithmetic","text":""},{"location":"content/endlesscheng/modular_arithmetic/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2453. Destroy Sequential Targets (Medium)</li> <li> 2598. Smallest Missing Non-negative Integer After Operations (Medium)</li> <li> 1590. Make Sum Divisible by P (Medium)</li> </ul>"},{"location":"content/endlesscheng/modular_arithmetic/#2453-destroy-sequential-targets","title":"2453. Destroy Sequential Targets","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, counting</p> </li> </ul>"},{"location":"content/endlesscheng/modular_arithmetic/#2598-smallest-missing-non-negative-integer-after-operations","title":"2598. Smallest Missing Non-negative Integer After Operations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/modular_arithmetic/#1590-make-sum-divisible-by-p","title":"1590. Make Sum Divisible by P","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/monotonic_queue/","title":"Monotonic Queue","text":""},{"location":"content/endlesscheng/monotonic_queue/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 239. Sliding Window Maximum (Hard)</li> <li> 1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit (Medium)</li> <li> 2762. Continuous Subarrays (Medium)</li> <li> 2398. Maximum Number of Robots Within Budget (Hard)</li> <li> 862. Shortest Subarray with Sum at Least K (Hard)</li> <li> 1499. Max Value of Equation (Hard)</li> <li> 2071. Maximum Number of Tasks You Can Assign (Hard)</li> </ul>"},{"location":"content/endlesscheng/monotonic_queue/#239-sliding-window-maximum","title":"239. Sliding Window Maximum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, queue, sliding window, heap priority queue, monotonic queue 239. Sliding Window Maximum - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# Monotonic Queue\ndef maxSlidingWindow(nums: List[int], k: int) -&gt; List[int]:\n    q = deque()\n    res = []\n\n    for i, num in enumerate(nums):\n        if q and q[0] &lt; i - k + 1:\n            q.popleft()\n\n        while q and nums[q[-1]] &lt; num:\n            q.pop()\n\n        q.append(i)\n\n        if i &gt;= k - 1:\n            res.append(nums[q[0]])\n\n    return res\n\n\nnums = [1, 3, -1, -3, 5, 3, 6, 7]\nk = 3\nprint(maxSlidingWindow(nums, k))  # [3, 3, 5, 5, 6, 7]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/monotonic_queue/#1438-longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit","title":"1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, queue, sliding window, heap priority queue, ordered set, monotonic queue</p> </li> </ul>"},{"location":"content/endlesscheng/monotonic_queue/#2762-continuous-subarrays","title":"2762. Continuous Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, queue, sliding window, heap priority queue, ordered set, monotonic queue</p> </li> </ul>"},{"location":"content/endlesscheng/monotonic_queue/#2398-maximum-number-of-robots-within-budget","title":"2398. Maximum Number of Robots Within Budget","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, queue, sliding window, heap priority queue, prefix sum, monotonic queue 2398. Maximum Number of Robots Within Budget - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# Monotonic Queue\ndef maximumRobots(\n    chargeTimes: List[int], runningCosts: List[int], budget: int\n) -&gt; int:\n    ans = sum_cost = left = 0\n    q = deque()\n\n    for right, (time, cost) in enumerate(zip(chargeTimes, runningCosts)):\n        # 1. Add\n        while q and time &gt;= chargeTimes[q[-1]]:\n            q.pop()\n        q.append(right)\n        sum_cost += cost\n\n        # 2. Remove\n        while q and chargeTimes[q[0]] + (right - left + 1) * sum_cost &gt; budget:\n            if q[0] == left:\n                q.popleft()\n            sum_cost -= runningCosts[left]\n            left += 1\n\n        # 3. Update\n        ans = max(ans, right - left + 1)\n    return ans\n\n\nchargeTimes = [3, 6, 1, 3, 4]\nrunningCosts = [2, 1, 3, 4, 5]\nbudget = 25\nprint(maximumRobots(chargeTimes, runningCosts, budget))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/monotonic_queue/#862-shortest-subarray-with-sum-at-least-k","title":"862. Shortest Subarray with Sum at Least K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, queue, sliding window, heap priority queue, prefix sum, monotonic queue 862. Shortest Subarray with Sum at Least K - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# Prefix Sum + Monotonic Queue\ndef shortestSubarray(nums: List[int], k: int) -&gt; int:\n    n = len(nums)\n    ps = [0 for _ in range(n + 1)]\n\n    for i in range(n):\n        ps[i + 1] = ps[i] + nums[i]\n\n    res = float(\"inf\")\n    q = deque()\n\n    for i in range(n + 1):\n        while q and ps[i] - ps[q[0]] &gt;= k:\n            res = min(res, i - q.popleft())\n        while q and ps[i] &lt;= ps[q[-1]]:\n            q.pop()\n        q.append(i)\n\n    return res if res != float(\"inf\") else -1\n\n\nnums = [2, -1, 2]\nk = 3\nprint(shortestSubarray(nums, k))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/monotonic_queue/#1499-max-value-of-equation","title":"1499. Max Value of Equation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, queue, sliding window, heap priority queue, monotonic queue</p> </li> </ul>"},{"location":"content/endlesscheng/monotonic_queue/#2071-maximum-number-of-tasks-you-can-assign","title":"2071. Maximum Number of Tasks You Can Assign","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, greedy, queue, sorting, monotonic queue</p> </li> </ul>"},{"location":"content/endlesscheng/monotonic_queue_optimized_dp/","title":"Monotonic Queue Optimized DP","text":""},{"location":"content/endlesscheng/monotonic_queue_optimized_dp/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2944. Minimum Number of Coins for Fruits (Medium)</li> <li> 1696. Jump Game VI (Medium)</li> <li> 1425. Constrained Subsequence Sum (Hard)</li> <li> 375. Guess Number Higher or Lower II (Medium)</li> <li> 1687. Delivering Boxes from Storage to Ports (Hard)</li> <li> 3117. Minimum Sum of Values by Dividing Array (Hard)</li> <li> 2945. Find Maximum Non-decreasing Array Length (Hard)</li> <li> 2969. Minimum Number of Coins for Fruits II (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/monotonic_queue_optimized_dp/#2944-minimum-number-of-coins-for-fruits","title":"2944. Minimum Number of Coins for Fruits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, queue, heap priority queue, monotonic queue</p> </li> </ul>"},{"location":"content/endlesscheng/monotonic_queue_optimized_dp/#1696-jump-game-vi","title":"1696. Jump Game VI","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, queue, heap priority queue, monotonic queue</p> </li> </ul>"},{"location":"content/endlesscheng/monotonic_queue_optimized_dp/#1425-constrained-subsequence-sum","title":"1425. Constrained Subsequence Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, queue, sliding window, heap priority queue, monotonic queue</p> </li> </ul>"},{"location":"content/endlesscheng/monotonic_queue_optimized_dp/#375-guess-number-higher-or-lower-ii","title":"375. Guess Number Higher or Lower II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, game theory</p> </li> </ul>"},{"location":"content/endlesscheng/monotonic_queue_optimized_dp/#1687-delivering-boxes-from-storage-to-ports","title":"1687. Delivering Boxes from Storage to Ports","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, segment tree, queue, heap priority queue, prefix sum, monotonic queue</p> </li> </ul>"},{"location":"content/endlesscheng/monotonic_queue_optimized_dp/#3117-minimum-sum-of-values-by-dividing-array","title":"3117. Minimum Sum of Values by Dividing Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, dynamic programming, bit manipulation, segment tree, queue</p> </li> </ul>"},{"location":"content/endlesscheng/monotonic_queue_optimized_dp/#2945-find-maximum-non-decreasing-array-length","title":"2945. Find Maximum Non-decreasing Array Length","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, dynamic programming, stack, queue, monotonic stack, monotonic queue</p> </li> </ul>"},{"location":"content/endlesscheng/monotonic_queue_optimized_dp/#2969-minimum-number-of-coins-for-fruits-ii","title":"2969. Minimum Number of Coins for Fruits II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, queue, heap priority queue, monotonic queue</p> </li> </ul>"},{"location":"content/endlesscheng/monotonic_stack/","title":"Monotonic Stack","text":""},{"location":"content/endlesscheng/monotonic_stack/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 739. Daily Temperatures (Medium)</li> <li> 1475. Final Prices With a Special Discount in a Shop (Easy)</li> <li> 496. Next Greater Element I (Easy)</li> <li> 503. Next Greater Element II (Medium)</li> <li> 1019. Next Greater Node In Linked List (Medium)</li> <li> 962. Maximum Width Ramp (Medium)</li> <li> 853. Car Fleet (Medium)</li> <li> 901. Online Stock Span (Medium)</li> <li> 1124. Longest Well-Performing Interval (Medium)</li> <li> 1793. Maximum Score of a Good Subarray (Hard)</li> <li> 456. 132 Pattern (Medium)</li> <li> 3113. Find the Number of Subarrays Where Boundary Elements Are Maximum (Hard)</li> <li> 2866. Beautiful Towers II (Medium)</li> <li> 1944. Number of Visible People in a Queue (Hard)</li> <li> 2454. Next Greater Element IV (Hard)</li> <li> 1130. Minimum Cost Tree From Leaf Values (Medium)</li> <li> 2289. Steps to Make Array Non-decreasing (Medium)</li> <li> 1776. Car Fleet II (Hard)</li> <li> 3221. Maximum Array Hopping Score II (Medium) \ud83d\udc51</li> <li> 1966. Binary Searchable Numbers in an Unsorted Array (Medium) \ud83d\udc51</li> <li> 2832. Maximal Range That Each Element Is Maximum in It (Medium) \ud83d\udc51</li> <li> 2282. Number of People That Can Be Seen in a Grid (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/monotonic_stack/#739-daily-temperatures","title":"739. Daily Temperatures","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, monotonic stack</p> </li> <li>Return an array <code>res</code> such that <code>res[i]</code> is the number of days you have to wait after the <code>ith</code> day to get a warmer temperature.</li> </ul> Index Temp &gt; stack last stack result 0 73 False <code>[ [73, 0] ]</code> 1 - 0 = 1 1 74 True <code>[ [74, 1] ]</code> 2 - 1 = 1 2 75 True <code>[ [75, 2] ]</code> 6 - 2 = 4 3 71 False <code>[ [75, 2], [71, 3] ]</code> 5 - 3 = 2 4 69 False <code>[ [75, 2], [71, 3], [69, 4] ]</code> 5 - 4 = 1 5 72 True <code>[ [75, 2], [72, 5] ]</code> 6 - 5 = 1 6 76 True <code>[ [76, 6] ]</code> 0 7 73 False <code>[[76, 6], [73, 7]]</code> 0 739. Daily Temperatures - Python Solution<pre><code>from typing import List\n\n\n# Monotonic Stack\ndef dailyTemperatures(temperatures: List[int]) -&gt; List[int]:\n    res = [0 for _ in range(len(temperatures))]\n    stack = []  # [temp, index]\n\n    for i, temp in enumerate(temperatures):\n        while stack and temp &gt; stack[-1][0]:\n            _, idx = stack.pop()\n            res[idx] = i - idx\n\n        stack.append([temp, i])\n\n    return res\n\n\nprint(dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73]))\n# [1, 1, 4, 2, 1, 1, 0, 0]\n</code></pre>"},{"location":"content/endlesscheng/monotonic_stack/#1475-final-prices-with-a-special-discount-in-a-shop","title":"1475. Final Prices With a Special Discount in a Shop","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, stack, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/monotonic_stack/#496-next-greater-element-i","title":"496. Next Greater Element I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, stack, monotonic stack 496. Next Greater Element I - Python Solution<pre><code>from typing import List\n\n\n# Monotonic Stack\ndef nextGreaterElement(nums1: List[int], nums2: List[int]) -&gt; List[int]:\n    next_greater = {}\n    stack = []\n    result = []\n\n    for num in nums2:\n        while stack and num &gt; stack[-1]:\n            next_greater[stack.pop()] = num\n        stack.append(num)\n\n    for num in nums1:\n        result.append(next_greater.get(num, -1))\n\n    return result\n\n\nnums1 = [4, 1, 2]\nnums2 = [1, 3, 4, 2]\nprint(nextGreaterElement(nums1, nums2))  # [3, -1, -1]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/monotonic_stack/#503-next-greater-element-ii","title":"503. Next Greater Element II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, monotonic stack 503. Next Greater Element II - Python Solution<pre><code>from typing import List\n\n\n# Monotonic Stack\ndef nextGreaterElements(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    result = [-1] * n\n    stack = []\n\n    for i in range(2 * n):\n        while stack and nums[stack[-1]] &lt; nums[i % n]:\n            result[stack.pop()] = nums[i % n]\n        if i &lt; n:\n            stack.append(i)\n\n    return result\n\n\nnums = [1, 2, 1]\nprint(nextGreaterElements(nums))  # [2, -1, 2]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/monotonic_stack/#1019-next-greater-node-in-linked-list","title":"1019. Next Greater Node In Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, linked list, stack, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/monotonic_stack/#962-maximum-width-ramp","title":"962. Maximum Width Ramp","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, stack, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/monotonic_stack/#853-car-fleet","title":"853. Car Fleet","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, sorting, monotonic stack 853. Car Fleet - Python Solution<pre><code>from typing import List\n\n\n# Stack\ndef carFleet(target: int, position: List[int], speed: List[int]) -&gt; int:\n    cars = sorted(zip(position, speed), reverse=True)\n    stack = []\n\n    for p, s in cars:\n        time = (target - p) / s\n\n        if not stack or time &gt; stack[-1]:\n            stack.append(time)\n\n    return len(stack)\n\n\nprint(carFleet(12, [10, 8, 0, 5, 3], [2, 4, 1, 1, 3]))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/monotonic_stack/#901-online-stock-span","title":"901. Online Stock Span","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: stack, design, monotonic stack, data stream</p> </li> <li>Design a class <code>StockSpanner</code> to return the number of consecutive days (including the current day) the price of the stock has been less than or equal to the current price.</li> </ul> 901. Online Stock Span - Python Solution<pre><code>from typing import List\n\n\n# Monotonic Stack\nclass StockSpanner:\n\n    def __init__(self):\n        self.stack = [(-1, float(\"inf\"))]\n        self.cur_day = -1\n\n    def next(self, price: int) -&gt; int:\n        while price &gt;= self.stack[-1][1]:\n            self.stack.pop()\n        self.cur_day += 1\n        self.stack.append((self.cur_day, price))\n        return self.cur_day - self.stack[-2][0]\n\n\nif __name__ == \"__main__\":\n    ss = StockSpanner()\n    prices = [100, 80, 60, 70, 60, 75, 85]\n    print([ss.next(price) for price in prices])  # [1, 1, 1, 2, 1, 4, 6]\n</code></pre>"},{"location":"content/endlesscheng/monotonic_stack/#1124-longest-well-performing-interval","title":"1124. Longest Well-Performing Interval","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, stack, monotonic stack, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/monotonic_stack/#1793-maximum-score-of-a-good-subarray","title":"1793. Maximum Score of a Good Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, binary search, stack, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/monotonic_stack/#456-132-pattern","title":"456. 132 Pattern","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, stack, monotonic stack, ordered set 456. 132 Pattern - Python Solution<pre><code>from typing import List\n\n\n# Monotonic Stack\ndef find132pattern(nums: List[int]) -&gt; bool:\n    n = len(nums)\n    if n &lt; 3:\n        return False\n\n    stack = []\n    second_max = float(\"-inf\")\n\n    for i in range(n - 1, -1, -1):\n        if nums[i] &lt; second_max:\n            return True\n\n        while stack and stack[-1] &lt; nums[i]:\n            second_max = stack.pop()\n\n        stack.append(nums[i])\n\n    return False\n\n\nnums = [-1, 3, 2, 0]\nprint(find132pattern(nums))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/monotonic_stack/#3113-find-the-number-of-subarrays-where-boundary-elements-are-maximum","title":"3113. Find the Number of Subarrays Where Boundary Elements Are Maximum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, stack, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/monotonic_stack/#2866-beautiful-towers-ii","title":"2866. Beautiful Towers II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/monotonic_stack/#1944-number-of-visible-people-in-a-queue","title":"1944. Number of Visible People in a Queue","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, stack, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/monotonic_stack/#2454-next-greater-element-iv","title":"2454. Next Greater Element IV","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, stack, sorting, heap priority queue, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/monotonic_stack/#1130-minimum-cost-tree-from-leaf-values","title":"1130. Minimum Cost Tree From Leaf Values","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, stack, greedy, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/monotonic_stack/#2289-steps-to-make-array-non-decreasing","title":"2289. Steps to Make Array Non-decreasing","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, linked list, stack, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/monotonic_stack/#1776-car-fleet-ii","title":"1776. Car Fleet II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, stack, heap priority queue, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/monotonic_stack/#3221-maximum-array-hopping-score-ii","title":"3221. Maximum Array Hopping Score II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, greedy, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/monotonic_stack/#1966-binary-searchable-numbers-in-an-unsorted-array","title":"1966. Binary Searchable Numbers in an Unsorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"content/endlesscheng/monotonic_stack/#2832-maximal-range-that-each-element-is-maximum-in-it","title":"2832. Maximal Range That Each Element Is Maximum in It","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/monotonic_stack/#2282-number-of-people-that-can-be-seen-in-a-grid","title":"2282. Number of People That Can Be Seen in a Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, matrix, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/multiplication_principle/","title":"Multiplication Principle","text":""},{"location":"content/endlesscheng/multiplication_principle/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2125. Number of Laser Beams in a Bank (Medium)</li> <li> 3128. Right Triangles (Medium)</li> <li> 1573. Number of Ways to Split a String (Medium)</li> <li> 2750. Ways to Split Array Into Good Subarrays (Medium)</li> <li> 2550. Count Collisions of Monkeys on a Polygon (Medium)</li> <li> 1922. Count Good Numbers (Medium)</li> <li> 3067. Count Pairs of Connectable Servers in a Weighted Tree Network (Medium)</li> <li> 2147. Number of Ways to Divide a Long Corridor (Hard)</li> <li> 2963. Count the Number of Good Partitions (Hard)</li> <li> 2306. Naming a Company (Hard)</li> <li> 2867. Count Valid Paths in a Tree (Hard)</li> <li> 2450. Number of Distinct Binary Strings After Applying Operations (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/multiplication_principle/#2125-number-of-laser-beams-in-a-bank","title":"2125. Number of Laser Beams in a Bank","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, string, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/multiplication_principle/#3128-right-triangles","title":"3128. Right Triangles","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, combinatorics, counting</p> </li> </ul>"},{"location":"content/endlesscheng/multiplication_principle/#1573-number-of-ways-to-split-a-string","title":"1573. Number of Ways to Split a String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, string</p> </li> </ul>"},{"location":"content/endlesscheng/multiplication_principle/#2750-ways-to-split-array-into-good-subarrays","title":"2750. Ways to Split Array Into Good Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/multiplication_principle/#2550-count-collisions-of-monkeys-on-a-polygon","title":"2550. Count Collisions of Monkeys on a Polygon","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, recursion</p> </li> </ul>"},{"location":"content/endlesscheng/multiplication_principle/#1922-count-good-numbers","title":"1922. Count Good Numbers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, recursion</p> </li> </ul>"},{"location":"content/endlesscheng/multiplication_principle/#3067-count-pairs-of-connectable-servers-in-a-weighted-tree-network","title":"3067. Count Pairs of Connectable Servers in a Weighted Tree Network","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, tree, depth first search</p> </li> </ul>"},{"location":"content/endlesscheng/multiplication_principle/#2147-number-of-ways-to-divide-a-long-corridor","title":"2147. Number of Ways to Divide a Long Corridor","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, string, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/multiplication_principle/#2963-count-the-number-of-good-partitions","title":"2963. Count the Number of Good Partitions","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, math, combinatorics</p> </li> </ul>"},{"location":"content/endlesscheng/multiplication_principle/#2306-naming-a-company","title":"2306. Naming a Company","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, string, bit manipulation, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/multiplication_principle/#2867-count-valid-paths-in-a-tree","title":"2867. Count Valid Paths in a Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, dynamic programming, tree, depth first search, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/multiplication_principle/#2450-number-of-distinct-binary-strings-after-applying-operations","title":"2450. Number of Distinct Binary Strings After Applying Operations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, string</p> </li> </ul>"},{"location":"content/endlesscheng/n-ary_tree/","title":"N-ary Tree","text":""},{"location":"content/endlesscheng/n-ary_tree/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 589. N-ary Tree Preorder Traversal (Easy)</li> <li> 590. N-ary Tree Postorder Traversal (Easy)</li> <li> 559. Maximum Depth of N-ary Tree (Easy)</li> <li> 429. N-ary Tree Level Order Traversal (Medium)</li> <li> 427. Construct Quad Tree (Medium)</li> <li> 558. Logical OR of Two Binary Grids Represented as Quad-Trees (Medium)</li> <li> 428. Serialize and Deserialize N-ary Tree (Hard) \ud83d\udc51</li> <li> 1490. Clone N-ary Tree (Medium) \ud83d\udc51</li> <li> 1506. Find Root of N-Ary Tree (Medium) \ud83d\udc51</li> <li> 1522. Diameter of N-Ary Tree (Medium) \ud83d\udc51</li> <li> 1516. Move Sub-Tree of N-Ary Tree (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/n-ary_tree/#589-n-ary-tree-preorder-traversal","title":"589. N-ary Tree Preorder Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: stack, tree, depth first search</p> </li> </ul>"},{"location":"content/endlesscheng/n-ary_tree/#590-n-ary-tree-postorder-traversal","title":"590. N-ary Tree Postorder Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: stack, tree, depth first search</p> </li> </ul>"},{"location":"content/endlesscheng/n-ary_tree/#559-maximum-depth-of-n-ary-tree","title":"559. Maximum Depth of N-ary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search</p> </li> </ul>"},{"location":"content/endlesscheng/n-ary_tree/#429-n-ary-tree-level-order-traversal","title":"429. N-ary Tree Level Order Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, breadth first search 429. N-ary Tree Level Order Traversal - Python Solution<pre><code>from collections import deque\nfrom typing import List, Optional\n\n\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\n\ndef levelOrder(root: Optional[Node]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    queue = deque([root])\n    result = []\n\n    while queue:\n        level = []\n        size = len(queue)\n\n        for _ in range(size):\n            node = queue.popleft()\n            level.append(node.val)\n\n            for child in node.children:\n                queue.append(child)\n\n        result.append(level)\n\n    return result\n\n\nroot = Node(\n    1,\n    [\n        Node(\n            3,\n            [\n                Node(5, []),\n                Node(6, []),\n            ],\n        ),\n        Node(2, []),\n        Node(4, []),\n    ],\n)\nprint(levelOrder(root))  # [[1], [3, 2, 4], [5, 6]]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/n-ary_tree/#427-construct-quad-tree","title":"427. Construct Quad Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, divide and conquer, tree, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/n-ary_tree/#558-logical-or-of-two-binary-grids-represented-as-quad-trees","title":"558. Logical OR of Two Binary Grids Represented as Quad-Trees","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: divide and conquer, tree</p> </li> </ul>"},{"location":"content/endlesscheng/n-ary_tree/#428-serialize-and-deserialize-n-ary-tree","title":"428. Serialize and Deserialize N-ary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, tree, depth first search, breadth first search 428. Serialize and Deserialize N-ary Tree - Python Solution<pre><code>from typing import List, Optional\n\n\nclass Node(object):\n    def __init__(\n        self,\n        val: Optional[int] = None,\n        children: Optional[List[\"Node\"]] = None,\n    ):\n        if children is None:\n            children = []\n        self.val = val\n        self.children = children\n\n\n# DFS\nclass CodecDFS:\n    def serialize(self, root: \"Node\") -&gt; str:\n        \"\"\"Encodes a tree to a single string.\n\n        :type root: Node\n        :rtype: str\n        \"\"\"\n        if not root:\n            return \"*\"\n\n        data = \"\"\n        data += str(root.val) + \"|\" + str(len(root.children))\n        for child in root.children:\n            data += \"|\" + self.serialize(child)\n        return data\n\n    def deserialize(self, data: str) -&gt; \"Node\":\n        \"\"\"Decodes your encoded data to tree.\n\n        :type data: str\n        :rtype: Node\n        \"\"\"\n        if data == \"*\":\n            return None\n\n        data = data.split(\"|\")[::-1]\n\n        def dfs(data):\n            root = Node(int(data.pop()))\n            size = int(data.pop())\n            for i in range(size):\n                root.children.append(dfs(data))\n            return root\n\n        return dfs(data)\n\n\nif __name__ == \"__main__\":\n    obj = CodecDFS()\n    root = Node(1, [Node(3, [Node(5), Node(6)]), Node(2), Node(4)])\n    data = obj.serialize(root)\n    print(data)  # 1|3|3|2|5|0|6|0|2|0|4|0\n    root = obj.deserialize(data)\n    print(root.val)  # 1\n    print(root.children[0].val)  # 3\n    print(root.children[1].val)  # 2\n    print(root.children[2].val)  # 4\n    print(root.children[0].children[0].val)  # 5\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/n-ary_tree/#1490-clone-n-ary-tree","title":"1490. Clone N-ary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, tree, depth first search, breadth first search</p> </li> </ul>"},{"location":"content/endlesscheng/n-ary_tree/#1506-find-root-of-n-ary-tree","title":"1506. Find Root of N-Ary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, bit manipulation, tree, depth first search</p> </li> </ul>"},{"location":"content/endlesscheng/n-ary_tree/#1522-diameter-of-n-ary-tree","title":"1522. Diameter of N-Ary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search 1522. Diameter of N-Ary Tree - Python Solution<pre><code>from typing import List, Optional\n\n\nclass Node:\n    def __init__(\n        self,\n        val: Optional[int] = None,\n        children: Optional[List[\"Node\"]] = None,\n    ):\n        self.val = val\n        self.children = children if children is not None else []\n\n\ndef diameter(root: \"Node\") -&gt; int:\n\n    def dfs(node):\n        if not node.children:\n            return 1, 1\n        mx0, mx1 = 0, 0\n        mxf = 0\n        for child in node.children:\n            hl, fl = dfs(child)\n            mxf = max(mxf, fl)\n            if hl &gt; mx1:\n                if hl &lt; mx0:\n                    mx1 = hl\n                else:\n                    mx0, mx1 = hl, mx0\n        return mx0 + 1, max(mxf, mx0 + mx1 + 1)\n\n    return dfs(root)[1] - 1\n\n\nroot = [1, None, 2, None, 3, 4, None, 5, None, 6]\nroot = Node(1)\nroot.children = [Node(2)]\nroot.children[0].children = [Node(3), Node(4)]\nroot.children[0].children[0].children = [Node(5)]\nroot.children[0].children[1].children = [Node(6)]\nprint(diameter(root))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/n-ary_tree/#1516-move-sub-tree-of-n-ary-tree","title":"1516. Move Sub-Tree of N-Ary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: tree, depth first search</p> </li> </ul>"},{"location":"content/endlesscheng/network_flow/","title":"Network Flow","text":""},{"location":"content/endlesscheng/network_flow/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3376. Minimum Time to Break Locks I (Medium)</li> <li> 1947. Maximum Compatibility Score Sum (Medium)</li> <li> 2850. Minimum Moves to Spread Stones Over Grid (Medium)</li> <li> 1879. Minimum XOR Sum of Two Arrays (Hard)</li> <li> 1349. Maximum Students Taking Exam (Hard)</li> <li> 2172. Maximum AND Sum of Array (Hard)</li> <li> 3276. Select Cells in Grid With Maximum Score (Hard)</li> <li> 1595. Minimum Cost to Connect Two Groups of Points (Hard)</li> <li> 3257. Maximum Value Sum by Placing Three Rooks II (Hard)</li> <li> 1820. Maximum Number of Accepted Invitations (Medium) \ud83d\udc51</li> <li> 2403. Minimum Time to Kill All Monsters (Hard) \ud83d\udc51</li> <li> 3385. Minimum Time to Break Locks II (Hard) \ud83d\udc51</li> <li> 1066. Campus Bikes II (Medium) \ud83d\udc51</li> <li> 2123. Minimum Operations to Remove Adjacent Ones in Matrix (Hard) \ud83d\udc51</li> <li> 2463. Minimum Total Distance Traveled (Hard)</li> </ul>"},{"location":"content/endlesscheng/network_flow/#3376-minimum-time-to-break-locks-i","title":"3376. Minimum Time to Break Locks I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, backtracking, bit manipulation, depth first search, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/network_flow/#1947-maximum-compatibility-score-sum","title":"1947. Maximum Compatibility Score Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, backtracking, bit manipulation, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/network_flow/#2850-minimum-moves-to-spread-stones-over-grid","title":"2850. Minimum Moves to Spread Stones Over Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, breadth first search, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/network_flow/#1879-minimum-xor-sum-of-two-arrays","title":"1879. Minimum XOR Sum of Two Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, bit manipulation, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/network_flow/#1349-maximum-students-taking-exam","title":"1349. Maximum Students Taking Exam","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, bit manipulation, matrix, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/network_flow/#2172-maximum-and-sum-of-array","title":"2172. Maximum AND Sum of Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, bit manipulation, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/network_flow/#3276-select-cells-in-grid-with-maximum-score","title":"3276. Select Cells in Grid With Maximum Score","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, bit manipulation, matrix, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/network_flow/#1595-minimum-cost-to-connect-two-groups-of-points","title":"1595. Minimum Cost to Connect Two Groups of Points","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, bit manipulation, matrix, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/network_flow/#3257-maximum-value-sum-by-placing-three-rooks-ii","title":"3257. Maximum Value Sum by Placing Three Rooks II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, matrix, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/network_flow/#1820-maximum-number-of-accepted-invitations","title":"1820. Maximum Number of Accepted Invitations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, graph, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/network_flow/#2403-minimum-time-to-kill-all-monsters","title":"2403. Minimum Time to Kill All Monsters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, bit manipulation, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/network_flow/#3385-minimum-time-to-break-locks-ii","title":"3385. Minimum Time to Break Locks II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, depth first search, graph</p> </li> </ul>"},{"location":"content/endlesscheng/network_flow/#1066-campus-bikes-ii","title":"1066. Campus Bikes II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, backtracking, bit manipulation, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/network_flow/#2123-minimum-operations-to-remove-adjacent-ones-in-matrix","title":"2123. Minimum Operations to Remove Adjacent Ones in Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, graph, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/network_flow/#2463-minimum-total-distance-traveled","title":"2463. Minimum Total Distance Traveled","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/non-overlapping_intervals/","title":"Non-Overlapping Intervals","text":""},{"location":"content/endlesscheng/non-overlapping_intervals/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 435. Non-overlapping Intervals (Medium)</li> <li> 646. Maximum Length of Pair Chain (Medium)</li> <li> 1520. Maximum Number of Non-Overlapping Substrings (Hard)</li> <li> 3458. Select K Disjoint Special Substrings (Medium)</li> </ul>"},{"location":"content/endlesscheng/non-overlapping_intervals/#435-non-overlapping-intervals","title":"435. Non-overlapping Intervals","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy, sorting 435. Non-overlapping Intervals - Python Solution<pre><code>from typing import List\n\n\ndef eraseOverlapIntervals(intervals: List[List[int]]) -&gt; int:\n    if len(intervals) &lt;= 1:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n    result = 0\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &gt;= intervals[i - 1][1]:\n            continue\n        else:\n            result += 1\n            intervals[i][1] = min(intervals[i][1], intervals[i - 1][1])\n\n    return result\n\n\nprint(eraseOverlapIntervals([[1, 2], [2, 3], [3, 4], [1, 3]]))  # 1\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/non-overlapping_intervals/#646-maximum-length-of-pair-chain","title":"646. Maximum Length of Pair Chain","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/non-overlapping_intervals/#1520-maximum-number-of-non-overlapping-substrings","title":"1520. Maximum Number of Non-Overlapping Substrings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/non-overlapping_intervals/#3458-select-k-disjoint-special-substrings","title":"3458. Select K Disjoint Special Substrings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, dynamic programming, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/number_theory_others/","title":"Number Theory Others","text":""},{"location":"content/endlesscheng/number_theory_others/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 326. Power of Three (Easy)</li> <li> 633. Sum of Square Numbers (Medium)</li> <li> 279. Perfect Squares (Medium)</li> <li> 1015. Smallest Integer Divisible by K (Medium)</li> <li> 2240. Number of Ways to Buy Pens and Pencils (Medium)</li> <li> 2221. Find Triangular Sum of an Array (Medium)</li> </ul>"},{"location":"content/endlesscheng/number_theory_others/#326-power-of-three","title":"326. Power of Three","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, recursion</p> </li> </ul>"},{"location":"content/endlesscheng/number_theory_others/#633-sum-of-square-numbers","title":"633. Sum of Square Numbers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, two pointers, binary search</p> </li> </ul>"},{"location":"content/endlesscheng/number_theory_others/#279-perfect-squares","title":"279. Perfect Squares","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, breadth first search 279. Perfect Squares - Python Solution<pre><code>import math\n\n\n# DP - Knapsack Unbounded\ndef numSquares(n: int) -&gt; int:\n    dp = [float(\"inf\") for _ in range(n + 1)]\n    dp[0] = 0\n\n    for i in range(1, n + 1):\n        for j in range(1, int(math.sqrt(n)) + 1):\n            dp[i] = min(dp[i], dp[i - j**2] + 1)\n\n    return dp[n]\n\n\nn = 12\nprint(numSquares(n))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/number_theory_others/#1015-smallest-integer-divisible-by-k","title":"1015. Smallest Integer Divisible by K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, math</p> </li> </ul>"},{"location":"content/endlesscheng/number_theory_others/#2240-number-of-ways-to-buy-pens-and-pencils","title":"2240. Number of Ways to Buy Pens and Pencils","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/number_theory_others/#2221-find-triangular-sum-of-an-array","title":"2221. Find Triangular Sum of an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, simulation, combinatorics</p> </li> </ul>"},{"location":"content/endlesscheng/offline_algorithm/","title":"Offline Algorithm","text":""},{"location":"content/endlesscheng/offline_algorithm/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2343. Query Kth Smallest Trimmed Number (Medium)</li> <li> 2070. Most Beautiful Item for Each Query (Medium)</li> <li> 1847. Closest Room (Hard)</li> <li> 2503. Maximum Number of Points From Grid Queries (Hard)</li> <li> 1851. Minimum Interval to Include Each Query (Hard)</li> <li> 1697. Checking Existence of Edge Length Limited Paths (Hard)</li> <li> 2940. Find Building Where Alice and Bob Can Meet (Hard)</li> <li> 2747. Count Zero Request Servers (Medium)</li> <li> 1938. Maximum Genetic Difference Query (Hard)</li> <li> 2736. Maximum Sum Queries (Hard)</li> <li> 3382. Maximum Area Rectangle With Point Constraints II (Hard)</li> </ul>"},{"location":"content/endlesscheng/offline_algorithm/#2343-query-kth-smallest-trimmed-number","title":"2343. Query Kth Smallest Trimmed Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, divide and conquer, sorting, heap priority queue, radix sort, quickselect</p> </li> </ul>"},{"location":"content/endlesscheng/offline_algorithm/#2070-most-beautiful-item-for-each-query","title":"2070. Most Beautiful Item for Each Query","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sorting 2070. Most Beautiful Item for Each Query - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;numeric&gt;\n#include &lt;ranges&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;int&gt; maximumBeauty(vector&lt;vector&lt;int&gt;&gt;&amp; items, vector&lt;int&gt;&amp; queries) {\n    ranges::sort(items, {}, [](auto&amp; item) { return item[0]; });\n    vector&lt;int&gt; idx(queries.size());\n    iota(idx.begin(), idx.end(), 0);\n    ranges::sort(idx, {}, [&amp;](int i) { return queries[i]; });\n\n    vector&lt;int&gt; res(queries.size());\n    int max_beauty = 0, j = 0;\n    for (int i : idx) {\n        int q = queries[i];\n        while (j &lt; items.size() &amp;&amp; items[j][0] &lt;= q) {\n            max_beauty = max(max_beauty, items[j][1]);\n            j++;\n        }\n        res[i] = max_beauty;\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;vector&lt;int&gt;&gt; items = {{1, 2}, {2, 4}, {3, 2}, {5, 6}, {3, 5}};\n    vector&lt;int&gt; queries = {1, 2, 3, 4, 5, 6};\n    vector&lt;int&gt; res = maximumBeauty(items, queries);\n    // 2 4 5 5 6 6\n    for (int i : res) {\n        cout &lt;&lt; i &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n    return 0;\n}\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/offline_algorithm/#1847-closest-room","title":"1847. Closest Room","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, sorting, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/offline_algorithm/#2503-maximum-number-of-points-from-grid-queries","title":"2503. Maximum Number of Points From Grid Queries","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, breadth first search, union find, sorting, heap priority queue, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/offline_algorithm/#1851-minimum-interval-to-include-each-query","title":"1851. Minimum Interval to Include Each Query","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, line sweep, sorting, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/offline_algorithm/#1697-checking-existence-of-edge-length-limited-paths","title":"1697. Checking Existence of Edge Length Limited Paths","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, union find, graph, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/offline_algorithm/#2940-find-building-where-alice-and-bob-can-meet","title":"2940. Find Building Where Alice and Bob Can Meet","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, stack, binary indexed tree, segment tree, heap priority queue, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/offline_algorithm/#2747-count-zero-request-servers","title":"2747. Count Zero Request Servers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, sliding window, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/offline_algorithm/#1938-maximum-genetic-difference-query","title":"1938. Maximum Genetic Difference Query","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, bit manipulation, depth first search, trie</p> </li> </ul>"},{"location":"content/endlesscheng/offline_algorithm/#2736-maximum-sum-queries","title":"2736. Maximum Sum Queries","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, stack, binary indexed tree, segment tree, sorting, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/offline_algorithm/#3382-maximum-area-rectangle-with-point-constraints-ii","title":"3382. Maximum Area Rectangle With Point Constraints II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, binary indexed tree, segment tree, geometry, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/one_sequence_two_pointers_backward/","title":"One Sequence Two Pointers Backward","text":""},{"location":"content/endlesscheng/one_sequence_two_pointers_backward/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1793. Maximum Score of a Good Subarray (Hard)</li> </ul>"},{"location":"content/endlesscheng/one_sequence_two_pointers_backward/#1793-maximum-score-of-a-good-subarray","title":"1793. Maximum Score of a Good Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, binary search, stack, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/one_sequence_two_pointers_in-place_modification/","title":"One Sequence Two Pointers In-Place Modification","text":""},{"location":"content/endlesscheng/one_sequence_two_pointers_in-place_modification/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 27. Remove Element (Easy)</li> <li> 26. Remove Duplicates from Sorted Array (Easy)</li> <li> 80. Remove Duplicates from Sorted Array II (Medium)</li> <li> 283. Move Zeroes (Easy)</li> <li> 905. Sort Array By Parity (Easy)</li> <li> 922. Sort Array By Parity II (Easy)</li> <li> 2460. Apply Operations to an Array (Easy)</li> <li> 1089. Duplicate Zeros (Easy)</li> </ul>"},{"location":"content/endlesscheng/one_sequence_two_pointers_in-place_modification/#27-remove-element","title":"27. Remove Element","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers</p> </li> <li>Remove all instances of a given value in-place.</li> </ul> 27. Remove Element - Python Solution<pre><code>from typing import List\n\n\n# Fast Slow Pointers\ndef removeElement(nums: List[int], val: int) -&gt; int:\n    fast, slow = 0, 0\n\n    while fast &lt; len(nums):\n        if nums[fast] != val:\n            nums[slow] = nums[fast]\n            slow += 1\n        fast += 1\n\n    return slow\n\n\nnums = [0, 1, 2, 2, 3, 0, 4, 2]\nval = 2\nprint(removeElement(nums, val))  # 5\n</code></pre> 27. Remove Element - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// Fast Slow Pointers\nint removeElement(vector&lt;int&gt;&amp; nums, int val) {\n    size_t n = nums.size();\n    size_t slow = 0, fast = 0;\n\n    while (fast &lt; n) {\n        if (nums[fast] != val) {\n            nums[slow] = nums[fast];\n            slow++;\n        }\n        fast++;\n    }\n    return (int)slow;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {3, 2, 2, 3};\n    int val = 3;\n    cout &lt;&lt; removeElement(nums, val) &lt;&lt; endl;  // 2\n    return 0;\n}\n</code></pre>"},{"location":"content/endlesscheng/one_sequence_two_pointers_in-place_modification/#26-remove-duplicates-from-sorted-array","title":"26. Remove Duplicates from Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers</p> </li> <li>Remove duplicates in-place.</li> </ul> 26. Remove Duplicates from Sorted Array - Python Solution<pre><code>from typing import List\n\n\ndef removeDuplicates(nums: List[int]) -&gt; int:\n    fast, slow = 1, 1\n\n    while fast &lt; len(nums):\n        if nums[fast] != nums[fast - 1]:\n            nums[slow] = nums[fast]\n            slow += 1\n        fast += 1\n\n    return slow\n\n\nnums = [1, 1, 2]\nprint(removeDuplicates(nums))  # 2\n</code></pre>"},{"location":"content/endlesscheng/one_sequence_two_pointers_in-place_modification/#80-remove-duplicates-from-sorted-array-ii","title":"80. Remove Duplicates from Sorted Array II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers</p> </li> <li>Allow at most two duplicates.</li> <li>fast pointer: explore the array</li> <li>slow pointer: point to the position to be replaced</li> </ul> 80. Remove Duplicates from Sorted Array II - Python Solution<pre><code>from typing import List\n\n\ndef removeDuplicates(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 2:\n        return len(nums)\n\n    fast, slow = 2, 2\n\n    while fast &lt; len(nums):\n        if nums[fast] != nums[slow - 2]:\n            nums[slow] = nums[fast]\n            slow += 1\n        fast += 1\n\n    return slow\n\n\nnums = [1, 1, 1, 2, 2, 3]\nprint(removeDuplicates(nums))\n</code></pre>"},{"location":"content/endlesscheng/one_sequence_two_pointers_in-place_modification/#283-move-zeroes","title":"283. Move Zeroes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers</p> </li> <li>Move all zeroes to the end of the array while maintaining the relative order of the non-zero elements.</li> </ul> 283. Move Zeroes - Python Solution<pre><code>from typing import List\n\n\ndef moveZeroes(nums: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    fast, slow = 0, 0\n\n    while fast &lt; len(nums):\n        if nums[fast] != 0:\n            nums[slow], nums[fast] = nums[fast], nums[slow]\n            slow += 1\n        fast += 1\n\n\nnums = [0, 1, 0, 3, 12]\nmoveZeroes(nums)\nprint(nums)  # [1, 3, 12, 0, 0]\n</code></pre> 283. Move Zeroes - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvoid moveZeroes(vector&lt;int&gt;&amp; nums) {\n    size_t n = nums.size();\n    size_t fast = 0, slow = 0;\n\n    while (fast &lt; n) {\n        if (nums[fast] != 0) {\n            swap(nums[slow], nums[fast]);\n            slow++;\n        }\n        fast++;\n    }\n}\n\nint main() {\n    vector&lt;int&gt; nums = {0, 1, 0, 3, 12};\n    moveZeroes(nums);\n    // [1, 3, 12, 0, 0]\n    for (size_t i = 0; i &lt; nums.size(); i++) {\n        cout &lt;&lt; nums[i] &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/endlesscheng/one_sequence_two_pointers_in-place_modification/#905-sort-array-by-parity","title":"905. Sort Array By Parity","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers, sorting 905. Sort Array By Parity - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef sortArrayByParityLR(nums: List[int]) -&gt; List[int]:\n    left, right = 0, len(nums) - 1\n\n    while left &lt; right:\n        if not nums[left] % 2:\n            left += 1\n        else:\n            while left &lt; right and nums[right] % 2:\n                right -= 1\n            nums[left], nums[right] = nums[right], nums[left]\n\n    return nums\n\n\n# Fast Slow Pointers\ndef sortArrayByParityFS(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    fast, slow = 0, 0\n\n    while fast &lt; n:\n        if not nums[fast] % 2:\n            nums[slow], nums[fast] = nums[fast], nums[slow]\n            slow += 1\n        fast += 1\n\n    return nums\n\n\nnums = [3, 1, 2, 4]\nprint(sortArrayByParityLR(nums))  # [4, 2, 1, 3]\nprint(sortArrayByParityFS(nums))  # [4, 2, 1, 3]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/one_sequence_two_pointers_in-place_modification/#922-sort-array-by-parity-ii","title":"922. Sort Array By Parity II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/one_sequence_two_pointers_in-place_modification/#2460-apply-operations-to-an-array","title":"2460. Apply Operations to an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers, simulation</p> </li> </ul>"},{"location":"content/endlesscheng/one_sequence_two_pointers_in-place_modification/#1089-duplicate-zeros","title":"1089. Duplicate Zeros","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers</p> </li> <li>Duplicate each occurrence of zero, shifting the remaining elements to the right.</li> </ul> 1089. Duplicate Zeros - Python Solution<pre><code>from typing import List\n\n\ndef duplicateZeros(arr: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify arr in-place instead.\n    \"\"\"\n    n = len(arr)\n    fast, slow = 0, 0\n\n    # First pass: find the position\n    # where the last element would be in the expanded array\n    while fast &lt; n:\n        if arr[slow] == 0:\n            fast += 1\n        slow += 1\n        fast += 1\n\n    slow -= 1\n    fast -= 1\n\n    # Second pass: move elements backwards\n    while slow &gt;= 0:\n        if fast &lt; n:\n            arr[fast] = arr[slow]\n\n        if arr[slow] == 0:\n            fast -= 1\n            if fast &lt; n:\n                arr[fast] = 0\n\n        slow -= 1\n        fast -= 1\n\n\narr = [1, 0, 2, 3, 0, 4, 5, 0]\nduplicateZeros(arr)\nprint(arr)  # [1, 0, 0, 2, 3, 0, 0, 4]\n</code></pre>"},{"location":"content/endlesscheng/one_sequence_two_pointers_opposite_direction/","title":"One Sequence Two Pointers Opposite Direction","text":""},{"location":"content/endlesscheng/one_sequence_two_pointers_opposite_direction/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 344. Reverse String (Easy)</li> <li> 125. Valid Palindrome (Easy)</li> <li> 1750. Minimum Length of String After Deleting Similar Ends (Medium)</li> <li> 2105. Watering Plants II (Medium)</li> <li> 977. Squares of a Sorted Array (Easy)</li> <li> 658. Find K Closest Elements (Medium)</li> <li> 1471. The k Strongest Values in an Array (Medium)</li> <li> 167. Two Sum II - Input Array Is Sorted (Medium)</li> <li> 633. Sum of Square Numbers (Medium)</li> <li> 2824. Count Pairs Whose Sum is Less than Target (Easy)</li> <li> 15. 3Sum (Medium)</li> <li> 16. 3Sum Closest (Medium)</li> <li> 18. 4Sum (Medium)</li> <li> 611. Valid Triangle Number (Medium)</li> <li> 1577. Number of Ways Where Square of Number Is Equal to Product of Two Numbers (Medium)</li> <li> 923. 3Sum With Multiplicity (Medium)</li> <li> 948. Bag of Tokens (Medium)</li> <li> 11. Container With Most Water (Medium)</li> <li> 42. Trapping Rain Water (Hard)</li> <li> 1616. Split Two Strings to Make Palindrome (Medium)</li> <li> 1498. Number of Subsequences That Satisfy the Given Sum Condition (Medium)</li> <li> 1782. Count Pairs Of Nodes (Hard)</li> <li> 1099. Two Sum Less Than K (Easy) \ud83d\udc51</li> <li> 360. Sort Transformed Array (Medium) \ud83d\udc51</li> <li> 2422. Merge Operations to Turn Array Into a Palindrome (Medium) \ud83d\udc51</li> <li> 259. 3Sum Smaller (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/one_sequence_two_pointers_opposite_direction/#344-reverse-string","title":"344. Reverse String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string 344. Reverse String - Python Solution<pre><code>from typing import List\n\n\ndef reverseString(s: List[str]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify s in-place instead.\n    \"\"\"\n    left, right = 0, len(s) - 1\n\n    while left &lt; right:\n        s[left], s[right] = s[right], s[left]\n        left += 1\n        right -= 1\n\n\ns = [\"h\", \"e\", \"l\", \"l\", \"o\"]\nreverseString(s)\nprint(s)  # ['o', 'l', 'l', 'e', 'h']\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/one_sequence_two_pointers_opposite_direction/#125-valid-palindrome","title":"125. Valid Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string 125. Valid Palindrome - Python Solution<pre><code># List Comprehension\ndef isPalindrome(s: str) -&gt; bool:\n    s = [char.lower() for char in s if char.isalnum()]\n    return s == s[::-1]\n\n\n# Left Right Pointers\ndef isPalindromeLR(s: str) -&gt; bool:\n    left, right = 0, len(s) - 1\n\n    while left &lt; right:\n        while left &lt; right and not s[left].isalnum():\n            left += 1\n        while left &lt; right and not s[right].isalnum():\n            right -= 1\n\n        if s[left].lower() != s[right].lower():\n            return False\n\n        left += 1\n        right -= 1\n\n    return True\n\n\ns = \"A man, a plan, a canal: Panama\"\nprint(isPalindrome(s))  # True\nprint(isPalindromeLR(s))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/one_sequence_two_pointers_opposite_direction/#1750-minimum-length-of-string-after-deleting-similar-ends","title":"1750. Minimum Length of String After Deleting Similar Ends","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string 1750. Minimum Length of String After Deleting Similar Ends - Python Solution<pre><code># Sliding Window Variable Size\ndef minimumLength(s: str) -&gt; int:\n    left, right = 0, len(s) - 1\n\n    while left &lt; right and s[left] == s[right]:\n        val = s[left]\n\n        while left &lt;= right and s[left] == val:\n            left += 1\n        while left &lt;= right and s[right] == val:\n            right -= 1\n\n    return right - left + 1\n\n\nprint(minimumLength(\"cabaabac\"))  # 0\nprint(minimumLength(\"aabccabba\"))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/one_sequence_two_pointers_opposite_direction/#2105-watering-plants-ii","title":"2105. Watering Plants II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, simulation 2105. Watering Plants II - Python Solution<pre><code>from typing import List\n\n\n# Right Left Pointers\ndef minimumRefill(plants: List[int], capacityA: int, capacityB: int) -&gt; int:\n    i, j = 0, len(plants) - 1\n    a, b = capacityA, capacityB\n    res = 0\n\n    while i &lt; j:\n        if a &lt; plants[i]:\n            res += 1\n            a = capacityA\n        if b &lt; plants[j]:\n            res += 1\n            b = capacityB\n\n        a -= plants[i]\n        b -= plants[j]\n        i += 1\n        j -= 1\n\n    if i == j and max(a, b) &lt; plants[i]:\n        res += 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert minimumRefill([2, 2, 3, 3], 5, 5) == 1\n    assert minimumRefill([2, 2, 3, 3], 3, 4) == 2\n    assert minimumRefill([5, 5], 10, 10) == 0\n    assert minimumRefill([1, 2, 4, 4], 4, 4) == 1\n    assert minimumRefill([1, 1, 1], 2, 2) == 0\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/one_sequence_two_pointers_opposite_direction/#977-squares-of-a-sorted-array","title":"977. Squares of a Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers, sorting 977. Squares of a Sorted Array - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef sortedSquares(nums: List[int]) -&gt; List[int]:\n    \"\"\"Returns the squares of the sorted array.\"\"\"\n    n = len(nums)\n    result = [0 for _ in range(n)]\n\n    left, right, tail = 0, n - 1, n - 1\n\n    while left &lt;= right:\n        if abs(nums[left]) &gt;= abs(nums[right]):\n            result[tail] = nums[left] ** 2\n            left += 1\n        else:\n            result[tail] = nums[right] ** 2\n            right -= 1\n        tail -= 1\n\n    return result\n\n\n# |---------------------|------|-------|\n# | Approach            | Time | Space |\n# |---------------------|------|-------|\n# | Left Right Pointers | O(n) | O(n)  |\n# |---------------------|------|-------|\n\n\nnums = [-4, -1, 0, 3, 10]\nprint(sortedSquares(nums))  # [0, 1, 9, 16, 100]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/one_sequence_two_pointers_opposite_direction/#658-find-k-closest-elements","title":"658. Find K Closest Elements","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, sliding window, sorting, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/one_sequence_two_pointers_opposite_direction/#1471-the-k-strongest-values-in-an-array","title":"1471. The k Strongest Values in an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/one_sequence_two_pointers_opposite_direction/#167-two-sum-ii-input-array-is-sorted","title":"167. Two Sum II - Input Array Is Sorted","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search 167. Two Sum II - Input Array Is Sorted - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef twoSum(numbers: List[int], target: int) -&gt; List[int]:\n    left, right = 0, len(numbers) - 1\n\n    while left &lt; right:\n        total = numbers[left] + numbers[right]\n\n        if total &gt; target:\n            right -= 1\n        elif total &lt; target:\n            left += 1\n        else:\n            return [left + 1, right + 1]\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nnumbers = [2, 7, 11, 15]\ntarget = 9\nprint(twoSum(numbers, target))  # [1, 2]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/one_sequence_two_pointers_opposite_direction/#633-sum-of-square-numbers","title":"633. Sum of Square Numbers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, two pointers, binary search</p> </li> </ul>"},{"location":"content/endlesscheng/one_sequence_two_pointers_opposite_direction/#2824-count-pairs-whose-sum-is-less-than-target","title":"2824. Count Pairs Whose Sum is Less than Target","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers, binary search, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/one_sequence_two_pointers_opposite_direction/#15-3sum","title":"15. 3Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, sorting 15. 3Sum - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef threeSum(nums: List[int]) -&gt; List[List[int]]:\n    nums.sort()\n    res = []\n    n = len(nums)\n\n    for i in range(n - 2):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        left, right = i + 1, n - 1\n\n        while left &lt; right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total &gt; 0:\n                right -= 1\n            elif total &lt; 0:\n                left += 1\n            else:\n                res.append([nums[i], nums[left], nums[right]])\n\n                while left &lt; right and nums[left] == nums[left + 1]:\n                    left += 1\n\n                while left &lt; right and nums[right] == nums[right - 1]:\n                    right -= 1\n\n                left += 1\n                right -= 1\n\n    return res\n\n\nnums = [-1, 0, 1, 2, -1, -4]\nassert threeSum(nums) == [[-1, -1, 2], [-1, 0, 1]]\n</code></pre></p> </li> </ul> 15. 3Sum - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {\n    sort(nums.begin(), nums.end());\n    vector&lt;vector&lt;int&gt;&gt; res;\n    int n = nums.size();\n\n    for (int i = 0; i &lt; n - 2; i++) {\n        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) {\n            continue;\n        }\n\n        int left = i + 1, right = n - 1;\n\n        while (left &lt; right) {\n            int total = nums[i] + nums[left] + nums[right];\n\n            if (total &gt; 0)\n                right--;\n            else if (total &lt; 0)\n                left++;\n            else {\n                res.push_back({nums[i], nums[left], nums[right]});\n                while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++;\n                while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--;\n                left++;\n                right--;\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {-1, 0, 1, 2, -1, -4};\n    vector&lt;vector&lt;int&gt;&gt; res = threeSum(nums);\n    for (auto&amp; v : res) {\n        for (int i : v) {\n            cout &lt;&lt; i &lt;&lt; \" \";\n        }\n        cout &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"content/endlesscheng/one_sequence_two_pointers_opposite_direction/#16-3sum-closest","title":"16. 3Sum Closest","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, sorting 16. 3Sum Closest - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef threeSumClosest(nums: List[int], target: int) -&gt; int:\n    nums.sort()\n    n = len(nums)\n    res = 0\n    minDiff = float(\"inf\")\n\n    for i in range(n - 2):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        left, right = i + 1, n - 1\n\n        while left &lt; right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total &gt; target:\n                if total - target &lt; minDiff:\n                    minDiff = total - target\n                    res = total\n                right -= 1\n\n            elif total &lt; target:\n                if target - total &lt; minDiff:\n                    minDiff = target - total\n                    res = total\n                left += 1\n\n            else:\n                return total\n\n    return res\n\n\nnums = [-1, 2, 1, -4]\ntarget = 1\nassert threeSumClosest(nums, target) == 2\n</code></pre></p> </li> </ul> 16. 3Sum Closest - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;climits&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint threeSumClosest(vector&lt;int&gt;&amp; nums, int target) {\n    sort(nums.begin(), nums.end());\n    int n = nums.size();\n    int res = 0;\n    int minDiff = INT_MAX;\n\n    for (int i = 0; i &lt; n - 2; i++) {\n        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;\n\n        int left = i + 1, right = n - 1;\n        while (left &lt; right) {\n            int total = nums[i] + nums[left] + nums[right];\n\n            int diff = abs(total - target);\n            if (diff &lt; minDiff) {\n                minDiff = diff;\n                res = total;\n            }\n\n            if (total &gt; target)\n                right--;\n            else if (total &lt; target)\n                left++;\n            else\n                return total;\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {-1, 2, 1, -4};\n    int target = 1;\n    cout &lt;&lt; threeSumClosest(nums, target) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/endlesscheng/one_sequence_two_pointers_opposite_direction/#18-4sum","title":"18. 4Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, sorting 18. 4Sum - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef fourSum(nums: List[int], target: int) -&gt; List[List[int]]:\n    \"\"\"Returns all unique quadruplets that sum up to the target.\"\"\"\n    nums.sort()\n    result = []\n\n    for i in range(len(nums) - 3):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        for j in range(i + 1, len(nums) - 2):\n            if j &gt; i + 1 and nums[j] == nums[j - 1]:\n                continue\n\n            left = j + 1\n            right = len(nums) - 1\n\n            while left &lt; right:\n                total = nums[i] + nums[j] + nums[left] + nums[right]\n\n                if total &gt; target:\n                    right -= 1\n                elif total &lt; target:\n                    left += 1\n                else:\n                    result.append([nums[i], nums[j], nums[left], nums[right]])\n                    while left &lt; right and nums[left] == nums[left + 1]:\n                        left += 1\n                    while left &lt; right and nums[right] == nums[right - 1]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n\n    return result\n\n\nnums = [1, 0, -1, 0, -2, 2]\ntarget = 0\nprint(fourSum(nums, target))\n# [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/one_sequence_two_pointers_opposite_direction/#611-valid-triangle-number","title":"611. Valid Triangle Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/one_sequence_two_pointers_opposite_direction/#1577-number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers","title":"1577. Number of Ways Where Square of Number Is Equal to Product of Two Numbers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, two pointers</p> </li> </ul>"},{"location":"content/endlesscheng/one_sequence_two_pointers_opposite_direction/#923-3sum-with-multiplicity","title":"923. 3Sum With Multiplicity","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, two pointers, sorting, counting</p> </li> </ul>"},{"location":"content/endlesscheng/one_sequence_two_pointers_opposite_direction/#948-bag-of-tokens","title":"948. Bag of Tokens","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/one_sequence_two_pointers_opposite_direction/#11-container-with-most-water","title":"11. Container With Most Water","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy</p> </li> <li>Return the maximum area of water that can be trapped between the vertical lines.</li> </ul> <p></p> 11. Container With Most Water - Python Solution<pre><code>from typing import List\n\n\n# Brute Force\ndef maxAreaBF(height: List[int]) -&gt; int:\n    max_area = 0\n\n    for i in range(len(height)):\n        for j in range(i + 1, len(height)):\n            h = min(height[i], height[j])\n            w = j - i\n            max_area = max(max_area, h * w)\n\n    return max_area\n\n\n# Left Right Pointers\ndef maxAreaLR(height: List[int]) -&gt; int:\n    left, right = 0, len(height) - 1\n    res = 0\n\n    while left &lt; right:\n        h = min(height[left], height[right])\n        w = right - left\n        res = max(res, h * w)\n\n        if height[left] &lt; height[right]:\n            left += 1\n        else:\n            right -= 1\n\n    return res\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force| O(n^2) |  O(1)   |\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nheight = [1, 8, 6, 2, 5, 4, 8, 3, 7]\nprint(maxAreaBF(height))  # 49\nprint(maxAreaLR(height))  # 49\n</code></pre> 11. Container With Most Water - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint maxArea(vector&lt;int&gt;&amp; height) {\n    int left = 0, right = height.size() - 1;\n    int res = 0;\n\n    while (left &lt; right) {\n        int h = min(height[left], height[right]);\n        int w = right - left;\n        res = max(res, h * w);\n\n        if (height[left] &lt; height[right])\n            left++;\n        else\n            right--;\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; height = {1, 8, 6, 2, 5, 4, 8, 3, 7};\n    cout &lt;&lt; maxArea(height) &lt;&lt; endl;  // 49\n    return 0;\n}\n</code></pre>"},{"location":"content/endlesscheng/one_sequence_two_pointers_opposite_direction/#42-trapping-rain-water","title":"42. Trapping Rain Water","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, dynamic programming, stack, monotonic stack</p> </li> <li></li> </ul> Approach Time Space DP O(N) O(N) Left Right O(N) O(1) Monotonic O(N) O(N) 42. Trapping Rain Water - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef trapDP(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    n = len(height)\n    maxLeft, maxRight = [0 for _ in range(n)], [0 for _ in range(n)]\n\n    for i in range(1, n):\n        maxLeft[i] = max(maxLeft[i - 1], height[i - 1])\n\n    for i in range(n - 2, -1, -1):\n        maxRight[i] = max(maxRight[i + 1], height[i + 1])\n\n    res = 0\n    for i in range(n):\n        res += max(0, min(maxLeft[i], maxRight[i]) - height[i])\n\n    return res\n\n\n# Left Right Pointers\ndef trapLR(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    left, right = 0, len(height) - 1\n    maxL, maxR = height[left], height[right]\n    res = 0\n\n    while left &lt; right:\n        if maxL &lt; maxR:\n            left += 1\n            maxL = max(maxL, height[left])\n            res += maxL - height[left]\n        else:\n            right -= 1\n            maxR = max(maxR, height[right])\n            res += maxR - height[right]\n\n    return res\n\n\n# Monotonic Stack\ndef trapStack(height: List[int]) -&gt; int:\n    stack = []\n    total = 0\n\n    for i in range(len(height)):\n        while stack and height[i] &gt; height[stack[-1]]:\n            top = stack.pop()\n            if not stack:\n                break\n            distance = i - stack[-1] - 1\n            bounded_height = min(height[i], height[stack[-1]]) - height[top]\n            total += distance * bounded_height\n        stack.append(i)\n\n    return total\n\n\nheight = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\nprint(trapDP(height))  # 6\nprint(trapLR(height))  # 6\nprint(trapStack(height))  # 6\n</code></pre> 42. Trapping Rain Water - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int trap(vector&lt;int&gt; &amp;height)\n    {\n        if (height.empty())\n            return 0;\n\n        int res = 0;\n        int left = 0, right = height.size() - 1;\n        int maxL = height[left], maxR = height[right];\n\n        while (left &lt; right)\n        {\n            if (maxL &lt; maxR)\n            {\n                left++;\n                maxL = max(maxL, height[left]);\n                res += maxL - height[left];\n            }\n            else\n            {\n                right--;\n                maxR = max(maxR, height[right]);\n                res += maxR - height[right];\n            }\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    vector&lt;int&gt; height = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};\n    Solution solution;\n    cout &lt;&lt; solution.trap(height) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/endlesscheng/one_sequence_two_pointers_opposite_direction/#1616-split-two-strings-to-make-palindrome","title":"1616. Split Two Strings to Make Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string</p> </li> </ul>"},{"location":"content/endlesscheng/one_sequence_two_pointers_opposite_direction/#1498-number-of-subsequences-that-satisfy-the-given-sum-condition","title":"1498. Number of Subsequences That Satisfy the Given Sum Condition","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/one_sequence_two_pointers_opposite_direction/#1782-count-pairs-of-nodes","title":"1782. Count Pairs Of Nodes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, binary search, graph, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/one_sequence_two_pointers_opposite_direction/#1099-two-sum-less-than-k","title":"1099. Two Sum Less Than K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers, binary search, sorting 1099. Two Sum Less Than K - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef twoSumLessThanK(nums: List[int], k: int) -&gt; int:\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    res = float(\"-inf\")\n\n    while left &lt; right:\n        total = nums[left] + nums[right]\n\n        if total &gt;= k:\n            right -= 1\n        else:\n            res = max(res, total)\n            left += 1\n\n    return res if res != float(\"-inf\") else -1\n\n\nnums = [34, 23, 1, 24, 75, 33, 54, 8]\nk = 60\nprint(twoSumLessThanK(nums, k))  # 58\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/one_sequence_two_pointers_opposite_direction/#360-sort-transformed-array","title":"360. Sort Transformed Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, two pointers, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/one_sequence_two_pointers_opposite_direction/#2422-merge-operations-to-turn-array-into-a-palindrome","title":"2422. Merge Operations to Turn Array Into a Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/one_sequence_two_pointers_opposite_direction/#259-3sum-smaller","title":"259. 3Sum Smaller","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/one_sequence_two_pointers_same_direction/","title":"One Sequence Two Pointers Same Direction","text":""},{"location":"content/endlesscheng/one_sequence_two_pointers_same_direction/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1574. Shortest Subarray to be Removed to Make Array Sorted (Medium)</li> <li> 2972. Count the Number of Incremovable Subarrays II (Hard)</li> <li> 2122. Recover the Original Array (Hard)</li> <li> 2234. Maximum Total Beauty of the Gardens (Hard)</li> <li> 3323. Minimize Connected Groups by Inserting Interval (Medium) \ud83d\udc51</li> <li> 581. Shortest Unsorted Continuous Subarray (Medium)</li> </ul>"},{"location":"content/endlesscheng/one_sequence_two_pointers_same_direction/#1574-shortest-subarray-to-be-removed-to-make-array-sorted","title":"1574. Shortest Subarray to be Removed to Make Array Sorted","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, stack, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/one_sequence_two_pointers_same_direction/#2972-count-the-number-of-incremovable-subarrays-ii","title":"2972. Count the Number of Incremovable Subarrays II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, binary search</p> </li> </ul>"},{"location":"content/endlesscheng/one_sequence_two_pointers_same_direction/#2122-recover-the-original-array","title":"2122. Recover the Original Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, two pointers, sorting, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/one_sequence_two_pointers_same_direction/#2234-maximum-total-beauty-of-the-gardens","title":"2234. Maximum Total Beauty of the Gardens","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, binary search, greedy, sorting 2234. Maximum Total Beauty of the Gardens - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nlong long maximumBeauty(vector&lt;int&gt;&amp; flowers, long long newFlowers, int target,\n                        int full, int partial) {\n    int n = flowers.size();\n\n    long long left = newFlowers - 1LL * target * n;\n    for (int&amp; flower : flowers) {\n        flower = min(flower, target);\n        left += flower;\n    }\n\n    if (left == newFlowers) return 1LL * full * n;\n\n    if (left &gt;= 0) {\n        return max(1LL * (target - 1) * partial + 1LL * (n - 1) * full,\n                   1LL * n * full);\n    }\n\n    sort(flowers.begin(), flowers.end());\n    long long res = 0, pre_sum = 0;\n\n    int j = 0;\n    for (int i = 1; i &lt;= n; i++) {\n        left += target - flowers[i - 1];\n        if (left &lt; 0) {\n            continue;\n        }\n\n        while (j &lt; i &amp;&amp; 1LL * flowers[j] * j &lt;= pre_sum + left) {\n            pre_sum += flowers[j];\n            j++;\n        }\n\n        long long avg = (left + pre_sum) / j;\n        long long total_beauty = avg * partial + 1LL * (n - i) * full;\n        res = max(res, total_beauty);\n    }\n\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; flowers = {1, 3, 1, 1};\n    long long newFlowers = 7;\n    int target = 6;\n    int full = 12;\n    int partial = 1;\n    long long res = maximumBeauty(flowers, newFlowers, target, full, partial);\n    cout &lt;&lt; res &lt;&lt; endl;  // 14\n    return 0;\n}\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/one_sequence_two_pointers_same_direction/#3323-minimize-connected-groups-by-inserting-interval","title":"3323. Minimize Connected Groups by Inserting Interval","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sliding window, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/one_sequence_two_pointers_same_direction/#581-shortest-unsorted-continuous-subarray","title":"581. Shortest Unsorted Continuous Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, stack, greedy, sorting, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/other_interval_greedy/","title":"Other Interval Greedy","text":""},{"location":"content/endlesscheng/other_interval_greedy/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1288. Remove Covered Intervals (Medium)</li> <li> 2054. Two Best Non-Overlapping Events (Medium)</li> <li> 1705. Maximum Number of Eaten Apples (Medium)</li> <li> 1353. Maximum Number of Events That Can Be Attended (Medium)</li> <li> 2589. Minimum Time to Complete All Tasks (Hard)</li> </ul>"},{"location":"content/endlesscheng/other_interval_greedy/#1288-remove-covered-intervals","title":"1288. Remove Covered Intervals","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/other_interval_greedy/#2054-two-best-non-overlapping-events","title":"2054. Two Best Non-Overlapping Events","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, dynamic programming, sorting, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/other_interval_greedy/#1705-maximum-number-of-eaten-apples","title":"1705. Maximum Number of Eaten Apples","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/other_interval_greedy/#1353-maximum-number-of-events-that-can-be-attended","title":"1353. Maximum Number of Events That Can Be Attended","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/other_interval_greedy/#2589-minimum-time-to-complete-all-tasks","title":"2589. Minimum Time to Complete All Tasks","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, stack, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/other_math_greedy/","title":"Other Math Greedy","text":""},{"location":"content/endlesscheng/other_math_greedy/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K (Medium)</li> <li> 3107. Minimum Operations to Make Median of Array Equal to K (Medium)</li> <li> 754. Reach a Number (Medium)</li> <li> 1058. Minimize Rounding Error to Meet Target (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/other_math_greedy/#1414-find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k","title":"1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/other_math_greedy/#3107-minimum-operations-to-make-median-of-array-equal-to-k","title":"3107. Minimum Operations to Make Median of Array Equal to K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/other_math_greedy/#754-reach-a-number","title":"754. Reach a Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, binary search</p> </li> </ul>"},{"location":"content/endlesscheng/other_math_greedy/#1058-minimize-rounding-error-to-meet-target","title":"1058. Minimize Rounding Error to Meet Target","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, string, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/palindrome_greedy/","title":"Palindrome Greedy","text":""},{"location":"content/endlesscheng/palindrome_greedy/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 409. Longest Palindrome (Easy)</li> <li> 2697. Lexicographically Smallest Palindrome (Easy)</li> <li> 680. Valid Palindrome II (Easy)</li> <li> 1328. Break a Palindrome (Medium)</li> <li> 1400. Construct K Palindrome Strings (Medium)</li> <li> 2131. Longest Palindrome by Concatenating Two Letter Words (Medium)</li> <li> 2384. Largest Palindromic Number (Medium)</li> <li> 3035. Maximum Palindromes After Operations (Medium)</li> <li> 1616. Split Two Strings to Make Palindrome (Medium)</li> <li> 1147. Longest Chunked Palindrome Decomposition (Hard)</li> <li> 2193. Minimum Number of Moves to Make Palindrome (Hard)</li> <li> 564. Find the Closest Palindrome (Hard)</li> <li> 266. Palindrome Permutation (Easy) \ud83d\udc51</li> <li> 2422. Merge Operations to Turn Array Into a Palindrome (Medium) \ud83d\udc51</li> <li> 1842. Next Palindrome Using Same Digits (Hard) \ud83d\udc51</li> <li> 3088. Make String Anti-palindrome (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/palindrome_greedy/#409-longest-palindrome","title":"409. Longest Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, string, greedy</p> </li> <li>Return the length of the longest palindrome that can be built with the characters in the string.</li> </ul> 409. Longest Palindrome - Python Solution<pre><code>def longestPalindrome(s: str) -&gt; int:\n    hashmap = dict()\n    result = 0\n\n    for char in s:\n        if char not in hashmap or hashmap[char] == 0:\n            hashmap[char] = 1\n        else:\n            result += 2\n            hashmap[char] = 0\n\n    if any(hashmap.values()):\n        result += 1\n\n    return result\n\n\nprint(longestPalindrome(\"abccccdd\"))  # 7\n</code></pre>"},{"location":"content/endlesscheng/palindrome_greedy/#2697-lexicographically-smallest-palindrome","title":"2697. Lexicographically Smallest Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string, greedy 2697. Lexicographically Smallest Palindrome - Python Solution<pre><code>def makeSmallestPalindrome(s: str) -&gt; str:\n    n = len(s)\n    s = list(s)\n    left, right = 0, n - 1\n\n    while left &lt; right:\n        if s[left] &lt; s[right]:\n            s[right] = s[left]\n        elif s[left] &gt; s[right]:\n            s[left] = s[right]\n        left += 1\n        right -= 1\n\n    return \"\".join(s)\n\n\ns = \"egcfe\"\nprint(makeSmallestPalindrome(s))  # \"efcfe\"\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/palindrome_greedy/#680-valid-palindrome-ii","title":"680. Valid Palindrome II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/palindrome_greedy/#1328-break-a-palindrome","title":"1328. Break a Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, greedy 1328. Break a Palindrome - Python Solution<pre><code># Greedy\ndef breakPalindrome(palindrome: str) -&gt; str:\n    n = len(palindrome)\n    if n == 1:\n        return \"\"\n\n    for i in range(n // 2):\n        if palindrome[i] != \"a\":\n            return palindrome[:i] + \"a\" + palindrome[i + 1 :]\n\n    return palindrome[:-1] + \"b\"\n\n\npalindrome = \"abccba\"\nprint(breakPalindrome(palindrome))  # \"aaccba\"\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/palindrome_greedy/#1400-construct-k-palindrome-strings","title":"1400. Construct K Palindrome Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, greedy, counting 1400. Construct K Palindrome Strings - Python Solution<pre><code>from collections import Counter\n\n\ndef canConstructCounter(s: str, k: int) -&gt; bool:\n    if len(s) &lt; k:\n        return False\n\n    counts = Counter(s)\n    odd = 0\n\n    for c in counts.values():\n        odd += c % 2\n\n    return odd &lt;= k\n\n\ndef canConstructHash(s: str, k: int) -&gt; bool:\n    if len(s) &lt; k:\n        return False\n\n    counts = [0 for _ in range(26)]\n\n    for ch in s:\n        idx = ord(ch) - ord(\"a\")\n        if counts[idx] == 0:\n            counts[idx] += 1\n        else:\n            counts[idx] -= 1\n\n    return sum(counts) &lt;= k\n\n\ns = \"annabelle\"\nk = 2\nprint(canConstructCounter(s, k))  # True\nprint(canConstructHash(s, k))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/palindrome_greedy/#2131-longest-palindrome-by-concatenating-two-letter-words","title":"2131. Longest Palindrome by Concatenating Two Letter Words","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, greedy, counting</p> </li> </ul>"},{"location":"content/endlesscheng/palindrome_greedy/#2384-largest-palindromic-number","title":"2384. Largest Palindromic Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, greedy, counting</p> </li> </ul>"},{"location":"content/endlesscheng/palindrome_greedy/#3035-maximum-palindromes-after-operations","title":"3035. Maximum Palindromes After Operations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, greedy, sorting, counting</p> </li> </ul>"},{"location":"content/endlesscheng/palindrome_greedy/#1616-split-two-strings-to-make-palindrome","title":"1616. Split Two Strings to Make Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string</p> </li> </ul>"},{"location":"content/endlesscheng/palindrome_greedy/#1147-longest-chunked-palindrome-decomposition","title":"1147. Longest Chunked Palindrome Decomposition","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: two pointers, string, dynamic programming, greedy, rolling hash, hash function</p> </li> </ul>"},{"location":"content/endlesscheng/palindrome_greedy/#2193-minimum-number-of-moves-to-make-palindrome","title":"2193. Minimum Number of Moves to Make Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: two pointers, string, greedy, binary indexed tree</p> </li> </ul>"},{"location":"content/endlesscheng/palindrome_greedy/#564-find-the-closest-palindrome","title":"564. Find the Closest Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, string</p> </li> </ul>"},{"location":"content/endlesscheng/palindrome_greedy/#266-palindrome-permutation","title":"266. Palindrome Permutation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, string, bit manipulation 266. Palindrome Permutation - Python Solution<pre><code>from collections import defaultdict\n\n\n# Hash\ndef canPermutePalindromeDict(s: str) -&gt; bool:\n    if len(s) == 1:\n        return True\n\n    count = defaultdict(int)\n\n    for ch in s:\n        if count[ch] == 1:\n            count[ch] = 0\n            continue\n        count[ch] = 1\n\n    return sum(count.values()) &lt;= 1\n\n\n# Set\ndef canPermutePalindromeSet(s: str) -&gt; bool:\n    if len(s) == 1:\n        return True\n\n    seen = set()\n\n    for ch in s:\n        if ch in seen:\n            seen.remove(ch)\n        else:\n            seen.add(ch)\n\n    return len(seen) &lt;= 1\n\n\nassert canPermutePalindromeDict(\"carerac\") is True\nassert canPermutePalindromeSet(\"carerac\") is True\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/palindrome_greedy/#2422-merge-operations-to-turn-array-into-a-palindrome","title":"2422. Merge Operations to Turn Array Into a Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/palindrome_greedy/#1842-next-palindrome-using-same-digits","title":"1842. Next Palindrome Using Same Digits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: two pointers, string</p> </li> </ul>"},{"location":"content/endlesscheng/palindrome_greedy/#3088-make-string-anti-palindrome","title":"3088. Make String Anti-palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, greedy, sorting, counting sort</p> </li> </ul>"},{"location":"content/endlesscheng/palindromic_numbers/","title":"Palindromic Numbers","text":""},{"location":"content/endlesscheng/palindromic_numbers/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 9. Palindrome Number (Easy)</li> <li> 2396. Strictly Palindromic Number (Medium)</li> <li> 2217. Find Palindrome With Fixed Length (Medium)</li> <li> 866. Prime Palindrome (Medium)</li> <li> 2967. Minimum Cost to Make Array Equalindromic (Medium)</li> <li> 906. Super Palindromes (Hard)</li> <li> 2081. Sum of k-Mirror Numbers (Hard)</li> <li> 3260. Find the Largest Palindrome Divisible by K (Hard)</li> <li> 3272. Find the Count of Good Integers (Hard)</li> <li> 564. Find the Closest Palindrome (Hard)</li> <li> 479. Largest Palindrome Product (Hard)</li> </ul>"},{"location":"content/endlesscheng/palindromic_numbers/#9-palindrome-number","title":"9. Palindrome Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math</p> </li> <li>Return true if the given number is a palindrome. Otherwise, return false.</li> </ul> 9. Palindrome Number - Python Solution<pre><code># Reverse\ndef isPalindromeReverse(x: int) -&gt; bool:\n    if x &lt; 0:\n        return False\n\n    return str(x) == str(x)[::-1]\n\n\n# Left Right Pointers\ndef isPalindromeLR(x: int) -&gt; bool:\n    if x &lt; 0:\n        return False\n\n    x = list(str(x))  # 121 -&gt; ['1', '2', '1']\n\n    left, right = 0, len(x) - 1\n\n    while left &lt; right:\n        if x[left] != x[right]:\n            return False\n        left += 1\n        right -= 1\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |  Reverse   |  O(N)  |   O(N)  |\n# | Left Right |  O(N)  |   O(1)  |\n# |------------|--------|---------|\n\n\nx = 121\nprint(isPalindromeReverse(x))  # True\nprint(isPalindromeLR(x))  # True\n</code></pre>"},{"location":"content/endlesscheng/palindromic_numbers/#2396-strictly-palindromic-number","title":"2396. Strictly Palindromic Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, two pointers, brainteaser</p> </li> </ul>"},{"location":"content/endlesscheng/palindromic_numbers/#2217-find-palindrome-with-fixed-length","title":"2217. Find Palindrome With Fixed Length","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math</p> </li> </ul>"},{"location":"content/endlesscheng/palindromic_numbers/#866-prime-palindrome","title":"866. Prime Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/palindromic_numbers/#2967-minimum-cost-to-make-array-equalindromic","title":"2967. Minimum Cost to Make Array Equalindromic","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, binary search, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/palindromic_numbers/#906-super-palindromes","title":"906. Super Palindromes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, string, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/palindromic_numbers/#2081-sum-of-k-mirror-numbers","title":"2081. Sum of k-Mirror Numbers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/palindromic_numbers/#3260-find-the-largest-palindrome-divisible-by-k","title":"3260. Find the Largest Palindrome Divisible by K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, string, dynamic programming, greedy, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/palindromic_numbers/#3272-find-the-count-of-good-integers","title":"3272. Find the Count of Good Integers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, math, combinatorics, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/palindromic_numbers/#564-find-the-closest-palindrome","title":"564. Find the Closest Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, string</p> </li> </ul>"},{"location":"content/endlesscheng/palindromic_numbers/#479-largest-palindrome-product","title":"479. Largest Palindrome Product","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/partitioning_greedy/","title":"Partitioning Greedy","text":""},{"location":"content/endlesscheng/partitioning_greedy/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1221. Split a String in Balanced Strings (Easy)</li> <li> 2405. Optimal Partition of String (Medium)</li> <li> 2294. Partition Array Such That Maximum Difference Is K (Medium)</li> <li> 2358. Maximum Number of Groups Entering a Competition (Medium)</li> <li> 2522. Partition String Into Substrings With Values at Most K (Medium)</li> <li> 1546. Maximum Number of Non-Overlapping Subarrays With Sum Equals Target (Medium)</li> <li> 2436. Minimum Split Into Subarrays With GCD Greater Than One (Medium) \ud83d\udc51</li> <li> 2892. Minimizing Array After Replacing Pairs With Their Product (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/partitioning_greedy/#1221-split-a-string-in-balanced-strings","title":"1221. Split a String in Balanced Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, greedy, counting</p> </li> </ul>"},{"location":"content/endlesscheng/partitioning_greedy/#2405-optimal-partition-of-string","title":"2405. Optimal Partition of String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/partitioning_greedy/#2294-partition-array-such-that-maximum-difference-is-k","title":"2294. Partition Array Such That Maximum Difference Is K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting 2294. Partition Array Such That Maximum Difference Is K - Python Solution<pre><code>from typing import List\n\n\ndef partitionArray(nums: List[int], k: int) -&gt; int:\n    nums.sort()\n    mn = float(\"-inf\")\n    res = 0\n\n    for num in nums:\n        if num - mn &gt; k:\n            res += 1\n            mn = num\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert partitionArray([3, 6, 1, 2, 5], 2) == 2\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/partitioning_greedy/#2358-maximum-number-of-groups-entering-a-competition","title":"2358. Maximum Number of Groups Entering a Competition","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, binary search, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/partitioning_greedy/#2522-partition-string-into-substrings-with-values-at-most-k","title":"2522. Partition String Into Substrings With Values at Most K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/partitioning_greedy/#1546-maximum-number-of-non-overlapping-subarrays-with-sum-equals-target","title":"1546. Maximum Number of Non-Overlapping Subarrays With Sum Equals Target","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, greedy, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/partitioning_greedy/#2436-minimum-split-into-subarrays-with-gcd-greater-than-one","title":"2436. Minimum Split Into Subarrays With GCD Greater Than One","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, dynamic programming, greedy, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/partitioning_greedy/#2892-minimizing-array-after-replacing-pairs-with-their-product","title":"2892. Minimizing Array After Replacing Pairs With Their Product","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/points_and_lines/","title":"Points and Lines","text":""},{"location":"content/endlesscheng/points_and_lines/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1232. Check If It Is a Straight Line (Easy)</li> <li> 2280. Minimum Lines to Represent a Line Chart (Medium)</li> <li> 1610. Maximum Number of Visible Points (Hard)</li> <li> 2152. Minimum Number of Lines to Cover Points (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/points_and_lines/#1232-check-if-it-is-a-straight-line","title":"1232. Check If It Is a Straight Line","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, math, geometry</p> </li> </ul>"},{"location":"content/endlesscheng/points_and_lines/#2280-minimum-lines-to-represent-a-line-chart","title":"2280. Minimum Lines to Represent a Line Chart","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, geometry, sorting, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/points_and_lines/#1610-maximum-number-of-visible-points","title":"1610. Maximum Number of Visible Points","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, geometry, sliding window, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/points_and_lines/#2152-minimum-number-of-lines-to-cover-points","title":"2152. Minimum Number of Lines to Cover Points","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, dynamic programming, backtracking, bit manipulation, geometry, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/polynomial_convolution/","title":"Polynomial Convolution","text":""},{"location":"content/endlesscheng/polynomial_convolution/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3400. Maximum Number of Matching Indices After Right Shifts (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/polynomial_convolution/#3400-maximum-number-of-matching-indices-after-right-shifts","title":"3400. Maximum Number of Matching Indices After Right Shifts","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, simulation</p> </li> </ul>"},{"location":"content/endlesscheng/prefix_sum_basics/","title":"Prefix Sum Basics","text":""},{"location":"content/endlesscheng/prefix_sum_basics/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 303. Range Sum Query - Immutable (Easy)</li> <li> 3427. Sum of Variable Length Subarrays (Easy)</li> <li> 2559. Count Vowel Strings in Ranges (Medium)</li> <li> 3152. Special Array II (Medium)</li> <li> 1749. Maximum Absolute Sum of Any Subarray (Medium)</li> <li> 2389. Longest Subsequence With Limited Sum (Easy)</li> <li> 3361. Shift Distance Between Two Strings (Medium)</li> <li> 2055. Plates Between Candles (Medium)</li> <li> 1744. Can You Eat Your Favorite Candy on Your Favorite Day? (Medium)</li> <li> 53. Maximum Subarray (Medium)</li> <li> 1523. Count Odd Numbers in an Interval Range (Easy)</li> </ul>"},{"location":"content/endlesscheng/prefix_sum_basics/#303-range-sum-query-immutable","title":"303. Range Sum Query - Immutable","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, design, prefix sum 303. Range Sum Query - Immutable - Python Solution<pre><code>from typing import List\n\n\n# Prefix Sum\nclass NumArray:\n\n    def __init__(self, nums: List[int]):\n        n = len(nums)\n        self.ps = [0 for _ in range(n + 1)]  # prefix sum\n        for i in range(1, n + 1):\n            self.ps[i] = self.ps[i - 1] + nums[i - 1]\n\n    def sumRange(self, left: int, right: int) -&gt; int:\n        return self.ps[right + 1] - self.ps[left]\n\n\nnums = [-2, 0, 3, -5, 2, -1]\nobj = NumArray(nums)\nassert obj.sumRange(0, 2) == 1\nassert obj.sumRange(2, 5) == -1\nassert obj.sumRange(0, 5) == -3\nprint(\"PASSED\")\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/prefix_sum_basics/#3427-sum-of-variable-length-subarrays","title":"3427. Sum of Variable Length Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/prefix_sum_basics/#2559-count-vowel-strings-in-ranges","title":"2559. Count Vowel Strings in Ranges","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/prefix_sum_basics/#3152-special-array-ii","title":"3152. Special Array II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/prefix_sum_basics/#1749-maximum-absolute-sum-of-any-subarray","title":"1749. Maximum Absolute Sum of Any Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/prefix_sum_basics/#2389-longest-subsequence-with-limited-sum","title":"2389. Longest Subsequence With Limited Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, binary search, greedy, sorting, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/prefix_sum_basics/#3361-shift-distance-between-two-strings","title":"3361. Shift Distance Between Two Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/prefix_sum_basics/#2055-plates-between-candles","title":"2055. Plates Between Candles","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, binary search, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/prefix_sum_basics/#1744-can-you-eat-your-favorite-candy-on-your-favorite-day","title":"1744. Can You Eat Your Favorite Candy on Your Favorite Day?","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/prefix_sum_basics/#53-maximum-subarray","title":"53. Maximum Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, divide and conquer, dynamic programming 53. Maximum Subarray - Python Solution<pre><code>from typing import List\n\n\n# DP Kadane\ndef maxSubArrayDP(nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n\n    dp[0] = nums[0]\n    maxSum = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(\n            dp[i - 1] + nums[i],  # continue the previous subarray\n            nums[i],  # start a new subarray\n        )\n        maxSum = max(maxSum, dp[i])\n\n    return maxSum\n\n\n# Greedy\ndef maxSubArrayGreedy(nums: List[int]) -&gt; int:\n    max_sum = nums[0]\n    cur_sum = 0\n\n    for num in nums:\n        cur_sum = max(cur_sum + num, num)\n        max_sum = max(max_sum, cur_sum)\n\n    return max_sum\n\n\n# Prefix Sum\ndef maxSubArrayPrefixSum(nums: List[int]) -&gt; int:\n    prefix_sum = 0\n    prefix_sum_min = 0\n    res = float(\"-inf\")\n\n    for num in nums:\n        prefix_sum += num\n        res = max(res, prefix_sum - prefix_sum_min)\n        prefix_sum_min = min(prefix_sum_min, prefix_sum)\n\n    return res\n\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArrayDP(nums))  # 6\nprint(maxSubArrayGreedy(nums))  # 6\nprint(maxSubArrayPrefixSum(nums))  # 6\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/prefix_sum_basics/#1523-count-odd-numbers-in-an-interval-range","title":"1523. Count Odd Numbers in an Interval Range","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math</p> </li> </ul>"},{"location":"content/endlesscheng/prefix_sum_with_hash_table/","title":"Prefix Sum with Hash Table","text":""},{"location":"content/endlesscheng/prefix_sum_with_hash_table/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 930. Binary Subarrays With Sum (Medium)</li> <li> 560. Subarray Sum Equals K (Medium)</li> <li> 1524. Number of Sub-arrays With Odd Sum (Medium)</li> <li> 974. Subarray Sums Divisible by K (Medium)</li> <li> 523. Continuous Subarray Sum (Medium)</li> <li> 437. Path Sum III (Medium)</li> <li> 2588. Count the Number of Beautiful Subarrays (Medium)</li> <li> 525. Contiguous Array (Medium)</li> <li> 3026. Maximum Good Subarray Sum (Medium)</li> <li> 1477. Find Two Non-overlapping Sub-arrays Each With Target Sum (Medium)</li> <li> 1546. Maximum Number of Non-Overlapping Subarrays With Sum Equals Target (Medium)</li> <li> 1124. Longest Well-Performing Interval (Medium)</li> <li> 3381. Maximum Subarray Sum With Length Divisible by K (Medium)</li> <li> 2488. Count Subarrays With Median K (Hard)</li> <li> 1590. Make Sum Divisible by P (Medium)</li> <li> 2845. Count of Interesting Subarrays (Medium)</li> <li> 1442. Count Triplets That Can Form Two Arrays of Equal XOR (Medium)</li> <li> 2949. Count Beautiful Substrings II (Hard)</li> <li> 325. Maximum Size Subarray Sum Equals k (Medium) \ud83d\udc51</li> <li> 548. Split Array with Equal Sum (Hard) \ud83d\udc51</li> <li> 1983. Widest Pair of Indices With Equal Range Sum (Medium) \ud83d\udc51</li> <li> 2489. Number of Substrings With Fixed Ratio (Medium) \ud83d\udc51</li> <li> 2950. Number of Divisible Substrings (Medium) \ud83d\udc51</li> <li> 3364. Minimum Positive Sum Subarray  (Easy)</li> <li> 2025. Maximum Number of Ways to Partition an Array (Hard)</li> </ul>"},{"location":"content/endlesscheng/prefix_sum_with_hash_table/#930-binary-subarrays-with-sum","title":"930. Binary Subarrays With Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, sliding window, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/prefix_sum_with_hash_table/#560-subarray-sum-equals-k","title":"560. Subarray Sum Equals K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, prefix sum 560. Subarray Sum Equals K - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Prefix Sum\ndef subarraySum(nums: List[int], k: int) -&gt; int:\n    preSums = defaultdict(int)\n    preSums[0] = 1\n    curSum = 0\n    res = 0\n\n    for num in nums:\n        curSum += num\n        res += preSums[curSum - k]\n        preSums[curSum] += 1\n\n    return res\n\n\nnums = [1, 1, 1]\nk = 2\nprint(subarraySum(nums, k))  # 2\n</code></pre></p> </li> </ul> 560. Subarray Sum Equals K - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint subarraySum(vector&lt;int&gt;&amp; nums, int k) {\n    int n = nums.size();\n    vector&lt;int&gt; prefixSum(n + 1);\n    for (int i = 0; i &lt; n; i++) {\n        prefixSum[i + 1] = prefixSum[i] + nums[i];\n    }\n\n    int res = 0;\n    unordered_map&lt;int, int&gt; cnt;\n\n    for (int ps : prefixSum) {\n        if (cnt.find(ps - k) != cnt.end()) res += cnt[ps - k];\n        cnt[ps]++;\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {1, 1, 1};\n    int k = 2;\n    cout &lt;&lt; subarraySum(nums, k) &lt;&lt; endl;  // 2\n    return 0;\n}\n</code></pre>"},{"location":"content/endlesscheng/prefix_sum_with_hash_table/#1524-number-of-sub-arrays-with-odd-sum","title":"1524. Number of Sub-arrays With Odd Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, dynamic programming, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/prefix_sum_with_hash_table/#974-subarray-sums-divisible-by-k","title":"974. Subarray Sums Divisible by K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, prefix sum 974. Subarray Sums Divisible by K - Python Solution<pre><code>from typing import List\n\n\ndef subarraysDivByK_1(nums: List[int], k: int) -&gt; int:\n    mods = {0: 1}\n    prefixSum, result = 0, 0\n\n    for num in nums:\n        prefixSum += num\n        mod = prefixSum % k\n\n        if mod &lt; 0:\n            mod += k\n\n        if mod in mods:\n            result += mods[mod]\n\n        if mod in mods:\n            mods[mod] += 1\n        else:\n            mods[mod] = 1\n\n    return result\n\n\ndef subarraysDivByK_2(nums: List[int], k: int) -&gt; int:\n    mods = {0: 1}\n    prefixSum, result = 0, 0\n\n    for num in nums:\n        prefixSum += num\n        mod = prefixSum % k\n        result += mods.get(mod, 0)\n        mods[mod] = mods.get(mod, 0) + 1\n\n    return result\n\n\nnums = [4, 5, 0, -2, -3, 1]\nk = 5\nprint(subarraysDivByK_1(nums, k))  # 7\nprint(subarraysDivByK_2(nums, k))  # 7\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/prefix_sum_with_hash_table/#523-continuous-subarray-sum","title":"523. Continuous Subarray Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, prefix sum 523. Continuous Subarray Sum - Python Solution<pre><code>from typing import List\n\n\n# Prefix Sum\ndef checkSubarraySum(nums: List[int], k: int) -&gt; bool:\n    if k == 0:\n        for i in range(1, len(nums)):\n            if nums[i - 1] == 0 and nums[i] == 0:\n                return True\n\n    prefix_sum = 0\n    mod_dict = {0: -1}\n\n    for i, num in enumerate(nums):\n        prefix_sum += num\n        mod = prefix_sum % k\n\n        if mod in mod_dict:\n            if i - mod_dict[mod] &gt; 1:\n                return True\n        else:\n            mod_dict[mod] = i\n\n    return False\n\n\nnums = [23, 2, 4, 6, 7]\nk = 6\nprint(checkSubarraySum(nums, k))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/prefix_sum_with_hash_table/#437-path-sum-iii","title":"437. Path Sum III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree 437. Path Sum III - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   public:\n    int pathSum(TreeNode *root, int targetSum) {\n        int res = 0;\n        unordered_map&lt;long long, int&gt; cnt{{0, 1}};\n\n        auto dfs = [&amp;](auto &amp;&amp;self, TreeNode *node, long long cur) {\n            if (!node) return;\n            cur += node-&gt;val;\n\n            if (cnt.find(cur - targetSum) != cnt.end())\n                res += cnt[cur - targetSum];\n\n            cnt[cur]++;\n            self(self, node-&gt;left, cur);\n            self(self, node-&gt;right, cur);\n            cnt[cur]--;\n        };\n\n        dfs(dfs, root, 0);\n        return res;\n    }\n};\n\nint main() {\n    Solution s;\n    {\n        TreeNode *root = new TreeNode(10);\n        root-&gt;left = new TreeNode(5);\n        root-&gt;right = new TreeNode(-3);\n        root-&gt;left-&gt;left = new TreeNode(3);\n        root-&gt;left-&gt;right = new TreeNode(2);\n        root-&gt;right-&gt;right = new TreeNode(11);\n        root-&gt;left-&gt;left-&gt;left = new TreeNode(3);\n        root-&gt;left-&gt;left-&gt;right = new TreeNode(-2);\n        root-&gt;left-&gt;right-&gt;right = new TreeNode(1);\n        cout &lt;&lt; s.pathSum(root, 8) &lt;&lt; endl;  // 3\n    }\n    {\n        TreeNode *root = new TreeNode(5);\n        root-&gt;left = new TreeNode(4);\n        root-&gt;right = new TreeNode(8);\n        root-&gt;left-&gt;left = new TreeNode(11);\n        root-&gt;right-&gt;left = new TreeNode(13);\n        root-&gt;right-&gt;right = new TreeNode(4);\n        root-&gt;left-&gt;left-&gt;left = new TreeNode(7);\n        root-&gt;left-&gt;left-&gt;right = new TreeNode(2);\n        root-&gt;right-&gt;right-&gt;left = new TreeNode(5);\n        root-&gt;right-&gt;right-&gt;right = new TreeNode(1);\n        cout &lt;&lt; s.pathSum(root, 22) &lt;&lt; endl;  // 3\n    }\n    return 0;\n}\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/prefix_sum_with_hash_table/#2588-count-the-number-of-beautiful-subarrays","title":"2588. Count the Number of Beautiful Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, bit manipulation, prefix sum</p> </li> <li><code>nums = [4, 3, 1, 2, 4]</code></li> <li>In bianry</li> </ul> <pre><code>4 -&gt; 100\n3 -&gt; 011\n1 -&gt; 001\n2 -&gt; 010\n4 -&gt; 100\n</code></pre> 2588. Count the Number of Beautiful Subarrays - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\ndef beautifulSubarrays(nums: List[int]) -&gt; int:\n    res, s = 0, 0\n    cnt = defaultdict(int)\n    cnt[0] = 1\n\n    for x in nums:\n        s ^= x\n        res += cnt[s]\n        cnt[s] += 1\n\n    return res\n\n\nnums = [4, 3, 1, 2, 4]\nprint(beautifulSubarrays(nums))  # 2\n</code></pre>"},{"location":"content/endlesscheng/prefix_sum_with_hash_table/#525-contiguous-array","title":"525. Contiguous Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/prefix_sum_with_hash_table/#3026-maximum-good-subarray-sum","title":"3026. Maximum Good Subarray Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/prefix_sum_with_hash_table/#1477-find-two-non-overlapping-sub-arrays-each-with-target-sum","title":"1477. Find Two Non-overlapping Sub-arrays Each With Target Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, binary search, dynamic programming, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/prefix_sum_with_hash_table/#1546-maximum-number-of-non-overlapping-subarrays-with-sum-equals-target","title":"1546. Maximum Number of Non-Overlapping Subarrays With Sum Equals Target","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, greedy, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/prefix_sum_with_hash_table/#1124-longest-well-performing-interval","title":"1124. Longest Well-Performing Interval","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, stack, monotonic stack, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/prefix_sum_with_hash_table/#3381-maximum-subarray-sum-with-length-divisible-by-k","title":"3381. Maximum Subarray Sum With Length Divisible by K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/prefix_sum_with_hash_table/#2488-count-subarrays-with-median-k","title":"2488. Count Subarrays With Median K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/prefix_sum_with_hash_table/#1590-make-sum-divisible-by-p","title":"1590. Make Sum Divisible by P","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/prefix_sum_with_hash_table/#2845-count-of-interesting-subarrays","title":"2845. Count of Interesting Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/prefix_sum_with_hash_table/#1442-count-triplets-that-can-form-two-arrays-of-equal-xor","title":"1442. Count Triplets That Can Form Two Arrays of Equal XOR","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, bit manipulation, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/prefix_sum_with_hash_table/#2949-count-beautiful-substrings-ii","title":"2949. Count Beautiful Substrings II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, math, string, number theory, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/prefix_sum_with_hash_table/#325-maximum-size-subarray-sum-equals-k","title":"325. Maximum Size Subarray Sum Equals k","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, prefix sum 325. Maximum Size Subarray Sum Equals k - Python Solution<pre><code>from typing import List\n\n\n# Prefix Sum\ndef maxSubArrayLen(nums: List[int], k: int) -&gt; int:\n    res = 0\n    prefix = 0\n    sumMap = {0: -1}  # sum -&gt; index\n\n    for i, num in enumerate(nums):\n        prefix += num\n        if prefix - k in sumMap:\n            res = max(res, i - sumMap[prefix - k])\n        if prefix not in sumMap:\n            sumMap[prefix] = i\n\n    return res\n\n\nnums = [1, -1, 5, -2, 3]\nk = 3\nprint(maxSubArrayLen(nums, k))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/prefix_sum_with_hash_table/#548-split-array-with-equal-sum","title":"548. Split Array with Equal Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/prefix_sum_with_hash_table/#1983-widest-pair-of-indices-with-equal-range-sum","title":"1983. Widest Pair of Indices With Equal Range Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/prefix_sum_with_hash_table/#2489-number-of-substrings-with-fixed-ratio","title":"2489. Number of Substrings With Fixed Ratio","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, math, string, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/prefix_sum_with_hash_table/#2950-number-of-divisible-substrings","title":"2950. Number of Divisible Substrings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, counting, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/prefix_sum_with_hash_table/#3364-minimum-positive-sum-subarray","title":"3364. Minimum Positive Sum Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, sliding window, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/prefix_sum_with_hash_table/#2025-maximum-number-of-ways-to-partition-an-array","title":"2025. Maximum Number of Ways to Partition an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, counting, enumeration, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/prefix_xor_sum/","title":"Prefix XOR Sum","text":""},{"location":"content/endlesscheng/prefix_xor_sum/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1177. Can Make Palindrome from Substring (Medium)</li> <li> 1371. Find the Longest Substring Containing Vowels in Even Counts (Medium)</li> <li> 1542. Find Longest Awesome Substring (Hard)</li> <li> 1915. Number of Wonderful Substrings (Medium)</li> <li> 2791. Count Paths That Can Form a Palindrome in a Tree (Hard)</li> </ul>"},{"location":"content/endlesscheng/prefix_xor_sum/#1177-can-make-palindrome-from-substring","title":"1177. Can Make Palindrome from Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, bit manipulation, prefix sum 1177. Can Make Palindrome from Substring - Python Solution<pre><code>from typing import List\n\n\n# Prefix XOR Sum\ndef canMakePaliQueries(s: str, queries: List[List[int]]) -&gt; List[bool]:\n    sum = [[0] * 26]\n    for c in s:\n        sum.append(sum[-1].copy())\n        sum[-1][ord(c) - ord(\"a\")] ^= 1  # \u5947\u6570\u53d8\u5076\u6570\uff0c\u5076\u6570\u53d8\u5947\u6570\n\n    ans = []\n    for left, right, k in queries:\n        m = 0\n        for sl, sr in zip(sum[left], sum[right + 1]):\n            m += sr ^ sl\n        ans.append(m // 2 &lt;= k)\n    return ans\n\n\nif __name__ == \"__main__\":\n    s = \"abcda\"\n    queries = [[3, 3, 0], [1, 2, 0], [0, 3, 1], [0, 3, 2], [0, 4, 1]]\n    assert canMakePaliQueries(s, queries) == [True, False, False, True, True]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/prefix_xor_sum/#1371-find-the-longest-substring-containing-vowels-in-even-counts","title":"1371. Find the Longest Substring Containing Vowels in Even Counts","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, bit manipulation, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/prefix_xor_sum/#1542-find-longest-awesome-substring","title":"1542. Find Longest Awesome Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/prefix_xor_sum/#1915-number-of-wonderful-substrings","title":"1915. Number of Wonderful Substrings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, bit manipulation, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/prefix_xor_sum/#2791-count-paths-that-can-form-a-palindrome-in-a-tree","title":"2791. Count Paths That Can Form a Palindrome in a Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, bit manipulation, tree, depth first search, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/prime_check/","title":"Prime Check","text":""},{"location":"content/endlesscheng/prime_check/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3115. Maximum Prime Difference (Medium)</li> <li> 2614. Prime In Diagonal (Easy)</li> <li> 762. Prime Number of Set Bits in Binary Representation (Easy)</li> <li> 3044. Most Frequent Prime (Medium)</li> <li> 866. Prime Palindrome (Medium)</li> </ul>"},{"location":"content/endlesscheng/prime_check/#3115-maximum-prime-difference","title":"3115. Maximum Prime Difference","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/prime_check/#2614-prime-in-diagonal","title":"2614. Prime In Diagonal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, math, matrix, number theory 2614. Prime In Diagonal - Python Solution<pre><code>from math import isqrt\nfrom typing import List\n\n\n# Prime\ndef diagonalPrime(nums: List[List[int]]) -&gt; int:\n    def is_prime(n):\n        if n &lt;= 1:\n            return False\n\n        for i in range(2, isqrt(n) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    res = 0\n    for i, row in enumerate(nums):\n        for x in row[i], row[-1 - i]:\n            if x &gt; res and is_prime(x):\n                res = x\n\n    return res\n\n\nif __name__ == \"__main__\":\n    nums = [[1, 2, 3], [5, 6, 7], [9, 10, 11]]\n    print(diagonalPrime(nums))  # 11\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/prime_check/#762-prime-number-of-set-bits-in-binary-representation","title":"762. Prime Number of Set Bits in Binary Representation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/prime_check/#3044-most-frequent-prime","title":"3044. Most Frequent Prime","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, matrix, counting, enumeration, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/prime_check/#866-prime-palindrome","title":"866. Prime Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/prime_factorization/","title":"Prime Factorization","text":""},{"location":"content/endlesscheng/prime_factorization/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2521. Distinct Prime Factors of Product of Array (Medium)</li> <li> 2507. Smallest Value After Replacing With Sum of Prime Factors (Medium)</li> <li> 3326. Minimum Division Operations to Make Array Non Decreasing (Medium)</li> <li> 2584. Split the Array to Make Coprime Products (Hard)</li> <li> 2709. Greatest Common Divisor Traversal (Hard)</li> <li> 2862. Maximum Element-Sum of a Complete Subset of Indices (Hard)</li> <li> 2818. Apply Operations to Maximize Score (Hard)</li> <li> 1998. GCD Sort of an Array (Hard)</li> <li> 1735. Count Ways to Make Array With Product (Hard)</li> <li> 2338. Count the Number of Ideal Arrays (Hard)</li> </ul>"},{"location":"content/endlesscheng/prime_factorization/#2521-distinct-prime-factors-of-product-of-array","title":"2521. Distinct Prime Factors of Product of Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/prime_factorization/#2507-smallest-value-after-replacing-with-sum-of-prime-factors","title":"2507. Smallest Value After Replacing With Sum of Prime Factors","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, simulation, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/prime_factorization/#3326-minimum-division-operations-to-make-array-non-decreasing","title":"3326. Minimum Division Operations to Make Array Non Decreasing","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, greedy, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/prime_factorization/#2584-split-the-array-to-make-coprime-products","title":"2584. Split the Array to Make Coprime Products","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, math, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/prime_factorization/#2709-greatest-common-divisor-traversal","title":"2709. Greatest Common Divisor Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, union find, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/prime_factorization/#2862-maximum-element-sum-of-a-complete-subset-of-indices","title":"2862. Maximum Element-Sum of a Complete Subset of Indices","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/prime_factorization/#2818-apply-operations-to-maximize-score","title":"2818. Apply Operations to Maximize Score","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, stack, greedy, sorting, monotonic stack, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/prime_factorization/#1998-gcd-sort-of-an-array","title":"1998. GCD Sort of an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, union find, sorting, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/prime_factorization/#1735-count-ways-to-make-array-with-product","title":"1735. Count Ways to Make Array With Product","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, dynamic programming, combinatorics, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/prime_factorization/#2338-count-the-number-of-ideal-arrays","title":"2338. Count the Number of Ideal Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, dynamic programming, combinatorics, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/prime_preprocessing/","title":"Prime Preprocessing","text":""},{"location":"content/endlesscheng/prime_preprocessing/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 204. Count Primes (Medium)</li> <li> 2761. Prime Pairs With Target Sum (Medium)</li> <li> 3233. Find the Count of Numbers Which Are Not Special (Medium)</li> <li> 2523. Closest Prime Numbers in Range (Medium)</li> <li> 2601. Prime Subtraction Operation (Medium)</li> </ul>"},{"location":"content/endlesscheng/prime_preprocessing/#204-count-primes","title":"204. Count Primes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, enumeration, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/prime_preprocessing/#2761-prime-pairs-with-target-sum","title":"2761. Prime Pairs With Target Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, enumeration, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/prime_preprocessing/#3233-find-the-count-of-numbers-which-are-not-special","title":"3233. Find the Count of Numbers Which Are Not Special","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/prime_preprocessing/#2523-closest-prime-numbers-in-range","title":"2523. Closest Prime Numbers in Range","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/prime_preprocessing/#2601-prime-subtraction-operation","title":"2601. Prime Subtraction Operation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, binary search, greedy, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/probability_and_expectation/","title":"Probability and Expectation","text":""},{"location":"content/endlesscheng/probability_and_expectation/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1227. Airplane Seat Assignment Probability (Medium)</li> <li> 688. Knight Probability in Chessboard (Medium)</li> <li> 837. New 21 Game (Medium)</li> <li> 1467. Probability of a Two Boxes Having The Same Number of Distinct Balls (Hard)</li> <li> 808. Soup Servings (Medium)</li> <li> 1230. Toss Strange Coins (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/probability_and_expectation/#1227-airplane-seat-assignment-probability","title":"1227. Airplane Seat Assignment Probability","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, brainteaser, probability and statistics</p> </li> </ul>"},{"location":"content/endlesscheng/probability_and_expectation/#688-knight-probability-in-chessboard","title":"688. Knight Probability in Chessboard","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/probability_and_expectation/#837-new-21-game","title":"837. New 21 Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, sliding window, probability and statistics</p> </li> </ul>"},{"location":"content/endlesscheng/probability_and_expectation/#1467-probability-of-a-two-boxes-having-the-same-number-of-distinct-balls","title":"1467. Probability of a Two Boxes Having The Same Number of Distinct Balls","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, dynamic programming, backtracking, combinatorics, probability and statistics</p> </li> </ul>"},{"location":"content/endlesscheng/probability_and_expectation/#808-soup-servings","title":"808. Soup Servings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, probability and statistics</p> </li> </ul>"},{"location":"content/endlesscheng/probability_and_expectation/#1230-toss-strange-coins","title":"1230. Toss Strange Coins","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, dynamic programming, probability and statistics</p> </li> </ul>"},{"location":"content/endlesscheng/product_greedy/","title":"Product Greedy","text":""},{"location":"content/endlesscheng/product_greedy/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 628. Maximum Product of Three Numbers (Easy)</li> <li> 1567. Maximum Length of Subarray With Positive Product (Medium)</li> </ul>"},{"location":"content/endlesscheng/product_greedy/#628-maximum-product-of-three-numbers","title":"628. Maximum Product of Three Numbers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, math, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/product_greedy/#1567-maximum-length-of-subarray-with-positive-product","title":"1567. Maximum Length of Subarray With Positive Product","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/queue_basics/","title":"Queue Basics","text":""},{"location":"content/endlesscheng/queue_basics/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 933. Number of Recent Calls (Easy)</li> <li> 950. Reveal Cards In Increasing Order (Medium)</li> <li> 649. Dota2 Senate (Medium)</li> <li> 346. Moving Average from Data Stream (Easy) \ud83d\udc51</li> <li> 362. Design Hit Counter (Medium) \ud83d\udc51</li> <li> 379. Design Phone Directory (Medium) \ud83d\udc51</li> <li> 1429. First Unique Number (Medium) \ud83d\udc51</li> <li> 2534. Time Taken to Cross the Door (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/queue_basics/#933-number-of-recent-calls","title":"933. Number of Recent Calls","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: design, queue, data stream</p> </li> </ul>"},{"location":"content/endlesscheng/queue_basics/#950-reveal-cards-in-increasing-order","title":"950. Reveal Cards In Increasing Order","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, queue, sorting, simulation</p> </li> </ul>"},{"location":"content/endlesscheng/queue_basics/#649-dota2-senate","title":"649. Dota2 Senate","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, greedy, queue</p> </li> </ul>"},{"location":"content/endlesscheng/queue_basics/#346-moving-average-from-data-stream","title":"346. Moving Average from Data Stream","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, design, queue, data stream 346. Moving Average from Data Stream - Python Solution<pre><code>from collections import deque\n\n\n# Deque\nclass MovingAverage:\n    def __init__(self, size: int):\n        self.q = deque()\n        self.cur = 0\n        self.sum = 0\n        self.size = size\n\n    def next(self, val: int) -&gt; float:\n        if self.cur &gt;= self.size:\n            self.sum -= self.q.popleft()\n            self.cur -= 1\n\n        self.q.append(val)\n        self.sum += val\n        self.cur += 1\n\n        return self.sum / self.cur\n\n\nif __name__ == \"__main__\":\n    ma = MovingAverage(3)\n    assert ma.next(1) == 1.0\n    assert ma.next(10) == 5.5\n    assert ma.next(3) == 4.666666666666667\n    assert ma.next(5) == 6.0\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/queue_basics/#362-design-hit-counter","title":"362. Design Hit Counter","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, design, queue, data stream 362. Design Hit Counter - Python Solution<pre><code>from collections import deque\n\n\nclass HitCounter:\n\n    def __init__(self):\n        self.hits = deque()\n\n    def hit(self, timestamp: int) -&gt; None:\n        self.hits.append(timestamp)\n\n    def getHits(self, timestamp: int) -&gt; int:\n        # Remove hits that are older than 5 minutes (300 seconds)\n        while self.hits and self.hits[0] &lt;= timestamp - 300:\n            self.hits.popleft()\n        return len(self.hits)\n\n\nobj = HitCounter()\nobj.hit(1)\nobj.hit(2)\nobj.hit(3)\nprint(obj.getHits(4))  # 3\nobj.hit(300)\nprint(obj.getHits(300))  # 4\nprint(obj.getHits(301))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/queue_basics/#379-design-phone-directory","title":"379. Design Phone Directory","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, linked list, design, queue</p> </li> </ul>"},{"location":"content/endlesscheng/queue_basics/#1429-first-unique-number","title":"1429. First Unique Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, design, queue, data stream 1429. First Unique Number - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# Deque\nclass FirstUnique:\n\n    def __init__(self, nums: List[int]):\n        self.all = set()\n        self.multi = set()\n\n        for num in nums:\n            if num in self.all:\n                self.multi.add(num)\n            self.all.add(num)\n\n        self.q = deque([i for i in nums if i not in self.multi])\n\n    def showFirstUnique(self) -&gt; int:\n        while self.q and self.q[0] in self.multi:\n            self.q.popleft()\n        return self.q[0] if self.q else -1\n\n    def add(self, value: int) -&gt; None:\n        if value not in self.all:\n            self.all.add(value)\n            self.q.append(value)\n        elif value not in self.multi:\n            self.multi.add(value)\n\n\nif __name__ == \"__main__\":\n    nums = [2, 3, 5]\n    firstUnique = FirstUnique(nums)\n    assert firstUnique.showFirstUnique() == 2\n    firstUnique.add(5)\n    assert firstUnique.showFirstUnique() == 2\n    firstUnique.add(2)\n    assert firstUnique.showFirstUnique() == 3\n    firstUnique.add(3)\n    assert firstUnique.showFirstUnique() == -1\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/queue_basics/#2534-time-taken-to-cross-the-door","title":"2534. Time Taken to Cross the Door","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, queue, simulation</p> </li> </ul>"},{"location":"content/endlesscheng/queue_design/","title":"Queue Design","text":""},{"location":"content/endlesscheng/queue_design/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 225. Implement Stack using Queues (Easy)</li> <li> 232. Implement Queue using Stacks (Easy)</li> <li> 622. Design Circular Queue (Medium)</li> <li> 641. Design Circular Deque (Medium)</li> <li> 1670. Design Front Middle Back Queue (Medium)</li> </ul>"},{"location":"content/endlesscheng/queue_design/#225-implement-stack-using-queues","title":"225. Implement Stack using Queues","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: stack, design, queue 225. Implement Stack using Queues - Python Solution<pre><code>from collections import deque\n\n\n# Queue\nclass MyStack:\n\n    def __init__(self):\n        self.q1 = deque()  # main queue\n        self.q2 = deque()  # auxiliary queue\n\n    def push(self, x: int) -&gt; None:\n        self.q1.append(x)\n\n    def pop(self) -&gt; int:\n        while len(self.q1) &gt; 1:\n            self.q2.append(self.q1.popleft())\n        res = self.q1.popleft()\n        self.q1, self.q2 = self.q2, self.q1\n        return res\n\n    def top(self) -&gt; int:\n        while len(self.q1) &gt; 1:\n            self.q2.append(self.q1.popleft())\n        res = self.q1[0]\n        self.q2.append(self.q1.popleft())\n        self.q1, self.q2 = self.q2, self.q1\n        return res\n\n    def empty(self) -&gt; bool:\n        return not self.q1\n\n\nobj = MyStack()\nobj.push(1)\nobj.push(2)\nobj.push(3)\nobj.push(4)\nprint(obj.pop())  # 4\nprint(obj.top())  # 3\nprint(obj.empty())  # False\nprint(obj.pop())  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/queue_design/#232-implement-queue-using-stacks","title":"232. Implement Queue using Stacks","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: stack, design, queue</p> </li> <li>Implement the following operations of a queue using stacks.<ul> <li><code>push(x)</code> - Push element x to the back of queue.</li> <li><code>pop()</code> - Removes the element from in front of queue.</li> <li><code>peek()</code> - Get the front element.</li> <li><code>empty()</code> - Return whether the queue is empty.</li> </ul> </li> </ul> 232. Implement Queue using Stacks - Python Solution<pre><code>class MyQueue:\n    def __init__(self):\n        self.stack_in = []\n        self.stack_out = []\n\n    def push(self, x: int) -&gt; None:\n        self.stack_in.append(x)\n\n    def pop(self) -&gt; int:\n        if self.empty():\n            return None\n\n        if self.stack_out:\n            return self.stack_out.pop()\n        else:\n            for _ in range(len(self.stack_in)):\n                self.stack_out.append(self.stack_in.pop())\n            return self.stack_out.pop()\n\n    def peek(self) -&gt; int:\n        answer = self.pop()\n        self.stack_out.append(answer)\n        return answer\n\n    def empty(self) -&gt; bool:\n        return not (self.stack_in or self.stack_out)\n\n\nobj = MyQueue()\nobj.push(1)\nprint(obj.pop())  # 1\nprint(obj.peek())  # None\nprint(obj.empty())  # False\n</code></pre>"},{"location":"content/endlesscheng/queue_design/#622-design-circular-queue","title":"622. Design Circular Queue","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, linked list, design, queue 622. Design Circular Queue - Python Solution<pre><code># Design\nclass MyCircularQueue:\n\n    def __init__(self, k: int):\n        self.queue = [0] * k\n        self.head = 0\n        self.tail = -1\n        self.size = 0\n        self.capacity = k\n\n    def enQueue(self, value: int) -&gt; bool:\n        if self.isFull():\n            return False\n        self.tail = (self.tail + 1) % self.capacity\n        self.queue[self.tail] = value\n        self.size += 1\n        return True\n\n    def deQueue(self) -&gt; bool:\n        if self.isEmpty():\n            return False\n        self.head = (self.head + 1) % self.capacity\n        self.size -= 1\n        return True\n\n    def Front(self) -&gt; int:\n        if self.isEmpty():\n            return -1\n        return self.queue[self.head]\n\n    def Rear(self) -&gt; int:\n        if self.isEmpty():\n            return -1\n        return self.queue[self.tail]\n\n    def isEmpty(self) -&gt; bool:\n        return self.size == 0\n\n    def isFull(self) -&gt; bool:\n        return self.size == self.capacity\n\n\nobj = MyCircularQueue(3)\nprint(obj.enQueue(1))  # True\nprint(obj.enQueue(2))  # True\nprint(obj.enQueue(3))  # True\nprint(obj.enQueue(4))  # False\nprint(obj.Rear())  # 3\nprint(obj.isFull())  # True\nprint(obj.deQueue())  # True\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/queue_design/#641-design-circular-deque","title":"641. Design Circular Deque","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, linked list, design, queue</p> </li> </ul>"},{"location":"content/endlesscheng/queue_design/#1670-design-front-middle-back-queue","title":"1670. Design Front Middle Back Queue","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, linked list, design, queue, data stream</p> </li> </ul>"},{"location":"content/endlesscheng/randomized_algorithms/","title":"Randomized Algorithms","text":""},{"location":"content/endlesscheng/randomized_algorithms/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 398. Random Pick Index (Medium)</li> <li> 382. Linked List Random Node (Medium)</li> <li> 384. Shuffle an Array (Medium)</li> <li> 470. Implement Rand10() Using Rand7() (Medium)</li> <li> 528. Random Pick with Weight (Medium)</li> <li> 710. Random Pick with Blacklist (Hard)</li> <li> 478. Generate Random Point in a Circle (Medium)</li> <li> 497. Random Point in Non-overlapping Rectangles (Medium)</li> <li> 519. Random Flip Matrix (Medium)</li> <li> 380. Insert Delete GetRandom O(1) (Medium)</li> <li> 381. Insert Delete GetRandom O(1) - Duplicates allowed (Hard)</li> <li> 1515. Best Position for a Service Centre (Hard)</li> <li> 1968. Array With Elements Not Equal to Average of Neighbors (Medium)</li> </ul>"},{"location":"content/endlesscheng/randomized_algorithms/#398-random-pick-index","title":"398. Random Pick Index","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, math, reservoir sampling, randomized</p> </li> </ul>"},{"location":"content/endlesscheng/randomized_algorithms/#382-linked-list-random-node","title":"382. Linked List Random Node","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, math, reservoir sampling, randomized</p> </li> </ul>"},{"location":"content/endlesscheng/randomized_algorithms/#384-shuffle-an-array","title":"384. Shuffle an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, design, randomized</p> </li> </ul>"},{"location":"content/endlesscheng/randomized_algorithms/#470-implement-rand10-using-rand7","title":"470. Implement Rand10() Using Rand7()","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, rejection sampling, randomized, probability and statistics</p> </li> </ul>"},{"location":"content/endlesscheng/randomized_algorithms/#528-random-pick-with-weight","title":"528. Random Pick with Weight","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, binary search, prefix sum, randomized</p> </li> </ul>"},{"location":"content/endlesscheng/randomized_algorithms/#710-random-pick-with-blacklist","title":"710. Random Pick with Blacklist","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, math, binary search, sorting, randomized</p> </li> </ul>"},{"location":"content/endlesscheng/randomized_algorithms/#478-generate-random-point-in-a-circle","title":"478. Generate Random Point in a Circle","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, geometry, rejection sampling, randomized</p> </li> </ul>"},{"location":"content/endlesscheng/randomized_algorithms/#497-random-point-in-non-overlapping-rectangles","title":"497. Random Point in Non-overlapping Rectangles","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, binary search, reservoir sampling, prefix sum, ordered set, randomized</p> </li> </ul>"},{"location":"content/endlesscheng/randomized_algorithms/#519-random-flip-matrix","title":"519. Random Flip Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, math, reservoir sampling, randomized</p> </li> </ul>"},{"location":"content/endlesscheng/randomized_algorithms/#380-insert-delete-getrandom-o1","title":"380. Insert Delete GetRandom O(1)","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, design, randomized 380. Insert Delete GetRandom O(1) - Python Solution<pre><code>import random\n\n\nclass RandomizedSet:\n    def __init__(self):\n        self.dict = {}\n        self.list = []\n\n    def insert(self, val: int) -&gt; bool:\n        if val in self.dict:\n            return False\n        self.dict[val] = len(self.list)\n        self.list.append(val)\n\n        return True\n\n    def remove(self, val: int) -&gt; bool:\n        if val not in self.dict:\n            return False\n        last_element = self.list[-1]\n        idx = self.dict[val]\n        self.list[idx] = last_element\n        self.dict[last_element] = idx\n        self.list.pop()\n        del self.dict[val]\n        return True\n\n    def getRandom(self) -&gt; int:\n        return random.choice(self.list)\n\n\nobj = RandomizedSet()\nprint(obj.insert(1))  # True\nprint(obj.remove(2))  # False\nprint(obj.insert(2))  # True\nprint(obj.getRandom())  # 1 or 2\nprint(obj.remove(1))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/randomized_algorithms/#381-insert-delete-getrandom-o1-duplicates-allowed","title":"381. Insert Delete GetRandom O(1) - Duplicates allowed","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, math, design, randomized</p> </li> </ul>"},{"location":"content/endlesscheng/randomized_algorithms/#1515-best-position-for-a-service-centre","title":"1515. Best Position for a Service Centre","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, geometry, randomized</p> </li> </ul>"},{"location":"content/endlesscheng/randomized_algorithms/#1968-array-with-elements-not-equal-to-average-of-neighbors","title":"1968. Array With Elements Not Equal to Average of Neighbors","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/rectangle/","title":"Rectangle","text":""},{"location":"content/endlesscheng/rectangle/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 84. Largest Rectangle in Histogram (Hard)</li> <li> 1793. Maximum Score of a Good Subarray (Hard)</li> <li> 85. Maximal Rectangle (Hard)</li> <li> 1504. Count Submatrices With All Ones (Medium)</li> <li> 42. Trapping Rain Water (Hard)</li> <li> 755. Pour Water (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/rectangle/#84-largest-rectangle-in-histogram","title":"84. Largest Rectangle in Histogram","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, stack, monotonic stack 84. Largest Rectangle in Histogram - Python Solution<pre><code>from typing import List\n\n\n# Monotonic Stack\ndef largestRectangleArea(heights: List[int]) -&gt; int:\n    stack = []\n    max_area = 0\n    n = len(heights)\n\n    for i in range(n + 1):\n        h = 0 if i == n else heights[i]\n\n        while stack and h &lt; heights[stack[-1]]:\n            height = heights[stack.pop()]\n            width = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, height * width)\n\n        stack.append(i)\n\n    return max_area\n\n\nprint(largestRectangleArea([2, 1, 5, 6, 2, 3]))  # 10\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/rectangle/#1793-maximum-score-of-a-good-subarray","title":"1793. Maximum Score of a Good Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, binary search, stack, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/rectangle/#85-maximal-rectangle","title":"85. Maximal Rectangle","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, stack, matrix, monotonic stack</p> </li> <li>Return the area of the largest rectangle that can be formed within a rectangle of 1's.</li> </ul> <p></p> 85. Maximal Rectangle - Python Solution<pre><code>from typing import List\n\n\n# Monotonic Stack\ndef maximalRectangle(matrix: List[List[str]]) -&gt; int:\n    if not matrix or not matrix[0]:\n        return 0\n\n    n = len(matrix[0])\n    heights = [0] * (n + 1)\n    max_area = 0\n\n    for row in matrix:\n        for i in range(n):\n            if row[i] == \"1\":\n                heights[i] += 1\n            else:\n                heights[i] = 0\n\n        stack = [-1]\n        for i in range(n + 1):\n            while heights[i] &lt; heights[stack[-1]]:\n                h = heights[stack.pop()]\n                w = i - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            stack.append(i)\n\n    return max_area\n\n\nmatrix = [\n    [\"1\", \"0\", \"1\", \"0\", \"0\"],\n    [\"1\", \"0\", \"1\", \"1\", \"1\"],\n    [\"1\", \"1\", \"1\", \"1\", \"1\"],\n    [\"1\", \"0\", \"0\", \"1\", \"0\"],\n]\nprint(maximalRectangle(matrix))  # 6\n</code></pre>"},{"location":"content/endlesscheng/rectangle/#1504-count-submatrices-with-all-ones","title":"1504. Count Submatrices With All Ones","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, stack, matrix, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/rectangle/#42-trapping-rain-water","title":"42. Trapping Rain Water","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, dynamic programming, stack, monotonic stack</p> </li> <li></li> </ul> Approach Time Space DP O(N) O(N) Left Right O(N) O(1) Monotonic O(N) O(N) 42. Trapping Rain Water - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef trapDP(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    n = len(height)\n    maxLeft, maxRight = [0 for _ in range(n)], [0 for _ in range(n)]\n\n    for i in range(1, n):\n        maxLeft[i] = max(maxLeft[i - 1], height[i - 1])\n\n    for i in range(n - 2, -1, -1):\n        maxRight[i] = max(maxRight[i + 1], height[i + 1])\n\n    res = 0\n    for i in range(n):\n        res += max(0, min(maxLeft[i], maxRight[i]) - height[i])\n\n    return res\n\n\n# Left Right Pointers\ndef trapLR(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    left, right = 0, len(height) - 1\n    maxL, maxR = height[left], height[right]\n    res = 0\n\n    while left &lt; right:\n        if maxL &lt; maxR:\n            left += 1\n            maxL = max(maxL, height[left])\n            res += maxL - height[left]\n        else:\n            right -= 1\n            maxR = max(maxR, height[right])\n            res += maxR - height[right]\n\n    return res\n\n\n# Monotonic Stack\ndef trapStack(height: List[int]) -&gt; int:\n    stack = []\n    total = 0\n\n    for i in range(len(height)):\n        while stack and height[i] &gt; height[stack[-1]]:\n            top = stack.pop()\n            if not stack:\n                break\n            distance = i - stack[-1] - 1\n            bounded_height = min(height[i], height[stack[-1]]) - height[top]\n            total += distance * bounded_height\n        stack.append(i)\n\n    return total\n\n\nheight = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\nprint(trapDP(height))  # 6\nprint(trapLR(height))  # 6\nprint(trapStack(height))  # 6\n</code></pre> 42. Trapping Rain Water - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int trap(vector&lt;int&gt; &amp;height)\n    {\n        if (height.empty())\n            return 0;\n\n        int res = 0;\n        int left = 0, right = height.size() - 1;\n        int maxL = height[left], maxR = height[right];\n\n        while (left &lt; right)\n        {\n            if (maxL &lt; maxR)\n            {\n                left++;\n                maxL = max(maxL, height[left]);\n                res += maxL - height[left];\n            }\n            else\n            {\n                right--;\n                maxR = max(maxR, height[right]);\n                res += maxR - height[right];\n            }\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    vector&lt;int&gt; height = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};\n    Solution solution;\n    cout &lt;&lt; solution.trap(height) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/endlesscheng/rectangle/#755-pour-water","title":"755. Pour Water","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, simulation</p> </li> </ul>"},{"location":"content/endlesscheng/rectangles_and_polygons/","title":"Rectangles and Polygons","text":""},{"location":"content/endlesscheng/rectangles_and_polygons/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 836. Rectangle Overlap (Easy)</li> <li> 223. Rectangle Area (Medium)</li> <li> 593. Valid Square (Medium)</li> <li> 939. Minimum Area Rectangle (Medium)</li> <li> 963. Minimum Area Rectangle II (Medium)</li> <li> 469. Convex Polygon (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/rectangles_and_polygons/#836-rectangle-overlap","title":"836. Rectangle Overlap","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, geometry</p> </li> </ul>"},{"location":"content/endlesscheng/rectangles_and_polygons/#223-rectangle-area","title":"223. Rectangle Area","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, geometry</p> </li> </ul>"},{"location":"content/endlesscheng/rectangles_and_polygons/#593-valid-square","title":"593. Valid Square","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, geometry</p> </li> </ul>"},{"location":"content/endlesscheng/rectangles_and_polygons/#939-minimum-area-rectangle","title":"939. Minimum Area Rectangle","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, geometry, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/rectangles_and_polygons/#963-minimum-area-rectangle-ii","title":"963. Minimum Area Rectangle II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, geometry</p> </li> </ul>"},{"location":"content/endlesscheng/rectangles_and_polygons/#469-convex-polygon","title":"469. Convex Polygon","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, geometry</p> </li> </ul>"},{"location":"content/endlesscheng/regret_greedy/","title":"Regret Greedy","text":""},{"location":"content/endlesscheng/regret_greedy/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1642. Furthest Building You Can Reach (Medium)</li> <li> 630. Course Schedule III (Hard)</li> <li> 871. Minimum Number of Refueling Stops (Hard)</li> <li> 3362. Zero Array Transformation III (Medium)</li> <li> 2813. Maximum Elegance of a K-Length Subsequence (Hard)</li> <li> 3049. Earliest Second to Mark Indices II (Hard)</li> <li> 2599. Make the Prefix Sum Non-negative (Medium) \ud83d\udc51</li> <li> 2463. Minimum Total Distance Traveled (Hard)</li> </ul>"},{"location":"content/endlesscheng/regret_greedy/#1642-furthest-building-you-can-reach","title":"1642. Furthest Building You Can Reach","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/regret_greedy/#630-course-schedule-iii","title":"630. Course Schedule III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sorting, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/regret_greedy/#871-minimum-number-of-refueling-stops","title":"871. Minimum Number of Refueling Stops","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, greedy, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/regret_greedy/#3362-zero-array-transformation-iii","title":"3362. Zero Array Transformation III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting, heap priority queue, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/regret_greedy/#2813-maximum-elegance-of-a-k-length-subsequence","title":"2813. Maximum Elegance of a K-Length Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, stack, greedy, sorting, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/regret_greedy/#3049-earliest-second-to-mark-indices-ii","title":"3049. Earliest Second to Mark Indices II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, greedy, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/regret_greedy/#2599-make-the-prefix-sum-non-negative","title":"2599. Make the Prefix Sum Non-negative","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/regret_greedy/#2463-minimum-total-distance-traveled","title":"2463. Minimum Total Distance Traveled","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/regret_heap/","title":"Regret Heap","text":""},{"location":"content/endlesscheng/regret_heap/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1642. Furthest Building You Can Reach (Medium)</li> <li> 630. Course Schedule III (Hard)</li> <li> 871. Minimum Number of Refueling Stops (Hard)</li> <li> 3362. Zero Array Transformation III (Medium)</li> <li> 2813. Maximum Elegance of a K-Length Subsequence (Hard)</li> <li> 3049. Earliest Second to Mark Indices II (Hard)</li> <li> 2599. Make the Prefix Sum Non-negative (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/regret_heap/#1642-furthest-building-you-can-reach","title":"1642. Furthest Building You Can Reach","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/regret_heap/#630-course-schedule-iii","title":"630. Course Schedule III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sorting, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/regret_heap/#871-minimum-number-of-refueling-stops","title":"871. Minimum Number of Refueling Stops","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, greedy, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/regret_heap/#3362-zero-array-transformation-iii","title":"3362. Zero Array Transformation III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting, heap priority queue, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/regret_heap/#2813-maximum-elegance-of-a-k-length-subsequence","title":"2813. Maximum Elegance of a K-Length Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, stack, greedy, sorting, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/regret_heap/#3049-earliest-second-to-mark-indices-ii","title":"3049. Earliest Second to Mark Indices II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, greedy, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/regret_heap/#2599-make-the-prefix-sum-non-negative","title":"2599. Make the Prefix Sum Non-negative","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/reverse_thinking/","title":"Reverse Thinking","text":""},{"location":"content/endlesscheng/reverse_thinking/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2139. Minimum Moves to Reach Target Score (Medium)</li> <li> 1558. Minimum Numbers of Function Calls to Make Target Array (Medium)</li> <li> 554. Brick Wall (Medium)</li> <li> 2718. Sum of Matrix After Queries (Medium)</li> <li> 417. Pacific Atlantic Water Flow (Medium)</li> <li> 991. Broken Calculator (Medium)</li> <li> 2227. Encrypt and Decrypt Strings (Hard)</li> <li> 3419. Minimize the Maximum Edge Weight of Graph (Medium)</li> <li> 936. Stamping The Sequence (Hard)</li> </ul>"},{"location":"content/endlesscheng/reverse_thinking/#2139-minimum-moves-to-reach-target-score","title":"2139. Minimum Moves to Reach Target Score","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/reverse_thinking/#1558-minimum-numbers-of-function-calls-to-make-target-array","title":"1558. Minimum Numbers of Function Calls to Make Target Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/reverse_thinking/#554-brick-wall","title":"554. Brick Wall","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table</p> </li> </ul>"},{"location":"content/endlesscheng/reverse_thinking/#2718-sum-of-matrix-after-queries","title":"2718. Sum of Matrix After Queries","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table</p> </li> </ul>"},{"location":"content/endlesscheng/reverse_thinking/#417-pacific-atlantic-water-flow","title":"417. Pacific Atlantic Water Flow","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, matrix 417. Pacific Atlantic Water Flow - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef pacificAtlanticDFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(r, c, visited, prev_height):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or heights[r][c] &lt; prev_height\n            or (r, c) in visited\n        ):\n            return None\n\n        visited.add((r, c))\n        height = heights[r][c]\n        for dr, dc in directions:\n            dfs(dr + r, dc + c, visited, height)\n\n    for c in range(n):\n        dfs(0, c, pac, heights[0][c])\n        dfs(m - 1, c, atl, heights[m - 1][c])\n\n    for r in range(m):\n        dfs(r, 0, pac, heights[r][0])\n        dfs(r, n - 1, atl, heights[r][n - 1])\n\n    return list(pac &amp; atl)\n\n\n# BFS\ndef pacificAtlanticBFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def bfs(r, c, visited):\n        q = deque([(r, c)])\n        visited.add((r, c))\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr in range(m)\n                    and nc in range(n)\n                    and heights[row][col] &lt;= heights[nr][nc]\n                    and (nr, nc) not in visited\n                ):\n                    q.append((nr, nc))\n                    visited.add((nr, nc))\n\n    for c in range(n):\n        bfs(0, c, pac)  # top\n        bfs(m - 1, c, atl)  # bottom\n\n    for r in range(m):\n        bfs(r, 0, pac)  # left\n        bfs(r, n - 1, atl)  # right\n\n    return list(pac &amp; atl)\n\n\nheights = [\n    [1, 2, 2, 3, 5],\n    [3, 2, 3, 4, 4],\n    [2, 4, 5, 3, 1],\n    [6, 7, 1, 4, 5],\n    [5, 1, 1, 2, 4],\n]\nprint(pacificAtlanticDFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\nprint(pacificAtlanticBFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/reverse_thinking/#991-broken-calculator","title":"991. Broken Calculator","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/reverse_thinking/#2227-encrypt-and-decrypt-strings","title":"2227. Encrypt and Decrypt Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, string, design, trie</p> </li> </ul>"},{"location":"content/endlesscheng/reverse_thinking/#3419-minimize-the-maximum-edge-weight-of-graph","title":"3419. Minimize the Maximum Edge Weight of Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: binary search, depth first search, breadth first search, graph, shortest path</p> </li> </ul>"},{"location":"content/endlesscheng/reverse_thinking/#936-stamping-the-sequence","title":"936. Stamping The Sequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, stack, greedy, queue</p> </li> </ul>"},{"location":"content/endlesscheng/segment_tree/","title":"Segment Tree","text":""},{"location":"content/endlesscheng/segment_tree/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1157. Online Majority Element In Subarray (Hard)</li> <li> 2407. Longest Increasing Subsequence II (Hard)</li> <li> 2940. Find Building Where Alice and Bob Can Meet (Hard)</li> <li> 2286. Booking Concert Tickets in Groups (Hard)</li> <li> 3161. Block Placement Queries (Hard)</li> <li> 2213. Longest Substring of One Repeating Character (Hard)</li> <li> 3165. Maximum Sum of Subsequence With Non-adjacent Elements (Hard)</li> </ul>"},{"location":"content/endlesscheng/segment_tree/#1157-online-majority-element-in-subarray","title":"1157. Online Majority Element In Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, design, binary indexed tree, segment tree</p> </li> </ul>"},{"location":"content/endlesscheng/segment_tree/#2407-longest-increasing-subsequence-ii","title":"2407. Longest Increasing Subsequence II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, divide and conquer, dynamic programming, binary indexed tree, segment tree, queue, monotonic queue</p> </li> </ul>"},{"location":"content/endlesscheng/segment_tree/#2940-find-building-where-alice-and-bob-can-meet","title":"2940. Find Building Where Alice and Bob Can Meet","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, stack, binary indexed tree, segment tree, heap priority queue, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/segment_tree/#2286-booking-concert-tickets-in-groups","title":"2286. Booking Concert Tickets in Groups","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: binary search, design, binary indexed tree, segment tree</p> </li> </ul>"},{"location":"content/endlesscheng/segment_tree/#3161-block-placement-queries","title":"3161. Block Placement Queries","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, binary indexed tree, segment tree</p> </li> </ul>"},{"location":"content/endlesscheng/segment_tree/#2213-longest-substring-of-one-repeating-character","title":"2213. Longest Substring of One Repeating Character","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, segment tree, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/segment_tree/#3165-maximum-sum-of-subsequence-with-non-adjacent-elements","title":"3165. Maximum Sum of Subsequence With Non-adjacent Elements","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, divide and conquer, dynamic programming, segment tree</p> </li> </ul>"},{"location":"content/endlesscheng/shortest_path_all_pairs_floyd/","title":"Shortest Path All Pairs Floyd","text":""},{"location":"content/endlesscheng/shortest_path_all_pairs_floyd/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2642. Design Graph With Shortest Path Calculator (Hard)</li> <li> 1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance (Medium)</li> <li> 2976. Minimum Cost to Convert String I (Medium)</li> <li> 2959. Number of Possible Sets of Closing Branches (Hard)</li> <li> 2977. Minimum Cost to Convert String II (Hard)</li> <li> 2101. Detonate the Maximum Bombs (Medium)</li> </ul>"},{"location":"content/endlesscheng/shortest_path_all_pairs_floyd/#2642-design-graph-with-shortest-path-calculator","title":"2642. Design Graph With Shortest Path Calculator","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: graph, design, heap priority queue, shortest path</p> </li> </ul>"},{"location":"content/endlesscheng/shortest_path_all_pairs_floyd/#1334-find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance","title":"1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming, graph, shortest path</p> </li> </ul>"},{"location":"content/endlesscheng/shortest_path_all_pairs_floyd/#2976-minimum-cost-to-convert-string-i","title":"2976. Minimum Cost to Convert String I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, graph, shortest path</p> </li> </ul>"},{"location":"content/endlesscheng/shortest_path_all_pairs_floyd/#2959-number-of-possible-sets-of-closing-branches","title":"2959. Number of Possible Sets of Closing Branches","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: bit manipulation, graph, heap priority queue, enumeration, shortest path</p> </li> </ul>"},{"location":"content/endlesscheng/shortest_path_all_pairs_floyd/#2977-minimum-cost-to-convert-string-ii","title":"2977. Minimum Cost to Convert String II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, dynamic programming, graph, trie, shortest path</p> </li> </ul>"},{"location":"content/endlesscheng/shortest_path_all_pairs_floyd/#2101-detonate-the-maximum-bombs","title":"2101. Detonate the Maximum Bombs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, depth first search, breadth first search, graph, geometry</p> </li> </ul>"},{"location":"content/endlesscheng/shortest_path_single_source_dijkstra/","title":"Shortest Path Single Source Dijkstra","text":""},{"location":"content/endlesscheng/shortest_path_single_source_dijkstra/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 743. Network Delay Time (Medium)</li> <li> 3341. Find Minimum Time to Reach Last Room I (Medium)</li> <li> 3112. Minimum Time to Visit Disappearing Nodes (Medium)</li> <li> 2642. Design Graph With Shortest Path Calculator (Hard)</li> <li> 1514. Path with Maximum Probability (Medium)</li> <li> 3342. Find Minimum Time to Reach Last Room II (Medium)</li> <li> 1631. Path With Minimum Effort (Medium)</li> <li> 1786. Number of Restricted Paths From First to Last Node (Medium)</li> <li> 3123. Find Edges in Shortest Paths (Hard)</li> <li> 1976. Number of Ways to Arrive at Destination (Medium)</li> <li> 778. Swim in Rising Water (Hard)</li> <li> 2662. Minimum Cost of a Path With Special Roads (Medium)</li> <li> 3377. Digit Operations to Make Two Integers Equal (Medium)</li> <li> 2045. Second Minimum Time to Reach Destination (Hard)</li> <li> 3419. Minimize the Maximum Edge Weight of Graph (Medium)</li> <li> 882. Reachable Nodes In Subdivided Graph (Hard)</li> <li> 2203. Minimum Weighted Subgraph With the Required Paths (Hard)</li> <li> 2577. Minimum Time to Visit a Cell In a Grid (Hard)</li> <li> 1928. Minimum Cost to Reach Destination in Time (Hard)</li> <li> 787. Cheapest Flights Within K Stops (Medium)</li> <li> 2699. Modify Graph Edge Weights (Hard)</li> <li> 1810. Minimum Path Cost in a Hidden Grid (Medium) \ud83d\udc51</li> <li> 2093. Minimum Cost to Reach City With Discounts (Medium) \ud83d\udc51</li> <li> 2473. Minimum Cost to Buy Apples (Medium) \ud83d\udc51</li> <li> 2714. Find Shortest Path with K Hops (Hard) \ud83d\udc51</li> <li> 2737. Find the Closest Marked Node (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/shortest_path_single_source_dijkstra/#743-network-delay-time","title":"743. Network Delay Time","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, heap priority queue, shortest path</p> </li> <li>Return the minimum time taken to reach all nodes in a network.</li> </ul> <pre><code>graph LR\n1((1))\n2((2))\n3((3))\n4((4))\n2 --&gt; |1| 1\n2 --&gt; |1| 3\n3 --&gt; |1| 4</code></pre> <ul> <li>Shortest Path Problem: Find the shortest path between two vertices in a graph.</li> <li>Dijkstra's Algorithm<ul> <li>Shortest path algorithm</li> <li>Weighted graph (non-negative weights)</li> <li>Data Structure: Heap; Hash Set</li> <li>Time Complexity: O(E * logV)</li> <li>Space Complexity: O(V)</li> </ul> </li> </ul> 743. Network Delay Time - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Dijkstra - Set\ndef networkDelayTime1(times: List[List[int]], n: int, k: int) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    heap = [(0, k)]\n    visit = set()\n    t = 0\n\n    while heap:\n        w1, n1 = heapq.heappop(heap)\n        if n1 in visit:\n            continue\n\n        visit.add(n1)\n        t = w1\n\n        for n2, w2 in graph[n1]:\n            heapq.heappush(heap, (w1 + w2, n2))\n\n    return t if len(visit) == n else -1\n\n\n# Dijkstra - Dict\ndef networkDelayTime2(times: List[List[int]], n: int, k: int) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    heap = [(0, k)]\n    dist = defaultdict(int)\n\n    while heap:\n        w1, n1 = heapq.heappop(heap)\n        if n1 in dist:\n            continue\n\n        dist[n1] = w1\n\n        for n2, w2 in graph[n1]:\n            heapq.heappush(heap, (w1 + w2, n2))\n\n    return max(dist.values()) if len(dist) == n else -1\n\n\n# Bellman-Ford\ndef networkDelayTimeBF(times: List[List[int]], n: int, k: int) -&gt; int:\n    delay = {i: float(\"inf\") for i in range(1, n + 1)}\n    delay[k] = 0\n\n    for _ in range(n - 1):\n        for u, v, t in times:\n            delay[v] = min(delay[v], delay[u] + t)\n\n    max_delay = max(delay.values())\n    return max_delay if max_delay &lt; float(\"inf\") else -1\n\n\n# |--------------|-----------|--------|\n# | Approach     | Time      | Space  |\n# |--------------|-----------|--------|\n# | Dijkstra     | O(E*logV) | O(V+E) |\n# | Bellman-Ford | O(E*V)    | O(V)   |\n# |--------------|-----------|--------|\n\nif __name__ == \"__main__\":\n    times = [[2, 1, 1], [2, 3, 1], [3, 4, 1]]\n    n = 4\n    k = 2\n    print(networkDelayTime1(times, n, k))  # 2\n    print(networkDelayTime2(times, n, k))  # 2\n    print(networkDelayTimeBF(times, n, k))  # 2\n</code></pre>"},{"location":"content/endlesscheng/shortest_path_single_source_dijkstra/#3341-find-minimum-time-to-reach-last-room-i","title":"3341. Find Minimum Time to Reach Last Room I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, graph, heap priority queue, matrix, shortest path</p> </li> </ul>"},{"location":"content/endlesscheng/shortest_path_single_source_dijkstra/#3112-minimum-time-to-visit-disappearing-nodes","title":"3112. Minimum Time to Visit Disappearing Nodes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, graph, heap priority queue, shortest path</p> </li> </ul>"},{"location":"content/endlesscheng/shortest_path_single_source_dijkstra/#2642-design-graph-with-shortest-path-calculator","title":"2642. Design Graph With Shortest Path Calculator","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: graph, design, heap priority queue, shortest path</p> </li> </ul>"},{"location":"content/endlesscheng/shortest_path_single_source_dijkstra/#1514-path-with-maximum-probability","title":"1514. Path with Maximum Probability","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, graph, heap priority queue, shortest path 1514. Path with Maximum Probability - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Dijkstra - Dict\ndef maxProbability1(\n    n: int,\n    edges: List[List[int]],\n    succProb: List[float],\n    start_node: int,\n    end_node: int,\n) -&gt; float:\n    graph = defaultdict(list)\n    for i, (u, v) in enumerate(edges):\n        graph[u].append((v, succProb[i]))\n        graph[v].append((u, succProb[i]))\n\n    heap = [(-1, start_node)]\n    max_prob = {i: 0.0 for i in range(n)}\n    max_prob[start_node] = 1.0\n\n    while heap:\n        p1, n1 = heapq.heappop(heap)\n\n        if n1 == end_node:\n            return -p1\n\n        for n2, p2 in graph[n1]:\n            p2 *= -p1\n            if p2 &gt; max_prob[n2]:\n                max_prob[n2] = p2\n                heapq.heappush(heap, (-p2, n2))\n\n    return 0.0\n\n\n# Dijkstra - Set\ndef maxProbability2(\n    n: int,\n    edges: List[List[int]],\n    succProb: List[float],\n    start_node: int,\n    end_node: int,\n) -&gt; float:\n    graph = defaultdict(list)\n    for i, (u, v) in enumerate(edges):\n        graph[u].append((v, succProb[i]))\n        graph[v].append((u, succProb[i]))\n\n    heap = [(-1, start_node)]\n    visited = set()\n\n    while heap:\n        p1, n1 = heapq.heappop(heap)\n        visited.add(n1)\n\n        if n1 == end_node:\n            return -p1\n\n        for n2, p2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (p1 * p2, n2))\n\n    return 0.0\n\n\n# |------------|-----------|-----------|\n# |  Approach  |    Time   |   Space   |\n# |------------|-----------|-----------|\n# |  Dijkstra  | O(E log V)|   O(E)    |\n# |------------|-----------|-----------|\n\n\nn = 3\nedges = [[0, 1], [1, 2], [0, 2]]\nsuccProb = [0.5, 0.5, 0.2]\nstart = 0\nend = 2\n\nprint(maxProbability1(n, edges, succProb, start, end))  # 0.25\nprint(maxProbability2(n, edges, succProb, start, end))  # 0.25\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/shortest_path_single_source_dijkstra/#3342-find-minimum-time-to-reach-last-room-ii","title":"3342. Find Minimum Time to Reach Last Room II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, graph, heap priority queue, matrix, shortest path</p> </li> </ul>"},{"location":"content/endlesscheng/shortest_path_single_source_dijkstra/#1631-path-with-minimum-effort","title":"1631. Path With Minimum Effort","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, depth first search, breadth first search, union find, heap priority queue, matrix</p> </li> <li>Return the minimum effort required to travel from the top-left to the bottom-right corner.</li> </ul> 1631. Path With Minimum Effort - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Prim\ndef minimumEffortPath(heights: List[List[int]]) -&gt; int:\n    m, n = len(heights), len(heights[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * n for _ in range(m)]\n    heap = [(0, 0, 0)]  # (effort, row, col)\n\n    while heap:\n        effort, r, c = heapq.heappop(heap)\n\n        if visited[r][c]:\n            continue\n\n        if r == m - 1 and c == n - 1:\n            return effort\n\n        visited[r][c] = True\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and not visited[nr][nc]:\n                updated = max(effort, abs(heights[r][c] - heights[nr][nc]))\n                heapq.heappush(heap, (updated, nr, nc))\n\n    return -1\n\n\nheights = [[1, 2, 2], [3, 8, 2], [5, 3, 5]]\nprint(minimumEffortPath(heights))  # 2\n</code></pre>"},{"location":"content/endlesscheng/shortest_path_single_source_dijkstra/#1786-number-of-restricted-paths-from-first-to-last-node","title":"1786. Number of Restricted Paths From First to Last Node","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming, graph, topological sort, heap priority queue, shortest path</p> </li> </ul>"},{"location":"content/endlesscheng/shortest_path_single_source_dijkstra/#3123-find-edges-in-shortest-paths","title":"3123. Find Edges in Shortest Paths","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, heap priority queue, shortest path</p> </li> </ul>"},{"location":"content/endlesscheng/shortest_path_single_source_dijkstra/#1976-number-of-ways-to-arrive-at-destination","title":"1976. Number of Ways to Arrive at Destination","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming, graph, topological sort, shortest path 1976. Number of Ways to Arrive at Destination - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra\ndef countPaths(n: int, roads: List[List[int]]) -&gt; int:\n    mod = 10**9 + 7\n    graph = [[] for _ in range(n)]\n    for u, v, w in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n\n    dist = [float(\"inf\") for _ in range(n)]\n    dist[0] = 0\n    count = [0 for _ in range(n)]\n    count[0] = 1\n\n    heap = [(0, 0)]\n\n    while heap:\n        d, u = heapq.heappop(heap)\n        if d &gt; dist[u]:\n            continue\n\n        for v, w in graph[u]:\n            if dist[u] + w &lt; dist[v]:\n                dist[v] = dist[u] + w\n                count[v] = count[u]\n                heapq.heappush(heap, (dist[v], v))\n            elif dist[u] + w == dist[v]:\n                count[v] += count[u]\n                count[v] %= mod\n\n    return count[-1]\n\n\nn = 7\nroads = [\n    [0, 6, 7],\n    [0, 1, 2],\n    [1, 2, 3],\n    [1, 3, 3],\n    [6, 3, 3],\n    [3, 5, 1],\n    [6, 5, 1],\n    [2, 5, 1],\n    [0, 4, 5],\n    [4, 6, 2],\n]\nprint(countPaths(n, roads))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/shortest_path_single_source_dijkstra/#778-swim-in-rising-water","title":"778. Swim in Rising Water","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, depth first search, breadth first search, union find, heap priority queue, matrix</p> </li> <li>Return the minimum time when you can reach the target.</li> </ul> <p></p> 778. Swim in Rising Water - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra's\ndef swimInWater(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    visited = set()\n    minHeap = [(grid[0][0], 0, 0)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    visited.add((0, 0))\n\n    while minHeap:\n        time, r, c = heapq.heappop(minHeap)\n\n        if r == n - 1 and c == n - 1:\n            return time\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if nr in range(n) and nc in range(n) and (nr, nc) not in visited:\n                visited.add((nr, nc))\n                heapq.heappush(minHeap, (max(time, grid[nr][nc]), nr, nc))\n\n\ngrid = [\n    [0, 1, 2, 3, 4],\n    [24, 23, 22, 21, 5],\n    [12, 13, 14, 15, 16],\n    [11, 17, 18, 19, 20],\n    [10, 9, 8, 7, 6],\n]\nprint(swimInWater(grid))  # 16\n</code></pre>"},{"location":"content/endlesscheng/shortest_path_single_source_dijkstra/#2662-minimum-cost-of-a-path-with-special-roads","title":"2662. Minimum Cost of a Path With Special Roads","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, graph, heap priority queue, shortest path</p> </li> </ul>"},{"location":"content/endlesscheng/shortest_path_single_source_dijkstra/#3377-digit-operations-to-make-two-integers-equal","title":"3377. Digit Operations to Make Two Integers Equal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, graph, heap priority queue, number theory, shortest path</p> </li> </ul>"},{"location":"content/endlesscheng/shortest_path_single_source_dijkstra/#2045-second-minimum-time-to-reach-destination","title":"2045. Second Minimum Time to Reach Destination","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: breadth first search, graph, shortest path</p> </li> </ul>"},{"location":"content/endlesscheng/shortest_path_single_source_dijkstra/#3419-minimize-the-maximum-edge-weight-of-graph","title":"3419. Minimize the Maximum Edge Weight of Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: binary search, depth first search, breadth first search, graph, shortest path</p> </li> </ul>"},{"location":"content/endlesscheng/shortest_path_single_source_dijkstra/#882-reachable-nodes-in-subdivided-graph","title":"882. Reachable Nodes In Subdivided Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: graph, heap priority queue, shortest path 882. Reachable Nodes In Subdivided Graph - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra's\ndef reachableNodes(self, edges: List[List[int]], maxMoves: int, n: int) -&gt; int:\n    graph = {i: {} for i in range(n)}\n    for u, v, cnt in edges:\n        graph[u][v] = cnt\n        graph[v][u] = cnt\n\n    heap = [(-maxMoves, 0)]\n    seen = {}\n\n    while heap:\n        moves, node = heapq.heappop(heap)\n        if node in seen:\n            continue\n        seen[node] = -moves\n        for nxt, cnt in graph[node].items():\n            movesLeft = -moves - cnt - 1\n            if nxt not in seen and movesLeft &gt;= 0:\n                heapq.heappush(heap, (-movesLeft, nxt))\n\n    res = len(seen)\n    for u, v, cnt in edges:\n        res += min(seen.get(u, 0) + seen.get(v, 0), cnt)\n\n    return res\n\n\nedges = [[0, 1, 10], [0, 2, 1], [1, 2, 2]]\nmaxMoves = 6\nn = 3\nprint(reachableNodes(None, edges, maxMoves, n))  # 13\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/shortest_path_single_source_dijkstra/#2203-minimum-weighted-subgraph-with-the-required-paths","title":"2203. Minimum Weighted Subgraph With the Required Paths","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: graph, shortest path</p> </li> </ul>"},{"location":"content/endlesscheng/shortest_path_single_source_dijkstra/#2577-minimum-time-to-visit-a-cell-in-a-grid","title":"2577. Minimum Time to Visit a Cell In a Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, breadth first search, graph, heap priority queue, matrix, shortest path</p> </li> </ul>"},{"location":"content/endlesscheng/shortest_path_single_source_dijkstra/#1928-minimum-cost-to-reach-destination-in-time","title":"1928. Minimum Cost to Reach Destination in Time","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, graph</p> </li> </ul>"},{"location":"content/endlesscheng/shortest_path_single_source_dijkstra/#787-cheapest-flights-within-k-stops","title":"787. Cheapest Flights Within K Stops","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming, depth first search, breadth first search, graph, heap priority queue, shortest path</p> </li> <li>Return the cheapest price from <code>src</code> to <code>dst</code> with at most <code>K</code> stops.</li> </ul> <pre><code>graph TD\n0((0))\n1((1))\n2((2))\n3((3))\n0 --&gt; |100| 1\n1 --&gt; |600| 3\n1 --&gt; |100| 2\n2 --&gt; |100| 0\n2 --&gt; |200| 3</code></pre> 787. Cheapest Flights Within K Stops - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Bellman-Ford\ndef findCheapestPriceBF(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    prices = [float(\"inf\") for _ in range(n)]\n    prices[src] = 0\n\n    for _ in range(k + 1):\n        temp = prices[:]\n        for u, v, w in flights:\n            temp[v] = min(temp[v], prices[u] + w)\n        prices = temp\n\n    return prices[dst] if prices[dst] != float(\"inf\") else -1\n\n\n# Dijkstra\ndef findCheapestPriceDijkstra(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in flights:\n        graph[u].append((v, w))\n\n    heap = [(0, src, 0)]  # (price, city, stops)\n    visited = defaultdict(int)  # {city: stops}\n\n    while heap:\n        price, city, stops = heapq.heappop(heap)\n\n        if city == dst:\n            return price\n\n        if stops &gt; k:\n            continue\n\n        if city in visited and visited[city] &lt;= stops:\n            continue\n\n        visited[city] = stops\n\n        for neighbor, cost in graph[city]:\n            heapq.heappush(heap, (price + cost, neighbor, stops + 1))\n\n    return -1\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |Bellman-Ford|    O(k * E)      |  O(n)   |\n# | Dijkstra   | O(E * log(V))    |  O(n)   |\n# |------------|------------------|---------|\n\n\nn = 4\nflights = [[0, 1, 100], [1, 2, 100], [2, 0, 100], [1, 3, 600], [2, 3, 200]]\nsrc = 0\ndst = 3\nk = 1\nprint(findCheapestPriceBF(n, flights, src, dst, k))  # 700\nprint(findCheapestPriceDijkstra(n, flights, src, dst, k))  # 700\n</code></pre>"},{"location":"content/endlesscheng/shortest_path_single_source_dijkstra/#2699-modify-graph-edge-weights","title":"2699. Modify Graph Edge Weights","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: graph, heap priority queue, shortest path</p> </li> </ul>"},{"location":"content/endlesscheng/shortest_path_single_source_dijkstra/#1810-minimum-path-cost-in-a-hidden-grid","title":"1810. Minimum Path Cost in a Hidden Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, heap priority queue, interactive</p> </li> </ul>"},{"location":"content/endlesscheng/shortest_path_single_source_dijkstra/#2093-minimum-cost-to-reach-city-with-discounts","title":"2093. Minimum Cost to Reach City With Discounts","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: graph, heap priority queue, shortest path</p> </li> </ul>"},{"location":"content/endlesscheng/shortest_path_single_source_dijkstra/#2473-minimum-cost-to-buy-apples","title":"2473. Minimum Cost to Buy Apples","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, graph, heap priority queue, shortest path</p> </li> </ul>"},{"location":"content/endlesscheng/shortest_path_single_source_dijkstra/#2714-find-shortest-path-with-k-hops","title":"2714. Find Shortest Path with K Hops","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: graph, heap priority queue, shortest path</p> </li> </ul>"},{"location":"content/endlesscheng/shortest_path_single_source_dijkstra/#2737-find-the-closest-marked-node","title":"2737. Find the Closest Marked Node","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, graph, heap priority queue, shortest path</p> </li> </ul>"},{"location":"content/endlesscheng/single_sequence_pairing/","title":"Single Sequence Pairing","text":""},{"location":"content/endlesscheng/single_sequence_pairing/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2144. Minimum Cost of Buying Candies With Discount (Easy)</li> <li> 561. Array Partition (Easy)</li> <li> 1877. Minimize Maximum Pair Sum in Array (Medium)</li> <li> 881. Boats to Save People (Medium)</li> <li> 2592. Maximize Greatness of an Array (Medium)</li> <li> 2576. Find the Maximum Number of Marked Indices (Medium)</li> </ul>"},{"location":"content/endlesscheng/single_sequence_pairing/#2144-minimum-cost-of-buying-candies-with-discount","title":"2144. Minimum Cost of Buying Candies With Discount","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/single_sequence_pairing/#561-array-partition","title":"561. Array Partition","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, greedy, sorting, counting sort</p> </li> </ul>"},{"location":"content/endlesscheng/single_sequence_pairing/#1877-minimize-maximum-pair-sum-in-array","title":"1877. Minimize Maximum Pair Sum in Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/single_sequence_pairing/#881-boats-to-save-people","title":"881. Boats to Save People","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy, sorting 881. Boats to Save People - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef numRescueBoats(people: List[int], limit: int) -&gt; int:\n    \"\"\"Returns the minimum number of boats to rescue people.\"\"\"\n    people.sort()\n    left, right = 0, len(people) - 1\n    boats = 0\n\n    while left &lt;= right:\n        if people[left] + people[right] &lt;= limit:\n            left += 1\n        right -= 1\n        boats += 1\n\n    return boats\n\n\npeople = [3, 2, 2, 1]\nlimit = 3\nprint(numRescueBoats(people, limit))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/single_sequence_pairing/#2592-maximize-greatness-of-an-array","title":"2592. Maximize Greatness of an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/single_sequence_pairing/#2576-find-the-maximum-number-of-marked-indices","title":"2576. Find the Maximum Number of Marked Indices","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, greedy, sorting 2576. Find the Maximum Number of Marked Indices - Python Solution<pre><code>from typing import List\n\n\n# Fast Slow Pointers\ndef maxNumOfMarkedIndices(nums: List[int]) -&gt; int:\n    nums.sort()\n    n = len(nums)\n    slow, fast = 0, n // 2\n    count = 0\n\n    while slow &lt; n // 2 and fast &lt; n:\n        if nums[fast] &gt;= 2 * nums[slow]:\n            count += 2\n            slow += 1\n        fast += 1\n\n    return count\n\n\nnums = [3, 5, 2, 4]\nprint(maxNumOfMarkedIndices(nums))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_fixed_size_advanced/","title":"Sliding Window Fixed Size Advanced","text":""},{"location":"content/endlesscheng/sliding_window_fixed_size_advanced/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1461. Check If a String Contains All Binary Codes of Size K (Medium)</li> <li> 2134. Minimum Swaps to Group All 1's Together II (Medium)</li> <li> 1297. Maximum Number of Occurrences of a Substring (Medium)</li> <li> 2653. Sliding Subarray Beauty (Medium)</li> <li> 3439. Reschedule Meetings for Maximum Free Time I (Medium)</li> <li> 1888. Minimum Number of Flips to Make the Binary String Alternating (Medium)</li> <li> 567. Permutation in String (Medium)</li> <li> 438. Find All Anagrams in a String (Medium)</li> <li> 30. Substring with Concatenation of All Words (Hard)</li> <li> 2156. Find Substring With Given Hash Value (Hard)</li> <li> 2953. Count Complete Substrings (Hard)</li> <li> 1016. Binary String With Substrings Representing 1 To N (Medium)</li> <li> 683. K Empty Slots (Hard) \ud83d\udc51</li> <li> 2067. Number of Equal Count Substrings (Medium) \ud83d\udc51</li> <li> 2524. Maximum Frequency Score of a Subarray (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/sliding_window_fixed_size_advanced/#1461-check-if-a-string-contains-all-binary-codes-of-size-k","title":"1461. Check If a String Contains All Binary Codes of Size K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, bit manipulation, rolling hash, hash function</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_fixed_size_advanced/#2134-minimum-swaps-to-group-all-1s-together-ii","title":"2134. Minimum Swaps to Group All 1's Together II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_fixed_size_advanced/#1297-maximum-number-of-occurrences-of-a-substring","title":"1297. Maximum Number of Occurrences of a Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_fixed_size_advanced/#2653-sliding-subarray-beauty","title":"2653. Sliding Subarray Beauty","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_fixed_size_advanced/#3439-reschedule-meetings-for-maximum-free-time-i","title":"3439. Reschedule Meetings for Maximum Free Time I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_fixed_size_advanced/#1888-minimum-number-of-flips-to-make-the-binary-string-alternating","title":"1888. Minimum Number of Flips to Make the Binary String Alternating","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming, greedy, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_fixed_size_advanced/#567-permutation-in-string","title":"567. Permutation in String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, two pointers, string, sliding window 567. Permutation in String - Python Solution<pre><code>def checkInclusion(s1: str, s2: str) -&gt; bool:\n    if len(s1) &gt; len(s2):\n        return False\n\n    count1 = [0] * 26\n    count2 = [0] * 26\n\n    for i in range(len(s1)):\n        count1[ord(s1[i]) - ord(\"a\")] += 1\n        count2[ord(s2[i]) - ord(\"a\")] += 1\n\n    matches = 0\n    for i in range(26):\n        if count1[i] == count2[i]:\n            matches += 1\n\n    l = 0\n    for r in range(len(s1), len(s2)):\n        if matches == 26:\n            return True\n\n        index = ord(s2[r]) - ord(\"a\")\n        count2[index] += 1\n        if count1[index] == count2[index]:\n            matches += 1\n        elif count1[index] + 1 == count2[index]:\n            matches -= 1\n\n        index = ord(s2[l]) - ord(\"a\")\n        count2[index] -= 1\n        if count1[index] == count2[index]:\n            matches += 1\n        elif count1[index] - 1 == count2[index]:\n            matches -= 1\n\n        l += 1\n\n    return matches == 26\n\n\ns1 = \"ab\"\ns2 = \"eidba\"\nprint(checkInclusion(s1, s2))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_fixed_size_advanced/#438-find-all-anagrams-in-a-string","title":"438. Find All Anagrams in a String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window 438. Find All Anagrams in a String - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window Fixed Size\ndef findAnagrams(s: str, p: str) -&gt; List[int]:\n    n, k = len(s), len(p)\n    target = [0 for _ in range(26)]\n    for ch in p:\n        target[ord(ch) - ord(\"a\")] += 1\n\n    count = [0 for _ in range(26)]\n    left = 0\n    res = []\n\n    for right in range(n):\n        count[ord(s[right]) - ord(\"a\")] += 1\n        if right &lt; k - 1:\n            continue\n\n        if count == target:\n            res.append(left)\n\n        count[ord(s[left]) - ord(\"a\")] -= 1\n        left += 1\n\n    return res\n\n\ns = \"cbaebabacd\"\np = \"abc\"\nprint(findAnagrams(s, p))  # [0, 6]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_fixed_size_advanced/#30-substring-with-concatenation-of-all-words","title":"30. Substring with Concatenation of All Words","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_fixed_size_advanced/#2156-find-substring-with-given-hash-value","title":"2156. Find Substring With Given Hash Value","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, sliding window, rolling hash, hash function</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_fixed_size_advanced/#2953-count-complete-substrings","title":"2953. Count Complete Substrings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_fixed_size_advanced/#1016-binary-string-with-substrings-representing-1-to-n","title":"1016. Binary String With Substrings Representing 1 To N","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_fixed_size_advanced/#683-k-empty-slots","title":"683. K Empty Slots","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary indexed tree, segment tree, queue, sliding window, heap priority queue, ordered set, monotonic queue</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_fixed_size_advanced/#2067-number-of-equal-count-substrings","title":"2067. Number of Equal Count Substrings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, counting, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_fixed_size_advanced/#2524-maximum-frequency-score-of-a-subarray","title":"2524. Maximum Frequency Score of a Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, math, stack, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_fixed_size_basics/","title":"Sliding Window Fixed Size Basics","text":""},{"location":"content/endlesscheng/sliding_window_fixed_size_basics/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1456. Maximum Number of Vowels in a Substring of Given Length (Medium)</li> <li> 643. Maximum Average Subarray I (Easy)</li> <li> 1343. Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold (Medium)</li> <li> 2090. K Radius Subarray Averages (Medium)</li> <li> 2379. Minimum Recolors to Get K Consecutive Black Blocks (Easy)</li> <li> 2841. Maximum Sum of Almost Unique Subarray (Medium)</li> <li> 2461. Maximum Sum of Distinct Subarrays With Length K (Medium)</li> <li> 1423. Maximum Points You Can Obtain from Cards (Medium)</li> <li> 1052. Grumpy Bookstore Owner (Medium)</li> <li> 1652. Defuse the Bomb (Easy)</li> <li> 1176. Diet Plan Performance (Easy) \ud83d\udc51</li> <li> 1100. Find K-Length Substrings With No Repeated Characters (Medium) \ud83d\udc51</li> <li> 1852. Distinct Numbers in Each Subarray (Medium) \ud83d\udc51</li> <li> 1151. Minimum Swaps to Group All 1's Together (Medium) \ud83d\udc51</li> <li> 2107. Number of Unique Flavors After Sharing K Candies (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/sliding_window_fixed_size_basics/#1456-maximum-number-of-vowels-in-a-substring-of-given-length","title":"1456. Maximum Number of Vowels in a Substring of Given Length","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, sliding window</p> </li> <li>This problem is a classic example of the Sliding Window Fixed Size technique.</li> <li>Templace tutorial by \u7075\u5c71\u8336\u827e\u5e9c</li> <li>Technique: add-update-remove (\u5165-\u66f4\u65b0-\u51fa)</li> </ul> 1456. Maximum Number of Vowels in a Substring of Given Length - Python Solution<pre><code># Template of Sliding Window Fixed Size\ndef templateMaxVowels(s: str, k: int) -&gt; int:\n    res, cnt = 0, 0\n\n    for idx, ch in enumerate(s):\n        # ADD\n        if ch in \"aeiou\":\n            cnt += 1\n\n        # FORM\n        if idx &lt; k - 1:\n            continue\n\n        # UPDATE\n        res = max(res, cnt)\n\n        # REMOVE\n        if s[idx - k + 1] in \"aeiou\":\n            cnt -= 1\n\n    return res\n\n\n# Sliding Window Fixed Size\ndef maxVowels1(s: str, k: int) -&gt; int:\n    res, cnt = 0, 0\n\n    for idx, ch in enumerate(s):\n        if ch in \"aeiou\":\n            cnt += 1\n\n        if idx &lt; k - 1:\n            continue\n\n        res = max(res, cnt)\n\n        if s[idx - k + 1] in \"aeiou\":\n            cnt -= 1\n\n    return res\n\n\n# Sliding Window Fixed Size\ndef maxVowels2(s: str, k: int) -&gt; int:\n    vowels = set(\"aeiou\")\n    n = len(s)\n    cnt, res = 0, 0\n\n    for i in range(k):\n        if s[i] in vowels:\n            cnt += 1\n\n    res = cnt\n\n    for i in range(k, n):\n        if s[i] in vowels:\n            cnt += 1\n        if s[i - k] in vowels:\n            cnt -= 1\n        res = max(res, cnt)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    s = \"abciiidef\"\n    k = 3\n    assert maxVowels1(s, k) == 3\n    assert maxVowels2(s, k) == 3\n    assert templateMaxVowels(s, k) == 3\n</code></pre>"},{"location":"content/endlesscheng/sliding_window_fixed_size_basics/#643-maximum-average-subarray-i","title":"643. Maximum Average Subarray I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, sliding window 643. Maximum Average Subarray I - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window Fixed Size\ndef findMaxAverage1(nums: List[int], k: int) -&gt; float:\n    maxSum = float(\"-inf\")\n    cur = 0\n\n    for idx, num in enumerate(nums):\n        cur += num\n\n        if idx &lt; k - 1:\n            continue\n\n        maxSum = max(maxSum, cur)\n        cur -= nums[idx - k + 1]\n\n    return maxSum / k\n\n\n# Sliding Window Fixed Size\ndef findMaxAverage2(nums: List[int], k: int) -&gt; float:\n    n = len(nums)\n    if n == 1:\n        return float(nums[0])\n\n    cur = sum(nums[:k])\n\n    maxSum = cur\n    for i in range(k, n):\n        cur += nums[i] - nums[i - k]\n        maxSum = max(maxSum, cur)\n\n    return maxSum / k\n\n\nnums = [1, 12, -5, -6, 50, 3]\nk = 4\nprint(findMaxAverage1(nums, k))  # 12.75\nprint(findMaxAverage2(nums, k))  # 12.75\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_fixed_size_basics/#1343-number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold","title":"1343. Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sliding window 1343. Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window Fixed Size\ndef numOfSubarrays(arr: List[int], k: int, threshold: int) -&gt; int:\n    target = k * threshold\n    res, cur = 0, 0\n\n    for idx, num in enumerate(arr):\n        cur += num\n\n        if idx &lt; k - 1:\n            continue\n\n        if cur &gt;= target:\n            res += 1\n\n        cur -= arr[idx - k + 1]\n\n    return res\n\n\narr = [2, 2, 2, 2, 5, 5, 5, 8]\nk = 3\nthreshold = 4\nprint(numOfSubarrays(arr, k, threshold))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_fixed_size_basics/#2090-k-radius-subarray-averages","title":"2090. K Radius Subarray Averages","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sliding window 2090. K Radius Subarray Averages - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window Fixed Size\ndef getAverages(nums: List[int], k: int) -&gt; List[int]:\n    n = len(nums)\n    res = [-1 for _ in range(n)]\n    size = 2 * k + 1\n\n    if size &gt; n:\n        return res\n    if k == 0:\n        return nums\n\n    cur = 0\n    for idx, num in enumerate(nums):\n        cur += num\n\n        if idx &lt; 2 * k:\n            continue\n\n        res[idx - k] = cur // size\n        cur -= nums[idx - 2 * k]\n\n    return res\n\n\nnums = [7, 4, 3, 9, 1, 8, 5, 2, 6]\nk = 3\nprint(getAverages(nums, k))\n# [-1, -1, -1, 5, 4, 4, -1, -1, -1]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_fixed_size_basics/#2379-minimum-recolors-to-get-k-consecutive-black-blocks","title":"2379. Minimum Recolors to Get K Consecutive Black Blocks","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, sliding window 2379. Minimum Recolors to Get K Consecutive Black Blocks - Python Solution<pre><code># Sliding Window Fixed Size\ndef minimumRecolors(blocks: str, k: int) -&gt; int:\n    cnt, res = 0, float(\"inf\")\n\n    for idx, block in enumerate(blocks):\n        if block == \"W\":\n            cnt += 1\n\n        if idx &lt; k - 1:\n            continue\n\n        res = min(res, cnt)\n\n        if blocks[idx - k + 1] == \"W\":\n            cnt -= 1\n\n    return res\n\n\nblocks = \"WBBWWBBWBW\"\nk = 7\nprint(minimumRecolors(blocks, k))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_fixed_size_basics/#2841-maximum-sum-of-almost-unique-subarray","title":"2841. Maximum Sum of Almost Unique Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, sliding window 2841. Maximum Sum of Almost Unique Subarray - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Sliding Window Fixed Size\ndef maxSum(nums: List[int], m: int, k: int) -&gt; int:\n    counts = defaultdict(int)\n    cur, res = 0, 0\n\n    for idx, num in enumerate(nums):\n        counts[num] += 1\n        cur += num\n\n        if idx &lt; k - 1:\n            continue\n\n        if len(counts) &gt;= m:\n            res = max(res, cur)\n\n        first = idx - k + 1\n        cur -= nums[first]\n        counts[nums[first]] -= 1\n        if counts[nums[first]] == 0:\n            del counts[nums[first]]\n\n    return res\n\n\nnums = [2, 6, 7, 3, 1, 7]\nm = 3\nk = 4\nprint(maxSum(nums, m, k))  # 18\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_fixed_size_basics/#2461-maximum-sum-of-distinct-subarrays-with-length-k","title":"2461. Maximum Sum of Distinct Subarrays With Length K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, sliding window 2461. Maximum Sum of Distinct Subarrays With Length K - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Sliding Window Fixed Size\ndef maximumSubarraySum(nums: List[int], k: int) -&gt; int:\n    counts = defaultdict(int)\n    res = 0\n    cur = 0\n\n    for idx, num in enumerate(nums):\n        counts[num] += 1\n        cur += num\n\n        if idx &lt; k - 1:\n            continue\n\n        if len(counts) == k:\n            res = max(res, cur)\n\n        first = idx - k + 1\n        cur -= nums[first]\n        counts[nums[first]] -= 1\n        if counts[nums[first]] == 0:\n            del counts[nums[first]]\n\n    return res\n\n\nnums = [1, 5, 4, 2, 9, 9, 9]\nk = 3\nprint(maximumSubarraySum(nums, k))  # 15\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_fixed_size_basics/#1423-maximum-points-you-can-obtain-from-cards","title":"1423. Maximum Points You Can Obtain from Cards","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sliding window, prefix sum 1423. Maximum Points You Can Obtain from Cards - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window Fixed Size\ndef maxScore(cardPoints: List[int], k: int) -&gt; int:\n    n = len(cardPoints)\n    j = n - k\n    total = sum(cardPoints)\n\n    if j == 0:\n        return total\n\n    curSum, minSum = 0, float(\"inf\")\n\n    for idx, point in enumerate(cardPoints):\n        curSum += point\n\n        if idx &lt; j - 1:\n            continue\n\n        minSum = min(minSum, curSum)\n        curSum -= cardPoints[idx - j + 1]\n\n    return total - minSum\n\n\ncardPoints = [1, 2, 3, 4, 5, 6, 1]\nk = 3\nprint(maxScore(cardPoints, k))  # 12\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_fixed_size_basics/#1052-grumpy-bookstore-owner","title":"1052. Grumpy Bookstore Owner","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sliding window</p> </li> <li>Hint: Maximize the number of unsatisfied customers in the fixed window of <code>minutes</code>.</li> </ul> 1052. Grumpy Bookstore Owner - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window Fixed Size\ndef maxSatisfied(customers: List[int], grumpy: List[int], minutes: int) -&gt; int:\n    n = len(customers)\n    k = minutes\n    if k &gt;= n:\n        return sum(customers)\n\n    total_satisfied = sum(customers[i] for i in range(n) if not grumpy[i])\n\n    cur, maxGrumpy = 0, 0\n\n    for idx, customer in enumerate(customers):\n        cur += customer if grumpy[idx] else 0\n\n        if idx &lt; k - 1:\n            continue\n\n        maxGrumpy = max(maxGrumpy, cur)\n\n        cur -= customers[idx - k + 1] if grumpy[idx - k + 1] else 0\n\n    return total_satisfied + maxGrumpy\n\n\ncustomers = [1, 0, 1, 2, 1, 1, 7, 5]\ngrumpy = [0, 1, 0, 1, 0, 1, 0, 1]\nminutes = 3\nprint(maxSatisfied(customers, grumpy, minutes))  # 16\n</code></pre>"},{"location":"content/endlesscheng/sliding_window_fixed_size_basics/#1652-defuse-the-bomb","title":"1652. Defuse the Bomb","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, sliding window</p> </li> <li>How to deal with the circular array?<ul> <li>Trick: mod (index % length)</li> </ul> </li> </ul> 1652. Defuse the Bomb - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window Fixed Size\ndef decrypt(code: List[int], k: int) -&gt; List[int]:\n    n = len(code)\n    res = [0 for _ in range(n)]\n    if k == 0:\n        return res\n\n    left, right = (1, k) if k &gt; 0 else (n + k, n - 1)\n\n    curSum = 0\n    for i in range(left, right + 1):\n        curSum += code[i % n]\n\n    for i in range(n):\n        res[i] = curSum\n\n        curSum -= code[left % n]\n        left += 1\n        right += 1\n        curSum += code[right % n]\n\n    return res\n\n\ncode = [2, 4, 9, 3]\nk = -2\nprint(decrypt(code, k))  # [12, 5, 6, 13]\n</code></pre>"},{"location":"content/endlesscheng/sliding_window_fixed_size_basics/#1176-diet-plan-performance","title":"1176. Diet Plan Performance","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, sliding window 1176. Diet Plan Performance - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window Fixed Size\ndef dietPlanPerformance(\n    calories: List[int], k: int, lower: int, upper: int\n) -&gt; int:\n    res, T = 0, 0\n\n    for i in range(len(calories)):\n        T += calories[i]\n\n        if i &lt; k - 1:\n            continue\n\n        if T &lt; lower:\n            res -= 1\n        elif T &gt; upper:\n            res += 1\n\n        T -= calories[i - k + 1]\n\n    return res\n\n\nif __name__ == \"__main__\":\n    calories = [1, 2, 3, 4, 5]\n    k = 1\n    lower = 3\n    upper = 3\n\n    assert dietPlanPerformance(calories, k, lower, upper) == 0\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_fixed_size_basics/#1100-find-k-length-substrings-with-no-repeated-characters","title":"1100. Find K-Length Substrings With No Repeated Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window 1100. Find K-Length Substrings With No Repeated Characters - Python Solution<pre><code>from collections import defaultdict\n\n\n# Sliding Window Fixed Size\ndef numKLenSubstrNoRepeats(s: str, k: int) -&gt; int:\n    n = len(s)\n    if k &gt; n:\n        return 0\n\n    counts = defaultdict(int)\n    res = 0\n\n    for i, ch in enumerate(s):\n        # add to the window\n        counts[ch] += 1\n\n        # form a valid window\n        if i &lt; k - 1:\n            continue\n\n        # update\n        res += 1 if len(counts) == k else 0\n\n        # remove from the window\n        first = i - k + 1\n        counts[s[first]] -= 1\n        if counts[s[first]] == 0:\n            del counts[s[first]]\n\n    return res\n\n\nif __name__ == \"__main__\":\n    s = \"havefunonleetcode\"\n    k = 5\n\n    assert numKLenSubstrNoRepeats(s, k) == 6\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_fixed_size_basics/#1852-distinct-numbers-in-each-subarray","title":"1852. Distinct Numbers in Each Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, sliding window 1852. Distinct Numbers in Each Subarray - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Sliding Window Fixed Size\ndef distinctNumbers(nums: List[int], k: int) -&gt; List[int]:\n    res = []\n    counts = defaultdict(int)\n\n    for right in range(len(nums)):\n        counts[nums[right]] += 1  # add\n\n        if right &lt; k - 1:  # form\n            continue\n\n        res.append(len(counts))  # update\n\n        left = right - k + 1  # remove\n        counts[nums[left]] -= 1\n        if counts[nums[left]] == 0:\n            del counts[nums[left]]\n\n    return res\n\n\nif __name__ == \"__main__\":\n    nums = [1, 2, 3, 2, 2, 1, 3]\n    k = 3\n    assert distinctNumbers(nums, k) == [3, 2, 2, 2, 3]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_fixed_size_basics/#1151-minimum-swaps-to-group-all-1s-together","title":"1151. Minimum Swaps to Group All 1's Together","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sliding window 1151. Minimum Swaps to Group All 1's Together - Python Solution<pre><code>from typing import List\n\n\ndef minSwaps(data: List[int]) -&gt; int:\n    n = len(data)\n    total = sum(data)\n\n    if total == 0 or total == 1 or total == n:\n        return 0\n\n    max_count = 0\n    cur = 0\n    left = 0\n\n    for right in range(n):\n        cur += data[right]\n\n        if right - left + 1 &gt; total:\n            cur -= data[left]\n            left += 1\n\n        max_count = max(max_count, cur)\n\n    return total - max_count\n\n\ndata = [1, 0, 1, 0, 1]\nprint(minSwaps(data))  # 1\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_fixed_size_basics/#2107-number-of-unique-flavors-after-sharing-k-candies","title":"2107. Number of Unique Flavors After Sharing K Candies","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, sliding window 2107. Number of Unique Flavors After Sharing K Candies - Python Solution<pre><code>from collections import Counter\nfrom typing import List\n\n\n# Sliding Window Fixed Size\ndef shareCandies(candies: List[int], k: int) -&gt; int:\n    res = 0\n    n = len(candies)\n    counts = Counter(candies)\n\n    if k &gt;= n:\n        return 0\n    if k == 0:\n        return len(counts)\n\n    for right in range(n):\n        counts[candies[right]] -= 1  # remove\n        if counts[candies[right]] == 0:\n            del counts[candies[right]]\n\n        if right &lt; k - 1:  # form the window\n            continue\n\n        res = max(res, len(counts))  # update\n\n        left = right - k + 1  # add\n        counts[candies[left]] += 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    candies = [1, 2, 2, 3, 4, 3]\n    k = 3\n    assert shareCandies(candies, k) == 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_fixed_size_others/","title":"Sliding Window Fixed Size Others","text":""},{"location":"content/endlesscheng/sliding_window_fixed_size_others/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2269. Find the K-Beauty of a Number (Easy)</li> <li> 1984. Minimum Difference Between Highest and Lowest of K Scores (Easy)</li> <li> 220. Contains Duplicate III (Hard)</li> </ul>"},{"location":"content/endlesscheng/sliding_window_fixed_size_others/#2269-find-the-k-beauty-of-a-number","title":"2269. Find the K-Beauty of a Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, string, sliding window 2269. Find the K-Beauty of a Number - Python Solution<pre><code>def divisorSubstrings(num: int, k: int) -&gt; int:\n    numStr = str(num)\n    n = len(numStr)\n    res = 0\n\n    for i in range(n - k + 1):\n        x = int(numStr[i : i + k])\n        if x &gt; 0 and num % x == 0:\n            res += 1\n\n    return res\n\n\nnum = 240\nk = 2\nprint(divisorSubstrings(num, k))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_fixed_size_others/#1984-minimum-difference-between-highest-and-lowest-of-k-scores","title":"1984. Minimum Difference Between Highest and Lowest of K Scores","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, sliding window, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_fixed_size_others/#220-contains-duplicate-iii","title":"220. Contains Duplicate III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, sliding window, sorting, bucket sort, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_max_advanced/","title":"Sliding Window Variable Max Advanced","text":""},{"location":"content/endlesscheng/sliding_window_variable_max_advanced/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2730. Find the Longest Semi-Repetitive Substring (Medium)</li> <li> 2779. Maximum Beauty of an Array After Applying Operation (Medium)</li> <li> 1838. Frequency of the Most Frequent Element (Medium)</li> <li> 2516. Take K of Each Character From Left and Right (Medium)</li> <li> 2831. Find the Longest Equal Subarray (Medium)</li> <li> 2271. Maximum White Tiles Covered by a Carpet (Medium)</li> <li> 2106. Maximum Fruits Harvested After at Most K Steps (Hard)</li> <li> 2555. Maximize Win From Two Segments (Medium)</li> <li> 2009. Minimum Number of Operations to Make Array Continuous (Hard)</li> <li> 1610. Maximum Number of Visible Points (Hard)</li> <li> 2781. Length of the Longest Valid Substring (Hard)</li> <li> 3411. Maximum Subarray With Equal Products (Easy)</li> <li> 2968. Apply Operations to Maximize Frequency Score (Hard)</li> <li> 1040. Moving Stones Until Consecutive II (Medium)</li> <li> 3413. Maximum Coins From K Consecutive Bags (Medium)</li> <li> 395. Longest Substring with At Least K Repeating Characters (Medium)</li> <li> 1763. Longest Nice Substring (Easy)</li> <li> 487. Max Consecutive Ones II (Medium) \ud83d\udc51</li> <li> 159. Longest Substring with At Most Two Distinct Characters (Medium) \ud83d\udc51</li> <li> 340. Longest Substring with At Most K Distinct Characters (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_max_advanced/#2730-find-the-longest-semi-repetitive-substring","title":"2730. Find the Longest Semi-Repetitive Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, sliding window 2730. Find the Longest Semi-Repetitive Substring - Python Solution<pre><code># Sliding Window Variable Max\ndef longestSemiRepetitiveSubstring(s: str) -&gt; int:\n    n = len(s)\n    left = 0\n    repeat = 0\n    res = 1\n\n    for right in range(1, n):\n        if s[right] == s[right - 1]:\n            repeat += 1\n\n        while repeat &gt; 1:\n            if s[left] == s[left + 1]:\n                repeat -= 1\n            left += 1\n\n        res = max(res, right - left + 1)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert longestSemiRepetitiveSubstring(\"abacaba\") == 7\n    assert longestSemiRepetitiveSubstring(\"aa\") == 2\n    assert longestSemiRepetitiveSubstring(\"a\") == 1\n    assert longestSemiRepetitiveSubstring(\"abcde\") == 5\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_max_advanced/#2779-maximum-beauty-of-an-array-after-applying-operation","title":"2779. Maximum Beauty of an Array After Applying Operation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sliding window, sorting 2779. Maximum Beauty of an Array After Applying Operation - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window Variable Max\ndef maximumBeauty(nums: List[int], k: int) -&gt; int:\n    nums.sort()\n    res, left = 0, 0\n\n    for right, x in enumerate(nums):\n        while x - nums[left] &gt; k * 2:\n            left += 1\n        res = max(res, right - left + 1)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert maximumBeauty([4, 6, 1, 2], 2) == 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_max_advanced/#1838-frequency-of-the-most-frequent-element","title":"1838. Frequency of the Most Frequent Element","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, greedy, sliding window, sorting, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_max_advanced/#2516-take-k-of-each-character-from-left-and-right","title":"2516. Take K of Each Character From Left and Right","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_max_advanced/#2831-find-the-longest-equal-subarray","title":"2831. Find the Longest Equal Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, binary search, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_max_advanced/#2271-maximum-white-tiles-covered-by-a-carpet","title":"2271. Maximum White Tiles Covered by a Carpet","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, greedy, sliding window, sorting, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_max_advanced/#2106-maximum-fruits-harvested-after-at-most-k-steps","title":"2106. Maximum Fruits Harvested After at Most K Steps","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, sliding window, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_max_advanced/#2555-maximize-win-from-two-segments","title":"2555. Maximize Win From Two Segments","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sliding window 2555. Maximize Win From Two Segments - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window - Variable\ndef maximizeWin(prizePositions: List[int], k: int) -&gt; int:\n    n = len(prizePositions)\n\n    if 2 * k &gt;= prizePositions[-1] - prizePositions[0]:\n        return n\n\n    ans = left = 0\n    mx = [0] * (n + 1)\n\n    for right, p in enumerate(prizePositions):\n        while p - prizePositions[left] &gt; k:\n            left += 1\n        ans = max(ans, mx[left] + right - left + 1)\n        mx[right + 1] = max(mx[right], right - left + 1)\n\n    return ans\n\n\nprizePositions = [1, 1, 2, 2, 3, 3, 5]\nk = 2\nprint(maximizeWin(prizePositions, k))  # 7\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_max_advanced/#2009-minimum-number-of-operations-to-make-array-continuous","title":"2009. Minimum Number of Operations to Make Array Continuous","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, binary search, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_max_advanced/#1610-maximum-number-of-visible-points","title":"1610. Maximum Number of Visible Points","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, geometry, sliding window, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_max_advanced/#2781-length-of-the-longest-valid-substring","title":"2781. Length of the Longest Valid Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, string, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_max_advanced/#3411-maximum-subarray-with-equal-products","title":"3411. Maximum Subarray With Equal Products","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, math, sliding window, enumeration, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_max_advanced/#2968-apply-operations-to-maximize-frequency-score","title":"2968. Apply Operations to Maximize Frequency Score","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, sliding window, sorting, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_max_advanced/#1040-moving-stones-until-consecutive-ii","title":"1040. Moving Stones Until Consecutive II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, two pointers, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_max_advanced/#3413-maximum-coins-from-k-consecutive-bags","title":"3413. Maximum Coins From K Consecutive Bags","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, greedy, sliding window, sorting, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_max_advanced/#395-longest-substring-with-at-least-k-repeating-characters","title":"395. Longest Substring with At Least K Repeating Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, divide and conquer, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_max_advanced/#1763-longest-nice-substring","title":"1763. Longest Nice Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, string, divide and conquer, bit manipulation, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_max_advanced/#487-max-consecutive-ones-ii","title":"487. Max Consecutive Ones II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_max_advanced/#159-longest-substring-with-at-most-two-distinct-characters","title":"159. Longest Substring with At Most Two Distinct Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> <li>Prerequisite: 3. Longest Substring Without Repeating Characters</li> </ul> 159. Longest Substring with At Most Two Distinct Characters - Python Solution<pre><code>from collections import defaultdict\n\n\n# Sliding Window - Variable\ndef lengthOfLongestSubstringTwoDistinct(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 2:\n        return n\n\n    window = defaultdict(int)\n    left, res = 0, 0\n\n    for right in range(n):\n        window[s[right]] += 1\n\n        while len(window) &gt; 2:\n            window[s[left]] -= 1\n            if window[s[left]] == 0:\n                del window[s[left]]\n            left += 1\n\n        res = max(res, right - left + 1)\n\n    return res\n\n\ns = \"ccaabbb\"\nassert lengthOfLongestSubstringTwoDistinct(s) == 5\n</code></pre>"},{"location":"content/endlesscheng/sliding_window_variable_max_advanced/#340-longest-substring-with-at-most-k-distinct-characters","title":"340. Longest Substring with At Most K Distinct Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window 340. Longest Substring with At Most K Distinct Characters - Python Solution<pre><code>from collections import defaultdict\n\n\n# Sliding Window Variable\ndef lengthOfLongestSubstringKDistinct(s: str, k: int) -&gt; int:\n    n = len(s)\n    if n &lt;= k:\n        return n\n\n    window = defaultdict(int)\n    left, res = 0, 0\n\n    for right in range(n):\n        window[s[right]] += 1\n        while len(window) &gt; k:\n            window[s[left]] -= 1\n            if window[s[left]] == 0:\n                del window[s[left]]\n            left += 1\n        res = max(res, right - left + 1)\n\n    return res\n\n\ns = \"eceba\"\nk = 2\nassert lengthOfLongestSubstringKDistinct(s, k) == 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_max_basics/","title":"Sliding Window Variable Max Basics","text":""},{"location":"content/endlesscheng/sliding_window_variable_max_basics/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3. Longest Substring Without Repeating Characters (Medium)</li> <li> 3090. Maximum Length Substring With Two Occurrences (Easy)</li> <li> 1493. Longest Subarray of 1's After Deleting One Element (Medium)</li> <li> 1208. Get Equal Substrings Within Budget (Medium)</li> <li> 904. Fruit Into Baskets (Medium)</li> <li> 1695. Maximum Erasure Value (Medium)</li> <li> 2958. Length of Longest Subarray With at Most K Frequency (Medium)</li> <li> 2024. Maximize the Confusion of an Exam (Medium)</li> <li> 1004. Max Consecutive Ones III (Medium)</li> <li> 1658. Minimum Operations to Reduce X to Zero (Medium)</li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_max_basics/#3-longest-substring-without-repeating-characters","title":"3. Longest Substring Without Repeating Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> <li>Classic variable sliding window problem. Use a set to keep track of the characters in the current window.</li> <li>Return the length of the longest substring without repeating characters.</li> <li>Template tutorial by \u7075\u5c71\u8336\u827e\u5e9c</li> </ul> 3. Longest Substring Without Repeating Characters - Python Solution<pre><code>from collections import defaultdict\n\n\n# Sliding Window Variable Max - HashMap\ndef lengthOfLongestSubstringHash(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    left = 0\n    cnt = defaultdict(int)\n    res = 0\n\n    for right in range(n):\n        cnt[s[right]] += 1\n\n        while cnt[s[right]] &gt; 1:\n            cnt[s[left]] -= 1\n            left += 1\n\n        res = max(res, right - left + 1)\n\n    return res\n\n\n# Sliding Window Variable Max - Set\ndef lengthOfLongestSubstringSet(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    left = 0\n    res = 0\n    window = set()\n\n    for right in range(n):\n        while left &lt; right and s[right] in window:\n            window.remove(s[left])\n            left += 1\n        window.add(s[right])\n        res = max(res, right - left + 1)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    s = \"abcabcbb\"\n    assert lengthOfLongestSubstringHash(s) == 3\n    assert lengthOfLongestSubstringSet(s) == 3\n</code></pre> 3. Longest Substring Without Repeating Characters - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;unordered_set&gt;\nusing namespace std;\n\nint lengthOfLongestSubstring(string s) {\n    int n = s.length();\n    int res = 0;\n    int left = 0;\n    unordered_set&lt;char&gt; window;\n\n    for (int right = 0; right &lt; n; right++) {\n        char ch = s[right];\n\n        while (window.find(ch) != window.end()) {\n            window.erase(s[left]);\n            left++;\n        }\n\n        window.insert(ch);\n        res = max(res, right - left + 1);\n    }\n    return (int)res;\n}\n\nint main() {\n    string s = \"abcabcbb\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 3\n    s = \"bbbbb\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 1\n    s = \"pwwkew\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 3\n    return 0;\n}\n</code></pre>"},{"location":"content/endlesscheng/sliding_window_variable_max_basics/#3090-maximum-length-substring-with-two-occurrences","title":"3090. Maximum Length Substring With Two Occurrences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, string, sliding window 3090. Maximum Length Substring With Two Occurrences - Python Solution<pre><code>from collections import defaultdict\n\n\n# Sliding Window Variable Max\ndef maximumLengthSubstring(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 2:\n        return n\n\n    counts = defaultdict(int)\n    left = 0\n    res = 0\n\n    for right in range(n):\n        while left &lt; right and counts[s[right]] == 2:\n            counts[s[left]] -= 1\n            if counts[s[left]] == 0:\n                del counts[s[left]]\n            left += 1\n\n        res = max(res, right - left + 1)\n        counts[s[right]] += 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    s = \"bcbbbcba\"\n    assert maximumLengthSubstring(s) == 4\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_max_basics/#1493-longest-subarray-of-1s-after-deleting-one-element","title":"1493. Longest Subarray of 1's After Deleting One Element","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, sliding window 1493. Longest Subarray of 1's After Deleting One Element - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window Variable Max\ndef longestSubarray(nums: List[int]) -&gt; int:\n    zeroCount = 0\n    res = 0\n    left = 0\n\n    for right in range(len(nums)):\n        if nums[right] == 0:\n            zeroCount += 1\n\n        while zeroCount &gt; 1:\n            if nums[left] == 0:\n                zeroCount -= 1\n            left += 1\n\n        res = max(res, right - left)\n\n    return res\n\n\nnums = [1, 1, 0, 1]\nprint(longestSubarray(nums))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_max_basics/#1208-get-equal-substrings-within-budget","title":"1208. Get Equal Substrings Within Budget","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, binary search, sliding window, prefix sum 1208. Get Equal Substrings Within Budget - Python Solution<pre><code># Sliding Window - Variable\ndef equalSubstring(s: str, t: str, maxCost: int) -&gt; int:\n    left = 0\n    maxLen = 0\n    currentCost = 0\n\n    for right in range(len(s)):\n        currentCost += abs(ord(s[right]) - ord(t[right]))\n\n        while currentCost &gt; maxCost:\n            currentCost -= abs(ord(s[left]) - ord(t[left]))\n            left += 1\n\n        maxLen = max(maxLen, right - left + 1)\n\n    return maxLen\n\n\ns = \"abcd\"\nt = \"bcdf\"\nmaxCost = 3\nprint(equalSubstring(s, t, maxCost))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_max_basics/#904-fruit-into-baskets","title":"904. Fruit Into Baskets","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, sliding window 904. Fruit Into Baskets - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Sliding Window Variable Size\ndef totalFruit(fruits: List[int]) -&gt; int:\n    n = len(fruits)\n    if n &lt;= 2:\n        return n\n\n    baskets = defaultdict(int)\n    res, left = 0, 0\n\n    for right in range(n):\n        baskets[fruits[right]] += 1\n\n        while len(baskets) &gt; 2:\n            baskets[fruits[left]] -= 1\n            if baskets[fruits[left]] == 0:\n                del baskets[fruits[left]]\n            left += 1\n\n        res = max(res, right - left + 1)\n\n    return res\n\n\nfruits = [1, 2, 3, 2, 2]\nprint(totalFruit(fruits))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_max_basics/#1695-maximum-erasure-value","title":"1695. Maximum Erasure Value","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, sliding window 1695. Maximum Erasure Value - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window Variable Size\ndef maximumUniqueSubarray(nums: List[int]) -&gt; int:\n    n = len(nums)\n    left = 0\n    cur, res = 0, 0\n    sub = set()\n\n    for right in range(n):\n        while left &lt; right and nums[right] in sub:\n            sub.remove(nums[left])\n            cur -= nums[left]\n            left += 1\n\n        sub.add(nums[right])\n        cur += nums[right]\n        res = max(res, cur)\n\n    return res\n\n\nnums = [4, 2, 4, 5, 6]\nprint(maximumUniqueSubarray(nums))  # 17\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_max_basics/#2958-length-of-longest-subarray-with-at-most-k-frequency","title":"2958. Length of Longest Subarray With at Most K Frequency","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, sliding window 2958. Length of Longest Subarray With at Most K Frequency - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Sliding Window Variable Size\ndef maxSubarrayLength(nums: List[int], k: int) -&gt; int:\n    n = len(nums)\n    freqs = defaultdict(int)  # num -&gt; freq\n    left = 0\n    res = 0\n\n    for right in range(n):\n        freqs[nums[right]] += 1\n\n        while freqs[nums[right]] &gt; k:\n            freqs[nums[left]] -= 1\n            left += 1\n\n        res = max(res, right - left + 1)\n\n    return res\n\n\nnums = [1, 2, 1, 2, 1, 2, 1, 2]\nk = 2\nprint(maxSubarrayLength(nums, k))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_max_basics/#2024-maximize-the-confusion-of-an-exam","title":"2024. Maximize the Confusion of an Exam","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, binary search, sliding window, prefix sum 2024. Maximize the Confusion of an Exam - Python Solution<pre><code># Sliding Window - Variable\ndef maxConsecutiveAnswers1(answerKey: str, k: int) -&gt; int:\n    def maxConsecutiveChar(s: str, k: int, char: str) -&gt; int:\n        max_len = 0\n        left = 0\n        count = 0  # num of str != char\n\n        for right in range(len(s)):\n            if s[right] != char:\n                count += 1\n\n            while count &gt; k:\n                if s[left] != char:\n                    count -= 1\n                left += 1\n\n            max_len = max(max_len, right - left + 1)\n\n        return max_len\n\n    max_t = maxConsecutiveChar(answerKey, k, \"T\")\n    max_f = maxConsecutiveChar(answerKey, k, \"F\")\n\n    return max(max_t, max_f)\n\n\n# Sliding Window - Variable\ndef maxConsecutiveAnswers2(answerKey: str, k: int) -&gt; int:\n    def maxConsecutiveChar(s: str, k: int, char: str) -&gt; int:\n        max_len = 0\n        left, right = 0, 0\n\n        while right &lt; len(s):\n            if s[right] != char:\n                k -= 1\n\n            while k &lt; 0:\n                if s[left] != char:\n                    k += 1\n                left += 1\n\n            max_len = max(max_len, right - left + 1)\n            right += 1\n\n        return max_len\n\n    max_t = maxConsecutiveChar(answerKey, k, \"T\")\n    max_f = maxConsecutiveChar(answerKey, k, \"F\")\n\n    return max(max_t, max_f)\n\n\n# |-----------------|---------|------------|\n# |  Approach       |  Time   |  Space     |\n# |-----------------|---------|------------|\n# | Sliding Window  |  O(N)   |  O(1)      |\n# |-----------------|---------|------------|\n\n\nanswerKey = \"TTFF\"\nk = 2\nprint(maxConsecutiveAnswers1(answerKey, k))  # 4\nprint(maxConsecutiveAnswers2(answerKey, k))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_max_basics/#1004-max-consecutive-ones-iii","title":"1004. Max Consecutive Ones III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sliding window, prefix sum 1004. Max Consecutive Ones III - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window - Variable\ndef longestOnes(nums: List[int], k: int) -&gt; int:\n    left = 0\n    maxLen = 0\n    zero_count = 0\n\n    for right in range(len(nums)):\n        if nums[right] == 0:\n            zero_count += 1\n\n        while zero_count &gt; k:\n            if nums[left] == 0:\n                zero_count -= 1\n            left += 1\n\n        maxLen = max(maxLen, right - left + 1)\n\n    return maxLen\n\n\nnums = [1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0]\nk = 2\nprint(longestOnes(nums, k))  # 6\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_max_basics/#1658-minimum-operations-to-reduce-x-to-zero","title":"1658. Minimum Operations to Reduce X to Zero","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, binary search, sliding window, prefix sum 1658. Minimum Operations to Reduce X to Zero - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window Variable Max\ndef minOperations(nums: List[int], x: int) -&gt; int:\n    window = 0\n    total = sum(nums)\n    target = total - x\n    n = len(nums)\n    left = 0\n    maxLen = 0\n\n    if target &lt; 0:\n        return -1\n    if target == 0:\n        return n\n\n    for right in range(n):\n        window += nums[right]\n\n        while left &lt;= right and window &gt; target:\n            window -= nums[left]\n            left += 1\n\n        if window == target:\n            maxLen = max(maxLen, right - left + 1)\n\n    return -1 if not maxLen else n - maxLen\n\n\nif __name__ == \"__main__\":\n    nums = [1, 1, 4, 2, 3]\n    x = 5\n    assert minOperations(nums, x) == 2\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_min/","title":"Sliding Window Variable Min","text":""},{"location":"content/endlesscheng/sliding_window_variable_min/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 209. Minimum Size Subarray Sum (Medium)</li> <li> 2904. Shortest and Lexicographically Smallest Beautiful String (Medium)</li> <li> 1234. Replace the Substring for Balanced String (Medium)</li> <li> 2875. Minimum Size Subarray in Infinite Array (Medium)</li> <li> 76. Minimum Window Substring (Hard)</li> <li> 632. Smallest Range Covering Elements from K Lists (Hard)</li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_min/#209-minimum-size-subarray-sum","title":"209. Minimum Size Subarray Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sliding window, prefix sum 209. Minimum Size Subarray Sum - Python Solution<pre><code>import bisect\nfrom typing import List\n\n\n# Prefix Sum\ndef minSubArrayLenPS(target: int, nums: List[int]) -&gt; int:\n    n = len(nums)\n    prefix_sums = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        prefix_sums[i] = prefix_sums[i - 1] + nums[i - 1]\n\n    minLen = float(\"inf\")\n\n    for i in range(n + 1):\n        new_target = target + prefix_sums[i]\n        bound = bisect.bisect_left(prefix_sums, new_target)\n        if bound != len(prefix_sums):\n            minLen = min(minLen, bound - i)\n\n    return 0 if minLen == float(\"inf\") else minLen\n\n\n# Sliding Window Variable Size\ndef minSubArrayLenSW(target: int, nums: List[int]) -&gt; int:\n    res, cur = float(\"inf\"), 0\n    left = 0\n\n    for right in range(len(nums)):\n        cur += nums[right]\n\n        while cur &gt;= target:\n            res = min(res, right - left + 1)\n            cur -= nums[left]\n            left += 1\n\n    return res if res != float(\"inf\") else 0\n\n\ntarget = 7\nnums = [2, 3, 1, 2, 4, 3]\nprint(minSubArrayLenPS(target, nums))  # 2\nprint(minSubArrayLenSW(target, nums))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_min/#2904-shortest-and-lexicographically-smallest-beautiful-string","title":"2904. Shortest and Lexicographically Smallest Beautiful String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, sliding window 2904. Shortest and Lexicographically Smallest Beautiful String - Python Solution<pre><code># Sliding Window Variable Size\ndef shortestBeautifulSubstring(s: str, k: int) -&gt; str:\n    n = len(s)\n    left = 0\n    oneCount = 0\n    minLen = float(\"inf\")\n    res = \"\"\n\n    for right in range(n):\n        if s[right] == \"1\":\n            oneCount += 1\n\n        while oneCount == k:\n            size = right - left + 1\n\n            if size &lt; minLen:\n                minLen = size\n                res = s[left : right + 1]\n            elif size == minLen:\n                res = min(res, s[left : right + 1])\n\n            if s[left] == \"1\":\n                oneCount -= 1\n            left += 1\n\n    return res\n\n\ns = \"100011001\"\nk = 3\nprint(shortestBeautifulSubstring(s, k))  # 11001\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_min/#1234-replace-the-substring-for-balanced-string","title":"1234. Replace the Substring for Balanced String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, sliding window 1234. Replace the Substring for Balanced String - Python Solution<pre><code>from collections import Counter\n\n\n# Sliding Window Variable Min\ndef balancedString(s: str) -&gt; int:\n    n = len(s)\n    m = n // 4\n    counts = Counter(s)\n\n    if len(counts) == 4 and min(counts.values()) == m:\n        return 0\n\n    left = 0\n    res = float(\"inf\")\n\n    for right in range(n):\n        counts[s[right]] -= 1\n\n        while max(counts.values()) &lt;= m:\n            res = min(res, right - left + 1)\n            counts[s[left]] += 1\n            left += 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert balancedString(\"QWER\") == 0\n    assert balancedString(\"QQWE\") == 1\n    assert balancedString(\"QQQW\") == 2\n    assert balancedString(\"QQQQ\") == 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_min/#2875-minimum-size-subarray-in-infinite-array","title":"2875. Minimum Size Subarray in Infinite Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, sliding window, prefix sum 2875. Minimum Size Subarray in Infinite Array - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window Variable Min\ndef minSizeSubarray(nums: List[int], target: int) -&gt; int:\n    total = sum(nums)\n    n = len(nums)\n    div, mod = divmod(target, total)\n    left, cur, res = 0, 0, float(\"inf\")\n\n    for right in range(n * 2):\n        cur += nums[right % n]\n\n        while cur &gt; mod:\n            cur -= nums[left % n]\n            left += 1\n\n        if cur == mod:\n            res = min(res, right - left + 1)\n\n    return res + div * n if res != float(\"inf\") else -1\n\n\nif __name__ == \"__main__\":\n    assert minSizeSubarray([1, 2, 3], 5) == 2\n    assert minSizeSubarray([1, 1, 1, 2, 3], 4) == 2\n    assert minSizeSubarray([2, 4, 6, 8], 3) == -1\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_min/#76-minimum-window-substring","title":"76. Minimum Window Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, sliding window 76. Minimum Window Substring - Python Solution<pre><code>from collections import Counter\n\n\ndef minWindow(s: str, t: str) -&gt; str:\n    if not t or not s:\n        return \"\"\n\n    counts = Counter(t)\n    required = len(counts)\n\n    left, right = 0, 0\n    formed = 0\n    window_counts = dict()\n\n    result = float(\"inf\"), None, None\n\n    while right &lt; len(s):\n        char = s[right]\n        window_counts[char] = window_counts.get(char, 0) + 1\n        if char in counts and window_counts[char] == counts[char]:\n            formed += 1\n\n        while left &lt;= right and formed == required:\n            char = s[left]\n            if right - left + 1 &lt; result[0]:\n                result = (right - left + 1, left, right)\n            window_counts[char] -= 1\n            if char in counts and window_counts[char] &lt; counts[char]:\n                formed -= 1\n            left += 1\n\n        right += 1\n\n    return \"\" if result[0] == float(\"inf\") else s[result[1] : result[2] + 1]\n\n\ns = \"ADOBECODEBANC\"\nt = \"ABC\"\nprint(minWindow(s, t))  # BANC\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_min/#632-smallest-range-covering-elements-from-k-lists","title":"632. Smallest Range Covering Elements from K Lists","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, greedy, sliding window, sorting, heap priority queue 632. Smallest Range Covering Elements from K Lists - Python Solution<pre><code>from heapq import heapify, heapreplace\nfrom math import inf\nfrom typing import List\n\n\n# Heap\ndef smallestRange(nums: List[List[int]]) -&gt; List[int]:\n    heap = [(arr[0], i, 0) for i, arr in enumerate(nums)]\n    heapify(heap)\n\n    res_l = heap[0][0]\n    res_r = right = max(arr[0] for arr in nums)\n\n    while heap[0][2] + 1 &lt; len(nums[heap[0][1]]):\n        _, i, j = heap[0]\n        x = nums[i][j + 1]\n        heapreplace(heap, (x, i, j + 1))\n        right = max(right, x)\n        left = heap[0][0]\n        if right - left &lt; res_r - res_l:\n            res_l, res_r = left, right\n\n    return [res_l, res_r]\n\n\n# Sliding Window Variable Min\ndef smallestRangeSliding(nums: List[List[int]]) -&gt; List[int]:\n    pairs = sorted((x, i) for (i, arr) in enumerate(nums) for x in arr)\n    res_l, res_r = -inf, inf\n    empty = len(nums)\n    cnt = [0] * empty\n    left = 0\n\n    for r, i in pairs:\n        if cnt[i] == 0:\n            empty -= 1\n        cnt[i] += 1\n        while empty == 0:\n            l, i = pairs[left]\n            if r - l &lt; res_r - res_l:\n                res_l, res_r = l, r\n            cnt[i] -= 1\n            if cnt[i] == 0:\n                empty += 1\n            left += 1\n\n    return [res_l, res_r]\n\n\nif __name__ == \"__main__\":\n    nums = [[4, 10, 15, 24, 26], [0, 9, 12, 20], [5, 18, 22, 30]]\n    assert smallestRange(nums) == [20, 24]\n    assert smallestRangeSliding(nums) == [20, 24]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_others/","title":"Sliding Window Variable Others","text":""},{"location":"content/endlesscheng/sliding_window_variable_others/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit (Medium)</li> <li> 825. Friends Of Appropriate Ages (Medium)</li> <li> 2401. Longest Nice Subarray (Medium)</li> <li> 1156. Swap For Longest Repeated Character Substring (Medium)</li> <li> 424. Longest Repeating Character Replacement (Medium)</li> <li> 438. Find All Anagrams in a String (Medium)</li> <li> 1712. Ways to Split Array Into Three Subarrays (Medium)</li> <li> 1918. Kth Smallest Subarray Sum (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_others/#1438-longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit","title":"1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, queue, sliding window, heap priority queue, ordered set, monotonic queue</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_others/#825-friends-of-appropriate-ages","title":"825. Friends Of Appropriate Ages","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_others/#2401-longest-nice-subarray","title":"2401. Longest Nice Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_others/#1156-swap-for-longest-repeated-character-substring","title":"1156. Swap For Longest Repeated Character Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_others/#424-longest-repeating-character-replacement","title":"424. Longest Repeating Character Replacement","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window 424. Longest Repeating Character Replacement - Python Solution<pre><code>from collections import defaultdict\n\n\n# Sliding Window - Variable\ndef characterReplacement(s: str, k: int) -&gt; int:\n    left = 0\n    maxCount = 0\n    counts = defaultdict(int)\n    maxLen = 0\n\n    for right in range(len(s)):\n        counts[s[right]] += 1\n        maxCount = max(maxCount, counts[s[right]])\n\n        while right - left + 1 - maxCount &gt; k:\n            counts[s[left]] -= 1\n            left += 1\n\n        maxLen = max(maxLen, right - left + 1)\n\n    return maxLen\n\n\ns = \"ABAB\"\nk = 2\nprint(characterReplacement(s, k))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_others/#438-find-all-anagrams-in-a-string","title":"438. Find All Anagrams in a String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window 438. Find All Anagrams in a String - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window Fixed Size\ndef findAnagrams(s: str, p: str) -&gt; List[int]:\n    n, k = len(s), len(p)\n    target = [0 for _ in range(26)]\n    for ch in p:\n        target[ord(ch) - ord(\"a\")] += 1\n\n    count = [0 for _ in range(26)]\n    left = 0\n    res = []\n\n    for right in range(n):\n        count[ord(s[right]) - ord(\"a\")] += 1\n        if right &lt; k - 1:\n            continue\n\n        if count == target:\n            res.append(left)\n\n        count[ord(s[left]) - ord(\"a\")] -= 1\n        left += 1\n\n    return res\n\n\ns = \"cbaebabacd\"\np = \"abc\"\nprint(findAnagrams(s, p))  # [0, 6]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_others/#1712-ways-to-split-array-into-three-subarrays","title":"1712. Ways to Split Array Into Three Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_others/#1918-kth-smallest-subarray-sum","title":"1918. Kth Smallest Subarray Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_subarrays_exact/","title":"Sliding Window Variable Subarrays Exact","text":""},{"location":"content/endlesscheng/sliding_window_variable_subarrays_exact/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 930. Binary Subarrays With Sum (Medium)</li> <li> 1248. Count Number of Nice Subarrays (Medium)</li> <li> 3305. Count of Substrings Containing Every Vowel and K Consonants I (Medium)</li> <li> 3306. Count of Substrings Containing Every Vowel and K Consonants II (Medium)</li> <li> 992. Subarrays with K Different Integers (Hard)</li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_subarrays_exact/#930-binary-subarrays-with-sum","title":"930. Binary Subarrays With Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, sliding window, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_subarrays_exact/#1248-count-number-of-nice-subarrays","title":"1248. Count Number of Nice Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, sliding window, prefix sum 1248. Count Number of Nice Subarrays - Python Solution<pre><code>from typing import List\n\n\n# Prefix Sum\ndef numberOfSubarrays(nums: List[int], k: int) -&gt; int:\n    count = 0\n    odd_counts = {0: 1}  # odd_count -&gt; count\n    odd_count = 0\n\n    for num in nums:\n        if num % 2 == 1:\n            odd_count += 1\n        if odd_count - k in odd_counts:\n            count += odd_counts[odd_count - k]\n        if odd_count in odd_counts:\n            odd_counts[odd_count] += 1\n        else:\n            odd_counts[odd_count] = 1\n\n    return count\n\n\nnums = [1, 1, 2, 1, 1]\nk = 3\nprint(numberOfSubarrays(nums, k))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_subarrays_exact/#3305-count-of-substrings-containing-every-vowel-and-k-consonants-i","title":"3305. Count of Substrings Containing Every Vowel and K Consonants I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window 3305. Count of Substrings Containing Every Vowel and K Consonants I - Python Solution<pre><code>from collections import defaultdict\n\n\n# Sliding Window Variable Subarrays Exact\ndef countOfSubstrings(word: str, k: int) -&gt; int:\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\"}\n    n = len(word)\n\n    def count(m: int) -&gt; int:\n        occur = defaultdict(int)\n        valid_vow_cnt, con_cnt = 0, 0\n        left = 0\n        res = 0\n\n        for right in range(n):\n            while left &lt; n and (con_cnt &lt; m or valid_vow_cnt &lt; 5):\n                if word[left] in vowels:\n                    if occur[word[left]] == 0:\n                        valid_vow_cnt += 1\n                    occur[word[left]] += 1\n                else:\n                    con_cnt += 1\n                left += 1\n\n            if con_cnt &gt;= m and valid_vow_cnt == 5:\n                res += n - left + 1\n\n            if word[right] in vowels:\n                occur[word[right]] -= 1\n                if occur[word[right]] == 0:\n                    valid_vow_cnt -= 1\n            else:\n                con_cnt -= 1\n\n        return res\n\n    return count(k) - count(k + 1)\n\n\nword = \"ieaouqqieaouqq\"\nk = 1\nprint(countOfSubstrings(word, k))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_subarrays_exact/#3306-count-of-substrings-containing-every-vowel-and-k-consonants-ii","title":"3306. Count of Substrings Containing Every Vowel and K Consonants II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window 3306. Count of Substrings Containing Every Vowel and K Consonants II - Python Solution<pre><code>from collections import defaultdict\n\n\n# Sliding Window Variable Subarrays Exact\ndef countOfSubstrings(word: str, k: int) -&gt; int:\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\"}\n    n = len(word)\n\n    def count(m: int) -&gt; int:\n        occur = defaultdict(int)\n        valid_vow_cnt, con_cnt = 0, 0\n        left = 0\n        res = 0\n\n        for right in range(n):\n            while left &lt; n and (con_cnt &lt; m or valid_vow_cnt &lt; 5):\n                if word[left] in vowels:\n                    if occur[word[left]] == 0:\n                        valid_vow_cnt += 1\n                    occur[word[left]] += 1\n                else:\n                    con_cnt += 1\n                left += 1\n\n            if con_cnt &gt;= m and valid_vow_cnt == 5:\n                res += n - left + 1\n\n            if word[right] in vowels:\n                occur[word[right]] -= 1\n                if occur[word[right]] == 0:\n                    valid_vow_cnt -= 1\n            else:\n                con_cnt -= 1\n\n        return res\n\n    return count(k) - count(k + 1)\n\n\nword = \"ieaouqqieaouqq\"\nk = 1\nprint(countOfSubstrings(word, k))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_subarrays_exact/#992-subarrays-with-k-different-integers","title":"992. Subarrays with K Different Integers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, sliding window, counting 992. Subarrays with K Different Integers - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window - Variable\ndef subarraysWithKDistinct(nums: List[int], k: int) -&gt; int:\n    def atMost(k: int) -&gt; int:\n        count = 0\n        left = 0\n        freq = {}\n\n        for right in range(len(nums)):\n            if nums[right] not in freq:\n                freq[nums[right]] = 0\n            freq[nums[right]] += 1\n\n            while len(freq) &gt; k:\n                freq[nums[left]] -= 1\n                if freq[nums[left]] == 0:\n                    del freq[nums[left]]\n                left += 1\n\n            count += right - left + 1\n\n        return count\n\n    return atMost(k) - atMost(k - 1)\n\n\nnums = [1, 2, 1, 2, 3]\nk = 2\nprint(subarraysWithKDistinct(nums, k))  # 7\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_subarrays_longer/","title":"Sliding Window Variable Subarrays Longer","text":""},{"location":"content/endlesscheng/sliding_window_variable_subarrays_longer/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1358. Number of Substrings Containing All Three Characters (Medium)</li> <li> 2962. Count Subarrays Where Max Element Appears at Least K Times (Medium)</li> <li> 3325. Count Substrings With K-Frequency Characters I (Medium)</li> <li> 2799. Count Complete Subarrays in an Array (Medium)</li> <li> 2537. Count the Number of Good Subarrays (Medium)</li> <li> 3298. Count Substrings That Can Be Rearranged to Contain a String II (Hard)</li> <li> 2495. Number of Subarrays Having Even Product (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_subarrays_longer/#1358-number-of-substrings-containing-all-three-characters","title":"1358. Number of Substrings Containing All Three Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window 1358. Number of Substrings Containing All Three Characters - Python Solution<pre><code>from collections import defaultdict\n\n\n# Sliding Window Variable Size\ndef numberOfSubstrings(s: str) -&gt; int:\n    freqs = defaultdict(int)\n    res = 0\n    left = 0\n\n    for right in range(len(s)):\n        freqs[s[right]] += 1\n\n        while len(freqs) == 3:\n            freqs[s[left]] -= 1\n            if freqs[s[left]] == 0:\n                del freqs[s[left]]\n            left += 1\n\n        res += left\n\n    return res\n\n\ns = \"abcabc\"\nprint(numberOfSubstrings(s))  # 10\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_subarrays_longer/#2962-count-subarrays-where-max-element-appears-at-least-k-times","title":"2962. Count Subarrays Where Max Element Appears at Least K Times","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_subarrays_longer/#3325-count-substrings-with-k-frequency-characters-i","title":"3325. Count Substrings With K-Frequency Characters I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_subarrays_longer/#2799-count-complete-subarrays-in-an-array","title":"2799. Count Complete Subarrays in an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_subarrays_longer/#2537-count-the-number-of-good-subarrays","title":"2537. Count the Number of Good Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_subarrays_longer/#3298-count-substrings-that-can-be-rearranged-to-contain-a-string-ii","title":"3298. Count Substrings That Can Be Rearranged to Contain a String II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_subarrays_longer/#2495-number-of-subarrays-having-even-product","title":"2495. Number of Subarrays Having Even Product","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_subarrays_shorter/","title":"Sliding Window Variable Subarrays Shorter","text":""},{"location":"content/endlesscheng/sliding_window_variable_subarrays_shorter/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 713. Subarray Product Less Than K (Medium)</li> <li> 3258. Count Substrings That Satisfy K-Constraint I (Easy)</li> <li> 2302. Count Subarrays With Score Less Than K (Hard)</li> <li> 2762. Continuous Subarrays (Medium)</li> <li> 3134. Find the Median of the Uniqueness Array (Hard)</li> <li> 3261. Count Substrings That Satisfy K-Constraint II (Hard)</li> <li> 2743. Count Substrings Without Repeating Character (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_subarrays_shorter/#713-subarray-product-less-than-k","title":"713. Subarray Product Less Than K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sliding window, prefix sum 713. Subarray Product Less Than K - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window Variable Subarrays Shorter\ndef numSubarrayProductLessThanK(nums: List[int], k: int) -&gt; int:\n    if k &lt;= 1:\n        return 0\n\n    left = 0\n    prod = 1\n    res = 0\n\n    for right in range(len(nums)):\n        prod *= nums[right]\n\n        while prod &gt;= k:\n            prod //= nums[left]\n            left += 1\n\n        res += right - left + 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert numSubarrayProductLessThanK([10, 5, 2, 6], 100) == 8\n    assert numSubarrayProductLessThanK([1, 2, 3], 0) == 0\n    assert numSubarrayProductLessThanK([1, 2, 3], 1) == 0\n    assert numSubarrayProductLessThanK([1, 2, 3], 2) == 1\n    assert numSubarrayProductLessThanK([1, 2, 3], 3) == 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_subarrays_shorter/#3258-count-substrings-that-satisfy-k-constraint-i","title":"3258. Count Substrings That Satisfy K-Constraint I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_subarrays_shorter/#2302-count-subarrays-with-score-less-than-k","title":"2302. Count Subarrays With Score Less Than K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, sliding window, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_subarrays_shorter/#2762-continuous-subarrays","title":"2762. Continuous Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, queue, sliding window, heap priority queue, ordered set, monotonic queue</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_subarrays_shorter/#3134-find-the-median-of-the-uniqueness-array","title":"3134. Find the Median of the Uniqueness Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, binary search, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_subarrays_shorter/#3261-count-substrings-that-satisfy-k-constraint-ii","title":"3261. Count Substrings That Satisfy K-Constraint II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, binary search, sliding window, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/sliding_window_variable_subarrays_shorter/#2743-count-substrings-without-repeating-character","title":"2743. Count Substrings Without Repeating Character","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/sorting_inequality/","title":"Sorting Inequality","text":""},{"location":"content/endlesscheng/sorting_inequality/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2285. Maximum Total Importance of Roads (Medium)</li> <li> 3016. Minimum Number of Pushes to Type Word II (Medium)</li> <li> 1402. Reducing Dishes (Hard)</li> <li> 2931. Maximum Spending After Buying Items (Hard)</li> <li> 1589. Maximum Sum Obtained of Any Permutation (Medium)</li> <li> 1874. Minimize Product Sum of Two Arrays (Medium) \ud83d\udc51</li> <li> 2268. Minimum Number of Keypresses (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/sorting_inequality/#2285-maximum-total-importance-of-roads","title":"2285. Maximum Total Importance of Roads","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: greedy, graph, sorting, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/sorting_inequality/#3016-minimum-number-of-pushes-to-type-word-ii","title":"3016. Minimum Number of Pushes to Type Word II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, greedy, sorting, counting</p> </li> </ul>"},{"location":"content/endlesscheng/sorting_inequality/#1402-reducing-dishes","title":"1402. Reducing Dishes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/sorting_inequality/#2931-maximum-spending-after-buying-items","title":"2931. Maximum Spending After Buying Items","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sorting, heap priority queue, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/sorting_inequality/#1589-maximum-sum-obtained-of-any-permutation","title":"1589. Maximum Sum Obtained of Any Permutation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting, prefix sum 1589. Maximum Sum Obtained of Any Permutation - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef maxSumRangeQuery(nums: List[int], requests: List[List[int]]) -&gt; int:\n    n = len(nums)\n    freq = [0 for _ in range(n + 1)]\n\n    for start, end in requests:\n        freq[start] += 1\n        if end + 1 &lt; n:\n            freq[end + 1] -= 1\n\n    for i in range(1, n):\n        freq[i] += freq[i - 1]\n\n    freq.pop()\n\n    freq.sort(reverse=True)\n    nums.sort(reverse=True)\n\n    max_sum = 0\n    mod = 10**9 + 7\n\n    for i, j in zip(nums, freq):\n        max_sum += i * j\n        max_sum %= mod\n\n    return max_sum\n\n\nnums = [1, 2, 3, 4, 5]\nrequests = [[1, 3], [0, 1]]\nprint(maxSumRangeQuery(nums, requests))  # 19\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/sorting_inequality/#1874-minimize-product-sum-of-two-arrays","title":"1874. Minimize Product Sum of Two Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/sorting_inequality/#2268-minimum-number-of-keypresses","title":"2268. Minimum Number of Keypresses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, greedy, sorting, counting</p> </li> </ul>"},{"location":"content/endlesscheng/stack_advanced/","title":"Stack Advanced","text":""},{"location":"content/endlesscheng/stack_advanced/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3170. Lexicographically Minimum String After Removing Stars (Medium)</li> <li> 155. Min Stack (Medium)</li> <li> 1381. Design a Stack With Increment Operation (Medium)</li> <li> 636. Exclusive Time of Functions (Medium)</li> <li> 2434. Using a Robot to Print the Lexicographically Smallest String (Medium)</li> <li> 895. Maximum Frequency Stack (Hard)</li> <li> 1172. Dinner Plate Stacks (Hard)</li> <li> 2589. Minimum Time to Complete All Tasks (Hard)</li> <li> 716. Max Stack (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/stack_advanced/#3170-lexicographically-minimum-string-after-removing-stars","title":"3170. Lexicographically Minimum String After Removing Stars","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, stack, greedy, heap priority queue 3170. Lexicographically Minimum String After Removing Stars - Python Solution<pre><code>from itertools import chain\n\n\n# Stack\ndef clearStars(s: str) -&gt; str:\n    stacks = [[] for _ in range(26)]\n    for i, c in enumerate(s):\n        if c != \"*\":\n            stacks[ord(c) - ord(\"a\")].append(i)\n            continue\n\n        for st in stacks:\n            if st:\n                st.pop()\n                break\n    return \"\".join(s[i] for i in sorted(chain.from_iterable(stacks)))\n\n\nif __name__ == \"__main__\":\n    assert clearStars(\"aaba*\") == \"aab\"\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/stack_advanced/#155-min-stack","title":"155. Min Stack","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: stack, design</p> </li> <li>Implement a stack that supports push, pop, top, and retrieving the minimum element in constant time.</li> </ul> 155. Min Stack - Python Solution<pre><code># Stack\nclass MinStack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, val: int) -&gt; None:\n        if self.stack:\n            self.stack.append((val, min(val, self.getMin())))\n        else:\n            self.stack.append((val, val))\n\n    def pop(self) -&gt; None:\n        self.stack.pop()\n\n    def top(self) -&gt; int:\n        return self.stack[-1][0]\n\n    def getMin(self) -&gt; int:\n        return self.stack[-1][1]\n\n\nobj = MinStack()\nobj.push(3)\nobj.push(2)\nobj.pop()\nprint(obj.top())  # 3\nprint(obj.getMin())  # 3\n</code></pre> 155. Min Stack - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;climits&gt;\n#include &lt;iostream&gt;\n#include &lt;stack&gt;\n#include &lt;utility&gt;\nusing namespace std;\n\nclass MinStack {\n    stack&lt;pair&lt;int, int&gt;&gt; st;\n\n   public:\n    MinStack() { st.emplace(0, INT_MAX); }\n\n    void push(int val) { st.emplace(val, min(getMin(), val)); }\n\n    void pop() { st.pop(); }\n\n    int top() { return st.top().first; }\n\n    int getMin() { return st.top().second; }\n};\n\nint main() {\n    MinStack minStack;\n    minStack.push(-2);\n    minStack.push(0);\n    minStack.push(-3);\n    cout &lt;&lt; minStack.getMin() &lt;&lt; endl;  // -3\n    minStack.pop();\n    cout &lt;&lt; minStack.top() &lt;&lt; endl;     // 0\n    cout &lt;&lt; minStack.getMin() &lt;&lt; endl;  // -2\n    return 0;\n}\n</code></pre>"},{"location":"content/endlesscheng/stack_advanced/#1381-design-a-stack-with-increment-operation","title":"1381. Design a Stack With Increment Operation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, design</p> </li> </ul>"},{"location":"content/endlesscheng/stack_advanced/#636-exclusive-time-of-functions","title":"636. Exclusive Time of Functions","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack</p> </li> </ul>"},{"location":"content/endlesscheng/stack_advanced/#2434-using-a-robot-to-print-the-lexicographically-smallest-string","title":"2434. Using a Robot to Print the Lexicographically Smallest String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, stack, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/stack_advanced/#895-maximum-frequency-stack","title":"895. Maximum Frequency Stack","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, stack, design, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/stack_advanced/#1172-dinner-plate-stacks","title":"1172. Dinner Plate Stacks","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, stack, design, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/stack_advanced/#2589-minimum-time-to-complete-all-tasks","title":"2589. Minimum Time to Complete All Tasks","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, stack, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/stack_advanced/#716-max-stack","title":"716. Max Stack","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: linked list, stack, design, doubly linked list, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/stack_basics/","title":"Stack Basics","text":""},{"location":"content/endlesscheng/stack_basics/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1441. Build an Array With Stack Operations (Medium)</li> <li> 844. Backspace String Compare (Easy)</li> <li> 682. Baseball Game (Easy)</li> <li> 2390. Removing Stars From a String (Medium)</li> <li> 1472. Design Browser History (Medium)</li> <li> 946. Validate Stack Sequences (Medium)</li> <li> 3412. Find Mirror Score of a String (Medium)</li> <li> 71. Simplify Path (Medium)</li> </ul>"},{"location":"content/endlesscheng/stack_basics/#1441-build-an-array-with-stack-operations","title":"1441. Build an Array With Stack Operations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, simulation 1441. Build an Array With Stack Operations - Python Solution<pre><code>from typing import List\n\n\n# Stack\ndef buildArray(target: List[int], n: int) -&gt; List[str]:\n    res = []\n    m, i, j = len(target), 1, 0\n\n    while i &lt;= n and j &lt; m:\n        res.append(\"Push\")\n        if target[j] != i:\n            res.append(\"Pop\")\n        else:\n            j += 1\n        i += 1\n\n    return res\n\n\ntarget = [1, 3, 4]\nn = 4\nprint(buildArray(target, n))\n# ['Push', 'Push', 'Pop', 'Push', 'Push']\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/stack_basics/#844-backspace-string-compare","title":"844. Backspace String Compare","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string, stack, simulation 844. Backspace String Compare - Python Solution<pre><code>def backspaceCompare(s: str, t: str) -&gt; bool:\n\n    def build(text):\n        stack = []\n\n        for char in text:\n            if char != \"#\":\n                stack.append(char)\n            elif stack:\n                stack.pop()\n\n        return \"\".join(stack)\n\n    return build(s) == build(t)\n\n\nprint(backspaceCompare(\"ab#c\", \"ad#c\"))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/stack_basics/#682-baseball-game","title":"682. Baseball Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, stack, simulation 682. Baseball Game - Python Solution<pre><code>from typing import List\n\n\n# Stack\ndef calPoints(operations: List[str]) -&gt; int:\n    stack = []\n\n    for op in operations:\n        if op == \"+\":\n            stack.append(stack[-2] + stack[-1])\n        elif op == \"D\":\n            stack.append(2 * stack[-1])\n        elif op == \"C\":\n            stack.pop()\n        else:\n            stack.append(int(op))\n\n    return sum(stack)\n\n\nops = [\"5\", \"2\", \"C\", \"D\", \"+\"]\nprint(calPoints(ops))  # 30\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/stack_basics/#2390-removing-stars-from-a-string","title":"2390. Removing Stars From a String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack, simulation</p> </li> <li>Remove all <code>*</code> characters and their adjacent characters from the string.</li> <li>Steps for the string <code>leet**cod*e</code>:</li> </ul> char action stack l push \"l\" e push \"le\" e push \"lee\" t push \"leet\" * pop \"lee\" * pop \"le\" c push \"lec\" o push \"leco\" d push \"lecod\" * pop \"leco\" e push \"lecoe\" 2390. Removing Stars From a String - Python Solution<pre><code># Stack\ndef removeStars(s: str) -&gt; str:\n    stack = []\n\n    for char in s:\n        if char == \"*\":\n            stack.pop()\n        else:\n            stack.append(char)\n\n    return \"\".join(stack)\n\n\ns = \"leet**cod*e\"\nprint(removeStars(s))  # \"lecoe\"\n</code></pre>"},{"location":"content/endlesscheng/stack_basics/#1472-design-browser-history","title":"1472. Design Browser History","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, linked list, stack, design, doubly linked list, data stream 1472. Design Browser History - Python Solution<pre><code>class BrowserHistory:\n\n    def __init__(self, homepage: str):\n        self.hist = [homepage]\n        self.cur = 0\n\n    def visit(self, url: str) -&gt; None:\n        self.cur += 1\n        del self.hist[self.cur :]\n        self.hist.append(url)\n\n    def back(self, steps: int) -&gt; str:\n        self.cur = max(self.cur - steps, 0)\n        return self.hist[self.cur]\n\n    def forward(self, steps: int) -&gt; str:\n        self.cur = min(self.cur + steps, len(self.hist) - 1)\n        return self.hist[self.cur]\n\n\nif __name__ == \"__main__\":\n    obj = BrowserHistory(\"leetcode.com\")\n    obj.visit(\"google.com\")\n    obj.visit(\"facebook.com\")\n    obj.visit(\"youtube.com\")\n    assert obj.back(1) == \"facebook.com\"\n    assert obj.back(1) == \"google.com\"\n    assert obj.forward(1) == \"facebook.com\"\n    obj.visit(\"linkedin.com\")\n    assert obj.forward(2) == \"linkedin.com\"\n    assert obj.back(2) == \"google.com\"\n    assert obj.back(7) == \"leetcode.com\"\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/stack_basics/#946-validate-stack-sequences","title":"946. Validate Stack Sequences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, simulation</p> </li> </ul>"},{"location":"content/endlesscheng/stack_basics/#3412-find-mirror-score-of-a-string","title":"3412. Find Mirror Score of a String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, stack, simulation</p> </li> </ul>"},{"location":"content/endlesscheng/stack_basics/#71-simplify-path","title":"71. Simplify Path","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack 71. Simplify Path - Python Solution<pre><code>def simplify_path_stack(path: str) -&gt; str:\n    if not path:\n        return \"/\"\n\n    stack = []\n\n    for p in path.split(\"/\"):\n        if p == \"\" or p == \".\":\n            continue\n        if p != \"..\":\n            stack.append(p)\n        elif stack:\n            stack.pop()\n    return \"/\" + \"/\".join(stack)\n\n\nif __name__ == \"__main__\":\n    assert simplify_path_stack(\"/home/\") == \"/home\"\n    assert simplify_path_stack(\"/../\") == \"/\"\n    assert simplify_path_stack(\"/home//foo/\") == \"/home/foo\"\n    assert simplify_path_stack(\"/a/./b/../../c/\") == \"/c\"\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/string_ac_automaton/","title":"String AC Automaton","text":""},{"location":"content/endlesscheng/string_ac_automaton/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1032. Stream of Characters (Hard)</li> <li> 1408. String Matching in an Array (Easy)</li> <li> 3213. Construct String with Minimum Cost (Hard)</li> <li> 3292. Minimum Number of Valid Strings to Form Target II (Hard)</li> </ul>"},{"location":"content/endlesscheng/string_ac_automaton/#1032-stream-of-characters","title":"1032. Stream of Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, design, trie, data stream</p> </li> </ul>"},{"location":"content/endlesscheng/string_ac_automaton/#1408-string-matching-in-an-array","title":"1408. String Matching in an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, string, string matching</p> </li> </ul>"},{"location":"content/endlesscheng/string_ac_automaton/#3213-construct-string-with-minimum-cost","title":"3213. Construct String with Minimum Cost","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, dynamic programming, suffix array</p> </li> </ul>"},{"location":"content/endlesscheng/string_ac_automaton/#3292-minimum-number-of-valid-strings-to-form-target-ii","title":"3292. Minimum Number of Valid Strings to Form Target II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, binary search, dynamic programming, segment tree, rolling hash, string matching, hash function</p> </li> </ul>"},{"location":"content/endlesscheng/string_hashing/","title":"String Hashing","text":""},{"location":"content/endlesscheng/string_hashing/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 28. Find the Index of the First Occurrence in a String (Easy)</li> <li> 187. Repeated DNA Sequences (Medium)</li> <li> 1316. Distinct Echo Substrings (Hard)</li> <li> 1297. Maximum Number of Occurrences of a Substring (Medium)</li> <li> 2261. K Divisible Elements Subarrays (Medium)</li> <li> 3213. Construct String with Minimum Cost (Hard)</li> <li> 1367. Linked List in Binary Tree (Medium)</li> <li> 1044. Longest Duplicate Substring (Hard)</li> <li> 718. Maximum Length of Repeated Subarray (Medium)</li> <li> 1923. Longest Common Subpath (Hard)</li> <li> 3292. Minimum Number of Valid Strings to Form Target II (Hard)</li> <li> 2168. Unique Substrings With Equal Digit Frequency (Medium) \ud83d\udc51</li> <li> 1554. Strings Differ by One Character (Medium) \ud83d\udc51</li> <li> 1062. Longest Repeating Substring (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/string_hashing/#28-find-the-index-of-the-first-occurrence-in-a-string","title":"28. Find the Index of the First Occurrence in a String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string, string matching 28. Find the Index of the First Occurrence in a String - Python Solution<pre><code>from template import LPS\n\n\n# Brute Force\ndef strStrBF(haystack: str, needle: str) -&gt; int:\n    m, n = len(haystack), len(needle)\n    for i in range(m - n + 1):\n        if haystack[i : i + n] == needle:\n            return i\n    return -1\n\n\n# KMP\ndef strStrKMP(haystack: str, needle: str) -&gt; int:\n    lps = LPS(needle)\n    m, n = len(haystack), len(needle)\n    j = 0\n\n    for i in range(m):\n        while j &gt; 0 and haystack[i] != needle[j]:\n            j = lps[j - 1]\n        if haystack[i] == needle[j]:\n            j += 1\n        if j == n:\n            return i - n + 1\n    return -1\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# | Brute Force| O((m - n) * n)   | O(1)    |\n# | KMP        | O(m + n)         | O(n)    |\n# |------------|------------------|---------|\n\n\nhaystack = \"hello\"\nneedle = \"ll\"\nprint(strStrBF(haystack, needle))  # 2\nprint(strStrKMP(haystack, needle))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/string_hashing/#187-repeated-dna-sequences","title":"187. Repeated DNA Sequences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, bit manipulation, sliding window, rolling hash, hash function</p> </li> </ul>"},{"location":"content/endlesscheng/string_hashing/#1316-distinct-echo-substrings","title":"1316. Distinct Echo Substrings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, trie, rolling hash, hash function</p> </li> </ul>"},{"location":"content/endlesscheng/string_hashing/#1297-maximum-number-of-occurrences-of-a-substring","title":"1297. Maximum Number of Occurrences of a Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/string_hashing/#2261-k-divisible-elements-subarrays","title":"2261. K Divisible Elements Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, trie, rolling hash, hash function, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/string_hashing/#3213-construct-string-with-minimum-cost","title":"3213. Construct String with Minimum Cost","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, dynamic programming, suffix array</p> </li> </ul>"},{"location":"content/endlesscheng/string_hashing/#1367-linked-list-in-binary-tree","title":"1367. Linked List in Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/string_hashing/#1044-longest-duplicate-substring","title":"1044. Longest Duplicate Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, binary search, sliding window, rolling hash, suffix array, hash function</p> </li> </ul>"},{"location":"content/endlesscheng/string_hashing/#718-maximum-length-of-repeated-subarray","title":"718. Maximum Length of Repeated Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, dynamic programming, sliding window, rolling hash, hash function 718. Maximum Length of Repeated Subarray - Python Solution<pre><code>from typing import List\n\n\ndef findLength(nums1: List[int], nums2: List[int]) -&gt; int:\n    m = len(nums1)\n    n = len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    length = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if nums1[i - 1] == nums2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            if length &lt; dp[i][j]:\n                length = dp[i][j]\n\n    return length\n\n\nprint(findLength([1, 2, 3, 2, 1], [3, 2, 1, 4, 7]))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/string_hashing/#1923-longest-common-subpath","title":"1923. Longest Common Subpath","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, rolling hash, suffix array, hash function</p> </li> </ul>"},{"location":"content/endlesscheng/string_hashing/#3292-minimum-number-of-valid-strings-to-form-target-ii","title":"3292. Minimum Number of Valid Strings to Form Target II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, binary search, dynamic programming, segment tree, rolling hash, string matching, hash function</p> </li> </ul>"},{"location":"content/endlesscheng/string_hashing/#2168-unique-substrings-with-equal-digit-frequency","title":"2168. Unique Substrings With Equal Digit Frequency","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, rolling hash, counting, hash function</p> </li> </ul>"},{"location":"content/endlesscheng/string_hashing/#1554-strings-differ-by-one-character","title":"1554. Strings Differ by One Character","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, rolling hash, hash function</p> </li> </ul>"},{"location":"content/endlesscheng/string_hashing/#1062-longest-repeating-substring","title":"1062. Longest Repeating Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, binary search, dynamic programming, rolling hash, suffix array, hash function</p> </li> </ul>"},{"location":"content/endlesscheng/string_kmp/","title":"String KMP","text":""},{"location":"content/endlesscheng/string_kmp/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 28. Find the Index of the First Occurrence in a String (Easy)</li> <li> 796. Rotate String (Easy)</li> <li> 1392. Longest Happy Prefix (Hard)</li> <li> 3036. Number of Subarrays That Match a Pattern II (Hard)</li> <li> 1764. Form Array by Concatenating Subarrays of Another Array (Medium)</li> <li> 1668. Maximum Repeating Substring (Easy)</li> <li> 459. Repeated Substring Pattern (Easy)</li> <li> 3008. Find Beautiful Indices in the Given Array II (Hard)</li> <li> 214. Shortest Palindrome (Hard)</li> <li> 686. Repeated String Match (Medium)</li> <li> 1397. Find All Good Strings (Hard)</li> <li> 3037. Find Pattern in Infinite Stream II (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/string_kmp/#28-find-the-index-of-the-first-occurrence-in-a-string","title":"28. Find the Index of the First Occurrence in a String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string, string matching 28. Find the Index of the First Occurrence in a String - Python Solution<pre><code>from template import LPS\n\n\n# Brute Force\ndef strStrBF(haystack: str, needle: str) -&gt; int:\n    m, n = len(haystack), len(needle)\n    for i in range(m - n + 1):\n        if haystack[i : i + n] == needle:\n            return i\n    return -1\n\n\n# KMP\ndef strStrKMP(haystack: str, needle: str) -&gt; int:\n    lps = LPS(needle)\n    m, n = len(haystack), len(needle)\n    j = 0\n\n    for i in range(m):\n        while j &gt; 0 and haystack[i] != needle[j]:\n            j = lps[j - 1]\n        if haystack[i] == needle[j]:\n            j += 1\n        if j == n:\n            return i - n + 1\n    return -1\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# | Brute Force| O((m - n) * n)   | O(1)    |\n# | KMP        | O(m + n)         | O(n)    |\n# |------------|------------------|---------|\n\n\nhaystack = \"hello\"\nneedle = \"ll\"\nprint(strStrBF(haystack, needle))  # 2\nprint(strStrKMP(haystack, needle))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/string_kmp/#796-rotate-string","title":"796. Rotate String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, string matching 796. Rotate String - Python Solution<pre><code># String\ndef rotateString(s: str, goal: str) -&gt; bool:\n    n = len(s)\n    s += s\n\n    for i in range(n):\n        if s[i : i + n] == goal:\n            return True\n\n    return False\n\n\ns = \"abcde\"\ngoal = \"cdeab\"\nprint(rotateString(s, goal))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/string_kmp/#1392-longest-happy-prefix","title":"1392. Longest Happy Prefix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, rolling hash, string matching, hash function 1392. Longest Happy Prefix - Python Solution<pre><code>from template import LPS\n\n\n# KMP\ndef longestPrefix(s: str) -&gt; str:\n    if len(s) &lt;= 1:\n        return \"\"\n\n    lps = LPS(s)\n\n    return s[: lps[-1]]\n\n\nprint(longestPrefix(\"ababab\"))  # abab\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/string_kmp/#3036-number-of-subarrays-that-match-a-pattern-ii","title":"3036. Number of Subarrays That Match a Pattern II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, rolling hash, string matching, hash function</p> </li> </ul>"},{"location":"content/endlesscheng/string_kmp/#1764-form-array-by-concatenating-subarrays-of-another-array","title":"1764. Form Array by Concatenating Subarrays of Another Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy, string matching</p> </li> </ul>"},{"location":"content/endlesscheng/string_kmp/#1668-maximum-repeating-substring","title":"1668. Maximum Repeating Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, dynamic programming, string matching</p> </li> </ul>"},{"location":"content/endlesscheng/string_kmp/#459-repeated-substring-pattern","title":"459. Repeated Substring Pattern","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, string matching 459. Repeated Substring Pattern - Python Solution<pre><code>from template import LPS\n\n\n# KMP\ndef repeatedSubstringPattern(s: str) -&gt; bool:\n    lps = LPS(s)\n    length = len(s)\n\n    if lps[-1] != 0 and length % (length - lps[-1]) == 0:\n        return True\n\n    return False\n\n\ns = \"abab\"\nprint(repeatedSubstringPattern(s))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/string_kmp/#3008-find-beautiful-indices-in-the-given-array-ii","title":"3008. Find Beautiful Indices in the Given Array II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: two pointers, string, binary search, rolling hash, string matching, hash function</p> </li> </ul>"},{"location":"content/endlesscheng/string_kmp/#214-shortest-palindrome","title":"214. Shortest Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, rolling hash, string matching, hash function 214. Shortest Palindrome - Python Solution<pre><code>from template import LPS\n\n\n# KMP\ndef shortestPalindrome(s: str) -&gt; str:\n    if not s:\n        return s\n\n    new = s + \"#\" + s[::-1]\n    lps = LPS(new)\n\n    add_len = len(s) - lps[-1]\n\n    return s[::-1][:add_len] + s\n\n\nprint(shortestPalindrome(\"aacecaaa\"))  # aaacecaaa\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/string_kmp/#686-repeated-string-match","title":"686. Repeated String Match","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, string matching 686. Repeated String Match - Python Solution<pre><code>import math\n\nfrom template import LPS\n\n\n# KMP\ndef repeatedStringMatch(a: str, b: str) -&gt; int:\n    min_repeat = math.ceil(len(b) / len(a))\n\n    def kmp(text, pattern):\n        n, m = len(text), len(pattern)\n        lps = LPS(pattern)\n        j = 0\n\n        for i in range(n):\n            while j &gt; 0 and text[i] != pattern[j]:\n                j = lps[j - 1]\n            if text[i] == pattern[j]:\n                j += 1\n            if j == m:\n                return i - j + 1\n        return -1\n\n    for i in range(min_repeat, min_repeat + 2):\n        if kmp(a * i, b) != -1:\n            return i\n    return -1\n\n\nprint(repeatedStringMatch(\"abcd\", \"cdabcdab\"))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/string_kmp/#1397-find-all-good-strings","title":"1397. Find All Good Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming, string matching</p> </li> </ul>"},{"location":"content/endlesscheng/string_kmp/#3037-find-pattern-in-infinite-stream-ii","title":"3037. Find Pattern in Infinite Stream II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, sliding window, rolling hash, string matching, hash function</p> </li> </ul>"},{"location":"content/endlesscheng/string_manacher_algorithm/","title":"String Manacher Algorithm","text":""},{"location":"content/endlesscheng/string_manacher_algorithm/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 5. Longest Palindromic Substring (Medium)</li> <li> 647. Palindromic Substrings (Medium)</li> <li> 214. Shortest Palindrome (Hard)</li> <li> 3327. Check if DFS Strings Are Palindromes (Hard)</li> <li> 1745. Palindrome Partitioning IV (Hard)</li> <li> 1960. Maximum Product of the Length of Two Palindromic Substrings (Hard)</li> </ul>"},{"location":"content/endlesscheng/string_manacher_algorithm/#5-longest-palindromic-substring","title":"5. Longest Palindromic Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string, dynamic programming</p> </li> <li>Return the longest palindromic substring in <code>s</code>.</li> </ul> 5. Longest Palindromic Substring - Python Solution<pre><code># DP - Interval\ndef longestPalindromeDP(s: str) -&gt; str:\n    n = len(s)\n    if n &lt;= 1:\n        return s\n\n    start, maxLen = 0, 1\n\n    # Init\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for j in range(1, n):\n        for i in range(j):\n            if s[i] == s[j]:\n                if j - i &lt;= 2:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1]\n\n                if dp[i][j] and j - i + 1 &gt; maxLen:\n                    maxLen = j - i + 1\n                    start = i\n\n    return s[start : start + maxLen]\n\n\n# Expand Around Center\ndef longestPalindromeCenter(s: str) -&gt; str:\n    def expand_around_center(left, right):\n        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n\n    if len(s) &lt;= 1:\n        return s\n\n    start, end = 0, 0\n    for i in range(len(s)):\n        len1 = expand_around_center(i, i)  # odd\n        len2 = expand_around_center(i, i + 1)  # even\n\n        maxLen = max(len1, len2)\n        if maxLen &gt; end - start:\n            start = i - (maxLen - 1) // 2\n            end = i + maxLen // 2\n\n    return s[start : end + 1]\n\n\ns = \"babad\"\nprint(longestPalindromeDP(s))  # \"bab\"\nprint(longestPalindromeCenter(s))  # \"aba\"\n</code></pre>"},{"location":"content/endlesscheng/string_manacher_algorithm/#647-palindromic-substrings","title":"647. Palindromic Substrings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string, dynamic programming</p> </li> <li>Return the number of palindromic substrings in <code>s</code>.</li> <li>Bottom-up DP table</li> </ul> dp a b b a e a 1 0 0 1 0 b 0 1 1 0 0 b 0 0 1 0 0 a 0 0 0 1 0 e 0 0 0 0 1 647. Palindromic Substrings - Python Solution<pre><code>def countSubstrings(s: str) -&gt; int:\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    res = 0\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i, n):\n            if s[i] == s[j]:\n                if j - i &lt;= 1:\n                    dp[i][j] = 1\n                    res += 1\n                elif dp[i + 1][j - 1]:\n                    dp[i][j] = 1\n                    res += 1\n\n    return res\n\n\nprint(countSubstrings(\"abbae\"))  # 7\n</code></pre>"},{"location":"content/endlesscheng/string_manacher_algorithm/#214-shortest-palindrome","title":"214. Shortest Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, rolling hash, string matching, hash function 214. Shortest Palindrome - Python Solution<pre><code>from template import LPS\n\n\n# KMP\ndef shortestPalindrome(s: str) -&gt; str:\n    if not s:\n        return s\n\n    new = s + \"#\" + s[::-1]\n    lps = LPS(new)\n\n    add_len = len(s) - lps[-1]\n\n    return s[::-1][:add_len] + s\n\n\nprint(shortestPalindrome(\"aacecaaa\"))  # aaacecaaa\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/string_manacher_algorithm/#3327-check-if-dfs-strings-are-palindromes","title":"3327. Check if DFS Strings Are Palindromes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, string, tree, depth first search, hash function</p> </li> </ul>"},{"location":"content/endlesscheng/string_manacher_algorithm/#1745-palindrome-partitioning-iv","title":"1745. Palindrome Partitioning IV","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming 1745. Palindrome Partitioning IV - Python Solution<pre><code># DP\ndef checkPartitioning(s: str) -&gt; bool:\n    def palidrome_partition(s, k):\n        n = len(s)\n        min_change = [[0] * n for _ in range(n)]\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 1, n):\n                min_change[i][j] = min_change[i + 1][j - 1] + (\n                    1 if s[i] != s[j] else 0\n                )\n\n        dp = min_change[0]\n\n        for i in range(1, k):\n            for right in range(n - k + i, i - 1, -1):\n                dp[right] = min(\n                    dp[left - 1] + min_change[left][right]\n                    for left in range(i, right + 1)\n                )\n\n        return dp[-1]\n\n    return palidrome_partition(s, 3) == 0\n\n\ns = \"abcbdd\"\nprint(checkPartitioning(s))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/string_manacher_algorithm/#1960-maximum-product-of-the-length-of-two-palindromic-substrings","title":"1960. Maximum Product of the Length of Two Palindromic Substrings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, rolling hash, hash function</p> </li> </ul>"},{"location":"content/endlesscheng/string_minimal_representation/","title":"String Minimal Representation","text":""},{"location":"content/endlesscheng/string_minimal_representation/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1163. Last Substring in Lexicographical Order (Hard)</li> <li> 899. Orderly Queue (Hard)</li> <li> 3403. Find the Lexicographically Largest String From the Box I (Medium)</li> </ul>"},{"location":"content/endlesscheng/string_minimal_representation/#1163-last-substring-in-lexicographical-order","title":"1163. Last Substring in Lexicographical Order","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: two pointers, string</p> </li> </ul>"},{"location":"content/endlesscheng/string_minimal_representation/#899-orderly-queue","title":"899. Orderly Queue","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, string, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/string_minimal_representation/#3403-find-the-lexicographically-largest-string-from-the-box-i","title":"3403. Find the Lexicographically Largest String From the Box I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string, enumeration 3403. Find the Lexicographically Largest String From the Box I - Python Solution<pre><code># Lexicographically Smallest/Largest\ndef answerString(word: str, numFriends: int) -&gt; str:\n    if numFriends == 1:\n        return word\n\n    n = len(word)\n    return max(word[i : i + n - numFriends + 1] for i in range(n))\n\n\nif __name__ == \"__main__\":\n    assert answerString(\"dbca\", 2) == \"dbc\"\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/string_subsequence_automaton/","title":"String Subsequence Automaton","text":""},{"location":"content/endlesscheng/string_subsequence_automaton/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 792. Number of Matching Subsequences (Medium)</li> <li> 514. Freedom Trail (Hard)</li> <li> 2014. Longest Subsequence Repeated k Times (Hard)</li> <li> 1055. Shortest Way to Form String (Medium) \ud83d\udc51</li> <li> 727. Minimum Window Subsequence (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/string_subsequence_automaton/#792-number-of-matching-subsequences","title":"792. Number of Matching Subsequences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, binary search, dynamic programming, trie, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/string_subsequence_automaton/#514-freedom-trail","title":"514. Freedom Trail","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming, depth first search, breadth first search</p> </li> </ul>"},{"location":"content/endlesscheng/string_subsequence_automaton/#2014-longest-subsequence-repeated-k-times","title":"2014. Longest Subsequence Repeated k Times","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, backtracking, greedy, counting, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/string_subsequence_automaton/#1055-shortest-way-to-form-string","title":"1055. Shortest Way to Form String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string, binary search, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/string_subsequence_automaton/#727-minimum-window-subsequence","title":"727. Minimum Window Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/string_suffix_array/","title":"String Suffix Array","text":""},{"location":"content/endlesscheng/string_suffix_array/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1163. Last Substring in Lexicographical Order (Hard)</li> <li> 1754. Largest Merge Of Two Strings (Medium)</li> <li> 2904. Shortest and Lexicographically Smallest Beautiful String (Medium)</li> <li> 3213. Construct String with Minimum Cost (Hard)</li> <li> 1044. Longest Duplicate Substring (Hard)</li> <li> 718. Maximum Length of Repeated Subarray (Medium)</li> <li> 1923. Longest Common Subpath (Hard)</li> <li> 1408. String Matching in an Array (Easy)</li> <li> 3076. Shortest Uncommon Substring in an Array (Medium)</li> <li> 1316. Distinct Echo Substrings (Hard)</li> <li> 3388. Count Beautiful Splits in an Array (Medium)</li> <li> 2564. Substring XOR Queries (Medium)</li> <li> 1698. Number of Distinct Substrings in a String (Medium) \ud83d\udc51</li> <li> 1062. Longest Repeating Substring (Medium) \ud83d\udc51</li> <li> 3135. Equalize Strings by Adding or Removing Characters at Ends (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/string_suffix_array/#1163-last-substring-in-lexicographical-order","title":"1163. Last Substring in Lexicographical Order","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: two pointers, string</p> </li> </ul>"},{"location":"content/endlesscheng/string_suffix_array/#1754-largest-merge-of-two-strings","title":"1754. Largest Merge Of Two Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/string_suffix_array/#2904-shortest-and-lexicographically-smallest-beautiful-string","title":"2904. Shortest and Lexicographically Smallest Beautiful String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, sliding window 2904. Shortest and Lexicographically Smallest Beautiful String - Python Solution<pre><code># Sliding Window Variable Size\ndef shortestBeautifulSubstring(s: str, k: int) -&gt; str:\n    n = len(s)\n    left = 0\n    oneCount = 0\n    minLen = float(\"inf\")\n    res = \"\"\n\n    for right in range(n):\n        if s[right] == \"1\":\n            oneCount += 1\n\n        while oneCount == k:\n            size = right - left + 1\n\n            if size &lt; minLen:\n                minLen = size\n                res = s[left : right + 1]\n            elif size == minLen:\n                res = min(res, s[left : right + 1])\n\n            if s[left] == \"1\":\n                oneCount -= 1\n            left += 1\n\n    return res\n\n\ns = \"100011001\"\nk = 3\nprint(shortestBeautifulSubstring(s, k))  # 11001\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/string_suffix_array/#3213-construct-string-with-minimum-cost","title":"3213. Construct String with Minimum Cost","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, dynamic programming, suffix array</p> </li> </ul>"},{"location":"content/endlesscheng/string_suffix_array/#1044-longest-duplicate-substring","title":"1044. Longest Duplicate Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, binary search, sliding window, rolling hash, suffix array, hash function</p> </li> </ul>"},{"location":"content/endlesscheng/string_suffix_array/#718-maximum-length-of-repeated-subarray","title":"718. Maximum Length of Repeated Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, dynamic programming, sliding window, rolling hash, hash function 718. Maximum Length of Repeated Subarray - Python Solution<pre><code>from typing import List\n\n\ndef findLength(nums1: List[int], nums2: List[int]) -&gt; int:\n    m = len(nums1)\n    n = len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    length = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if nums1[i - 1] == nums2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            if length &lt; dp[i][j]:\n                length = dp[i][j]\n\n    return length\n\n\nprint(findLength([1, 2, 3, 2, 1], [3, 2, 1, 4, 7]))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/string_suffix_array/#1923-longest-common-subpath","title":"1923. Longest Common Subpath","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, rolling hash, suffix array, hash function</p> </li> </ul>"},{"location":"content/endlesscheng/string_suffix_array/#1408-string-matching-in-an-array","title":"1408. String Matching in an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, string, string matching</p> </li> </ul>"},{"location":"content/endlesscheng/string_suffix_array/#3076-shortest-uncommon-substring-in-an-array","title":"3076. Shortest Uncommon Substring in an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, trie</p> </li> </ul>"},{"location":"content/endlesscheng/string_suffix_array/#1316-distinct-echo-substrings","title":"1316. Distinct Echo Substrings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, trie, rolling hash, hash function</p> </li> </ul>"},{"location":"content/endlesscheng/string_suffix_array/#3388-count-beautiful-splits-in-an-array","title":"3388. Count Beautiful Splits in an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/string_suffix_array/#2564-substring-xor-queries","title":"2564. Substring XOR Queries","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, bit manipulation</p> </li> </ul>"},{"location":"content/endlesscheng/string_suffix_array/#1698-number-of-distinct-substrings-in-a-string","title":"1698. Number of Distinct Substrings in a String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, trie, rolling hash, suffix array, hash function</p> </li> </ul>"},{"location":"content/endlesscheng/string_suffix_array/#1062-longest-repeating-substring","title":"1062. Longest Repeating Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, binary search, dynamic programming, rolling hash, suffix array, hash function</p> </li> </ul>"},{"location":"content/endlesscheng/string_suffix_array/#3135-equalize-strings-by-adding-or-removing-characters-at-ends","title":"3135. Equalize Strings by Adding or Removing Characters at Ends","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, binary search, dynamic programming, sliding window, hash function</p> </li> </ul>"},{"location":"content/endlesscheng/string_z_function/","title":"String Z Function","text":""},{"location":"content/endlesscheng/string_z_function/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2223. Sum of Scores of Built Strings (Hard)</li> <li> 3031. Minimum Time to Revert Word to Initial State II (Hard)</li> <li> 3045. Count Prefix and Suffix Pairs II (Hard)</li> <li> 3303. Find the Occurrence of First Almost Equal Substring (Hard)</li> <li> 3292. Minimum Number of Valid Strings to Form Target II (Hard)</li> <li> 2430. Maximum Deletions on a String (Hard)</li> <li> 3388. Count Beautiful Splits in an Array (Medium)</li> <li> 1977. Number of Ways to Separate Numbers (Hard)</li> </ul>"},{"location":"content/endlesscheng/string_z_function/#2223-sum-of-scores-of-built-strings","title":"2223. Sum of Scores of Built Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, binary search, rolling hash, suffix array, string matching, hash function</p> </li> </ul>"},{"location":"content/endlesscheng/string_z_function/#3031-minimum-time-to-revert-word-to-initial-state-ii","title":"3031. Minimum Time to Revert Word to Initial State II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, rolling hash, string matching, hash function</p> </li> </ul>"},{"location":"content/endlesscheng/string_z_function/#3045-count-prefix-and-suffix-pairs-ii","title":"3045. Count Prefix and Suffix Pairs II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, trie, rolling hash, string matching, hash function</p> </li> </ul>"},{"location":"content/endlesscheng/string_z_function/#3303-find-the-occurrence-of-first-almost-equal-substring","title":"3303. Find the Occurrence of First Almost Equal Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, string matching</p> </li> </ul>"},{"location":"content/endlesscheng/string_z_function/#3292-minimum-number-of-valid-strings-to-form-target-ii","title":"3292. Minimum Number of Valid Strings to Form Target II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, binary search, dynamic programming, segment tree, rolling hash, string matching, hash function</p> </li> </ul>"},{"location":"content/endlesscheng/string_z_function/#2430-maximum-deletions-on-a-string","title":"2430. Maximum Deletions on a String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming, rolling hash, string matching, hash function</p> </li> </ul>"},{"location":"content/endlesscheng/string_z_function/#3388-count-beautiful-splits-in-an-array","title":"3388. Count Beautiful Splits in an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/endlesscheng/string_z_function/#1977-number-of-ways-to-separate-numbers","title":"1977. Number of Ways to Separate Numbers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming, suffix array</p> </li> </ul>"},{"location":"content/endlesscheng/strongly_and_biconnected_components/","title":"Strongly and Biconnected Components","text":""},{"location":"content/endlesscheng/strongly_and_biconnected_components/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1192. Critical Connections in a Network (Hard)</li> <li> 1568. Minimum Number of Days to Disconnect Island (Hard)</li> <li> 3383. Minimum Runes to Add to Cast Spell (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/strongly_and_biconnected_components/#1192-critical-connections-in-a-network","title":"1192. Critical Connections in a Network","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: depth first search, graph, biconnected component 1192. Critical Connections in a Network - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Tarjan\ndef criticalConnections(\n    n: int, connections: List[List[int]]\n) -&gt; List[List[int]]:\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    disc = [-1] * n\n    low = [-1] * n\n    bridges = []\n    time = 0\n\n    def dfs(n1, prev):\n        nonlocal time\n        disc[n1], low[n1] = time, time\n        time += 1\n\n        for n2 in graph[n1]:\n            if n2 == prev:\n                continue\n            if disc[n2] == -1:\n                dfs(n2, n1)\n                low[n1] = min(low[n1], low[n2])\n\n                if low[n2] &gt; disc[n1]:\n                    bridges.append([n1, n2])\n            else:\n                low[n1] = min(low[n1], disc[n2])\n\n    for i in range(n):\n        if disc[i] == -1:\n            dfs(i, -1)\n\n    return bridges\n\n\nn = 4\nconnections = [[0, 1], [1, 2], [2, 0], [1, 3]]\nprint(criticalConnections(n, connections))  # [[1, 3]]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/strongly_and_biconnected_components/#1568-minimum-number-of-days-to-disconnect-island","title":"1568. Minimum Number of Days to Disconnect Island","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, matrix, strongly connected component</p> </li> </ul>"},{"location":"content/endlesscheng/strongly_and_biconnected_components/#3383-minimum-runes-to-add-to-cast-spell","title":"3383. Minimum Runes to Add to Cast Spell","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, graph, topological sort</p> </li> </ul>"},{"location":"content/endlesscheng/three_pointers/","title":"Three Pointers","text":""},{"location":"content/endlesscheng/three_pointers/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2367. Number of Arithmetic Triplets (Easy)</li> <li> 2563. Count the Number of Fair Pairs (Medium)</li> <li> 795. Number of Subarrays with Bounded Maximum (Medium)</li> <li> 2444. Count Subarrays With Fixed Bounds (Hard)</li> <li> 3347. Maximum Frequency of an Element After Performing Operations II (Hard)</li> <li> 1213. Intersection of Three Sorted Arrays (Easy) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/three_pointers/#2367-number-of-arithmetic-triplets","title":"2367. Number of Arithmetic Triplets","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, two pointers, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/three_pointers/#2563-count-the-number-of-fair-pairs","title":"2563. Count the Number of Fair Pairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/three_pointers/#795-number-of-subarrays-with-bounded-maximum","title":"795. Number of Subarrays with Bounded Maximum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers</p> </li> </ul>"},{"location":"content/endlesscheng/three_pointers/#2444-count-subarrays-with-fixed-bounds","title":"2444. Count Subarrays With Fixed Bounds","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, queue, sliding window, monotonic queue</p> </li> </ul>"},{"location":"content/endlesscheng/three_pointers/#3347-maximum-frequency-of-an-element-after-performing-operations-ii","title":"3347. Maximum Frequency of an Element After Performing Operations II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, sliding window, sorting, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/three_pointers/#1213-intersection-of-three-sorted-arrays","title":"1213. Intersection of Three Sorted Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, binary search, counting</p> </li> </ul>"},{"location":"content/endlesscheng/topological_order_dp/","title":"Topological Order DP","text":""},{"location":"content/endlesscheng/topological_order_dp/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2050. Parallel Courses III (Hard)</li> <li> 1857. Largest Color Value in a Directed Graph (Hard)</li> </ul>"},{"location":"content/endlesscheng/topological_order_dp/#2050-parallel-courses-iii","title":"2050. Parallel Courses III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, graph, topological sort</p> </li> </ul>"},{"location":"content/endlesscheng/topological_order_dp/#1857-largest-color-value-in-a-directed-graph","title":"1857. Largest Color Value in a Directed Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, dynamic programming, graph, topological sort, memoization, counting 1857. Largest Color Value in a Directed Graph - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# Topological Sort\ndef largestPathValue(colors: str, edges: List[List[int]]) -&gt; int:\n    n = len(colors)\n    graph = defaultdict(list)\n    indegree = [0 for _ in range(n)]\n\n    for u, v in edges:\n        graph[u].append(v)\n        indegree[v] += 1\n\n    q = deque([i for i in range(n) if indegree[i] == 0])\n\n    dp = [[0] * 26 for _ in range(n)]\n\n    for i in range(n):\n        dp[i][ord(colors[i]) - ord(\"a\")] = 1\n\n    processed, max_color = 0, 0\n\n    while q:\n        n1 = q.popleft()\n        processed += 1\n        max_color = max(max_color, max(dp[n1]))\n\n        for n2 in graph[n1]:\n            indegree[n2] -= 1\n            for i in range(26):\n                dp[n2][i] = max(\n                    dp[n2][i],\n                    dp[n1][i] + (1 if i == ord(colors[n2]) - ord(\"a\") else 0),\n                )\n            if indegree[n2] == 0:\n                q.append(n2)\n\n    return max_color if processed == n else -1\n\n\ncolors = \"abaca\"\nedges = [[0, 1], [0, 2], [2, 3], [3, 4]]\nprint(largestPathValue(colors, edges))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/topological_sorting/","title":"Topological Sorting","text":""},{"location":"content/endlesscheng/topological_sorting/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1557. Minimum Number of Vertices to Reach All Nodes (Medium)</li> <li> 210. Course Schedule II (Medium)</li> <li> 1462. Course Schedule IV (Medium)</li> <li> 2115. Find All Possible Recipes from Given Supplies (Medium)</li> <li> 851. Loud and Rich (Medium)</li> <li> 310. Minimum Height Trees (Medium)</li> <li> 2392. Build a Matrix With Conditions (Hard)</li> <li> 802. Find Eventual Safe States (Medium)</li> <li> 1591. Strange Printer II (Hard)</li> <li> 1203. Sort Items by Groups Respecting Dependencies (Hard)</li> <li> 2603. Collect Coins in a Tree (Hard)</li> <li> 269. Alien Dictionary (Hard) \ud83d\udc51</li> <li> 444. Sequence Reconstruction (Medium) \ud83d\udc51</li> <li> 1059. All Paths from Source Lead to Destination (Medium) \ud83d\udc51</li> <li> 1136. Parallel Courses (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/topological_sorting/#1557-minimum-number-of-vertices-to-reach-all-nodes","title":"1557. Minimum Number of Vertices to Reach All Nodes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: graph</p> </li> <li>Return a list of integers representing the minimum number of vertices needed to traverse all the nodes.</li> <li>Hint: Return the vertices with indegree 0.</li> </ul> 1557. Minimum Number of Vertices to Reach All Nodes - Python Solution<pre><code>from typing import List\n\n\n# Graph\ndef findSmallestSetOfVertices(n: int, edges: List[List[int]]) -&gt; List[int]:\n    indegree = {i: 0 for i in range(n)}\n\n    for _, end in edges:\n        indegree[end] += 1\n\n    return [i for i in range(n) if indegree[i] == 0]\n\n\nif __name__ == \"__main__\":\n    n = 6\n    edges = [[0, 1], [0, 2], [2, 5], [3, 4], [4, 2]]\n    assert findSmallestSetOfVertices(n, edges) == [0, 3]\n</code></pre>"},{"location":"content/endlesscheng/topological_sorting/#210-course-schedule-ii","title":"210. Course Schedule II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort</p> </li> <li>Return the ordering of courses you should take to finish all courses. If there are multiple valid answers, return any of them.</li> </ul> <p></p> 210. Course Schedule II - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# 1. BFS - Kahn's Algorithm\ndef findOrderBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    order = []\n\n    while q:\n        pre = q.popleft()\n        order.append(pre)\n\n        for crs in graph[pre]:\n            indegree[crs] -= 1\n            if indegree[crs] == 0:\n                q.append(crs)\n\n    return order if len(order) == numCourses else []\n\n\n# 2. DFS + Set\ndef findOrderDFS1(\n    numCourses: int, prerequisites: List[List[int]]\n) -&gt; List[int]:\n    adj = defaultdict(list)\n    for crs, pre in prerequisites:\n        adj[crs].append(pre)\n\n    visit, cycle = set(), set()\n    order = []\n\n    def dfs(crs):\n        if crs in cycle:\n            return False\n        if crs in visit:\n            return True\n\n        cycle.add(crs)\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        cycle.remove(crs)\n        visit.add(crs)\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order\n\n\n# 3. DFS + List\ndef findOrderDFS2(\n    numCourses: int, prerequisites: List[List[int]]\n) -&gt; List[int]:\n    adj = defaultdict(list)\n    for pre, crs in prerequisites:\n        adj[crs].append(pre)\n\n    # 0: not visited, 1: visiting, 2: visited\n    state = [0] * numCourses\n    order = []\n\n    def dfs(crs):\n        if state[crs] == 1:\n            return False\n        if state[crs] == 2:\n            return True\n\n        state[crs] = 1\n\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        state[crs] = 2\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order[::-1]\n\n\nnumCourses = 5\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(findOrderBFS(numCourses, prerequisites))  # [2, 4, 3, 1, 0]\nprint(findOrderDFS1(numCourses, prerequisites))  # [4, 3, 1, 2, 0]\nprint(findOrderDFS2(numCourses, prerequisites))  # [4, 3, 2, 1, 0]\n</code></pre> 210. Course Schedule II - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    // BFS\n    vector&lt;int&gt; findOrderBFS(int numCourses,\n                             vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        vector&lt;int&gt; indegree(numCourses, 0);\n\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n            indegree[pre[0]]++;\n        }\n\n        queue&lt;int&gt; q;\n        for (int i = 0; i &lt; numCourses; i++)\n            if (indegree[i] == 0) q.push(i);\n\n        vector&lt;int&gt; order;\n\n        while (!q.empty()) {\n            int cur = q.front();\n            q.pop();\n            order.push_back(cur);\n\n            for (int nxt : graph[cur]) {\n                indegree[nxt]--;\n                if (indegree[nxt] == 0) q.push(nxt);\n            }\n        }\n\n        return (int)order.size() == numCourses ? order : vector&lt;int&gt;{};\n    }\n};\n\nint main() {\n    Solution obj;\n    vector&lt;vector&lt;int&gt;&gt; prerequisites{{1, 0}, {2, 0}, {3, 1}, {3, 2}};\n    vector&lt;int&gt; res = obj.findOrderBFS(4, prerequisites);\n    for (size_t i = 0; i &lt; res.size(); i++) cout &lt;&lt; res[i] &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"content/endlesscheng/topological_sorting/#1462-course-schedule-iv","title":"1462. Course Schedule IV","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort 1462. Course Schedule IV - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# Topological Sort\ndef checkIfPrerequisite(\n    numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]\n) -&gt; List[bool]:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n    record = defaultdict(set)  # store all prerequisites for each course\n\n    for a, b in prerequisites:\n        graph[a].append(b)\n        indegree[b] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n\n    while q:\n        cur = q.popleft()\n        for nxt in graph[cur]:\n            record[nxt].add(cur)\n            record[nxt].update(record[cur])\n\n            indegree[nxt] -= 1\n            if indegree[nxt] == 0:\n                q.append(nxt)\n\n    res = []\n    for u, v in queries:\n        res.append(u in record[v])\n    return res\n\n\nif __name__ == \"__main__\":\n    numCourses = 2\n    prerequisites = [[1, 0]]\n    queries = [[0, 1], [1, 0]]\n    assert checkIfPrerequisite(numCourses, prerequisites, queries) == [\n        False,\n        True,\n    ]\n    numCourses = 3\n    prerequisites = [[1, 2], [1, 0], [2, 0]]\n    queries = [[1, 0], [1, 2]]\n    assert checkIfPrerequisite(numCourses, prerequisites, queries) == [\n        True,\n        True,\n    ]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/topological_sorting/#2115-find-all-possible-recipes-from-given-supplies","title":"2115. Find All Possible Recipes from Given Supplies","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, graph, topological sort 2115. Find All Possible Recipes from Given Supplies - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# Topological Sort\ndef findAllRecipes(\n    recipes: List[str], ingredients: List[List[str]], supplies: List[str]\n) -&gt; List[str]:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for a, b in zip(recipes, ingredients):\n        for i in b:\n            graph[i].append(a)\n        indegree[a] = len(b)\n\n    res = []\n    q = deque(supplies)\n\n    while q:\n        cur = q.popleft()\n        for nxt in graph[cur]:\n            indegree[nxt] -= 1\n            if indegree[nxt] == 0:\n                q.append(nxt)\n                res.append(nxt)\n    return res\n\n\nif __name__ == \"__main__\":\n    recipes = [\"bread\"]\n    ingredients = [[\"yeast\", \"flour\"]]\n    supplies = [\"yeast\", \"flour\", \"corn\"]\n    assert findAllRecipes(recipes, ingredients, supplies) == [\"bread\"]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/topological_sorting/#851-loud-and-rich","title":"851. Loud and Rich","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, graph, topological sort</p> </li> </ul>"},{"location":"content/endlesscheng/topological_sorting/#310-minimum-height-trees","title":"310. Minimum Height Trees","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort 310. Minimum Height Trees - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\ndef findMinHeightTrees(n: int, edges: List[List[int]]) -&gt; List[int]:\n    if n == 1:\n        return [0]\n\n    graph = {i: set() for i in range(n)}\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    q = deque([i for i in range(n) if len(graph[i]) == 1])\n    remaining = n\n\n    while remaining &gt; 2:\n        size = len(q)\n        remaining -= size\n\n        for _ in range(size):\n            cur = q.popleft()\n            nei = graph[cur].pop()\n            graph[nei].remove(cur)\n\n            if len(graph[nei]) == 1:\n                q.append(nei)\n\n    return list(q)\n\n\nn = 6\nedges = [[3, 0], [3, 1], [3, 2], [3, 4], [5, 4]]\nprint(findMinHeightTrees(n, edges))  # [3, 4]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/topological_sorting/#2392-build-a-matrix-with-conditions","title":"2392. Build a Matrix With Conditions","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, graph, topological sort, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/topological_sorting/#802-find-eventual-safe-states","title":"802. Find Eventual Safe States","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort 802. Find Eventual Safe States - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# Topological Sort\ndef eventualSafeNodesTS(graph: List[List[int]]) -&gt; List[int]:\n    n = len(graph)\n    reverse_graph = defaultdict(list)\n    indegree = [0 for _ in range(n)]\n    safe = [False for _ in range(n)]\n\n    for u in range(n):\n        for v in graph[u]:\n            reverse_graph[v].append(u)\n        indegree[u] = len(graph[u])\n\n    q = deque([i for i in range(n) if indegree[i] == 0])\n\n    while q:\n        node = q.popleft()\n        safe[node] = True\n\n        for neighbor in reverse_graph[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n\n    return [i for i in range(n) if safe[i]]\n\n\n# DFS\ndef eventualSafeNodesDFS(graph: List[List[int]]) -&gt; List[int]:\n    n = len(graph)\n    state = [0 for _ in range(n)]  # 0: unvisited, 1: visiting, 2: visited\n\n    def dfs(node):\n        if state[node] &gt; 0:\n            return state[node] == 2\n        state[node] = 1\n        for neighbor in graph[node]:\n            if state[neighbor] == 1 or not dfs(neighbor):\n                return False\n        state[node] = 2\n        return True\n\n    return [i for i in range(n) if dfs(i)]\n\n\ngraph = [[1, 2], [2, 3], [5], [0], [5], [], []]\nprint(eventualSafeNodesTS(graph))  # [2, 4, 5, 6]\nprint(eventualSafeNodesDFS(graph))  # [2, 4, 5, 6]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/topological_sorting/#1591-strange-printer-ii","title":"1591. Strange Printer II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, graph, topological sort, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/topological_sorting/#1203-sort-items-by-groups-respecting-dependencies","title":"1203. Sort Items by Groups Respecting Dependencies","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort</p> </li> <li>Return any permutation of the items that satisfies the requirements.</li> </ul> 1203. Sort Items by Groups Respecting Dependencies - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS - Kahn's algorithm (Topological Sort)\ndef sortItems(\n    n: int, m: int, group: List[int], beforeItems: List[List[int]]\n) -&gt; List[int]:\n    def topological_sort(graph, indegree, nodes):\n        q = deque([node for node in nodes if indegree[node] == 0])\n        result = []\n\n        while q:\n            node = q.popleft()\n            result.append(node)\n\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    q.append(neighbor)\n\n        return result if len(result) == len(nodes) else []\n\n    groupItems = defaultdict(list)\n    groupGraph = defaultdict(set)\n    groupIndegree = defaultdict(int)\n    itemGraph = defaultdict(set)\n    itemIndegree = defaultdict(int)\n\n    for i in range(n):\n        if group[i] == -1:\n            group[i] = m\n            m += 1\n        groupItems[group[i]].append(i)\n\n    for i, beforeItem in enumerate(beforeItems):\n        for before in beforeItem:\n            if group[before] != group[i]:\n                if group[i] not in groupGraph[group[before]]:\n                    groupGraph[group[before]].add(group[i])\n                    groupIndegree[group[i]] += 1\n            else:\n                itemGraph[before].add(i)\n                itemIndegree[i] += 1\n\n    allGroups = list(set(group))\n    groupOrder = topological_sort(groupGraph, groupIndegree, allGroups)\n    if not groupOrder:\n        return []\n\n    result = []\n    for g in groupOrder:\n        items = groupItems[g]\n        itemOrder = topological_sort(itemGraph, itemIndegree, items)\n        if not itemOrder:\n            return []\n        result.extend(itemOrder)\n\n    return result\n\n\nn = 8\nm = 2\ngroup = [-1, -1, 1, 0, 0, 1, 0, -1]\nbeforeItems = [[], [6], [5], [6], [3, 6], [], [], []]\nprint(sortItems(n, m, group, beforeItems))\n</code></pre>"},{"location":"content/endlesscheng/topological_sorting/#2603-collect-coins-in-a-tree","title":"2603. Collect Coins in a Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, tree, graph, topological sort</p> </li> </ul>"},{"location":"content/endlesscheng/topological_sorting/#269-alien-dictionary","title":"269. Alien Dictionary","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, depth first search, breadth first search, graph, topological sort</p> </li> <li>Return the correct order of characters in the alien language.</li> </ul> 269. Alien Dictionary - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS - Kahn's algorithm (Topological Sort)\ndef alienOrderBFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    indegree = {c: 0 for word in words for c in word}\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                    indegree[w2[j]] += 1\n                break\n\n    q = deque([c for c in indegree if indegree[c] == 0])\n    result = []\n\n    while q:\n        char = q.popleft()\n        result.append(char)\n\n        for neighbor in graph[char]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n\n    return \"\".join(result) if len(result) == len(indegree) else \"\"\n\n\n# DFS - Topological Sort\ndef alienOrderDFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    visited = {}\n    result = []\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                break\n\n    def dfs(c):\n        if c in visited:\n            return visited[c]\n\n        visited[c] = False\n        for neighbor in graph[c]:\n            if not dfs(neighbor):\n                return False\n\n        visited[c] = True\n        result.append(c)\n        return True\n\n    for c in list(graph.keys()):\n        if not dfs(c):\n            return \"\"\n\n    return \"\".join(result[::-1])\n\n\nwords = [\"wrt\", \"wrf\", \"er\", \"ett\", \"rftt\"]\nprint(alienOrderBFS(words))  # wertf\nprint(alienOrderDFS(words))  # wertf\n</code></pre>"},{"location":"content/endlesscheng/topological_sorting/#444-sequence-reconstruction","title":"444. Sequence Reconstruction","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, graph, topological sort</p> </li> </ul>"},{"location":"content/endlesscheng/topological_sorting/#1059-all-paths-from-source-lead-to-destination","title":"1059. All Paths from Source Lead to Destination","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: graph, topological sort</p> </li> </ul>"},{"location":"content/endlesscheng/topological_sorting/#1136-parallel-courses","title":"1136. Parallel Courses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: graph, topological sort</p> </li> <li>Return the minimum number of semesters needed to take all courses.</li> </ul> <p></p> 1136. Parallel Courses - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# Topological Sort\ndef minimumSemesters(n: int, relations: List[List[int]]) -&gt; int:\n    graph = {i: [] for i in range(1, n + 1)}\n    indegree = {i: 0 for i in range(1, n + 1)}\n\n    for pre, nxt in relations:\n        graph[pre].append(nxt)\n        indegree[nxt] += 1\n\n    q = deque([i for i in range(1, n + 1) if indegree[i] == 0])\n    semester = 0\n    done = 0\n\n    while q:\n        semester += 1\n        size = len(q)\n\n        for _ in range(size):\n            pre = q.popleft()\n            done += 1\n\n            for nxt in graph[pre]:\n                indegree[nxt] -= 1\n                if indegree[nxt] == 0:\n                    q.append(nxt)\n\n    return semester if done == n else -1\n\n\nn = 3\nrelations = [[1, 3], [2, 3]]\nprint(minimumSemesters(n, relations))  # 2\n</code></pre>"},{"location":"content/endlesscheng/tree_dp/","title":"Tree DP","text":""},{"location":"content/endlesscheng/tree_dp/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 337. House Robber III (Medium)</li> <li> 968. Binary Tree Cameras (Hard)</li> <li> 2313. Minimum Flips in Binary Tree to Get Result (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/tree_dp/#337-house-robber-iii","title":"337. House Robber III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming, tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/tree_dp/#968-binary-tree-cameras","title":"968. Binary Tree Cameras","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, tree, depth first search, binary tree 968. Binary Tree Cameras - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef minCameraCover(root: Optional[TreeNode]) -&gt; int:\n    res = 0\n\n    def dfs(node, hasParent):\n        if not node:\n            return -1\n\n        nonlocal res\n        left, right = dfs(node.left, True), dfs(node.right, True)\n\n        if left == -1 and right == -1:\n            if hasParent:\n                return 0\n            res += 1\n            return 2\n        if left == 0 or right == 0:\n            res += 1\n            return 2\n        if left == 2 or right == 2:\n            return 1\n        if hasParent:\n            return 0\n        res += 1\n        return 2\n\n    dfs(root, False)\n\n    return res\n\n\nroot = build([0, 0, None, 0, 0])\nprint(root)\nprint(minCameraCover(root))  # 1\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/tree_dp/#2313-minimum-flips-in-binary-tree-to-get-result","title":"2313. Minimum Flips in Binary Tree to Get Result","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/tree_dp_maximum_independent_set/","title":"Tree DP Maximum Independent Set","text":""},{"location":"content/endlesscheng/tree_dp_maximum_independent_set/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 337. House Robber III (Medium)</li> <li> 2646. Minimize the Total Price of the Trips (Hard)</li> <li> 2378. Choose Edges to Maximize Score in a Tree (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/tree_dp_maximum_independent_set/#337-house-robber-iii","title":"337. House Robber III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming, tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/tree_dp_maximum_independent_set/#2646-minimize-the-total-price-of-the-trips","title":"2646. Minimize the Total Price of the Trips","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, tree, depth first search, graph</p> </li> </ul>"},{"location":"content/endlesscheng/tree_dp_maximum_independent_set/#2378-choose-edges-to-maximize-score-in-a-tree","title":"2378. Choose Edges to Maximize Score in a Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming, tree, depth first search</p> </li> </ul>"},{"location":"content/endlesscheng/tree_dp_minimum_dominating_set/","title":"Tree DP Minimum Dominating Set","text":""},{"location":"content/endlesscheng/tree_dp_minimum_dominating_set/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 968. Binary Tree Cameras (Hard)</li> </ul>"},{"location":"content/endlesscheng/tree_dp_minimum_dominating_set/#968-binary-tree-cameras","title":"968. Binary Tree Cameras","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, tree, depth first search, binary tree 968. Binary Tree Cameras - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef minCameraCover(root: Optional[TreeNode]) -&gt; int:\n    res = 0\n\n    def dfs(node, hasParent):\n        if not node:\n            return -1\n\n        nonlocal res\n        left, right = dfs(node.left, True), dfs(node.right, True)\n\n        if left == -1 and right == -1:\n            if hasParent:\n                return 0\n            res += 1\n            return 2\n        if left == 0 or right == 0:\n            res += 1\n            return 2\n        if left == 2 or right == 2:\n            return 1\n        if hasParent:\n            return 0\n        res += 1\n        return 2\n\n    dfs(root, False)\n\n    return res\n\n\nroot = build([0, 0, None, 0, 0])\nprint(root)\nprint(minCameraCover(root))  # 1\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/tree_dp_other/","title":"Tree DP Other","text":""},{"location":"content/endlesscheng/tree_dp_other/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2925. Maximum Score After Applying Operations on a Tree (Medium)</li> <li> 3068. Find the Maximum Sum of Node Values (Hard)</li> <li> 2920. Maximum Points After Collecting Coins From All Nodes (Hard)</li> <li> 1916. Count Ways to Build Rooms in an Ant Colony (Hard)</li> <li> 3367. Maximize Sum of Weights after Edge Removals (Hard)</li> <li> 2313. Minimum Flips in Binary Tree to Get Result (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/tree_dp_other/#2925-maximum-score-after-applying-operations-on-a-tree","title":"2925. Maximum Score After Applying Operations on a Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming, tree, depth first search</p> </li> </ul>"},{"location":"content/endlesscheng/tree_dp_other/#3068-find-the-maximum-sum-of-node-values","title":"3068. Find the Maximum Sum of Node Values","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, greedy, bit manipulation, tree, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/tree_dp_other/#2920-maximum-points-after-collecting-coins-from-all-nodes","title":"2920. Maximum Points After Collecting Coins From All Nodes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, bit manipulation, tree, depth first search, memoization</p> </li> </ul>"},{"location":"content/endlesscheng/tree_dp_other/#1916-count-ways-to-build-rooms-in-an-ant-colony","title":"1916. Count Ways to Build Rooms in an Ant Colony","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, dynamic programming, tree, graph, topological sort, combinatorics</p> </li> </ul>"},{"location":"content/endlesscheng/tree_dp_other/#3367-maximize-sum-of-weights-after-edge-removals","title":"3367. Maximize Sum of Weights after Edge Removals","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, tree, depth first search</p> </li> </ul>"},{"location":"content/endlesscheng/tree_dp_other/#2313-minimum-flips-in-binary-tree-to-get-result","title":"2313. Minimum Flips in Binary Tree to Get Result","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/tree_dp_rerooting_dp/","title":"Tree DP Rerooting DP","text":""},{"location":"content/endlesscheng/tree_dp_rerooting_dp/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 834. Sum of Distances in Tree (Hard)</li> <li> 2581. Count Number of Possible Root Nodes (Hard)</li> <li> 2858. Minimum Edge Reversals So Every Node Is Reachable (Hard)</li> <li> 310. Minimum Height Trees (Medium)</li> <li> 3241. Time Taken to Mark All Nodes (Hard)</li> </ul>"},{"location":"content/endlesscheng/tree_dp_rerooting_dp/#834-sum-of-distances-in-tree","title":"834. Sum of Distances in Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, tree, depth first search, graph</p> </li> </ul>"},{"location":"content/endlesscheng/tree_dp_rerooting_dp/#2581-count-number-of-possible-root-nodes","title":"2581. Count Number of Possible Root Nodes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, dynamic programming, tree, depth first search</p> </li> </ul>"},{"location":"content/endlesscheng/tree_dp_rerooting_dp/#2858-minimum-edge-reversals-so-every-node-is-reachable","title":"2858. Minimum Edge Reversals So Every Node Is Reachable","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, depth first search, breadth first search, graph</p> </li> </ul>"},{"location":"content/endlesscheng/tree_dp_rerooting_dp/#310-minimum-height-trees","title":"310. Minimum Height Trees","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort 310. Minimum Height Trees - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\ndef findMinHeightTrees(n: int, edges: List[List[int]]) -&gt; List[int]:\n    if n == 1:\n        return [0]\n\n    graph = {i: set() for i in range(n)}\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    q = deque([i for i in range(n) if len(graph[i]) == 1])\n    remaining = n\n\n    while remaining &gt; 2:\n        size = len(q)\n        remaining -= size\n\n        for _ in range(size):\n            cur = q.popleft()\n            nei = graph[cur].pop()\n            graph[nei].remove(cur)\n\n            if len(graph[nei]) == 1:\n                q.append(nei)\n\n    return list(q)\n\n\nn = 6\nedges = [[3, 0], [3, 1], [3, 2], [3, 4], [5, 4]]\nprint(findMinHeightTrees(n, edges))  # [3, 4]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/tree_dp_rerooting_dp/#3241-time-taken-to-mark-all-nodes","title":"3241. Time Taken to Mark All Nodes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, tree, depth first search, graph</p> </li> </ul>"},{"location":"content/endlesscheng/tree_dp_tree_diameter/","title":"Tree DP Tree Diameter","text":""},{"location":"content/endlesscheng/tree_dp_tree_diameter/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 543. Diameter of Binary Tree (Easy)</li> <li> 687. Longest Univalue Path (Medium)</li> <li> 124. Binary Tree Maximum Path Sum (Hard)</li> <li> 2385. Amount of Time for Binary Tree to Be Infected (Medium)</li> <li> 2246. Longest Path With Different Adjacent Characters (Hard)</li> <li> 3203. Find Minimum Diameter After Merging Two Trees (Hard)</li> <li> 1617. Count Subtrees With Max Distance Between Cities (Hard)</li> <li> 2538. Difference Between Maximum and Minimum Price Sum (Hard)</li> <li> 1522. Diameter of N-Ary Tree (Medium) \ud83d\udc51</li> <li> 1245. Tree Diameter (Medium) \ud83d\udc51</li> <li> 549. Binary Tree Longest Consecutive Sequence II (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/tree_dp_tree_diameter/#543-diameter-of-binary-tree","title":"543. Diameter of Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, binary tree 543. Diameter of Binary Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Tree DFS\nclass Solution:\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -&gt; int:\n        self.diameter = 0\n\n        def dfs(node):\n            if not node:\n                return 0\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n            self.diameter = max(self.diameter, left + right)\n\n            return 1 + max(left, right)\n\n        dfs(root)\n\n        return self.diameter\n\n\nroot = build([1, 2, 3, 4, 5])\nprint(root)\n#     __1\n#    /   \\\n#   2     3\n#  / \\\n# 4   5\nobj = Solution()\nprint(obj.diameterOfBinaryTree(root))  # 3\n</code></pre></p> </li> </ul> 543. Diameter of Binary Tree - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nint diameterOfBinaryTree(TreeNode* root) {\n    int diameter = 0;\n\n    auto dfs = [&amp;](auto&amp;&amp; self, TreeNode* node) -&gt; int {\n        if (!node) return 0;\n        int left = self(self, node-&gt;left);\n        int right = self(self, node-&gt;right);\n\n        diameter = max(diameter, left + right);\n\n        return 1 + max(left, right);\n    };\n\n    dfs(dfs, root);\n    return diameter;\n}\n\nint main() {\n    // [1, 2, 3, 4, 5]\n    TreeNode* root = new TreeNode(1);\n    root-&gt;left = new TreeNode(2);\n    root-&gt;right = new TreeNode(3);\n    root-&gt;left-&gt;left = new TreeNode(4);\n    root-&gt;left-&gt;right = new TreeNode(5);\n    cout &lt;&lt; diameterOfBinaryTree(root) &lt;&lt; endl;  // 3\n\n    return 0;\n}\n</code></pre>"},{"location":"content/endlesscheng/tree_dp_tree_diameter/#687-longest-univalue-path","title":"687. Longest Univalue Path","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/tree_dp_tree_diameter/#124-binary-tree-maximum-path-sum","title":"124. Binary Tree Maximum Path Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, tree, depth first search, binary tree 124. Binary Tree Maximum Path Sum - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef maxPathSum(root: Optional[TreeNode]) -&gt; int:\n    res = float(\"-inf\")\n\n    def dfs(node):\n        if not node:\n            return 0\n\n        leftMax = max(dfs(node.left), 0)\n        rightMax = max(dfs(node.right), 0)\n\n        cur = node.val + leftMax + rightMax\n        nonlocal res\n        res = max(res, cur)\n\n        return node.val + max(leftMax, rightMax)\n\n    dfs(root)\n\n    return res\n\n\nroot = build([-10, 9, 20, None, None, 15, 7])\nprint(root)\n#   -10___\n#  /      \\\n# 9       _20\n#        /   \\\n#       15    7\nprint(maxPathSum(root))  # 42\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/tree_dp_tree_diameter/#2385-amount-of-time-for-binary-tree-to-be-infected","title":"2385. Amount of Time for Binary Tree to Be Infected","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, tree, depth first search, breadth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/tree_dp_tree_diameter/#2246-longest-path-with-different-adjacent-characters","title":"2246. Longest Path With Different Adjacent Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, tree, depth first search, graph, topological sort</p> </li> </ul>"},{"location":"content/endlesscheng/tree_dp_tree_diameter/#3203-find-minimum-diameter-after-merging-two-trees","title":"3203. Find Minimum Diameter After Merging Two Trees","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, graph</p> </li> </ul>"},{"location":"content/endlesscheng/tree_dp_tree_diameter/#1617-count-subtrees-with-max-distance-between-cities","title":"1617. Count Subtrees With Max Distance Between Cities","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, bit manipulation, tree, enumeration, bitmask</p> </li> </ul>"},{"location":"content/endlesscheng/tree_dp_tree_diameter/#2538-difference-between-maximum-and-minimum-price-sum","title":"2538. Difference Between Maximum and Minimum Price Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, tree, depth first search</p> </li> </ul>"},{"location":"content/endlesscheng/tree_dp_tree_diameter/#1522-diameter-of-n-ary-tree","title":"1522. Diameter of N-Ary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search 1522. Diameter of N-Ary Tree - Python Solution<pre><code>from typing import List, Optional\n\n\nclass Node:\n    def __init__(\n        self,\n        val: Optional[int] = None,\n        children: Optional[List[\"Node\"]] = None,\n    ):\n        self.val = val\n        self.children = children if children is not None else []\n\n\ndef diameter(root: \"Node\") -&gt; int:\n\n    def dfs(node):\n        if not node.children:\n            return 1, 1\n        mx0, mx1 = 0, 0\n        mxf = 0\n        for child in node.children:\n            hl, fl = dfs(child)\n            mxf = max(mxf, fl)\n            if hl &gt; mx1:\n                if hl &lt; mx0:\n                    mx1 = hl\n                else:\n                    mx0, mx1 = hl, mx0\n        return mx0 + 1, max(mxf, mx0 + mx1 + 1)\n\n    return dfs(root)[1] - 1\n\n\nroot = [1, None, 2, None, 3, 4, None, 5, None, 6]\nroot = Node(1)\nroot.children = [Node(2)]\nroot.children[0].children = [Node(3), Node(4)]\nroot.children[0].children[0].children = [Node(5)]\nroot.children[0].children[1].children = [Node(6)]\nprint(diameter(root))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/tree_dp_tree_diameter/#1245-tree-diameter","title":"1245. Tree Diameter","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, graph, topological sort 1245. Tree Diameter - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# Tree Diameter\ndef treeDiameter(edges: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = {0}\n    q = deque([0])\n    cur = 0\n\n    while q:\n        size = len(q)\n        for _ in range(size):\n            cur = q.popleft()\n            for nxt in graph[cur]:\n                if nxt not in visited:\n                    q.append(nxt)\n                    visited.add(nxt)\n\n    visited = {cur}\n    q = deque([cur])\n    res = -1\n\n    while q:\n        size = len(q)\n        for _ in range(size):\n            cur = q.popleft()\n            for nxt in graph[cur]:\n                if nxt not in visited:\n                    q.append(nxt)\n                    visited.add(nxt)\n        res += 1\n\n    return res\n\n\nedges = [[0, 1], [1, 2], [2, 3], [1, 4], [4, 5]]\nassert treeDiameter(edges) == 4\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/tree_dp_tree_diameter/#549-binary-tree-longest-consecutive-sequence-ii","title":"549. Binary Tree Longest Consecutive Sequence II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/trie_advanced/","title":"Trie Advanced","text":""},{"location":"content/endlesscheng/trie_advanced/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 676. Implement Magic Dictionary (Medium)</li> <li> 212. Word Search II (Hard)</li> <li> 3093. Longest Common Suffix Queries (Hard)</li> <li> 745. Prefix and Suffix Search (Hard)</li> <li> 3045. Count Prefix and Suffix Pairs II (Hard)</li> <li> 336. Palindrome Pairs (Hard)</li> <li> 1948. Delete Duplicate Folders in System (Hard)</li> <li> 425. Word Squares (Hard) \ud83d\udc51</li> <li> 527. Word Abbreviation (Hard) \ud83d\udc51</li> <li> 588. Design In-Memory File System (Hard) \ud83d\udc51</li> <li> 616. Add Bold Tag in String (Medium) \ud83d\udc51</li> <li> 758. Bold Words in String (Medium) \ud83d\udc51</li> <li> 642. Design Search Autocomplete System (Hard) \ud83d\udc51</li> <li> 1065. Index Pairs of a String (Easy) \ud83d\udc51</li> <li> 1166. Design File System (Medium) \ud83d\udc51</li> <li> 1858. Longest Word With All Prefixes (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/trie_advanced/#676-implement-magic-dictionary","title":"676. Implement Magic Dictionary","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, depth first search, design, trie</p> </li> </ul>"},{"location":"content/endlesscheng/trie_advanced/#212-word-search-ii","title":"212. Word Search II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, backtracking, trie, matrix 212. Word Search II - Python Solution<pre><code>from typing import List\n\nfrom template import TrieNode\n\n\n# Backtracking + Trie\ndef findWords(board: List[List[str]], words: List[str]) -&gt; List[str]:\n    root = TrieNode()\n    for word in words:\n        root.addWord(word)\n\n    m, n = len(board), len(board[0])\n    result, visit = set(), set()\n\n    def dfs(r, c, node, word):\n        if (\n            r &lt; 0\n            or r &gt;= m\n            or c &lt; 0\n            or c &gt;= n\n            or (r, c) in visit\n            or board[r][c] not in node.children\n        ):\n            return None\n\n        visit.add((r, c))\n\n        node = node.children[board[r][c]]\n        word += board[r][c]\n        if node.isWord:\n            result.add(word)\n\n        dfs(r - 1, c, node, word)\n        dfs(r + 1, c, node, word)\n        dfs(r, c - 1, node, word)\n        dfs(r, c + 1, node, word)\n\n        visit.remove((r, c))\n\n    for r in range(m):\n        for c in range(n):\n            dfs(r, c, root, \"\")\n\n    return list(result)\n\n\nboard = [\n    [\"o\", \"a\", \"a\", \"n\"],\n    [\"e\", \"t\", \"a\", \"e\"],\n    [\"i\", \"h\", \"k\", \"r\"],\n    [\"i\", \"f\", \"l\", \"v\"],\n]\nwords = [\"oath\", \"pea\", \"eat\", \"rain\"]\nprint(findWords(board, words))\n# ['eat', 'oath']\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/trie_advanced/#3093-longest-common-suffix-queries","title":"3093. Longest Common Suffix Queries","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, trie</p> </li> </ul>"},{"location":"content/endlesscheng/trie_advanced/#745-prefix-and-suffix-search","title":"745. Prefix and Suffix Search","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, string, design, trie</p> </li> </ul>"},{"location":"content/endlesscheng/trie_advanced/#3045-count-prefix-and-suffix-pairs-ii","title":"3045. Count Prefix and Suffix Pairs II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, trie, rolling hash, string matching, hash function</p> </li> </ul>"},{"location":"content/endlesscheng/trie_advanced/#336-palindrome-pairs","title":"336. Palindrome Pairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, string, trie</p> </li> </ul>"},{"location":"content/endlesscheng/trie_advanced/#1948-delete-duplicate-folders-in-system","title":"1948. Delete Duplicate Folders in System","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, string, trie, hash function</p> </li> </ul>"},{"location":"content/endlesscheng/trie_advanced/#425-word-squares","title":"425. Word Squares","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, backtracking, trie</p> </li> </ul>"},{"location":"content/endlesscheng/trie_advanced/#527-word-abbreviation","title":"527. Word Abbreviation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, greedy, trie, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/trie_advanced/#588-design-in-memory-file-system","title":"588. Design In-Memory File System","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, design, trie, sorting 588. Design In-Memory File System - Python Solution<pre><code>from collections import defaultdict\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children = defaultdict(TrieNode)\n        self.content = \"\"\n\n\n# Trie\nclass FileSystem:\n\n    def __init__(self):\n        self.root = TrieNode()\n\n    def ls(self, path: str) -&gt; list:\n        cur = self.root\n\n        if path != \"/\":\n            paths = path.split(\"/\")[1:]\n            for p in paths:\n                cur = cur.children[p]\n        if cur.content:\n            return [path.split(\"/\")[-1]]\n\n        return sorted(cur.children.keys())\n\n    def mkdir(self, path: str) -&gt; None:\n        cur = self.root\n        paths = path.split(\"/\")[1:]\n        for p in paths:\n            cur = cur.children[p]\n\n    def addContentToFile(self, filePath: str, content: str) -&gt; None:\n        cur = self.root\n        paths = filePath.split(\"/\")[1:]\n        for p in paths:\n            cur = cur.children[p]\n        cur.content += content\n\n    def readContentFromFile(self, filePath: str) -&gt; str:\n        cur = self.root\n        paths = filePath.split(\"/\")[1:]\n        for p in paths:\n            cur = cur.children[p]\n        return cur.content\n\n\nobj = FileSystem()\nobj.mkdir(\"/a/b/c\")\nobj.addContentToFile(\"/a/b/c/d\", \"hello\")\nprint(obj.ls(\"/\"))  # [\"a\"]\nprint(obj.readContentFromFile(\"/a/b/c/d\"))  # \"hello\"\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/trie_advanced/#616-add-bold-tag-in-string","title":"616. Add Bold Tag in String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, trie, string matching</p> </li> </ul>"},{"location":"content/endlesscheng/trie_advanced/#758-bold-words-in-string","title":"758. Bold Words in String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, trie, string matching</p> </li> </ul>"},{"location":"content/endlesscheng/trie_advanced/#642-design-search-autocomplete-system","title":"642. Design Search Autocomplete System","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, depth first search, design, trie, sorting, heap priority queue, data stream</p> </li> </ul>"},{"location":"content/endlesscheng/trie_advanced/#1065-index-pairs-of-a-string","title":"1065. Index Pairs of a String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, string, trie, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/trie_advanced/#1166-design-file-system","title":"1166. Design File System","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, design, trie 1166. Design File System - Python Solution<pre><code>from collections import defaultdict\n\n\nclass TrieNode:\n    def __init__(self, name):\n        self.name = name\n        self.children = defaultdict(TrieNode)\n        self.value = -1\n\n\n# Trie\nclass FileSystem:\n    def __init__(self):\n        self.root = TrieNode(\"\")\n\n    def createPath(self, path: str, value: int) -&gt; bool:\n        paths = path.split(\"/\")[1:]\n        cur = self.root\n\n        for idx, path in enumerate(paths):\n            if path not in cur.children:\n                if idx == len(paths) - 1:\n                    cur.children[path] = TrieNode(path)\n                else:\n                    return False\n            cur = cur.children[path]\n\n        if cur.value != -1:\n            return False\n        cur.value = value\n        return True\n\n    def get(self, path: str) -&gt; int:\n        cur = self.root\n        paths = path.split(\"/\")[1:]\n\n        for path in paths:\n            if path not in cur.children:\n                return -1\n            cur = cur.children[path]\n\n        return cur.value\n\n\n# Your FileSystem object will be instantiated and called as such:\npath = \"/a\"\nvalue = 1\nobj = FileSystem()\nprint(obj.createPath(path, value))  # False\nprint(obj.get(path))  # 1\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/trie_advanced/#1858-longest-word-with-all-prefixes","title":"1858. Longest Word With All Prefixes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, trie</p> </li> </ul>"},{"location":"content/endlesscheng/trie_basics/","title":"Trie Basics","text":""},{"location":"content/endlesscheng/trie_basics/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 208. Implement Trie (Prefix Tree) (Medium)</li> <li> 211. Design Add and Search Words Data Structure (Medium)</li> <li> 14. Longest Common Prefix (Easy)</li> <li> 648. Replace Words (Medium)</li> <li> 677. Map Sum Pairs (Medium)</li> <li> 720. Longest Word in Dictionary (Medium)</li> <li> 1268. Search Suggestions System (Medium)</li> <li> 1233. Remove Sub-Folders from the Filesystem (Medium)</li> <li> 820. Short Encoding of Words (Medium)</li> <li> 2416. Sum of Prefix Scores of Strings (Hard)</li> <li> 2261. K Divisible Elements Subarrays (Medium)</li> <li> 1804. Implement Trie II (Prefix Tree) (Medium) \ud83d\udc51</li> <li> 2168. Unique Substrings With Equal Digit Frequency (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/trie_basics/#208-implement-trie-prefix-tree","title":"208. Implement Trie (Prefix Tree)","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, design, trie</p> </li> </ul>"},{"location":"content/endlesscheng/trie_basics/#trie","title":"Trie","text":"<ul> <li>A trie is a tree-like data structure whose nodes store the letters of an alphabet.</li> </ul> <pre><code>flowchart TD\nRoot(( ))\nRoot --- C1((\"C\"))\nRoot --- D((D))\nC1 --- A1((\"A\"))\nA1 --- T1((\"T\"))\nA1 --- R1((\"R\"))\nA1 --- N((N))\nRoot --- B1((B))\nB1 --- A2((A))\nA2 --- T2((T))\nA2 --- R2((R))</code></pre> 208. Implement Trie (Prefix Tree) - Python Solution<pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.endOfWord = None\n\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.endOfWord = True\n\n    def search(self, word: str) -&gt; bool:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return node.endOfWord\n\n    def startsWith(self, prefix: str) -&gt; bool:\n        node = self.root\n\n        for c in prefix:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return True\n\n\n# Your Trie object will be instantiated and called as such:\nobj = Trie()\nobj.insert(\"apple\")\nprint(obj.search(\"word\"))  # False\nprint(obj.startsWith(\"app\"))  # True\n</code></pre>"},{"location":"content/endlesscheng/trie_basics/#211-design-add-and-search-words-data-structure","title":"211. Design Add and Search Words Data Structure","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, depth first search, design, trie 211. Design Add and Search Words Data Structure - Python Solution<pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.word = False\n\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.word = True\n\n    def search(self, word: str) -&gt; bool:\n\n        def dfs(j, root):\n            node = root\n\n            for i in range(j, len(word)):\n                c = word[i]\n\n                if c == \".\":\n                    for child in node.children.values():\n                        if dfs(i + 1, child):\n                            return True\n                    return False\n                else:\n                    if c not in node.children:\n                        return False\n                    node = node.children[c]\n            return node.word\n\n        return dfs(0, self.root)\n\n\n# Your WordDictionary object will be instantiated and called as such:\nobj = WordDictionary()\nobj.addWord(\"word\")\nprint(obj.search(\"word\"))\nprint(obj.search(\"w.rd\"))\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/trie_basics/#14-longest-common-prefix","title":"14. Longest Common Prefix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, trie 14. Longest Common Prefix - Python Solution<pre><code>from typing import List\n\n\n# Horizontal Scanning\ndef longestCommonPrefixHorizontal(strs: List[str]) -&gt; str:\n    if not strs:\n        return \"\"\n\n    prefix = strs[0]\n    for i in range(1, len(strs)):\n        while not strs[i].startswith(prefix):\n            prefix = prefix[:-1]\n            if not prefix:\n                return \"\"\n\n    return prefix\n\n\n# Vertical Scanning\ndef longestCommonPrefixVertical(strs: List[str]) -&gt; str:\n    if not strs:\n        return \"\"\n\n    for i in range(len(strs[0])):\n        char = strs[0][i]\n        for j in range(1, len(strs)):\n            if i &gt;= len(strs[j]) or strs[j][i] != char:\n                return strs[0][:i]\n\n    return strs[0]\n\n\n# Divide and Conquer\ndef longestCommonPrefixDivideConquer(strs: List[str]) -&gt; str:\n    if not strs:\n        return \"\"\n\n    def merge(left, right):\n        n = min(len(left), len(right))\n        for i in range(n):\n            if left[i] != right[i]:\n                return left[:i]\n        return left[:n]\n\n    def helper(strs, start, end):\n        if start == end:\n            return strs[start]\n        mid = start + (end - start) // 2\n        left = helper(strs, start, mid)\n        right = helper(strs, mid + 1, end)\n        return merge(left, right)\n\n    return helper(strs, 0, len(strs) - 1)\n\n\n# Binary Search\ndef longestCommonPrefixBinarySearch(strs: List[str]) -&gt; str:\n    if not strs:\n        return \"\"\n\n    def isCommonPrefix(strs, length):\n        prefix = strs[0][:length]\n        return all(s.startswith(prefix) for s in strs)\n\n    minLen = min(len(s) for s in strs)\n    low, high = 0, minLen\n    while low &lt; high:\n        mid = low + (high - low) // 2\n        if isCommonPrefix(strs, mid + 1):\n            low = mid + 1\n        else:\n            high = mid\n\n    return strs[0][:low]\n\n\nstrs = [\"flower\", \"flow\", \"flight\"]\nprint(longestCommonPrefixHorizontal(strs))  # \"fl\"\nprint(longestCommonPrefixVertical(strs))  # \"fl\"\nprint(longestCommonPrefixDivideConquer(strs))  # \"fl\"\nprint(longestCommonPrefixBinarySearch(strs))  # \"fl\"\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/trie_basics/#648-replace-words","title":"648. Replace Words","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, trie</p> </li> </ul>"},{"location":"content/endlesscheng/trie_basics/#677-map-sum-pairs","title":"677. Map Sum Pairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, design, trie</p> </li> </ul>"},{"location":"content/endlesscheng/trie_basics/#720-longest-word-in-dictionary","title":"720. Longest Word in Dictionary","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, trie, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/trie_basics/#1268-search-suggestions-system","title":"1268. Search Suggestions System","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, binary search, trie, sorting, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/trie_basics/#1233-remove-sub-folders-from-the-filesystem","title":"1233. Remove Sub-Folders from the Filesystem","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, depth first search, trie</p> </li> </ul>"},{"location":"content/endlesscheng/trie_basics/#820-short-encoding-of-words","title":"820. Short Encoding of Words","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, trie</p> </li> </ul>"},{"location":"content/endlesscheng/trie_basics/#2416-sum-of-prefix-scores-of-strings","title":"2416. Sum of Prefix Scores of Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, trie, counting</p> </li> </ul>"},{"location":"content/endlesscheng/trie_basics/#2261-k-divisible-elements-subarrays","title":"2261. K Divisible Elements Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, trie, rolling hash, hash function, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/trie_basics/#1804-implement-trie-ii-prefix-tree","title":"1804. Implement Trie II (Prefix Tree)","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, design, trie</p> </li> </ul>"},{"location":"content/endlesscheng/trie_basics/#2168-unique-substrings-with-equal-digit-frequency","title":"2168. Unique Substrings With Equal Digit Frequency","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, rolling hash, counting, hash function</p> </li> </ul>"},{"location":"content/endlesscheng/trie_optimized_dp/","title":"Trie Optimized DP","text":""},{"location":"content/endlesscheng/trie_optimized_dp/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 139. Word Break (Medium)</li> <li> 140. Word Break II (Hard)</li> <li> 472. Concatenated Words (Hard)</li> <li> 2977. Minimum Cost to Convert String II (Hard)</li> </ul>"},{"location":"content/endlesscheng/trie_optimized_dp/#139-word-break","title":"139. Word Break","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, dynamic programming, trie, memoization 139. Word Break - Python Solution<pre><code>from typing import List\n\n\n# DP (Unbounded Knapsack)\ndef wordBreak(s: str, wordDict: List[str]) -&gt; bool:\n    n = len(s)\n    dp = [False for _ in range(n + 1)]\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for word in wordDict:\n            m = len(word)\n            if s[i - m : i] == word and dp[i - m]:\n                dp[i] = True\n    return dp[-1]\n\n\ns = \"leetcode\"\nwordDict = [\"leet\", \"code\"]\nprint(wordBreak(s, wordDict))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/trie_optimized_dp/#140-word-break-ii","title":"140. Word Break II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, string, dynamic programming, backtracking, trie, memoization</p> </li> </ul>"},{"location":"content/endlesscheng/trie_optimized_dp/#472-concatenated-words","title":"472. Concatenated Words","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, dynamic programming, depth first search, trie</p> </li> </ul>"},{"location":"content/endlesscheng/trie_optimized_dp/#2977-minimum-cost-to-convert-string-ii","title":"2977. Minimum Cost to Convert String II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, dynamic programming, graph, trie, shortest path</p> </li> </ul>"},{"location":"content/endlesscheng/two_sequences_subsequence_checking/","title":"Two Sequences Subsequence Checking","text":""},{"location":"content/endlesscheng/two_sequences_subsequence_checking/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 392. Is Subsequence (Easy)</li> <li> 524. Longest Word in Dictionary through Deleting (Medium)</li> <li> 2486. Append Characters to String to Make Subsequence (Medium)</li> <li> 2825. Make String a Subsequence Using Cyclic Increments (Medium)</li> <li> 1023. Camelcase Matching (Medium)</li> <li> 3132. Find the Integer Added to Array II (Medium)</li> <li> 522. Longest Uncommon Subsequence II (Medium)</li> <li> 1898. Maximum Number of Removable Characters (Medium)</li> <li> 2565. Subsequence With the Minimum Score (Hard)</li> <li> 3302. Find the Lexicographically Smallest Valid Sequence (Medium)</li> </ul>"},{"location":"content/endlesscheng/two_sequences_subsequence_checking/#392-is-subsequence","title":"392. Is Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string, dynamic programming 392. Is Subsequence - Python Solution<pre><code># DP - LCS\ndef isSubsequenceLCS(s: str, t: str) -&gt; bool:\n    m = len(s)\n    n = len(t)\n\n    if m &gt; n:\n        return False\n\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    length = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = dp[i][j - 1]  # only delete t string\n\n            if length &lt; dp[i][j]:\n                length = dp[i][j]\n\n    return length == m\n\n\n# Two Pointers\ndef isSubsequenceTP(s: str, t: str) -&gt; bool:\n    i, j = 0, 0\n\n    while i &lt; len(s) and j &lt; len(t):\n        if s[i] == t[j]:\n            i += 1\n        j += 1\n\n    return i == len(s)\n\n\ns = \"abc\"\nt = \"ahbgdc\"\nprint(isSubsequenceLCS(s, t))  # True\nprint(isSubsequenceTP(s, t))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/two_sequences_subsequence_checking/#524-longest-word-in-dictionary-through-deleting","title":"524. Longest Word in Dictionary through Deleting","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, string, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/two_sequences_subsequence_checking/#2486-append-characters-to-string-to-make-subsequence","title":"2486. Append Characters to String to Make Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/two_sequences_subsequence_checking/#2825-make-string-a-subsequence-using-cyclic-increments","title":"2825. Make String a Subsequence Using Cyclic Increments","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string</p> </li> </ul>"},{"location":"content/endlesscheng/two_sequences_subsequence_checking/#1023-camelcase-matching","title":"1023. Camelcase Matching","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, string, trie, string matching</p> </li> </ul>"},{"location":"content/endlesscheng/two_sequences_subsequence_checking/#3132-find-the-integer-added-to-array-ii","title":"3132. Find the Integer Added to Array II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, sorting, enumeration</p> </li> </ul>"},{"location":"content/endlesscheng/two_sequences_subsequence_checking/#522-longest-uncommon-subsequence-ii","title":"522. Longest Uncommon Subsequence II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, two pointers, string, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/two_sequences_subsequence_checking/#1898-maximum-number-of-removable-characters","title":"1898. Maximum Number of Removable Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, string, binary search</p> </li> </ul>"},{"location":"content/endlesscheng/two_sequences_subsequence_checking/#2565-subsequence-with-the-minimum-score","title":"2565. Subsequence With the Minimum Score","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: two pointers, string, binary search</p> </li> </ul>"},{"location":"content/endlesscheng/two_sequences_subsequence_checking/#3302-find-the-lexicographically-smallest-valid-sequence","title":"3302. Find the Lexicographically Smallest Valid Sequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string, dynamic programming, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/two_sequences_two_pointers/","title":"Two Sequences Two Pointers","text":""},{"location":"content/endlesscheng/two_sequences_two_pointers/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2540. Minimum Common Value (Easy)</li> <li> 88. Merge Sorted Array (Easy)</li> <li> 2570. Merge Two 2D Arrays by Summing Values (Easy)</li> <li> 1855. Maximum Distance Between a Pair of Values (Medium)</li> <li> 1385. Find the Distance Value Between Two Arrays (Easy)</li> <li> 925. Long Pressed Name (Easy)</li> <li> 809. Expressive Words (Medium)</li> <li> 2337. Move Pieces to Obtain a String (Medium)</li> <li> 777. Swap Adjacent in LR String (Medium)</li> <li> 844. Backspace String Compare (Easy)</li> <li> 986. Interval List Intersections (Medium)</li> <li> 1537. Get the Maximum Score (Hard)</li> <li> 244. Shortest Word Distance II (Medium) \ud83d\udc51</li> <li> 2838. Maximum Coins Heroes Can Collect (Medium) \ud83d\udc51</li> <li> 1229. Meeting Scheduler (Medium) \ud83d\udc51</li> <li> 1570. Dot Product of Two Sparse Vectors (Medium) \ud83d\udc51</li> <li> 1868. Product of Two Run-Length Encoded Arrays (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/two_sequences_two_pointers/#2540-minimum-common-value","title":"2540. Minimum Common Value","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, two pointers, binary search</p> </li> </ul>"},{"location":"content/endlesscheng/two_sequences_two_pointers/#88-merge-sorted-array","title":"88. Merge Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers, sorting 88. Merge Sorted Array - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef merge(nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None:\n    \"\"\"Merges two sorted arrays in-place.\"\"\"\n    p1, p2, t = m - 1, n - 1, m + n - 1\n\n    while p1 &gt;= 0 or p2 &gt;= 0:\n        if p1 == -1:\n            nums1[t] = nums2[p2]\n            p2 -= 1\n        elif p2 == -1:\n            nums1[t] = nums1[p1]\n            p1 -= 1\n        elif nums1[p1] &gt; nums2[p2]:\n            nums1[t] = nums1[p1]\n            p1 -= 1\n        else:\n            nums1[t] = nums2[p2]\n            p2 -= 1\n\n        t -= 1\n\n\nnums1 = [1, 2, 3, 0, 0, 0]\nm = 3\nnums2 = [2, 5, 6]\nn = 3\nmerge(nums1, m, nums2, n)\nprint(nums1)  # [1, 2, 2, 3, 5, 6]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/two_sequences_two_pointers/#2570-merge-two-2d-arrays-by-summing-values","title":"2570. Merge Two 2D Arrays by Summing Values","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, two pointers</p> </li> </ul>"},{"location":"content/endlesscheng/two_sequences_two_pointers/#1855-maximum-distance-between-a-pair-of-values","title":"1855. Maximum Distance Between a Pair of Values","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search</p> </li> </ul>"},{"location":"content/endlesscheng/two_sequences_two_pointers/#1385-find-the-distance-value-between-two-arrays","title":"1385. Find the Distance Value Between Two Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers, binary search, sorting 1385. Find the Distance Value Between Two Arrays - Python Solution<pre><code>from bisect import bisect_left\nfrom typing import List\n\n\n# Binary Search\ndef findTheDistanceValue(arr1: List[int], arr2: List[int], d: int) -&gt; int:\n    arr2.sort()\n    res = 0\n\n    for x in arr1:\n        i = bisect_left(arr2, x - d)\n        if i == len(arr2) or arr2[i] &gt; x + d:\n            res += 1\n\n    return res\n\n\narr1 = [4, 5, 8]\narr2 = [10, 9, 1, 8]\nd = 2\nprint(findTheDistanceValue(arr1, arr2, d))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/two_sequences_two_pointers/#925-long-pressed-name","title":"925. Long Pressed Name","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string</p> </li> </ul>"},{"location":"content/endlesscheng/two_sequences_two_pointers/#809-expressive-words","title":"809. Expressive Words","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, string</p> </li> </ul>"},{"location":"content/endlesscheng/two_sequences_two_pointers/#2337-move-pieces-to-obtain-a-string","title":"2337. Move Pieces to Obtain a String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string</p> </li> </ul>"},{"location":"content/endlesscheng/two_sequences_two_pointers/#777-swap-adjacent-in-lr-string","title":"777. Swap Adjacent in LR String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string</p> </li> </ul>"},{"location":"content/endlesscheng/two_sequences_two_pointers/#844-backspace-string-compare","title":"844. Backspace String Compare","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string, stack, simulation 844. Backspace String Compare - Python Solution<pre><code>def backspaceCompare(s: str, t: str) -&gt; bool:\n\n    def build(text):\n        stack = []\n\n        for char in text:\n            if char != \"#\":\n                stack.append(char)\n            elif stack:\n                stack.pop()\n\n        return \"\".join(stack)\n\n    return build(s) == build(t)\n\n\nprint(backspaceCompare(\"ab#c\", \"ad#c\"))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/two_sequences_two_pointers/#986-interval-list-intersections","title":"986. Interval List Intersections","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, line sweep</p> </li> </ul>"},{"location":"content/endlesscheng/two_sequences_two_pointers/#1537-get-the-maximum-score","title":"1537. Get the Maximum Score","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, dynamic programming, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/two_sequences_two_pointers/#244-shortest-word-distance-ii","title":"244. Shortest Word Distance II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, two pointers, string, design</p> </li> </ul>"},{"location":"content/endlesscheng/two_sequences_two_pointers/#2838-maximum-coins-heroes-can-collect","title":"2838. Maximum Coins Heroes Can Collect","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, sorting, prefix sum</p> </li> </ul>"},{"location":"content/endlesscheng/two_sequences_two_pointers/#1229-meeting-scheduler","title":"1229. Meeting Scheduler","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/two_sequences_two_pointers/#1570-dot-product-of-two-sparse-vectors","title":"1570. Dot Product of Two Sparse Vectors","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, two pointers, design</p> </li> </ul>"},{"location":"content/endlesscheng/two_sequences_two_pointers/#1868-product-of-two-run-length-encoded-arrays","title":"1868. Product of Two Run-Length Encoded Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers</p> </li> </ul>"},{"location":"content/endlesscheng/union_find_advanced/","title":"Union Find Advanced","text":""},{"location":"content/endlesscheng/union_find_advanced/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1202. Smallest String With Swaps (Medium)</li> <li> 1061. Lexicographically Smallest Equivalent String (Medium)</li> <li> 1722. Minimize Hamming Distance After Swap Operations (Medium)</li> <li> 765. Couples Holding Hands (Hard)</li> <li> 684. Redundant Connection (Medium)</li> <li> 685. Redundant Connection II (Hard)</li> <li> 947. Most Stones Removed with Same Row or Column (Medium)</li> <li> 839. Similar String Groups (Hard)</li> <li> 1970. Last Day Where You Can Still Cross (Hard)</li> <li> 2076. Process Restricted Friend Requests (Hard)</li> <li> 1579. Remove Max Number of Edges to Keep Graph Fully Traversable (Hard)</li> <li> 959. Regions Cut By Slashes (Medium)</li> <li> 2812. Find the Safest Path in a Grid (Medium)</li> <li> 2503. Maximum Number of Points From Grid Queries (Hard)</li> <li> 2867. Count Valid Paths in a Tree (Hard)</li> <li> 2421. Number of Good Paths (Hard)</li> <li> 2157. Groups of Strings (Hard)</li> <li> 1632. Rank Transform of a Matrix (Hard)</li> <li> 803. Bricks Falling When Hit (Hard)</li> <li> 1569. Number of Ways to Reorder Array to Get Same BST (Hard)</li> <li> 3235. Check if the Rectangle Corner Is Reachable (Hard)</li> <li> 2371. Minimize Maximum Value in a Grid (Hard) \ud83d\udc51</li> <li> 2459. Sort Array by Moving Items to Empty Space (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/union_find_advanced/#1202-smallest-string-with-swaps","title":"1202. Smallest String With Swaps","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, depth first search, breadth first search, union find, sorting 1202. Smallest String With Swaps - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef smallestStringWithSwaps(s: str, pairs: List[List[int]]) -&gt; str:\n    n = len(s)\n    par = list(range(n))\n    components = defaultdict(list)\n\n    def find(node):\n        p = par[node]\n        while par[p] != p:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 != p2:\n            par[p1] = p2\n\n    for index, j in pairs:\n        union(index, j)\n\n    for index in range(n):\n        components[find(index)].append(index)\n\n    res = list(s)\n    for indices in components.values():\n        chars = sorted([s[index] for index in indices])\n        for index, char in zip(indices, chars):\n            res[index] = char\n\n    return \"\".join(res)\n\n\ns = \"dcab\"\npairs = [[0, 3], [1, 2]]\nprint(smallestStringWithSwaps(s, pairs))  # \"bacd\"\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/union_find_advanced/#1061-lexicographically-smallest-equivalent-string","title":"1061. Lexicographically Smallest Equivalent String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, union find 1061. Lexicographically Smallest Equivalent String - Python Solution<pre><code># Union Find\ndef smallestEquivalentString(s1: str, s2: str, baseStr: str) -&gt; str:\n    parent = {chr(i): chr(i) for i in range(ord(\"a\"), ord(\"z\") + 1)}\n\n    def find(n):\n        p = parent[n]\n        while parent[p] != p:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            if p1 &lt; p2:\n                parent[p2] = p1\n            else:\n                parent[p1] = p2\n\n    for i in range(len(s1)):\n        union(s1[i], s2[i])\n\n    result = []\n    for c in baseStr:\n        result.append(find(c))\n\n    return \"\".join(result)\n\n\nif __name__ == \"__main__\":\n    s1 = \"parker\"\n    s2 = \"morris\"\n    baseStr = \"parser\"\n    assert smallestEquivalentString(s1, s2, baseStr) == \"makkek\"\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/union_find_advanced/#1722-minimize-hamming-distance-after-swap-operations","title":"1722. Minimize Hamming Distance After Swap Operations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, union find</p> </li> </ul>"},{"location":"content/endlesscheng/union_find_advanced/#765-couples-holding-hands","title":"765. Couples Holding Hands","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: greedy, depth first search, breadth first search, union find, graph</p> </li> </ul>"},{"location":"content/endlesscheng/union_find_advanced/#684-redundant-connection","title":"684. Redundant Connection","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph 684. Redundant Connection - Python Solution<pre><code>from typing import List\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(1, n + 1)}\n        self.rank = {i: 1 for i in range(1, n + 1)}\n\n    def find(self, n):\n        p = self.par[n]\n        while self.par[p] != p:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return False\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.par[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.par[p1] = p2\n        else:\n            self.par[p2] = p1\n            self.rank[p1] += 1\n\n        return True\n\n\n# Union Find\ndef findRedundantConnectionUF(edges: List[List[int]]) -&gt; List[int]:\n    n = len(edges)\n    uf = UnionFind(n)\n\n    for u, v in edges:\n        if not uf.union(u, v):\n            return (u, v)\n\n\n# DFS\ndef findRedundantConnectionDFS(edges: List[List[int]]) -&gt; List[int]:\n    graph, cycle = {}, {}\n    for a, b in edges:\n        graph.setdefault(a, []).append(b)\n        graph.setdefault(b, []).append(a)\n\n    def dfs(node, parent):\n        if node in cycle:\n            for k in list(cycle.keys()):\n                if k == node:\n                    return True\n                del cycle[k]\n\n        cycle[node] = None\n        for child in graph[node]:\n            if child != parent and dfs(child, node):\n                return True\n        del cycle[node]\n        return False\n\n    dfs(edges[0][0], -1)\n    for a, b in edges[::-1]:\n        if a in cycle and b in cycle:\n            return (a, b)\n\n\nedges = [[1, 2], [1, 3], [2, 3]]\nprint(findRedundantConnectionUF(edges))  # (2, 3)\nprint(findRedundantConnectionDFS(edges))  # (2, 3)\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/union_find_advanced/#685-redundant-connection-ii","title":"685. Redundant Connection II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph 685. Redundant Connection II - Python Solution<pre><code>from typing import List\n\n\n# Union Find\ndef findRedundantDirectedConnectionUF(edges: List[List[int]]) -&gt; List[int]:\n    n = len(edges)\n    uf = UnionFind(n + 1)\n    parent = list(range(n + 1))\n    candidates = []\n\n    for u, v in edges:\n        if parent[v] != v:\n            candidates.append([parent[v], v])\n            candidates.append([u, v])\n        else:\n            parent[v] = u\n\n    if not candidates:\n        for u, v in edges:\n            if not uf.union(u, v):\n                return [u, v]\n\n    for u, v in edges:\n        if [u, v] == candidates[1]:\n            continue\n        if not uf.union(u, v):\n            return candidates[0]\n\n    return candidates[1]\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(1, n + 1)}\n\n    def find(self, n):\n        p = self.par[n]\n        while p != self.par[p]:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n        if p1 == p2:\n            return False\n        self.par[p1] = p2\n        return True\n\n\nedges = [[1, 2], [1, 3], [2, 3]]\nprint(findRedundantDirectedConnectionUF(edges))\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/union_find_advanced/#947-most-stones-removed-with-same-row-or-column","title":"947. Most Stones Removed with Same Row or Column","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, depth first search, union find, graph</p> </li> </ul>"},{"location":"content/endlesscheng/union_find_advanced/#839-similar-string-groups","title":"839. Similar String Groups","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, string, depth first search, breadth first search, union find 839. Similar String Groups - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef numSimilarGroups(strs: List[str]) -&gt; int:\n    n = len(strs)\n    parent = list(range(n))\n    rank = [0 for _ in range(n)]\n\n    def find(n):\n        p = parent[n]\n        while parent[p] != p:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    def is_similar(s1, s2):\n        diff = 0\n        for c1, c2 in zip(s1, s2):\n            if c1 != c2:\n                diff += 1\n            if diff &gt; 2:\n                return False\n        return True\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_similar(strs[i], strs[j]):\n                union(i, j)\n\n    return sum(find(i) == i for i in range(n))\n\n\nstrs = [\"tars\", \"rats\", \"arts\", \"star\"]\nprint(numSimilarGroups(strs))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/union_find_advanced/#1970-last-day-where-you-can-still-cross","title":"1970. Last Day Where You Can Still Cross","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, depth first search, breadth first search, union find, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/union_find_advanced/#2076-process-restricted-friend-requests","title":"2076. Process Restricted Friend Requests","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: union find, graph</p> </li> </ul>"},{"location":"content/endlesscheng/union_find_advanced/#1579-remove-max-number-of-edges-to-keep-graph-fully-traversable","title":"1579. Remove Max Number of Edges to Keep Graph Fully Traversable","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: union find, graph</p> </li> <li>Return the maximum number of edges you can remove so that the graph remains fully traversable.</li> </ul> <p></p> 1579. Remove Max Number of Edges to Keep Graph Fully Traversable - Python Solution<pre><code>from typing import List\n\n\n# Kruskal\ndef maxNumEdgesToRemove(n: int, edges: List[List[int]]) -&gt; int:\n    alice, bob = UnionFind(n), UnionFind(n)\n    visited = 0\n\n    for t, u, v in edges:\n        if t == 3:\n            if alice.union(u, v) | bob.union(u, v):\n                visited += 1\n\n    for t, u, v in edges:\n        if t == 1:\n            if alice.union(u, v):\n                visited += 1\n        elif t == 2:\n            if bob.union(u, v):\n                visited += 1\n\n    if alice.components &gt; 1 or bob.components &gt; 1:\n        return -1\n\n    return len(edges) - visited\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = {i: i for i in range(1, n + 1)}\n        self.rank = {i: 0 for i in range(1, n + 1)}\n        self.components = n\n\n    def find(self, n):\n        p = self.parent[n]\n        while self.parent[p] != p:\n            self.parent[p] = self.parent[self.parent[p]]\n            p = self.parent[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return False\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.parent[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.parent[p1] = p2\n        else:\n            self.parent[p2] = p1\n            self.rank[p1] += 1\n\n        self.components -= 1\n\n        return True\n\n\nn = 4\nedges = [[3, 1, 2], [3, 2, 3], [1, 1, 3], [1, 2, 4], [1, 1, 2], [2, 3, 4]]\nprint(maxNumEdgesToRemove(n, edges))  # 2\n</code></pre>"},{"location":"content/endlesscheng/union_find_advanced/#959-regions-cut-by-slashes","title":"959. Regions Cut By Slashes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, depth first search, breadth first search, union find, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/union_find_advanced/#2812-find-the-safest-path-in-a-grid","title":"2812. Find the Safest Path in a Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, breadth first search, union find, heap priority queue, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/union_find_advanced/#2503-maximum-number-of-points-from-grid-queries","title":"2503. Maximum Number of Points From Grid Queries","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, breadth first search, union find, sorting, heap priority queue, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/union_find_advanced/#2867-count-valid-paths-in-a-tree","title":"2867. Count Valid Paths in a Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, dynamic programming, tree, depth first search, number theory</p> </li> </ul>"},{"location":"content/endlesscheng/union_find_advanced/#2421-number-of-good-paths","title":"2421. Number of Good Paths","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, tree, union find, graph, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/union_find_advanced/#2157-groups-of-strings","title":"2157. Groups of Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, bit manipulation, union find</p> </li> </ul>"},{"location":"content/endlesscheng/union_find_advanced/#1632-rank-transform-of-a-matrix","title":"1632. Rank Transform of a Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, union find, graph, topological sort, sorting, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/union_find_advanced/#803-bricks-falling-when-hit","title":"803. Bricks Falling When Hit","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, union find, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/union_find_advanced/#1569-number-of-ways-to-reorder-array-to-get-same-bst","title":"1569. Number of Ways to Reorder Array to Get Same BST","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, divide and conquer, dynamic programming, tree, union find, binary search tree, memoization, combinatorics, binary tree</p> </li> </ul>"},{"location":"content/endlesscheng/union_find_advanced/#3235-check-if-the-rectangle-corner-is-reachable","title":"3235. Check if the Rectangle Corner Is Reachable","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, depth first search, breadth first search, union find, geometry</p> </li> </ul>"},{"location":"content/endlesscheng/union_find_advanced/#2371-minimize-maximum-value-in-a-grid","title":"2371. Minimize Maximum Value in a Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, union find, graph, topological sort, sorting, matrix</p> </li> </ul>"},{"location":"content/endlesscheng/union_find_advanced/#2459-sort-array-by-moving-items-to-empty-space","title":"2459. Sort Array by Moving Items to Empty Space","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"content/endlesscheng/union_find_basics/","title":"Union Find Basics","text":""},{"location":"content/endlesscheng/union_find_basics/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 990. Satisfiability of Equality Equations (Medium)</li> <li> 721. Accounts Merge (Medium)</li> <li> 737. Sentence Similarity II (Medium) \ud83d\udc51</li> <li> 1101. The Earliest Moment When Everyone Become Friends (Medium) \ud83d\udc51</li> <li> 1258. Synonymous Sentences (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/union_find_basics/#990-satisfiability-of-equality-equations","title":"990. Satisfiability of Equality Equations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, union find, graph 990. Satisfiability of Equality Equations - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef equationsPossible(equations: List[str]) -&gt; bool:\n    parent = defaultdict(str)\n    rank = defaultdict(int)\n\n    def find(n):\n        p = parent[n]\n        while p != parent[p]:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    for equation in equations:\n        if equation[0] not in parent:\n            parent[equation[0]] = equation[0]\n            rank[equation[0]] = 1\n        if equation[3] not in parent:\n            parent[equation[3]] = equation[3]\n            rank[equation[3]] = 1\n\n    for equation in equations:\n        if equation[1] == \"=\":\n            union(equation[0], equation[3])\n\n    for equation in equations:\n        if equation[1] == \"!\":\n            if find(equation[0]) == find(equation[3]):\n                return False\n\n    return True\n\n\nequations = [\"a==b\", \"b!=a\"]\nprint(equationsPossible(equations))  # False\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/union_find_basics/#721-accounts-merge","title":"721. Accounts Merge","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, depth first search, breadth first search, union find, sorting 721. Accounts Merge - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef accountsMerge(accounts: List[List[str]]) -&gt; List[List[str]]:\n    parent = defaultdict(str)\n    rank = defaultdict(int)\n    email_to_name = defaultdict(str)\n    merged_accounts = defaultdict(list)\n\n    def find(n):\n        p = parent[n]\n        while p != parent[p]:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    for account in accounts:\n        name = account[0]\n        first_email = account[1]\n\n        for email in account[1:]:\n            if email not in parent:\n                parent[email] = email\n                rank[email] = 1\n            email_to_name[email] = name\n            union(first_email, email)\n\n    for email in parent:\n        root_email = find(email)\n        merged_accounts[root_email].append(email)\n\n    result = []\n    for root_email, emails in merged_accounts.items():\n        result.append([email_to_name[root_email]] + sorted(emails))\n\n    return result\n\n\naccounts = [\n    [\"John\", \"johnsmith@mail.com\", \"john_newyork@mail.com\"],\n    [\"John\", \"johnsmith@mail.com\", \"john00@mail.com\"],\n    [\"Mary\", \"mary@mail.com\"],\n    [\"John\", \"johnnybravo@mail.com\"],\n]\nprint(accountsMerge(accounts))\n# [['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],\n# ['Mary', 'mary@mail.com'],\n# ['John', 'johnnybravo@mail.com']]\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/union_find_basics/#737-sentence-similarity-ii","title":"737. Sentence Similarity II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, depth first search, breadth first search, union find</p> </li> </ul>"},{"location":"content/endlesscheng/union_find_basics/#1101-the-earliest-moment-when-everyone-become-friends","title":"1101. The Earliest Moment When Everyone Become Friends","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, union find, sorting 1101. The Earliest Moment When Everyone Become Friends - Python Solution<pre><code>from typing import List\n\n\n# Union Find\ndef earliestAcq(logs: List[List[int]], n: int) -&gt; int:\n    logs.sort()\n    par = {i: i for i in range(n)}\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    for time, a, b in logs:\n        pa, pb = find(a), find(b)\n        if pa != pb:\n            par[pa] = pb\n            n -= 1\n        if n == 1:\n            return time\n    return -1\n\n\nlogs = [[0, 2, 0], [1, 0, 1], [3, 0, 3], [4, 1, 2], [7, 3, 1]]\nn = 4\nprint(earliestAcq(logs, n))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/union_find_basics/#1258-synonymous-sentences","title":"1258. Synonymous Sentences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, backtracking, union find</p> </li> </ul>"},{"location":"content/endlesscheng/union_find_interval/","title":"Union Find Interval","text":""},{"location":"content/endlesscheng/union_find_interval/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1851. Minimum Interval to Include Each Query (Hard)</li> <li> 3244. Shortest Distance After Road Addition Queries II (Hard)</li> <li> 2158. Amount of New Area Painted Each Day (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/union_find_interval/#1851-minimum-interval-to-include-each-query","title":"1851. Minimum Interval to Include Each Query","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, line sweep, sorting, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/union_find_interval/#3244-shortest-distance-after-road-addition-queries-ii","title":"3244. Shortest Distance After Road Addition Queries II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, graph, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/union_find_interval/#2158-amount-of-new-area-painted-each-day","title":"2158. Amount of New Area Painted Each Day","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, segment tree, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/union_find_on_arrays/","title":"Union Find on Arrays","text":""},{"location":"content/endlesscheng/union_find_on_arrays/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1562. Find Latest Group of Size M (Medium)</li> <li> 1488. Avoid Flood in The City (Medium)</li> <li> 2382. Maximum Segment Sum After Removals (Hard)</li> <li> 2334. Subarray With Elements Greater Than Varying Threshold (Hard)</li> </ul>"},{"location":"content/endlesscheng/union_find_on_arrays/#1562-find-latest-group-of-size-m","title":"1562. Find Latest Group of Size M","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, binary search, simulation</p> </li> </ul>"},{"location":"content/endlesscheng/union_find_on_arrays/#1488-avoid-flood-in-the-city","title":"1488. Avoid Flood in The City","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, binary search, greedy, heap priority queue</p> </li> </ul>"},{"location":"content/endlesscheng/union_find_on_arrays/#2382-maximum-segment-sum-after-removals","title":"2382. Maximum Segment Sum After Removals","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, union find, prefix sum, ordered set</p> </li> </ul>"},{"location":"content/endlesscheng/union_find_on_arrays/#2334-subarray-with-elements-greater-than-varying-threshold","title":"2334. Subarray With Elements Greater Than Varying Threshold","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, stack, union find, monotonic stack</p> </li> </ul>"},{"location":"content/endlesscheng/valid_parentheses_strings/","title":"Valid Parentheses Strings","text":""},{"location":"content/endlesscheng/valid_parentheses_strings/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 20. Valid Parentheses (Easy)</li> <li> 921. Minimum Add to Make Parentheses Valid (Medium)</li> <li> 1021. Remove Outermost Parentheses (Easy)</li> <li> 1614. Maximum Nesting Depth of the Parentheses (Easy)</li> <li> 1190. Reverse Substrings Between Each Pair of Parentheses (Medium)</li> <li> 856. Score of Parentheses (Medium)</li> <li> 1249. Minimum Remove to Make Valid Parentheses (Medium)</li> <li> 1963. Minimum Number of Swaps to Make the String Balanced (Medium)</li> <li> 678. Valid Parenthesis String (Medium)</li> <li> 1111. Maximum Nesting Depth of Two Valid Parentheses Strings (Medium)</li> <li> 1541. Minimum Insertions to Balance a Parentheses String (Medium)</li> <li> 2116. Check if a Parentheses String Can Be Valid (Medium)</li> <li> 32. Longest Valid Parentheses (Hard)</li> </ul>"},{"location":"content/endlesscheng/valid_parentheses_strings/#20-valid-parentheses","title":"20. Valid Parentheses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, stack</p> </li> <li>Determine if the input string is valid.</li> <li>Steps for the string <code>()[]{}</code>:</li> </ul> char action stack <code>(</code> push \"(\" <code>)</code> pop \"\" <code>[</code> push \"[\" <code>]</code> pop \"\" <code>{</code> push \"{\" <code>}</code> pop \"\" 20. Valid Parentheses - Python Solution<pre><code># Stack\ndef isValid(s: str) -&gt; bool:\n    hashmap = {\n        \")\": \"(\",\n        \"]\": \"[\",\n        \"}\": \"{\",\n    }\n    stack = []\n\n    for ch in s:\n        if ch in hashmap:\n            if stack and stack[-1] == hashmap[ch]:\n                stack.pop()\n            else:\n                return False\n        else:\n            stack.append(ch)\n\n    return True if not stack else False\n\n\nif __name__ == \"__main__\":\n    assert isValid(\"()[]{}\")\n    assert not isValid(\"(]\")\n    assert not isValid(\"([)]\")\n    assert isValid(\"{[]}\")\n    assert isValid(\"\")\n</code></pre> 20. Valid Parentheses - C++ Solution<pre><code>#include &lt;cassert&gt;\n#include &lt;stack&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool isValid(string s) {\n        unordered_map&lt;char, char&gt; map{{')', '('}, {'}', '{'}, {']', '['}};\n        stack&lt;char&gt; stack;\n        if (s.length() % 2 == 1) return false;\n\n        for (char&amp; ch : s) {\n            if (stack.empty() || map.find(ch) == map.end()) {\n                stack.push(ch);\n            } else {\n                if (map[ch] != stack.top()) {\n                    return false;\n                }\n                stack.pop();\n            }\n        }\n        return stack.empty();\n    }\n};\n\nint main() {\n    Solution s;\n    assert(s.isValid(\"()\") == true);\n    assert(s.isValid(\"()[]{}\") == true);\n    assert(s.isValid(\"(]\") == false);\n    assert(s.isValid(\"([)]\") == false);\n    assert(s.isValid(\"{[]}\") == true);\n    return 0;\n}\n</code></pre>"},{"location":"content/endlesscheng/valid_parentheses_strings/#921-minimum-add-to-make-parentheses-valid","title":"921. Minimum Add to Make Parentheses Valid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/valid_parentheses_strings/#1021-remove-outermost-parentheses","title":"1021. Remove Outermost Parentheses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, stack</p> </li> </ul>"},{"location":"content/endlesscheng/valid_parentheses_strings/#1614-maximum-nesting-depth-of-the-parentheses","title":"1614. Maximum Nesting Depth of the Parentheses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, stack</p> </li> </ul>"},{"location":"content/endlesscheng/valid_parentheses_strings/#1190-reverse-substrings-between-each-pair-of-parentheses","title":"1190. Reverse Substrings Between Each Pair of Parentheses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack</p> </li> </ul>"},{"location":"content/endlesscheng/valid_parentheses_strings/#856-score-of-parentheses","title":"856. Score of Parentheses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack</p> </li> </ul>"},{"location":"content/endlesscheng/valid_parentheses_strings/#1249-minimum-remove-to-make-valid-parentheses","title":"1249. Minimum Remove to Make Valid Parentheses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack</p> </li> </ul>"},{"location":"content/endlesscheng/valid_parentheses_strings/#1963-minimum-number-of-swaps-to-make-the-string-balanced","title":"1963. Minimum Number of Swaps to Make the String Balanced","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string, stack, greedy 1963. Minimum Number of Swaps to Make the String Balanced - Python Solution<pre><code>def minSwaps(s: str) -&gt; int:\n    res, balance = 0, 0\n\n    for char in s:\n        if char == \"[\":\n            balance += 1\n        elif balance &gt; 0:\n            balance -= 1\n        else:\n            res += 1\n            balance += 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(minSwaps(\"][][\"))  # 1\n    print(minSwaps(\"]]][[[\"))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/valid_parentheses_strings/#678-valid-parenthesis-string","title":"678. Valid Parenthesis String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming, stack, greedy 678. Valid Parenthesis String - Python Solution<pre><code># Greedy\ndef checkValidString(s: str) -&gt; bool:\n    min_open, max_open = 0, 0\n\n    for char in s:\n        if char == \"(\":\n            min_open += 1\n            max_open += 1\n        elif char == \")\":\n            min_open = max(min_open - 1, 0)\n            max_open -= 1\n        elif char == \"*\":\n            min_open = max(min_open - 1, 0)\n            max_open += 1\n\n        if max_open &lt; 0:\n            return False\n\n    return min_open == 0\n\n\ns = \"(*))\"\nprint(checkValidString(s))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/valid_parentheses_strings/#1111-maximum-nesting-depth-of-two-valid-parentheses-strings","title":"1111. Maximum Nesting Depth of Two Valid Parentheses Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack</p> </li> </ul>"},{"location":"content/endlesscheng/valid_parentheses_strings/#1541-minimum-insertions-to-balance-a-parentheses-string","title":"1541. Minimum Insertions to Balance a Parentheses String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack, greedy</p> </li> </ul>"},{"location":"content/endlesscheng/valid_parentheses_strings/#2116-check-if-a-parentheses-string-can-be-valid","title":"2116. Check if a Parentheses String Can Be Valid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack, greedy 2116. Check if a Parentheses String Can Be Valid - Python Solution<pre><code># Valid Parentheses Strings\ndef canBeValid(s: str, locked: str) -&gt; bool:\n    if len(s) % 2:\n        return False\n\n    mx, mn = 0, 0\n    for ch, lock in zip(s, locked):\n        if lock == \"1\":\n            d = 1 if ch == \"(\" else -1\n            mx += d\n            if mx &lt; 0:\n                return False\n            mn += d\n        else:\n            mx += 1\n            mn -= 1\n\n        if mn &lt; 0:\n            mn = 1\n\n    return mn == 0\n\n\nif __name__ == \"__main__\":\n    s = \"))()))\"\n    locked = \"010100\"\n    print(canBeValid(s, locked))  # True\n</code></pre></p> </li> </ul> 2116. Check if a Parentheses String Can Be Valid - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\n// Valid Parentheses Strings\nbool canBeValid(string s, string locked) {\n    if (s.length() % 2 != 0) {\n        return false;\n    }\n\n    int mx = 0, mn = 0;\n    for (size_t i = 0; i &lt; s.length(); ++i) {\n        char ch = s[i];\n        char lock = locked[i];\n\n        if (lock == '1') {\n            int d = (ch == '(') ? 1 : -1;\n            mx += d;\n            if (mx &lt; 0) {\n                return false;\n            }\n            mn += d;\n        } else {\n            mx += 1;\n            mn -= 1;\n        }\n\n        if (mn &lt; 0) {\n            mn = 1;\n        }\n    }\n\n    return mn == 0;\n}\n\nint main() {\n    string s = \"))()))\";\n    string locked = \"010100\";\n    cout &lt;&lt; (canBeValid(s, locked) ? \"true\" : \"false\") &lt;&lt; endl;  // true\n    return 0;\n}\n</code></pre>"},{"location":"content/endlesscheng/valid_parentheses_strings/#32-longest-valid-parentheses","title":"32. Longest Valid Parentheses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming, stack 32. Longest Valid Parentheses - Python Solution<pre><code># Stack\ndef longestValidParentheses(s: str) -&gt; int:\n    stack = [-1]\n    res = 0\n\n    for i, ch in enumerate(s):\n        if ch == \"(\":\n            stack.append(i)\n        elif ch == \")\":\n            stack.pop()\n            if stack:\n                res = max(res, i - stack[-1])\n            else:\n                stack.append(i)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(longestValidParentheses(\"(()\"))  # 2\n    print(longestValidParentheses(\")()())\"))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/endlesscheng/xor_trie/","title":"XOR Trie","text":""},{"location":"content/endlesscheng/xor_trie/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 421. Maximum XOR of Two Numbers in an Array (Medium)</li> <li> 2935. Maximum Strong Pair XOR II (Hard)</li> <li> 1707. Maximum XOR With an Element From Array (Hard)</li> <li> 1803. Count Pairs With XOR in a Range (Hard)</li> <li> 1938. Maximum Genetic Difference Query (Hard)</li> <li> 2479. Maximum XOR of Two Non-Overlapping Subtrees (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/endlesscheng/xor_trie/#421-maximum-xor-of-two-numbers-in-an-array","title":"421. Maximum XOR of Two Numbers in an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, bit manipulation, trie</p> </li> </ul>"},{"location":"content/endlesscheng/xor_trie/#2935-maximum-strong-pair-xor-ii","title":"2935. Maximum Strong Pair XOR II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, bit manipulation, trie, sliding window</p> </li> </ul>"},{"location":"content/endlesscheng/xor_trie/#1707-maximum-xor-with-an-element-from-array","title":"1707. Maximum XOR With an Element From Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, bit manipulation, trie</p> </li> </ul>"},{"location":"content/endlesscheng/xor_trie/#1803-count-pairs-with-xor-in-a-range","title":"1803. Count Pairs With XOR in a Range","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, bit manipulation, trie</p> </li> </ul>"},{"location":"content/endlesscheng/xor_trie/#1938-maximum-genetic-difference-query","title":"1938. Maximum Genetic Difference Query","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, bit manipulation, depth first search, trie</p> </li> </ul>"},{"location":"content/endlesscheng/xor_trie/#2479-maximum-xor-of-two-non-overlapping-subtrees","title":"2479. Maximum XOR of Two Non-Overlapping Subtrees","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: tree, depth first search, graph, trie</p> </li> </ul>"},{"location":"content/graph_theory/","title":"Graph Theory","text":""},{"location":"content/graph_theory/#resources","title":"Resources","text":"<ul> <li>Graph Editor: Create and visualize graphs.</li> <li>\u3010\u9898\u5355\u3011\u56fe\u8bba\u7b97\u6cd5\uff08DFS/BFS/\u62d3\u6251\u6392\u5e8f/\u6700\u77ed\u8def/\u6700\u5c0f\u751f\u6210\u6811/\u4e8c\u5206\u56fe/\u57fa\u73af\u6811/\u6b27\u62c9\u8def\u5f84\uff09</li> </ul>"},{"location":"content/graph_theory/#concepts","title":"Concepts","text":"<ul> <li>Graph</li> <li>Vertex (Node)</li> <li>Edge</li> <li>Weight</li> </ul>"},{"location":"content/graph_theory/#types","title":"Types","text":"<ul> <li>Undirected graph: A graph in which edges have no direction.</li> </ul> <ul> <li>Directed graph: A graph in which edges have direction.</li> </ul> <pre><code>flowchart LR\nA((1)) --&gt; B((2)) &amp; C((3))\nC --&gt; B &amp; D((4))\nD --&gt; C</code></pre> <ul> <li>Cyclic graph: A graph in which there is a cycle. A cycle is a path of edges that starts and ends at the same vertex, e.g., <code>1 -&gt; 3 -&gt; 4 -&gt; 1</code>.</li> </ul> <pre><code>flowchart LR\nA((1)) --&gt; B((2)) &amp; C((3))\nB --&gt; C\nC --&gt; D((4))\nD --&gt; A</code></pre> <ul> <li>Acyclic graph: A graph in which there is no cycle.</li> </ul> <ul> <li>Directed Acyclic Graph (DAG): A directed graph with no cycles.</li> <li>Topological sort</li> </ul> <ul> <li>Weighted graph: A graph in which edges have weights.</li> </ul> <ul> <li>Connected Graph: A graph in which there is a path between every pair of vertices.</li> </ul> <ul> <li>Disconnected Graph: A graph in which there is no path between some pairs of vertices.</li> </ul> <ul> <li>Eulerian path: A path that visits every edge exactly once, e.g., <code>5 -&gt; 4 -&gt; 1 -&gt; 2 -&gt; 3</code>.</li> </ul>"},{"location":"content/graph_theory/#representation","title":"Representation","text":"<ol> <li>Adjacency Matrix</li> <li>Adjacency List</li> </ol> <pre><code>flowchart LR\n1((1))\n2((2))\n3((3))\n4((4))\n1 --&gt; 3\n1 --&gt; 2\n3 --&gt; 4\n2 --&gt; 3</code></pre> <p>Adjacency Matrix</p> Node 1 Node 2 Node 3 Node 4 Node 1 0 1 1 0 Node 2 0 0 1 0 Node 3 0 0 0 1 Node 4 0 0 0 0 <pre><code>grid = [\n    [0, 1, 1, 0],\n    [0, 0, 1, 0],\n    [0, 0, 0, 1],\n    [0, 0, 0, 0]\n]\n</code></pre> <p>Adjacency List</p> <pre><code>classDiagram\ndirection LR\nclass 1{2, 3}\nclass 2{3}\nclass 3{4}\nclass 4{-}\n1 -- 2\n2 -- 3\n3 -- 4</code></pre> <pre><code>graph = {\n    1: [2, 3],\n    2: [3],\n    3: [4],\n    4: []\n}\n</code></pre>"},{"location":"content/graph_theory/#degree","title":"Degree","text":"<ol> <li>Degree: Number of edges connected to a node</li> <li>In-degree: Number of edges coming into a node</li> <li>Out-degree: Number of edges going out of a node</li> </ol> <pre><code>flowchart LR\n1((1))\n2((2))\n3((3))\n4((4))\n1 --&gt; 3\n1 --&gt; 2\n3 --&gt; 4\n2 --&gt; 3</code></pre> <ul> <li>In-degree of Node 1: 0</li> <li>Out-degree of Node 1: 2</li> <li>In-degree of Node 2: 1</li> <li>Out-degree of Node 2: 1</li> </ul> <pre><code># List\nin_degree = [0, 1, 2, 1]\nout_degree = [2, 1, 1, 0]\n\n# Dict\nin_degree = {1: 0, 2: 1, 3: 2, 4: 1}\nout_degree = {1: 2, 2: 1, 3: 1, 4: 0}\n</code></pre>"},{"location":"content/graph_theory/#graph-bellman-ford-algorithm","title":"Graph - Bellman-Ford Algorithm","text":"<ul> <li>The Bellman-Ford algorithm is used to find the shortest path from a source vertex to all other vertices in a weighted graph.</li> <li>It is slower than Dijkstra's algorithm, but it is more versatile, as it is able to handle graphs with negative edge weights.</li> <li>Time Complexity: O(V x E), where V is the number of vertices and E is the number of edges in the graph.</li> <li>Space Complexity: O(V), where V is the number of vertices in the graph.</li> </ul>"},{"location":"content/graph_theory/bfs/","title":"BFS","text":""},{"location":"content/graph_theory/bfs/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1926. Nearest Exit from Entrance in Maze (Medium)</li> <li> 934. Shortest Bridge (Medium)</li> <li> 433. Minimum Genetic Mutation (Medium)</li> <li> 127. Word Ladder (Hard)</li> <li> 1306. Jump Game III (Medium)</li> <li> 542. 01 Matrix (Medium)</li> <li> 1091. Shortest Path in Binary Matrix (Medium)</li> <li> 863. All Nodes Distance K in Binary Tree (Medium)</li> <li> 864. Shortest Path to Get All Keys (Hard)</li> </ul>"},{"location":"content/graph_theory/bfs/#1926-nearest-exit-from-entrance-in-maze","title":"1926. Nearest Exit from Entrance in Maze","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, breadth first search, matrix 1926. Nearest Exit from Entrance in Maze - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef nearestExit(maze: List[List[str]], entrance: List[int]) -&gt; int:\n    m, n = len(maze), len(maze[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque([(entrance[0], entrance[1], 0)])\n    maze[entrance[0]][entrance[1]] = \"+\"\n\n    while q:\n        r, c, steps = q.popleft()\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and maze[nr][nc] == \".\":\n                if nr in [0, m - 1] or nc in [0, n - 1]:\n                    return steps + 1\n                q.append((nr, nc, steps + 1))\n                maze[nr][nc] = \"+\"\n\n    return -1\n\n\nmaze = [[\"+\", \"+\", \".\", \"+\"], [\".\", \".\", \".\", \"+\"], [\"+\", \"+\", \"+\", \".\"]]\nentrance = [1, 2]\nprint(nearestExit(maze, entrance))  # 1\n</code></pre></p> </li> </ul>"},{"location":"content/graph_theory/bfs/#934-shortest-bridge","title":"934. Shortest Bridge","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, matrix 934. Shortest Bridge - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS + DFS; Coloring\ndef shortestBridge(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(r, c, queue):\n        grid[r][c] = 2\n        queue.append((r, c))\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if nr in range(n) and nc in range(n) and grid[nr][nc] == 1:\n                dfs(nr, nc, queue)\n\n    q = deque()\n    found = False\n    for r in range(n):\n        if found:\n            break\n        for c in range(n):\n            if grid[r][c] == 1:\n                dfs(r, c, q)\n                found = True\n                break\n\n    steps = 0\n    while q:\n        m = len(q)\n        for _ in range(m):\n            r, c = q.popleft()\n            for dr, dc in directions:\n                nr, nc = r + dr, c + dc\n                if nr in range(n) and nc in range(n):\n                    if grid[nr][nc] == 1:\n                        return steps\n                    elif grid[nr][nc] == 0:\n                        grid[nr][nc] = 2\n                        q.append((nr, nc))\n        steps += 1\n\n    return -1\n\n\ngrid = [\n    [1, 1, 1, 1, 1],\n    [1, 0, 0, 0, 1],\n    [1, 0, 1, 0, 1],\n    [1, 0, 0, 0, 1],\n    [1, 1, 1, 1, 1],\n]\nprint(shortestBridge(grid))  # 1\n</code></pre></p> </li> </ul>"},{"location":"content/graph_theory/bfs/#433-minimum-genetic-mutation","title":"433. Minimum Genetic Mutation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, breadth first search 433. Minimum Genetic Mutation - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef minMutation(startGene: str, endGene: str, bank: List[str]) -&gt; int:\n    if endGene not in bank:\n        return -1\n\n    bank = set(bank)\n    q = deque([(startGene, 0)])\n\n    while q:\n        gene, step = q.popleft()\n        if gene == endGene:\n            return step\n\n        for i in range(8):\n            for c in \"ACGT\":\n                if gene[i] == c:\n                    continue\n                newGene = gene[:i] + c + gene[i + 1 :]\n                if newGene in bank:\n                    bank.remove(newGene)\n                    q.append((newGene, step + 1))\n    return -1\n\n\nstartGene = \"AACCGGTT\"\nendGene = \"AAACGGTA\"\nbank = [\"AACCGGTA\", \"AACCGCTA\", \"AAACGGTA\"]\nprint(minMutation(startGene, endGene, bank))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/graph_theory/bfs/#127-word-ladder","title":"127. Word Ladder","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, breadth first search</p> </li> <li>The most classic BFS problem.</li> <li>Return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.</li> <li>Approach: BFS</li> <li>Time Complexity: O(n * m^2)</li> <li>Space Complexity: O(n * m)</li> </ul> 127. Word Ladder - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef ladderLength(beginWord: str, endWord: str, wordList: List[str]) -&gt; int:\n    if endWord not in wordList:\n        return 0\n\n    n = len(beginWord)\n    graph = defaultdict(list)  # pattern: words\n    wordList.append(beginWord)\n\n    for word in wordList:\n        for i in range(n):\n            pattern = word[:i] + \"*\" + word[i + 1 :]\n            graph[pattern].append(word)\n\n    visited = set([beginWord])\n    q = deque([beginWord])\n    res = 1\n\n    while q:\n        size = len(q)\n        for _ in range(size):\n            word = q.popleft()\n            if word == endWord:\n                return res\n\n            for i in range(n):\n                pattern = word[:i] + \"*\" + word[i + 1 :]\n                for neighbor in graph[pattern]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        q.append(neighbor)\n        res += 1\n\n    return 0\n\n\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]\nprint(ladderLength(beginWord, endWord, wordList))  # 5\n</code></pre>"},{"location":"content/graph_theory/bfs/#1306-jump-game-iii","title":"1306. Jump Game III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search 1306. Jump Game III - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef canReach(arr: List[int], start: int) -&gt; bool:\n    n = len(arr)\n    visited = [False for _ in range(n)]\n    q = deque([start])\n\n    while q:\n        i = q.popleft()\n\n        if arr[i] == 0:\n            return True\n\n        visited[i] = True\n\n        for j in [i - arr[i], i + arr[i]]:\n            if j in range(n) and not visited[j]:\n                q.append(j)\n\n    return False\n\n\narr = [4, 2, 3, 0, 3, 1, 2]\nstart = 5\nprint(canReach(arr, start))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/graph_theory/bfs/#542-01-matrix","title":"542. 01 Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, breadth first search, matrix 542. 01 Matrix - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef updateMatrix(mat: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(mat), len(mat[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    q = deque()\n\n    for i in range(m):\n        for j in range(n):\n            if mat[i][j] == 0:\n                dist[i][j] = 0\n                q.append((i, j))\n\n    while q:\n        r, c = q.popleft()\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and dist[nr][nc] &gt; dist[r][c] + 1:\n                dist[nr][nc] = dist[r][c] + 1\n                q.append((nr, nc))\n\n    return dist\n\n\nmat = [[0, 0, 0], [0, 1, 0], [1, 1, 1]]\nprint(updateMatrix(mat))\n# [[0, 0, 0], [0, 1, 0], [1, 2, 1]]\n</code></pre></p> </li> </ul>"},{"location":"content/graph_theory/bfs/#1091-shortest-path-in-binary-matrix","title":"1091. Shortest Path in Binary Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, breadth first search, matrix 1091. Shortest Path in Binary Matrix - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    if grid[0][0] == 1 or grid[n - 1][n - 1] == 1:\n        return -1\n    if n == 1:\n        return 1\n\n    directions = [\n        (0, 1),\n        (1, 0),\n        (0, -1),\n        (-1, 0),\n        (1, 1),\n        (-1, -1),\n        (1, -1),\n        (-1, 1),\n    ]\n    q = deque([(0, 0, 1)])  # (row, column, distance)\n    grid[0][0] = 1\n\n    while q:\n        r, c, d = q.popleft()\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 &lt;= nr &lt; n and 0 &lt;= nc &lt; n and grid[nr][nc] == 0:\n                if nr == nc == n - 1:\n                    return d + 1\n                q.append((nr, nc, d + 1))\n                grid[nr][nc] = 1\n\n    return -1\n\n\ngrid = [[0, 0, 0], [1, 1, 0], [1, 1, 0]]\nprint(shortestPathBinaryMatrix(grid))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/graph_theory/bfs/#863-all-nodes-distance-k-in-binary-tree","title":"863. All Nodes Distance K in Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, tree, depth first search, breadth first search, binary tree 863. All Nodes Distance K in Binary Tree - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BFS\ndef distanceK(root: TreeNode, target: TreeNode, k: int) -&gt; List[int]:\n    parent = dict()\n\n    def dfs(node, par=None):\n        if node:\n            parent[node] = par\n            dfs(node.left, node)\n            dfs(node.right, node)\n\n    dfs(root)\n\n    q = deque([(target, 0)])\n    seen = set([target])\n\n    while q:\n        node, dist = q.popleft()\n\n        if dist == k:\n            return [node.val] + [node.val for node, _ in q]\n\n        for nei in (node.left, node.right, parent[node]):\n            if nei and nei not in seen:\n                seen.add(nei)\n                q.append((nei, dist + 1))\n\n    return []\n\n\nroot = build([3, 5, 1, 6, 2, 0, 8, None, None, 7, 4])\nprint(root)\n#     ______3__\n#    /         \\\n#   5__         1\n#  /   \\       / \\\n# 6     2     0   8\n#      / \\\n#     7   4\ntarget = root.left\nk = 2\nprint(distanceK(root, target, k))  # [7, 4, 1]\n</code></pre></p> </li> </ul>"},{"location":"content/graph_theory/bfs/#864-shortest-path-to-get-all-keys","title":"864. Shortest Path to Get All Keys","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, bit manipulation, breadth first search, matrix 864. Shortest Path to Get All Keys - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef shortestPathAllKeys(grid: List[str]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    q = deque()\n    visited = set()\n    total = 0\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"@\":\n                q.append((r, c, 0, 0))\n                visited.add((r, c, 0))\n            if grid[r][c].islower():\n                total += 1\n\n    while q:\n        r, c, keys, steps = q.popleft()\n\n        if keys == (1 &lt;&lt; total) - 1:\n            return steps\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n:\n                cell = grid[nr][nc]\n\n                if cell == \"#\":\n                    continue\n\n                new_keys = keys\n                if cell.islower():\n                    new_keys |= 1 &lt;&lt; (ord(cell) - ord(\"a\"))\n\n                if cell.isupper() and not (\n                    keys &amp; (1 &lt;&lt; (ord(cell) - ord(\"A\")))\n                ):\n                    continue\n\n                if (nr, nc, new_keys) not in visited:\n                    visited.add((nr, nc, new_keys))\n                    q.append((nr, nc, new_keys, steps + 1))\n\n    return -1\n\n\ngrid = [\"@.a..\", \"###.#\", \"b.A.B\"]\nprint(shortestPathAllKeys(grid))  # 8\n</code></pre></p> </li> </ul>"},{"location":"content/graph_theory/dijkstra%27s/","title":"Dijkstra's","text":""},{"location":"content/graph_theory/dijkstra%27s/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 787. Cheapest Flights Within K Stops (Medium)</li> <li> 1514. Path with Maximum Probability (Medium)</li> <li> 505. The Maze II (Medium) \ud83d\udc51</li> <li> 499. The Maze III (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/graph_theory/dijkstra%27s/#787-cheapest-flights-within-k-stops","title":"787. Cheapest Flights Within K Stops","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming, depth first search, breadth first search, graph, heap priority queue, shortest path</p> </li> <li>Return the cheapest price from <code>src</code> to <code>dst</code> with at most <code>K</code> stops.</li> </ul> <pre><code>graph TD\n0((0))\n1((1))\n2((2))\n3((3))\n0 --&gt; |100| 1\n1 --&gt; |600| 3\n1 --&gt; |100| 2\n2 --&gt; |100| 0\n2 --&gt; |200| 3</code></pre> 787. Cheapest Flights Within K Stops - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Bellman-Ford\ndef findCheapestPriceBF(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    prices = [float(\"inf\") for _ in range(n)]\n    prices[src] = 0\n\n    for _ in range(k + 1):\n        temp = prices[:]\n        for u, v, w in flights:\n            temp[v] = min(temp[v], prices[u] + w)\n        prices = temp\n\n    return prices[dst] if prices[dst] != float(\"inf\") else -1\n\n\n# Dijkstra\ndef findCheapestPriceDijkstra(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in flights:\n        graph[u].append((v, w))\n\n    heap = [(0, src, 0)]  # (price, city, stops)\n    visited = defaultdict(int)  # {city: stops}\n\n    while heap:\n        price, city, stops = heapq.heappop(heap)\n\n        if city == dst:\n            return price\n\n        if stops &gt; k:\n            continue\n\n        if city in visited and visited[city] &lt;= stops:\n            continue\n\n        visited[city] = stops\n\n        for neighbor, cost in graph[city]:\n            heapq.heappush(heap, (price + cost, neighbor, stops + 1))\n\n    return -1\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |Bellman-Ford|    O(k * E)      |  O(n)   |\n# | Dijkstra   | O(E * log(V))    |  O(n)   |\n# |------------|------------------|---------|\n\n\nn = 4\nflights = [[0, 1, 100], [1, 2, 100], [2, 0, 100], [1, 3, 600], [2, 3, 200]]\nsrc = 0\ndst = 3\nk = 1\nprint(findCheapestPriceBF(n, flights, src, dst, k))  # 700\nprint(findCheapestPriceDijkstra(n, flights, src, dst, k))  # 700\n</code></pre>"},{"location":"content/graph_theory/dijkstra%27s/#1514-path-with-maximum-probability","title":"1514. Path with Maximum Probability","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, graph, heap priority queue, shortest path 1514. Path with Maximum Probability - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Dijkstra - Dict\ndef maxProbability1(\n    n: int,\n    edges: List[List[int]],\n    succProb: List[float],\n    start_node: int,\n    end_node: int,\n) -&gt; float:\n    graph = defaultdict(list)\n    for i, (u, v) in enumerate(edges):\n        graph[u].append((v, succProb[i]))\n        graph[v].append((u, succProb[i]))\n\n    heap = [(-1, start_node)]\n    max_prob = {i: 0.0 for i in range(n)}\n    max_prob[start_node] = 1.0\n\n    while heap:\n        p1, n1 = heapq.heappop(heap)\n\n        if n1 == end_node:\n            return -p1\n\n        for n2, p2 in graph[n1]:\n            p2 *= -p1\n            if p2 &gt; max_prob[n2]:\n                max_prob[n2] = p2\n                heapq.heappush(heap, (-p2, n2))\n\n    return 0.0\n\n\n# Dijkstra - Set\ndef maxProbability2(\n    n: int,\n    edges: List[List[int]],\n    succProb: List[float],\n    start_node: int,\n    end_node: int,\n) -&gt; float:\n    graph = defaultdict(list)\n    for i, (u, v) in enumerate(edges):\n        graph[u].append((v, succProb[i]))\n        graph[v].append((u, succProb[i]))\n\n    heap = [(-1, start_node)]\n    visited = set()\n\n    while heap:\n        p1, n1 = heapq.heappop(heap)\n        visited.add(n1)\n\n        if n1 == end_node:\n            return -p1\n\n        for n2, p2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (p1 * p2, n2))\n\n    return 0.0\n\n\n# |------------|-----------|-----------|\n# |  Approach  |    Time   |   Space   |\n# |------------|-----------|-----------|\n# |  Dijkstra  | O(E log V)|   O(E)    |\n# |------------|-----------|-----------|\n\n\nn = 3\nedges = [[0, 1], [1, 2], [0, 2]]\nsuccProb = [0.5, 0.5, 0.2]\nstart = 0\nend = 2\n\nprint(maxProbability1(n, edges, succProb, start, end))  # 0.25\nprint(maxProbability2(n, edges, succProb, start, end))  # 0.25\n</code></pre></p> </li> </ul>"},{"location":"content/graph_theory/dijkstra%27s/#505-the-maze-ii","title":"505. The Maze II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, graph, heap priority queue, matrix, shortest path 505. The Maze II - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra\ndef shortestDistance(\n    maze: List[List[int]], start: List[int], destination: List[int]\n) -&gt; int:\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    m, n = len(maze), len(maze[0])\n\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    dist[start[0]][start[1]] = 0\n\n    heap = [(0, start[0], start[1])]\n\n    while heap:\n        d, r, c = heapq.heappop(heap)\n\n        if [r, c] == destination:\n            return d\n\n        for dr, dc in directions:\n            nr, nc, nd = r, c, d\n\n            while (\n                0 &lt;= nr + dr &lt; m\n                and 0 &lt;= nc + dc &lt; n\n                and maze[nr + dr][nc + dc] == 0\n            ):\n                nr += dr\n                nc += dc\n                nd += 1\n\n            if nd &lt; dist[nr][nc]:\n                dist[nr][nc] = nd\n                heapq.heappush(heap, (nd, nr, nc))\n\n    return -1\n\n\nmaze = [\n    [0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0],\n    [0, 0, 0, 1, 0],\n    [1, 1, 0, 1, 1],\n    [0, 0, 0, 0, 0],\n]\nstart = [0, 4]\ndestination = [4, 4]\nprint(shortestDistance(maze, start, destination))  # 12\n</code></pre></p> </li> </ul>"},{"location":"content/graph_theory/dijkstra%27s/#499-the-maze-iii","title":"499. The Maze III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, depth first search, breadth first search, graph, heap priority queue, matrix, shortest path 499. The Maze III - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra\ndef findShortestWay(\n    maze: List[List[int]], ball: List[int], hole: List[int]\n) -&gt; str:\n    directions = [(-1, 0, \"u\"), (1, 0, \"d\"), (0, -1, \"l\"), (0, 1, \"r\")]\n    m, n = len(maze), len(maze[0])\n\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    dist[ball[0]][ball[1]] = 0\n\n    paths = [[\"\"] * n for _ in range(m)]\n    paths[ball[0]][ball[1]] = \"\"\n\n    heap = [(0, \"\", ball[0], ball[1])]\n\n    while heap:\n        d, path, x, y = heapq.heappop(heap)\n\n        if [x, y] == hole:\n            return path\n\n        for dx, dy, direction in directions:\n            nx, ny, nd = x, y, d\n\n            while (\n                0 &lt;= nx + dx &lt; m\n                and 0 &lt;= ny + dy &lt; n\n                and maze[nx + dx][ny + dy] == 0\n            ):\n                nx += dx\n                ny += dy\n                nd += 1\n\n                if [nx, ny] == hole:\n                    break\n\n            new_path = path + direction\n            if nd &lt; dist[nx][ny] or (\n                nd == dist[nx][ny] and new_path &lt; paths[nx][ny]\n            ):\n                dist[nx][ny] = nd\n                paths[nx][ny] = new_path\n                heapq.heappush(heap, (nd, new_path, nx, ny))\n\n    return \"impossible\"\n\n\nmaze = [\n    [0, 0, 0, 0, 0],\n    [1, 1, 0, 0, 1],\n    [0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 1],\n    [0, 1, 0, 0, 0],\n]\nball = [4, 3]\nhole = [0, 1]\nprint(findShortestWay(maze, ball, hole))  # \"lul\"\n</code></pre></p> </li> </ul>"},{"location":"content/graph_theory/graph_theory/","title":"Graph Theory","text":""},{"location":"content/graph_theory/graph_theory/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 997. Find the Town Judge (Easy)</li> <li> 1557. Minimum Number of Vertices to Reach All Nodes (Medium)</li> <li> 1615. Maximal Network Rank (Medium)</li> <li> 785. Is Graph Bipartite? (Medium)</li> <li> 261. Graph Valid Tree (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/graph_theory/graph_theory/#997-find-the-town-judge","title":"997. Find the Town Judge","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, graph</p> </li> <li><code>trust = [[1, 3], [2, 3], [1, 2], [4, 3]]</code></li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 3((3))\n    2((2)) --&gt; 3((3))\n    1((1)) --&gt; 2((2))\n    4((4)) --&gt; 3((3))</code></pre> 997. Find the Town Judge - Python Solution<pre><code>from typing import List\n\n\n# Graph\ndef findJudge(n: int, trust: List[List[int]]) -&gt; int:\n    indegree = {i: 0 for i in range(1, n + 1)}\n    outdegree = {i: 0 for i in range(1, n + 1)}\n\n    for a, b in trust:\n        outdegree[a] += 1\n        indegree[b] += 1\n\n    for i in range(1, n + 1):\n        if indegree[i] == n - 1 and outdegree[i] == 0:\n            return i\n\n    return -1\n\n\nn = 4\ntrust = [[1, 3], [2, 3], [1, 2], [4, 3]]\nprint(findJudge(n, trust))  # 4\n</code></pre>"},{"location":"content/graph_theory/graph_theory/#1557-minimum-number-of-vertices-to-reach-all-nodes","title":"1557. Minimum Number of Vertices to Reach All Nodes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: graph</p> </li> <li>Return a list of integers representing the minimum number of vertices needed to traverse all the nodes.</li> <li>Hint: Return the vertices with indegree 0.</li> </ul> 1557. Minimum Number of Vertices to Reach All Nodes - Python Solution<pre><code>from typing import List\n\n\n# Graph\ndef findSmallestSetOfVertices(n: int, edges: List[List[int]]) -&gt; List[int]:\n    indegree = {i: 0 for i in range(n)}\n\n    for _, end in edges:\n        indegree[end] += 1\n\n    return [i for i in range(n) if indegree[i] == 0]\n\n\nif __name__ == \"__main__\":\n    n = 6\n    edges = [[0, 1], [0, 2], [2, 5], [3, 4], [4, 2]]\n    assert findSmallestSetOfVertices(n, edges) == [0, 3]\n</code></pre>"},{"location":"content/graph_theory/graph_theory/#1615-maximal-network-rank","title":"1615. Maximal Network Rank","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: graph 1615. Maximal Network Rank - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Graph\ndef maximalNetworkRank(n: int, roads: List[List[int]]) -&gt; int:\n    degree = defaultdict(int)\n    roads_set = set(map(tuple, roads))\n\n    for a, b in roads_set:\n        degree[a] += 1\n        degree[b] += 1\n\n    rank = 0\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if (i, j) in roads_set or (j, i) in roads_set:\n                rank = max(rank, degree[i] + degree[j] - 1)\n            else:\n                rank = max(rank, degree[i] + degree[j])\n\n    return rank\n\n\nn = 4\nroads = [[0, 1], [0, 3], [1, 2], [1, 3]]\nprint(maximalNetworkRank(n, roads))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/graph_theory/graph_theory/#785-is-graph-bipartite","title":"785. Is Graph Bipartite?","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> <li>Determine if a graph is bipartite.</li> </ul> <p>How to group</p> Uncolored Color 1 Color 2 Operation Method 1 -1 0 1 <code>1 - color</code> Method 2 0 1 -1 <code>-color</code> 785. Is Graph Bipartite? - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef isBipartiteBFS(graph: List[List[int]]) -&gt; bool:\n    n = len(graph)\n    # -1: not colored; 0: blue; 1: red\n    color = [-1 for _ in range(n)]\n\n    def bfs(node):\n        q = deque([node])\n        color[node] = 0\n\n        while q:\n            cur = q.popleft()\n\n            for neighbor in graph[cur]:\n                if color[neighbor] == -1:\n                    color[neighbor] = 1 - color[cur]\n                    q.append(neighbor)\n                elif color[neighbor] == color[cur]:\n                    return False\n        return True\n\n    for i in range(n):\n        if color[i] == -1:\n            if not bfs(i):\n                return False\n\n    return True\n\n\n# DFS\ndef isBipartiteDFS(graph: List[List[int]]) -&gt; bool:\n    n = len(graph)\n    # -1: not colored; 0: blue; 1: red\n    color = [-1] * n\n\n    def dfs(node, c):\n        color[node] = c\n        for neighbor in graph[node]:\n            if color[neighbor] == -1:\n                if not dfs(neighbor, 1 - c):\n                    return False\n            elif color[neighbor] == c:\n                return False\n        return True\n\n    for i in range(n):\n        if color[i] == -1:\n            if not dfs(i, 0):\n                return False\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |    BFS     | O(V+E) |  O(V)   |\n# |    DFS     | O(V+E) |  O(V)   |\n# |------------|--------|---------|\n\n\ngraph = [[1, 2, 3], [0, 2], [0, 1, 3], [0, 2]]\nprint(isBipartiteBFS(graph))  # False\nprint(isBipartiteDFS(graph))  # False\n</code></pre>"},{"location":"content/graph_theory/graph_theory/#261-graph-valid-tree","title":"261. Graph Valid Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph 261. Graph Valid Tree - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Graph\ndef validTree(n: int, edges: List[List[int]]) -&gt; bool:\n    if n == 0:\n        return False\n    if len(edges) != n - 1:\n        return False\n\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = set()\n\n    def dfs(node, parent):\n        if node in visited:\n            return False\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor != parent and not dfs(neighbor, node):\n                return False\n        return True\n\n    return dfs(0, -1) and len(visited) == n\n\n\nprint(validTree(5, [[0, 1], [0, 2], [0, 3], [1, 4]]))  # True\nprint(validTree(5, [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]))  # False\n</code></pre></p> </li> </ul>"},{"location":"content/graph_theory/matrix_graphs/","title":"Matrix Graphs","text":""},{"location":"content/graph_theory/matrix_graphs/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 200. Number of Islands (Medium)</li> <li> 1020. Number of Enclaves (Medium)</li> <li> 1254. Number of Closed Islands (Medium)</li> <li> 695. Max Area of Island (Medium)</li> <li> 417. Pacific Atlantic Water Flow (Medium)</li> </ul>"},{"location":"content/graph_theory/matrix_graphs/#200-number-of-islands","title":"200. Number of Islands","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix</p> </li> <li>Count the number of islands in a 2D grid.</li> <li>Method 1: DFS</li> <li> <p>Method 2: BFS (use a queue to traverse the grid)</p> </li> <li> <p>How to keep track of visited cells?</p> <ol> <li>Mark the visited cell as <code>0</code> (or any other value) to avoid revisiting it.</li> <li>Use a set to store the visited cells.</li> </ol> </li> <li> <p>Steps:</p> <ol> <li>Init: variables</li> <li>DFS/BFS: starting from the cell with <code>1</code>, turn all the connected <code>1</code>s to <code>0</code>.</li> <li>Traverse the grid, and if the cell is <code>1</code>, increment the count and call DFS/BFS.</li> </ol> </li> </ul> <p></p> 200. Number of Islands - Python Solution<pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef numIslandsDFS(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    res = 0\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] != \"1\":\n            return\n\n        grid[r][c] = \"2\"\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                dfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Set\ndef numIslandsBFS1(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == \"0\"\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\" and (r, c) not in visited:\n                visited.add((r, c))\n                bfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = dr + row, dc + col\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] != \"1\"\n                ):\n                    continue\n                grid[nr][nc] = \"2\"\n                q.append((nr, nc))\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == \"1\":\n                grid[i][j] = \"2\"\n                bfs(i, j)\n                res += 1\n\n    return res\n\n\ngrid = [\n    [\"1\", \"1\", \"1\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"0\", \"0\", \"0\", \"0\", \"0\"],\n]\n\nprint(numIslandsDFS(deepcopy(grid)))  # 1\nprint(numIslandsBFS1(deepcopy(grid)))  # 1\nprint(numIslandsBFS2(deepcopy(grid)))  # 1\n</code></pre> 200. Number of Islands - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\nprivate:\n    void dfs(vector&lt;vector&lt;char&gt;&gt; &amp;grid, int r, int c)\n    {\n        int row = grid.size();\n        int col = grid[0].size();\n\n        if (r &lt; 0 || r &gt;= row || c &lt; 0 || c &gt;= col || grid[r][c] != '1')\n        {\n            return;\n        }\n        grid[r][c] = '0';\n\n        dfs(grid, r - 1, c);\n        dfs(grid, r + 1, c);\n        dfs(grid, r, c - 1);\n        dfs(grid, r, c + 1);\n    }\n\npublic:\n    int numIslands(vector&lt;vector&lt;char&gt;&gt; &amp;grid)\n    {\n        int m = grid.size(), n = grid[0].size();\n        int res = 0;\n        for (int i = 0; i &lt; m; i++)\n        {\n            for (int j = 0; j &lt; n; j++)\n            {\n                if (grid[i][j] == '1')\n                {\n                    res++;\n                    dfs(grid, i, j);\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    Solution s;\n    vector&lt;vector&lt;char&gt;&gt; grid = {\n        {'1', '1', '0', '0', '0'},\n        {'1', '1', '0', '0', '0'},\n        {'0', '0', '1', '0', '0'},\n        {'0', '0', '0', '1', '1'}};\n    cout &lt;&lt; s.numIslands(grid) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/graph_theory/matrix_graphs/#1020-number-of-enclaves","title":"1020. Number of Enclaves","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix 1020. Number of Enclaves - Python Solution<pre><code>from typing import List\n\n\n# DFS\ndef numEnclaves(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    visited = set()\n\n    def dfs(r, c):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or grid[r][c] == 0\n            or (r, c) in visited\n        ):\n            return\n\n        grid[r][c] = 0\n        visited.add((r, c))\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if (\n                (r in [0, m - 1] or c in [0, n - 1])\n                and grid[r][c] == 1\n                and (r, c) not in visited\n            ):\n                dfs(r, c)\n\n    count = 0\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1 and (r, c) not in visited:\n                count += 1\n\n    return count\n\n\ngrid = [[0, 0, 0, 0], [1, 0, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0]]\nprint(numEnclaves(grid))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/graph_theory/matrix_graphs/#1254-number-of-closed-islands","title":"1254. Number of Closed Islands","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix 1254. Number of Closed Islands - Python Solution<pre><code>from typing import List\n\n\n# DFS\ndef closedIsland(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    visited = set()\n\n    def dfs(r, c):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or grid[r][c] == 1\n            or (r, c) in visited\n        ):\n            return\n\n        grid[r][c] = 1\n        visited.add((r, c))\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if (\n                (r in [0, m - 1] or c in [0, n - 1])\n                and grid[r][c] == 0\n                and (r, c) not in visited\n            ):\n                dfs(r, c)\n\n    island = 0\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 0 and (r, c) not in visited:\n                island += 1\n                dfs(r, c)\n\n    return island\n\n\ngrid = [\n    [1, 1, 1, 1, 1, 1, 1, 0],\n    [1, 0, 0, 0, 0, 1, 1, 0],\n    [1, 0, 1, 0, 1, 1, 1, 0],\n    [1, 0, 0, 0, 0, 1, 0, 1],\n    [1, 1, 1, 1, 1, 1, 1, 0],\n]\nprint(closedIsland(grid))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/graph_theory/matrix_graphs/#695-max-area-of-island","title":"695. Max Area of Island","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix 695. Max Area of Island - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef maxAreaOfIslandDFS(grid: List[List[int]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] == 0:\n            return 0\n\n        grid[r][c] = 0\n\n        return (\n            1 + dfs(r + 1, c) + dfs(r - 1, c) + dfs(r, c + 1) + dfs(r, c - 1)\n        )\n\n    res = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                res = max(res, dfs(i, j))\n    return res\n\n\n# BFS\ndef maxAreaOfIslandBFS1(grid: List[List[int]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        area = 0\n\n        while q:\n            row, col = q.popleft()\n            area += 1\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == 0\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n        return area\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1 and (r, c) not in visited:\n                visited.add((r, c))\n                res = max(res, bfs(r, c))\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        area = 0\n\n        while q:\n            row, col = q.popleft()\n            area += 1\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n\n                if nr &lt; 0 or nr &gt;= m or nc &lt; 0 or nc &gt;= n or grid[nr][nc] == 0:\n                    continue\n\n                q.append((nr, nc))\n                grid[nr][nc] = 0\n\n        return area\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                grid[r][c] = 0\n                res = max(res, bfs(r, c))\n\n    return res\n\n\ngrid = [\n    [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0],\n    [0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],\n]\nprint(maxAreaOfIslandDFS(grid))  # 6\nprint(maxAreaOfIslandBFS1(grid))  # 6\nprint(numIslandsBFS2(grid))  # 6\n</code></pre></p> </li> </ul> 695. Max Area of Island - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {\n        int m = grid.size(), n = grid[0].size();\n        int res = 0;\n\n        auto dfs = [&amp;](auto&amp;&amp; self, int r, int c) -&gt; int {\n            if (r &lt; 0 || r &gt;= m || c &lt; 0 || c &gt;= n || grid[r][c] != 1) {\n                return 0;\n            }\n            grid[r][c] = 0;\n\n            return 1 + self(self, r - 1, c) + self(self, r, c - 1) +\n                   self(self, r + 1, c) + self(self, r, c + 1);\n        };\n        for (int i = 0; i &lt; m; i++) {\n            for (int j = 0; j &lt; n; j++) {\n                if (grid[i][j] == 1) {\n                    int area = dfs(dfs, i, j);\n                    res = max(res, area);\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution s;\n    vector&lt;vector&lt;int&gt;&gt; grid = {{0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},\n                                {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},\n                                {0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},\n                                {0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0},\n                                {0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0},\n                                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0},\n                                {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},\n                                {0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0}};\n    cout &lt;&lt; s.maxAreaOfIsland(grid) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/graph_theory/matrix_graphs/#417-pacific-atlantic-water-flow","title":"417. Pacific Atlantic Water Flow","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, matrix 417. Pacific Atlantic Water Flow - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef pacificAtlanticDFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(r, c, visited, prev_height):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or heights[r][c] &lt; prev_height\n            or (r, c) in visited\n        ):\n            return None\n\n        visited.add((r, c))\n        height = heights[r][c]\n        for dr, dc in directions:\n            dfs(dr + r, dc + c, visited, height)\n\n    for c in range(n):\n        dfs(0, c, pac, heights[0][c])\n        dfs(m - 1, c, atl, heights[m - 1][c])\n\n    for r in range(m):\n        dfs(r, 0, pac, heights[r][0])\n        dfs(r, n - 1, atl, heights[r][n - 1])\n\n    return list(pac &amp; atl)\n\n\n# BFS\ndef pacificAtlanticBFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def bfs(r, c, visited):\n        q = deque([(r, c)])\n        visited.add((r, c))\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr in range(m)\n                    and nc in range(n)\n                    and heights[row][col] &lt;= heights[nr][nc]\n                    and (nr, nc) not in visited\n                ):\n                    q.append((nr, nc))\n                    visited.add((nr, nc))\n\n    for c in range(n):\n        bfs(0, c, pac)  # top\n        bfs(m - 1, c, atl)  # bottom\n\n    for r in range(m):\n        bfs(r, 0, pac)  # left\n        bfs(r, n - 1, atl)  # right\n\n    return list(pac &amp; atl)\n\n\nheights = [\n    [1, 2, 2, 3, 5],\n    [3, 2, 3, 4, 4],\n    [2, 4, 5, 3, 1],\n    [6, 7, 1, 4, 5],\n    [5, 1, 1, 2, 4],\n]\nprint(pacificAtlanticDFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\nprint(pacificAtlanticBFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\n</code></pre></p> </li> </ul>"},{"location":"content/graph_theory/mst/","title":"MST","text":""},{"location":"content/graph_theory/mst/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1135. Connecting Cities With Minimum Cost (Medium) \ud83d\udc51</li> <li> 1584. Min Cost to Connect All Points (Medium)</li> <li> 1168. Optimize Water Distribution in a Village (Hard) \ud83d\udc51</li> <li> 1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree (Hard)</li> </ul>"},{"location":"content/graph_theory/mst/#1135-connecting-cities-with-minimum-cost","title":"1135. Connecting Cities With Minimum Cost","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: union find, graph, heap priority queue, minimum spanning tree 1135. Connecting Cities With Minimum Cost - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minimumCost(n: int, connections: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, c in connections:\n        graph[u].append((c, v))\n        graph[v].append((c, u))\n\n    cost = 0\n    heap = [(0, 1)]  # (cost, node)\n    visited = set()\n\n    while heap:\n        c1, n1 = heapq.heappop(heap)\n\n        if n1 in visited:\n            continue\n\n        visited.add(n1)\n\n        cost += c1\n\n        for c2, n2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (c2, n2))\n\n    return cost if len(visited) == n else -1\n\n\nn = 3\nconnections = [[1, 2, 5], [1, 3, 6], [2, 3, 1]]\nprint(minimumCost(n, connections))  # 6\n</code></pre></p> </li> </ul>"},{"location":"content/graph_theory/mst/#1584-min-cost-to-connect-all-points","title":"1584. Min Cost to Connect All Points","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, union find, graph, minimum spanning tree</p> </li> <li>Tree: a connected acyclic graph</li> <li>Spanning Tree: a subgraph that is a tree and connects all the vertices together</li> <li>Minimum Spanning Tree (MST): a spanning tree with the minimum possible sum of edge weights</li> <li>Prim's Algorithm</li> <li>Data Structure: Heap</li> <li>Time Complexity: O(E * logV)</li> <li>Space Complexity: O(V + E)</li> <li>Kruskal's Algorithm</li> <li>Union Find</li> <li>Time Complexity: O(E * logV)</li> <li>Space Complexity: O(V + E)</li> </ul> 1584. Min Cost to Connect All Points - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minCostConnectPointsPrim(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    graph = defaultdict(list)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            dist = abs(x1 - x2) + abs(y1 - y2)\n            graph[i].append((dist, j))\n            graph[j].append((dist, i))\n\n    cost = 0\n    heap = [(0, 0)]  # (cost, node)\n    visited = set()\n\n    while heap:\n        d1, n1 = heapq.heappop(heap)\n        if n1 in visited:\n            continue\n        visited.add(n1)\n        cost += d1\n\n        for d2, n2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (d2, n2))\n\n    return cost\n\n\n# Kruskal\ndef minCostConnectPointsKruskal(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    par = {i: i for i in range(n)}\n    rank = {i: 0 for i in range(n)}\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 == p2:\n            return False\n\n        if rank[p1] &gt; rank[p2]:\n            par[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n        else:\n            par[p2] = p1\n            rank[p1] += 1\n\n        return True\n\n    heap = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            dist = abs(x1 - x2) + abs(y1 - y2)\n            heapq.heappush(heap, (dist, i, j))\n\n    cost = 0\n    while heap:\n        d, n1, n2 = heapq.heappop(heap)\n        if union(n1, n2):\n            cost += d\n\n    return cost\n\n\nif __name__ == \"__main__\":\n    points = [[0, 0], [2, 2], [3, 10], [5, 2], [7, 0]]\n    print(minCostConnectPointsPrim(points))  # 20\n    print(minCostConnectPointsKruskal(points))  # 20\n</code></pre>"},{"location":"content/graph_theory/mst/#1168-optimize-water-distribution-in-a-village","title":"1168. Optimize Water Distribution in a Village","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: union find, graph, heap priority queue, minimum spanning tree</p> </li> <li> <p></p> </li> <li> <p></p> </li> </ul> 1168. Optimize Water Distribution in a Village - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minCostToSupplyWater1(\n    n: int, wells: List[int], pipes: List[List[int]]\n) -&gt; int:\n    graph = defaultdict(list)\n\n    for h1, h2, cost in pipes:\n        graph[h1].append((h2, cost))\n        graph[h2].append((h1, cost))\n\n    # Add the cost of the wells to the graph (house 0)\n    for i in range(n):\n        graph[0].append((i + 1, wells[i]))\n        graph[i + 1].append((0, wells[i]))\n\n    visited = set([0])\n    heap = [(cost, dest) for dest, cost in graph[0]]\n    heapq.heapify(heap)\n\n    cost = 0\n\n    while heap:\n        c1, n1 = heapq.heappop(heap)\n        if n1 in visited:\n            continue\n        visited.add(n1)\n        cost += c1\n\n        for n2, c2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (c2, n2))\n\n    return cost\n\n\n# Kruskal\ndef minCostToSupplyWater2(\n    n: int, wells: List[int], pipes: List[List[int]]\n) -&gt; int:\n    par = list(range(n + 1))\n    rank = [0] * (n + 1)\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            if rank[p1] &lt; rank[p2]:\n                par[p1] = p2\n            elif rank[p1] &gt; rank[p2]:\n                par[p2] = p1\n            else:\n                par[p1] = p2\n                rank[p2] += 1\n            return True\n        return False\n\n    graph = [(c, 0, i + 1) for i, c in enumerate(wells)]\n    for h1, h2, c in pipes:\n        graph.append((c, h1, h2))\n\n    graph.sort()\n\n    cost = 0\n\n    for c, h1, h2 in graph:\n        if union(h1, h2):\n            cost += c\n\n    return cost\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |    Prim    | O((V + E) log V) | O(V + E)|\n# |  Kruskal   |     O(E log E)   | O(V + E)|\n# |------------|------------------|---------|\n\n\nn = 3\nwells = [1, 2, 2]\npipes = [[1, 2, 1], [2, 3, 1]]\nprint(minCostToSupplyWater1(n, wells, pipes))  # 3\nprint(minCostToSupplyWater2(n, wells, pipes))  # 3\n</code></pre>"},{"location":"content/graph_theory/mst/#1489-find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree","title":"1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: union find, graph, sorting, minimum spanning tree, strongly connected component 1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree - Python Solution<pre><code>from typing import List\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [1 for _ in range(n)]\n        self.part = n\n\n    def find(self, n):\n        p = self.parent[n]\n        while p != self.parent[p]:\n            self.parent[p] = self.parent[self.parent[p]]\n            p = self.parent[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return False\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.parent[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.parent[p1] = p2\n        else:\n            self.parent[p2] = p1\n            self.rank[p1] += 1\n\n        self.part -= 1\n        return True\n\n\n# Kruskal\ndef findCriticalAndPseudoCriticalEdges(\n    n: int, edges: List[List[int]]\n) -&gt; List[List[int]]:\n    m = len(edges)\n\n    # Add index to edges\n    lst = list(range(m))\n    lst.sort(key=lambda x: edges[x][2])\n\n    # Calculate minimum cost\n    min_cost = 0\n    uf = UnionFind(n)\n    for i in lst:\n        x, y, cost = edges[i]\n        if uf.union(x, y):\n            min_cost += cost\n\n    # Calculate key edges\n    key = set()\n    for i in lst:\n        cur_cost = 0\n        uf = UnionFind(n)\n        for j in lst:\n            if j != i:\n                x, y, cost = edges[j]\n                if uf.union(x, y):\n                    cur_cost += cost\n        if cur_cost &gt; min_cost or uf.part != 1:\n            key.add(i)\n\n    # Calculate fake edges\n    fake = set()\n    for i in lst:\n        if i not in key:\n            cur_cost = edges[i][2]\n            uf = UnionFind(n)\n            uf.union(edges[i][0], edges[i][1])\n            for j in lst:\n                x, y, cost = edges[j]\n                if uf.union(x, y):\n                    cur_cost += cost\n            if cur_cost == min_cost and uf.part == 1:\n                fake.add(i)\n\n    return [sorted(list(key)), sorted(list(fake))]\n\n\nn = 5\nedges = [\n    [0, 1, 1],\n    [1, 2, 1],\n    [2, 3, 2],\n    [0, 3, 2],\n    [0, 4, 3],\n    [3, 4, 3],\n    [1, 4, 6],\n]\nprint(findCriticalAndPseudoCriticalEdges(n, edges))\n</code></pre></p> </li> </ul>"},{"location":"content/graph_theory/standard_traversal/","title":"Standard Traversal","text":""},{"location":"content/graph_theory/standard_traversal/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 547. Number of Provinces (Medium)</li> <li> 802. Find Eventual Safe States (Medium)</li> <li> 841. Keys and Rooms (Medium)</li> <li> 1129. Shortest Path with Alternating Colors (Medium)</li> <li> 1376. Time Needed to Inform All Employees (Medium)</li> <li> 1466. Reorder Routes to Make All Paths Lead to the City Zero (Medium)</li> <li> 797. All Paths From Source to Target (Medium)</li> <li> 1192. Critical Connections in a Network (Hard)</li> </ul>"},{"location":"content/graph_theory/standard_traversal/#547-number-of-provinces","title":"547. Number of Provinces","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> <li>Return the number of provinces.</li> </ul>"},{"location":"content/graph_theory/standard_traversal/#union-find","title":"Union Find","text":"<ul> <li>Find by Path Compression</li> <li>Union by Rank</li> <li>Time Complexity: O(log(n))</li> <li>Space Complexity: O(n)</li> </ul> template/union_find.py 547. Number of Provinces - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\nfrom template import UnionFind\n\n\n# DFS (Adjacency Matrix)\ndef findCircleNumDFSMatrix(isConnected: List[List[int]]) -&gt; int:\n    n = len(isConnected)\n    visited = set()\n\n    def dfs(node):\n        if node in visited:\n            return\n        visited.add(node)\n        for neighbor in range(n):\n            if node != neighbor and isConnected[node][neighbor] == 1:\n                dfs(neighbor)\n\n    res = 0\n    for i in range(n):\n        if i not in visited:\n            dfs(i)\n            res += 1\n\n    return res\n\n\n# DFS (Adjacency List)\ndef findCircleNumDFSList(isConnected: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    n = len(isConnected)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if isConnected[i][j] == 1:\n                graph[i].append(j)\n                graph[j].append(i)\n\n    visited = set()\n\n    def dfs(node):\n        if node in visited:\n            return\n        visited.add(node)\n        for neighbor in graph[node]:\n            dfs(neighbor)\n\n    res = 0\n    for i in range(n):\n        if i not in visited:\n            dfs(i)\n            res += 1\n\n    return res\n\n\n# BFS (Adjacency Matrix)\ndef findCircleNumBFS(isConnected: List[List[int]]) -&gt; int:\n    n = len(isConnected)\n    visited = set()\n    q = deque()\n    res = 0\n\n    for i in range(n):\n        if i not in visited:\n            res += 1\n\n            q.append(i)\n            while q:\n                node = q.popleft()\n                visited.add(node)\n                for node, val in enumerate(isConnected[node]):\n                    if val == 1 and node not in visited:\n                        q.append(node)\n                        visited.add(node)\n\n    return res\n\n\n# Union Find\ndef findCircleNumUF(isConnected: List[List[int]]) -&gt; int:\n    n = len(isConnected)\n    uf = UnionFind(n)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if isConnected[i][j] == 1:\n                uf.union(i, j)\n\n    res = len(set(uf.find(i) for i in range(n)))\n\n    return res\n\n\n# Union Find\ndef findCircleNum(isConnected: List[List[int]]) -&gt; int:\n    n = len(isConnected)\n    par = {i: i for i in range(n)}\n    rank = {i: 0 for i in range(n)}\n\n    def find(n):\n        p = par[n]\n        while par[p] != p:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 == p2:\n            return None\n\n        if rank[p1] &gt; rank[p2]:\n            par[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n        else:\n            par[p2] = p1\n            rank[p1] += 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if isConnected[i][j] == 1:\n                union(i, j)\n\n    res = len(set(find(i) for i in range(n)))\n\n    return res\n\n\nisConnected = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]\nprint(findCircleNumDFSList(isConnected))  # 2\nprint(findCircleNumDFSMatrix(isConnected))  # 2\nprint(findCircleNumBFS(isConnected))  # 2\nprint(findCircleNum(isConnected))  # 2\nprint(findCircleNumUF(isConnected))  # 2\n</code></pre>"},{"location":"content/graph_theory/standard_traversal/#802-find-eventual-safe-states","title":"802. Find Eventual Safe States","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort 802. Find Eventual Safe States - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# Topological Sort\ndef eventualSafeNodesTS(graph: List[List[int]]) -&gt; List[int]:\n    n = len(graph)\n    reverse_graph = defaultdict(list)\n    indegree = [0 for _ in range(n)]\n    safe = [False for _ in range(n)]\n\n    for u in range(n):\n        for v in graph[u]:\n            reverse_graph[v].append(u)\n        indegree[u] = len(graph[u])\n\n    q = deque([i for i in range(n) if indegree[i] == 0])\n\n    while q:\n        node = q.popleft()\n        safe[node] = True\n\n        for neighbor in reverse_graph[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n\n    return [i for i in range(n) if safe[i]]\n\n\n# DFS\ndef eventualSafeNodesDFS(graph: List[List[int]]) -&gt; List[int]:\n    n = len(graph)\n    state = [0 for _ in range(n)]  # 0: unvisited, 1: visiting, 2: visited\n\n    def dfs(node):\n        if state[node] &gt; 0:\n            return state[node] == 2\n        state[node] = 1\n        for neighbor in graph[node]:\n            if state[neighbor] == 1 or not dfs(neighbor):\n                return False\n        state[node] = 2\n        return True\n\n    return [i for i in range(n) if dfs(i)]\n\n\ngraph = [[1, 2], [2, 3], [5], [0], [5], [], []]\nprint(eventualSafeNodesTS(graph))  # [2, 4, 5, 6]\nprint(eventualSafeNodesDFS(graph))  # [2, 4, 5, 6]\n</code></pre></p> </li> </ul>"},{"location":"content/graph_theory/standard_traversal/#841-keys-and-rooms","title":"841. Keys and Rooms","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph 841. Keys and Rooms - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef canVisitAllRoomsDFS(rooms: List[List[int]]) -&gt; bool:\n    n = len(rooms)\n    visited = [False for _ in range(n)]\n\n    def dfs(room):\n        visited[room] = True\n        for key in rooms[room]:\n            if not visited[key]:\n                dfs(key)\n\n    dfs(0)\n\n    return all(visited)\n\n\n# BFS\ndef canVisitAllRoomsBFS(rooms):\n    n = len(rooms)\n    visited = [False for _ in range(n)]\n    q = deque([0])\n    visited[0] = True\n\n    while q:\n        room = q.popleft()\n        for key in rooms[room]:\n            if not visited[key]:\n                visited[key] = True\n                q.append(key)\n\n    return all(visited)\n\n\nrooms = [[1, 3], [3, 0, 1], [2], [0]]\nprint(canVisitAllRoomsDFS(rooms))  # False\nprint(canVisitAllRoomsBFS(rooms))  # False\n</code></pre></p> </li> </ul>"},{"location":"content/graph_theory/standard_traversal/#1129-shortest-path-with-alternating-colors","title":"1129. Shortest Path with Alternating Colors","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: breadth first search, graph 1129. Shortest Path with Alternating Colors - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef shortestAlternatingPaths(\n    n: int, redEdges: List[List[int]], blueEdges: List[List[int]]\n) -&gt; List[int]:\n    red_graph = defaultdict(list)\n    blue_graph = defaultdict(list)\n\n    for u, v in redEdges:\n        red_graph[u].append(v)\n    for u, v in blueEdges:\n        blue_graph[u].append(v)\n\n    answer = [-1 for _ in range(n)]\n    q = deque([(0, 0, 0), (0, 0, 1)])  # (node, distance, color)\n    visited = set()\n\n    while q:\n        node, dist, color = q.popleft()\n        if (node, color) in visited:\n            continue\n        visited.add((node, color))\n        if answer[node] == -1:\n            answer[node] = dist\n        if color == 0:\n            for neighbor in blue_graph[node]:\n                q.append((neighbor, dist + 1, 1))\n        else:\n            for neighbor in red_graph[node]:\n                q.append((neighbor, dist + 1, 0))\n\n    return answer\n\n\nn = 3\nred_edges = [[0, 1], [1, 2]]\nblue_edges = []\nprint(shortestAlternatingPaths(n, red_edges, blue_edges))  # [0, 1, -1]\n</code></pre></p> </li> </ul>"},{"location":"content/graph_theory/standard_traversal/#1376-time-needed-to-inform-all-employees","title":"1376. Time Needed to Inform All Employees","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search 1376. Time Needed to Inform All Employees - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# DFS\ndef numOfMinutesDFS(\n    n: int, headID: int, manager: List[int], informTime: List[int]\n) -&gt; int:\n    graph = defaultdict(list)\n    for i in range(n):\n        if manager[i] != -1:\n            graph[manager[i]].append(i)\n\n    def dfs(node):\n        time = 0\n        for sub in graph[node]:\n            time = max(time, dfs(sub))\n        return time + informTime[node]\n\n    return dfs(headID)\n\n\n# BFS\ndef numOfMinutesBFS(\n    n: int, headID: int, manager: List[int], informTime: List[int]\n) -&gt; int:\n    graph = defaultdict(list)\n    for i in range(n):\n        if manager[i] != -1:\n            graph[manager[i]].append(i)\n\n    q = deque([(headID, 0)])\n    max_time = 0\n\n    while q:\n        node, time = q.popleft()\n        max_time = max(max_time, time)\n        for sub in graph[node]:\n            q.append((sub, time + informTime[node]))\n\n    return max_time\n\n\nn = 6\nheadID = 2\nmanager = [2, 2, -1, 2, 2, 2]\ninformTime = [0, 0, 1, 0, 0, 0]\nprint(numOfMinutesDFS(n, headID, manager, informTime))  # 1\nprint(numOfMinutesBFS(n, headID, manager, informTime))  # 1\n</code></pre></p> </li> </ul>"},{"location":"content/graph_theory/standard_traversal/#1466-reorder-routes-to-make-all-paths-lead-to-the-city-zero","title":"1466. Reorder Routes to Make All Paths Lead to the City Zero","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph</p> </li> <li></li> </ul> 1466. Reorder Routes to Make All Paths Lead to the City Zero - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef minReorderBFS(n: int, connections: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append((v, 1))  # go\n        graph[v].append((u, 0))  # come\n\n    changes = 0\n    q = deque([(0, -1)])\n\n    while q:\n        n1, d1 = q.popleft()\n\n        for n2, d2 in graph[n1]:\n            if n2 != d1:\n                changes += d2\n                q.append((n2, n1))\n\n    return changes\n\n\n# DFS\ndef minReorderDFS(n: int, connections: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append((v, 1))  # go\n        graph[v].append((u, 0))  # come\n\n    def dfs(n1, d1):\n        changes = 0\n        for n2, d2 in graph[n1]:\n            if n2 != d1:\n                changes += d2 + dfs(n2, n1)\n        return changes\n\n    return dfs(0, -1)\n\n\nn = 5\nconnections = [[1, 0], [1, 2], [3, 2], [3, 4]]\nprint(minReorderBFS(n, connections))  # 2\nprint(minReorderDFS(n, connections))  # 2\n</code></pre>"},{"location":"content/graph_theory/standard_traversal/#797-all-paths-from-source-to-target","title":"797. All Paths From Source to Target","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: backtracking, depth first search, breadth first search, graph 797. All Paths From Source to Target - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS (Backtracking)\ndef allPathsSourceTargetDFS(graph: List[List[int]]) -&gt; List[List[int]]:\n    res = []\n    n = len(graph)\n\n    def dfs(node, path):\n        if node == n - 1:\n            res.append(path.copy())\n            return None\n\n        for nei in graph[node]:\n            path.append(nei)\n            dfs(nei, path)\n            path.pop()\n\n    dfs(0, [0])\n\n    return res\n\n\n# BFS\ndef allPathsSourceTargetBFS(graph: List[List[int]]) -&gt; List[List[int]]:\n    n = len(graph)\n    res = []\n    q = deque([(0, [0])])\n\n    while q:\n        node, path = q.popleft()\n\n        if node == n - 1:\n            res.append(path)\n\n        for nei in graph[node]:\n            q.append((nei, path + [nei]))\n\n    return res\n\n\ngraph = [[1, 2], [3], [3], []]\nprint(allPathsSourceTargetDFS(graph))  # [[0, 1, 3], [0, 2, 3]]\nprint(allPathsSourceTargetBFS(graph))  # [[0, 1, 3], [0, 2, 3]]\n</code></pre></p> </li> </ul>"},{"location":"content/graph_theory/standard_traversal/#1192-critical-connections-in-a-network","title":"1192. Critical Connections in a Network","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: depth first search, graph, biconnected component 1192. Critical Connections in a Network - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Tarjan\ndef criticalConnections(\n    n: int, connections: List[List[int]]\n) -&gt; List[List[int]]:\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    disc = [-1] * n\n    low = [-1] * n\n    bridges = []\n    time = 0\n\n    def dfs(n1, prev):\n        nonlocal time\n        disc[n1], low[n1] = time, time\n        time += 1\n\n        for n2 in graph[n1]:\n            if n2 == prev:\n                continue\n            if disc[n2] == -1:\n                dfs(n2, n1)\n                low[n1] = min(low[n1], low[n2])\n\n                if low[n2] &gt; disc[n1]:\n                    bridges.append([n1, n2])\n            else:\n                low[n1] = min(low[n1], disc[n2])\n\n    for i in range(n):\n        if disc[i] == -1:\n            dfs(i, -1)\n\n    return bridges\n\n\nn = 4\nconnections = [[0, 1], [1, 2], [2, 0], [1, 3]]\nprint(criticalConnections(n, connections))  # [[1, 3]]\n</code></pre></p> </li> </ul>"},{"location":"content/graph_theory/topological_sort/","title":"Topological Sort","text":""},{"location":"content/graph_theory/topological_sort/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 207. Course Schedule (Medium)</li> <li> 210. Course Schedule II (Medium)</li> <li> 269. Alien Dictionary (Hard) \ud83d\udc51</li> <li> 1203. Sort Items by Groups Respecting Dependencies (Hard)</li> <li> 1857. Largest Color Value in a Directed Graph (Hard)</li> </ul>"},{"location":"content/graph_theory/topological_sort/#207-course-schedule","title":"207. Course Schedule","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort</p> </li> <li>Return true if it is possible to finish all courses, otherwise return false.</li> <li>Dependency relationships imply the topological sort algorithm.</li> <li>Cycle detection</li> <li>Topological Sort</li> <li>DAG (Directed Acyclic Graph)</li> <li>Time complexity: O(V+E)</li> <li>Space complexity: O(V+E)</li> <li>Prerequisites: Indegree (Look at the problem 1557. Minimum Number of Vertices to Reach All Nodes)<ul> <li>Indegree: Number of incoming edges to a vertex</li> </ul> </li> <li>Applications: task scheduling, course scheduling, build systems, dependency resolution, compiler optimization, etc.</li> </ul> <p></p> <p></p> <p>Course to prerequisites mapping</p> <pre><code>flowchart LR\n    0((0)) --&gt; 1((1))\n    0((0)) --&gt; 2((2))\n    1((1)) --&gt; 3((3))\n    3((3)) --&gt; 4((4))\n    1((1)) --&gt; 4((4))</code></pre> <p>Prerequisites to course mapping</p> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    2((2)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))\n    4((4)) --&gt; 3((3))\n    4((4)) --&gt; 1((1))</code></pre> course 0 0 1 1 3 prerequisite 1 2 3 4 4 index 0 1 2 3 4 in-degree 0 0 0 0 0 <p>Initialize</p> <ul> <li>graph</li> </ul> prerequisite 1 2 3 4 course <code>[0]</code> <code>[0]</code> <code>[1]</code> <code>[1, 3]</code> <ul> <li>in-degree</li> </ul> 0 1 2 3 4 in-degree 2 2 0 1 0 <ul> <li>queue: <code>[2, 4]</code></li> <li>pop <code>2</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))\n    4((4)) --&gt; 3((3))\n    4((4)) --&gt; 1((1))</code></pre> 0 1 2 3 4 in-degree 1 2 0 1 0 <ul> <li>queue: <code>[4]</code></li> <li>pop <code>4</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))</code></pre> 0 1 2 3 4 in-degree 1 1 0 0 0 <ul> <li>queue: <code>[3]</code></li> <li>pop <code>3</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))</code></pre> 0 1 2 3 4 in-degree 1 0 0 0 0 <ul> <li>queue: <code>[1]</code></li> <li>pop <code>1</code> from the queue</li> </ul> <pre><code>flowchart LR\n    0((0))</code></pre> 0 1 2 3 4 in-degree 0 0 0 0 0 <ul> <li>queue: <code>[0]</code></li> <li>pop <code>0</code> from the queue</li> <li>All courses are taken. Return <code>True</code>.</li> </ul> 207. Course Schedule - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS (Kahn's Algorithm)\ndef canFinishBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    count = 0\n\n    while q:\n        crs = q.popleft()\n        count += 1\n\n        for nxt in graph[crs]:\n            indegree[nxt] -= 1\n\n            if indegree[nxt] == 0:\n                q.append(nxt)\n\n    return count == numCourses\n\n\n# DFS + Set\ndef canFinishDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for crs, pre in prerequisites:\n        graph[crs].append(pre)\n\n    visiting = set()\n\n    def dfs(crs):\n        if crs in visiting:  # cycle detected\n            return False\n        if graph[crs] == []:\n            return True\n\n        visiting.add(crs)\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        visiting.remove(crs)\n        graph[crs] = []\n\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\n# DFS + List\ndef canFinishDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for pre, crs in prerequisites:\n        graph[crs].append(pre)\n\n    # 0: init, 1: visiting, 2: visited\n    status = [0] * numCourses\n\n    def dfs(crs):\n        if status[crs] == 1:  # cycle detected\n            return False\n        if status[crs] == 2:\n            return True\n\n        status[crs] = 1\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        status[crs] = 2\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(canFinishBFS(5, prerequisites))  # True\nprint(canFinishDFS1(5, prerequisites))  # True\nprint(canFinishDFS2(5, prerequisites))  # True\n</code></pre> 207. Course Schedule - C++ Solution<pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    // BFS\n    bool canFinishBFS(int numCourses, vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        vector&lt;int&gt; indegree(numCourses, 0);\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n            indegree[pre[0]]++;\n        }\n\n        queue&lt;int&gt; q;\n        for (int i = 0; i &lt; numCourses; i++) {\n            if (indegree[i] == 0) {\n                q.push(i);\n            }\n        }\n\n        int cnt = 0;\n        while (!q.empty()) {\n            int cur = q.front();\n            q.pop();\n            cnt++;\n\n            for (int nxt : graph[cur]) {\n                indegree[nxt]--;\n                if (indegree[nxt] == 0) {\n                    q.push(nxt);\n                }\n            }\n        }\n        return cnt == numCourses;\n    }\n\n    // DFS\n    bool canFinishDFS(int numCourses, vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n        }\n        // 0: not visited, 1: visiting, 2: visited\n        vector&lt;int&gt; state(numCourses, 0);\n\n        function&lt;bool(int)&gt; dfs = [&amp;](int pre) -&gt; bool {\n            state[pre] = 1;  // visiting\n            for (int crs : graph[pre]) {\n                if (state[crs] == 1 || (state[crs] == 0 &amp;&amp; dfs(crs))) {\n                    return true;\n                }\n            }\n            state[pre] = 2;  // visited\n            return false;\n        };\n\n        for (int i = 0; i &lt; numCourses; i++) {\n            if (state[i] == 0 &amp;&amp; dfs(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution sol;\n    vector&lt;vector&lt;int&gt;&gt; prerequisites = {{1, 0}, {2, 1}, {3, 2}, {4, 3},\n                                         {5, 4}, {6, 5}, {7, 6}, {8, 7},\n                                         {9, 8}, {10, 9}};\n    int numCourses = 11;\n    cout &lt;&lt; sol.canFinishBFS(numCourses, prerequisites) &lt;&lt; endl;\n    cout &lt;&lt; sol.canFinishDFS(numCourses, prerequisites) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/graph_theory/topological_sort/#210-course-schedule-ii","title":"210. Course Schedule II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort</p> </li> <li>Return the ordering of courses you should take to finish all courses. If there are multiple valid answers, return any of them.</li> </ul> <p></p> 210. Course Schedule II - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# 1. BFS - Kahn's Algorithm\ndef findOrderBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    order = []\n\n    while q:\n        pre = q.popleft()\n        order.append(pre)\n\n        for crs in graph[pre]:\n            indegree[crs] -= 1\n            if indegree[crs] == 0:\n                q.append(crs)\n\n    return order if len(order) == numCourses else []\n\n\n# 2. DFS + Set\ndef findOrderDFS1(\n    numCourses: int, prerequisites: List[List[int]]\n) -&gt; List[int]:\n    adj = defaultdict(list)\n    for crs, pre in prerequisites:\n        adj[crs].append(pre)\n\n    visit, cycle = set(), set()\n    order = []\n\n    def dfs(crs):\n        if crs in cycle:\n            return False\n        if crs in visit:\n            return True\n\n        cycle.add(crs)\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        cycle.remove(crs)\n        visit.add(crs)\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order\n\n\n# 3. DFS + List\ndef findOrderDFS2(\n    numCourses: int, prerequisites: List[List[int]]\n) -&gt; List[int]:\n    adj = defaultdict(list)\n    for pre, crs in prerequisites:\n        adj[crs].append(pre)\n\n    # 0: not visited, 1: visiting, 2: visited\n    state = [0] * numCourses\n    order = []\n\n    def dfs(crs):\n        if state[crs] == 1:\n            return False\n        if state[crs] == 2:\n            return True\n\n        state[crs] = 1\n\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        state[crs] = 2\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order[::-1]\n\n\nnumCourses = 5\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(findOrderBFS(numCourses, prerequisites))  # [2, 4, 3, 1, 0]\nprint(findOrderDFS1(numCourses, prerequisites))  # [4, 3, 1, 2, 0]\nprint(findOrderDFS2(numCourses, prerequisites))  # [4, 3, 2, 1, 0]\n</code></pre> 210. Course Schedule II - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    // BFS\n    vector&lt;int&gt; findOrderBFS(int numCourses,\n                             vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        vector&lt;int&gt; indegree(numCourses, 0);\n\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n            indegree[pre[0]]++;\n        }\n\n        queue&lt;int&gt; q;\n        for (int i = 0; i &lt; numCourses; i++)\n            if (indegree[i] == 0) q.push(i);\n\n        vector&lt;int&gt; order;\n\n        while (!q.empty()) {\n            int cur = q.front();\n            q.pop();\n            order.push_back(cur);\n\n            for (int nxt : graph[cur]) {\n                indegree[nxt]--;\n                if (indegree[nxt] == 0) q.push(nxt);\n            }\n        }\n\n        return (int)order.size() == numCourses ? order : vector&lt;int&gt;{};\n    }\n};\n\nint main() {\n    Solution obj;\n    vector&lt;vector&lt;int&gt;&gt; prerequisites{{1, 0}, {2, 0}, {3, 1}, {3, 2}};\n    vector&lt;int&gt; res = obj.findOrderBFS(4, prerequisites);\n    for (size_t i = 0; i &lt; res.size(); i++) cout &lt;&lt; res[i] &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"content/graph_theory/topological_sort/#269-alien-dictionary","title":"269. Alien Dictionary","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, depth first search, breadth first search, graph, topological sort</p> </li> <li>Return the correct order of characters in the alien language.</li> </ul> 269. Alien Dictionary - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS - Kahn's algorithm (Topological Sort)\ndef alienOrderBFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    indegree = {c: 0 for word in words for c in word}\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                    indegree[w2[j]] += 1\n                break\n\n    q = deque([c for c in indegree if indegree[c] == 0])\n    result = []\n\n    while q:\n        char = q.popleft()\n        result.append(char)\n\n        for neighbor in graph[char]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n\n    return \"\".join(result) if len(result) == len(indegree) else \"\"\n\n\n# DFS - Topological Sort\ndef alienOrderDFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    visited = {}\n    result = []\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                break\n\n    def dfs(c):\n        if c in visited:\n            return visited[c]\n\n        visited[c] = False\n        for neighbor in graph[c]:\n            if not dfs(neighbor):\n                return False\n\n        visited[c] = True\n        result.append(c)\n        return True\n\n    for c in list(graph.keys()):\n        if not dfs(c):\n            return \"\"\n\n    return \"\".join(result[::-1])\n\n\nwords = [\"wrt\", \"wrf\", \"er\", \"ett\", \"rftt\"]\nprint(alienOrderBFS(words))  # wertf\nprint(alienOrderDFS(words))  # wertf\n</code></pre>"},{"location":"content/graph_theory/topological_sort/#1203-sort-items-by-groups-respecting-dependencies","title":"1203. Sort Items by Groups Respecting Dependencies","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort</p> </li> <li>Return any permutation of the items that satisfies the requirements.</li> </ul> 1203. Sort Items by Groups Respecting Dependencies - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS - Kahn's algorithm (Topological Sort)\ndef sortItems(\n    n: int, m: int, group: List[int], beforeItems: List[List[int]]\n) -&gt; List[int]:\n    def topological_sort(graph, indegree, nodes):\n        q = deque([node for node in nodes if indegree[node] == 0])\n        result = []\n\n        while q:\n            node = q.popleft()\n            result.append(node)\n\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    q.append(neighbor)\n\n        return result if len(result) == len(nodes) else []\n\n    groupItems = defaultdict(list)\n    groupGraph = defaultdict(set)\n    groupIndegree = defaultdict(int)\n    itemGraph = defaultdict(set)\n    itemIndegree = defaultdict(int)\n\n    for i in range(n):\n        if group[i] == -1:\n            group[i] = m\n            m += 1\n        groupItems[group[i]].append(i)\n\n    for i, beforeItem in enumerate(beforeItems):\n        for before in beforeItem:\n            if group[before] != group[i]:\n                if group[i] not in groupGraph[group[before]]:\n                    groupGraph[group[before]].add(group[i])\n                    groupIndegree[group[i]] += 1\n            else:\n                itemGraph[before].add(i)\n                itemIndegree[i] += 1\n\n    allGroups = list(set(group))\n    groupOrder = topological_sort(groupGraph, groupIndegree, allGroups)\n    if not groupOrder:\n        return []\n\n    result = []\n    for g in groupOrder:\n        items = groupItems[g]\n        itemOrder = topological_sort(itemGraph, itemIndegree, items)\n        if not itemOrder:\n            return []\n        result.extend(itemOrder)\n\n    return result\n\n\nn = 8\nm = 2\ngroup = [-1, -1, 1, 0, 0, 1, 0, -1]\nbeforeItems = [[], [6], [5], [6], [3, 6], [], [], []]\nprint(sortItems(n, m, group, beforeItems))\n</code></pre>"},{"location":"content/graph_theory/topological_sort/#1857-largest-color-value-in-a-directed-graph","title":"1857. Largest Color Value in a Directed Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, dynamic programming, graph, topological sort, memoization, counting 1857. Largest Color Value in a Directed Graph - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# Topological Sort\ndef largestPathValue(colors: str, edges: List[List[int]]) -&gt; int:\n    n = len(colors)\n    graph = defaultdict(list)\n    indegree = [0 for _ in range(n)]\n\n    for u, v in edges:\n        graph[u].append(v)\n        indegree[v] += 1\n\n    q = deque([i for i in range(n) if indegree[i] == 0])\n\n    dp = [[0] * 26 for _ in range(n)]\n\n    for i in range(n):\n        dp[i][ord(colors[i]) - ord(\"a\")] = 1\n\n    processed, max_color = 0, 0\n\n    while q:\n        n1 = q.popleft()\n        processed += 1\n        max_color = max(max_color, max(dp[n1]))\n\n        for n2 in graph[n1]:\n            indegree[n2] -= 1\n            for i in range(26):\n                dp[n2][i] = max(\n                    dp[n2][i],\n                    dp[n1][i] + (1 if i == ord(colors[n2]) - ord(\"a\") else 0),\n                )\n            if indegree[n2] == 0:\n                q.append(n2)\n\n    return max_color if processed == n else -1\n\n\ncolors = \"abaca\"\nedges = [[0, 1], [0, 2], [2, 3], [3, 4]]\nprint(largestPathValue(colors, edges))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/graph_theory/union_find/","title":"Union Find","text":""},{"location":"content/graph_theory/union_find/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 721. Accounts Merge (Medium)</li> <li> 990. Satisfiability of Equality Equations (Medium)</li> <li> 1061. Lexicographically Smallest Equivalent String (Medium)</li> <li> 839. Similar String Groups (Hard)</li> </ul>"},{"location":"content/graph_theory/union_find/#721-accounts-merge","title":"721. Accounts Merge","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, depth first search, breadth first search, union find, sorting 721. Accounts Merge - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef accountsMerge(accounts: List[List[str]]) -&gt; List[List[str]]:\n    parent = defaultdict(str)\n    rank = defaultdict(int)\n    email_to_name = defaultdict(str)\n    merged_accounts = defaultdict(list)\n\n    def find(n):\n        p = parent[n]\n        while p != parent[p]:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    for account in accounts:\n        name = account[0]\n        first_email = account[1]\n\n        for email in account[1:]:\n            if email not in parent:\n                parent[email] = email\n                rank[email] = 1\n            email_to_name[email] = name\n            union(first_email, email)\n\n    for email in parent:\n        root_email = find(email)\n        merged_accounts[root_email].append(email)\n\n    result = []\n    for root_email, emails in merged_accounts.items():\n        result.append([email_to_name[root_email]] + sorted(emails))\n\n    return result\n\n\naccounts = [\n    [\"John\", \"johnsmith@mail.com\", \"john_newyork@mail.com\"],\n    [\"John\", \"johnsmith@mail.com\", \"john00@mail.com\"],\n    [\"Mary\", \"mary@mail.com\"],\n    [\"John\", \"johnnybravo@mail.com\"],\n]\nprint(accountsMerge(accounts))\n# [['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],\n# ['Mary', 'mary@mail.com'],\n# ['John', 'johnnybravo@mail.com']]\n</code></pre></p> </li> </ul>"},{"location":"content/graph_theory/union_find/#990-satisfiability-of-equality-equations","title":"990. Satisfiability of Equality Equations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, union find, graph 990. Satisfiability of Equality Equations - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef equationsPossible(equations: List[str]) -&gt; bool:\n    parent = defaultdict(str)\n    rank = defaultdict(int)\n\n    def find(n):\n        p = parent[n]\n        while p != parent[p]:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    for equation in equations:\n        if equation[0] not in parent:\n            parent[equation[0]] = equation[0]\n            rank[equation[0]] = 1\n        if equation[3] not in parent:\n            parent[equation[3]] = equation[3]\n            rank[equation[3]] = 1\n\n    for equation in equations:\n        if equation[1] == \"=\":\n            union(equation[0], equation[3])\n\n    for equation in equations:\n        if equation[1] == \"!\":\n            if find(equation[0]) == find(equation[3]):\n                return False\n\n    return True\n\n\nequations = [\"a==b\", \"b!=a\"]\nprint(equationsPossible(equations))  # False\n</code></pre></p> </li> </ul>"},{"location":"content/graph_theory/union_find/#1061-lexicographically-smallest-equivalent-string","title":"1061. Lexicographically Smallest Equivalent String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, union find 1061. Lexicographically Smallest Equivalent String - Python Solution<pre><code># Union Find\ndef smallestEquivalentString(s1: str, s2: str, baseStr: str) -&gt; str:\n    parent = {chr(i): chr(i) for i in range(ord(\"a\"), ord(\"z\") + 1)}\n\n    def find(n):\n        p = parent[n]\n        while parent[p] != p:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            if p1 &lt; p2:\n                parent[p2] = p1\n            else:\n                parent[p1] = p2\n\n    for i in range(len(s1)):\n        union(s1[i], s2[i])\n\n    result = []\n    for c in baseStr:\n        result.append(find(c))\n\n    return \"\".join(result)\n\n\nif __name__ == \"__main__\":\n    s1 = \"parker\"\n    s2 = \"morris\"\n    baseStr = \"parser\"\n    assert smallestEquivalentString(s1, s2, baseStr) == \"makkek\"\n</code></pre></p> </li> </ul>"},{"location":"content/graph_theory/union_find/#839-similar-string-groups","title":"839. Similar String Groups","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, string, depth first search, breadth first search, union find 839. Similar String Groups - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef numSimilarGroups(strs: List[str]) -&gt; int:\n    n = len(strs)\n    parent = list(range(n))\n    rank = [0 for _ in range(n)]\n\n    def find(n):\n        p = parent[n]\n        while parent[p] != p:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    def is_similar(s1, s2):\n        diff = 0\n        for c1, c2 in zip(s1, s2):\n            if c1 != c2:\n                diff += 1\n            if diff &gt; 2:\n                return False\n        return True\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_similar(strs[i], strs[j]):\n                union(i, j)\n\n    return sum(find(i) == i for i in range(n))\n\n\nstrs = [\"tars\", \"rats\", \"arts\", \"star\"]\nprint(numSimilarGroups(strs))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/grind75/","title":"Grind 75","text":""},{"location":"content/grind75/array/","title":"Array","text":""},{"location":"content/grind75/array/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1. Two Sum (Easy)</li> <li> 121. Best Time to Buy and Sell Stock (Easy)</li> <li> 169. Majority Element (Easy)</li> <li> 217. Contains Duplicate (Easy)</li> <li> 57. Insert Interval (Medium)</li> <li> 15. 3Sum (Medium)</li> <li> 238. Product of Array Except Self (Medium)</li> <li> 39. Combination Sum (Medium)</li> <li> 56. Merge Intervals (Medium)</li> <li> 75. Sort Colors (Medium)</li> <li> 11. Container With Most Water (Medium)</li> </ul>"},{"location":"content/grind75/array/#1-two-sum","title":"1. Two Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table</p> </li> <li>Return the indices of the two numbers such that they add up to a specific target.</li> <li>Approach: Use a hashmap to store the indices of the numbers.</li> <li>Time Complexity: O(n)</li> <li>Space Complexity: O(n)</li> </ul> 1. Two Sum - Python Solution<pre><code>from typing import List\n\n\ndef twoSum(nums: List[int], target: int) -&gt; List[int]:\n    hashmap = {}  # val: idx\n\n    for idx, val in enumerate(nums):\n        if (target - val) in hashmap:\n            return [hashmap[target - val], idx]\n\n        hashmap[val] = idx\n\n\nif __name__ == \"__main__\":\n    nums = [2, 7, 11, 15]\n    target = 9\n    assert twoSum(nums, target) == [0, 1]\n</code></pre> 1. Two Sum - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;nums, int target) {\n    unordered_map&lt;int, int&gt; hashmap;\n\n    for (size_t i = 0; i &lt; nums.size(); i++) {\n        int complement = target - nums[i];\n\n        if (hashmap.find(complement) != hashmap.end()) {\n            return {hashmap[complement], (int)i};\n        }\n        hashmap[nums[i]] = (int)i;\n    }\n\n    return {-1, -1};\n}\n\nint main() {\n    vector&lt;int&gt; nums = {2, 7, 11, 15};\n    int target = 9;\n    vector&lt;int&gt; result = twoSum(nums, target);\n    cout &lt;&lt; result[0] &lt;&lt; \", \" &lt;&lt; result[1] &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/grind75/array/#121-best-time-to-buy-and-sell-stock","title":"121. Best Time to Buy and Sell Stock","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li>Return the maximum profit that can be achieved from buying on one day and selling on another day.</li> </ul> 121. Best Time to Buy and Sell Stock - Python Solution<pre><code>from typing import List\n\n\n# Brute Force\ndef maxProfitBF(prices: List[int]) -&gt; int:\n    max_profit = 0\n    n = len(prices)\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_profit = max(max_profit, prices[j] - prices[i])\n\n    return max_profit\n\n\n# DP\ndef maxProfitDP(prices: List[int]) -&gt; int:\n    dp = [[0] * 2 for _ in range(len(prices))]\n    dp[0][0] = -prices[0]  # buy\n    dp[0][1] = 0  # sell\n\n    for i in range(1, len(prices)):\n        dp[i][0] = max(dp[i - 1][0], -prices[i])  # the lowest price to buy\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    max_profit = 0\n    seen_min = prices[0]\n\n    for i in range(1, len(prices)):\n        max_profit = max(max_profit, prices[i] - seen_min)\n        seen_min = min(seen_min, prices[i])\n\n    return max_profit\n\n\n# Fast Slow Pointers\ndef maxProfitFS(prices: List[int]) -&gt; int:\n    max_profit = 0\n    slow, fast = 0, 1\n\n    while fast &lt; len(prices):\n        if prices[fast] &gt; prices[slow]:\n            max_profit = max(max_profit, prices[fast] - prices[slow])\n        else:\n            slow = fast\n        fast += 1\n\n    return max_profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force|  O(n^2)|  O(1)   |\n# | DP         |  O(n)  |  O(n)   |\n# | Greedy     |  O(n)  |  O(1)   |\n# | Fast Slow  |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitBF(prices))  # 5\nprint(maxProfitDP(prices))  # 5\nprint(maxProfitGreedy(prices))  # 5\nprint(maxProfitFS(prices))  # 5\n</code></pre> 121. Best Time to Buy and Sell Stock - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int maxProfit(vector&lt;int&gt; &amp;prices)\n    {\n        if (prices.size() &lt;= 1)\n            return 0;\n\n        int seen_min = prices[0];\n        int res = 0;\n\n        for (int &amp;price : prices)\n        {\n            res = max(res, price - seen_min);\n            seen_min = min(seen_min, price);\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    vector&lt;int&gt; prices = {7, 1, 5, 3, 6, 4};\n    Solution obj;\n    cout &lt;&lt; obj.maxProfit(prices) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/grind75/array/#169-majority-element","title":"169. Majority Element","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, divide and conquer, sorting, counting</p> </li> <li>Return the majority element in an array. The majority element is the element that appears more than <code>n // 2</code> times.</li> </ul> <code>num</code> <code>count</code> <code>res</code> 2 1 2 2 2 2 1 1 2 1 0 2 1 1 1 2 0 1 2 1 2 169. Majority Element - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash Map\ndef majorityElementHashMap(nums: List[int]) -&gt; int:\n    n = len(nums)\n    freq = defaultdict(int)\n\n    for num in nums:\n        freq[num] += 1\n        if freq[num] &gt; n // 2:\n            return num\n\n\n# Array - Boyer-Moore Voting Algorithm\ndef majorityElementArray(nums: List[int]) -&gt; int:\n    res = None\n    count = 0\n\n    for num in nums:\n        if count == 0:\n            res = num\n        count += 1 if num == res else -1\n\n    return res\n\n\n# | Algorithm | Time Complexity | Space Complexity |\n# |-----------|-----------------|------------------|\n# | HashMap   | O(N)            | O(N)             |\n# | Array     | O(N)            | O(1)             |\n# |-----------|-----------------|------------------|\n\n\nnums = [2, 2, 1, 1, 1, 2, 2]\nprint(majorityElementArray(nums))  # 2\nprint(majorityElementHashMap(nums))  # 2\n</code></pre>"},{"location":"content/grind75/array/#217-contains-duplicate","title":"217. Contains Duplicate","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, sorting</p> </li> <li>Return True if the array contains any duplicates, otherwise return False.</li> </ul> 217. Contains Duplicate - Python Solution<pre><code>from typing import List\n\n\n# Brute Force\ndef containsDuplicateBF(nums: List[int]) -&gt; bool:\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] == nums[j]:\n                return True\n\n    return False\n\n\n# Sort\ndef containsDuplicateSort(nums: List[int]) -&gt; bool:\n    nums.sort()\n\n    for i in range(1, len(nums)):\n        if nums[i] == nums[i - 1]:\n            return True\n\n    return False\n\n\n# Set\ndef containsDuplicateSet(nums: List[int]) -&gt; bool:\n    seen = set()\n\n    for i in nums:\n        if i in seen:\n            return True\n        seen.add(i)\n\n    return False\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# | Brute Force |    O(n^2)       |    O(1)      |\n# |     Sort    |    O(n log n)   |    O(1)      |\n# |     Set     |    O(n)         |    O(n)      |\n# |-------------|-----------------|--------------|\n\nprint(containsDuplicateBF([1, 2, 3, 1]))  # True\nprint(containsDuplicateSort([1, 2, 3, 1]))  # True\nprint(containsDuplicateSet([1, 2, 3, 1]))  # True\n</code></pre>"},{"location":"content/grind75/array/#57-insert-interval","title":"57. Insert Interval","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array 57. Insert Interval - Python Solution<pre><code>from typing import List\n\n\n# Interval\ndef insert(\n    intervals: List[List[int]], newInterval: List[int]\n) -&gt; List[List[int]]:\n    n = len(intervals)\n\n    if n == 0:\n        return [newInterval]\n\n    if newInterval[1] &lt; intervals[0][0]:\n        return [newInterval] + intervals\n\n    if newInterval[0] &gt; intervals[-1][1]:\n        return intervals + [newInterval]\n\n    i = 0\n    result = []\n\n    while i &lt; n and intervals[i][1] &lt; newInterval[0]:\n        result.append(intervals[i])\n        i += 1\n\n    while i &lt; n and intervals[i][0] &lt;= newInterval[1]:\n        newInterval[0] = min(newInterval[0], intervals[i][0])\n        newInterval[1] = max(newInterval[1], intervals[i][1])\n        i += 1\n\n    result.append(newInterval)\n\n    while i &lt; n:\n        result.append(intervals[i])\n        i += 1\n\n    return result\n\n\nintervals = [[1, 3], [6, 9]]\nnewInterval = [2, 5]\nprint(insert(intervals, newInterval))  # [[1, 5], [6, 9]]\n</code></pre></p> </li> </ul>"},{"location":"content/grind75/array/#15-3sum","title":"15. 3Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, sorting 15. 3Sum - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef threeSum(nums: List[int]) -&gt; List[List[int]]:\n    nums.sort()\n    res = []\n    n = len(nums)\n\n    for i in range(n - 2):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        left, right = i + 1, n - 1\n\n        while left &lt; right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total &gt; 0:\n                right -= 1\n            elif total &lt; 0:\n                left += 1\n            else:\n                res.append([nums[i], nums[left], nums[right]])\n\n                while left &lt; right and nums[left] == nums[left + 1]:\n                    left += 1\n\n                while left &lt; right and nums[right] == nums[right - 1]:\n                    right -= 1\n\n                left += 1\n                right -= 1\n\n    return res\n\n\nnums = [-1, 0, 1, 2, -1, -4]\nassert threeSum(nums) == [[-1, -1, 2], [-1, 0, 1]]\n</code></pre></p> </li> </ul> 15. 3Sum - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {\n    sort(nums.begin(), nums.end());\n    vector&lt;vector&lt;int&gt;&gt; res;\n    int n = nums.size();\n\n    for (int i = 0; i &lt; n - 2; i++) {\n        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) {\n            continue;\n        }\n\n        int left = i + 1, right = n - 1;\n\n        while (left &lt; right) {\n            int total = nums[i] + nums[left] + nums[right];\n\n            if (total &gt; 0)\n                right--;\n            else if (total &lt; 0)\n                left++;\n            else {\n                res.push_back({nums[i], nums[left], nums[right]});\n                while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++;\n                while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--;\n                left++;\n                right--;\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {-1, 0, 1, 2, -1, -4};\n    vector&lt;vector&lt;int&gt;&gt; res = threeSum(nums);\n    for (auto&amp; v : res) {\n        for (int i : v) {\n            cout &lt;&lt; i &lt;&lt; \" \";\n        }\n        cout &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"content/grind75/array/#238-product-of-array-except-self","title":"238. Product of Array Except Self","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, prefix sum</p> </li> <li>Classic Prefix Sum problem</li> <li>Return an array <code>output</code> such that <code>output[i]</code> is equal to the product of all the elements of <code>nums</code> except <code>nums[i]</code>.</li> </ul> Approach Time Space Prefix O(n) O(n) Prefix (Optimized) O(n) O(1) 238. Product of Array Except Self - Python Solution<pre><code>from typing import List\n\n\n# Prefix\ndef productExceptSelf(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    prefix = [1 for _ in range(n)]\n    suffix = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        prefix[i] = nums[i - 1] * prefix[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        suffix[i] = nums[i + 1] * suffix[i + 1]\n\n    result = [i * j for i, j in zip(prefix, suffix)]\n\n    return result\n\n\n# Prefix (Optimized)\ndef productExceptSelfOptimized(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    result = [1 for _ in range(n)]\n\n    prefix = 1\n    for i in range(n):\n        result[i] = prefix\n        prefix *= nums[i]\n\n    suffix = 1\n    for i in range(n - 1, -1, -1):\n        result[i] *= suffix\n        suffix *= nums[i]\n\n    return result\n\n\nprint(productExceptSelf([1, 2, 3, 4]))\n# [24, 12, 8, 6]\nprint(productExceptSelfOptimized([1, 2, 3, 4]))\n# [24, 12, 8, 6]\n</code></pre> 238. Product of Array Except Self - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\n// Prefix Sum\nclass Solution\n{\npublic:\n    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt; &amp;nums)\n    {\n        int n = nums.size();\n        vector&lt;int&gt; prefix(n, 1);\n        vector&lt;int&gt; suffix(n, 1);\n        vector&lt;int&gt; res(n, 1);\n\n        for (int i = 1; i &lt; n; i++)\n        {\n            prefix[i] = prefix[i - 1] * nums[i - 1];\n        }\n\n        for (int i = n - 2; i &gt;= 0; i--)\n        {\n            suffix[i] = suffix[i + 1] * nums[i + 1];\n        }\n\n        for (int i = 0; i &lt; n; i++)\n        {\n            res[i] = prefix[i] * suffix[i];\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    vector&lt;int&gt; nums = {1, 2, 3, 4};\n    Solution obj;\n    vector&lt;int&gt; result = obj.productExceptSelf(nums);\n\n    for (int i = 0; i &lt; result.size(); i++)\n    {\n        cout &lt;&lt; result[i] &lt;&lt; \"\\n\";\n    }\n    cout &lt;&lt; endl;\n    // 24, 12, 8, 6\n    return 0;\n}\n</code></pre>"},{"location":"content/grind75/array/#39-combination-sum","title":"39. Combination Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking 39. Combination Sum - Python Solution<pre><code>from typing import List\n\n\ndef combinationSum(candidates: List[int], target: int) -&gt; List[List[int]]:\n    n = len(candidates)\n    res, path = [], []\n\n    def dfs(total, start):\n        if total &gt; target:\n            return\n        if total == target:\n            res.append(path.copy())\n            return\n\n        for i in range(start, n):\n            total += candidates[i]\n            path.append(candidates[i])\n            dfs(total, i)\n            total -= candidates[i]\n            path.pop()\n\n    dfs(0, 0)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(combinationSum([2, 3, 5], 8))\n    # [[2, 2, 2, 2], [2, 3, 3], [3, 5]]\n    print(combinationSum([2, 3, 6, 7], 7))\n    # [[2, 2, 3], [7]]\n</code></pre></p> </li> </ul>"},{"location":"content/grind75/array/#56-merge-intervals","title":"56. Merge Intervals","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sorting</p> </li> <li>Merge all overlapping intervals.</li> </ul> 56. Merge Intervals - Python Solution<pre><code>from typing import List\n\n\n# Intervals\ndef merge(intervals: List[List[int]]) -&gt; List[List[int]]:\n    n = len(intervals)\n    if n &lt;= 1:\n        return intervals\n\n    intervals.sort(key=lambda x: x[0])\n    res = [intervals[0]]\n\n    for i in range(1, n):\n        if intervals[i][0] &lt;= res[-1][1]:\n            res[-1][1] = max(res[-1][1], intervals[i][1])\n        else:\n            res.append(intervals[i])\n\n    return res\n\n\nprint(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))\n# [[1, 6], [8, 10], [15, 18]]\n</code></pre> 56. Merge Intervals - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// Interval\nvector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {\n    sort(intervals.begin(), intervals.end());\n    vector&lt;vector&lt;int&gt;&gt; res;\n\n    for (auto&amp; range : intervals) {\n        if (!res.empty() &amp;&amp; range[0] &lt;= res.back()[1]) {\n            res.back()[1] = max(res.back()[1], range[1]);\n        } else {\n            res.emplace_back(range);\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;vector&lt;int&gt;&gt; intervals = {{1, 3}, {2, 6}, {8, 10}, {15, 18}};\n    vector&lt;vector&lt;int&gt;&gt; res = merge(intervals);\n    for (auto&amp; range : res) {\n        cout &lt;&lt; range[0] &lt;&lt; \", \" &lt;&lt; range[1] &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"content/grind75/array/#75-sort-colors","title":"75. Sort Colors","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, sorting 75. Sort Colors - Python Solution<pre><code>from copy import deepcopy\nfrom typing import List\n\n\n# Left Right Pointers\ndef sort_colors_lr_pointers(nums: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    n = len(nums)\n    left = 0\n    for right in range(n):\n        if nums[right] == 0:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n\n    for right in range(left, n):\n        if nums[right] == 1:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n\n\n# Three Pointers\ndef sort_colors_three_pointers(nums: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    cur = 0\n\n    while cur &lt;= right:\n        if nums[cur] == 0:\n            nums[left], nums[cur] = nums[cur], nums[left]\n            left += 1\n            cur += 1\n        elif nums[cur] == 2:\n            nums[right], nums[cur] = nums[cur], nums[right]\n            right -= 1\n        else:\n            cur += 1\n\n\nnums = [2, 0, 2, 1, 1, 0]\nnums1, nums2 = deepcopy(nums), deepcopy(nums)\nsort_colors_lr_pointers(nums1)\nprint(nums1)  # [0, 0, 1, 1, 2, 2]\nsort_colors_three_pointers(nums2)\nprint(nums2)  # [0, 0, 1, 1, 2, 2]\n</code></pre></p> </li> </ul>"},{"location":"content/grind75/array/#11-container-with-most-water","title":"11. Container With Most Water","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy</p> </li> <li>Return the maximum area of water that can be trapped between the vertical lines.</li> </ul> <p></p> 11. Container With Most Water - Python Solution<pre><code>from typing import List\n\n\n# Brute Force\ndef maxAreaBF(height: List[int]) -&gt; int:\n    max_area = 0\n\n    for i in range(len(height)):\n        for j in range(i + 1, len(height)):\n            h = min(height[i], height[j])\n            w = j - i\n            max_area = max(max_area, h * w)\n\n    return max_area\n\n\n# Left Right Pointers\ndef maxAreaLR(height: List[int]) -&gt; int:\n    left, right = 0, len(height) - 1\n    res = 0\n\n    while left &lt; right:\n        h = min(height[left], height[right])\n        w = right - left\n        res = max(res, h * w)\n\n        if height[left] &lt; height[right]:\n            left += 1\n        else:\n            right -= 1\n\n    return res\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force| O(n^2) |  O(1)   |\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nheight = [1, 8, 6, 2, 5, 4, 8, 3, 7]\nprint(maxAreaBF(height))  # 49\nprint(maxAreaLR(height))  # 49\n</code></pre> 11. Container With Most Water - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint maxArea(vector&lt;int&gt;&amp; height) {\n    int left = 0, right = height.size() - 1;\n    int res = 0;\n\n    while (left &lt; right) {\n        int h = min(height[left], height[right]);\n        int w = right - left;\n        res = max(res, h * w);\n\n        if (height[left] &lt; height[right])\n            left++;\n        else\n            right--;\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; height = {1, 8, 6, 2, 5, 4, 8, 3, 7};\n    cout &lt;&lt; maxArea(height) &lt;&lt; endl;  // 49\n    return 0;\n}\n</code></pre>"},{"location":"content/grind75/binary/","title":"Binary","text":""},{"location":"content/grind75/binary/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 67. Add Binary (Easy)</li> </ul>"},{"location":"content/grind75/binary/#67-add-binary","title":"67. Add Binary","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, string, bit manipulation, simulation</p> </li> </ul>"},{"location":"content/grind75/binary_search/","title":"Binary Search","text":""},{"location":"content/grind75/binary_search/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 704. Binary Search (Easy)</li> <li> 278. First Bad Version (Easy)</li> <li> 33. Search in Rotated Sorted Array (Medium)</li> <li> 981. Time Based Key-Value Store (Medium)</li> <li> 1235. Maximum Profit in Job Scheduling (Hard)</li> </ul>"},{"location":"content/grind75/binary_search/#704-binary-search","title":"704. Binary Search","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, binary search</p> </li> <li>Implement binary search algorithm.</li> </ul> 704. Binary Search - Python Solution<pre><code>from typing import List\n\n\n# Binary Search [left, right]\ndef search(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] &lt; target:\n            left = mid + 1\n        elif nums[mid] &gt; target:\n            right = mid - 1\n        else:\n            return mid\n\n    return -1\n\n\n# Binary Search [left, right)\ndef search_half_open(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums)\n\n    while left &lt; right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] &lt; target:\n            left = mid + 1\n        elif nums[mid] &gt; target:\n            right = mid\n        else:\n            return mid\n\n    return -1\n\n\n# Binary Search (left, right)\ndef search_open_interval(nums: List[int], target: int) -&gt; int:\n    left, right = -1, len(nums)\n\n    while left + 1 &lt; right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] &lt; target:\n            left = mid\n        elif nums[mid] &gt; target:\n            right = mid\n        else:\n            return mid\n\n    return -1\n\n\nif __name__ == \"__main__\":\n    nums = [-1, 0, 3, 5, 9, 12]\n    target = 9\n    assert search(nums, target) == 4\n    assert search_half_open(nums, target) == 4\n    assert search_open_interval(nums, target) == 4\n</code></pre>"},{"location":"content/grind75/binary_search/#278-first-bad-version","title":"278. First Bad Version","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: binary search, interactive</p> </li> <li>Find the first bad version given a function <code>isBadVersion</code>.</li> </ul> 278. First Bad Version - Python Solution<pre><code># Binary Search\ndef firstBadVersion(n: int) -&gt; int:\n    left, right = 1, n\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if isBadVersion(mid):\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return left\n\n\ndef isBadVersion(version: int) -&gt; bool:\n    pass\n</code></pre>"},{"location":"content/grind75/binary_search/#33-search-in-rotated-sorted-array","title":"33. Search in Rotated Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search 33. Search in Rotated Sorted Array - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef search(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] == target:\n            return mid\n\n        if nums[left] &lt;= nums[mid]:\n            if nums[left] &lt;= target &lt; nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if nums[mid] &lt; target &lt;= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n    return -1\n\n\nnums = [4, 5, 6, 7, 0, 1, 2]\ntarget = 0\nprint(search(nums, target))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/grind75/binary_search/#981-time-based-key-value-store","title":"981. Time Based Key-Value Store","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, binary search, design 981. Time Based Key-Value Store - Python Solution<pre><code>from collections import defaultdict\n\n\n# Binary Search\nclass TimeMap:\n\n    def __init__(self):\n        self.keys = defaultdict(list)\n        self.times = dict()\n\n    def set(self, key: str, value: str, timestamp: int) -&gt; None:\n        self.keys[key].append(timestamp)\n        self.times[timestamp] = value\n\n    def get(self, key: str, timestamp: int) -&gt; str:\n        tmp = self.keys[key]\n\n        left, right = 0, len(tmp) - 1\n        while left &lt;= right:\n            mid = left + (right - left) // 2\n            if tmp[mid] &gt; timestamp:\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        return self.times[tmp[right]] if right &gt;= 0 else \"\"\n\n\nobj = TimeMap()\nobj.set(\"foo\", \"bar\", 1)\nprint(obj.get(\"foo\", 1))  # bar\nprint(obj.get(\"foo\", 3))  # bar\nobj.set(\"foo\", \"bar2\", 4)\nprint(obj.get(\"foo\", 4))  # bar2\nprint(obj.get(\"foo\", 5))  # bar2\n</code></pre></p> </li> </ul>"},{"location":"content/grind75/binary_search/#1235-maximum-profit-in-job-scheduling","title":"1235. Maximum Profit in Job Scheduling","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, dynamic programming, sorting</p> </li> </ul>"},{"location":"content/grind75/binary_search_tree/","title":"Binary Search Tree","text":""},{"location":"content/grind75/binary_search_tree/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 235. Lowest Common Ancestor of a Binary Search Tree (Medium)</li> <li> 98. Validate Binary Search Tree (Medium)</li> <li> 230. Kth Smallest Element in a BST (Medium)</li> </ul>"},{"location":"content/grind75/binary_search_tree/#235-lowest-common-ancestor-of-a-binary-search-tree","title":"235. Lowest Common Ancestor of a Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree 235. Lowest Common Ancestor of a Binary Search Tree - Python Solution<pre><code>from binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef lowestCommonAncestor(\n    root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n) -&gt; \"TreeNode\":\n    while root:\n        if root.val &gt; p.val and root.val &gt; q.val:\n            root = root.left\n        elif root.val &lt; p.val and root.val &lt; q.val:\n            root = root.right\n        else:\n            return root\n\n\nroot = [6, 2, 8, 0, 4, 7, 9, None, None, 3, 5]\nroot = build(root)\np = root.left\nq = root.right\nprint(root)\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\nprint(lowestCommonAncestor(root, p, q))\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\n</code></pre></p> </li> </ul>"},{"location":"content/grind75/binary_search_tree/#98-validate-binary-search-tree","title":"98. Validate Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree 98. Validate Binary Search Tree - Python Solution<pre><code>from itertools import pairwise\nfrom math import inf\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef isValidBST1(root: Optional[TreeNode]) -&gt; bool:\n    inorder = []  # inorder traversal\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    for a, b in pairwise(inorder):\n        if a &gt;= b:\n            return False\n\n    return True\n\n\ndef isValidBST2(root: Optional[TreeNode]) -&gt; bool:\n    if not root:\n        return True\n    pre = -inf\n\n    def dfs(node):\n        if not node:\n            return True\n        if not dfs(node.left):\n            return False\n\n        nonlocal pre\n        if node.val &lt;= pre:\n            return False\n        pre = node.val\n\n        return dfs(node.right)\n\n    return dfs(root)\n\n\nif __name__ == \"__main__\":\n    root = [5, 1, 4, None, None, 3, 6]\n    root = build(root)\n    print(root)\n    #   5__\n    #  /   \\\n    # 1     4\n    #      / \\\n    #     3   6\n    assert not isValidBST1(root)  # [1, 5, 3, 4, 6]\n    assert not isValidBST2(root)  # [1, 5, 3, 4, 6]\n</code></pre></p> </li> </ul> 98. Validate Binary Search Tree - C++ Solution<pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   private:\n    vector&lt;int&gt; inorder;\n    bool check(vector&lt;int&gt; inorder) {\n        int n = inorder.size();\n        if (n &lt;= 1) return true;\n        for (int i = 1; i &lt; n; i++) {\n            if (inorder[i] &lt;= inorder[i - 1]) return false;\n        }\n        return true;\n    }\n\n   public:\n    bool isValidBST(TreeNode *root) {\n        auto dfs = [&amp;](auto &amp;&amp;self, TreeNode *node) -&gt; void {\n            if (!node) return;\n\n            self(self, node-&gt;left);\n            inorder.push_back(node-&gt;val);\n            self(self, node-&gt;right);\n        };\n\n        dfs(dfs, root);\n\n        return check(inorder);\n    }\n};\n\nint main() {\n    Solution s;\n    TreeNode *root = new TreeNode(2);\n    root-&gt;left = new TreeNode(1);\n    root-&gt;right = new TreeNode(3);\n    assert(s.isValidBST(root) == true);\n\n    root = new TreeNode(5);\n    root-&gt;left = new TreeNode(1);\n    root-&gt;right = new TreeNode(4);\n    root-&gt;right-&gt;left = new TreeNode(3);\n    root-&gt;right-&gt;right = new TreeNode(6);\n    assert(s.isValidBST(root) == false);\n\n    root = new TreeNode(5);\n    root-&gt;left = new TreeNode(4);\n    root-&gt;right = new TreeNode(6);\n    root-&gt;right-&gt;left = new TreeNode(3);\n    root-&gt;right-&gt;right = new TreeNode(7);\n    assert(s.isValidBST(root) == false);\n\n    return 0;\n}\n</code></pre>"},{"location":"content/grind75/binary_search_tree/#230-kth-smallest-element-in-a-bst","title":"230. Kth Smallest Element in a BST","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree 230. Kth Smallest Element in a BST - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef kthSmallestRecursive(root: Optional[TreeNode], k: int) -&gt; int:\n    inorder = []\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n    return inorder[k - 1]\n\n\n# Iteratve\ndef kthSmallestIteratve(root: Optional[TreeNode], k: int) -&gt; int:\n    stack = []\n    while True:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        k -= 1\n        if not k:\n            return root.val\n        root = root.right\n\n\nif __name__ == \"__main__\":\n    root = build([3, 1, 4, None, 2])\n    k = 1\n    assert kthSmallestRecursive(root, k) == 1\n    assert kthSmallestIteratve(root, k) == 1\n</code></pre></p> </li> </ul>"},{"location":"content/grind75/binary_tree/","title":"Binary Tree","text":""},{"location":"content/grind75/binary_tree/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 226. Invert Binary Tree (Easy)</li> <li> 110. Balanced Binary Tree (Easy)</li> <li> 543. Diameter of Binary Tree (Easy)</li> <li> 104. Maximum Depth of Binary Tree (Easy)</li> <li> 102. Binary Tree Level Order Traversal (Medium)</li> <li> 236. Lowest Common Ancestor of a Binary Tree (Medium)</li> <li> 199. Binary Tree Right Side View (Medium)</li> <li> 105. Construct Binary Tree from Preorder and Inorder Traversal (Medium)</li> <li> 297. Serialize and Deserialize Binary Tree (Hard)</li> </ul>"},{"location":"content/grind75/binary_tree/#226-invert-binary-tree","title":"226. Invert Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 226. Invert Binary Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef invertTreeRecursive(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    root.left, root.right = root.right, root.left\n\n    invertTreeRecursive(root.left)\n    invertTreeRecursive(root.right)\n\n    return root\n\n\n# Iterative\ndef invertTreeIterative(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    stack = [root]\n\n    while stack:\n        node = stack.pop()\n\n        node.left, node.right = node.right, node.left\n        if node.left:\n            stack.append(node.left)\n        if node.right:\n            stack.append(node.right)\n\n    return root\n\n\nroot = build([4, 2, 7, 1, 3, 6, 9])\nprint(root)\n#     __4__\n#    /     \\\n#   2       7\n#  / \\     / \\\n# 1   3   6   9\ninvertedRecursive = invertTreeRecursive(root)\nprint(invertedRecursive)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\nroot = build([4, 2, 7, 1, 3, 6, 9])\ninvertedIterative = invertTreeIterative(root)\nprint(invertedIterative)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\n</code></pre></p> </li> </ul>"},{"location":"content/grind75/binary_tree/#110-balanced-binary-tree","title":"110. Balanced Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, binary tree 110. Balanced Binary Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef isBalanced(root: Optional[TreeNode]) -&gt; bool:\n    def getHeight(node):\n        if not node:\n            return 0\n\n        # post order\n        leftHeight = getHeight(node.left)\n        rightHeight = getHeight(node.right)\n\n        if leftHeight == -1 or rightHeight == -1:\n            return -1\n\n        if abs(leftHeight - rightHeight) &gt; 1:\n            return -1\n        else:\n            return 1 + max(leftHeight, rightHeight)\n\n    if getHeight(root) != -1:\n        return True\n    else:\n        return False\n\n\nroot = [3, 9, 20, None, None, 15, 7]\nroot = build(root)\nprint(root)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(isBalanced(root))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/grind75/binary_tree/#543-diameter-of-binary-tree","title":"543. Diameter of Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, binary tree 543. Diameter of Binary Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Tree DFS\nclass Solution:\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -&gt; int:\n        self.diameter = 0\n\n        def dfs(node):\n            if not node:\n                return 0\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n            self.diameter = max(self.diameter, left + right)\n\n            return 1 + max(left, right)\n\n        dfs(root)\n\n        return self.diameter\n\n\nroot = build([1, 2, 3, 4, 5])\nprint(root)\n#     __1\n#    /   \\\n#   2     3\n#  / \\\n# 4   5\nobj = Solution()\nprint(obj.diameterOfBinaryTree(root))  # 3\n</code></pre></p> </li> </ul> 543. Diameter of Binary Tree - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nint diameterOfBinaryTree(TreeNode* root) {\n    int diameter = 0;\n\n    auto dfs = [&amp;](auto&amp;&amp; self, TreeNode* node) -&gt; int {\n        if (!node) return 0;\n        int left = self(self, node-&gt;left);\n        int right = self(self, node-&gt;right);\n\n        diameter = max(diameter, left + right);\n\n        return 1 + max(left, right);\n    };\n\n    dfs(dfs, root);\n    return diameter;\n}\n\nint main() {\n    // [1, 2, 3, 4, 5]\n    TreeNode* root = new TreeNode(1);\n    root-&gt;left = new TreeNode(2);\n    root-&gt;right = new TreeNode(3);\n    root-&gt;left-&gt;left = new TreeNode(4);\n    root-&gt;left-&gt;right = new TreeNode(5);\n    cout &lt;&lt; diameterOfBinaryTree(root) &lt;&lt; endl;  // 3\n\n    return 0;\n}\n</code></pre>"},{"location":"content/grind75/binary_tree/#104-maximum-depth-of-binary-tree","title":"104. Maximum Depth of Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 104. Maximum Depth of Binary Tree - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef maxDepthRecursive(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    left = maxDepthRecursive(root.left)\n    right = maxDepthRecursive(root.right)\n\n    return 1 + max(left, right)\n\n\n# DFS\ndef maxDepthDFS(root: Optional[TreeNode]) -&gt; int:\n    res = 0\n\n    def dfs(node, cnt):\n        if node is None:\n            return\n        cnt += 1\n        nonlocal res\n        res = max(res, cnt)\n\n        dfs(node.left, cnt)\n        dfs(node.right, cnt)\n\n    dfs(root, 0)\n\n    return res\n\n\n# Iterative\ndef maxDepthIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n    res = 0\n\n    while q:\n        res += 1\n        n = len(q)\n\n        for _ in range(n):\n            node = q.popleft()\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    root = [1, 2, 2, 3, 4, None, None, None, None, 5]\n    root = build(root)\n    print(root)\n    #     ____1\n    #    /     \\\n    #   2__     2\n    #  /   \\\n    # 3     4\n    #      /\n    #     5\n    assert maxDepthRecursive(root) == 4\n    assert maxDepthDFS(root) == 4\n    assert maxDepthIterative(root) == 4\n</code></pre></p> </li> </ul>"},{"location":"content/grind75/binary_tree/#102-binary-tree-level-order-traversal","title":"102. Binary Tree Level Order Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, breadth first search, binary tree 102. Binary Tree Level Order Traversal - Python Solution<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef levelOrder(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        level = []\n        size = len(q)\n\n        for _ in range(size):\n            cur = q.popleft()\n            level.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(level)\n\n    return res\n\n\ntree = build([3, 9, 20, None, None, 15, 7])\nprint(tree)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(levelOrder(tree))  # [[3], [9, 20], [15, 7]]\n</code></pre></p> </li> </ul>"},{"location":"content/grind75/binary_tree/#236-lowest-common-ancestor-of-a-binary-tree","title":"236. Lowest Common Ancestor of a Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree 236. Lowest Common Ancestor of a Binary Tree - Python Solution<pre><code>from typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef lowestCommonAncestor(\n    root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n) -&gt; \"TreeNode\":\n    if not root or q == root or p == root:\n        return root\n\n    left = lowestCommonAncestor(root.left, p, q)\n    right = lowestCommonAncestor(root.right, p, q)\n\n    if left and right:\n        return root\n\n    return left or right\n\n\nroot = build([3, 5, 1, 6, 2, 0, 8, None, None, 7, 4])\nprint(root)\n#     ______3__\n#    /         \\\n#   5__         1\n#  /   \\       / \\\n# 6     2     0   8\n#      / \\\n#     7   4\np = root.left  # 5\nq = root.right  # 1\nprint(lowestCommonAncestor(root, p, q))  # 3\n#     ______3__\n#    /         \\\n#   5__         1\n#  /   \\       / \\\n# 6     2     0   8\n#      / \\\n#     7   4\nr = root.left.right.right  # 4\nprint(lowestCommonAncestor(root, p, r))  # 5\n#   5__\n#  /   \\\n# 6     2\n#      / \\\n#     7   4\n</code></pre></p> </li> </ul> 236. Lowest Common Ancestor of a Binary Tree - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   public:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if (root == nullptr || root == p || root == q) {\n            return root;\n        }\n\n        TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);\n        TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);\n\n        if (left &amp;&amp; right) {\n            return root;\n        }\n\n        return left ? left : right;\n    }\n};\n\nint main() { return 0; }\n</code></pre>"},{"location":"content/grind75/binary_tree/#199-binary-tree-right-side-view","title":"199. Binary Tree Right Side View","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 199. Binary Tree Right Side View - Python Solution<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Binary Tree BFS\ndef rightSideViewBFS(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        n = len(q)\n        for i in range(n):\n            node = q.popleft()\n            if i == n - 1:\n                res.append(node.val)\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return res\n\n\n# Binary Tree DFS\ndef rightSideViewDFS(root: Optional[TreeNode]) -&gt; List[int]:\n    \"\"\"\u540e\u5e8f\u904d\u5386\uff0c\u5148\u53f3\u540e\u5de6\uff0c\u9047\u5230\u7684\u7b2c\u4e00\u4e2a\u8282\u70b9\u5c31\u662f\u8be5\u6df1\u5ea6\u7684\u6700\u53f3\u4fa7\u8282\u70b9\"\"\"\n    ans = []\n\n    def dfs(node, depth):\n        if node is None:\n            return\n        if depth == len(ans):  # \u8fd9\u4e2a\u6df1\u5ea6\u9996\u6b21\u9047\u5230\n            ans.append(node.val)\n\n        dfs(node.right, depth + 1)\n        dfs(node.left, depth + 1)\n\n    dfs(root, 0)\n\n    return ans\n\n\nif __name__ == \"__main__\":\n    root = [1, 2, 2, 3, 4, None, 3, None, None, 5]\n    root = build(root)\n    print(root)\n    #     ____1\n    #    /     \\\n    #   2__     2\n    #  /   \\     \\\n    # 3     4     3\n    #      /\n    #     5\n    assert rightSideViewBFS(root) == [1, 2, 3, 5]\n    assert rightSideViewDFS(root) == [1, 2, 3, 5]\n</code></pre></p> </li> </ul>"},{"location":"content/grind75/binary_tree/#105-construct-binary-tree-from-preorder-and-inorder-traversal","title":"105. Construct Binary Tree from Preorder and Inorder Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, divide and conquer, tree, binary tree 105. Construct Binary Tree from Preorder and Inorder Traversal - Python Solution<pre><code>from typing import List, Optional\n\nfrom helper import TreeNode\n\n\ndef buildTree(preorder: List[int], inorder: List[int]) -&gt; Optional[TreeNode]:\n    \"\"\"\n    preorder  root left right  1  2  3\n    inorder   left root right  4  5  6\n    \"\"\"\n    if len(preorder) == 0:\n        return None\n\n    root_val = preorder[0]  # 1\n    root = TreeNode(root_val)\n\n    separator_idx = inorder.index(root_val)  # 5\n\n    left_inorder = inorder[:separator_idx]  # 4\n    right_inorder = inorder[separator_idx + 1 :]  # 6\n\n    left_preorder = preorder[1 : 1 + len(left_inorder)]  # 2\n    right_preorder = preorder[1 + len(left_inorder) :]  # 3\n\n    root.left = buildTree(left_preorder, left_inorder)\n    root.right = buildTree(right_preorder, right_inorder)\n\n    return root\n\n\npreorder = [3, 9, 20, 15, 7]\ninorder = [9, 3, 15, 20, 7]\nroot = buildTree(preorder, inorder)\nprint(root)\n#     3\n#    / \\\n#   9  20\n#     /  \\\n#    15   7\n</code></pre></p> </li> </ul> 105. Construct Binary Tree from Preorder and Inorder Traversal - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   public:\n    vector&lt;int&gt; preorder;\n    unordered_map&lt;int, int&gt; inorderMap;\n\n    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {\n        this-&gt;preorder = preorder;\n        for (size_t i = 0; i &lt; inorder.size(); i++) {\n            inorderMap[inorder[i]] = i;\n        }\n        return buildSubtree(0, 0, inorder.size() - 1);\n    }\n\n   private:\n    TreeNode* buildSubtree(int rootIndex, int left, int right) {\n        if (left &gt; right) return nullptr;\n\n        TreeNode* root = new TreeNode(preorder[rootIndex]);\n        int inorderIndex = inorderMap[preorder[rootIndex]];\n\n        root-&gt;left = buildSubtree(rootIndex + 1, left, inorderIndex - 1);\n        root-&gt;right = buildSubtree(rootIndex + (inorderIndex - left + 1),\n                                   inorderIndex + 1, right);\n\n        return root;\n    }\n};\n\nint main() {\n    vector&lt;int&gt; preorder = {3, 9, 20, 15, 7};\n    vector&lt;int&gt; inorder = {9, 3, 15, 20, 7};\n    Solution solution;\n    TreeNode* root = solution.buildTree(preorder, inorder);\n    cout &lt;&lt; root-&gt;val &lt;&lt; endl;                // 3\n    cout &lt;&lt; root-&gt;left-&gt;val &lt;&lt; endl;          // 9\n    cout &lt;&lt; root-&gt;right-&gt;val &lt;&lt; endl;         // 20\n    cout &lt;&lt; root-&gt;right-&gt;left-&gt;val &lt;&lt; endl;   // 15\n    cout &lt;&lt; root-&gt;right-&gt;right-&gt;val &lt;&lt; endl;  // 7\n    return 0;\n}\n</code></pre>"},{"location":"content/grind75/binary_tree/#297-serialize-and-deserialize-binary-tree","title":"297. Serialize and Deserialize Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, tree, depth first search, breadth first search, design, binary tree 297. Serialize and Deserialize Binary Tree - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BFS\nclass BFS:\n    def serialize(self, root: Optional[TreeNode]) -&gt; str:\n        if not root:\n            return \"\"\n\n        res = []\n        q = deque([root])\n\n        while q:\n            node = q.popleft()\n\n            if node:\n                res.append(str(node.val))\n                q.append(node.left)\n                q.append(node.right)\n            else:\n                res.append(\"null\")\n\n        return \",\".join(res)\n\n    def deserialize(self, data: str) -&gt; Optional[TreeNode]:\n        if not data:\n            return None\n\n        nodes = data.split(\",\")\n        root = TreeNode(int(nodes[0]))\n        q = deque([root])\n        index = 1\n\n        while q:\n            node = q.popleft()\n\n            if nodes[index] != \"null\":\n                node.left = TreeNode(int(nodes[index]))\n                q.append(node.left)\n            index += 1\n\n            if nodes[index] != \"null\":\n                node.right = TreeNode(int(nodes[index]))\n                q.append(node.right)\n            index += 1\n\n        return root\n\n\n# DFS\nclass DFS:\n    def serialize(self, root: Optional[TreeNode]) -&gt; str:\n        def dfs(node):\n            if not node:\n                return [\"null\"]\n            return [str(node.val)] + dfs(node.left) + dfs(node.right)\n\n        return \",\".join(dfs(root))\n\n    def deserialize(self, data: str) -&gt; Optional[TreeNode]:\n        nodes = data.split(\",\")\n        self.index = 0\n\n        def dfs():\n            if nodes[self.index] == \"null\":\n                self.index += 1\n                return None\n\n            node = TreeNode(int(nodes[self.index]))\n            self.index += 1\n\n            node.left = dfs()\n            node.right = dfs()\n\n            return node\n\n        root = dfs()\n        return root\n\n\nroot = build([1, 2, 3, None, None, 4, 5])\nprint(root)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n\nbfs = BFS()\ndata1 = bfs.serialize(root)\nprint(data1)  # \"1,2,3,null,null,4,5,null,null,null,null\"\nroot1 = bfs.deserialize(data1)\nprint(root1)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n\ndfs = DFS()\ndata2 = dfs.serialize(root)\nprint(data2)  # \"1,2,null,null,3,4,null,null,5,null,null\"\nroot2 = dfs.deserialize(data2)\nprint(root2)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n</code></pre></p> </li> </ul>"},{"location":"content/grind75/dynamic_programming/","title":"Dynamic Programming","text":""},{"location":"content/grind75/dynamic_programming/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 70. Climbing Stairs (Easy)</li> <li> 53. Maximum Subarray (Medium)</li> <li> 322. Coin Change (Medium)</li> <li> 416. Partition Equal Subset Sum (Medium)</li> <li> 62. Unique Paths (Medium)</li> </ul>"},{"location":"content/grind75/dynamic_programming/#70-climbing-stairs","title":"70. Climbing Stairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, dynamic programming, memoization</p> </li> <li>Return the number of distinct ways to reach the top of the stairs.</li> <li><code>dp[n]</code> stores the number of distinct ways to reach the <code>n-th</code> stair.</li> <li>Formula: <code>dp[n] = dp[n - 1] + dp[n - 2]</code>.</li> <li>Initialize <code>dp[0] = 0</code>, <code>dp[1] = 1</code>, and <code>dp[2] = 2</code>.</li> </ul> 70. Climbing Stairs - Python Solution<pre><code>from functools import cache\n\n\n# DP\ndef climbStairsDP(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    dp = [i for i in range(n + 1)]\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\n# DP (Optimized)\ndef climbStairsDPOptimized(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    first, second = 1, 2\n\n    for _ in range(3, n + 1):\n        first, second = second, first + second\n\n    return second\n\n\n# Recursion\ndef climbStairsRecursion(n: int) -&gt; int:\n    @cache\n    def dfs(i: int) -&gt; int:\n        if i &lt;= 1:\n            return 1\n        return dfs(i - 1) + dfs(i - 2)\n\n    return dfs(n)\n\n\n# Greedy\ndef climbStairsGreedy(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    p1, p2 = 1, 2\n\n    for _ in range(3, n + 1):\n        p1, p2 = p2, p1 + p2\n\n    return p2\n\n\nif __name__ == \"__main__\":\n    assert climbStairsDP(10) == 89\n    assert climbStairsDPOptimized(10) == 89\n    assert climbStairsRecursion(10) == 89\n    assert climbStairsGreedy(10) == 89\n</code></pre> 70. Climbing Stairs - C++ Solution<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint climbStairs(int n) {\n    if (n &lt;= 2) return n;\n    int f1 = 1, f2 = 2;\n    int res;\n\n    int i = 3;\n    while (i &lt;= n) {\n        res = f1 + f2;\n        f1 = f2;\n        f2 = res;\n        ++i;\n    }\n    return res;\n}\n\nint main() {\n    cout &lt;&lt; climbStairs(2) &lt;&lt; endl;  // 2\n    cout &lt;&lt; climbStairs(3) &lt;&lt; endl;  // 3\n    cout &lt;&lt; climbStairs(6) &lt;&lt; endl;  // 13\n    return 0;\n}\n</code></pre>"},{"location":"content/grind75/dynamic_programming/#53-maximum-subarray","title":"53. Maximum Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, divide and conquer, dynamic programming 53. Maximum Subarray - Python Solution<pre><code>from typing import List\n\n\n# DP Kadane\ndef maxSubArrayDP(nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n\n    dp[0] = nums[0]\n    maxSum = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(\n            dp[i - 1] + nums[i],  # continue the previous subarray\n            nums[i],  # start a new subarray\n        )\n        maxSum = max(maxSum, dp[i])\n\n    return maxSum\n\n\n# Greedy\ndef maxSubArrayGreedy(nums: List[int]) -&gt; int:\n    max_sum = nums[0]\n    cur_sum = 0\n\n    for num in nums:\n        cur_sum = max(cur_sum + num, num)\n        max_sum = max(max_sum, cur_sum)\n\n    return max_sum\n\n\n# Prefix Sum\ndef maxSubArrayPrefixSum(nums: List[int]) -&gt; int:\n    prefix_sum = 0\n    prefix_sum_min = 0\n    res = float(\"-inf\")\n\n    for num in nums:\n        prefix_sum += num\n        res = max(res, prefix_sum - prefix_sum_min)\n        prefix_sum_min = min(prefix_sum_min, prefix_sum)\n\n    return res\n\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArrayDP(nums))  # 6\nprint(maxSubArrayGreedy(nums))  # 6\nprint(maxSubArrayPrefixSum(nums))  # 6\n</code></pre></p> </li> </ul>"},{"location":"content/grind75/dynamic_programming/#322-coin-change","title":"322. Coin Change","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, breadth first search 322. Coin Change - Python Solution<pre><code>from typing import List\n\n\ndef coinChange(coins: List[int], amount: int) -&gt; int:\n    dp = [float(\"inf\") for _ in range(amount + 1)]\n\n    dp[0] = 0\n\n    for i in range(1, amount + 1):\n        for c in coins:\n            if i - c &gt;= 0:\n                dp[i] = min(dp[i], 1 + dp[i - c])\n\n    return dp[amount] if dp[amount] != float(\"inf\") else -1\n\n\ncoins = [1, 2, 5]\namount = 11\nprint(coinChange(coins, amount))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/grind75/dynamic_programming/#416-partition-equal-subset-sum","title":"416. Partition Equal Subset Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming 416. Partition Equal Subset Sum - Python Solution<pre><code>from functools import cache\nfrom typing import List\n\nfrom template import knapsack01\n\n\n# Memoization\ndef canPartitionMemoization(nums: List[int]) -&gt; bool:\n    total = sum(nums)\n    n = len(nums)\n\n    if total % 2 == 1 or n &lt;= 1:\n        return False\n\n    @cache\n    def dfs(i, j):\n        if i &lt; 0:\n            return j == 0\n        return j &gt;= nums[i] and dfs(i - 1, j - nums[i]) or dfs(i - 1, j)\n\n    return dfs(n - 1, total // 2)\n\n\n# DP - Knapsack 01\ndef canPartitionTemplate(nums: List[int]) -&gt; bool:\n    total = sum(nums)\n\n    if total % 2 == 1 or len(nums) &lt; 2:\n        return False\n\n    target = total // 2\n\n    return knapsack01(nums, nums, target) == target\n\n\n# DP - Knapsack 01\ndef canPartition(nums: List[int]) -&gt; bool:\n    total = sum(nums)\n\n    if total % 2 == 1 or len(nums) &lt; 2:\n        return False\n\n    target = total // 2\n\n    dp = [0 for _ in range(target + 1)]\n\n    for i in range(len(nums)):\n        for j in range(target, nums[i] - 1, -1):\n            dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])\n\n    return dp[target] == target\n\n\nif __name__ == \"__main__\":\n    nums = [1, 5, 11, 5]\n    print(canPartitionTemplate(nums))  # True\n    print(canPartition(nums))  # True\n    print(canPartitionMemoization(nums))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/grind75/dynamic_programming/#62-unique-paths","title":"62. Unique Paths","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, combinatorics</p> </li> <li>Count the number of unique paths to reach the bottom-right corner of a <code>m x n</code> grid.</li> </ul> <p></p> 62. Unique Paths - Python Solution<pre><code># DP - 2D\ndef uniquePaths(m: int, n: int) -&gt; int:\n    if m == 1 or n == 1:\n        return 1\n\n    dp = [[1] * n for _ in range(m)]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]\n\n\nprint(uniquePaths(m=3, n=7))  # 28\n# [[1, 1, 1,  1,  1,  1,  1],\n#  [1, 2, 3,  4,  5,  6,  7],\n#  [1, 3, 6, 10, 15, 21, 28]]\n</code></pre> 62. Unique Paths - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint uniquePaths(int m, int n) {\n    vector dp(m, vector&lt;int&gt;(n, 1));\n\n    for (int i = 1; i &lt; m; i++) {\n        for (int j = 1; j &lt; n; j++) {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n\n    return dp[m - 1][n - 1];\n}\n\nint main() {\n    int m = 3, n = 7;\n    cout &lt;&lt; uniquePaths(m, n) &lt;&lt; endl;  // 28\n    return 0;\n}\n</code></pre>"},{"location":"content/grind75/graph/","title":"Graph","text":""},{"location":"content/grind75/graph/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 733. Flood Fill (Easy)</li> <li> 542. 01 Matrix (Medium)</li> <li> 133. Clone Graph (Medium)</li> <li> 207. Course Schedule (Medium)</li> <li> 200. Number of Islands (Medium)</li> <li> 994. Rotting Oranges (Medium)</li> <li> 721. Accounts Merge (Medium)</li> <li> 79. Word Search (Medium)</li> <li> 310. Minimum Height Trees (Medium)</li> <li> 127. Word Ladder (Hard)</li> </ul>"},{"location":"content/grind75/graph/#733-flood-fill","title":"733. Flood Fill","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, matrix</p> </li> <li>Replace all the pixels of the same color starting from the given pixel.</li> <li>In other words, find the connected component of the starting pixel and change the color of all the pixels in that component.</li> <li>Edge cases: If the starting pixel is already the target color, return the image as it is.</li> <li>Flood Fill is essentially a graph traversal algorithm (like BFS or DFS) applied to matrices (2D grids).   It checks adjacent cells (up, down, left, right) of a starting point to determine whether they belong to the same region.   Typically, it involves modifying or marking the cells that belong to the same connected component.</li> </ul> <p></p> <p></p> 1 1 1 1 1 0 1 0 1 1 1 1 1 2 0 1 0 1 1 2 1 2 2 0 1 0 1 2 2 2 2 2 0 2 0 1 733. Flood Fill - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef floodFillDFS(\n    image: List[List[int]], sr: int, sc: int, color: int\n) -&gt; List[List[int]]:\n\n    org = image[sr][sc]\n    m, n = len(image), len(image[0])\n\n    if org == color:\n        return image\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or image[r][c] != org:\n            return None\n\n        image[r][c] = color\n\n        dfs(r - 1, c)\n        dfs(r + 1, c)\n        dfs(r, c - 1)\n        dfs(r, c + 1)\n\n    dfs(sr, sc)\n\n    return image\n\n\n# BFS\ndef floodFillBFS(\n    image: List[List[int]], sr: int, sc: int, color: int\n) -&gt; List[List[int]]:\n\n    org = image[sr][sc]\n    m, n = len(image), len(image[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    if org == color:\n        return image\n\n    q = deque([(sr, sc)])\n\n    while q:\n        r, c = q.popleft()\n        image[r][c] = color\n\n        for dr, dc in dirs:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and image[nr][nc] == org:\n                q.append((nr, nc))\n\n    return image\n\n\nimage = [[1, 1, 1], [1, 1, 0], [1, 0, 1]]\nsr = 1\nsc = 1\n\nprint(floodFillDFS(image, sr, sc, 2))\n# [[2, 2, 2], [2, 2, 0], [2, 0, 1]]\nprint(floodFillBFS(image, sr, sc, 2))\n# [[2, 2, 2], [2, 2, 0], [2, 0, 1]]\n</code></pre>"},{"location":"content/grind75/graph/#542-01-matrix","title":"542. 01 Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, breadth first search, matrix 542. 01 Matrix - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef updateMatrix(mat: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(mat), len(mat[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    q = deque()\n\n    for i in range(m):\n        for j in range(n):\n            if mat[i][j] == 0:\n                dist[i][j] = 0\n                q.append((i, j))\n\n    while q:\n        r, c = q.popleft()\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and dist[nr][nc] &gt; dist[r][c] + 1:\n                dist[nr][nc] = dist[r][c] + 1\n                q.append((nr, nc))\n\n    return dist\n\n\nmat = [[0, 0, 0], [0, 1, 0], [1, 1, 1]]\nprint(updateMatrix(mat))\n# [[0, 0, 0], [0, 1, 0], [1, 2, 1]]\n</code></pre></p> </li> </ul>"},{"location":"content/grind75/graph/#133-clone-graph","title":"133. Clone Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, depth first search, breadth first search, graph 133. Clone Graph - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\n\nclass Node:\n    def __init__(self, val=0, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\n\n# 1. DFS\ndef cloneGraphDFS(node: Optional[\"Node\"]) -&gt; Optional[\"Node\"]:\n    if not node:\n        return None\n\n    cloned = {}  # {old: new}\n\n    def dfs(node):\n        if node in cloned:\n            return cloned[node]\n\n        new = Node(node.val)\n        cloned[node] = new\n\n        for neighbor in node.neighbors:\n            new.neighbors.append(dfs(neighbor))\n\n        return new\n\n    return dfs(node)\n\n\n# 2. BFS\ndef cloneGraphBFS(node: Optional[\"Node\"]) -&gt; Optional[\"Node\"]:\n    if not node:\n        return None\n\n    cloned = {node: Node(node.val)}\n    q = deque([node])\n\n    while q:\n        cur = q.popleft()\n\n        for neighbor in cur.neighbors:\n            if neighbor not in cloned:\n                cloned[neighbor] = Node(neighbor.val)\n                q.append(neighbor)\n\n            cloned[cur].neighbors.append(cloned[neighbor])\n\n    return cloned[node]\n</code></pre></p> </li> </ul>"},{"location":"content/grind75/graph/#207-course-schedule","title":"207. Course Schedule","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort</p> </li> <li>Return true if it is possible to finish all courses, otherwise return false.</li> <li>Dependency relationships imply the topological sort algorithm.</li> <li>Cycle detection</li> <li>Topological Sort</li> <li>DAG (Directed Acyclic Graph)</li> <li>Time complexity: O(V+E)</li> <li>Space complexity: O(V+E)</li> <li>Prerequisites: Indegree (Look at the problem 1557. Minimum Number of Vertices to Reach All Nodes)<ul> <li>Indegree: Number of incoming edges to a vertex</li> </ul> </li> <li>Applications: task scheduling, course scheduling, build systems, dependency resolution, compiler optimization, etc.</li> </ul> <p></p> <p></p> <p>Course to prerequisites mapping</p> <pre><code>flowchart LR\n    0((0)) --&gt; 1((1))\n    0((0)) --&gt; 2((2))\n    1((1)) --&gt; 3((3))\n    3((3)) --&gt; 4((4))\n    1((1)) --&gt; 4((4))</code></pre> <p>Prerequisites to course mapping</p> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    2((2)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))\n    4((4)) --&gt; 3((3))\n    4((4)) --&gt; 1((1))</code></pre> course 0 0 1 1 3 prerequisite 1 2 3 4 4 index 0 1 2 3 4 in-degree 0 0 0 0 0 <p>Initialize</p> <ul> <li>graph</li> </ul> prerequisite 1 2 3 4 course <code>[0]</code> <code>[0]</code> <code>[1]</code> <code>[1, 3]</code> <ul> <li>in-degree</li> </ul> 0 1 2 3 4 in-degree 2 2 0 1 0 <ul> <li>queue: <code>[2, 4]</code></li> <li>pop <code>2</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))\n    4((4)) --&gt; 3((3))\n    4((4)) --&gt; 1((1))</code></pre> 0 1 2 3 4 in-degree 1 2 0 1 0 <ul> <li>queue: <code>[4]</code></li> <li>pop <code>4</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))</code></pre> 0 1 2 3 4 in-degree 1 1 0 0 0 <ul> <li>queue: <code>[3]</code></li> <li>pop <code>3</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))</code></pre> 0 1 2 3 4 in-degree 1 0 0 0 0 <ul> <li>queue: <code>[1]</code></li> <li>pop <code>1</code> from the queue</li> </ul> <pre><code>flowchart LR\n    0((0))</code></pre> 0 1 2 3 4 in-degree 0 0 0 0 0 <ul> <li>queue: <code>[0]</code></li> <li>pop <code>0</code> from the queue</li> <li>All courses are taken. Return <code>True</code>.</li> </ul> 207. Course Schedule - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS (Kahn's Algorithm)\ndef canFinishBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    count = 0\n\n    while q:\n        crs = q.popleft()\n        count += 1\n\n        for nxt in graph[crs]:\n            indegree[nxt] -= 1\n\n            if indegree[nxt] == 0:\n                q.append(nxt)\n\n    return count == numCourses\n\n\n# DFS + Set\ndef canFinishDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for crs, pre in prerequisites:\n        graph[crs].append(pre)\n\n    visiting = set()\n\n    def dfs(crs):\n        if crs in visiting:  # cycle detected\n            return False\n        if graph[crs] == []:\n            return True\n\n        visiting.add(crs)\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        visiting.remove(crs)\n        graph[crs] = []\n\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\n# DFS + List\ndef canFinishDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for pre, crs in prerequisites:\n        graph[crs].append(pre)\n\n    # 0: init, 1: visiting, 2: visited\n    status = [0] * numCourses\n\n    def dfs(crs):\n        if status[crs] == 1:  # cycle detected\n            return False\n        if status[crs] == 2:\n            return True\n\n        status[crs] = 1\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        status[crs] = 2\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(canFinishBFS(5, prerequisites))  # True\nprint(canFinishDFS1(5, prerequisites))  # True\nprint(canFinishDFS2(5, prerequisites))  # True\n</code></pre> 207. Course Schedule - C++ Solution<pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    // BFS\n    bool canFinishBFS(int numCourses, vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        vector&lt;int&gt; indegree(numCourses, 0);\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n            indegree[pre[0]]++;\n        }\n\n        queue&lt;int&gt; q;\n        for (int i = 0; i &lt; numCourses; i++) {\n            if (indegree[i] == 0) {\n                q.push(i);\n            }\n        }\n\n        int cnt = 0;\n        while (!q.empty()) {\n            int cur = q.front();\n            q.pop();\n            cnt++;\n\n            for (int nxt : graph[cur]) {\n                indegree[nxt]--;\n                if (indegree[nxt] == 0) {\n                    q.push(nxt);\n                }\n            }\n        }\n        return cnt == numCourses;\n    }\n\n    // DFS\n    bool canFinishDFS(int numCourses, vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n        }\n        // 0: not visited, 1: visiting, 2: visited\n        vector&lt;int&gt; state(numCourses, 0);\n\n        function&lt;bool(int)&gt; dfs = [&amp;](int pre) -&gt; bool {\n            state[pre] = 1;  // visiting\n            for (int crs : graph[pre]) {\n                if (state[crs] == 1 || (state[crs] == 0 &amp;&amp; dfs(crs))) {\n                    return true;\n                }\n            }\n            state[pre] = 2;  // visited\n            return false;\n        };\n\n        for (int i = 0; i &lt; numCourses; i++) {\n            if (state[i] == 0 &amp;&amp; dfs(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution sol;\n    vector&lt;vector&lt;int&gt;&gt; prerequisites = {{1, 0}, {2, 1}, {3, 2}, {4, 3},\n                                         {5, 4}, {6, 5}, {7, 6}, {8, 7},\n                                         {9, 8}, {10, 9}};\n    int numCourses = 11;\n    cout &lt;&lt; sol.canFinishBFS(numCourses, prerequisites) &lt;&lt; endl;\n    cout &lt;&lt; sol.canFinishDFS(numCourses, prerequisites) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/grind75/graph/#200-number-of-islands","title":"200. Number of Islands","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix</p> </li> <li>Count the number of islands in a 2D grid.</li> <li>Method 1: DFS</li> <li> <p>Method 2: BFS (use a queue to traverse the grid)</p> </li> <li> <p>How to keep track of visited cells?</p> <ol> <li>Mark the visited cell as <code>0</code> (or any other value) to avoid revisiting it.</li> <li>Use a set to store the visited cells.</li> </ol> </li> <li> <p>Steps:</p> <ol> <li>Init: variables</li> <li>DFS/BFS: starting from the cell with <code>1</code>, turn all the connected <code>1</code>s to <code>0</code>.</li> <li>Traverse the grid, and if the cell is <code>1</code>, increment the count and call DFS/BFS.</li> </ol> </li> </ul> <p></p> 200. Number of Islands - Python Solution<pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef numIslandsDFS(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    res = 0\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] != \"1\":\n            return\n\n        grid[r][c] = \"2\"\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                dfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Set\ndef numIslandsBFS1(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == \"0\"\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\" and (r, c) not in visited:\n                visited.add((r, c))\n                bfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = dr + row, dc + col\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] != \"1\"\n                ):\n                    continue\n                grid[nr][nc] = \"2\"\n                q.append((nr, nc))\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == \"1\":\n                grid[i][j] = \"2\"\n                bfs(i, j)\n                res += 1\n\n    return res\n\n\ngrid = [\n    [\"1\", \"1\", \"1\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"0\", \"0\", \"0\", \"0\", \"0\"],\n]\n\nprint(numIslandsDFS(deepcopy(grid)))  # 1\nprint(numIslandsBFS1(deepcopy(grid)))  # 1\nprint(numIslandsBFS2(deepcopy(grid)))  # 1\n</code></pre> 200. Number of Islands - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\nprivate:\n    void dfs(vector&lt;vector&lt;char&gt;&gt; &amp;grid, int r, int c)\n    {\n        int row = grid.size();\n        int col = grid[0].size();\n\n        if (r &lt; 0 || r &gt;= row || c &lt; 0 || c &gt;= col || grid[r][c] != '1')\n        {\n            return;\n        }\n        grid[r][c] = '0';\n\n        dfs(grid, r - 1, c);\n        dfs(grid, r + 1, c);\n        dfs(grid, r, c - 1);\n        dfs(grid, r, c + 1);\n    }\n\npublic:\n    int numIslands(vector&lt;vector&lt;char&gt;&gt; &amp;grid)\n    {\n        int m = grid.size(), n = grid[0].size();\n        int res = 0;\n        for (int i = 0; i &lt; m; i++)\n        {\n            for (int j = 0; j &lt; n; j++)\n            {\n                if (grid[i][j] == '1')\n                {\n                    res++;\n                    dfs(grid, i, j);\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    Solution s;\n    vector&lt;vector&lt;char&gt;&gt; grid = {\n        {'1', '1', '0', '0', '0'},\n        {'1', '1', '0', '0', '0'},\n        {'0', '0', '1', '0', '0'},\n        {'0', '0', '0', '1', '1'}};\n    cout &lt;&lt; s.numIslands(grid) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/grind75/graph/#994-rotting-oranges","title":"994. Rotting Oranges","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, breadth first search, matrix</p> </li> <li>Return the minimum number of minutes that must elapse until no cell has a fresh orange.</li> <li>Hint: Multi-source BFS to count the level.</li> </ul> <p></p> 994. Rotting Oranges - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef orangesRotting(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    fresh = 0\n    q = deque()\n    dirs = [[1, 0], [0, 1], [0, -1], [-1, 0]]\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 2:\n                q.append([i, j])\n            elif grid[i][j] == 1:\n                fresh += 1\n    res = 0\n\n    while q and fresh &gt; 0:\n        size = len(q)\n        for _ in range(size):\n            r, c = q.popleft()\n            for dr, dc in dirs:\n                nr, nc = dr + r, dc + c\n                if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and grid[nr][nc] == 1:\n                    q.append([nr, nc])\n                    grid[nr][nc] = 2\n                    fresh -= 1\n        res += 1\n\n    return res if fresh == 0 else -1\n\n\ngrid = [[2, 1, 1], [1, 1, 0], [0, 1, 1]]\nassert orangesRotting(grid) == 4\n</code></pre>"},{"location":"content/grind75/graph/#721-accounts-merge","title":"721. Accounts Merge","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, depth first search, breadth first search, union find, sorting 721. Accounts Merge - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef accountsMerge(accounts: List[List[str]]) -&gt; List[List[str]]:\n    parent = defaultdict(str)\n    rank = defaultdict(int)\n    email_to_name = defaultdict(str)\n    merged_accounts = defaultdict(list)\n\n    def find(n):\n        p = parent[n]\n        while p != parent[p]:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    for account in accounts:\n        name = account[0]\n        first_email = account[1]\n\n        for email in account[1:]:\n            if email not in parent:\n                parent[email] = email\n                rank[email] = 1\n            email_to_name[email] = name\n            union(first_email, email)\n\n    for email in parent:\n        root_email = find(email)\n        merged_accounts[root_email].append(email)\n\n    result = []\n    for root_email, emails in merged_accounts.items():\n        result.append([email_to_name[root_email]] + sorted(emails))\n\n    return result\n\n\naccounts = [\n    [\"John\", \"johnsmith@mail.com\", \"john_newyork@mail.com\"],\n    [\"John\", \"johnsmith@mail.com\", \"john00@mail.com\"],\n    [\"Mary\", \"mary@mail.com\"],\n    [\"John\", \"johnnybravo@mail.com\"],\n]\nprint(accountsMerge(accounts))\n# [['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],\n# ['Mary', 'mary@mail.com'],\n# ['John', 'johnnybravo@mail.com']]\n</code></pre></p> </li> </ul>"},{"location":"content/grind75/graph/#79-word-search","title":"79. Word Search","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, backtracking, depth first search, matrix 79. Word Search - Python Solution<pre><code>from typing import List\n\n\ndef exist(board: List[List[str]], word: str) -&gt; bool:\n    m, n = len(board), len(board[0])\n    path = set()\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n\n    def dfs(r, c, i):\n        if i == len(word):\n            return True\n\n        if (\n            r &lt; 0\n            or r &gt;= m\n            or c &lt; 0\n            or c &gt;= n\n            or board[r][c] != word[i]\n            or (r, c) in path\n        ):\n            return False\n\n        path.add((r, c))\n\n        for dr, dc in dirs:\n            if dfs(r + dr, c + dc, i + 1):\n                return True\n\n        path.remove((r, c))\n        return False\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, 0):\n                return True\n\n    return False\n\n\nboard = [\n    [\"A\", \"B\", \"C\", \"E\"],\n    [\"S\", \"F\", \"C\", \"S\"],\n    [\"A\", \"D\", \"E\", \"E\"],\n]\nword = \"ABCCED\"\nprint(exist(board, word))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/grind75/graph/#310-minimum-height-trees","title":"310. Minimum Height Trees","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort 310. Minimum Height Trees - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\ndef findMinHeightTrees(n: int, edges: List[List[int]]) -&gt; List[int]:\n    if n == 1:\n        return [0]\n\n    graph = {i: set() for i in range(n)}\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    q = deque([i for i in range(n) if len(graph[i]) == 1])\n    remaining = n\n\n    while remaining &gt; 2:\n        size = len(q)\n        remaining -= size\n\n        for _ in range(size):\n            cur = q.popleft()\n            nei = graph[cur].pop()\n            graph[nei].remove(cur)\n\n            if len(graph[nei]) == 1:\n                q.append(nei)\n\n    return list(q)\n\n\nn = 6\nedges = [[3, 0], [3, 1], [3, 2], [3, 4], [5, 4]]\nprint(findMinHeightTrees(n, edges))  # [3, 4]\n</code></pre></p> </li> </ul>"},{"location":"content/grind75/graph/#127-word-ladder","title":"127. Word Ladder","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, breadth first search</p> </li> <li>The most classic BFS problem.</li> <li>Return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.</li> <li>Approach: BFS</li> <li>Time Complexity: O(n * m^2)</li> <li>Space Complexity: O(n * m)</li> </ul> 127. Word Ladder - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef ladderLength(beginWord: str, endWord: str, wordList: List[str]) -&gt; int:\n    if endWord not in wordList:\n        return 0\n\n    n = len(beginWord)\n    graph = defaultdict(list)  # pattern: words\n    wordList.append(beginWord)\n\n    for word in wordList:\n        for i in range(n):\n            pattern = word[:i] + \"*\" + word[i + 1 :]\n            graph[pattern].append(word)\n\n    visited = set([beginWord])\n    q = deque([beginWord])\n    res = 1\n\n    while q:\n        size = len(q)\n        for _ in range(size):\n            word = q.popleft()\n            if word == endWord:\n                return res\n\n            for i in range(n):\n                pattern = word[:i] + \"*\" + word[i + 1 :]\n                for neighbor in graph[pattern]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        q.append(neighbor)\n        res += 1\n\n    return 0\n\n\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]\nprint(ladderLength(beginWord, endWord, wordList))  # 5\n</code></pre>"},{"location":"content/grind75/hash_table/","title":"Hash Table","text":""},{"location":"content/grind75/hash_table/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 383. Ransom Note (Easy)</li> </ul>"},{"location":"content/grind75/hash_table/#383-ransom-note","title":"383. Ransom Note","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, string, counting</p> </li> <li>Return <code>True</code> if the ransom note can be constructed from the magazines, otherwise, return <code>False</code>.</li> </ul> <pre><code>graph LR\n    A[\"Magazine: abcdef\"] --&gt; C(True)\n    B[\"Ransom Note: abc\"] --&gt; C</code></pre> 383. Ransom Note - Python Solution<pre><code>from collections import Counter, defaultdict\n\n\n# Array\ndef canConstructArray(ransomNote: str, magazine: str) -&gt; bool:\n    if len(ransomNote) &gt; len(magazine):\n        return False\n\n    record = [0 for _ in range(26)]\n\n    for i in magazine:\n        record[ord(i) - ord(\"a\")] += 1\n\n    for j in ransomNote:\n        record[ord(j) - ord(\"a\")] -= 1\n\n    for i in record:\n        if i &lt; 0:\n            return False\n\n    return True\n\n\n# Dict\ndef canConstructDict(ransomNote: str, magazine: str) -&gt; bool:\n    if len(ransomNote) &gt; len(magazine):\n        return False\n\n    record = defaultdict(int)\n\n    for i in magazine:\n        record[i] += 1\n\n    for j in ransomNote:\n        if j not in record or record[j] == 0:\n            return False\n        record[j] -= 1\n\n    return True\n\n\n# Counter\ndef canConstructCounter(ransomNote: str, magazine: str) -&gt; bool:\n    return not Counter(ransomNote) - Counter(magazine)\n\n\nransomNote = \"aa\"\nmagazine = \"aab\"\nprint(canConstructArray(ransomNote, magazine))  # True\nprint(canConstructDict(ransomNote, magazine))  # True\nprint(canConstructCounter(ransomNote, magazine))  # True\n</code></pre>"},{"location":"content/grind75/heap/","title":"Heap","text":""},{"location":"content/grind75/heap/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 973. K Closest Points to Origin (Medium)</li> <li> 621. Task Scheduler (Medium)</li> <li> 295. Find Median from Data Stream (Hard)</li> <li> 23. Merge k Sorted Lists (Hard)</li> </ul>"},{"location":"content/grind75/heap/#973-k-closest-points-to-origin","title":"973. K Closest Points to Origin","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, divide and conquer, geometry, sorting, heap priority queue, quickselect 973. K Closest Points to Origin - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\ndef kClosest(points: List[List[int]], k: int) -&gt; List[List[int]]:\n    heap = []\n\n    for x, y in points:\n        dist = -(x**2 + y**2)  # max heap\n        if len(heap) &lt; k:\n            heapq.heappush(heap, (dist, x, y))\n        else:\n            heapq.heappushpop(heap, (dist, x, y))  # push and pop the smallest\n\n    return [[x, y] for (_, x, y) in heap]\n\n\n# Time complexity: O(n * log(k))\n#   - O(log(k)) for heapify\n#   - O(n) for iterating through the input list\n# Space complexity: O(k)\n\npoints = [[1, 3], [-2, 2]]\nk = 1\nprint(kClosest(points, k))  # [[-2, 2]]\n</code></pre></p> </li> </ul>"},{"location":"content/grind75/heap/#621-task-scheduler","title":"621. Task Scheduler","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, greedy, sorting, heap priority queue, counting 621. Task Scheduler - Python Solution<pre><code>import heapq\nfrom collections import Counter, deque\nfrom typing import List\n\n\n# Heap\ndef leastInterval1(tasks: List[str], n: int) -&gt; int:\n    count = Counter(tasks)\n    heap = [-c for c in count.values()]\n    heapq.heapify(heap)\n\n    time = 0\n\n    q = deque()\n\n    while heap or q:\n        time += 1\n\n        if heap:\n            cnt = 1 + heapq.heappop(heap)\n            if cnt:\n                q.append((cnt, time + n))\n\n        if q and q[0][1] == time:\n            heapq.heappush(heap, q.popleft()[0])\n\n    return time\n\n\ndef leastInterval2(tasks: List[str], n: int) -&gt; int:\n    freq = Counter(tasks)\n\n    maxExec = max(freq.values())\n    maxCount = sum(1 for v in freq.values() if v == maxExec)\n\n    return max((maxExec - 1) * (n + 1) + maxCount, len(tasks))\n\n\ntasks = [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\"]\nn = 2\nprint(leastInterval1(tasks, n))  # 8\nprint(leastInterval2(tasks, n))  # 8\n</code></pre></p> </li> </ul>"},{"location":"content/grind75/heap/#295-find-median-from-data-stream","title":"295. Find Median from Data Stream","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: two pointers, design, sorting, heap priority queue, data stream 295. Find Median from Data Stream - Python Solution<pre><code>from heapq import heappop, heappush\n\n\n# Dual Heaps\nclass MedianFinder:\n\n    def __init__(self):\n        self.minHeap = []\n        self.maxHeap = []\n        self.min_size = 0\n        self.max_size = 0\n\n    def addNum(self, num: int) -&gt; None:\n        heappush(self.maxHeap, -num)\n        heappush(self.minHeap, -heappop(self.maxHeap))\n        self.min_size += 1\n\n        if self.min_size &gt; self.max_size:\n            heappush(self.maxHeap, -heappop(self.minHeap))\n            self.min_size -= 1\n            self.max_size += 1\n\n    def findMedian(self) -&gt; float:\n        if self.min_size == self.max_size:\n            return (-self.maxHeap[0] + self.minHeap[0]) / 2.0\n        return -self.maxHeap[0]\n\n\nobj = MedianFinder()\nobj.addNum(1)\nobj.addNum(2)\nassert obj.findMedian() == 1.5\nobj.addNum(3)\nassert obj.findMedian() == 2\nobj.addNum(4)\nassert obj.findMedian() == 2.5\nobj.addNum(5)\nassert obj.findMedian() == 3\nprint(\"All Passed.\")\n</code></pre></p> </li> </ul> 295. Find Median from Data Stream - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass MedianFinder {\n   private:\n    priority_queue&lt;int&gt; maxHeap;\n    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;\n    int max_size = 0;\n    int min_size = 0;\n\n   public:\n    MedianFinder() {}\n\n    void addNum(int num) {\n        if (min_size == max_size) {\n            minHeap.push(num);\n            maxHeap.push(minHeap.top());\n            minHeap.pop();\n            max_size++;\n        } else {\n            maxHeap.push(num);\n            minHeap.push(maxHeap.top());\n            maxHeap.pop();\n            min_size++;\n        }\n    }\n\n    double findMedian() {\n        if (min_size == max_size) {\n            return (maxHeap.top() + minHeap.top()) / 2.0;\n        } else {\n            return (double)maxHeap.top();\n        }\n    }\n};\n\nint main() {\n    MedianFinder* obj = new MedianFinder();\n    obj-&gt;addNum(1);\n    obj-&gt;addNum(2);\n    cout &lt;&lt; obj-&gt;findMedian() &lt;&lt; endl;  // 1.5\n    obj-&gt;addNum(3);\n    cout &lt;&lt; obj-&gt;findMedian() &lt;&lt; endl;  // 2\n    return 0;\n}\n</code></pre>"},{"location":"content/grind75/heap/#23-merge-k-sorted-lists","title":"23. Merge k Sorted Lists","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: linked list, divide and conquer, heap priority queue, merge sort</p> </li> <li>Prerequisite: 21. Merge Two Sorted Lists</li> <li>Video explanation: 23. Merge K Sorted Lists - NeetCode</li> </ul> 23. Merge k Sorted Lists - Python Solution<pre><code>import copy\nimport heapq\nfrom typing import List, Optional\n\nfrom template import ListNode\n\n\n# Divide and Conquer\ndef mergeKListsDC(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    if not lists or len(lists) == 0:\n        return None\n\n    def mergeTwo(l1, l2):\n        dummy = ListNode()\n        cur = dummy\n\n        while l1 and l2:\n            if l1.val &lt; l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n\n            cur = cur.next\n\n        cur.next = l1 if l1 else l2\n\n        return dummy.next\n\n    while len(lists) &gt; 1:\n        merged = []\n\n        for i in range(0, len(lists), 2):\n            l1 = lists[i]\n            l2 = lists[i + 1] if i + 1 &lt; len(lists) else None\n            merged.append(mergeTwo(l1, l2))\n\n        lists = merged\n\n    return lists[0]\n\n\n# Heap - Merge k Sorted\ndef mergeKLists(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    minHeap = []  # (val, idx, node)\n\n    for idx, head in enumerate(lists):\n        if head:\n            heapq.heappush(minHeap, (head.val, idx, head))\n\n    while minHeap:\n        _, idx, node = heapq.heappop(minHeap)\n        cur.next = node\n        cur = cur.next\n\n        node = node.next\n        if node:\n            heapq.heappush(minHeap, (node.val, idx, node))\n\n    return dummy.next\n\n\nn1 = ListNode.create([1, 4, 5])\nn2 = ListNode.create([1, 3, 4])\nn3 = ListNode.create([2, 6])\nlists = [n1, n2, n3]\nlists1 = copy.deepcopy(lists)\nlists2 = copy.deepcopy(lists)\nprint(mergeKListsDC(lists1))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6\nprint(mergeKLists(lists2))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6\n</code></pre>"},{"location":"content/grind75/linked_list/","title":"Linked List","text":""},{"location":"content/grind75/linked_list/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 21. Merge Two Sorted Lists (Easy)</li> <li> 141. Linked List Cycle (Easy)</li> <li> 206. Reverse Linked List (Easy)</li> <li> 876. Middle of the Linked List (Easy)</li> <li> 146. LRU Cache (Medium)</li> </ul>"},{"location":"content/grind75/linked_list/#21-merge-two-sorted-lists","title":"21. Merge Two Sorted Lists","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: linked list, recursion</p> </li> <li>Merge the two lists into one sorted list.</li> </ul> 21. Merge Two Sorted Lists - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef mergeTwoLists(\n    list1: Optional[ListNode], list2: Optional[ListNode]\n) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    while list1 and list2:\n        if list1.val &lt; list2.val:\n            cur.next = list1\n            list1 = list1.next\n        else:\n            cur.next = list2\n            list2 = list2.next\n        cur = cur.next\n\n    if list1:\n        cur.next = list1\n    elif list2:\n        cur.next = list2\n\n    return dummy.next\n\n\nlist1 = ListNode.create([1, 2, 4])\nlist2 = ListNode.create([1, 3, 4])\nprint(mergeTwoLists(list1, list2))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4\n</code></pre> 21. Merge Two Sorted Lists - C++ Solution<pre><code>struct ListNode {\n    int val;\n    ListNode* next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode* next) : val(x), next(next) {}\n};\n\nclass Solution {\n   public:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        ListNode dummy;\n        ListNode* cur = &amp;dummy;\n\n        while (list1 &amp;&amp; list2) {\n            if (list1-&gt;val &lt; list2-&gt;val) {\n                cur-&gt;next = list1;\n                list1 = list1-&gt;next;\n            } else {\n                cur-&gt;next = list2;\n                list2 = list2-&gt;next;\n            }\n            cur = cur-&gt;next;\n        }\n\n        cur-&gt;next = list1 ? list1 : list2;\n\n        return dummy.next;\n    }\n};\n</code></pre>"},{"location":"content/grind75/linked_list/#141-linked-list-cycle","title":"141. Linked List Cycle","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, linked list, two pointers</p> </li> <li>Determine if a linked list has a cycle in it.</li> </ul> <pre><code>graph LR\n    A((3)) --&gt; B((2))\n    B --&gt; C((0))\n    C --&gt; D((4))</code></pre> <pre><code>graph LR\n    A((3)) --&gt; B((2))\n    B --&gt; C((0))\n    C --&gt; D((4))\n    D --&gt; B</code></pre> 141. Linked List Cycle - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\ndef hasCycle(head: Optional[ListNode]) -&gt; bool:\n    slow, fast = head, head\n\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n        if slow == fast:\n            return True\n\n    return False\n\n\nprint(hasCycle(ListNode.create([3, 2, 0, -4])))  # False\nprint(hasCycle(ListNode.create([3, 2, 0, -4], 1)))  # True\n</code></pre> 141. Linked List Cycle - C++ Solution<pre><code>#include &lt;iostream&gt;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nclass Solution {\n   public:\n    bool hasCycle(ListNode* head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while (fast &amp;&amp; fast-&gt;next) {\n            slow = slow-&gt;next;\n            fast = fast-&gt;next-&gt;next;\n\n            if (fast == slow) return true;\n        }\n        return false;\n    }\n};\n</code></pre>"},{"location":"content/grind75/linked_list/#206-reverse-linked-list","title":"206. Reverse Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: linked list, recursion</p> </li> <li>Reverse a singly linked list.</li> </ul> <pre><code>graph LR\nA((1)) --&gt; B((2))\nB --&gt; C((3))\nC --&gt; D((4))\nD --&gt; E((5))</code></pre> <pre><code>graph RL\nE((5)) --&gt; D((4))\nD --&gt; C((3))\nC --&gt; B((2))\nB --&gt; A((1))</code></pre> 206. Reverse Linked List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Iterative\ndef reverseListIterative(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    cur = head\n    prev = None\n\n    while cur:\n        temp = cur.next\n        cur.next = prev\n\n        prev = cur\n        cur = temp\n\n    return prev\n\n\n# Recursive\ndef reverseListRecursive(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    def reverse(cur, prev):\n        if not cur:\n            return prev\n\n        temp = cur.next\n        cur.next = prev\n\n        return reverse(temp, cur)\n\n    return reverse(head, None)\n\n\nnums = [1, 2, 3, 4, 5]\nhead1 = ListNode.create(nums)\nprint(head1)\n# 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(reverseListIterative(head1))\n# 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1\nhead2 = ListNode.create(nums)\nprint(reverseListRecursive(head2))\n# 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1\n</code></pre>"},{"location":"content/grind75/linked_list/#876-middle-of-the-linked-list","title":"876. Middle of the Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: linked list, two pointers 876. Middle of the Linked List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef middleNode(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    fast, slow = head, head\n\n    while fast and fast.next:\n        fast = fast.next.next\n        slow = slow.next\n\n    return slow\n\n\nprint(middleNode(ListNode.create([1, 2, 3, 4, 5])))\n# 3 -&gt; 4 -&gt; 5\nprint(middleNode(ListNode.create([1, 2, 3, 4, 5, 6])))\n# 4 -&gt; 5 -&gt; 6\n</code></pre></p> </li> </ul>"},{"location":"content/grind75/linked_list/#146-lru-cache","title":"146. LRU Cache","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, linked list, design, doubly linked list</p> </li> <li>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.</li> <li>lru</li> <li></li> </ul> Data structure Description Doubly Linked List To store the key-value pairs. Hash Map To store the key-node pairs. 146. LRU Cache - Python Solution<pre><code>from collections import OrderedDict\n\n\n# Doubly Linked List\nclass Node:\n    def __init__(self, key=0, val=0):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.cache = {}\n        self.head = Node()\n        self.tail = Node()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def add_to_last(self, node):\n        self.tail.prev.next = node\n        node.prev = self.tail.prev\n        node.next = self.tail\n        self.tail.prev = node\n\n    def move_to_last(self, node):\n        self.remove(node)\n        self.add_to_last(node)\n\n    def get(self, key: int) -&gt; int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self.move_to_last(node)\n        return node.val\n\n    def put(self, key: int, value: int) -&gt; None:\n        if key in self.cache:\n            node = self.cache[key]\n            node.val = value\n            self.move_to_last(node)\n            return None\n\n        if len(self.cache) == self.cap:\n            del self.cache[self.head.next.key]\n            self.remove(self.head.next)\n\n        node = Node(key=key, val=value)\n        self.cache[key] = node\n        self.add_to_last(node)\n\n\n# OrderedDict\nclass LRUCacheOrderedDict:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.cap = capacity\n\n    def get(self, key: int):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key, last=True)\n        return self.cache[key]\n\n    def put(self, key: int, value: int):\n        if key in self.cache:\n            self.cache.move_to_end(key, last=True)\n        elif len(self.cache) &gt;= self.cap:\n            self.cache.popitem(last=False)\n\n        self.cache[key] = value\n\n\ncache = LRUCache(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\n\ncache = LRUCacheOrderedDict(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\nprint(\"LRU Cache passed\")\nprint(\"LRU Cache Ordered Dict passed\")\n</code></pre> 146. LRU Cache - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nclass Node {\n   public:\n    int key;\n    int val;\n    Node *prev;\n    Node *next;\n\n    Node(int k = 0, int v = 0) : key(k), val(v), prev(nullptr), next(nullptr) {}\n};\n\nclass LRUCache {\n   private:\n    int cap;\n    unordered_map&lt;int, Node *&gt; cache;\n    Node *head;\n    Node *tail;\n\n    void remove(Node *node) {\n        node-&gt;prev-&gt;next = node-&gt;next;\n        node-&gt;next-&gt;prev = node-&gt;prev;\n    }\n\n    void insert_to_last(Node *node) {\n        tail-&gt;prev-&gt;next = node;\n        node-&gt;prev = tail-&gt;prev;\n        tail-&gt;prev = node;\n        node-&gt;next = tail;\n    }\n\n    void move_to_last(Node *node) {\n        remove(node);\n        insert_to_last(node);\n    }\n\n   public:\n    LRUCache(int capacity) {\n        this-&gt;cap = capacity;\n        head = new Node();\n        tail = new Node();\n        head-&gt;next = tail;\n        tail-&gt;prev = head;\n    }\n\n    int get(int key) {\n        if (cache.find(key) != cache.end()) {\n            Node *node = cache[key];\n            move_to_last(node);\n            return node-&gt;val;\n        }\n        return -1;\n    }\n\n    void put(int key, int value) {\n        if (cache.find(key) != cache.end()) {\n            Node *node = cache[key];\n            node-&gt;val = value;\n            move_to_last(node);\n        } else {\n            Node *newNode = new Node(key, value);\n            cache[key] = newNode;\n            insert_to_last(newNode);\n\n            if ((int)cache.size() &gt; cap) {\n                Node *removed = head-&gt;next;\n                remove(removed);\n                cache.erase(removed-&gt;key);\n                delete removed;\n            }\n        }\n    }\n};\n\nint main() {\n    LRUCache lru(2);\n    lru.put(1, 1);\n    lru.put(2, 2);\n    cout &lt;&lt; lru.get(1) &lt;&lt; endl;  // 1\n    lru.put(3, 3);\n    cout &lt;&lt; lru.get(2) &lt;&lt; endl;  // -1\n    lru.put(4, 4);\n    cout &lt;&lt; lru.get(1) &lt;&lt; endl;  // -1\n    cout &lt;&lt; lru.get(3) &lt;&lt; endl;  // 3\n    cout &lt;&lt; lru.get(4) &lt;&lt; endl;  // 4\n    return 0;\n}\n</code></pre>"},{"location":"content/grind75/matrix/","title":"Matrix","text":""},{"location":"content/grind75/matrix/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 54. Spiral Matrix (Medium)</li> </ul>"},{"location":"content/grind75/matrix/#54-spiral-matrix","title":"54. Spiral Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, matrix, simulation</p> </li> <li>Return all elements of the matrix in spiral order.</li> </ul> 54. Spiral Matrix - Python Solution<pre><code>from typing import List\n\n\n# Array\ndef spiralOrder(matrix: List[List[int]]) -&gt; List[int]:\n    if not matrix or not matrix[0]:\n        return []\n\n    res = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n\n    while top &lt;= bottom and left &lt;= right:\n\n        for i in range(left, right + 1):\n            res.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            res.append(matrix[i][right])\n        right -= 1\n\n        if top &lt;= bottom:\n\n            for i in range(right, left - 1, -1):\n                res.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left &lt;= right:\n\n            for i in range(bottom, top - 1, -1):\n                res.append(matrix[i][left])\n            left += 1\n\n    return res\n\n\n# Math\ndef spiralOrderMath(matrix: List[List[int]]) -&gt; List[int]:\n    dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]]  # Right Down Left Up\n    m, n = len(matrix), len(matrix[0])\n    size = m * n\n    res = []\n    i, j, di = 0, -1, 0\n\n    while len(res) &lt; size:\n        dx, dy = dirs[di]\n        for _ in range(n):\n            i += dx\n            j += dy\n            res.append(matrix[i][j])\n        di = (di + 1) % 4\n        n, m = m - 1, n\n\n    return res\n\n\nprint(spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n# [1, 2, 3, 6, 9, 8, 7, 4, 5]\nprint(spiralOrderMath([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]))\n# [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]\n</code></pre>"},{"location":"content/grind75/recursion/","title":"Recursion","text":""},{"location":"content/grind75/recursion/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 46. Permutations (Medium)</li> <li> 78. Subsets (Medium)</li> <li> 17. Letter Combinations of a Phone Number (Medium)</li> </ul>"},{"location":"content/grind75/recursion/#46-permutations","title":"46. Permutations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking 46. Permutations - Python Solution<pre><code>from typing import List\n\n\n# Backtracking\ndef permute(nums: List[int]) -&gt; List[List[int]]:\n    n = len(nums)\n    path, res = [], []\n    used = [False for _ in range(n)]\n\n    def dfs(x: int):\n        if x == n:\n            res.append(path[:])\n            return\n\n        for i in range(n):\n            if used[i]:\n                continue\n            used[i] = True\n            path.append(nums[i])\n            dfs(x + 1)\n            path.pop()\n            used[i] = False\n\n    dfs(0)\n\n    return res\n\n\nprint(permute([1, 2, 3]))\n# [[1, 2, 3], [1, 3, 2], [2, 1, 3],\n#  [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n</code></pre></p> </li> </ul>"},{"location":"content/grind75/recursion/#78-subsets","title":"78. Subsets","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking, bit manipulation 78. Subsets - Python Solution<pre><code>from typing import List\n\n\n# Iterative Inclusion Backtracking\ndef subsets_iterative_inclusion(nums: List[int]) -&gt; List[List[int]]:\n    n = len(nums)\n    res, path = [], []\n\n    def dfs(i):\n        res.append(path.copy())\n\n        for j in range(i, n):\n            path.append(nums[j])\n            dfs(j + 1)\n            path.pop()\n\n    dfs(0)\n\n    return res\n\n\n# Binary Decision Backtracking\ndef subsets_binary_decision(nums: List[int]) -&gt; List[List[int]]:\n    n = len(nums)\n    res, path = [], []\n\n    def dfs(i):\n        if i == n:\n            res.append(path.copy())\n            return\n\n        # Exclude\n        dfs(i + 1)\n\n        # Include\n        path.append(nums[i])\n        dfs(i + 1)\n        path.pop()\n\n    dfs(0)\n\n    return res\n\n\nprint(subsets_iterative_inclusion([1, 2, 3]))\n# [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]\nprint(subsets_binary_decision([1, 2, 3]))\n# [[], [3], [2], [2, 3], [1], [1, 3], [1, 2], [1, 2, 3]]\n</code></pre></p> </li> </ul>"},{"location":"content/grind75/recursion/#17-letter-combinations-of-a-phone-number","title":"17. Letter Combinations of a Phone Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, backtracking</p> </li> <li>Return all possible letter combinations that the number could represent.</li> </ul> <p></p> 17. Letter Combinations of a Phone Number - Python Solution<pre><code>from typing import List\n\n\n# Backtracking\ndef letterCombinations(digits: str) -&gt; List[str]:\n    letter_map = {\n        \"2\": \"abc\",\n        \"3\": \"def\",\n        \"4\": \"ghi\",\n        \"5\": \"jkl\",\n        \"6\": \"mno\",\n        \"7\": \"pqrs\",\n        \"8\": \"tuv\",\n        \"9\": \"wxyz\",\n    }\n\n    n = len(digits)\n    if n == 0:\n        return []\n\n    res = []\n\n    def dfs(idx, path):\n        if idx == n:\n            res.append(path)\n            return None\n\n        letters = letter_map[digits[idx]]\n\n        for i in range(len(letters)):\n            dfs(idx + 1, path + letters[i])\n\n    dfs(0, \"\")\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert letterCombinations(\"23\") == [\n        \"ad\",\n        \"ae\",\n        \"af\",\n        \"bd\",\n        \"be\",\n        \"bf\",\n        \"cd\",\n        \"ce\",\n        \"cf\",\n    ]\n</code></pre>"},{"location":"content/grind75/stack/","title":"Stack","text":""},{"location":"content/grind75/stack/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 20. Valid Parentheses (Easy)</li> <li> 232. Implement Queue using Stacks (Easy)</li> <li> 150. Evaluate Reverse Polish Notation (Medium)</li> <li> 155. Min Stack (Medium)</li> <li> 42. Trapping Rain Water (Hard)</li> <li> 224. Basic Calculator (Hard)</li> <li> 84. Largest Rectangle in Histogram (Hard)</li> </ul>"},{"location":"content/grind75/stack/#20-valid-parentheses","title":"20. Valid Parentheses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, stack</p> </li> <li>Determine if the input string is valid.</li> <li>Steps for the string <code>()[]{}</code>:</li> </ul> char action stack <code>(</code> push \"(\" <code>)</code> pop \"\" <code>[</code> push \"[\" <code>]</code> pop \"\" <code>{</code> push \"{\" <code>}</code> pop \"\" 20. Valid Parentheses - Python Solution<pre><code># Stack\ndef isValid(s: str) -&gt; bool:\n    hashmap = {\n        \")\": \"(\",\n        \"]\": \"[\",\n        \"}\": \"{\",\n    }\n    stack = []\n\n    for ch in s:\n        if ch in hashmap:\n            if stack and stack[-1] == hashmap[ch]:\n                stack.pop()\n            else:\n                return False\n        else:\n            stack.append(ch)\n\n    return True if not stack else False\n\n\nif __name__ == \"__main__\":\n    assert isValid(\"()[]{}\")\n    assert not isValid(\"(]\")\n    assert not isValid(\"([)]\")\n    assert isValid(\"{[]}\")\n    assert isValid(\"\")\n</code></pre> 20. Valid Parentheses - C++ Solution<pre><code>#include &lt;cassert&gt;\n#include &lt;stack&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool isValid(string s) {\n        unordered_map&lt;char, char&gt; map{{')', '('}, {'}', '{'}, {']', '['}};\n        stack&lt;char&gt; stack;\n        if (s.length() % 2 == 1) return false;\n\n        for (char&amp; ch : s) {\n            if (stack.empty() || map.find(ch) == map.end()) {\n                stack.push(ch);\n            } else {\n                if (map[ch] != stack.top()) {\n                    return false;\n                }\n                stack.pop();\n            }\n        }\n        return stack.empty();\n    }\n};\n\nint main() {\n    Solution s;\n    assert(s.isValid(\"()\") == true);\n    assert(s.isValid(\"()[]{}\") == true);\n    assert(s.isValid(\"(]\") == false);\n    assert(s.isValid(\"([)]\") == false);\n    assert(s.isValid(\"{[]}\") == true);\n    return 0;\n}\n</code></pre>"},{"location":"content/grind75/stack/#232-implement-queue-using-stacks","title":"232. Implement Queue using Stacks","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: stack, design, queue</p> </li> <li>Implement the following operations of a queue using stacks.<ul> <li><code>push(x)</code> - Push element x to the back of queue.</li> <li><code>pop()</code> - Removes the element from in front of queue.</li> <li><code>peek()</code> - Get the front element.</li> <li><code>empty()</code> - Return whether the queue is empty.</li> </ul> </li> </ul> 232. Implement Queue using Stacks - Python Solution<pre><code>class MyQueue:\n    def __init__(self):\n        self.stack_in = []\n        self.stack_out = []\n\n    def push(self, x: int) -&gt; None:\n        self.stack_in.append(x)\n\n    def pop(self) -&gt; int:\n        if self.empty():\n            return None\n\n        if self.stack_out:\n            return self.stack_out.pop()\n        else:\n            for _ in range(len(self.stack_in)):\n                self.stack_out.append(self.stack_in.pop())\n            return self.stack_out.pop()\n\n    def peek(self) -&gt; int:\n        answer = self.pop()\n        self.stack_out.append(answer)\n        return answer\n\n    def empty(self) -&gt; bool:\n        return not (self.stack_in or self.stack_out)\n\n\nobj = MyQueue()\nobj.push(1)\nprint(obj.pop())  # 1\nprint(obj.peek())  # None\nprint(obj.empty())  # False\n</code></pre>"},{"location":"content/grind75/stack/#150-evaluate-reverse-polish-notation","title":"150. Evaluate Reverse Polish Notation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, stack</p> </li> <li>Steps for the list <code>[\"2\", \"1\", \"+\", \"3\", \"*\"]</code>:</li> </ul> token action stack <code>2</code> push <code>[2]</code> <code>1</code> push <code>[2, 1]</code> <code>+</code> pop <code>[3]</code> <code>3</code> push <code>[3, 3]</code> <code>*</code> pop <code>[9]</code> 150. Evaluate Reverse Polish Notation - Python Solution<pre><code>from typing import List\n\n\n# Stack\ndef evalRPN(tokens: List[str]) -&gt; int:\n    stack = []\n\n    for c in tokens:\n        if c == \"+\":\n            stack.append(stack.pop() + stack.pop())\n        elif c == \"-\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(b - a)\n        elif c == \"*\":\n            stack.append(stack.pop() * stack.pop())\n        elif c == \"/\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(int(b / a))\n        else:\n            stack.append(int(c))\n\n    return stack[0]\n\n\nprint(evalRPN([\"2\", \"1\", \"+\", \"3\", \"*\"]))  # 9\nprint(evalRPN([\"4\", \"13\", \"5\", \"/\", \"-\"]))  # 2\nprint(evalRPN([\"18\"]))  # 18\nprint(evalRPN([\"4\", \"3\", \"-\"]))  # 1\n</code></pre>"},{"location":"content/grind75/stack/#155-min-stack","title":"155. Min Stack","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: stack, design</p> </li> <li>Implement a stack that supports push, pop, top, and retrieving the minimum element in constant time.</li> </ul> 155. Min Stack - Python Solution<pre><code># Stack\nclass MinStack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, val: int) -&gt; None:\n        if self.stack:\n            self.stack.append((val, min(val, self.getMin())))\n        else:\n            self.stack.append((val, val))\n\n    def pop(self) -&gt; None:\n        self.stack.pop()\n\n    def top(self) -&gt; int:\n        return self.stack[-1][0]\n\n    def getMin(self) -&gt; int:\n        return self.stack[-1][1]\n\n\nobj = MinStack()\nobj.push(3)\nobj.push(2)\nobj.pop()\nprint(obj.top())  # 3\nprint(obj.getMin())  # 3\n</code></pre> 155. Min Stack - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;climits&gt;\n#include &lt;iostream&gt;\n#include &lt;stack&gt;\n#include &lt;utility&gt;\nusing namespace std;\n\nclass MinStack {\n    stack&lt;pair&lt;int, int&gt;&gt; st;\n\n   public:\n    MinStack() { st.emplace(0, INT_MAX); }\n\n    void push(int val) { st.emplace(val, min(getMin(), val)); }\n\n    void pop() { st.pop(); }\n\n    int top() { return st.top().first; }\n\n    int getMin() { return st.top().second; }\n};\n\nint main() {\n    MinStack minStack;\n    minStack.push(-2);\n    minStack.push(0);\n    minStack.push(-3);\n    cout &lt;&lt; minStack.getMin() &lt;&lt; endl;  // -3\n    minStack.pop();\n    cout &lt;&lt; minStack.top() &lt;&lt; endl;     // 0\n    cout &lt;&lt; minStack.getMin() &lt;&lt; endl;  // -2\n    return 0;\n}\n</code></pre>"},{"location":"content/grind75/stack/#42-trapping-rain-water","title":"42. Trapping Rain Water","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, dynamic programming, stack, monotonic stack</p> </li> <li></li> </ul> Approach Time Space DP O(N) O(N) Left Right O(N) O(1) Monotonic O(N) O(N) 42. Trapping Rain Water - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef trapDP(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    n = len(height)\n    maxLeft, maxRight = [0 for _ in range(n)], [0 for _ in range(n)]\n\n    for i in range(1, n):\n        maxLeft[i] = max(maxLeft[i - 1], height[i - 1])\n\n    for i in range(n - 2, -1, -1):\n        maxRight[i] = max(maxRight[i + 1], height[i + 1])\n\n    res = 0\n    for i in range(n):\n        res += max(0, min(maxLeft[i], maxRight[i]) - height[i])\n\n    return res\n\n\n# Left Right Pointers\ndef trapLR(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    left, right = 0, len(height) - 1\n    maxL, maxR = height[left], height[right]\n    res = 0\n\n    while left &lt; right:\n        if maxL &lt; maxR:\n            left += 1\n            maxL = max(maxL, height[left])\n            res += maxL - height[left]\n        else:\n            right -= 1\n            maxR = max(maxR, height[right])\n            res += maxR - height[right]\n\n    return res\n\n\n# Monotonic Stack\ndef trapStack(height: List[int]) -&gt; int:\n    stack = []\n    total = 0\n\n    for i in range(len(height)):\n        while stack and height[i] &gt; height[stack[-1]]:\n            top = stack.pop()\n            if not stack:\n                break\n            distance = i - stack[-1] - 1\n            bounded_height = min(height[i], height[stack[-1]]) - height[top]\n            total += distance * bounded_height\n        stack.append(i)\n\n    return total\n\n\nheight = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\nprint(trapDP(height))  # 6\nprint(trapLR(height))  # 6\nprint(trapStack(height))  # 6\n</code></pre> 42. Trapping Rain Water - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int trap(vector&lt;int&gt; &amp;height)\n    {\n        if (height.empty())\n            return 0;\n\n        int res = 0;\n        int left = 0, right = height.size() - 1;\n        int maxL = height[left], maxR = height[right];\n\n        while (left &lt; right)\n        {\n            if (maxL &lt; maxR)\n            {\n                left++;\n                maxL = max(maxL, height[left]);\n                res += maxL - height[left];\n            }\n            else\n            {\n                right--;\n                maxR = max(maxR, height[right]);\n                res += maxR - height[right];\n            }\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    vector&lt;int&gt; height = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};\n    Solution solution;\n    cout &lt;&lt; solution.trap(height) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/grind75/stack/#224-basic-calculator","title":"224. Basic Calculator","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, string, stack, recursion 224. Basic Calculator - Python Solution<pre><code># Stack\ndef calculate(s: str) -&gt; int:\n    stack = []\n    result = 0\n    number = 0\n    sign = 1\n\n    for char in s:\n        if char.isdigit():\n            number = number * 10 + int(char)\n\n        elif char == \"+\":\n            result += sign * number\n            number = 0\n            sign = 1\n        elif char == \"-\":\n            result += sign * number\n            number = 0\n            sign = -1\n\n        elif char == \"(\":\n            stack.append(result)\n            stack.append(sign)\n            result = 0\n            sign = 1\n        elif char == \")\":\n            result += sign * number\n            number = 0\n            result *= stack.pop()  # pop sign\n            result += stack.pop()  # pop previous result\n\n    result += sign * number\n\n    return result\n\n\nprint(calculate(\"(1+(4+5+2)-3)+(6+8)\"))  # 23\n</code></pre></p> </li> </ul>"},{"location":"content/grind75/stack/#84-largest-rectangle-in-histogram","title":"84. Largest Rectangle in Histogram","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, stack, monotonic stack 84. Largest Rectangle in Histogram - Python Solution<pre><code>from typing import List\n\n\n# Monotonic Stack\ndef largestRectangleArea(heights: List[int]) -&gt; int:\n    stack = []\n    max_area = 0\n    n = len(heights)\n\n    for i in range(n + 1):\n        h = 0 if i == n else heights[i]\n\n        while stack and h &lt; heights[stack[-1]]:\n            height = heights[stack.pop()]\n            width = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, height * width)\n\n        stack.append(i)\n\n    return max_area\n\n\nprint(largestRectangleArea([2, 1, 5, 6, 2, 3]))  # 10\n</code></pre></p> </li> </ul>"},{"location":"content/grind75/string/","title":"String","text":""},{"location":"content/grind75/string/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 125. Valid Palindrome (Easy)</li> <li> 242. Valid Anagram (Easy)</li> <li> 409. Longest Palindrome (Easy)</li> <li> 3. Longest Substring Without Repeating Characters (Medium)</li> <li> 8. String to Integer (atoi) (Medium)</li> <li> 5. Longest Palindromic Substring (Medium)</li> <li> 438. Find All Anagrams in a String (Medium)</li> <li> 76. Minimum Window Substring (Hard)</li> </ul>"},{"location":"content/grind75/string/#125-valid-palindrome","title":"125. Valid Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string 125. Valid Palindrome - Python Solution<pre><code># List Comprehension\ndef isPalindrome(s: str) -&gt; bool:\n    s = [char.lower() for char in s if char.isalnum()]\n    return s == s[::-1]\n\n\n# Left Right Pointers\ndef isPalindromeLR(s: str) -&gt; bool:\n    left, right = 0, len(s) - 1\n\n    while left &lt; right:\n        while left &lt; right and not s[left].isalnum():\n            left += 1\n        while left &lt; right and not s[right].isalnum():\n            right -= 1\n\n        if s[left].lower() != s[right].lower():\n            return False\n\n        left += 1\n        right -= 1\n\n    return True\n\n\ns = \"A man, a plan, a canal: Panama\"\nprint(isPalindrome(s))  # True\nprint(isPalindromeLR(s))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/grind75/string/#242-valid-anagram","title":"242. Valid Anagram","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, string, sorting</p> </li> <li>Return true if an input string is an anagram of another string.</li> <li>An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once, e.g., <code>listen</code> is an anagram of <code>silent</code>.</li> </ul> 242. Valid Anagram - Python Solution<pre><code>from collections import Counter\n\n\n# Hashmap\ndef isAnagramHash(s: str, t: str) -&gt; bool:\n    \"\"\"Return True if t is an anagram of s, False otherwise.\"\"\"\n    if len(s) != len(t):\n        return False\n\n    count = dict()\n\n    for i in s:\n        if i in count:\n            count[i] += 1\n        else:\n            count[i] = 1\n\n    for j in t:\n        if j in count:\n            count[j] -= 1\n        else:\n            return False\n\n    for count in count.values():\n        if count != 0:\n            return False\n\n    return True\n\n\n# Array\ndef isAnagramArray(s: str, t: str) -&gt; bool:\n    if len(s) != len(t):\n        return False\n\n    count = [0 for _ in range(26)]\n\n    for i in s:\n        count[ord(i) - ord(\"a\")] += 1\n\n    for j in t:\n        count[ord(j) - ord(\"a\")] -= 1\n\n    for i in count:\n        if i != 0:\n            return False\n\n    return True\n\n\n# Counter\ndef isAnagramCounter(s: str, t: str) -&gt; bool:\n    return Counter(s) == Counter(t)\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |   Hashmap   |       O(n)      |     O(1)     |\n# |    Array    |       O(n)      |     O(1)     |\n# |   Counter   |       O(n)      |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\ns = \"anagram\"\nt = \"nagaram\"\nprint(isAnagramHash(s, t))  # True\nprint(isAnagramArray(s, t))  # True\nprint(isAnagramCounter(s, t))  # True\n</code></pre>"},{"location":"content/grind75/string/#409-longest-palindrome","title":"409. Longest Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, string, greedy</p> </li> <li>Return the length of the longest palindrome that can be built with the characters in the string.</li> </ul> 409. Longest Palindrome - Python Solution<pre><code>def longestPalindrome(s: str) -&gt; int:\n    hashmap = dict()\n    result = 0\n\n    for char in s:\n        if char not in hashmap or hashmap[char] == 0:\n            hashmap[char] = 1\n        else:\n            result += 2\n            hashmap[char] = 0\n\n    if any(hashmap.values()):\n        result += 1\n\n    return result\n\n\nprint(longestPalindrome(\"abccccdd\"))  # 7\n</code></pre>"},{"location":"content/grind75/string/#3-longest-substring-without-repeating-characters","title":"3. Longest Substring Without Repeating Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> <li>Classic variable sliding window problem. Use a set to keep track of the characters in the current window.</li> <li>Return the length of the longest substring without repeating characters.</li> <li>Template tutorial by \u7075\u5c71\u8336\u827e\u5e9c</li> </ul> 3. Longest Substring Without Repeating Characters - Python Solution<pre><code>from collections import defaultdict\n\n\n# Sliding Window Variable Max - HashMap\ndef lengthOfLongestSubstringHash(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    left = 0\n    cnt = defaultdict(int)\n    res = 0\n\n    for right in range(n):\n        cnt[s[right]] += 1\n\n        while cnt[s[right]] &gt; 1:\n            cnt[s[left]] -= 1\n            left += 1\n\n        res = max(res, right - left + 1)\n\n    return res\n\n\n# Sliding Window Variable Max - Set\ndef lengthOfLongestSubstringSet(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    left = 0\n    res = 0\n    window = set()\n\n    for right in range(n):\n        while left &lt; right and s[right] in window:\n            window.remove(s[left])\n            left += 1\n        window.add(s[right])\n        res = max(res, right - left + 1)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    s = \"abcabcbb\"\n    assert lengthOfLongestSubstringHash(s) == 3\n    assert lengthOfLongestSubstringSet(s) == 3\n</code></pre> 3. Longest Substring Without Repeating Characters - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;unordered_set&gt;\nusing namespace std;\n\nint lengthOfLongestSubstring(string s) {\n    int n = s.length();\n    int res = 0;\n    int left = 0;\n    unordered_set&lt;char&gt; window;\n\n    for (int right = 0; right &lt; n; right++) {\n        char ch = s[right];\n\n        while (window.find(ch) != window.end()) {\n            window.erase(s[left]);\n            left++;\n        }\n\n        window.insert(ch);\n        res = max(res, right - left + 1);\n    }\n    return (int)res;\n}\n\nint main() {\n    string s = \"abcabcbb\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 3\n    s = \"bbbbb\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 1\n    s = \"pwwkew\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 3\n    return 0;\n}\n</code></pre>"},{"location":"content/grind75/string/#8-string-to-integer-atoi","title":"8. String to Integer (atoi)","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string</p> </li> </ul>"},{"location":"content/grind75/string/#5-longest-palindromic-substring","title":"5. Longest Palindromic Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string, dynamic programming</p> </li> <li>Return the longest palindromic substring in <code>s</code>.</li> </ul> 5. Longest Palindromic Substring - Python Solution<pre><code># DP - Interval\ndef longestPalindromeDP(s: str) -&gt; str:\n    n = len(s)\n    if n &lt;= 1:\n        return s\n\n    start, maxLen = 0, 1\n\n    # Init\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for j in range(1, n):\n        for i in range(j):\n            if s[i] == s[j]:\n                if j - i &lt;= 2:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1]\n\n                if dp[i][j] and j - i + 1 &gt; maxLen:\n                    maxLen = j - i + 1\n                    start = i\n\n    return s[start : start + maxLen]\n\n\n# Expand Around Center\ndef longestPalindromeCenter(s: str) -&gt; str:\n    def expand_around_center(left, right):\n        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n\n    if len(s) &lt;= 1:\n        return s\n\n    start, end = 0, 0\n    for i in range(len(s)):\n        len1 = expand_around_center(i, i)  # odd\n        len2 = expand_around_center(i, i + 1)  # even\n\n        maxLen = max(len1, len2)\n        if maxLen &gt; end - start:\n            start = i - (maxLen - 1) // 2\n            end = i + maxLen // 2\n\n    return s[start : end + 1]\n\n\ns = \"babad\"\nprint(longestPalindromeDP(s))  # \"bab\"\nprint(longestPalindromeCenter(s))  # \"aba\"\n</code></pre>"},{"location":"content/grind75/string/#438-find-all-anagrams-in-a-string","title":"438. Find All Anagrams in a String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window 438. Find All Anagrams in a String - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window Fixed Size\ndef findAnagrams(s: str, p: str) -&gt; List[int]:\n    n, k = len(s), len(p)\n    target = [0 for _ in range(26)]\n    for ch in p:\n        target[ord(ch) - ord(\"a\")] += 1\n\n    count = [0 for _ in range(26)]\n    left = 0\n    res = []\n\n    for right in range(n):\n        count[ord(s[right]) - ord(\"a\")] += 1\n        if right &lt; k - 1:\n            continue\n\n        if count == target:\n            res.append(left)\n\n        count[ord(s[left]) - ord(\"a\")] -= 1\n        left += 1\n\n    return res\n\n\ns = \"cbaebabacd\"\np = \"abc\"\nprint(findAnagrams(s, p))  # [0, 6]\n</code></pre></p> </li> </ul>"},{"location":"content/grind75/string/#76-minimum-window-substring","title":"76. Minimum Window Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, sliding window 76. Minimum Window Substring - Python Solution<pre><code>from collections import Counter\n\n\ndef minWindow(s: str, t: str) -&gt; str:\n    if not t or not s:\n        return \"\"\n\n    counts = Counter(t)\n    required = len(counts)\n\n    left, right = 0, 0\n    formed = 0\n    window_counts = dict()\n\n    result = float(\"inf\"), None, None\n\n    while right &lt; len(s):\n        char = s[right]\n        window_counts[char] = window_counts.get(char, 0) + 1\n        if char in counts and window_counts[char] == counts[char]:\n            formed += 1\n\n        while left &lt;= right and formed == required:\n            char = s[left]\n            if right - left + 1 &lt; result[0]:\n                result = (right - left + 1, left, right)\n            window_counts[char] -= 1\n            if char in counts and window_counts[char] &lt; counts[char]:\n                formed -= 1\n            left += 1\n\n        right += 1\n\n    return \"\" if result[0] == float(\"inf\") else s[result[1] : result[2] + 1]\n\n\ns = \"ADOBECODEBANC\"\nt = \"ABC\"\nprint(minWindow(s, t))  # BANC\n</code></pre></p> </li> </ul>"},{"location":"content/grind75/trie/","title":"Trie","text":""},{"location":"content/grind75/trie/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 208. Implement Trie (Prefix Tree) (Medium)</li> <li> 139. Word Break (Medium)</li> </ul>"},{"location":"content/grind75/trie/#208-implement-trie-prefix-tree","title":"208. Implement Trie (Prefix Tree)","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, design, trie</p> </li> </ul>"},{"location":"content/grind75/trie/#trie_1","title":"Trie","text":"<ul> <li>A trie is a tree-like data structure whose nodes store the letters of an alphabet.</li> </ul> <pre><code>flowchart TD\nRoot(( ))\nRoot --- C1((\"C\"))\nRoot --- D((D))\nC1 --- A1((\"A\"))\nA1 --- T1((\"T\"))\nA1 --- R1((\"R\"))\nA1 --- N((N))\nRoot --- B1((B))\nB1 --- A2((A))\nA2 --- T2((T))\nA2 --- R2((R))</code></pre> 208. Implement Trie (Prefix Tree) - Python Solution<pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.endOfWord = None\n\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.endOfWord = True\n\n    def search(self, word: str) -&gt; bool:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return node.endOfWord\n\n    def startsWith(self, prefix: str) -&gt; bool:\n        node = self.root\n\n        for c in prefix:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return True\n\n\n# Your Trie object will be instantiated and called as such:\nobj = Trie()\nobj.insert(\"apple\")\nprint(obj.search(\"word\"))  # False\nprint(obj.startsWith(\"app\"))  # True\n</code></pre>"},{"location":"content/grind75/trie/#139-word-break","title":"139. Word Break","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, dynamic programming, trie, memoization 139. Word Break - Python Solution<pre><code>from typing import List\n\n\n# DP (Unbounded Knapsack)\ndef wordBreak(s: str, wordDict: List[str]) -&gt; bool:\n    n = len(s)\n    dp = [False for _ in range(n + 1)]\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for word in wordDict:\n            m = len(word)\n            if s[i - m : i] == word and dp[i - m]:\n                dp[i] = True\n    return dp[-1]\n\n\ns = \"leetcode\"\nwordDict = [\"leet\", \"code\"]\nprint(wordBreak(s, wordDict))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/","title":"Interview 150","text":""},{"location":"content/interview150/1d_dynamic_programming/","title":"1D Dynamic Programming","text":""},{"location":"content/interview150/1d_dynamic_programming/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 70. Climbing Stairs (Easy)</li> <li> 198. House Robber (Medium)</li> <li> 139. Word Break (Medium)</li> <li> 322. Coin Change (Medium)</li> <li> 300. Longest Increasing Subsequence (Medium)</li> </ul>"},{"location":"content/interview150/1d_dynamic_programming/#70-climbing-stairs","title":"70. Climbing Stairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, dynamic programming, memoization</p> </li> <li>Return the number of distinct ways to reach the top of the stairs.</li> <li><code>dp[n]</code> stores the number of distinct ways to reach the <code>n-th</code> stair.</li> <li>Formula: <code>dp[n] = dp[n - 1] + dp[n - 2]</code>.</li> <li>Initialize <code>dp[0] = 0</code>, <code>dp[1] = 1</code>, and <code>dp[2] = 2</code>.</li> </ul> 70. Climbing Stairs - Python Solution<pre><code>from functools import cache\n\n\n# DP\ndef climbStairsDP(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    dp = [i for i in range(n + 1)]\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\n# DP (Optimized)\ndef climbStairsDPOptimized(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    first, second = 1, 2\n\n    for _ in range(3, n + 1):\n        first, second = second, first + second\n\n    return second\n\n\n# Recursion\ndef climbStairsRecursion(n: int) -&gt; int:\n    @cache\n    def dfs(i: int) -&gt; int:\n        if i &lt;= 1:\n            return 1\n        return dfs(i - 1) + dfs(i - 2)\n\n    return dfs(n)\n\n\n# Greedy\ndef climbStairsGreedy(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    p1, p2 = 1, 2\n\n    for _ in range(3, n + 1):\n        p1, p2 = p2, p1 + p2\n\n    return p2\n\n\nif __name__ == \"__main__\":\n    assert climbStairsDP(10) == 89\n    assert climbStairsDPOptimized(10) == 89\n    assert climbStairsRecursion(10) == 89\n    assert climbStairsGreedy(10) == 89\n</code></pre> 70. Climbing Stairs - C++ Solution<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint climbStairs(int n) {\n    if (n &lt;= 2) return n;\n    int f1 = 1, f2 = 2;\n    int res;\n\n    int i = 3;\n    while (i &lt;= n) {\n        res = f1 + f2;\n        f1 = f2;\n        f2 = res;\n        ++i;\n    }\n    return res;\n}\n\nint main() {\n    cout &lt;&lt; climbStairs(2) &lt;&lt; endl;  // 2\n    cout &lt;&lt; climbStairs(3) &lt;&lt; endl;  // 3\n    cout &lt;&lt; climbStairs(6) &lt;&lt; endl;  // 13\n    return 0;\n}\n</code></pre>"},{"location":"content/interview150/1d_dynamic_programming/#198-house-robber","title":"198. House Robber","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li> <p>Return the maximum amount of money that can be robbed from the houses. No two adjacent houses can be robbed.</p> </li> <li> <p><code>dp[n]</code> stores the maximum amount of money that can be robbed from the first <code>n</code> houses.</p> </li> <li>Formula: <code>dp[n] = max(dp[n - 1], dp[n - 2] + nums[n])</code>.<ul> <li>Skip: <code>dp[n]</code> \u2192 <code>dp[n - 1]</code></li> <li>Rob: <code>dp[n]</code> \u2192 <code>dp[n - 2] + nums[n]</code></li> </ul> </li> <li>Initialize <code>dp[0] = nums[0]</code> and <code>dp[1] = max(nums[0], nums[1])</code>.</li> <li>Return <code>dp[-1]</code>.</li> <li>Example: <code>nums = [2, 7, 9, 3, 1]</code></li> </ul> n <code>nums[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n-2] + nums[n]</code> <code>dp[n]</code> 0 2 - 2 - 2 1 7 - 7 - 7 2 9 2 7 11 11 3 3 7 11 10 11 4 1 11 11 12 12 198. House Robber - Python Solution<pre><code>from typing import List\n\n\n# DP (House Robber)\ndef rob1(nums: List[int]) -&gt; int:\n    if len(nums) &lt; 3:\n        return max(nums)\n\n    dp = [0 for _ in range(len(nums))]\n    dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n    for i in range(2, len(nums)):\n        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n    return dp[-1]\n\n\n# DP (House Robber) Optimized\ndef rob2(nums: List[int]) -&gt; int:\n    f0, f1 = 0, 0\n\n    for num in nums:\n        f0, f1 = f1, max(f1, f0 + num)\n\n    return f1\n\n\nnums = [2, 7, 9, 3, 1]\nprint(rob1(nums))  # 12\nprint(rob2(nums))  # 12\n</code></pre> 198. House Robber - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint rob(vector&lt;int&gt; &amp;nums) {\n    int prev = 0, cur = 0, temp = 0;\n\n    for (int num : nums) {\n        temp = cur;\n        cur = max(cur, prev + num);\n        prev = temp;\n    }\n    return cur;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {2, 7, 9, 3, 1};\n    cout &lt;&lt; rob(nums) &lt;&lt; endl;  // 12\n    return 0;\n}\n</code></pre>"},{"location":"content/interview150/1d_dynamic_programming/#139-word-break","title":"139. Word Break","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, dynamic programming, trie, memoization 139. Word Break - Python Solution<pre><code>from typing import List\n\n\n# DP (Unbounded Knapsack)\ndef wordBreak(s: str, wordDict: List[str]) -&gt; bool:\n    n = len(s)\n    dp = [False for _ in range(n + 1)]\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for word in wordDict:\n            m = len(word)\n            if s[i - m : i] == word and dp[i - m]:\n                dp[i] = True\n    return dp[-1]\n\n\ns = \"leetcode\"\nwordDict = [\"leet\", \"code\"]\nprint(wordBreak(s, wordDict))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/1d_dynamic_programming/#322-coin-change","title":"322. Coin Change","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, breadth first search 322. Coin Change - Python Solution<pre><code>from typing import List\n\n\ndef coinChange(coins: List[int], amount: int) -&gt; int:\n    dp = [float(\"inf\") for _ in range(amount + 1)]\n\n    dp[0] = 0\n\n    for i in range(1, amount + 1):\n        for c in coins:\n            if i - c &gt;= 0:\n                dp[i] = min(dp[i], 1 + dp[i - c])\n\n    return dp[amount] if dp[amount] != float(\"inf\") else -1\n\n\ncoins = [1, 2, 5]\namount = 11\nprint(coinChange(coins, amount))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/1d_dynamic_programming/#300-longest-increasing-subsequence","title":"300. Longest Increasing Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, dynamic programming 300. Longest Increasing Subsequence - Python Solution<pre><code>from functools import cache\nfrom typing import List\n\n\n# DP - LIS\ndef lengthOfLISMemo(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return n\n\n    @cache\n    def dfs(i: int) -&gt; int:\n        res = 0\n        for j in range(i):\n            if nums[j] &lt; nums[i]:\n                res = max(res, dfs(j))\n        return res + 1\n\n    return max(dfs(i) for i in range(n))\n\n\n# DP - LIS\ndef lengthOfLISTable(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return n\n\n    dp = [1 for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i):\n            if nums[i] &gt; nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\n\nif __name__ == \"__main__\":\n    assert lengthOfLISMemo([10, 9, 2, 5, 3, 7, 101, 18]) == 4\n    assert lengthOfLISTable([10, 9, 2, 5, 3, 7, 101, 18]) == 4\n    assert lengthOfLISMemo([0, 1, 0, 3, 2, 3]) == 4\n    assert lengthOfLISTable([0, 1, 0, 3, 2, 3]) == 4\n    assert lengthOfLISMemo([7, 7, 7, 7]) == 1\n    assert lengthOfLISTable([7, 7, 7, 7]) == 1\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/arrays_string/","title":"Arrays String","text":""},{"location":"content/interview150/arrays_string/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 88. Merge Sorted Array (Easy)</li> <li> 27. Remove Element (Easy)</li> <li> 26. Remove Duplicates from Sorted Array (Easy)</li> <li> 80. Remove Duplicates from Sorted Array II (Medium)</li> <li> 169. Majority Element (Easy)</li> <li> 189. Rotate Array (Medium)</li> <li> 121. Best Time to Buy and Sell Stock (Easy)</li> <li> 122. Best Time to Buy and Sell Stock II (Medium)</li> <li> 55. Jump Game (Medium)</li> <li> 45. Jump Game II (Medium)</li> <li> 274. H-Index (Medium)</li> <li> 380. Insert Delete GetRandom O(1) (Medium)</li> <li> 238. Product of Array Except Self (Medium)</li> <li> 134. Gas Station (Medium)</li> <li> 135. Candy (Hard)</li> <li> 42. Trapping Rain Water (Hard)</li> <li> 13. Roman to Integer (Easy)</li> <li> 12. Integer to Roman (Medium)</li> <li> 58. Length of Last Word (Easy)</li> <li> 14. Longest Common Prefix (Easy)</li> <li> 151. Reverse Words in a String (Medium)</li> <li> 6. Zigzag Conversion (Medium)</li> <li> 28. Find the Index of the First Occurrence in a String (Easy)</li> <li> 68. Text Justification (Hard)</li> </ul>"},{"location":"content/interview150/arrays_string/#88-merge-sorted-array","title":"88. Merge Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers, sorting 88. Merge Sorted Array - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef merge(nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None:\n    \"\"\"Merges two sorted arrays in-place.\"\"\"\n    p1, p2, t = m - 1, n - 1, m + n - 1\n\n    while p1 &gt;= 0 or p2 &gt;= 0:\n        if p1 == -1:\n            nums1[t] = nums2[p2]\n            p2 -= 1\n        elif p2 == -1:\n            nums1[t] = nums1[p1]\n            p1 -= 1\n        elif nums1[p1] &gt; nums2[p2]:\n            nums1[t] = nums1[p1]\n            p1 -= 1\n        else:\n            nums1[t] = nums2[p2]\n            p2 -= 1\n\n        t -= 1\n\n\nnums1 = [1, 2, 3, 0, 0, 0]\nm = 3\nnums2 = [2, 5, 6]\nn = 3\nmerge(nums1, m, nums2, n)\nprint(nums1)  # [1, 2, 2, 3, 5, 6]\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/arrays_string/#27-remove-element","title":"27. Remove Element","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers</p> </li> <li>Remove all instances of a given value in-place.</li> </ul> 27. Remove Element - Python Solution<pre><code>from typing import List\n\n\n# Fast Slow Pointers\ndef removeElement(nums: List[int], val: int) -&gt; int:\n    fast, slow = 0, 0\n\n    while fast &lt; len(nums):\n        if nums[fast] != val:\n            nums[slow] = nums[fast]\n            slow += 1\n        fast += 1\n\n    return slow\n\n\nnums = [0, 1, 2, 2, 3, 0, 4, 2]\nval = 2\nprint(removeElement(nums, val))  # 5\n</code></pre> 27. Remove Element - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// Fast Slow Pointers\nint removeElement(vector&lt;int&gt;&amp; nums, int val) {\n    size_t n = nums.size();\n    size_t slow = 0, fast = 0;\n\n    while (fast &lt; n) {\n        if (nums[fast] != val) {\n            nums[slow] = nums[fast];\n            slow++;\n        }\n        fast++;\n    }\n    return (int)slow;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {3, 2, 2, 3};\n    int val = 3;\n    cout &lt;&lt; removeElement(nums, val) &lt;&lt; endl;  // 2\n    return 0;\n}\n</code></pre>"},{"location":"content/interview150/arrays_string/#26-remove-duplicates-from-sorted-array","title":"26. Remove Duplicates from Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers</p> </li> <li>Remove duplicates in-place.</li> </ul> 26. Remove Duplicates from Sorted Array - Python Solution<pre><code>from typing import List\n\n\ndef removeDuplicates(nums: List[int]) -&gt; int:\n    fast, slow = 1, 1\n\n    while fast &lt; len(nums):\n        if nums[fast] != nums[fast - 1]:\n            nums[slow] = nums[fast]\n            slow += 1\n        fast += 1\n\n    return slow\n\n\nnums = [1, 1, 2]\nprint(removeDuplicates(nums))  # 2\n</code></pre>"},{"location":"content/interview150/arrays_string/#80-remove-duplicates-from-sorted-array-ii","title":"80. Remove Duplicates from Sorted Array II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers</p> </li> <li>Allow at most two duplicates.</li> <li>fast pointer: explore the array</li> <li>slow pointer: point to the position to be replaced</li> </ul> 80. Remove Duplicates from Sorted Array II - Python Solution<pre><code>from typing import List\n\n\ndef removeDuplicates(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 2:\n        return len(nums)\n\n    fast, slow = 2, 2\n\n    while fast &lt; len(nums):\n        if nums[fast] != nums[slow - 2]:\n            nums[slow] = nums[fast]\n            slow += 1\n        fast += 1\n\n    return slow\n\n\nnums = [1, 1, 1, 2, 2, 3]\nprint(removeDuplicates(nums))\n</code></pre>"},{"location":"content/interview150/arrays_string/#169-majority-element","title":"169. Majority Element","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, divide and conquer, sorting, counting</p> </li> <li>Return the majority element in an array. The majority element is the element that appears more than <code>n // 2</code> times.</li> </ul> <code>num</code> <code>count</code> <code>res</code> 2 1 2 2 2 2 1 1 2 1 0 2 1 1 1 2 0 1 2 1 2 169. Majority Element - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash Map\ndef majorityElementHashMap(nums: List[int]) -&gt; int:\n    n = len(nums)\n    freq = defaultdict(int)\n\n    for num in nums:\n        freq[num] += 1\n        if freq[num] &gt; n // 2:\n            return num\n\n\n# Array - Boyer-Moore Voting Algorithm\ndef majorityElementArray(nums: List[int]) -&gt; int:\n    res = None\n    count = 0\n\n    for num in nums:\n        if count == 0:\n            res = num\n        count += 1 if num == res else -1\n\n    return res\n\n\n# | Algorithm | Time Complexity | Space Complexity |\n# |-----------|-----------------|------------------|\n# | HashMap   | O(N)            | O(N)             |\n# | Array     | O(N)            | O(1)             |\n# |-----------|-----------------|------------------|\n\n\nnums = [2, 2, 1, 1, 1, 2, 2]\nprint(majorityElementArray(nums))  # 2\nprint(majorityElementHashMap(nums))  # 2\n</code></pre>"},{"location":"content/interview150/arrays_string/#189-rotate-array","title":"189. Rotate Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, two pointers</p> </li> <li>Rotate array with reversing subarrays</li> </ul> <pre><code>graph TD\n    A[1 2 3 4 5 6 7] --Reverse entire array--&gt; B[7 6 5 4 3 2 1]\n    B --Reverse first k elements--&gt; C[5 6 7 4 3 2 1]\n    C --Reverse remaining n-k elements--&gt; D[5 6 7 1 2 3 4];</code></pre> 189. Rotate Array - Python Solution<pre><code>from typing import List\n\n\n# Array\ndef rotate(nums: List[int], k: int) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n\n    def reverse(i: int, j: int) -&gt; None:\n        while i &lt; j:\n            nums[i], nums[j] = nums[j], nums[i]\n            i += 1\n            j -= 1\n\n    n = len(nums)\n    k %= n\n    reverse(0, n - 1)\n    reverse(0, k - 1)\n    reverse(k, n - 1)\n\n\nnums = [1, 2, 3, 4, 5, 6, 7]\nk = 3\nrotate(nums, k)\nprint(nums)  # [5, 6, 7, 1, 2, 3, 4]\n</code></pre> 189. Rotate Array - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// Array\nvoid rotate(vector&lt;int&gt;&amp; nums, int k) {\n    k %= nums.size();\n\n    reverse(nums.begin(), nums.end());\n    reverse(nums.begin(), nums.begin() + k);\n    reverse(nums.begin() + k, nums.end());\n}\n\nint main() {\n    vector&lt;int&gt; nums = {1, 2, 3, 4, 5, 6, 7};\n    int k = 3;\n    rotate(nums, k);\n    // [5, 6, 7, 1, 2, 3, 4]\n    for (const auto&amp; num : nums) {\n        cout &lt;&lt; num &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/interview150/arrays_string/#121-best-time-to-buy-and-sell-stock","title":"121. Best Time to Buy and Sell Stock","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li>Return the maximum profit that can be achieved from buying on one day and selling on another day.</li> </ul> 121. Best Time to Buy and Sell Stock - Python Solution<pre><code>from typing import List\n\n\n# Brute Force\ndef maxProfitBF(prices: List[int]) -&gt; int:\n    max_profit = 0\n    n = len(prices)\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_profit = max(max_profit, prices[j] - prices[i])\n\n    return max_profit\n\n\n# DP\ndef maxProfitDP(prices: List[int]) -&gt; int:\n    dp = [[0] * 2 for _ in range(len(prices))]\n    dp[0][0] = -prices[0]  # buy\n    dp[0][1] = 0  # sell\n\n    for i in range(1, len(prices)):\n        dp[i][0] = max(dp[i - 1][0], -prices[i])  # the lowest price to buy\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    max_profit = 0\n    seen_min = prices[0]\n\n    for i in range(1, len(prices)):\n        max_profit = max(max_profit, prices[i] - seen_min)\n        seen_min = min(seen_min, prices[i])\n\n    return max_profit\n\n\n# Fast Slow Pointers\ndef maxProfitFS(prices: List[int]) -&gt; int:\n    max_profit = 0\n    slow, fast = 0, 1\n\n    while fast &lt; len(prices):\n        if prices[fast] &gt; prices[slow]:\n            max_profit = max(max_profit, prices[fast] - prices[slow])\n        else:\n            slow = fast\n        fast += 1\n\n    return max_profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force|  O(n^2)|  O(1)   |\n# | DP         |  O(n)  |  O(n)   |\n# | Greedy     |  O(n)  |  O(1)   |\n# | Fast Slow  |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitBF(prices))  # 5\nprint(maxProfitDP(prices))  # 5\nprint(maxProfitGreedy(prices))  # 5\nprint(maxProfitFS(prices))  # 5\n</code></pre> 121. Best Time to Buy and Sell Stock - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int maxProfit(vector&lt;int&gt; &amp;prices)\n    {\n        if (prices.size() &lt;= 1)\n            return 0;\n\n        int seen_min = prices[0];\n        int res = 0;\n\n        for (int &amp;price : prices)\n        {\n            res = max(res, price - seen_min);\n            seen_min = min(seen_min, price);\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    vector&lt;int&gt; prices = {7, 1, 5, 3, 6, 4};\n    Solution obj;\n    cout &lt;&lt; obj.maxProfit(prices) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/interview150/arrays_string/#122-best-time-to-buy-and-sell-stock-ii","title":"122. Best Time to Buy and Sell Stock II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> <li>Return the maximum profit you can achieve.</li> </ul> 122. Best Time to Buy and Sell Stock II - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef maxProfitDP1(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 2 for _ in range(n)]\n    dp[0][0] = -prices[0]\n    dp[0][1] = 0\n\n    for i in range(1, n):\n        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i])\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# DP - Optimized\ndef maxProfitDP2(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    hold = -prices[0]\n    profit = 0\n\n    for i in range(1, n):\n        hold = max(hold, profit - prices[i])\n        profit = max(profit, hold + prices[i])\n\n    return profit\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    profit = 0\n\n    for i in range(1, len(prices)):\n        profit += max(prices[i] - prices[i - 1], 0)\n\n    return profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |     DP1    |  O(n)  |   O(n)  |\n# |     DP2    |  O(n)  |   O(1)  |\n# |   Greedy   |  O(n)  |   O(1)  |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitDP1(prices))  # 7\nprint(maxProfitDP2(prices))  # 7\nprint(maxProfitGreedy(prices))  # 7\n</code></pre>"},{"location":"content/interview150/arrays_string/#55-jump-game","title":"55. Jump Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> <li>Return <code>True</code> if you can reach the last index, otherwise <code>False</code>.</li> </ul> 55. Jump Game - Python Solution<pre><code>from typing import List\n\n\n# Greedy - Interval\ndef canJump(nums: List[int]) -&gt; bool:\n    n = len(nums)\n    reach = 0\n    i = 0\n\n    while reach &gt;= i:\n        if reach &gt;= n - 1:\n            return True\n        reach = max(reach, i + nums[i])\n        i += 1\n\n    return False\n\n\nif __name__ == \"__main__\":\n    assert canJump([2, 3, 1, 1, 4]) is True\n    assert canJump([3, 2, 1, 0, 4]) is False\n</code></pre> 55. Jump Game - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool canJump(vector&lt;int&gt;&amp; nums) {\n        int canReach = 0;\n        int n = nums.size();\n\n        for (int i = 0; i &lt; n; i++) {\n            if (i &gt; canReach) return false;\n            canReach = max(canReach, i + nums[i]);\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution obj;\n    vector&lt;int&gt; nums = {2, 3, 1, 1, 4};\n    cout &lt;&lt; obj.canJump(nums) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/interview150/arrays_string/#45-jump-game-ii","title":"45. Jump Game II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> <li>Return the minimum number of jumps to reach the last index.</li> </ul> 45. Jump Game II - Python Solution<pre><code>from typing import List\n\n\n# Greedy - Interval\ndef jump(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n == 1:\n        return 0\n\n    reach = 0\n    left, right = 0, 0\n    res = 0\n\n    while right &lt; n - 1:\n        for i in range(left, right + 1):\n            reach = max(reach, i + nums[i])\n\n        left = right + 1\n        right = reach\n        res += 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert jump([2, 3, 1, 1, 4]) == 2\n    assert jump([2, 3, 0, 1, 4]) == 2\n</code></pre>"},{"location":"content/interview150/arrays_string/#274-h-index","title":"274. H-Index","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sorting, counting sort 274. H-Index - Python Solution<pre><code>from typing import List\n\n\n# Arrays\ndef hIndex(citations: List[int]) -&gt; int:\n    n = len(citations)\n    cnt = [0 for _ in range(n + 1)]\n\n    for c in citations:\n        cnt[min(c, n)] += 1\n\n    s = 0\n    for i in range(n, -1, -1):\n        s += cnt[i]\n        if s &gt;= i:\n            return i\n\n\nif __name__ == \"__main__\":\n    assert hIndex([3, 0, 6, 1, 5]) == 3\n    assert hIndex([1, 3, 1]) == 1\n    assert hIndex([1, 2, 3, 4, 5]) == 3\n    assert hIndex([0, 0, 0]) == 0\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/arrays_string/#380-insert-delete-getrandom-o1","title":"380. Insert Delete GetRandom O(1)","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, design, randomized 380. Insert Delete GetRandom O(1) - Python Solution<pre><code>import random\n\n\nclass RandomizedSet:\n    def __init__(self):\n        self.dict = {}\n        self.list = []\n\n    def insert(self, val: int) -&gt; bool:\n        if val in self.dict:\n            return False\n        self.dict[val] = len(self.list)\n        self.list.append(val)\n\n        return True\n\n    def remove(self, val: int) -&gt; bool:\n        if val not in self.dict:\n            return False\n        last_element = self.list[-1]\n        idx = self.dict[val]\n        self.list[idx] = last_element\n        self.dict[last_element] = idx\n        self.list.pop()\n        del self.dict[val]\n        return True\n\n    def getRandom(self) -&gt; int:\n        return random.choice(self.list)\n\n\nobj = RandomizedSet()\nprint(obj.insert(1))  # True\nprint(obj.remove(2))  # False\nprint(obj.insert(2))  # True\nprint(obj.getRandom())  # 1 or 2\nprint(obj.remove(1))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/arrays_string/#238-product-of-array-except-self","title":"238. Product of Array Except Self","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, prefix sum</p> </li> <li>Classic Prefix Sum problem</li> <li>Return an array <code>output</code> such that <code>output[i]</code> is equal to the product of all the elements of <code>nums</code> except <code>nums[i]</code>.</li> </ul> Approach Time Space Prefix O(n) O(n) Prefix (Optimized) O(n) O(1) 238. Product of Array Except Self - Python Solution<pre><code>from typing import List\n\n\n# Prefix\ndef productExceptSelf(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    prefix = [1 for _ in range(n)]\n    suffix = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        prefix[i] = nums[i - 1] * prefix[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        suffix[i] = nums[i + 1] * suffix[i + 1]\n\n    result = [i * j for i, j in zip(prefix, suffix)]\n\n    return result\n\n\n# Prefix (Optimized)\ndef productExceptSelfOptimized(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    result = [1 for _ in range(n)]\n\n    prefix = 1\n    for i in range(n):\n        result[i] = prefix\n        prefix *= nums[i]\n\n    suffix = 1\n    for i in range(n - 1, -1, -1):\n        result[i] *= suffix\n        suffix *= nums[i]\n\n    return result\n\n\nprint(productExceptSelf([1, 2, 3, 4]))\n# [24, 12, 8, 6]\nprint(productExceptSelfOptimized([1, 2, 3, 4]))\n# [24, 12, 8, 6]\n</code></pre> 238. Product of Array Except Self - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\n// Prefix Sum\nclass Solution\n{\npublic:\n    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt; &amp;nums)\n    {\n        int n = nums.size();\n        vector&lt;int&gt; prefix(n, 1);\n        vector&lt;int&gt; suffix(n, 1);\n        vector&lt;int&gt; res(n, 1);\n\n        for (int i = 1; i &lt; n; i++)\n        {\n            prefix[i] = prefix[i - 1] * nums[i - 1];\n        }\n\n        for (int i = n - 2; i &gt;= 0; i--)\n        {\n            suffix[i] = suffix[i + 1] * nums[i + 1];\n        }\n\n        for (int i = 0; i &lt; n; i++)\n        {\n            res[i] = prefix[i] * suffix[i];\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    vector&lt;int&gt; nums = {1, 2, 3, 4};\n    Solution obj;\n    vector&lt;int&gt; result = obj.productExceptSelf(nums);\n\n    for (int i = 0; i &lt; result.size(); i++)\n    {\n        cout &lt;&lt; result[i] &lt;&lt; \"\\n\";\n    }\n    cout &lt;&lt; endl;\n    // 24, 12, 8, 6\n    return 0;\n}\n</code></pre>"},{"location":"content/interview150/arrays_string/#134-gas-station","title":"134. Gas Station","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy 134. Gas Station - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef canCompleteCircuit(gas: List[int], cost: List[int]) -&gt; int:\n    curSum = 0\n    totalSum = 0\n    start = 0\n\n    for i in range(len(gas)):\n        curSum += gas[i] - cost[i]\n        totalSum += gas[i] - cost[i]\n\n        if curSum &lt; 0:\n            start = i + 1\n            curSum = 0\n\n    if totalSum &lt; 0:\n        return -1\n\n    return start\n\n\ngas = [1, 2, 3, 4, 5]\ncost = [3, 4, 5, 1, 2]\nprint(canCompleteCircuit(gas, cost))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/arrays_string/#135-candy","title":"135. Candy","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy</p> </li> <li>Return the minimum number of candies you must give.</li> </ul> 135. Candy - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef candy(ratings: List[int]) -&gt; int:\n    # TC: O(n)\n    # SC: O(n)\n    n = len(ratings)\n\n    if n &lt;= 1:\n        return n\n\n    candy = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        if ratings[i] &gt; ratings[i - 1]:\n            candy[i] = candy[i - 1] + 1\n\n    for j in range(n - 2, -1, -1):\n        if ratings[j] &gt; ratings[j + 1]:\n            candy[j] = max(candy[j], candy[j + 1] + 1)\n\n    return sum(candy)\n\n\nratings = [1, 0, 2]\nprint(candy(ratings))  # 5\n</code></pre>"},{"location":"content/interview150/arrays_string/#42-trapping-rain-water","title":"42. Trapping Rain Water","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, dynamic programming, stack, monotonic stack</p> </li> <li></li> </ul> Approach Time Space DP O(N) O(N) Left Right O(N) O(1) Monotonic O(N) O(N) 42. Trapping Rain Water - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef trapDP(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    n = len(height)\n    maxLeft, maxRight = [0 for _ in range(n)], [0 for _ in range(n)]\n\n    for i in range(1, n):\n        maxLeft[i] = max(maxLeft[i - 1], height[i - 1])\n\n    for i in range(n - 2, -1, -1):\n        maxRight[i] = max(maxRight[i + 1], height[i + 1])\n\n    res = 0\n    for i in range(n):\n        res += max(0, min(maxLeft[i], maxRight[i]) - height[i])\n\n    return res\n\n\n# Left Right Pointers\ndef trapLR(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    left, right = 0, len(height) - 1\n    maxL, maxR = height[left], height[right]\n    res = 0\n\n    while left &lt; right:\n        if maxL &lt; maxR:\n            left += 1\n            maxL = max(maxL, height[left])\n            res += maxL - height[left]\n        else:\n            right -= 1\n            maxR = max(maxR, height[right])\n            res += maxR - height[right]\n\n    return res\n\n\n# Monotonic Stack\ndef trapStack(height: List[int]) -&gt; int:\n    stack = []\n    total = 0\n\n    for i in range(len(height)):\n        while stack and height[i] &gt; height[stack[-1]]:\n            top = stack.pop()\n            if not stack:\n                break\n            distance = i - stack[-1] - 1\n            bounded_height = min(height[i], height[stack[-1]]) - height[top]\n            total += distance * bounded_height\n        stack.append(i)\n\n    return total\n\n\nheight = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\nprint(trapDP(height))  # 6\nprint(trapLR(height))  # 6\nprint(trapStack(height))  # 6\n</code></pre> 42. Trapping Rain Water - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int trap(vector&lt;int&gt; &amp;height)\n    {\n        if (height.empty())\n            return 0;\n\n        int res = 0;\n        int left = 0, right = height.size() - 1;\n        int maxL = height[left], maxR = height[right];\n\n        while (left &lt; right)\n        {\n            if (maxL &lt; maxR)\n            {\n                left++;\n                maxL = max(maxL, height[left]);\n                res += maxL - height[left];\n            }\n            else\n            {\n                right--;\n                maxR = max(maxR, height[right]);\n                res += maxR - height[right];\n            }\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    vector&lt;int&gt; height = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};\n    Solution solution;\n    cout &lt;&lt; solution.trap(height) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/interview150/arrays_string/#13-roman-to-integer","title":"13. Roman to Integer","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, math, string 13. Roman to Integer - Python Solution<pre><code>from itertools import pairwise\n\n\n# Arrays\ndef romanToInt(s: str) -&gt; int:\n    ROMAN = {\n        \"I\": 1,\n        \"V\": 5,\n        \"X\": 10,\n        \"L\": 50,\n        \"C\": 100,\n        \"D\": 500,\n        \"M\": 1000,\n    }\n\n    res = 0\n\n    for x, y in pairwise(s):\n        x, y = ROMAN[x], ROMAN[y]\n        res += x if x &gt;= y else -x\n\n    return res + ROMAN[s[-1]]\n\n\nif __name__ == \"__main__\":\n    assert romanToInt(\"III\") == 3\n    assert romanToInt(\"IV\") == 4\n    assert romanToInt(\"IX\") == 9\n    assert romanToInt(\"LVIII\") == 58\n    assert romanToInt(\"MCMXCIV\") == 1994\n    assert romanToInt(\"MMXXIII\") == 2023\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/arrays_string/#12-integer-to-roman","title":"12. Integer to Roman","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, math, string</p> </li> </ul>"},{"location":"content/interview150/arrays_string/#58-length-of-last-word","title":"58. Length of Last Word","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string 58. Length of Last Word - Python Solution<pre><code>def lengthOfLastWord(s: str) -&gt; int:\n    n = 0\n\n    for i in range(len(s) - 1, -1, -1):\n        if s[i] != \" \":\n            n += 1\n        if s[i] == \" \" and n &gt; 0:\n            return n\n\n    return n\n\n\nprint(lengthOfLastWord(\"Hello World\"))  # 5\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/arrays_string/#14-longest-common-prefix","title":"14. Longest Common Prefix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, trie 14. Longest Common Prefix - Python Solution<pre><code>from typing import List\n\n\n# Horizontal Scanning\ndef longestCommonPrefixHorizontal(strs: List[str]) -&gt; str:\n    if not strs:\n        return \"\"\n\n    prefix = strs[0]\n    for i in range(1, len(strs)):\n        while not strs[i].startswith(prefix):\n            prefix = prefix[:-1]\n            if not prefix:\n                return \"\"\n\n    return prefix\n\n\n# Vertical Scanning\ndef longestCommonPrefixVertical(strs: List[str]) -&gt; str:\n    if not strs:\n        return \"\"\n\n    for i in range(len(strs[0])):\n        char = strs[0][i]\n        for j in range(1, len(strs)):\n            if i &gt;= len(strs[j]) or strs[j][i] != char:\n                return strs[0][:i]\n\n    return strs[0]\n\n\n# Divide and Conquer\ndef longestCommonPrefixDivideConquer(strs: List[str]) -&gt; str:\n    if not strs:\n        return \"\"\n\n    def merge(left, right):\n        n = min(len(left), len(right))\n        for i in range(n):\n            if left[i] != right[i]:\n                return left[:i]\n        return left[:n]\n\n    def helper(strs, start, end):\n        if start == end:\n            return strs[start]\n        mid = start + (end - start) // 2\n        left = helper(strs, start, mid)\n        right = helper(strs, mid + 1, end)\n        return merge(left, right)\n\n    return helper(strs, 0, len(strs) - 1)\n\n\n# Binary Search\ndef longestCommonPrefixBinarySearch(strs: List[str]) -&gt; str:\n    if not strs:\n        return \"\"\n\n    def isCommonPrefix(strs, length):\n        prefix = strs[0][:length]\n        return all(s.startswith(prefix) for s in strs)\n\n    minLen = min(len(s) for s in strs)\n    low, high = 0, minLen\n    while low &lt; high:\n        mid = low + (high - low) // 2\n        if isCommonPrefix(strs, mid + 1):\n            low = mid + 1\n        else:\n            high = mid\n\n    return strs[0][:low]\n\n\nstrs = [\"flower\", \"flow\", \"flight\"]\nprint(longestCommonPrefixHorizontal(strs))  # \"fl\"\nprint(longestCommonPrefixVertical(strs))  # \"fl\"\nprint(longestCommonPrefixDivideConquer(strs))  # \"fl\"\nprint(longestCommonPrefixBinarySearch(strs))  # \"fl\"\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/arrays_string/#151-reverse-words-in-a-string","title":"151. Reverse Words in a String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string 151. Reverse Words in a String - Python Solution<pre><code>def reverseWords(s: str) -&gt; str:\n    words = s.split()\n\n    left, right = 0, len(words) - 1\n\n    while left &lt; right:\n        words[left], words[right] = words[right], words[left]\n        left += 1\n        right -= 1\n\n    return \" \".join(words)\n\n\ns = \"the sky is blue\"\nprint(reverseWords(s))  # \"blue is sky the\"\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/arrays_string/#6-zigzag-conversion","title":"6. Zigzag Conversion","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string</p> </li> </ul>"},{"location":"content/interview150/arrays_string/#28-find-the-index-of-the-first-occurrence-in-a-string","title":"28. Find the Index of the First Occurrence in a String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string, string matching 28. Find the Index of the First Occurrence in a String - Python Solution<pre><code>from template import LPS\n\n\n# Brute Force\ndef strStrBF(haystack: str, needle: str) -&gt; int:\n    m, n = len(haystack), len(needle)\n    for i in range(m - n + 1):\n        if haystack[i : i + n] == needle:\n            return i\n    return -1\n\n\n# KMP\ndef strStrKMP(haystack: str, needle: str) -&gt; int:\n    lps = LPS(needle)\n    m, n = len(haystack), len(needle)\n    j = 0\n\n    for i in range(m):\n        while j &gt; 0 and haystack[i] != needle[j]:\n            j = lps[j - 1]\n        if haystack[i] == needle[j]:\n            j += 1\n        if j == n:\n            return i - n + 1\n    return -1\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# | Brute Force| O((m - n) * n)   | O(1)    |\n# | KMP        | O(m + n)         | O(n)    |\n# |------------|------------------|---------|\n\n\nhaystack = \"hello\"\nneedle = \"ll\"\nprint(strStrBF(haystack, needle))  # 2\nprint(strStrKMP(haystack, needle))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/arrays_string/#68-text-justification","title":"68. Text Justification","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, simulation</p> </li> </ul>"},{"location":"content/interview150/backtracking/","title":"Backtracking","text":""},{"location":"content/interview150/backtracking/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 17. Letter Combinations of a Phone Number (Medium)</li> <li> 77. Combinations (Medium)</li> <li> 46. Permutations (Medium)</li> <li> 39. Combination Sum (Medium)</li> <li> 52. N-Queens II (Hard)</li> <li> 22. Generate Parentheses (Medium)</li> <li> 79. Word Search (Medium)</li> </ul>"},{"location":"content/interview150/backtracking/#17-letter-combinations-of-a-phone-number","title":"17. Letter Combinations of a Phone Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, backtracking</p> </li> <li>Return all possible letter combinations that the number could represent.</li> </ul> <p></p> 17. Letter Combinations of a Phone Number - Python Solution<pre><code>from typing import List\n\n\n# Backtracking\ndef letterCombinations(digits: str) -&gt; List[str]:\n    letter_map = {\n        \"2\": \"abc\",\n        \"3\": \"def\",\n        \"4\": \"ghi\",\n        \"5\": \"jkl\",\n        \"6\": \"mno\",\n        \"7\": \"pqrs\",\n        \"8\": \"tuv\",\n        \"9\": \"wxyz\",\n    }\n\n    n = len(digits)\n    if n == 0:\n        return []\n\n    res = []\n\n    def dfs(idx, path):\n        if idx == n:\n            res.append(path)\n            return None\n\n        letters = letter_map[digits[idx]]\n\n        for i in range(len(letters)):\n            dfs(idx + 1, path + letters[i])\n\n    dfs(0, \"\")\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert letterCombinations(\"23\") == [\n        \"ad\",\n        \"ae\",\n        \"af\",\n        \"bd\",\n        \"be\",\n        \"bf\",\n        \"cd\",\n        \"ce\",\n        \"cf\",\n    ]\n</code></pre>"},{"location":"content/interview150/backtracking/#77-combinations","title":"77. Combinations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: backtracking 77. Combinations - Python Solution<pre><code>import itertools\nfrom typing import List\n\n\n# Backtracking\ndef combine(n: int, k: int) -&gt; List[List[int]]:\n    res = []\n\n    def backtrack(start, path):\n        if len(path) == k:\n            res.append(path[:])\n            return None\n\n        for i in range(start, n + 1):\n            path.append(i)\n            backtrack(i + 1, path)\n            path.pop()\n\n    backtrack(1, [])\n\n    return res\n\n\n# itertools\ndef combineItertools(n: int, k: int) -&gt; List[List[int]]:\n    path = itertools.combinations(range(1, n + 1), k)\n    return path\n\n\nprint(combine(4, 2))\n# [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\nprint(list(combineItertools(4, 2)))\n# [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/backtracking/#46-permutations","title":"46. Permutations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking 46. Permutations - Python Solution<pre><code>from typing import List\n\n\n# Backtracking\ndef permute(nums: List[int]) -&gt; List[List[int]]:\n    n = len(nums)\n    path, res = [], []\n    used = [False for _ in range(n)]\n\n    def dfs(x: int):\n        if x == n:\n            res.append(path[:])\n            return\n\n        for i in range(n):\n            if used[i]:\n                continue\n            used[i] = True\n            path.append(nums[i])\n            dfs(x + 1)\n            path.pop()\n            used[i] = False\n\n    dfs(0)\n\n    return res\n\n\nprint(permute([1, 2, 3]))\n# [[1, 2, 3], [1, 3, 2], [2, 1, 3],\n#  [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/backtracking/#39-combination-sum","title":"39. Combination Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking 39. Combination Sum - Python Solution<pre><code>from typing import List\n\n\ndef combinationSum(candidates: List[int], target: int) -&gt; List[List[int]]:\n    n = len(candidates)\n    res, path = [], []\n\n    def dfs(total, start):\n        if total &gt; target:\n            return\n        if total == target:\n            res.append(path.copy())\n            return\n\n        for i in range(start, n):\n            total += candidates[i]\n            path.append(candidates[i])\n            dfs(total, i)\n            total -= candidates[i]\n            path.pop()\n\n    dfs(0, 0)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(combinationSum([2, 3, 5], 8))\n    # [[2, 2, 2, 2], [2, 3, 3], [3, 5]]\n    print(combinationSum([2, 3, 6, 7], 7))\n    # [[2, 2, 3], [7]]\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/backtracking/#52-n-queens-ii","title":"52. N-Queens II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: backtracking</p> </li> </ul>"},{"location":"content/interview150/backtracking/#22-generate-parentheses","title":"22. Generate Parentheses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming, backtracking 22. Generate Parentheses - Python Solution<pre><code>from typing import List\n\n\n# Backtracking\ndef generateParenthesis1(n: int) -&gt; List[str]:\n    path, res = [], []\n\n    def dfs(openN, closeN):\n        if openN == closeN == n:\n            res.append(\"\".join(path))\n            return\n\n        if openN &lt; n:\n            path.append(\"(\")\n            dfs(openN + 1, closeN)\n            path.pop()\n\n        if closeN &lt; openN:\n            path.append(\")\")\n            dfs(openN, closeN + 1)\n            path.pop()\n\n    dfs(0, 0)\n\n    return res\n\n\n# Backtracking\ndef generateParenthesis2(n: int) -&gt; List[str]:\n    m = n * 2\n    res, path = [], [\"\"] * m\n\n    def dfs(i, left):\n        if i == m:\n            res.append(\"\".join(path))\n            return\n\n        if left &lt; n:\n            path[i] = \"(\"\n            dfs(i + 1, left + 1)\n        if i - left &lt; left:\n            path[i] = \")\"\n            dfs(i + 1, left)\n\n    dfs(0, 0)\n    return res\n\n\nif __name__ == \"__main__\":\n    print(generateParenthesis1(3))\n    # ['((()))', '(()())', '(())()', '()(())', '()()()']\n    print(generateParenthesis2(3))\n    # ['((()))', '(()())', '(())()', '()(())', '()()()']\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/backtracking/#79-word-search","title":"79. Word Search","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, backtracking, depth first search, matrix 79. Word Search - Python Solution<pre><code>from typing import List\n\n\ndef exist(board: List[List[str]], word: str) -&gt; bool:\n    m, n = len(board), len(board[0])\n    path = set()\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n\n    def dfs(r, c, i):\n        if i == len(word):\n            return True\n\n        if (\n            r &lt; 0\n            or r &gt;= m\n            or c &lt; 0\n            or c &gt;= n\n            or board[r][c] != word[i]\n            or (r, c) in path\n        ):\n            return False\n\n        path.add((r, c))\n\n        for dr, dc in dirs:\n            if dfs(r + dr, c + dc, i + 1):\n                return True\n\n        path.remove((r, c))\n        return False\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, 0):\n                return True\n\n    return False\n\n\nboard = [\n    [\"A\", \"B\", \"C\", \"E\"],\n    [\"S\", \"F\", \"C\", \"S\"],\n    [\"A\", \"D\", \"E\", \"E\"],\n]\nword = \"ABCCED\"\nprint(exist(board, word))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/binary_search/","title":"Binary Search","text":""},{"location":"content/interview150/binary_search/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 35. Search Insert Position (Easy)</li> <li> 74. Search a 2D Matrix (Medium)</li> <li> 162. Find Peak Element (Medium)</li> <li> 33. Search in Rotated Sorted Array (Medium)</li> <li> 34. Find First and Last Position of Element in Sorted Array (Medium)</li> <li> 153. Find Minimum in Rotated Sorted Array (Medium)</li> <li> 4. Median of Two Sorted Arrays (Hard)</li> </ul>"},{"location":"content/interview150/binary_search/#35-search-insert-position","title":"35. Search Insert Position","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, binary search</p> </li> <li>Return the index of the target if it is found. If not, return the index where it would be if it were inserted in order.</li> </ul> 35. Search Insert Position - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef searchInsert(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        if nums[mid] &lt; target:\n            left = mid + 1\n        elif nums[mid] &gt; target:\n            right = mid - 1\n        else:\n            return mid\n\n    return left\n\n\nnums = [1, 3, 5, 6]\ntarget = 5\nprint(searchInsert(nums, target))  # 2\n</code></pre>"},{"location":"content/interview150/binary_search/#74-search-a-2d-matrix","title":"74. Search a 2D Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, matrix 74. Search a 2D Matrix - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef searchMatrix(matrix: List[List[int]], target: int) -&gt; bool:\n    if not matrix or not matrix[0]:\n        return False\n\n    m, n = len(matrix), len(matrix[0])\n    left, right = 0, m * n - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        x = matrix[mid // n][mid % n]\n\n        if x &lt; target:\n            left = mid + 1\n        elif x &gt; target:\n            right = mid - 1\n        else:\n            return True\n\n    return False\n\n\nif __name__ == \"__main__\":\n    matrix = [[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]]\n    target = 3\n    print(searchMatrix(matrix, target))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/binary_search/#162-find-peak-element","title":"162. Find Peak Element","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"content/interview150/binary_search/#33-search-in-rotated-sorted-array","title":"33. Search in Rotated Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search 33. Search in Rotated Sorted Array - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef search(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] == target:\n            return mid\n\n        if nums[left] &lt;= nums[mid]:\n            if nums[left] &lt;= target &lt; nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if nums[mid] &lt; target &lt;= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n    return -1\n\n\nnums = [4, 5, 6, 7, 0, 1, 2]\ntarget = 0\nprint(search(nums, target))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/binary_search/#34-find-first-and-last-position-of-element-in-sorted-array","title":"34. Find First and Last Position of Element in Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> <li>Find the starting and ending position of a given target value in a sorted array.</li> </ul> 34. Find First and Last Position of Element in Sorted Array - Python Solution<pre><code>from bisect import bisect_left\nfrom typing import List\n\n\n# Binary Search\ndef searchRangeBS(nums: List[int], target: int) -&gt; List[int]:\n    def bisect_left(nums, target):\n        left, right = 0, len(nums) - 1\n        while left &lt;= right:\n            mid = left + (right - left) // 2\n            if nums[mid] &lt; target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n\n    left = bisect_left(nums, target)\n    right = bisect_left(nums, target + 1) - 1\n\n    if left &lt;= right:\n        return [left, right]\n\n    return [-1, -1]\n\n\n# Bisect\ndef searchRangeBSBisect(nums: List[int], target: int) -&gt; List[int]:\n    if not nums:\n        return [-1, -1]\n\n    left = bisect_left(nums, target)\n    right = bisect_left(nums, target + 1) - 1\n\n    return [left, right] if left &lt;= right else [-1, -1]\n\n\nnums = [5, 7, 7, 8, 8, 10]\ntarget = 8\nprint(searchRangeBS(nums, target))  # [3, 4]\nprint(searchRangeBSBisect(nums, target))  # [3, 4]\n</code></pre> 34. Find First and Last Position of Element in Sorted Array - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\n  int bisect_left(vector&lt;int&gt; &amp;nums, int target)\n  {\n    int left = 0, right = (int)nums.size() - 1;\n\n    while (left &lt;= right)\n    {\n      int mid = left + (right - left) / 2;\n      if (nums[mid] &lt; target)\n      {\n        left = mid + 1;\n      }\n      else\n      {\n        right = mid - 1;\n      }\n    }\n    return left;\n  }\n\npublic:\n  vector&lt;int&gt; searchRange(vector&lt;int&gt; &amp;nums, int target)\n  {\n    int left = bisect_left(nums, target);\n    if (left == (int)nums.size() || nums[left] != target)\n    {\n      return {-1, -1};\n    }\n    int right = bisect_left(nums, target + 1) - 1;\n    return {left, right};\n  }\n};\n\nint main()\n{\n  vector&lt;int&gt; nums = {5, 7, 7, 8, 8, 10};\n  int target = 8;\n  Solution s;\n  vector&lt;int&gt; res = s.searchRange(nums, target);\n  cout &lt;&lt; res[0] &lt;&lt; \", \" &lt;&lt; res[1] &lt;&lt; endl;\n  return 0;\n}\n</code></pre>"},{"location":"content/interview150/binary_search/#153-find-minimum-in-rotated-sorted-array","title":"153. Find Minimum in Rotated Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search 153. Find Minimum in Rotated Sorted Array - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef findMin(nums: List[int]) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt; right:\n        mid = left + (right - left) // 2\n        if nums[mid] &gt; nums[right]:\n            left = mid + 1\n        else:\n            right = mid\n\n    return nums[right]\n\n\nnums = [4, 5, 6, 7, 0, 1, 2]\nprint(findMin(nums))  # 0\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/binary_search/#4-median-of-two-sorted-arrays","title":"4. Median of Two Sorted Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, divide and conquer 4. Median of Two Sorted Arrays - Python Solution<pre><code>from typing import List\n\n\n# Brute Force\ndef findMedianSortedArraysBF(nums1: List[int], nums2: List[int]) -&gt; float:\n    nums = sorted(nums1 + nums2)\n    n = len(nums)\n    if n % 2 == 0:\n        return (nums[n // 2 - 1] + nums[n // 2]) / 2\n    else:\n        return nums[n // 2]\n\n\n# Binary Search\ndef findMedianSortedArraysBS(nums1: List[int], nums2: List[int]) -&gt; float:\n    if len(nums1) &gt; len(nums2):\n        nums1, nums2 = nums2, nums1\n\n    m, n = len(nums1), len(nums2)\n    imin, imax, half_len = 0, m, (m + n + 1) // 2\n\n    while imin &lt;= imax:\n        i = (imin + imax) // 2\n        j = half_len - i\n\n        if i &lt; m and nums2[j - 1] &gt; nums1[i]:\n            imin = i + 1\n        elif i &gt; 0 and nums1[i - 1] &gt; nums2[j]:\n            imax = i - 1\n        else:\n            if i == 0:\n                max_of_left = nums2[j - 1]\n            elif j == 0:\n                max_of_left = nums1[i - 1]\n            else:\n                max_of_left = max(nums1[i - 1], nums2[j - 1])\n\n            if (m + n) % 2 == 1:\n                return max_of_left\n\n            if i == m:\n                min_of_right = nums2[j]\n            elif j == n:\n                min_of_right = nums1[i]\n            else:\n                min_of_right = min(nums1[i], nums2[j])\n\n            return (max_of_left + min_of_right) / 2\n\n\n# |--------------|-----------------|--------------|\n# | Approach     | Time            | Space        |\n# |--------------|-----------------|--------------|\n# | Brute Force  | O((n+m)log(n+m))| O(n+m)       |\n# | Binary Search| O(log(min(n,m)))| O(1)         |\n# |--------------|-----------------|--------------|\n\n\nnums1 = [1, 3]\nnums2 = [2]\nprint(findMedianSortedArraysBF(nums1, nums2))  # 2.0\nprint(findMedianSortedArraysBS(nums1, nums2))  # 2.0\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/binary_search_tree/","title":"Binary Search Tree","text":""},{"location":"content/interview150/binary_search_tree/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 530. Minimum Absolute Difference in BST (Easy)</li> <li> 230. Kth Smallest Element in a BST (Medium)</li> <li> 98. Validate Binary Search Tree (Medium)</li> </ul>"},{"location":"content/interview150/binary_search_tree/#530-minimum-absolute-difference-in-bst","title":"530. Minimum Absolute Difference in BST","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary search tree, binary tree 530. Minimum Absolute Difference in BST - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef getMinimumDifference(root: Optional[TreeNode]) -&gt; int:\n    res = float(\"inf\")\n    pre = float(\"-inf\")\n\n    def dfs(node):  # inorder traversal\n        if not node:\n            return\n\n        dfs(node.left)\n\n        nonlocal res, pre\n        res = min(res, node.val - pre)\n        pre = node.val\n\n        if res == 1:  # the minimum possible difference\n            return\n\n        dfs(node.right)\n\n    dfs(root)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    root = [4, 2, 6, 1, 3]\n    root = build(root)\n    print(root)\n    #     __4\n    #    /   \\\n    #   2     6\n    #  / \\\n    # 1   3\n    assert getMinimumDifference(root) == 1\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/binary_search_tree/#230-kth-smallest-element-in-a-bst","title":"230. Kth Smallest Element in a BST","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree 230. Kth Smallest Element in a BST - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef kthSmallestRecursive(root: Optional[TreeNode], k: int) -&gt; int:\n    inorder = []\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n    return inorder[k - 1]\n\n\n# Iteratve\ndef kthSmallestIteratve(root: Optional[TreeNode], k: int) -&gt; int:\n    stack = []\n    while True:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        k -= 1\n        if not k:\n            return root.val\n        root = root.right\n\n\nif __name__ == \"__main__\":\n    root = build([3, 1, 4, None, 2])\n    k = 1\n    assert kthSmallestRecursive(root, k) == 1\n    assert kthSmallestIteratve(root, k) == 1\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/binary_search_tree/#98-validate-binary-search-tree","title":"98. Validate Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree 98. Validate Binary Search Tree - Python Solution<pre><code>from itertools import pairwise\nfrom math import inf\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef isValidBST1(root: Optional[TreeNode]) -&gt; bool:\n    inorder = []  # inorder traversal\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    for a, b in pairwise(inorder):\n        if a &gt;= b:\n            return False\n\n    return True\n\n\ndef isValidBST2(root: Optional[TreeNode]) -&gt; bool:\n    if not root:\n        return True\n    pre = -inf\n\n    def dfs(node):\n        if not node:\n            return True\n        if not dfs(node.left):\n            return False\n\n        nonlocal pre\n        if node.val &lt;= pre:\n            return False\n        pre = node.val\n\n        return dfs(node.right)\n\n    return dfs(root)\n\n\nif __name__ == \"__main__\":\n    root = [5, 1, 4, None, None, 3, 6]\n    root = build(root)\n    print(root)\n    #   5__\n    #  /   \\\n    # 1     4\n    #      / \\\n    #     3   6\n    assert not isValidBST1(root)  # [1, 5, 3, 4, 6]\n    assert not isValidBST2(root)  # [1, 5, 3, 4, 6]\n</code></pre></p> </li> </ul> 98. Validate Binary Search Tree - C++ Solution<pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   private:\n    vector&lt;int&gt; inorder;\n    bool check(vector&lt;int&gt; inorder) {\n        int n = inorder.size();\n        if (n &lt;= 1) return true;\n        for (int i = 1; i &lt; n; i++) {\n            if (inorder[i] &lt;= inorder[i - 1]) return false;\n        }\n        return true;\n    }\n\n   public:\n    bool isValidBST(TreeNode *root) {\n        auto dfs = [&amp;](auto &amp;&amp;self, TreeNode *node) -&gt; void {\n            if (!node) return;\n\n            self(self, node-&gt;left);\n            inorder.push_back(node-&gt;val);\n            self(self, node-&gt;right);\n        };\n\n        dfs(dfs, root);\n\n        return check(inorder);\n    }\n};\n\nint main() {\n    Solution s;\n    TreeNode *root = new TreeNode(2);\n    root-&gt;left = new TreeNode(1);\n    root-&gt;right = new TreeNode(3);\n    assert(s.isValidBST(root) == true);\n\n    root = new TreeNode(5);\n    root-&gt;left = new TreeNode(1);\n    root-&gt;right = new TreeNode(4);\n    root-&gt;right-&gt;left = new TreeNode(3);\n    root-&gt;right-&gt;right = new TreeNode(6);\n    assert(s.isValidBST(root) == false);\n\n    root = new TreeNode(5);\n    root-&gt;left = new TreeNode(4);\n    root-&gt;right = new TreeNode(6);\n    root-&gt;right-&gt;left = new TreeNode(3);\n    root-&gt;right-&gt;right = new TreeNode(7);\n    assert(s.isValidBST(root) == false);\n\n    return 0;\n}\n</code></pre>"},{"location":"content/interview150/binary_tree/","title":"Binary Tree","text":""},{"location":"content/interview150/binary_tree/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 104. Maximum Depth of Binary Tree (Easy)</li> <li> 100. Same Tree (Easy)</li> <li> 226. Invert Binary Tree (Easy)</li> <li> 101. Symmetric Tree (Easy)</li> <li> 105. Construct Binary Tree from Preorder and Inorder Traversal (Medium)</li> <li> 106. Construct Binary Tree from Inorder and Postorder Traversal (Medium)</li> <li> 117. Populating Next Right Pointers in Each Node II (Medium)</li> <li> 114. Flatten Binary Tree to Linked List (Medium)</li> <li> 112. Path Sum (Easy)</li> <li> 129. Sum Root to Leaf Numbers (Medium)</li> <li> 124. Binary Tree Maximum Path Sum (Hard)</li> <li> 173. Binary Search Tree Iterator (Medium)</li> <li> 222. Count Complete Tree Nodes (Easy)</li> <li> 236. Lowest Common Ancestor of a Binary Tree (Medium)</li> </ul>"},{"location":"content/interview150/binary_tree/#104-maximum-depth-of-binary-tree","title":"104. Maximum Depth of Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 104. Maximum Depth of Binary Tree - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef maxDepthRecursive(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    left = maxDepthRecursive(root.left)\n    right = maxDepthRecursive(root.right)\n\n    return 1 + max(left, right)\n\n\n# DFS\ndef maxDepthDFS(root: Optional[TreeNode]) -&gt; int:\n    res = 0\n\n    def dfs(node, cnt):\n        if node is None:\n            return\n        cnt += 1\n        nonlocal res\n        res = max(res, cnt)\n\n        dfs(node.left, cnt)\n        dfs(node.right, cnt)\n\n    dfs(root, 0)\n\n    return res\n\n\n# Iterative\ndef maxDepthIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n    res = 0\n\n    while q:\n        res += 1\n        n = len(q)\n\n        for _ in range(n):\n            node = q.popleft()\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    root = [1, 2, 2, 3, 4, None, None, None, None, 5]\n    root = build(root)\n    print(root)\n    #     ____1\n    #    /     \\\n    #   2__     2\n    #  /   \\\n    # 3     4\n    #      /\n    #     5\n    assert maxDepthRecursive(root) == 4\n    assert maxDepthDFS(root) == 4\n    assert maxDepthIterative(root) == 4\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/binary_tree/#100-same-tree","title":"100. Same Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 100. Same Tree - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# 1. Recursive\ndef isSameTreeRecursive(p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:\n    if not p and not q:\n        return True\n    elif not p or not q:\n        return False\n    elif p.val != q.val:\n        return False\n\n    return isSameTreeRecursive(p.left, q.left) and isSameTreeRecursive(\n        p.right, q.right\n    )\n\n\n# 2. Iterative with queue\ndef isSameTreeIterativeQueue(\n    p: Optional[TreeNode], q: Optional[TreeNode]\n) -&gt; bool:\n    queue = deque([(p, q)])\n\n    while queue:\n        p, q = queue.popleft()\n\n        if not p and not q:\n            continue\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n\n        queue.append((p.left, q.left))\n        queue.append((p.right, q.right))\n\n    return True\n\n\n# 3. Iterative with stack\ndef isSameTreeIterativeStack(\n    p: Optional[TreeNode], q: Optional[TreeNode]\n) -&gt; bool:\n    stack = [(p, q)]\n\n    while stack:\n        n1, n2 = stack.pop()\n\n        if not n1 and not n2:\n            continue\n        if not n1 or not n2:\n            return False\n        if n1.val != n2.val:\n            return False\n\n        stack.append((n1.left, n2.left))\n        stack.append((n1.right, n2.right))\n\n    return True\n\n\nif __name__ == \"__main__\":\n    p1 = build([1, 2, 3])\n    q1 = build([1, 2, 3])\n    p2 = build([1, 2])\n    q2 = build([1, None, 2])\n\n    assert isSameTreeRecursive(p1, q1) is True\n    assert isSameTreeRecursive(p2, q2) is False\n    assert isSameTreeIterativeQueue(p1, q1) is True\n    assert isSameTreeIterativeQueue(p2, q2) is False\n    assert isSameTreeIterativeStack(p1, q1) is True\n    assert isSameTreeIterativeStack(p2, q2) is False\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/binary_tree/#226-invert-binary-tree","title":"226. Invert Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 226. Invert Binary Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef invertTreeRecursive(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    root.left, root.right = root.right, root.left\n\n    invertTreeRecursive(root.left)\n    invertTreeRecursive(root.right)\n\n    return root\n\n\n# Iterative\ndef invertTreeIterative(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    stack = [root]\n\n    while stack:\n        node = stack.pop()\n\n        node.left, node.right = node.right, node.left\n        if node.left:\n            stack.append(node.left)\n        if node.right:\n            stack.append(node.right)\n\n    return root\n\n\nroot = build([4, 2, 7, 1, 3, 6, 9])\nprint(root)\n#     __4__\n#    /     \\\n#   2       7\n#  / \\     / \\\n# 1   3   6   9\ninvertedRecursive = invertTreeRecursive(root)\nprint(invertedRecursive)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\nroot = build([4, 2, 7, 1, 3, 6, 9])\ninvertedIterative = invertTreeIterative(root)\nprint(invertedIterative)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/binary_tree/#101-symmetric-tree","title":"101. Symmetric Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 101. Symmetric Tree - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef is_symmetric_recursive(root: Optional[TreeNode]) -&gt; bool:\n    if not root:\n        return True\n\n    def check(left, right):\n        if left is right:\n            return True\n        if not left or not right or left.val != right.val:\n            return False\n        outside = check(left.left, right.right)\n        inside = check(left.right, right.left)\n        return outside and inside\n\n    return check(root.left, root.right)\n\n\n# Iterative\ndef is_symmetric_iterative(root: Optional[TreeNode]) -&gt; bool:\n    if not root:\n        return True\n\n    q = deque()\n    q.append(root.left)\n    q.append(root.right)\n\n    while q:\n        left = q.popleft()\n        right = q.popleft()\n\n        if not left and not right:\n            continue\n\n        if not left or not right or left.val != right.val:\n            return False\n\n        q.append(left.left)\n        q.append(right.right)\n        q.append(left.right)\n        q.append(right.left)\n\n    return True\n\n\nif __name__ == \"__main__\":\n    root = [1, 2, 2, 3, 4, 4, 3]\n    root = build(root)\n    print(root)\n    #     __1__\n    #    /     \\\n    #   2       2\n    #  / \\     / \\\n    # 3   4   4   3\n    assert is_symmetric_recursive(root) is True\n    assert is_symmetric_iterative(root) is True\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/binary_tree/#105-construct-binary-tree-from-preorder-and-inorder-traversal","title":"105. Construct Binary Tree from Preorder and Inorder Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, divide and conquer, tree, binary tree 105. Construct Binary Tree from Preorder and Inorder Traversal - Python Solution<pre><code>from typing import List, Optional\n\nfrom helper import TreeNode\n\n\ndef buildTree(preorder: List[int], inorder: List[int]) -&gt; Optional[TreeNode]:\n    \"\"\"\n    preorder  root left right  1  2  3\n    inorder   left root right  4  5  6\n    \"\"\"\n    if len(preorder) == 0:\n        return None\n\n    root_val = preorder[0]  # 1\n    root = TreeNode(root_val)\n\n    separator_idx = inorder.index(root_val)  # 5\n\n    left_inorder = inorder[:separator_idx]  # 4\n    right_inorder = inorder[separator_idx + 1 :]  # 6\n\n    left_preorder = preorder[1 : 1 + len(left_inorder)]  # 2\n    right_preorder = preorder[1 + len(left_inorder) :]  # 3\n\n    root.left = buildTree(left_preorder, left_inorder)\n    root.right = buildTree(right_preorder, right_inorder)\n\n    return root\n\n\npreorder = [3, 9, 20, 15, 7]\ninorder = [9, 3, 15, 20, 7]\nroot = buildTree(preorder, inorder)\nprint(root)\n#     3\n#    / \\\n#   9  20\n#     /  \\\n#    15   7\n</code></pre></p> </li> </ul> 105. Construct Binary Tree from Preorder and Inorder Traversal - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   public:\n    vector&lt;int&gt; preorder;\n    unordered_map&lt;int, int&gt; inorderMap;\n\n    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {\n        this-&gt;preorder = preorder;\n        for (size_t i = 0; i &lt; inorder.size(); i++) {\n            inorderMap[inorder[i]] = i;\n        }\n        return buildSubtree(0, 0, inorder.size() - 1);\n    }\n\n   private:\n    TreeNode* buildSubtree(int rootIndex, int left, int right) {\n        if (left &gt; right) return nullptr;\n\n        TreeNode* root = new TreeNode(preorder[rootIndex]);\n        int inorderIndex = inorderMap[preorder[rootIndex]];\n\n        root-&gt;left = buildSubtree(rootIndex + 1, left, inorderIndex - 1);\n        root-&gt;right = buildSubtree(rootIndex + (inorderIndex - left + 1),\n                                   inorderIndex + 1, right);\n\n        return root;\n    }\n};\n\nint main() {\n    vector&lt;int&gt; preorder = {3, 9, 20, 15, 7};\n    vector&lt;int&gt; inorder = {9, 3, 15, 20, 7};\n    Solution solution;\n    TreeNode* root = solution.buildTree(preorder, inorder);\n    cout &lt;&lt; root-&gt;val &lt;&lt; endl;                // 3\n    cout &lt;&lt; root-&gt;left-&gt;val &lt;&lt; endl;          // 9\n    cout &lt;&lt; root-&gt;right-&gt;val &lt;&lt; endl;         // 20\n    cout &lt;&lt; root-&gt;right-&gt;left-&gt;val &lt;&lt; endl;   // 15\n    cout &lt;&lt; root-&gt;right-&gt;right-&gt;val &lt;&lt; endl;  // 7\n    return 0;\n}\n</code></pre>"},{"location":"content/interview150/binary_tree/#106-construct-binary-tree-from-inorder-and-postorder-traversal","title":"106. Construct Binary Tree from Inorder and Postorder Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, divide and conquer, tree, binary tree 106. Construct Binary Tree from Inorder and Postorder Traversal - Python Solution<pre><code>from typing import List, Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef buildTree(inorder: List[int], postorder: List[int]) -&gt; Optional[TreeNode]:\n    \"\"\"\n    inorder:    left root  right   1  2  3\n    postorder:  left right root    4  5  6\n    \"\"\"\n\n    if not postorder:\n        return None\n\n    root_val = postorder[-1]  # 6\n    root = TreeNode(root_val)\n\n    separator_idx = inorder.index(root_val)  # 2\n\n    left_inorder = inorder[:separator_idx]  # 1\n    right_inorder = inorder[separator_idx + 1 :]  # 3\n\n    left_postorder = postorder[: len(left_inorder)]  # 4\n    right_postorder = postorder[len(left_inorder) : -1]  # 5\n\n    root.left = buildTree(left_inorder, left_postorder)\n    root.right = buildTree(right_inorder, right_postorder)\n\n    return root\n\n\ninorder = [9, 3, 15, 20, 7]\npostorder = [9, 15, 7, 20, 3]\nroot = buildTree(inorder, postorder)\nprint(root)\n#     3\n#    / \\\n#   9  20\n#     /  \\\n#    15   7\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/binary_tree/#117-populating-next-right-pointers-in-each-node-ii","title":"117. Populating Next Right Pointers in Each Node II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, tree, depth first search, breadth first search, binary tree 117. Populating Next Right Pointers in Each Node II - Python Solution<pre><code>from collections import deque\n\n\nclass Node:\n    def __init__(\n        self,\n        val: int = 0,\n        left: \"Node\" = None,\n        right: \"Node\" = None,\n        next: \"Node\" = None,\n    ):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\n\ndef connect(root: \"Node\") -&gt; \"Node\":\n    if not root:\n        return root\n\n    queue = deque([root])\n\n    while queue:\n        size = len(queue)\n        prev = None\n\n        for _ in range(size):\n            node = queue.popleft()\n\n            if prev:\n                prev.next = node\n\n            prev = node\n\n            if node.left:\n                queue.append(node.left)\n\n            if node.right:\n                queue.append(node.right)\n\n    return root\n\n\n# Binary tree creation\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.right.right = Node(7)\n#       1\n#      / \\\n#     2   3\n#    / \\   \\\n#   4   5   7\n\n# Connect the nodes\nconnect(root)\n#       1 -&gt; None\n#      / \\\n#     2 -&gt; 3 -&gt; None\n#    / \\    \\\n#   4 -&gt; 5 -&gt; 7 -&gt; None\n\nassert root.next is None\nassert root.left.next == root.right\nassert root.right.next is None\nassert root.left.left.next == root.left.right\nassert root.left.right.next == root.right.right\nassert root.right.right.next is None\n\nprint(\"All tests passed.\")\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/binary_tree/#114-flatten-binary-tree-to-linked-list","title":"114. Flatten Binary Tree to Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, stack, tree, depth first search, binary tree 114. Flatten Binary Tree to Linked List - C++ Solution<pre><code>struct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n    TreeNode* head;\n\n   public:\n    void flatten(TreeNode* root) {\n        if (!root) return;\n\n        flatten(root-&gt;right);\n        flatten(root-&gt;left);\n        root-&gt;left = nullptr;\n        root-&gt;right = head;\n        head = root;\n    }\n};\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/binary_tree/#112-path-sum","title":"112. Path Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 112. Path Sum - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef hasPathSum(root: Optional[TreeNode], targetSum: int) -&gt; bool:\n    if not root:\n        return False\n\n    if not root.left and not root.right:\n        return root.val == targetSum\n\n    targetSum -= root.val\n\n    return hasPathSum(root.left, targetSum) or hasPathSum(\n        root.right, targetSum\n    )\n\n\nroot = build([5, 4, 8, 11, None, 13, 4, 7, 2, None, None, None, None, None, 1])\nprint(root)\n#          5___\n#         /    \\\n#     ___4     _8\n#    /        /  \\\n#   11       13   4\n#  /  \\            \\\n# 7    2            1\nprint(hasPathSum(root, 22))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/binary_tree/#129-sum-root-to-leaf-numbers","title":"129. Sum Root to Leaf Numbers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree 129. Sum Root to Leaf Numbers - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -&gt; int:\n        self.res = 0\n\n        def dfs(node, cur):\n            if not node:\n                return\n            cur = cur * 10 + node.val\n            if not node.left and not node.right:\n                self.res += cur\n                return\n            dfs(node.left, cur)\n            dfs(node.right, cur)\n\n        dfs(root, 0)\n\n        return self.res\n\n\nroot = [1, 2, 3]\nroot = build(root)\nprint(root)\n#   1\n#  / \\\n# 2   3\nprint(Solution().sumNumbers(root))  # 25\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/binary_tree/#124-binary-tree-maximum-path-sum","title":"124. Binary Tree Maximum Path Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, tree, depth first search, binary tree 124. Binary Tree Maximum Path Sum - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef maxPathSum(root: Optional[TreeNode]) -&gt; int:\n    res = float(\"-inf\")\n\n    def dfs(node):\n        if not node:\n            return 0\n\n        leftMax = max(dfs(node.left), 0)\n        rightMax = max(dfs(node.right), 0)\n\n        cur = node.val + leftMax + rightMax\n        nonlocal res\n        res = max(res, cur)\n\n        return node.val + max(leftMax, rightMax)\n\n    dfs(root)\n\n    return res\n\n\nroot = build([-10, 9, 20, None, None, 15, 7])\nprint(root)\n#   -10___\n#  /      \\\n# 9       _20\n#        /   \\\n#       15    7\nprint(maxPathSum(root))  # 42\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/binary_tree/#173-binary-search-tree-iterator","title":"173. Binary Search Tree Iterator","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: stack, tree, design, binary search tree, binary tree, iterator 173. Binary Search Tree Iterator - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BST\nclass BSTIterator:\n\n    def __init__(self, root: Optional[TreeNode]):\n        self.stack = []\n        self._leftmost_inorder(root)\n\n    def _leftmost_inorder(self, root):\n        while root:\n            self.stack.append(root)\n            root = root.left\n\n    def next(self) -&gt; int:\n        topmost_node = self.stack.pop()\n\n        if topmost_node.right:\n            self._leftmost_inorder(topmost_node.right)\n\n        return topmost_node.val\n\n    def hasNext(self) -&gt; bool:\n        return len(self.stack) &gt; 0\n\n\nroot = build([7, 3, 15, None, None, 9, 20])\nprint(root)\n#   7__\n#  /   \\\n# 3     15\n#      /  \\\n#     9    20\nobj = BSTIterator(root)\nprint(obj.next())  # 3\nprint(obj.next())  # 7\nprint(obj.hasNext())  # True\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/binary_tree/#222-count-complete-tree-nodes","title":"222. Count Complete Tree Nodes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: binary search, bit manipulation, tree, binary tree 222. Count Complete Tree Nodes - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef countNodesRecursive(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    num = 1 + countNodesRecursive(root.left) + countNodesRecursive(root.right)\n\n    return num\n\n\n# Iterative\ndef countNodesIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n    count = 0\n\n    while q:\n        n = len(q)\n\n        for _ in range(n):\n            node = q.popleft()\n            count += 1\n\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return count\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Recursive  |  O(n)  |  O(n)   |\n# | Iterative  |  O(n)  |  O(n)   |\n# |------------|--------|---------|\n\nroot = [1, 2, 3, 4, 5, 6]\nroot = build(root)\nprint(root)\n#     __1__\n#    /     \\\n#   2       3\n#  / \\     /\n# 4   5   6\nprint(countNodesRecursive(root))  # 6\nprint(countNodesIterative(root))  # 6\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/binary_tree/#236-lowest-common-ancestor-of-a-binary-tree","title":"236. Lowest Common Ancestor of a Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree 236. Lowest Common Ancestor of a Binary Tree - Python Solution<pre><code>from typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef lowestCommonAncestor(\n    root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n) -&gt; \"TreeNode\":\n    if not root or q == root or p == root:\n        return root\n\n    left = lowestCommonAncestor(root.left, p, q)\n    right = lowestCommonAncestor(root.right, p, q)\n\n    if left and right:\n        return root\n\n    return left or right\n\n\nroot = build([3, 5, 1, 6, 2, 0, 8, None, None, 7, 4])\nprint(root)\n#     ______3__\n#    /         \\\n#   5__         1\n#  /   \\       / \\\n# 6     2     0   8\n#      / \\\n#     7   4\np = root.left  # 5\nq = root.right  # 1\nprint(lowestCommonAncestor(root, p, q))  # 3\n#     ______3__\n#    /         \\\n#   5__         1\n#  /   \\       / \\\n# 6     2     0   8\n#      / \\\n#     7   4\nr = root.left.right.right  # 4\nprint(lowestCommonAncestor(root, p, r))  # 5\n#   5__\n#  /   \\\n# 6     2\n#      / \\\n#     7   4\n</code></pre></p> </li> </ul> 236. Lowest Common Ancestor of a Binary Tree - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   public:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if (root == nullptr || root == p || root == q) {\n            return root;\n        }\n\n        TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);\n        TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);\n\n        if (left &amp;&amp; right) {\n            return root;\n        }\n\n        return left ? left : right;\n    }\n};\n\nint main() { return 0; }\n</code></pre>"},{"location":"content/interview150/binary_tree_level_order/","title":"Binary Tree Level Order","text":""},{"location":"content/interview150/binary_tree_level_order/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 199. Binary Tree Right Side View (Medium)</li> <li> 637. Average of Levels in Binary Tree (Easy)</li> <li> 102. Binary Tree Level Order Traversal (Medium)</li> <li> 103. Binary Tree Zigzag Level Order Traversal (Medium)</li> </ul>"},{"location":"content/interview150/binary_tree_level_order/#199-binary-tree-right-side-view","title":"199. Binary Tree Right Side View","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 199. Binary Tree Right Side View - Python Solution<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Binary Tree BFS\ndef rightSideViewBFS(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        n = len(q)\n        for i in range(n):\n            node = q.popleft()\n            if i == n - 1:\n                res.append(node.val)\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return res\n\n\n# Binary Tree DFS\ndef rightSideViewDFS(root: Optional[TreeNode]) -&gt; List[int]:\n    \"\"\"\u540e\u5e8f\u904d\u5386\uff0c\u5148\u53f3\u540e\u5de6\uff0c\u9047\u5230\u7684\u7b2c\u4e00\u4e2a\u8282\u70b9\u5c31\u662f\u8be5\u6df1\u5ea6\u7684\u6700\u53f3\u4fa7\u8282\u70b9\"\"\"\n    ans = []\n\n    def dfs(node, depth):\n        if node is None:\n            return\n        if depth == len(ans):  # \u8fd9\u4e2a\u6df1\u5ea6\u9996\u6b21\u9047\u5230\n            ans.append(node.val)\n\n        dfs(node.right, depth + 1)\n        dfs(node.left, depth + 1)\n\n    dfs(root, 0)\n\n    return ans\n\n\nif __name__ == \"__main__\":\n    root = [1, 2, 2, 3, 4, None, 3, None, None, 5]\n    root = build(root)\n    print(root)\n    #     ____1\n    #    /     \\\n    #   2__     2\n    #  /   \\     \\\n    # 3     4     3\n    #      /\n    #     5\n    assert rightSideViewBFS(root) == [1, 2, 3, 5]\n    assert rightSideViewDFS(root) == [1, 2, 3, 5]\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/binary_tree_level_order/#637-average-of-levels-in-binary-tree","title":"637. Average of Levels in Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 637. Average of Levels in Binary Tree - Python Solution<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Binary Tree BFS\ndef averageOfLevels(root: Optional[TreeNode]) -&gt; List[float]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        n = len(q)\n        level = 0\n        for _ in range(n):\n            cur = q.popleft()\n            level += cur.val\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(float(level / n))\n\n    return res\n\n\nif __name__ == \"__main__\":\n    root = [3, 9, 20, None, None, 15, 7]\n    root = build(root)\n    print(root)\n    #   3___\n    #  /    \\\n    # 9     _20\n    #      /   \\\n    #     15    7\n    assert averageOfLevels(root) == [3.00000, 14.50000, 11.00000]\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/binary_tree_level_order/#102-binary-tree-level-order-traversal","title":"102. Binary Tree Level Order Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, breadth first search, binary tree 102. Binary Tree Level Order Traversal - Python Solution<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef levelOrder(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        level = []\n        size = len(q)\n\n        for _ in range(size):\n            cur = q.popleft()\n            level.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(level)\n\n    return res\n\n\ntree = build([3, 9, 20, None, None, 15, 7])\nprint(tree)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(levelOrder(tree))  # [[3], [9, 20], [15, 7]]\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/binary_tree_level_order/#103-binary-tree-zigzag-level-order-traversal","title":"103. Binary Tree Zigzag Level Order Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, breadth first search, binary tree 103. Binary Tree Zigzag Level Order Traversal - Python Solution<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef zigzagLevelOrder(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        level = []\n        size = len(q)\n\n        for _ in range(size):\n            cur = q.popleft()\n            level.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(level if not len(res) % 2 else level[::-1])\n\n    return res\n\n\nif __name__ == \"__main__\":\n    tree = build([3, 9, 20, None, None, 15, 7])\n    print(tree)\n    #   3___\n    #  /    \\\n    # 9     _20\n    #      /   \\\n    #     15    7\n    assert zigzagLevelOrder(tree) == [[3], [20, 9], [15, 7]]\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/bit_manipulation/","title":"Bit Manipulation","text":""},{"location":"content/interview150/bit_manipulation/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 67. Add Binary (Easy)</li> <li> 190. Reverse Bits (Easy)</li> <li> 191. Number of 1 Bits (Easy)</li> <li> 136. Single Number (Easy)</li> <li> 137. Single Number II (Medium)</li> <li> 201. Bitwise AND of Numbers Range (Medium)</li> </ul>"},{"location":"content/interview150/bit_manipulation/#67-add-binary","title":"67. Add Binary","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, string, bit manipulation, simulation</p> </li> </ul>"},{"location":"content/interview150/bit_manipulation/#190-reverse-bits","title":"190. Reverse Bits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: divide and conquer, bit manipulation 190. Reverse Bits - Python Solution<pre><code># Bit Manipulation\ndef reverseBits(n: int) -&gt; int:\n    res = 0\n\n    for i in range(32):\n        res = (res &lt;&lt; 1) | (n &amp; 1)\n        n &gt;&gt;= 1\n\n    return res\n\n\nn = 0b00000010100101000001111010011100\nprint(reverseBits(n))  # 964176192\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/bit_manipulation/#191-number-of-1-bits","title":"191. Number of 1 Bits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: divide and conquer, bit manipulation 191. Number of 1 Bits - Python Solution<pre><code># Bit Manipulation\ndef hammingWeight1(n: int) -&gt; int:\n    res = 0\n\n    while n != 0:\n        n = n &amp; (n - 1)  # Unset the rightmost 1-bit\n        res += 1\n\n    return res\n\n\ndef hammingWeight2(n: int) -&gt; int:\n    return bin(n).count(\"1\")\n\n\ndef hammingWeight3(n: int) -&gt; int:\n    def decimalToBinary(n: int) -&gt; str:\n        if n == 0:\n            return \"0\"\n\n        binary = \"\"\n        while n &gt; 0:\n            binary = str(n % 2) + binary\n            n //= 2\n\n        return binary\n\n    binary = decimalToBinary(n)\n\n    return binary.count(\"1\")\n\n\nn = 11\nprint(hammingWeight1(n))  # 3\nprint(hammingWeight2(n))  # 3\n\nn = 47\nprint(bin(n))\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/bit_manipulation/#136-single-number","title":"136. Single Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, bit manipulation 136. Single Number - Python Solution<pre><code>from functools import reduce\nfrom operator import xor\nfrom typing import List\n\n\n# XOR\ndef singleNumber(nums: List[int]) -&gt; int:\n    res = 0\n    for num in nums:\n        res ^= num\n    return res\n\n\n# XOR\ndef singleNumberXOR(nums: List[int]) -&gt; int:\n    return reduce(xor, nums)\n\n\n# XOR\ndef singleNumberXORLambda(nums: List[int]) -&gt; int:\n    return reduce(lambda x, y: x ^ y, nums)\n\n\nnums = [4, 1, 2, 1, 2]\nprint(singleNumber(nums))  # 4\nprint(singleNumberXOR(nums))  # 4\nprint(singleNumberXORLambda(nums))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/bit_manipulation/#137-single-number-ii","title":"137. Single Number II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation</p> </li> </ul>"},{"location":"content/interview150/bit_manipulation/#201-bitwise-and-of-numbers-range","title":"201. Bitwise AND of Numbers Range","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: bit manipulation</p> </li> </ul>"},{"location":"content/interview150/divide_and_conquer/","title":"Divide and Conquer","text":""},{"location":"content/interview150/divide_and_conquer/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 108. Convert Sorted Array to Binary Search Tree (Easy)</li> <li> 148. Sort List (Medium)</li> <li> 427. Construct Quad Tree (Medium)</li> <li> 23. Merge k Sorted Lists (Hard)</li> </ul>"},{"location":"content/interview150/divide_and_conquer/#108-convert-sorted-array-to-binary-search-tree","title":"108. Convert Sorted Array to Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, divide and conquer, tree, binary search tree, binary tree 108. Convert Sorted Array to Binary Search Tree - Python Solution<pre><code>from typing import List, Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef sortedArrayToBST(nums: List[int]) -&gt; Optional[TreeNode]:\n    if len(nums) == 0:\n        return None\n\n    mid = len(nums) // 2\n    root = TreeNode(nums[mid])\n\n    root.left = sortedArrayToBST(nums[:mid])\n    root.right = sortedArrayToBST(nums[mid + 1 :])\n\n    return root\n\n\nnums = [-10, -3, 0, 5, 9]\nroot = sortedArrayToBST(nums)\n#      0\n#     / \\\n#   -3   9\n#   /   /\n# -10  5\n</code></pre></p> </li> </ul> 108. Convert Sorted Array to Binary Search Tree - C++ Solution<pre><code>#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   public:\n    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) {\n        if (nums.size() == 0) return nullptr;\n\n        int mid = nums.size() / 2;\n        TreeNode* root = new TreeNode(nums[mid]);\n\n        vector&lt;int&gt; left(nums.begin(), nums.begin() + mid);\n        vector&lt;int&gt; right(nums.begin() + mid + 1, nums.end());\n\n        root-&gt;left = sortedArrayToBST(left);\n        root-&gt;right = sortedArrayToBST(right);\n\n        return root;\n    }\n};\n\nint main() { return 0; }\n</code></pre>"},{"location":"content/interview150/divide_and_conquer/#148-sort-list","title":"148. Sort List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, two pointers, divide and conquer, sorting, merge sort 148. Sort List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef sortListSort(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    nums = []\n\n    while head:\n        nums.append(head.val)\n        head = head.next\n\n    dummy = ListNode()\n    cur = dummy\n    nums.sort()\n\n    for num in nums:\n        cur.next = ListNode(val=num)\n        cur = cur.next\n\n    return dummy.next\n\n\n# Linked List\ndef sortListDivideConquer(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    def middle(node):\n        fast, slow = node, node\n        while fast and fast.next:\n            pre = slow\n            slow = slow.next\n            fast = fast.next.next\n        pre.next = None\n        return slow\n\n    def merge_two_lists(l1, l2):\n        dummy = ListNode()\n        cur = dummy\n        while l1 and l2:\n            if l1.val &lt; l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n            cur = cur.next\n\n        cur.next = l1 if l1 else l2\n        return dummy.next\n\n    if not head or not head.next:\n        return head\n\n    head2 = middle(head)\n    head = sortListDivideConquer(head)\n    head2 = sortListDivideConquer(head2)\n\n    return merge_two_lists(head, head2)\n\n\nhead = ListNode().create([4, 2, 1, 3])\nprint(head)  # 4 -&gt; 2 -&gt; 1 -&gt; 3\nprint(sortListSort(head))  # 1 -&gt; 2 -&gt; 3 -&gt; 4\nprint(sortListDivideConquer(head))  # 1 -&gt; 2 -&gt; 3 -&gt; 4\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/divide_and_conquer/#427-construct-quad-tree","title":"427. Construct Quad Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, divide and conquer, tree, matrix</p> </li> </ul>"},{"location":"content/interview150/divide_and_conquer/#23-merge-k-sorted-lists","title":"23. Merge k Sorted Lists","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: linked list, divide and conquer, heap priority queue, merge sort</p> </li> <li>Prerequisite: 21. Merge Two Sorted Lists</li> <li>Video explanation: 23. Merge K Sorted Lists - NeetCode</li> </ul> 23. Merge k Sorted Lists - Python Solution<pre><code>import copy\nimport heapq\nfrom typing import List, Optional\n\nfrom template import ListNode\n\n\n# Divide and Conquer\ndef mergeKListsDC(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    if not lists or len(lists) == 0:\n        return None\n\n    def mergeTwo(l1, l2):\n        dummy = ListNode()\n        cur = dummy\n\n        while l1 and l2:\n            if l1.val &lt; l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n\n            cur = cur.next\n\n        cur.next = l1 if l1 else l2\n\n        return dummy.next\n\n    while len(lists) &gt; 1:\n        merged = []\n\n        for i in range(0, len(lists), 2):\n            l1 = lists[i]\n            l2 = lists[i + 1] if i + 1 &lt; len(lists) else None\n            merged.append(mergeTwo(l1, l2))\n\n        lists = merged\n\n    return lists[0]\n\n\n# Heap - Merge k Sorted\ndef mergeKLists(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    minHeap = []  # (val, idx, node)\n\n    for idx, head in enumerate(lists):\n        if head:\n            heapq.heappush(minHeap, (head.val, idx, head))\n\n    while minHeap:\n        _, idx, node = heapq.heappop(minHeap)\n        cur.next = node\n        cur = cur.next\n\n        node = node.next\n        if node:\n            heapq.heappush(minHeap, (node.val, idx, node))\n\n    return dummy.next\n\n\nn1 = ListNode.create([1, 4, 5])\nn2 = ListNode.create([1, 3, 4])\nn3 = ListNode.create([2, 6])\nlists = [n1, n2, n3]\nlists1 = copy.deepcopy(lists)\nlists2 = copy.deepcopy(lists)\nprint(mergeKListsDC(lists1))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6\nprint(mergeKLists(lists2))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6\n</code></pre>"},{"location":"content/interview150/graph/","title":"Graph","text":""},{"location":"content/interview150/graph/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 200. Number of Islands (Medium)</li> <li> 130. Surrounded Regions (Medium)</li> <li> 133. Clone Graph (Medium)</li> <li> 399. Evaluate Division (Medium)</li> <li> 207. Course Schedule (Medium)</li> <li> 210. Course Schedule II (Medium)</li> </ul>"},{"location":"content/interview150/graph/#200-number-of-islands","title":"200. Number of Islands","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix</p> </li> <li>Count the number of islands in a 2D grid.</li> <li>Method 1: DFS</li> <li> <p>Method 2: BFS (use a queue to traverse the grid)</p> </li> <li> <p>How to keep track of visited cells?</p> <ol> <li>Mark the visited cell as <code>0</code> (or any other value) to avoid revisiting it.</li> <li>Use a set to store the visited cells.</li> </ol> </li> <li> <p>Steps:</p> <ol> <li>Init: variables</li> <li>DFS/BFS: starting from the cell with <code>1</code>, turn all the connected <code>1</code>s to <code>0</code>.</li> <li>Traverse the grid, and if the cell is <code>1</code>, increment the count and call DFS/BFS.</li> </ol> </li> </ul> <p></p> 200. Number of Islands - Python Solution<pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef numIslandsDFS(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    res = 0\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] != \"1\":\n            return\n\n        grid[r][c] = \"2\"\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                dfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Set\ndef numIslandsBFS1(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == \"0\"\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\" and (r, c) not in visited:\n                visited.add((r, c))\n                bfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = dr + row, dc + col\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] != \"1\"\n                ):\n                    continue\n                grid[nr][nc] = \"2\"\n                q.append((nr, nc))\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == \"1\":\n                grid[i][j] = \"2\"\n                bfs(i, j)\n                res += 1\n\n    return res\n\n\ngrid = [\n    [\"1\", \"1\", \"1\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"0\", \"0\", \"0\", \"0\", \"0\"],\n]\n\nprint(numIslandsDFS(deepcopy(grid)))  # 1\nprint(numIslandsBFS1(deepcopy(grid)))  # 1\nprint(numIslandsBFS2(deepcopy(grid)))  # 1\n</code></pre> 200. Number of Islands - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\nprivate:\n    void dfs(vector&lt;vector&lt;char&gt;&gt; &amp;grid, int r, int c)\n    {\n        int row = grid.size();\n        int col = grid[0].size();\n\n        if (r &lt; 0 || r &gt;= row || c &lt; 0 || c &gt;= col || grid[r][c] != '1')\n        {\n            return;\n        }\n        grid[r][c] = '0';\n\n        dfs(grid, r - 1, c);\n        dfs(grid, r + 1, c);\n        dfs(grid, r, c - 1);\n        dfs(grid, r, c + 1);\n    }\n\npublic:\n    int numIslands(vector&lt;vector&lt;char&gt;&gt; &amp;grid)\n    {\n        int m = grid.size(), n = grid[0].size();\n        int res = 0;\n        for (int i = 0; i &lt; m; i++)\n        {\n            for (int j = 0; j &lt; n; j++)\n            {\n                if (grid[i][j] == '1')\n                {\n                    res++;\n                    dfs(grid, i, j);\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    Solution s;\n    vector&lt;vector&lt;char&gt;&gt; grid = {\n        {'1', '1', '0', '0', '0'},\n        {'1', '1', '0', '0', '0'},\n        {'0', '0', '1', '0', '0'},\n        {'0', '0', '0', '1', '1'}};\n    cout &lt;&lt; s.numIslands(grid) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/interview150/graph/#130-surrounded-regions","title":"130. Surrounded Regions","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix 130. Surrounded Regions - Python Solution<pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef solveDFS(board: List[List[str]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n    if not board and not board[0]:\n        return None\n\n    m, n = len(board), len(board[0])\n\n    def capture(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or board[r][c] != \"O\":\n            return None\n\n        board[r][c] = \"T\"\n        capture(r + 1, c)\n        capture(r - 1, c)\n        capture(r, c + 1)\n        capture(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\" and (r in [0, m - 1] or c in [0, n - 1]):\n                capture(r, c)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\":\n                board[r][c] = \"X\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"T\":\n                board[r][c] = \"O\"\n\n\n# BFS\ndef solveBFS(board: List[List[str]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n    if not board and not board[0]:\n        return None\n\n    m, n = len(board), len(board[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def capture(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr = row + dr\n                nc = col + dc\n                if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and board[nr][nc] == \"O\":\n                    board[nr][nc] = \"T\"\n                    q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\" and (r in [0, m - 1] or c in [0, n - 1]):\n                board[r][c] = \"T\"\n                capture(r, c)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\":\n                board[r][c] = \"X\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"T\":\n                board[r][c] = \"O\"\n\n\nif __name__ == \"__main__\":\n    board = [\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"O\", \"O\", \"X\"],\n        [\"X\", \"X\", \"O\", \"X\"],\n        [\"X\", \"O\", \"X\", \"X\"],\n    ]\n\n    b = deepcopy(board)\n    solveDFS(b)\n    assert b == [\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"O\", \"X\", \"X\"],\n    ]\n\n    b = deepcopy(board)\n    solveBFS(b)\n    assert b == [\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"O\", \"X\", \"X\"],\n    ]\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/graph/#133-clone-graph","title":"133. Clone Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, depth first search, breadth first search, graph 133. Clone Graph - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\n\nclass Node:\n    def __init__(self, val=0, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\n\n# 1. DFS\ndef cloneGraphDFS(node: Optional[\"Node\"]) -&gt; Optional[\"Node\"]:\n    if not node:\n        return None\n\n    cloned = {}  # {old: new}\n\n    def dfs(node):\n        if node in cloned:\n            return cloned[node]\n\n        new = Node(node.val)\n        cloned[node] = new\n\n        for neighbor in node.neighbors:\n            new.neighbors.append(dfs(neighbor))\n\n        return new\n\n    return dfs(node)\n\n\n# 2. BFS\ndef cloneGraphBFS(node: Optional[\"Node\"]) -&gt; Optional[\"Node\"]:\n    if not node:\n        return None\n\n    cloned = {node: Node(node.val)}\n    q = deque([node])\n\n    while q:\n        cur = q.popleft()\n\n        for neighbor in cur.neighbors:\n            if neighbor not in cloned:\n                cloned[neighbor] = Node(neighbor.val)\n                q.append(neighbor)\n\n            cloned[cur].neighbors.append(cloned[neighbor])\n\n    return cloned[node]\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/graph/#399-evaluate-division","title":"399. Evaluate Division","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, depth first search, breadth first search, union find, graph, shortest path 399. Evaluate Division - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef calcEquation(\n    equations: List[List[str]], values: List[float], queries: List[List[str]]\n) -&gt; List[float]:\n    graph = defaultdict(dict)\n    for (a, b), v in zip(equations, values):\n        graph[a][b] = v\n        graph[b][a] = 1 / v\n\n    def dfs(a, b, visited):\n        if a not in graph or b not in graph:\n            return -1.0\n\n        if b in graph[a]:\n            return graph[a][b]\n\n        for c in graph[a]:\n            if c not in visited:\n                visited.add(c)\n                d = dfs(c, b, visited)\n                if d != -1.0:\n                    return graph[a][c] * d\n        return -1.0\n\n    result = []\n    for a, b in queries:\n        result.append(dfs(a, b, set()))\n\n    return result\n\n\nequations = [[\"a\", \"b\"], [\"b\", \"c\"]]\nvalues = [2.0, 3.0]\nqueries = [[\"a\", \"c\"], [\"b\", \"a\"], [\"a\", \"e\"], [\"a\", \"a\"], [\"x\", \"x\"]]\nprint(calcEquation(equations, values, queries))  # [6.0, 0.5, -1.0, 1.0, -1.0]\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/graph/#207-course-schedule","title":"207. Course Schedule","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort</p> </li> <li>Return true if it is possible to finish all courses, otherwise return false.</li> <li>Dependency relationships imply the topological sort algorithm.</li> <li>Cycle detection</li> <li>Topological Sort</li> <li>DAG (Directed Acyclic Graph)</li> <li>Time complexity: O(V+E)</li> <li>Space complexity: O(V+E)</li> <li>Prerequisites: Indegree (Look at the problem 1557. Minimum Number of Vertices to Reach All Nodes)<ul> <li>Indegree: Number of incoming edges to a vertex</li> </ul> </li> <li>Applications: task scheduling, course scheduling, build systems, dependency resolution, compiler optimization, etc.</li> </ul> <p></p> <p></p> <p>Course to prerequisites mapping</p> <pre><code>flowchart LR\n    0((0)) --&gt; 1((1))\n    0((0)) --&gt; 2((2))\n    1((1)) --&gt; 3((3))\n    3((3)) --&gt; 4((4))\n    1((1)) --&gt; 4((4))</code></pre> <p>Prerequisites to course mapping</p> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    2((2)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))\n    4((4)) --&gt; 3((3))\n    4((4)) --&gt; 1((1))</code></pre> course 0 0 1 1 3 prerequisite 1 2 3 4 4 index 0 1 2 3 4 in-degree 0 0 0 0 0 <p>Initialize</p> <ul> <li>graph</li> </ul> prerequisite 1 2 3 4 course <code>[0]</code> <code>[0]</code> <code>[1]</code> <code>[1, 3]</code> <ul> <li>in-degree</li> </ul> 0 1 2 3 4 in-degree 2 2 0 1 0 <ul> <li>queue: <code>[2, 4]</code></li> <li>pop <code>2</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))\n    4((4)) --&gt; 3((3))\n    4((4)) --&gt; 1((1))</code></pre> 0 1 2 3 4 in-degree 1 2 0 1 0 <ul> <li>queue: <code>[4]</code></li> <li>pop <code>4</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))</code></pre> 0 1 2 3 4 in-degree 1 1 0 0 0 <ul> <li>queue: <code>[3]</code></li> <li>pop <code>3</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))</code></pre> 0 1 2 3 4 in-degree 1 0 0 0 0 <ul> <li>queue: <code>[1]</code></li> <li>pop <code>1</code> from the queue</li> </ul> <pre><code>flowchart LR\n    0((0))</code></pre> 0 1 2 3 4 in-degree 0 0 0 0 0 <ul> <li>queue: <code>[0]</code></li> <li>pop <code>0</code> from the queue</li> <li>All courses are taken. Return <code>True</code>.</li> </ul> 207. Course Schedule - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS (Kahn's Algorithm)\ndef canFinishBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    count = 0\n\n    while q:\n        crs = q.popleft()\n        count += 1\n\n        for nxt in graph[crs]:\n            indegree[nxt] -= 1\n\n            if indegree[nxt] == 0:\n                q.append(nxt)\n\n    return count == numCourses\n\n\n# DFS + Set\ndef canFinishDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for crs, pre in prerequisites:\n        graph[crs].append(pre)\n\n    visiting = set()\n\n    def dfs(crs):\n        if crs in visiting:  # cycle detected\n            return False\n        if graph[crs] == []:\n            return True\n\n        visiting.add(crs)\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        visiting.remove(crs)\n        graph[crs] = []\n\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\n# DFS + List\ndef canFinishDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for pre, crs in prerequisites:\n        graph[crs].append(pre)\n\n    # 0: init, 1: visiting, 2: visited\n    status = [0] * numCourses\n\n    def dfs(crs):\n        if status[crs] == 1:  # cycle detected\n            return False\n        if status[crs] == 2:\n            return True\n\n        status[crs] = 1\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        status[crs] = 2\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(canFinishBFS(5, prerequisites))  # True\nprint(canFinishDFS1(5, prerequisites))  # True\nprint(canFinishDFS2(5, prerequisites))  # True\n</code></pre> 207. Course Schedule - C++ Solution<pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    // BFS\n    bool canFinishBFS(int numCourses, vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        vector&lt;int&gt; indegree(numCourses, 0);\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n            indegree[pre[0]]++;\n        }\n\n        queue&lt;int&gt; q;\n        for (int i = 0; i &lt; numCourses; i++) {\n            if (indegree[i] == 0) {\n                q.push(i);\n            }\n        }\n\n        int cnt = 0;\n        while (!q.empty()) {\n            int cur = q.front();\n            q.pop();\n            cnt++;\n\n            for (int nxt : graph[cur]) {\n                indegree[nxt]--;\n                if (indegree[nxt] == 0) {\n                    q.push(nxt);\n                }\n            }\n        }\n        return cnt == numCourses;\n    }\n\n    // DFS\n    bool canFinishDFS(int numCourses, vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n        }\n        // 0: not visited, 1: visiting, 2: visited\n        vector&lt;int&gt; state(numCourses, 0);\n\n        function&lt;bool(int)&gt; dfs = [&amp;](int pre) -&gt; bool {\n            state[pre] = 1;  // visiting\n            for (int crs : graph[pre]) {\n                if (state[crs] == 1 || (state[crs] == 0 &amp;&amp; dfs(crs))) {\n                    return true;\n                }\n            }\n            state[pre] = 2;  // visited\n            return false;\n        };\n\n        for (int i = 0; i &lt; numCourses; i++) {\n            if (state[i] == 0 &amp;&amp; dfs(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution sol;\n    vector&lt;vector&lt;int&gt;&gt; prerequisites = {{1, 0}, {2, 1}, {3, 2}, {4, 3},\n                                         {5, 4}, {6, 5}, {7, 6}, {8, 7},\n                                         {9, 8}, {10, 9}};\n    int numCourses = 11;\n    cout &lt;&lt; sol.canFinishBFS(numCourses, prerequisites) &lt;&lt; endl;\n    cout &lt;&lt; sol.canFinishDFS(numCourses, prerequisites) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/interview150/graph/#210-course-schedule-ii","title":"210. Course Schedule II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort</p> </li> <li>Return the ordering of courses you should take to finish all courses. If there are multiple valid answers, return any of them.</li> </ul> <p></p> 210. Course Schedule II - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# 1. BFS - Kahn's Algorithm\ndef findOrderBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    order = []\n\n    while q:\n        pre = q.popleft()\n        order.append(pre)\n\n        for crs in graph[pre]:\n            indegree[crs] -= 1\n            if indegree[crs] == 0:\n                q.append(crs)\n\n    return order if len(order) == numCourses else []\n\n\n# 2. DFS + Set\ndef findOrderDFS1(\n    numCourses: int, prerequisites: List[List[int]]\n) -&gt; List[int]:\n    adj = defaultdict(list)\n    for crs, pre in prerequisites:\n        adj[crs].append(pre)\n\n    visit, cycle = set(), set()\n    order = []\n\n    def dfs(crs):\n        if crs in cycle:\n            return False\n        if crs in visit:\n            return True\n\n        cycle.add(crs)\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        cycle.remove(crs)\n        visit.add(crs)\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order\n\n\n# 3. DFS + List\ndef findOrderDFS2(\n    numCourses: int, prerequisites: List[List[int]]\n) -&gt; List[int]:\n    adj = defaultdict(list)\n    for pre, crs in prerequisites:\n        adj[crs].append(pre)\n\n    # 0: not visited, 1: visiting, 2: visited\n    state = [0] * numCourses\n    order = []\n\n    def dfs(crs):\n        if state[crs] == 1:\n            return False\n        if state[crs] == 2:\n            return True\n\n        state[crs] = 1\n\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        state[crs] = 2\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order[::-1]\n\n\nnumCourses = 5\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(findOrderBFS(numCourses, prerequisites))  # [2, 4, 3, 1, 0]\nprint(findOrderDFS1(numCourses, prerequisites))  # [4, 3, 1, 2, 0]\nprint(findOrderDFS2(numCourses, prerequisites))  # [4, 3, 2, 1, 0]\n</code></pre> 210. Course Schedule II - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    // BFS\n    vector&lt;int&gt; findOrderBFS(int numCourses,\n                             vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        vector&lt;int&gt; indegree(numCourses, 0);\n\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n            indegree[pre[0]]++;\n        }\n\n        queue&lt;int&gt; q;\n        for (int i = 0; i &lt; numCourses; i++)\n            if (indegree[i] == 0) q.push(i);\n\n        vector&lt;int&gt; order;\n\n        while (!q.empty()) {\n            int cur = q.front();\n            q.pop();\n            order.push_back(cur);\n\n            for (int nxt : graph[cur]) {\n                indegree[nxt]--;\n                if (indegree[nxt] == 0) q.push(nxt);\n            }\n        }\n\n        return (int)order.size() == numCourses ? order : vector&lt;int&gt;{};\n    }\n};\n\nint main() {\n    Solution obj;\n    vector&lt;vector&lt;int&gt;&gt; prerequisites{{1, 0}, {2, 0}, {3, 1}, {3, 2}};\n    vector&lt;int&gt; res = obj.findOrderBFS(4, prerequisites);\n    for (size_t i = 0; i &lt; res.size(); i++) cout &lt;&lt; res[i] &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"content/interview150/graph_bfs/","title":"Graph BFS","text":""},{"location":"content/interview150/graph_bfs/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 909. Snakes and Ladders (Medium)</li> <li> 433. Minimum Genetic Mutation (Medium)</li> <li> 127. Word Ladder (Hard)</li> </ul>"},{"location":"content/interview150/graph_bfs/#909-snakes-and-ladders","title":"909. Snakes and Ladders","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, breadth first search, matrix</p> </li> </ul>"},{"location":"content/interview150/graph_bfs/#433-minimum-genetic-mutation","title":"433. Minimum Genetic Mutation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, breadth first search 433. Minimum Genetic Mutation - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef minMutation(startGene: str, endGene: str, bank: List[str]) -&gt; int:\n    if endGene not in bank:\n        return -1\n\n    bank = set(bank)\n    q = deque([(startGene, 0)])\n\n    while q:\n        gene, step = q.popleft()\n        if gene == endGene:\n            return step\n\n        for i in range(8):\n            for c in \"ACGT\":\n                if gene[i] == c:\n                    continue\n                newGene = gene[:i] + c + gene[i + 1 :]\n                if newGene in bank:\n                    bank.remove(newGene)\n                    q.append((newGene, step + 1))\n    return -1\n\n\nstartGene = \"AACCGGTT\"\nendGene = \"AAACGGTA\"\nbank = [\"AACCGGTA\", \"AACCGCTA\", \"AAACGGTA\"]\nprint(minMutation(startGene, endGene, bank))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/graph_bfs/#127-word-ladder","title":"127. Word Ladder","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, breadth first search</p> </li> <li>The most classic BFS problem.</li> <li>Return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.</li> <li>Approach: BFS</li> <li>Time Complexity: O(n * m^2)</li> <li>Space Complexity: O(n * m)</li> </ul> 127. Word Ladder - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef ladderLength(beginWord: str, endWord: str, wordList: List[str]) -&gt; int:\n    if endWord not in wordList:\n        return 0\n\n    n = len(beginWord)\n    graph = defaultdict(list)  # pattern: words\n    wordList.append(beginWord)\n\n    for word in wordList:\n        for i in range(n):\n            pattern = word[:i] + \"*\" + word[i + 1 :]\n            graph[pattern].append(word)\n\n    visited = set([beginWord])\n    q = deque([beginWord])\n    res = 1\n\n    while q:\n        size = len(q)\n        for _ in range(size):\n            word = q.popleft()\n            if word == endWord:\n                return res\n\n            for i in range(n):\n                pattern = word[:i] + \"*\" + word[i + 1 :]\n                for neighbor in graph[pattern]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        q.append(neighbor)\n        res += 1\n\n    return 0\n\n\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]\nprint(ladderLength(beginWord, endWord, wordList))  # 5\n</code></pre>"},{"location":"content/interview150/hash_table/","title":"Hash Table","text":""},{"location":"content/interview150/hash_table/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 383. Ransom Note (Easy)</li> <li> 205. Isomorphic Strings (Easy)</li> <li> 290. Word Pattern (Easy)</li> <li> 242. Valid Anagram (Easy)</li> <li> 49. Group Anagrams (Medium)</li> <li> 1. Two Sum (Easy)</li> <li> 202. Happy Number (Easy)</li> <li> 219. Contains Duplicate II (Easy)</li> <li> 128. Longest Consecutive Sequence (Medium)</li> </ul>"},{"location":"content/interview150/hash_table/#383-ransom-note","title":"383. Ransom Note","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, string, counting</p> </li> <li>Return <code>True</code> if the ransom note can be constructed from the magazines, otherwise, return <code>False</code>.</li> </ul> <pre><code>graph LR\n    A[\"Magazine: abcdef\"] --&gt; C(True)\n    B[\"Ransom Note: abc\"] --&gt; C</code></pre> 383. Ransom Note - Python Solution<pre><code>from collections import Counter, defaultdict\n\n\n# Array\ndef canConstructArray(ransomNote: str, magazine: str) -&gt; bool:\n    if len(ransomNote) &gt; len(magazine):\n        return False\n\n    record = [0 for _ in range(26)]\n\n    for i in magazine:\n        record[ord(i) - ord(\"a\")] += 1\n\n    for j in ransomNote:\n        record[ord(j) - ord(\"a\")] -= 1\n\n    for i in record:\n        if i &lt; 0:\n            return False\n\n    return True\n\n\n# Dict\ndef canConstructDict(ransomNote: str, magazine: str) -&gt; bool:\n    if len(ransomNote) &gt; len(magazine):\n        return False\n\n    record = defaultdict(int)\n\n    for i in magazine:\n        record[i] += 1\n\n    for j in ransomNote:\n        if j not in record or record[j] == 0:\n            return False\n        record[j] -= 1\n\n    return True\n\n\n# Counter\ndef canConstructCounter(ransomNote: str, magazine: str) -&gt; bool:\n    return not Counter(ransomNote) - Counter(magazine)\n\n\nransomNote = \"aa\"\nmagazine = \"aab\"\nprint(canConstructArray(ransomNote, magazine))  # True\nprint(canConstructDict(ransomNote, magazine))  # True\nprint(canConstructCounter(ransomNote, magazine))  # True\n</code></pre>"},{"location":"content/interview150/hash_table/#205-isomorphic-strings","title":"205. Isomorphic Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, string</p> </li> </ul>"},{"location":"content/interview150/hash_table/#290-word-pattern","title":"290. Word Pattern","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, string</p> </li> </ul>"},{"location":"content/interview150/hash_table/#242-valid-anagram","title":"242. Valid Anagram","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, string, sorting</p> </li> <li>Return true if an input string is an anagram of another string.</li> <li>An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once, e.g., <code>listen</code> is an anagram of <code>silent</code>.</li> </ul> 242. Valid Anagram - Python Solution<pre><code>from collections import Counter\n\n\n# Hashmap\ndef isAnagramHash(s: str, t: str) -&gt; bool:\n    \"\"\"Return True if t is an anagram of s, False otherwise.\"\"\"\n    if len(s) != len(t):\n        return False\n\n    count = dict()\n\n    for i in s:\n        if i in count:\n            count[i] += 1\n        else:\n            count[i] = 1\n\n    for j in t:\n        if j in count:\n            count[j] -= 1\n        else:\n            return False\n\n    for count in count.values():\n        if count != 0:\n            return False\n\n    return True\n\n\n# Array\ndef isAnagramArray(s: str, t: str) -&gt; bool:\n    if len(s) != len(t):\n        return False\n\n    count = [0 for _ in range(26)]\n\n    for i in s:\n        count[ord(i) - ord(\"a\")] += 1\n\n    for j in t:\n        count[ord(j) - ord(\"a\")] -= 1\n\n    for i in count:\n        if i != 0:\n            return False\n\n    return True\n\n\n# Counter\ndef isAnagramCounter(s: str, t: str) -&gt; bool:\n    return Counter(s) == Counter(t)\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |   Hashmap   |       O(n)      |     O(1)     |\n# |    Array    |       O(n)      |     O(1)     |\n# |   Counter   |       O(n)      |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\ns = \"anagram\"\nt = \"nagaram\"\nprint(isAnagramHash(s, t))  # True\nprint(isAnagramArray(s, t))  # True\nprint(isAnagramCounter(s, t))  # True\n</code></pre>"},{"location":"content/interview150/hash_table/#49-group-anagrams","title":"49. Group Anagrams","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, sorting 49. Group Anagrams - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash - List\ndef groupAnagrams(strs: List[str]) -&gt; List[List[str]]:\n    result = defaultdict(list)\n\n    for s in strs:\n        count = [0] * 26\n        for i in s:\n            count[ord(i) - ord(\"a\")] += 1\n\n        result[tuple(count)].append(s)\n\n    return list(result.values())\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Hash     |     O(n * k)    |     O(n)     |\n# |-------------|-----------------|--------------|\n\n\nstrs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\nprint(groupAnagrams(strs))\n# [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/hash_table/#1-two-sum","title":"1. Two Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table</p> </li> <li>Return the indices of the two numbers such that they add up to a specific target.</li> <li>Approach: Use a hashmap to store the indices of the numbers.</li> <li>Time Complexity: O(n)</li> <li>Space Complexity: O(n)</li> </ul> 1. Two Sum - Python Solution<pre><code>from typing import List\n\n\ndef twoSum(nums: List[int], target: int) -&gt; List[int]:\n    hashmap = {}  # val: idx\n\n    for idx, val in enumerate(nums):\n        if (target - val) in hashmap:\n            return [hashmap[target - val], idx]\n\n        hashmap[val] = idx\n\n\nif __name__ == \"__main__\":\n    nums = [2, 7, 11, 15]\n    target = 9\n    assert twoSum(nums, target) == [0, 1]\n</code></pre> 1. Two Sum - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;nums, int target) {\n    unordered_map&lt;int, int&gt; hashmap;\n\n    for (size_t i = 0; i &lt; nums.size(); i++) {\n        int complement = target - nums[i];\n\n        if (hashmap.find(complement) != hashmap.end()) {\n            return {hashmap[complement], (int)i};\n        }\n        hashmap[nums[i]] = (int)i;\n    }\n\n    return {-1, -1};\n}\n\nint main() {\n    vector&lt;int&gt; nums = {2, 7, 11, 15};\n    int target = 9;\n    vector&lt;int&gt; result = twoSum(nums, target);\n    cout &lt;&lt; result[0] &lt;&lt; \", \" &lt;&lt; result[1] &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/interview150/hash_table/#202-happy-number","title":"202. Happy Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, math, two pointers</p> </li> <li>Return <code>True</code> if the number is a happy number, otherwise, return <code>False</code>.</li> <li>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.</li> </ul> 202. Happy Number - Python Solution<pre><code>def isHappy(n: int) -&gt; bool:\n\n    def getSum(n):\n        sum_of_squares = 0\n        while n:\n            a, b = divmod(n, 10)\n            sum_of_squares += b**2\n            n = a\n        return sum_of_squares\n\n    record = set()\n\n    while True:\n        if n == 1:\n            return True\n\n        if n in record:\n            return False\n        else:\n            record.add(n)\n\n        n = getSum(n)\n\n\nn = 19\nprint(isHappy(n))  # True\n</code></pre>"},{"location":"content/interview150/hash_table/#219-contains-duplicate-ii","title":"219. Contains Duplicate II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, sliding window 219. Contains Duplicate II - Python Solution<pre><code>from typing import List\n\n\n# Hash\ndef containsNearbyDuplicateHash(nums: List[int], k: int) -&gt; bool:\n    hashmap = {}  # num: last index\n\n    for idx, num in enumerate(nums):\n        if num in hashmap:\n            if idx - hashmap[num] &lt;= k:\n                return True\n\n        hashmap[num] = idx\n\n    return False\n\n\n# Sliding window - Fixed\ndef containsNearbyDuplicateWindow(nums: List[int], k: int) -&gt; bool:\n    window = set()\n    left = 0\n\n    for right in range(len(nums)):\n        if right - left &gt; k:\n            window.remove(nums[left])\n            left += 1\n        if nums[right] in window:\n            return True\n        window.add(nums[right])\n\n    return False\n\n\nnums = [1, 2, 3, 1]\nk = 3\nprint(containsNearbyDuplicateHash(nums, k))  # True\nprint(containsNearbyDuplicateWindow(nums, k))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/hash_table/#128-longest-consecutive-sequence","title":"128. Longest Consecutive Sequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, union find 128. Longest Consecutive Sequence - Python Solution<pre><code>from typing import List\n\n\n# Set\ndef longestConsecutiveSet(nums: List[int]) -&gt; int:\n    num_set = set(nums)  # O(n)\n    longest = 0\n\n    for n in nums:\n        if (n - 1) not in num_set:  # left boundary\n            length = 1\n\n            while (n + length) in num_set:\n                length += 1\n\n            longest = max(longest, length)\n\n    return longest\n\n\n# Union Find\ndef longestConsecutiveUF(nums: List[int]) -&gt; int:\n    if not nums:\n        return 0\n\n    par = {num: num for num in nums}\n    rank = {num: 1 for num in nums}\n\n    def find(num):\n        p = par[num]\n        while p != par[p]:\n            p = par[p]\n        return p\n\n    def union(num1, num2):\n        p1, p2 = find(num1), find(num2)\n        if p1 == p2:\n            return\n\n        if rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n            rank[p2] += rank[p1]\n        else:\n            par[p2] = p1\n            rank[p1] += rank[p2]\n\n    for num in nums:\n        if num - 1 in par:\n            union(num, num - 1)\n\n    return max(rank.values())\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |  Set       |  O(N)  |  O(N)   |\n# | Union Find |  O(N)  |  O(N)   |\n# |------------|--------|---------|\n\n\nnums = [100, 4, 200, 1, 3, 2]\nprint(longestConsecutiveSet(nums))  # 4\nprint(longestConsecutiveUF(nums))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/heap/","title":"Heap","text":""},{"location":"content/interview150/heap/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 215. Kth Largest Element in an Array (Medium)</li> <li> 502. IPO (Hard)</li> <li> 373. Find K Pairs with Smallest Sums (Medium)</li> <li> 295. Find Median from Data Stream (Hard)</li> </ul>"},{"location":"content/interview150/heap/#215-kth-largest-element-in-an-array","title":"215. Kth Largest Element in an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, divide and conquer, sorting, heap priority queue, quickselect 215. Kth Largest Element in an Array - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\ndef findKthLargest(nums: List[int], k: int) -&gt; int:\n    min_heap = []\n\n    for i, num in enumerate(nums):\n        heapq.heappush(min_heap, num)\n        if i &gt;= k:\n            heapq.heappop(min_heap)\n\n    return min_heap[0]\n\n\nif __name__ == \"__main__\":\n    assert findKthLargest([3, 2, 1, 5, 6, 4], 2) == 5\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/heap/#502-ipo","title":"502. IPO","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sorting, heap priority queue 502. IPO - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Heap - Two Heaps\ndef findMaximizedCapital(\n    k: int, w: int, profits: List[int], capital: List[int]\n) -&gt; int:\n    \"\"\"\n    Time Complexity: O(k log N)\n    Space Complexity: O(N)\n    \"\"\"\n    if not profits or not capital:\n        return w\n\n    if w &gt;= max(capital) and k &gt;= len(capital):\n        return sum(profits) + w\n\n    max_profit = []\n    min_capital = [(c, p) for c, p in zip(capital, profits)]\n    heapq.heapify(min_capital)\n\n    for _ in range(k):\n        while min_capital and min_capital[0][0] &lt;= w:\n            _, pro = heapq.heappop(min_capital)\n            heapq.heappush(max_profit, -pro)\n\n        if max_profit:\n            w += -heapq.heappop(max_profit)\n\n    return w\n\n\nif __name__ == \"__main__\":\n    k = 2\n    w = 0\n    profits = [1, 2, 3]\n    capital = [0, 1, 1]\n    assert findMaximizedCapital(k, w, profits, capital) == 4\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/heap/#373-find-k-pairs-with-smallest-sums","title":"373. Find K Pairs with Smallest Sums","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, heap priority queue 373. Find K Pairs with Smallest Sums - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Heap - Merge K Sorted\ndef kSmallestPairs(\n    nums1: List[int], nums2: List[int], k: int\n) -&gt; List[List[int]]:\n    if not nums1 or not nums2 or k &lt;= 0:\n        return []\n\n    res = []\n    min_heap = []\n\n    for j in range(min(k, len(nums2))):\n        heapq.heappush(min_heap, (nums1[0] + nums2[j], 0, j))\n\n    while k &gt; 0 and min_heap:\n        _, i, j = heapq.heappop(min_heap)\n        res.append([nums1[i], nums2[j]])\n        k -= 1\n\n        if i + 1 &lt; len(nums1):\n            heapq.heappush(min_heap, (nums1[i + 1] + nums2[j], i + 1, j))\n\n    return res\n\n\nif __name__ == \"__main__\":\n    nums1 = [1, 2, 4, 5, 6]\n    nums2 = [3, 5, 7, 9]\n    k = 3\n    assert kSmallestPairs(nums1, nums2, k) == [[1, 3], [2, 3], [1, 5]]\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/heap/#295-find-median-from-data-stream","title":"295. Find Median from Data Stream","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: two pointers, design, sorting, heap priority queue, data stream 295. Find Median from Data Stream - Python Solution<pre><code>from heapq import heappop, heappush\n\n\n# Dual Heaps\nclass MedianFinder:\n\n    def __init__(self):\n        self.minHeap = []\n        self.maxHeap = []\n        self.min_size = 0\n        self.max_size = 0\n\n    def addNum(self, num: int) -&gt; None:\n        heappush(self.maxHeap, -num)\n        heappush(self.minHeap, -heappop(self.maxHeap))\n        self.min_size += 1\n\n        if self.min_size &gt; self.max_size:\n            heappush(self.maxHeap, -heappop(self.minHeap))\n            self.min_size -= 1\n            self.max_size += 1\n\n    def findMedian(self) -&gt; float:\n        if self.min_size == self.max_size:\n            return (-self.maxHeap[0] + self.minHeap[0]) / 2.0\n        return -self.maxHeap[0]\n\n\nobj = MedianFinder()\nobj.addNum(1)\nobj.addNum(2)\nassert obj.findMedian() == 1.5\nobj.addNum(3)\nassert obj.findMedian() == 2\nobj.addNum(4)\nassert obj.findMedian() == 2.5\nobj.addNum(5)\nassert obj.findMedian() == 3\nprint(\"All Passed.\")\n</code></pre></p> </li> </ul> 295. Find Median from Data Stream - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass MedianFinder {\n   private:\n    priority_queue&lt;int&gt; maxHeap;\n    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;\n    int max_size = 0;\n    int min_size = 0;\n\n   public:\n    MedianFinder() {}\n\n    void addNum(int num) {\n        if (min_size == max_size) {\n            minHeap.push(num);\n            maxHeap.push(minHeap.top());\n            minHeap.pop();\n            max_size++;\n        } else {\n            maxHeap.push(num);\n            minHeap.push(maxHeap.top());\n            maxHeap.pop();\n            min_size++;\n        }\n    }\n\n    double findMedian() {\n        if (min_size == max_size) {\n            return (maxHeap.top() + minHeap.top()) / 2.0;\n        } else {\n            return (double)maxHeap.top();\n        }\n    }\n};\n\nint main() {\n    MedianFinder* obj = new MedianFinder();\n    obj-&gt;addNum(1);\n    obj-&gt;addNum(2);\n    cout &lt;&lt; obj-&gt;findMedian() &lt;&lt; endl;  // 1.5\n    obj-&gt;addNum(3);\n    cout &lt;&lt; obj-&gt;findMedian() &lt;&lt; endl;  // 2\n    return 0;\n}\n</code></pre>"},{"location":"content/interview150/intervals/","title":"Intervals","text":""},{"location":"content/interview150/intervals/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 228. Summary Ranges (Easy)</li> <li> 56. Merge Intervals (Medium)</li> <li> 57. Insert Interval (Medium)</li> <li> 452. Minimum Number of Arrows to Burst Balloons (Medium)</li> </ul>"},{"location":"content/interview150/intervals/#228-summary-ranges","title":"228. Summary Ranges","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array 228. Summary Ranges - Python Solution<pre><code>from typing import List\n\n\n# Variable Sliding Window\ndef summaryRanges(nums: List[int]) -&gt; List[str]:\n    left, right = 0, 0\n    n = len(nums)\n    res = []\n\n    while left &lt; n:\n        while right + 1 &lt; n and nums[right] + 1 == nums[right + 1]:\n            right += 1\n\n        if left == right:\n            res.append(f\"{nums[left]}\")\n        else:\n            res.append(f\"{nums[left]}-&gt;{nums[right]}\")\n\n        right += 1\n        left = right\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(summaryRanges([0, 1, 2, 4, 5, 7]))\n    # [\"0-&gt;2\", \"4-&gt;5\", \"7\"]\n    print(summaryRanges([0, 2, 3, 4, 6, 8, 9]))\n    # [\"0\", \"2-&gt;4\", \"6\", \"8-&gt;9\"]\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/intervals/#56-merge-intervals","title":"56. Merge Intervals","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sorting</p> </li> <li>Merge all overlapping intervals.</li> </ul> 56. Merge Intervals - Python Solution<pre><code>from typing import List\n\n\n# Intervals\ndef merge(intervals: List[List[int]]) -&gt; List[List[int]]:\n    n = len(intervals)\n    if n &lt;= 1:\n        return intervals\n\n    intervals.sort(key=lambda x: x[0])\n    res = [intervals[0]]\n\n    for i in range(1, n):\n        if intervals[i][0] &lt;= res[-1][1]:\n            res[-1][1] = max(res[-1][1], intervals[i][1])\n        else:\n            res.append(intervals[i])\n\n    return res\n\n\nprint(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))\n# [[1, 6], [8, 10], [15, 18]]\n</code></pre> 56. Merge Intervals - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// Interval\nvector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {\n    sort(intervals.begin(), intervals.end());\n    vector&lt;vector&lt;int&gt;&gt; res;\n\n    for (auto&amp; range : intervals) {\n        if (!res.empty() &amp;&amp; range[0] &lt;= res.back()[1]) {\n            res.back()[1] = max(res.back()[1], range[1]);\n        } else {\n            res.emplace_back(range);\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;vector&lt;int&gt;&gt; intervals = {{1, 3}, {2, 6}, {8, 10}, {15, 18}};\n    vector&lt;vector&lt;int&gt;&gt; res = merge(intervals);\n    for (auto&amp; range : res) {\n        cout &lt;&lt; range[0] &lt;&lt; \", \" &lt;&lt; range[1] &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"content/interview150/intervals/#57-insert-interval","title":"57. Insert Interval","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array 57. Insert Interval - Python Solution<pre><code>from typing import List\n\n\n# Interval\ndef insert(\n    intervals: List[List[int]], newInterval: List[int]\n) -&gt; List[List[int]]:\n    n = len(intervals)\n\n    if n == 0:\n        return [newInterval]\n\n    if newInterval[1] &lt; intervals[0][0]:\n        return [newInterval] + intervals\n\n    if newInterval[0] &gt; intervals[-1][1]:\n        return intervals + [newInterval]\n\n    i = 0\n    result = []\n\n    while i &lt; n and intervals[i][1] &lt; newInterval[0]:\n        result.append(intervals[i])\n        i += 1\n\n    while i &lt; n and intervals[i][0] &lt;= newInterval[1]:\n        newInterval[0] = min(newInterval[0], intervals[i][0])\n        newInterval[1] = max(newInterval[1], intervals[i][1])\n        i += 1\n\n    result.append(newInterval)\n\n    while i &lt; n:\n        result.append(intervals[i])\n        i += 1\n\n    return result\n\n\nintervals = [[1, 3], [6, 9]]\nnewInterval = [2, 5]\nprint(insert(intervals, newInterval))  # [[1, 5], [6, 9]]\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/intervals/#452-minimum-number-of-arrows-to-burst-balloons","title":"452. Minimum Number of Arrows to Burst Balloons","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> <li>Return the minimum number of arrows.</li> </ul> <ul> <li>Differece between two versions<ol> <li>Start from 1: if there is no overlap, we add one more arrow.</li> <li>Start from the number of balloons: if there is overlap, we need to reduce one arrow.</li> </ol> </li> </ul> 452. Minimum Number of Arrows to Burst Balloons - Python Solution<pre><code>from typing import List\n\nimport matplotlib.pyplot as plt\n\n\n# Greedy - Interval\ndef findMinArrowShotsGreedy1(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    if n &lt;= 1:\n        return n\n\n    res = 1\n    points.sort(key=lambda x: x[0])\n\n    for i in range(1, n):\n        if points[i][0] &gt; points[i - 1][1]:\n            res += 1\n        else:\n            points[i][1] = min(points[i][1], points[i - 1][1])\n    return res\n\n\n# Greedy - Interval (Neetcode's version)\ndef findMinArrowShotsGreedy2(points: List[List[int]]) -&gt; int:\n    res = len(points)\n    if res == 0:\n        return 0\n\n    points.sort()\n    prev = points[0]\n\n    for i in range(1, len(points)):\n        cur = points[i]\n        if cur[0] &lt;= prev[1]:\n            res -= 1\n            prev = [cur[0], min(prev[1], cur[1])]\n        else:\n            prev = cur\n\n    return res\n\n\n# Greedy - Interval\ndef findMinArrowShotsGreedy3(points: List[List[int]]) -&gt; int:\n    if not points:\n        return 0\n\n    points.sort(key=lambda x: x[1])\n\n    res = 1\n    cur_end = points[0][1]\n\n    for i in range(1, len(points)):\n        if points[i][0] &gt; cur_end:\n            res += 1\n            cur_end = points[i][1]\n\n    return res\n\n\n# Utility\ndef plot(points, i=None):\n    plt.figure(figsize=(8, 4))\n    for idx in range(len(points)):\n        color = \"b\" if idx == i else \"k\"\n        plt.plot(\n            [points[idx][0], points[idx][1]],\n            [idx + 1, idx + 1],\n            f\"{color}o-\",\n            label=f\"Line {idx + 1}\",\n        )\n\n    plt.title(\"Find Min Arrow Shots\")\n    plt.xlabel(\"X-axis\")\n    plt.xlim(0, 17)\n    plt.grid(True)\n    plt.savefig(f\"find_min_arrow_shots_{i}.png\")\n    plt.show()\n\n\n# |------------|-----------|---------|\n# |  Approach  |  Time     |  Space  |\n# |------------|-----------|---------|\n# |  Greedy    |  O(NlogN) |  O(1)   |\n# |------------|-----------|---------|\n\n\npoints = [[10, 16], [2, 8], [1, 6], [7, 12]]\nprint(findMinArrowShotsGreedy1(points))  # 2\nprint(findMinArrowShotsGreedy2(points))  # 2\n</code></pre>"},{"location":"content/interview150/kadane_algorithm/","title":"Kadane Algorithm","text":""},{"location":"content/interview150/kadane_algorithm/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 53. Maximum Subarray (Medium)</li> <li> 918. Maximum Sum Circular Subarray (Medium)</li> </ul>"},{"location":"content/interview150/kadane_algorithm/#53-maximum-subarray","title":"53. Maximum Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, divide and conquer, dynamic programming 53. Maximum Subarray - Python Solution<pre><code>from typing import List\n\n\n# DP Kadane\ndef maxSubArrayDP(nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n\n    dp[0] = nums[0]\n    maxSum = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(\n            dp[i - 1] + nums[i],  # continue the previous subarray\n            nums[i],  # start a new subarray\n        )\n        maxSum = max(maxSum, dp[i])\n\n    return maxSum\n\n\n# Greedy\ndef maxSubArrayGreedy(nums: List[int]) -&gt; int:\n    max_sum = nums[0]\n    cur_sum = 0\n\n    for num in nums:\n        cur_sum = max(cur_sum + num, num)\n        max_sum = max(max_sum, cur_sum)\n\n    return max_sum\n\n\n# Prefix Sum\ndef maxSubArrayPrefixSum(nums: List[int]) -&gt; int:\n    prefix_sum = 0\n    prefix_sum_min = 0\n    res = float(\"-inf\")\n\n    for num in nums:\n        prefix_sum += num\n        res = max(res, prefix_sum - prefix_sum_min)\n        prefix_sum_min = min(prefix_sum_min, prefix_sum)\n\n    return res\n\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArrayDP(nums))  # 6\nprint(maxSubArrayGreedy(nums))  # 6\nprint(maxSubArrayPrefixSum(nums))  # 6\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/kadane_algorithm/#918-maximum-sum-circular-subarray","title":"918. Maximum Sum Circular Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, divide and conquer, dynamic programming, queue, monotonic queue 918. Maximum Sum Circular Subarray - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# DP - Kadane\ndef maxSubarraySumCircularKadane(nums: List[int]) -&gt; int:\n    max_sum = min_sum = nums[0]\n    max_cur = min_cur = 0\n    total = 0\n\n    for num in nums:\n        max_cur = max(max_cur + num, num)\n        min_cur = min(min_cur + num, num)\n        total += num\n\n        max_sum = max(max_sum, max_cur)\n        min_sum = min(min_sum, min_cur)\n\n    return max(max_sum, total - min_sum) if max_sum &gt; 0 else max_sum\n\n\n# Monotonic Queue\ndef maxSubarraySumCircularMQ(nums: List[int]) -&gt; int:\n    n = len(nums)\n    prefix_sum = [0] * (2 * n + 1)\n\n    for i in range(1, 2 * n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + nums[(i - 1) % n]\n\n    q = deque([0])\n    max_sum = float(\"-inf\")\n\n    for i in range(1, 2 * n + 1):\n        if q[0] &lt; i - n:\n            q.popleft()\n\n        max_sum = max(max_sum, prefix_sum[i] - prefix_sum[q[0]])\n\n        while q and prefix_sum[q[-1]] &gt;= prefix_sum[i]:\n            q.pop()\n\n        q.append(i)\n\n    return max_sum\n\n\nnums = [1, -2, 3, -2]\nprint(maxSubarraySumCircularKadane(nums))  # 3\nprint(maxSubarraySumCircularMQ(nums))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/linked_list/","title":"Linked List","text":""},{"location":"content/interview150/linked_list/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 141. Linked List Cycle (Easy)</li> <li> 2. Add Two Numbers (Medium)</li> <li> 21. Merge Two Sorted Lists (Easy)</li> <li> 138. Copy List with Random Pointer (Medium)</li> <li> 92. Reverse Linked List II (Medium)</li> <li> 25. Reverse Nodes in k-Group (Hard)</li> <li> 19. Remove Nth Node From End of List (Medium)</li> <li> 82. Remove Duplicates from Sorted List II (Medium)</li> <li> 61. Rotate List (Medium)</li> <li> 86. Partition List (Medium)</li> <li> 146. LRU Cache (Medium)</li> </ul>"},{"location":"content/interview150/linked_list/#141-linked-list-cycle","title":"141. Linked List Cycle","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, linked list, two pointers</p> </li> <li>Determine if a linked list has a cycle in it.</li> </ul> <pre><code>graph LR\n    A((3)) --&gt; B((2))\n    B --&gt; C((0))\n    C --&gt; D((4))</code></pre> <pre><code>graph LR\n    A((3)) --&gt; B((2))\n    B --&gt; C((0))\n    C --&gt; D((4))\n    D --&gt; B</code></pre> 141. Linked List Cycle - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\ndef hasCycle(head: Optional[ListNode]) -&gt; bool:\n    slow, fast = head, head\n\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n        if slow == fast:\n            return True\n\n    return False\n\n\nprint(hasCycle(ListNode.create([3, 2, 0, -4])))  # False\nprint(hasCycle(ListNode.create([3, 2, 0, -4], 1)))  # True\n</code></pre> 141. Linked List Cycle - C++ Solution<pre><code>#include &lt;iostream&gt;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nclass Solution {\n   public:\n    bool hasCycle(ListNode* head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while (fast &amp;&amp; fast-&gt;next) {\n            slow = slow-&gt;next;\n            fast = fast-&gt;next-&gt;next;\n\n            if (fast == slow) return true;\n        }\n        return false;\n    }\n};\n</code></pre>"},{"location":"content/interview150/linked_list/#2-add-two-numbers","title":"2. Add Two Numbers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, math, recursion</p> </li> <li>Represent the sum of two numbers as a linked list.</li> </ul> 2. Add Two Numbers - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef addTwoNumbers(\n    l1: Optional[ListNode], l2: Optional[ListNode]\n) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n    carry = 0\n\n    while l1 or l2:\n        v1 = l1.val if l1 else 0\n        v2 = l2.val if l2 else 0\n\n        carry, val = divmod(v1 + v2 + carry, 10)\n        cur.next = ListNode(val)\n        cur = cur.next\n\n        if l1:\n            l1 = l1.next\n        if l2:\n            l2 = l2.next\n\n    if carry:\n        cur.next = ListNode(val=carry)\n\n    return dummy.next\n\n\nl1 = ListNode.create([2, 4, 3])\nl2 = ListNode.create([5, 6, 4])\nprint(addTwoNumbers(l1, l2))  # 7 -&gt; 0 -&gt; 8\n</code></pre> 2. Add Two Numbers - C++ Solution<pre><code>struct ListNode {\n    int val;\n    ListNode* next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode* next) : val(x), next(next) {}\n};\n\nclass Solution {\n   public:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode dummy;\n        ListNode* cur = &amp;dummy;\n        int carry = 0;\n\n        while (l1 || l2 || carry) {\n            if (l1) {\n                carry += l1-&gt;val;\n                l1 = l1-&gt;next;\n            }\n            if (l2) {\n                carry += l2-&gt;val;\n                l2 = l2-&gt;next;\n            }\n            cur-&gt;next = new ListNode(carry % 10);\n            cur = cur-&gt;next;\n            carry /= 10;\n        }\n        return dummy.next;\n    }\n};\n</code></pre>"},{"location":"content/interview150/linked_list/#21-merge-two-sorted-lists","title":"21. Merge Two Sorted Lists","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: linked list, recursion</p> </li> <li>Merge the two lists into one sorted list.</li> </ul> 21. Merge Two Sorted Lists - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef mergeTwoLists(\n    list1: Optional[ListNode], list2: Optional[ListNode]\n) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    while list1 and list2:\n        if list1.val &lt; list2.val:\n            cur.next = list1\n            list1 = list1.next\n        else:\n            cur.next = list2\n            list2 = list2.next\n        cur = cur.next\n\n    if list1:\n        cur.next = list1\n    elif list2:\n        cur.next = list2\n\n    return dummy.next\n\n\nlist1 = ListNode.create([1, 2, 4])\nlist2 = ListNode.create([1, 3, 4])\nprint(mergeTwoLists(list1, list2))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4\n</code></pre> 21. Merge Two Sorted Lists - C++ Solution<pre><code>struct ListNode {\n    int val;\n    ListNode* next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode* next) : val(x), next(next) {}\n};\n\nclass Solution {\n   public:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        ListNode dummy;\n        ListNode* cur = &amp;dummy;\n\n        while (list1 &amp;&amp; list2) {\n            if (list1-&gt;val &lt; list2-&gt;val) {\n                cur-&gt;next = list1;\n                list1 = list1-&gt;next;\n            } else {\n                cur-&gt;next = list2;\n                list2 = list2-&gt;next;\n            }\n            cur = cur-&gt;next;\n        }\n\n        cur-&gt;next = list1 ? list1 : list2;\n\n        return dummy.next;\n    }\n};\n</code></pre>"},{"location":"content/interview150/linked_list/#138-copy-list-with-random-pointer","title":"138. Copy List with Random Pointer","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, linked list 138. Copy List with Random Pointer - Python Solution<pre><code>from typing import Optional\n\n\nclass Node:\n    def __init__(self, x: int, next: \"Node\" = None, random: \"Node\" = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\n\ndef copyRandomList(head: \"Optional[Node]\") -&gt; \"Optional[Node]\":\n    if not head:\n        return None\n\n    # Copy nodes and link them together\n    cur = head\n    while cur:\n        new_node = Node(cur.val)\n        new_node.next = cur.next\n        cur.next = new_node\n        cur = new_node.next\n\n    # Copy random pointers\n    cur = head\n    while cur:\n        cur.next.random = cur.random.next if cur.random else None\n        cur = cur.next.next\n\n    # Separate the original and copied lists\n    cur = head\n    new_head = head.next\n    while cur:\n        new_node = cur.next\n        cur.next = new_node.next\n        new_node.next = new_node.next.next if new_node.next else None\n        cur = cur.next\n\n    return new_head\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/linked_list/#92-reverse-linked-list-ii","title":"92. Reverse Linked List II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list</p> </li> <li>Reverse a linked list from position left to position right. Return the linked list after reversing.</li> </ul> <pre><code>graph LR\nA((1)) --&gt; B((2))\nB --&gt; C((3))\nC --&gt; D((4))\nD --&gt; E((5))</code></pre> <pre><code>graph LR\nA((1)) --&gt; B((4))\nB --&gt; C((3))\nC --&gt; D((2))\nD --&gt; E((5))</code></pre> 92. Reverse Linked List II - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef reverseBetween(\n    head: Optional[ListNode], left: int, right: int\n) -&gt; Optional[ListNode]:\n    dummy = ListNode(next=head)\n    p0 = dummy\n    for _ in range(left - 1):\n        p0 = p0.next\n\n    pre = None\n    cur = p0.next\n    for _ in range(right - left + 1):\n        nxt = cur.next\n        cur.next = pre\n        pre = cur\n        cur = nxt\n\n    p0.next.next = cur\n    p0.next = pre\n\n    return dummy.next\n\n\nhead = ListNode().create([1, 2, 3, 4, 5])\nleft = 2\nright = 4\nprint(reverseBetween(head, left, right))\n# 1 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 5\n</code></pre>"},{"location":"content/interview150/linked_list/#25-reverse-nodes-in-k-group","title":"25. Reverse Nodes in k-Group","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: linked list, recursion 25. Reverse Nodes in k-Group - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef reverseKGroup(head: Optional[ListNode], k: int) -&gt; Optional[ListNode]:\n    n = 0\n    cur = head\n    while cur:\n        n += 1\n        cur = cur.next\n\n    p0 = dummy = ListNode(next=head)\n    pre = None\n    cur = head\n\n    while n &gt;= k:\n        n -= k\n        for _ in range(k):\n            nxt = cur.next\n            cur.next = pre\n            pre = cur\n            cur = nxt\n\n        nxt = p0.next\n        nxt.next = cur\n        p0.next = pre\n        p0 = nxt\n\n    return dummy.next\n\n\nif __name__ == \"__main__\":\n    head = [1, 2, 3, 4, 5]\n    k = 2\n    head = ListNode.create(head)\n    print(head)  # 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\n    print(reverseKGroup(head, k))  # 2 -&gt; 1 -&gt; 4 -&gt; 3 -&gt; 5\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/linked_list/#19-remove-nth-node-from-end-of-list","title":"19. Remove Nth Node From End of List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, two pointers</p> </li> <li>Given the <code>head</code> of a linked list, remove the <code>n-th</code> node from the end of the list and return its head.</li> </ul> 19. Remove Nth Node From End of List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef removeNthFromEnd(head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:\n    dummy = ListNode(0, head)\n    fast, slow = dummy, dummy\n\n    for _ in range(n):\n        fast = fast.next\n\n    while fast.next:\n        fast = fast.next\n        slow = slow.next\n\n    slow.next = slow.next.next\n\n    return dummy.next\n\n\nhead = [1, 2, 3, 4, 5]\nn = 2\nhead = ListNode.create(head)\nprint(head)  # 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(removeNthFromEnd(head, n))  # 1 -&gt; 2 -&gt; 3 -&gt; 5\n</code></pre>"},{"location":"content/interview150/linked_list/#82-remove-duplicates-from-sorted-list-ii","title":"82. Remove Duplicates from Sorted List II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, two pointers 82. Remove Duplicates from Sorted List II - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef deleteDuplicates(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    dummy = ListNode(0, head)\n    cur = dummy\n\n    while cur.next and cur.next.next:\n        val = cur.next.val\n        if cur.next.next.val == val:\n            while cur.next and cur.next.val == val:\n                cur.next = cur.next.next\n        else:\n            cur = cur.next\n\n    return dummy.next\n\n\nhead = ListNode().create([1, 1, 2, 3, 3, 4, 5])\nprint(deleteDuplicates(head))  # 2 -&gt; 4 -&gt; 5\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/linked_list/#61-rotate-list","title":"61. Rotate List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, two pointers</p> </li> </ul>"},{"location":"content/interview150/linked_list/#86-partition-list","title":"86. Partition List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, two pointers</p> </li> </ul>"},{"location":"content/interview150/linked_list/#146-lru-cache","title":"146. LRU Cache","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, linked list, design, doubly linked list</p> </li> <li>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.</li> <li>lru</li> <li></li> </ul> Data structure Description Doubly Linked List To store the key-value pairs. Hash Map To store the key-node pairs. 146. LRU Cache - Python Solution<pre><code>from collections import OrderedDict\n\n\n# Doubly Linked List\nclass Node:\n    def __init__(self, key=0, val=0):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.cache = {}\n        self.head = Node()\n        self.tail = Node()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def add_to_last(self, node):\n        self.tail.prev.next = node\n        node.prev = self.tail.prev\n        node.next = self.tail\n        self.tail.prev = node\n\n    def move_to_last(self, node):\n        self.remove(node)\n        self.add_to_last(node)\n\n    def get(self, key: int) -&gt; int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self.move_to_last(node)\n        return node.val\n\n    def put(self, key: int, value: int) -&gt; None:\n        if key in self.cache:\n            node = self.cache[key]\n            node.val = value\n            self.move_to_last(node)\n            return None\n\n        if len(self.cache) == self.cap:\n            del self.cache[self.head.next.key]\n            self.remove(self.head.next)\n\n        node = Node(key=key, val=value)\n        self.cache[key] = node\n        self.add_to_last(node)\n\n\n# OrderedDict\nclass LRUCacheOrderedDict:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.cap = capacity\n\n    def get(self, key: int):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key, last=True)\n        return self.cache[key]\n\n    def put(self, key: int, value: int):\n        if key in self.cache:\n            self.cache.move_to_end(key, last=True)\n        elif len(self.cache) &gt;= self.cap:\n            self.cache.popitem(last=False)\n\n        self.cache[key] = value\n\n\ncache = LRUCache(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\n\ncache = LRUCacheOrderedDict(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\nprint(\"LRU Cache passed\")\nprint(\"LRU Cache Ordered Dict passed\")\n</code></pre> 146. LRU Cache - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nclass Node {\n   public:\n    int key;\n    int val;\n    Node *prev;\n    Node *next;\n\n    Node(int k = 0, int v = 0) : key(k), val(v), prev(nullptr), next(nullptr) {}\n};\n\nclass LRUCache {\n   private:\n    int cap;\n    unordered_map&lt;int, Node *&gt; cache;\n    Node *head;\n    Node *tail;\n\n    void remove(Node *node) {\n        node-&gt;prev-&gt;next = node-&gt;next;\n        node-&gt;next-&gt;prev = node-&gt;prev;\n    }\n\n    void insert_to_last(Node *node) {\n        tail-&gt;prev-&gt;next = node;\n        node-&gt;prev = tail-&gt;prev;\n        tail-&gt;prev = node;\n        node-&gt;next = tail;\n    }\n\n    void move_to_last(Node *node) {\n        remove(node);\n        insert_to_last(node);\n    }\n\n   public:\n    LRUCache(int capacity) {\n        this-&gt;cap = capacity;\n        head = new Node();\n        tail = new Node();\n        head-&gt;next = tail;\n        tail-&gt;prev = head;\n    }\n\n    int get(int key) {\n        if (cache.find(key) != cache.end()) {\n            Node *node = cache[key];\n            move_to_last(node);\n            return node-&gt;val;\n        }\n        return -1;\n    }\n\n    void put(int key, int value) {\n        if (cache.find(key) != cache.end()) {\n            Node *node = cache[key];\n            node-&gt;val = value;\n            move_to_last(node);\n        } else {\n            Node *newNode = new Node(key, value);\n            cache[key] = newNode;\n            insert_to_last(newNode);\n\n            if ((int)cache.size() &gt; cap) {\n                Node *removed = head-&gt;next;\n                remove(removed);\n                cache.erase(removed-&gt;key);\n                delete removed;\n            }\n        }\n    }\n};\n\nint main() {\n    LRUCache lru(2);\n    lru.put(1, 1);\n    lru.put(2, 2);\n    cout &lt;&lt; lru.get(1) &lt;&lt; endl;  // 1\n    lru.put(3, 3);\n    cout &lt;&lt; lru.get(2) &lt;&lt; endl;  // -1\n    lru.put(4, 4);\n    cout &lt;&lt; lru.get(1) &lt;&lt; endl;  // -1\n    cout &lt;&lt; lru.get(3) &lt;&lt; endl;  // 3\n    cout &lt;&lt; lru.get(4) &lt;&lt; endl;  // 4\n    return 0;\n}\n</code></pre>"},{"location":"content/interview150/math/","title":"Math","text":""},{"location":"content/interview150/math/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 9. Palindrome Number (Easy)</li> <li> 66. Plus One (Easy)</li> <li> 172. Factorial Trailing Zeroes (Medium)</li> <li> 69. Sqrt(x) (Easy)</li> <li> 50. Pow(x, n) (Medium)</li> <li> 149. Max Points on a Line (Hard)</li> </ul>"},{"location":"content/interview150/math/#9-palindrome-number","title":"9. Palindrome Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math</p> </li> <li>Return true if the given number is a palindrome. Otherwise, return false.</li> </ul> 9. Palindrome Number - Python Solution<pre><code># Reverse\ndef isPalindromeReverse(x: int) -&gt; bool:\n    if x &lt; 0:\n        return False\n\n    return str(x) == str(x)[::-1]\n\n\n# Left Right Pointers\ndef isPalindromeLR(x: int) -&gt; bool:\n    if x &lt; 0:\n        return False\n\n    x = list(str(x))  # 121 -&gt; ['1', '2', '1']\n\n    left, right = 0, len(x) - 1\n\n    while left &lt; right:\n        if x[left] != x[right]:\n            return False\n        left += 1\n        right -= 1\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |  Reverse   |  O(N)  |   O(N)  |\n# | Left Right |  O(N)  |   O(1)  |\n# |------------|--------|---------|\n\n\nx = 121\nprint(isPalindromeReverse(x))  # True\nprint(isPalindromeLR(x))  # True\n</code></pre>"},{"location":"content/interview150/math/#66-plus-one","title":"66. Plus One","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, math 66. Plus One - Python Solution<pre><code>from typing import List\n\n\n# Math\ndef plusOne(digits: List[int]) -&gt; List[int]:\n    n = len(digits)\n\n    for i in range(n - 1, -1, -1):\n        if digits[i] &lt; 9:\n            digits[i] += 1\n            return digits\n        else:\n            digits[i] = 0\n\n    return [1] + digits\n\n\ndigits = [4, 3, 2, 1]\nprint(plusOne(digits))  # [4, 3, 2, 2]\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/math/#172-factorial-trailing-zeroes","title":"172. Factorial Trailing Zeroes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math</p> </li> </ul>"},{"location":"content/interview150/math/#69-sqrtx","title":"69. Sqrt(x)","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, binary search 69. Sqrt(x) - Python Solution<pre><code># Left Right Pointers\ndef mySqrt(x: int) -&gt; int:\n    \"\"\"Returns the square root of a number.\"\"\"\n    if x &lt; 2:\n        return x\n\n    left, right = 0, x // 2\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        if mid * mid &lt;= x &lt; (mid + 1) * (mid + 1):\n            return mid\n        elif mid * mid &lt; x:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n\nx = 8\nprint(mySqrt(x))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/math/#50-powx-n","title":"50. Pow(x, n)","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, recursion 50. Pow(x, n) - Python Solution<pre><code># Iterative\ndef myPowIterative(x: float, n: int) -&gt; float:\n    if n == 0:\n        return 1\n    if n &lt; 0:\n        x = 1 / x\n        n = -n\n\n    result = 1\n    cur = x\n\n    while n &gt; 0:\n        if n % 2 == 1:\n            result *= cur\n\n        cur *= cur\n        n //= 2\n\n    return result\n\n\n# Recursive\ndef myPowRecursive(x: float, n: int) -&gt; float:\n    if n == 0:\n        return 1\n    if n &lt; 0:\n        x = 1 / x\n        n = -n\n\n    if n % 2 == 0:\n        return myPowRecursive(x * x, n // 2)\n    else:\n        return x * myPowRecursive(x * x, n // 2)\n\n\nx = 2.00000\nn = 10\nprint(myPowIterative(x, n))  # 1024.0\nprint(myPowRecursive(x, n))  # 1024.0\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/math/#149-max-points-on-a-line","title":"149. Max Points on a Line","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, math, geometry 149. Max Points on a Line - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# GCD\ndef maxPoints(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    if n &lt;= 2:\n        return n\n\n    res = 0\n\n    for i in range(n - 1):\n        x1, y1 = points[i]\n        cnt = defaultdict(int)\n\n        for j in range(i + 1, n):\n            x2, y2 = points[j]\n            g = \"inf\" if x1 == x2 else (y2 - y1) / (x2 - x1)\n            cnt[g] += 1\n\n        res = max(res, 1 + max(cnt.values()))\n\n    return res\n\n\npoints = [[1, 1], [3, 2], [5, 3], [4, 1], [2, 3], [1, 4]]\nprint(maxPoints(points))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/matrix/","title":"Matrix","text":""},{"location":"content/interview150/matrix/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 36. Valid Sudoku (Medium)</li> <li> 54. Spiral Matrix (Medium)</li> <li> 48. Rotate Image (Medium)</li> <li> 73. Set Matrix Zeroes (Medium)</li> <li> 289. Game of Life (Medium)</li> </ul>"},{"location":"content/interview150/matrix/#36-valid-sudoku","title":"36. Valid Sudoku","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, matrix 36. Valid Sudoku - Python Solution<pre><code>from typing import List\n\n\n# Set\ndef isValidSudoku(board: List[List[str]]) -&gt; bool:\n    rows = [set() for _ in range(9)]\n    cols = [set() for _ in range(9)]\n    boxes = [set() for _ in range(9)]\n\n    for i in range(9):\n        for j in range(9):\n            if board[i][j] == \".\":\n                continue\n\n            if board[i][j] in rows[i]:\n                return False\n            rows[i].add(board[i][j])\n\n            if board[i][j] in cols[j]:\n                return False\n            cols[j].add(board[i][j])\n\n            box_index = (i // 3) * 3 + j // 3\n            if board[i][j] in boxes[box_index]:\n                return False\n            boxes[box_index].add(board[i][j])\n\n    return True\n\n\nboard = [\n    [\"5\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],\n    [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n    [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n    [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n    [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n    [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n    [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"],\n    [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n    [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"],\n]\nprint(isValidSudoku(board))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/matrix/#54-spiral-matrix","title":"54. Spiral Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, matrix, simulation</p> </li> <li>Return all elements of the matrix in spiral order.</li> </ul> 54. Spiral Matrix - Python Solution<pre><code>from typing import List\n\n\n# Array\ndef spiralOrder(matrix: List[List[int]]) -&gt; List[int]:\n    if not matrix or not matrix[0]:\n        return []\n\n    res = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n\n    while top &lt;= bottom and left &lt;= right:\n\n        for i in range(left, right + 1):\n            res.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            res.append(matrix[i][right])\n        right -= 1\n\n        if top &lt;= bottom:\n\n            for i in range(right, left - 1, -1):\n                res.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left &lt;= right:\n\n            for i in range(bottom, top - 1, -1):\n                res.append(matrix[i][left])\n            left += 1\n\n    return res\n\n\n# Math\ndef spiralOrderMath(matrix: List[List[int]]) -&gt; List[int]:\n    dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]]  # Right Down Left Up\n    m, n = len(matrix), len(matrix[0])\n    size = m * n\n    res = []\n    i, j, di = 0, -1, 0\n\n    while len(res) &lt; size:\n        dx, dy = dirs[di]\n        for _ in range(n):\n            i += dx\n            j += dy\n            res.append(matrix[i][j])\n        di = (di + 1) % 4\n        n, m = m - 1, n\n\n    return res\n\n\nprint(spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n# [1, 2, 3, 6, 9, 8, 7, 4, 5]\nprint(spiralOrderMath([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]))\n# [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]\n</code></pre>"},{"location":"content/interview150/matrix/#48-rotate-image","title":"48. Rotate Image","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, matrix 48. Rotate Image - Python Solution<pre><code>from copy import deepcopy\nfrom typing import List\n\n\n# Math\ndef rotate1(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    n = len(matrix)\n\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n\n\ndef rotate2(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    n = len(matrix)\n    for i in range(n):\n        for j in range(i, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\n    for i in range(n):\n        matrix[i].reverse()\n\n\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nprint(matrix)\n# [[1, 2, 3],\n#  [4, 5, 6],\n#  [7, 8, 9]]\nmatrix1 = deepcopy(matrix)\nrotate1(matrix1)\nprint(matrix1)\n# [[7, 4, 1],\n#  [8, 5, 2],\n#  [9, 6, 3]]\nmatrix2 = deepcopy(matrix)\nrotate2(matrix2)\nprint(matrix2)\n# [[7, 4, 1],\n#  [8, 5, 2],\n#  [9, 6, 3]]\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/matrix/#73-set-matrix-zeroes","title":"73. Set Matrix Zeroes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, matrix 73. Set Matrix Zeroes - Python Solution<pre><code>from copy import deepcopy\nfrom typing import List\n\n\n# Math\ndef setZeroes1(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    m, n = len(matrix), len(matrix[0])\n\n    rows, cols = set(), set()\n\n    for i in range(m):\n        for j in range(n):\n            if matrix[i][j] == 0:\n                rows.add(i)\n                cols.add(j)\n\n    for i in rows:\n        for j in range(n):\n            matrix[i][j] = 0\n\n    for i in range(m):\n        for j in cols:\n            matrix[i][j] = 0\n\n\n# Math - Optimized\ndef setZeroes2(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    m, n = len(matrix), len(matrix[0])\n    row_zero, col_zero = False, False\n\n    for i in range(m):\n        if matrix[i][0] == 0:\n            col_zero = True\n            break\n\n    for j in range(n):\n        if matrix[0][j] == 0:\n            row_zero = True\n            break\n\n    for i in range(1, m):\n        for j in range(1, n):\n            if matrix[i][j] == 0:\n                matrix[i][0] = 0\n                matrix[0][j] = 0\n\n    for i in range(1, m):\n        if matrix[i][0] == 0:\n            for j in range(1, n):\n                matrix[i][j] = 0\n\n    for j in range(1, n):\n        if matrix[0][j] == 0:\n            for i in range(1, m):\n                matrix[i][j] = 0\n\n    if col_zero:\n        for i in range(m):\n            matrix[i][0] = 0\n\n    if row_zero:\n        for j in range(n):\n            matrix[0][j] = 0\n\n\nmatrix = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]\nprint(matrix)\n# [[1, 1, 1],\n#  [1, 0, 1],\n#  [1, 1, 1]]\nmatrix1 = deepcopy(matrix)\nsetZeroes1(matrix1)\nprint(matrix1)\n# [[1, 0, 1],\n#  [0, 0, 0],\n#  [1, 0, 1]]\nmatrix2 = deepcopy(matrix)\nsetZeroes2(matrix2)\nprint(matrix2)\n# [[1, 0, 1],\n#  [0, 0, 0],\n#  [1, 0, 1]]\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/matrix/#289-game-of-life","title":"289. Game of Life","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, matrix, simulation 289. Game of Life - Python Solution<pre><code>from typing import List\n\n\ndef gameOfLife(board: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n    DIRS = [\n        [1, 0],\n        [0, 1],\n        [-1, 0],\n        [0, -1],\n        [1, 1],\n        [1, -1],\n        [-1, 1],\n        [-1, -1],\n    ]\n    m, n = len(board), len(board[0])\n\n    def count_live(r, c):\n        cnt = 0\n        for dr, dc in DIRS:\n            nr, nc = dr + r, dc + c\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and board[nr][nc] &amp; 1:\n                cnt += 1\n        return cnt\n\n    # Encode next state: bit 1 = current, bit 2 = next\n    for i in range(m):\n        for j in range(n):\n            cnt = count_live(i, j)\n            if board[i][j] == 1:  # currently alive\n                if 2 &lt;= cnt &lt;= 3:\n                    board[i][j] = 3  # 11: was alive, stays alive\n            else:  # currently dead\n                if cnt == 3:\n                    board[i][j] = 2  # 10: was dead, becomes alive\n\n    # Extract next state\n    for i in range(m):\n        for j in range(n):\n            board[i][j] &gt;&gt;= 1\n\n\nif __name__ == \"__main__\":\n    board = [[0, 1, 0], [0, 0, 1], [1, 1, 1], [0, 0, 0]]\n    gameOfLife(board)\n    assert board == [[0, 0, 0], [1, 0, 1], [0, 1, 1], [0, 1, 0]]\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/multidimensional_dp/","title":"Multidimensional DP","text":""},{"location":"content/interview150/multidimensional_dp/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 120. Triangle (Medium)</li> <li> 64. Minimum Path Sum (Medium)</li> <li> 63. Unique Paths II (Medium)</li> <li> 5. Longest Palindromic Substring (Medium)</li> <li> 97. Interleaving String (Medium)</li> <li> 72. Edit Distance (Medium)</li> <li> 123. Best Time to Buy and Sell Stock III (Hard)</li> <li> 188. Best Time to Buy and Sell Stock IV (Hard)</li> <li> 221. Maximal Square (Medium)</li> </ul>"},{"location":"content/interview150/multidimensional_dp/#120-triangle","title":"120. Triangle","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/interview150/multidimensional_dp/#64-minimum-path-sum","title":"64. Minimum Path Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, matrix 64. Minimum Path Sum - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef minPathSum(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = grid[i][0] + dp[i - 1][0]\n    for j in range(1, n):\n        dp[0][j] = grid[0][j] + dp[0][j - 1]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[-1][-1]\n\n\ngrid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\nprint(minPathSum(grid))  # 7\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/multidimensional_dp/#63-unique-paths-ii","title":"63. Unique Paths II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, matrix</p> </li> <li>Count the number of unique paths to reach the bottom-right corner of a <code>m x n</code> grid with obstacles.</li> </ul> <p></p> 63. Unique Paths II - Python Solution<pre><code>from typing import List\n\n\n# DP - 2D\ndef uniquePathsWithObstacles(obstacleGrid: List[List[int]]) -&gt; int:\n    if obstacleGrid[0][0] == 1 or obstacleGrid[-1][-1] == 1:\n        return 0\n\n    m, n = len(obstacleGrid), len(obstacleGrid[0])\n    dp = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n        if obstacleGrid[i][0] == 0:\n            dp[i][0] = 1\n        else:\n            break\n\n    for j in range(n):\n        if obstacleGrid[0][j] == 0:\n            dp[0][j] = 1\n        else:\n            break\n\n    for i in range(1, m):\n        for j in range(1, n):\n            if obstacleGrid[i][j] == 1:\n                continue\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]\n\n\nobstacleGrid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\nprint(uniquePathsWithObstacles(obstacleGrid))  # 2\n# [[1, 1, 1],\n#  [1, 0, 1],\n#  [1, 1, 2]]\n</code></pre>"},{"location":"content/interview150/multidimensional_dp/#5-longest-palindromic-substring","title":"5. Longest Palindromic Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string, dynamic programming</p> </li> <li>Return the longest palindromic substring in <code>s</code>.</li> </ul> 5. Longest Palindromic Substring - Python Solution<pre><code># DP - Interval\ndef longestPalindromeDP(s: str) -&gt; str:\n    n = len(s)\n    if n &lt;= 1:\n        return s\n\n    start, maxLen = 0, 1\n\n    # Init\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for j in range(1, n):\n        for i in range(j):\n            if s[i] == s[j]:\n                if j - i &lt;= 2:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1]\n\n                if dp[i][j] and j - i + 1 &gt; maxLen:\n                    maxLen = j - i + 1\n                    start = i\n\n    return s[start : start + maxLen]\n\n\n# Expand Around Center\ndef longestPalindromeCenter(s: str) -&gt; str:\n    def expand_around_center(left, right):\n        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n\n    if len(s) &lt;= 1:\n        return s\n\n    start, end = 0, 0\n    for i in range(len(s)):\n        len1 = expand_around_center(i, i)  # odd\n        len2 = expand_around_center(i, i + 1)  # even\n\n        maxLen = max(len1, len2)\n        if maxLen &gt; end - start:\n            start = i - (maxLen - 1) // 2\n            end = i + maxLen // 2\n\n    return s[start : end + 1]\n\n\ns = \"babad\"\nprint(longestPalindromeDP(s))  # \"bab\"\nprint(longestPalindromeCenter(s))  # \"aba\"\n</code></pre>"},{"location":"content/interview150/multidimensional_dp/#97-interleaving-string","title":"97. Interleaving String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming 97. Interleaving String - Python Solution<pre><code># DP - 2D\ndef isInterleaveDP(s1: str, s2: str, s3: str) -&gt; bool:\n    m, n, k = len(s1), len(s2), len(s3)\n\n    if m + n != k:\n        return False\n\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    for i in range(1, m + 1):\n        dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n\n    for j in range(1, n + 1):\n        dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (\n                dp[i][j - 1] and s2[j - 1] == s3[i + j - 1]\n            )\n\n    return dp[m][n]\n\n\n# DFS\ndef isInterleaveDFS(s1: str, s2: str, s3: str) -&gt; bool:\n    memo = {}\n\n    def dfs(i, j, k):\n        if i == len(s1) and j == len(s2) and k == len(s3):\n            return True\n\n        if (i, j) in memo:\n            return memo[(i, j)]\n\n        res = False\n\n        if i &lt; len(s1) and k &lt; len(s3) and s1[i] == s3[k]:\n            res |= dfs(i + 1, j, k + 1)\n\n        if j &lt; len(s2) and k &lt; len(s3) and s2[j] == s3[k]:\n            res |= dfs(i, j + 1, k + 1)\n\n        memo[(i, j)] = res\n\n        return res\n\n    return dfs(0, 0, 0)\n\n\ns1 = \"aabcc\"\ns2 = \"dbbca\"\ns3 = \"aadbbbaccc\"\nprint(isInterleaveDP(s1, s2, s3))  # False\nprint(isInterleaveDFS(s1, s2, s3))  # False\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/multidimensional_dp/#72-edit-distance","title":"72. Edit Distance","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming 72. Edit Distance - Python Solution<pre><code>from functools import cache\n\n\n# Recursive\ndef minDistanceDFS(word1: str, word2: str) -&gt; int:\n    n, m = len(word1), len(word2)\n\n    @cache\n    def dfs(i: int, j: int) -&gt; int:\n        if i &lt; 0:\n            return j + 1\n        if j &lt; 0:\n            return i + 1\n        if word1[i] == word2[j]:\n            return dfs(i - 1, j - 1)\n\n        return 1 + min(dfs(i - 1, j), dfs(i, j - 1), dfs(i - 1, j - 1))\n\n    return dfs(n - 1, m - 1)\n\n\n# Iterative\ndef minDistanceDP(word1: str, word2: str) -&gt; int:\n    m, n = len(word1), len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]  # no operation\n            else:\n                dp[i][j] = 1 + min(\n                    dp[i - 1][j],  # delete\n                    dp[i][j - 1],  # insert\n                    dp[i - 1][j - 1],  # replace\n                )\n    return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    word1 = \"horse\"\n    word2 = \"ros\"\n    print(minDistanceDFS(word1, word2))  # 3\n    print(minDistanceDP(word1, word2))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/multidimensional_dp/#123-best-time-to-buy-and-sell-stock-iii","title":"123. Best Time to Buy and Sell Stock III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming 123. Best Time to Buy and Sell Stock III - Python Solution<pre><code>from typing import List\n\n\n# 1. DP\ndef maxProfitDP1(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 5 for _ in range(n)]\n\n    dp[0][0] = 0  # no transaction\n    dp[0][1] = -prices[0]  # buy 1\n    dp[0][2] = 0  # sell 1\n    dp[0][3] = -prices[0]  # buy 2\n    dp[0][4] = 0  # sell 2\n\n    for i in range(1, n):\n        dp[i][0] = dp[i - 1][0]\n        dp[i][1] = max(dp[i - 1][1], -prices[i])\n        dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i])\n        dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i])\n        dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i])\n\n    return dp[-1][4]\n\n\n# 2. DP - Optimized\ndef maxProfitDP2(prices: List[int]) -&gt; int:\n    b1, b2 = float(\"inf\"), float(\"inf\")\n    s1, s2 = 0, 0\n\n    for price in prices:\n        b1 = min(b1, price)\n        s1 = max(s1, price - b1)\n        b2 = min(b2, price - s1)\n        s2 = max(s2, price - b2)\n\n    return s2\n\n\nprices = [3, 3, 5, 0, 0, 3, 1, 4]\nprint(maxProfitDP1(prices))  # 6\nprint(maxProfitDP2(prices))  # 6\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/multidimensional_dp/#188-best-time-to-buy-and-sell-stock-iv","title":"188. Best Time to Buy and Sell Stock IV","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming 188. Best Time to Buy and Sell Stock IV - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef maxProfit(k: int, prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * (2 * k + 1) for _ in range(n)]\n\n    for j in range(1, 2 * k, 2):\n        dp[0][j] = -prices[0]\n\n    for i in range(1, n):\n        for j in range(0, 2 * k - 1, 2):\n            dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i])\n            dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i])\n\n    return dp[-1][2 * k]\n\n\nk = 2\nprices = [2, 4, 1]\nprint(maxProfit(k, prices))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/multidimensional_dp/#221-maximal-square","title":"221. Maximal Square","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, matrix</p> </li> </ul>"},{"location":"content/interview150/sliding_window/","title":"Sliding Window","text":""},{"location":"content/interview150/sliding_window/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 209. Minimum Size Subarray Sum (Medium)</li> <li> 3. Longest Substring Without Repeating Characters (Medium)</li> <li> 30. Substring with Concatenation of All Words (Hard)</li> <li> 76. Minimum Window Substring (Hard)</li> </ul>"},{"location":"content/interview150/sliding_window/#209-minimum-size-subarray-sum","title":"209. Minimum Size Subarray Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sliding window, prefix sum 209. Minimum Size Subarray Sum - Python Solution<pre><code>import bisect\nfrom typing import List\n\n\n# Prefix Sum\ndef minSubArrayLenPS(target: int, nums: List[int]) -&gt; int:\n    n = len(nums)\n    prefix_sums = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        prefix_sums[i] = prefix_sums[i - 1] + nums[i - 1]\n\n    minLen = float(\"inf\")\n\n    for i in range(n + 1):\n        new_target = target + prefix_sums[i]\n        bound = bisect.bisect_left(prefix_sums, new_target)\n        if bound != len(prefix_sums):\n            minLen = min(minLen, bound - i)\n\n    return 0 if minLen == float(\"inf\") else minLen\n\n\n# Sliding Window Variable Size\ndef minSubArrayLenSW(target: int, nums: List[int]) -&gt; int:\n    res, cur = float(\"inf\"), 0\n    left = 0\n\n    for right in range(len(nums)):\n        cur += nums[right]\n\n        while cur &gt;= target:\n            res = min(res, right - left + 1)\n            cur -= nums[left]\n            left += 1\n\n    return res if res != float(\"inf\") else 0\n\n\ntarget = 7\nnums = [2, 3, 1, 2, 4, 3]\nprint(minSubArrayLenPS(target, nums))  # 2\nprint(minSubArrayLenSW(target, nums))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/sliding_window/#3-longest-substring-without-repeating-characters","title":"3. Longest Substring Without Repeating Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> <li>Classic variable sliding window problem. Use a set to keep track of the characters in the current window.</li> <li>Return the length of the longest substring without repeating characters.</li> <li>Template tutorial by \u7075\u5c71\u8336\u827e\u5e9c</li> </ul> 3. Longest Substring Without Repeating Characters - Python Solution<pre><code>from collections import defaultdict\n\n\n# Sliding Window Variable Max - HashMap\ndef lengthOfLongestSubstringHash(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    left = 0\n    cnt = defaultdict(int)\n    res = 0\n\n    for right in range(n):\n        cnt[s[right]] += 1\n\n        while cnt[s[right]] &gt; 1:\n            cnt[s[left]] -= 1\n            left += 1\n\n        res = max(res, right - left + 1)\n\n    return res\n\n\n# Sliding Window Variable Max - Set\ndef lengthOfLongestSubstringSet(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    left = 0\n    res = 0\n    window = set()\n\n    for right in range(n):\n        while left &lt; right and s[right] in window:\n            window.remove(s[left])\n            left += 1\n        window.add(s[right])\n        res = max(res, right - left + 1)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    s = \"abcabcbb\"\n    assert lengthOfLongestSubstringHash(s) == 3\n    assert lengthOfLongestSubstringSet(s) == 3\n</code></pre> 3. Longest Substring Without Repeating Characters - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;unordered_set&gt;\nusing namespace std;\n\nint lengthOfLongestSubstring(string s) {\n    int n = s.length();\n    int res = 0;\n    int left = 0;\n    unordered_set&lt;char&gt; window;\n\n    for (int right = 0; right &lt; n; right++) {\n        char ch = s[right];\n\n        while (window.find(ch) != window.end()) {\n            window.erase(s[left]);\n            left++;\n        }\n\n        window.insert(ch);\n        res = max(res, right - left + 1);\n    }\n    return (int)res;\n}\n\nint main() {\n    string s = \"abcabcbb\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 3\n    s = \"bbbbb\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 1\n    s = \"pwwkew\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 3\n    return 0;\n}\n</code></pre>"},{"location":"content/interview150/sliding_window/#30-substring-with-concatenation-of-all-words","title":"30. Substring with Concatenation of All Words","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> </ul>"},{"location":"content/interview150/sliding_window/#76-minimum-window-substring","title":"76. Minimum Window Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, sliding window 76. Minimum Window Substring - Python Solution<pre><code>from collections import Counter\n\n\ndef minWindow(s: str, t: str) -&gt; str:\n    if not t or not s:\n        return \"\"\n\n    counts = Counter(t)\n    required = len(counts)\n\n    left, right = 0, 0\n    formed = 0\n    window_counts = dict()\n\n    result = float(\"inf\"), None, None\n\n    while right &lt; len(s):\n        char = s[right]\n        window_counts[char] = window_counts.get(char, 0) + 1\n        if char in counts and window_counts[char] == counts[char]:\n            formed += 1\n\n        while left &lt;= right and formed == required:\n            char = s[left]\n            if right - left + 1 &lt; result[0]:\n                result = (right - left + 1, left, right)\n            window_counts[char] -= 1\n            if char in counts and window_counts[char] &lt; counts[char]:\n                formed -= 1\n            left += 1\n\n        right += 1\n\n    return \"\" if result[0] == float(\"inf\") else s[result[1] : result[2] + 1]\n\n\ns = \"ADOBECODEBANC\"\nt = \"ABC\"\nprint(minWindow(s, t))  # BANC\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/stack/","title":"Stack","text":""},{"location":"content/interview150/stack/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 20. Valid Parentheses (Easy)</li> <li> 71. Simplify Path (Medium)</li> <li> 155. Min Stack (Medium)</li> <li> 150. Evaluate Reverse Polish Notation (Medium)</li> <li> 224. Basic Calculator (Hard)</li> </ul>"},{"location":"content/interview150/stack/#20-valid-parentheses","title":"20. Valid Parentheses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, stack</p> </li> <li>Determine if the input string is valid.</li> <li>Steps for the string <code>()[]{}</code>:</li> </ul> char action stack <code>(</code> push \"(\" <code>)</code> pop \"\" <code>[</code> push \"[\" <code>]</code> pop \"\" <code>{</code> push \"{\" <code>}</code> pop \"\" 20. Valid Parentheses - Python Solution<pre><code># Stack\ndef isValid(s: str) -&gt; bool:\n    hashmap = {\n        \")\": \"(\",\n        \"]\": \"[\",\n        \"}\": \"{\",\n    }\n    stack = []\n\n    for ch in s:\n        if ch in hashmap:\n            if stack and stack[-1] == hashmap[ch]:\n                stack.pop()\n            else:\n                return False\n        else:\n            stack.append(ch)\n\n    return True if not stack else False\n\n\nif __name__ == \"__main__\":\n    assert isValid(\"()[]{}\")\n    assert not isValid(\"(]\")\n    assert not isValid(\"([)]\")\n    assert isValid(\"{[]}\")\n    assert isValid(\"\")\n</code></pre> 20. Valid Parentheses - C++ Solution<pre><code>#include &lt;cassert&gt;\n#include &lt;stack&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool isValid(string s) {\n        unordered_map&lt;char, char&gt; map{{')', '('}, {'}', '{'}, {']', '['}};\n        stack&lt;char&gt; stack;\n        if (s.length() % 2 == 1) return false;\n\n        for (char&amp; ch : s) {\n            if (stack.empty() || map.find(ch) == map.end()) {\n                stack.push(ch);\n            } else {\n                if (map[ch] != stack.top()) {\n                    return false;\n                }\n                stack.pop();\n            }\n        }\n        return stack.empty();\n    }\n};\n\nint main() {\n    Solution s;\n    assert(s.isValid(\"()\") == true);\n    assert(s.isValid(\"()[]{}\") == true);\n    assert(s.isValid(\"(]\") == false);\n    assert(s.isValid(\"([)]\") == false);\n    assert(s.isValid(\"{[]}\") == true);\n    return 0;\n}\n</code></pre>"},{"location":"content/interview150/stack/#71-simplify-path","title":"71. Simplify Path","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack 71. Simplify Path - Python Solution<pre><code>def simplify_path_stack(path: str) -&gt; str:\n    if not path:\n        return \"/\"\n\n    stack = []\n\n    for p in path.split(\"/\"):\n        if p == \"\" or p == \".\":\n            continue\n        if p != \"..\":\n            stack.append(p)\n        elif stack:\n            stack.pop()\n    return \"/\" + \"/\".join(stack)\n\n\nif __name__ == \"__main__\":\n    assert simplify_path_stack(\"/home/\") == \"/home\"\n    assert simplify_path_stack(\"/../\") == \"/\"\n    assert simplify_path_stack(\"/home//foo/\") == \"/home/foo\"\n    assert simplify_path_stack(\"/a/./b/../../c/\") == \"/c\"\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/stack/#155-min-stack","title":"155. Min Stack","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: stack, design</p> </li> <li>Implement a stack that supports push, pop, top, and retrieving the minimum element in constant time.</li> </ul> 155. Min Stack - Python Solution<pre><code># Stack\nclass MinStack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, val: int) -&gt; None:\n        if self.stack:\n            self.stack.append((val, min(val, self.getMin())))\n        else:\n            self.stack.append((val, val))\n\n    def pop(self) -&gt; None:\n        self.stack.pop()\n\n    def top(self) -&gt; int:\n        return self.stack[-1][0]\n\n    def getMin(self) -&gt; int:\n        return self.stack[-1][1]\n\n\nobj = MinStack()\nobj.push(3)\nobj.push(2)\nobj.pop()\nprint(obj.top())  # 3\nprint(obj.getMin())  # 3\n</code></pre> 155. Min Stack - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;climits&gt;\n#include &lt;iostream&gt;\n#include &lt;stack&gt;\n#include &lt;utility&gt;\nusing namespace std;\n\nclass MinStack {\n    stack&lt;pair&lt;int, int&gt;&gt; st;\n\n   public:\n    MinStack() { st.emplace(0, INT_MAX); }\n\n    void push(int val) { st.emplace(val, min(getMin(), val)); }\n\n    void pop() { st.pop(); }\n\n    int top() { return st.top().first; }\n\n    int getMin() { return st.top().second; }\n};\n\nint main() {\n    MinStack minStack;\n    minStack.push(-2);\n    minStack.push(0);\n    minStack.push(-3);\n    cout &lt;&lt; minStack.getMin() &lt;&lt; endl;  // -3\n    minStack.pop();\n    cout &lt;&lt; minStack.top() &lt;&lt; endl;     // 0\n    cout &lt;&lt; minStack.getMin() &lt;&lt; endl;  // -2\n    return 0;\n}\n</code></pre>"},{"location":"content/interview150/stack/#150-evaluate-reverse-polish-notation","title":"150. Evaluate Reverse Polish Notation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, stack</p> </li> <li>Steps for the list <code>[\"2\", \"1\", \"+\", \"3\", \"*\"]</code>:</li> </ul> token action stack <code>2</code> push <code>[2]</code> <code>1</code> push <code>[2, 1]</code> <code>+</code> pop <code>[3]</code> <code>3</code> push <code>[3, 3]</code> <code>*</code> pop <code>[9]</code> 150. Evaluate Reverse Polish Notation - Python Solution<pre><code>from typing import List\n\n\n# Stack\ndef evalRPN(tokens: List[str]) -&gt; int:\n    stack = []\n\n    for c in tokens:\n        if c == \"+\":\n            stack.append(stack.pop() + stack.pop())\n        elif c == \"-\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(b - a)\n        elif c == \"*\":\n            stack.append(stack.pop() * stack.pop())\n        elif c == \"/\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(int(b / a))\n        else:\n            stack.append(int(c))\n\n    return stack[0]\n\n\nprint(evalRPN([\"2\", \"1\", \"+\", \"3\", \"*\"]))  # 9\nprint(evalRPN([\"4\", \"13\", \"5\", \"/\", \"-\"]))  # 2\nprint(evalRPN([\"18\"]))  # 18\nprint(evalRPN([\"4\", \"3\", \"-\"]))  # 1\n</code></pre>"},{"location":"content/interview150/stack/#224-basic-calculator","title":"224. Basic Calculator","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, string, stack, recursion 224. Basic Calculator - Python Solution<pre><code># Stack\ndef calculate(s: str) -&gt; int:\n    stack = []\n    result = 0\n    number = 0\n    sign = 1\n\n    for char in s:\n        if char.isdigit():\n            number = number * 10 + int(char)\n\n        elif char == \"+\":\n            result += sign * number\n            number = 0\n            sign = 1\n        elif char == \"-\":\n            result += sign * number\n            number = 0\n            sign = -1\n\n        elif char == \"(\":\n            stack.append(result)\n            stack.append(sign)\n            result = 0\n            sign = 1\n        elif char == \")\":\n            result += sign * number\n            number = 0\n            result *= stack.pop()  # pop sign\n            result += stack.pop()  # pop previous result\n\n    result += sign * number\n\n    return result\n\n\nprint(calculate(\"(1+(4+5+2)-3)+(6+8)\"))  # 23\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/trie/","title":"Trie","text":""},{"location":"content/interview150/trie/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 208. Implement Trie (Prefix Tree) (Medium)</li> <li> 211. Design Add and Search Words Data Structure (Medium)</li> <li> 212. Word Search II (Hard)</li> </ul>"},{"location":"content/interview150/trie/#208-implement-trie-prefix-tree","title":"208. Implement Trie (Prefix Tree)","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, design, trie</p> </li> </ul>"},{"location":"content/interview150/trie/#trie_1","title":"Trie","text":"<ul> <li>A trie is a tree-like data structure whose nodes store the letters of an alphabet.</li> </ul> <pre><code>flowchart TD\nRoot(( ))\nRoot --- C1((\"C\"))\nRoot --- D((D))\nC1 --- A1((\"A\"))\nA1 --- T1((\"T\"))\nA1 --- R1((\"R\"))\nA1 --- N((N))\nRoot --- B1((B))\nB1 --- A2((A))\nA2 --- T2((T))\nA2 --- R2((R))</code></pre> 208. Implement Trie (Prefix Tree) - Python Solution<pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.endOfWord = None\n\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.endOfWord = True\n\n    def search(self, word: str) -&gt; bool:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return node.endOfWord\n\n    def startsWith(self, prefix: str) -&gt; bool:\n        node = self.root\n\n        for c in prefix:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return True\n\n\n# Your Trie object will be instantiated and called as such:\nobj = Trie()\nobj.insert(\"apple\")\nprint(obj.search(\"word\"))  # False\nprint(obj.startsWith(\"app\"))  # True\n</code></pre>"},{"location":"content/interview150/trie/#211-design-add-and-search-words-data-structure","title":"211. Design Add and Search Words Data Structure","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, depth first search, design, trie 211. Design Add and Search Words Data Structure - Python Solution<pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.word = False\n\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.word = True\n\n    def search(self, word: str) -&gt; bool:\n\n        def dfs(j, root):\n            node = root\n\n            for i in range(j, len(word)):\n                c = word[i]\n\n                if c == \".\":\n                    for child in node.children.values():\n                        if dfs(i + 1, child):\n                            return True\n                    return False\n                else:\n                    if c not in node.children:\n                        return False\n                    node = node.children[c]\n            return node.word\n\n        return dfs(0, self.root)\n\n\n# Your WordDictionary object will be instantiated and called as such:\nobj = WordDictionary()\nobj.addWord(\"word\")\nprint(obj.search(\"word\"))\nprint(obj.search(\"w.rd\"))\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/trie/#212-word-search-ii","title":"212. Word Search II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, backtracking, trie, matrix 212. Word Search II - Python Solution<pre><code>from typing import List\n\nfrom template import TrieNode\n\n\n# Backtracking + Trie\ndef findWords(board: List[List[str]], words: List[str]) -&gt; List[str]:\n    root = TrieNode()\n    for word in words:\n        root.addWord(word)\n\n    m, n = len(board), len(board[0])\n    result, visit = set(), set()\n\n    def dfs(r, c, node, word):\n        if (\n            r &lt; 0\n            or r &gt;= m\n            or c &lt; 0\n            or c &gt;= n\n            or (r, c) in visit\n            or board[r][c] not in node.children\n        ):\n            return None\n\n        visit.add((r, c))\n\n        node = node.children[board[r][c]]\n        word += board[r][c]\n        if node.isWord:\n            result.add(word)\n\n        dfs(r - 1, c, node, word)\n        dfs(r + 1, c, node, word)\n        dfs(r, c - 1, node, word)\n        dfs(r, c + 1, node, word)\n\n        visit.remove((r, c))\n\n    for r in range(m):\n        for c in range(n):\n            dfs(r, c, root, \"\")\n\n    return list(result)\n\n\nboard = [\n    [\"o\", \"a\", \"a\", \"n\"],\n    [\"e\", \"t\", \"a\", \"e\"],\n    [\"i\", \"h\", \"k\", \"r\"],\n    [\"i\", \"f\", \"l\", \"v\"],\n]\nwords = [\"oath\", \"pea\", \"eat\", \"rain\"]\nprint(findWords(board, words))\n# ['eat', 'oath']\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/two_pointers/","title":"Two Pointers","text":""},{"location":"content/interview150/two_pointers/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 125. Valid Palindrome (Easy)</li> <li> 392. Is Subsequence (Easy)</li> <li> 167. Two Sum II - Input Array Is Sorted (Medium)</li> <li> 11. Container With Most Water (Medium)</li> <li> 15. 3Sum (Medium)</li> </ul>"},{"location":"content/interview150/two_pointers/#125-valid-palindrome","title":"125. Valid Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string 125. Valid Palindrome - Python Solution<pre><code># List Comprehension\ndef isPalindrome(s: str) -&gt; bool:\n    s = [char.lower() for char in s if char.isalnum()]\n    return s == s[::-1]\n\n\n# Left Right Pointers\ndef isPalindromeLR(s: str) -&gt; bool:\n    left, right = 0, len(s) - 1\n\n    while left &lt; right:\n        while left &lt; right and not s[left].isalnum():\n            left += 1\n        while left &lt; right and not s[right].isalnum():\n            right -= 1\n\n        if s[left].lower() != s[right].lower():\n            return False\n\n        left += 1\n        right -= 1\n\n    return True\n\n\ns = \"A man, a plan, a canal: Panama\"\nprint(isPalindrome(s))  # True\nprint(isPalindromeLR(s))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/two_pointers/#392-is-subsequence","title":"392. Is Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string, dynamic programming 392. Is Subsequence - Python Solution<pre><code># DP - LCS\ndef isSubsequenceLCS(s: str, t: str) -&gt; bool:\n    m = len(s)\n    n = len(t)\n\n    if m &gt; n:\n        return False\n\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    length = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = dp[i][j - 1]  # only delete t string\n\n            if length &lt; dp[i][j]:\n                length = dp[i][j]\n\n    return length == m\n\n\n# Two Pointers\ndef isSubsequenceTP(s: str, t: str) -&gt; bool:\n    i, j = 0, 0\n\n    while i &lt; len(s) and j &lt; len(t):\n        if s[i] == t[j]:\n            i += 1\n        j += 1\n\n    return i == len(s)\n\n\ns = \"abc\"\nt = \"ahbgdc\"\nprint(isSubsequenceLCS(s, t))  # True\nprint(isSubsequenceTP(s, t))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/two_pointers/#167-two-sum-ii-input-array-is-sorted","title":"167. Two Sum II - Input Array Is Sorted","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search 167. Two Sum II - Input Array Is Sorted - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef twoSum(numbers: List[int], target: int) -&gt; List[int]:\n    left, right = 0, len(numbers) - 1\n\n    while left &lt; right:\n        total = numbers[left] + numbers[right]\n\n        if total &gt; target:\n            right -= 1\n        elif total &lt; target:\n            left += 1\n        else:\n            return [left + 1, right + 1]\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nnumbers = [2, 7, 11, 15]\ntarget = 9\nprint(twoSum(numbers, target))  # [1, 2]\n</code></pre></p> </li> </ul>"},{"location":"content/interview150/two_pointers/#11-container-with-most-water","title":"11. Container With Most Water","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy</p> </li> <li>Return the maximum area of water that can be trapped between the vertical lines.</li> </ul> <p></p> 11. Container With Most Water - Python Solution<pre><code>from typing import List\n\n\n# Brute Force\ndef maxAreaBF(height: List[int]) -&gt; int:\n    max_area = 0\n\n    for i in range(len(height)):\n        for j in range(i + 1, len(height)):\n            h = min(height[i], height[j])\n            w = j - i\n            max_area = max(max_area, h * w)\n\n    return max_area\n\n\n# Left Right Pointers\ndef maxAreaLR(height: List[int]) -&gt; int:\n    left, right = 0, len(height) - 1\n    res = 0\n\n    while left &lt; right:\n        h = min(height[left], height[right])\n        w = right - left\n        res = max(res, h * w)\n\n        if height[left] &lt; height[right]:\n            left += 1\n        else:\n            right -= 1\n\n    return res\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force| O(n^2) |  O(1)   |\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nheight = [1, 8, 6, 2, 5, 4, 8, 3, 7]\nprint(maxAreaBF(height))  # 49\nprint(maxAreaLR(height))  # 49\n</code></pre> 11. Container With Most Water - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint maxArea(vector&lt;int&gt;&amp; height) {\n    int left = 0, right = height.size() - 1;\n    int res = 0;\n\n    while (left &lt; right) {\n        int h = min(height[left], height[right]);\n        int w = right - left;\n        res = max(res, h * w);\n\n        if (height[left] &lt; height[right])\n            left++;\n        else\n            right--;\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; height = {1, 8, 6, 2, 5, 4, 8, 3, 7};\n    cout &lt;&lt; maxArea(height) &lt;&lt; endl;  // 49\n    return 0;\n}\n</code></pre>"},{"location":"content/interview150/two_pointers/#15-3sum","title":"15. 3Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, sorting 15. 3Sum - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef threeSum(nums: List[int]) -&gt; List[List[int]]:\n    nums.sort()\n    res = []\n    n = len(nums)\n\n    for i in range(n - 2):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        left, right = i + 1, n - 1\n\n        while left &lt; right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total &gt; 0:\n                right -= 1\n            elif total &lt; 0:\n                left += 1\n            else:\n                res.append([nums[i], nums[left], nums[right]])\n\n                while left &lt; right and nums[left] == nums[left + 1]:\n                    left += 1\n\n                while left &lt; right and nums[right] == nums[right - 1]:\n                    right -= 1\n\n                left += 1\n                right -= 1\n\n    return res\n\n\nnums = [-1, 0, 1, 2, -1, -4]\nassert threeSum(nums) == [[-1, -1, 2], [-1, 0, 1]]\n</code></pre></p> </li> </ul> 15. 3Sum - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {\n    sort(nums.begin(), nums.end());\n    vector&lt;vector&lt;int&gt;&gt; res;\n    int n = nums.size();\n\n    for (int i = 0; i &lt; n - 2; i++) {\n        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) {\n            continue;\n        }\n\n        int left = i + 1, right = n - 1;\n\n        while (left &lt; right) {\n            int total = nums[i] + nums[left] + nums[right];\n\n            if (total &gt; 0)\n                right--;\n            else if (total &lt; 0)\n                left++;\n            else {\n                res.push_back({nums[i], nums[left], nums[right]});\n                while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++;\n                while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--;\n                left++;\n                right--;\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {-1, 0, 1, 2, -1, -4};\n    vector&lt;vector&lt;int&gt;&gt; res = threeSum(nums);\n    for (auto&amp; v : res) {\n        for (int i : v) {\n            cout &lt;&lt; i &lt;&lt; \" \";\n        }\n        cout &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"content/leetpattern/","title":"LeetPattern","text":""},{"location":"content/leetpattern/#resources","title":"Resources","text":"<ul> <li>\u6ed1\u52a8\u7a97\u53e3\u9898\u5355</li> </ul>"},{"location":"content/leetpattern/#sheet","title":"Sheet","text":"<ul> <li>In order to visualize and practice the algorithm, I use google sheets to make drafts. You also can have access to it here.</li> </ul>"},{"location":"content/leetpattern/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python Basics: Python Distilled</li> </ul>"},{"location":"content/leetpattern/#resources_1","title":"Resources","text":"<ul> <li>\u7b97\u6cd5\u7ade\u8d5b\u6a21\u677f\u5e93 by \u7075\u8336\u5c71\u827e\u5e9c</li> <li>[Leetcode Discuss] Solved all two pointers problems in 100 days</li> <li>[Leetcode Discuss] Solved all dynamic programming (dp) problems in 7 months</li> <li>liquidslr/leetcode-company-wise-problems</li> <li>\u5982\u4f55\u66f4\u52a0\u4f18\u96c5\u5730\u4f7f\u7528 LeetCode \u5237\u9898 \uff1f</li> </ul>"},{"location":"content/leetpattern/#dynamic-programming","title":"Dynamic Programming","text":"<p>Steps to Solve DP Problems</p> <ol> <li>Define the <code>dp</code> array and its meaning.</li> <li>Define the <code>dp</code> formula.</li> <li>Initialize the <code>dp</code> array.</li> <li>Determine the traversal direction.</li> <li>Derive the <code>dp</code> array.</li> </ol>"},{"location":"content/leetpattern/#c-containers","title":"C++ Containers","text":"<ul> <li>Array (<code>std::vector</code>)</li> </ul> Operation Method Append <code>v.push_back(x);</code> Pop last element <code>v.pop_back();</code> Insert at position <code>v.insert(v.begin() + index, x);</code> Remove at position <code>v.erase(v.begin() + index);</code> Clear all elements <code>v.clear();</code> Get size <code>v.size();</code> Access element <code>v[i]</code> or <code>v.at(i);</code> Sort <code>sort(v.begin(), v.end());</code> <ul> <li>Deque (<code>std::deque</code>)</li> </ul> Operation Method Append (back) <code>d.push_back(x);</code> Append (front) <code>d.push_front(x);</code> Pop last <code>d.pop_back();</code> Pop front <code>d.pop_front();</code> Access front <code>d.front();</code> Access back <code>d.back();</code> <ul> <li>Queue (<code>std::queue</code>)</li> </ul> Operation Method Enqueue (push) <code>q.push(x);</code> Dequeue (pop) <code>q.pop();</code> Get front element <code>q.front();</code> Get back element <code>q.back();</code> Check if empty <code>q.empty();</code> Get size <code>q.size();</code> <ul> <li>Priority Queue (<code>std::priority_queue</code>)<ul> <li>Default is max heap</li> </ul> </li> </ul> Operation Method Insert <code>pq.push(x);</code> Remove top <code>pq.pop();</code> Get top element <code>pq.top();</code> Check if empty <code>pq.empty();</code> Get size <code>pq.size();</code> Min heap <code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;</code> <ul> <li>Stack (<code>std::stack</code>)</li> </ul> Operation Method Push <code>s.push(x);</code> Pop <code>s.pop();</code> Get top element <code>s.top();</code> Check if empty <code>s.empty();</code> Get size <code>s.size();</code> <ul> <li>Set (<code>std::set</code>)</li> </ul> Operation Method Insert <code>s.insert(x);</code> Remove <code>s.erase(x);</code> Check existence <code>s.count(x);</code> Get size <code>s.size();</code> Find element <code>s.find(x);</code> Get first element <code>*s.begin();</code> Get last element <code>*s.rbegin();</code> <ul> <li>Unordered Set (<code>std::unordered_set</code>)<ul> <li>Similar to <code>std::set</code>, but uses hashing for faster lookups</li> </ul> </li> </ul> Operation Method Insert <code>us.insert(x);</code> Remove <code>us.erase(x);</code> Check existence <code>us.count(x);</code> Find element <code>us.find(x);</code> <ul> <li>Map (<code>std::map</code>)</li> </ul> Operation Method Insert/update <code>mp[key] = value;</code> Get value <code>mp[key];</code> Remove key <code>mp.erase(key);</code> Check existence <code>mp.count(key);</code> Get size <code>mp.size();</code> Iterate <code>for (auto [k, v] : mp) { ... }</code> <ul> <li>Unordered Map (<code>std::unordered_map</code>)<ul> <li>Similar to <code>std::map</code>, but uses hashing for faster lookups</li> </ul> </li> </ul> Operation Method Insert/update <code>ump[key] = value;</code> Get value <code>ump[key];</code> Remove key <code>ump.erase(key);</code> Check existence <code>ump.count(key);</code> <ul> <li>List (<code>std::list</code>)<ul> <li>Doubly linked list</li> </ul> </li> </ul> Operation Method Push front <code>lst.push_front(x);</code> Push back <code>lst.push_back(x);</code> Pop front <code>lst.pop_front();</code> Pop back <code>lst.pop_back();</code> Insert at position <code>lst.insert(it, x);</code> Remove element <code>lst.remove(x);</code>"},{"location":"content/leetpattern/array/","title":"Array","text":""},{"location":"content/leetpattern/array/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 414. Third Maximum Number (Easy)</li> <li> 169. Majority Element (Easy)</li> <li> 2022. Convert 1D Array Into 2D Array (Easy)</li> <li> 54. Spiral Matrix (Medium)</li> <li> 59. Spiral Matrix II (Medium)</li> </ul>"},{"location":"content/leetpattern/array/#414-third-maximum-number","title":"414. Third Maximum Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, sorting</p> </li> <li>Return the third maximum number in an array. If the third maximum does not exist, return the maximum number.</li> </ul> 414. Third Maximum Number - Python Solution<pre><code>from typing import List\n\n\n# Sort\ndef thirdMaxSort(nums: List[int]) -&gt; int:\n    nums = list(set(nums))\n    nums.sort(reverse=True)\n\n    return nums[2] if len(nums) &gt;= 3 else nums[0]\n\n\n# Compare\ndef thirdMaxCompare(nums: List[int]) -&gt; int:\n    first, second, third = float(\"-inf\"), float(\"-inf\"), float(\"-inf\")\n\n    for num in nums:\n        if num &gt; first:\n            first, second, third = num, first, second\n        elif first &gt; num &gt; second:\n            second, third = num, second\n        elif second &gt; num &gt; third:\n            third = num\n\n    return third if third != float(\"-inf\") else first\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Sort     |    O(NlogN)     |     O(N)     |\n# |  Compare    |       O(N)      |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\nprint(thirdMaxSort([3, 2, 1]))  # 1\nprint(thirdMaxCompare([3, 2, 1]))  # 1\n</code></pre>"},{"location":"content/leetpattern/array/#169-majority-element","title":"169. Majority Element","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, divide and conquer, sorting, counting</p> </li> <li>Return the majority element in an array. The majority element is the element that appears more than <code>n // 2</code> times.</li> </ul> <code>num</code> <code>count</code> <code>res</code> 2 1 2 2 2 2 1 1 2 1 0 2 1 1 1 2 0 1 2 1 2 169. Majority Element - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash Map\ndef majorityElementHashMap(nums: List[int]) -&gt; int:\n    n = len(nums)\n    freq = defaultdict(int)\n\n    for num in nums:\n        freq[num] += 1\n        if freq[num] &gt; n // 2:\n            return num\n\n\n# Array - Boyer-Moore Voting Algorithm\ndef majorityElementArray(nums: List[int]) -&gt; int:\n    res = None\n    count = 0\n\n    for num in nums:\n        if count == 0:\n            res = num\n        count += 1 if num == res else -1\n\n    return res\n\n\n# | Algorithm | Time Complexity | Space Complexity |\n# |-----------|-----------------|------------------|\n# | HashMap   | O(N)            | O(N)             |\n# | Array     | O(N)            | O(1)             |\n# |-----------|-----------------|------------------|\n\n\nnums = [2, 2, 1, 1, 1, 2, 2]\nprint(majorityElementArray(nums))  # 2\nprint(majorityElementHashMap(nums))  # 2\n</code></pre>"},{"location":"content/leetpattern/array/#2022-convert-1d-array-into-2d-array","title":"2022. Convert 1D Array Into 2D Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, matrix, simulation 2022. Convert 1D Array Into 2D Array - Python Solution<pre><code>from typing import List\n\n\n# Brute Force\ndef construct2DArray(original: List[int], m: int, n: int) -&gt; List[List[int]]:\n    if len(original) != m * n:\n        return []\n    array = []\n\n    for i in range(m):\n        row = original[n * i : n * (i + 1)]\n        array.append(row)\n\n    return array\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |  Brute     |  O(m)  |  O(1)   |\n# |------------|--------|---------|\n\n\noriginal = [1, 2, 3, 4]\nm = 2\nn = 2\n\nprint(construct2DArray(original, m, n))  # [[1, 2], [3, 4]]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/array/#54-spiral-matrix","title":"54. Spiral Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, matrix, simulation</p> </li> <li>Return all elements of the matrix in spiral order.</li> </ul> 54. Spiral Matrix - Python Solution<pre><code>from typing import List\n\n\n# Array\ndef spiralOrder(matrix: List[List[int]]) -&gt; List[int]:\n    if not matrix or not matrix[0]:\n        return []\n\n    res = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n\n    while top &lt;= bottom and left &lt;= right:\n\n        for i in range(left, right + 1):\n            res.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            res.append(matrix[i][right])\n        right -= 1\n\n        if top &lt;= bottom:\n\n            for i in range(right, left - 1, -1):\n                res.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left &lt;= right:\n\n            for i in range(bottom, top - 1, -1):\n                res.append(matrix[i][left])\n            left += 1\n\n    return res\n\n\n# Math\ndef spiralOrderMath(matrix: List[List[int]]) -&gt; List[int]:\n    dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]]  # Right Down Left Up\n    m, n = len(matrix), len(matrix[0])\n    size = m * n\n    res = []\n    i, j, di = 0, -1, 0\n\n    while len(res) &lt; size:\n        dx, dy = dirs[di]\n        for _ in range(n):\n            i += dx\n            j += dy\n            res.append(matrix[i][j])\n        di = (di + 1) % 4\n        n, m = m - 1, n\n\n    return res\n\n\nprint(spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n# [1, 2, 3, 6, 9, 8, 7, 4, 5]\nprint(spiralOrderMath([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]))\n# [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]\n</code></pre>"},{"location":"content/leetpattern/array/#59-spiral-matrix-ii","title":"59. Spiral Matrix II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, matrix, simulation</p> </li> <li>Return a square matrix filled with elements from 1 to n^2 in spiral order.</li> </ul> 59. Spiral Matrix II - Python Solution<pre><code>from pprint import pprint\nfrom typing import List\n\n\n# Array\ndef generateMatrix(n: int) -&gt; List[List[int]]:\n    matrix = [[0] * n for _ in range(n)]\n    num = 1\n\n    for layer in range((n + 1) // 2):\n        for i in range(layer, n - layer):\n            matrix[layer][i] = num\n            num += 1\n        for j in range(layer + 1, n - layer):\n            matrix[j][n - 1 - layer] = num\n            num += 1\n        for i in range(n - 2 - layer, layer - 1, -1):\n            matrix[n - 1 - layer][i] = num\n            num += 1\n        for j in range(n - 2 - layer, layer, -1):\n            matrix[j][layer] = num\n            num += 1\n\n    return matrix\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |   Layer     |      O(N^2)     |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\npprint(generateMatrix(5))\n# [[ 1,  2,  3,  4, 5],\n#  [16, 17, 18, 19, 6],\n#  [15, 24, 25, 20, 7],\n#  [14, 23, 22, 21, 8],\n#  [13, 12, 11, 10, 9]]\n</code></pre>"},{"location":"content/leetpattern/backtracking/","title":"Backtracking","text":""},{"location":"content/leetpattern/backtracking/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 77. Combinations (Medium)</li> <li> 17. Letter Combinations of a Phone Number (Medium)</li> <li> 39. Combination Sum (Medium)</li> <li> 40. Combination Sum II (Medium)</li> <li> 216. Combination Sum III (Medium)</li> <li> 131. Palindrome Partitioning (Medium)</li> <li> 93. Restore IP Addresses (Medium)</li> <li> 78. Subsets (Medium)</li> <li> 90. Subsets II (Medium)</li> <li> 491. Non-decreasing Subsequences (Medium)</li> <li> 46. Permutations (Medium)</li> <li> 47. Permutations II (Medium)</li> <li> 51. N-Queens (Hard)</li> <li> 37. Sudoku Solver (Hard)</li> <li> 79. Word Search (Medium)</li> <li> 212. Word Search II (Hard)</li> </ul>"},{"location":"content/leetpattern/backtracking/#77-combinations","title":"77. Combinations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: backtracking 77. Combinations - Python Solution<pre><code>import itertools\nfrom typing import List\n\n\n# Backtracking\ndef combine(n: int, k: int) -&gt; List[List[int]]:\n    res = []\n\n    def backtrack(start, path):\n        if len(path) == k:\n            res.append(path[:])\n            return None\n\n        for i in range(start, n + 1):\n            path.append(i)\n            backtrack(i + 1, path)\n            path.pop()\n\n    backtrack(1, [])\n\n    return res\n\n\n# itertools\ndef combineItertools(n: int, k: int) -&gt; List[List[int]]:\n    path = itertools.combinations(range(1, n + 1), k)\n    return path\n\n\nprint(combine(4, 2))\n# [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\nprint(list(combineItertools(4, 2)))\n# [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/backtracking/#17-letter-combinations-of-a-phone-number","title":"17. Letter Combinations of a Phone Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, backtracking</p> </li> <li>Return all possible letter combinations that the number could represent.</li> </ul> <p></p> 17. Letter Combinations of a Phone Number - Python Solution<pre><code>from typing import List\n\n\n# Backtracking\ndef letterCombinations(digits: str) -&gt; List[str]:\n    letter_map = {\n        \"2\": \"abc\",\n        \"3\": \"def\",\n        \"4\": \"ghi\",\n        \"5\": \"jkl\",\n        \"6\": \"mno\",\n        \"7\": \"pqrs\",\n        \"8\": \"tuv\",\n        \"9\": \"wxyz\",\n    }\n\n    n = len(digits)\n    if n == 0:\n        return []\n\n    res = []\n\n    def dfs(idx, path):\n        if idx == n:\n            res.append(path)\n            return None\n\n        letters = letter_map[digits[idx]]\n\n        for i in range(len(letters)):\n            dfs(idx + 1, path + letters[i])\n\n    dfs(0, \"\")\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert letterCombinations(\"23\") == [\n        \"ad\",\n        \"ae\",\n        \"af\",\n        \"bd\",\n        \"be\",\n        \"bf\",\n        \"cd\",\n        \"ce\",\n        \"cf\",\n    ]\n</code></pre>"},{"location":"content/leetpattern/backtracking/#39-combination-sum","title":"39. Combination Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking 39. Combination Sum - Python Solution<pre><code>from typing import List\n\n\ndef combinationSum(candidates: List[int], target: int) -&gt; List[List[int]]:\n    n = len(candidates)\n    res, path = [], []\n\n    def dfs(total, start):\n        if total &gt; target:\n            return\n        if total == target:\n            res.append(path.copy())\n            return\n\n        for i in range(start, n):\n            total += candidates[i]\n            path.append(candidates[i])\n            dfs(total, i)\n            total -= candidates[i]\n            path.pop()\n\n    dfs(0, 0)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(combinationSum([2, 3, 5], 8))\n    # [[2, 2, 2, 2], [2, 3, 3], [3, 5]]\n    print(combinationSum([2, 3, 6, 7], 7))\n    # [[2, 2, 3], [7]]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/backtracking/#40-combination-sum-ii","title":"40. Combination Sum II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking 40. Combination Sum II - Python Solution<pre><code>from typing import List\n\n\ndef combinationSum2(candidates: List[int], target: int) -&gt; List[List[int]]:\n    result, path = [], []\n    candidates.sort()\n\n    def backtracking(total, start):\n        if total == target:\n            result.append(path[:])\n            return None\n\n        for i in range(start, len(candidates)):\n\n            if i &gt; start and candidates[i] == candidates[i - 1]:\n                continue\n\n            if total + candidates[i] &gt; target:\n                break\n\n            total += candidates[i]\n            path.append(candidates[i])\n            backtracking(total, i + 1)\n            total -= candidates[i]\n            path.pop()\n\n    backtracking(0, 0)\n\n    return result\n\n\nprint(combinationSum2([10, 1, 2, 7, 6, 1, 5], 8))\n# [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/backtracking/#216-combination-sum-iii","title":"216. Combination Sum III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking 216. Combination Sum III - Python Solution<pre><code>import itertools\nfrom typing import List\n\n\n# 1. Backtracking\ndef combinationSum3(k: int, n: int) -&gt; List[List[int]]:\n    path, result = [], []\n\n    def backtracking(start):\n        if len(path) == k and sum(path) == n:\n            result.append(path[:])\n            return\n\n        for i in range(start, 10):\n            path.append(i)\n            backtracking(i + 1)\n            path.pop()\n\n    backtracking(1)\n\n    return result\n\n\n# 2. Itertools\ndef combinationSum3Itertools(k: int, n: int) -&gt; List[List[int]]:\n    combinations = itertools.combinations(range(1, 10), k)\n    result = []\n\n    for i in combinations:\n        if sum(i) == n:\n            result.append(i)\n\n    return result\n\n\nprint(combinationSum3(3, 7))  # [[1, 2, 4]]\nprint(combinationSum3Itertools(3, 7))  # [(1, 2, 4)]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/backtracking/#131-palindrome-partitioning","title":"131. Palindrome Partitioning","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming, backtracking 131. Palindrome Partitioning - Python Solution<pre><code>from typing import List\n\n\n# Backtracking\ndef partition(s: str) -&gt; List[List[str]]:\n    n = len(s)\n    res, path = [], []\n\n    def dfs(start):\n        if start == n:\n            res.append(path.copy())\n            return\n\n        for end in range(start, n):\n            cur = s[start : end + 1]\n            if cur == cur[::-1]:\n                path.append(cur)\n                dfs(end + 1)\n                path.pop()\n\n    dfs(0)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(partition(\"aab\"))\n    # [['a', 'a', 'b'], ['aa', 'b']]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/backtracking/#93-restore-ip-addresses","title":"93. Restore IP Addresses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, backtracking 93. Restore IP Addresses - Python Solution<pre><code>from typing import List\n\n\ndef restoreIpAddresses(s: str) -&gt; List[str]:\n    result = []\n\n    def backtracking(start_index, point_num, current, result):\n        # stop condition\n        if point_num == 3:\n            if is_valid(s, start_index, len(s) - 1):\n                current += s[start_index:]\n                result.append(current)\n            return\n\n        for i in range(start_index, len(s)):\n            if is_valid(s, start_index, i):\n                sub = s[start_index : i + 1]\n                backtracking(i + 1, point_num + 1, current + sub + \".\", result)\n            else:\n                break\n\n    def is_valid(s, start, end):\n        if start &gt; end:\n            return False\n\n        if s[start] == \"0\" and start != end:\n            return False\n\n        num = 0\n        for i in range(start, end + 1):\n            if not s[i].isdigit():\n                return False\n            num = num * 10 + int(s[i])\n            if num &gt; 255:\n                return False\n        return True\n\n    backtracking(0, 0, \"\", result)\n\n    return result\n\n\nprint(restoreIpAddresses(\"25525511135\"))\n# ['255.255.11.135', '255.255.111.35']\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/backtracking/#78-subsets","title":"78. Subsets","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking, bit manipulation 78. Subsets - Python Solution<pre><code>from typing import List\n\n\n# Iterative Inclusion Backtracking\ndef subsets_iterative_inclusion(nums: List[int]) -&gt; List[List[int]]:\n    n = len(nums)\n    res, path = [], []\n\n    def dfs(i):\n        res.append(path.copy())\n\n        for j in range(i, n):\n            path.append(nums[j])\n            dfs(j + 1)\n            path.pop()\n\n    dfs(0)\n\n    return res\n\n\n# Binary Decision Backtracking\ndef subsets_binary_decision(nums: List[int]) -&gt; List[List[int]]:\n    n = len(nums)\n    res, path = [], []\n\n    def dfs(i):\n        if i == n:\n            res.append(path.copy())\n            return\n\n        # Exclude\n        dfs(i + 1)\n\n        # Include\n        path.append(nums[i])\n        dfs(i + 1)\n        path.pop()\n\n    dfs(0)\n\n    return res\n\n\nprint(subsets_iterative_inclusion([1, 2, 3]))\n# [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]\nprint(subsets_binary_decision([1, 2, 3]))\n# [[], [3], [2], [2, 3], [1], [1, 3], [1, 2], [1, 2, 3]]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/backtracking/#90-subsets-ii","title":"90. Subsets II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking, bit manipulation 90. Subsets II - Python Solution<pre><code>from typing import List\n\n\ndef subsetsWithDup(nums: List[int]) -&gt; List[List[int]]:\n    path, result = [], []\n    nums.sort()\n\n    def backtracking(startIndex):\n        if path not in result:\n            result.append(path[:])\n\n        for i in range(startIndex, len(nums)):\n            path.append(nums[i])\n            backtracking(i + 1)\n            path.pop()\n\n    backtracking(startIndex=0)\n\n    return result\n\n\nprint(subsetsWithDup([1, 2, 2]))\n# [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/backtracking/#491-non-decreasing-subsequences","title":"491. Non-decreasing Subsequences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, backtracking, bit manipulation 491. Non-decreasing Subsequences - Python Solution<pre><code>from typing import List\n\n\ndef findSubsequences(nums: List[int]) -&gt; List[List[int]]:\n    path, result = [], []\n\n    def backtracking(startIndex):\n        if len(path) &gt; 1:\n            result.append(path[:])\n\n        used = set()\n        for i in range(startIndex, len(nums)):\n\n            if (path and nums[i] &lt; path[-1]) or nums[i] in used:\n                continue\n\n            used.add(nums[i])\n            path.append(nums[i])\n            backtracking(i + 1)\n            path.pop()\n\n    backtracking(0)\n\n    return result\n\n\nprint(findSubsequences([4, 6, 7, 7]))\n# [[4, 6], [4, 6, 7], [4, 6, 7, 7], [4, 7], [4, 7, 7], [6, 7], [6, 7, 7], [7, 7]]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/backtracking/#46-permutations","title":"46. Permutations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking 46. Permutations - Python Solution<pre><code>from typing import List\n\n\n# Backtracking\ndef permute(nums: List[int]) -&gt; List[List[int]]:\n    n = len(nums)\n    path, res = [], []\n    used = [False for _ in range(n)]\n\n    def dfs(x: int):\n        if x == n:\n            res.append(path[:])\n            return\n\n        for i in range(n):\n            if used[i]:\n                continue\n            used[i] = True\n            path.append(nums[i])\n            dfs(x + 1)\n            path.pop()\n            used[i] = False\n\n    dfs(0)\n\n    return res\n\n\nprint(permute([1, 2, 3]))\n# [[1, 2, 3], [1, 3, 2], [2, 1, 3],\n#  [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/backtracking/#47-permutations-ii","title":"47. Permutations II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking, sorting 47. Permutations II - Python Solution<pre><code>from typing import List\n\n\ndef permuteUnique(nums: List[int]) -&gt; List[List[int]]:\n    nums.sort()\n    path, result = [], []\n    used = [False for _ in range(len(nums))]\n\n    def backtracking():\n        if len(path) == len(nums):\n            result.append(path[:])\n\n        for i in range(len(nums)):\n            if used[i]:\n                continue\n            if i &gt; 0 and nums[i] == nums[i - 1] and not used[i - 1]:\n                continue\n\n            used[i] = True\n            path.append(nums[i])\n            backtracking()\n            path.pop()\n            used[i] = False\n\n    backtracking()\n\n    return result\n\n\nprint(permuteUnique([1, 1, 2]))\n# [[1, 1, 2], [1, 2, 1], [2, 1, 1]]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/backtracking/#51-n-queens","title":"51. N-Queens","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, backtracking</p> </li> <li>Hard</li> <li>N-Queens</li> <li>N \u7687\u540e</li> </ul> 51. N-Queens - Python Solution<pre><code>from typing import List\n\n\n# Backtracking\ndef solveNQueens(n: int) -&gt; List[List[str]]:\n    res = []\n    board = [\".\" * n for _ in range(n)]\n\n    def dfs(row):\n        if row == n:\n            res.append(board[:])\n            return None\n        for col in range(n):\n            if is_valid(row, col, board):\n                board[row] = board[row][:col] + \"Q\" + board[row][col + 1 :]\n                dfs(row + 1)\n                board[row] = board[row][:col] + \".\" + board[row][col + 1 :]\n\n    def is_valid(row, col, chessboard):\n        for i in range(row):\n            if chessboard[i][col] == \"Q\":\n                return False\n\n        i, j = row - 1, col - 1\n        while i &gt;= 0 and j &gt;= 0:\n            if chessboard[i][j] == \"Q\":\n                return False\n            i -= 1\n            j -= 1\n\n        i, j = row - 1, col + 1\n        while i &gt;= 0 and j &lt; len(chessboard):\n            if chessboard[i][j] == \"Q\":\n                return False\n            i -= 1\n            j += 1\n\n        return True\n\n    dfs(0)\n\n    return [[\"\".join(row) for row in i] for i in res]\n\n\n# Backtracking\ndef solveNQueens2(n: int) -&gt; List[List[str]]:\n    res = []\n    queens = [0] * n\n    col = [False] * n\n    diag1 = [False] * (n * 2 - 1)\n    diag2 = [False] * (n * 2 - 1)\n\n    def dfs(r: int) -&gt; None:\n        if r == n:\n            res.append([\".\" * c + \"Q\" + \".\" * (n - 1 - c) for c in queens])\n            return\n\n        for c, ok in enumerate(col):\n            if not ok and not diag1[r + c] and not diag2[r - c]:\n                queens[r] = c\n                col[c] = diag1[r + c] = diag2[r - c] = True\n                dfs(r + 1)\n                col[c] = diag1[r + c] = diag2[r - c] = False\n\n    dfs(0)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(solveNQueens(4))\n    # [['.Q..', '...Q', 'Q...', '..Q.'],\n    #  ['..Q.', 'Q...', '...Q', '.Q..']]\n    print(solveNQueens(1))\n    # [['Q']]\n    print(solveNQueens2(4))\n    # [['.Q..', '...Q', 'Q...', '..Q.'],\n    #  ['..Q.', 'Q...', '...Q', '.Q..']]\n    print(solveNQueens2(1))\n    # [['Q']]\n</code></pre>"},{"location":"content/leetpattern/backtracking/#37-sudoku-solver","title":"37. Sudoku Solver","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, backtracking, matrix</p> </li> <li>Sudoku Solver</li> <li>\u89e3\u6570\u72ec</li> <li>Hard</li> </ul> 37. Sudoku Solver - Python Solution<pre><code>from pprint import pprint\nfrom typing import List\n\n\n# Backtracking - Board\ndef solveSudoku(board: List[List[str]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n\n    def backtracking(board: List[List[str]]) -&gt; bool:\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] != \".\":\n                    continue\n                for k in range(1, 10):\n                    if is_valid(i, j, k, board):\n                        board[i][j] = str(k)\n                        if backtracking(board):\n                            return True\n                        board[i][j] = \".\"\n                return False\n        return True\n\n    def is_valid(row: int, col: int, val: int, board: List[List[str]]) -&gt; bool:\n        for i in range(9):\n            if board[row][i] == str(val):\n                return False\n        for j in range(9):\n            if board[j][col] == str(val):\n                return False\n        start_row = (row // 3) * 3\n        start_col = (col // 3) * 3\n        for i in range(start_row, start_row + 3):\n            for j in range(start_col, start_col + 3):\n                if board[i][j] == str(val):\n                    return False\n        return True\n\n    backtracking(board)\n\n\nboard = [\n    [\"5\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],\n    [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n    [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n    [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n    [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n    [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n    [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"],\n    [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n    [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"],\n]\n\nsolveSudoku(board)\npprint(board)\n# [['5', '3', '4', '6', '7', '8', '9', '1', '2'],\n#  ['6', '7', '2', '1', '9', '5', '3', '4', '8'],\n#  ['1', '9', '8', '3', '4', '2', '5', '6', '7'],\n#  ['8', '5', '9', '7', '6', '1', '4', '2', '3'],\n#  ['4', '2', '6', '8', '5', '3', '7', '9', '1'],\n#  ['7', '1', '3', '9', '2', '4', '8', '5', '6'],\n#  ['9', '6', '1', '5', '3', '7', '2', '8', '4'],\n#  ['2', '8', '7', '4', '1', '9', '6', '3', '5'],\n#  ['3', '4', '5', '2', '8', '6', '1', '7', '9']]\n</code></pre>"},{"location":"content/leetpattern/backtracking/#79-word-search","title":"79. Word Search","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, backtracking, depth first search, matrix 79. Word Search - Python Solution<pre><code>from typing import List\n\n\ndef exist(board: List[List[str]], word: str) -&gt; bool:\n    m, n = len(board), len(board[0])\n    path = set()\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n\n    def dfs(r, c, i):\n        if i == len(word):\n            return True\n\n        if (\n            r &lt; 0\n            or r &gt;= m\n            or c &lt; 0\n            or c &gt;= n\n            or board[r][c] != word[i]\n            or (r, c) in path\n        ):\n            return False\n\n        path.add((r, c))\n\n        for dr, dc in dirs:\n            if dfs(r + dr, c + dc, i + 1):\n                return True\n\n        path.remove((r, c))\n        return False\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, 0):\n                return True\n\n    return False\n\n\nboard = [\n    [\"A\", \"B\", \"C\", \"E\"],\n    [\"S\", \"F\", \"C\", \"S\"],\n    [\"A\", \"D\", \"E\", \"E\"],\n]\nword = \"ABCCED\"\nprint(exist(board, word))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/backtracking/#212-word-search-ii","title":"212. Word Search II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, backtracking, trie, matrix 212. Word Search II - Python Solution<pre><code>from typing import List\n\nfrom template import TrieNode\n\n\n# Backtracking + Trie\ndef findWords(board: List[List[str]], words: List[str]) -&gt; List[str]:\n    root = TrieNode()\n    for word in words:\n        root.addWord(word)\n\n    m, n = len(board), len(board[0])\n    result, visit = set(), set()\n\n    def dfs(r, c, node, word):\n        if (\n            r &lt; 0\n            or r &gt;= m\n            or c &lt; 0\n            or c &gt;= n\n            or (r, c) in visit\n            or board[r][c] not in node.children\n        ):\n            return None\n\n        visit.add((r, c))\n\n        node = node.children[board[r][c]]\n        word += board[r][c]\n        if node.isWord:\n            result.add(word)\n\n        dfs(r - 1, c, node, word)\n        dfs(r + 1, c, node, word)\n        dfs(r, c - 1, node, word)\n        dfs(r, c + 1, node, word)\n\n        visit.remove((r, c))\n\n    for r in range(m):\n        for c in range(n):\n            dfs(r, c, root, \"\")\n\n    return list(result)\n\n\nboard = [\n    [\"o\", \"a\", \"a\", \"n\"],\n    [\"e\", \"t\", \"a\", \"e\"],\n    [\"i\", \"h\", \"k\", \"r\"],\n    [\"i\", \"f\", \"l\", \"v\"],\n]\nwords = [\"oath\", \"pea\", \"eat\", \"rain\"]\nprint(findWords(board, words))\n# ['eat', 'oath']\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/binary_search/","title":"Binary Search","text":""},{"location":"content/leetpattern/binary_search/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 704. Binary Search (Easy)</li> <li> 35. Search Insert Position (Easy)</li> <li> 278. First Bad Version (Easy)</li> <li> 34. Find First and Last Position of Element in Sorted Array (Medium)</li> <li> 367. Valid Perfect Square (Easy)</li> <li> 875. Koko Eating Bananas (Medium)</li> <li> 1011. Capacity To Ship Packages Within D Days (Medium)</li> <li> 378. Kth Smallest Element in a Sorted Matrix (Medium)</li> </ul>"},{"location":"content/leetpattern/binary_search/#704-binary-search","title":"704. Binary Search","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, binary search</p> </li> <li>Implement binary search algorithm.</li> </ul> 704. Binary Search - Python Solution<pre><code>from typing import List\n\n\n# Binary Search [left, right]\ndef search(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] &lt; target:\n            left = mid + 1\n        elif nums[mid] &gt; target:\n            right = mid - 1\n        else:\n            return mid\n\n    return -1\n\n\n# Binary Search [left, right)\ndef search_half_open(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums)\n\n    while left &lt; right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] &lt; target:\n            left = mid + 1\n        elif nums[mid] &gt; target:\n            right = mid\n        else:\n            return mid\n\n    return -1\n\n\n# Binary Search (left, right)\ndef search_open_interval(nums: List[int], target: int) -&gt; int:\n    left, right = -1, len(nums)\n\n    while left + 1 &lt; right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] &lt; target:\n            left = mid\n        elif nums[mid] &gt; target:\n            right = mid\n        else:\n            return mid\n\n    return -1\n\n\nif __name__ == \"__main__\":\n    nums = [-1, 0, 3, 5, 9, 12]\n    target = 9\n    assert search(nums, target) == 4\n    assert search_half_open(nums, target) == 4\n    assert search_open_interval(nums, target) == 4\n</code></pre>"},{"location":"content/leetpattern/binary_search/#35-search-insert-position","title":"35. Search Insert Position","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, binary search</p> </li> <li>Return the index of the target if it is found. If not, return the index where it would be if it were inserted in order.</li> </ul> 35. Search Insert Position - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef searchInsert(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        if nums[mid] &lt; target:\n            left = mid + 1\n        elif nums[mid] &gt; target:\n            right = mid - 1\n        else:\n            return mid\n\n    return left\n\n\nnums = [1, 3, 5, 6]\ntarget = 5\nprint(searchInsert(nums, target))  # 2\n</code></pre>"},{"location":"content/leetpattern/binary_search/#278-first-bad-version","title":"278. First Bad Version","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: binary search, interactive</p> </li> <li>Find the first bad version given a function <code>isBadVersion</code>.</li> </ul> 278. First Bad Version - Python Solution<pre><code># Binary Search\ndef firstBadVersion(n: int) -&gt; int:\n    left, right = 1, n\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if isBadVersion(mid):\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return left\n\n\ndef isBadVersion(version: int) -&gt; bool:\n    pass\n</code></pre>"},{"location":"content/leetpattern/binary_search/#34-find-first-and-last-position-of-element-in-sorted-array","title":"34. Find First and Last Position of Element in Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> <li>Find the starting and ending position of a given target value in a sorted array.</li> </ul> 34. Find First and Last Position of Element in Sorted Array - Python Solution<pre><code>from bisect import bisect_left\nfrom typing import List\n\n\n# Binary Search\ndef searchRangeBS(nums: List[int], target: int) -&gt; List[int]:\n    def bisect_left(nums, target):\n        left, right = 0, len(nums) - 1\n        while left &lt;= right:\n            mid = left + (right - left) // 2\n            if nums[mid] &lt; target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n\n    left = bisect_left(nums, target)\n    right = bisect_left(nums, target + 1) - 1\n\n    if left &lt;= right:\n        return [left, right]\n\n    return [-1, -1]\n\n\n# Bisect\ndef searchRangeBSBisect(nums: List[int], target: int) -&gt; List[int]:\n    if not nums:\n        return [-1, -1]\n\n    left = bisect_left(nums, target)\n    right = bisect_left(nums, target + 1) - 1\n\n    return [left, right] if left &lt;= right else [-1, -1]\n\n\nnums = [5, 7, 7, 8, 8, 10]\ntarget = 8\nprint(searchRangeBS(nums, target))  # [3, 4]\nprint(searchRangeBSBisect(nums, target))  # [3, 4]\n</code></pre> 34. Find First and Last Position of Element in Sorted Array - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\n  int bisect_left(vector&lt;int&gt; &amp;nums, int target)\n  {\n    int left = 0, right = (int)nums.size() - 1;\n\n    while (left &lt;= right)\n    {\n      int mid = left + (right - left) / 2;\n      if (nums[mid] &lt; target)\n      {\n        left = mid + 1;\n      }\n      else\n      {\n        right = mid - 1;\n      }\n    }\n    return left;\n  }\n\npublic:\n  vector&lt;int&gt; searchRange(vector&lt;int&gt; &amp;nums, int target)\n  {\n    int left = bisect_left(nums, target);\n    if (left == (int)nums.size() || nums[left] != target)\n    {\n      return {-1, -1};\n    }\n    int right = bisect_left(nums, target + 1) - 1;\n    return {left, right};\n  }\n};\n\nint main()\n{\n  vector&lt;int&gt; nums = {5, 7, 7, 8, 8, 10};\n  int target = 8;\n  Solution s;\n  vector&lt;int&gt; res = s.searchRange(nums, target);\n  cout &lt;&lt; res[0] &lt;&lt; \", \" &lt;&lt; res[1] &lt;&lt; endl;\n  return 0;\n}\n</code></pre>"},{"location":"content/leetpattern/binary_search/#367-valid-perfect-square","title":"367. Valid Perfect Square","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, binary search</p> </li> <li>Determine if a positive integer is a perfect square without using any built-in library function.</li> </ul> 367. Valid Perfect Square - Python Solution<pre><code># Binary Search\ndef isPerfectSquare(num: int) -&gt; bool:\n    if num &lt; 2:\n        return True\n\n    left, right = 0, num // 2\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if mid * mid == num:\n            return True\n        elif mid * mid &lt; num:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\n\nnum = 16\nprint(isPerfectSquare(num))  # True\n</code></pre>"},{"location":"content/leetpattern/binary_search/#875-koko-eating-bananas","title":"875. Koko Eating Bananas","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> <li>Koko loves to eat bananas. She wants to eat all the bananas within <code>H</code> hours. Each pile has a number of bananas. The <code>i-th</code> pile has <code>piles[i]</code> bananas. Return the minimum integer <code>K</code> such that she can eat all the bananas within <code>H</code> hours.</li> </ul> 875. Koko Eating Bananas - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef minEatingSpeed(piles: List[int], h: int) -&gt; int:\n    def canEat(piles, k, h):\n        hours = 0\n        for pile in piles:\n            hours += (pile + k - 1) // k\n        return hours &lt;= h\n\n    left, right = 1, max(piles)\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if canEat(piles, mid, h):\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return left\n\n\npiles = [3, 6, 7, 11]\nh = 8\nprint(minEatingSpeed(piles, h))  # 4\n</code></pre>"},{"location":"content/leetpattern/binary_search/#1011-capacity-to-ship-packages-within-d-days","title":"1011. Capacity To Ship Packages Within D Days","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> <li>A conveyor belt has packages that must be shipped from one port to another within <code>D</code> days. The <code>i-th</code> package has a weight of <code>weights[i]</code>. Each day, we load the ship with packages on the conveyor belt. The ship will be loaded with packages up to its capacity. The ship will not be loaded beyond its capacity. Return the least weight capacity of the ship.</li> </ul> 1011. Capacity To Ship Packages Within D Days - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef shipWithinDays(weights: List[int], days: int) -&gt; int:\n\n    def canShip(weights, D, capacity):\n        days = 1\n        current_weight = 0\n\n        for weight in weights:\n            if current_weight + weight &gt; capacity:\n                days += 1\n                current_weight = 0\n            current_weight += weight\n\n        return days &lt;= D\n\n    left, right = max(weights), sum(weights)\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if canShip(weights, days, mid):\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return left\n\n\nweights = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\ndays = 5\nprint(shipWithinDays(weights, days))  # 15\n</code></pre>"},{"location":"content/leetpattern/binary_search/#378-kth-smallest-element-in-a-sorted-matrix","title":"378. Kth Smallest Element in a Sorted Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sorting, heap priority queue, matrix</p> </li> <li>Given an <code>n x n</code> matrix where each of the rows and columns are sorted in ascending order, return the <code>k-th</code> smallest element in the matrix.</li> </ul> 378. Kth Smallest Element in a Sorted Matrix - Python Solution<pre><code>from heapq import heapify, heappop, heappush\nfrom typing import List\n\n\n# Heap - Merge K Sorted\ndef kthSmallestHeap(matrix: List[List[int]], k: int) -&gt; int:\n    n = len(matrix)\n    heap = [(matrix[i][0], i, 0) for i in range(n)]\n    heapify(heap)\n\n    for _ in range(k - 1):\n        _, row, col = heappop(heap)\n\n        if col + 1 &lt; n:\n            heappush(heap, (matrix[row][col + 1], row, col + 1))\n\n    return heappop(heap)[0]\n\n\n# Binary Search\ndef kthSmallestBinarySearch(matrix: List[List[int]], k: int) -&gt; int:\n    n = len(matrix)\n\n    def check(mid):\n        i, j = n - 1, 0\n        num = 0\n\n        while i &gt;= 0 and j &lt; n:\n            if matrix[i][j] &lt;= mid:\n                num += i + 1\n                j += 1\n            else:\n                i -= 1\n\n        return num &gt;= k\n\n    left, right = matrix[0][0], matrix[-1][-1]\n\n    while left &lt; right:\n        mid = (left + right) // 2\n        if check(mid):\n            right = mid\n        else:\n            left = mid + 1\n\n    return left\n\n\nmatrix = [[1, 5, 9], [10, 11, 13], [12, 13, 15]]\nk = 8\n\nprint(kthSmallestHeap(matrix, k))  # 13\nprint(kthSmallestBinarySearch(matrix, k))  # 13\n</code></pre>"},{"location":"content/leetpattern/bit_manipulation/","title":"Bit Manipulation","text":""},{"location":"content/leetpattern/bit_manipulation/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2595. Number of Even and Odd Bits (Easy)</li> </ul>"},{"location":"content/leetpattern/bit_manipulation/#2595-number-of-even-and-odd-bits","title":"2595. Number of Even and Odd Bits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: bit manipulation</p> </li> <li>Topic: Bit Manipulation</li> <li>Difficulty: Easy</li> </ul> <p>You are given a positive integer n. Let even denote the number of even indices in the binary representation of n with value 1. Let odd denote the number of odd indices in the binary representation of n with value 1. Note that bits are indexed from right to left in the binary representation of a number. Return the array [even, odd].</p>"},{"location":"content/leetpattern/boyer_moore/","title":"Boyer Moore","text":""},{"location":"content/leetpattern/boyer_moore/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 169. Majority Element (Easy)</li> <li> 229. Majority Element II (Medium)</li> <li> 287. Find the Duplicate Number (Medium)</li> <li> 1150. Check If a Number Is Majority Element in a Sorted Array (Easy) \ud83d\udc51</li> <li> 1157. Online Majority Element In Subarray (Hard)</li> <li> 495. Teemo Attacking (Easy)</li> </ul>"},{"location":"content/leetpattern/boyer_moore/#169-majority-element","title":"169. Majority Element","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, divide and conquer, sorting, counting</p> </li> <li>Return the majority element in an array. The majority element is the element that appears more than <code>n // 2</code> times.</li> </ul> <code>num</code> <code>count</code> <code>res</code> 2 1 2 2 2 2 1 1 2 1 0 2 1 1 1 2 0 1 2 1 2 169. Majority Element - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash Map\ndef majorityElementHashMap(nums: List[int]) -&gt; int:\n    n = len(nums)\n    freq = defaultdict(int)\n\n    for num in nums:\n        freq[num] += 1\n        if freq[num] &gt; n // 2:\n            return num\n\n\n# Array - Boyer-Moore Voting Algorithm\ndef majorityElementArray(nums: List[int]) -&gt; int:\n    res = None\n    count = 0\n\n    for num in nums:\n        if count == 0:\n            res = num\n        count += 1 if num == res else -1\n\n    return res\n\n\n# | Algorithm | Time Complexity | Space Complexity |\n# |-----------|-----------------|------------------|\n# | HashMap   | O(N)            | O(N)             |\n# | Array     | O(N)            | O(1)             |\n# |-----------|-----------------|------------------|\n\n\nnums = [2, 2, 1, 1, 1, 2, 2]\nprint(majorityElementArray(nums))  # 2\nprint(majorityElementHashMap(nums))  # 2\n</code></pre>"},{"location":"content/leetpattern/boyer_moore/#229-majority-element-ii","title":"229. Majority Element II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, sorting, counting 229. Majority Element II - Python Solution<pre><code>from collections import Counter\nfrom typing import List\n\n\n# Hash Map\ndef majorityElementHash(nums: List[int]) -&gt; List[int]:\n    counts = Counter(nums)\n    target = len(nums) // 3\n    res = []\n\n    for num in nums:\n        if counts[num] &gt; target and num not in res:\n            res.append(num)\n\n    return res\n\n\n# Boyer-Moore\ndef majorityElementMoore(nums: List[int]) -&gt; List[int]:\n    if not nums:\n        return []\n\n    cdt1, cnt1 = None, 0\n    cdt2, cnt2 = None, 0\n\n    for num in nums:\n        if num == cdt1:\n            cnt1 += 1\n        elif num == cdt2:\n            cnt2 += 1\n        elif cnt1 == 0:\n            cdt1, cnt1 = num, 1\n        elif cnt2 == 0:\n            cdt2, cnt2 = num, 1\n        else:\n            cnt1 -= 1\n            cnt2 -= 1\n\n    return [n for n in (cdt1, cdt2) if nums.count(n) &gt; len(nums) // 3]\n\n\nnums = [3, 2, 3]\nprint(majorityElementHash(nums))  # [3]\nprint(majorityElementMoore(nums))  # [3]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/boyer_moore/#287-find-the-duplicate-number","title":"287. Find the Duplicate Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, bit manipulation</p> </li> <li>Find the duplicate number in an array containing <code>n + 1</code> integers where each integer is between <code>1</code> and <code>n</code> inclusive.</li> <li>Floyd's Tortoise and Hare (Cycle Detection)<ul> <li> <ol> <li>Linked List Cycle</li> </ol> </li> <li> <ol> <li>Linked List Cycle II</li> </ol> </li> </ul> </li> <li>Time Complexity: O(n)</li> <li>Space Complexity: O(1)</li> </ul> <p>Example: <code>nums = [1, 3, 4, 2, 2]</code></p> 0 1 2 3 4 1 3 4 2 2 <pre><code>graph LR\n0((0)) --&gt; 1((1))\n1 --&gt; 3((3))\n2((2))--&gt; 4((4))\n3 --&gt; 2\n4 --&gt; 2</code></pre> 287. Find the Duplicate Number - Python Solution<pre><code>from typing import List\n\n\n# Floyd Cycle Detection Algorithm\ndef findDuplicate(nums: List[int]) -&gt; int:\n    fast, slow = nums[0], nums[0]\n\n    while True:\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n        if slow == fast:\n            break\n\n    slow = nums[0]\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[fast]\n\n    return slow\n\n\nnums = [1, 3, 4, 2, 2]\nprint(findDuplicate(nums))  # 2\n</code></pre>"},{"location":"content/leetpattern/boyer_moore/#1150-check-if-a-number-is-majority-element-in-a-sorted-array","title":"1150. Check If a Number Is Majority Element in a Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"content/leetpattern/boyer_moore/#1157-online-majority-element-in-subarray","title":"1157. Online Majority Element In Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, design, binary indexed tree, segment tree</p> </li> </ul>"},{"location":"content/leetpattern/boyer_moore/#495-teemo-attacking","title":"495. Teemo Attacking","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, simulation</p> </li> </ul>"},{"location":"content/leetpattern/bst/","title":"BST","text":""},{"location":"content/leetpattern/bst/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 700. Search in a Binary Search Tree (Easy)</li> <li> 98. Validate Binary Search Tree (Medium)</li> <li> 530. Minimum Absolute Difference in BST (Easy)</li> <li> 501. Find Mode in Binary Search Tree (Easy)</li> <li> 235. Lowest Common Ancestor of a Binary Search Tree (Medium)</li> <li> 701. Insert into a Binary Search Tree (Medium)</li> <li> 450. Delete Node in a BST (Medium)</li> <li> 669. Trim a Binary Search Tree (Medium)</li> <li> 108. Convert Sorted Array to Binary Search Tree (Easy)</li> <li> 109. Convert Sorted List to Binary Search Tree (Medium)</li> <li> 538. Convert BST to Greater Tree (Medium)</li> <li> 230. Kth Smallest Element in a BST (Medium)</li> <li> 173. Binary Search Tree Iterator (Medium)</li> <li> 1586. Binary Search Tree Iterator II (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/leetpattern/bst/#700-search-in-a-binary-search-tree","title":"700. Search in a Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, binary search tree, binary tree</p> </li> </ul>"},{"location":"content/leetpattern/bst/#binary-search-tree","title":"Binary Search Tree","text":"<ol> <li>Binary Tree</li> <li>Left subtree of a node contains only nodes with keys less than the node's key</li> <li>Right subtree of a node contains only nodes with keys greater than the node's key</li> <li>The left and right subtree each must also be a binary search tree</li> <li>There must be no duplicate nodes</li> <li>Inorder traversal of a BST gives a sorted list of keys</li> </ol> <pre><code>graph TD\n4((4)) --- 2((2))\n4 --- 7((7))\n2 --- 1((1))\n2 --- 3((3))</code></pre> 700. Search in a Binary Search Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# 1. Recursive\ndef searchBSTRecursive(\n    root: Optional[TreeNode], val: int\n) -&gt; Optional[TreeNode]:\n    if not root:\n        return None\n\n    if root.val &gt; val:\n        return searchBSTRecursive(root.left, val)\n\n    elif root.val &lt; val:\n        return searchBSTRecursive(root.right, val)\n\n    else:\n        return root\n\n\n# 2. Iterative\ndef searchBSTIterative(\n    root: Optional[TreeNode], val: int\n) -&gt; Optional[TreeNode]:\n    while root:\n        if root.val &gt; val:\n            root = root.left\n        elif root.val &lt; val:\n            root = root.right\n        else:\n            return root\n    return None\n\n\nroot = [4, 2, 7, 1, 3]\nval = 2\nroot = build(root)\nprint(root)\n#     __4\n#    /   \\\n#   2     7\n#  / \\\n# 1   3\nprint(searchBSTRecursive(root, val))\n#   2\n#  / \\\n# 1   3\nprint(searchBSTIterative(root, val))\n#   2\n#  / \\\n# 1   3\n</code></pre>"},{"location":"content/leetpattern/bst/#98-validate-binary-search-tree","title":"98. Validate Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree 98. Validate Binary Search Tree - Python Solution<pre><code>from itertools import pairwise\nfrom math import inf\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef isValidBST1(root: Optional[TreeNode]) -&gt; bool:\n    inorder = []  # inorder traversal\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    for a, b in pairwise(inorder):\n        if a &gt;= b:\n            return False\n\n    return True\n\n\ndef isValidBST2(root: Optional[TreeNode]) -&gt; bool:\n    if not root:\n        return True\n    pre = -inf\n\n    def dfs(node):\n        if not node:\n            return True\n        if not dfs(node.left):\n            return False\n\n        nonlocal pre\n        if node.val &lt;= pre:\n            return False\n        pre = node.val\n\n        return dfs(node.right)\n\n    return dfs(root)\n\n\nif __name__ == \"__main__\":\n    root = [5, 1, 4, None, None, 3, 6]\n    root = build(root)\n    print(root)\n    #   5__\n    #  /   \\\n    # 1     4\n    #      / \\\n    #     3   6\n    assert not isValidBST1(root)  # [1, 5, 3, 4, 6]\n    assert not isValidBST2(root)  # [1, 5, 3, 4, 6]\n</code></pre></p> </li> </ul> 98. Validate Binary Search Tree - C++ Solution<pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   private:\n    vector&lt;int&gt; inorder;\n    bool check(vector&lt;int&gt; inorder) {\n        int n = inorder.size();\n        if (n &lt;= 1) return true;\n        for (int i = 1; i &lt; n; i++) {\n            if (inorder[i] &lt;= inorder[i - 1]) return false;\n        }\n        return true;\n    }\n\n   public:\n    bool isValidBST(TreeNode *root) {\n        auto dfs = [&amp;](auto &amp;&amp;self, TreeNode *node) -&gt; void {\n            if (!node) return;\n\n            self(self, node-&gt;left);\n            inorder.push_back(node-&gt;val);\n            self(self, node-&gt;right);\n        };\n\n        dfs(dfs, root);\n\n        return check(inorder);\n    }\n};\n\nint main() {\n    Solution s;\n    TreeNode *root = new TreeNode(2);\n    root-&gt;left = new TreeNode(1);\n    root-&gt;right = new TreeNode(3);\n    assert(s.isValidBST(root) == true);\n\n    root = new TreeNode(5);\n    root-&gt;left = new TreeNode(1);\n    root-&gt;right = new TreeNode(4);\n    root-&gt;right-&gt;left = new TreeNode(3);\n    root-&gt;right-&gt;right = new TreeNode(6);\n    assert(s.isValidBST(root) == false);\n\n    root = new TreeNode(5);\n    root-&gt;left = new TreeNode(4);\n    root-&gt;right = new TreeNode(6);\n    root-&gt;right-&gt;left = new TreeNode(3);\n    root-&gt;right-&gt;right = new TreeNode(7);\n    assert(s.isValidBST(root) == false);\n\n    return 0;\n}\n</code></pre>"},{"location":"content/leetpattern/bst/#530-minimum-absolute-difference-in-bst","title":"530. Minimum Absolute Difference in BST","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary search tree, binary tree 530. Minimum Absolute Difference in BST - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef getMinimumDifference(root: Optional[TreeNode]) -&gt; int:\n    res = float(\"inf\")\n    pre = float(\"-inf\")\n\n    def dfs(node):  # inorder traversal\n        if not node:\n            return\n\n        dfs(node.left)\n\n        nonlocal res, pre\n        res = min(res, node.val - pre)\n        pre = node.val\n\n        if res == 1:  # the minimum possible difference\n            return\n\n        dfs(node.right)\n\n    dfs(root)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    root = [4, 2, 6, 1, 3]\n    root = build(root)\n    print(root)\n    #     __4\n    #    /   \\\n    #   2     6\n    #  / \\\n    # 1   3\n    assert getMinimumDifference(root) == 1\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/bst/#501-find-mode-in-binary-search-tree","title":"501. Find Mode in Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree 501. Find Mode in Binary Search Tree - Python Solution<pre><code>from typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef findMode(root: Optional[TreeNode]) -&gt; List[int]:\n    hashmap = dict()\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        if node.val not in hashmap:\n            hashmap[node.val] = 1\n        else:\n            hashmap[node.val] += 1\n        dfs(node.right)\n\n    dfs(root)\n    max_counts = max(hashmap.values())\n    result = []\n\n    for key, value in hashmap.items():\n        if value == max_counts:\n            result.append(key)\n\n    return result\n\n\nroot = [1, None, 2, None, None, 2]\nroot = build(root)\nprint(root)\n# 1__\n#    \\\n#     2\n#    /\n#   2\nprint(findMode(root))  # [2]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/bst/#235-lowest-common-ancestor-of-a-binary-search-tree","title":"235. Lowest Common Ancestor of a Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree 235. Lowest Common Ancestor of a Binary Search Tree - Python Solution<pre><code>from binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef lowestCommonAncestor(\n    root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n) -&gt; \"TreeNode\":\n    while root:\n        if root.val &gt; p.val and root.val &gt; q.val:\n            root = root.left\n        elif root.val &lt; p.val and root.val &lt; q.val:\n            root = root.right\n        else:\n            return root\n\n\nroot = [6, 2, 8, 0, 4, 7, 9, None, None, 3, 5]\nroot = build(root)\np = root.left\nq = root.right\nprint(root)\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\nprint(lowestCommonAncestor(root, p, q))\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/bst/#701-insert-into-a-binary-search-tree","title":"701. Insert into a Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, binary search tree, binary tree 701. Insert into a Binary Search Tree - Python Solution<pre><code>from typing import Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef insertIntoBST(root: Optional[TreeNode], val: int) -&gt; Optional[TreeNode]:\n    if root is None:\n        return TreeNode(val)\n\n    if root.val &gt; val:\n        root.left = insertIntoBST(root.left, val)\n    if root.val &lt; val:\n        root.right = insertIntoBST(root.right, val)\n\n    return root\n\n\nroot = TreeNode(4)\nroot.left = TreeNode(2)\nroot.right = TreeNode(6)\nroot.left.left = TreeNode(1)\nroot.left.right = TreeNode(3)\n#     __4\n#    /   \\\n#   2     6\n#  / \\\n# 1   3\n\ninsertIntoBST(root, 5)\n#     __4\n#    /   \\\n#   2     6\n#  / \\   /\n# 1   3 5\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/bst/#450-delete-node-in-a-bst","title":"450. Delete Node in a BST","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, binary search tree, binary tree 450. Delete Node in a BST - Python Solution<pre><code>from typing import Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef deleteNode(root: Optional[TreeNode], key: int) -&gt; Optional[TreeNode]:\n    if root is None:\n        return root\n\n    if root.val == key:\n        if root.left is None and root.right is None:\n            return None\n        elif root.left is None:\n            return root.right\n        elif root.right is None:\n            return root.left\n        else:\n            cur = root.right\n            while cur.left is not None:\n                cur = cur.left\n            cur.left = root.left\n            return root.right\n\n    if root.val &gt; key:\n        root.left = deleteNode(root.left, key)\n    if root.val &lt; key:\n        root.right = deleteNode(root.right, key)\n\n    return root\n\n\nroot = TreeNode(5)\nroot.left = TreeNode(3)\nroot.right = TreeNode(6)\nroot.left.left = TreeNode(2)\nroot.left.right = TreeNode(4)\nroot.right.right = TreeNode(7)\n#     __5\n#    /   \\\n#   3     6\n#  / \\     \\\n# 2   4     7\n\ndeleteNode(root, 3)\n#     __5\n#    /   \\\n#   4     6\n#  /       \\\n# 2         7\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/bst/#669-trim-a-binary-search-tree","title":"669. Trim a Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree 669. Trim a Binary Search Tree - Python Solution<pre><code>from typing import Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef trimBST(\n    root: Optional[TreeNode], low: int, high: int\n) -&gt; Optional[TreeNode]:\n    if root is None:\n        return None\n\n    if root.val &lt; low:\n        return trimBST(root.right, low, high)\n    if root.val &gt; high:\n        return trimBST(root.left, low, high)\n\n    root.left = trimBST(root.left, low, high)\n    root.right = trimBST(root.right, low, high)\n\n    return root\n\n\nroot = TreeNode(3)\nroot.left = TreeNode(0)\nroot.right = TreeNode(4)\nroot.left.right = TreeNode(2)\nroot.left.right.left = TreeNode(1)\n#     __3\n#    /   \\\n#   0     4\n#    \\\n#     2\n#    /\n#   1\n\ntrimBST(root, 1, 3)\n#     __3\n#    /\n#   2\n#  /\n# 1\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/bst/#108-convert-sorted-array-to-binary-search-tree","title":"108. Convert Sorted Array to Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, divide and conquer, tree, binary search tree, binary tree 108. Convert Sorted Array to Binary Search Tree - Python Solution<pre><code>from typing import List, Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef sortedArrayToBST(nums: List[int]) -&gt; Optional[TreeNode]:\n    if len(nums) == 0:\n        return None\n\n    mid = len(nums) // 2\n    root = TreeNode(nums[mid])\n\n    root.left = sortedArrayToBST(nums[:mid])\n    root.right = sortedArrayToBST(nums[mid + 1 :])\n\n    return root\n\n\nnums = [-10, -3, 0, 5, 9]\nroot = sortedArrayToBST(nums)\n#      0\n#     / \\\n#   -3   9\n#   /   /\n# -10  5\n</code></pre></p> </li> </ul> 108. Convert Sorted Array to Binary Search Tree - C++ Solution<pre><code>#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   public:\n    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) {\n        if (nums.size() == 0) return nullptr;\n\n        int mid = nums.size() / 2;\n        TreeNode* root = new TreeNode(nums[mid]);\n\n        vector&lt;int&gt; left(nums.begin(), nums.begin() + mid);\n        vector&lt;int&gt; right(nums.begin() + mid + 1, nums.end());\n\n        root-&gt;left = sortedArrayToBST(left);\n        root-&gt;right = sortedArrayToBST(right);\n\n        return root;\n    }\n};\n\nint main() { return 0; }\n</code></pre>"},{"location":"content/leetpattern/bst/#109-convert-sorted-list-to-binary-search-tree","title":"109. Convert Sorted List to Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, divide and conquer, tree, binary search tree, binary tree </p> </li> </ul> 109. Convert Sorted List to Binary Search Tree - Python Solution<pre><code>from typing import Optional\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef sortedListToBST(head: Optional[ListNode]) -&gt; Optional[TreeNode]:\n    if not head:\n        return None\n\n    def find_mid(head: ListNode) -&gt; ListNode:\n        prev = None\n        slow = head\n        fast = head\n\n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n\n        if prev:\n            prev.next = None\n\n        return slow\n\n    mid = find_mid(head)\n\n    node = TreeNode(mid.val)\n\n    if head == mid:\n        return node\n\n    node.left = sortedListToBST(head)\n    node.right = sortedListToBST(mid.next)\n\n    return node\n\n\nhead = ListNode(-10)\nhead.next = ListNode(-3)\nhead.next.next = ListNode(0)\nhead.next.next.next = ListNode(5)\nhead.next.next.next.next = ListNode(9)\n\nroot = sortedListToBST(head)\nassert root.val == 0\nassert root.left.val == -3\nassert root.left.left.val == -10\nassert root.right.val == 9\nassert root.right.left.val == 5\nprint(\"All passed\")\n\n#      0\n#     / \\\n#   -3   9\n#   /   /\n# -10  5\n</code></pre>"},{"location":"content/leetpattern/bst/#538-convert-bst-to-greater-tree","title":"538. Convert BST to Greater Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree </p> </li> </ul> 538. Convert BST to Greater Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef convertBST(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    prev = 0\n\n    def dfs(node):\n        if not node:\n            return None\n        nonlocal prev\n\n        dfs(node.right)\n\n        node.val += prev\n        prev = node.val\n\n        dfs(node.left)\n\n    dfs(root)\n\n    return root\n\n\nroot = [4, 1, 6, 0, 2, 5, 7, None, None, None, 3, None, None, None, 8]\nroot = build(root)\nprint(root)\n#     ____4__\n#    /       \\\n#   1         6\n#  / \\       / \\\n# 0   2     5   7\n#      \\         \\\n#       3         8\ngreater_tree = convertBST(root)\nprint(greater_tree)\n#      _______30___\n#     /            \\\n#   _36            _21\n#  /   \\          /   \\\n# 36    35       26    15\n#         \\              \\\n#          33             8\n</code></pre>"},{"location":"content/leetpattern/bst/#230-kth-smallest-element-in-a-bst","title":"230. Kth Smallest Element in a BST","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree 230. Kth Smallest Element in a BST - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef kthSmallestRecursive(root: Optional[TreeNode], k: int) -&gt; int:\n    inorder = []\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n    return inorder[k - 1]\n\n\n# Iteratve\ndef kthSmallestIteratve(root: Optional[TreeNode], k: int) -&gt; int:\n    stack = []\n    while True:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        k -= 1\n        if not k:\n            return root.val\n        root = root.right\n\n\nif __name__ == \"__main__\":\n    root = build([3, 1, 4, None, 2])\n    k = 1\n    assert kthSmallestRecursive(root, k) == 1\n    assert kthSmallestIteratve(root, k) == 1\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/bst/#173-binary-search-tree-iterator","title":"173. Binary Search Tree Iterator","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: stack, tree, design, binary search tree, binary tree, iterator 173. Binary Search Tree Iterator - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BST\nclass BSTIterator:\n\n    def __init__(self, root: Optional[TreeNode]):\n        self.stack = []\n        self._leftmost_inorder(root)\n\n    def _leftmost_inorder(self, root):\n        while root:\n            self.stack.append(root)\n            root = root.left\n\n    def next(self) -&gt; int:\n        topmost_node = self.stack.pop()\n\n        if topmost_node.right:\n            self._leftmost_inorder(topmost_node.right)\n\n        return topmost_node.val\n\n    def hasNext(self) -&gt; bool:\n        return len(self.stack) &gt; 0\n\n\nroot = build([7, 3, 15, None, None, 9, 20])\nprint(root)\n#   7__\n#  /   \\\n# 3     15\n#      /  \\\n#     9    20\nobj = BSTIterator(root)\nprint(obj.next())  # 3\nprint(obj.next())  # 7\nprint(obj.hasNext())  # True\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/bst/#1586-binary-search-tree-iterator-ii","title":"1586. Binary Search Tree Iterator II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: stack, tree, design, binary search tree, binary tree, iterator 1586. Binary Search Tree Iterator II - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BST\nclass BSTIterator:\n    def __init__(self, root: Optional[TreeNode]):\n        self.nodes = self._inorder(root)\n        self.index = -1\n        self.size = len(self.nodes)\n\n    def _inorder(self, node):\n        if not node:\n            return []\n        return (\n            self._inorder(node.left) + [node.val] + self._inorder(node.right)\n        )\n\n    def hasNext(self) -&gt; bool:\n        return self.index &lt; self.size - 1\n\n    def next(self) -&gt; int:\n        self.index += 1\n        return self.nodes[min(self.index, self.size - 1)]\n\n    def hasPrev(self) -&gt; bool:\n        return self.index &gt; 0\n\n    def prev(self) -&gt; int:\n        self.index -= 1\n        return self.nodes[max(self.index, 0)]\n\n\nroot = build([7, 3, 15, None, None, 9, 20])\nprint(root)\n#   7__\n#  /   \\\n# 3     15\n#      /  \\\n#     9    20\nobj = BSTIterator(root)\nprint(obj.next())  # 3\nprint(obj.next())  # 7\nprint(obj.hasNext())  # True\nprint(obj.prev())  # 3\nprint(obj.prev())  # None\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/design/","title":"Design","text":""},{"location":"content/leetpattern/design/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 146. LRU Cache (Medium)</li> <li> 355. Design Twitter (Medium)</li> <li> 588. Design In-Memory File System (Hard) \ud83d\udc51</li> <li> 460. LFU Cache (Hard)</li> <li> 1166. Design File System (Medium) \ud83d\udc51</li> <li> 380. Insert Delete GetRandom O(1) (Medium)</li> <li> 362. Design Hit Counter (Medium) \ud83d\udc51</li> <li> 297. Serialize and Deserialize Binary Tree (Hard)</li> <li> 622. Design Circular Queue (Medium)</li> <li> 353. Design Snake Game (Medium) \ud83d\udc51</li> <li> 1244. Design A Leaderboard (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/leetpattern/design/#146-lru-cache","title":"146. LRU Cache","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, linked list, design, doubly linked list</p> </li> <li>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.</li> <li>lru</li> <li></li> </ul> Data structure Description Doubly Linked List To store the key-value pairs. Hash Map To store the key-node pairs. 146. LRU Cache - Python Solution<pre><code>from collections import OrderedDict\n\n\n# Doubly Linked List\nclass Node:\n    def __init__(self, key=0, val=0):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.cache = {}\n        self.head = Node()\n        self.tail = Node()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def add_to_last(self, node):\n        self.tail.prev.next = node\n        node.prev = self.tail.prev\n        node.next = self.tail\n        self.tail.prev = node\n\n    def move_to_last(self, node):\n        self.remove(node)\n        self.add_to_last(node)\n\n    def get(self, key: int) -&gt; int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self.move_to_last(node)\n        return node.val\n\n    def put(self, key: int, value: int) -&gt; None:\n        if key in self.cache:\n            node = self.cache[key]\n            node.val = value\n            self.move_to_last(node)\n            return None\n\n        if len(self.cache) == self.cap:\n            del self.cache[self.head.next.key]\n            self.remove(self.head.next)\n\n        node = Node(key=key, val=value)\n        self.cache[key] = node\n        self.add_to_last(node)\n\n\n# OrderedDict\nclass LRUCacheOrderedDict:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.cap = capacity\n\n    def get(self, key: int):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key, last=True)\n        return self.cache[key]\n\n    def put(self, key: int, value: int):\n        if key in self.cache:\n            self.cache.move_to_end(key, last=True)\n        elif len(self.cache) &gt;= self.cap:\n            self.cache.popitem(last=False)\n\n        self.cache[key] = value\n\n\ncache = LRUCache(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\n\ncache = LRUCacheOrderedDict(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\nprint(\"LRU Cache passed\")\nprint(\"LRU Cache Ordered Dict passed\")\n</code></pre> 146. LRU Cache - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nclass Node {\n   public:\n    int key;\n    int val;\n    Node *prev;\n    Node *next;\n\n    Node(int k = 0, int v = 0) : key(k), val(v), prev(nullptr), next(nullptr) {}\n};\n\nclass LRUCache {\n   private:\n    int cap;\n    unordered_map&lt;int, Node *&gt; cache;\n    Node *head;\n    Node *tail;\n\n    void remove(Node *node) {\n        node-&gt;prev-&gt;next = node-&gt;next;\n        node-&gt;next-&gt;prev = node-&gt;prev;\n    }\n\n    void insert_to_last(Node *node) {\n        tail-&gt;prev-&gt;next = node;\n        node-&gt;prev = tail-&gt;prev;\n        tail-&gt;prev = node;\n        node-&gt;next = tail;\n    }\n\n    void move_to_last(Node *node) {\n        remove(node);\n        insert_to_last(node);\n    }\n\n   public:\n    LRUCache(int capacity) {\n        this-&gt;cap = capacity;\n        head = new Node();\n        tail = new Node();\n        head-&gt;next = tail;\n        tail-&gt;prev = head;\n    }\n\n    int get(int key) {\n        if (cache.find(key) != cache.end()) {\n            Node *node = cache[key];\n            move_to_last(node);\n            return node-&gt;val;\n        }\n        return -1;\n    }\n\n    void put(int key, int value) {\n        if (cache.find(key) != cache.end()) {\n            Node *node = cache[key];\n            node-&gt;val = value;\n            move_to_last(node);\n        } else {\n            Node *newNode = new Node(key, value);\n            cache[key] = newNode;\n            insert_to_last(newNode);\n\n            if ((int)cache.size() &gt; cap) {\n                Node *removed = head-&gt;next;\n                remove(removed);\n                cache.erase(removed-&gt;key);\n                delete removed;\n            }\n        }\n    }\n};\n\nint main() {\n    LRUCache lru(2);\n    lru.put(1, 1);\n    lru.put(2, 2);\n    cout &lt;&lt; lru.get(1) &lt;&lt; endl;  // 1\n    lru.put(3, 3);\n    cout &lt;&lt; lru.get(2) &lt;&lt; endl;  // -1\n    lru.put(4, 4);\n    cout &lt;&lt; lru.get(1) &lt;&lt; endl;  // -1\n    cout &lt;&lt; lru.get(3) &lt;&lt; endl;  // 3\n    cout &lt;&lt; lru.get(4) &lt;&lt; endl;  // 4\n    return 0;\n}\n</code></pre>"},{"location":"content/leetpattern/design/#355-design-twitter","title":"355. Design Twitter","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, linked list, design, heap priority queue</p> </li> <li>Similar question: 23. Merge K Sorted Lists (Hard)</li> </ul> 355. Design Twitter - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Design\nclass Twitter:\n\n    def __init__(self):\n        self.tweets = defaultdict(list)\n        self.followees = defaultdict(set)\n        self.time = 0\n\n    def postTweet(self, userId: int, tweetId: int) -&gt; None:\n        self.tweets[userId].append((self.time, tweetId))\n        self.time += 1\n\n    def getNewsFeed(self, userId: int) -&gt; List[int]:\n        news_feed = []\n        news_feed.extend(self.tweets[userId])\n        for followee in self.followees[userId]:\n            news_feed.extend(self.tweets[followee])\n\n        return [tweet for _, tweet in heapq.nlargest(10, news_feed)]\n\n    def follow(self, followerId: int, followeeId: int) -&gt; None:\n        if followerId != followeeId:\n            self.followees[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -&gt; None:\n        if followerId != followeeId:\n            self.followees[followerId].discard(followeeId)\n\n\ntwitter = Twitter()\nprint(twitter.postTweet(1, 5))  # None\nprint(twitter.getNewsFeed(1))  # [5]\nprint(twitter.follow(1, 2))  # None\nprint(twitter.postTweet(2, 6))  # None\nprint(twitter.getNewsFeed(1))  # [6, 5]\nprint(twitter.unfollow(1, 2))  # None\nprint(twitter.getNewsFeed(1))  # [5]\n</code></pre>"},{"location":"content/leetpattern/design/#588-design-in-memory-file-system","title":"588. Design In-Memory File System","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, design, trie, sorting 588. Design In-Memory File System - Python Solution<pre><code>from collections import defaultdict\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children = defaultdict(TrieNode)\n        self.content = \"\"\n\n\n# Trie\nclass FileSystem:\n\n    def __init__(self):\n        self.root = TrieNode()\n\n    def ls(self, path: str) -&gt; list:\n        cur = self.root\n\n        if path != \"/\":\n            paths = path.split(\"/\")[1:]\n            for p in paths:\n                cur = cur.children[p]\n        if cur.content:\n            return [path.split(\"/\")[-1]]\n\n        return sorted(cur.children.keys())\n\n    def mkdir(self, path: str) -&gt; None:\n        cur = self.root\n        paths = path.split(\"/\")[1:]\n        for p in paths:\n            cur = cur.children[p]\n\n    def addContentToFile(self, filePath: str, content: str) -&gt; None:\n        cur = self.root\n        paths = filePath.split(\"/\")[1:]\n        for p in paths:\n            cur = cur.children[p]\n        cur.content += content\n\n    def readContentFromFile(self, filePath: str) -&gt; str:\n        cur = self.root\n        paths = filePath.split(\"/\")[1:]\n        for p in paths:\n            cur = cur.children[p]\n        return cur.content\n\n\nobj = FileSystem()\nobj.mkdir(\"/a/b/c\")\nobj.addContentToFile(\"/a/b/c/d\", \"hello\")\nprint(obj.ls(\"/\"))  # [\"a\"]\nprint(obj.readContentFromFile(\"/a/b/c/d\"))  # \"hello\"\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/design/#460-lfu-cache","title":"460. LFU Cache","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, linked list, design, doubly linked list 460. LFU Cache - Python Solution<pre><code>from collections import OrderedDict, defaultdict\n\n\nclass LFUCache:\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        # key -&gt; [val, freq]\n        self.key_to_val_freq = {}\n        # freq -&gt; OrderedDict of keys\n        self.freq_to_keys = defaultdict(OrderedDict)\n        self.min_freq = 0\n\n    def remove_least_frequent(self):\n\n        lfu_key, _ = self.freq_to_keys[self.min_freq].popitem(last=False)\n        del self.key_to_val_freq[lfu_key]\n\n        # If the frequency list is empty after removal, delete it\n        if not self.freq_to_keys[self.min_freq]:\n            del self.freq_to_keys[self.min_freq]\n\n    def update_freq(self, key):\n        \"\"\"Updates the frequency of an existing key.\"\"\"\n        value, freq = self.key_to_val_freq[key]\n\n        # Remove key from current frequency group\n        del self.freq_to_keys[freq][key]\n        if not self.freq_to_keys[freq]:\n            del self.freq_to_keys[freq]\n            if self.min_freq == freq:\n                self.min_freq += 1\n\n        # Update key frequency\n        new_freq = freq + 1\n        self.key_to_val_freq[key] = [value, new_freq]\n        self.freq_to_keys[new_freq][key] = None\n\n    def add_new_key(self, key, value):\n        if len(self.key_to_val_freq) &gt;= self.cap:\n            self.remove_least_frequent()\n\n        # Insert the new key with frequency 1\n        self.key_to_val_freq[key] = [value, 1]\n        self.freq_to_keys[1][key] = None\n        self.min_freq = 1\n\n    def get(self, key: int) -&gt; int:\n        if key not in self.key_to_val_freq:\n            return -1\n        self.update_freq(key)\n        return self.key_to_val_freq[key][0]\n\n    def put(self, key: int, value: int) -&gt; None:\n        if self.cap == 0:\n            return\n\n        if key in self.key_to_val_freq:\n            self.key_to_val_freq[key][0] = value\n            self.update_freq(key)\n        else:\n            self.add_new_key(key, value)\n\n\nlfu = LFUCache(2)\nlfu.put(1, 1)\nlfu.put(2, 2)\nprint(lfu.get(1))  # 1\nlfu.put(3, 3)\nprint(lfu.get(2))  # -1\nprint(lfu.get(3))  # 3\nlfu.put(4, 4)\nprint(lfu.get(1))  # -1\nprint(lfu.get(3))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/design/#1166-design-file-system","title":"1166. Design File System","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, design, trie 1166. Design File System - Python Solution<pre><code>from collections import defaultdict\n\n\nclass TrieNode:\n    def __init__(self, name):\n        self.name = name\n        self.children = defaultdict(TrieNode)\n        self.value = -1\n\n\n# Trie\nclass FileSystem:\n    def __init__(self):\n        self.root = TrieNode(\"\")\n\n    def createPath(self, path: str, value: int) -&gt; bool:\n        paths = path.split(\"/\")[1:]\n        cur = self.root\n\n        for idx, path in enumerate(paths):\n            if path not in cur.children:\n                if idx == len(paths) - 1:\n                    cur.children[path] = TrieNode(path)\n                else:\n                    return False\n            cur = cur.children[path]\n\n        if cur.value != -1:\n            return False\n        cur.value = value\n        return True\n\n    def get(self, path: str) -&gt; int:\n        cur = self.root\n        paths = path.split(\"/\")[1:]\n\n        for path in paths:\n            if path not in cur.children:\n                return -1\n            cur = cur.children[path]\n\n        return cur.value\n\n\n# Your FileSystem object will be instantiated and called as such:\npath = \"/a\"\nvalue = 1\nobj = FileSystem()\nprint(obj.createPath(path, value))  # False\nprint(obj.get(path))  # 1\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/design/#380-insert-delete-getrandom-o1","title":"380. Insert Delete GetRandom O(1)","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, design, randomized 380. Insert Delete GetRandom O(1) - Python Solution<pre><code>import random\n\n\nclass RandomizedSet:\n    def __init__(self):\n        self.dict = {}\n        self.list = []\n\n    def insert(self, val: int) -&gt; bool:\n        if val in self.dict:\n            return False\n        self.dict[val] = len(self.list)\n        self.list.append(val)\n\n        return True\n\n    def remove(self, val: int) -&gt; bool:\n        if val not in self.dict:\n            return False\n        last_element = self.list[-1]\n        idx = self.dict[val]\n        self.list[idx] = last_element\n        self.dict[last_element] = idx\n        self.list.pop()\n        del self.dict[val]\n        return True\n\n    def getRandom(self) -&gt; int:\n        return random.choice(self.list)\n\n\nobj = RandomizedSet()\nprint(obj.insert(1))  # True\nprint(obj.remove(2))  # False\nprint(obj.insert(2))  # True\nprint(obj.getRandom())  # 1 or 2\nprint(obj.remove(1))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/design/#362-design-hit-counter","title":"362. Design Hit Counter","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, design, queue, data stream 362. Design Hit Counter - Python Solution<pre><code>from collections import deque\n\n\nclass HitCounter:\n\n    def __init__(self):\n        self.hits = deque()\n\n    def hit(self, timestamp: int) -&gt; None:\n        self.hits.append(timestamp)\n\n    def getHits(self, timestamp: int) -&gt; int:\n        # Remove hits that are older than 5 minutes (300 seconds)\n        while self.hits and self.hits[0] &lt;= timestamp - 300:\n            self.hits.popleft()\n        return len(self.hits)\n\n\nobj = HitCounter()\nobj.hit(1)\nobj.hit(2)\nobj.hit(3)\nprint(obj.getHits(4))  # 3\nobj.hit(300)\nprint(obj.getHits(300))  # 4\nprint(obj.getHits(301))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/design/#297-serialize-and-deserialize-binary-tree","title":"297. Serialize and Deserialize Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, tree, depth first search, breadth first search, design, binary tree 297. Serialize and Deserialize Binary Tree - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BFS\nclass BFS:\n    def serialize(self, root: Optional[TreeNode]) -&gt; str:\n        if not root:\n            return \"\"\n\n        res = []\n        q = deque([root])\n\n        while q:\n            node = q.popleft()\n\n            if node:\n                res.append(str(node.val))\n                q.append(node.left)\n                q.append(node.right)\n            else:\n                res.append(\"null\")\n\n        return \",\".join(res)\n\n    def deserialize(self, data: str) -&gt; Optional[TreeNode]:\n        if not data:\n            return None\n\n        nodes = data.split(\",\")\n        root = TreeNode(int(nodes[0]))\n        q = deque([root])\n        index = 1\n\n        while q:\n            node = q.popleft()\n\n            if nodes[index] != \"null\":\n                node.left = TreeNode(int(nodes[index]))\n                q.append(node.left)\n            index += 1\n\n            if nodes[index] != \"null\":\n                node.right = TreeNode(int(nodes[index]))\n                q.append(node.right)\n            index += 1\n\n        return root\n\n\n# DFS\nclass DFS:\n    def serialize(self, root: Optional[TreeNode]) -&gt; str:\n        def dfs(node):\n            if not node:\n                return [\"null\"]\n            return [str(node.val)] + dfs(node.left) + dfs(node.right)\n\n        return \",\".join(dfs(root))\n\n    def deserialize(self, data: str) -&gt; Optional[TreeNode]:\n        nodes = data.split(\",\")\n        self.index = 0\n\n        def dfs():\n            if nodes[self.index] == \"null\":\n                self.index += 1\n                return None\n\n            node = TreeNode(int(nodes[self.index]))\n            self.index += 1\n\n            node.left = dfs()\n            node.right = dfs()\n\n            return node\n\n        root = dfs()\n        return root\n\n\nroot = build([1, 2, 3, None, None, 4, 5])\nprint(root)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n\nbfs = BFS()\ndata1 = bfs.serialize(root)\nprint(data1)  # \"1,2,3,null,null,4,5,null,null,null,null\"\nroot1 = bfs.deserialize(data1)\nprint(root1)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n\ndfs = DFS()\ndata2 = dfs.serialize(root)\nprint(data2)  # \"1,2,null,null,3,4,null,null,5,null,null\"\nroot2 = dfs.deserialize(data2)\nprint(root2)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/design/#622-design-circular-queue","title":"622. Design Circular Queue","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, linked list, design, queue 622. Design Circular Queue - Python Solution<pre><code># Design\nclass MyCircularQueue:\n\n    def __init__(self, k: int):\n        self.queue = [0] * k\n        self.head = 0\n        self.tail = -1\n        self.size = 0\n        self.capacity = k\n\n    def enQueue(self, value: int) -&gt; bool:\n        if self.isFull():\n            return False\n        self.tail = (self.tail + 1) % self.capacity\n        self.queue[self.tail] = value\n        self.size += 1\n        return True\n\n    def deQueue(self) -&gt; bool:\n        if self.isEmpty():\n            return False\n        self.head = (self.head + 1) % self.capacity\n        self.size -= 1\n        return True\n\n    def Front(self) -&gt; int:\n        if self.isEmpty():\n            return -1\n        return self.queue[self.head]\n\n    def Rear(self) -&gt; int:\n        if self.isEmpty():\n            return -1\n        return self.queue[self.tail]\n\n    def isEmpty(self) -&gt; bool:\n        return self.size == 0\n\n    def isFull(self) -&gt; bool:\n        return self.size == self.capacity\n\n\nobj = MyCircularQueue(3)\nprint(obj.enQueue(1))  # True\nprint(obj.enQueue(2))  # True\nprint(obj.enQueue(3))  # True\nprint(obj.enQueue(4))  # False\nprint(obj.Rear())  # 3\nprint(obj.isFull())  # True\nprint(obj.deQueue())  # True\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/design/#353-design-snake-game","title":"353. Design Snake Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, design, queue, simulation 353. Design Snake Game - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\nclass SnakeGame:\n\n    def __init__(self, width: int, height: int, food: List[List[int]]):\n        self.width = width\n        self.height = height\n        self.food = deque(food)\n        self.snake = deque([(0, 0)])  # Snake starts at the top-left corner\n        self.snake_body = set([(0, 0)])  # To quickly check for collisions\n        self.score = 0\n        self.dirs = {\"U\": (-1, 0), \"L\": (0, -1), \"R\": (0, 1), \"D\": (1, 0)}\n\n    def move(self, direction: str) -&gt; int:\n        head = self.snake[0]\n        dx, dy = self.dirs[direction]\n        new_head = (head[0] + dx, head[1] + dy)\n\n        # Check if the new head is out of bounds\n        if not (\n            0 &lt;= new_head[0] &lt; self.height and 0 &lt;= new_head[1] &lt; self.width\n        ):\n            return -1\n\n        # Check if the new head collides with the snake body (excluding the tail)\n        if new_head in self.snake_body and new_head != self.snake[-1]:\n            return -1\n\n        # Check if the new head is on a food cell\n        if self.food and self.food[0] == list(new_head):\n            self.food.popleft()\n            self.score += 1\n        else:\n            tail = self.snake.pop()\n            self.snake_body.remove(tail)\n\n        # Add the new head to the snake\n        self.snake.appendleft(new_head)\n        self.snake_body.add(new_head)\n\n        return self.score\n\n\nsnake = SnakeGame(3, 2, [[1, 2], [0, 1]])\nprint(snake.move(\"R\"))  # 0\nprint(snake.move(\"D\"))  # 0\nprint(snake.move(\"R\"))  # 1\nprint(snake.move(\"U\"))  # 1\nprint(snake.move(\"L\"))  # 2\nprint(snake.move(\"U\"))  # -1\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/design/#1244-design-a-leaderboard","title":"1244. Design A Leaderboard","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, design, sorting 1244. Design A Leaderboard - Python Solution<pre><code>class Leaderboard:\n\n    def __init__(self):\n        self.scores = {}\n\n    def addScore(self, playerId: int, score: int) -&gt; None:\n        if playerId in self.scores:\n            self.scores[playerId] += score\n        else:\n            self.scores[playerId] = score\n\n    def top(self, K: int) -&gt; int:\n        topK = sorted(self.scores.values(), reverse=True)[:K]\n        return sum(topK)\n\n    def reset(self, playerId: int) -&gt; None:\n        if playerId in self.scores:\n            self.scores[playerId] = 0\n\n\nboard = Leaderboard()\nboard.addScore(1, 73)\nboard.addScore(2, 56)\nboard.addScore(3, 39)\nboard.addScore(4, 51)\nprint(board.top(1))  # 73\nboard.reset(1)\nboard.reset(2)\nprint(board.top(2))  # 90\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/difference_array/","title":"Difference Array","text":""},{"location":"content/leetpattern/difference_array/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1094. Car Pooling (Medium)</li> <li> 370. Range Addition (Medium) \ud83d\udc51</li> <li> 1109. Corporate Flight Bookings (Medium)</li> <li> 2848. Points That Intersect With Cars (Easy)</li> </ul>"},{"location":"content/leetpattern/difference_array/#1094-car-pooling","title":"1094. Car Pooling","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sorting, heap priority queue, simulation, prefix sum</p> </li> <li>Return <code>False</code> if the total number of passengers at any point is greater than <code>capacity</code>. Otherwise, return <code>True</code>.</li> </ul> 1094. Car Pooling - Python Solution<pre><code>from itertools import accumulate\nfrom typing import List\n\n\n# Difference Array\ndef carPooling1(trips: List[List[int]], capacity: int) -&gt; bool:\n    max_location = 0\n    for trip in trips:\n        max_location = max(max_location, trip[2])\n\n    diff = [0] * (max_location + 1)\n    n = len(diff)\n\n    for num, start, end in trips:\n        diff[start] += num\n        if end &lt; n:\n            diff[end] -= num\n\n    cur = 0\n    for i in range(n):\n        cur += diff[i]\n        if cur &gt; capacity:\n            return False\n\n    return True\n\n\n# Difference Array\ndef carPooling2(trips: List[List[int]], capacity: int) -&gt; bool:\n    diff = [0] * 1001\n\n    for num, start, end in trips:\n        diff[start] += num\n        diff[end] -= num\n\n    return all(s &lt;= capacity for s in accumulate(diff))\n\n\ntrips = [[2, 1, 5], [3, 3, 7]]\ncapacity = 4\nprint(carPooling1(trips, capacity))  # False\nprint(carPooling2(trips, capacity))  # False\n</code></pre>"},{"location":"content/leetpattern/difference_array/#370-range-addition","title":"370. Range Addition","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, prefix sum</p> </li> <li>Return the final array after applying all the Adition operations.</li> </ul> 370. Range Addition - Python Solution<pre><code>from typing import List\n\n\n# Difference Array\ndef getModifiedArray(length: int, updates: List[List[int]]) -&gt; List[int]:\n    result = [0 for _ in range(length)]\n\n    for start, end, inc in updates:\n        result[start] += inc\n\n        if end + 1 &lt; length:\n            result[end + 1] -= inc\n\n    for i in range(1, length):\n        result[i] += result[i - 1]\n\n    return result\n\n\nlength = 5\nupdates = [[1, 3, 2], [2, 4, 3], [0, 2, -2]]\nprint(getModifiedArray(length, updates))  # [-2, 0, 3, 5, 3]\n</code></pre>"},{"location":"content/leetpattern/difference_array/#1109-corporate-flight-bookings","title":"1109. Corporate Flight Bookings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, prefix sum</p> </li> <li>Return the number of seats booked on each flight.</li> </ul> 1109. Corporate Flight Bookings - Python Solution<pre><code>from typing import List\n\n\n# Difference Array\ndef corpFlightBookings(bookings: List[List[int]], n: int) -&gt; List[int]:\n    \"\"\"Return the number of seats booked for each flight.\"\"\"\n    res = [0 for _ in range(n)]\n\n    for i, j, k in bookings:\n        res[i - 1] += k\n        if j &lt; n:\n            res[j] -= k\n\n    for i in range(1, n):\n        res[i] += res[i - 1]\n\n    return res\n\n\nbookings = [[1, 2, 10], [2, 3, 20], [2, 5, 25]]\nn = 5\nprint(corpFlightBookings(bookings, n))  # [10, 55, 45, 25, 25]\n</code></pre>"},{"location":"content/leetpattern/difference_array/#2848-points-that-intersect-with-cars","title":"2848. Points That Intersect With Cars","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, prefix sum</p> </li> <li>Return the number of points that intersect with cars.</li> </ul> 2848. Points That Intersect With Cars - Python Solution<pre><code>from itertools import accumulate\nfrom typing import List\n\n\n# Differnce Array\ndef numberOfPoints(nums: List[List[int]]) -&gt; int:\n    max_end = max(end for _, end in nums)\n\n    diff = [0] * (max_end + 2)\n\n    for start, end in nums:\n        diff[start] += 1\n        diff[end + 1] -= 1\n\n    return sum(s &gt; 0 for s in accumulate(diff))\n\n\nnums = [[3, 6], [1, 5], [4, 7]]\nprint(numberOfPoints(nums))  # 7\n</code></pre>"},{"location":"content/leetpattern/dp_01_knapsack/","title":"DP 01 Knapsack","text":""},{"location":"content/leetpattern/dp_01_knapsack/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 416. Partition Equal Subset Sum (Medium)</li> <li> 474. Ones and Zeroes (Medium)</li> <li> 494. Target Sum (Medium)</li> <li> 1046. Last Stone Weight (Easy)</li> <li> 1049. Last Stone Weight II (Medium)</li> </ul>"},{"location":"content/leetpattern/dp_01_knapsack/#416-partition-equal-subset-sum","title":"416. Partition Equal Subset Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming 416. Partition Equal Subset Sum - Python Solution<pre><code>from functools import cache\nfrom typing import List\n\nfrom template import knapsack01\n\n\n# Memoization\ndef canPartitionMemoization(nums: List[int]) -&gt; bool:\n    total = sum(nums)\n    n = len(nums)\n\n    if total % 2 == 1 or n &lt;= 1:\n        return False\n\n    @cache\n    def dfs(i, j):\n        if i &lt; 0:\n            return j == 0\n        return j &gt;= nums[i] and dfs(i - 1, j - nums[i]) or dfs(i - 1, j)\n\n    return dfs(n - 1, total // 2)\n\n\n# DP - Knapsack 01\ndef canPartitionTemplate(nums: List[int]) -&gt; bool:\n    total = sum(nums)\n\n    if total % 2 == 1 or len(nums) &lt; 2:\n        return False\n\n    target = total // 2\n\n    return knapsack01(nums, nums, target) == target\n\n\n# DP - Knapsack 01\ndef canPartition(nums: List[int]) -&gt; bool:\n    total = sum(nums)\n\n    if total % 2 == 1 or len(nums) &lt; 2:\n        return False\n\n    target = total // 2\n\n    dp = [0 for _ in range(target + 1)]\n\n    for i in range(len(nums)):\n        for j in range(target, nums[i] - 1, -1):\n            dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])\n\n    return dp[target] == target\n\n\nif __name__ == \"__main__\":\n    nums = [1, 5, 11, 5]\n    print(canPartitionTemplate(nums))  # True\n    print(canPartition(nums))  # True\n    print(canPartitionMemoization(nums))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/dp_01_knapsack/#474-ones-and-zeroes","title":"474. Ones and Zeroes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, dynamic programming 474. Ones and Zeroes - Python Solution<pre><code>from typing import List\n\n\ndef findMaxForm(strs: List[str], m: int, n: int) -&gt; int:\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for s in strs:\n        zerosNum = s.count(\"0\")\n        onesNum = len(s) - zerosNum\n\n        for i in range(m, zerosNum - 1, -1):\n            for j in range(n, onesNum - 1, -1):\n                dp[i][j] = max(dp[i][j], dp[i - zerosNum][j - onesNum] + 1)\n\n    return dp[m][n]\n\n\nstrs = [\"10\", \"0001\", \"111001\", \"1\", \"0\"]\nm = 5\nn = 3\nprint(findMaxForm(strs, m, n))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/dp_01_knapsack/#494-target-sum","title":"494. Target Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, backtracking 494. Target Sum - Python Solution<pre><code>from typing import List\n\n\ndef findTargetSumWays(nums: List[int], target: int) -&gt; int:\n\n    totalSum = sum(nums)\n\n    if abs(target) &gt; totalSum:\n        return 0\n    if (target + totalSum) % 2 == 1:\n        return 0\n\n    targetSum = (target + totalSum) // 2\n    dp = [0] * (targetSum + 1)\n    dp[0] = 1\n\n    for i in range(len(nums)):\n        for j in range(targetSum, nums[i] - 1, -1):\n            dp[j] += dp[j - nums[i]]\n\n    return dp[targetSum]\n\n\nnums = [1, 1, 1, 1, 1]\ntarget = 3\nprint(findTargetSumWays(nums, target))  # 5\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/dp_01_knapsack/#1046-last-stone-weight","title":"1046. Last Stone Weight","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, heap priority queue</p> </li> <li>Heap<ul> <li>Time: O(n log n); Space: O(n)</li> </ul> </li> <li>0/1 Knapsack<ul> <li>Time: O(n); Space: O(n)</li> </ul> </li> </ul> 1046. Last Stone Weight - Python Solution<pre><code>from heapq import heapify, heappop, heappush\nfrom typing import List\n\n\n# Heap\ndef lastStoneWeightHeap(stones: List[int]) -&gt; int:\n    maxHeap = [-s for s in stones]\n    heapify(maxHeap)\n\n    while len(maxHeap) &gt; 1:\n        s1 = heappop(maxHeap)\n        s2 = heappop(maxHeap)\n\n        if s1 != s2:\n            heappush(maxHeap, s1 - s2)\n\n    return -maxHeap[0] if maxHeap else 0\n\n\n# 0/1 Knapsack\ndef lastStoneWeightKnapsack(stones: List[int]) -&gt; int:\n    total = sum(stones)\n    target = total // 2\n\n    dp = [0 for _ in range(target + 1)]\n\n    for i in stones:\n        for j in range(target, i - 1, -1):\n            dp[j] = max(dp[j], dp[j - i] + i)\n\n    return total - 2 * dp[target]\n\n\nif __name__ == \"__main__\":\n    stones = [2, 7, 4, 1, 8, 1]\n    assert lastStoneWeightHeap(stones) == 1\n    assert lastStoneWeightKnapsack(stones) == 1\n</code></pre> 1046. Last Stone Weight - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;queue&gt;\n\nusing namespace std;\n\nint lastStoneWeight(vector&lt;int&gt; &amp;stones)\n{\n    priority_queue&lt;int&gt; maxHeap(stones.begin(), stones.end());\n\n    while (maxHeap.size() &gt;= 1)\n    {\n        int first = maxHeap.top();\n        maxHeap.pop();\n        int second = maxHeap.top();\n        maxHeap.pop();\n\n        if (first != second)\n        {\n            maxHeap.push(first - second);\n        }\n    }\n\n    return maxHeap.empty() ? 0 : maxHeap.top();\n}\n\nint main()\n{\n    vector&lt;int&gt; stones = {2, 7, 4, 1, 8, 1};\n    cout &lt;&lt; lastStoneWeight(stones) &lt;&lt; endl; // 1\n    return 0;\n}\n</code></pre>"},{"location":"content/leetpattern/dp_01_knapsack/#1049-last-stone-weight-ii","title":"1049. Last Stone Weight II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming 1049. Last Stone Weight II - Python Solution<pre><code>from typing import List\n\n\ndef lastStoneWeightII(stones: List[int]) -&gt; int:\n    target = sum(stones) // 2\n\n    dp = [0 for _ in range(target + 1)]\n\n    for i in range(len(stones)):\n        for j in range(target, stones[i] - 1, -1):\n            dp[j] = max(dp[j], dp[j - stones[i]] + stones[i])\n\n    result = (sum(stones) - dp[target]) - dp[target]\n\n    return result\n\n\nstones = [2, 7, 4, 1, 8, 1]\nprint(lastStoneWeightII(stones))  # 1\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/dp_2d/","title":"DP 2D","text":""},{"location":"content/leetpattern/dp_2d/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 118. Pascal's Triangle (Easy)</li> <li> 119. Pascal's Triangle II (Easy)</li> <li> 62. Unique Paths (Medium)</li> <li> 63. Unique Paths II (Medium)</li> </ul>"},{"location":"content/leetpattern/dp_2d/#118-pascals-triangle","title":"118. Pascal's Triangle","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li>Generate the first <code>numRows</code> of Pascal's triangle.</li> </ul> <pre><code>                 numRows\n     1              1\n    1 1             2\n   1 2 1            3\n  1 3 3 1           4\n 1 4 6 4 1          5\n</code></pre> 118. Pascal's Triangle - Python Solution<pre><code>from typing import List\n\n\ndef generate(numRows: int) -&gt; List[List[int]]:\n    dp = [[1] * i for i in range(1, numRows + 1)]\n\n    if numRows &lt;= 2:\n        return dp\n\n    for i in range(2, numRows):\n        for j in range(1, i):\n            dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n\n    return dp\n\n\nif __name__ == \"__main__\":\n    print(generate(numRows=5))\n    # [[1],\n    #  [1, 1],\n    #  [1, 2, 1],\n    #  [1, 3, 3, 1],\n    #  [1, 4, 6, 4, 1]]\n</code></pre>"},{"location":"content/leetpattern/dp_2d/#119-pascals-triangle-ii","title":"119. Pascal's Triangle II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li>Return the <code>rowIndex</code>th row of Pascal's triangle.</li> </ul> 119. Pascal's Triangle II - Python Solution<pre><code>from typing import List\n\n\ndef getRow(rowIndex: int) -&gt; List[int]:\n    dp = [[1] * (i + 1) for i in range(rowIndex + 1)]\n\n    if rowIndex &lt;= 1:\n        return dp[rowIndex]\n\n    for i in range(2, rowIndex + 1):\n        for j in range(1, i):\n            dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n\n    return dp[-1]\n\n\nprint(getRow(rowIndex=3))  # [1, 3, 3, 1]\n</code></pre>"},{"location":"content/leetpattern/dp_2d/#62-unique-paths","title":"62. Unique Paths","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, combinatorics</p> </li> <li>Count the number of unique paths to reach the bottom-right corner of a <code>m x n</code> grid.</li> </ul> <p></p> 62. Unique Paths - Python Solution<pre><code># DP - 2D\ndef uniquePaths(m: int, n: int) -&gt; int:\n    if m == 1 or n == 1:\n        return 1\n\n    dp = [[1] * n for _ in range(m)]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]\n\n\nprint(uniquePaths(m=3, n=7))  # 28\n# [[1, 1, 1,  1,  1,  1,  1],\n#  [1, 2, 3,  4,  5,  6,  7],\n#  [1, 3, 6, 10, 15, 21, 28]]\n</code></pre> 62. Unique Paths - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint uniquePaths(int m, int n) {\n    vector dp(m, vector&lt;int&gt;(n, 1));\n\n    for (int i = 1; i &lt; m; i++) {\n        for (int j = 1; j &lt; n; j++) {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n\n    return dp[m - 1][n - 1];\n}\n\nint main() {\n    int m = 3, n = 7;\n    cout &lt;&lt; uniquePaths(m, n) &lt;&lt; endl;  // 28\n    return 0;\n}\n</code></pre>"},{"location":"content/leetpattern/dp_2d/#63-unique-paths-ii","title":"63. Unique Paths II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, matrix</p> </li> <li>Count the number of unique paths to reach the bottom-right corner of a <code>m x n</code> grid with obstacles.</li> </ul> <p></p> 63. Unique Paths II - Python Solution<pre><code>from typing import List\n\n\n# DP - 2D\ndef uniquePathsWithObstacles(obstacleGrid: List[List[int]]) -&gt; int:\n    if obstacleGrid[0][0] == 1 or obstacleGrid[-1][-1] == 1:\n        return 0\n\n    m, n = len(obstacleGrid), len(obstacleGrid[0])\n    dp = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n        if obstacleGrid[i][0] == 0:\n            dp[i][0] = 1\n        else:\n            break\n\n    for j in range(n):\n        if obstacleGrid[0][j] == 0:\n            dp[0][j] = 1\n        else:\n            break\n\n    for i in range(1, m):\n        for j in range(1, n):\n            if obstacleGrid[i][j] == 1:\n                continue\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]\n\n\nobstacleGrid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\nprint(uniquePathsWithObstacles(obstacleGrid))  # 2\n# [[1, 1, 1],\n#  [1, 0, 1],\n#  [1, 1, 2]]\n</code></pre>"},{"location":"content/leetpattern/dp_basic/","title":"DP Basic","text":""},{"location":"content/leetpattern/dp_basic/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 509. Fibonacci Number (Easy)</li> <li> 70. Climbing Stairs (Easy)</li> <li> 746. Min Cost Climbing Stairs (Easy)</li> <li> 198. House Robber (Medium)</li> <li> 213. House Robber II (Medium)</li> <li> 376. Wiggle Subsequence (Medium)</li> <li> 343. Integer Break (Medium)</li> <li> 1025. Divisor Game (Easy)</li> </ul>"},{"location":"content/leetpattern/dp_basic/#509-fibonacci-number","title":"509. Fibonacci Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, dynamic programming, recursion, memoization</p> </li> <li>Return the <code>n-th</code> Fibonacci number.</li> <li><code>dp[n]</code> stores the <code>n-th</code> Fibonacci number.</li> <li>Formula: <code>dp[n] = dp[n - 1] + dp[n - 2]</code>.</li> <li>Initialize <code>dp[0] = 0</code> and <code>dp[1] = 1</code>.</li> </ul> n <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n]</code> 0 - - 0 1 - 0 1 2 0 1 1 3 1 1 2 4 1 2 3 5 2 3 5 6 3 5 8 7 5 8 13 8 8 13 21 9 13 21 34 10 21 34 55 509. Fibonacci Number - Python Solution<pre><code>from functools import cache\n\n\n# DP\ndef fibDP(n: int) -&gt; int:\n    if n &lt;= 1:\n        return n\n\n    dp = [i for i in range(n + 1)]\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\n# DP (Optimized)\ndef fibDPOptimized(n: int) -&gt; int:\n    if n &lt;= 1:\n        return n\n\n    n1, n2 = 0, 1\n    for _ in range(2, n + 1):\n        n1, n2 = n2, n1 + n2\n\n    return n2\n\n\n# Recursive\n@cache\ndef fibRecursive(n: int) -&gt; int:\n    if n &lt;= 1:\n        return n\n\n    return fibRecursive(n - 1) + fibRecursive(n - 2)\n\n\nn = 10\nprint(fibDP(n))  # 55\nprint(fibDPOptimized(n))  # 55\nprint(fibRecursive(n))  # 55\n</code></pre>"},{"location":"content/leetpattern/dp_basic/#70-climbing-stairs","title":"70. Climbing Stairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, dynamic programming, memoization</p> </li> <li>Return the number of distinct ways to reach the top of the stairs.</li> <li><code>dp[n]</code> stores the number of distinct ways to reach the <code>n-th</code> stair.</li> <li>Formula: <code>dp[n] = dp[n - 1] + dp[n - 2]</code>.</li> <li>Initialize <code>dp[0] = 0</code>, <code>dp[1] = 1</code>, and <code>dp[2] = 2</code>.</li> </ul> 70. Climbing Stairs - Python Solution<pre><code>from functools import cache\n\n\n# DP\ndef climbStairsDP(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    dp = [i for i in range(n + 1)]\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\n# DP (Optimized)\ndef climbStairsDPOptimized(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    first, second = 1, 2\n\n    for _ in range(3, n + 1):\n        first, second = second, first + second\n\n    return second\n\n\n# Recursion\ndef climbStairsRecursion(n: int) -&gt; int:\n    @cache\n    def dfs(i: int) -&gt; int:\n        if i &lt;= 1:\n            return 1\n        return dfs(i - 1) + dfs(i - 2)\n\n    return dfs(n)\n\n\n# Greedy\ndef climbStairsGreedy(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    p1, p2 = 1, 2\n\n    for _ in range(3, n + 1):\n        p1, p2 = p2, p1 + p2\n\n    return p2\n\n\nif __name__ == \"__main__\":\n    assert climbStairsDP(10) == 89\n    assert climbStairsDPOptimized(10) == 89\n    assert climbStairsRecursion(10) == 89\n    assert climbStairsGreedy(10) == 89\n</code></pre> 70. Climbing Stairs - C++ Solution<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint climbStairs(int n) {\n    if (n &lt;= 2) return n;\n    int f1 = 1, f2 = 2;\n    int res;\n\n    int i = 3;\n    while (i &lt;= n) {\n        res = f1 + f2;\n        f1 = f2;\n        f2 = res;\n        ++i;\n    }\n    return res;\n}\n\nint main() {\n    cout &lt;&lt; climbStairs(2) &lt;&lt; endl;  // 2\n    cout &lt;&lt; climbStairs(3) &lt;&lt; endl;  // 3\n    cout &lt;&lt; climbStairs(6) &lt;&lt; endl;  // 13\n    return 0;\n}\n</code></pre>"},{"location":"content/leetpattern/dp_basic/#746-min-cost-climbing-stairs","title":"746. Min Cost Climbing Stairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li> <p>Return the minimum cost to reach the top of the stairs.</p> </li> <li> <p><code>dp[n]</code> stores the minimum cost to reach the <code>n-th</code> stair.</p> </li> <li>Formula: <code>dp[n] = cost[n] + min(dp[n - 1], dp[n - 2])</code>.</li> <li>Initialize <code>dp[0] = cost[0]</code> and <code>dp[1] = cost[1]</code>.</li> <li> <p>Return <code>min(dp[-1], dp[-2])</code>.</p> </li> <li> <p>Example: <code>cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</code></p> </li> </ul> n <code>cost[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n]</code> 0 1 - - 1 1 100 - 1 100 2 1 1 100 2 3 1 100 2 3 4 1 2 3 3 5 100 3 3 103 6 1 3 103 4 7 1 103 4 5 8 100 4 5 104 9 1 5 104 6 746. Min Cost Climbing Stairs - Python Solution<pre><code>from typing import List\n\n\ndef minCostClimbingStairs(cost: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(cost))]\n\n    dp[0], dp[1] = cost[0], cost[1]\n\n    for i in range(2, len(cost)):\n        dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]\n    print(dp)\n    return min(dp[-1], dp[-2])\n\n\ncost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]\nprint(minCostClimbingStairs(cost))  # 6\n</code></pre>"},{"location":"content/leetpattern/dp_basic/#198-house-robber","title":"198. House Robber","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li> <p>Return the maximum amount of money that can be robbed from the houses. No two adjacent houses can be robbed.</p> </li> <li> <p><code>dp[n]</code> stores the maximum amount of money that can be robbed from the first <code>n</code> houses.</p> </li> <li>Formula: <code>dp[n] = max(dp[n - 1], dp[n - 2] + nums[n])</code>.<ul> <li>Skip: <code>dp[n]</code> \u2192 <code>dp[n - 1]</code></li> <li>Rob: <code>dp[n]</code> \u2192 <code>dp[n - 2] + nums[n]</code></li> </ul> </li> <li>Initialize <code>dp[0] = nums[0]</code> and <code>dp[1] = max(nums[0], nums[1])</code>.</li> <li>Return <code>dp[-1]</code>.</li> <li>Example: <code>nums = [2, 7, 9, 3, 1]</code></li> </ul> n <code>nums[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n-2] + nums[n]</code> <code>dp[n]</code> 0 2 - 2 - 2 1 7 - 7 - 7 2 9 2 7 11 11 3 3 7 11 10 11 4 1 11 11 12 12 198. House Robber - Python Solution<pre><code>from typing import List\n\n\n# DP (House Robber)\ndef rob1(nums: List[int]) -&gt; int:\n    if len(nums) &lt; 3:\n        return max(nums)\n\n    dp = [0 for _ in range(len(nums))]\n    dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n    for i in range(2, len(nums)):\n        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n    return dp[-1]\n\n\n# DP (House Robber) Optimized\ndef rob2(nums: List[int]) -&gt; int:\n    f0, f1 = 0, 0\n\n    for num in nums:\n        f0, f1 = f1, max(f1, f0 + num)\n\n    return f1\n\n\nnums = [2, 7, 9, 3, 1]\nprint(rob1(nums))  # 12\nprint(rob2(nums))  # 12\n</code></pre> 198. House Robber - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint rob(vector&lt;int&gt; &amp;nums) {\n    int prev = 0, cur = 0, temp = 0;\n\n    for (int num : nums) {\n        temp = cur;\n        cur = max(cur, prev + num);\n        prev = temp;\n    }\n    return cur;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {2, 7, 9, 3, 1};\n    cout &lt;&lt; rob(nums) &lt;&lt; endl;  // 12\n    return 0;\n}\n</code></pre>"},{"location":"content/leetpattern/dp_basic/#213-house-robber-ii","title":"213. House Robber II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li>Return the maximum amount of money that can be robbed from the houses arranged in a circle.</li> <li>Circular \u2192 Linear: <code>nums[0]</code> and <code>nums[-1]</code> cannot be robbed together.</li> <li>Rob from <code>0</code> to <code>n - 2</code></li> </ul> n <code>nums[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n-2] + nums[n]</code> <code>dp[n]</code> 0 2 - 2 - 2 1 7 - 7 - 7 2 9 2 7 11 11 3 3 7 11 10 11 <ul> <li>Rob from <code>1</code> to <code>n - 1</code></li> </ul> n <code>nums[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n-2] + nums[n]</code> <code>dp[n]</code> 1 7 - - - 7 2 9 - 7 - 9 3 3 7 9 10 10 4 1 9 10 10 10 213. House Robber II - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef rob(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 3:\n        return max(nums)\n\n    def robLinear(nums: List[int]) -&gt; int:\n        dp = [0 for _ in range(len(nums))]\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n        return dp[-1]\n\n    # circle -&gt; linear\n    a = robLinear(nums[1:])  # 2nd house to the last house\n    b = robLinear(nums[:-1])  # 1st house to the 2nd last house\n\n    return max(a, b)\n\n\nnums = [2, 7, 9, 3, 1]\nprint(rob(nums))  # 11\n</code></pre> 213. House Robber II - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// DP\nint robDP(vector&lt;int&gt;&amp; nums) {\n    int n = nums.size();\n    if (n &lt;= 3) return *max_element(nums.begin(), nums.end());\n\n    vector&lt;int&gt; dp1(n, 0), dp2(n, 0);\n\n    dp1[0] = nums[0];\n    dp2[1] = max(nums[0], nums[1]);\n    for (int i = 2; i &lt; n - 1; i++) {\n        dp1[i] = max(dp1[i - 1], dp1[i - 2] + nums[i]);\n    }\n\n    dp2[1] = nums[1];\n    dp2[2] = max(nums[1], nums[2]);\n    for (int i = 3; i &lt; n; i++) {\n        dp1[i] = max(dp1[i - 1], dp1[i - 2] + nums[i]);\n    }\n\n    return max(dp1[n - 2], dp2[n - 1]);\n}\n\n// DP (Space Optimized)\nint robDPOptimized(vector&lt;int&gt;&amp; nums) {\n    int n = nums.size();\n    if (n &lt;= 3) return *max_element(nums.begin(), nums.end());\n\n    int f1 = nums[0];\n    int f2 = max(nums[0], nums[1]);\n    int res1;\n    for (int i = 2; i &lt; n - 1; i++) {\n        res1 = max(f2, f1 + nums[i]);\n        f1 = f2;\n        f2 = res1;\n    }\n\n    f1 = nums[1];\n    f2 = max(nums[1], nums[2]);\n    int res2;\n    for (int i = 3; i &lt; n; i++) {\n        res2 = max(f2, f1 + nums[i]);\n        f1 = f2;\n        f2 = res2;\n    }\n\n    return max(res1, res2);\n}\n\nint main() {\n    vector&lt;int&gt; nums = {2, 3, 2};\n    cout &lt;&lt; robDP(nums) &lt;&lt; endl;           // 3\n    cout &lt;&lt; robDPOptimized(nums) &lt;&lt; endl;  // 3\n\n    nums = {1, 2, 3, 1};\n    cout &lt;&lt; robDP(nums) &lt;&lt; endl;           // 4\n    cout &lt;&lt; robDPOptimized(nums) &lt;&lt; endl;  // 4\n\n    return 0;\n}\n</code></pre>"},{"location":"content/leetpattern/dp_basic/#376-wiggle-subsequence","title":"376. Wiggle Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> <li>Return the length of the longest wiggle subsequence.</li> <li><code>up[n]</code> stores the length of the longest wiggle subsequence ending at <code>n</code> with a rising wiggle.</li> <li><code>down[n]</code> stores the length of the longest wiggle subsequence ending at <code>n</code> with a falling wiggle.</li> <li>Initialize <code>up[0] = 1</code> and <code>down[0] = 1</code>.</li> <li>Example: <code>nums = [1, 7, 4, 9, 2, 5]</code></li> </ul> <code>nums[n]</code> <code>nums[n-1]</code> <code>up[n-1]</code> <code>down[n-1]</code> <code>up[n]</code> <code>down[n]</code> 1 - - - 1 1 7 1 1 1 2 1 4 7 2 1 2 3 9 4 2 3 4 3 2 9 4 3 4 5 5 2 4 5 6 5 376. Wiggle Subsequence - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef wiggleMaxLengthDP(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 1:\n        return len(nums)\n\n    up = [0 for _ in range(len(nums))]\n    down = [0 for _ in range(len(nums))]\n\n    up[0], down[0] = 1, 1\n\n    for i in range(1, len(nums)):\n        if nums[i] &gt; nums[i - 1]:\n            up[i] = down[i - 1] + 1\n            down[i] = down[i - 1]\n        elif nums[i] &lt; nums[i - 1]:\n            down[i] = up[i - 1] + 1\n            up[i] = up[i - 1]\n        else:\n            up[i] = up[i - 1]\n            down[i] = down[i - 1]\n\n    return max(up[-1], down[-1])\n\n\n# Greedy\ndef wiggleMaxLengthGreedy(nums: List[int]) -&gt; int:\n    if len(nums) &lt; 2:\n        return len(nums)\n\n    prev_diff = nums[1] - nums[0]\n    count = 2 if prev_diff != 0 else 1\n\n    for i in range(2, len(nums)):\n        diff = nums[i] - nums[i - 1]\n        if (diff &gt; 0 and prev_diff &lt;= 0) or (diff &lt; 0 and prev_diff &gt;= 0):\n            count += 1\n            prev_diff = diff\n\n    return count\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    DP       |      O(n)       |     O(n)     |\n# |  Greedy     |      O(n)       |     O(1)     |\n# |-------------|-----------------|--------------|\n\nnums = [1, 7, 4, 9, 2, 5]\nprint(wiggleMaxLengthDP(nums))  # 6\nprint(wiggleMaxLengthGreedy(nums))  # 6\n</code></pre>"},{"location":"content/leetpattern/dp_basic/#343-integer-break","title":"343. Integer Break","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming</p> </li> <li>Return the maximum product of the integer after breaking it into at least two positive integers.</li> <li><code>dp[i]</code> stores the maximum product of the integer <code>i</code>.</li> <li>Formula: <code>dp[i] = max(dp[i - j] * j, (i - j) * j)</code></li> <li>Time Complexity: O(n^2)</li> <li>Space Complexity: O(n)</li> </ul> dp 3 4 5 6 7 8 2 2*1=2 2*2=4 2*3=6 2*4=8 2*5=10 2*6=12 dp[2]=1 1*1=1 1*2=2 1*3=3 1*4=4 1*5=5 1*6=6 3 3*1=3 3*2=6 3*3=9 3*4=12 3*5=15 dp[3]=2 2*1=2 2*2=4 2*3=6 2*4=8 2*5=10 4 4*1=4 4*2=8 4*3=12 4*4=16 dp[4]=4 4*1=4 4*2=8 4*3=12 4*4=16 5 5*1=5 5*2=10 5*3=15 dp[5]=6 6*1=6 6*2=12 6*3=18 6 6*1=6 6*2=12 dp[6]=9 9*1=9 9*2=18 7 7*1=7 dp[7]=12 12*1=12 <code>dp[n]</code> 2 4 6 9 12 18 343. Integer Break - Python Solution<pre><code>def integerBreak(n: int) -&gt; int:\n    dp = [0 for _ in range(n + 1)]\n    dp[2] = 1\n\n    for i in range(3, n + 1):\n        for j in range(2, i):\n            dp[i] = max(dp[i], dp[i - j] * j, (i - j) * j)\n\n    return dp[n]\n\n\nif __name__ == \"__main__\":\n    print(integerBreak(8))  # 18\n</code></pre>"},{"location":"content/leetpattern/dp_basic/#1025-divisor-game","title":"1025. Divisor Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, dynamic programming, brainteaser, game theory</p> </li> <li>Return <code>True</code> if Alice wins the game, assuming both players play optimally.</li> <li><code>dp[n]</code> stores the result of the game when the number is <code>n</code>.</li> <li>Initialize <code>dp[1] = False</code>.</li> </ul> 1025. Divisor Game - Python Solution<pre><code># DP\ndef divisorGameDP(n: int) -&gt; bool:\n    if n &lt;= 1:\n        return False\n\n    dp = [False for _ in range(n + 1)]\n\n    for i in range(2, n + 1):\n        for j in range(1, i):\n            if i % j == 0 and not dp[i - j]:\n                dp[i] = True\n                break\n\n    return dp[n]\n\n\n# Math\ndef divisorGameDPMath(n: int) -&gt; bool:\n    return n % 2 == 0\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |  DP         |      O(n^2)     |    O(n)      |\n# |  Math       |      O(1)       |    O(1)      |\n# |-------------|-----------------|--------------|\n\nn = 2\nprint(divisorGameDP(n))  # True\nprint(divisorGameDPMath(n))  # True\n</code></pre>"},{"location":"content/leetpattern/dp_interval/","title":"DP Interval","text":""},{"location":"content/leetpattern/dp_interval/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 516. Longest Palindromic Subsequence (Medium)</li> <li> 647. Palindromic Substrings (Medium)</li> <li> 5. Longest Palindromic Substring (Medium)</li> </ul>"},{"location":"content/leetpattern/dp_interval/#516-longest-palindromic-subsequence","title":"516. Longest Palindromic Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> <li>Return the length of the longest palindromic subsequence in <code>s</code>.</li> <li>Bottom-up DP table</li> </ul> dp b b b a b b 1 2 3 3 4 b 0 1 2 2 3 <code>dp[i][j]</code> b 0 0 1 1 <code>dp[i+1][j-1]</code> 2 a 0 0 0 1 1 b 0 0 0 0 1 516. Longest Palindromic Subsequence - Python Solution<pre><code>def longestPalindromeSubseq(s: str) -&gt; int:\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            if s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])\n\n    return dp[0][-1]\n\n\nprint(longestPalindromeSubseq(\"bbbab\"))  # 4\n</code></pre>"},{"location":"content/leetpattern/dp_interval/#647-palindromic-substrings","title":"647. Palindromic Substrings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string, dynamic programming</p> </li> <li>Return the number of palindromic substrings in <code>s</code>.</li> <li>Bottom-up DP table</li> </ul> dp a b b a e a 1 0 0 1 0 b 0 1 1 0 0 b 0 0 1 0 0 a 0 0 0 1 0 e 0 0 0 0 1 647. Palindromic Substrings - Python Solution<pre><code>def countSubstrings(s: str) -&gt; int:\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    res = 0\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i, n):\n            if s[i] == s[j]:\n                if j - i &lt;= 1:\n                    dp[i][j] = 1\n                    res += 1\n                elif dp[i + 1][j - 1]:\n                    dp[i][j] = 1\n                    res += 1\n\n    return res\n\n\nprint(countSubstrings(\"abbae\"))  # 7\n</code></pre>"},{"location":"content/leetpattern/dp_interval/#5-longest-palindromic-substring","title":"5. Longest Palindromic Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string, dynamic programming</p> </li> <li>Return the longest palindromic substring in <code>s</code>.</li> </ul> 5. Longest Palindromic Substring - Python Solution<pre><code># DP - Interval\ndef longestPalindromeDP(s: str) -&gt; str:\n    n = len(s)\n    if n &lt;= 1:\n        return s\n\n    start, maxLen = 0, 1\n\n    # Init\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for j in range(1, n):\n        for i in range(j):\n            if s[i] == s[j]:\n                if j - i &lt;= 2:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1]\n\n                if dp[i][j] and j - i + 1 &gt; maxLen:\n                    maxLen = j - i + 1\n                    start = i\n\n    return s[start : start + maxLen]\n\n\n# Expand Around Center\ndef longestPalindromeCenter(s: str) -&gt; str:\n    def expand_around_center(left, right):\n        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n\n    if len(s) &lt;= 1:\n        return s\n\n    start, end = 0, 0\n    for i in range(len(s)):\n        len1 = expand_around_center(i, i)  # odd\n        len2 = expand_around_center(i, i + 1)  # even\n\n        maxLen = max(len1, len2)\n        if maxLen &gt; end - start:\n            start = i - (maxLen - 1) // 2\n            end = i + maxLen // 2\n\n    return s[start : end + 1]\n\n\ns = \"babad\"\nprint(longestPalindromeDP(s))  # \"bab\"\nprint(longestPalindromeCenter(s))  # \"aba\"\n</code></pre>"},{"location":"content/leetpattern/dp_kadane/","title":"DP Kadane","text":""},{"location":"content/leetpattern/dp_kadane/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 53. Maximum Subarray (Medium)</li> <li> 918. Maximum Sum Circular Subarray (Medium)</li> <li> 152. Maximum Product Subarray (Medium)</li> <li> 978. Longest Turbulent Subarray (Medium)</li> <li> 1186. Maximum Subarray Sum with One Deletion (Medium)</li> </ul>"},{"location":"content/leetpattern/dp_kadane/#53-maximum-subarray","title":"53. Maximum Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, divide and conquer, dynamic programming 53. Maximum Subarray - Python Solution<pre><code>from typing import List\n\n\n# DP Kadane\ndef maxSubArrayDP(nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n\n    dp[0] = nums[0]\n    maxSum = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(\n            dp[i - 1] + nums[i],  # continue the previous subarray\n            nums[i],  # start a new subarray\n        )\n        maxSum = max(maxSum, dp[i])\n\n    return maxSum\n\n\n# Greedy\ndef maxSubArrayGreedy(nums: List[int]) -&gt; int:\n    max_sum = nums[0]\n    cur_sum = 0\n\n    for num in nums:\n        cur_sum = max(cur_sum + num, num)\n        max_sum = max(max_sum, cur_sum)\n\n    return max_sum\n\n\n# Prefix Sum\ndef maxSubArrayPrefixSum(nums: List[int]) -&gt; int:\n    prefix_sum = 0\n    prefix_sum_min = 0\n    res = float(\"-inf\")\n\n    for num in nums:\n        prefix_sum += num\n        res = max(res, prefix_sum - prefix_sum_min)\n        prefix_sum_min = min(prefix_sum_min, prefix_sum)\n\n    return res\n\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArrayDP(nums))  # 6\nprint(maxSubArrayGreedy(nums))  # 6\nprint(maxSubArrayPrefixSum(nums))  # 6\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/dp_kadane/#918-maximum-sum-circular-subarray","title":"918. Maximum Sum Circular Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, divide and conquer, dynamic programming, queue, monotonic queue 918. Maximum Sum Circular Subarray - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# DP - Kadane\ndef maxSubarraySumCircularKadane(nums: List[int]) -&gt; int:\n    max_sum = min_sum = nums[0]\n    max_cur = min_cur = 0\n    total = 0\n\n    for num in nums:\n        max_cur = max(max_cur + num, num)\n        min_cur = min(min_cur + num, num)\n        total += num\n\n        max_sum = max(max_sum, max_cur)\n        min_sum = min(min_sum, min_cur)\n\n    return max(max_sum, total - min_sum) if max_sum &gt; 0 else max_sum\n\n\n# Monotonic Queue\ndef maxSubarraySumCircularMQ(nums: List[int]) -&gt; int:\n    n = len(nums)\n    prefix_sum = [0] * (2 * n + 1)\n\n    for i in range(1, 2 * n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + nums[(i - 1) % n]\n\n    q = deque([0])\n    max_sum = float(\"-inf\")\n\n    for i in range(1, 2 * n + 1):\n        if q[0] &lt; i - n:\n            q.popleft()\n\n        max_sum = max(max_sum, prefix_sum[i] - prefix_sum[q[0]])\n\n        while q and prefix_sum[q[-1]] &gt;= prefix_sum[i]:\n            q.pop()\n\n        q.append(i)\n\n    return max_sum\n\n\nnums = [1, -2, 3, -2]\nprint(maxSubarraySumCircularKadane(nums))  # 3\nprint(maxSubarraySumCircularMQ(nums))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/dp_kadane/#152-maximum-product-subarray","title":"152. Maximum Product Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming 152. Maximum Product Subarray - Python Solution<pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxProduct(nums: List[int]) -&gt; int:\n    n = len(nums)\n    dp_max = [0 for _ in range(n)]\n    dp_min = [0 for _ in range(n)]\n\n    dp_max[0] = nums[0]\n    dp_min[0] = nums[0]\n    max_product = nums[0]\n\n    for i in range(1, n):\n        dp_max[i] = max(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n        dp_min[i] = min(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n\n        max_product = max(max_product, dp_max[i])\n\n    return max_product\n\n\nnums = [2, 3, -2, 4]\nprint(maxProduct(nums))  # 6\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/dp_kadane/#978-longest-turbulent-subarray","title":"978. Longest Turbulent Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, sliding window 978. Longest Turbulent Subarray - Python Solution<pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxTurbulenceSize(arr: List[int]) -&gt; int:\n    n = len(arr)\n    up = [1 for _ in range(n)]\n    down = [1 for _ in range(n)]\n    maxLen = 1\n\n    for i in range(1, n):\n        if arr[i - 1] &lt; arr[i]:\n            up[i] = down[i - 1] + 1\n            down[i] = 1\n        elif arr[i - 1] &gt; arr[i]:\n            down[i] = up[i - 1] + 1\n            up[i] = 1\n        else:\n            up[i] = 1\n            down[i] = 1\n\n        maxLen = max(maxLen, up[i], down[i])\n\n    return maxLen\n\n\narr = [9, 4, 2, 10, 7, 8, 8, 1, 9]\nprint(maxTurbulenceSize(arr))  # 5\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/dp_kadane/#1186-maximum-subarray-sum-with-one-deletion","title":"1186. Maximum Subarray Sum with One Deletion","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li>\u7075\u795e\uff1a\u6559\u4f60\u4e00\u6b65\u6b65\u601d\u8003\u52a8\u6001\u89c4\u5212 - \u4ece\u8bb0\u5fc6\u5316\u641c\u7d22\u5230\u9012\u63a8)</li> </ul> 1186. Maximum Subarray Sum with One Deletion - Python Solution<pre><code>from functools import cache\nfrom math import inf\nfrom typing import List\n\n\n# DP - Kadane\ndef maximumSum(arr: List[int]) -&gt; int:\n    dp0 = arr[0]\n    dp1 = 0\n    res = dp0\n\n    for i in range(1, len(arr)):\n        dp1 = max(dp1 + arr[i], dp0)  # delete previous element or not\n        dp0 = max(dp0, 0) + arr[i]  # delete current element or not\n        res = max(res, dp0, dp1)  # update result\n\n    return res\n\n\n# DP - Memoization\ndef maximumSumMemo(arr: List[int]) -&gt; int:\n    @cache\n    def dfs(i: int, j: int) -&gt; int:\n        if i &lt; 0:\n            return -inf\n        if j == 0:\n            return max(dfs(i - 1, 0), 0) + arr[i]\n        return max(dfs(i - 1, 1) + arr[i], dfs(i - 1, 0))\n\n    return max(max(dfs(i, 0), dfs(i, 1)) for i in range(len(arr)))\n\n\nif __name__ == \"__main__\":\n    arr = [1, -2, 0, 3]\n    assert maximumSum(arr) == 4\n    assert maximumSumMemo(arr) == 4\n</code></pre>"},{"location":"content/leetpattern/dp_lcs/","title":"DP LCS","text":""},{"location":"content/leetpattern/dp_lcs/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1143. Longest Common Subsequence (Medium)</li> <li> 72. Edit Distance (Medium)</li> <li> 115. Distinct Subsequences (Hard)</li> <li> 392. Is Subsequence (Easy)</li> <li> 583. Delete Operation for Two Strings (Medium)</li> <li> 674. Longest Continuous Increasing Subsequence (Easy)</li> <li> 718. Maximum Length of Repeated Subarray (Medium)</li> <li> 1035. Uncrossed Lines (Medium)</li> </ul>"},{"location":"content/leetpattern/dp_lcs/#1143-longest-common-subsequence","title":"1143. Longest Common Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming 1143. Longest Common Subsequence - Python Solution<pre><code>from functools import cache\n\n\n# DP - LCS\ndef longestCommonSubsequenceMemo(text1: str, text2: str) -&gt; int:\n    m, n = len(text1), len(text2)\n\n    @cache\n    def dfs(i: int, j: int) -&gt; int:\n        if i &lt; 0 or j &lt; 0:\n            return 0\n        if text1[i] == text2[j]:\n            return dfs(i - 1, j - 1) + 1\n        return max(dfs(i - 1, j), dfs(i, j - 1))\n\n    return dfs(m - 1, n - 1)\n\n\n# DP - LCS\ndef longestCommonSubsequenceTable(text1: str, text2: str) -&gt; int:\n    m, n = len(text1), len(text2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i - 1] == text2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    assert longestCommonSubsequenceMemo(\"abcde\", \"ace\") == 3\n    assert longestCommonSubsequenceTable(\"abcde\", \"ace\") == 3\n    assert longestCommonSubsequenceMemo(\"abc\", \"abc\") == 3\n    assert longestCommonSubsequenceTable(\"abc\", \"abc\") == 3\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/dp_lcs/#72-edit-distance","title":"72. Edit Distance","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming 72. Edit Distance - Python Solution<pre><code>from functools import cache\n\n\n# Recursive\ndef minDistanceDFS(word1: str, word2: str) -&gt; int:\n    n, m = len(word1), len(word2)\n\n    @cache\n    def dfs(i: int, j: int) -&gt; int:\n        if i &lt; 0:\n            return j + 1\n        if j &lt; 0:\n            return i + 1\n        if word1[i] == word2[j]:\n            return dfs(i - 1, j - 1)\n\n        return 1 + min(dfs(i - 1, j), dfs(i, j - 1), dfs(i - 1, j - 1))\n\n    return dfs(n - 1, m - 1)\n\n\n# Iterative\ndef minDistanceDP(word1: str, word2: str) -&gt; int:\n    m, n = len(word1), len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]  # no operation\n            else:\n                dp[i][j] = 1 + min(\n                    dp[i - 1][j],  # delete\n                    dp[i][j - 1],  # insert\n                    dp[i - 1][j - 1],  # replace\n                )\n    return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    word1 = \"horse\"\n    word2 = \"ros\"\n    print(minDistanceDFS(word1, word2))  # 3\n    print(minDistanceDP(word1, word2))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/dp_lcs/#115-distinct-subsequences","title":"115. Distinct Subsequences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming 115. Distinct Subsequences - Python Solution<pre><code>def numDistinct(s: str, t: str) -&gt; int:\n    m = len(s)\n    n = len(t)\n    dp = [[0] * (n + 1) for _ in range((m + 1))]\n\n    for i in range(m):\n        dp[i][0] = 1\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                # include and exclude s[i-1]\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]  # exclude s[i-1]\n\n    return dp[-1][-1]\n\n\ns = \"rabbbit\"\nt = \"rabbit\"\nprint(numDistinct(s, t))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/dp_lcs/#392-is-subsequence","title":"392. Is Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string, dynamic programming 392. Is Subsequence - Python Solution<pre><code># DP - LCS\ndef isSubsequenceLCS(s: str, t: str) -&gt; bool:\n    m = len(s)\n    n = len(t)\n\n    if m &gt; n:\n        return False\n\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    length = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = dp[i][j - 1]  # only delete t string\n\n            if length &lt; dp[i][j]:\n                length = dp[i][j]\n\n    return length == m\n\n\n# Two Pointers\ndef isSubsequenceTP(s: str, t: str) -&gt; bool:\n    i, j = 0, 0\n\n    while i &lt; len(s) and j &lt; len(t):\n        if s[i] == t[j]:\n            i += 1\n        j += 1\n\n    return i == len(s)\n\n\ns = \"abc\"\nt = \"ahbgdc\"\nprint(isSubsequenceLCS(s, t))  # True\nprint(isSubsequenceTP(s, t))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/dp_lcs/#583-delete-operation-for-two-strings","title":"583. Delete Operation for Two Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming 583. Delete Operation for Two Strings - Python Solution<pre><code># DP - LCS\ndef minDistance1(word1: str, word2: str) -&gt; int:\n    m = len(word1)\n    n = len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]  # no need to delete\n            else:\n                dp[i][j] = min(\n                    dp[i - 1][j] + 1,  # delete word1[i]\n                    dp[i][j - 1] + 1,  # delete word2[j]\n                    dp[i - 1][j - 1] + 2,  # delete both\n                )\n    return dp[-1][-1]\n\n\n# DP - LCS\ndef minDistance2(word1: str, word2: str) -&gt; int:\n    def LCS(word1: str, word2: str) -&gt; int:\n        m = len(word1)\n        n = len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        lcs = 0\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n                if lcs &lt; dp[i][j]:\n                    lcs = dp[i][j]\n        return lcs\n\n    lcs = LCS(word1, word2)\n    return len(word1) + len(word2) - 2 * lcs\n\n\nword1 = \"sea\"\nword2 = \"eat\"\nprint(minDistance1(word1, word2))  # 2\nprint(minDistance2(word1, word2))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/dp_lcs/#674-longest-continuous-increasing-subsequence","title":"674. Longest Continuous Increasing Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array 674. Longest Continuous Increasing Subsequence - Python Solution<pre><code>from typing import List\n\n\ndef findLengthOfLCIS(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return n\n\n    dp = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        if nums[i] &gt; nums[i - 1]:\n            dp[i] = dp[i - 1] + 1\n\n    return max(dp)\n\n\nprint(findLengthOfLCIS([1, 3, 5, 4, 7]))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/dp_lcs/#718-maximum-length-of-repeated-subarray","title":"718. Maximum Length of Repeated Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, dynamic programming, sliding window, rolling hash, hash function 718. Maximum Length of Repeated Subarray - Python Solution<pre><code>from typing import List\n\n\ndef findLength(nums1: List[int], nums2: List[int]) -&gt; int:\n    m = len(nums1)\n    n = len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    length = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if nums1[i - 1] == nums2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            if length &lt; dp[i][j]:\n                length = dp[i][j]\n\n    return length\n\n\nprint(findLength([1, 2, 3, 2, 1], [3, 2, 1, 4, 7]))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/dp_lcs/#1035-uncrossed-lines","title":"1035. Uncrossed Lines","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming 1035. Uncrossed Lines - Python Solution<pre><code>from typing import List\n\n\ndef maxUncrossedLines(nums1: List[int], nums2: List[int]) -&gt; int:\n    m = len(nums1)\n    n = len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    num = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if nums1[i - 1] == nums2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n            if num &lt; dp[i][j]:\n                num = dp[i][j]\n\n    return num\n\n\nprint(maxUncrossedLines([1, 4, 2], [1, 2, 4]))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/dp_lis/","title":"DP LIS","text":""},{"location":"content/leetpattern/dp_lis/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 300. Longest Increasing Subsequence (Medium)</li> <li> 673. Number of Longest Increasing Subsequence (Medium)</li> <li> 354. Russian Doll Envelopes (Hard)</li> <li> 960. Delete Columns to Make Sorted III (Hard)</li> <li> 1671. Minimum Number of Removals to Make Mountain Array (Hard)</li> <li> 941. Valid Mountain Array (Easy)</li> <li> 845. Longest Mountain in Array (Medium)</li> </ul>"},{"location":"content/leetpattern/dp_lis/#300-longest-increasing-subsequence","title":"300. Longest Increasing Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, dynamic programming 300. Longest Increasing Subsequence - Python Solution<pre><code>from functools import cache\nfrom typing import List\n\n\n# DP - LIS\ndef lengthOfLISMemo(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return n\n\n    @cache\n    def dfs(i: int) -&gt; int:\n        res = 0\n        for j in range(i):\n            if nums[j] &lt; nums[i]:\n                res = max(res, dfs(j))\n        return res + 1\n\n    return max(dfs(i) for i in range(n))\n\n\n# DP - LIS\ndef lengthOfLISTable(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return n\n\n    dp = [1 for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i):\n            if nums[i] &gt; nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\n\nif __name__ == \"__main__\":\n    assert lengthOfLISMemo([10, 9, 2, 5, 3, 7, 101, 18]) == 4\n    assert lengthOfLISTable([10, 9, 2, 5, 3, 7, 101, 18]) == 4\n    assert lengthOfLISMemo([0, 1, 0, 3, 2, 3]) == 4\n    assert lengthOfLISTable([0, 1, 0, 3, 2, 3]) == 4\n    assert lengthOfLISMemo([7, 7, 7, 7]) == 1\n    assert lengthOfLISTable([7, 7, 7, 7]) == 1\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/dp_lis/#673-number-of-longest-increasing-subsequence","title":"673. Number of Longest Increasing Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, binary indexed tree, segment tree 673. Number of Longest Increasing Subsequence - Python Solution<pre><code>from typing import List\n\n\n# DP - LIS\ndef findNumberOfLIS(nums: List[int]) -&gt; int:\n    if not nums:\n        return 0\n\n    n = len(nums)\n    dp = [1 for _ in range(n)]\n    counts = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] &gt; nums[j]:\n                if dp[j] + 1 &gt; dp[i]:\n                    dp[i] = dp[j] + 1\n                    counts[i] = counts[j]\n                elif dp[j] + 1 == dp[i]:\n                    counts[i] += counts[j]\n\n    longest = max(dp)\n    return sum(c for i, c in enumerate(counts) if dp[i] == longest)\n\n\nnums = [1, 3, 5, 4, 7]\nprint(findNumberOfLIS(nums))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/dp_lis/#354-russian-doll-envelopes","title":"354. Russian Doll Envelopes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, dynamic programming, sorting 354. Russian Doll Envelopes - Python Solution<pre><code>from typing import List\n\n\n# DP - LIS\ndef maxEnvelopes(envelopes: List[List[int]]) -&gt; int:\n    envelopes.sort(key=lambda x: (x[0], -x[1]))\n    dp = []\n\n    for w, h in envelopes:\n        left, right = 0, len(dp)\n        while left &lt; right:\n            mid = left + (right - left) // 2\n            if dp[mid][1] &lt; h:\n                left = mid + 1\n            else:\n                right = mid\n        if right == len(dp):\n            dp.append((w, h))\n        else:\n            dp[right] = (w, h)\n\n    return len(dp)\n\n\nenvelopes = [[5, 4], [6, 4], [6, 7], [2, 3]]\nprint(maxEnvelopes(envelopes))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/dp_lis/#960-delete-columns-to-make-sorted-iii","title":"960. Delete Columns to Make Sorted III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, dynamic programming 960. Delete Columns to Make Sorted III - Python Solution<pre><code>from typing import List\n\n\n# DP - LIS\ndef minDeletionSize(strs: List[str]) -&gt; int:\n    if not strs:\n        return 0\n\n    n = len(strs[0])\n    dp = [1 for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i):\n            if all(row[j] &lt;= row[i] for row in strs):\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return n - max(dp)\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/dp_lis/#1671-minimum-number-of-removals-to-make-mountain-array","title":"1671. Minimum Number of Removals to Make Mountain Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, dynamic programming, greedy 1671. Minimum Number of Removals to Make Mountain Array - Python Solution<pre><code>from typing import List\n\n\n# DP - LIS\ndef minimumMountainRemovals(nums: List[int]) -&gt; int:\n    n = len(nums)\n    lis = [1 for _ in range(n)]\n    lds = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] &gt; nums[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    for i in range(n - 2, -1, -1):\n        for j in range(n - 1, i, -1):\n            if nums[i] &gt; nums[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    maxLen = 0\n    for i in range(1, n - 1):\n        if lis[i] &gt; 1 and lds[i] &gt; 1:\n            maxLen = max(maxLen, lis[i] + lds[i] - 1)\n\n    return n - maxLen\n\n\nnums = [2, 1, 1, 5, 6, 2, 3, 1]\nprint(minimumMountainRemovals(nums))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/dp_lis/#941-valid-mountain-array","title":"941. Valid Mountain Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array 941. Valid Mountain Array - Python Solution<pre><code>from typing import List\n\n\n# Array\ndef validMountainArray(arr: List[int]) -&gt; bool:\n    n = len(arr)\n    i = 0\n\n    while i &lt; n - 1 and arr[i] &lt; arr[i + 1]:\n        i += 1\n\n    if i == 0 or i == n - 1:\n        return False\n\n    while i &lt; n - 1 and arr[i] &gt; arr[i + 1]:\n        i += 1\n\n    return i == n - 1\n\n\n# Left Right Pointers\ndef validMountainArrayLP(arr: List[int]) -&gt; bool:\n    n = len(arr)\n\n    if n &lt; 3:\n        return False\n\n    left, right = 0, n - 1\n\n    while left &lt; n - 1 and arr[left] &lt; arr[left + 1]:\n        left += 1\n\n    while right &gt; 0 and arr[right] &lt; arr[right - 1]:\n        right -= 1\n\n    return 0 &lt; left == right &lt; n - 1\n\n\narr = [0, 3, 2, 1]\nprint(validMountainArray(arr))  # True\nprint(validMountainArrayLP(arr))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/dp_lis/#845-longest-mountain-in-array","title":"845. Longest Mountain in Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, dynamic programming, enumeration 845. Longest Mountain in Array - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef longestMountain(arr: List[int]) -&gt; int:\n    n = len(arr)\n    res = 0\n    left = 0\n\n    while left &lt; n:\n        right = left\n\n        if right &lt; n - 1 and arr[right] &lt; arr[right + 1]:\n            while right &lt; n - 1 and arr[right] &lt; arr[right + 1]:\n                right += 1\n\n            if right &lt; n - 1 and arr[right] &gt; arr[right + 1]:\n                while right &lt; n - 1 and arr[right] &gt; arr[right + 1]:\n                    right += 1\n                res = max(res, right - left + 1)\n\n        left = max(right, left + 1)\n\n    return res\n\n\narr = [2, 1, 4, 7, 3, 2, 5]\nprint(longestMountain(arr))  # 5\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/dp_stock/","title":"DP Stock","text":""},{"location":"content/leetpattern/dp_stock/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 121. Best Time to Buy and Sell Stock (Easy)</li> <li> 122. Best Time to Buy and Sell Stock II (Medium)</li> <li> 123. Best Time to Buy and Sell Stock III (Hard)</li> <li> 188. Best Time to Buy and Sell Stock IV (Hard)</li> <li> 309. Best Time to Buy and Sell Stock with Cooldown (Medium)</li> <li> 714. Best Time to Buy and Sell Stock with Transaction Fee (Medium)</li> </ul>"},{"location":"content/leetpattern/dp_stock/#121-best-time-to-buy-and-sell-stock","title":"121. Best Time to Buy and Sell Stock","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li>Return the maximum profit that can be achieved from buying on one day and selling on another day.</li> </ul> 121. Best Time to Buy and Sell Stock - Python Solution<pre><code>from typing import List\n\n\n# Brute Force\ndef maxProfitBF(prices: List[int]) -&gt; int:\n    max_profit = 0\n    n = len(prices)\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_profit = max(max_profit, prices[j] - prices[i])\n\n    return max_profit\n\n\n# DP\ndef maxProfitDP(prices: List[int]) -&gt; int:\n    dp = [[0] * 2 for _ in range(len(prices))]\n    dp[0][0] = -prices[0]  # buy\n    dp[0][1] = 0  # sell\n\n    for i in range(1, len(prices)):\n        dp[i][0] = max(dp[i - 1][0], -prices[i])  # the lowest price to buy\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    max_profit = 0\n    seen_min = prices[0]\n\n    for i in range(1, len(prices)):\n        max_profit = max(max_profit, prices[i] - seen_min)\n        seen_min = min(seen_min, prices[i])\n\n    return max_profit\n\n\n# Fast Slow Pointers\ndef maxProfitFS(prices: List[int]) -&gt; int:\n    max_profit = 0\n    slow, fast = 0, 1\n\n    while fast &lt; len(prices):\n        if prices[fast] &gt; prices[slow]:\n            max_profit = max(max_profit, prices[fast] - prices[slow])\n        else:\n            slow = fast\n        fast += 1\n\n    return max_profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force|  O(n^2)|  O(1)   |\n# | DP         |  O(n)  |  O(n)   |\n# | Greedy     |  O(n)  |  O(1)   |\n# | Fast Slow  |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitBF(prices))  # 5\nprint(maxProfitDP(prices))  # 5\nprint(maxProfitGreedy(prices))  # 5\nprint(maxProfitFS(prices))  # 5\n</code></pre> 121. Best Time to Buy and Sell Stock - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int maxProfit(vector&lt;int&gt; &amp;prices)\n    {\n        if (prices.size() &lt;= 1)\n            return 0;\n\n        int seen_min = prices[0];\n        int res = 0;\n\n        for (int &amp;price : prices)\n        {\n            res = max(res, price - seen_min);\n            seen_min = min(seen_min, price);\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    vector&lt;int&gt; prices = {7, 1, 5, 3, 6, 4};\n    Solution obj;\n    cout &lt;&lt; obj.maxProfit(prices) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/leetpattern/dp_stock/#122-best-time-to-buy-and-sell-stock-ii","title":"122. Best Time to Buy and Sell Stock II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> <li>Return the maximum profit you can achieve.</li> </ul> 122. Best Time to Buy and Sell Stock II - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef maxProfitDP1(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 2 for _ in range(n)]\n    dp[0][0] = -prices[0]\n    dp[0][1] = 0\n\n    for i in range(1, n):\n        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i])\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# DP - Optimized\ndef maxProfitDP2(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    hold = -prices[0]\n    profit = 0\n\n    for i in range(1, n):\n        hold = max(hold, profit - prices[i])\n        profit = max(profit, hold + prices[i])\n\n    return profit\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    profit = 0\n\n    for i in range(1, len(prices)):\n        profit += max(prices[i] - prices[i - 1], 0)\n\n    return profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |     DP1    |  O(n)  |   O(n)  |\n# |     DP2    |  O(n)  |   O(1)  |\n# |   Greedy   |  O(n)  |   O(1)  |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitDP1(prices))  # 7\nprint(maxProfitDP2(prices))  # 7\nprint(maxProfitGreedy(prices))  # 7\n</code></pre>"},{"location":"content/leetpattern/dp_stock/#123-best-time-to-buy-and-sell-stock-iii","title":"123. Best Time to Buy and Sell Stock III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming 123. Best Time to Buy and Sell Stock III - Python Solution<pre><code>from typing import List\n\n\n# 1. DP\ndef maxProfitDP1(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 5 for _ in range(n)]\n\n    dp[0][0] = 0  # no transaction\n    dp[0][1] = -prices[0]  # buy 1\n    dp[0][2] = 0  # sell 1\n    dp[0][3] = -prices[0]  # buy 2\n    dp[0][4] = 0  # sell 2\n\n    for i in range(1, n):\n        dp[i][0] = dp[i - 1][0]\n        dp[i][1] = max(dp[i - 1][1], -prices[i])\n        dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i])\n        dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i])\n        dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i])\n\n    return dp[-1][4]\n\n\n# 2. DP - Optimized\ndef maxProfitDP2(prices: List[int]) -&gt; int:\n    b1, b2 = float(\"inf\"), float(\"inf\")\n    s1, s2 = 0, 0\n\n    for price in prices:\n        b1 = min(b1, price)\n        s1 = max(s1, price - b1)\n        b2 = min(b2, price - s1)\n        s2 = max(s2, price - b2)\n\n    return s2\n\n\nprices = [3, 3, 5, 0, 0, 3, 1, 4]\nprint(maxProfitDP1(prices))  # 6\nprint(maxProfitDP2(prices))  # 6\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/dp_stock/#188-best-time-to-buy-and-sell-stock-iv","title":"188. Best Time to Buy and Sell Stock IV","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming 188. Best Time to Buy and Sell Stock IV - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef maxProfit(k: int, prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * (2 * k + 1) for _ in range(n)]\n\n    for j in range(1, 2 * k, 2):\n        dp[0][j] = -prices[0]\n\n    for i in range(1, n):\n        for j in range(0, 2 * k - 1, 2):\n            dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i])\n            dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i])\n\n    return dp[-1][2 * k]\n\n\nk = 2\nprices = [2, 4, 1]\nprint(maxProfit(k, prices))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/dp_stock/#309-best-time-to-buy-and-sell-stock-with-cooldown","title":"309. Best Time to Buy and Sell Stock with Cooldown","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming 309. Best Time to Buy and Sell Stock with Cooldown - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef maxProfit(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 4 for _ in range(n)]\n\n    dp[0][0] = -prices[0]  # poessess\n    dp[0][1] = 0  # stay sold\n    dp[0][2] = 0  # sell\n    dp[0][3] = 0  # cooldown\n\n    for i in range(1, n):\n        dp[i][0] = max(\n            dp[i - 1][0],  # stay poessess\n            dp[i - 1][1] - prices[i],  # buy after stay sold\n            dp[i - 1][3] - prices[i],  # buy after cooldown\n        )\n        dp[i][1] = max(\n            dp[i - 1][1],  # stay sold\n            dp[i - 1][3],  # stay cooldown\n        )\n        dp[i][2] = dp[i - 1][0] + prices[i]\n        dp[i][3] = dp[i - 1][2]\n\n    return max(dp[-1])\n\n\nprices = [1, 2, 3, 0, 2]\nprint(maxProfit(prices))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/dp_stock/#714-best-time-to-buy-and-sell-stock-with-transaction-fee","title":"714. Best Time to Buy and Sell Stock with Transaction Fee","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> <li>Return the maximum profit you can achieve with the given transaction fee.</li> </ul> 714. Best Time to Buy and Sell Stock with Transaction Fee - Python Solution<pre><code>from typing import List\n\n\n# 1. DP\ndef maxProfitDP(prices: List[int], fee: int) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 2 for _ in range(n)]\n\n    dp[0][0] = -prices[0] - fee\n    dp[0][1] = 0\n\n    for i in range(1, n):\n        dp[i][0] = max(\n            dp[i - 1][0],  # hold\n            dp[i - 1][1] - prices[i] - fee,  # buy\n        )\n        dp[i][1] = max(\n            dp[i - 1][1],  # hold\n            dp[i - 1][0] + prices[i],  # sell\n        )\n\n    return max(dp[-1])\n\n\n# 2. Greedy\ndef maxProfitGreedy(prices: List[int], fee: int) -&gt; int:\n    n = len(prices)\n    if n == 0:\n        return 0\n\n    buy = prices[0]\n    profit = 0\n\n    for i in range(1, n):\n        if prices[i] &lt; buy:\n            buy = prices[i]\n        elif prices[i] &gt; buy + fee:\n            profit += prices[i] - buy - fee\n            buy = prices[i] - fee\n\n    return profit\n\n\nprices = [1, 3, 2, 8, 4, 9]\nfee = 2\nprint(maxProfitDP(prices, fee))  # 8\nprint(maxProfitGreedy(prices, fee))  # 8\n</code></pre>"},{"location":"content/leetpattern/dp_unbounded_knapsack/","title":"DP Unbounded Knapsack","text":""},{"location":"content/leetpattern/dp_unbounded_knapsack/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 139. Word Break (Medium)</li> <li> 279. Perfect Squares (Medium)</li> <li> 322. Coin Change (Medium)</li> <li> 518. Coin Change II (Medium)</li> <li> 377. Combination Sum IV (Medium)</li> </ul>"},{"location":"content/leetpattern/dp_unbounded_knapsack/#139-word-break","title":"139. Word Break","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, dynamic programming, trie, memoization 139. Word Break - Python Solution<pre><code>from typing import List\n\n\n# DP (Unbounded Knapsack)\ndef wordBreak(s: str, wordDict: List[str]) -&gt; bool:\n    n = len(s)\n    dp = [False for _ in range(n + 1)]\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for word in wordDict:\n            m = len(word)\n            if s[i - m : i] == word and dp[i - m]:\n                dp[i] = True\n    return dp[-1]\n\n\ns = \"leetcode\"\nwordDict = [\"leet\", \"code\"]\nprint(wordBreak(s, wordDict))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/dp_unbounded_knapsack/#279-perfect-squares","title":"279. Perfect Squares","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, breadth first search 279. Perfect Squares - Python Solution<pre><code>import math\n\n\n# DP - Knapsack Unbounded\ndef numSquares(n: int) -&gt; int:\n    dp = [float(\"inf\") for _ in range(n + 1)]\n    dp[0] = 0\n\n    for i in range(1, n + 1):\n        for j in range(1, int(math.sqrt(n)) + 1):\n            dp[i] = min(dp[i], dp[i - j**2] + 1)\n\n    return dp[n]\n\n\nn = 12\nprint(numSquares(n))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/dp_unbounded_knapsack/#322-coin-change","title":"322. Coin Change","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, breadth first search 322. Coin Change - Python Solution<pre><code>from typing import List\n\n\ndef coinChange(coins: List[int], amount: int) -&gt; int:\n    dp = [float(\"inf\") for _ in range(amount + 1)]\n\n    dp[0] = 0\n\n    for i in range(1, amount + 1):\n        for c in coins:\n            if i - c &gt;= 0:\n                dp[i] = min(dp[i], 1 + dp[i - c])\n\n    return dp[amount] if dp[amount] != float(\"inf\") else -1\n\n\ncoins = [1, 2, 5]\namount = 11\nprint(coinChange(coins, amount))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/dp_unbounded_knapsack/#518-coin-change-ii","title":"518. Coin Change II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming 518. Coin Change II - Python Solution<pre><code>from typing import List\n\n\ndef change(amount: int, coins: List[int]) -&gt; int:\n    dp = [0 for _ in range(amount + 1)]\n    dp[0] = 1\n\n    for i in range(len(coins)):\n        for j in range(coins[i], amount + 1):\n            dp[j] += dp[j - coins[i]]\n\n    return dp[-1]\n\n\namount = 5\ncoins = [1, 2, 5]\nprint(change(amount, coins))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/dp_unbounded_knapsack/#377-combination-sum-iv","title":"377. Combination Sum IV","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming 377. Combination Sum IV - Python Solution<pre><code>from typing import List\n\n\ndef combinationSum4(nums: List[int], target: int) -&gt; int:\n    dp = [0 for _ in range(target + 1)]\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for j in range(len(nums)):\n            if i - nums[j] &gt;= 0:\n                dp[i] += dp[i - nums[j]]\n\n        return dp[target]\n\n\nnums = [1, 2, 3]\ntarget = 4\nprint(combinationSum4(nums, target))  # 7\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/fast_slow_pointers/","title":"Fast Slow Pointers","text":""},{"location":"content/leetpattern/fast_slow_pointers/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 27. Remove Element (Easy)</li> <li> 26. Remove Duplicates from Sorted Array (Easy)</li> <li> 80. Remove Duplicates from Sorted Array II (Medium)</li> <li> 283. Move Zeroes (Easy)</li> <li> 1089. Duplicate Zeros (Easy)</li> <li> 287. Find the Duplicate Number (Medium)</li> </ul>"},{"location":"content/leetpattern/fast_slow_pointers/#27-remove-element","title":"27. Remove Element","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers</p> </li> <li>Remove all instances of a given value in-place.</li> </ul> 27. Remove Element - Python Solution<pre><code>from typing import List\n\n\n# Fast Slow Pointers\ndef removeElement(nums: List[int], val: int) -&gt; int:\n    fast, slow = 0, 0\n\n    while fast &lt; len(nums):\n        if nums[fast] != val:\n            nums[slow] = nums[fast]\n            slow += 1\n        fast += 1\n\n    return slow\n\n\nnums = [0, 1, 2, 2, 3, 0, 4, 2]\nval = 2\nprint(removeElement(nums, val))  # 5\n</code></pre> 27. Remove Element - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// Fast Slow Pointers\nint removeElement(vector&lt;int&gt;&amp; nums, int val) {\n    size_t n = nums.size();\n    size_t slow = 0, fast = 0;\n\n    while (fast &lt; n) {\n        if (nums[fast] != val) {\n            nums[slow] = nums[fast];\n            slow++;\n        }\n        fast++;\n    }\n    return (int)slow;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {3, 2, 2, 3};\n    int val = 3;\n    cout &lt;&lt; removeElement(nums, val) &lt;&lt; endl;  // 2\n    return 0;\n}\n</code></pre>"},{"location":"content/leetpattern/fast_slow_pointers/#26-remove-duplicates-from-sorted-array","title":"26. Remove Duplicates from Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers</p> </li> <li>Remove duplicates in-place.</li> </ul> 26. Remove Duplicates from Sorted Array - Python Solution<pre><code>from typing import List\n\n\ndef removeDuplicates(nums: List[int]) -&gt; int:\n    fast, slow = 1, 1\n\n    while fast &lt; len(nums):\n        if nums[fast] != nums[fast - 1]:\n            nums[slow] = nums[fast]\n            slow += 1\n        fast += 1\n\n    return slow\n\n\nnums = [1, 1, 2]\nprint(removeDuplicates(nums))  # 2\n</code></pre>"},{"location":"content/leetpattern/fast_slow_pointers/#80-remove-duplicates-from-sorted-array-ii","title":"80. Remove Duplicates from Sorted Array II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers</p> </li> <li>Allow at most two duplicates.</li> <li>fast pointer: explore the array</li> <li>slow pointer: point to the position to be replaced</li> </ul> 80. Remove Duplicates from Sorted Array II - Python Solution<pre><code>from typing import List\n\n\ndef removeDuplicates(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 2:\n        return len(nums)\n\n    fast, slow = 2, 2\n\n    while fast &lt; len(nums):\n        if nums[fast] != nums[slow - 2]:\n            nums[slow] = nums[fast]\n            slow += 1\n        fast += 1\n\n    return slow\n\n\nnums = [1, 1, 1, 2, 2, 3]\nprint(removeDuplicates(nums))\n</code></pre>"},{"location":"content/leetpattern/fast_slow_pointers/#283-move-zeroes","title":"283. Move Zeroes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers</p> </li> <li>Move all zeroes to the end of the array while maintaining the relative order of the non-zero elements.</li> </ul> 283. Move Zeroes - Python Solution<pre><code>from typing import List\n\n\ndef moveZeroes(nums: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    fast, slow = 0, 0\n\n    while fast &lt; len(nums):\n        if nums[fast] != 0:\n            nums[slow], nums[fast] = nums[fast], nums[slow]\n            slow += 1\n        fast += 1\n\n\nnums = [0, 1, 0, 3, 12]\nmoveZeroes(nums)\nprint(nums)  # [1, 3, 12, 0, 0]\n</code></pre> 283. Move Zeroes - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvoid moveZeroes(vector&lt;int&gt;&amp; nums) {\n    size_t n = nums.size();\n    size_t fast = 0, slow = 0;\n\n    while (fast &lt; n) {\n        if (nums[fast] != 0) {\n            swap(nums[slow], nums[fast]);\n            slow++;\n        }\n        fast++;\n    }\n}\n\nint main() {\n    vector&lt;int&gt; nums = {0, 1, 0, 3, 12};\n    moveZeroes(nums);\n    // [1, 3, 12, 0, 0]\n    for (size_t i = 0; i &lt; nums.size(); i++) {\n        cout &lt;&lt; nums[i] &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/leetpattern/fast_slow_pointers/#1089-duplicate-zeros","title":"1089. Duplicate Zeros","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers</p> </li> <li>Duplicate each occurrence of zero, shifting the remaining elements to the right.</li> </ul> 1089. Duplicate Zeros - Python Solution<pre><code>from typing import List\n\n\ndef duplicateZeros(arr: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify arr in-place instead.\n    \"\"\"\n    n = len(arr)\n    fast, slow = 0, 0\n\n    # First pass: find the position\n    # where the last element would be in the expanded array\n    while fast &lt; n:\n        if arr[slow] == 0:\n            fast += 1\n        slow += 1\n        fast += 1\n\n    slow -= 1\n    fast -= 1\n\n    # Second pass: move elements backwards\n    while slow &gt;= 0:\n        if fast &lt; n:\n            arr[fast] = arr[slow]\n\n        if arr[slow] == 0:\n            fast -= 1\n            if fast &lt; n:\n                arr[fast] = 0\n\n        slow -= 1\n        fast -= 1\n\n\narr = [1, 0, 2, 3, 0, 4, 5, 0]\nduplicateZeros(arr)\nprint(arr)  # [1, 0, 0, 2, 3, 0, 0, 4]\n</code></pre>"},{"location":"content/leetpattern/fast_slow_pointers/#287-find-the-duplicate-number","title":"287. Find the Duplicate Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, bit manipulation</p> </li> <li>Find the duplicate number in an array containing <code>n + 1</code> integers where each integer is between <code>1</code> and <code>n</code> inclusive.</li> <li>Floyd's Tortoise and Hare (Cycle Detection)<ul> <li> <ol> <li>Linked List Cycle</li> </ol> </li> <li> <ol> <li>Linked List Cycle II</li> </ol> </li> </ul> </li> <li>Time Complexity: O(n)</li> <li>Space Complexity: O(1)</li> </ul> <p>Example: <code>nums = [1, 3, 4, 2, 2]</code></p> 0 1 2 3 4 1 3 4 2 2 <pre><code>graph LR\n0((0)) --&gt; 1((1))\n1 --&gt; 3((3))\n2((2))--&gt; 4((4))\n3 --&gt; 2\n4 --&gt; 2</code></pre> 287. Find the Duplicate Number - Python Solution<pre><code>from typing import List\n\n\n# Floyd Cycle Detection Algorithm\ndef findDuplicate(nums: List[int]) -&gt; int:\n    fast, slow = nums[0], nums[0]\n\n    while True:\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n        if slow == fast:\n            break\n\n    slow = nums[0]\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[fast]\n\n    return slow\n\n\nnums = [1, 3, 4, 2, 2]\nprint(findDuplicate(nums))  # 2\n</code></pre>"},{"location":"content/leetpattern/graph_bellman_ford/","title":"Graph Bellman Ford","text":""},{"location":"content/leetpattern/graph_bellman_ford/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 743. Network Delay Time (Medium)</li> <li> 787. Cheapest Flights Within K Stops (Medium)</li> </ul>"},{"location":"content/leetpattern/graph_bellman_ford/#743-network-delay-time","title":"743. Network Delay Time","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, heap priority queue, shortest path</p> </li> <li>Return the minimum time taken to reach all nodes in a network.</li> </ul> <pre><code>graph LR\n1((1))\n2((2))\n3((3))\n4((4))\n2 --&gt; |1| 1\n2 --&gt; |1| 3\n3 --&gt; |1| 4</code></pre> <ul> <li>Shortest Path Problem: Find the shortest path between two vertices in a graph.</li> <li>Dijkstra's Algorithm<ul> <li>Shortest path algorithm</li> <li>Weighted graph (non-negative weights)</li> <li>Data Structure: Heap; Hash Set</li> <li>Time Complexity: O(E * logV)</li> <li>Space Complexity: O(V)</li> </ul> </li> </ul> 743. Network Delay Time - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Dijkstra - Set\ndef networkDelayTime1(times: List[List[int]], n: int, k: int) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    heap = [(0, k)]\n    visit = set()\n    t = 0\n\n    while heap:\n        w1, n1 = heapq.heappop(heap)\n        if n1 in visit:\n            continue\n\n        visit.add(n1)\n        t = w1\n\n        for n2, w2 in graph[n1]:\n            heapq.heappush(heap, (w1 + w2, n2))\n\n    return t if len(visit) == n else -1\n\n\n# Dijkstra - Dict\ndef networkDelayTime2(times: List[List[int]], n: int, k: int) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    heap = [(0, k)]\n    dist = defaultdict(int)\n\n    while heap:\n        w1, n1 = heapq.heappop(heap)\n        if n1 in dist:\n            continue\n\n        dist[n1] = w1\n\n        for n2, w2 in graph[n1]:\n            heapq.heappush(heap, (w1 + w2, n2))\n\n    return max(dist.values()) if len(dist) == n else -1\n\n\n# Bellman-Ford\ndef networkDelayTimeBF(times: List[List[int]], n: int, k: int) -&gt; int:\n    delay = {i: float(\"inf\") for i in range(1, n + 1)}\n    delay[k] = 0\n\n    for _ in range(n - 1):\n        for u, v, t in times:\n            delay[v] = min(delay[v], delay[u] + t)\n\n    max_delay = max(delay.values())\n    return max_delay if max_delay &lt; float(\"inf\") else -1\n\n\n# |--------------|-----------|--------|\n# | Approach     | Time      | Space  |\n# |--------------|-----------|--------|\n# | Dijkstra     | O(E*logV) | O(V+E) |\n# | Bellman-Ford | O(E*V)    | O(V)   |\n# |--------------|-----------|--------|\n\nif __name__ == \"__main__\":\n    times = [[2, 1, 1], [2, 3, 1], [3, 4, 1]]\n    n = 4\n    k = 2\n    print(networkDelayTime1(times, n, k))  # 2\n    print(networkDelayTime2(times, n, k))  # 2\n    print(networkDelayTimeBF(times, n, k))  # 2\n</code></pre>"},{"location":"content/leetpattern/graph_bellman_ford/#787-cheapest-flights-within-k-stops","title":"787. Cheapest Flights Within K Stops","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming, depth first search, breadth first search, graph, heap priority queue, shortest path</p> </li> <li>Return the cheapest price from <code>src</code> to <code>dst</code> with at most <code>K</code> stops.</li> </ul> <pre><code>graph TD\n0((0))\n1((1))\n2((2))\n3((3))\n0 --&gt; |100| 1\n1 --&gt; |600| 3\n1 --&gt; |100| 2\n2 --&gt; |100| 0\n2 --&gt; |200| 3</code></pre> 787. Cheapest Flights Within K Stops - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Bellman-Ford\ndef findCheapestPriceBF(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    prices = [float(\"inf\") for _ in range(n)]\n    prices[src] = 0\n\n    for _ in range(k + 1):\n        temp = prices[:]\n        for u, v, w in flights:\n            temp[v] = min(temp[v], prices[u] + w)\n        prices = temp\n\n    return prices[dst] if prices[dst] != float(\"inf\") else -1\n\n\n# Dijkstra\ndef findCheapestPriceDijkstra(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in flights:\n        graph[u].append((v, w))\n\n    heap = [(0, src, 0)]  # (price, city, stops)\n    visited = defaultdict(int)  # {city: stops}\n\n    while heap:\n        price, city, stops = heapq.heappop(heap)\n\n        if city == dst:\n            return price\n\n        if stops &gt; k:\n            continue\n\n        if city in visited and visited[city] &lt;= stops:\n            continue\n\n        visited[city] = stops\n\n        for neighbor, cost in graph[city]:\n            heapq.heappush(heap, (price + cost, neighbor, stops + 1))\n\n    return -1\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |Bellman-Ford|    O(k * E)      |  O(n)   |\n# | Dijkstra   | O(E * log(V))    |  O(n)   |\n# |------------|------------------|---------|\n\n\nn = 4\nflights = [[0, 1, 100], [1, 2, 100], [2, 0, 100], [1, 3, 600], [2, 3, 200]]\nsrc = 0\ndst = 3\nk = 1\nprint(findCheapestPriceBF(n, flights, src, dst, k))  # 700\nprint(findCheapestPriceDijkstra(n, flights, src, dst, k))  # 700\n</code></pre>"},{"location":"content/leetpattern/graph_bfs/","title":"Graph BFS","text":""},{"location":"content/leetpattern/graph_bfs/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 994. Rotting Oranges (Medium)</li> <li> 127. Word Ladder (Hard)</li> <li> 1466. Reorder Routes to Make All Paths Lead to the City Zero (Medium)</li> <li> 286. Walls and Gates (Medium) \ud83d\udc51</li> <li> 815. Bus Routes (Hard)</li> </ul>"},{"location":"content/leetpattern/graph_bfs/#994-rotting-oranges","title":"994. Rotting Oranges","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, breadth first search, matrix</p> </li> <li>Return the minimum number of minutes that must elapse until no cell has a fresh orange.</li> <li>Hint: Multi-source BFS to count the level.</li> </ul> <p></p> 994. Rotting Oranges - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef orangesRotting(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    fresh = 0\n    q = deque()\n    dirs = [[1, 0], [0, 1], [0, -1], [-1, 0]]\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 2:\n                q.append([i, j])\n            elif grid[i][j] == 1:\n                fresh += 1\n    res = 0\n\n    while q and fresh &gt; 0:\n        size = len(q)\n        for _ in range(size):\n            r, c = q.popleft()\n            for dr, dc in dirs:\n                nr, nc = dr + r, dc + c\n                if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and grid[nr][nc] == 1:\n                    q.append([nr, nc])\n                    grid[nr][nc] = 2\n                    fresh -= 1\n        res += 1\n\n    return res if fresh == 0 else -1\n\n\ngrid = [[2, 1, 1], [1, 1, 0], [0, 1, 1]]\nassert orangesRotting(grid) == 4\n</code></pre>"},{"location":"content/leetpattern/graph_bfs/#127-word-ladder","title":"127. Word Ladder","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, breadth first search</p> </li> <li>The most classic BFS problem.</li> <li>Return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.</li> <li>Approach: BFS</li> <li>Time Complexity: O(n * m^2)</li> <li>Space Complexity: O(n * m)</li> </ul> 127. Word Ladder - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef ladderLength(beginWord: str, endWord: str, wordList: List[str]) -&gt; int:\n    if endWord not in wordList:\n        return 0\n\n    n = len(beginWord)\n    graph = defaultdict(list)  # pattern: words\n    wordList.append(beginWord)\n\n    for word in wordList:\n        for i in range(n):\n            pattern = word[:i] + \"*\" + word[i + 1 :]\n            graph[pattern].append(word)\n\n    visited = set([beginWord])\n    q = deque([beginWord])\n    res = 1\n\n    while q:\n        size = len(q)\n        for _ in range(size):\n            word = q.popleft()\n            if word == endWord:\n                return res\n\n            for i in range(n):\n                pattern = word[:i] + \"*\" + word[i + 1 :]\n                for neighbor in graph[pattern]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        q.append(neighbor)\n        res += 1\n\n    return 0\n\n\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]\nprint(ladderLength(beginWord, endWord, wordList))  # 5\n</code></pre>"},{"location":"content/leetpattern/graph_bfs/#1466-reorder-routes-to-make-all-paths-lead-to-the-city-zero","title":"1466. Reorder Routes to Make All Paths Lead to the City Zero","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph</p> </li> <li></li> </ul> 1466. Reorder Routes to Make All Paths Lead to the City Zero - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef minReorderBFS(n: int, connections: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append((v, 1))  # go\n        graph[v].append((u, 0))  # come\n\n    changes = 0\n    q = deque([(0, -1)])\n\n    while q:\n        n1, d1 = q.popleft()\n\n        for n2, d2 in graph[n1]:\n            if n2 != d1:\n                changes += d2\n                q.append((n2, n1))\n\n    return changes\n\n\n# DFS\ndef minReorderDFS(n: int, connections: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append((v, 1))  # go\n        graph[v].append((u, 0))  # come\n\n    def dfs(n1, d1):\n        changes = 0\n        for n2, d2 in graph[n1]:\n            if n2 != d1:\n                changes += d2 + dfs(n2, n1)\n        return changes\n\n    return dfs(0, -1)\n\n\nn = 5\nconnections = [[1, 0], [1, 2], [3, 2], [3, 4]]\nprint(minReorderBFS(n, connections))  # 2\nprint(minReorderDFS(n, connections))  # 2\n</code></pre>"},{"location":"content/leetpattern/graph_bfs/#286-walls-and-gates","title":"286. Walls and Gates","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, breadth first search, matrix 286. Walls and Gates - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# Multi-Source BFS\ndef wallsAndGates(rooms: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify rooms in-place instead.\n    \"\"\"\n    m, n = len(rooms), len(rooms[0])\n    visited = set()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def addRoom(r, c):\n        if (\n            0 &lt;= r &lt; m\n            and 0 &lt;= c &lt; n\n            and (r, c) not in visited\n            and rooms[r][c] != -1\n        ):\n            q.append((r, c))\n            visited.add((r, c))\n\n    q = deque()\n    for r in range(m):\n        for c in range(n):\n            if rooms[r][c] == 0:\n                q.append((r, c))\n                visited.add((r, c))\n\n    dist = 0\n\n    while q:\n        for _ in range(len(q)):\n            r, c = q.popleft()\n            rooms[r][c] = dist\n\n            for dr, dc in directions:\n                addRoom(r + dr, c + dc)\n        dist += 1\n\n\nif __name__ == \"__main__\":\n    rooms = [\n        [2147483647, -1, 0, 2147483647],\n        [2147483647, 2147483647, 2147483647, -1],\n        [2147483647, -1, 2147483647, -1],\n        [0, -1, 2147483647, 2147483647],\n    ]\n    wallsAndGates(rooms)\n    assert rooms == [\n        [3, -1, 0, 1],\n        [2, 2, 1, -1],\n        [1, -1, 2, -1],\n        [0, -1, 3, 4],\n    ]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/graph_bfs/#815-bus-routes","title":"815. Bus Routes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, breadth first search 815. Bus Routes - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef numBusesToDestination(\n    routes: List[List[int]], source: int, target: int\n) -&gt; int:\n    if source == target:\n        return 0\n\n    graph = defaultdict(set)  # {stop: buses}\n    for buses, route in enumerate(routes):\n        for stop in route:\n            graph[stop].add(buses)\n\n    q = deque([(source, 0)])  # (stop, bus)\n    visited_stops = set([source])\n    visited_buses = set()\n\n    while q:\n        stop, bus = q.popleft()\n\n        if stop == target:\n            return bus\n\n        for buses in graph[stop]:\n            if buses not in visited_buses:\n                visited_buses.add(buses)\n                for next_stop in routes[buses]:\n                    if next_stop not in visited_stops:\n                        visited_stops.add(next_stop)\n                        q.append((next_stop, bus + 1))\n\n    return -1\n\n\nroutes = [[1, 2, 7], [3, 6, 7]]\nsource = 1\ntarget = 6\nprint(numBusesToDestination(routes, source, target))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/graph_coloring/","title":"Graph Coloring","text":""},{"location":"content/leetpattern/graph_coloring/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 785. Is Graph Bipartite? (Medium)</li> <li> 886. Possible Bipartition (Medium)</li> <li> 924. Minimize Malware Spread (Hard)</li> </ul>"},{"location":"content/leetpattern/graph_coloring/#785-is-graph-bipartite","title":"785. Is Graph Bipartite?","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> <li>Determine if a graph is bipartite.</li> </ul> <p>How to group</p> Uncolored Color 1 Color 2 Operation Method 1 -1 0 1 <code>1 - color</code> Method 2 0 1 -1 <code>-color</code> 785. Is Graph Bipartite? - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef isBipartiteBFS(graph: List[List[int]]) -&gt; bool:\n    n = len(graph)\n    # -1: not colored; 0: blue; 1: red\n    color = [-1 for _ in range(n)]\n\n    def bfs(node):\n        q = deque([node])\n        color[node] = 0\n\n        while q:\n            cur = q.popleft()\n\n            for neighbor in graph[cur]:\n                if color[neighbor] == -1:\n                    color[neighbor] = 1 - color[cur]\n                    q.append(neighbor)\n                elif color[neighbor] == color[cur]:\n                    return False\n        return True\n\n    for i in range(n):\n        if color[i] == -1:\n            if not bfs(i):\n                return False\n\n    return True\n\n\n# DFS\ndef isBipartiteDFS(graph: List[List[int]]) -&gt; bool:\n    n = len(graph)\n    # -1: not colored; 0: blue; 1: red\n    color = [-1] * n\n\n    def dfs(node, c):\n        color[node] = c\n        for neighbor in graph[node]:\n            if color[neighbor] == -1:\n                if not dfs(neighbor, 1 - c):\n                    return False\n            elif color[neighbor] == c:\n                return False\n        return True\n\n    for i in range(n):\n        if color[i] == -1:\n            if not dfs(i, 0):\n                return False\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |    BFS     | O(V+E) |  O(V)   |\n# |    DFS     | O(V+E) |  O(V)   |\n# |------------|--------|---------|\n\n\ngraph = [[1, 2, 3], [0, 2], [0, 1, 3], [0, 2]]\nprint(isBipartiteBFS(graph))  # False\nprint(isBipartiteDFS(graph))  # False\n</code></pre>"},{"location":"content/leetpattern/graph_coloring/#886-possible-bipartition","title":"886. Possible Bipartition","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> <li>Determine if a graph can be divided into two groups such that no two nodes of the same group are connected.</li> </ul> 886. Possible Bipartition - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef possibleBipartitionBFS(n: int, dislikes: List[List[int]]) -&gt; bool:\n    group = {i: -1 for i in range(1, n + 1)}\n\n    # Undirected graph\n    graph = {i: [] for i in range(1, n + 1)}\n    for i, j in dislikes:\n        graph[i].append(j)\n        graph[j].append(i)\n\n    def bfs(person):\n        q = deque([person])\n        group[person] = 0\n\n        while q:\n            cur = q.popleft()\n\n            for neighbor in graph[cur]:\n                if group[neighbor] == -1:\n                    group[neighbor] = 1 - group[cur]\n                    q.append(neighbor)\n                elif group[neighbor] == group[cur]:\n                    return False\n        return True\n\n    for i in range(1, n + 1):\n        if group[i] == -1:\n            if not bfs(i):\n                return False\n    return True\n\n\n# DFS\ndef possibleBipartitionDFS(n: int, dislikes: List[List[int]]) -&gt; bool:\n    group = {i: -1 for i in range(1, n + 1)}\n    graph = {i: [] for i in range(1, n + 1)}\n    for i, j in dislikes:\n        graph[i].append(j)\n        graph[j].append(i)\n\n    def dfs(person, g):\n        group[person] = g\n\n        for neighbor in graph[person]:\n            if group[neighbor] == -1:\n                if not dfs(neighbor, 1 - g):\n                    return False\n            elif group[neighbor] == g:\n                return False\n\n        return True\n\n    for i in range(1, n + 1):\n        if group[i] == -1:\n            if not dfs(i, 0):\n                return False\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |    BFS     | O(V+E) |  O(V+E) |\n# |    DFS     | O(V+E) |  O(V+E) |\n# |------------|--------|---------|\n\n\nn = 4\ndislikes = [[1, 2], [1, 3], [2, 4]]\nprint(possibleBipartitionBFS(n, dislikes))  # True\nprint(possibleBipartitionDFS(n, dislikes))  # True\n</code></pre>"},{"location":"content/leetpattern/graph_coloring/#924-minimize-malware-spread","title":"924. Minimize Malware Spread","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, depth first search, breadth first search, union find, graph 924. Minimize Malware Spread - Python Solution<pre><code>from typing import List\n\n\n# Coloring\ndef minMalwareSpread(graph: List[List[int]], initial: List[int]) -&gt; int:\n    n = len(graph)\n    initial = set(initial)\n\n    def dfs(x):\n        visited.add(x)\n        mark[x] = 1\n        if x in initial:\n            v.append(x)\n        for nxt in range(n):\n            if graph[x][nxt] and nxt != x and not mark[nxt]:\n                dfs(nxt)\n\n    ans = min(initial)\n    mx = 0\n    mark = [0] * n\n    for i in range(n):\n        if not mark[i]:\n            visited = set()\n            v = []\n            dfs(i)\n            if len(v) == 1 and (\n                len(visited) &gt; mx or len(visited) == mx and v[0] &lt; ans\n            ):\n                ans, mx = v[0], len(visited)\n    return ans\n\n\ngraph = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]\ninitial = [0, 1]\nprint(minMalwareSpread(graph, initial))  # 0\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/graph_flood_fill/","title":"Graph Flood Fill","text":""},{"location":"content/leetpattern/graph_flood_fill/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 733. Flood Fill (Easy)</li> <li> 200. Number of Islands (Medium)</li> <li> 695. Max Area of Island (Medium)</li> <li> 463. Island Perimeter (Easy)</li> <li> 130. Surrounded Regions (Medium)</li> <li> 417. Pacific Atlantic Water Flow (Medium)</li> <li> 827. Making A Large Island (Hard)</li> </ul>"},{"location":"content/leetpattern/graph_flood_fill/#733-flood-fill","title":"733. Flood Fill","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, matrix</p> </li> <li>Replace all the pixels of the same color starting from the given pixel.</li> <li>In other words, find the connected component of the starting pixel and change the color of all the pixels in that component.</li> <li>Edge cases: If the starting pixel is already the target color, return the image as it is.</li> <li>Flood Fill is essentially a graph traversal algorithm (like BFS or DFS) applied to matrices (2D grids).   It checks adjacent cells (up, down, left, right) of a starting point to determine whether they belong to the same region.   Typically, it involves modifying or marking the cells that belong to the same connected component.</li> </ul> <p></p> <p></p> 1 1 1 1 1 0 1 0 1 1 1 1 1 2 0 1 0 1 1 2 1 2 2 0 1 0 1 2 2 2 2 2 0 2 0 1 733. Flood Fill - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef floodFillDFS(\n    image: List[List[int]], sr: int, sc: int, color: int\n) -&gt; List[List[int]]:\n\n    org = image[sr][sc]\n    m, n = len(image), len(image[0])\n\n    if org == color:\n        return image\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or image[r][c] != org:\n            return None\n\n        image[r][c] = color\n\n        dfs(r - 1, c)\n        dfs(r + 1, c)\n        dfs(r, c - 1)\n        dfs(r, c + 1)\n\n    dfs(sr, sc)\n\n    return image\n\n\n# BFS\ndef floodFillBFS(\n    image: List[List[int]], sr: int, sc: int, color: int\n) -&gt; List[List[int]]:\n\n    org = image[sr][sc]\n    m, n = len(image), len(image[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    if org == color:\n        return image\n\n    q = deque([(sr, sc)])\n\n    while q:\n        r, c = q.popleft()\n        image[r][c] = color\n\n        for dr, dc in dirs:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and image[nr][nc] == org:\n                q.append((nr, nc))\n\n    return image\n\n\nimage = [[1, 1, 1], [1, 1, 0], [1, 0, 1]]\nsr = 1\nsc = 1\n\nprint(floodFillDFS(image, sr, sc, 2))\n# [[2, 2, 2], [2, 2, 0], [2, 0, 1]]\nprint(floodFillBFS(image, sr, sc, 2))\n# [[2, 2, 2], [2, 2, 0], [2, 0, 1]]\n</code></pre>"},{"location":"content/leetpattern/graph_flood_fill/#200-number-of-islands","title":"200. Number of Islands","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix</p> </li> <li>Count the number of islands in a 2D grid.</li> <li>Method 1: DFS</li> <li> <p>Method 2: BFS (use a queue to traverse the grid)</p> </li> <li> <p>How to keep track of visited cells?</p> <ol> <li>Mark the visited cell as <code>0</code> (or any other value) to avoid revisiting it.</li> <li>Use a set to store the visited cells.</li> </ol> </li> <li> <p>Steps:</p> <ol> <li>Init: variables</li> <li>DFS/BFS: starting from the cell with <code>1</code>, turn all the connected <code>1</code>s to <code>0</code>.</li> <li>Traverse the grid, and if the cell is <code>1</code>, increment the count and call DFS/BFS.</li> </ol> </li> </ul> <p></p> 200. Number of Islands - Python Solution<pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef numIslandsDFS(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    res = 0\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] != \"1\":\n            return\n\n        grid[r][c] = \"2\"\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                dfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Set\ndef numIslandsBFS1(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == \"0\"\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\" and (r, c) not in visited:\n                visited.add((r, c))\n                bfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = dr + row, dc + col\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] != \"1\"\n                ):\n                    continue\n                grid[nr][nc] = \"2\"\n                q.append((nr, nc))\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == \"1\":\n                grid[i][j] = \"2\"\n                bfs(i, j)\n                res += 1\n\n    return res\n\n\ngrid = [\n    [\"1\", \"1\", \"1\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"0\", \"0\", \"0\", \"0\", \"0\"],\n]\n\nprint(numIslandsDFS(deepcopy(grid)))  # 1\nprint(numIslandsBFS1(deepcopy(grid)))  # 1\nprint(numIslandsBFS2(deepcopy(grid)))  # 1\n</code></pre> 200. Number of Islands - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\nprivate:\n    void dfs(vector&lt;vector&lt;char&gt;&gt; &amp;grid, int r, int c)\n    {\n        int row = grid.size();\n        int col = grid[0].size();\n\n        if (r &lt; 0 || r &gt;= row || c &lt; 0 || c &gt;= col || grid[r][c] != '1')\n        {\n            return;\n        }\n        grid[r][c] = '0';\n\n        dfs(grid, r - 1, c);\n        dfs(grid, r + 1, c);\n        dfs(grid, r, c - 1);\n        dfs(grid, r, c + 1);\n    }\n\npublic:\n    int numIslands(vector&lt;vector&lt;char&gt;&gt; &amp;grid)\n    {\n        int m = grid.size(), n = grid[0].size();\n        int res = 0;\n        for (int i = 0; i &lt; m; i++)\n        {\n            for (int j = 0; j &lt; n; j++)\n            {\n                if (grid[i][j] == '1')\n                {\n                    res++;\n                    dfs(grid, i, j);\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    Solution s;\n    vector&lt;vector&lt;char&gt;&gt; grid = {\n        {'1', '1', '0', '0', '0'},\n        {'1', '1', '0', '0', '0'},\n        {'0', '0', '1', '0', '0'},\n        {'0', '0', '0', '1', '1'}};\n    cout &lt;&lt; s.numIslands(grid) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/leetpattern/graph_flood_fill/#695-max-area-of-island","title":"695. Max Area of Island","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix 695. Max Area of Island - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef maxAreaOfIslandDFS(grid: List[List[int]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] == 0:\n            return 0\n\n        grid[r][c] = 0\n\n        return (\n            1 + dfs(r + 1, c) + dfs(r - 1, c) + dfs(r, c + 1) + dfs(r, c - 1)\n        )\n\n    res = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                res = max(res, dfs(i, j))\n    return res\n\n\n# BFS\ndef maxAreaOfIslandBFS1(grid: List[List[int]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        area = 0\n\n        while q:\n            row, col = q.popleft()\n            area += 1\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == 0\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n        return area\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1 and (r, c) not in visited:\n                visited.add((r, c))\n                res = max(res, bfs(r, c))\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        area = 0\n\n        while q:\n            row, col = q.popleft()\n            area += 1\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n\n                if nr &lt; 0 or nr &gt;= m or nc &lt; 0 or nc &gt;= n or grid[nr][nc] == 0:\n                    continue\n\n                q.append((nr, nc))\n                grid[nr][nc] = 0\n\n        return area\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                grid[r][c] = 0\n                res = max(res, bfs(r, c))\n\n    return res\n\n\ngrid = [\n    [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0],\n    [0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],\n]\nprint(maxAreaOfIslandDFS(grid))  # 6\nprint(maxAreaOfIslandBFS1(grid))  # 6\nprint(numIslandsBFS2(grid))  # 6\n</code></pre></p> </li> </ul> 695. Max Area of Island - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {\n        int m = grid.size(), n = grid[0].size();\n        int res = 0;\n\n        auto dfs = [&amp;](auto&amp;&amp; self, int r, int c) -&gt; int {\n            if (r &lt; 0 || r &gt;= m || c &lt; 0 || c &gt;= n || grid[r][c] != 1) {\n                return 0;\n            }\n            grid[r][c] = 0;\n\n            return 1 + self(self, r - 1, c) + self(self, r, c - 1) +\n                   self(self, r + 1, c) + self(self, r, c + 1);\n        };\n        for (int i = 0; i &lt; m; i++) {\n            for (int j = 0; j &lt; n; j++) {\n                if (grid[i][j] == 1) {\n                    int area = dfs(dfs, i, j);\n                    res = max(res, area);\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution s;\n    vector&lt;vector&lt;int&gt;&gt; grid = {{0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},\n                                {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},\n                                {0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},\n                                {0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0},\n                                {0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0},\n                                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0},\n                                {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},\n                                {0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0}};\n    cout &lt;&lt; s.maxAreaOfIsland(grid) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/leetpattern/graph_flood_fill/#463-island-perimeter","title":"463. Island Perimeter","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, matrix 463. Island Perimeter - Python Solution<pre><code>from typing import List\n\n\n# DFS\ndef islandPerimeterDFS(grid: List[List[int]]) -&gt; int:\n    # TC: O(m * n)\n    # SC: O(m * n)\n\n    visited = set()\n    m, n = len(grid), len(grid[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def dfs(r, c):\n        if (r, c) in visited or grid[r][c] == 0:\n            return 0\n        visited.add((r, c))\n        perimeter = 0\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if nr not in range(m) or nc not in range(n) or grid[nr][nc] == 0:\n                perimeter += 1\n            else:\n                perimeter += dfs(nr, nc)\n\n        return perimeter\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                return dfs(r, c)\n    return 0\n\n\ndef islandPerimeter(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    perimeter = 0\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                perimeter += 4\n\n                if r &gt; 0 and grid[r - 1][c] == 1:\n                    perimeter -= 2\n\n                if c &gt; 0 and grid[r][c - 1] == 1:\n                    perimeter -= 2\n\n    return perimeter\n\n\ngrid = [[0, 1, 0, 0], [1, 1, 1, 0], [0, 1, 0, 0], [1, 1, 0, 0]]\nprint(islandPerimeterDFS(grid))  # 16\nprint(islandPerimeter(grid))  # 16\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/graph_flood_fill/#130-surrounded-regions","title":"130. Surrounded Regions","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix 130. Surrounded Regions - Python Solution<pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef solveDFS(board: List[List[str]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n    if not board and not board[0]:\n        return None\n\n    m, n = len(board), len(board[0])\n\n    def capture(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or board[r][c] != \"O\":\n            return None\n\n        board[r][c] = \"T\"\n        capture(r + 1, c)\n        capture(r - 1, c)\n        capture(r, c + 1)\n        capture(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\" and (r in [0, m - 1] or c in [0, n - 1]):\n                capture(r, c)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\":\n                board[r][c] = \"X\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"T\":\n                board[r][c] = \"O\"\n\n\n# BFS\ndef solveBFS(board: List[List[str]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n    if not board and not board[0]:\n        return None\n\n    m, n = len(board), len(board[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def capture(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr = row + dr\n                nc = col + dc\n                if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and board[nr][nc] == \"O\":\n                    board[nr][nc] = \"T\"\n                    q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\" and (r in [0, m - 1] or c in [0, n - 1]):\n                board[r][c] = \"T\"\n                capture(r, c)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\":\n                board[r][c] = \"X\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"T\":\n                board[r][c] = \"O\"\n\n\nif __name__ == \"__main__\":\n    board = [\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"O\", \"O\", \"X\"],\n        [\"X\", \"X\", \"O\", \"X\"],\n        [\"X\", \"O\", \"X\", \"X\"],\n    ]\n\n    b = deepcopy(board)\n    solveDFS(b)\n    assert b == [\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"O\", \"X\", \"X\"],\n    ]\n\n    b = deepcopy(board)\n    solveBFS(b)\n    assert b == [\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"O\", \"X\", \"X\"],\n    ]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/graph_flood_fill/#417-pacific-atlantic-water-flow","title":"417. Pacific Atlantic Water Flow","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, matrix 417. Pacific Atlantic Water Flow - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef pacificAtlanticDFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(r, c, visited, prev_height):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or heights[r][c] &lt; prev_height\n            or (r, c) in visited\n        ):\n            return None\n\n        visited.add((r, c))\n        height = heights[r][c]\n        for dr, dc in directions:\n            dfs(dr + r, dc + c, visited, height)\n\n    for c in range(n):\n        dfs(0, c, pac, heights[0][c])\n        dfs(m - 1, c, atl, heights[m - 1][c])\n\n    for r in range(m):\n        dfs(r, 0, pac, heights[r][0])\n        dfs(r, n - 1, atl, heights[r][n - 1])\n\n    return list(pac &amp; atl)\n\n\n# BFS\ndef pacificAtlanticBFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def bfs(r, c, visited):\n        q = deque([(r, c)])\n        visited.add((r, c))\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr in range(m)\n                    and nc in range(n)\n                    and heights[row][col] &lt;= heights[nr][nc]\n                    and (nr, nc) not in visited\n                ):\n                    q.append((nr, nc))\n                    visited.add((nr, nc))\n\n    for c in range(n):\n        bfs(0, c, pac)  # top\n        bfs(m - 1, c, atl)  # bottom\n\n    for r in range(m):\n        bfs(r, 0, pac)  # left\n        bfs(r, n - 1, atl)  # right\n\n    return list(pac &amp; atl)\n\n\nheights = [\n    [1, 2, 2, 3, 5],\n    [3, 2, 3, 4, 4],\n    [2, 4, 5, 3, 1],\n    [6, 7, 1, 4, 5],\n    [5, 1, 1, 2, 4],\n]\nprint(pacificAtlanticDFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\nprint(pacificAtlanticBFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/graph_flood_fill/#827-making-a-large-island","title":"827. Making A Large Island","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix 827. Making A Large Island - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Flood Fill\ndef largestIsland(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    areas = defaultdict(int)  # {index: area}\n    index = 2\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(r, c, index):\n        area = 1\n        grid[r][c] = index\n        for dr, dc in dirs:\n            nr, nc = r + dr, c + dc\n            if 0 &lt;= nr &lt; n and 0 &lt;= nc &lt; n and grid[nr][nc] == 1:\n                area += dfs(nr, nc, index)\n        return area\n\n    for r in range(n):\n        for c in range(n):\n            if grid[r][c] == 1:\n                areas[index] = dfs(r, c, index)\n                index += 1\n\n    if not areas:\n        return 1\n\n    res = max(areas.values())\n\n    for r in range(n):\n        for c in range(n):\n            if grid[r][c] == 0:\n                connected = set()\n                area = 1\n                for dr, dc in dirs:\n                    nr, nc = r + dr, c + dc\n                    if 0 &lt;= nr &lt; n and 0 &lt;= nc &lt; n and grid[nr][nc] &gt; 1:\n                        connected.add(grid[nr][nc])\n\n                for island in connected:\n                    area += areas[island]\n                res = max(res, area)\n\n    return res\n\n\ngrid = [[1, 0], [0, 1]]\nprint(largestIsland(grid))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/graph_minimum_spanning_tree/","title":"Graph Minimum Spanning Tree","text":""},{"location":"content/leetpattern/graph_minimum_spanning_tree/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1584. Min Cost to Connect All Points (Medium)</li> <li> 1135. Connecting Cities With Minimum Cost (Medium) \ud83d\udc51</li> <li> 1168. Optimize Water Distribution in a Village (Hard) \ud83d\udc51</li> <li> 1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree (Hard)</li> <li> 1631. Path With Minimum Effort (Medium)</li> <li> 1579. Remove Max Number of Edges to Keep Graph Fully Traversable (Hard)</li> </ul>"},{"location":"content/leetpattern/graph_minimum_spanning_tree/#1584-min-cost-to-connect-all-points","title":"1584. Min Cost to Connect All Points","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, union find, graph, minimum spanning tree</p> </li> <li>Tree: a connected acyclic graph</li> <li>Spanning Tree: a subgraph that is a tree and connects all the vertices together</li> <li>Minimum Spanning Tree (MST): a spanning tree with the minimum possible sum of edge weights</li> <li>Prim's Algorithm</li> <li>Data Structure: Heap</li> <li>Time Complexity: O(E * logV)</li> <li>Space Complexity: O(V + E)</li> <li>Kruskal's Algorithm</li> <li>Union Find</li> <li>Time Complexity: O(E * logV)</li> <li>Space Complexity: O(V + E)</li> </ul> 1584. Min Cost to Connect All Points - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minCostConnectPointsPrim(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    graph = defaultdict(list)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            dist = abs(x1 - x2) + abs(y1 - y2)\n            graph[i].append((dist, j))\n            graph[j].append((dist, i))\n\n    cost = 0\n    heap = [(0, 0)]  # (cost, node)\n    visited = set()\n\n    while heap:\n        d1, n1 = heapq.heappop(heap)\n        if n1 in visited:\n            continue\n        visited.add(n1)\n        cost += d1\n\n        for d2, n2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (d2, n2))\n\n    return cost\n\n\n# Kruskal\ndef minCostConnectPointsKruskal(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    par = {i: i for i in range(n)}\n    rank = {i: 0 for i in range(n)}\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 == p2:\n            return False\n\n        if rank[p1] &gt; rank[p2]:\n            par[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n        else:\n            par[p2] = p1\n            rank[p1] += 1\n\n        return True\n\n    heap = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            dist = abs(x1 - x2) + abs(y1 - y2)\n            heapq.heappush(heap, (dist, i, j))\n\n    cost = 0\n    while heap:\n        d, n1, n2 = heapq.heappop(heap)\n        if union(n1, n2):\n            cost += d\n\n    return cost\n\n\nif __name__ == \"__main__\":\n    points = [[0, 0], [2, 2], [3, 10], [5, 2], [7, 0]]\n    print(minCostConnectPointsPrim(points))  # 20\n    print(minCostConnectPointsKruskal(points))  # 20\n</code></pre>"},{"location":"content/leetpattern/graph_minimum_spanning_tree/#1135-connecting-cities-with-minimum-cost","title":"1135. Connecting Cities With Minimum Cost","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: union find, graph, heap priority queue, minimum spanning tree 1135. Connecting Cities With Minimum Cost - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minimumCost(n: int, connections: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, c in connections:\n        graph[u].append((c, v))\n        graph[v].append((c, u))\n\n    cost = 0\n    heap = [(0, 1)]  # (cost, node)\n    visited = set()\n\n    while heap:\n        c1, n1 = heapq.heappop(heap)\n\n        if n1 in visited:\n            continue\n\n        visited.add(n1)\n\n        cost += c1\n\n        for c2, n2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (c2, n2))\n\n    return cost if len(visited) == n else -1\n\n\nn = 3\nconnections = [[1, 2, 5], [1, 3, 6], [2, 3, 1]]\nprint(minimumCost(n, connections))  # 6\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/graph_minimum_spanning_tree/#1168-optimize-water-distribution-in-a-village","title":"1168. Optimize Water Distribution in a Village","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: union find, graph, heap priority queue, minimum spanning tree</p> </li> <li> <p></p> </li> <li> <p></p> </li> </ul> 1168. Optimize Water Distribution in a Village - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minCostToSupplyWater1(\n    n: int, wells: List[int], pipes: List[List[int]]\n) -&gt; int:\n    graph = defaultdict(list)\n\n    for h1, h2, cost in pipes:\n        graph[h1].append((h2, cost))\n        graph[h2].append((h1, cost))\n\n    # Add the cost of the wells to the graph (house 0)\n    for i in range(n):\n        graph[0].append((i + 1, wells[i]))\n        graph[i + 1].append((0, wells[i]))\n\n    visited = set([0])\n    heap = [(cost, dest) for dest, cost in graph[0]]\n    heapq.heapify(heap)\n\n    cost = 0\n\n    while heap:\n        c1, n1 = heapq.heappop(heap)\n        if n1 in visited:\n            continue\n        visited.add(n1)\n        cost += c1\n\n        for n2, c2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (c2, n2))\n\n    return cost\n\n\n# Kruskal\ndef minCostToSupplyWater2(\n    n: int, wells: List[int], pipes: List[List[int]]\n) -&gt; int:\n    par = list(range(n + 1))\n    rank = [0] * (n + 1)\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            if rank[p1] &lt; rank[p2]:\n                par[p1] = p2\n            elif rank[p1] &gt; rank[p2]:\n                par[p2] = p1\n            else:\n                par[p1] = p2\n                rank[p2] += 1\n            return True\n        return False\n\n    graph = [(c, 0, i + 1) for i, c in enumerate(wells)]\n    for h1, h2, c in pipes:\n        graph.append((c, h1, h2))\n\n    graph.sort()\n\n    cost = 0\n\n    for c, h1, h2 in graph:\n        if union(h1, h2):\n            cost += c\n\n    return cost\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |    Prim    | O((V + E) log V) | O(V + E)|\n# |  Kruskal   |     O(E log E)   | O(V + E)|\n# |------------|------------------|---------|\n\n\nn = 3\nwells = [1, 2, 2]\npipes = [[1, 2, 1], [2, 3, 1]]\nprint(minCostToSupplyWater1(n, wells, pipes))  # 3\nprint(minCostToSupplyWater2(n, wells, pipes))  # 3\n</code></pre>"},{"location":"content/leetpattern/graph_minimum_spanning_tree/#1489-find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree","title":"1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: union find, graph, sorting, minimum spanning tree, strongly connected component 1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree - Python Solution<pre><code>from typing import List\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [1 for _ in range(n)]\n        self.part = n\n\n    def find(self, n):\n        p = self.parent[n]\n        while p != self.parent[p]:\n            self.parent[p] = self.parent[self.parent[p]]\n            p = self.parent[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return False\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.parent[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.parent[p1] = p2\n        else:\n            self.parent[p2] = p1\n            self.rank[p1] += 1\n\n        self.part -= 1\n        return True\n\n\n# Kruskal\ndef findCriticalAndPseudoCriticalEdges(\n    n: int, edges: List[List[int]]\n) -&gt; List[List[int]]:\n    m = len(edges)\n\n    # Add index to edges\n    lst = list(range(m))\n    lst.sort(key=lambda x: edges[x][2])\n\n    # Calculate minimum cost\n    min_cost = 0\n    uf = UnionFind(n)\n    for i in lst:\n        x, y, cost = edges[i]\n        if uf.union(x, y):\n            min_cost += cost\n\n    # Calculate key edges\n    key = set()\n    for i in lst:\n        cur_cost = 0\n        uf = UnionFind(n)\n        for j in lst:\n            if j != i:\n                x, y, cost = edges[j]\n                if uf.union(x, y):\n                    cur_cost += cost\n        if cur_cost &gt; min_cost or uf.part != 1:\n            key.add(i)\n\n    # Calculate fake edges\n    fake = set()\n    for i in lst:\n        if i not in key:\n            cur_cost = edges[i][2]\n            uf = UnionFind(n)\n            uf.union(edges[i][0], edges[i][1])\n            for j in lst:\n                x, y, cost = edges[j]\n                if uf.union(x, y):\n                    cur_cost += cost\n            if cur_cost == min_cost and uf.part == 1:\n                fake.add(i)\n\n    return [sorted(list(key)), sorted(list(fake))]\n\n\nn = 5\nedges = [\n    [0, 1, 1],\n    [1, 2, 1],\n    [2, 3, 2],\n    [0, 3, 2],\n    [0, 4, 3],\n    [3, 4, 3],\n    [1, 4, 6],\n]\nprint(findCriticalAndPseudoCriticalEdges(n, edges))\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/graph_minimum_spanning_tree/#1631-path-with-minimum-effort","title":"1631. Path With Minimum Effort","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, depth first search, breadth first search, union find, heap priority queue, matrix</p> </li> <li>Return the minimum effort required to travel from the top-left to the bottom-right corner.</li> </ul> 1631. Path With Minimum Effort - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Prim\ndef minimumEffortPath(heights: List[List[int]]) -&gt; int:\n    m, n = len(heights), len(heights[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * n for _ in range(m)]\n    heap = [(0, 0, 0)]  # (effort, row, col)\n\n    while heap:\n        effort, r, c = heapq.heappop(heap)\n\n        if visited[r][c]:\n            continue\n\n        if r == m - 1 and c == n - 1:\n            return effort\n\n        visited[r][c] = True\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and not visited[nr][nc]:\n                updated = max(effort, abs(heights[r][c] - heights[nr][nc]))\n                heapq.heappush(heap, (updated, nr, nc))\n\n    return -1\n\n\nheights = [[1, 2, 2], [3, 8, 2], [5, 3, 5]]\nprint(minimumEffortPath(heights))  # 2\n</code></pre>"},{"location":"content/leetpattern/graph_minimum_spanning_tree/#1579-remove-max-number-of-edges-to-keep-graph-fully-traversable","title":"1579. Remove Max Number of Edges to Keep Graph Fully Traversable","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: union find, graph</p> </li> <li>Return the maximum number of edges you can remove so that the graph remains fully traversable.</li> </ul> <p></p> 1579. Remove Max Number of Edges to Keep Graph Fully Traversable - Python Solution<pre><code>from typing import List\n\n\n# Kruskal\ndef maxNumEdgesToRemove(n: int, edges: List[List[int]]) -&gt; int:\n    alice, bob = UnionFind(n), UnionFind(n)\n    visited = 0\n\n    for t, u, v in edges:\n        if t == 3:\n            if alice.union(u, v) | bob.union(u, v):\n                visited += 1\n\n    for t, u, v in edges:\n        if t == 1:\n            if alice.union(u, v):\n                visited += 1\n        elif t == 2:\n            if bob.union(u, v):\n                visited += 1\n\n    if alice.components &gt; 1 or bob.components &gt; 1:\n        return -1\n\n    return len(edges) - visited\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = {i: i for i in range(1, n + 1)}\n        self.rank = {i: 0 for i in range(1, n + 1)}\n        self.components = n\n\n    def find(self, n):\n        p = self.parent[n]\n        while self.parent[p] != p:\n            self.parent[p] = self.parent[self.parent[p]]\n            p = self.parent[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return False\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.parent[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.parent[p1] = p2\n        else:\n            self.parent[p2] = p1\n            self.rank[p1] += 1\n\n        self.components -= 1\n\n        return True\n\n\nn = 4\nedges = [[3, 1, 2], [3, 2, 3], [1, 1, 3], [1, 2, 4], [1, 1, 2], [2, 3, 4]]\nprint(maxNumEdgesToRemove(n, edges))  # 2\n</code></pre>"},{"location":"content/leetpattern/graph_shortest_path/","title":"Graph Shortest Path","text":""},{"location":"content/leetpattern/graph_shortest_path/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 743. Network Delay Time (Medium)</li> <li> 778. Swim in Rising Water (Hard)</li> <li> 1631. Path With Minimum Effort (Medium)</li> <li> 787. Cheapest Flights Within K Stops (Medium)</li> <li> 1514. Path with Maximum Probability (Medium)</li> <li> 505. The Maze II (Medium) \ud83d\udc51</li> <li> 499. The Maze III (Hard) \ud83d\udc51</li> <li> 882. Reachable Nodes In Subdivided Graph (Hard)</li> <li> 1376. Time Needed to Inform All Employees (Medium)</li> <li> 1168. Optimize Water Distribution in a Village (Hard) \ud83d\udc51</li> <li> 1976. Number of Ways to Arrive at Destination (Medium)</li> </ul>"},{"location":"content/leetpattern/graph_shortest_path/#743-network-delay-time","title":"743. Network Delay Time","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, heap priority queue, shortest path</p> </li> <li>Return the minimum time taken to reach all nodes in a network.</li> </ul> <pre><code>graph LR\n1((1))\n2((2))\n3((3))\n4((4))\n2 --&gt; |1| 1\n2 --&gt; |1| 3\n3 --&gt; |1| 4</code></pre> <ul> <li>Shortest Path Problem: Find the shortest path between two vertices in a graph.</li> <li>Dijkstra's Algorithm<ul> <li>Shortest path algorithm</li> <li>Weighted graph (non-negative weights)</li> <li>Data Structure: Heap; Hash Set</li> <li>Time Complexity: O(E * logV)</li> <li>Space Complexity: O(V)</li> </ul> </li> </ul> 743. Network Delay Time - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Dijkstra - Set\ndef networkDelayTime1(times: List[List[int]], n: int, k: int) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    heap = [(0, k)]\n    visit = set()\n    t = 0\n\n    while heap:\n        w1, n1 = heapq.heappop(heap)\n        if n1 in visit:\n            continue\n\n        visit.add(n1)\n        t = w1\n\n        for n2, w2 in graph[n1]:\n            heapq.heappush(heap, (w1 + w2, n2))\n\n    return t if len(visit) == n else -1\n\n\n# Dijkstra - Dict\ndef networkDelayTime2(times: List[List[int]], n: int, k: int) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    heap = [(0, k)]\n    dist = defaultdict(int)\n\n    while heap:\n        w1, n1 = heapq.heappop(heap)\n        if n1 in dist:\n            continue\n\n        dist[n1] = w1\n\n        for n2, w2 in graph[n1]:\n            heapq.heappush(heap, (w1 + w2, n2))\n\n    return max(dist.values()) if len(dist) == n else -1\n\n\n# Bellman-Ford\ndef networkDelayTimeBF(times: List[List[int]], n: int, k: int) -&gt; int:\n    delay = {i: float(\"inf\") for i in range(1, n + 1)}\n    delay[k] = 0\n\n    for _ in range(n - 1):\n        for u, v, t in times:\n            delay[v] = min(delay[v], delay[u] + t)\n\n    max_delay = max(delay.values())\n    return max_delay if max_delay &lt; float(\"inf\") else -1\n\n\n# |--------------|-----------|--------|\n# | Approach     | Time      | Space  |\n# |--------------|-----------|--------|\n# | Dijkstra     | O(E*logV) | O(V+E) |\n# | Bellman-Ford | O(E*V)    | O(V)   |\n# |--------------|-----------|--------|\n\nif __name__ == \"__main__\":\n    times = [[2, 1, 1], [2, 3, 1], [3, 4, 1]]\n    n = 4\n    k = 2\n    print(networkDelayTime1(times, n, k))  # 2\n    print(networkDelayTime2(times, n, k))  # 2\n    print(networkDelayTimeBF(times, n, k))  # 2\n</code></pre>"},{"location":"content/leetpattern/graph_shortest_path/#778-swim-in-rising-water","title":"778. Swim in Rising Water","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, depth first search, breadth first search, union find, heap priority queue, matrix</p> </li> <li>Return the minimum time when you can reach the target.</li> </ul> <p></p> 778. Swim in Rising Water - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra's\ndef swimInWater(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    visited = set()\n    minHeap = [(grid[0][0], 0, 0)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    visited.add((0, 0))\n\n    while minHeap:\n        time, r, c = heapq.heappop(minHeap)\n\n        if r == n - 1 and c == n - 1:\n            return time\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if nr in range(n) and nc in range(n) and (nr, nc) not in visited:\n                visited.add((nr, nc))\n                heapq.heappush(minHeap, (max(time, grid[nr][nc]), nr, nc))\n\n\ngrid = [\n    [0, 1, 2, 3, 4],\n    [24, 23, 22, 21, 5],\n    [12, 13, 14, 15, 16],\n    [11, 17, 18, 19, 20],\n    [10, 9, 8, 7, 6],\n]\nprint(swimInWater(grid))  # 16\n</code></pre>"},{"location":"content/leetpattern/graph_shortest_path/#1631-path-with-minimum-effort","title":"1631. Path With Minimum Effort","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, depth first search, breadth first search, union find, heap priority queue, matrix</p> </li> <li>Return the minimum effort required to travel from the top-left to the bottom-right corner.</li> </ul> 1631. Path With Minimum Effort - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Prim\ndef minimumEffortPath(heights: List[List[int]]) -&gt; int:\n    m, n = len(heights), len(heights[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * n for _ in range(m)]\n    heap = [(0, 0, 0)]  # (effort, row, col)\n\n    while heap:\n        effort, r, c = heapq.heappop(heap)\n\n        if visited[r][c]:\n            continue\n\n        if r == m - 1 and c == n - 1:\n            return effort\n\n        visited[r][c] = True\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and not visited[nr][nc]:\n                updated = max(effort, abs(heights[r][c] - heights[nr][nc]))\n                heapq.heappush(heap, (updated, nr, nc))\n\n    return -1\n\n\nheights = [[1, 2, 2], [3, 8, 2], [5, 3, 5]]\nprint(minimumEffortPath(heights))  # 2\n</code></pre>"},{"location":"content/leetpattern/graph_shortest_path/#787-cheapest-flights-within-k-stops","title":"787. Cheapest Flights Within K Stops","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming, depth first search, breadth first search, graph, heap priority queue, shortest path</p> </li> <li>Return the cheapest price from <code>src</code> to <code>dst</code> with at most <code>K</code> stops.</li> </ul> <pre><code>graph TD\n0((0))\n1((1))\n2((2))\n3((3))\n0 --&gt; |100| 1\n1 --&gt; |600| 3\n1 --&gt; |100| 2\n2 --&gt; |100| 0\n2 --&gt; |200| 3</code></pre> 787. Cheapest Flights Within K Stops - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Bellman-Ford\ndef findCheapestPriceBF(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    prices = [float(\"inf\") for _ in range(n)]\n    prices[src] = 0\n\n    for _ in range(k + 1):\n        temp = prices[:]\n        for u, v, w in flights:\n            temp[v] = min(temp[v], prices[u] + w)\n        prices = temp\n\n    return prices[dst] if prices[dst] != float(\"inf\") else -1\n\n\n# Dijkstra\ndef findCheapestPriceDijkstra(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in flights:\n        graph[u].append((v, w))\n\n    heap = [(0, src, 0)]  # (price, city, stops)\n    visited = defaultdict(int)  # {city: stops}\n\n    while heap:\n        price, city, stops = heapq.heappop(heap)\n\n        if city == dst:\n            return price\n\n        if stops &gt; k:\n            continue\n\n        if city in visited and visited[city] &lt;= stops:\n            continue\n\n        visited[city] = stops\n\n        for neighbor, cost in graph[city]:\n            heapq.heappush(heap, (price + cost, neighbor, stops + 1))\n\n    return -1\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |Bellman-Ford|    O(k * E)      |  O(n)   |\n# | Dijkstra   | O(E * log(V))    |  O(n)   |\n# |------------|------------------|---------|\n\n\nn = 4\nflights = [[0, 1, 100], [1, 2, 100], [2, 0, 100], [1, 3, 600], [2, 3, 200]]\nsrc = 0\ndst = 3\nk = 1\nprint(findCheapestPriceBF(n, flights, src, dst, k))  # 700\nprint(findCheapestPriceDijkstra(n, flights, src, dst, k))  # 700\n</code></pre>"},{"location":"content/leetpattern/graph_shortest_path/#1514-path-with-maximum-probability","title":"1514. Path with Maximum Probability","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, graph, heap priority queue, shortest path 1514. Path with Maximum Probability - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Dijkstra - Dict\ndef maxProbability1(\n    n: int,\n    edges: List[List[int]],\n    succProb: List[float],\n    start_node: int,\n    end_node: int,\n) -&gt; float:\n    graph = defaultdict(list)\n    for i, (u, v) in enumerate(edges):\n        graph[u].append((v, succProb[i]))\n        graph[v].append((u, succProb[i]))\n\n    heap = [(-1, start_node)]\n    max_prob = {i: 0.0 for i in range(n)}\n    max_prob[start_node] = 1.0\n\n    while heap:\n        p1, n1 = heapq.heappop(heap)\n\n        if n1 == end_node:\n            return -p1\n\n        for n2, p2 in graph[n1]:\n            p2 *= -p1\n            if p2 &gt; max_prob[n2]:\n                max_prob[n2] = p2\n                heapq.heappush(heap, (-p2, n2))\n\n    return 0.0\n\n\n# Dijkstra - Set\ndef maxProbability2(\n    n: int,\n    edges: List[List[int]],\n    succProb: List[float],\n    start_node: int,\n    end_node: int,\n) -&gt; float:\n    graph = defaultdict(list)\n    for i, (u, v) in enumerate(edges):\n        graph[u].append((v, succProb[i]))\n        graph[v].append((u, succProb[i]))\n\n    heap = [(-1, start_node)]\n    visited = set()\n\n    while heap:\n        p1, n1 = heapq.heappop(heap)\n        visited.add(n1)\n\n        if n1 == end_node:\n            return -p1\n\n        for n2, p2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (p1 * p2, n2))\n\n    return 0.0\n\n\n# |------------|-----------|-----------|\n# |  Approach  |    Time   |   Space   |\n# |------------|-----------|-----------|\n# |  Dijkstra  | O(E log V)|   O(E)    |\n# |------------|-----------|-----------|\n\n\nn = 3\nedges = [[0, 1], [1, 2], [0, 2]]\nsuccProb = [0.5, 0.5, 0.2]\nstart = 0\nend = 2\n\nprint(maxProbability1(n, edges, succProb, start, end))  # 0.25\nprint(maxProbability2(n, edges, succProb, start, end))  # 0.25\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/graph_shortest_path/#505-the-maze-ii","title":"505. The Maze II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, graph, heap priority queue, matrix, shortest path 505. The Maze II - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra\ndef shortestDistance(\n    maze: List[List[int]], start: List[int], destination: List[int]\n) -&gt; int:\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    m, n = len(maze), len(maze[0])\n\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    dist[start[0]][start[1]] = 0\n\n    heap = [(0, start[0], start[1])]\n\n    while heap:\n        d, r, c = heapq.heappop(heap)\n\n        if [r, c] == destination:\n            return d\n\n        for dr, dc in directions:\n            nr, nc, nd = r, c, d\n\n            while (\n                0 &lt;= nr + dr &lt; m\n                and 0 &lt;= nc + dc &lt; n\n                and maze[nr + dr][nc + dc] == 0\n            ):\n                nr += dr\n                nc += dc\n                nd += 1\n\n            if nd &lt; dist[nr][nc]:\n                dist[nr][nc] = nd\n                heapq.heappush(heap, (nd, nr, nc))\n\n    return -1\n\n\nmaze = [\n    [0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0],\n    [0, 0, 0, 1, 0],\n    [1, 1, 0, 1, 1],\n    [0, 0, 0, 0, 0],\n]\nstart = [0, 4]\ndestination = [4, 4]\nprint(shortestDistance(maze, start, destination))  # 12\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/graph_shortest_path/#499-the-maze-iii","title":"499. The Maze III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, depth first search, breadth first search, graph, heap priority queue, matrix, shortest path 499. The Maze III - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra\ndef findShortestWay(\n    maze: List[List[int]], ball: List[int], hole: List[int]\n) -&gt; str:\n    directions = [(-1, 0, \"u\"), (1, 0, \"d\"), (0, -1, \"l\"), (0, 1, \"r\")]\n    m, n = len(maze), len(maze[0])\n\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    dist[ball[0]][ball[1]] = 0\n\n    paths = [[\"\"] * n for _ in range(m)]\n    paths[ball[0]][ball[1]] = \"\"\n\n    heap = [(0, \"\", ball[0], ball[1])]\n\n    while heap:\n        d, path, x, y = heapq.heappop(heap)\n\n        if [x, y] == hole:\n            return path\n\n        for dx, dy, direction in directions:\n            nx, ny, nd = x, y, d\n\n            while (\n                0 &lt;= nx + dx &lt; m\n                and 0 &lt;= ny + dy &lt; n\n                and maze[nx + dx][ny + dy] == 0\n            ):\n                nx += dx\n                ny += dy\n                nd += 1\n\n                if [nx, ny] == hole:\n                    break\n\n            new_path = path + direction\n            if nd &lt; dist[nx][ny] or (\n                nd == dist[nx][ny] and new_path &lt; paths[nx][ny]\n            ):\n                dist[nx][ny] = nd\n                paths[nx][ny] = new_path\n                heapq.heappush(heap, (nd, new_path, nx, ny))\n\n    return \"impossible\"\n\n\nmaze = [\n    [0, 0, 0, 0, 0],\n    [1, 1, 0, 0, 1],\n    [0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 1],\n    [0, 1, 0, 0, 0],\n]\nball = [4, 3]\nhole = [0, 1]\nprint(findShortestWay(maze, ball, hole))  # \"lul\"\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/graph_shortest_path/#882-reachable-nodes-in-subdivided-graph","title":"882. Reachable Nodes In Subdivided Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: graph, heap priority queue, shortest path 882. Reachable Nodes In Subdivided Graph - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra's\ndef reachableNodes(self, edges: List[List[int]], maxMoves: int, n: int) -&gt; int:\n    graph = {i: {} for i in range(n)}\n    for u, v, cnt in edges:\n        graph[u][v] = cnt\n        graph[v][u] = cnt\n\n    heap = [(-maxMoves, 0)]\n    seen = {}\n\n    while heap:\n        moves, node = heapq.heappop(heap)\n        if node in seen:\n            continue\n        seen[node] = -moves\n        for nxt, cnt in graph[node].items():\n            movesLeft = -moves - cnt - 1\n            if nxt not in seen and movesLeft &gt;= 0:\n                heapq.heappush(heap, (-movesLeft, nxt))\n\n    res = len(seen)\n    for u, v, cnt in edges:\n        res += min(seen.get(u, 0) + seen.get(v, 0), cnt)\n\n    return res\n\n\nedges = [[0, 1, 10], [0, 2, 1], [1, 2, 2]]\nmaxMoves = 6\nn = 3\nprint(reachableNodes(None, edges, maxMoves, n))  # 13\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/graph_shortest_path/#1376-time-needed-to-inform-all-employees","title":"1376. Time Needed to Inform All Employees","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search 1376. Time Needed to Inform All Employees - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# DFS\ndef numOfMinutesDFS(\n    n: int, headID: int, manager: List[int], informTime: List[int]\n) -&gt; int:\n    graph = defaultdict(list)\n    for i in range(n):\n        if manager[i] != -1:\n            graph[manager[i]].append(i)\n\n    def dfs(node):\n        time = 0\n        for sub in graph[node]:\n            time = max(time, dfs(sub))\n        return time + informTime[node]\n\n    return dfs(headID)\n\n\n# BFS\ndef numOfMinutesBFS(\n    n: int, headID: int, manager: List[int], informTime: List[int]\n) -&gt; int:\n    graph = defaultdict(list)\n    for i in range(n):\n        if manager[i] != -1:\n            graph[manager[i]].append(i)\n\n    q = deque([(headID, 0)])\n    max_time = 0\n\n    while q:\n        node, time = q.popleft()\n        max_time = max(max_time, time)\n        for sub in graph[node]:\n            q.append((sub, time + informTime[node]))\n\n    return max_time\n\n\nn = 6\nheadID = 2\nmanager = [2, 2, -1, 2, 2, 2]\ninformTime = [0, 0, 1, 0, 0, 0]\nprint(numOfMinutesDFS(n, headID, manager, informTime))  # 1\nprint(numOfMinutesBFS(n, headID, manager, informTime))  # 1\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/graph_shortest_path/#1168-optimize-water-distribution-in-a-village","title":"1168. Optimize Water Distribution in a Village","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: union find, graph, heap priority queue, minimum spanning tree</p> </li> <li> <p></p> </li> <li> <p></p> </li> </ul> 1168. Optimize Water Distribution in a Village - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minCostToSupplyWater1(\n    n: int, wells: List[int], pipes: List[List[int]]\n) -&gt; int:\n    graph = defaultdict(list)\n\n    for h1, h2, cost in pipes:\n        graph[h1].append((h2, cost))\n        graph[h2].append((h1, cost))\n\n    # Add the cost of the wells to the graph (house 0)\n    for i in range(n):\n        graph[0].append((i + 1, wells[i]))\n        graph[i + 1].append((0, wells[i]))\n\n    visited = set([0])\n    heap = [(cost, dest) for dest, cost in graph[0]]\n    heapq.heapify(heap)\n\n    cost = 0\n\n    while heap:\n        c1, n1 = heapq.heappop(heap)\n        if n1 in visited:\n            continue\n        visited.add(n1)\n        cost += c1\n\n        for n2, c2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (c2, n2))\n\n    return cost\n\n\n# Kruskal\ndef minCostToSupplyWater2(\n    n: int, wells: List[int], pipes: List[List[int]]\n) -&gt; int:\n    par = list(range(n + 1))\n    rank = [0] * (n + 1)\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            if rank[p1] &lt; rank[p2]:\n                par[p1] = p2\n            elif rank[p1] &gt; rank[p2]:\n                par[p2] = p1\n            else:\n                par[p1] = p2\n                rank[p2] += 1\n            return True\n        return False\n\n    graph = [(c, 0, i + 1) for i, c in enumerate(wells)]\n    for h1, h2, c in pipes:\n        graph.append((c, h1, h2))\n\n    graph.sort()\n\n    cost = 0\n\n    for c, h1, h2 in graph:\n        if union(h1, h2):\n            cost += c\n\n    return cost\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |    Prim    | O((V + E) log V) | O(V + E)|\n# |  Kruskal   |     O(E log E)   | O(V + E)|\n# |------------|------------------|---------|\n\n\nn = 3\nwells = [1, 2, 2]\npipes = [[1, 2, 1], [2, 3, 1]]\nprint(minCostToSupplyWater1(n, wells, pipes))  # 3\nprint(minCostToSupplyWater2(n, wells, pipes))  # 3\n</code></pre>"},{"location":"content/leetpattern/graph_shortest_path/#1976-number-of-ways-to-arrive-at-destination","title":"1976. Number of Ways to Arrive at Destination","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming, graph, topological sort, shortest path 1976. Number of Ways to Arrive at Destination - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra\ndef countPaths(n: int, roads: List[List[int]]) -&gt; int:\n    mod = 10**9 + 7\n    graph = [[] for _ in range(n)]\n    for u, v, w in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n\n    dist = [float(\"inf\") for _ in range(n)]\n    dist[0] = 0\n    count = [0 for _ in range(n)]\n    count[0] = 1\n\n    heap = [(0, 0)]\n\n    while heap:\n        d, u = heapq.heappop(heap)\n        if d &gt; dist[u]:\n            continue\n\n        for v, w in graph[u]:\n            if dist[u] + w &lt; dist[v]:\n                dist[v] = dist[u] + w\n                count[v] = count[u]\n                heapq.heappush(heap, (dist[v], v))\n            elif dist[u] + w == dist[v]:\n                count[v] += count[u]\n                count[v] %= mod\n\n    return count[-1]\n\n\nn = 7\nroads = [\n    [0, 6, 7],\n    [0, 1, 2],\n    [1, 2, 3],\n    [1, 3, 3],\n    [6, 3, 3],\n    [3, 5, 1],\n    [6, 5, 1],\n    [2, 5, 1],\n    [0, 4, 5],\n    [4, 6, 2],\n]\nprint(countPaths(n, roads))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/graph_tarjan/","title":"Graph Tarjan","text":""},{"location":"content/leetpattern/graph_tarjan/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1192. Critical Connections in a Network (Hard)</li> </ul>"},{"location":"content/leetpattern/graph_tarjan/#1192-critical-connections-in-a-network","title":"1192. Critical Connections in a Network","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: depth first search, graph, biconnected component 1192. Critical Connections in a Network - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Tarjan\ndef criticalConnections(\n    n: int, connections: List[List[int]]\n) -&gt; List[List[int]]:\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    disc = [-1] * n\n    low = [-1] * n\n    bridges = []\n    time = 0\n\n    def dfs(n1, prev):\n        nonlocal time\n        disc[n1], low[n1] = time, time\n        time += 1\n\n        for n2 in graph[n1]:\n            if n2 == prev:\n                continue\n            if disc[n2] == -1:\n                dfs(n2, n1)\n                low[n1] = min(low[n1], low[n2])\n\n                if low[n2] &gt; disc[n1]:\n                    bridges.append([n1, n2])\n            else:\n                low[n1] = min(low[n1], disc[n2])\n\n    for i in range(n):\n        if disc[i] == -1:\n            dfs(i, -1)\n\n    return bridges\n\n\nn = 4\nconnections = [[0, 1], [1, 2], [2, 0], [1, 3]]\nprint(criticalConnections(n, connections))  # [[1, 3]]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/graph_topological_sort/","title":"Graph Topological Sort","text":""},{"location":"content/leetpattern/graph_topological_sort/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1557. Minimum Number of Vertices to Reach All Nodes (Medium)</li> <li> 207. Course Schedule (Medium)</li> <li> 210. Course Schedule II (Medium)</li> <li> 269. Alien Dictionary (Hard) \ud83d\udc51</li> <li> 1203. Sort Items by Groups Respecting Dependencies (Hard)</li> <li> 1857. Largest Color Value in a Directed Graph (Hard)</li> <li> 1136. Parallel Courses (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/leetpattern/graph_topological_sort/#1557-minimum-number-of-vertices-to-reach-all-nodes","title":"1557. Minimum Number of Vertices to Reach All Nodes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: graph</p> </li> <li>Return a list of integers representing the minimum number of vertices needed to traverse all the nodes.</li> <li>Hint: Return the vertices with indegree 0.</li> </ul> 1557. Minimum Number of Vertices to Reach All Nodes - Python Solution<pre><code>from typing import List\n\n\n# Graph\ndef findSmallestSetOfVertices(n: int, edges: List[List[int]]) -&gt; List[int]:\n    indegree = {i: 0 for i in range(n)}\n\n    for _, end in edges:\n        indegree[end] += 1\n\n    return [i for i in range(n) if indegree[i] == 0]\n\n\nif __name__ == \"__main__\":\n    n = 6\n    edges = [[0, 1], [0, 2], [2, 5], [3, 4], [4, 2]]\n    assert findSmallestSetOfVertices(n, edges) == [0, 3]\n</code></pre>"},{"location":"content/leetpattern/graph_topological_sort/#207-course-schedule","title":"207. Course Schedule","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort</p> </li> <li>Return true if it is possible to finish all courses, otherwise return false.</li> <li>Dependency relationships imply the topological sort algorithm.</li> <li>Cycle detection</li> <li>Topological Sort</li> <li>DAG (Directed Acyclic Graph)</li> <li>Time complexity: O(V+E)</li> <li>Space complexity: O(V+E)</li> <li>Prerequisites: Indegree (Look at the problem 1557. Minimum Number of Vertices to Reach All Nodes)<ul> <li>Indegree: Number of incoming edges to a vertex</li> </ul> </li> <li>Applications: task scheduling, course scheduling, build systems, dependency resolution, compiler optimization, etc.</li> </ul> <p></p> <p></p> <p>Course to prerequisites mapping</p> <pre><code>flowchart LR\n    0((0)) --&gt; 1((1))\n    0((0)) --&gt; 2((2))\n    1((1)) --&gt; 3((3))\n    3((3)) --&gt; 4((4))\n    1((1)) --&gt; 4((4))</code></pre> <p>Prerequisites to course mapping</p> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    2((2)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))\n    4((4)) --&gt; 3((3))\n    4((4)) --&gt; 1((1))</code></pre> course 0 0 1 1 3 prerequisite 1 2 3 4 4 index 0 1 2 3 4 in-degree 0 0 0 0 0 <p>Initialize</p> <ul> <li>graph</li> </ul> prerequisite 1 2 3 4 course <code>[0]</code> <code>[0]</code> <code>[1]</code> <code>[1, 3]</code> <ul> <li>in-degree</li> </ul> 0 1 2 3 4 in-degree 2 2 0 1 0 <ul> <li>queue: <code>[2, 4]</code></li> <li>pop <code>2</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))\n    4((4)) --&gt; 3((3))\n    4((4)) --&gt; 1((1))</code></pre> 0 1 2 3 4 in-degree 1 2 0 1 0 <ul> <li>queue: <code>[4]</code></li> <li>pop <code>4</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))</code></pre> 0 1 2 3 4 in-degree 1 1 0 0 0 <ul> <li>queue: <code>[3]</code></li> <li>pop <code>3</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))</code></pre> 0 1 2 3 4 in-degree 1 0 0 0 0 <ul> <li>queue: <code>[1]</code></li> <li>pop <code>1</code> from the queue</li> </ul> <pre><code>flowchart LR\n    0((0))</code></pre> 0 1 2 3 4 in-degree 0 0 0 0 0 <ul> <li>queue: <code>[0]</code></li> <li>pop <code>0</code> from the queue</li> <li>All courses are taken. Return <code>True</code>.</li> </ul> 207. Course Schedule - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS (Kahn's Algorithm)\ndef canFinishBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    count = 0\n\n    while q:\n        crs = q.popleft()\n        count += 1\n\n        for nxt in graph[crs]:\n            indegree[nxt] -= 1\n\n            if indegree[nxt] == 0:\n                q.append(nxt)\n\n    return count == numCourses\n\n\n# DFS + Set\ndef canFinishDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for crs, pre in prerequisites:\n        graph[crs].append(pre)\n\n    visiting = set()\n\n    def dfs(crs):\n        if crs in visiting:  # cycle detected\n            return False\n        if graph[crs] == []:\n            return True\n\n        visiting.add(crs)\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        visiting.remove(crs)\n        graph[crs] = []\n\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\n# DFS + List\ndef canFinishDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for pre, crs in prerequisites:\n        graph[crs].append(pre)\n\n    # 0: init, 1: visiting, 2: visited\n    status = [0] * numCourses\n\n    def dfs(crs):\n        if status[crs] == 1:  # cycle detected\n            return False\n        if status[crs] == 2:\n            return True\n\n        status[crs] = 1\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        status[crs] = 2\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(canFinishBFS(5, prerequisites))  # True\nprint(canFinishDFS1(5, prerequisites))  # True\nprint(canFinishDFS2(5, prerequisites))  # True\n</code></pre> 207. Course Schedule - C++ Solution<pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    // BFS\n    bool canFinishBFS(int numCourses, vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        vector&lt;int&gt; indegree(numCourses, 0);\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n            indegree[pre[0]]++;\n        }\n\n        queue&lt;int&gt; q;\n        for (int i = 0; i &lt; numCourses; i++) {\n            if (indegree[i] == 0) {\n                q.push(i);\n            }\n        }\n\n        int cnt = 0;\n        while (!q.empty()) {\n            int cur = q.front();\n            q.pop();\n            cnt++;\n\n            for (int nxt : graph[cur]) {\n                indegree[nxt]--;\n                if (indegree[nxt] == 0) {\n                    q.push(nxt);\n                }\n            }\n        }\n        return cnt == numCourses;\n    }\n\n    // DFS\n    bool canFinishDFS(int numCourses, vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n        }\n        // 0: not visited, 1: visiting, 2: visited\n        vector&lt;int&gt; state(numCourses, 0);\n\n        function&lt;bool(int)&gt; dfs = [&amp;](int pre) -&gt; bool {\n            state[pre] = 1;  // visiting\n            for (int crs : graph[pre]) {\n                if (state[crs] == 1 || (state[crs] == 0 &amp;&amp; dfs(crs))) {\n                    return true;\n                }\n            }\n            state[pre] = 2;  // visited\n            return false;\n        };\n\n        for (int i = 0; i &lt; numCourses; i++) {\n            if (state[i] == 0 &amp;&amp; dfs(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution sol;\n    vector&lt;vector&lt;int&gt;&gt; prerequisites = {{1, 0}, {2, 1}, {3, 2}, {4, 3},\n                                         {5, 4}, {6, 5}, {7, 6}, {8, 7},\n                                         {9, 8}, {10, 9}};\n    int numCourses = 11;\n    cout &lt;&lt; sol.canFinishBFS(numCourses, prerequisites) &lt;&lt; endl;\n    cout &lt;&lt; sol.canFinishDFS(numCourses, prerequisites) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/leetpattern/graph_topological_sort/#210-course-schedule-ii","title":"210. Course Schedule II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort</p> </li> <li>Return the ordering of courses you should take to finish all courses. If there are multiple valid answers, return any of them.</li> </ul> <p></p> 210. Course Schedule II - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# 1. BFS - Kahn's Algorithm\ndef findOrderBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    order = []\n\n    while q:\n        pre = q.popleft()\n        order.append(pre)\n\n        for crs in graph[pre]:\n            indegree[crs] -= 1\n            if indegree[crs] == 0:\n                q.append(crs)\n\n    return order if len(order) == numCourses else []\n\n\n# 2. DFS + Set\ndef findOrderDFS1(\n    numCourses: int, prerequisites: List[List[int]]\n) -&gt; List[int]:\n    adj = defaultdict(list)\n    for crs, pre in prerequisites:\n        adj[crs].append(pre)\n\n    visit, cycle = set(), set()\n    order = []\n\n    def dfs(crs):\n        if crs in cycle:\n            return False\n        if crs in visit:\n            return True\n\n        cycle.add(crs)\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        cycle.remove(crs)\n        visit.add(crs)\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order\n\n\n# 3. DFS + List\ndef findOrderDFS2(\n    numCourses: int, prerequisites: List[List[int]]\n) -&gt; List[int]:\n    adj = defaultdict(list)\n    for pre, crs in prerequisites:\n        adj[crs].append(pre)\n\n    # 0: not visited, 1: visiting, 2: visited\n    state = [0] * numCourses\n    order = []\n\n    def dfs(crs):\n        if state[crs] == 1:\n            return False\n        if state[crs] == 2:\n            return True\n\n        state[crs] = 1\n\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        state[crs] = 2\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order[::-1]\n\n\nnumCourses = 5\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(findOrderBFS(numCourses, prerequisites))  # [2, 4, 3, 1, 0]\nprint(findOrderDFS1(numCourses, prerequisites))  # [4, 3, 1, 2, 0]\nprint(findOrderDFS2(numCourses, prerequisites))  # [4, 3, 2, 1, 0]\n</code></pre> 210. Course Schedule II - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    // BFS\n    vector&lt;int&gt; findOrderBFS(int numCourses,\n                             vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        vector&lt;int&gt; indegree(numCourses, 0);\n\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n            indegree[pre[0]]++;\n        }\n\n        queue&lt;int&gt; q;\n        for (int i = 0; i &lt; numCourses; i++)\n            if (indegree[i] == 0) q.push(i);\n\n        vector&lt;int&gt; order;\n\n        while (!q.empty()) {\n            int cur = q.front();\n            q.pop();\n            order.push_back(cur);\n\n            for (int nxt : graph[cur]) {\n                indegree[nxt]--;\n                if (indegree[nxt] == 0) q.push(nxt);\n            }\n        }\n\n        return (int)order.size() == numCourses ? order : vector&lt;int&gt;{};\n    }\n};\n\nint main() {\n    Solution obj;\n    vector&lt;vector&lt;int&gt;&gt; prerequisites{{1, 0}, {2, 0}, {3, 1}, {3, 2}};\n    vector&lt;int&gt; res = obj.findOrderBFS(4, prerequisites);\n    for (size_t i = 0; i &lt; res.size(); i++) cout &lt;&lt; res[i] &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"content/leetpattern/graph_topological_sort/#269-alien-dictionary","title":"269. Alien Dictionary","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, depth first search, breadth first search, graph, topological sort</p> </li> <li>Return the correct order of characters in the alien language.</li> </ul> 269. Alien Dictionary - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS - Kahn's algorithm (Topological Sort)\ndef alienOrderBFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    indegree = {c: 0 for word in words for c in word}\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                    indegree[w2[j]] += 1\n                break\n\n    q = deque([c for c in indegree if indegree[c] == 0])\n    result = []\n\n    while q:\n        char = q.popleft()\n        result.append(char)\n\n        for neighbor in graph[char]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n\n    return \"\".join(result) if len(result) == len(indegree) else \"\"\n\n\n# DFS - Topological Sort\ndef alienOrderDFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    visited = {}\n    result = []\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                break\n\n    def dfs(c):\n        if c in visited:\n            return visited[c]\n\n        visited[c] = False\n        for neighbor in graph[c]:\n            if not dfs(neighbor):\n                return False\n\n        visited[c] = True\n        result.append(c)\n        return True\n\n    for c in list(graph.keys()):\n        if not dfs(c):\n            return \"\"\n\n    return \"\".join(result[::-1])\n\n\nwords = [\"wrt\", \"wrf\", \"er\", \"ett\", \"rftt\"]\nprint(alienOrderBFS(words))  # wertf\nprint(alienOrderDFS(words))  # wertf\n</code></pre>"},{"location":"content/leetpattern/graph_topological_sort/#1203-sort-items-by-groups-respecting-dependencies","title":"1203. Sort Items by Groups Respecting Dependencies","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort</p> </li> <li>Return any permutation of the items that satisfies the requirements.</li> </ul> 1203. Sort Items by Groups Respecting Dependencies - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS - Kahn's algorithm (Topological Sort)\ndef sortItems(\n    n: int, m: int, group: List[int], beforeItems: List[List[int]]\n) -&gt; List[int]:\n    def topological_sort(graph, indegree, nodes):\n        q = deque([node for node in nodes if indegree[node] == 0])\n        result = []\n\n        while q:\n            node = q.popleft()\n            result.append(node)\n\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    q.append(neighbor)\n\n        return result if len(result) == len(nodes) else []\n\n    groupItems = defaultdict(list)\n    groupGraph = defaultdict(set)\n    groupIndegree = defaultdict(int)\n    itemGraph = defaultdict(set)\n    itemIndegree = defaultdict(int)\n\n    for i in range(n):\n        if group[i] == -1:\n            group[i] = m\n            m += 1\n        groupItems[group[i]].append(i)\n\n    for i, beforeItem in enumerate(beforeItems):\n        for before in beforeItem:\n            if group[before] != group[i]:\n                if group[i] not in groupGraph[group[before]]:\n                    groupGraph[group[before]].add(group[i])\n                    groupIndegree[group[i]] += 1\n            else:\n                itemGraph[before].add(i)\n                itemIndegree[i] += 1\n\n    allGroups = list(set(group))\n    groupOrder = topological_sort(groupGraph, groupIndegree, allGroups)\n    if not groupOrder:\n        return []\n\n    result = []\n    for g in groupOrder:\n        items = groupItems[g]\n        itemOrder = topological_sort(itemGraph, itemIndegree, items)\n        if not itemOrder:\n            return []\n        result.extend(itemOrder)\n\n    return result\n\n\nn = 8\nm = 2\ngroup = [-1, -1, 1, 0, 0, 1, 0, -1]\nbeforeItems = [[], [6], [5], [6], [3, 6], [], [], []]\nprint(sortItems(n, m, group, beforeItems))\n</code></pre>"},{"location":"content/leetpattern/graph_topological_sort/#1857-largest-color-value-in-a-directed-graph","title":"1857. Largest Color Value in a Directed Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, dynamic programming, graph, topological sort, memoization, counting 1857. Largest Color Value in a Directed Graph - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# Topological Sort\ndef largestPathValue(colors: str, edges: List[List[int]]) -&gt; int:\n    n = len(colors)\n    graph = defaultdict(list)\n    indegree = [0 for _ in range(n)]\n\n    for u, v in edges:\n        graph[u].append(v)\n        indegree[v] += 1\n\n    q = deque([i for i in range(n) if indegree[i] == 0])\n\n    dp = [[0] * 26 for _ in range(n)]\n\n    for i in range(n):\n        dp[i][ord(colors[i]) - ord(\"a\")] = 1\n\n    processed, max_color = 0, 0\n\n    while q:\n        n1 = q.popleft()\n        processed += 1\n        max_color = max(max_color, max(dp[n1]))\n\n        for n2 in graph[n1]:\n            indegree[n2] -= 1\n            for i in range(26):\n                dp[n2][i] = max(\n                    dp[n2][i],\n                    dp[n1][i] + (1 if i == ord(colors[n2]) - ord(\"a\") else 0),\n                )\n            if indegree[n2] == 0:\n                q.append(n2)\n\n    return max_color if processed == n else -1\n\n\ncolors = \"abaca\"\nedges = [[0, 1], [0, 2], [2, 3], [3, 4]]\nprint(largestPathValue(colors, edges))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/graph_topological_sort/#1136-parallel-courses","title":"1136. Parallel Courses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: graph, topological sort</p> </li> <li>Return the minimum number of semesters needed to take all courses.</li> </ul> <p></p> 1136. Parallel Courses - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# Topological Sort\ndef minimumSemesters(n: int, relations: List[List[int]]) -&gt; int:\n    graph = {i: [] for i in range(1, n + 1)}\n    indegree = {i: 0 for i in range(1, n + 1)}\n\n    for pre, nxt in relations:\n        graph[pre].append(nxt)\n        indegree[nxt] += 1\n\n    q = deque([i for i in range(1, n + 1) if indegree[i] == 0])\n    semester = 0\n    done = 0\n\n    while q:\n        semester += 1\n        size = len(q)\n\n        for _ in range(size):\n            pre = q.popleft()\n            done += 1\n\n            for nxt in graph[pre]:\n                indegree[nxt] -= 1\n                if indegree[nxt] == 0:\n                    q.append(nxt)\n\n    return semester if done == n else -1\n\n\nn = 3\nrelations = [[1, 3], [2, 3]]\nprint(minimumSemesters(n, relations))  # 2\n</code></pre>"},{"location":"content/leetpattern/graph_union_find/","title":"Graph Union Find","text":""},{"location":"content/leetpattern/graph_union_find/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 547. Number of Provinces (Medium)</li> <li> 684. Redundant Connection (Medium)</li> <li> 323. Number of Connected Components in an Undirected Graph (Medium) \ud83d\udc51</li> <li> 721. Accounts Merge (Medium)</li> <li> 990. Satisfiability of Equality Equations (Medium)</li> <li> 952. Largest Component Size by Common Factor (Hard)</li> <li> 839. Similar String Groups (Hard)</li> <li> 305. Number of Islands II (Hard) \ud83d\udc51</li> <li> 1202. Smallest String With Swaps (Medium)</li> <li> 685. Redundant Connection II (Hard)</li> <li> 399. Evaluate Division (Medium)</li> <li> 1101. The Earliest Moment When Everyone Become Friends (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/leetpattern/graph_union_find/#547-number-of-provinces","title":"547. Number of Provinces","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> <li>Return the number of provinces.</li> </ul>"},{"location":"content/leetpattern/graph_union_find/#union-find","title":"Union Find","text":"<ul> <li>Find by Path Compression</li> <li>Union by Rank</li> <li>Time Complexity: O(log(n))</li> <li>Space Complexity: O(n)</li> </ul> template/union_find.py 547. Number of Provinces - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\nfrom template import UnionFind\n\n\n# DFS (Adjacency Matrix)\ndef findCircleNumDFSMatrix(isConnected: List[List[int]]) -&gt; int:\n    n = len(isConnected)\n    visited = set()\n\n    def dfs(node):\n        if node in visited:\n            return\n        visited.add(node)\n        for neighbor in range(n):\n            if node != neighbor and isConnected[node][neighbor] == 1:\n                dfs(neighbor)\n\n    res = 0\n    for i in range(n):\n        if i not in visited:\n            dfs(i)\n            res += 1\n\n    return res\n\n\n# DFS (Adjacency List)\ndef findCircleNumDFSList(isConnected: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    n = len(isConnected)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if isConnected[i][j] == 1:\n                graph[i].append(j)\n                graph[j].append(i)\n\n    visited = set()\n\n    def dfs(node):\n        if node in visited:\n            return\n        visited.add(node)\n        for neighbor in graph[node]:\n            dfs(neighbor)\n\n    res = 0\n    for i in range(n):\n        if i not in visited:\n            dfs(i)\n            res += 1\n\n    return res\n\n\n# BFS (Adjacency Matrix)\ndef findCircleNumBFS(isConnected: List[List[int]]) -&gt; int:\n    n = len(isConnected)\n    visited = set()\n    q = deque()\n    res = 0\n\n    for i in range(n):\n        if i not in visited:\n            res += 1\n\n            q.append(i)\n            while q:\n                node = q.popleft()\n                visited.add(node)\n                for node, val in enumerate(isConnected[node]):\n                    if val == 1 and node not in visited:\n                        q.append(node)\n                        visited.add(node)\n\n    return res\n\n\n# Union Find\ndef findCircleNumUF(isConnected: List[List[int]]) -&gt; int:\n    n = len(isConnected)\n    uf = UnionFind(n)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if isConnected[i][j] == 1:\n                uf.union(i, j)\n\n    res = len(set(uf.find(i) for i in range(n)))\n\n    return res\n\n\n# Union Find\ndef findCircleNum(isConnected: List[List[int]]) -&gt; int:\n    n = len(isConnected)\n    par = {i: i for i in range(n)}\n    rank = {i: 0 for i in range(n)}\n\n    def find(n):\n        p = par[n]\n        while par[p] != p:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 == p2:\n            return None\n\n        if rank[p1] &gt; rank[p2]:\n            par[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n        else:\n            par[p2] = p1\n            rank[p1] += 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if isConnected[i][j] == 1:\n                union(i, j)\n\n    res = len(set(find(i) for i in range(n)))\n\n    return res\n\n\nisConnected = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]\nprint(findCircleNumDFSList(isConnected))  # 2\nprint(findCircleNumDFSMatrix(isConnected))  # 2\nprint(findCircleNumBFS(isConnected))  # 2\nprint(findCircleNum(isConnected))  # 2\nprint(findCircleNumUF(isConnected))  # 2\n</code></pre>"},{"location":"content/leetpattern/graph_union_find/#684-redundant-connection","title":"684. Redundant Connection","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph 684. Redundant Connection - Python Solution<pre><code>from typing import List\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(1, n + 1)}\n        self.rank = {i: 1 for i in range(1, n + 1)}\n\n    def find(self, n):\n        p = self.par[n]\n        while self.par[p] != p:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return False\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.par[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.par[p1] = p2\n        else:\n            self.par[p2] = p1\n            self.rank[p1] += 1\n\n        return True\n\n\n# Union Find\ndef findRedundantConnectionUF(edges: List[List[int]]) -&gt; List[int]:\n    n = len(edges)\n    uf = UnionFind(n)\n\n    for u, v in edges:\n        if not uf.union(u, v):\n            return (u, v)\n\n\n# DFS\ndef findRedundantConnectionDFS(edges: List[List[int]]) -&gt; List[int]:\n    graph, cycle = {}, {}\n    for a, b in edges:\n        graph.setdefault(a, []).append(b)\n        graph.setdefault(b, []).append(a)\n\n    def dfs(node, parent):\n        if node in cycle:\n            for k in list(cycle.keys()):\n                if k == node:\n                    return True\n                del cycle[k]\n\n        cycle[node] = None\n        for child in graph[node]:\n            if child != parent and dfs(child, node):\n                return True\n        del cycle[node]\n        return False\n\n    dfs(edges[0][0], -1)\n    for a, b in edges[::-1]:\n        if a in cycle and b in cycle:\n            return (a, b)\n\n\nedges = [[1, 2], [1, 3], [2, 3]]\nprint(findRedundantConnectionUF(edges))  # (2, 3)\nprint(findRedundantConnectionDFS(edges))  # (2, 3)\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/graph_union_find/#323-number-of-connected-components-in-an-undirected-graph","title":"323. Number of Connected Components in an Undirected Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph 323. Number of Connected Components in an Undirected Graph - Python Solution<pre><code>from typing import List\n\n\n# Union Find\ndef countComponents(n: int, edges: List[List[int]]) -&gt; int:\n    uf = UnionFind(n)\n    count = n\n\n    for u, v in edges:\n        count -= uf.union(u, v)\n\n    return count\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(n)}\n        self.rank = {i: 1 for i in range(n)}\n\n    def find(self, n):\n        p = self.par[n]\n        while self.par[p] != p:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return 0\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.par[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.par[p1] = p2\n        else:\n            self.par[p2] = p1\n            self.rank[p1] += 1\n\n        return 1\n\n\nprint(countComponents(5, [[0, 1], [1, 2], [3, 4]]))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/graph_union_find/#721-accounts-merge","title":"721. Accounts Merge","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, depth first search, breadth first search, union find, sorting 721. Accounts Merge - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef accountsMerge(accounts: List[List[str]]) -&gt; List[List[str]]:\n    parent = defaultdict(str)\n    rank = defaultdict(int)\n    email_to_name = defaultdict(str)\n    merged_accounts = defaultdict(list)\n\n    def find(n):\n        p = parent[n]\n        while p != parent[p]:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    for account in accounts:\n        name = account[0]\n        first_email = account[1]\n\n        for email in account[1:]:\n            if email not in parent:\n                parent[email] = email\n                rank[email] = 1\n            email_to_name[email] = name\n            union(first_email, email)\n\n    for email in parent:\n        root_email = find(email)\n        merged_accounts[root_email].append(email)\n\n    result = []\n    for root_email, emails in merged_accounts.items():\n        result.append([email_to_name[root_email]] + sorted(emails))\n\n    return result\n\n\naccounts = [\n    [\"John\", \"johnsmith@mail.com\", \"john_newyork@mail.com\"],\n    [\"John\", \"johnsmith@mail.com\", \"john00@mail.com\"],\n    [\"Mary\", \"mary@mail.com\"],\n    [\"John\", \"johnnybravo@mail.com\"],\n]\nprint(accountsMerge(accounts))\n# [['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],\n# ['Mary', 'mary@mail.com'],\n# ['John', 'johnnybravo@mail.com']]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/graph_union_find/#990-satisfiability-of-equality-equations","title":"990. Satisfiability of Equality Equations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, union find, graph 990. Satisfiability of Equality Equations - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef equationsPossible(equations: List[str]) -&gt; bool:\n    parent = defaultdict(str)\n    rank = defaultdict(int)\n\n    def find(n):\n        p = parent[n]\n        while p != parent[p]:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    for equation in equations:\n        if equation[0] not in parent:\n            parent[equation[0]] = equation[0]\n            rank[equation[0]] = 1\n        if equation[3] not in parent:\n            parent[equation[3]] = equation[3]\n            rank[equation[3]] = 1\n\n    for equation in equations:\n        if equation[1] == \"=\":\n            union(equation[0], equation[3])\n\n    for equation in equations:\n        if equation[1] == \"!\":\n            if find(equation[0]) == find(equation[3]):\n                return False\n\n    return True\n\n\nequations = [\"a==b\", \"b!=a\"]\nprint(equationsPossible(equations))  # False\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/graph_union_find/#952-largest-component-size-by-common-factor","title":"952. Largest Component Size by Common Factor","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, math, union find, number theory 952. Largest Component Size by Common Factor - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef largestComponentSize(nums: List[int]) -&gt; int:\n    par = {i: i for i in nums}\n    rank = {i: 0 for i in nums}\n\n    def find(n):\n        p = par[n]\n        while par[p] != p:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            if rank[p1] &gt; rank[p2]:\n                par[p2] = p1\n            elif rank[p1] &lt; rank[p2]:\n                par[p1] = p2\n            else:\n                par[p2] = p1\n                rank[p1] += 1\n\n    def prime_factors(n):\n        \"\"\"Return the prime factors of n.\"\"\"\n        i = 2\n        factors = set()\n        while i * i &lt;= n:\n            while (n % i) == 0:\n                factors.add(i)\n                n //= i\n            i += 1\n        if n &gt; 1:\n            factors.add(n)\n        return factors\n\n    factor_map = defaultdict(list)  # factor -&gt; [nums]\n    for num in nums:\n        factors = prime_factors(num)\n        for factor in factors:\n            factor_map[factor].append(num)\n\n    for factor, group in factor_map.items():\n        for i in range(1, len(group)):\n            union(group[0], group[i])\n\n    sizes = defaultdict(int)  # component root -&gt; size\n    for num in nums:\n        root = find(num)\n        sizes[root] += 1\n\n    return max(sizes.values())\n\n\nnums = [20, 50, 9, 63]\nprint(largestComponentSize(nums))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/graph_union_find/#839-similar-string-groups","title":"839. Similar String Groups","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, string, depth first search, breadth first search, union find 839. Similar String Groups - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef numSimilarGroups(strs: List[str]) -&gt; int:\n    n = len(strs)\n    parent = list(range(n))\n    rank = [0 for _ in range(n)]\n\n    def find(n):\n        p = parent[n]\n        while parent[p] != p:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    def is_similar(s1, s2):\n        diff = 0\n        for c1, c2 in zip(s1, s2):\n            if c1 != c2:\n                diff += 1\n            if diff &gt; 2:\n                return False\n        return True\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_similar(strs[i], strs[j]):\n                union(i, j)\n\n    return sum(find(i) == i for i in range(n))\n\n\nstrs = [\"tars\", \"rats\", \"arts\", \"star\"]\nprint(numSimilarGroups(strs))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/graph_union_find/#305-number-of-islands-ii","title":"305. Number of Islands II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, union find 305. Number of Islands II - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef numIslands2(m: int, n: int, positions: List[List[int]]) -&gt; List[int]:\n    parent = defaultdict(tuple)\n    islands = 0\n    result = []\n    visited = set()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def find(node):\n        p = parent[node]\n        while parent[p] != p:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            parent[p1] = p2\n            return True\n        return False\n\n    for r, c in positions:\n        if (r, c) in visited:\n            result.append(islands)\n            continue\n\n        islands += 1\n        parent[(r, c)] = (r, c)\n        visited.add((r, c))\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if (nr, nc) in visited:\n                if union((r, c), (nr, nc)):\n                    islands -= 1\n\n        result.append(islands)\n\n    return result\n\n\nm = 3\nn = 3\npositions = [[0, 0], [0, 1], [1, 2], [2, 1]]\nprint(numIslands2(m, n, positions))  # [1, 1, 2, 3]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/graph_union_find/#1202-smallest-string-with-swaps","title":"1202. Smallest String With Swaps","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, depth first search, breadth first search, union find, sorting 1202. Smallest String With Swaps - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef smallestStringWithSwaps(s: str, pairs: List[List[int]]) -&gt; str:\n    n = len(s)\n    par = list(range(n))\n    components = defaultdict(list)\n\n    def find(node):\n        p = par[node]\n        while par[p] != p:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 != p2:\n            par[p1] = p2\n\n    for index, j in pairs:\n        union(index, j)\n\n    for index in range(n):\n        components[find(index)].append(index)\n\n    res = list(s)\n    for indices in components.values():\n        chars = sorted([s[index] for index in indices])\n        for index, char in zip(indices, chars):\n            res[index] = char\n\n    return \"\".join(res)\n\n\ns = \"dcab\"\npairs = [[0, 3], [1, 2]]\nprint(smallestStringWithSwaps(s, pairs))  # \"bacd\"\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/graph_union_find/#685-redundant-connection-ii","title":"685. Redundant Connection II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph 685. Redundant Connection II - Python Solution<pre><code>from typing import List\n\n\n# Union Find\ndef findRedundantDirectedConnectionUF(edges: List[List[int]]) -&gt; List[int]:\n    n = len(edges)\n    uf = UnionFind(n + 1)\n    parent = list(range(n + 1))\n    candidates = []\n\n    for u, v in edges:\n        if parent[v] != v:\n            candidates.append([parent[v], v])\n            candidates.append([u, v])\n        else:\n            parent[v] = u\n\n    if not candidates:\n        for u, v in edges:\n            if not uf.union(u, v):\n                return [u, v]\n\n    for u, v in edges:\n        if [u, v] == candidates[1]:\n            continue\n        if not uf.union(u, v):\n            return candidates[0]\n\n    return candidates[1]\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(1, n + 1)}\n\n    def find(self, n):\n        p = self.par[n]\n        while p != self.par[p]:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n        if p1 == p2:\n            return False\n        self.par[p1] = p2\n        return True\n\n\nedges = [[1, 2], [1, 3], [2, 3]]\nprint(findRedundantDirectedConnectionUF(edges))\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/graph_union_find/#399-evaluate-division","title":"399. Evaluate Division","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, depth first search, breadth first search, union find, graph, shortest path 399. Evaluate Division - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef calcEquation(\n    equations: List[List[str]], values: List[float], queries: List[List[str]]\n) -&gt; List[float]:\n    graph = defaultdict(dict)\n    for (a, b), v in zip(equations, values):\n        graph[a][b] = v\n        graph[b][a] = 1 / v\n\n    def dfs(a, b, visited):\n        if a not in graph or b not in graph:\n            return -1.0\n\n        if b in graph[a]:\n            return graph[a][b]\n\n        for c in graph[a]:\n            if c not in visited:\n                visited.add(c)\n                d = dfs(c, b, visited)\n                if d != -1.0:\n                    return graph[a][c] * d\n        return -1.0\n\n    result = []\n    for a, b in queries:\n        result.append(dfs(a, b, set()))\n\n    return result\n\n\nequations = [[\"a\", \"b\"], [\"b\", \"c\"]]\nvalues = [2.0, 3.0]\nqueries = [[\"a\", \"c\"], [\"b\", \"a\"], [\"a\", \"e\"], [\"a\", \"a\"], [\"x\", \"x\"]]\nprint(calcEquation(equations, values, queries))  # [6.0, 0.5, -1.0, 1.0, -1.0]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/graph_union_find/#1101-the-earliest-moment-when-everyone-become-friends","title":"1101. The Earliest Moment When Everyone Become Friends","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, union find, sorting 1101. The Earliest Moment When Everyone Become Friends - Python Solution<pre><code>from typing import List\n\n\n# Union Find\ndef earliestAcq(logs: List[List[int]], n: int) -&gt; int:\n    logs.sort()\n    par = {i: i for i in range(n)}\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    for time, a, b in logs:\n        pa, pb = find(a), find(b)\n        if pa != pb:\n            par[pa] = pb\n            n -= 1\n        if n == 1:\n            return time\n    return -1\n\n\nlogs = [[0, 2, 0], [1, 0, 1], [3, 0, 3], [4, 1, 2], [7, 3, 1]]\nn = 4\nprint(earliestAcq(logs, n))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/greedy/","title":"Greedy","text":""},{"location":"content/leetpattern/greedy/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 455. Assign Cookies (Easy)</li> <li> 1005. Maximize Sum Of Array After K Negations (Easy)</li> <li> 860. Lemonade Change (Easy)</li> <li> 2037. Minimum Number of Moves to Seat Everyone (Easy)</li> <li> 376. Wiggle Subsequence (Medium)</li> <li> 738. Monotone Increasing Digits (Medium)</li> <li> 122. Best Time to Buy and Sell Stock II (Medium)</li> <li> 714. Best Time to Buy and Sell Stock with Transaction Fee (Medium)</li> <li> 135. Candy (Hard)</li> <li> 406. Queue Reconstruction by Height (Medium)</li> <li> 3075. Maximize Happiness of Selected Children (Medium)</li> <li> 945. Minimum Increment to Make Array Unique (Medium)</li> <li> 53. Maximum Subarray (Medium)</li> <li> 134. Gas Station (Medium)</li> <li> 968. Binary Tree Cameras (Hard)</li> <li> 1589. Maximum Sum Obtained of Any Permutation (Medium)</li> </ul>"},{"location":"content/leetpattern/greedy/#455-assign-cookies","title":"455. Assign Cookies","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers, greedy, sorting</p> </li> <li>Return the maximum number of your content children that can be satisfied.</li> </ul> 455. Assign Cookies - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef findContentChildren(g: List[int], s: List[int]) -&gt; int:\n    g.sort()\n    s.sort()\n    i, j = 0, 0\n\n    while i &lt; len(g) and j &lt; len(s):\n        if g[i] &lt;= s[j]:\n            i += 1\n        j += 1\n\n    return i\n\n\n# |-------------|-------------|--------------|\n# |   Approach  |    Time     |    Space     |\n# |-------------|-------------|--------------|\n# |   Greedy    | O(N * logN) |    O(1)      |\n# |-------------|-------------|--------------|\n\n\ng = [1, 2, 3]\ns = [1, 1]\nprint(findContentChildren(g, s))  # 1\n</code></pre>"},{"location":"content/leetpattern/greedy/#1005-maximize-sum-of-array-after-k-negations","title":"1005. Maximize Sum Of Array After K Negations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> <li>Return the maximum sum of the array after changing at most <code>k</code> elements.</li> </ul> 1005. Maximize Sum Of Array After K Negations - Python Solution<pre><code>from heapq import heapify, heapreplace\nfrom typing import List\n\n\n# Greedy\ndef largestSumAfterKNegationsGreedy(nums: List[int], k: int) -&gt; int:\n    nums.sort(key=abs, reverse=True)\n\n    for i in range(len(nums)):\n        if nums[i] &lt; 0 and k &gt; 0:\n            nums[i] *= -1\n            k -= 1\n\n    if k % 2:\n        nums[-1] *= -1\n\n    return sum(nums)\n\n\n# Heap\ndef largestSumAfterKNegationsHeap(nums: List[int], k: int) -&gt; int:\n    heapify(nums)\n\n    while k and nums[0] &lt; 0:\n        heapreplace(nums, -nums[0])\n        k -= 1\n\n    if k % 2:\n        heapreplace(nums, -nums[0])\n\n    return sum(nums)\n\n\nprint(largestSumAfterKNegationsGreedy([4, 2, 3], 1))  # 5\nprint(largestSumAfterKNegationsHeap([4, 2, 3], 1))\n</code></pre>"},{"location":"content/leetpattern/greedy/#860-lemonade-change","title":"860. Lemonade Change","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, greedy</p> </li> <li>Return <code>True</code> if and only if you can provide every customer with correct change.</li> </ul> 860. Lemonade Change - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef lemonadeChange(bills: List[int]) -&gt; bool:\n    hashmap = {5: 0, 10: 0, 20: 0}\n\n    for i in bills:\n        if i == 5:\n            hashmap[5] += 1\n\n        if i == 10:\n            if hashmap[5] &lt; 1:\n                return False\n\n            hashmap[5] -= 1\n            hashmap[10] += 1\n\n        if i == 20:\n            if hashmap[5] &gt;= 1 and hashmap[10] &gt;= 1:\n                hashmap[5] -= 1\n                hashmap[10] -= 1\n                hashmap[20] += 1\n\n            elif hashmap[5] &gt;= 3:\n                hashmap[5] -= 3\n                hashmap[20] += 1\n\n            else:\n                return False\n\n    return True\n\n\nprint(lemonadeChange([5, 5, 5, 10, 20]))  # True\n</code></pre>"},{"location":"content/leetpattern/greedy/#2037-minimum-number-of-moves-to-seat-everyone","title":"2037. Minimum Number of Moves to Seat Everyone","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, greedy, sorting, counting sort</p> </li> <li>Return the minimum number of moves needed to seat everyone.</li> </ul> 2037. Minimum Number of Moves to Seat Everyone - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef minMovesToSeat(seats: List[int], students: List[int]) -&gt; int:\n    seats.sort()\n    students.sort()\n    moves = 0\n\n    for i, j in zip(seats, students):\n        moves += abs(i - j)\n\n    return moves\n\n\nprint(minMovesToSeat([3, 1, 5], [2, 7, 4]))  # 4\n</code></pre>"},{"location":"content/leetpattern/greedy/#376-wiggle-subsequence","title":"376. Wiggle Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> <li>Return the length of the longest wiggle subsequence.</li> <li><code>up[n]</code> stores the length of the longest wiggle subsequence ending at <code>n</code> with a rising wiggle.</li> <li><code>down[n]</code> stores the length of the longest wiggle subsequence ending at <code>n</code> with a falling wiggle.</li> <li>Initialize <code>up[0] = 1</code> and <code>down[0] = 1</code>.</li> <li>Example: <code>nums = [1, 7, 4, 9, 2, 5]</code></li> </ul> <code>nums[n]</code> <code>nums[n-1]</code> <code>up[n-1]</code> <code>down[n-1]</code> <code>up[n]</code> <code>down[n]</code> 1 - - - 1 1 7 1 1 1 2 1 4 7 2 1 2 3 9 4 2 3 4 3 2 9 4 3 4 5 5 2 4 5 6 5 376. Wiggle Subsequence - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef wiggleMaxLengthDP(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 1:\n        return len(nums)\n\n    up = [0 for _ in range(len(nums))]\n    down = [0 for _ in range(len(nums))]\n\n    up[0], down[0] = 1, 1\n\n    for i in range(1, len(nums)):\n        if nums[i] &gt; nums[i - 1]:\n            up[i] = down[i - 1] + 1\n            down[i] = down[i - 1]\n        elif nums[i] &lt; nums[i - 1]:\n            down[i] = up[i - 1] + 1\n            up[i] = up[i - 1]\n        else:\n            up[i] = up[i - 1]\n            down[i] = down[i - 1]\n\n    return max(up[-1], down[-1])\n\n\n# Greedy\ndef wiggleMaxLengthGreedy(nums: List[int]) -&gt; int:\n    if len(nums) &lt; 2:\n        return len(nums)\n\n    prev_diff = nums[1] - nums[0]\n    count = 2 if prev_diff != 0 else 1\n\n    for i in range(2, len(nums)):\n        diff = nums[i] - nums[i - 1]\n        if (diff &gt; 0 and prev_diff &lt;= 0) or (diff &lt; 0 and prev_diff &gt;= 0):\n            count += 1\n            prev_diff = diff\n\n    return count\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    DP       |      O(n)       |     O(n)     |\n# |  Greedy     |      O(n)       |     O(1)     |\n# |-------------|-----------------|--------------|\n\nnums = [1, 7, 4, 9, 2, 5]\nprint(wiggleMaxLengthDP(nums))  # 6\nprint(wiggleMaxLengthGreedy(nums))  # 6\n</code></pre>"},{"location":"content/leetpattern/greedy/#738-monotone-increasing-digits","title":"738. Monotone Increasing Digits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, greedy</p> </li> <li>Return the largest number that is less than or equal to <code>n</code> with monotone increasing digits.</li> </ul> 738. Monotone Increasing Digits - Python Solution<pre><code># Greedy\ndef monotoneIncreasingDigits(n: int) -&gt; int:\n    strNum = list(str(n))\n\n    for i in range(len(strNum) - 2, -1, -1):\n        if int(strNum[i]) &gt; int(strNum[i + 1]):\n            strNum[i] = str(int(strNum[i]) - 1)\n            strNum[i + 1 :] = [\"9\"] * (len(strNum) - (i + 1))\n\n    return int(\"\".join(strNum))\n\n\nn = 332\nprint(monotoneIncreasingDigits(n))  # 299\n</code></pre>"},{"location":"content/leetpattern/greedy/#122-best-time-to-buy-and-sell-stock-ii","title":"122. Best Time to Buy and Sell Stock II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> <li>Return the maximum profit you can achieve.</li> </ul> 122. Best Time to Buy and Sell Stock II - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef maxProfitDP1(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 2 for _ in range(n)]\n    dp[0][0] = -prices[0]\n    dp[0][1] = 0\n\n    for i in range(1, n):\n        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i])\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# DP - Optimized\ndef maxProfitDP2(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    hold = -prices[0]\n    profit = 0\n\n    for i in range(1, n):\n        hold = max(hold, profit - prices[i])\n        profit = max(profit, hold + prices[i])\n\n    return profit\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    profit = 0\n\n    for i in range(1, len(prices)):\n        profit += max(prices[i] - prices[i - 1], 0)\n\n    return profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |     DP1    |  O(n)  |   O(n)  |\n# |     DP2    |  O(n)  |   O(1)  |\n# |   Greedy   |  O(n)  |   O(1)  |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitDP1(prices))  # 7\nprint(maxProfitDP2(prices))  # 7\nprint(maxProfitGreedy(prices))  # 7\n</code></pre>"},{"location":"content/leetpattern/greedy/#714-best-time-to-buy-and-sell-stock-with-transaction-fee","title":"714. Best Time to Buy and Sell Stock with Transaction Fee","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> <li>Return the maximum profit you can achieve with the given transaction fee.</li> </ul> 714. Best Time to Buy and Sell Stock with Transaction Fee - Python Solution<pre><code>from typing import List\n\n\n# 1. DP\ndef maxProfitDP(prices: List[int], fee: int) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 2 for _ in range(n)]\n\n    dp[0][0] = -prices[0] - fee\n    dp[0][1] = 0\n\n    for i in range(1, n):\n        dp[i][0] = max(\n            dp[i - 1][0],  # hold\n            dp[i - 1][1] - prices[i] - fee,  # buy\n        )\n        dp[i][1] = max(\n            dp[i - 1][1],  # hold\n            dp[i - 1][0] + prices[i],  # sell\n        )\n\n    return max(dp[-1])\n\n\n# 2. Greedy\ndef maxProfitGreedy(prices: List[int], fee: int) -&gt; int:\n    n = len(prices)\n    if n == 0:\n        return 0\n\n    buy = prices[0]\n    profit = 0\n\n    for i in range(1, n):\n        if prices[i] &lt; buy:\n            buy = prices[i]\n        elif prices[i] &gt; buy + fee:\n            profit += prices[i] - buy - fee\n            buy = prices[i] - fee\n\n    return profit\n\n\nprices = [1, 3, 2, 8, 4, 9]\nfee = 2\nprint(maxProfitDP(prices, fee))  # 8\nprint(maxProfitGreedy(prices, fee))  # 8\n</code></pre>"},{"location":"content/leetpattern/greedy/#135-candy","title":"135. Candy","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy</p> </li> <li>Return the minimum number of candies you must give.</li> </ul> 135. Candy - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef candy(ratings: List[int]) -&gt; int:\n    # TC: O(n)\n    # SC: O(n)\n    n = len(ratings)\n\n    if n &lt;= 1:\n        return n\n\n    candy = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        if ratings[i] &gt; ratings[i - 1]:\n            candy[i] = candy[i - 1] + 1\n\n    for j in range(n - 2, -1, -1):\n        if ratings[j] &gt; ratings[j + 1]:\n            candy[j] = max(candy[j], candy[j + 1] + 1)\n\n    return sum(candy)\n\n\nratings = [1, 0, 2]\nprint(candy(ratings))  # 5\n</code></pre>"},{"location":"content/leetpattern/greedy/#406-queue-reconstruction-by-height","title":"406. Queue Reconstruction by Height","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary indexed tree, segment tree, sorting</p> </li> <li>Reconstruct the queue.</li> </ul> 406. Queue Reconstruction by Height - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef reconstructQueue(people: List[List[int]]) -&gt; List[List[int]]:\n    queue = []\n    people.sort(key=lambda x: (-x[0], x[1]))\n\n    for i in people:\n        queue.insert(i[1], i)\n\n    return queue\n\n\npeople = [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nprint(reconstructQueue(people))\n# [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]\n</code></pre>"},{"location":"content/leetpattern/greedy/#3075-maximize-happiness-of-selected-children","title":"3075. Maximize Happiness of Selected Children","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting 3075. Maximize Happiness of Selected Children - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef maximumHappinessSum(happiness: List[int], k: int) -&gt; int:\n    selected = 0\n    happinessScore = 0\n    happiness.sort(reverse=True)\n\n    for score in happiness:\n        if selected == k:\n            return happinessScore\n        happinessScore += max(0, score - selected)\n        selected += 1\n\n    return happinessScore\n\n\nhappiness = [1, 2, 3]\nk = 2\nprint(maximumHappinessSum(happiness, k))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/greedy/#945-minimum-increment-to-make-array-unique","title":"945. Minimum Increment to Make Array Unique","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting, counting 945. Minimum Increment to Make Array Unique - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef minIncrementForUnique(nums: List[int]) -&gt; int:\n    nums.sort()\n    moves = 0\n\n    for i in range(1, len(nums)):\n        if nums[i] &lt;= nums[i - 1]:\n            moves += nums[i - 1] + 1 - nums[i]\n            nums[i] = nums[i - 1] + 1\n\n    return moves\n\n\nnums = [1, 2, 2]\nprint(minIncrementForUnique(nums))  # 1\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/greedy/#53-maximum-subarray","title":"53. Maximum Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, divide and conquer, dynamic programming 53. Maximum Subarray - Python Solution<pre><code>from typing import List\n\n\n# DP Kadane\ndef maxSubArrayDP(nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n\n    dp[0] = nums[0]\n    maxSum = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(\n            dp[i - 1] + nums[i],  # continue the previous subarray\n            nums[i],  # start a new subarray\n        )\n        maxSum = max(maxSum, dp[i])\n\n    return maxSum\n\n\n# Greedy\ndef maxSubArrayGreedy(nums: List[int]) -&gt; int:\n    max_sum = nums[0]\n    cur_sum = 0\n\n    for num in nums:\n        cur_sum = max(cur_sum + num, num)\n        max_sum = max(max_sum, cur_sum)\n\n    return max_sum\n\n\n# Prefix Sum\ndef maxSubArrayPrefixSum(nums: List[int]) -&gt; int:\n    prefix_sum = 0\n    prefix_sum_min = 0\n    res = float(\"-inf\")\n\n    for num in nums:\n        prefix_sum += num\n        res = max(res, prefix_sum - prefix_sum_min)\n        prefix_sum_min = min(prefix_sum_min, prefix_sum)\n\n    return res\n\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArrayDP(nums))  # 6\nprint(maxSubArrayGreedy(nums))  # 6\nprint(maxSubArrayPrefixSum(nums))  # 6\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/greedy/#134-gas-station","title":"134. Gas Station","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy 134. Gas Station - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef canCompleteCircuit(gas: List[int], cost: List[int]) -&gt; int:\n    curSum = 0\n    totalSum = 0\n    start = 0\n\n    for i in range(len(gas)):\n        curSum += gas[i] - cost[i]\n        totalSum += gas[i] - cost[i]\n\n        if curSum &lt; 0:\n            start = i + 1\n            curSum = 0\n\n    if totalSum &lt; 0:\n        return -1\n\n    return start\n\n\ngas = [1, 2, 3, 4, 5]\ncost = [3, 4, 5, 1, 2]\nprint(canCompleteCircuit(gas, cost))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/greedy/#968-binary-tree-cameras","title":"968. Binary Tree Cameras","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, tree, depth first search, binary tree 968. Binary Tree Cameras - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef minCameraCover(root: Optional[TreeNode]) -&gt; int:\n    res = 0\n\n    def dfs(node, hasParent):\n        if not node:\n            return -1\n\n        nonlocal res\n        left, right = dfs(node.left, True), dfs(node.right, True)\n\n        if left == -1 and right == -1:\n            if hasParent:\n                return 0\n            res += 1\n            return 2\n        if left == 0 or right == 0:\n            res += 1\n            return 2\n        if left == 2 or right == 2:\n            return 1\n        if hasParent:\n            return 0\n        res += 1\n        return 2\n\n    dfs(root, False)\n\n    return res\n\n\nroot = build([0, 0, None, 0, 0])\nprint(root)\nprint(minCameraCover(root))  # 1\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/greedy/#1589-maximum-sum-obtained-of-any-permutation","title":"1589. Maximum Sum Obtained of Any Permutation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting, prefix sum 1589. Maximum Sum Obtained of Any Permutation - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef maxSumRangeQuery(nums: List[int], requests: List[List[int]]) -&gt; int:\n    n = len(nums)\n    freq = [0 for _ in range(n + 1)]\n\n    for start, end in requests:\n        freq[start] += 1\n        if end + 1 &lt; n:\n            freq[end + 1] -= 1\n\n    for i in range(1, n):\n        freq[i] += freq[i - 1]\n\n    freq.pop()\n\n    freq.sort(reverse=True)\n    nums.sort(reverse=True)\n\n    max_sum = 0\n    mod = 10**9 + 7\n\n    for i, j in zip(nums, freq):\n        max_sum += i * j\n        max_sum %= mod\n\n    return max_sum\n\n\nnums = [1, 2, 3, 4, 5]\nrequests = [[1, 3], [0, 1]]\nprint(maxSumRangeQuery(nums, requests))  # 19\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/hash_counting/","title":"Hash Counting","text":""},{"location":"content/leetpattern/hash_counting/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 242. Valid Anagram (Easy)</li> <li> 560. Subarray Sum Equals K (Medium)</li> <li> 49. Group Anagrams (Medium)</li> <li> 438. Find All Anagrams in a String (Medium)</li> </ul>"},{"location":"content/leetpattern/hash_counting/#242-valid-anagram","title":"242. Valid Anagram","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, string, sorting</p> </li> <li>Return true if an input string is an anagram of another string.</li> <li>An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once, e.g., <code>listen</code> is an anagram of <code>silent</code>.</li> </ul> 242. Valid Anagram - Python Solution<pre><code>from collections import Counter\n\n\n# Hashmap\ndef isAnagramHash(s: str, t: str) -&gt; bool:\n    \"\"\"Return True if t is an anagram of s, False otherwise.\"\"\"\n    if len(s) != len(t):\n        return False\n\n    count = dict()\n\n    for i in s:\n        if i in count:\n            count[i] += 1\n        else:\n            count[i] = 1\n\n    for j in t:\n        if j in count:\n            count[j] -= 1\n        else:\n            return False\n\n    for count in count.values():\n        if count != 0:\n            return False\n\n    return True\n\n\n# Array\ndef isAnagramArray(s: str, t: str) -&gt; bool:\n    if len(s) != len(t):\n        return False\n\n    count = [0 for _ in range(26)]\n\n    for i in s:\n        count[ord(i) - ord(\"a\")] += 1\n\n    for j in t:\n        count[ord(j) - ord(\"a\")] -= 1\n\n    for i in count:\n        if i != 0:\n            return False\n\n    return True\n\n\n# Counter\ndef isAnagramCounter(s: str, t: str) -&gt; bool:\n    return Counter(s) == Counter(t)\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |   Hashmap   |       O(n)      |     O(1)     |\n# |    Array    |       O(n)      |     O(1)     |\n# |   Counter   |       O(n)      |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\ns = \"anagram\"\nt = \"nagaram\"\nprint(isAnagramHash(s, t))  # True\nprint(isAnagramArray(s, t))  # True\nprint(isAnagramCounter(s, t))  # True\n</code></pre>"},{"location":"content/leetpattern/hash_counting/#560-subarray-sum-equals-k","title":"560. Subarray Sum Equals K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, prefix sum 560. Subarray Sum Equals K - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Prefix Sum\ndef subarraySum(nums: List[int], k: int) -&gt; int:\n    preSums = defaultdict(int)\n    preSums[0] = 1\n    curSum = 0\n    res = 0\n\n    for num in nums:\n        curSum += num\n        res += preSums[curSum - k]\n        preSums[curSum] += 1\n\n    return res\n\n\nnums = [1, 1, 1]\nk = 2\nprint(subarraySum(nums, k))  # 2\n</code></pre></p> </li> </ul> 560. Subarray Sum Equals K - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint subarraySum(vector&lt;int&gt;&amp; nums, int k) {\n    int n = nums.size();\n    vector&lt;int&gt; prefixSum(n + 1);\n    for (int i = 0; i &lt; n; i++) {\n        prefixSum[i + 1] = prefixSum[i] + nums[i];\n    }\n\n    int res = 0;\n    unordered_map&lt;int, int&gt; cnt;\n\n    for (int ps : prefixSum) {\n        if (cnt.find(ps - k) != cnt.end()) res += cnt[ps - k];\n        cnt[ps]++;\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {1, 1, 1};\n    int k = 2;\n    cout &lt;&lt; subarraySum(nums, k) &lt;&lt; endl;  // 2\n    return 0;\n}\n</code></pre>"},{"location":"content/leetpattern/hash_counting/#49-group-anagrams","title":"49. Group Anagrams","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, sorting 49. Group Anagrams - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash - List\ndef groupAnagrams(strs: List[str]) -&gt; List[List[str]]:\n    result = defaultdict(list)\n\n    for s in strs:\n        count = [0] * 26\n        for i in s:\n            count[ord(i) - ord(\"a\")] += 1\n\n        result[tuple(count)].append(s)\n\n    return list(result.values())\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Hash     |     O(n * k)    |     O(n)     |\n# |-------------|-----------------|--------------|\n\n\nstrs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\nprint(groupAnagrams(strs))\n# [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/hash_counting/#438-find-all-anagrams-in-a-string","title":"438. Find All Anagrams in a String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window 438. Find All Anagrams in a String - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window Fixed Size\ndef findAnagrams(s: str, p: str) -&gt; List[int]:\n    n, k = len(s), len(p)\n    target = [0 for _ in range(26)]\n    for ch in p:\n        target[ord(ch) - ord(\"a\")] += 1\n\n    count = [0 for _ in range(26)]\n    left = 0\n    res = []\n\n    for right in range(n):\n        count[ord(s[right]) - ord(\"a\")] += 1\n        if right &lt; k - 1:\n            continue\n\n        if count == target:\n            res.append(left)\n\n        count[ord(s[left]) - ord(\"a\")] -= 1\n        left += 1\n\n    return res\n\n\ns = \"cbaebabacd\"\np = \"abc\"\nprint(findAnagrams(s, p))  # [0, 6]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/hash_map/","title":"Hash Map","text":""},{"location":"content/leetpattern/hash_map/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 383. Ransom Note (Easy)</li> <li> 350. Intersection of Two Arrays II (Easy)</li> <li> 1. Two Sum (Easy)</li> <li> 409. Longest Palindrome (Easy)</li> <li> 1365. How Many Numbers Are Smaller Than the Current Number (Easy)</li> <li> 202. Happy Number (Easy)</li> <li> 454. 4Sum II (Medium)</li> </ul>"},{"location":"content/leetpattern/hash_map/#383-ransom-note","title":"383. Ransom Note","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, string, counting</p> </li> <li>Return <code>True</code> if the ransom note can be constructed from the magazines, otherwise, return <code>False</code>.</li> </ul> <pre><code>graph LR\n    A[\"Magazine: abcdef\"] --&gt; C(True)\n    B[\"Ransom Note: abc\"] --&gt; C</code></pre> 383. Ransom Note - Python Solution<pre><code>from collections import Counter, defaultdict\n\n\n# Array\ndef canConstructArray(ransomNote: str, magazine: str) -&gt; bool:\n    if len(ransomNote) &gt; len(magazine):\n        return False\n\n    record = [0 for _ in range(26)]\n\n    for i in magazine:\n        record[ord(i) - ord(\"a\")] += 1\n\n    for j in ransomNote:\n        record[ord(j) - ord(\"a\")] -= 1\n\n    for i in record:\n        if i &lt; 0:\n            return False\n\n    return True\n\n\n# Dict\ndef canConstructDict(ransomNote: str, magazine: str) -&gt; bool:\n    if len(ransomNote) &gt; len(magazine):\n        return False\n\n    record = defaultdict(int)\n\n    for i in magazine:\n        record[i] += 1\n\n    for j in ransomNote:\n        if j not in record or record[j] == 0:\n            return False\n        record[j] -= 1\n\n    return True\n\n\n# Counter\ndef canConstructCounter(ransomNote: str, magazine: str) -&gt; bool:\n    return not Counter(ransomNote) - Counter(magazine)\n\n\nransomNote = \"aa\"\nmagazine = \"aab\"\nprint(canConstructArray(ransomNote, magazine))  # True\nprint(canConstructDict(ransomNote, magazine))  # True\nprint(canConstructCounter(ransomNote, magazine))  # True\n</code></pre>"},{"location":"content/leetpattern/hash_map/#350-intersection-of-two-arrays-ii","title":"350. Intersection of Two Arrays II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, two pointers, binary search, sorting</p> </li> <li>Return the intersection of two arrays.</li> </ul> 350. Intersection of Two Arrays II - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hashmap\ndef intersect(nums1: List[int], nums2: List[int]) -&gt; List[int]:\n    hashmap = defaultdict(int)  # {num: count}\n    result = []\n\n    for i in nums1:\n        hashmap[i] += 1\n\n    for i in nums2:\n        if hashmap[i] &gt; 0:\n            result.append(i)\n            hashmap[i] -= 1\n\n    return result\n\n\n# |-------------|-------------|--------------|\n# |   Approach  |    Time     |    Space     |\n# |-------------|-------------|--------------|\n# |   Hashmap   |   O(n + m)  | O(min(n, m)) |\n# |-------------|-------------|--------------|\n\nnums1 = [1, 2, 2, 1]\nnums2 = [2, 2]\nprint(intersect(nums1, nums2))  # [2, 2]\n</code></pre>"},{"location":"content/leetpattern/hash_map/#1-two-sum","title":"1. Two Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table</p> </li> <li>Return the indices of the two numbers such that they add up to a specific target.</li> <li>Approach: Use a hashmap to store the indices of the numbers.</li> <li>Time Complexity: O(n)</li> <li>Space Complexity: O(n)</li> </ul> 1. Two Sum - Python Solution<pre><code>from typing import List\n\n\ndef twoSum(nums: List[int], target: int) -&gt; List[int]:\n    hashmap = {}  # val: idx\n\n    for idx, val in enumerate(nums):\n        if (target - val) in hashmap:\n            return [hashmap[target - val], idx]\n\n        hashmap[val] = idx\n\n\nif __name__ == \"__main__\":\n    nums = [2, 7, 11, 15]\n    target = 9\n    assert twoSum(nums, target) == [0, 1]\n</code></pre> 1. Two Sum - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;nums, int target) {\n    unordered_map&lt;int, int&gt; hashmap;\n\n    for (size_t i = 0; i &lt; nums.size(); i++) {\n        int complement = target - nums[i];\n\n        if (hashmap.find(complement) != hashmap.end()) {\n            return {hashmap[complement], (int)i};\n        }\n        hashmap[nums[i]] = (int)i;\n    }\n\n    return {-1, -1};\n}\n\nint main() {\n    vector&lt;int&gt; nums = {2, 7, 11, 15};\n    int target = 9;\n    vector&lt;int&gt; result = twoSum(nums, target);\n    cout &lt;&lt; result[0] &lt;&lt; \", \" &lt;&lt; result[1] &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/leetpattern/hash_map/#409-longest-palindrome","title":"409. Longest Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, string, greedy</p> </li> <li>Return the length of the longest palindrome that can be built with the characters in the string.</li> </ul> 409. Longest Palindrome - Python Solution<pre><code>def longestPalindrome(s: str) -&gt; int:\n    hashmap = dict()\n    result = 0\n\n    for char in s:\n        if char not in hashmap or hashmap[char] == 0:\n            hashmap[char] = 1\n        else:\n            result += 2\n            hashmap[char] = 0\n\n    if any(hashmap.values()):\n        result += 1\n\n    return result\n\n\nprint(longestPalindrome(\"abccccdd\"))  # 7\n</code></pre>"},{"location":"content/leetpattern/hash_map/#1365-how-many-numbers-are-smaller-than-the-current-number","title":"1365. How Many Numbers Are Smaller Than the Current Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, sorting, counting</p> </li> <li>For each number in the array, return how many numbers are smaller than it.</li> </ul> 1365. How Many Numbers Are Smaller Than the Current Number - Python Solution<pre><code>from typing import List\n\n\ndef smallerNumbersThanCurrent(nums: List[int]) -&gt; List[int]:\n    sortedNums = sorted(nums)\n\n    hashmap = dict()\n\n    for i, num in enumerate(sortedNums):\n        if num not in hashmap:\n            hashmap[num] = i\n\n    result = []\n    for i in range(len(sortedNums)):\n        result.append(hashmap[nums[i]])\n\n    return result\n\n\nnums = [8, 1, 2, 2, 3]\nprint(smallerNumbersThanCurrent(nums))  # [4, 0, 1, 1, 3]\n</code></pre>"},{"location":"content/leetpattern/hash_map/#202-happy-number","title":"202. Happy Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, math, two pointers</p> </li> <li>Return <code>True</code> if the number is a happy number, otherwise, return <code>False</code>.</li> <li>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.</li> </ul> 202. Happy Number - Python Solution<pre><code>def isHappy(n: int) -&gt; bool:\n\n    def getSum(n):\n        sum_of_squares = 0\n        while n:\n            a, b = divmod(n, 10)\n            sum_of_squares += b**2\n            n = a\n        return sum_of_squares\n\n    record = set()\n\n    while True:\n        if n == 1:\n            return True\n\n        if n in record:\n            return False\n        else:\n            record.add(n)\n\n        n = getSum(n)\n\n\nn = 19\nprint(isHappy(n))  # True\n</code></pre>"},{"location":"content/leetpattern/hash_map/#454-4sum-ii","title":"454. 4Sum II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table</p> </li> <li>Return the number of tuples <code>(i, j, k, l)</code> such that <code>A[i] + B[j] + C[k] + D[l] == 0</code>.</li> </ul> 454. 4Sum II - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\ndef fourSumCount(\n    nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]\n) -&gt; int:\n\n    sumAB = defaultdict(int)\n    result = 0\n\n    for i in nums1:\n        for j in nums2:\n            sumAB[i + j] += 1\n\n    for i in nums3:\n        for j in nums4:\n            if -(i + j) in sumAB:\n                result += sumAB[-(i + j)]\n\n    return result\n\n\nnums1 = [1, 2]\nnums2 = [-2, -1]\nnums3 = [-1, 2]\nnums4 = [0, 2]\nprint(fourSumCount(nums1, nums2, nums3, nums4))  # 2\n</code></pre>"},{"location":"content/leetpattern/hash_set/","title":"Hash Set","text":""},{"location":"content/leetpattern/hash_set/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 349. Intersection of Two Arrays (Easy)</li> </ul>"},{"location":"content/leetpattern/hash_set/#349-intersection-of-two-arrays","title":"349. Intersection of Two Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, two pointers, binary search, sorting 349. Intersection of Two Arrays - Python Solution<pre><code>from typing import List\n\n\n# Set\ndef intersectionSet(nums1: List[int], nums2: List[int]) -&gt; List[int]:\n    set1 = set(nums1)\n    set2 = set(nums2)\n    return list(set1 &amp; set2)\n\n\n# Hash\ndef intersectionHash(nums1: List[int], nums2: List[int]) -&gt; List[int]:\n    set1 = set(nums1)\n    result = set()\n\n    for num in nums2:\n        if num in set1:\n            result.add(num)\n\n    return list(result)\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |     Set    | O(n+m) |  O(n+m) |\n# |    Hash    | O(n+m) |   O(n)  |\n# |------------|--------|---------|\n\n\nnums1 = [1, 2, 2, 1]\nnums2 = [2, 2]\nprint(intersectionSet(nums1, nums2))  # [2]\nprint(intersectionHash(nums1, nums2))  # [2]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/heap/","title":"Heap","text":""},{"location":"content/leetpattern/heap/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1046. Last Stone Weight (Easy)</li> </ul>"},{"location":"content/leetpattern/heap/#1046-last-stone-weight","title":"1046. Last Stone Weight","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, heap priority queue</p> </li> <li>Heap<ul> <li>Time: O(n log n); Space: O(n)</li> </ul> </li> <li>0/1 Knapsack<ul> <li>Time: O(n); Space: O(n)</li> </ul> </li> </ul> 1046. Last Stone Weight - Python Solution<pre><code>from heapq import heapify, heappop, heappush\nfrom typing import List\n\n\n# Heap\ndef lastStoneWeightHeap(stones: List[int]) -&gt; int:\n    maxHeap = [-s for s in stones]\n    heapify(maxHeap)\n\n    while len(maxHeap) &gt; 1:\n        s1 = heappop(maxHeap)\n        s2 = heappop(maxHeap)\n\n        if s1 != s2:\n            heappush(maxHeap, s1 - s2)\n\n    return -maxHeap[0] if maxHeap else 0\n\n\n# 0/1 Knapsack\ndef lastStoneWeightKnapsack(stones: List[int]) -&gt; int:\n    total = sum(stones)\n    target = total // 2\n\n    dp = [0 for _ in range(target + 1)]\n\n    for i in stones:\n        for j in range(target, i - 1, -1):\n            dp[j] = max(dp[j], dp[j - i] + i)\n\n    return total - 2 * dp[target]\n\n\nif __name__ == \"__main__\":\n    stones = [2, 7, 4, 1, 8, 1]\n    assert lastStoneWeightHeap(stones) == 1\n    assert lastStoneWeightKnapsack(stones) == 1\n</code></pre> 1046. Last Stone Weight - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;queue&gt;\n\nusing namespace std;\n\nint lastStoneWeight(vector&lt;int&gt; &amp;stones)\n{\n    priority_queue&lt;int&gt; maxHeap(stones.begin(), stones.end());\n\n    while (maxHeap.size() &gt;= 1)\n    {\n        int first = maxHeap.top();\n        maxHeap.pop();\n        int second = maxHeap.top();\n        maxHeap.pop();\n\n        if (first != second)\n        {\n            maxHeap.push(first - second);\n        }\n    }\n\n    return maxHeap.empty() ? 0 : maxHeap.top();\n}\n\nint main()\n{\n    vector&lt;int&gt; stones = {2, 7, 4, 1, 8, 1};\n    cout &lt;&lt; lastStoneWeight(stones) &lt;&lt; endl; // 1\n    return 0;\n}\n</code></pre>"},{"location":"content/leetpattern/heap_merge_k_sorted/","title":"Heap Merge K Sorted","text":""},{"location":"content/leetpattern/heap_merge_k_sorted/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 23. Merge k Sorted Lists (Hard)</li> <li> 373. Find K Pairs with Smallest Sums (Medium)</li> <li> 378. Kth Smallest Element in a Sorted Matrix (Medium)</li> </ul>"},{"location":"content/leetpattern/heap_merge_k_sorted/#23-merge-k-sorted-lists","title":"23. Merge k Sorted Lists","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: linked list, divide and conquer, heap priority queue, merge sort</p> </li> <li>Prerequisite: 21. Merge Two Sorted Lists</li> <li>Video explanation: 23. Merge K Sorted Lists - NeetCode</li> </ul> 23. Merge k Sorted Lists - Python Solution<pre><code>import copy\nimport heapq\nfrom typing import List, Optional\n\nfrom template import ListNode\n\n\n# Divide and Conquer\ndef mergeKListsDC(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    if not lists or len(lists) == 0:\n        return None\n\n    def mergeTwo(l1, l2):\n        dummy = ListNode()\n        cur = dummy\n\n        while l1 and l2:\n            if l1.val &lt; l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n\n            cur = cur.next\n\n        cur.next = l1 if l1 else l2\n\n        return dummy.next\n\n    while len(lists) &gt; 1:\n        merged = []\n\n        for i in range(0, len(lists), 2):\n            l1 = lists[i]\n            l2 = lists[i + 1] if i + 1 &lt; len(lists) else None\n            merged.append(mergeTwo(l1, l2))\n\n        lists = merged\n\n    return lists[0]\n\n\n# Heap - Merge k Sorted\ndef mergeKLists(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    minHeap = []  # (val, idx, node)\n\n    for idx, head in enumerate(lists):\n        if head:\n            heapq.heappush(minHeap, (head.val, idx, head))\n\n    while minHeap:\n        _, idx, node = heapq.heappop(minHeap)\n        cur.next = node\n        cur = cur.next\n\n        node = node.next\n        if node:\n            heapq.heappush(minHeap, (node.val, idx, node))\n\n    return dummy.next\n\n\nn1 = ListNode.create([1, 4, 5])\nn2 = ListNode.create([1, 3, 4])\nn3 = ListNode.create([2, 6])\nlists = [n1, n2, n3]\nlists1 = copy.deepcopy(lists)\nlists2 = copy.deepcopy(lists)\nprint(mergeKListsDC(lists1))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6\nprint(mergeKLists(lists2))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6\n</code></pre>"},{"location":"content/leetpattern/heap_merge_k_sorted/#373-find-k-pairs-with-smallest-sums","title":"373. Find K Pairs with Smallest Sums","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, heap priority queue 373. Find K Pairs with Smallest Sums - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Heap - Merge K Sorted\ndef kSmallestPairs(\n    nums1: List[int], nums2: List[int], k: int\n) -&gt; List[List[int]]:\n    if not nums1 or not nums2 or k &lt;= 0:\n        return []\n\n    res = []\n    min_heap = []\n\n    for j in range(min(k, len(nums2))):\n        heapq.heappush(min_heap, (nums1[0] + nums2[j], 0, j))\n\n    while k &gt; 0 and min_heap:\n        _, i, j = heapq.heappop(min_heap)\n        res.append([nums1[i], nums2[j]])\n        k -= 1\n\n        if i + 1 &lt; len(nums1):\n            heapq.heappush(min_heap, (nums1[i + 1] + nums2[j], i + 1, j))\n\n    return res\n\n\nif __name__ == \"__main__\":\n    nums1 = [1, 2, 4, 5, 6]\n    nums2 = [3, 5, 7, 9]\n    k = 3\n    assert kSmallestPairs(nums1, nums2, k) == [[1, 3], [2, 3], [1, 5]]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/heap_merge_k_sorted/#378-kth-smallest-element-in-a-sorted-matrix","title":"378. Kth Smallest Element in a Sorted Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sorting, heap priority queue, matrix</p> </li> <li>Given an <code>n x n</code> matrix where each of the rows and columns are sorted in ascending order, return the <code>k-th</code> smallest element in the matrix.</li> </ul> 378. Kth Smallest Element in a Sorted Matrix - Python Solution<pre><code>from heapq import heapify, heappop, heappush\nfrom typing import List\n\n\n# Heap - Merge K Sorted\ndef kthSmallestHeap(matrix: List[List[int]], k: int) -&gt; int:\n    n = len(matrix)\n    heap = [(matrix[i][0], i, 0) for i in range(n)]\n    heapify(heap)\n\n    for _ in range(k - 1):\n        _, row, col = heappop(heap)\n\n        if col + 1 &lt; n:\n            heappush(heap, (matrix[row][col + 1], row, col + 1))\n\n    return heappop(heap)[0]\n\n\n# Binary Search\ndef kthSmallestBinarySearch(matrix: List[List[int]], k: int) -&gt; int:\n    n = len(matrix)\n\n    def check(mid):\n        i, j = n - 1, 0\n        num = 0\n\n        while i &gt;= 0 and j &lt; n:\n            if matrix[i][j] &lt;= mid:\n                num += i + 1\n                j += 1\n            else:\n                i -= 1\n\n        return num &gt;= k\n\n    left, right = matrix[0][0], matrix[-1][-1]\n\n    while left &lt; right:\n        mid = (left + right) // 2\n        if check(mid):\n            right = mid\n        else:\n            left = mid + 1\n\n    return left\n\n\nmatrix = [[1, 5, 9], [10, 11, 13], [12, 13, 15]]\nk = 8\n\nprint(kthSmallestHeap(matrix, k))  # 13\nprint(kthSmallestBinarySearch(matrix, k))  # 13\n</code></pre>"},{"location":"content/leetpattern/heap_top_k/","title":"Heap Top K","text":""},{"location":"content/leetpattern/heap_top_k/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 215. Kth Largest Element in an Array (Medium)</li> <li> 973. K Closest Points to Origin (Medium)</li> <li> 347. Top K Frequent Elements (Medium)</li> <li> 692. Top K Frequent Words (Medium)</li> <li> 264. Ugly Number II (Medium)</li> <li> 451. Sort Characters By Frequency (Medium)</li> <li> 703. Kth Largest Element in a Stream (Easy)</li> <li> 767. Reorganize String (Medium)</li> <li> 786. K-th Smallest Prime Fraction (Medium)</li> </ul>"},{"location":"content/leetpattern/heap_top_k/#215-kth-largest-element-in-an-array","title":"215. Kth Largest Element in an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, divide and conquer, sorting, heap priority queue, quickselect 215. Kth Largest Element in an Array - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\ndef findKthLargest(nums: List[int], k: int) -&gt; int:\n    min_heap = []\n\n    for i, num in enumerate(nums):\n        heapq.heappush(min_heap, num)\n        if i &gt;= k:\n            heapq.heappop(min_heap)\n\n    return min_heap[0]\n\n\nif __name__ == \"__main__\":\n    assert findKthLargest([3, 2, 1, 5, 6, 4], 2) == 5\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/heap_top_k/#973-k-closest-points-to-origin","title":"973. K Closest Points to Origin","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, divide and conquer, geometry, sorting, heap priority queue, quickselect 973. K Closest Points to Origin - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\ndef kClosest(points: List[List[int]], k: int) -&gt; List[List[int]]:\n    heap = []\n\n    for x, y in points:\n        dist = -(x**2 + y**2)  # max heap\n        if len(heap) &lt; k:\n            heapq.heappush(heap, (dist, x, y))\n        else:\n            heapq.heappushpop(heap, (dist, x, y))  # push and pop the smallest\n\n    return [[x, y] for (_, x, y) in heap]\n\n\n# Time complexity: O(n * log(k))\n#   - O(log(k)) for heapify\n#   - O(n) for iterating through the input list\n# Space complexity: O(k)\n\npoints = [[1, 3], [-2, 2]]\nk = 1\nprint(kClosest(points, k))  # [[-2, 2]]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/heap_top_k/#347-top-k-frequent-elements","title":"347. Top K Frequent Elements","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, divide and conquer, sorting, heap priority queue, bucket sort, counting, quickselect 347. Top K Frequent Elements - Python Solution<pre><code>import heapq\nfrom collections import Counter\nfrom typing import List\n\n\n# Heap + Counter\ndef topKFrequent(nums: List[int], k: int) -&gt; List[int]:\n    minHeap = []\n\n    for val, freq in Counter(nums).items():\n        if len(minHeap) &lt; k:\n            heapq.heappush(minHeap, (freq, val))\n        else:\n            heapq.heappushpop(minHeap, (freq, val))\n\n    return [i for _, i in minHeap]\n\n\n# Counter (Most Common)\ndef topKFrequentCounter(nums: List[int], k: int) -&gt; List[int]:\n    commons = Counter(nums).most_common(k)\n    return [i for i, _ in commons]\n\n\nnums = [1, 1, 1, 2, 2, 3]\nk = 2\nprint(topKFrequent(nums, k))  # [1, 2]\nprint(topKFrequentCounter(nums, k))  # [1, 2]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/heap_top_k/#692-top-k-frequent-words","title":"692. Top K Frequent Words","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, trie, sorting, heap priority queue, bucket sort, counting 692. Top K Frequent Words - Python Solution<pre><code>import heapq\nfrom collections import Counter\nfrom typing import List\n\n\nclass WordFrequency:\n    def __init__(self, word, freq):\n        self.word = word\n        self.freq = freq\n\n    def __lt__(self, other):\n        # If the frequency is different\n        if self.freq != other.freq:\n            # The word with the lower frequency comes first\n            return self.freq &lt; other.freq\n        else:\n            # The word with the lower alphabetical order comes first\n            return self.word &gt; other.word\n\n\ndef topKFrequent(words: List[str], k: int) -&gt; List[str]:\n    heap = []\n\n    for word, freq in Counter(words).items():\n        heapq.heappush(heap, WordFrequency(word, freq))\n\n        if len(heap) &gt; k:\n            heapq.heappop(heap)\n\n    heap.sort(reverse=True)\n    return [x.word for x in heap]\n\n\nwords = [\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"]\nk = 2\nprint(topKFrequent(words, k))  # [\"i\", \"love\"]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/heap_top_k/#264-ugly-number-ii","title":"264. Ugly Number II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, math, dynamic programming, heap priority queue 264. Ugly Number II - Python Solution<pre><code>import heapq\n\n\ndef nthUglyNumber(n: int) -&gt; int:\n    heap = [1]\n    seen = set(heap)\n\n    factors = [2, 3, 5]\n    current = 1\n\n    # Pop the smallest ugly number n times\n    for _ in range(n):\n        current = heapq.heappop(heap)  # Pop the smallest ugly number\n\n        for factor in factors:\n            new = current * factor\n            if new not in seen:\n                seen.add(new)\n                heapq.heappush(heap, new)\n\n    return current\n\n\nprint(nthUglyNumber(10))  # 12\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/heap_top_k/#451-sort-characters-by-frequency","title":"451. Sort Characters By Frequency","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sorting, heap priority queue, bucket sort, counting 451. Sort Characters By Frequency - Python Solution<pre><code>import heapq\nfrom collections import Counter\n\n\ndef frequencySort(s: str) -&gt; str:\n    result = \"\"\n\n    # Max Heap\n    heap = [(-freq, val) for val, freq in Counter(s).items()]\n    heapq.heapify(heap)\n\n    while heap:\n        freq, val = heapq.heappop(heap)\n        result += val * -freq\n\n    return result\n\n\nprint(frequencySort(\"tree\"))  # eert\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/heap_top_k/#703-kth-largest-element-in-a-stream","title":"703. Kth Largest Element in a Stream","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, design, binary search tree, heap priority queue, binary tree, data stream 703. Kth Largest Element in a Stream - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Heap\nclass KthLargest:\n\n    def __init__(self, k: int, nums: List[int]):\n        self.k = k\n        self.heap = []\n        for num in nums:\n            self.add(num)\n\n    def add(self, val: int) -&gt; int:\n        heapq.heappush(self.heap, val)\n\n        if len(self.heap) &gt; self.k:\n            heapq.heappop(self.heap)\n\n        return self.heap[0]\n\n\nobj = KthLargest(3, [4, 5, 8, 2])\nprint(obj.add(3))  # 4\nprint(obj.add(5))  # 5\nprint(obj.add(10))  # 5\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/heap_top_k/#767-reorganize-string","title":"767. Reorganize String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, greedy, sorting, heap priority queue, counting 767. Reorganize String - Python Solution<pre><code>import heapq\nfrom collections import Counter\n\n\ndef reorganizeString(s: str) -&gt; str:\n    if not s:\n        return \"\"\n\n    heap = [(-freq, char) for char, freq in Counter(s).items()]  # max heap\n    heapq.heapify(heap)\n\n    result = []\n    prev_count, prev_char = 0, \"\"\n\n    while heap:\n        count, char = heapq.heappop(heap)  # pop the most frequent character\n        result.append(char)  # append the character to the result\n\n        if (\n            prev_count &lt; 0\n        ):  # if the previous character still has remaining count\n            heapq.heappush(heap, (prev_count, prev_char))\n\n        prev_count = (\n            count + 1\n        )  # update the current character's remaining count\n        prev_char = char  # update the current character\n\n    # check if there is any invalid result\n    if len(result) != len(s):\n        return \"\"\n\n    return \"\".join(result)\n\n\nprint(reorganizeString(\"aab\"))\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/heap_top_k/#786-k-th-smallest-prime-fraction","title":"786. K-th Smallest Prime Fraction","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, sorting, heap priority queue 786. K-th Smallest Prime Fraction - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\ndef kthSmallestPrimeFraction(arr: List[int], k: int) -&gt; List[int]:\n    max_heap = []\n\n    for j in range(1, len(arr)):\n        for i in range(j):\n            heapq.heappush(max_heap, (-arr[i] / arr[j], arr[i], arr[j]))\n\n            if len(max_heap) &gt; k:\n                heapq.heappop(max_heap)\n\n    return [max_heap[0][1], max_heap[0][2]]\n\n\narr = [1, 2, 3, 5]\nk = 3\nprint(kthSmallestPrimeFraction(arr, k))  # [2, 5]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/heap_two_heaps/","title":"Heap Two Heaps","text":""},{"location":"content/leetpattern/heap_two_heaps/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 295. Find Median from Data Stream (Hard)</li> <li> 480. Sliding Window Median (Hard)</li> <li> 502. IPO (Hard)</li> </ul>"},{"location":"content/leetpattern/heap_two_heaps/#295-find-median-from-data-stream","title":"295. Find Median from Data Stream","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: two pointers, design, sorting, heap priority queue, data stream 295. Find Median from Data Stream - Python Solution<pre><code>from heapq import heappop, heappush\n\n\n# Dual Heaps\nclass MedianFinder:\n\n    def __init__(self):\n        self.minHeap = []\n        self.maxHeap = []\n        self.min_size = 0\n        self.max_size = 0\n\n    def addNum(self, num: int) -&gt; None:\n        heappush(self.maxHeap, -num)\n        heappush(self.minHeap, -heappop(self.maxHeap))\n        self.min_size += 1\n\n        if self.min_size &gt; self.max_size:\n            heappush(self.maxHeap, -heappop(self.minHeap))\n            self.min_size -= 1\n            self.max_size += 1\n\n    def findMedian(self) -&gt; float:\n        if self.min_size == self.max_size:\n            return (-self.maxHeap[0] + self.minHeap[0]) / 2.0\n        return -self.maxHeap[0]\n\n\nobj = MedianFinder()\nobj.addNum(1)\nobj.addNum(2)\nassert obj.findMedian() == 1.5\nobj.addNum(3)\nassert obj.findMedian() == 2\nobj.addNum(4)\nassert obj.findMedian() == 2.5\nobj.addNum(5)\nassert obj.findMedian() == 3\nprint(\"All Passed.\")\n</code></pre></p> </li> </ul> 295. Find Median from Data Stream - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass MedianFinder {\n   private:\n    priority_queue&lt;int&gt; maxHeap;\n    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;\n    int max_size = 0;\n    int min_size = 0;\n\n   public:\n    MedianFinder() {}\n\n    void addNum(int num) {\n        if (min_size == max_size) {\n            minHeap.push(num);\n            maxHeap.push(minHeap.top());\n            minHeap.pop();\n            max_size++;\n        } else {\n            maxHeap.push(num);\n            minHeap.push(maxHeap.top());\n            maxHeap.pop();\n            min_size++;\n        }\n    }\n\n    double findMedian() {\n        if (min_size == max_size) {\n            return (maxHeap.top() + minHeap.top()) / 2.0;\n        } else {\n            return (double)maxHeap.top();\n        }\n    }\n};\n\nint main() {\n    MedianFinder* obj = new MedianFinder();\n    obj-&gt;addNum(1);\n    obj-&gt;addNum(2);\n    cout &lt;&lt; obj-&gt;findMedian() &lt;&lt; endl;  // 1.5\n    obj-&gt;addNum(3);\n    cout &lt;&lt; obj-&gt;findMedian() &lt;&lt; endl;  // 2\n    return 0;\n}\n</code></pre>"},{"location":"content/leetpattern/heap_two_heaps/#480-sliding-window-median","title":"480. Sliding Window Median","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, sliding window, heap priority queue 480. Sliding Window Median - Python Solution<pre><code>import heapq\nfrom typing import List\n\nfrom sortedcontainers import SortedList\n\n\n# Heap - Two Heaps\ndef medianSlidingWindow1(nums: List[int], k: int) -&gt; List[float]:\n    min_heap, max_heap = [], []\n\n    for i in range(k):\n        heapq.heappush(min_heap, (nums[i], i))\n    for i in range(k // 2):\n        n, idx = heapq.heappop(min_heap)\n        heapq.heappush(max_heap, (-n, idx))\n\n    res = [\n        (\n            (min_heap[0][0] - max_heap[0][0]) / 2\n            if k % 2 == 0\n            else min_heap[0][0] * 1.0\n        )\n    ]\n\n    for i in range(k, len(nums)):\n        if nums[i] &lt; min_heap[0][0]:\n            heapq.heappush(max_heap, (-nums[i], i))\n\n            if nums[i - k] &gt;= min_heap[0][0]:\n                n, idx = heapq.heappop(max_heap)\n                heapq.heappush(min_heap, (-n, idx))\n        else:\n            heapq.heappush(min_heap, (nums[i], i))\n\n            if nums[i - k] &lt;= min_heap[0][0]:\n                n, idx = heapq.heappop(min_heap)\n                heapq.heappush(max_heap, (-n, idx))\n\n        while min_heap and min_heap[0][1] &lt;= i - k:\n            heapq.heappop(min_heap)\n        while max_heap and max_heap[0][1] &lt;= i - k:\n            heapq.heappop(max_heap)\n\n        res.append(\n            (min_heap[0][0] - max_heap[0][0]) / 2\n            if k % 2 == 0\n            else min_heap[0][0] * 1.0\n        )\n\n    return res\n\n\n# Sorted List\ndef medianSlidingWindow2(nums: List[int], k: int) -&gt; List[float]:\n    window = SortedList()\n    res = []\n\n    for i in range(len(nums)):\n        window.add(nums[i])\n\n        if len(window) == k:\n            if k % 2 == 1:\n                res.append(window[k // 2])\n            else:\n                res.append((window[k // 2 - 1] + window[k // 2]) / 2.0)\n\n            window.remove(nums[i - k + 1])\n\n    return res\n\n\nnums = [1, 2, 3, 4, 2, 3, 1, 4, 2]\nk = 3\nprint(medianSlidingWindow1(nums, k))\nprint(medianSlidingWindow2(nums, k))\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/heap_two_heaps/#502-ipo","title":"502. IPO","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sorting, heap priority queue 502. IPO - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Heap - Two Heaps\ndef findMaximizedCapital(\n    k: int, w: int, profits: List[int], capital: List[int]\n) -&gt; int:\n    \"\"\"\n    Time Complexity: O(k log N)\n    Space Complexity: O(N)\n    \"\"\"\n    if not profits or not capital:\n        return w\n\n    if w &gt;= max(capital) and k &gt;= len(capital):\n        return sum(profits) + w\n\n    max_profit = []\n    min_capital = [(c, p) for c, p in zip(capital, profits)]\n    heapq.heapify(min_capital)\n\n    for _ in range(k):\n        while min_capital and min_capital[0][0] &lt;= w:\n            _, pro = heapq.heappop(min_capital)\n            heapq.heappush(max_profit, -pro)\n\n        if max_profit:\n            w += -heapq.heappop(max_profit)\n\n    return w\n\n\nif __name__ == \"__main__\":\n    k = 2\n    w = 0\n    profits = [1, 2, 3]\n    capital = [0, 1, 1]\n    assert findMaximizedCapital(k, w, profits, capital) == 4\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/intervals/","title":"Intervals","text":""},{"location":"content/leetpattern/intervals/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 55. Jump Game (Medium)</li> <li> 45. Jump Game II (Medium)</li> <li> 452. Minimum Number of Arrows to Burst Balloons (Medium)</li> <li> 435. Non-overlapping Intervals (Medium)</li> <li> 763. Partition Labels (Medium)</li> <li> 56. Merge Intervals (Medium)</li> </ul>"},{"location":"content/leetpattern/intervals/#55-jump-game","title":"55. Jump Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> <li>Return <code>True</code> if you can reach the last index, otherwise <code>False</code>.</li> </ul> 55. Jump Game - Python Solution<pre><code>from typing import List\n\n\n# Greedy - Interval\ndef canJump(nums: List[int]) -&gt; bool:\n    n = len(nums)\n    reach = 0\n    i = 0\n\n    while reach &gt;= i:\n        if reach &gt;= n - 1:\n            return True\n        reach = max(reach, i + nums[i])\n        i += 1\n\n    return False\n\n\nif __name__ == \"__main__\":\n    assert canJump([2, 3, 1, 1, 4]) is True\n    assert canJump([3, 2, 1, 0, 4]) is False\n</code></pre> 55. Jump Game - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool canJump(vector&lt;int&gt;&amp; nums) {\n        int canReach = 0;\n        int n = nums.size();\n\n        for (int i = 0; i &lt; n; i++) {\n            if (i &gt; canReach) return false;\n            canReach = max(canReach, i + nums[i]);\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution obj;\n    vector&lt;int&gt; nums = {2, 3, 1, 1, 4};\n    cout &lt;&lt; obj.canJump(nums) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/leetpattern/intervals/#45-jump-game-ii","title":"45. Jump Game II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> <li>Return the minimum number of jumps to reach the last index.</li> </ul> 45. Jump Game II - Python Solution<pre><code>from typing import List\n\n\n# Greedy - Interval\ndef jump(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n == 1:\n        return 0\n\n    reach = 0\n    left, right = 0, 0\n    res = 0\n\n    while right &lt; n - 1:\n        for i in range(left, right + 1):\n            reach = max(reach, i + nums[i])\n\n        left = right + 1\n        right = reach\n        res += 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert jump([2, 3, 1, 1, 4]) == 2\n    assert jump([2, 3, 0, 1, 4]) == 2\n</code></pre>"},{"location":"content/leetpattern/intervals/#452-minimum-number-of-arrows-to-burst-balloons","title":"452. Minimum Number of Arrows to Burst Balloons","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> <li>Return the minimum number of arrows.</li> </ul> <ul> <li>Differece between two versions<ol> <li>Start from 1: if there is no overlap, we add one more arrow.</li> <li>Start from the number of balloons: if there is overlap, we need to reduce one arrow.</li> </ol> </li> </ul> 452. Minimum Number of Arrows to Burst Balloons - Python Solution<pre><code>from typing import List\n\nimport matplotlib.pyplot as plt\n\n\n# Greedy - Interval\ndef findMinArrowShotsGreedy1(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    if n &lt;= 1:\n        return n\n\n    res = 1\n    points.sort(key=lambda x: x[0])\n\n    for i in range(1, n):\n        if points[i][0] &gt; points[i - 1][1]:\n            res += 1\n        else:\n            points[i][1] = min(points[i][1], points[i - 1][1])\n    return res\n\n\n# Greedy - Interval (Neetcode's version)\ndef findMinArrowShotsGreedy2(points: List[List[int]]) -&gt; int:\n    res = len(points)\n    if res == 0:\n        return 0\n\n    points.sort()\n    prev = points[0]\n\n    for i in range(1, len(points)):\n        cur = points[i]\n        if cur[0] &lt;= prev[1]:\n            res -= 1\n            prev = [cur[0], min(prev[1], cur[1])]\n        else:\n            prev = cur\n\n    return res\n\n\n# Greedy - Interval\ndef findMinArrowShotsGreedy3(points: List[List[int]]) -&gt; int:\n    if not points:\n        return 0\n\n    points.sort(key=lambda x: x[1])\n\n    res = 1\n    cur_end = points[0][1]\n\n    for i in range(1, len(points)):\n        if points[i][0] &gt; cur_end:\n            res += 1\n            cur_end = points[i][1]\n\n    return res\n\n\n# Utility\ndef plot(points, i=None):\n    plt.figure(figsize=(8, 4))\n    for idx in range(len(points)):\n        color = \"b\" if idx == i else \"k\"\n        plt.plot(\n            [points[idx][0], points[idx][1]],\n            [idx + 1, idx + 1],\n            f\"{color}o-\",\n            label=f\"Line {idx + 1}\",\n        )\n\n    plt.title(\"Find Min Arrow Shots\")\n    plt.xlabel(\"X-axis\")\n    plt.xlim(0, 17)\n    plt.grid(True)\n    plt.savefig(f\"find_min_arrow_shots_{i}.png\")\n    plt.show()\n\n\n# |------------|-----------|---------|\n# |  Approach  |  Time     |  Space  |\n# |------------|-----------|---------|\n# |  Greedy    |  O(NlogN) |  O(1)   |\n# |------------|-----------|---------|\n\n\npoints = [[10, 16], [2, 8], [1, 6], [7, 12]]\nprint(findMinArrowShotsGreedy1(points))  # 2\nprint(findMinArrowShotsGreedy2(points))  # 2\n</code></pre>"},{"location":"content/leetpattern/intervals/#435-non-overlapping-intervals","title":"435. Non-overlapping Intervals","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy, sorting 435. Non-overlapping Intervals - Python Solution<pre><code>from typing import List\n\n\ndef eraseOverlapIntervals(intervals: List[List[int]]) -&gt; int:\n    if len(intervals) &lt;= 1:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n    result = 0\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &gt;= intervals[i - 1][1]:\n            continue\n        else:\n            result += 1\n            intervals[i][1] = min(intervals[i][1], intervals[i - 1][1])\n\n    return result\n\n\nprint(eraseOverlapIntervals([[1, 2], [2, 3], [3, 4], [1, 3]]))  # 1\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/intervals/#763-partition-labels","title":"763. Partition Labels","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, two pointers, string, greedy 763. Partition Labels - Python Solution<pre><code>from typing import List\n\n\n# 1. Hashmap\ndef partitionLabels1(s: str) -&gt; List[int]:\n    hashmap = {}\n\n    for i, j in enumerate(s):\n        if j not in hashmap:\n            hashmap[j] = [i, i]\n        else:\n            hashmap[j][1] = i\n\n    intervals = list(hashmap.values())\n    intervals.sort(key=lambda x: x[0])\n\n    if len(intervals) &lt; 2:\n        return len(intervals)\n\n    res = []\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &lt; intervals[i - 1][1]:\n            intervals[i][1] = max(intervals[i][1], intervals[i - 1][1])\n        else:\n            res.append(intervals[i][0])\n\n    res.append(intervals[-1][1] + 1)\n\n    if len(res) == 1:\n        return res\n    else:\n        for i in range(len(res) - 1, 0, -1):\n            res[i] -= res[i - 1]\n        return res\n\n\n# Single Pass Partitioning\ndef partitionLabels2(s: str) -&gt; List[int]:\n    last = {c: i for i, c in enumerate(s)}\n    res = []\n    start, end = 0, 0\n\n    for i, c in enumerate(s):\n        end = max(end, last[c])\n        if end == i:\n            res.append(end - start + 1)\n            start = i + 1\n\n    return res\n\n\nprint(partitionLabels1(\"abaccd\"))  # [3, 2, 1]\nprint(partitionLabels2(\"abaccd\"))  # [3, 2, 1]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/intervals/#56-merge-intervals","title":"56. Merge Intervals","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sorting</p> </li> <li>Merge all overlapping intervals.</li> </ul> 56. Merge Intervals - Python Solution<pre><code>from typing import List\n\n\n# Intervals\ndef merge(intervals: List[List[int]]) -&gt; List[List[int]]:\n    n = len(intervals)\n    if n &lt;= 1:\n        return intervals\n\n    intervals.sort(key=lambda x: x[0])\n    res = [intervals[0]]\n\n    for i in range(1, n):\n        if intervals[i][0] &lt;= res[-1][1]:\n            res[-1][1] = max(res[-1][1], intervals[i][1])\n        else:\n            res.append(intervals[i])\n\n    return res\n\n\nprint(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))\n# [[1, 6], [8, 10], [15, 18]]\n</code></pre> 56. Merge Intervals - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// Interval\nvector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {\n    sort(intervals.begin(), intervals.end());\n    vector&lt;vector&lt;int&gt;&gt; res;\n\n    for (auto&amp; range : intervals) {\n        if (!res.empty() &amp;&amp; range[0] &lt;= res.back()[1]) {\n            res.back()[1] = max(res.back()[1], range[1]);\n        } else {\n            res.emplace_back(range);\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;vector&lt;int&gt;&gt; intervals = {{1, 3}, {2, 6}, {8, 10}, {15, 18}};\n    vector&lt;vector&lt;int&gt;&gt; res = merge(intervals);\n    for (auto&amp; range : res) {\n        cout &lt;&lt; range[0] &lt;&lt; \", \" &lt;&lt; range[1] &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"content/leetpattern/kmp/","title":"KMP","text":""},{"location":"content/leetpattern/kmp/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 28. Find the Index of the First Occurrence in a String (Easy)</li> <li> 459. Repeated Substring Pattern (Easy)</li> <li> 686. Repeated String Match (Medium)</li> <li> 1392. Longest Happy Prefix (Hard)</li> <li> 214. Shortest Palindrome (Hard)</li> </ul>"},{"location":"content/leetpattern/kmp/#28-find-the-index-of-the-first-occurrence-in-a-string","title":"28. Find the Index of the First Occurrence in a String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string, string matching 28. Find the Index of the First Occurrence in a String - Python Solution<pre><code>from template import LPS\n\n\n# Brute Force\ndef strStrBF(haystack: str, needle: str) -&gt; int:\n    m, n = len(haystack), len(needle)\n    for i in range(m - n + 1):\n        if haystack[i : i + n] == needle:\n            return i\n    return -1\n\n\n# KMP\ndef strStrKMP(haystack: str, needle: str) -&gt; int:\n    lps = LPS(needle)\n    m, n = len(haystack), len(needle)\n    j = 0\n\n    for i in range(m):\n        while j &gt; 0 and haystack[i] != needle[j]:\n            j = lps[j - 1]\n        if haystack[i] == needle[j]:\n            j += 1\n        if j == n:\n            return i - n + 1\n    return -1\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# | Brute Force| O((m - n) * n)   | O(1)    |\n# | KMP        | O(m + n)         | O(n)    |\n# |------------|------------------|---------|\n\n\nhaystack = \"hello\"\nneedle = \"ll\"\nprint(strStrBF(haystack, needle))  # 2\nprint(strStrKMP(haystack, needle))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/kmp/#459-repeated-substring-pattern","title":"459. Repeated Substring Pattern","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, string matching 459. Repeated Substring Pattern - Python Solution<pre><code>from template import LPS\n\n\n# KMP\ndef repeatedSubstringPattern(s: str) -&gt; bool:\n    lps = LPS(s)\n    length = len(s)\n\n    if lps[-1] != 0 and length % (length - lps[-1]) == 0:\n        return True\n\n    return False\n\n\ns = \"abab\"\nprint(repeatedSubstringPattern(s))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/kmp/#686-repeated-string-match","title":"686. Repeated String Match","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, string matching 686. Repeated String Match - Python Solution<pre><code>import math\n\nfrom template import LPS\n\n\n# KMP\ndef repeatedStringMatch(a: str, b: str) -&gt; int:\n    min_repeat = math.ceil(len(b) / len(a))\n\n    def kmp(text, pattern):\n        n, m = len(text), len(pattern)\n        lps = LPS(pattern)\n        j = 0\n\n        for i in range(n):\n            while j &gt; 0 and text[i] != pattern[j]:\n                j = lps[j - 1]\n            if text[i] == pattern[j]:\n                j += 1\n            if j == m:\n                return i - j + 1\n        return -1\n\n    for i in range(min_repeat, min_repeat + 2):\n        if kmp(a * i, b) != -1:\n            return i\n    return -1\n\n\nprint(repeatedStringMatch(\"abcd\", \"cdabcdab\"))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/kmp/#1392-longest-happy-prefix","title":"1392. Longest Happy Prefix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, rolling hash, string matching, hash function 1392. Longest Happy Prefix - Python Solution<pre><code>from template import LPS\n\n\n# KMP\ndef longestPrefix(s: str) -&gt; str:\n    if len(s) &lt;= 1:\n        return \"\"\n\n    lps = LPS(s)\n\n    return s[: lps[-1]]\n\n\nprint(longestPrefix(\"ababab\"))  # abab\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/kmp/#214-shortest-palindrome","title":"214. Shortest Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, rolling hash, string matching, hash function 214. Shortest Palindrome - Python Solution<pre><code>from template import LPS\n\n\n# KMP\ndef shortestPalindrome(s: str) -&gt; str:\n    if not s:\n        return s\n\n    new = s + \"#\" + s[::-1]\n    lps = LPS(new)\n\n    add_len = len(s) - lps[-1]\n\n    return s[::-1][:add_len] + s\n\n\nprint(shortestPalindrome(\"aacecaaa\"))  # aaacecaaa\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/left_right_pointers/","title":"Left Right Pointers","text":""},{"location":"content/leetpattern/left_right_pointers/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 9. Palindrome Number (Easy)</li> <li> 15. 3Sum (Medium)</li> <li> 18. 4Sum (Medium)</li> <li> 69. Sqrt(x) (Easy)</li> <li> 88. Merge Sorted Array (Easy)</li> <li> 977. Squares of a Sorted Array (Easy)</li> <li> 881. Boats to Save People (Medium)</li> <li> 75. Sort Colors (Medium)</li> <li> 125. Valid Palindrome (Easy)</li> <li> 167. Two Sum II - Input Array Is Sorted (Medium)</li> <li> 11. Container With Most Water (Medium)</li> </ul>"},{"location":"content/leetpattern/left_right_pointers/#9-palindrome-number","title":"9. Palindrome Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math</p> </li> <li>Return true if the given number is a palindrome. Otherwise, return false.</li> </ul> 9. Palindrome Number - Python Solution<pre><code># Reverse\ndef isPalindromeReverse(x: int) -&gt; bool:\n    if x &lt; 0:\n        return False\n\n    return str(x) == str(x)[::-1]\n\n\n# Left Right Pointers\ndef isPalindromeLR(x: int) -&gt; bool:\n    if x &lt; 0:\n        return False\n\n    x = list(str(x))  # 121 -&gt; ['1', '2', '1']\n\n    left, right = 0, len(x) - 1\n\n    while left &lt; right:\n        if x[left] != x[right]:\n            return False\n        left += 1\n        right -= 1\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |  Reverse   |  O(N)  |   O(N)  |\n# | Left Right |  O(N)  |   O(1)  |\n# |------------|--------|---------|\n\n\nx = 121\nprint(isPalindromeReverse(x))  # True\nprint(isPalindromeLR(x))  # True\n</code></pre>"},{"location":"content/leetpattern/left_right_pointers/#15-3sum","title":"15. 3Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, sorting 15. 3Sum - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef threeSum(nums: List[int]) -&gt; List[List[int]]:\n    nums.sort()\n    res = []\n    n = len(nums)\n\n    for i in range(n - 2):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        left, right = i + 1, n - 1\n\n        while left &lt; right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total &gt; 0:\n                right -= 1\n            elif total &lt; 0:\n                left += 1\n            else:\n                res.append([nums[i], nums[left], nums[right]])\n\n                while left &lt; right and nums[left] == nums[left + 1]:\n                    left += 1\n\n                while left &lt; right and nums[right] == nums[right - 1]:\n                    right -= 1\n\n                left += 1\n                right -= 1\n\n    return res\n\n\nnums = [-1, 0, 1, 2, -1, -4]\nassert threeSum(nums) == [[-1, -1, 2], [-1, 0, 1]]\n</code></pre></p> </li> </ul> 15. 3Sum - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {\n    sort(nums.begin(), nums.end());\n    vector&lt;vector&lt;int&gt;&gt; res;\n    int n = nums.size();\n\n    for (int i = 0; i &lt; n - 2; i++) {\n        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) {\n            continue;\n        }\n\n        int left = i + 1, right = n - 1;\n\n        while (left &lt; right) {\n            int total = nums[i] + nums[left] + nums[right];\n\n            if (total &gt; 0)\n                right--;\n            else if (total &lt; 0)\n                left++;\n            else {\n                res.push_back({nums[i], nums[left], nums[right]});\n                while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++;\n                while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--;\n                left++;\n                right--;\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {-1, 0, 1, 2, -1, -4};\n    vector&lt;vector&lt;int&gt;&gt; res = threeSum(nums);\n    for (auto&amp; v : res) {\n        for (int i : v) {\n            cout &lt;&lt; i &lt;&lt; \" \";\n        }\n        cout &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"content/leetpattern/left_right_pointers/#18-4sum","title":"18. 4Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, sorting 18. 4Sum - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef fourSum(nums: List[int], target: int) -&gt; List[List[int]]:\n    \"\"\"Returns all unique quadruplets that sum up to the target.\"\"\"\n    nums.sort()\n    result = []\n\n    for i in range(len(nums) - 3):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        for j in range(i + 1, len(nums) - 2):\n            if j &gt; i + 1 and nums[j] == nums[j - 1]:\n                continue\n\n            left = j + 1\n            right = len(nums) - 1\n\n            while left &lt; right:\n                total = nums[i] + nums[j] + nums[left] + nums[right]\n\n                if total &gt; target:\n                    right -= 1\n                elif total &lt; target:\n                    left += 1\n                else:\n                    result.append([nums[i], nums[j], nums[left], nums[right]])\n                    while left &lt; right and nums[left] == nums[left + 1]:\n                        left += 1\n                    while left &lt; right and nums[right] == nums[right - 1]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n\n    return result\n\n\nnums = [1, 0, -1, 0, -2, 2]\ntarget = 0\nprint(fourSum(nums, target))\n# [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/left_right_pointers/#69-sqrtx","title":"69. Sqrt(x)","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, binary search 69. Sqrt(x) - Python Solution<pre><code># Left Right Pointers\ndef mySqrt(x: int) -&gt; int:\n    \"\"\"Returns the square root of a number.\"\"\"\n    if x &lt; 2:\n        return x\n\n    left, right = 0, x // 2\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        if mid * mid &lt;= x &lt; (mid + 1) * (mid + 1):\n            return mid\n        elif mid * mid &lt; x:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n\nx = 8\nprint(mySqrt(x))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/left_right_pointers/#88-merge-sorted-array","title":"88. Merge Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers, sorting 88. Merge Sorted Array - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef merge(nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None:\n    \"\"\"Merges two sorted arrays in-place.\"\"\"\n    p1, p2, t = m - 1, n - 1, m + n - 1\n\n    while p1 &gt;= 0 or p2 &gt;= 0:\n        if p1 == -1:\n            nums1[t] = nums2[p2]\n            p2 -= 1\n        elif p2 == -1:\n            nums1[t] = nums1[p1]\n            p1 -= 1\n        elif nums1[p1] &gt; nums2[p2]:\n            nums1[t] = nums1[p1]\n            p1 -= 1\n        else:\n            nums1[t] = nums2[p2]\n            p2 -= 1\n\n        t -= 1\n\n\nnums1 = [1, 2, 3, 0, 0, 0]\nm = 3\nnums2 = [2, 5, 6]\nn = 3\nmerge(nums1, m, nums2, n)\nprint(nums1)  # [1, 2, 2, 3, 5, 6]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/left_right_pointers/#977-squares-of-a-sorted-array","title":"977. Squares of a Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers, sorting 977. Squares of a Sorted Array - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef sortedSquares(nums: List[int]) -&gt; List[int]:\n    \"\"\"Returns the squares of the sorted array.\"\"\"\n    n = len(nums)\n    result = [0 for _ in range(n)]\n\n    left, right, tail = 0, n - 1, n - 1\n\n    while left &lt;= right:\n        if abs(nums[left]) &gt;= abs(nums[right]):\n            result[tail] = nums[left] ** 2\n            left += 1\n        else:\n            result[tail] = nums[right] ** 2\n            right -= 1\n        tail -= 1\n\n    return result\n\n\n# |---------------------|------|-------|\n# | Approach            | Time | Space |\n# |---------------------|------|-------|\n# | Left Right Pointers | O(n) | O(n)  |\n# |---------------------|------|-------|\n\n\nnums = [-4, -1, 0, 3, 10]\nprint(sortedSquares(nums))  # [0, 1, 9, 16, 100]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/left_right_pointers/#881-boats-to-save-people","title":"881. Boats to Save People","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy, sorting 881. Boats to Save People - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef numRescueBoats(people: List[int], limit: int) -&gt; int:\n    \"\"\"Returns the minimum number of boats to rescue people.\"\"\"\n    people.sort()\n    left, right = 0, len(people) - 1\n    boats = 0\n\n    while left &lt;= right:\n        if people[left] + people[right] &lt;= limit:\n            left += 1\n        right -= 1\n        boats += 1\n\n    return boats\n\n\npeople = [3, 2, 2, 1]\nlimit = 3\nprint(numRescueBoats(people, limit))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/left_right_pointers/#75-sort-colors","title":"75. Sort Colors","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, sorting 75. Sort Colors - Python Solution<pre><code>from copy import deepcopy\nfrom typing import List\n\n\n# Left Right Pointers\ndef sort_colors_lr_pointers(nums: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    n = len(nums)\n    left = 0\n    for right in range(n):\n        if nums[right] == 0:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n\n    for right in range(left, n):\n        if nums[right] == 1:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n\n\n# Three Pointers\ndef sort_colors_three_pointers(nums: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    cur = 0\n\n    while cur &lt;= right:\n        if nums[cur] == 0:\n            nums[left], nums[cur] = nums[cur], nums[left]\n            left += 1\n            cur += 1\n        elif nums[cur] == 2:\n            nums[right], nums[cur] = nums[cur], nums[right]\n            right -= 1\n        else:\n            cur += 1\n\n\nnums = [2, 0, 2, 1, 1, 0]\nnums1, nums2 = deepcopy(nums), deepcopy(nums)\nsort_colors_lr_pointers(nums1)\nprint(nums1)  # [0, 0, 1, 1, 2, 2]\nsort_colors_three_pointers(nums2)\nprint(nums2)  # [0, 0, 1, 1, 2, 2]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/left_right_pointers/#125-valid-palindrome","title":"125. Valid Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string 125. Valid Palindrome - Python Solution<pre><code># List Comprehension\ndef isPalindrome(s: str) -&gt; bool:\n    s = [char.lower() for char in s if char.isalnum()]\n    return s == s[::-1]\n\n\n# Left Right Pointers\ndef isPalindromeLR(s: str) -&gt; bool:\n    left, right = 0, len(s) - 1\n\n    while left &lt; right:\n        while left &lt; right and not s[left].isalnum():\n            left += 1\n        while left &lt; right and not s[right].isalnum():\n            right -= 1\n\n        if s[left].lower() != s[right].lower():\n            return False\n\n        left += 1\n        right -= 1\n\n    return True\n\n\ns = \"A man, a plan, a canal: Panama\"\nprint(isPalindrome(s))  # True\nprint(isPalindromeLR(s))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/left_right_pointers/#167-two-sum-ii-input-array-is-sorted","title":"167. Two Sum II - Input Array Is Sorted","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search 167. Two Sum II - Input Array Is Sorted - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef twoSum(numbers: List[int], target: int) -&gt; List[int]:\n    left, right = 0, len(numbers) - 1\n\n    while left &lt; right:\n        total = numbers[left] + numbers[right]\n\n        if total &gt; target:\n            right -= 1\n        elif total &lt; target:\n            left += 1\n        else:\n            return [left + 1, right + 1]\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nnumbers = [2, 7, 11, 15]\ntarget = 9\nprint(twoSum(numbers, target))  # [1, 2]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/left_right_pointers/#11-container-with-most-water","title":"11. Container With Most Water","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy</p> </li> <li>Return the maximum area of water that can be trapped between the vertical lines.</li> </ul> <p></p> 11. Container With Most Water - Python Solution<pre><code>from typing import List\n\n\n# Brute Force\ndef maxAreaBF(height: List[int]) -&gt; int:\n    max_area = 0\n\n    for i in range(len(height)):\n        for j in range(i + 1, len(height)):\n            h = min(height[i], height[j])\n            w = j - i\n            max_area = max(max_area, h * w)\n\n    return max_area\n\n\n# Left Right Pointers\ndef maxAreaLR(height: List[int]) -&gt; int:\n    left, right = 0, len(height) - 1\n    res = 0\n\n    while left &lt; right:\n        h = min(height[left], height[right])\n        w = right - left\n        res = max(res, h * w)\n\n        if height[left] &lt; height[right]:\n            left += 1\n        else:\n            right -= 1\n\n    return res\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force| O(n^2) |  O(1)   |\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nheight = [1, 8, 6, 2, 5, 4, 8, 3, 7]\nprint(maxAreaBF(height))  # 49\nprint(maxAreaLR(height))  # 49\n</code></pre> 11. Container With Most Water - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint maxArea(vector&lt;int&gt;&amp; height) {\n    int left = 0, right = height.size() - 1;\n    int res = 0;\n\n    while (left &lt; right) {\n        int h = min(height[left], height[right]);\n        int w = right - left;\n        res = max(res, h * w);\n\n        if (height[left] &lt; height[right])\n            left++;\n        else\n            right--;\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; height = {1, 8, 6, 2, 5, 4, 8, 3, 7};\n    cout &lt;&lt; maxArea(height) &lt;&lt; endl;  // 49\n    return 0;\n}\n</code></pre>"},{"location":"content/leetpattern/linked_list/","title":"Linked List","text":""},{"location":"content/leetpattern/linked_list/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 203. Remove Linked List Elements (Easy)</li> <li> 707. Design Linked List (Medium)</li> <li> 206. Reverse Linked List (Easy)</li> <li> 237. Delete Node in a Linked List (Medium)</li> <li> 2487. Remove Nodes From Linked List (Medium)</li> <li> 24. Swap Nodes in Pairs (Medium)</li> <li> 19. Remove Nth Node From End of List (Medium)</li> <li> 160. Intersection of Two Linked Lists (Easy)</li> <li> 141. Linked List Cycle (Easy)</li> <li> 142. Linked List Cycle II (Medium)</li> <li> 2816. Double a Number Represented as a Linked List (Medium)</li> <li> 2. Add Two Numbers (Medium)</li> </ul>"},{"location":"content/leetpattern/linked_list/#203-remove-linked-list-elements","title":"203. Remove Linked List Elements","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: linked list, recursion</p> </li> <li> <p>Remove all elements from a linked list of integers that have value <code>val</code>.</p> </li> <li> <p>Before</p> </li> </ul> <pre><code>graph LR\nA((1)) --&gt; B((2))\nB --&gt; C((6))\nC --&gt; D((3))\nD --&gt; E((4))\nE --&gt; F((5))\nF --&gt; G((6))\nG --&gt; H((None))</code></pre> <ul> <li>After</li> </ul> <pre><code>graph LR\nA((1)) --&gt; B((2))\nB -.-&gt; C((6))\nC -.-&gt; D((3))\nD --&gt; E((4))\nE --&gt; F((5))\nF -.-&gt; G((6))\nB --&gt; D((3))\nF --&gt; I((None))</code></pre> 203. Remove Linked List Elements - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Iterative\ndef removeElements(head: Optional[ListNode], val: int) -&gt; Optional[ListNode]:\n    dummy = ListNode(0)\n    dummy.next = head\n    cur = dummy\n\n    while cur.next:\n        if cur.next.val == val:\n            cur.next = cur.next.next\n        else:\n            cur = cur.next\n\n    return dummy.next\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |  Iterative  |      O(N)       |    O(1)      |\n# |-------------|-----------------|--------------|\n\n\nnums = [1, 2, 6, 3, 4, 5, 6]\nval = 6\nhead = ListNode.create(nums)\nprint(head)\n# 1 -&gt; 2 -&gt; 6 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6\nprint(removeElements(head, val))\n# 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\n</code></pre>"},{"location":"content/leetpattern/linked_list/#707-design-linked-list","title":"707. Design Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, design</p> </li> <li>Design your implementation of the linked list. You can choose to use a singly or doubly linked list.</li> </ul> 707. Design Linked List - Python Solution<pre><code>class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass MyLinkedList:\n\n    def __init__(self):\n        self.dummy = ListNode()\n        self.size = 0\n\n    def get(self, index: int) -&gt; int:\n        if index &lt; 0 or index &gt;= self.size:\n            return -1\n\n        current = self.dummy.next\n        for _ in range(index):\n            current = current.next\n\n        return current.val\n\n    def addAtHead(self, val: int) -&gt; None:\n        self.dummy.next = ListNode(val, self.dummy.next)\n        self.size += 1\n\n    def addAtTail(self, val: int) -&gt; None:\n        current = self.dummy\n        while current.next:\n            current = current.next\n        current.next = ListNode(val)\n        self.size += 1\n\n    def addAtIndex(self, index: int, val: int) -&gt; None:\n        if index &lt; 0 or index &gt; self.size:\n            return\n\n        current = self.dummy\n        for i in range(index):\n            current = current.next\n        current.next = ListNode(val, current.next)\n        self.size += 1\n\n    def deleteAtIndex(self, index: int) -&gt; None:\n        if index &lt; 0 or index &gt;= self.size:\n            return\n\n        current = self.dummy\n        for i in range(index):\n            current = current.next\n        current.next = current.next.next\n        self.size -= 1\n\n\nll = MyLinkedList()\nll.addAtHead(1)\nll.addAtTail(3)\nll.addAtIndex(1, 2)  # 1 -&gt; 2 -&gt; 3\nprint(ll.get(1))  # 2\n</code></pre>"},{"location":"content/leetpattern/linked_list/#206-reverse-linked-list","title":"206. Reverse Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: linked list, recursion</p> </li> <li>Reverse a singly linked list.</li> </ul> <pre><code>graph LR\nA((1)) --&gt; B((2))\nB --&gt; C((3))\nC --&gt; D((4))\nD --&gt; E((5))</code></pre> <pre><code>graph RL\nE((5)) --&gt; D((4))\nD --&gt; C((3))\nC --&gt; B((2))\nB --&gt; A((1))</code></pre> 206. Reverse Linked List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Iterative\ndef reverseListIterative(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    cur = head\n    prev = None\n\n    while cur:\n        temp = cur.next\n        cur.next = prev\n\n        prev = cur\n        cur = temp\n\n    return prev\n\n\n# Recursive\ndef reverseListRecursive(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    def reverse(cur, prev):\n        if not cur:\n            return prev\n\n        temp = cur.next\n        cur.next = prev\n\n        return reverse(temp, cur)\n\n    return reverse(head, None)\n\n\nnums = [1, 2, 3, 4, 5]\nhead1 = ListNode.create(nums)\nprint(head1)\n# 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(reverseListIterative(head1))\n# 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1\nhead2 = ListNode.create(nums)\nprint(reverseListRecursive(head2))\n# 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1\n</code></pre>"},{"location":"content/leetpattern/linked_list/#237-delete-node-in-a-linked-list","title":"237. Delete Node in a Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list</p> </li> <li>Delete a node in a singly linked list. You are given only the node to be deleted.</li> </ul> 237. Delete Node in a Linked List - Python Solution<pre><code>from template import ListNode\n\n\ndef deleteNode(node: ListNode) -&gt; None:\n    node.val = node.next.val\n    node.next = node.next.next\n\n\nhead = ListNode.create([4, 5, 1, 9])\nnode = head.next\ndeleteNode(node)\nprint(head)  # 4 -&gt; 1 -&gt; 9\n</code></pre>"},{"location":"content/leetpattern/linked_list/#2487-remove-nodes-from-linked-list","title":"2487. Remove Nodes From Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, stack, recursion, monotonic stack</p> </li> <li>Remove all nodes from a linked list that have a value greater than <code>maxValue</code>.</li> </ul> 2487. Remove Nodes From Linked List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Recursive\ndef removeNodesRecursive(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    if not head:\n        return None\n\n    head.next = removeNodesRecursive(head.next)\n\n    if head.next and head.val &lt; head.next.val:\n        return head.next\n\n    return head\n\n\n# Iterative\ndef removeNodesIterative(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    stack = []\n    cur = head\n\n    while cur:\n        # pop all nodes in stack that are smaller than cur\n        while stack and cur.val &gt; stack[-1].val:\n            stack.pop()\n\n        stack.append(cur)\n        cur = cur.next\n\n    # link all nodes in stack\n    dummy = ListNode()\n    cur = dummy\n\n    for node in stack:\n        cur.next = node\n        cur = cur.next\n\n    return dummy.next\n\n\nhead = [5, 2, 13, 3, 8]\nhead1 = ListNode.create(head)\nprint(head1)  # 5 -&gt; 2 -&gt; 13 -&gt; 3 -&gt; 8\nprint(removeNodesRecursive(head1))  # 13 -&gt; 8\nhead2 = ListNode.create(head)\nprint(removeNodesIterative(head2))  # 13 -&gt; 8\n</code></pre>"},{"location":"content/leetpattern/linked_list/#24-swap-nodes-in-pairs","title":"24. Swap Nodes in Pairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, recursion</p> </li> <li>Given a linked list, swap every two adjacent nodes and return its head.</li> </ul> 24. Swap Nodes in Pairs - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef swapPairs(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    dummy = ListNode(0, head)\n    n0 = dummy\n    n1 = dummy.next\n\n    while n1 and n1.next:\n        n2 = n1.next\n        n3 = n2.next\n\n        n0.next = n2\n        n2.next = n1\n        n1.next = n3\n\n        n0 = n1\n        n1 = n3\n\n    return dummy.next\n\n\nnums = [1, 2, 3, 4, 5]\nhead = ListNode.create(nums)\nprint(head)\n# 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(swapPairs(head))\n# 2 -&gt; 1 -&gt; 4 -&gt; 3 -&gt; 5\n</code></pre>"},{"location":"content/leetpattern/linked_list/#19-remove-nth-node-from-end-of-list","title":"19. Remove Nth Node From End of List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, two pointers</p> </li> <li>Given the <code>head</code> of a linked list, remove the <code>n-th</code> node from the end of the list and return its head.</li> </ul> 19. Remove Nth Node From End of List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef removeNthFromEnd(head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:\n    dummy = ListNode(0, head)\n    fast, slow = dummy, dummy\n\n    for _ in range(n):\n        fast = fast.next\n\n    while fast.next:\n        fast = fast.next\n        slow = slow.next\n\n    slow.next = slow.next.next\n\n    return dummy.next\n\n\nhead = [1, 2, 3, 4, 5]\nn = 2\nhead = ListNode.create(head)\nprint(head)  # 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(removeNthFromEnd(head, n))  # 1 -&gt; 2 -&gt; 3 -&gt; 5\n</code></pre>"},{"location":"content/leetpattern/linked_list/#160-intersection-of-two-linked-lists","title":"160. Intersection of Two Linked Lists","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, linked list, two pointers</p> </li> <li>Find the node at which the intersection of two singly linked lists begins.</li> </ul> <pre><code>graph LR\n    a1((a1)) --&gt; a2((a2))\n    a2 --&gt; c1((c1))\n    b1((b1)) --&gt; b2((b2))\n    b2 --&gt; b3((b3))\n    b3 --&gt; c1\n    c1 --&gt; c2((c2))\n    c2 --&gt; c3((c3))</code></pre> 160. Intersection of Two Linked Lists - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Hash Set\ndef getIntersectionNodeHash(\n    headA: ListNode, headB: ListNode\n) -&gt; Optional[ListNode]:\n    if not headA or not headB:\n        return None\n\n    visited = set()\n    cur = headA\n    while cur:\n        visited.add(cur)\n        cur = cur.next\n\n    cur = headB\n    while cur:\n        if cur in visited:\n            return cur\n        cur = cur.next\n\n    return None\n\n\n# Two Pointers\ndef getIntersectionNodeTP(\n    headA: ListNode, headB: ListNode\n) -&gt; Optional[ListNode]:\n    if not headA or not headB:\n        return None\n\n    a, b = headA, headB\n\n    while a != b:\n        a = a.next if a else headB\n        b = b.next if b else headA\n\n    return a\n\n\nlistA = [4, 1, 8, 4, 5]\nlistB = [5, 6, 1, 8, 4, 5]\nheadA = ListNode.create(listA)\nprint(headA)\n# 4 -&gt; 1 -&gt; 8 -&gt; 4 -&gt; 5\nheadB = ListNode.create(listB)\nprint(headB)\n# 5 -&gt; 6 -&gt; 1 -&gt; 8 -&gt; 4 -&gt; 5\n\nheadA.intersect(headB, 8)\n\nprint(getIntersectionNodeHash(headA, headB))\n# 8 -&gt; 4 -&gt; 5\nprint(getIntersectionNodeTP(headA, headB))\n# 8 -&gt; 4 -&gt; 5\n</code></pre>"},{"location":"content/leetpattern/linked_list/#141-linked-list-cycle","title":"141. Linked List Cycle","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, linked list, two pointers</p> </li> <li>Determine if a linked list has a cycle in it.</li> </ul> <pre><code>graph LR\n    A((3)) --&gt; B((2))\n    B --&gt; C((0))\n    C --&gt; D((4))</code></pre> <pre><code>graph LR\n    A((3)) --&gt; B((2))\n    B --&gt; C((0))\n    C --&gt; D((4))\n    D --&gt; B</code></pre> 141. Linked List Cycle - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\ndef hasCycle(head: Optional[ListNode]) -&gt; bool:\n    slow, fast = head, head\n\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n        if slow == fast:\n            return True\n\n    return False\n\n\nprint(hasCycle(ListNode.create([3, 2, 0, -4])))  # False\nprint(hasCycle(ListNode.create([3, 2, 0, -4], 1)))  # True\n</code></pre> 141. Linked List Cycle - C++ Solution<pre><code>#include &lt;iostream&gt;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nclass Solution {\n   public:\n    bool hasCycle(ListNode* head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while (fast &amp;&amp; fast-&gt;next) {\n            slow = slow-&gt;next;\n            fast = fast-&gt;next-&gt;next;\n\n            if (fast == slow) return true;\n        }\n        return false;\n    }\n};\n</code></pre>"},{"location":"content/leetpattern/linked_list/#142-linked-list-cycle-ii","title":"142. Linked List Cycle II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, linked list, two pointers</p> </li> <li>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>None</code>.</li> </ul> <pre><code>graph LR\nA[3] --&gt; B[2]\nB --&gt; C[0]\nC --&gt; D[-4]\nD --&gt; B</code></pre> 142. Linked List Cycle II - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\ndef detectCycle(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    slow, fast = head, head\n\n    while fast and fast.next:\n        fast = fast.next.next\n        slow = slow.next\n\n        if slow == fast:\n            slow = head\n            while slow != fast:\n                slow = slow.next\n                fast = fast.next\n            return slow\n\n    return None\n\n\nhead1 = ListNode.create([3, 2, 0, -4], 1)\nprint(detectCycle(head1).val)  # 2\nhead2 = ListNode.create([3, 2, 0, -4])\nprint(detectCycle(head2))  # None\n</code></pre> 142. Linked List Cycle II - C++ Solution<pre><code>#include &lt;iostream&gt;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nclass Solution {\n   public:\n    ListNode* detectCycle(ListNode* head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while (fast &amp;&amp; fast-&gt;next) {\n            slow = slow-&gt;next;\n            fast = fast-&gt;next-&gt;next;\n\n            if (fast == slow) {\n                slow = head;\n                while (slow != fast) {\n                    slow = slow-&gt;next;\n                    fast = fast-&gt;next;\n                }\n                return slow;\n            }\n        }\n        return nullptr;\n    }\n};\n</code></pre>"},{"location":"content/leetpattern/linked_list/#2816-double-a-number-represented-as-a-linked-list","title":"2816. Double a Number Represented as a Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, math, stack</p> </li> <li>Given a number represented as a linked list, double it and return the resulting linked list.</li> </ul> 2816. Double a Number Represented as a Linked List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\ndef doubleIt(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n\n    def twice(node):\n        if not node:\n            return 0\n        doubled_value = node.val * 2 + twice(node.next)\n        node.val = doubled_value % 10\n        return doubled_value // 10\n\n    carry = twice(head)\n\n    if carry:\n        head = ListNode(val=carry, next=head)\n\n    return head\n\n\nhead = ListNode.create([1, 2, 3, 4])\nprint(head)\n# 1 -&gt; 2 -&gt; 3 -&gt; 4\nprint(doubleIt(head))\n# 2 -&gt; 4 -&gt; 6 -&gt; 8\n</code></pre>"},{"location":"content/leetpattern/linked_list/#2-add-two-numbers","title":"2. Add Two Numbers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, math, recursion</p> </li> <li>Represent the sum of two numbers as a linked list.</li> </ul> 2. Add Two Numbers - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef addTwoNumbers(\n    l1: Optional[ListNode], l2: Optional[ListNode]\n) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n    carry = 0\n\n    while l1 or l2:\n        v1 = l1.val if l1 else 0\n        v2 = l2.val if l2 else 0\n\n        carry, val = divmod(v1 + v2 + carry, 10)\n        cur.next = ListNode(val)\n        cur = cur.next\n\n        if l1:\n            l1 = l1.next\n        if l2:\n            l2 = l2.next\n\n    if carry:\n        cur.next = ListNode(val=carry)\n\n    return dummy.next\n\n\nl1 = ListNode.create([2, 4, 3])\nl2 = ListNode.create([5, 6, 4])\nprint(addTwoNumbers(l1, l2))  # 7 -&gt; 0 -&gt; 8\n</code></pre> 2. Add Two Numbers - C++ Solution<pre><code>struct ListNode {\n    int val;\n    ListNode* next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode* next) : val(x), next(next) {}\n};\n\nclass Solution {\n   public:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode dummy;\n        ListNode* cur = &amp;dummy;\n        int carry = 0;\n\n        while (l1 || l2 || carry) {\n            if (l1) {\n                carry += l1-&gt;val;\n                l1 = l1-&gt;next;\n            }\n            if (l2) {\n                carry += l2-&gt;val;\n                l2 = l2-&gt;next;\n            }\n            cur-&gt;next = new ListNode(carry % 10);\n            cur = cur-&gt;next;\n            carry /= 10;\n        }\n        return dummy.next;\n    }\n};\n</code></pre>"},{"location":"content/leetpattern/math/","title":"Math","text":""},{"location":"content/leetpattern/math/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1945. Sum of Digits of String After Convert (Easy)</li> <li> 1894. Find the Student that Will Replace the Chalk (Medium)</li> <li> 7. Reverse Integer (Medium)</li> </ul>"},{"location":"content/leetpattern/math/#1945-sum-of-digits-of-string-after-convert","title":"1945. Sum of Digits of String After Convert","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, simulation 1945. Sum of Digits of String After Convert - Python Solution<pre><code># Math\ndef getLucky(s: str, k: int) -&gt; int:\n    def getSum(n: int) -&gt; int:\n        total = 0\n        while n != 0:\n            n, m = divmod(n, 10)\n            total += m\n        return total\n\n    result = \"\"\n    for i in s:\n        result += str(ord(i) - ord(\"a\") + 1)\n    result = int(result)\n\n    for _ in range(k):\n        result = getSum(result)\n\n    return result\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |    Math    |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\ns = \"iiii\"\nk = 1\n\nprint(getLucky(s, k))  # 36\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/math/#1894-find-the-student-that-will-replace-the-chalk","title":"1894. Find the Student that Will Replace the Chalk","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, simulation, prefix sum 1894. Find the Student that Will Replace the Chalk - Python Solution<pre><code>from typing import List\n\n\n# Math\ndef chalkReplacer(chalk: List[int], k: int) -&gt; int:\n    total = sum(chalk)\n\n    k %= total\n\n    for i, c in enumerate(chalk):\n        k -= c\n\n        if k &lt; 0:\n            return i\n\n    return -1\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |    Math    |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nchalk = [5, 1, 5]\nk = 22\n\nprint(chalkReplacer(chalk, k))  # 0\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/math/#7-reverse-integer","title":"7. Reverse Integer","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math 7. Reverse Integer - Python Solution<pre><code># Math\ndef reverse(x: int) -&gt; int:\n    INT_MAX = 2**31 - 1\n\n    sign = -1 if x &lt; 0 else 1\n    x = abs(x)\n    res = 0\n\n    while x != 0:\n        x, pop = divmod(x, 10)\n\n        if res &gt; (INT_MAX - pop) // 10:\n            return 0\n\n        res = res * 10 + pop\n\n    return res * sign\n\n\nprint(reverse(123))  # 321\nprint(reverse(-123))  # -321\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/prefix_sum/","title":"Prefix Sum","text":""},{"location":"content/leetpattern/prefix_sum/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2574. Left and Right Sum Differences (Easy)</li> <li> 1732. Find the Highest Altitude (Easy)</li> <li> 303. Range Sum Query - Immutable (Easy)</li> <li> 304. Range Sum Query 2D - Immutable (Medium)</li> <li> 560. Subarray Sum Equals K (Medium)</li> <li> 238. Product of Array Except Self (Medium)</li> <li> 974. Subarray Sums Divisible by K (Medium)</li> <li> 209. Minimum Size Subarray Sum (Medium)</li> <li> 523. Continuous Subarray Sum (Medium)</li> <li> 1248. Count Number of Nice Subarrays (Medium)</li> <li> 325. Maximum Size Subarray Sum Equals k (Medium) \ud83d\udc51</li> <li> 862. Shortest Subarray with Sum at Least K (Hard)</li> <li> 1171. Remove Zero Sum Consecutive Nodes from Linked List (Medium)</li> </ul>"},{"location":"content/leetpattern/prefix_sum/#2574-left-and-right-sum-differences","title":"2574. Left and Right Sum Differences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, prefix sum 2574. Left and Right Sum Differences - Python Solution<pre><code>from typing import List\n\n\n# Prefix Sum\ndef leftRightDifferenceSum(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    left = [0 for _ in range(n)]\n    right = [0 for _ in range(n)]\n\n    for i in range(1, n):\n        left[i] = left[i - 1] + nums[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        right[i] = right[i + 1] + nums[i + 1]\n\n    return [abs(left[i] - right[i]) for i in range(n)]\n\n\n# Left Right Pointers\ndef leftRightDifferencePointer(nums: List[int]) -&gt; List[int]:\n    left, right = 0, sum(nums)\n    result = []\n\n    for num in nums:\n        right -= num\n        result.append(abs(left - right))\n        left += num\n\n    return result\n\n\nnums = [10, 4, 8, 3]\nprint(leftRightDifferenceSum(nums))  # [15, 1, 11, 22]\nprint(leftRightDifferencePointer(nums))  # [15, 1, 11, 22]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/prefix_sum/#1732-find-the-highest-altitude","title":"1732. Find the Highest Altitude","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, prefix sum 1732. Find the Highest Altitude - Python Solution<pre><code>from typing import List\n\n\ndef largestAltitude(gain: List[int]) -&gt; int:\n    result, altitude = 0, 0\n\n    for i in gain:\n        altitude += i\n        result = max(result, altitude)\n\n    return result\n\n\ngain = [-5, 1, 5, 0, -7]\nprint(largestAltitude(gain))  # 1\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/prefix_sum/#303-range-sum-query-immutable","title":"303. Range Sum Query - Immutable","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, design, prefix sum 303. Range Sum Query - Immutable - Python Solution<pre><code>from typing import List\n\n\n# Prefix Sum\nclass NumArray:\n\n    def __init__(self, nums: List[int]):\n        n = len(nums)\n        self.ps = [0 for _ in range(n + 1)]  # prefix sum\n        for i in range(1, n + 1):\n            self.ps[i] = self.ps[i - 1] + nums[i - 1]\n\n    def sumRange(self, left: int, right: int) -&gt; int:\n        return self.ps[right + 1] - self.ps[left]\n\n\nnums = [-2, 0, 3, -5, 2, -1]\nobj = NumArray(nums)\nassert obj.sumRange(0, 2) == 1\nassert obj.sumRange(2, 5) == -1\nassert obj.sumRange(0, 5) == -3\nprint(\"PASSED\")\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/prefix_sum/#304-range-sum-query-2d-immutable","title":"304. Range Sum Query 2D - Immutable","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, design, matrix, prefix sum 304. Range Sum Query 2D - Immutable - Python Solution<pre><code>from typing import List\n\n\nclass NumMatrix:\n\n    def __init__(self, matrix: List[List[int]]):\n        m, n = len(matrix), len(matrix[0])\n        if m == 0 or n == 0:\n            return None\n\n        self.sum = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                self.sum[i][j] = (\n                    matrix[i - 1][j - 1]\n                    + self.sum[i - 1][j]\n                    + self.sum[i][j - 1]\n                    - self.sum[i - 1][j - 1]  # to avoid double counting\n                )\n\n    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -&gt; int:\n        return (\n            self.sum[row2 + 1][col2 + 1]\n            - self.sum[row1][col2 + 1]\n            - self.sum[row2 + 1][col1]\n            + self.sum[row1][col1]\n        )\n\n\nmatrix = [\n    [3, 0, 1, 4, 2],\n    [5, 6, 3, 2, 1],\n    [1, 2, 0, 1, 5],\n    [4, 1, 0, 1, 7],\n    [1, 0, 3, 0, 5],\n]\nobj = NumMatrix(matrix)\nassert obj.sumRegion(2, 1, 4, 3) == 8\nassert obj.sumRegion(1, 1, 2, 2) == 11\nassert obj.sumRegion(1, 2, 2, 4) == 12\nprint(\"PASSED\")\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/prefix_sum/#560-subarray-sum-equals-k","title":"560. Subarray Sum Equals K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, prefix sum 560. Subarray Sum Equals K - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Prefix Sum\ndef subarraySum(nums: List[int], k: int) -&gt; int:\n    preSums = defaultdict(int)\n    preSums[0] = 1\n    curSum = 0\n    res = 0\n\n    for num in nums:\n        curSum += num\n        res += preSums[curSum - k]\n        preSums[curSum] += 1\n\n    return res\n\n\nnums = [1, 1, 1]\nk = 2\nprint(subarraySum(nums, k))  # 2\n</code></pre></p> </li> </ul> 560. Subarray Sum Equals K - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint subarraySum(vector&lt;int&gt;&amp; nums, int k) {\n    int n = nums.size();\n    vector&lt;int&gt; prefixSum(n + 1);\n    for (int i = 0; i &lt; n; i++) {\n        prefixSum[i + 1] = prefixSum[i] + nums[i];\n    }\n\n    int res = 0;\n    unordered_map&lt;int, int&gt; cnt;\n\n    for (int ps : prefixSum) {\n        if (cnt.find(ps - k) != cnt.end()) res += cnt[ps - k];\n        cnt[ps]++;\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {1, 1, 1};\n    int k = 2;\n    cout &lt;&lt; subarraySum(nums, k) &lt;&lt; endl;  // 2\n    return 0;\n}\n</code></pre>"},{"location":"content/leetpattern/prefix_sum/#238-product-of-array-except-self","title":"238. Product of Array Except Self","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, prefix sum</p> </li> <li>Classic Prefix Sum problem</li> <li>Return an array <code>output</code> such that <code>output[i]</code> is equal to the product of all the elements of <code>nums</code> except <code>nums[i]</code>.</li> </ul> Approach Time Space Prefix O(n) O(n) Prefix (Optimized) O(n) O(1) 238. Product of Array Except Self - Python Solution<pre><code>from typing import List\n\n\n# Prefix\ndef productExceptSelf(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    prefix = [1 for _ in range(n)]\n    suffix = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        prefix[i] = nums[i - 1] * prefix[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        suffix[i] = nums[i + 1] * suffix[i + 1]\n\n    result = [i * j for i, j in zip(prefix, suffix)]\n\n    return result\n\n\n# Prefix (Optimized)\ndef productExceptSelfOptimized(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    result = [1 for _ in range(n)]\n\n    prefix = 1\n    for i in range(n):\n        result[i] = prefix\n        prefix *= nums[i]\n\n    suffix = 1\n    for i in range(n - 1, -1, -1):\n        result[i] *= suffix\n        suffix *= nums[i]\n\n    return result\n\n\nprint(productExceptSelf([1, 2, 3, 4]))\n# [24, 12, 8, 6]\nprint(productExceptSelfOptimized([1, 2, 3, 4]))\n# [24, 12, 8, 6]\n</code></pre> 238. Product of Array Except Self - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\n// Prefix Sum\nclass Solution\n{\npublic:\n    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt; &amp;nums)\n    {\n        int n = nums.size();\n        vector&lt;int&gt; prefix(n, 1);\n        vector&lt;int&gt; suffix(n, 1);\n        vector&lt;int&gt; res(n, 1);\n\n        for (int i = 1; i &lt; n; i++)\n        {\n            prefix[i] = prefix[i - 1] * nums[i - 1];\n        }\n\n        for (int i = n - 2; i &gt;= 0; i--)\n        {\n            suffix[i] = suffix[i + 1] * nums[i + 1];\n        }\n\n        for (int i = 0; i &lt; n; i++)\n        {\n            res[i] = prefix[i] * suffix[i];\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    vector&lt;int&gt; nums = {1, 2, 3, 4};\n    Solution obj;\n    vector&lt;int&gt; result = obj.productExceptSelf(nums);\n\n    for (int i = 0; i &lt; result.size(); i++)\n    {\n        cout &lt;&lt; result[i] &lt;&lt; \"\\n\";\n    }\n    cout &lt;&lt; endl;\n    // 24, 12, 8, 6\n    return 0;\n}\n</code></pre>"},{"location":"content/leetpattern/prefix_sum/#974-subarray-sums-divisible-by-k","title":"974. Subarray Sums Divisible by K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, prefix sum 974. Subarray Sums Divisible by K - Python Solution<pre><code>from typing import List\n\n\ndef subarraysDivByK_1(nums: List[int], k: int) -&gt; int:\n    mods = {0: 1}\n    prefixSum, result = 0, 0\n\n    for num in nums:\n        prefixSum += num\n        mod = prefixSum % k\n\n        if mod &lt; 0:\n            mod += k\n\n        if mod in mods:\n            result += mods[mod]\n\n        if mod in mods:\n            mods[mod] += 1\n        else:\n            mods[mod] = 1\n\n    return result\n\n\ndef subarraysDivByK_2(nums: List[int], k: int) -&gt; int:\n    mods = {0: 1}\n    prefixSum, result = 0, 0\n\n    for num in nums:\n        prefixSum += num\n        mod = prefixSum % k\n        result += mods.get(mod, 0)\n        mods[mod] = mods.get(mod, 0) + 1\n\n    return result\n\n\nnums = [4, 5, 0, -2, -3, 1]\nk = 5\nprint(subarraysDivByK_1(nums, k))  # 7\nprint(subarraysDivByK_2(nums, k))  # 7\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/prefix_sum/#209-minimum-size-subarray-sum","title":"209. Minimum Size Subarray Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sliding window, prefix sum 209. Minimum Size Subarray Sum - Python Solution<pre><code>import bisect\nfrom typing import List\n\n\n# Prefix Sum\ndef minSubArrayLenPS(target: int, nums: List[int]) -&gt; int:\n    n = len(nums)\n    prefix_sums = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        prefix_sums[i] = prefix_sums[i - 1] + nums[i - 1]\n\n    minLen = float(\"inf\")\n\n    for i in range(n + 1):\n        new_target = target + prefix_sums[i]\n        bound = bisect.bisect_left(prefix_sums, new_target)\n        if bound != len(prefix_sums):\n            minLen = min(minLen, bound - i)\n\n    return 0 if minLen == float(\"inf\") else minLen\n\n\n# Sliding Window Variable Size\ndef minSubArrayLenSW(target: int, nums: List[int]) -&gt; int:\n    res, cur = float(\"inf\"), 0\n    left = 0\n\n    for right in range(len(nums)):\n        cur += nums[right]\n\n        while cur &gt;= target:\n            res = min(res, right - left + 1)\n            cur -= nums[left]\n            left += 1\n\n    return res if res != float(\"inf\") else 0\n\n\ntarget = 7\nnums = [2, 3, 1, 2, 4, 3]\nprint(minSubArrayLenPS(target, nums))  # 2\nprint(minSubArrayLenSW(target, nums))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/prefix_sum/#523-continuous-subarray-sum","title":"523. Continuous Subarray Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, prefix sum 523. Continuous Subarray Sum - Python Solution<pre><code>from typing import List\n\n\n# Prefix Sum\ndef checkSubarraySum(nums: List[int], k: int) -&gt; bool:\n    if k == 0:\n        for i in range(1, len(nums)):\n            if nums[i - 1] == 0 and nums[i] == 0:\n                return True\n\n    prefix_sum = 0\n    mod_dict = {0: -1}\n\n    for i, num in enumerate(nums):\n        prefix_sum += num\n        mod = prefix_sum % k\n\n        if mod in mod_dict:\n            if i - mod_dict[mod] &gt; 1:\n                return True\n        else:\n            mod_dict[mod] = i\n\n    return False\n\n\nnums = [23, 2, 4, 6, 7]\nk = 6\nprint(checkSubarraySum(nums, k))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/prefix_sum/#1248-count-number-of-nice-subarrays","title":"1248. Count Number of Nice Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, sliding window, prefix sum 1248. Count Number of Nice Subarrays - Python Solution<pre><code>from typing import List\n\n\n# Prefix Sum\ndef numberOfSubarrays(nums: List[int], k: int) -&gt; int:\n    count = 0\n    odd_counts = {0: 1}  # odd_count -&gt; count\n    odd_count = 0\n\n    for num in nums:\n        if num % 2 == 1:\n            odd_count += 1\n        if odd_count - k in odd_counts:\n            count += odd_counts[odd_count - k]\n        if odd_count in odd_counts:\n            odd_counts[odd_count] += 1\n        else:\n            odd_counts[odd_count] = 1\n\n    return count\n\n\nnums = [1, 1, 2, 1, 1]\nk = 3\nprint(numberOfSubarrays(nums, k))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/prefix_sum/#325-maximum-size-subarray-sum-equals-k","title":"325. Maximum Size Subarray Sum Equals k","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, prefix sum 325. Maximum Size Subarray Sum Equals k - Python Solution<pre><code>from typing import List\n\n\n# Prefix Sum\ndef maxSubArrayLen(nums: List[int], k: int) -&gt; int:\n    res = 0\n    prefix = 0\n    sumMap = {0: -1}  # sum -&gt; index\n\n    for i, num in enumerate(nums):\n        prefix += num\n        if prefix - k in sumMap:\n            res = max(res, i - sumMap[prefix - k])\n        if prefix not in sumMap:\n            sumMap[prefix] = i\n\n    return res\n\n\nnums = [1, -1, 5, -2, 3]\nk = 3\nprint(maxSubArrayLen(nums, k))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/prefix_sum/#862-shortest-subarray-with-sum-at-least-k","title":"862. Shortest Subarray with Sum at Least K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, queue, sliding window, heap priority queue, prefix sum, monotonic queue 862. Shortest Subarray with Sum at Least K - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# Prefix Sum + Monotonic Queue\ndef shortestSubarray(nums: List[int], k: int) -&gt; int:\n    n = len(nums)\n    ps = [0 for _ in range(n + 1)]\n\n    for i in range(n):\n        ps[i + 1] = ps[i] + nums[i]\n\n    res = float(\"inf\")\n    q = deque()\n\n    for i in range(n + 1):\n        while q and ps[i] - ps[q[0]] &gt;= k:\n            res = min(res, i - q.popleft())\n        while q and ps[i] &lt;= ps[q[-1]]:\n            q.pop()\n        q.append(i)\n\n    return res if res != float(\"inf\") else -1\n\n\nnums = [2, -1, 2]\nk = 3\nprint(shortestSubarray(nums, k))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/prefix_sum/#1171-remove-zero-sum-consecutive-nodes-from-linked-list","title":"1171. Remove Zero Sum Consecutive Nodes from Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, linked list 1171. Remove Zero Sum Consecutive Nodes from Linked List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Prefix Sum\ndef removeZeroSumSublists(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    dummy = ListNode(0)\n    dummy.next = head\n    cur = head\n    prefix_sum = 0\n    seen = {0: dummy}\n\n    while cur:\n        prefix_sum += cur.val\n        if prefix_sum in seen:\n            node = seen[prefix_sum].next\n            temp_sum = prefix_sum\n            while node != cur:\n                temp_sum += node.val\n                del seen[temp_sum]\n                node = node.next\n            seen[prefix_sum].next = cur.next\n        else:\n            seen[prefix_sum] = cur\n        cur = cur.next\n\n    return dummy.next\n\n\nhead = ListNode().create([1, 2, -3, 3, 1])\nprint(removeZeroSumSublists(head))  # 3 -&gt; 1\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/queue/","title":"Queue","text":""},{"location":"content/leetpattern/queue/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 232. Implement Queue using Stacks (Easy)</li> <li> 225. Implement Stack using Queues (Easy)</li> </ul>"},{"location":"content/leetpattern/queue/#232-implement-queue-using-stacks","title":"232. Implement Queue using Stacks","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: stack, design, queue</p> </li> <li>Implement the following operations of a queue using stacks.<ul> <li><code>push(x)</code> - Push element x to the back of queue.</li> <li><code>pop()</code> - Removes the element from in front of queue.</li> <li><code>peek()</code> - Get the front element.</li> <li><code>empty()</code> - Return whether the queue is empty.</li> </ul> </li> </ul> 232. Implement Queue using Stacks - Python Solution<pre><code>class MyQueue:\n    def __init__(self):\n        self.stack_in = []\n        self.stack_out = []\n\n    def push(self, x: int) -&gt; None:\n        self.stack_in.append(x)\n\n    def pop(self) -&gt; int:\n        if self.empty():\n            return None\n\n        if self.stack_out:\n            return self.stack_out.pop()\n        else:\n            for _ in range(len(self.stack_in)):\n                self.stack_out.append(self.stack_in.pop())\n            return self.stack_out.pop()\n\n    def peek(self) -&gt; int:\n        answer = self.pop()\n        self.stack_out.append(answer)\n        return answer\n\n    def empty(self) -&gt; bool:\n        return not (self.stack_in or self.stack_out)\n\n\nobj = MyQueue()\nobj.push(1)\nprint(obj.pop())  # 1\nprint(obj.peek())  # None\nprint(obj.empty())  # False\n</code></pre>"},{"location":"content/leetpattern/queue/#225-implement-stack-using-queues","title":"225. Implement Stack using Queues","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: stack, design, queue 225. Implement Stack using Queues - Python Solution<pre><code>from collections import deque\n\n\n# Queue\nclass MyStack:\n\n    def __init__(self):\n        self.q1 = deque()  # main queue\n        self.q2 = deque()  # auxiliary queue\n\n    def push(self, x: int) -&gt; None:\n        self.q1.append(x)\n\n    def pop(self) -&gt; int:\n        while len(self.q1) &gt; 1:\n            self.q2.append(self.q1.popleft())\n        res = self.q1.popleft()\n        self.q1, self.q2 = self.q2, self.q1\n        return res\n\n    def top(self) -&gt; int:\n        while len(self.q1) &gt; 1:\n            self.q2.append(self.q1.popleft())\n        res = self.q1[0]\n        self.q2.append(self.q1.popleft())\n        self.q1, self.q2 = self.q2, self.q1\n        return res\n\n    def empty(self) -&gt; bool:\n        return not self.q1\n\n\nobj = MyStack()\nobj.push(1)\nobj.push(2)\nobj.push(3)\nobj.push(4)\nprint(obj.pop())  # 4\nprint(obj.top())  # 3\nprint(obj.empty())  # False\nprint(obj.pop())  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/queue_monotonic/","title":"Queue Monotonic","text":""},{"location":"content/leetpattern/queue_monotonic/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 918. Maximum Sum Circular Subarray (Medium)</li> <li> 862. Shortest Subarray with Sum at Least K (Hard)</li> <li> 239. Sliding Window Maximum (Hard)</li> <li> 2398. Maximum Number of Robots Within Budget (Hard)</li> </ul>"},{"location":"content/leetpattern/queue_monotonic/#918-maximum-sum-circular-subarray","title":"918. Maximum Sum Circular Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, divide and conquer, dynamic programming, queue, monotonic queue 918. Maximum Sum Circular Subarray - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# DP - Kadane\ndef maxSubarraySumCircularKadane(nums: List[int]) -&gt; int:\n    max_sum = min_sum = nums[0]\n    max_cur = min_cur = 0\n    total = 0\n\n    for num in nums:\n        max_cur = max(max_cur + num, num)\n        min_cur = min(min_cur + num, num)\n        total += num\n\n        max_sum = max(max_sum, max_cur)\n        min_sum = min(min_sum, min_cur)\n\n    return max(max_sum, total - min_sum) if max_sum &gt; 0 else max_sum\n\n\n# Monotonic Queue\ndef maxSubarraySumCircularMQ(nums: List[int]) -&gt; int:\n    n = len(nums)\n    prefix_sum = [0] * (2 * n + 1)\n\n    for i in range(1, 2 * n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + nums[(i - 1) % n]\n\n    q = deque([0])\n    max_sum = float(\"-inf\")\n\n    for i in range(1, 2 * n + 1):\n        if q[0] &lt; i - n:\n            q.popleft()\n\n        max_sum = max(max_sum, prefix_sum[i] - prefix_sum[q[0]])\n\n        while q and prefix_sum[q[-1]] &gt;= prefix_sum[i]:\n            q.pop()\n\n        q.append(i)\n\n    return max_sum\n\n\nnums = [1, -2, 3, -2]\nprint(maxSubarraySumCircularKadane(nums))  # 3\nprint(maxSubarraySumCircularMQ(nums))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/queue_monotonic/#862-shortest-subarray-with-sum-at-least-k","title":"862. Shortest Subarray with Sum at Least K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, queue, sliding window, heap priority queue, prefix sum, monotonic queue 862. Shortest Subarray with Sum at Least K - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# Prefix Sum + Monotonic Queue\ndef shortestSubarray(nums: List[int], k: int) -&gt; int:\n    n = len(nums)\n    ps = [0 for _ in range(n + 1)]\n\n    for i in range(n):\n        ps[i + 1] = ps[i] + nums[i]\n\n    res = float(\"inf\")\n    q = deque()\n\n    for i in range(n + 1):\n        while q and ps[i] - ps[q[0]] &gt;= k:\n            res = min(res, i - q.popleft())\n        while q and ps[i] &lt;= ps[q[-1]]:\n            q.pop()\n        q.append(i)\n\n    return res if res != float(\"inf\") else -1\n\n\nnums = [2, -1, 2]\nk = 3\nprint(shortestSubarray(nums, k))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/queue_monotonic/#239-sliding-window-maximum","title":"239. Sliding Window Maximum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, queue, sliding window, heap priority queue, monotonic queue 239. Sliding Window Maximum - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# Monotonic Queue\ndef maxSlidingWindow(nums: List[int], k: int) -&gt; List[int]:\n    q = deque()\n    res = []\n\n    for i, num in enumerate(nums):\n        if q and q[0] &lt; i - k + 1:\n            q.popleft()\n\n        while q and nums[q[-1]] &lt; num:\n            q.pop()\n\n        q.append(i)\n\n        if i &gt;= k - 1:\n            res.append(nums[q[0]])\n\n    return res\n\n\nnums = [1, 3, -1, -3, 5, 3, 6, 7]\nk = 3\nprint(maxSlidingWindow(nums, k))  # [3, 3, 5, 5, 6, 7]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/queue_monotonic/#2398-maximum-number-of-robots-within-budget","title":"2398. Maximum Number of Robots Within Budget","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, queue, sliding window, heap priority queue, prefix sum, monotonic queue 2398. Maximum Number of Robots Within Budget - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# Monotonic Queue\ndef maximumRobots(\n    chargeTimes: List[int], runningCosts: List[int], budget: int\n) -&gt; int:\n    ans = sum_cost = left = 0\n    q = deque()\n\n    for right, (time, cost) in enumerate(zip(chargeTimes, runningCosts)):\n        # 1. Add\n        while q and time &gt;= chargeTimes[q[-1]]:\n            q.pop()\n        q.append(right)\n        sum_cost += cost\n\n        # 2. Remove\n        while q and chargeTimes[q[0]] + (right - left + 1) * sum_cost &gt; budget:\n            if q[0] == left:\n                q.popleft()\n            sum_cost -= runningCosts[left]\n            left += 1\n\n        # 3. Update\n        ans = max(ans, right - left + 1)\n    return ans\n\n\nchargeTimes = [3, 6, 1, 3, 4]\nrunningCosts = [2, 1, 3, 4, 5]\nbudget = 25\nprint(maximumRobots(chargeTimes, runningCosts, budget))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/simulation/","title":"Simulation","text":""},{"location":"content/leetpattern/simulation/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 874. Walking Robot Simulation (Medium)</li> </ul>"},{"location":"content/leetpattern/simulation/#874-walking-robot-simulation","title":"874. Walking Robot Simulation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, simulation 874. Walking Robot Simulation - Python Solution<pre><code>from typing import List\n\n\n# Simulation\ndef robotSim(commands: List[int], obstacles: List[List[int]]) -&gt; int:\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    obstacles_set = set(map(tuple, obstacles))\n\n    x, y, d = 0, 0, 0\n    res = 0\n\n    for command in commands:\n        if command == -2:  # Turn left\n            d = (d - 1) % 4\n        elif command == -1:  # Turn right\n            d = (d + 1) % 4\n        else:\n            dx, dy = dirs[d]\n            for _ in range(command):\n                if (x + dx, y + dy) not in obstacles_set:\n                    x += dx\n                    y += dy\n                    res = max(res, x**2 + y**2)\n                else:\n                    break\n\n    return res\n\n\ncommands = [4, -1, 4, -2, 4]\nobstacles = [[2, 4]]\nprint(robotSim(commands, obstacles))  # 65\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/sliding_window_fixed/","title":"Sliding Window Fixed","text":""},{"location":"content/leetpattern/sliding_window_fixed/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 643. Maximum Average Subarray I (Easy)</li> <li> 219. Contains Duplicate II (Easy)</li> <li> 1456. Maximum Number of Vowels in a Substring of Given Length (Medium)</li> <li> 567. Permutation in String (Medium)</li> <li> 713. Subarray Product Less Than K (Medium)</li> <li> 1151. Minimum Swaps to Group All 1's Together (Medium) \ud83d\udc51</li> <li> 209. Minimum Size Subarray Sum (Medium)</li> <li> 76. Minimum Window Substring (Hard)</li> </ul>"},{"location":"content/leetpattern/sliding_window_fixed/#643-maximum-average-subarray-i","title":"643. Maximum Average Subarray I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, sliding window 643. Maximum Average Subarray I - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window Fixed Size\ndef findMaxAverage1(nums: List[int], k: int) -&gt; float:\n    maxSum = float(\"-inf\")\n    cur = 0\n\n    for idx, num in enumerate(nums):\n        cur += num\n\n        if idx &lt; k - 1:\n            continue\n\n        maxSum = max(maxSum, cur)\n        cur -= nums[idx - k + 1]\n\n    return maxSum / k\n\n\n# Sliding Window Fixed Size\ndef findMaxAverage2(nums: List[int], k: int) -&gt; float:\n    n = len(nums)\n    if n == 1:\n        return float(nums[0])\n\n    cur = sum(nums[:k])\n\n    maxSum = cur\n    for i in range(k, n):\n        cur += nums[i] - nums[i - k]\n        maxSum = max(maxSum, cur)\n\n    return maxSum / k\n\n\nnums = [1, 12, -5, -6, 50, 3]\nk = 4\nprint(findMaxAverage1(nums, k))  # 12.75\nprint(findMaxAverage2(nums, k))  # 12.75\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/sliding_window_fixed/#219-contains-duplicate-ii","title":"219. Contains Duplicate II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, sliding window 219. Contains Duplicate II - Python Solution<pre><code>from typing import List\n\n\n# Hash\ndef containsNearbyDuplicateHash(nums: List[int], k: int) -&gt; bool:\n    hashmap = {}  # num: last index\n\n    for idx, num in enumerate(nums):\n        if num in hashmap:\n            if idx - hashmap[num] &lt;= k:\n                return True\n\n        hashmap[num] = idx\n\n    return False\n\n\n# Sliding window - Fixed\ndef containsNearbyDuplicateWindow(nums: List[int], k: int) -&gt; bool:\n    window = set()\n    left = 0\n\n    for right in range(len(nums)):\n        if right - left &gt; k:\n            window.remove(nums[left])\n            left += 1\n        if nums[right] in window:\n            return True\n        window.add(nums[right])\n\n    return False\n\n\nnums = [1, 2, 3, 1]\nk = 3\nprint(containsNearbyDuplicateHash(nums, k))  # True\nprint(containsNearbyDuplicateWindow(nums, k))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/sliding_window_fixed/#1456-maximum-number-of-vowels-in-a-substring-of-given-length","title":"1456. Maximum Number of Vowels in a Substring of Given Length","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, sliding window</p> </li> <li>This problem is a classic example of the Sliding Window Fixed Size technique.</li> <li>Templace tutorial by \u7075\u5c71\u8336\u827e\u5e9c</li> <li>Technique: add-update-remove (\u5165-\u66f4\u65b0-\u51fa)</li> </ul> 1456. Maximum Number of Vowels in a Substring of Given Length - Python Solution<pre><code># Template of Sliding Window Fixed Size\ndef templateMaxVowels(s: str, k: int) -&gt; int:\n    res, cnt = 0, 0\n\n    for idx, ch in enumerate(s):\n        # ADD\n        if ch in \"aeiou\":\n            cnt += 1\n\n        # FORM\n        if idx &lt; k - 1:\n            continue\n\n        # UPDATE\n        res = max(res, cnt)\n\n        # REMOVE\n        if s[idx - k + 1] in \"aeiou\":\n            cnt -= 1\n\n    return res\n\n\n# Sliding Window Fixed Size\ndef maxVowels1(s: str, k: int) -&gt; int:\n    res, cnt = 0, 0\n\n    for idx, ch in enumerate(s):\n        if ch in \"aeiou\":\n            cnt += 1\n\n        if idx &lt; k - 1:\n            continue\n\n        res = max(res, cnt)\n\n        if s[idx - k + 1] in \"aeiou\":\n            cnt -= 1\n\n    return res\n\n\n# Sliding Window Fixed Size\ndef maxVowels2(s: str, k: int) -&gt; int:\n    vowels = set(\"aeiou\")\n    n = len(s)\n    cnt, res = 0, 0\n\n    for i in range(k):\n        if s[i] in vowels:\n            cnt += 1\n\n    res = cnt\n\n    for i in range(k, n):\n        if s[i] in vowels:\n            cnt += 1\n        if s[i - k] in vowels:\n            cnt -= 1\n        res = max(res, cnt)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    s = \"abciiidef\"\n    k = 3\n    assert maxVowels1(s, k) == 3\n    assert maxVowels2(s, k) == 3\n    assert templateMaxVowels(s, k) == 3\n</code></pre>"},{"location":"content/leetpattern/sliding_window_fixed/#567-permutation-in-string","title":"567. Permutation in String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, two pointers, string, sliding window 567. Permutation in String - Python Solution<pre><code>def checkInclusion(s1: str, s2: str) -&gt; bool:\n    if len(s1) &gt; len(s2):\n        return False\n\n    count1 = [0] * 26\n    count2 = [0] * 26\n\n    for i in range(len(s1)):\n        count1[ord(s1[i]) - ord(\"a\")] += 1\n        count2[ord(s2[i]) - ord(\"a\")] += 1\n\n    matches = 0\n    for i in range(26):\n        if count1[i] == count2[i]:\n            matches += 1\n\n    l = 0\n    for r in range(len(s1), len(s2)):\n        if matches == 26:\n            return True\n\n        index = ord(s2[r]) - ord(\"a\")\n        count2[index] += 1\n        if count1[index] == count2[index]:\n            matches += 1\n        elif count1[index] + 1 == count2[index]:\n            matches -= 1\n\n        index = ord(s2[l]) - ord(\"a\")\n        count2[index] -= 1\n        if count1[index] == count2[index]:\n            matches += 1\n        elif count1[index] - 1 == count2[index]:\n            matches -= 1\n\n        l += 1\n\n    return matches == 26\n\n\ns1 = \"ab\"\ns2 = \"eidba\"\nprint(checkInclusion(s1, s2))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/sliding_window_fixed/#713-subarray-product-less-than-k","title":"713. Subarray Product Less Than K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sliding window, prefix sum 713. Subarray Product Less Than K - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window Variable Subarrays Shorter\ndef numSubarrayProductLessThanK(nums: List[int], k: int) -&gt; int:\n    if k &lt;= 1:\n        return 0\n\n    left = 0\n    prod = 1\n    res = 0\n\n    for right in range(len(nums)):\n        prod *= nums[right]\n\n        while prod &gt;= k:\n            prod //= nums[left]\n            left += 1\n\n        res += right - left + 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert numSubarrayProductLessThanK([10, 5, 2, 6], 100) == 8\n    assert numSubarrayProductLessThanK([1, 2, 3], 0) == 0\n    assert numSubarrayProductLessThanK([1, 2, 3], 1) == 0\n    assert numSubarrayProductLessThanK([1, 2, 3], 2) == 1\n    assert numSubarrayProductLessThanK([1, 2, 3], 3) == 3\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/sliding_window_fixed/#1151-minimum-swaps-to-group-all-1s-together","title":"1151. Minimum Swaps to Group All 1's Together","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sliding window 1151. Minimum Swaps to Group All 1's Together - Python Solution<pre><code>from typing import List\n\n\ndef minSwaps(data: List[int]) -&gt; int:\n    n = len(data)\n    total = sum(data)\n\n    if total == 0 or total == 1 or total == n:\n        return 0\n\n    max_count = 0\n    cur = 0\n    left = 0\n\n    for right in range(n):\n        cur += data[right]\n\n        if right - left + 1 &gt; total:\n            cur -= data[left]\n            left += 1\n\n        max_count = max(max_count, cur)\n\n    return total - max_count\n\n\ndata = [1, 0, 1, 0, 1]\nprint(minSwaps(data))  # 1\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/sliding_window_fixed/#209-minimum-size-subarray-sum","title":"209. Minimum Size Subarray Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sliding window, prefix sum 209. Minimum Size Subarray Sum - Python Solution<pre><code>import bisect\nfrom typing import List\n\n\n# Prefix Sum\ndef minSubArrayLenPS(target: int, nums: List[int]) -&gt; int:\n    n = len(nums)\n    prefix_sums = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        prefix_sums[i] = prefix_sums[i - 1] + nums[i - 1]\n\n    minLen = float(\"inf\")\n\n    for i in range(n + 1):\n        new_target = target + prefix_sums[i]\n        bound = bisect.bisect_left(prefix_sums, new_target)\n        if bound != len(prefix_sums):\n            minLen = min(minLen, bound - i)\n\n    return 0 if minLen == float(\"inf\") else minLen\n\n\n# Sliding Window Variable Size\ndef minSubArrayLenSW(target: int, nums: List[int]) -&gt; int:\n    res, cur = float(\"inf\"), 0\n    left = 0\n\n    for right in range(len(nums)):\n        cur += nums[right]\n\n        while cur &gt;= target:\n            res = min(res, right - left + 1)\n            cur -= nums[left]\n            left += 1\n\n    return res if res != float(\"inf\") else 0\n\n\ntarget = 7\nnums = [2, 3, 1, 2, 4, 3]\nprint(minSubArrayLenPS(target, nums))  # 2\nprint(minSubArrayLenSW(target, nums))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/sliding_window_fixed/#76-minimum-window-substring","title":"76. Minimum Window Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, sliding window 76. Minimum Window Substring - Python Solution<pre><code>from collections import Counter\n\n\ndef minWindow(s: str, t: str) -&gt; str:\n    if not t or not s:\n        return \"\"\n\n    counts = Counter(t)\n    required = len(counts)\n\n    left, right = 0, 0\n    formed = 0\n    window_counts = dict()\n\n    result = float(\"inf\"), None, None\n\n    while right &lt; len(s):\n        char = s[right]\n        window_counts[char] = window_counts.get(char, 0) + 1\n        if char in counts and window_counts[char] == counts[char]:\n            formed += 1\n\n        while left &lt;= right and formed == required:\n            char = s[left]\n            if right - left + 1 &lt; result[0]:\n                result = (right - left + 1, left, right)\n            window_counts[char] -= 1\n            if char in counts and window_counts[char] &lt; counts[char]:\n                formed -= 1\n            left += 1\n\n        right += 1\n\n    return \"\" if result[0] == float(\"inf\") else s[result[1] : result[2] + 1]\n\n\ns = \"ADOBECODEBANC\"\nt = \"ABC\"\nprint(minWindow(s, t))  # BANC\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/sliding_window_variable/","title":"Sliding Window Variable","text":""},{"location":"content/leetpattern/sliding_window_variable/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3. Longest Substring Without Repeating Characters (Medium)</li> <li> 159. Longest Substring with At Most Two Distinct Characters (Medium) \ud83d\udc51</li> <li> 424. Longest Repeating Character Replacement (Medium)</li> <li> 1208. Get Equal Substrings Within Budget (Medium)</li> <li> 1004. Max Consecutive Ones III (Medium)</li> <li> 438. Find All Anagrams in a String (Medium)</li> <li> 992. Subarrays with K Different Integers (Hard)</li> <li> 2024. Maximize the Confusion of an Exam (Medium)</li> </ul>"},{"location":"content/leetpattern/sliding_window_variable/#3-longest-substring-without-repeating-characters","title":"3. Longest Substring Without Repeating Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> <li>Classic variable sliding window problem. Use a set to keep track of the characters in the current window.</li> <li>Return the length of the longest substring without repeating characters.</li> <li>Template tutorial by \u7075\u5c71\u8336\u827e\u5e9c</li> </ul> 3. Longest Substring Without Repeating Characters - Python Solution<pre><code>from collections import defaultdict\n\n\n# Sliding Window Variable Max - HashMap\ndef lengthOfLongestSubstringHash(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    left = 0\n    cnt = defaultdict(int)\n    res = 0\n\n    for right in range(n):\n        cnt[s[right]] += 1\n\n        while cnt[s[right]] &gt; 1:\n            cnt[s[left]] -= 1\n            left += 1\n\n        res = max(res, right - left + 1)\n\n    return res\n\n\n# Sliding Window Variable Max - Set\ndef lengthOfLongestSubstringSet(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    left = 0\n    res = 0\n    window = set()\n\n    for right in range(n):\n        while left &lt; right and s[right] in window:\n            window.remove(s[left])\n            left += 1\n        window.add(s[right])\n        res = max(res, right - left + 1)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    s = \"abcabcbb\"\n    assert lengthOfLongestSubstringHash(s) == 3\n    assert lengthOfLongestSubstringSet(s) == 3\n</code></pre> 3. Longest Substring Without Repeating Characters - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;unordered_set&gt;\nusing namespace std;\n\nint lengthOfLongestSubstring(string s) {\n    int n = s.length();\n    int res = 0;\n    int left = 0;\n    unordered_set&lt;char&gt; window;\n\n    for (int right = 0; right &lt; n; right++) {\n        char ch = s[right];\n\n        while (window.find(ch) != window.end()) {\n            window.erase(s[left]);\n            left++;\n        }\n\n        window.insert(ch);\n        res = max(res, right - left + 1);\n    }\n    return (int)res;\n}\n\nint main() {\n    string s = \"abcabcbb\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 3\n    s = \"bbbbb\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 1\n    s = \"pwwkew\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 3\n    return 0;\n}\n</code></pre>"},{"location":"content/leetpattern/sliding_window_variable/#159-longest-substring-with-at-most-two-distinct-characters","title":"159. Longest Substring with At Most Two Distinct Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> <li>Prerequisite: 3. Longest Substring Without Repeating Characters</li> </ul> 159. Longest Substring with At Most Two Distinct Characters - Python Solution<pre><code>from collections import defaultdict\n\n\n# Sliding Window - Variable\ndef lengthOfLongestSubstringTwoDistinct(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 2:\n        return n\n\n    window = defaultdict(int)\n    left, res = 0, 0\n\n    for right in range(n):\n        window[s[right]] += 1\n\n        while len(window) &gt; 2:\n            window[s[left]] -= 1\n            if window[s[left]] == 0:\n                del window[s[left]]\n            left += 1\n\n        res = max(res, right - left + 1)\n\n    return res\n\n\ns = \"ccaabbb\"\nassert lengthOfLongestSubstringTwoDistinct(s) == 5\n</code></pre>"},{"location":"content/leetpattern/sliding_window_variable/#424-longest-repeating-character-replacement","title":"424. Longest Repeating Character Replacement","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window 424. Longest Repeating Character Replacement - Python Solution<pre><code>from collections import defaultdict\n\n\n# Sliding Window - Variable\ndef characterReplacement(s: str, k: int) -&gt; int:\n    left = 0\n    maxCount = 0\n    counts = defaultdict(int)\n    maxLen = 0\n\n    for right in range(len(s)):\n        counts[s[right]] += 1\n        maxCount = max(maxCount, counts[s[right]])\n\n        while right - left + 1 - maxCount &gt; k:\n            counts[s[left]] -= 1\n            left += 1\n\n        maxLen = max(maxLen, right - left + 1)\n\n    return maxLen\n\n\ns = \"ABAB\"\nk = 2\nprint(characterReplacement(s, k))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/sliding_window_variable/#1208-get-equal-substrings-within-budget","title":"1208. Get Equal Substrings Within Budget","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, binary search, sliding window, prefix sum 1208. Get Equal Substrings Within Budget - Python Solution<pre><code># Sliding Window - Variable\ndef equalSubstring(s: str, t: str, maxCost: int) -&gt; int:\n    left = 0\n    maxLen = 0\n    currentCost = 0\n\n    for right in range(len(s)):\n        currentCost += abs(ord(s[right]) - ord(t[right]))\n\n        while currentCost &gt; maxCost:\n            currentCost -= abs(ord(s[left]) - ord(t[left]))\n            left += 1\n\n        maxLen = max(maxLen, right - left + 1)\n\n    return maxLen\n\n\ns = \"abcd\"\nt = \"bcdf\"\nmaxCost = 3\nprint(equalSubstring(s, t, maxCost))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/sliding_window_variable/#1004-max-consecutive-ones-iii","title":"1004. Max Consecutive Ones III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sliding window, prefix sum 1004. Max Consecutive Ones III - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window - Variable\ndef longestOnes(nums: List[int], k: int) -&gt; int:\n    left = 0\n    maxLen = 0\n    zero_count = 0\n\n    for right in range(len(nums)):\n        if nums[right] == 0:\n            zero_count += 1\n\n        while zero_count &gt; k:\n            if nums[left] == 0:\n                zero_count -= 1\n            left += 1\n\n        maxLen = max(maxLen, right - left + 1)\n\n    return maxLen\n\n\nnums = [1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0]\nk = 2\nprint(longestOnes(nums, k))  # 6\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/sliding_window_variable/#438-find-all-anagrams-in-a-string","title":"438. Find All Anagrams in a String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window 438. Find All Anagrams in a String - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window Fixed Size\ndef findAnagrams(s: str, p: str) -&gt; List[int]:\n    n, k = len(s), len(p)\n    target = [0 for _ in range(26)]\n    for ch in p:\n        target[ord(ch) - ord(\"a\")] += 1\n\n    count = [0 for _ in range(26)]\n    left = 0\n    res = []\n\n    for right in range(n):\n        count[ord(s[right]) - ord(\"a\")] += 1\n        if right &lt; k - 1:\n            continue\n\n        if count == target:\n            res.append(left)\n\n        count[ord(s[left]) - ord(\"a\")] -= 1\n        left += 1\n\n    return res\n\n\ns = \"cbaebabacd\"\np = \"abc\"\nprint(findAnagrams(s, p))  # [0, 6]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/sliding_window_variable/#992-subarrays-with-k-different-integers","title":"992. Subarrays with K Different Integers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, sliding window, counting 992. Subarrays with K Different Integers - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window - Variable\ndef subarraysWithKDistinct(nums: List[int], k: int) -&gt; int:\n    def atMost(k: int) -&gt; int:\n        count = 0\n        left = 0\n        freq = {}\n\n        for right in range(len(nums)):\n            if nums[right] not in freq:\n                freq[nums[right]] = 0\n            freq[nums[right]] += 1\n\n            while len(freq) &gt; k:\n                freq[nums[left]] -= 1\n                if freq[nums[left]] == 0:\n                    del freq[nums[left]]\n                left += 1\n\n            count += right - left + 1\n\n        return count\n\n    return atMost(k) - atMost(k - 1)\n\n\nnums = [1, 2, 1, 2, 3]\nk = 2\nprint(subarraysWithKDistinct(nums, k))  # 7\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/sliding_window_variable/#2024-maximize-the-confusion-of-an-exam","title":"2024. Maximize the Confusion of an Exam","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, binary search, sliding window, prefix sum 2024. Maximize the Confusion of an Exam - Python Solution<pre><code># Sliding Window - Variable\ndef maxConsecutiveAnswers1(answerKey: str, k: int) -&gt; int:\n    def maxConsecutiveChar(s: str, k: int, char: str) -&gt; int:\n        max_len = 0\n        left = 0\n        count = 0  # num of str != char\n\n        for right in range(len(s)):\n            if s[right] != char:\n                count += 1\n\n            while count &gt; k:\n                if s[left] != char:\n                    count -= 1\n                left += 1\n\n            max_len = max(max_len, right - left + 1)\n\n        return max_len\n\n    max_t = maxConsecutiveChar(answerKey, k, \"T\")\n    max_f = maxConsecutiveChar(answerKey, k, \"F\")\n\n    return max(max_t, max_f)\n\n\n# Sliding Window - Variable\ndef maxConsecutiveAnswers2(answerKey: str, k: int) -&gt; int:\n    def maxConsecutiveChar(s: str, k: int, char: str) -&gt; int:\n        max_len = 0\n        left, right = 0, 0\n\n        while right &lt; len(s):\n            if s[right] != char:\n                k -= 1\n\n            while k &lt; 0:\n                if s[left] != char:\n                    k += 1\n                left += 1\n\n            max_len = max(max_len, right - left + 1)\n            right += 1\n\n        return max_len\n\n    max_t = maxConsecutiveChar(answerKey, k, \"T\")\n    max_f = maxConsecutiveChar(answerKey, k, \"F\")\n\n    return max(max_t, max_f)\n\n\n# |-----------------|---------|------------|\n# |  Approach       |  Time   |  Space     |\n# |-----------------|---------|------------|\n# | Sliding Window  |  O(N)   |  O(1)      |\n# |-----------------|---------|------------|\n\n\nanswerKey = \"TTFF\"\nk = 2\nprint(maxConsecutiveAnswers1(answerKey, k))  # 4\nprint(maxConsecutiveAnswers2(answerKey, k))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/stack/","title":"Stack","text":""},{"location":"content/leetpattern/stack/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2390. Removing Stars From a String (Medium)</li> <li> 1544. Make The String Great (Easy)</li> <li> 20. Valid Parentheses (Easy)</li> <li> 155. Min Stack (Medium)</li> <li> 150. Evaluate Reverse Polish Notation (Medium)</li> <li> 394. Decode String (Medium)</li> <li> 22. Generate Parentheses (Medium)</li> <li> 853. Car Fleet (Medium)</li> <li> 224. Basic Calculator (Hard)</li> <li> 227. Basic Calculator II (Medium)</li> <li> 772. Basic Calculator III (Hard) \ud83d\udc51</li> <li> 770. Basic Calculator IV (Hard)</li> </ul>"},{"location":"content/leetpattern/stack/#2390-removing-stars-from-a-string","title":"2390. Removing Stars From a String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack, simulation</p> </li> <li>Remove all <code>*</code> characters and their adjacent characters from the string.</li> <li>Steps for the string <code>leet**cod*e</code>:</li> </ul> char action stack l push \"l\" e push \"le\" e push \"lee\" t push \"leet\" * pop \"lee\" * pop \"le\" c push \"lec\" o push \"leco\" d push \"lecod\" * pop \"leco\" e push \"lecoe\" 2390. Removing Stars From a String - Python Solution<pre><code># Stack\ndef removeStars(s: str) -&gt; str:\n    stack = []\n\n    for char in s:\n        if char == \"*\":\n            stack.pop()\n        else:\n            stack.append(char)\n\n    return \"\".join(stack)\n\n\ns = \"leet**cod*e\"\nprint(removeStars(s))  # \"lecoe\"\n</code></pre>"},{"location":"content/leetpattern/stack/#1544-make-the-string-great","title":"1544. Make The String Great","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, stack</p> </li> <li>Remove all adjacent characters that are the same and have different cases.</li> <li>Steps for the string <code>leEeetcode</code>:</li> </ul> char action stack l push \"l\" e push \"le\" E pop \"l\" e push \"le\" e push \"lee\" t push \"leet\" c push \"leetc\" o push \"leetco\" d push \"leetcod\" e push \"leetcode\" 1544. Make The String Great - Python Solution<pre><code># Stack\ndef makeGood(s: str) -&gt; str:\n    stack = []\n\n    for i in range(len(s)):\n        if stack and stack[-1] == s[i].swapcase():\n            stack.pop()\n        else:\n            stack.append(s[i])\n    return \"\".join(stack)\n\n\nprint(makeGood(\"leEeetcode\"))  # \"leetcode\"\n</code></pre>"},{"location":"content/leetpattern/stack/#20-valid-parentheses","title":"20. Valid Parentheses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, stack</p> </li> <li>Determine if the input string is valid.</li> <li>Steps for the string <code>()[]{}</code>:</li> </ul> char action stack <code>(</code> push \"(\" <code>)</code> pop \"\" <code>[</code> push \"[\" <code>]</code> pop \"\" <code>{</code> push \"{\" <code>}</code> pop \"\" 20. Valid Parentheses - Python Solution<pre><code># Stack\ndef isValid(s: str) -&gt; bool:\n    hashmap = {\n        \")\": \"(\",\n        \"]\": \"[\",\n        \"}\": \"{\",\n    }\n    stack = []\n\n    for ch in s:\n        if ch in hashmap:\n            if stack and stack[-1] == hashmap[ch]:\n                stack.pop()\n            else:\n                return False\n        else:\n            stack.append(ch)\n\n    return True if not stack else False\n\n\nif __name__ == \"__main__\":\n    assert isValid(\"()[]{}\")\n    assert not isValid(\"(]\")\n    assert not isValid(\"([)]\")\n    assert isValid(\"{[]}\")\n    assert isValid(\"\")\n</code></pre> 20. Valid Parentheses - C++ Solution<pre><code>#include &lt;cassert&gt;\n#include &lt;stack&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool isValid(string s) {\n        unordered_map&lt;char, char&gt; map{{')', '('}, {'}', '{'}, {']', '['}};\n        stack&lt;char&gt; stack;\n        if (s.length() % 2 == 1) return false;\n\n        for (char&amp; ch : s) {\n            if (stack.empty() || map.find(ch) == map.end()) {\n                stack.push(ch);\n            } else {\n                if (map[ch] != stack.top()) {\n                    return false;\n                }\n                stack.pop();\n            }\n        }\n        return stack.empty();\n    }\n};\n\nint main() {\n    Solution s;\n    assert(s.isValid(\"()\") == true);\n    assert(s.isValid(\"()[]{}\") == true);\n    assert(s.isValid(\"(]\") == false);\n    assert(s.isValid(\"([)]\") == false);\n    assert(s.isValid(\"{[]}\") == true);\n    return 0;\n}\n</code></pre>"},{"location":"content/leetpattern/stack/#155-min-stack","title":"155. Min Stack","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: stack, design</p> </li> <li>Implement a stack that supports push, pop, top, and retrieving the minimum element in constant time.</li> </ul> 155. Min Stack - Python Solution<pre><code># Stack\nclass MinStack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, val: int) -&gt; None:\n        if self.stack:\n            self.stack.append((val, min(val, self.getMin())))\n        else:\n            self.stack.append((val, val))\n\n    def pop(self) -&gt; None:\n        self.stack.pop()\n\n    def top(self) -&gt; int:\n        return self.stack[-1][0]\n\n    def getMin(self) -&gt; int:\n        return self.stack[-1][1]\n\n\nobj = MinStack()\nobj.push(3)\nobj.push(2)\nobj.pop()\nprint(obj.top())  # 3\nprint(obj.getMin())  # 3\n</code></pre> 155. Min Stack - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;climits&gt;\n#include &lt;iostream&gt;\n#include &lt;stack&gt;\n#include &lt;utility&gt;\nusing namespace std;\n\nclass MinStack {\n    stack&lt;pair&lt;int, int&gt;&gt; st;\n\n   public:\n    MinStack() { st.emplace(0, INT_MAX); }\n\n    void push(int val) { st.emplace(val, min(getMin(), val)); }\n\n    void pop() { st.pop(); }\n\n    int top() { return st.top().first; }\n\n    int getMin() { return st.top().second; }\n};\n\nint main() {\n    MinStack minStack;\n    minStack.push(-2);\n    minStack.push(0);\n    minStack.push(-3);\n    cout &lt;&lt; minStack.getMin() &lt;&lt; endl;  // -3\n    minStack.pop();\n    cout &lt;&lt; minStack.top() &lt;&lt; endl;     // 0\n    cout &lt;&lt; minStack.getMin() &lt;&lt; endl;  // -2\n    return 0;\n}\n</code></pre>"},{"location":"content/leetpattern/stack/#150-evaluate-reverse-polish-notation","title":"150. Evaluate Reverse Polish Notation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, stack</p> </li> <li>Steps for the list <code>[\"2\", \"1\", \"+\", \"3\", \"*\"]</code>:</li> </ul> token action stack <code>2</code> push <code>[2]</code> <code>1</code> push <code>[2, 1]</code> <code>+</code> pop <code>[3]</code> <code>3</code> push <code>[3, 3]</code> <code>*</code> pop <code>[9]</code> 150. Evaluate Reverse Polish Notation - Python Solution<pre><code>from typing import List\n\n\n# Stack\ndef evalRPN(tokens: List[str]) -&gt; int:\n    stack = []\n\n    for c in tokens:\n        if c == \"+\":\n            stack.append(stack.pop() + stack.pop())\n        elif c == \"-\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(b - a)\n        elif c == \"*\":\n            stack.append(stack.pop() * stack.pop())\n        elif c == \"/\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(int(b / a))\n        else:\n            stack.append(int(c))\n\n    return stack[0]\n\n\nprint(evalRPN([\"2\", \"1\", \"+\", \"3\", \"*\"]))  # 9\nprint(evalRPN([\"4\", \"13\", \"5\", \"/\", \"-\"]))  # 2\nprint(evalRPN([\"18\"]))  # 18\nprint(evalRPN([\"4\", \"3\", \"-\"]))  # 1\n</code></pre>"},{"location":"content/leetpattern/stack/#394-decode-string","title":"394. Decode String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack, recursion 394. Decode String - Python Solution<pre><code># Stack\ndef decodeString(s: str) -&gt; str:\n    stack = []  # (str, int)\n    num = 0\n    res = \"\"\n\n    for c in s:\n        if c.isdigit():\n            num = num * 10 + int(c)\n        elif c == \"[\":\n            stack.append((res, num))\n            res, num = \"\", 0\n        elif c == \"]\":\n            top = stack.pop()\n            res = top[0] + res * top[1]\n        else:\n            res += c\n\n    return res\n\n\ns = \"3[a2[c]]\"\nprint(decodeString(s))  # accaccacc\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/stack/#22-generate-parentheses","title":"22. Generate Parentheses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming, backtracking 22. Generate Parentheses - Python Solution<pre><code>from typing import List\n\n\n# Backtracking\ndef generateParenthesis1(n: int) -&gt; List[str]:\n    path, res = [], []\n\n    def dfs(openN, closeN):\n        if openN == closeN == n:\n            res.append(\"\".join(path))\n            return\n\n        if openN &lt; n:\n            path.append(\"(\")\n            dfs(openN + 1, closeN)\n            path.pop()\n\n        if closeN &lt; openN:\n            path.append(\")\")\n            dfs(openN, closeN + 1)\n            path.pop()\n\n    dfs(0, 0)\n\n    return res\n\n\n# Backtracking\ndef generateParenthesis2(n: int) -&gt; List[str]:\n    m = n * 2\n    res, path = [], [\"\"] * m\n\n    def dfs(i, left):\n        if i == m:\n            res.append(\"\".join(path))\n            return\n\n        if left &lt; n:\n            path[i] = \"(\"\n            dfs(i + 1, left + 1)\n        if i - left &lt; left:\n            path[i] = \")\"\n            dfs(i + 1, left)\n\n    dfs(0, 0)\n    return res\n\n\nif __name__ == \"__main__\":\n    print(generateParenthesis1(3))\n    # ['((()))', '(()())', '(())()', '()(())', '()()()']\n    print(generateParenthesis2(3))\n    # ['((()))', '(()())', '(())()', '()(())', '()()()']\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/stack/#853-car-fleet","title":"853. Car Fleet","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, sorting, monotonic stack 853. Car Fleet - Python Solution<pre><code>from typing import List\n\n\n# Stack\ndef carFleet(target: int, position: List[int], speed: List[int]) -&gt; int:\n    cars = sorted(zip(position, speed), reverse=True)\n    stack = []\n\n    for p, s in cars:\n        time = (target - p) / s\n\n        if not stack or time &gt; stack[-1]:\n            stack.append(time)\n\n    return len(stack)\n\n\nprint(carFleet(12, [10, 8, 0, 5, 3], [2, 4, 1, 1, 3]))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/stack/#224-basic-calculator","title":"224. Basic Calculator","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, string, stack, recursion 224. Basic Calculator - Python Solution<pre><code># Stack\ndef calculate(s: str) -&gt; int:\n    stack = []\n    result = 0\n    number = 0\n    sign = 1\n\n    for char in s:\n        if char.isdigit():\n            number = number * 10 + int(char)\n\n        elif char == \"+\":\n            result += sign * number\n            number = 0\n            sign = 1\n        elif char == \"-\":\n            result += sign * number\n            number = 0\n            sign = -1\n\n        elif char == \"(\":\n            stack.append(result)\n            stack.append(sign)\n            result = 0\n            sign = 1\n        elif char == \")\":\n            result += sign * number\n            number = 0\n            result *= stack.pop()  # pop sign\n            result += stack.pop()  # pop previous result\n\n    result += sign * number\n\n    return result\n\n\nprint(calculate(\"(1+(4+5+2)-3)+(6+8)\"))  # 23\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/stack/#227-basic-calculator-ii","title":"227. Basic Calculator II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, string, stack 227. Basic Calculator II - Python Solution<pre><code># Stack\ndef calculate(s: str) -&gt; int:\n    stack = []\n    num = 0\n    sign = \"+\"\n\n    for index, char in enumerate(s):\n        if char.isdigit():\n            num = num * 10 + int(char)\n\n        if char in \"+-*/\" or index == len(s) - 1:\n            if sign == \"+\":\n                stack.append(num)\n            elif sign == \"-\":\n                stack.append(-num)\n            elif sign == \"*\":\n                stack.append(stack.pop() * num)\n            elif sign == \"/\":\n                stack.append(int(stack.pop() / num))\n            sign = char\n            num = 0\n\n    return sum(stack)\n\n\ns = \"3+2*2\"\nprint(calculate(s))  # 7\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/stack/#772-basic-calculator-iii","title":"772. Basic Calculator III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, string, stack, recursion 772. Basic Calculator III - Python Solution<pre><code># Stack\ndef calculate(s: str) -&gt; int:\n    def helper(index):\n        stack = []\n        num = 0\n        sign = \"+\"\n\n        while index &lt; len(s):\n            char = s[index]\n            if char.isdigit():\n                num = num * 10 + int(char)\n            if char == \"(\":\n                num, index = helper(index + 1)\n            if char in \"+-*/)\" or index == len(s) - 1:\n                if sign == \"+\":\n                    stack.append(num)\n                elif sign == \"-\":\n                    stack.append(-num)\n                elif sign == \"*\":\n                    stack.append(stack.pop() * num)\n                elif sign == \"/\":\n                    stack.append(int(stack.pop() / num))  # \u5411\u96f6\u53d6\u6574\n                num = 0\n                sign = char\n            if char == \")\":\n                break\n            index += 1\n\n        return sum(stack), index\n\n    s = s.replace(\" \", \"\")\n    result, _ = helper(0)\n\n    return result\n\n\ns = \"2*(5+5*2)/3+(6/2+8)\"\nprint(calculate(s))  # 21\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/stack/#770-basic-calculator-iv","title":"770. Basic Calculator IV","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, math, string, stack, recursion 770. Basic Calculator IV - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Stack\nclass Solution:\n    def __init__(self):\n        self.operators = set([\"+\", \"-\", \"*\"])\n\n    def basicCalculatorIV(\n        self, expression: str, evalvars: List[str], evalints: List[int]\n    ) -&gt; List[str]:\n        evalmap = dict(zip(evalvars, evalints))\n        tokens = self.parse_expression(expression)\n        result_terms = self.evaluate(tokens, evalmap)\n        return self.format_result(result_terms)\n\n    def parse_expression(self, expression):\n        tokens = []\n        i = 0\n        while i &lt; len(expression):\n            if expression[i].isalnum():  # Variable or digit\n                start = i\n                while i &lt; len(expression) and (\n                    expression[i].isalnum() or expression[i] == \"_\"\n                ):\n                    i += 1\n                tokens.append(expression[start:i])\n            elif expression[i] in self.operators or expression[i] in \"()\":\n                tokens.append(expression[i])\n                i += 1\n            elif expression[i] == \" \":\n                i += 1  # skip whitespace\n        return tokens\n\n    def evaluate(self, tokens, evalmap):\n        def apply_operator(op, b, a):\n            if op == \"+\":\n                return self.add_terms(a, b)\n            elif op == \"-\":\n                return self.add_terms(a, self.negate_terms(b))\n            elif op == \"*\":\n                return self.multiply_terms(a, b)\n\n        def process_token(token):\n            if token.isalnum():\n                if token in evalmap:\n                    stack.append({(): evalmap[token]})\n                elif token.isdigit():\n                    stack.append({(): int(token)})\n                else:\n                    stack.append({(token,): 1})\n            elif token == \"(\":\n                ops.append(token)\n            elif token == \")\":\n                while ops and ops[-1] != \"(\":\n                    operate()\n                ops.pop()\n            else:\n                while (\n                    ops\n                    and ops[-1] in precedence\n                    and precedence[ops[-1]] &gt;= precedence[token]\n                ):\n                    operate()\n                ops.append(token)\n\n        def operate():\n            if len(stack) &lt; 2 or not ops:\n                return\n            b = stack.pop()\n            a = stack.pop()\n            op = ops.pop()\n            stack.append(apply_operator(op, b, a))\n\n        stack = []\n        ops = []\n        precedence = {\"+\": 1, \"-\": 1, \"*\": 2}\n\n        for token in tokens:\n            process_token(token)\n\n        while ops:\n            operate()\n        return self.combine_terms(stack[-1])\n\n    def add_terms(self, a, b):\n        result = defaultdict(int, a)\n        for term, coef in b.items():\n            result[term] += coef\n        return dict(result)\n\n    def negate_terms(self, a):\n        return {term: -coef for term, coef in a.items()}\n\n    def multiply_terms(self, a, b):\n        result = defaultdict(int)\n        for term1, coef1 in a.items():\n            for term2, coef2 in b.items():\n                new_term = tuple(sorted(term1 + term2))\n                result[new_term] += coef1 * coef2\n        return dict(result)\n\n    def combine_terms(self, terms):\n        result = defaultdict(int)\n        for term, coef in terms.items():\n            if coef != 0:\n                result[term] = coef\n        return dict(result)\n\n    def format_result(self, result_terms):\n        result = []\n        for term in sorted(result_terms.keys(), key=lambda x: (-len(x), x)):\n            coef = result_terms[term]\n            if coef != 0:\n                term_str = \"*\".join(term)\n                if term_str:\n                    result.append(f\"{coef}*{term_str}\")\n                else:\n                    result.append(str(coef))\n        return result\n\n\ncalculator = Solution()\nexpression = \"e + 8 - a + 5\"\nevalvars = [\"e\"]\nevalints = [1]\nprint(calculator.basicCalculatorIV(expression, evalvars, evalints))\n# ['-1*a', '14']\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/stack_monotonic/","title":"Stack Monotonic","text":""},{"location":"content/leetpattern/stack_monotonic/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 739. Daily Temperatures (Medium)</li> <li> 496. Next Greater Element I (Easy)</li> <li> 503. Next Greater Element II (Medium)</li> <li> 84. Largest Rectangle in Histogram (Hard)</li> <li> 85. Maximal Rectangle (Hard)</li> <li> 42. Trapping Rain Water (Hard)</li> <li> 901. Online Stock Span (Medium)</li> <li> 316. Remove Duplicate Letters (Medium)</li> <li> 456. 132 Pattern (Medium)</li> <li> 2281. Sum of Total Strength of Wizards (Hard)</li> </ul>"},{"location":"content/leetpattern/stack_monotonic/#739-daily-temperatures","title":"739. Daily Temperatures","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, monotonic stack</p> </li> <li>Return an array <code>res</code> such that <code>res[i]</code> is the number of days you have to wait after the <code>ith</code> day to get a warmer temperature.</li> </ul> Index Temp &gt; stack last stack result 0 73 False <code>[ [73, 0] ]</code> 1 - 0 = 1 1 74 True <code>[ [74, 1] ]</code> 2 - 1 = 1 2 75 True <code>[ [75, 2] ]</code> 6 - 2 = 4 3 71 False <code>[ [75, 2], [71, 3] ]</code> 5 - 3 = 2 4 69 False <code>[ [75, 2], [71, 3], [69, 4] ]</code> 5 - 4 = 1 5 72 True <code>[ [75, 2], [72, 5] ]</code> 6 - 5 = 1 6 76 True <code>[ [76, 6] ]</code> 0 7 73 False <code>[[76, 6], [73, 7]]</code> 0 739. Daily Temperatures - Python Solution<pre><code>from typing import List\n\n\n# Monotonic Stack\ndef dailyTemperatures(temperatures: List[int]) -&gt; List[int]:\n    res = [0 for _ in range(len(temperatures))]\n    stack = []  # [temp, index]\n\n    for i, temp in enumerate(temperatures):\n        while stack and temp &gt; stack[-1][0]:\n            _, idx = stack.pop()\n            res[idx] = i - idx\n\n        stack.append([temp, i])\n\n    return res\n\n\nprint(dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73]))\n# [1, 1, 4, 2, 1, 1, 0, 0]\n</code></pre>"},{"location":"content/leetpattern/stack_monotonic/#496-next-greater-element-i","title":"496. Next Greater Element I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, stack, monotonic stack 496. Next Greater Element I - Python Solution<pre><code>from typing import List\n\n\n# Monotonic Stack\ndef nextGreaterElement(nums1: List[int], nums2: List[int]) -&gt; List[int]:\n    next_greater = {}\n    stack = []\n    result = []\n\n    for num in nums2:\n        while stack and num &gt; stack[-1]:\n            next_greater[stack.pop()] = num\n        stack.append(num)\n\n    for num in nums1:\n        result.append(next_greater.get(num, -1))\n\n    return result\n\n\nnums1 = [4, 1, 2]\nnums2 = [1, 3, 4, 2]\nprint(nextGreaterElement(nums1, nums2))  # [3, -1, -1]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/stack_monotonic/#503-next-greater-element-ii","title":"503. Next Greater Element II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, monotonic stack 503. Next Greater Element II - Python Solution<pre><code>from typing import List\n\n\n# Monotonic Stack\ndef nextGreaterElements(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    result = [-1] * n\n    stack = []\n\n    for i in range(2 * n):\n        while stack and nums[stack[-1]] &lt; nums[i % n]:\n            result[stack.pop()] = nums[i % n]\n        if i &lt; n:\n            stack.append(i)\n\n    return result\n\n\nnums = [1, 2, 1]\nprint(nextGreaterElements(nums))  # [2, -1, 2]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/stack_monotonic/#84-largest-rectangle-in-histogram","title":"84. Largest Rectangle in Histogram","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, stack, monotonic stack 84. Largest Rectangle in Histogram - Python Solution<pre><code>from typing import List\n\n\n# Monotonic Stack\ndef largestRectangleArea(heights: List[int]) -&gt; int:\n    stack = []\n    max_area = 0\n    n = len(heights)\n\n    for i in range(n + 1):\n        h = 0 if i == n else heights[i]\n\n        while stack and h &lt; heights[stack[-1]]:\n            height = heights[stack.pop()]\n            width = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, height * width)\n\n        stack.append(i)\n\n    return max_area\n\n\nprint(largestRectangleArea([2, 1, 5, 6, 2, 3]))  # 10\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/stack_monotonic/#85-maximal-rectangle","title":"85. Maximal Rectangle","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, stack, matrix, monotonic stack</p> </li> <li>Return the area of the largest rectangle that can be formed within a rectangle of 1's.</li> </ul> <p></p> 85. Maximal Rectangle - Python Solution<pre><code>from typing import List\n\n\n# Monotonic Stack\ndef maximalRectangle(matrix: List[List[str]]) -&gt; int:\n    if not matrix or not matrix[0]:\n        return 0\n\n    n = len(matrix[0])\n    heights = [0] * (n + 1)\n    max_area = 0\n\n    for row in matrix:\n        for i in range(n):\n            if row[i] == \"1\":\n                heights[i] += 1\n            else:\n                heights[i] = 0\n\n        stack = [-1]\n        for i in range(n + 1):\n            while heights[i] &lt; heights[stack[-1]]:\n                h = heights[stack.pop()]\n                w = i - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            stack.append(i)\n\n    return max_area\n\n\nmatrix = [\n    [\"1\", \"0\", \"1\", \"0\", \"0\"],\n    [\"1\", \"0\", \"1\", \"1\", \"1\"],\n    [\"1\", \"1\", \"1\", \"1\", \"1\"],\n    [\"1\", \"0\", \"0\", \"1\", \"0\"],\n]\nprint(maximalRectangle(matrix))  # 6\n</code></pre>"},{"location":"content/leetpattern/stack_monotonic/#42-trapping-rain-water","title":"42. Trapping Rain Water","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, dynamic programming, stack, monotonic stack</p> </li> <li></li> </ul> Approach Time Space DP O(N) O(N) Left Right O(N) O(1) Monotonic O(N) O(N) 42. Trapping Rain Water - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef trapDP(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    n = len(height)\n    maxLeft, maxRight = [0 for _ in range(n)], [0 for _ in range(n)]\n\n    for i in range(1, n):\n        maxLeft[i] = max(maxLeft[i - 1], height[i - 1])\n\n    for i in range(n - 2, -1, -1):\n        maxRight[i] = max(maxRight[i + 1], height[i + 1])\n\n    res = 0\n    for i in range(n):\n        res += max(0, min(maxLeft[i], maxRight[i]) - height[i])\n\n    return res\n\n\n# Left Right Pointers\ndef trapLR(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    left, right = 0, len(height) - 1\n    maxL, maxR = height[left], height[right]\n    res = 0\n\n    while left &lt; right:\n        if maxL &lt; maxR:\n            left += 1\n            maxL = max(maxL, height[left])\n            res += maxL - height[left]\n        else:\n            right -= 1\n            maxR = max(maxR, height[right])\n            res += maxR - height[right]\n\n    return res\n\n\n# Monotonic Stack\ndef trapStack(height: List[int]) -&gt; int:\n    stack = []\n    total = 0\n\n    for i in range(len(height)):\n        while stack and height[i] &gt; height[stack[-1]]:\n            top = stack.pop()\n            if not stack:\n                break\n            distance = i - stack[-1] - 1\n            bounded_height = min(height[i], height[stack[-1]]) - height[top]\n            total += distance * bounded_height\n        stack.append(i)\n\n    return total\n\n\nheight = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\nprint(trapDP(height))  # 6\nprint(trapLR(height))  # 6\nprint(trapStack(height))  # 6\n</code></pre> 42. Trapping Rain Water - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int trap(vector&lt;int&gt; &amp;height)\n    {\n        if (height.empty())\n            return 0;\n\n        int res = 0;\n        int left = 0, right = height.size() - 1;\n        int maxL = height[left], maxR = height[right];\n\n        while (left &lt; right)\n        {\n            if (maxL &lt; maxR)\n            {\n                left++;\n                maxL = max(maxL, height[left]);\n                res += maxL - height[left];\n            }\n            else\n            {\n                right--;\n                maxR = max(maxR, height[right]);\n                res += maxR - height[right];\n            }\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    vector&lt;int&gt; height = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};\n    Solution solution;\n    cout &lt;&lt; solution.trap(height) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/leetpattern/stack_monotonic/#901-online-stock-span","title":"901. Online Stock Span","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: stack, design, monotonic stack, data stream</p> </li> <li>Design a class <code>StockSpanner</code> to return the number of consecutive days (including the current day) the price of the stock has been less than or equal to the current price.</li> </ul> 901. Online Stock Span - Python Solution<pre><code>from typing import List\n\n\n# Monotonic Stack\nclass StockSpanner:\n\n    def __init__(self):\n        self.stack = [(-1, float(\"inf\"))]\n        self.cur_day = -1\n\n    def next(self, price: int) -&gt; int:\n        while price &gt;= self.stack[-1][1]:\n            self.stack.pop()\n        self.cur_day += 1\n        self.stack.append((self.cur_day, price))\n        return self.cur_day - self.stack[-2][0]\n\n\nif __name__ == \"__main__\":\n    ss = StockSpanner()\n    prices = [100, 80, 60, 70, 60, 75, 85]\n    print([ss.next(price) for price in prices])  # [1, 1, 1, 2, 1, 4, 6]\n</code></pre>"},{"location":"content/leetpattern/stack_monotonic/#316-remove-duplicate-letters","title":"316. Remove Duplicate Letters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack, greedy, monotonic stack 316. Remove Duplicate Letters - Python Solution<pre><code># Monotonic Stack\ndef removeDuplicateLetters(s: str) -&gt; str:\n    stack = []\n    seen = set()\n    last = {c: i for i, c in enumerate(s)}\n\n    for i, c in enumerate(s):\n        if c not in seen:\n            while stack and c &lt; stack[-1] and i &lt; last[stack[-1]]:\n                seen.discard(stack.pop())\n            seen.add(c)\n            stack.append(c)\n\n    return \"\".join(stack)\n\n\ns = \"cbacdcbc\"\nprint(removeDuplicateLetters(s))  # acdb\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/stack_monotonic/#456-132-pattern","title":"456. 132 Pattern","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, stack, monotonic stack, ordered set 456. 132 Pattern - Python Solution<pre><code>from typing import List\n\n\n# Monotonic Stack\ndef find132pattern(nums: List[int]) -&gt; bool:\n    n = len(nums)\n    if n &lt; 3:\n        return False\n\n    stack = []\n    second_max = float(\"-inf\")\n\n    for i in range(n - 1, -1, -1):\n        if nums[i] &lt; second_max:\n            return True\n\n        while stack and stack[-1] &lt; nums[i]:\n            second_max = stack.pop()\n\n        stack.append(nums[i])\n\n    return False\n\n\nnums = [-1, 3, 2, 0]\nprint(find132pattern(nums))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/stack_monotonic/#2281-sum-of-total-strength-of-wizards","title":"2281. Sum of Total Strength of Wizards","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, stack, monotonic stack, prefix sum 2281. Sum of Total Strength of Wizards - Python Solution<pre><code>from itertools import accumulate\nfrom typing import List\n\n\n# Monotonic Stack\ndef totalStrength(strength: List[int]) -&gt; int:\n    n = len(strength)\n    left = [-1 for _ in range(n)]\n    right = [n for _ in range(n)]\n    stack = []\n\n    for i, v in enumerate(strength):\n        while stack and strength[stack[-1]] &gt;= v:\n            right[stack.pop()] = i\n        if stack:\n            left[i] = stack[-1]\n        stack.append(i)\n\n    prefix_sum = list(accumulate(accumulate(strength, initial=0), initial=0))\n\n    ans = 0\n    for i, v in enumerate(strength):\n        l, r = left[i] + 1, right[i] - 1\n        tot = (i - l + 1) * (prefix_sum[r + 2] - prefix_sum[i + 1]) - (\n            r - i + 1\n        ) * (prefix_sum[i + 1] - prefix_sum[l])\n        ans += v * tot\n\n    return ans % (10**9 + 7)\n\n\nstrength = [1, 3, 1, 2]\nprint(totalStrength(strength))  # 44\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/string/","title":"String","text":""},{"location":"content/leetpattern/string/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 344. Reverse String (Easy)</li> <li> 541. Reverse String II (Easy)</li> <li> 151. Reverse Words in a String (Medium)</li> <li> 58. Length of Last Word (Easy)</li> <li> 844. Backspace String Compare (Easy)</li> <li> 2185. Counting Words With a Given Prefix (Easy)</li> <li> 2000. Reverse Prefix of Word (Easy)</li> </ul>"},{"location":"content/leetpattern/string/#344-reverse-string","title":"344. Reverse String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string 344. Reverse String - Python Solution<pre><code>from typing import List\n\n\ndef reverseString(s: List[str]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify s in-place instead.\n    \"\"\"\n    left, right = 0, len(s) - 1\n\n    while left &lt; right:\n        s[left], s[right] = s[right], s[left]\n        left += 1\n        right -= 1\n\n\ns = [\"h\", \"e\", \"l\", \"l\", \"o\"]\nreverseString(s)\nprint(s)  # ['o', 'l', 'l', 'e', 'h']\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/string/#541-reverse-string-ii","title":"541. Reverse String II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string 541. Reverse String II - Python Solution<pre><code>def reverseStr(s: str, k: int) -&gt; str:\n    def reverse_substring(text):\n        left, right = 0, len(text) - 1\n        while left &lt; right:\n            text[left], text[right] = text[right], text[left]\n            left += 1\n            right -= 1\n        return text\n\n    result = list(s)\n\n    for i in range(0, len(s), 2 * k):\n        result[i : i + k] = reverse_substring(result[i : i + k])\n\n    return \"\".join(result)\n\n\ns = \"abcdefg\"\nk = 2\nprint(reverseStr(s, k))  # \"bacdfeg\"\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/string/#151-reverse-words-in-a-string","title":"151. Reverse Words in a String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string 151. Reverse Words in a String - Python Solution<pre><code>def reverseWords(s: str) -&gt; str:\n    words = s.split()\n\n    left, right = 0, len(words) - 1\n\n    while left &lt; right:\n        words[left], words[right] = words[right], words[left]\n        left += 1\n        right -= 1\n\n    return \" \".join(words)\n\n\ns = \"the sky is blue\"\nprint(reverseWords(s))  # \"blue is sky the\"\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/string/#58-length-of-last-word","title":"58. Length of Last Word","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string 58. Length of Last Word - Python Solution<pre><code>def lengthOfLastWord(s: str) -&gt; int:\n    n = 0\n\n    for i in range(len(s) - 1, -1, -1):\n        if s[i] != \" \":\n            n += 1\n        if s[i] == \" \" and n &gt; 0:\n            return n\n\n    return n\n\n\nprint(lengthOfLastWord(\"Hello World\"))  # 5\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/string/#844-backspace-string-compare","title":"844. Backspace String Compare","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string, stack, simulation 844. Backspace String Compare - Python Solution<pre><code>def backspaceCompare(s: str, t: str) -&gt; bool:\n\n    def build(text):\n        stack = []\n\n        for char in text:\n            if char != \"#\":\n                stack.append(char)\n            elif stack:\n                stack.pop()\n\n        return \"\".join(stack)\n\n    return build(s) == build(t)\n\n\nprint(backspaceCompare(\"ab#c\", \"ad#c\"))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/string/#2185-counting-words-with-a-given-prefix","title":"2185. Counting Words With a Given Prefix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, string, string matching 2185. Counting Words With a Given Prefix - Python Solution<pre><code>from typing import List\n\n\n# 1\ndef prefixCount1(words: List[str], pref: str) -&gt; int:\n    count = 0\n\n    for word in words:\n        if word.startswith(pref):\n            count += 1\n\n    return count\n\n\n# 2\ndef prefixCount2(words: List[str], pref: str) -&gt; int:\n    count = 0\n\n    for word in words:\n        n = len(pref)\n\n        if len(word) &lt; n:\n            continue\n\n        if word[:n] == pref:\n            count += 1\n\n    return count\n\n\nwords = [\"pay\", \"attention\", \"practice\", \"attend\"]\npref = \"at\"\nprint(prefixCount1(words, pref))  # 2\nprint(prefixCount2(words, pref))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/string/#2000-reverse-prefix-of-word","title":"2000. Reverse Prefix of Word","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string, stack 2000. Reverse Prefix of Word - Python Solution<pre><code>def reversePrefix(word: str, ch: str) -&gt; str:\n    if ch not in word:\n        return word\n\n    wordList = list(word)\n    left, right = 0, 0\n\n    for i in range(len(wordList)):\n        if wordList[i] == ch:\n            right = i\n            break\n\n    while left &lt; right:\n        wordList[left], wordList[right] = wordList[right], wordList[left]\n        left += 1\n        right -= 1\n\n    return \"\".join(wordList)\n\n\nword = \"abcdefd\"\nch = \"d\"\nprint(reversePrefix(word, ch))  # \"dcbaefd\"\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/tree_bfs/","title":"Tree BFS","text":""},{"location":"content/leetpattern/tree_bfs/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 199. Binary Tree Right Side View (Medium)</li> <li> 111. Minimum Depth of Binary Tree (Easy)</li> <li> 104. Maximum Depth of Binary Tree (Easy)</li> <li> 637. Average of Levels in Binary Tree (Easy)</li> <li> 429. N-ary Tree Level Order Traversal (Medium)</li> <li> 515. Find Largest Value in Each Tree Row (Medium)</li> <li> 116. Populating Next Right Pointers in Each Node (Medium)</li> <li> 117. Populating Next Right Pointers in Each Node II (Medium)</li> <li> 513. Find Bottom Left Tree Value (Medium)</li> <li> 863. All Nodes Distance K in Binary Tree (Medium)</li> </ul>"},{"location":"content/leetpattern/tree_bfs/#199-binary-tree-right-side-view","title":"199. Binary Tree Right Side View","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 199. Binary Tree Right Side View - Python Solution<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Binary Tree BFS\ndef rightSideViewBFS(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        n = len(q)\n        for i in range(n):\n            node = q.popleft()\n            if i == n - 1:\n                res.append(node.val)\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return res\n\n\n# Binary Tree DFS\ndef rightSideViewDFS(root: Optional[TreeNode]) -&gt; List[int]:\n    \"\"\"\u540e\u5e8f\u904d\u5386\uff0c\u5148\u53f3\u540e\u5de6\uff0c\u9047\u5230\u7684\u7b2c\u4e00\u4e2a\u8282\u70b9\u5c31\u662f\u8be5\u6df1\u5ea6\u7684\u6700\u53f3\u4fa7\u8282\u70b9\"\"\"\n    ans = []\n\n    def dfs(node, depth):\n        if node is None:\n            return\n        if depth == len(ans):  # \u8fd9\u4e2a\u6df1\u5ea6\u9996\u6b21\u9047\u5230\n            ans.append(node.val)\n\n        dfs(node.right, depth + 1)\n        dfs(node.left, depth + 1)\n\n    dfs(root, 0)\n\n    return ans\n\n\nif __name__ == \"__main__\":\n    root = [1, 2, 2, 3, 4, None, 3, None, None, 5]\n    root = build(root)\n    print(root)\n    #     ____1\n    #    /     \\\n    #   2__     2\n    #  /   \\     \\\n    # 3     4     3\n    #      /\n    #     5\n    assert rightSideViewBFS(root) == [1, 2, 3, 5]\n    assert rightSideViewDFS(root) == [1, 2, 3, 5]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/tree_bfs/#111-minimum-depth-of-binary-tree","title":"111. Minimum Depth of Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 111. Minimum Depth of Binary Tree - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Iterative\ndef minDepthIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n    res = 0\n\n    while q:\n        res += 1\n\n        for _ in range(len(q)):\n            node = q.popleft()\n\n            if not node.left and not node.right:\n                return res\n\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n\n# Recursive\ndef minDepthRecursive(root: Optional[TreeNode]) -&gt; int:\n    if root is None:\n        return 0\n\n    if root.left is None and root.right is not None:\n        return 1 + minDepthRecursive(root.right)\n    if root.left is not None and root.right is None:\n        return 1 + minDepthRecursive(root.left)\n\n    return 1 + min(minDepthRecursive(root.left), minDepthRecursive(root.right))\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n\"\"\"\n    ____1\n   /     \\\n  2__     2\n /   \\\n3     4\n     /\n    5\n\n\"\"\"\nprint(minDepthIterative(root))  # 2\nprint(minDepthRecursive(root))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/tree_bfs/#104-maximum-depth-of-binary-tree","title":"104. Maximum Depth of Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 104. Maximum Depth of Binary Tree - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef maxDepthRecursive(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    left = maxDepthRecursive(root.left)\n    right = maxDepthRecursive(root.right)\n\n    return 1 + max(left, right)\n\n\n# DFS\ndef maxDepthDFS(root: Optional[TreeNode]) -&gt; int:\n    res = 0\n\n    def dfs(node, cnt):\n        if node is None:\n            return\n        cnt += 1\n        nonlocal res\n        res = max(res, cnt)\n\n        dfs(node.left, cnt)\n        dfs(node.right, cnt)\n\n    dfs(root, 0)\n\n    return res\n\n\n# Iterative\ndef maxDepthIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n    res = 0\n\n    while q:\n        res += 1\n        n = len(q)\n\n        for _ in range(n):\n            node = q.popleft()\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    root = [1, 2, 2, 3, 4, None, None, None, None, 5]\n    root = build(root)\n    print(root)\n    #     ____1\n    #    /     \\\n    #   2__     2\n    #  /   \\\n    # 3     4\n    #      /\n    #     5\n    assert maxDepthRecursive(root) == 4\n    assert maxDepthDFS(root) == 4\n    assert maxDepthIterative(root) == 4\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/tree_bfs/#637-average-of-levels-in-binary-tree","title":"637. Average of Levels in Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 637. Average of Levels in Binary Tree - Python Solution<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Binary Tree BFS\ndef averageOfLevels(root: Optional[TreeNode]) -&gt; List[float]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        n = len(q)\n        level = 0\n        for _ in range(n):\n            cur = q.popleft()\n            level += cur.val\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(float(level / n))\n\n    return res\n\n\nif __name__ == \"__main__\":\n    root = [3, 9, 20, None, None, 15, 7]\n    root = build(root)\n    print(root)\n    #   3___\n    #  /    \\\n    # 9     _20\n    #      /   \\\n    #     15    7\n    assert averageOfLevels(root) == [3.00000, 14.50000, 11.00000]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/tree_bfs/#429-n-ary-tree-level-order-traversal","title":"429. N-ary Tree Level Order Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, breadth first search 429. N-ary Tree Level Order Traversal - Python Solution<pre><code>from collections import deque\nfrom typing import List, Optional\n\n\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\n\ndef levelOrder(root: Optional[Node]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    queue = deque([root])\n    result = []\n\n    while queue:\n        level = []\n        size = len(queue)\n\n        for _ in range(size):\n            node = queue.popleft()\n            level.append(node.val)\n\n            for child in node.children:\n                queue.append(child)\n\n        result.append(level)\n\n    return result\n\n\nroot = Node(\n    1,\n    [\n        Node(\n            3,\n            [\n                Node(5, []),\n                Node(6, []),\n            ],\n        ),\n        Node(2, []),\n        Node(4, []),\n    ],\n)\nprint(levelOrder(root))  # [[1], [3, 2, 4], [5, 6]]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/tree_bfs/#515-find-largest-value-in-each-tree-row","title":"515. Find Largest Value in Each Tree Row","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 515. Find Largest Value in Each Tree Row - Python Solution<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef largestValues(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    queue = deque([root])\n    result = []\n\n    while queue:\n        levelMax = float(\"-inf\")\n        for _ in range(len(queue)):\n            node = queue.popleft()\n\n            levelMax = max(levelMax, node.val)\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n        result.append(levelMax)\n\n    return result\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n#     ____1\n#    /     \\\n#   2__     2\n#  /   \\\n# 3     4\n#      /\n#     5\nprint(largestValues(root))  # [1, 2, 4, 5]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/tree_bfs/#116-populating-next-right-pointers-in-each-node","title":"116. Populating Next Right Pointers in Each Node","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, tree, depth first search, breadth first search, binary tree</p> </li> <li>Perfect Binary Tree</li> </ul> 116. Populating Next Right Pointers in Each Node - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\n\nclass Node:\n    def __init__(\n        self,\n        val: int = 0,\n        left: \"Node\" = None,\n        right: \"Node\" = None,\n        next: \"Node\" = None,\n    ):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\n\ndef connect(root: \"Optional[Node]\") -&gt; \"Optional[Node]\":\n    if not root:\n        return root\n\n    queue = deque([root])\n\n    while queue:\n        size = len(queue)\n        prev = None\n\n        for _ in range(size):\n            node = queue.popleft()\n\n            if prev:\n                prev.next = node\n            prev = node\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n    return root\n\n\n# Perfect binary tree creation\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.right.left = Node(6)\nroot.right.right = Node(7)\n#     __1__\n#    /     \\\n#   2__     3\n#  /   \\   / \\\n# 4     5 6   7\n\n\n# Connect the nodes\nconnect(root)\n#      __1__ -&gt; None\n#     /     \\\n#   _2_ -&gt;  3 -&gt; None\n#  /   \\   / \\\n# 4 -&gt; 5-&gt;6-&gt; 7 -&gt; None\n\n\nassert root.next is None\nassert root.left.next == root.right\nassert root.left.left.next == root.left.right\nassert root.left.right.next == root.right.left\nassert root.right.left.next == root.right.right\nassert root.right.right.next is None\nprint(\"All tests passed.\")\n</code></pre>"},{"location":"content/leetpattern/tree_bfs/#117-populating-next-right-pointers-in-each-node-ii","title":"117. Populating Next Right Pointers in Each Node II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, tree, depth first search, breadth first search, binary tree 117. Populating Next Right Pointers in Each Node II - Python Solution<pre><code>from collections import deque\n\n\nclass Node:\n    def __init__(\n        self,\n        val: int = 0,\n        left: \"Node\" = None,\n        right: \"Node\" = None,\n        next: \"Node\" = None,\n    ):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\n\ndef connect(root: \"Node\") -&gt; \"Node\":\n    if not root:\n        return root\n\n    queue = deque([root])\n\n    while queue:\n        size = len(queue)\n        prev = None\n\n        for _ in range(size):\n            node = queue.popleft()\n\n            if prev:\n                prev.next = node\n\n            prev = node\n\n            if node.left:\n                queue.append(node.left)\n\n            if node.right:\n                queue.append(node.right)\n\n    return root\n\n\n# Binary tree creation\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.right.right = Node(7)\n#       1\n#      / \\\n#     2   3\n#    / \\   \\\n#   4   5   7\n\n# Connect the nodes\nconnect(root)\n#       1 -&gt; None\n#      / \\\n#     2 -&gt; 3 -&gt; None\n#    / \\    \\\n#   4 -&gt; 5 -&gt; 7 -&gt; None\n\nassert root.next is None\nassert root.left.next == root.right\nassert root.right.next is None\nassert root.left.left.next == root.left.right\nassert root.left.right.next == root.right.right\nassert root.right.right.next is None\n\nprint(\"All tests passed.\")\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/tree_bfs/#513-find-bottom-left-tree-value","title":"513. Find Bottom Left Tree Value","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 513. Find Bottom Left Tree Value - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef findBottomLeftValue(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    queue = deque([root])\n    result = 0\n\n    while queue:\n        size = len(queue)\n\n        for i in range(size):\n            node = queue.popleft()\n            if i == 0:\n                result = node.val\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n    return result\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n#     ____1\n#    /     \\\n#   2__     2\n#  /   \\\n# 3     4\n#      /\n#     5\n\nprint(findBottomLeftValue(root))  # 5\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/tree_bfs/#863-all-nodes-distance-k-in-binary-tree","title":"863. All Nodes Distance K in Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, tree, depth first search, breadth first search, binary tree 863. All Nodes Distance K in Binary Tree - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BFS\ndef distanceK(root: TreeNode, target: TreeNode, k: int) -&gt; List[int]:\n    parent = dict()\n\n    def dfs(node, par=None):\n        if node:\n            parent[node] = par\n            dfs(node.left, node)\n            dfs(node.right, node)\n\n    dfs(root)\n\n    q = deque([(target, 0)])\n    seen = set([target])\n\n    while q:\n        node, dist = q.popleft()\n\n        if dist == k:\n            return [node.val] + [node.val for node, _ in q]\n\n        for nei in (node.left, node.right, parent[node]):\n            if nei and nei not in seen:\n                seen.add(nei)\n                q.append((nei, dist + 1))\n\n    return []\n\n\nroot = build([3, 5, 1, 6, 2, 0, 8, None, None, 7, 4])\nprint(root)\n#     ______3__\n#    /         \\\n#   5__         1\n#  /   \\       / \\\n# 6     2     0   8\n#      / \\\n#     7   4\ntarget = root.left\nk = 2\nprint(distanceK(root, target, k))  # [7, 4, 1]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/tree_feature/","title":"Tree Feature","text":""},{"location":"content/leetpattern/tree_feature/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 101. Symmetric Tree (Easy)</li> <li> 222. Count Complete Tree Nodes (Easy)</li> <li> 110. Balanced Binary Tree (Easy)</li> <li> 257. Binary Tree Paths (Easy)</li> <li> 404. Sum of Left Leaves (Easy)</li> <li> 112. Path Sum (Easy)</li> <li> 2331. Evaluate Boolean Binary Tree (Easy)</li> <li> 100. Same Tree (Easy)</li> <li> 235. Lowest Common Ancestor of a Binary Search Tree (Medium)</li> <li> 236. Lowest Common Ancestor of a Binary Tree (Medium)</li> </ul>"},{"location":"content/leetpattern/tree_feature/#101-symmetric-tree","title":"101. Symmetric Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 101. Symmetric Tree - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef is_symmetric_recursive(root: Optional[TreeNode]) -&gt; bool:\n    if not root:\n        return True\n\n    def check(left, right):\n        if left is right:\n            return True\n        if not left or not right or left.val != right.val:\n            return False\n        outside = check(left.left, right.right)\n        inside = check(left.right, right.left)\n        return outside and inside\n\n    return check(root.left, root.right)\n\n\n# Iterative\ndef is_symmetric_iterative(root: Optional[TreeNode]) -&gt; bool:\n    if not root:\n        return True\n\n    q = deque()\n    q.append(root.left)\n    q.append(root.right)\n\n    while q:\n        left = q.popleft()\n        right = q.popleft()\n\n        if not left and not right:\n            continue\n\n        if not left or not right or left.val != right.val:\n            return False\n\n        q.append(left.left)\n        q.append(right.right)\n        q.append(left.right)\n        q.append(right.left)\n\n    return True\n\n\nif __name__ == \"__main__\":\n    root = [1, 2, 2, 3, 4, 4, 3]\n    root = build(root)\n    print(root)\n    #     __1__\n    #    /     \\\n    #   2       2\n    #  / \\     / \\\n    # 3   4   4   3\n    assert is_symmetric_recursive(root) is True\n    assert is_symmetric_iterative(root) is True\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/tree_feature/#222-count-complete-tree-nodes","title":"222. Count Complete Tree Nodes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: binary search, bit manipulation, tree, binary tree 222. Count Complete Tree Nodes - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef countNodesRecursive(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    num = 1 + countNodesRecursive(root.left) + countNodesRecursive(root.right)\n\n    return num\n\n\n# Iterative\ndef countNodesIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n    count = 0\n\n    while q:\n        n = len(q)\n\n        for _ in range(n):\n            node = q.popleft()\n            count += 1\n\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return count\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Recursive  |  O(n)  |  O(n)   |\n# | Iterative  |  O(n)  |  O(n)   |\n# |------------|--------|---------|\n\nroot = [1, 2, 3, 4, 5, 6]\nroot = build(root)\nprint(root)\n#     __1__\n#    /     \\\n#   2       3\n#  / \\     /\n# 4   5   6\nprint(countNodesRecursive(root))  # 6\nprint(countNodesIterative(root))  # 6\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/tree_feature/#110-balanced-binary-tree","title":"110. Balanced Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, binary tree 110. Balanced Binary Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef isBalanced(root: Optional[TreeNode]) -&gt; bool:\n    def getHeight(node):\n        if not node:\n            return 0\n\n        # post order\n        leftHeight = getHeight(node.left)\n        rightHeight = getHeight(node.right)\n\n        if leftHeight == -1 or rightHeight == -1:\n            return -1\n\n        if abs(leftHeight - rightHeight) &gt; 1:\n            return -1\n        else:\n            return 1 + max(leftHeight, rightHeight)\n\n    if getHeight(root) != -1:\n        return True\n    else:\n        return False\n\n\nroot = [3, 9, 20, None, None, 15, 7]\nroot = build(root)\nprint(root)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(isBalanced(root))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/tree_feature/#257-binary-tree-paths","title":"257. Binary Tree Paths","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, backtracking, tree, depth first search, binary tree 257. Binary Tree Paths - Python Solution<pre><code>from typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef binaryTreePaths(root: Optional[TreeNode]) -&gt; List[str]:\n    res = []\n\n    def dfs(node, path):\n        if not node:\n            return\n        path += str(node.val)\n\n        if not node.left and not node.right:\n            res.append(path)\n            return\n\n        path += \"-&gt;\"\n\n        dfs(node.left, path)\n        dfs(node.right, path)\n\n    dfs(root, \"\")\n\n    return res\n\n\nroot = build([1, 2, 3, None, 5])\nprint(root)\n#   __1\n#  /   \\\n# 2     3\n#  \\\n#   5\nprint(binaryTreePaths(root))  # ['1-&gt;2-&gt;5', '1-&gt;3']\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/tree_feature/#404-sum-of-left-leaves","title":"404. Sum of Left Leaves","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 404. Sum of Left Leaves - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Iterative\ndef sumOfLeftLeaves(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    stack = [root]\n    sumLL = 0\n\n    while stack:\n        node = stack.pop()\n\n        if node.left and not node.left.left and not node.left.right:\n            sumLL += node.left.val\n\n        if node.right:\n            stack.append(node.right)\n        if node.left:\n            stack.append(node.left)\n\n    return sumLL\n\n\n# Left Leave None:\n#   - node.left is not None\n#   - node.left.left is None\n#   - node.left.right is None\n\nroot = build([3, 9, 20, None, None, 15, 7])\nprint(root)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(sumOfLeftLeaves(root))  # 24\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/tree_feature/#112-path-sum","title":"112. Path Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 112. Path Sum - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef hasPathSum(root: Optional[TreeNode], targetSum: int) -&gt; bool:\n    if not root:\n        return False\n\n    if not root.left and not root.right:\n        return root.val == targetSum\n\n    targetSum -= root.val\n\n    return hasPathSum(root.left, targetSum) or hasPathSum(\n        root.right, targetSum\n    )\n\n\nroot = build([5, 4, 8, 11, None, 13, 4, 7, 2, None, None, None, None, None, 1])\nprint(root)\n#          5___\n#         /    \\\n#     ___4     _8\n#    /        /  \\\n#   11       13   4\n#  /  \\            \\\n# 7    2            1\nprint(hasPathSum(root, 22))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/tree_feature/#2331-evaluate-boolean-binary-tree","title":"2331. Evaluate Boolean Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, binary tree 2331. Evaluate Boolean Binary Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef evaluateTree(root: Optional[TreeNode]) -&gt; bool:\n    if not root.left and not root.right:\n        return root.val\n\n    left = evaluateTree(root.left)\n    right = evaluateTree(root.right)\n\n    if root.val == 2:\n        return left or right\n    elif root.val == 3:\n        return left and right\n\n\nroot = build([2, 1, 3, None, None, 0, 1])\nprint(root)\n#   2__\n#  /   \\\n# 1     3\n#      / \\\n#     0   1\nboolTree = build([\"OR\", \"True\", \"AND\", None, None, \"False\", \"True\"])\nprint(boolTree)\n#    __OR_______\n#   /           \\\n# True        __AND_\n#            /      \\\n#         False     True\nprint(evaluateTree(root))  # 1\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/tree_feature/#100-same-tree","title":"100. Same Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 100. Same Tree - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# 1. Recursive\ndef isSameTreeRecursive(p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:\n    if not p and not q:\n        return True\n    elif not p or not q:\n        return False\n    elif p.val != q.val:\n        return False\n\n    return isSameTreeRecursive(p.left, q.left) and isSameTreeRecursive(\n        p.right, q.right\n    )\n\n\n# 2. Iterative with queue\ndef isSameTreeIterativeQueue(\n    p: Optional[TreeNode], q: Optional[TreeNode]\n) -&gt; bool:\n    queue = deque([(p, q)])\n\n    while queue:\n        p, q = queue.popleft()\n\n        if not p and not q:\n            continue\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n\n        queue.append((p.left, q.left))\n        queue.append((p.right, q.right))\n\n    return True\n\n\n# 3. Iterative with stack\ndef isSameTreeIterativeStack(\n    p: Optional[TreeNode], q: Optional[TreeNode]\n) -&gt; bool:\n    stack = [(p, q)]\n\n    while stack:\n        n1, n2 = stack.pop()\n\n        if not n1 and not n2:\n            continue\n        if not n1 or not n2:\n            return False\n        if n1.val != n2.val:\n            return False\n\n        stack.append((n1.left, n2.left))\n        stack.append((n1.right, n2.right))\n\n    return True\n\n\nif __name__ == \"__main__\":\n    p1 = build([1, 2, 3])\n    q1 = build([1, 2, 3])\n    p2 = build([1, 2])\n    q2 = build([1, None, 2])\n\n    assert isSameTreeRecursive(p1, q1) is True\n    assert isSameTreeRecursive(p2, q2) is False\n    assert isSameTreeIterativeQueue(p1, q1) is True\n    assert isSameTreeIterativeQueue(p2, q2) is False\n    assert isSameTreeIterativeStack(p1, q1) is True\n    assert isSameTreeIterativeStack(p2, q2) is False\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/tree_feature/#235-lowest-common-ancestor-of-a-binary-search-tree","title":"235. Lowest Common Ancestor of a Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree 235. Lowest Common Ancestor of a Binary Search Tree - Python Solution<pre><code>from binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef lowestCommonAncestor(\n    root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n) -&gt; \"TreeNode\":\n    while root:\n        if root.val &gt; p.val and root.val &gt; q.val:\n            root = root.left\n        elif root.val &lt; p.val and root.val &lt; q.val:\n            root = root.right\n        else:\n            return root\n\n\nroot = [6, 2, 8, 0, 4, 7, 9, None, None, 3, 5]\nroot = build(root)\np = root.left\nq = root.right\nprint(root)\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\nprint(lowestCommonAncestor(root, p, q))\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/tree_feature/#236-lowest-common-ancestor-of-a-binary-tree","title":"236. Lowest Common Ancestor of a Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree 236. Lowest Common Ancestor of a Binary Tree - Python Solution<pre><code>from typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef lowestCommonAncestor(\n    root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n) -&gt; \"TreeNode\":\n    if not root or q == root or p == root:\n        return root\n\n    left = lowestCommonAncestor(root.left, p, q)\n    right = lowestCommonAncestor(root.right, p, q)\n\n    if left and right:\n        return root\n\n    return left or right\n\n\nroot = build([3, 5, 1, 6, 2, 0, 8, None, None, 7, 4])\nprint(root)\n#     ______3__\n#    /         \\\n#   5__         1\n#  /   \\       / \\\n# 6     2     0   8\n#      / \\\n#     7   4\np = root.left  # 5\nq = root.right  # 1\nprint(lowestCommonAncestor(root, p, q))  # 3\n#     ______3__\n#    /         \\\n#   5__         1\n#  /   \\       / \\\n# 6     2     0   8\n#      / \\\n#     7   4\nr = root.left.right.right  # 4\nprint(lowestCommonAncestor(root, p, r))  # 5\n#   5__\n#  /   \\\n# 6     2\n#      / \\\n#     7   4\n</code></pre></p> </li> </ul> 236. Lowest Common Ancestor of a Binary Tree - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   public:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if (root == nullptr || root == p || root == q) {\n            return root;\n        }\n\n        TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);\n        TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);\n\n        if (left &amp;&amp; right) {\n            return root;\n        }\n\n        return left ? left : right;\n    }\n};\n\nint main() { return 0; }\n</code></pre>"},{"location":"content/leetpattern/tree_modification/","title":"Tree Modification","text":""},{"location":"content/leetpattern/tree_modification/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 226. Invert Binary Tree (Easy)</li> <li> 105. Construct Binary Tree from Preorder and Inorder Traversal (Medium)</li> <li> 106. Construct Binary Tree from Inorder and Postorder Traversal (Medium)</li> <li> 654. Maximum Binary Tree (Medium)</li> <li> 617. Merge Two Binary Trees (Easy)</li> </ul>"},{"location":"content/leetpattern/tree_modification/#226-invert-binary-tree","title":"226. Invert Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 226. Invert Binary Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef invertTreeRecursive(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    root.left, root.right = root.right, root.left\n\n    invertTreeRecursive(root.left)\n    invertTreeRecursive(root.right)\n\n    return root\n\n\n# Iterative\ndef invertTreeIterative(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    stack = [root]\n\n    while stack:\n        node = stack.pop()\n\n        node.left, node.right = node.right, node.left\n        if node.left:\n            stack.append(node.left)\n        if node.right:\n            stack.append(node.right)\n\n    return root\n\n\nroot = build([4, 2, 7, 1, 3, 6, 9])\nprint(root)\n#     __4__\n#    /     \\\n#   2       7\n#  / \\     / \\\n# 1   3   6   9\ninvertedRecursive = invertTreeRecursive(root)\nprint(invertedRecursive)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\nroot = build([4, 2, 7, 1, 3, 6, 9])\ninvertedIterative = invertTreeIterative(root)\nprint(invertedIterative)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/tree_modification/#105-construct-binary-tree-from-preorder-and-inorder-traversal","title":"105. Construct Binary Tree from Preorder and Inorder Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, divide and conquer, tree, binary tree 105. Construct Binary Tree from Preorder and Inorder Traversal - Python Solution<pre><code>from typing import List, Optional\n\nfrom helper import TreeNode\n\n\ndef buildTree(preorder: List[int], inorder: List[int]) -&gt; Optional[TreeNode]:\n    \"\"\"\n    preorder  root left right  1  2  3\n    inorder   left root right  4  5  6\n    \"\"\"\n    if len(preorder) == 0:\n        return None\n\n    root_val = preorder[0]  # 1\n    root = TreeNode(root_val)\n\n    separator_idx = inorder.index(root_val)  # 5\n\n    left_inorder = inorder[:separator_idx]  # 4\n    right_inorder = inorder[separator_idx + 1 :]  # 6\n\n    left_preorder = preorder[1 : 1 + len(left_inorder)]  # 2\n    right_preorder = preorder[1 + len(left_inorder) :]  # 3\n\n    root.left = buildTree(left_preorder, left_inorder)\n    root.right = buildTree(right_preorder, right_inorder)\n\n    return root\n\n\npreorder = [3, 9, 20, 15, 7]\ninorder = [9, 3, 15, 20, 7]\nroot = buildTree(preorder, inorder)\nprint(root)\n#     3\n#    / \\\n#   9  20\n#     /  \\\n#    15   7\n</code></pre></p> </li> </ul> 105. Construct Binary Tree from Preorder and Inorder Traversal - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   public:\n    vector&lt;int&gt; preorder;\n    unordered_map&lt;int, int&gt; inorderMap;\n\n    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {\n        this-&gt;preorder = preorder;\n        for (size_t i = 0; i &lt; inorder.size(); i++) {\n            inorderMap[inorder[i]] = i;\n        }\n        return buildSubtree(0, 0, inorder.size() - 1);\n    }\n\n   private:\n    TreeNode* buildSubtree(int rootIndex, int left, int right) {\n        if (left &gt; right) return nullptr;\n\n        TreeNode* root = new TreeNode(preorder[rootIndex]);\n        int inorderIndex = inorderMap[preorder[rootIndex]];\n\n        root-&gt;left = buildSubtree(rootIndex + 1, left, inorderIndex - 1);\n        root-&gt;right = buildSubtree(rootIndex + (inorderIndex - left + 1),\n                                   inorderIndex + 1, right);\n\n        return root;\n    }\n};\n\nint main() {\n    vector&lt;int&gt; preorder = {3, 9, 20, 15, 7};\n    vector&lt;int&gt; inorder = {9, 3, 15, 20, 7};\n    Solution solution;\n    TreeNode* root = solution.buildTree(preorder, inorder);\n    cout &lt;&lt; root-&gt;val &lt;&lt; endl;                // 3\n    cout &lt;&lt; root-&gt;left-&gt;val &lt;&lt; endl;          // 9\n    cout &lt;&lt; root-&gt;right-&gt;val &lt;&lt; endl;         // 20\n    cout &lt;&lt; root-&gt;right-&gt;left-&gt;val &lt;&lt; endl;   // 15\n    cout &lt;&lt; root-&gt;right-&gt;right-&gt;val &lt;&lt; endl;  // 7\n    return 0;\n}\n</code></pre>"},{"location":"content/leetpattern/tree_modification/#106-construct-binary-tree-from-inorder-and-postorder-traversal","title":"106. Construct Binary Tree from Inorder and Postorder Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, divide and conquer, tree, binary tree 106. Construct Binary Tree from Inorder and Postorder Traversal - Python Solution<pre><code>from typing import List, Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef buildTree(inorder: List[int], postorder: List[int]) -&gt; Optional[TreeNode]:\n    \"\"\"\n    inorder:    left root  right   1  2  3\n    postorder:  left right root    4  5  6\n    \"\"\"\n\n    if not postorder:\n        return None\n\n    root_val = postorder[-1]  # 6\n    root = TreeNode(root_val)\n\n    separator_idx = inorder.index(root_val)  # 2\n\n    left_inorder = inorder[:separator_idx]  # 1\n    right_inorder = inorder[separator_idx + 1 :]  # 3\n\n    left_postorder = postorder[: len(left_inorder)]  # 4\n    right_postorder = postorder[len(left_inorder) : -1]  # 5\n\n    root.left = buildTree(left_inorder, left_postorder)\n    root.right = buildTree(right_inorder, right_postorder)\n\n    return root\n\n\ninorder = [9, 3, 15, 20, 7]\npostorder = [9, 15, 7, 20, 3]\nroot = buildTree(inorder, postorder)\nprint(root)\n#     3\n#    / \\\n#   9  20\n#     /  \\\n#    15   7\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/tree_modification/#654-maximum-binary-tree","title":"654. Maximum Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, divide and conquer, stack, tree, monotonic stack, binary tree 654. Maximum Binary Tree - Python Solution<pre><code>from typing import List, Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef constructMaximumBinaryTree(nums: List[int]) -&gt; Optional[TreeNode]:\n    if len(nums) == 0:\n        return None\n\n    maximum = max(nums)\n    rootIndex = nums.index(maximum)\n\n    root = TreeNode(maximum)\n\n    left_nums = nums[:rootIndex]\n    right_nums = nums[rootIndex + 1 :]\n\n    root.left = constructMaximumBinaryTree(left_nums)\n    root.right = constructMaximumBinaryTree(right_nums)\n\n    return root\n\n\nnums = [3, 2, 1, 6, 0, 5]\nroot = constructMaximumBinaryTree(nums)\n#     __6__\n#    /     \\\n#   3       5\n#    \\     /\n#     2   0\n#      \\\n#       1\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/tree_modification/#617-merge-two-binary-trees","title":"617. Merge Two Binary Trees","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 617. Merge Two Binary Trees - Python Solution<pre><code>from typing import List, Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef mergeTrees(\n    root1: Optional[TreeNode], root2: Optional[TreeNode]\n) -&gt; Optional[TreeNode]:\n\n    if not root1:\n        return root2\n    if not root2:\n        return root1\n\n    root = TreeNode()\n\n    root.val += root1.val + root2.val\n    root.left = mergeTrees(root1.left, root2.left)\n    root.right = mergeTrees(root1.right, root2.right)\n\n    return root\n\n\nroot1 = TreeNode(1)\nroot1.left = TreeNode(3)\nroot1.right = TreeNode(2)\nroot1.left.left = TreeNode(5)\n#     1\n#    / \\\n#   3   2\n#  /\n# 5\n\nroot2 = TreeNode(2)\nroot2.left = TreeNode(1)\nroot2.right = TreeNode(3)\nroot2.left.right = TreeNode(4)\nroot2.right.right = TreeNode(7)\n#     2\n#    / \\\n#   1   3\n#    \\   \\\n#     4   7\n\nroot = mergeTrees(root1, root2)\n#     3\n#    / \\\n#   4   5\n#  / \\   \\\n# 5   4   7\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/tree_traversal/","title":"Tree Traversal","text":""},{"location":"content/leetpattern/tree_traversal/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 144. Binary Tree Preorder Traversal (Easy)</li> <li> 94. Binary Tree Inorder Traversal (Easy)</li> <li> 145. Binary Tree Postorder Traversal (Easy)</li> <li> 102. Binary Tree Level Order Traversal (Medium)</li> <li> 107. Binary Tree Level Order Traversal II (Medium)</li> <li> 103. Binary Tree Zigzag Level Order Traversal (Medium)</li> </ul>"},{"location":"content/leetpattern/tree_traversal/#144-binary-tree-preorder-traversal","title":"144. Binary Tree Preorder Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: stack, tree, depth first search, binary tree </p> </li> </ul>"},{"location":"content/leetpattern/tree_traversal/#example-1","title":"Example 1","text":"<pre><code>graph TD\nA(( ))\nB(( ))\nC(( ))\nD(( ))\nE(( ))\nF(( ))\nG(( ))\nA --- B\nA --- E\nB --- C\nB --- D\nE --- F\nE --- G</code></pre> <p>Pre-order Traversal</p> <pre><code>graph TD\n0((0))\n1((1))\n2((2))\n3((3))\n4((4))\n5((5))\n6((6))\n0 --- 1\n0 --- 4\n1 --- 2\n1 --- 3\n4 --- 5\n4 --- 6</code></pre> <p>In-order Traversal</p> <pre><code>graph TD\n0((0))\n1((1))\n2((2))\n3((3))\n4((4))\n5((5))\n6((6))\n3 --- 1\n3 --- 5\n1 --- 0\n1 --- 2\n5 --- 4\n5 --- 6</code></pre> <p>Post-order Traversal</p> <pre><code>graph TD\n0((0))\n1((1))\n2((2))\n3((3))\n4((4))\n5((5))\n6((6))\n6 --- 2\n6 --- 5\n2 --- 0\n2 --- 1\n5 --- 3\n5 --- 4</code></pre> <p>Level Order Traversal</p> <pre><code>graph TD\n0((0))\n1((1))\n2((1))\n3((2))\n4((2))\n5((2))\n6((2))\n0 --- 1\n0 --- 2\n1 --- 3\n1 --- 4\n2 --- 5\n2 --- 6</code></pre>"},{"location":"content/leetpattern/tree_traversal/#example-2","title":"Example 2","text":"<pre><code>graph TD\n0((0))\n1((1))\n2((2))\n3((3))\n4((4))\n5((5))\n6((6))\n0 --- 1\n0 --- 2\n1 --- 3\n1 --- 4\n2 --- 5\n2 --- 6</code></pre> Traversal Order Method Result Preorder Root, Left, Right DFS or Stack <code>[0, 1, 3, 4, 2, 5, 6]</code> Inorder Left, Root, Right DFS or Stack <code>[3, 1, 4, 0, 5, 2, 6]</code> Postorder Left, Right, Root DFS or Stack <code>[3, 4, 1, 5, 6, 2, 0]</code> Level Order Level by Level BFS with Queue <code>[[0], [1, 2], [3, 4, 5, 6]]</code> 144. Binary Tree Preorder Traversal - Python Solution<pre><code>from typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef preorderTraversalRecursive(root: Optional[TreeNode]) -&gt; List[int]:\n    res = []\n\n    def dfs(node):\n        if not node:\n            return None\n\n        res.append(node.val)  # &lt;--\n        dfs(node.left)\n        dfs(node.right)\n\n    dfs(root)\n\n    return res\n\n\n# Iterative\ndef preorderTraversalIterative(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    stack = [root]\n    res = []\n\n    while stack:\n        node = stack.pop()\n        res.append(node.val)\n\n        if node.right:\n            stack.append(node.right)\n        if node.left:\n            stack.append(node.left)\n\n    return res\n\n\ntree = build([0, 1, 2, 3, 4, 5, 6])\nprint(tree)\n#     __0__\n#    /     \\\n#   1       2\n#  / \\     / \\\n# 3   4   5   6\nprint(preorderTraversalRecursive(tree))  # [0, 1, 3, 4, 2, 5, 6]\nprint(preorderTraversalIterative(tree))  # [0, 1, 3, 4, 2, 5, 6]\n</code></pre>"},{"location":"content/leetpattern/tree_traversal/#94-binary-tree-inorder-traversal","title":"94. Binary Tree Inorder Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: stack, tree, depth first search, binary tree 94. Binary Tree Inorder Traversal - Python Solution<pre><code>from typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef inorderTraversalRecursive(root: TreeNode) -&gt; List[int]:\n    res = []\n\n    def dfs(node):\n        if not node:\n            return\n\n        dfs(node.left)\n        res.append(node.val)  # &lt;--\n        dfs(node.right)\n\n    dfs(root)\n\n    return res\n\n\n# Iterative\ndef inorderTraversalIterative(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    stack = []\n    res = []\n    cur = root\n\n    while cur or stack:\n        if cur:\n            stack.append(cur)\n            cur = cur.left\n        else:\n            cur = stack.pop()\n            res.append(cur.val)\n            cur = cur.right\n\n    return res\n\n\ntree = build([0, 1, 2, 3, 4, 5, 6])\nprint(tree)\n#     __0__\n#    /     \\\n#   1       2\n#  / \\     / \\\n# 3   4   5   6\nprint(inorderTraversalRecursive(tree))  # [3, 1, 4, 0, 5, 2, 6]\nprint(inorderTraversalIterative(tree))  # [3, 1, 4, 0, 5, 2, 6]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/tree_traversal/#145-binary-tree-postorder-traversal","title":"145. Binary Tree Postorder Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: stack, tree, depth first search, binary tree 145. Binary Tree Postorder Traversal - Python Solution<pre><code>from typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef postorderTraversalRecursive(root: Optional[TreeNode]) -&gt; List[int]:\n    res = []\n\n    def dfs(node):\n        if not node:\n            return\n\n        dfs(node.left)\n        dfs(node.right)\n        res.append(node.val)  # &lt;--\n\n    dfs(root)\n\n    return res\n\n\n# Iterative\ndef postorderTraversalIterative(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    res = []\n    stack = [root]\n\n    while stack:\n        node = stack.pop()\n        res.append(node.val)\n\n        if node.left:\n            stack.append(node.left)\n        if node.right:\n            stack.append(node.right)\n\n    return res[::-1]\n\n\ntree = build([0, 1, 2, 3, 4, 5, 6])\nprint(tree)\n#     __0__\n#    /     \\\n#   1       2\n#  / \\     / \\\n# 3   4   5   6\nprint(postorderTraversalRecursive(tree))  # [3, 4, 1, 5, 6, 2, 0]\nprint(postorderTraversalIterative(tree))  # [3, 4, 1, 5, 6, 2, 0]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/tree_traversal/#102-binary-tree-level-order-traversal","title":"102. Binary Tree Level Order Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, breadth first search, binary tree 102. Binary Tree Level Order Traversal - Python Solution<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef levelOrder(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        level = []\n        size = len(q)\n\n        for _ in range(size):\n            cur = q.popleft()\n            level.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(level)\n\n    return res\n\n\ntree = build([3, 9, 20, None, None, 15, 7])\nprint(tree)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(levelOrder(tree))  # [[3], [9, 20], [15, 7]]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/tree_traversal/#107-binary-tree-level-order-traversal-ii","title":"107. Binary Tree Level Order Traversal II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, breadth first search, binary tree 107. Binary Tree Level Order Traversal II - Python Solution<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef levelOrderBottom(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    res = []\n    q = deque([root])\n\n    while q:\n        level = []\n        n = len(q)\n\n        for _ in range(n):\n            cur = q.popleft()\n            level.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(level)\n\n    return res[::-1]\n\n\ntree = build([3, 9, 20, None, None, 15, 7])\nprint(tree)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(levelOrderBottom(tree))  # [[15, 7], [9, 20], [3]]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/tree_traversal/#103-binary-tree-zigzag-level-order-traversal","title":"103. Binary Tree Zigzag Level Order Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, breadth first search, binary tree 103. Binary Tree Zigzag Level Order Traversal - Python Solution<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef zigzagLevelOrder(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        level = []\n        size = len(q)\n\n        for _ in range(size):\n            cur = q.popleft()\n            level.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(level if not len(res) % 2 else level[::-1])\n\n    return res\n\n\nif __name__ == \"__main__\":\n    tree = build([3, 9, 20, None, None, 15, 7])\n    print(tree)\n    #   3___\n    #  /    \\\n    # 9     _20\n    #      /   \\\n    #     15    7\n    assert zigzagLevelOrder(tree) == [[3], [20, 9], [15, 7]]\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/trie/","title":"Trie","text":""},{"location":"content/leetpattern/trie/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 208. Implement Trie (Prefix Tree) (Medium)</li> <li> 211. Design Add and Search Words Data Structure (Medium)</li> <li> 212. Word Search II (Hard)</li> </ul>"},{"location":"content/leetpattern/trie/#208-implement-trie-prefix-tree","title":"208. Implement Trie (Prefix Tree)","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, design, trie</p> </li> </ul>"},{"location":"content/leetpattern/trie/#trie_1","title":"Trie","text":"<ul> <li>A trie is a tree-like data structure whose nodes store the letters of an alphabet.</li> </ul> <pre><code>flowchart TD\nRoot(( ))\nRoot --- C1((\"C\"))\nRoot --- D((D))\nC1 --- A1((\"A\"))\nA1 --- T1((\"T\"))\nA1 --- R1((\"R\"))\nA1 --- N((N))\nRoot --- B1((B))\nB1 --- A2((A))\nA2 --- T2((T))\nA2 --- R2((R))</code></pre> 208. Implement Trie (Prefix Tree) - Python Solution<pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.endOfWord = None\n\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.endOfWord = True\n\n    def search(self, word: str) -&gt; bool:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return node.endOfWord\n\n    def startsWith(self, prefix: str) -&gt; bool:\n        node = self.root\n\n        for c in prefix:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return True\n\n\n# Your Trie object will be instantiated and called as such:\nobj = Trie()\nobj.insert(\"apple\")\nprint(obj.search(\"word\"))  # False\nprint(obj.startsWith(\"app\"))  # True\n</code></pre>"},{"location":"content/leetpattern/trie/#211-design-add-and-search-words-data-structure","title":"211. Design Add and Search Words Data Structure","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, depth first search, design, trie 211. Design Add and Search Words Data Structure - Python Solution<pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.word = False\n\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.word = True\n\n    def search(self, word: str) -&gt; bool:\n\n        def dfs(j, root):\n            node = root\n\n            for i in range(j, len(word)):\n                c = word[i]\n\n                if c == \".\":\n                    for child in node.children.values():\n                        if dfs(i + 1, child):\n                            return True\n                    return False\n                else:\n                    if c not in node.children:\n                        return False\n                    node = node.children[c]\n            return node.word\n\n        return dfs(0, self.root)\n\n\n# Your WordDictionary object will be instantiated and called as such:\nobj = WordDictionary()\nobj.addWord(\"word\")\nprint(obj.search(\"word\"))\nprint(obj.search(\"w.rd\"))\n</code></pre></p> </li> </ul>"},{"location":"content/leetpattern/trie/#212-word-search-ii","title":"212. Word Search II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, backtracking, trie, matrix 212. Word Search II - Python Solution<pre><code>from typing import List\n\nfrom template import TrieNode\n\n\n# Backtracking + Trie\ndef findWords(board: List[List[str]], words: List[str]) -&gt; List[str]:\n    root = TrieNode()\n    for word in words:\n        root.addWord(word)\n\n    m, n = len(board), len(board[0])\n    result, visit = set(), set()\n\n    def dfs(r, c, node, word):\n        if (\n            r &lt; 0\n            or r &gt;= m\n            or c &lt; 0\n            or c &gt;= n\n            or (r, c) in visit\n            or board[r][c] not in node.children\n        ):\n            return None\n\n        visit.add((r, c))\n\n        node = node.children[board[r][c]]\n        word += board[r][c]\n        if node.isWord:\n            result.add(word)\n\n        dfs(r - 1, c, node, word)\n        dfs(r + 1, c, node, word)\n        dfs(r, c - 1, node, word)\n        dfs(r, c + 1, node, word)\n\n        visit.remove((r, c))\n\n    for r in range(m):\n        for c in range(n):\n            dfs(r, c, root, \"\")\n\n    return list(result)\n\n\nboard = [\n    [\"o\", \"a\", \"a\", \"n\"],\n    [\"e\", \"t\", \"a\", \"e\"],\n    [\"i\", \"h\", \"k\", \"r\"],\n    [\"i\", \"f\", \"l\", \"v\"],\n]\nwords = [\"oath\", \"pea\", \"eat\", \"rain\"]\nprint(findWords(board, words))\n# ['eat', 'oath']\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/","title":"Neetcode 150","text":""},{"location":"content/neetcode150/1d_dynamic_programming/","title":"1D Dynamic Programming","text":""},{"location":"content/neetcode150/1d_dynamic_programming/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 70. Climbing Stairs (Easy)</li> <li> 746. Min Cost Climbing Stairs (Easy)</li> <li> 198. House Robber (Medium)</li> <li> 213. House Robber II (Medium)</li> <li> 5. Longest Palindromic Substring (Medium)</li> <li> 647. Palindromic Substrings (Medium)</li> <li> 91. Decode Ways (Medium)</li> <li> 322. Coin Change (Medium)</li> <li> 152. Maximum Product Subarray (Medium)</li> <li> 139. Word Break (Medium)</li> <li> 300. Longest Increasing Subsequence (Medium)</li> <li> 416. Partition Equal Subset Sum (Medium)</li> </ul>"},{"location":"content/neetcode150/1d_dynamic_programming/#70-climbing-stairs","title":"70. Climbing Stairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, dynamic programming, memoization</p> </li> <li>Return the number of distinct ways to reach the top of the stairs.</li> <li><code>dp[n]</code> stores the number of distinct ways to reach the <code>n-th</code> stair.</li> <li>Formula: <code>dp[n] = dp[n - 1] + dp[n - 2]</code>.</li> <li>Initialize <code>dp[0] = 0</code>, <code>dp[1] = 1</code>, and <code>dp[2] = 2</code>.</li> </ul> 70. Climbing Stairs - Python Solution<pre><code>from functools import cache\n\n\n# DP\ndef climbStairsDP(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    dp = [i for i in range(n + 1)]\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\n# DP (Optimized)\ndef climbStairsDPOptimized(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    first, second = 1, 2\n\n    for _ in range(3, n + 1):\n        first, second = second, first + second\n\n    return second\n\n\n# Recursion\ndef climbStairsRecursion(n: int) -&gt; int:\n    @cache\n    def dfs(i: int) -&gt; int:\n        if i &lt;= 1:\n            return 1\n        return dfs(i - 1) + dfs(i - 2)\n\n    return dfs(n)\n\n\n# Greedy\ndef climbStairsGreedy(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    p1, p2 = 1, 2\n\n    for _ in range(3, n + 1):\n        p1, p2 = p2, p1 + p2\n\n    return p2\n\n\nif __name__ == \"__main__\":\n    assert climbStairsDP(10) == 89\n    assert climbStairsDPOptimized(10) == 89\n    assert climbStairsRecursion(10) == 89\n    assert climbStairsGreedy(10) == 89\n</code></pre> 70. Climbing Stairs - C++ Solution<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint climbStairs(int n) {\n    if (n &lt;= 2) return n;\n    int f1 = 1, f2 = 2;\n    int res;\n\n    int i = 3;\n    while (i &lt;= n) {\n        res = f1 + f2;\n        f1 = f2;\n        f2 = res;\n        ++i;\n    }\n    return res;\n}\n\nint main() {\n    cout &lt;&lt; climbStairs(2) &lt;&lt; endl;  // 2\n    cout &lt;&lt; climbStairs(3) &lt;&lt; endl;  // 3\n    cout &lt;&lt; climbStairs(6) &lt;&lt; endl;  // 13\n    return 0;\n}\n</code></pre>"},{"location":"content/neetcode150/1d_dynamic_programming/#746-min-cost-climbing-stairs","title":"746. Min Cost Climbing Stairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li> <p>Return the minimum cost to reach the top of the stairs.</p> </li> <li> <p><code>dp[n]</code> stores the minimum cost to reach the <code>n-th</code> stair.</p> </li> <li>Formula: <code>dp[n] = cost[n] + min(dp[n - 1], dp[n - 2])</code>.</li> <li>Initialize <code>dp[0] = cost[0]</code> and <code>dp[1] = cost[1]</code>.</li> <li> <p>Return <code>min(dp[-1], dp[-2])</code>.</p> </li> <li> <p>Example: <code>cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</code></p> </li> </ul> n <code>cost[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n]</code> 0 1 - - 1 1 100 - 1 100 2 1 1 100 2 3 1 100 2 3 4 1 2 3 3 5 100 3 3 103 6 1 3 103 4 7 1 103 4 5 8 100 4 5 104 9 1 5 104 6 746. Min Cost Climbing Stairs - Python Solution<pre><code>from typing import List\n\n\ndef minCostClimbingStairs(cost: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(cost))]\n\n    dp[0], dp[1] = cost[0], cost[1]\n\n    for i in range(2, len(cost)):\n        dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]\n    print(dp)\n    return min(dp[-1], dp[-2])\n\n\ncost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]\nprint(minCostClimbingStairs(cost))  # 6\n</code></pre>"},{"location":"content/neetcode150/1d_dynamic_programming/#198-house-robber","title":"198. House Robber","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li> <p>Return the maximum amount of money that can be robbed from the houses. No two adjacent houses can be robbed.</p> </li> <li> <p><code>dp[n]</code> stores the maximum amount of money that can be robbed from the first <code>n</code> houses.</p> </li> <li>Formula: <code>dp[n] = max(dp[n - 1], dp[n - 2] + nums[n])</code>.<ul> <li>Skip: <code>dp[n]</code> \u2192 <code>dp[n - 1]</code></li> <li>Rob: <code>dp[n]</code> \u2192 <code>dp[n - 2] + nums[n]</code></li> </ul> </li> <li>Initialize <code>dp[0] = nums[0]</code> and <code>dp[1] = max(nums[0], nums[1])</code>.</li> <li>Return <code>dp[-1]</code>.</li> <li>Example: <code>nums = [2, 7, 9, 3, 1]</code></li> </ul> n <code>nums[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n-2] + nums[n]</code> <code>dp[n]</code> 0 2 - 2 - 2 1 7 - 7 - 7 2 9 2 7 11 11 3 3 7 11 10 11 4 1 11 11 12 12 198. House Robber - Python Solution<pre><code>from typing import List\n\n\n# DP (House Robber)\ndef rob1(nums: List[int]) -&gt; int:\n    if len(nums) &lt; 3:\n        return max(nums)\n\n    dp = [0 for _ in range(len(nums))]\n    dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n    for i in range(2, len(nums)):\n        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n    return dp[-1]\n\n\n# DP (House Robber) Optimized\ndef rob2(nums: List[int]) -&gt; int:\n    f0, f1 = 0, 0\n\n    for num in nums:\n        f0, f1 = f1, max(f1, f0 + num)\n\n    return f1\n\n\nnums = [2, 7, 9, 3, 1]\nprint(rob1(nums))  # 12\nprint(rob2(nums))  # 12\n</code></pre> 198. House Robber - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint rob(vector&lt;int&gt; &amp;nums) {\n    int prev = 0, cur = 0, temp = 0;\n\n    for (int num : nums) {\n        temp = cur;\n        cur = max(cur, prev + num);\n        prev = temp;\n    }\n    return cur;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {2, 7, 9, 3, 1};\n    cout &lt;&lt; rob(nums) &lt;&lt; endl;  // 12\n    return 0;\n}\n</code></pre>"},{"location":"content/neetcode150/1d_dynamic_programming/#213-house-robber-ii","title":"213. House Robber II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li>Return the maximum amount of money that can be robbed from the houses arranged in a circle.</li> <li>Circular \u2192 Linear: <code>nums[0]</code> and <code>nums[-1]</code> cannot be robbed together.</li> <li>Rob from <code>0</code> to <code>n - 2</code></li> </ul> n <code>nums[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n-2] + nums[n]</code> <code>dp[n]</code> 0 2 - 2 - 2 1 7 - 7 - 7 2 9 2 7 11 11 3 3 7 11 10 11 <ul> <li>Rob from <code>1</code> to <code>n - 1</code></li> </ul> n <code>nums[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n-2] + nums[n]</code> <code>dp[n]</code> 1 7 - - - 7 2 9 - 7 - 9 3 3 7 9 10 10 4 1 9 10 10 10 213. House Robber II - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef rob(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 3:\n        return max(nums)\n\n    def robLinear(nums: List[int]) -&gt; int:\n        dp = [0 for _ in range(len(nums))]\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n        return dp[-1]\n\n    # circle -&gt; linear\n    a = robLinear(nums[1:])  # 2nd house to the last house\n    b = robLinear(nums[:-1])  # 1st house to the 2nd last house\n\n    return max(a, b)\n\n\nnums = [2, 7, 9, 3, 1]\nprint(rob(nums))  # 11\n</code></pre> 213. House Robber II - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// DP\nint robDP(vector&lt;int&gt;&amp; nums) {\n    int n = nums.size();\n    if (n &lt;= 3) return *max_element(nums.begin(), nums.end());\n\n    vector&lt;int&gt; dp1(n, 0), dp2(n, 0);\n\n    dp1[0] = nums[0];\n    dp2[1] = max(nums[0], nums[1]);\n    for (int i = 2; i &lt; n - 1; i++) {\n        dp1[i] = max(dp1[i - 1], dp1[i - 2] + nums[i]);\n    }\n\n    dp2[1] = nums[1];\n    dp2[2] = max(nums[1], nums[2]);\n    for (int i = 3; i &lt; n; i++) {\n        dp1[i] = max(dp1[i - 1], dp1[i - 2] + nums[i]);\n    }\n\n    return max(dp1[n - 2], dp2[n - 1]);\n}\n\n// DP (Space Optimized)\nint robDPOptimized(vector&lt;int&gt;&amp; nums) {\n    int n = nums.size();\n    if (n &lt;= 3) return *max_element(nums.begin(), nums.end());\n\n    int f1 = nums[0];\n    int f2 = max(nums[0], nums[1]);\n    int res1;\n    for (int i = 2; i &lt; n - 1; i++) {\n        res1 = max(f2, f1 + nums[i]);\n        f1 = f2;\n        f2 = res1;\n    }\n\n    f1 = nums[1];\n    f2 = max(nums[1], nums[2]);\n    int res2;\n    for (int i = 3; i &lt; n; i++) {\n        res2 = max(f2, f1 + nums[i]);\n        f1 = f2;\n        f2 = res2;\n    }\n\n    return max(res1, res2);\n}\n\nint main() {\n    vector&lt;int&gt; nums = {2, 3, 2};\n    cout &lt;&lt; robDP(nums) &lt;&lt; endl;           // 3\n    cout &lt;&lt; robDPOptimized(nums) &lt;&lt; endl;  // 3\n\n    nums = {1, 2, 3, 1};\n    cout &lt;&lt; robDP(nums) &lt;&lt; endl;           // 4\n    cout &lt;&lt; robDPOptimized(nums) &lt;&lt; endl;  // 4\n\n    return 0;\n}\n</code></pre>"},{"location":"content/neetcode150/1d_dynamic_programming/#5-longest-palindromic-substring","title":"5. Longest Palindromic Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string, dynamic programming</p> </li> <li>Return the longest palindromic substring in <code>s</code>.</li> </ul> 5. Longest Palindromic Substring - Python Solution<pre><code># DP - Interval\ndef longestPalindromeDP(s: str) -&gt; str:\n    n = len(s)\n    if n &lt;= 1:\n        return s\n\n    start, maxLen = 0, 1\n\n    # Init\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for j in range(1, n):\n        for i in range(j):\n            if s[i] == s[j]:\n                if j - i &lt;= 2:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1]\n\n                if dp[i][j] and j - i + 1 &gt; maxLen:\n                    maxLen = j - i + 1\n                    start = i\n\n    return s[start : start + maxLen]\n\n\n# Expand Around Center\ndef longestPalindromeCenter(s: str) -&gt; str:\n    def expand_around_center(left, right):\n        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n\n    if len(s) &lt;= 1:\n        return s\n\n    start, end = 0, 0\n    for i in range(len(s)):\n        len1 = expand_around_center(i, i)  # odd\n        len2 = expand_around_center(i, i + 1)  # even\n\n        maxLen = max(len1, len2)\n        if maxLen &gt; end - start:\n            start = i - (maxLen - 1) // 2\n            end = i + maxLen // 2\n\n    return s[start : end + 1]\n\n\ns = \"babad\"\nprint(longestPalindromeDP(s))  # \"bab\"\nprint(longestPalindromeCenter(s))  # \"aba\"\n</code></pre>"},{"location":"content/neetcode150/1d_dynamic_programming/#647-palindromic-substrings","title":"647. Palindromic Substrings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string, dynamic programming</p> </li> <li>Return the number of palindromic substrings in <code>s</code>.</li> <li>Bottom-up DP table</li> </ul> dp a b b a e a 1 0 0 1 0 b 0 1 1 0 0 b 0 0 1 0 0 a 0 0 0 1 0 e 0 0 0 0 1 647. Palindromic Substrings - Python Solution<pre><code>def countSubstrings(s: str) -&gt; int:\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    res = 0\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i, n):\n            if s[i] == s[j]:\n                if j - i &lt;= 1:\n                    dp[i][j] = 1\n                    res += 1\n                elif dp[i + 1][j - 1]:\n                    dp[i][j] = 1\n                    res += 1\n\n    return res\n\n\nprint(countSubstrings(\"abbae\"))  # 7\n</code></pre>"},{"location":"content/neetcode150/1d_dynamic_programming/#91-decode-ways","title":"91. Decode Ways","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming 91. Decode Ways - Python Solution<pre><code># DP\ndef numDecodingsDP(s: str) -&gt; int:\n    if not s or s[0] == \"0\":\n        return 0\n\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for i in range(1, n + 1):\n        # Check single digit decode\n        if s[i - 1] != \"0\":\n            dp[i] += dp[i - 1]\n\n        # Check two digit decode\n        if i &gt; 1 and \"10\" &lt;= s[i - 2 : i] &lt;= \"26\":\n            dp[i] += dp[i - 2]\n\n    return dp[n]\n\n\n# DFS\ndef numDecodingsDFS(s: str) -&gt; int:\n    memo = {}\n\n    def dfs(i):\n        if i == len(s):\n            return 1\n\n        if s[i] == \"0\":\n            return 0\n\n        if i in memo:\n            return memo[i]\n\n        # Single digit decode\n        ways = dfs(i + 1)\n\n        # Two digits decode\n        if i + 1 &lt; len(s) and \"10\" &lt;= s[i : i + 2] &lt;= \"26\":\n            ways += dfs(i + 2)\n\n        memo[i] = ways\n\n        return ways\n\n    return dfs(0)\n\n\ns = \"226\"\nprint(numDecodingsDP(s))  # 3\nprint(numDecodingsDFS(s))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/1d_dynamic_programming/#322-coin-change","title":"322. Coin Change","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, breadth first search 322. Coin Change - Python Solution<pre><code>from typing import List\n\n\ndef coinChange(coins: List[int], amount: int) -&gt; int:\n    dp = [float(\"inf\") for _ in range(amount + 1)]\n\n    dp[0] = 0\n\n    for i in range(1, amount + 1):\n        for c in coins:\n            if i - c &gt;= 0:\n                dp[i] = min(dp[i], 1 + dp[i - c])\n\n    return dp[amount] if dp[amount] != float(\"inf\") else -1\n\n\ncoins = [1, 2, 5]\namount = 11\nprint(coinChange(coins, amount))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/1d_dynamic_programming/#152-maximum-product-subarray","title":"152. Maximum Product Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming 152. Maximum Product Subarray - Python Solution<pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxProduct(nums: List[int]) -&gt; int:\n    n = len(nums)\n    dp_max = [0 for _ in range(n)]\n    dp_min = [0 for _ in range(n)]\n\n    dp_max[0] = nums[0]\n    dp_min[0] = nums[0]\n    max_product = nums[0]\n\n    for i in range(1, n):\n        dp_max[i] = max(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n        dp_min[i] = min(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n\n        max_product = max(max_product, dp_max[i])\n\n    return max_product\n\n\nnums = [2, 3, -2, 4]\nprint(maxProduct(nums))  # 6\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/1d_dynamic_programming/#139-word-break","title":"139. Word Break","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, dynamic programming, trie, memoization 139. Word Break - Python Solution<pre><code>from typing import List\n\n\n# DP (Unbounded Knapsack)\ndef wordBreak(s: str, wordDict: List[str]) -&gt; bool:\n    n = len(s)\n    dp = [False for _ in range(n + 1)]\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for word in wordDict:\n            m = len(word)\n            if s[i - m : i] == word and dp[i - m]:\n                dp[i] = True\n    return dp[-1]\n\n\ns = \"leetcode\"\nwordDict = [\"leet\", \"code\"]\nprint(wordBreak(s, wordDict))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/1d_dynamic_programming/#300-longest-increasing-subsequence","title":"300. Longest Increasing Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, dynamic programming 300. Longest Increasing Subsequence - Python Solution<pre><code>from functools import cache\nfrom typing import List\n\n\n# DP - LIS\ndef lengthOfLISMemo(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return n\n\n    @cache\n    def dfs(i: int) -&gt; int:\n        res = 0\n        for j in range(i):\n            if nums[j] &lt; nums[i]:\n                res = max(res, dfs(j))\n        return res + 1\n\n    return max(dfs(i) for i in range(n))\n\n\n# DP - LIS\ndef lengthOfLISTable(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return n\n\n    dp = [1 for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i):\n            if nums[i] &gt; nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\n\nif __name__ == \"__main__\":\n    assert lengthOfLISMemo([10, 9, 2, 5, 3, 7, 101, 18]) == 4\n    assert lengthOfLISTable([10, 9, 2, 5, 3, 7, 101, 18]) == 4\n    assert lengthOfLISMemo([0, 1, 0, 3, 2, 3]) == 4\n    assert lengthOfLISTable([0, 1, 0, 3, 2, 3]) == 4\n    assert lengthOfLISMemo([7, 7, 7, 7]) == 1\n    assert lengthOfLISTable([7, 7, 7, 7]) == 1\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/1d_dynamic_programming/#416-partition-equal-subset-sum","title":"416. Partition Equal Subset Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming 416. Partition Equal Subset Sum - Python Solution<pre><code>from functools import cache\nfrom typing import List\n\nfrom template import knapsack01\n\n\n# Memoization\ndef canPartitionMemoization(nums: List[int]) -&gt; bool:\n    total = sum(nums)\n    n = len(nums)\n\n    if total % 2 == 1 or n &lt;= 1:\n        return False\n\n    @cache\n    def dfs(i, j):\n        if i &lt; 0:\n            return j == 0\n        return j &gt;= nums[i] and dfs(i - 1, j - nums[i]) or dfs(i - 1, j)\n\n    return dfs(n - 1, total // 2)\n\n\n# DP - Knapsack 01\ndef canPartitionTemplate(nums: List[int]) -&gt; bool:\n    total = sum(nums)\n\n    if total % 2 == 1 or len(nums) &lt; 2:\n        return False\n\n    target = total // 2\n\n    return knapsack01(nums, nums, target) == target\n\n\n# DP - Knapsack 01\ndef canPartition(nums: List[int]) -&gt; bool:\n    total = sum(nums)\n\n    if total % 2 == 1 or len(nums) &lt; 2:\n        return False\n\n    target = total // 2\n\n    dp = [0 for _ in range(target + 1)]\n\n    for i in range(len(nums)):\n        for j in range(target, nums[i] - 1, -1):\n            dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])\n\n    return dp[target] == target\n\n\nif __name__ == \"__main__\":\n    nums = [1, 5, 11, 5]\n    print(canPartitionTemplate(nums))  # True\n    print(canPartition(nums))  # True\n    print(canPartitionMemoization(nums))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/2d_dynamic_programming/","title":"2D Dynamic_Programming","text":""},{"location":"content/neetcode150/2d_dynamic_programming/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 62. Unique Paths (Medium)</li> <li> 1143. Longest Common Subsequence (Medium)</li> <li> 309. Best Time to Buy and Sell Stock with Cooldown (Medium)</li> <li> 518. Coin Change II (Medium)</li> <li> 494. Target Sum (Medium)</li> <li> 97. Interleaving String (Medium)</li> <li> 329. Longest Increasing Path in a Matrix (Hard)</li> <li> 115. Distinct Subsequences (Hard)</li> <li> 72. Edit Distance (Medium)</li> <li> 312. Burst Balloons (Hard)</li> <li> 10. Regular Expression Matching (Hard)</li> </ul>"},{"location":"content/neetcode150/2d_dynamic_programming/#62-unique-paths","title":"62. Unique Paths","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, combinatorics</p> </li> <li>Count the number of unique paths to reach the bottom-right corner of a <code>m x n</code> grid.</li> </ul> <p></p> 62. Unique Paths - Python Solution<pre><code># DP - 2D\ndef uniquePaths(m: int, n: int) -&gt; int:\n    if m == 1 or n == 1:\n        return 1\n\n    dp = [[1] * n for _ in range(m)]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]\n\n\nprint(uniquePaths(m=3, n=7))  # 28\n# [[1, 1, 1,  1,  1,  1,  1],\n#  [1, 2, 3,  4,  5,  6,  7],\n#  [1, 3, 6, 10, 15, 21, 28]]\n</code></pre> 62. Unique Paths - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint uniquePaths(int m, int n) {\n    vector dp(m, vector&lt;int&gt;(n, 1));\n\n    for (int i = 1; i &lt; m; i++) {\n        for (int j = 1; j &lt; n; j++) {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n\n    return dp[m - 1][n - 1];\n}\n\nint main() {\n    int m = 3, n = 7;\n    cout &lt;&lt; uniquePaths(m, n) &lt;&lt; endl;  // 28\n    return 0;\n}\n</code></pre>"},{"location":"content/neetcode150/2d_dynamic_programming/#1143-longest-common-subsequence","title":"1143. Longest Common Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming 1143. Longest Common Subsequence - Python Solution<pre><code>from functools import cache\n\n\n# DP - LCS\ndef longestCommonSubsequenceMemo(text1: str, text2: str) -&gt; int:\n    m, n = len(text1), len(text2)\n\n    @cache\n    def dfs(i: int, j: int) -&gt; int:\n        if i &lt; 0 or j &lt; 0:\n            return 0\n        if text1[i] == text2[j]:\n            return dfs(i - 1, j - 1) + 1\n        return max(dfs(i - 1, j), dfs(i, j - 1))\n\n    return dfs(m - 1, n - 1)\n\n\n# DP - LCS\ndef longestCommonSubsequenceTable(text1: str, text2: str) -&gt; int:\n    m, n = len(text1), len(text2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i - 1] == text2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    assert longestCommonSubsequenceMemo(\"abcde\", \"ace\") == 3\n    assert longestCommonSubsequenceTable(\"abcde\", \"ace\") == 3\n    assert longestCommonSubsequenceMemo(\"abc\", \"abc\") == 3\n    assert longestCommonSubsequenceTable(\"abc\", \"abc\") == 3\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/2d_dynamic_programming/#309-best-time-to-buy-and-sell-stock-with-cooldown","title":"309. Best Time to Buy and Sell Stock with Cooldown","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming 309. Best Time to Buy and Sell Stock with Cooldown - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef maxProfit(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 4 for _ in range(n)]\n\n    dp[0][0] = -prices[0]  # poessess\n    dp[0][1] = 0  # stay sold\n    dp[0][2] = 0  # sell\n    dp[0][3] = 0  # cooldown\n\n    for i in range(1, n):\n        dp[i][0] = max(\n            dp[i - 1][0],  # stay poessess\n            dp[i - 1][1] - prices[i],  # buy after stay sold\n            dp[i - 1][3] - prices[i],  # buy after cooldown\n        )\n        dp[i][1] = max(\n            dp[i - 1][1],  # stay sold\n            dp[i - 1][3],  # stay cooldown\n        )\n        dp[i][2] = dp[i - 1][0] + prices[i]\n        dp[i][3] = dp[i - 1][2]\n\n    return max(dp[-1])\n\n\nprices = [1, 2, 3, 0, 2]\nprint(maxProfit(prices))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/2d_dynamic_programming/#518-coin-change-ii","title":"518. Coin Change II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming 518. Coin Change II - Python Solution<pre><code>from typing import List\n\n\ndef change(amount: int, coins: List[int]) -&gt; int:\n    dp = [0 for _ in range(amount + 1)]\n    dp[0] = 1\n\n    for i in range(len(coins)):\n        for j in range(coins[i], amount + 1):\n            dp[j] += dp[j - coins[i]]\n\n    return dp[-1]\n\n\namount = 5\ncoins = [1, 2, 5]\nprint(change(amount, coins))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/2d_dynamic_programming/#494-target-sum","title":"494. Target Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, backtracking 494. Target Sum - Python Solution<pre><code>from typing import List\n\n\ndef findTargetSumWays(nums: List[int], target: int) -&gt; int:\n\n    totalSum = sum(nums)\n\n    if abs(target) &gt; totalSum:\n        return 0\n    if (target + totalSum) % 2 == 1:\n        return 0\n\n    targetSum = (target + totalSum) // 2\n    dp = [0] * (targetSum + 1)\n    dp[0] = 1\n\n    for i in range(len(nums)):\n        for j in range(targetSum, nums[i] - 1, -1):\n            dp[j] += dp[j - nums[i]]\n\n    return dp[targetSum]\n\n\nnums = [1, 1, 1, 1, 1]\ntarget = 3\nprint(findTargetSumWays(nums, target))  # 5\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/2d_dynamic_programming/#97-interleaving-string","title":"97. Interleaving String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming 97. Interleaving String - Python Solution<pre><code># DP - 2D\ndef isInterleaveDP(s1: str, s2: str, s3: str) -&gt; bool:\n    m, n, k = len(s1), len(s2), len(s3)\n\n    if m + n != k:\n        return False\n\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    for i in range(1, m + 1):\n        dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n\n    for j in range(1, n + 1):\n        dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (\n                dp[i][j - 1] and s2[j - 1] == s3[i + j - 1]\n            )\n\n    return dp[m][n]\n\n\n# DFS\ndef isInterleaveDFS(s1: str, s2: str, s3: str) -&gt; bool:\n    memo = {}\n\n    def dfs(i, j, k):\n        if i == len(s1) and j == len(s2) and k == len(s3):\n            return True\n\n        if (i, j) in memo:\n            return memo[(i, j)]\n\n        res = False\n\n        if i &lt; len(s1) and k &lt; len(s3) and s1[i] == s3[k]:\n            res |= dfs(i + 1, j, k + 1)\n\n        if j &lt; len(s2) and k &lt; len(s3) and s2[j] == s3[k]:\n            res |= dfs(i, j + 1, k + 1)\n\n        memo[(i, j)] = res\n\n        return res\n\n    return dfs(0, 0, 0)\n\n\ns1 = \"aabcc\"\ns2 = \"dbbca\"\ns3 = \"aadbbbaccc\"\nprint(isInterleaveDP(s1, s2, s3))  # False\nprint(isInterleaveDFS(s1, s2, s3))  # False\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/2d_dynamic_programming/#329-longest-increasing-path-in-a-matrix","title":"329. Longest Increasing Path in a Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, depth first search, breadth first search, graph, topological sort, memoization, matrix 329. Longest Increasing Path in a Matrix - Python Solution<pre><code>from collections import deque\nfrom functools import cache\nfrom typing import List\n\n\n# BFS - Topological Sort\ndef longestIncreasingPathBFS(matrix: List[List[int]]) -&gt; int:\n    if not matrix:\n        return 0\n\n    m, n = len(matrix), len(matrix[0])\n    dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    # Calculate indegrees and initialize queue in one pass\n    indegree = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            for dr, dc in dirs:\n                nr, nc = i + dr, j + dc\n                if (\n                    0 &lt;= nr &lt; m\n                    and 0 &lt;= nc &lt; n\n                    and matrix[nr][nc] &gt; matrix[i][j]\n                ):\n                    indegree[nr][nc] += 1\n\n    # Start with cells that have no smaller neighbors\n    queue = deque(\n        (i, j) for i in range(m) for j in range(n) if indegree[i][j] == 0\n    )\n\n    res = 0\n    while queue:\n        res += 1\n        for _ in range(len(queue)):\n            r, c = queue.popleft()\n            for dr, dc in dirs:\n                nr, nc = r + dr, c + dc\n                if (\n                    0 &lt;= nr &lt; m\n                    and 0 &lt;= nc &lt; n\n                    and matrix[nr][nc] &gt; matrix[r][c]\n                ):\n                    indegree[nr][nc] -= 1\n                    if indegree[nr][nc] == 0:\n                        queue.append((nr, nc))\n\n    return res\n\n\n# DP - 2D\ndef longestIncreasingPath(matrix: List[List[int]]) -&gt; int:\n    if not matrix:\n        return 0\n\n    m, n = len(matrix), len(matrix[0])\n    dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    @cache\n    def dfs(r, c):\n        path = 1\n        for dr, dc in dirs:\n            nr, nc = r + dr, c + dc\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and matrix[nr][nc] &gt; matrix[r][c]:\n                path = max(path, dfs(nr, nc) + 1)\n        return path\n\n    res = 0\n    for i in range(m):\n        for j in range(n):\n            res = max(res, dfs(i, j))\n\n    return res\n\n\nif __name__ == \"__main__\":\n    matrix = [[9, 9, 4], [6, 6, 8], [2, 1, 1]]\n    assert longestIncreasingPath(matrix) == 4\n    assert longestIncreasingPathBFS(matrix) == 4\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/2d_dynamic_programming/#115-distinct-subsequences","title":"115. Distinct Subsequences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming 115. Distinct Subsequences - Python Solution<pre><code>def numDistinct(s: str, t: str) -&gt; int:\n    m = len(s)\n    n = len(t)\n    dp = [[0] * (n + 1) for _ in range((m + 1))]\n\n    for i in range(m):\n        dp[i][0] = 1\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                # include and exclude s[i-1]\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]  # exclude s[i-1]\n\n    return dp[-1][-1]\n\n\ns = \"rabbbit\"\nt = \"rabbit\"\nprint(numDistinct(s, t))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/2d_dynamic_programming/#72-edit-distance","title":"72. Edit Distance","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming 72. Edit Distance - Python Solution<pre><code>from functools import cache\n\n\n# Recursive\ndef minDistanceDFS(word1: str, word2: str) -&gt; int:\n    n, m = len(word1), len(word2)\n\n    @cache\n    def dfs(i: int, j: int) -&gt; int:\n        if i &lt; 0:\n            return j + 1\n        if j &lt; 0:\n            return i + 1\n        if word1[i] == word2[j]:\n            return dfs(i - 1, j - 1)\n\n        return 1 + min(dfs(i - 1, j), dfs(i, j - 1), dfs(i - 1, j - 1))\n\n    return dfs(n - 1, m - 1)\n\n\n# Iterative\ndef minDistanceDP(word1: str, word2: str) -&gt; int:\n    m, n = len(word1), len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]  # no operation\n            else:\n                dp[i][j] = 1 + min(\n                    dp[i - 1][j],  # delete\n                    dp[i][j - 1],  # insert\n                    dp[i - 1][j - 1],  # replace\n                )\n    return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    word1 = \"horse\"\n    word2 = \"ros\"\n    print(minDistanceDFS(word1, word2))  # 3\n    print(minDistanceDP(word1, word2))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/2d_dynamic_programming/#312-burst-balloons","title":"312. Burst Balloons","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/neetcode150/2d_dynamic_programming/#10-regular-expression-matching","title":"10. Regular Expression Matching","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming, recursion</p> </li> </ul>"},{"location":"content/neetcode150/advanced_graphs/","title":"Advanced Graphs","text":""},{"location":"content/neetcode150/advanced_graphs/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 332. Reconstruct Itinerary (Hard)</li> <li> 1584. Min Cost to Connect All Points (Medium)</li> <li> 743. Network Delay Time (Medium)</li> <li> 778. Swim in Rising Water (Hard)</li> <li> 269. Alien Dictionary (Hard) \ud83d\udc51</li> <li> 787. Cheapest Flights Within K Stops (Medium)</li> </ul>"},{"location":"content/neetcode150/advanced_graphs/#332-reconstruct-itinerary","title":"332. Reconstruct Itinerary","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: depth first search, graph, eulerian circuit</p> </li> <li>Return the itinerary in order that visits every airport exactly once.</li> <li>The starting airport is <code>JFK</code>.</li> <li>If there are multiple valid itineraries, return the lexicographically smallest one.</li> <li>Eulerian path: A path that visits every edge exactly once.</li> </ul> <pre><code>graph TD\nJFK((JFK))\nSFO((SFO))\nATL((ATL))\nJFK --&gt; SFO\nSFO --&gt; ATL\nATL --&gt; JFK\nJFK --&gt; ATL\nATL --&gt; SFO</code></pre> 332. Reconstruct Itinerary - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hierholzer\ndef findItinerary1(tickets: List[List[str]]) -&gt; List[str]:\n    graph = defaultdict(list)\n    for u, v in sorted(tickets, reverse=True):\n        graph[u].append(v)\n\n    route = []\n\n    def dfs(node):\n        while graph[node]:\n            dest = graph[node].pop()\n            dfs(dest)\n        route.append(node)\n\n    dfs(\"JFK\")\n\n    return route[::-1]\n\n\n# Backtracking\ndef findItinerary2(tickets: List[List[str]]) -&gt; List[str]:\n    graph = defaultdict(list)\n    tickets.sort()\n    for u, v in tickets:\n        graph[u].append(v)\n\n    route = [\"JFK\"]\n\n    def backtraking(node):\n        if len(route) == len(tickets) + 1:\n            return True\n        if node not in graph:\n            return False\n\n        temp = list(graph[node])\n        for i, v in enumerate(temp):\n            graph[node].pop(i)\n            route.append(v)\n\n            if backtraking(v):\n                return True\n\n            graph[node].insert(i, v)\n            route.pop()\n\n        return False\n\n    backtraking(\"JFK\")\n\n    return route\n\n\ntickets = tickets = [\n    [\"JFK\", \"SFO\"],\n    [\"JFK\", \"ATL\"],\n    [\"SFO\", \"ATL\"],\n    [\"ATL\", \"JFK\"],\n    [\"ATL\", \"SFO\"],\n]\nprint(findItinerary1(tickets))\n# ['JFK', 'ATL', 'JFK', 'SFO', 'ATL', 'SFO']\nprint(findItinerary2(tickets))\n# ['JFK', 'ATL', 'JFK', 'SFO', 'ATL', 'SFO']\n</code></pre>"},{"location":"content/neetcode150/advanced_graphs/#1584-min-cost-to-connect-all-points","title":"1584. Min Cost to Connect All Points","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, union find, graph, minimum spanning tree</p> </li> <li>Tree: a connected acyclic graph</li> <li>Spanning Tree: a subgraph that is a tree and connects all the vertices together</li> <li>Minimum Spanning Tree (MST): a spanning tree with the minimum possible sum of edge weights</li> <li>Prim's Algorithm</li> <li>Data Structure: Heap</li> <li>Time Complexity: O(E * logV)</li> <li>Space Complexity: O(V + E)</li> <li>Kruskal's Algorithm</li> <li>Union Find</li> <li>Time Complexity: O(E * logV)</li> <li>Space Complexity: O(V + E)</li> </ul> 1584. Min Cost to Connect All Points - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minCostConnectPointsPrim(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    graph = defaultdict(list)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            dist = abs(x1 - x2) + abs(y1 - y2)\n            graph[i].append((dist, j))\n            graph[j].append((dist, i))\n\n    cost = 0\n    heap = [(0, 0)]  # (cost, node)\n    visited = set()\n\n    while heap:\n        d1, n1 = heapq.heappop(heap)\n        if n1 in visited:\n            continue\n        visited.add(n1)\n        cost += d1\n\n        for d2, n2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (d2, n2))\n\n    return cost\n\n\n# Kruskal\ndef minCostConnectPointsKruskal(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    par = {i: i for i in range(n)}\n    rank = {i: 0 for i in range(n)}\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 == p2:\n            return False\n\n        if rank[p1] &gt; rank[p2]:\n            par[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n        else:\n            par[p2] = p1\n            rank[p1] += 1\n\n        return True\n\n    heap = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            dist = abs(x1 - x2) + abs(y1 - y2)\n            heapq.heappush(heap, (dist, i, j))\n\n    cost = 0\n    while heap:\n        d, n1, n2 = heapq.heappop(heap)\n        if union(n1, n2):\n            cost += d\n\n    return cost\n\n\nif __name__ == \"__main__\":\n    points = [[0, 0], [2, 2], [3, 10], [5, 2], [7, 0]]\n    print(minCostConnectPointsPrim(points))  # 20\n    print(minCostConnectPointsKruskal(points))  # 20\n</code></pre>"},{"location":"content/neetcode150/advanced_graphs/#743-network-delay-time","title":"743. Network Delay Time","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, heap priority queue, shortest path</p> </li> <li>Return the minimum time taken to reach all nodes in a network.</li> </ul> <pre><code>graph LR\n1((1))\n2((2))\n3((3))\n4((4))\n2 --&gt; |1| 1\n2 --&gt; |1| 3\n3 --&gt; |1| 4</code></pre> <ul> <li>Shortest Path Problem: Find the shortest path between two vertices in a graph.</li> <li>Dijkstra's Algorithm<ul> <li>Shortest path algorithm</li> <li>Weighted graph (non-negative weights)</li> <li>Data Structure: Heap; Hash Set</li> <li>Time Complexity: O(E * logV)</li> <li>Space Complexity: O(V)</li> </ul> </li> </ul> 743. Network Delay Time - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Dijkstra - Set\ndef networkDelayTime1(times: List[List[int]], n: int, k: int) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    heap = [(0, k)]\n    visit = set()\n    t = 0\n\n    while heap:\n        w1, n1 = heapq.heappop(heap)\n        if n1 in visit:\n            continue\n\n        visit.add(n1)\n        t = w1\n\n        for n2, w2 in graph[n1]:\n            heapq.heappush(heap, (w1 + w2, n2))\n\n    return t if len(visit) == n else -1\n\n\n# Dijkstra - Dict\ndef networkDelayTime2(times: List[List[int]], n: int, k: int) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    heap = [(0, k)]\n    dist = defaultdict(int)\n\n    while heap:\n        w1, n1 = heapq.heappop(heap)\n        if n1 in dist:\n            continue\n\n        dist[n1] = w1\n\n        for n2, w2 in graph[n1]:\n            heapq.heappush(heap, (w1 + w2, n2))\n\n    return max(dist.values()) if len(dist) == n else -1\n\n\n# Bellman-Ford\ndef networkDelayTimeBF(times: List[List[int]], n: int, k: int) -&gt; int:\n    delay = {i: float(\"inf\") for i in range(1, n + 1)}\n    delay[k] = 0\n\n    for _ in range(n - 1):\n        for u, v, t in times:\n            delay[v] = min(delay[v], delay[u] + t)\n\n    max_delay = max(delay.values())\n    return max_delay if max_delay &lt; float(\"inf\") else -1\n\n\n# |--------------|-----------|--------|\n# | Approach     | Time      | Space  |\n# |--------------|-----------|--------|\n# | Dijkstra     | O(E*logV) | O(V+E) |\n# | Bellman-Ford | O(E*V)    | O(V)   |\n# |--------------|-----------|--------|\n\nif __name__ == \"__main__\":\n    times = [[2, 1, 1], [2, 3, 1], [3, 4, 1]]\n    n = 4\n    k = 2\n    print(networkDelayTime1(times, n, k))  # 2\n    print(networkDelayTime2(times, n, k))  # 2\n    print(networkDelayTimeBF(times, n, k))  # 2\n</code></pre>"},{"location":"content/neetcode150/advanced_graphs/#778-swim-in-rising-water","title":"778. Swim in Rising Water","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, depth first search, breadth first search, union find, heap priority queue, matrix</p> </li> <li>Return the minimum time when you can reach the target.</li> </ul> <p></p> 778. Swim in Rising Water - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra's\ndef swimInWater(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    visited = set()\n    minHeap = [(grid[0][0], 0, 0)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    visited.add((0, 0))\n\n    while minHeap:\n        time, r, c = heapq.heappop(minHeap)\n\n        if r == n - 1 and c == n - 1:\n            return time\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if nr in range(n) and nc in range(n) and (nr, nc) not in visited:\n                visited.add((nr, nc))\n                heapq.heappush(minHeap, (max(time, grid[nr][nc]), nr, nc))\n\n\ngrid = [\n    [0, 1, 2, 3, 4],\n    [24, 23, 22, 21, 5],\n    [12, 13, 14, 15, 16],\n    [11, 17, 18, 19, 20],\n    [10, 9, 8, 7, 6],\n]\nprint(swimInWater(grid))  # 16\n</code></pre>"},{"location":"content/neetcode150/advanced_graphs/#269-alien-dictionary","title":"269. Alien Dictionary","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, depth first search, breadth first search, graph, topological sort</p> </li> <li>Return the correct order of characters in the alien language.</li> </ul> 269. Alien Dictionary - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS - Kahn's algorithm (Topological Sort)\ndef alienOrderBFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    indegree = {c: 0 for word in words for c in word}\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                    indegree[w2[j]] += 1\n                break\n\n    q = deque([c for c in indegree if indegree[c] == 0])\n    result = []\n\n    while q:\n        char = q.popleft()\n        result.append(char)\n\n        for neighbor in graph[char]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n\n    return \"\".join(result) if len(result) == len(indegree) else \"\"\n\n\n# DFS - Topological Sort\ndef alienOrderDFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    visited = {}\n    result = []\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                break\n\n    def dfs(c):\n        if c in visited:\n            return visited[c]\n\n        visited[c] = False\n        for neighbor in graph[c]:\n            if not dfs(neighbor):\n                return False\n\n        visited[c] = True\n        result.append(c)\n        return True\n\n    for c in list(graph.keys()):\n        if not dfs(c):\n            return \"\"\n\n    return \"\".join(result[::-1])\n\n\nwords = [\"wrt\", \"wrf\", \"er\", \"ett\", \"rftt\"]\nprint(alienOrderBFS(words))  # wertf\nprint(alienOrderDFS(words))  # wertf\n</code></pre>"},{"location":"content/neetcode150/advanced_graphs/#787-cheapest-flights-within-k-stops","title":"787. Cheapest Flights Within K Stops","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming, depth first search, breadth first search, graph, heap priority queue, shortest path</p> </li> <li>Return the cheapest price from <code>src</code> to <code>dst</code> with at most <code>K</code> stops.</li> </ul> <pre><code>graph TD\n0((0))\n1((1))\n2((2))\n3((3))\n0 --&gt; |100| 1\n1 --&gt; |600| 3\n1 --&gt; |100| 2\n2 --&gt; |100| 0\n2 --&gt; |200| 3</code></pre> 787. Cheapest Flights Within K Stops - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Bellman-Ford\ndef findCheapestPriceBF(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    prices = [float(\"inf\") for _ in range(n)]\n    prices[src] = 0\n\n    for _ in range(k + 1):\n        temp = prices[:]\n        for u, v, w in flights:\n            temp[v] = min(temp[v], prices[u] + w)\n        prices = temp\n\n    return prices[dst] if prices[dst] != float(\"inf\") else -1\n\n\n# Dijkstra\ndef findCheapestPriceDijkstra(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in flights:\n        graph[u].append((v, w))\n\n    heap = [(0, src, 0)]  # (price, city, stops)\n    visited = defaultdict(int)  # {city: stops}\n\n    while heap:\n        price, city, stops = heapq.heappop(heap)\n\n        if city == dst:\n            return price\n\n        if stops &gt; k:\n            continue\n\n        if city in visited and visited[city] &lt;= stops:\n            continue\n\n        visited[city] = stops\n\n        for neighbor, cost in graph[city]:\n            heapq.heappush(heap, (price + cost, neighbor, stops + 1))\n\n    return -1\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |Bellman-Ford|    O(k * E)      |  O(n)   |\n# | Dijkstra   | O(E * log(V))    |  O(n)   |\n# |------------|------------------|---------|\n\n\nn = 4\nflights = [[0, 1, 100], [1, 2, 100], [2, 0, 100], [1, 3, 600], [2, 3, 200]]\nsrc = 0\ndst = 3\nk = 1\nprint(findCheapestPriceBF(n, flights, src, dst, k))  # 700\nprint(findCheapestPriceDijkstra(n, flights, src, dst, k))  # 700\n</code></pre>"},{"location":"content/neetcode150/arrays_hashing/","title":"Arrays Hashing","text":""},{"location":"content/neetcode150/arrays_hashing/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 217. Contains Duplicate (Easy)</li> <li> 242. Valid Anagram (Easy)</li> <li> 1. Two Sum (Easy)</li> <li> 49. Group Anagrams (Medium)</li> <li> 347. Top K Frequent Elements (Medium)</li> <li> 271. Encode and Decode Strings (Medium) \ud83d\udc51</li> <li> 238. Product of Array Except Self (Medium)</li> <li> 36. Valid Sudoku (Medium)</li> <li> 128. Longest Consecutive Sequence (Medium)</li> </ul>"},{"location":"content/neetcode150/arrays_hashing/#217-contains-duplicate","title":"217. Contains Duplicate","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, sorting</p> </li> <li>Return True if the array contains any duplicates, otherwise return False.</li> </ul> 217. Contains Duplicate - Python Solution<pre><code>from typing import List\n\n\n# Brute Force\ndef containsDuplicateBF(nums: List[int]) -&gt; bool:\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] == nums[j]:\n                return True\n\n    return False\n\n\n# Sort\ndef containsDuplicateSort(nums: List[int]) -&gt; bool:\n    nums.sort()\n\n    for i in range(1, len(nums)):\n        if nums[i] == nums[i - 1]:\n            return True\n\n    return False\n\n\n# Set\ndef containsDuplicateSet(nums: List[int]) -&gt; bool:\n    seen = set()\n\n    for i in nums:\n        if i in seen:\n            return True\n        seen.add(i)\n\n    return False\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# | Brute Force |    O(n^2)       |    O(1)      |\n# |     Sort    |    O(n log n)   |    O(1)      |\n# |     Set     |    O(n)         |    O(n)      |\n# |-------------|-----------------|--------------|\n\nprint(containsDuplicateBF([1, 2, 3, 1]))  # True\nprint(containsDuplicateSort([1, 2, 3, 1]))  # True\nprint(containsDuplicateSet([1, 2, 3, 1]))  # True\n</code></pre>"},{"location":"content/neetcode150/arrays_hashing/#242-valid-anagram","title":"242. Valid Anagram","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, string, sorting</p> </li> <li>Return true if an input string is an anagram of another string.</li> <li>An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once, e.g., <code>listen</code> is an anagram of <code>silent</code>.</li> </ul> 242. Valid Anagram - Python Solution<pre><code>from collections import Counter\n\n\n# Hashmap\ndef isAnagramHash(s: str, t: str) -&gt; bool:\n    \"\"\"Return True if t is an anagram of s, False otherwise.\"\"\"\n    if len(s) != len(t):\n        return False\n\n    count = dict()\n\n    for i in s:\n        if i in count:\n            count[i] += 1\n        else:\n            count[i] = 1\n\n    for j in t:\n        if j in count:\n            count[j] -= 1\n        else:\n            return False\n\n    for count in count.values():\n        if count != 0:\n            return False\n\n    return True\n\n\n# Array\ndef isAnagramArray(s: str, t: str) -&gt; bool:\n    if len(s) != len(t):\n        return False\n\n    count = [0 for _ in range(26)]\n\n    for i in s:\n        count[ord(i) - ord(\"a\")] += 1\n\n    for j in t:\n        count[ord(j) - ord(\"a\")] -= 1\n\n    for i in count:\n        if i != 0:\n            return False\n\n    return True\n\n\n# Counter\ndef isAnagramCounter(s: str, t: str) -&gt; bool:\n    return Counter(s) == Counter(t)\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |   Hashmap   |       O(n)      |     O(1)     |\n# |    Array    |       O(n)      |     O(1)     |\n# |   Counter   |       O(n)      |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\ns = \"anagram\"\nt = \"nagaram\"\nprint(isAnagramHash(s, t))  # True\nprint(isAnagramArray(s, t))  # True\nprint(isAnagramCounter(s, t))  # True\n</code></pre>"},{"location":"content/neetcode150/arrays_hashing/#1-two-sum","title":"1. Two Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table</p> </li> <li>Return the indices of the two numbers such that they add up to a specific target.</li> <li>Approach: Use a hashmap to store the indices of the numbers.</li> <li>Time Complexity: O(n)</li> <li>Space Complexity: O(n)</li> </ul> 1. Two Sum - Python Solution<pre><code>from typing import List\n\n\ndef twoSum(nums: List[int], target: int) -&gt; List[int]:\n    hashmap = {}  # val: idx\n\n    for idx, val in enumerate(nums):\n        if (target - val) in hashmap:\n            return [hashmap[target - val], idx]\n\n        hashmap[val] = idx\n\n\nif __name__ == \"__main__\":\n    nums = [2, 7, 11, 15]\n    target = 9\n    assert twoSum(nums, target) == [0, 1]\n</code></pre> 1. Two Sum - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;nums, int target) {\n    unordered_map&lt;int, int&gt; hashmap;\n\n    for (size_t i = 0; i &lt; nums.size(); i++) {\n        int complement = target - nums[i];\n\n        if (hashmap.find(complement) != hashmap.end()) {\n            return {hashmap[complement], (int)i};\n        }\n        hashmap[nums[i]] = (int)i;\n    }\n\n    return {-1, -1};\n}\n\nint main() {\n    vector&lt;int&gt; nums = {2, 7, 11, 15};\n    int target = 9;\n    vector&lt;int&gt; result = twoSum(nums, target);\n    cout &lt;&lt; result[0] &lt;&lt; \", \" &lt;&lt; result[1] &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/neetcode150/arrays_hashing/#49-group-anagrams","title":"49. Group Anagrams","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, sorting 49. Group Anagrams - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash - List\ndef groupAnagrams(strs: List[str]) -&gt; List[List[str]]:\n    result = defaultdict(list)\n\n    for s in strs:\n        count = [0] * 26\n        for i in s:\n            count[ord(i) - ord(\"a\")] += 1\n\n        result[tuple(count)].append(s)\n\n    return list(result.values())\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Hash     |     O(n * k)    |     O(n)     |\n# |-------------|-----------------|--------------|\n\n\nstrs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\nprint(groupAnagrams(strs))\n# [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/arrays_hashing/#347-top-k-frequent-elements","title":"347. Top K Frequent Elements","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, divide and conquer, sorting, heap priority queue, bucket sort, counting, quickselect 347. Top K Frequent Elements - Python Solution<pre><code>import heapq\nfrom collections import Counter\nfrom typing import List\n\n\n# Heap + Counter\ndef topKFrequent(nums: List[int], k: int) -&gt; List[int]:\n    minHeap = []\n\n    for val, freq in Counter(nums).items():\n        if len(minHeap) &lt; k:\n            heapq.heappush(minHeap, (freq, val))\n        else:\n            heapq.heappushpop(minHeap, (freq, val))\n\n    return [i for _, i in minHeap]\n\n\n# Counter (Most Common)\ndef topKFrequentCounter(nums: List[int], k: int) -&gt; List[int]:\n    commons = Counter(nums).most_common(k)\n    return [i for i, _ in commons]\n\n\nnums = [1, 1, 1, 2, 2, 3]\nk = 2\nprint(topKFrequent(nums, k))  # [1, 2]\nprint(topKFrequentCounter(nums, k))  # [1, 2]\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/arrays_hashing/#271-encode-and-decode-strings","title":"271. Encode and Decode Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, design 271. Encode and Decode Strings - Python Solution<pre><code>from typing import List\n\n\nclass Codec:\n    def encode(self, strs: List[str]) -&gt; str:\n        \"\"\"Encodes a list of strings to a single string.\"\"\"\n        encoded = \"\"\n\n        for s in strs:\n            encoded += str(len(s)) + \"#\" + s\n\n        return encoded\n\n    def decode(self, s: str) -&gt; List[str]:\n        \"\"\"Decodes a single string to a list of strings.\"\"\"\n        decoded = []\n        i = 0\n\n        while i &lt; len(s):\n            j = i\n            while s[j] != \"#\":\n                j += 1\n\n            strLen = int(s[i:j])\n            decoded.append(s[j + 1 : j + 1 + strLen])\n            i = j + 1 + strLen\n\n        return decoded\n\n\n# |-------------|-------------|--------------|\n# |   Approach  |    Time     |    Space     |\n# |-------------|-------------|--------------|\n# | Two pointers|    O(n)     |     O(n)     |\n# |-------------|-------------|--------------|\n\n\ncodec = Codec()\nencoded = codec.encode([\"hello\", \"world\"])\nprint(encoded)  # \"5#hello5#world\"\ndecoded = codec.decode(encoded)\nprint(decoded)  # [\"hello\", \"world\"]\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/arrays_hashing/#238-product-of-array-except-self","title":"238. Product of Array Except Self","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, prefix sum</p> </li> <li>Classic Prefix Sum problem</li> <li>Return an array <code>output</code> such that <code>output[i]</code> is equal to the product of all the elements of <code>nums</code> except <code>nums[i]</code>.</li> </ul> Approach Time Space Prefix O(n) O(n) Prefix (Optimized) O(n) O(1) 238. Product of Array Except Self - Python Solution<pre><code>from typing import List\n\n\n# Prefix\ndef productExceptSelf(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    prefix = [1 for _ in range(n)]\n    suffix = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        prefix[i] = nums[i - 1] * prefix[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        suffix[i] = nums[i + 1] * suffix[i + 1]\n\n    result = [i * j for i, j in zip(prefix, suffix)]\n\n    return result\n\n\n# Prefix (Optimized)\ndef productExceptSelfOptimized(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    result = [1 for _ in range(n)]\n\n    prefix = 1\n    for i in range(n):\n        result[i] = prefix\n        prefix *= nums[i]\n\n    suffix = 1\n    for i in range(n - 1, -1, -1):\n        result[i] *= suffix\n        suffix *= nums[i]\n\n    return result\n\n\nprint(productExceptSelf([1, 2, 3, 4]))\n# [24, 12, 8, 6]\nprint(productExceptSelfOptimized([1, 2, 3, 4]))\n# [24, 12, 8, 6]\n</code></pre> 238. Product of Array Except Self - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\n// Prefix Sum\nclass Solution\n{\npublic:\n    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt; &amp;nums)\n    {\n        int n = nums.size();\n        vector&lt;int&gt; prefix(n, 1);\n        vector&lt;int&gt; suffix(n, 1);\n        vector&lt;int&gt; res(n, 1);\n\n        for (int i = 1; i &lt; n; i++)\n        {\n            prefix[i] = prefix[i - 1] * nums[i - 1];\n        }\n\n        for (int i = n - 2; i &gt;= 0; i--)\n        {\n            suffix[i] = suffix[i + 1] * nums[i + 1];\n        }\n\n        for (int i = 0; i &lt; n; i++)\n        {\n            res[i] = prefix[i] * suffix[i];\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    vector&lt;int&gt; nums = {1, 2, 3, 4};\n    Solution obj;\n    vector&lt;int&gt; result = obj.productExceptSelf(nums);\n\n    for (int i = 0; i &lt; result.size(); i++)\n    {\n        cout &lt;&lt; result[i] &lt;&lt; \"\\n\";\n    }\n    cout &lt;&lt; endl;\n    // 24, 12, 8, 6\n    return 0;\n}\n</code></pre>"},{"location":"content/neetcode150/arrays_hashing/#36-valid-sudoku","title":"36. Valid Sudoku","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, matrix 36. Valid Sudoku - Python Solution<pre><code>from typing import List\n\n\n# Set\ndef isValidSudoku(board: List[List[str]]) -&gt; bool:\n    rows = [set() for _ in range(9)]\n    cols = [set() for _ in range(9)]\n    boxes = [set() for _ in range(9)]\n\n    for i in range(9):\n        for j in range(9):\n            if board[i][j] == \".\":\n                continue\n\n            if board[i][j] in rows[i]:\n                return False\n            rows[i].add(board[i][j])\n\n            if board[i][j] in cols[j]:\n                return False\n            cols[j].add(board[i][j])\n\n            box_index = (i // 3) * 3 + j // 3\n            if board[i][j] in boxes[box_index]:\n                return False\n            boxes[box_index].add(board[i][j])\n\n    return True\n\n\nboard = [\n    [\"5\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],\n    [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n    [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n    [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n    [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n    [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n    [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"],\n    [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n    [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"],\n]\nprint(isValidSudoku(board))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/arrays_hashing/#128-longest-consecutive-sequence","title":"128. Longest Consecutive Sequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, union find 128. Longest Consecutive Sequence - Python Solution<pre><code>from typing import List\n\n\n# Set\ndef longestConsecutiveSet(nums: List[int]) -&gt; int:\n    num_set = set(nums)  # O(n)\n    longest = 0\n\n    for n in nums:\n        if (n - 1) not in num_set:  # left boundary\n            length = 1\n\n            while (n + length) in num_set:\n                length += 1\n\n            longest = max(longest, length)\n\n    return longest\n\n\n# Union Find\ndef longestConsecutiveUF(nums: List[int]) -&gt; int:\n    if not nums:\n        return 0\n\n    par = {num: num for num in nums}\n    rank = {num: 1 for num in nums}\n\n    def find(num):\n        p = par[num]\n        while p != par[p]:\n            p = par[p]\n        return p\n\n    def union(num1, num2):\n        p1, p2 = find(num1), find(num2)\n        if p1 == p2:\n            return\n\n        if rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n            rank[p2] += rank[p1]\n        else:\n            par[p2] = p1\n            rank[p1] += rank[p2]\n\n    for num in nums:\n        if num - 1 in par:\n            union(num, num - 1)\n\n    return max(rank.values())\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |  Set       |  O(N)  |  O(N)   |\n# | Union Find |  O(N)  |  O(N)   |\n# |------------|--------|---------|\n\n\nnums = [100, 4, 200, 1, 3, 2]\nprint(longestConsecutiveSet(nums))  # 4\nprint(longestConsecutiveUF(nums))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/backtracking/","title":"Backtracking","text":""},{"location":"content/neetcode150/backtracking/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 78. Subsets (Medium)</li> <li> 39. Combination Sum (Medium)</li> <li> 40. Combination Sum II (Medium)</li> <li> 46. Permutations (Medium)</li> <li> 90. Subsets II (Medium)</li> <li> 79. Word Search (Medium)</li> <li> 131. Palindrome Partitioning (Medium)</li> <li> 17. Letter Combinations of a Phone Number (Medium)</li> <li> 51. N-Queens (Hard)</li> </ul>"},{"location":"content/neetcode150/backtracking/#78-subsets","title":"78. Subsets","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking, bit manipulation 78. Subsets - Python Solution<pre><code>from typing import List\n\n\n# Iterative Inclusion Backtracking\ndef subsets_iterative_inclusion(nums: List[int]) -&gt; List[List[int]]:\n    n = len(nums)\n    res, path = [], []\n\n    def dfs(i):\n        res.append(path.copy())\n\n        for j in range(i, n):\n            path.append(nums[j])\n            dfs(j + 1)\n            path.pop()\n\n    dfs(0)\n\n    return res\n\n\n# Binary Decision Backtracking\ndef subsets_binary_decision(nums: List[int]) -&gt; List[List[int]]:\n    n = len(nums)\n    res, path = [], []\n\n    def dfs(i):\n        if i == n:\n            res.append(path.copy())\n            return\n\n        # Exclude\n        dfs(i + 1)\n\n        # Include\n        path.append(nums[i])\n        dfs(i + 1)\n        path.pop()\n\n    dfs(0)\n\n    return res\n\n\nprint(subsets_iterative_inclusion([1, 2, 3]))\n# [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]\nprint(subsets_binary_decision([1, 2, 3]))\n# [[], [3], [2], [2, 3], [1], [1, 3], [1, 2], [1, 2, 3]]\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/backtracking/#39-combination-sum","title":"39. Combination Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking 39. Combination Sum - Python Solution<pre><code>from typing import List\n\n\ndef combinationSum(candidates: List[int], target: int) -&gt; List[List[int]]:\n    n = len(candidates)\n    res, path = [], []\n\n    def dfs(total, start):\n        if total &gt; target:\n            return\n        if total == target:\n            res.append(path.copy())\n            return\n\n        for i in range(start, n):\n            total += candidates[i]\n            path.append(candidates[i])\n            dfs(total, i)\n            total -= candidates[i]\n            path.pop()\n\n    dfs(0, 0)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(combinationSum([2, 3, 5], 8))\n    # [[2, 2, 2, 2], [2, 3, 3], [3, 5]]\n    print(combinationSum([2, 3, 6, 7], 7))\n    # [[2, 2, 3], [7]]\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/backtracking/#40-combination-sum-ii","title":"40. Combination Sum II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking 40. Combination Sum II - Python Solution<pre><code>from typing import List\n\n\ndef combinationSum2(candidates: List[int], target: int) -&gt; List[List[int]]:\n    result, path = [], []\n    candidates.sort()\n\n    def backtracking(total, start):\n        if total == target:\n            result.append(path[:])\n            return None\n\n        for i in range(start, len(candidates)):\n\n            if i &gt; start and candidates[i] == candidates[i - 1]:\n                continue\n\n            if total + candidates[i] &gt; target:\n                break\n\n            total += candidates[i]\n            path.append(candidates[i])\n            backtracking(total, i + 1)\n            total -= candidates[i]\n            path.pop()\n\n    backtracking(0, 0)\n\n    return result\n\n\nprint(combinationSum2([10, 1, 2, 7, 6, 1, 5], 8))\n# [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/backtracking/#46-permutations","title":"46. Permutations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking 46. Permutations - Python Solution<pre><code>from typing import List\n\n\n# Backtracking\ndef permute(nums: List[int]) -&gt; List[List[int]]:\n    n = len(nums)\n    path, res = [], []\n    used = [False for _ in range(n)]\n\n    def dfs(x: int):\n        if x == n:\n            res.append(path[:])\n            return\n\n        for i in range(n):\n            if used[i]:\n                continue\n            used[i] = True\n            path.append(nums[i])\n            dfs(x + 1)\n            path.pop()\n            used[i] = False\n\n    dfs(0)\n\n    return res\n\n\nprint(permute([1, 2, 3]))\n# [[1, 2, 3], [1, 3, 2], [2, 1, 3],\n#  [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/backtracking/#90-subsets-ii","title":"90. Subsets II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking, bit manipulation 90. Subsets II - Python Solution<pre><code>from typing import List\n\n\ndef subsetsWithDup(nums: List[int]) -&gt; List[List[int]]:\n    path, result = [], []\n    nums.sort()\n\n    def backtracking(startIndex):\n        if path not in result:\n            result.append(path[:])\n\n        for i in range(startIndex, len(nums)):\n            path.append(nums[i])\n            backtracking(i + 1)\n            path.pop()\n\n    backtracking(startIndex=0)\n\n    return result\n\n\nprint(subsetsWithDup([1, 2, 2]))\n# [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/backtracking/#79-word-search","title":"79. Word Search","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, backtracking, depth first search, matrix 79. Word Search - Python Solution<pre><code>from typing import List\n\n\ndef exist(board: List[List[str]], word: str) -&gt; bool:\n    m, n = len(board), len(board[0])\n    path = set()\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n\n    def dfs(r, c, i):\n        if i == len(word):\n            return True\n\n        if (\n            r &lt; 0\n            or r &gt;= m\n            or c &lt; 0\n            or c &gt;= n\n            or board[r][c] != word[i]\n            or (r, c) in path\n        ):\n            return False\n\n        path.add((r, c))\n\n        for dr, dc in dirs:\n            if dfs(r + dr, c + dc, i + 1):\n                return True\n\n        path.remove((r, c))\n        return False\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, 0):\n                return True\n\n    return False\n\n\nboard = [\n    [\"A\", \"B\", \"C\", \"E\"],\n    [\"S\", \"F\", \"C\", \"S\"],\n    [\"A\", \"D\", \"E\", \"E\"],\n]\nword = \"ABCCED\"\nprint(exist(board, word))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/backtracking/#131-palindrome-partitioning","title":"131. Palindrome Partitioning","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming, backtracking 131. Palindrome Partitioning - Python Solution<pre><code>from typing import List\n\n\n# Backtracking\ndef partition(s: str) -&gt; List[List[str]]:\n    n = len(s)\n    res, path = [], []\n\n    def dfs(start):\n        if start == n:\n            res.append(path.copy())\n            return\n\n        for end in range(start, n):\n            cur = s[start : end + 1]\n            if cur == cur[::-1]:\n                path.append(cur)\n                dfs(end + 1)\n                path.pop()\n\n    dfs(0)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(partition(\"aab\"))\n    # [['a', 'a', 'b'], ['aa', 'b']]\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/backtracking/#17-letter-combinations-of-a-phone-number","title":"17. Letter Combinations of a Phone Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, backtracking</p> </li> <li>Return all possible letter combinations that the number could represent.</li> </ul> <p></p> 17. Letter Combinations of a Phone Number - Python Solution<pre><code>from typing import List\n\n\n# Backtracking\ndef letterCombinations(digits: str) -&gt; List[str]:\n    letter_map = {\n        \"2\": \"abc\",\n        \"3\": \"def\",\n        \"4\": \"ghi\",\n        \"5\": \"jkl\",\n        \"6\": \"mno\",\n        \"7\": \"pqrs\",\n        \"8\": \"tuv\",\n        \"9\": \"wxyz\",\n    }\n\n    n = len(digits)\n    if n == 0:\n        return []\n\n    res = []\n\n    def dfs(idx, path):\n        if idx == n:\n            res.append(path)\n            return None\n\n        letters = letter_map[digits[idx]]\n\n        for i in range(len(letters)):\n            dfs(idx + 1, path + letters[i])\n\n    dfs(0, \"\")\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert letterCombinations(\"23\") == [\n        \"ad\",\n        \"ae\",\n        \"af\",\n        \"bd\",\n        \"be\",\n        \"bf\",\n        \"cd\",\n        \"ce\",\n        \"cf\",\n    ]\n</code></pre>"},{"location":"content/neetcode150/backtracking/#51-n-queens","title":"51. N-Queens","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, backtracking</p> </li> <li>Hard</li> <li>N-Queens</li> <li>N \u7687\u540e</li> </ul> 51. N-Queens - Python Solution<pre><code>from typing import List\n\n\n# Backtracking\ndef solveNQueens(n: int) -&gt; List[List[str]]:\n    res = []\n    board = [\".\" * n for _ in range(n)]\n\n    def dfs(row):\n        if row == n:\n            res.append(board[:])\n            return None\n        for col in range(n):\n            if is_valid(row, col, board):\n                board[row] = board[row][:col] + \"Q\" + board[row][col + 1 :]\n                dfs(row + 1)\n                board[row] = board[row][:col] + \".\" + board[row][col + 1 :]\n\n    def is_valid(row, col, chessboard):\n        for i in range(row):\n            if chessboard[i][col] == \"Q\":\n                return False\n\n        i, j = row - 1, col - 1\n        while i &gt;= 0 and j &gt;= 0:\n            if chessboard[i][j] == \"Q\":\n                return False\n            i -= 1\n            j -= 1\n\n        i, j = row - 1, col + 1\n        while i &gt;= 0 and j &lt; len(chessboard):\n            if chessboard[i][j] == \"Q\":\n                return False\n            i -= 1\n            j += 1\n\n        return True\n\n    dfs(0)\n\n    return [[\"\".join(row) for row in i] for i in res]\n\n\n# Backtracking\ndef solveNQueens2(n: int) -&gt; List[List[str]]:\n    res = []\n    queens = [0] * n\n    col = [False] * n\n    diag1 = [False] * (n * 2 - 1)\n    diag2 = [False] * (n * 2 - 1)\n\n    def dfs(r: int) -&gt; None:\n        if r == n:\n            res.append([\".\" * c + \"Q\" + \".\" * (n - 1 - c) for c in queens])\n            return\n\n        for c, ok in enumerate(col):\n            if not ok and not diag1[r + c] and not diag2[r - c]:\n                queens[r] = c\n                col[c] = diag1[r + c] = diag2[r - c] = True\n                dfs(r + 1)\n                col[c] = diag1[r + c] = diag2[r - c] = False\n\n    dfs(0)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(solveNQueens(4))\n    # [['.Q..', '...Q', 'Q...', '..Q.'],\n    #  ['..Q.', 'Q...', '...Q', '.Q..']]\n    print(solveNQueens(1))\n    # [['Q']]\n    print(solveNQueens2(4))\n    # [['.Q..', '...Q', 'Q...', '..Q.'],\n    #  ['..Q.', 'Q...', '...Q', '.Q..']]\n    print(solveNQueens2(1))\n    # [['Q']]\n</code></pre>"},{"location":"content/neetcode150/binary_search/","title":"Binary Search","text":""},{"location":"content/neetcode150/binary_search/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 704. Binary Search (Easy)</li> <li> 74. Search a 2D Matrix (Medium)</li> <li> 875. Koko Eating Bananas (Medium)</li> <li> 153. Find Minimum in Rotated Sorted Array (Medium)</li> <li> 33. Search in Rotated Sorted Array (Medium)</li> <li> 981. Time Based Key-Value Store (Medium)</li> <li> 4. Median of Two Sorted Arrays (Hard)</li> </ul>"},{"location":"content/neetcode150/binary_search/#704-binary-search","title":"704. Binary Search","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, binary search</p> </li> <li>Implement binary search algorithm.</li> </ul> 704. Binary Search - Python Solution<pre><code>from typing import List\n\n\n# Binary Search [left, right]\ndef search(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] &lt; target:\n            left = mid + 1\n        elif nums[mid] &gt; target:\n            right = mid - 1\n        else:\n            return mid\n\n    return -1\n\n\n# Binary Search [left, right)\ndef search_half_open(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums)\n\n    while left &lt; right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] &lt; target:\n            left = mid + 1\n        elif nums[mid] &gt; target:\n            right = mid\n        else:\n            return mid\n\n    return -1\n\n\n# Binary Search (left, right)\ndef search_open_interval(nums: List[int], target: int) -&gt; int:\n    left, right = -1, len(nums)\n\n    while left + 1 &lt; right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] &lt; target:\n            left = mid\n        elif nums[mid] &gt; target:\n            right = mid\n        else:\n            return mid\n\n    return -1\n\n\nif __name__ == \"__main__\":\n    nums = [-1, 0, 3, 5, 9, 12]\n    target = 9\n    assert search(nums, target) == 4\n    assert search_half_open(nums, target) == 4\n    assert search_open_interval(nums, target) == 4\n</code></pre>"},{"location":"content/neetcode150/binary_search/#74-search-a-2d-matrix","title":"74. Search a 2D Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, matrix 74. Search a 2D Matrix - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef searchMatrix(matrix: List[List[int]], target: int) -&gt; bool:\n    if not matrix or not matrix[0]:\n        return False\n\n    m, n = len(matrix), len(matrix[0])\n    left, right = 0, m * n - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        x = matrix[mid // n][mid % n]\n\n        if x &lt; target:\n            left = mid + 1\n        elif x &gt; target:\n            right = mid - 1\n        else:\n            return True\n\n    return False\n\n\nif __name__ == \"__main__\":\n    matrix = [[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]]\n    target = 3\n    print(searchMatrix(matrix, target))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/binary_search/#875-koko-eating-bananas","title":"875. Koko Eating Bananas","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> <li>Koko loves to eat bananas. She wants to eat all the bananas within <code>H</code> hours. Each pile has a number of bananas. The <code>i-th</code> pile has <code>piles[i]</code> bananas. Return the minimum integer <code>K</code> such that she can eat all the bananas within <code>H</code> hours.</li> </ul> 875. Koko Eating Bananas - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef minEatingSpeed(piles: List[int], h: int) -&gt; int:\n    def canEat(piles, k, h):\n        hours = 0\n        for pile in piles:\n            hours += (pile + k - 1) // k\n        return hours &lt;= h\n\n    left, right = 1, max(piles)\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if canEat(piles, mid, h):\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return left\n\n\npiles = [3, 6, 7, 11]\nh = 8\nprint(minEatingSpeed(piles, h))  # 4\n</code></pre>"},{"location":"content/neetcode150/binary_search/#153-find-minimum-in-rotated-sorted-array","title":"153. Find Minimum in Rotated Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search 153. Find Minimum in Rotated Sorted Array - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef findMin(nums: List[int]) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt; right:\n        mid = left + (right - left) // 2\n        if nums[mid] &gt; nums[right]:\n            left = mid + 1\n        else:\n            right = mid\n\n    return nums[right]\n\n\nnums = [4, 5, 6, 7, 0, 1, 2]\nprint(findMin(nums))  # 0\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/binary_search/#33-search-in-rotated-sorted-array","title":"33. Search in Rotated Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search 33. Search in Rotated Sorted Array - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef search(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] == target:\n            return mid\n\n        if nums[left] &lt;= nums[mid]:\n            if nums[left] &lt;= target &lt; nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if nums[mid] &lt; target &lt;= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n    return -1\n\n\nnums = [4, 5, 6, 7, 0, 1, 2]\ntarget = 0\nprint(search(nums, target))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/binary_search/#981-time-based-key-value-store","title":"981. Time Based Key-Value Store","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, binary search, design 981. Time Based Key-Value Store - Python Solution<pre><code>from collections import defaultdict\n\n\n# Binary Search\nclass TimeMap:\n\n    def __init__(self):\n        self.keys = defaultdict(list)\n        self.times = dict()\n\n    def set(self, key: str, value: str, timestamp: int) -&gt; None:\n        self.keys[key].append(timestamp)\n        self.times[timestamp] = value\n\n    def get(self, key: str, timestamp: int) -&gt; str:\n        tmp = self.keys[key]\n\n        left, right = 0, len(tmp) - 1\n        while left &lt;= right:\n            mid = left + (right - left) // 2\n            if tmp[mid] &gt; timestamp:\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        return self.times[tmp[right]] if right &gt;= 0 else \"\"\n\n\nobj = TimeMap()\nobj.set(\"foo\", \"bar\", 1)\nprint(obj.get(\"foo\", 1))  # bar\nprint(obj.get(\"foo\", 3))  # bar\nobj.set(\"foo\", \"bar2\", 4)\nprint(obj.get(\"foo\", 4))  # bar2\nprint(obj.get(\"foo\", 5))  # bar2\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/binary_search/#4-median-of-two-sorted-arrays","title":"4. Median of Two Sorted Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, divide and conquer 4. Median of Two Sorted Arrays - Python Solution<pre><code>from typing import List\n\n\n# Brute Force\ndef findMedianSortedArraysBF(nums1: List[int], nums2: List[int]) -&gt; float:\n    nums = sorted(nums1 + nums2)\n    n = len(nums)\n    if n % 2 == 0:\n        return (nums[n // 2 - 1] + nums[n // 2]) / 2\n    else:\n        return nums[n // 2]\n\n\n# Binary Search\ndef findMedianSortedArraysBS(nums1: List[int], nums2: List[int]) -&gt; float:\n    if len(nums1) &gt; len(nums2):\n        nums1, nums2 = nums2, nums1\n\n    m, n = len(nums1), len(nums2)\n    imin, imax, half_len = 0, m, (m + n + 1) // 2\n\n    while imin &lt;= imax:\n        i = (imin + imax) // 2\n        j = half_len - i\n\n        if i &lt; m and nums2[j - 1] &gt; nums1[i]:\n            imin = i + 1\n        elif i &gt; 0 and nums1[i - 1] &gt; nums2[j]:\n            imax = i - 1\n        else:\n            if i == 0:\n                max_of_left = nums2[j - 1]\n            elif j == 0:\n                max_of_left = nums1[i - 1]\n            else:\n                max_of_left = max(nums1[i - 1], nums2[j - 1])\n\n            if (m + n) % 2 == 1:\n                return max_of_left\n\n            if i == m:\n                min_of_right = nums2[j]\n            elif j == n:\n                min_of_right = nums1[i]\n            else:\n                min_of_right = min(nums1[i], nums2[j])\n\n            return (max_of_left + min_of_right) / 2\n\n\n# |--------------|-----------------|--------------|\n# | Approach     | Time            | Space        |\n# |--------------|-----------------|--------------|\n# | Brute Force  | O((n+m)log(n+m))| O(n+m)       |\n# | Binary Search| O(log(min(n,m)))| O(1)         |\n# |--------------|-----------------|--------------|\n\n\nnums1 = [1, 3]\nnums2 = [2]\nprint(findMedianSortedArraysBF(nums1, nums2))  # 2.0\nprint(findMedianSortedArraysBS(nums1, nums2))  # 2.0\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/bit_manipulation/","title":"Bit Manipulation","text":""},{"location":"content/neetcode150/bit_manipulation/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 136. Single Number (Easy)</li> <li> 191. Number of 1 Bits (Easy)</li> <li> 338. Counting Bits (Easy)</li> <li> 190. Reverse Bits (Easy)</li> <li> 268. Missing Number (Easy)</li> <li> 371. Sum of Two Integers (Medium)</li> <li> 7. Reverse Integer (Medium)</li> </ul>"},{"location":"content/neetcode150/bit_manipulation/#136-single-number","title":"136. Single Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, bit manipulation 136. Single Number - Python Solution<pre><code>from functools import reduce\nfrom operator import xor\nfrom typing import List\n\n\n# XOR\ndef singleNumber(nums: List[int]) -&gt; int:\n    res = 0\n    for num in nums:\n        res ^= num\n    return res\n\n\n# XOR\ndef singleNumberXOR(nums: List[int]) -&gt; int:\n    return reduce(xor, nums)\n\n\n# XOR\ndef singleNumberXORLambda(nums: List[int]) -&gt; int:\n    return reduce(lambda x, y: x ^ y, nums)\n\n\nnums = [4, 1, 2, 1, 2]\nprint(singleNumber(nums))  # 4\nprint(singleNumberXOR(nums))  # 4\nprint(singleNumberXORLambda(nums))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/bit_manipulation/#191-number-of-1-bits","title":"191. Number of 1 Bits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: divide and conquer, bit manipulation 191. Number of 1 Bits - Python Solution<pre><code># Bit Manipulation\ndef hammingWeight1(n: int) -&gt; int:\n    res = 0\n\n    while n != 0:\n        n = n &amp; (n - 1)  # Unset the rightmost 1-bit\n        res += 1\n\n    return res\n\n\ndef hammingWeight2(n: int) -&gt; int:\n    return bin(n).count(\"1\")\n\n\ndef hammingWeight3(n: int) -&gt; int:\n    def decimalToBinary(n: int) -&gt; str:\n        if n == 0:\n            return \"0\"\n\n        binary = \"\"\n        while n &gt; 0:\n            binary = str(n % 2) + binary\n            n //= 2\n\n        return binary\n\n    binary = decimalToBinary(n)\n\n    return binary.count(\"1\")\n\n\nn = 11\nprint(hammingWeight1(n))  # 3\nprint(hammingWeight2(n))  # 3\n\nn = 47\nprint(bin(n))\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/bit_manipulation/#338-counting-bits","title":"338. Counting Bits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: dynamic programming, bit manipulation 338. Counting Bits - Python Solution<pre><code>from typing import List\n\n\n# Bit Manipulation\ndef countBits(n: int) -&gt; List[int]:\n    bits = [0 for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        bits[i] = bits[i &gt;&gt; 1] + (i &amp; 1)\n\n    return bits\n\n\nn = 5\nprint(countBits(n))  # [0, 1, 1, 2, 1, 2]\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/bit_manipulation/#190-reverse-bits","title":"190. Reverse Bits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: divide and conquer, bit manipulation 190. Reverse Bits - Python Solution<pre><code># Bit Manipulation\ndef reverseBits(n: int) -&gt; int:\n    res = 0\n\n    for i in range(32):\n        res = (res &lt;&lt; 1) | (n &amp; 1)\n        n &gt;&gt;= 1\n\n    return res\n\n\nn = 0b00000010100101000001111010011100\nprint(reverseBits(n))  # 964176192\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/bit_manipulation/#268-missing-number","title":"268. Missing Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, math, binary search, bit manipulation, sorting 268. Missing Number - Python Solution<pre><code>from typing import List\n\n\n# Math\ndef missingNumberMath(nums: List[int]) -&gt; int:\n    n = len(nums)\n    return (n * (n + 1)) // 2 - sum(nums)\n\n\n# Bit Manipulation (XOR)\ndef missingNumberXOR(nums: List[int]) -&gt; int:\n    n = len(nums)\n\n    for i, num in enumerate(nums):\n        n ^= i ^ num\n\n    return n\n\n\nnums = [3, 0, 1]\nprint(missingNumberMath(nums))  # 2\nprint(missingNumberXOR(nums))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/bit_manipulation/#371-sum-of-two-integers","title":"371. Sum of Two Integers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, bit manipulation 371. Sum of Two Integers - Python Solution<pre><code># Bit Manipulation\ndef getSum(a: int, b: int) -&gt; int:\n    MASK = 0xFFFFFFFF\n    MAX_INT = 0x7FFFFFFF\n\n    while b != 0:\n        temp = (a ^ b) &amp; MASK\n        b = ((a &amp; b) &lt;&lt; 1) &amp; MASK\n        a = temp\n\n    return a if a &lt;= MAX_INT else ~(a ^ MASK)\n\n\nprint(getSum(1, 2))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/bit_manipulation/#7-reverse-integer","title":"7. Reverse Integer","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math 7. Reverse Integer - Python Solution<pre><code># Math\ndef reverse(x: int) -&gt; int:\n    INT_MAX = 2**31 - 1\n\n    sign = -1 if x &lt; 0 else 1\n    x = abs(x)\n    res = 0\n\n    while x != 0:\n        x, pop = divmod(x, 10)\n\n        if res &gt; (INT_MAX - pop) // 10:\n            return 0\n\n        res = res * 10 + pop\n\n    return res * sign\n\n\nprint(reverse(123))  # 321\nprint(reverse(-123))  # -321\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/graphs/","title":"Graphs","text":""},{"location":"content/neetcode150/graphs/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 200. Number of Islands (Medium)</li> <li> 695. Max Area of Island (Medium)</li> <li> 133. Clone Graph (Medium)</li> <li> 286. Walls and Gates (Medium) \ud83d\udc51</li> <li> 994. Rotting Oranges (Medium)</li> <li> 417. Pacific Atlantic Water Flow (Medium)</li> <li> 130. Surrounded Regions (Medium)</li> <li> 207. Course Schedule (Medium)</li> <li> 210. Course Schedule II (Medium)</li> <li> 261. Graph Valid Tree (Medium) \ud83d\udc51</li> <li> 323. Number of Connected Components in an Undirected Graph (Medium) \ud83d\udc51</li> <li> 684. Redundant Connection (Medium)</li> <li> 127. Word Ladder (Hard)</li> </ul>"},{"location":"content/neetcode150/graphs/#200-number-of-islands","title":"200. Number of Islands","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix</p> </li> <li>Count the number of islands in a 2D grid.</li> <li>Method 1: DFS</li> <li> <p>Method 2: BFS (use a queue to traverse the grid)</p> </li> <li> <p>How to keep track of visited cells?</p> <ol> <li>Mark the visited cell as <code>0</code> (or any other value) to avoid revisiting it.</li> <li>Use a set to store the visited cells.</li> </ol> </li> <li> <p>Steps:</p> <ol> <li>Init: variables</li> <li>DFS/BFS: starting from the cell with <code>1</code>, turn all the connected <code>1</code>s to <code>0</code>.</li> <li>Traverse the grid, and if the cell is <code>1</code>, increment the count and call DFS/BFS.</li> </ol> </li> </ul> <p></p> 200. Number of Islands - Python Solution<pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef numIslandsDFS(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    res = 0\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] != \"1\":\n            return\n\n        grid[r][c] = \"2\"\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                dfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Set\ndef numIslandsBFS1(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == \"0\"\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\" and (r, c) not in visited:\n                visited.add((r, c))\n                bfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = dr + row, dc + col\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] != \"1\"\n                ):\n                    continue\n                grid[nr][nc] = \"2\"\n                q.append((nr, nc))\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == \"1\":\n                grid[i][j] = \"2\"\n                bfs(i, j)\n                res += 1\n\n    return res\n\n\ngrid = [\n    [\"1\", \"1\", \"1\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"0\", \"0\", \"0\", \"0\", \"0\"],\n]\n\nprint(numIslandsDFS(deepcopy(grid)))  # 1\nprint(numIslandsBFS1(deepcopy(grid)))  # 1\nprint(numIslandsBFS2(deepcopy(grid)))  # 1\n</code></pre> 200. Number of Islands - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\nprivate:\n    void dfs(vector&lt;vector&lt;char&gt;&gt; &amp;grid, int r, int c)\n    {\n        int row = grid.size();\n        int col = grid[0].size();\n\n        if (r &lt; 0 || r &gt;= row || c &lt; 0 || c &gt;= col || grid[r][c] != '1')\n        {\n            return;\n        }\n        grid[r][c] = '0';\n\n        dfs(grid, r - 1, c);\n        dfs(grid, r + 1, c);\n        dfs(grid, r, c - 1);\n        dfs(grid, r, c + 1);\n    }\n\npublic:\n    int numIslands(vector&lt;vector&lt;char&gt;&gt; &amp;grid)\n    {\n        int m = grid.size(), n = grid[0].size();\n        int res = 0;\n        for (int i = 0; i &lt; m; i++)\n        {\n            for (int j = 0; j &lt; n; j++)\n            {\n                if (grid[i][j] == '1')\n                {\n                    res++;\n                    dfs(grid, i, j);\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    Solution s;\n    vector&lt;vector&lt;char&gt;&gt; grid = {\n        {'1', '1', '0', '0', '0'},\n        {'1', '1', '0', '0', '0'},\n        {'0', '0', '1', '0', '0'},\n        {'0', '0', '0', '1', '1'}};\n    cout &lt;&lt; s.numIslands(grid) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/neetcode150/graphs/#695-max-area-of-island","title":"695. Max Area of Island","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix 695. Max Area of Island - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef maxAreaOfIslandDFS(grid: List[List[int]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] == 0:\n            return 0\n\n        grid[r][c] = 0\n\n        return (\n            1 + dfs(r + 1, c) + dfs(r - 1, c) + dfs(r, c + 1) + dfs(r, c - 1)\n        )\n\n    res = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                res = max(res, dfs(i, j))\n    return res\n\n\n# BFS\ndef maxAreaOfIslandBFS1(grid: List[List[int]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        area = 0\n\n        while q:\n            row, col = q.popleft()\n            area += 1\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == 0\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n        return area\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1 and (r, c) not in visited:\n                visited.add((r, c))\n                res = max(res, bfs(r, c))\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        area = 0\n\n        while q:\n            row, col = q.popleft()\n            area += 1\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n\n                if nr &lt; 0 or nr &gt;= m or nc &lt; 0 or nc &gt;= n or grid[nr][nc] == 0:\n                    continue\n\n                q.append((nr, nc))\n                grid[nr][nc] = 0\n\n        return area\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                grid[r][c] = 0\n                res = max(res, bfs(r, c))\n\n    return res\n\n\ngrid = [\n    [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0],\n    [0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],\n]\nprint(maxAreaOfIslandDFS(grid))  # 6\nprint(maxAreaOfIslandBFS1(grid))  # 6\nprint(numIslandsBFS2(grid))  # 6\n</code></pre></p> </li> </ul> 695. Max Area of Island - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {\n        int m = grid.size(), n = grid[0].size();\n        int res = 0;\n\n        auto dfs = [&amp;](auto&amp;&amp; self, int r, int c) -&gt; int {\n            if (r &lt; 0 || r &gt;= m || c &lt; 0 || c &gt;= n || grid[r][c] != 1) {\n                return 0;\n            }\n            grid[r][c] = 0;\n\n            return 1 + self(self, r - 1, c) + self(self, r, c - 1) +\n                   self(self, r + 1, c) + self(self, r, c + 1);\n        };\n        for (int i = 0; i &lt; m; i++) {\n            for (int j = 0; j &lt; n; j++) {\n                if (grid[i][j] == 1) {\n                    int area = dfs(dfs, i, j);\n                    res = max(res, area);\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution s;\n    vector&lt;vector&lt;int&gt;&gt; grid = {{0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},\n                                {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},\n                                {0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},\n                                {0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0},\n                                {0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0},\n                                {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0},\n                                {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},\n                                {0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0}};\n    cout &lt;&lt; s.maxAreaOfIsland(grid) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/neetcode150/graphs/#133-clone-graph","title":"133. Clone Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, depth first search, breadth first search, graph 133. Clone Graph - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\n\nclass Node:\n    def __init__(self, val=0, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\n\n# 1. DFS\ndef cloneGraphDFS(node: Optional[\"Node\"]) -&gt; Optional[\"Node\"]:\n    if not node:\n        return None\n\n    cloned = {}  # {old: new}\n\n    def dfs(node):\n        if node in cloned:\n            return cloned[node]\n\n        new = Node(node.val)\n        cloned[node] = new\n\n        for neighbor in node.neighbors:\n            new.neighbors.append(dfs(neighbor))\n\n        return new\n\n    return dfs(node)\n\n\n# 2. BFS\ndef cloneGraphBFS(node: Optional[\"Node\"]) -&gt; Optional[\"Node\"]:\n    if not node:\n        return None\n\n    cloned = {node: Node(node.val)}\n    q = deque([node])\n\n    while q:\n        cur = q.popleft()\n\n        for neighbor in cur.neighbors:\n            if neighbor not in cloned:\n                cloned[neighbor] = Node(neighbor.val)\n                q.append(neighbor)\n\n            cloned[cur].neighbors.append(cloned[neighbor])\n\n    return cloned[node]\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/graphs/#286-walls-and-gates","title":"286. Walls and Gates","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, breadth first search, matrix 286. Walls and Gates - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# Multi-Source BFS\ndef wallsAndGates(rooms: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify rooms in-place instead.\n    \"\"\"\n    m, n = len(rooms), len(rooms[0])\n    visited = set()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def addRoom(r, c):\n        if (\n            0 &lt;= r &lt; m\n            and 0 &lt;= c &lt; n\n            and (r, c) not in visited\n            and rooms[r][c] != -1\n        ):\n            q.append((r, c))\n            visited.add((r, c))\n\n    q = deque()\n    for r in range(m):\n        for c in range(n):\n            if rooms[r][c] == 0:\n                q.append((r, c))\n                visited.add((r, c))\n\n    dist = 0\n\n    while q:\n        for _ in range(len(q)):\n            r, c = q.popleft()\n            rooms[r][c] = dist\n\n            for dr, dc in directions:\n                addRoom(r + dr, c + dc)\n        dist += 1\n\n\nif __name__ == \"__main__\":\n    rooms = [\n        [2147483647, -1, 0, 2147483647],\n        [2147483647, 2147483647, 2147483647, -1],\n        [2147483647, -1, 2147483647, -1],\n        [0, -1, 2147483647, 2147483647],\n    ]\n    wallsAndGates(rooms)\n    assert rooms == [\n        [3, -1, 0, 1],\n        [2, 2, 1, -1],\n        [1, -1, 2, -1],\n        [0, -1, 3, 4],\n    ]\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/graphs/#994-rotting-oranges","title":"994. Rotting Oranges","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, breadth first search, matrix</p> </li> <li>Return the minimum number of minutes that must elapse until no cell has a fresh orange.</li> <li>Hint: Multi-source BFS to count the level.</li> </ul> <p></p> 994. Rotting Oranges - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef orangesRotting(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    fresh = 0\n    q = deque()\n    dirs = [[1, 0], [0, 1], [0, -1], [-1, 0]]\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 2:\n                q.append([i, j])\n            elif grid[i][j] == 1:\n                fresh += 1\n    res = 0\n\n    while q and fresh &gt; 0:\n        size = len(q)\n        for _ in range(size):\n            r, c = q.popleft()\n            for dr, dc in dirs:\n                nr, nc = dr + r, dc + c\n                if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and grid[nr][nc] == 1:\n                    q.append([nr, nc])\n                    grid[nr][nc] = 2\n                    fresh -= 1\n        res += 1\n\n    return res if fresh == 0 else -1\n\n\ngrid = [[2, 1, 1], [1, 1, 0], [0, 1, 1]]\nassert orangesRotting(grid) == 4\n</code></pre>"},{"location":"content/neetcode150/graphs/#417-pacific-atlantic-water-flow","title":"417. Pacific Atlantic Water Flow","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, matrix 417. Pacific Atlantic Water Flow - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef pacificAtlanticDFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(r, c, visited, prev_height):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or heights[r][c] &lt; prev_height\n            or (r, c) in visited\n        ):\n            return None\n\n        visited.add((r, c))\n        height = heights[r][c]\n        for dr, dc in directions:\n            dfs(dr + r, dc + c, visited, height)\n\n    for c in range(n):\n        dfs(0, c, pac, heights[0][c])\n        dfs(m - 1, c, atl, heights[m - 1][c])\n\n    for r in range(m):\n        dfs(r, 0, pac, heights[r][0])\n        dfs(r, n - 1, atl, heights[r][n - 1])\n\n    return list(pac &amp; atl)\n\n\n# BFS\ndef pacificAtlanticBFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def bfs(r, c, visited):\n        q = deque([(r, c)])\n        visited.add((r, c))\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr in range(m)\n                    and nc in range(n)\n                    and heights[row][col] &lt;= heights[nr][nc]\n                    and (nr, nc) not in visited\n                ):\n                    q.append((nr, nc))\n                    visited.add((nr, nc))\n\n    for c in range(n):\n        bfs(0, c, pac)  # top\n        bfs(m - 1, c, atl)  # bottom\n\n    for r in range(m):\n        bfs(r, 0, pac)  # left\n        bfs(r, n - 1, atl)  # right\n\n    return list(pac &amp; atl)\n\n\nheights = [\n    [1, 2, 2, 3, 5],\n    [3, 2, 3, 4, 4],\n    [2, 4, 5, 3, 1],\n    [6, 7, 1, 4, 5],\n    [5, 1, 1, 2, 4],\n]\nprint(pacificAtlanticDFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\nprint(pacificAtlanticBFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/graphs/#130-surrounded-regions","title":"130. Surrounded Regions","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix 130. Surrounded Regions - Python Solution<pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef solveDFS(board: List[List[str]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n    if not board and not board[0]:\n        return None\n\n    m, n = len(board), len(board[0])\n\n    def capture(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or board[r][c] != \"O\":\n            return None\n\n        board[r][c] = \"T\"\n        capture(r + 1, c)\n        capture(r - 1, c)\n        capture(r, c + 1)\n        capture(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\" and (r in [0, m - 1] or c in [0, n - 1]):\n                capture(r, c)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\":\n                board[r][c] = \"X\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"T\":\n                board[r][c] = \"O\"\n\n\n# BFS\ndef solveBFS(board: List[List[str]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n    if not board and not board[0]:\n        return None\n\n    m, n = len(board), len(board[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def capture(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr = row + dr\n                nc = col + dc\n                if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and board[nr][nc] == \"O\":\n                    board[nr][nc] = \"T\"\n                    q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\" and (r in [0, m - 1] or c in [0, n - 1]):\n                board[r][c] = \"T\"\n                capture(r, c)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\":\n                board[r][c] = \"X\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"T\":\n                board[r][c] = \"O\"\n\n\nif __name__ == \"__main__\":\n    board = [\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"O\", \"O\", \"X\"],\n        [\"X\", \"X\", \"O\", \"X\"],\n        [\"X\", \"O\", \"X\", \"X\"],\n    ]\n\n    b = deepcopy(board)\n    solveDFS(b)\n    assert b == [\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"O\", \"X\", \"X\"],\n    ]\n\n    b = deepcopy(board)\n    solveBFS(b)\n    assert b == [\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"X\", \"X\", \"X\"],\n        [\"X\", \"O\", \"X\", \"X\"],\n    ]\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/graphs/#207-course-schedule","title":"207. Course Schedule","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort</p> </li> <li>Return true if it is possible to finish all courses, otherwise return false.</li> <li>Dependency relationships imply the topological sort algorithm.</li> <li>Cycle detection</li> <li>Topological Sort</li> <li>DAG (Directed Acyclic Graph)</li> <li>Time complexity: O(V+E)</li> <li>Space complexity: O(V+E)</li> <li>Prerequisites: Indegree (Look at the problem 1557. Minimum Number of Vertices to Reach All Nodes)<ul> <li>Indegree: Number of incoming edges to a vertex</li> </ul> </li> <li>Applications: task scheduling, course scheduling, build systems, dependency resolution, compiler optimization, etc.</li> </ul> <p></p> <p></p> <p>Course to prerequisites mapping</p> <pre><code>flowchart LR\n    0((0)) --&gt; 1((1))\n    0((0)) --&gt; 2((2))\n    1((1)) --&gt; 3((3))\n    3((3)) --&gt; 4((4))\n    1((1)) --&gt; 4((4))</code></pre> <p>Prerequisites to course mapping</p> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    2((2)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))\n    4((4)) --&gt; 3((3))\n    4((4)) --&gt; 1((1))</code></pre> course 0 0 1 1 3 prerequisite 1 2 3 4 4 index 0 1 2 3 4 in-degree 0 0 0 0 0 <p>Initialize</p> <ul> <li>graph</li> </ul> prerequisite 1 2 3 4 course <code>[0]</code> <code>[0]</code> <code>[1]</code> <code>[1, 3]</code> <ul> <li>in-degree</li> </ul> 0 1 2 3 4 in-degree 2 2 0 1 0 <ul> <li>queue: <code>[2, 4]</code></li> <li>pop <code>2</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))\n    4((4)) --&gt; 3((3))\n    4((4)) --&gt; 1((1))</code></pre> 0 1 2 3 4 in-degree 1 2 0 1 0 <ul> <li>queue: <code>[4]</code></li> <li>pop <code>4</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))</code></pre> 0 1 2 3 4 in-degree 1 1 0 0 0 <ul> <li>queue: <code>[3]</code></li> <li>pop <code>3</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))</code></pre> 0 1 2 3 4 in-degree 1 0 0 0 0 <ul> <li>queue: <code>[1]</code></li> <li>pop <code>1</code> from the queue</li> </ul> <pre><code>flowchart LR\n    0((0))</code></pre> 0 1 2 3 4 in-degree 0 0 0 0 0 <ul> <li>queue: <code>[0]</code></li> <li>pop <code>0</code> from the queue</li> <li>All courses are taken. Return <code>True</code>.</li> </ul> 207. Course Schedule - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS (Kahn's Algorithm)\ndef canFinishBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    count = 0\n\n    while q:\n        crs = q.popleft()\n        count += 1\n\n        for nxt in graph[crs]:\n            indegree[nxt] -= 1\n\n            if indegree[nxt] == 0:\n                q.append(nxt)\n\n    return count == numCourses\n\n\n# DFS + Set\ndef canFinishDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for crs, pre in prerequisites:\n        graph[crs].append(pre)\n\n    visiting = set()\n\n    def dfs(crs):\n        if crs in visiting:  # cycle detected\n            return False\n        if graph[crs] == []:\n            return True\n\n        visiting.add(crs)\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        visiting.remove(crs)\n        graph[crs] = []\n\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\n# DFS + List\ndef canFinishDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for pre, crs in prerequisites:\n        graph[crs].append(pre)\n\n    # 0: init, 1: visiting, 2: visited\n    status = [0] * numCourses\n\n    def dfs(crs):\n        if status[crs] == 1:  # cycle detected\n            return False\n        if status[crs] == 2:\n            return True\n\n        status[crs] = 1\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        status[crs] = 2\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(canFinishBFS(5, prerequisites))  # True\nprint(canFinishDFS1(5, prerequisites))  # True\nprint(canFinishDFS2(5, prerequisites))  # True\n</code></pre> 207. Course Schedule - C++ Solution<pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    // BFS\n    bool canFinishBFS(int numCourses, vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        vector&lt;int&gt; indegree(numCourses, 0);\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n            indegree[pre[0]]++;\n        }\n\n        queue&lt;int&gt; q;\n        for (int i = 0; i &lt; numCourses; i++) {\n            if (indegree[i] == 0) {\n                q.push(i);\n            }\n        }\n\n        int cnt = 0;\n        while (!q.empty()) {\n            int cur = q.front();\n            q.pop();\n            cnt++;\n\n            for (int nxt : graph[cur]) {\n                indegree[nxt]--;\n                if (indegree[nxt] == 0) {\n                    q.push(nxt);\n                }\n            }\n        }\n        return cnt == numCourses;\n    }\n\n    // DFS\n    bool canFinishDFS(int numCourses, vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n        }\n        // 0: not visited, 1: visiting, 2: visited\n        vector&lt;int&gt; state(numCourses, 0);\n\n        function&lt;bool(int)&gt; dfs = [&amp;](int pre) -&gt; bool {\n            state[pre] = 1;  // visiting\n            for (int crs : graph[pre]) {\n                if (state[crs] == 1 || (state[crs] == 0 &amp;&amp; dfs(crs))) {\n                    return true;\n                }\n            }\n            state[pre] = 2;  // visited\n            return false;\n        };\n\n        for (int i = 0; i &lt; numCourses; i++) {\n            if (state[i] == 0 &amp;&amp; dfs(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution sol;\n    vector&lt;vector&lt;int&gt;&gt; prerequisites = {{1, 0}, {2, 1}, {3, 2}, {4, 3},\n                                         {5, 4}, {6, 5}, {7, 6}, {8, 7},\n                                         {9, 8}, {10, 9}};\n    int numCourses = 11;\n    cout &lt;&lt; sol.canFinishBFS(numCourses, prerequisites) &lt;&lt; endl;\n    cout &lt;&lt; sol.canFinishDFS(numCourses, prerequisites) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/neetcode150/graphs/#210-course-schedule-ii","title":"210. Course Schedule II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort</p> </li> <li>Return the ordering of courses you should take to finish all courses. If there are multiple valid answers, return any of them.</li> </ul> <p></p> 210. Course Schedule II - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# 1. BFS - Kahn's Algorithm\ndef findOrderBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    order = []\n\n    while q:\n        pre = q.popleft()\n        order.append(pre)\n\n        for crs in graph[pre]:\n            indegree[crs] -= 1\n            if indegree[crs] == 0:\n                q.append(crs)\n\n    return order if len(order) == numCourses else []\n\n\n# 2. DFS + Set\ndef findOrderDFS1(\n    numCourses: int, prerequisites: List[List[int]]\n) -&gt; List[int]:\n    adj = defaultdict(list)\n    for crs, pre in prerequisites:\n        adj[crs].append(pre)\n\n    visit, cycle = set(), set()\n    order = []\n\n    def dfs(crs):\n        if crs in cycle:\n            return False\n        if crs in visit:\n            return True\n\n        cycle.add(crs)\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        cycle.remove(crs)\n        visit.add(crs)\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order\n\n\n# 3. DFS + List\ndef findOrderDFS2(\n    numCourses: int, prerequisites: List[List[int]]\n) -&gt; List[int]:\n    adj = defaultdict(list)\n    for pre, crs in prerequisites:\n        adj[crs].append(pre)\n\n    # 0: not visited, 1: visiting, 2: visited\n    state = [0] * numCourses\n    order = []\n\n    def dfs(crs):\n        if state[crs] == 1:\n            return False\n        if state[crs] == 2:\n            return True\n\n        state[crs] = 1\n\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        state[crs] = 2\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order[::-1]\n\n\nnumCourses = 5\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(findOrderBFS(numCourses, prerequisites))  # [2, 4, 3, 1, 0]\nprint(findOrderDFS1(numCourses, prerequisites))  # [4, 3, 1, 2, 0]\nprint(findOrderDFS2(numCourses, prerequisites))  # [4, 3, 2, 1, 0]\n</code></pre> 210. Course Schedule II - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    // BFS\n    vector&lt;int&gt; findOrderBFS(int numCourses,\n                             vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        vector&lt;int&gt; indegree(numCourses, 0);\n\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n            indegree[pre[0]]++;\n        }\n\n        queue&lt;int&gt; q;\n        for (int i = 0; i &lt; numCourses; i++)\n            if (indegree[i] == 0) q.push(i);\n\n        vector&lt;int&gt; order;\n\n        while (!q.empty()) {\n            int cur = q.front();\n            q.pop();\n            order.push_back(cur);\n\n            for (int nxt : graph[cur]) {\n                indegree[nxt]--;\n                if (indegree[nxt] == 0) q.push(nxt);\n            }\n        }\n\n        return (int)order.size() == numCourses ? order : vector&lt;int&gt;{};\n    }\n};\n\nint main() {\n    Solution obj;\n    vector&lt;vector&lt;int&gt;&gt; prerequisites{{1, 0}, {2, 0}, {3, 1}, {3, 2}};\n    vector&lt;int&gt; res = obj.findOrderBFS(4, prerequisites);\n    for (size_t i = 0; i &lt; res.size(); i++) cout &lt;&lt; res[i] &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"content/neetcode150/graphs/#261-graph-valid-tree","title":"261. Graph Valid Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph 261. Graph Valid Tree - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Graph\ndef validTree(n: int, edges: List[List[int]]) -&gt; bool:\n    if n == 0:\n        return False\n    if len(edges) != n - 1:\n        return False\n\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = set()\n\n    def dfs(node, parent):\n        if node in visited:\n            return False\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor != parent and not dfs(neighbor, node):\n                return False\n        return True\n\n    return dfs(0, -1) and len(visited) == n\n\n\nprint(validTree(5, [[0, 1], [0, 2], [0, 3], [1, 4]]))  # True\nprint(validTree(5, [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]))  # False\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/graphs/#323-number-of-connected-components-in-an-undirected-graph","title":"323. Number of Connected Components in an Undirected Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph 323. Number of Connected Components in an Undirected Graph - Python Solution<pre><code>from typing import List\n\n\n# Union Find\ndef countComponents(n: int, edges: List[List[int]]) -&gt; int:\n    uf = UnionFind(n)\n    count = n\n\n    for u, v in edges:\n        count -= uf.union(u, v)\n\n    return count\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(n)}\n        self.rank = {i: 1 for i in range(n)}\n\n    def find(self, n):\n        p = self.par[n]\n        while self.par[p] != p:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return 0\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.par[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.par[p1] = p2\n        else:\n            self.par[p2] = p1\n            self.rank[p1] += 1\n\n        return 1\n\n\nprint(countComponents(5, [[0, 1], [1, 2], [3, 4]]))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/graphs/#684-redundant-connection","title":"684. Redundant Connection","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph 684. Redundant Connection - Python Solution<pre><code>from typing import List\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(1, n + 1)}\n        self.rank = {i: 1 for i in range(1, n + 1)}\n\n    def find(self, n):\n        p = self.par[n]\n        while self.par[p] != p:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return False\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.par[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.par[p1] = p2\n        else:\n            self.par[p2] = p1\n            self.rank[p1] += 1\n\n        return True\n\n\n# Union Find\ndef findRedundantConnectionUF(edges: List[List[int]]) -&gt; List[int]:\n    n = len(edges)\n    uf = UnionFind(n)\n\n    for u, v in edges:\n        if not uf.union(u, v):\n            return (u, v)\n\n\n# DFS\ndef findRedundantConnectionDFS(edges: List[List[int]]) -&gt; List[int]:\n    graph, cycle = {}, {}\n    for a, b in edges:\n        graph.setdefault(a, []).append(b)\n        graph.setdefault(b, []).append(a)\n\n    def dfs(node, parent):\n        if node in cycle:\n            for k in list(cycle.keys()):\n                if k == node:\n                    return True\n                del cycle[k]\n\n        cycle[node] = None\n        for child in graph[node]:\n            if child != parent and dfs(child, node):\n                return True\n        del cycle[node]\n        return False\n\n    dfs(edges[0][0], -1)\n    for a, b in edges[::-1]:\n        if a in cycle and b in cycle:\n            return (a, b)\n\n\nedges = [[1, 2], [1, 3], [2, 3]]\nprint(findRedundantConnectionUF(edges))  # (2, 3)\nprint(findRedundantConnectionDFS(edges))  # (2, 3)\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/graphs/#127-word-ladder","title":"127. Word Ladder","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, breadth first search</p> </li> <li>The most classic BFS problem.</li> <li>Return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.</li> <li>Approach: BFS</li> <li>Time Complexity: O(n * m^2)</li> <li>Space Complexity: O(n * m)</li> </ul> 127. Word Ladder - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef ladderLength(beginWord: str, endWord: str, wordList: List[str]) -&gt; int:\n    if endWord not in wordList:\n        return 0\n\n    n = len(beginWord)\n    graph = defaultdict(list)  # pattern: words\n    wordList.append(beginWord)\n\n    for word in wordList:\n        for i in range(n):\n            pattern = word[:i] + \"*\" + word[i + 1 :]\n            graph[pattern].append(word)\n\n    visited = set([beginWord])\n    q = deque([beginWord])\n    res = 1\n\n    while q:\n        size = len(q)\n        for _ in range(size):\n            word = q.popleft()\n            if word == endWord:\n                return res\n\n            for i in range(n):\n                pattern = word[:i] + \"*\" + word[i + 1 :]\n                for neighbor in graph[pattern]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        q.append(neighbor)\n        res += 1\n\n    return 0\n\n\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]\nprint(ladderLength(beginWord, endWord, wordList))  # 5\n</code></pre>"},{"location":"content/neetcode150/greedy/","title":"Greedy","text":""},{"location":"content/neetcode150/greedy/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 53. Maximum Subarray (Medium)</li> <li> 55. Jump Game (Medium)</li> <li> 45. Jump Game II (Medium)</li> <li> 134. Gas Station (Medium)</li> <li> 846. Hand of Straights (Medium)</li> <li> 1899. Merge Triplets to Form Target Triplet (Medium)</li> <li> 763. Partition Labels (Medium)</li> <li> 678. Valid Parenthesis String (Medium)</li> </ul>"},{"location":"content/neetcode150/greedy/#53-maximum-subarray","title":"53. Maximum Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, divide and conquer, dynamic programming 53. Maximum Subarray - Python Solution<pre><code>from typing import List\n\n\n# DP Kadane\ndef maxSubArrayDP(nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n\n    dp[0] = nums[0]\n    maxSum = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(\n            dp[i - 1] + nums[i],  # continue the previous subarray\n            nums[i],  # start a new subarray\n        )\n        maxSum = max(maxSum, dp[i])\n\n    return maxSum\n\n\n# Greedy\ndef maxSubArrayGreedy(nums: List[int]) -&gt; int:\n    max_sum = nums[0]\n    cur_sum = 0\n\n    for num in nums:\n        cur_sum = max(cur_sum + num, num)\n        max_sum = max(max_sum, cur_sum)\n\n    return max_sum\n\n\n# Prefix Sum\ndef maxSubArrayPrefixSum(nums: List[int]) -&gt; int:\n    prefix_sum = 0\n    prefix_sum_min = 0\n    res = float(\"-inf\")\n\n    for num in nums:\n        prefix_sum += num\n        res = max(res, prefix_sum - prefix_sum_min)\n        prefix_sum_min = min(prefix_sum_min, prefix_sum)\n\n    return res\n\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArrayDP(nums))  # 6\nprint(maxSubArrayGreedy(nums))  # 6\nprint(maxSubArrayPrefixSum(nums))  # 6\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/greedy/#55-jump-game","title":"55. Jump Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> <li>Return <code>True</code> if you can reach the last index, otherwise <code>False</code>.</li> </ul> 55. Jump Game - Python Solution<pre><code>from typing import List\n\n\n# Greedy - Interval\ndef canJump(nums: List[int]) -&gt; bool:\n    n = len(nums)\n    reach = 0\n    i = 0\n\n    while reach &gt;= i:\n        if reach &gt;= n - 1:\n            return True\n        reach = max(reach, i + nums[i])\n        i += 1\n\n    return False\n\n\nif __name__ == \"__main__\":\n    assert canJump([2, 3, 1, 1, 4]) is True\n    assert canJump([3, 2, 1, 0, 4]) is False\n</code></pre> 55. Jump Game - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool canJump(vector&lt;int&gt;&amp; nums) {\n        int canReach = 0;\n        int n = nums.size();\n\n        for (int i = 0; i &lt; n; i++) {\n            if (i &gt; canReach) return false;\n            canReach = max(canReach, i + nums[i]);\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution obj;\n    vector&lt;int&gt; nums = {2, 3, 1, 1, 4};\n    cout &lt;&lt; obj.canJump(nums) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/neetcode150/greedy/#45-jump-game-ii","title":"45. Jump Game II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> <li>Return the minimum number of jumps to reach the last index.</li> </ul> 45. Jump Game II - Python Solution<pre><code>from typing import List\n\n\n# Greedy - Interval\ndef jump(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n == 1:\n        return 0\n\n    reach = 0\n    left, right = 0, 0\n    res = 0\n\n    while right &lt; n - 1:\n        for i in range(left, right + 1):\n            reach = max(reach, i + nums[i])\n\n        left = right + 1\n        right = reach\n        res += 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert jump([2, 3, 1, 1, 4]) == 2\n    assert jump([2, 3, 0, 1, 4]) == 2\n</code></pre>"},{"location":"content/neetcode150/greedy/#134-gas-station","title":"134. Gas Station","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy 134. Gas Station - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef canCompleteCircuit(gas: List[int], cost: List[int]) -&gt; int:\n    curSum = 0\n    totalSum = 0\n    start = 0\n\n    for i in range(len(gas)):\n        curSum += gas[i] - cost[i]\n        totalSum += gas[i] - cost[i]\n\n        if curSum &lt; 0:\n            start = i + 1\n            curSum = 0\n\n    if totalSum &lt; 0:\n        return -1\n\n    return start\n\n\ngas = [1, 2, 3, 4, 5]\ncost = [3, 4, 5, 1, 2]\nprint(canCompleteCircuit(gas, cost))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/greedy/#846-hand-of-straights","title":"846. Hand of Straights","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, greedy, sorting 846. Hand of Straights - Python Solution<pre><code>from collections import Counter\nfrom typing import List\n\n\n# Greedy\ndef isNStraightHand(hand: List[int], groupSize: int) -&gt; bool:\n    if len(hand) % groupSize != 0:\n        return False\n\n    count = Counter(hand)\n\n    while count:\n        minVal = min(count)\n        for i in range(minVal, minVal + groupSize):\n            if count[i] == 0:\n                return False\n            count[i] -= 1\n            if count[i] == 0:\n                del count[i]\n    return True\n\n\nhand = [1, 2, 3, 6, 2, 3, 4, 7, 8]\ngroupSize = 3\nprint(isNStraightHand(hand, groupSize))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/greedy/#1899-merge-triplets-to-form-target-triplet","title":"1899. Merge Triplets to Form Target Triplet","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy 1899. Merge Triplets to Form Target Triplet - Python Solution<pre><code>from typing import List\n\n\ndef mergeTriplets(triplets: List[List[int]], target: List[int]) -&gt; bool:\n    can_form = [False, False, False]\n\n    for triplet in triplets:\n        if all(triplet[i] &lt;= target[i] for i in range(3)):\n            for i in range(3):\n                if triplet[i] == target[i]:\n                    can_form[i] = True\n\n    return all(can_form)\n\n\ntriplets = [[2, 5, 3], [1, 8, 4], [1, 7, 5]]\ntarget = [2, 7, 5]\nprint(mergeTriplets(triplets, target))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/greedy/#763-partition-labels","title":"763. Partition Labels","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, two pointers, string, greedy 763. Partition Labels - Python Solution<pre><code>from typing import List\n\n\n# 1. Hashmap\ndef partitionLabels1(s: str) -&gt; List[int]:\n    hashmap = {}\n\n    for i, j in enumerate(s):\n        if j not in hashmap:\n            hashmap[j] = [i, i]\n        else:\n            hashmap[j][1] = i\n\n    intervals = list(hashmap.values())\n    intervals.sort(key=lambda x: x[0])\n\n    if len(intervals) &lt; 2:\n        return len(intervals)\n\n    res = []\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &lt; intervals[i - 1][1]:\n            intervals[i][1] = max(intervals[i][1], intervals[i - 1][1])\n        else:\n            res.append(intervals[i][0])\n\n    res.append(intervals[-1][1] + 1)\n\n    if len(res) == 1:\n        return res\n    else:\n        for i in range(len(res) - 1, 0, -1):\n            res[i] -= res[i - 1]\n        return res\n\n\n# Single Pass Partitioning\ndef partitionLabels2(s: str) -&gt; List[int]:\n    last = {c: i for i, c in enumerate(s)}\n    res = []\n    start, end = 0, 0\n\n    for i, c in enumerate(s):\n        end = max(end, last[c])\n        if end == i:\n            res.append(end - start + 1)\n            start = i + 1\n\n    return res\n\n\nprint(partitionLabels1(\"abaccd\"))  # [3, 2, 1]\nprint(partitionLabels2(\"abaccd\"))  # [3, 2, 1]\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/greedy/#678-valid-parenthesis-string","title":"678. Valid Parenthesis String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming, stack, greedy 678. Valid Parenthesis String - Python Solution<pre><code># Greedy\ndef checkValidString(s: str) -&gt; bool:\n    min_open, max_open = 0, 0\n\n    for char in s:\n        if char == \"(\":\n            min_open += 1\n            max_open += 1\n        elif char == \")\":\n            min_open = max(min_open - 1, 0)\n            max_open -= 1\n        elif char == \"*\":\n            min_open = max(min_open - 1, 0)\n            max_open += 1\n\n        if max_open &lt; 0:\n            return False\n\n    return min_open == 0\n\n\ns = \"(*))\"\nprint(checkValidString(s))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/heap/","title":"Heap","text":""},{"location":"content/neetcode150/heap/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 703. Kth Largest Element in a Stream (Easy)</li> <li> 1046. Last Stone Weight (Easy)</li> <li> 973. K Closest Points to Origin (Medium)</li> <li> 215. Kth Largest Element in an Array (Medium)</li> <li> 621. Task Scheduler (Medium)</li> <li> 355. Design Twitter (Medium)</li> <li> 295. Find Median from Data Stream (Hard)</li> </ul>"},{"location":"content/neetcode150/heap/#703-kth-largest-element-in-a-stream","title":"703. Kth Largest Element in a Stream","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, design, binary search tree, heap priority queue, binary tree, data stream 703. Kth Largest Element in a Stream - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Heap\nclass KthLargest:\n\n    def __init__(self, k: int, nums: List[int]):\n        self.k = k\n        self.heap = []\n        for num in nums:\n            self.add(num)\n\n    def add(self, val: int) -&gt; int:\n        heapq.heappush(self.heap, val)\n\n        if len(self.heap) &gt; self.k:\n            heapq.heappop(self.heap)\n\n        return self.heap[0]\n\n\nobj = KthLargest(3, [4, 5, 8, 2])\nprint(obj.add(3))  # 4\nprint(obj.add(5))  # 5\nprint(obj.add(10))  # 5\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/heap/#1046-last-stone-weight","title":"1046. Last Stone Weight","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, heap priority queue</p> </li> <li>Heap<ul> <li>Time: O(n log n); Space: O(n)</li> </ul> </li> <li>0/1 Knapsack<ul> <li>Time: O(n); Space: O(n)</li> </ul> </li> </ul> 1046. Last Stone Weight - Python Solution<pre><code>from heapq import heapify, heappop, heappush\nfrom typing import List\n\n\n# Heap\ndef lastStoneWeightHeap(stones: List[int]) -&gt; int:\n    maxHeap = [-s for s in stones]\n    heapify(maxHeap)\n\n    while len(maxHeap) &gt; 1:\n        s1 = heappop(maxHeap)\n        s2 = heappop(maxHeap)\n\n        if s1 != s2:\n            heappush(maxHeap, s1 - s2)\n\n    return -maxHeap[0] if maxHeap else 0\n\n\n# 0/1 Knapsack\ndef lastStoneWeightKnapsack(stones: List[int]) -&gt; int:\n    total = sum(stones)\n    target = total // 2\n\n    dp = [0 for _ in range(target + 1)]\n\n    for i in stones:\n        for j in range(target, i - 1, -1):\n            dp[j] = max(dp[j], dp[j - i] + i)\n\n    return total - 2 * dp[target]\n\n\nif __name__ == \"__main__\":\n    stones = [2, 7, 4, 1, 8, 1]\n    assert lastStoneWeightHeap(stones) == 1\n    assert lastStoneWeightKnapsack(stones) == 1\n</code></pre> 1046. Last Stone Weight - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;queue&gt;\n\nusing namespace std;\n\nint lastStoneWeight(vector&lt;int&gt; &amp;stones)\n{\n    priority_queue&lt;int&gt; maxHeap(stones.begin(), stones.end());\n\n    while (maxHeap.size() &gt;= 1)\n    {\n        int first = maxHeap.top();\n        maxHeap.pop();\n        int second = maxHeap.top();\n        maxHeap.pop();\n\n        if (first != second)\n        {\n            maxHeap.push(first - second);\n        }\n    }\n\n    return maxHeap.empty() ? 0 : maxHeap.top();\n}\n\nint main()\n{\n    vector&lt;int&gt; stones = {2, 7, 4, 1, 8, 1};\n    cout &lt;&lt; lastStoneWeight(stones) &lt;&lt; endl; // 1\n    return 0;\n}\n</code></pre>"},{"location":"content/neetcode150/heap/#973-k-closest-points-to-origin","title":"973. K Closest Points to Origin","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, divide and conquer, geometry, sorting, heap priority queue, quickselect 973. K Closest Points to Origin - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\ndef kClosest(points: List[List[int]], k: int) -&gt; List[List[int]]:\n    heap = []\n\n    for x, y in points:\n        dist = -(x**2 + y**2)  # max heap\n        if len(heap) &lt; k:\n            heapq.heappush(heap, (dist, x, y))\n        else:\n            heapq.heappushpop(heap, (dist, x, y))  # push and pop the smallest\n\n    return [[x, y] for (_, x, y) in heap]\n\n\n# Time complexity: O(n * log(k))\n#   - O(log(k)) for heapify\n#   - O(n) for iterating through the input list\n# Space complexity: O(k)\n\npoints = [[1, 3], [-2, 2]]\nk = 1\nprint(kClosest(points, k))  # [[-2, 2]]\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/heap/#215-kth-largest-element-in-an-array","title":"215. Kth Largest Element in an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, divide and conquer, sorting, heap priority queue, quickselect 215. Kth Largest Element in an Array - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\ndef findKthLargest(nums: List[int], k: int) -&gt; int:\n    min_heap = []\n\n    for i, num in enumerate(nums):\n        heapq.heappush(min_heap, num)\n        if i &gt;= k:\n            heapq.heappop(min_heap)\n\n    return min_heap[0]\n\n\nif __name__ == \"__main__\":\n    assert findKthLargest([3, 2, 1, 5, 6, 4], 2) == 5\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/heap/#621-task-scheduler","title":"621. Task Scheduler","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, greedy, sorting, heap priority queue, counting 621. Task Scheduler - Python Solution<pre><code>import heapq\nfrom collections import Counter, deque\nfrom typing import List\n\n\n# Heap\ndef leastInterval1(tasks: List[str], n: int) -&gt; int:\n    count = Counter(tasks)\n    heap = [-c for c in count.values()]\n    heapq.heapify(heap)\n\n    time = 0\n\n    q = deque()\n\n    while heap or q:\n        time += 1\n\n        if heap:\n            cnt = 1 + heapq.heappop(heap)\n            if cnt:\n                q.append((cnt, time + n))\n\n        if q and q[0][1] == time:\n            heapq.heappush(heap, q.popleft()[0])\n\n    return time\n\n\ndef leastInterval2(tasks: List[str], n: int) -&gt; int:\n    freq = Counter(tasks)\n\n    maxExec = max(freq.values())\n    maxCount = sum(1 for v in freq.values() if v == maxExec)\n\n    return max((maxExec - 1) * (n + 1) + maxCount, len(tasks))\n\n\ntasks = [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\"]\nn = 2\nprint(leastInterval1(tasks, n))  # 8\nprint(leastInterval2(tasks, n))  # 8\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/heap/#355-design-twitter","title":"355. Design Twitter","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, linked list, design, heap priority queue</p> </li> <li>Similar question: 23. Merge K Sorted Lists (Hard)</li> </ul> 355. Design Twitter - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Design\nclass Twitter:\n\n    def __init__(self):\n        self.tweets = defaultdict(list)\n        self.followees = defaultdict(set)\n        self.time = 0\n\n    def postTweet(self, userId: int, tweetId: int) -&gt; None:\n        self.tweets[userId].append((self.time, tweetId))\n        self.time += 1\n\n    def getNewsFeed(self, userId: int) -&gt; List[int]:\n        news_feed = []\n        news_feed.extend(self.tweets[userId])\n        for followee in self.followees[userId]:\n            news_feed.extend(self.tweets[followee])\n\n        return [tweet for _, tweet in heapq.nlargest(10, news_feed)]\n\n    def follow(self, followerId: int, followeeId: int) -&gt; None:\n        if followerId != followeeId:\n            self.followees[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -&gt; None:\n        if followerId != followeeId:\n            self.followees[followerId].discard(followeeId)\n\n\ntwitter = Twitter()\nprint(twitter.postTweet(1, 5))  # None\nprint(twitter.getNewsFeed(1))  # [5]\nprint(twitter.follow(1, 2))  # None\nprint(twitter.postTweet(2, 6))  # None\nprint(twitter.getNewsFeed(1))  # [6, 5]\nprint(twitter.unfollow(1, 2))  # None\nprint(twitter.getNewsFeed(1))  # [5]\n</code></pre>"},{"location":"content/neetcode150/heap/#295-find-median-from-data-stream","title":"295. Find Median from Data Stream","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: two pointers, design, sorting, heap priority queue, data stream 295. Find Median from Data Stream - Python Solution<pre><code>from heapq import heappop, heappush\n\n\n# Dual Heaps\nclass MedianFinder:\n\n    def __init__(self):\n        self.minHeap = []\n        self.maxHeap = []\n        self.min_size = 0\n        self.max_size = 0\n\n    def addNum(self, num: int) -&gt; None:\n        heappush(self.maxHeap, -num)\n        heappush(self.minHeap, -heappop(self.maxHeap))\n        self.min_size += 1\n\n        if self.min_size &gt; self.max_size:\n            heappush(self.maxHeap, -heappop(self.minHeap))\n            self.min_size -= 1\n            self.max_size += 1\n\n    def findMedian(self) -&gt; float:\n        if self.min_size == self.max_size:\n            return (-self.maxHeap[0] + self.minHeap[0]) / 2.0\n        return -self.maxHeap[0]\n\n\nobj = MedianFinder()\nobj.addNum(1)\nobj.addNum(2)\nassert obj.findMedian() == 1.5\nobj.addNum(3)\nassert obj.findMedian() == 2\nobj.addNum(4)\nassert obj.findMedian() == 2.5\nobj.addNum(5)\nassert obj.findMedian() == 3\nprint(\"All Passed.\")\n</code></pre></p> </li> </ul> 295. Find Median from Data Stream - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass MedianFinder {\n   private:\n    priority_queue&lt;int&gt; maxHeap;\n    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;\n    int max_size = 0;\n    int min_size = 0;\n\n   public:\n    MedianFinder() {}\n\n    void addNum(int num) {\n        if (min_size == max_size) {\n            minHeap.push(num);\n            maxHeap.push(minHeap.top());\n            minHeap.pop();\n            max_size++;\n        } else {\n            maxHeap.push(num);\n            minHeap.push(maxHeap.top());\n            maxHeap.pop();\n            min_size++;\n        }\n    }\n\n    double findMedian() {\n        if (min_size == max_size) {\n            return (maxHeap.top() + minHeap.top()) / 2.0;\n        } else {\n            return (double)maxHeap.top();\n        }\n    }\n};\n\nint main() {\n    MedianFinder* obj = new MedianFinder();\n    obj-&gt;addNum(1);\n    obj-&gt;addNum(2);\n    cout &lt;&lt; obj-&gt;findMedian() &lt;&lt; endl;  // 1.5\n    obj-&gt;addNum(3);\n    cout &lt;&lt; obj-&gt;findMedian() &lt;&lt; endl;  // 2\n    return 0;\n}\n</code></pre>"},{"location":"content/neetcode150/intervals/","title":"Intervals","text":""},{"location":"content/neetcode150/intervals/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 57. Insert Interval (Medium)</li> <li> 56. Merge Intervals (Medium)</li> <li> 435. Non-overlapping Intervals (Medium)</li> <li> 252. Meeting Rooms (Easy) \ud83d\udc51</li> <li> 253. Meeting Rooms II (Medium) \ud83d\udc51</li> <li> 1851. Minimum Interval to Include Each Query (Hard)</li> </ul>"},{"location":"content/neetcode150/intervals/#57-insert-interval","title":"57. Insert Interval","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array 57. Insert Interval - Python Solution<pre><code>from typing import List\n\n\n# Interval\ndef insert(\n    intervals: List[List[int]], newInterval: List[int]\n) -&gt; List[List[int]]:\n    n = len(intervals)\n\n    if n == 0:\n        return [newInterval]\n\n    if newInterval[1] &lt; intervals[0][0]:\n        return [newInterval] + intervals\n\n    if newInterval[0] &gt; intervals[-1][1]:\n        return intervals + [newInterval]\n\n    i = 0\n    result = []\n\n    while i &lt; n and intervals[i][1] &lt; newInterval[0]:\n        result.append(intervals[i])\n        i += 1\n\n    while i &lt; n and intervals[i][0] &lt;= newInterval[1]:\n        newInterval[0] = min(newInterval[0], intervals[i][0])\n        newInterval[1] = max(newInterval[1], intervals[i][1])\n        i += 1\n\n    result.append(newInterval)\n\n    while i &lt; n:\n        result.append(intervals[i])\n        i += 1\n\n    return result\n\n\nintervals = [[1, 3], [6, 9]]\nnewInterval = [2, 5]\nprint(insert(intervals, newInterval))  # [[1, 5], [6, 9]]\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/intervals/#56-merge-intervals","title":"56. Merge Intervals","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sorting</p> </li> <li>Merge all overlapping intervals.</li> </ul> 56. Merge Intervals - Python Solution<pre><code>from typing import List\n\n\n# Intervals\ndef merge(intervals: List[List[int]]) -&gt; List[List[int]]:\n    n = len(intervals)\n    if n &lt;= 1:\n        return intervals\n\n    intervals.sort(key=lambda x: x[0])\n    res = [intervals[0]]\n\n    for i in range(1, n):\n        if intervals[i][0] &lt;= res[-1][1]:\n            res[-1][1] = max(res[-1][1], intervals[i][1])\n        else:\n            res.append(intervals[i])\n\n    return res\n\n\nprint(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))\n# [[1, 6], [8, 10], [15, 18]]\n</code></pre> 56. Merge Intervals - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// Interval\nvector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {\n    sort(intervals.begin(), intervals.end());\n    vector&lt;vector&lt;int&gt;&gt; res;\n\n    for (auto&amp; range : intervals) {\n        if (!res.empty() &amp;&amp; range[0] &lt;= res.back()[1]) {\n            res.back()[1] = max(res.back()[1], range[1]);\n        } else {\n            res.emplace_back(range);\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;vector&lt;int&gt;&gt; intervals = {{1, 3}, {2, 6}, {8, 10}, {15, 18}};\n    vector&lt;vector&lt;int&gt;&gt; res = merge(intervals);\n    for (auto&amp; range : res) {\n        cout &lt;&lt; range[0] &lt;&lt; \", \" &lt;&lt; range[1] &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"content/neetcode150/intervals/#435-non-overlapping-intervals","title":"435. Non-overlapping Intervals","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy, sorting 435. Non-overlapping Intervals - Python Solution<pre><code>from typing import List\n\n\ndef eraseOverlapIntervals(intervals: List[List[int]]) -&gt; int:\n    if len(intervals) &lt;= 1:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n    result = 0\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &gt;= intervals[i - 1][1]:\n            continue\n        else:\n            result += 1\n            intervals[i][1] = min(intervals[i][1], intervals[i - 1][1])\n\n    return result\n\n\nprint(eraseOverlapIntervals([[1, 2], [2, 3], [3, 4], [1, 3]]))  # 1\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/intervals/#252-meeting-rooms","title":"252. Meeting Rooms","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, sorting 252. Meeting Rooms - Python Solution<pre><code>from typing import List\n\n\n# Interval\ndef canAttendMeetings(intervals: List[List[int]]) -&gt; bool:\n    intervals.sort(key=lambda x: x[0])\n    n = len(intervals)\n\n    if n &lt;= 1:\n        return True\n\n    for i in range(1, n):\n        if intervals[i][0] &lt; intervals[i - 1][1]:\n            return False\n\n    return True\n\n\nif __name__ == \"__main__\":\n    intervals = [[0, 30], [5, 10], [15, 20]]\n    assert not canAttendMeetings(intervals)\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/intervals/#253-meeting-rooms-ii","title":"253. Meeting Rooms II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy, sorting, heap priority queue, prefix sum</p> </li> <li>Given an array of meeting time <code>intervals</code> where <code>intervals[i] = [start_i, end_i]</code>, return the minimum number of conference rooms required.</li> </ul> 253. Meeting Rooms II - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Heap\ndef minMeetingRooms(intervals: List[List[int]]) -&gt; int:\n    if not intervals:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n    minHeap = [intervals[0][1]]\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &gt;= minHeap[0]:\n            heapq.heappop(minHeap)\n        heapq.heappush(minHeap, intervals[i][1])\n\n    return len(minHeap)\n\n\nif __name__ == \"__main__\":\n    intervals = [[0, 30], [5, 10], [15, 20]]\n    assert minMeetingRooms(intervals) == 2\n</code></pre>"},{"location":"content/neetcode150/intervals/#1851-minimum-interval-to-include-each-query","title":"1851. Minimum Interval to Include Each Query","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, line sweep, sorting, heap priority queue</p> </li> </ul>"},{"location":"content/neetcode150/linked_list/","title":"Linked List","text":""},{"location":"content/neetcode150/linked_list/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 206. Reverse Linked List (Easy)</li> <li> 21. Merge Two Sorted Lists (Easy)</li> <li> 143. Reorder List (Medium)</li> <li> 19. Remove Nth Node From End of List (Medium)</li> <li> 138. Copy List with Random Pointer (Medium)</li> <li> 2. Add Two Numbers (Medium)</li> <li> 141. Linked List Cycle (Easy)</li> <li> 287. Find the Duplicate Number (Medium)</li> <li> 146. LRU Cache (Medium)</li> <li> 23. Merge k Sorted Lists (Hard)</li> <li> 25. Reverse Nodes in k-Group (Hard)</li> </ul>"},{"location":"content/neetcode150/linked_list/#206-reverse-linked-list","title":"206. Reverse Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: linked list, recursion</p> </li> <li>Reverse a singly linked list.</li> </ul> <pre><code>graph LR\nA((1)) --&gt; B((2))\nB --&gt; C((3))\nC --&gt; D((4))\nD --&gt; E((5))</code></pre> <pre><code>graph RL\nE((5)) --&gt; D((4))\nD --&gt; C((3))\nC --&gt; B((2))\nB --&gt; A((1))</code></pre> 206. Reverse Linked List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Iterative\ndef reverseListIterative(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    cur = head\n    prev = None\n\n    while cur:\n        temp = cur.next\n        cur.next = prev\n\n        prev = cur\n        cur = temp\n\n    return prev\n\n\n# Recursive\ndef reverseListRecursive(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    def reverse(cur, prev):\n        if not cur:\n            return prev\n\n        temp = cur.next\n        cur.next = prev\n\n        return reverse(temp, cur)\n\n    return reverse(head, None)\n\n\nnums = [1, 2, 3, 4, 5]\nhead1 = ListNode.create(nums)\nprint(head1)\n# 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(reverseListIterative(head1))\n# 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1\nhead2 = ListNode.create(nums)\nprint(reverseListRecursive(head2))\n# 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1\n</code></pre>"},{"location":"content/neetcode150/linked_list/#21-merge-two-sorted-lists","title":"21. Merge Two Sorted Lists","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: linked list, recursion</p> </li> <li>Merge the two lists into one sorted list.</li> </ul> 21. Merge Two Sorted Lists - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef mergeTwoLists(\n    list1: Optional[ListNode], list2: Optional[ListNode]\n) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    while list1 and list2:\n        if list1.val &lt; list2.val:\n            cur.next = list1\n            list1 = list1.next\n        else:\n            cur.next = list2\n            list2 = list2.next\n        cur = cur.next\n\n    if list1:\n        cur.next = list1\n    elif list2:\n        cur.next = list2\n\n    return dummy.next\n\n\nlist1 = ListNode.create([1, 2, 4])\nlist2 = ListNode.create([1, 3, 4])\nprint(mergeTwoLists(list1, list2))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4\n</code></pre> 21. Merge Two Sorted Lists - C++ Solution<pre><code>struct ListNode {\n    int val;\n    ListNode* next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode* next) : val(x), next(next) {}\n};\n\nclass Solution {\n   public:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        ListNode dummy;\n        ListNode* cur = &amp;dummy;\n\n        while (list1 &amp;&amp; list2) {\n            if (list1-&gt;val &lt; list2-&gt;val) {\n                cur-&gt;next = list1;\n                list1 = list1-&gt;next;\n            } else {\n                cur-&gt;next = list2;\n                list2 = list2-&gt;next;\n            }\n            cur = cur-&gt;next;\n        }\n\n        cur-&gt;next = list1 ? list1 : list2;\n\n        return dummy.next;\n    }\n};\n</code></pre>"},{"location":"content/neetcode150/linked_list/#143-reorder-list","title":"143. Reorder List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, two pointers, stack, recursion 143. Reorder List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef reorderList(head: Optional[ListNode]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify head in-place instead.\n    \"\"\"\n    if not head or not head.next:\n        return\n\n    # Middle of the linked list\n    slow, fast = head, head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n    # Reverse the second half\n    pre, cur = None, slow\n    while cur:\n        temp = cur.next\n        cur.next = pre\n        pre = cur\n        cur = temp\n\n    # Merge two linked lists\n    first, second = head, pre\n    while second.next:\n        temp1, temp2 = first.next, second.next\n        first.next = second\n        second.next = temp1\n        first, second = temp1, temp2\n\n\nhead = ListNode.create([1, 2, 3, 4, 5, 6])\nprint(head)  # 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6\nreorderList(head)\nprint(head)  # 1 -&gt; 6 -&gt; 2 -&gt; 5 -&gt; 3 -&gt; 4\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/linked_list/#19-remove-nth-node-from-end-of-list","title":"19. Remove Nth Node From End of List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, two pointers</p> </li> <li>Given the <code>head</code> of a linked list, remove the <code>n-th</code> node from the end of the list and return its head.</li> </ul> 19. Remove Nth Node From End of List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef removeNthFromEnd(head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:\n    dummy = ListNode(0, head)\n    fast, slow = dummy, dummy\n\n    for _ in range(n):\n        fast = fast.next\n\n    while fast.next:\n        fast = fast.next\n        slow = slow.next\n\n    slow.next = slow.next.next\n\n    return dummy.next\n\n\nhead = [1, 2, 3, 4, 5]\nn = 2\nhead = ListNode.create(head)\nprint(head)  # 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(removeNthFromEnd(head, n))  # 1 -&gt; 2 -&gt; 3 -&gt; 5\n</code></pre>"},{"location":"content/neetcode150/linked_list/#138-copy-list-with-random-pointer","title":"138. Copy List with Random Pointer","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, linked list 138. Copy List with Random Pointer - Python Solution<pre><code>from typing import Optional\n\n\nclass Node:\n    def __init__(self, x: int, next: \"Node\" = None, random: \"Node\" = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\n\ndef copyRandomList(head: \"Optional[Node]\") -&gt; \"Optional[Node]\":\n    if not head:\n        return None\n\n    # Copy nodes and link them together\n    cur = head\n    while cur:\n        new_node = Node(cur.val)\n        new_node.next = cur.next\n        cur.next = new_node\n        cur = new_node.next\n\n    # Copy random pointers\n    cur = head\n    while cur:\n        cur.next.random = cur.random.next if cur.random else None\n        cur = cur.next.next\n\n    # Separate the original and copied lists\n    cur = head\n    new_head = head.next\n    while cur:\n        new_node = cur.next\n        cur.next = new_node.next\n        new_node.next = new_node.next.next if new_node.next else None\n        cur = cur.next\n\n    return new_head\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/linked_list/#2-add-two-numbers","title":"2. Add Two Numbers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, math, recursion</p> </li> <li>Represent the sum of two numbers as a linked list.</li> </ul> 2. Add Two Numbers - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef addTwoNumbers(\n    l1: Optional[ListNode], l2: Optional[ListNode]\n) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n    carry = 0\n\n    while l1 or l2:\n        v1 = l1.val if l1 else 0\n        v2 = l2.val if l2 else 0\n\n        carry, val = divmod(v1 + v2 + carry, 10)\n        cur.next = ListNode(val)\n        cur = cur.next\n\n        if l1:\n            l1 = l1.next\n        if l2:\n            l2 = l2.next\n\n    if carry:\n        cur.next = ListNode(val=carry)\n\n    return dummy.next\n\n\nl1 = ListNode.create([2, 4, 3])\nl2 = ListNode.create([5, 6, 4])\nprint(addTwoNumbers(l1, l2))  # 7 -&gt; 0 -&gt; 8\n</code></pre> 2. Add Two Numbers - C++ Solution<pre><code>struct ListNode {\n    int val;\n    ListNode* next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode* next) : val(x), next(next) {}\n};\n\nclass Solution {\n   public:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode dummy;\n        ListNode* cur = &amp;dummy;\n        int carry = 0;\n\n        while (l1 || l2 || carry) {\n            if (l1) {\n                carry += l1-&gt;val;\n                l1 = l1-&gt;next;\n            }\n            if (l2) {\n                carry += l2-&gt;val;\n                l2 = l2-&gt;next;\n            }\n            cur-&gt;next = new ListNode(carry % 10);\n            cur = cur-&gt;next;\n            carry /= 10;\n        }\n        return dummy.next;\n    }\n};\n</code></pre>"},{"location":"content/neetcode150/linked_list/#141-linked-list-cycle","title":"141. Linked List Cycle","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, linked list, two pointers</p> </li> <li>Determine if a linked list has a cycle in it.</li> </ul> <pre><code>graph LR\n    A((3)) --&gt; B((2))\n    B --&gt; C((0))\n    C --&gt; D((4))</code></pre> <pre><code>graph LR\n    A((3)) --&gt; B((2))\n    B --&gt; C((0))\n    C --&gt; D((4))\n    D --&gt; B</code></pre> 141. Linked List Cycle - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\ndef hasCycle(head: Optional[ListNode]) -&gt; bool:\n    slow, fast = head, head\n\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n        if slow == fast:\n            return True\n\n    return False\n\n\nprint(hasCycle(ListNode.create([3, 2, 0, -4])))  # False\nprint(hasCycle(ListNode.create([3, 2, 0, -4], 1)))  # True\n</code></pre> 141. Linked List Cycle - C++ Solution<pre><code>#include &lt;iostream&gt;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nclass Solution {\n   public:\n    bool hasCycle(ListNode* head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while (fast &amp;&amp; fast-&gt;next) {\n            slow = slow-&gt;next;\n            fast = fast-&gt;next-&gt;next;\n\n            if (fast == slow) return true;\n        }\n        return false;\n    }\n};\n</code></pre>"},{"location":"content/neetcode150/linked_list/#287-find-the-duplicate-number","title":"287. Find the Duplicate Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, bit manipulation</p> </li> <li>Find the duplicate number in an array containing <code>n + 1</code> integers where each integer is between <code>1</code> and <code>n</code> inclusive.</li> <li>Floyd's Tortoise and Hare (Cycle Detection)<ul> <li> <ol> <li>Linked List Cycle</li> </ol> </li> <li> <ol> <li>Linked List Cycle II</li> </ol> </li> </ul> </li> <li>Time Complexity: O(n)</li> <li>Space Complexity: O(1)</li> </ul> <p>Example: <code>nums = [1, 3, 4, 2, 2]</code></p> 0 1 2 3 4 1 3 4 2 2 <pre><code>graph LR\n0((0)) --&gt; 1((1))\n1 --&gt; 3((3))\n2((2))--&gt; 4((4))\n3 --&gt; 2\n4 --&gt; 2</code></pre> 287. Find the Duplicate Number - Python Solution<pre><code>from typing import List\n\n\n# Floyd Cycle Detection Algorithm\ndef findDuplicate(nums: List[int]) -&gt; int:\n    fast, slow = nums[0], nums[0]\n\n    while True:\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n        if slow == fast:\n            break\n\n    slow = nums[0]\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[fast]\n\n    return slow\n\n\nnums = [1, 3, 4, 2, 2]\nprint(findDuplicate(nums))  # 2\n</code></pre>"},{"location":"content/neetcode150/linked_list/#146-lru-cache","title":"146. LRU Cache","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, linked list, design, doubly linked list</p> </li> <li>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.</li> <li>lru</li> <li></li> </ul> Data structure Description Doubly Linked List To store the key-value pairs. Hash Map To store the key-node pairs. 146. LRU Cache - Python Solution<pre><code>from collections import OrderedDict\n\n\n# Doubly Linked List\nclass Node:\n    def __init__(self, key=0, val=0):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.cache = {}\n        self.head = Node()\n        self.tail = Node()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def add_to_last(self, node):\n        self.tail.prev.next = node\n        node.prev = self.tail.prev\n        node.next = self.tail\n        self.tail.prev = node\n\n    def move_to_last(self, node):\n        self.remove(node)\n        self.add_to_last(node)\n\n    def get(self, key: int) -&gt; int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self.move_to_last(node)\n        return node.val\n\n    def put(self, key: int, value: int) -&gt; None:\n        if key in self.cache:\n            node = self.cache[key]\n            node.val = value\n            self.move_to_last(node)\n            return None\n\n        if len(self.cache) == self.cap:\n            del self.cache[self.head.next.key]\n            self.remove(self.head.next)\n\n        node = Node(key=key, val=value)\n        self.cache[key] = node\n        self.add_to_last(node)\n\n\n# OrderedDict\nclass LRUCacheOrderedDict:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.cap = capacity\n\n    def get(self, key: int):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key, last=True)\n        return self.cache[key]\n\n    def put(self, key: int, value: int):\n        if key in self.cache:\n            self.cache.move_to_end(key, last=True)\n        elif len(self.cache) &gt;= self.cap:\n            self.cache.popitem(last=False)\n\n        self.cache[key] = value\n\n\ncache = LRUCache(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\n\ncache = LRUCacheOrderedDict(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\nprint(\"LRU Cache passed\")\nprint(\"LRU Cache Ordered Dict passed\")\n</code></pre> 146. LRU Cache - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nclass Node {\n   public:\n    int key;\n    int val;\n    Node *prev;\n    Node *next;\n\n    Node(int k = 0, int v = 0) : key(k), val(v), prev(nullptr), next(nullptr) {}\n};\n\nclass LRUCache {\n   private:\n    int cap;\n    unordered_map&lt;int, Node *&gt; cache;\n    Node *head;\n    Node *tail;\n\n    void remove(Node *node) {\n        node-&gt;prev-&gt;next = node-&gt;next;\n        node-&gt;next-&gt;prev = node-&gt;prev;\n    }\n\n    void insert_to_last(Node *node) {\n        tail-&gt;prev-&gt;next = node;\n        node-&gt;prev = tail-&gt;prev;\n        tail-&gt;prev = node;\n        node-&gt;next = tail;\n    }\n\n    void move_to_last(Node *node) {\n        remove(node);\n        insert_to_last(node);\n    }\n\n   public:\n    LRUCache(int capacity) {\n        this-&gt;cap = capacity;\n        head = new Node();\n        tail = new Node();\n        head-&gt;next = tail;\n        tail-&gt;prev = head;\n    }\n\n    int get(int key) {\n        if (cache.find(key) != cache.end()) {\n            Node *node = cache[key];\n            move_to_last(node);\n            return node-&gt;val;\n        }\n        return -1;\n    }\n\n    void put(int key, int value) {\n        if (cache.find(key) != cache.end()) {\n            Node *node = cache[key];\n            node-&gt;val = value;\n            move_to_last(node);\n        } else {\n            Node *newNode = new Node(key, value);\n            cache[key] = newNode;\n            insert_to_last(newNode);\n\n            if ((int)cache.size() &gt; cap) {\n                Node *removed = head-&gt;next;\n                remove(removed);\n                cache.erase(removed-&gt;key);\n                delete removed;\n            }\n        }\n    }\n};\n\nint main() {\n    LRUCache lru(2);\n    lru.put(1, 1);\n    lru.put(2, 2);\n    cout &lt;&lt; lru.get(1) &lt;&lt; endl;  // 1\n    lru.put(3, 3);\n    cout &lt;&lt; lru.get(2) &lt;&lt; endl;  // -1\n    lru.put(4, 4);\n    cout &lt;&lt; lru.get(1) &lt;&lt; endl;  // -1\n    cout &lt;&lt; lru.get(3) &lt;&lt; endl;  // 3\n    cout &lt;&lt; lru.get(4) &lt;&lt; endl;  // 4\n    return 0;\n}\n</code></pre>"},{"location":"content/neetcode150/linked_list/#23-merge-k-sorted-lists","title":"23. Merge k Sorted Lists","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: linked list, divide and conquer, heap priority queue, merge sort</p> </li> <li>Prerequisite: 21. Merge Two Sorted Lists</li> <li>Video explanation: 23. Merge K Sorted Lists - NeetCode</li> </ul> 23. Merge k Sorted Lists - Python Solution<pre><code>import copy\nimport heapq\nfrom typing import List, Optional\n\nfrom template import ListNode\n\n\n# Divide and Conquer\ndef mergeKListsDC(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    if not lists or len(lists) == 0:\n        return None\n\n    def mergeTwo(l1, l2):\n        dummy = ListNode()\n        cur = dummy\n\n        while l1 and l2:\n            if l1.val &lt; l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n\n            cur = cur.next\n\n        cur.next = l1 if l1 else l2\n\n        return dummy.next\n\n    while len(lists) &gt; 1:\n        merged = []\n\n        for i in range(0, len(lists), 2):\n            l1 = lists[i]\n            l2 = lists[i + 1] if i + 1 &lt; len(lists) else None\n            merged.append(mergeTwo(l1, l2))\n\n        lists = merged\n\n    return lists[0]\n\n\n# Heap - Merge k Sorted\ndef mergeKLists(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    minHeap = []  # (val, idx, node)\n\n    for idx, head in enumerate(lists):\n        if head:\n            heapq.heappush(minHeap, (head.val, idx, head))\n\n    while minHeap:\n        _, idx, node = heapq.heappop(minHeap)\n        cur.next = node\n        cur = cur.next\n\n        node = node.next\n        if node:\n            heapq.heappush(minHeap, (node.val, idx, node))\n\n    return dummy.next\n\n\nn1 = ListNode.create([1, 4, 5])\nn2 = ListNode.create([1, 3, 4])\nn3 = ListNode.create([2, 6])\nlists = [n1, n2, n3]\nlists1 = copy.deepcopy(lists)\nlists2 = copy.deepcopy(lists)\nprint(mergeKListsDC(lists1))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6\nprint(mergeKLists(lists2))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6\n</code></pre>"},{"location":"content/neetcode150/linked_list/#25-reverse-nodes-in-k-group","title":"25. Reverse Nodes in k-Group","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: linked list, recursion 25. Reverse Nodes in k-Group - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef reverseKGroup(head: Optional[ListNode], k: int) -&gt; Optional[ListNode]:\n    n = 0\n    cur = head\n    while cur:\n        n += 1\n        cur = cur.next\n\n    p0 = dummy = ListNode(next=head)\n    pre = None\n    cur = head\n\n    while n &gt;= k:\n        n -= k\n        for _ in range(k):\n            nxt = cur.next\n            cur.next = pre\n            pre = cur\n            cur = nxt\n\n        nxt = p0.next\n        nxt.next = cur\n        p0.next = pre\n        p0 = nxt\n\n    return dummy.next\n\n\nif __name__ == \"__main__\":\n    head = [1, 2, 3, 4, 5]\n    k = 2\n    head = ListNode.create(head)\n    print(head)  # 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\n    print(reverseKGroup(head, k))  # 2 -&gt; 1 -&gt; 4 -&gt; 3 -&gt; 5\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/math_geometry/","title":"Math Geometry","text":""},{"location":"content/neetcode150/math_geometry/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 48. Rotate Image (Medium)</li> <li> 54. Spiral Matrix (Medium)</li> <li> 73. Set Matrix Zeroes (Medium)</li> <li> 202. Happy Number (Easy)</li> <li> 66. Plus One (Easy)</li> <li> 50. Pow(x, n) (Medium)</li> <li> 43. Multiply Strings (Medium)</li> <li> 166. Fraction to Recurring Decimal (Medium)</li> </ul>"},{"location":"content/neetcode150/math_geometry/#48-rotate-image","title":"48. Rotate Image","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, matrix 48. Rotate Image - Python Solution<pre><code>from copy import deepcopy\nfrom typing import List\n\n\n# Math\ndef rotate1(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    n = len(matrix)\n\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n\n\ndef rotate2(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    n = len(matrix)\n    for i in range(n):\n        for j in range(i, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\n    for i in range(n):\n        matrix[i].reverse()\n\n\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nprint(matrix)\n# [[1, 2, 3],\n#  [4, 5, 6],\n#  [7, 8, 9]]\nmatrix1 = deepcopy(matrix)\nrotate1(matrix1)\nprint(matrix1)\n# [[7, 4, 1],\n#  [8, 5, 2],\n#  [9, 6, 3]]\nmatrix2 = deepcopy(matrix)\nrotate2(matrix2)\nprint(matrix2)\n# [[7, 4, 1],\n#  [8, 5, 2],\n#  [9, 6, 3]]\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/math_geometry/#54-spiral-matrix","title":"54. Spiral Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, matrix, simulation</p> </li> <li>Return all elements of the matrix in spiral order.</li> </ul> 54. Spiral Matrix - Python Solution<pre><code>from typing import List\n\n\n# Array\ndef spiralOrder(matrix: List[List[int]]) -&gt; List[int]:\n    if not matrix or not matrix[0]:\n        return []\n\n    res = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n\n    while top &lt;= bottom and left &lt;= right:\n\n        for i in range(left, right + 1):\n            res.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            res.append(matrix[i][right])\n        right -= 1\n\n        if top &lt;= bottom:\n\n            for i in range(right, left - 1, -1):\n                res.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left &lt;= right:\n\n            for i in range(bottom, top - 1, -1):\n                res.append(matrix[i][left])\n            left += 1\n\n    return res\n\n\n# Math\ndef spiralOrderMath(matrix: List[List[int]]) -&gt; List[int]:\n    dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]]  # Right Down Left Up\n    m, n = len(matrix), len(matrix[0])\n    size = m * n\n    res = []\n    i, j, di = 0, -1, 0\n\n    while len(res) &lt; size:\n        dx, dy = dirs[di]\n        for _ in range(n):\n            i += dx\n            j += dy\n            res.append(matrix[i][j])\n        di = (di + 1) % 4\n        n, m = m - 1, n\n\n    return res\n\n\nprint(spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n# [1, 2, 3, 6, 9, 8, 7, 4, 5]\nprint(spiralOrderMath([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]))\n# [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]\n</code></pre>"},{"location":"content/neetcode150/math_geometry/#73-set-matrix-zeroes","title":"73. Set Matrix Zeroes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, matrix 73. Set Matrix Zeroes - Python Solution<pre><code>from copy import deepcopy\nfrom typing import List\n\n\n# Math\ndef setZeroes1(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    m, n = len(matrix), len(matrix[0])\n\n    rows, cols = set(), set()\n\n    for i in range(m):\n        for j in range(n):\n            if matrix[i][j] == 0:\n                rows.add(i)\n                cols.add(j)\n\n    for i in rows:\n        for j in range(n):\n            matrix[i][j] = 0\n\n    for i in range(m):\n        for j in cols:\n            matrix[i][j] = 0\n\n\n# Math - Optimized\ndef setZeroes2(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    m, n = len(matrix), len(matrix[0])\n    row_zero, col_zero = False, False\n\n    for i in range(m):\n        if matrix[i][0] == 0:\n            col_zero = True\n            break\n\n    for j in range(n):\n        if matrix[0][j] == 0:\n            row_zero = True\n            break\n\n    for i in range(1, m):\n        for j in range(1, n):\n            if matrix[i][j] == 0:\n                matrix[i][0] = 0\n                matrix[0][j] = 0\n\n    for i in range(1, m):\n        if matrix[i][0] == 0:\n            for j in range(1, n):\n                matrix[i][j] = 0\n\n    for j in range(1, n):\n        if matrix[0][j] == 0:\n            for i in range(1, m):\n                matrix[i][j] = 0\n\n    if col_zero:\n        for i in range(m):\n            matrix[i][0] = 0\n\n    if row_zero:\n        for j in range(n):\n            matrix[0][j] = 0\n\n\nmatrix = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]\nprint(matrix)\n# [[1, 1, 1],\n#  [1, 0, 1],\n#  [1, 1, 1]]\nmatrix1 = deepcopy(matrix)\nsetZeroes1(matrix1)\nprint(matrix1)\n# [[1, 0, 1],\n#  [0, 0, 0],\n#  [1, 0, 1]]\nmatrix2 = deepcopy(matrix)\nsetZeroes2(matrix2)\nprint(matrix2)\n# [[1, 0, 1],\n#  [0, 0, 0],\n#  [1, 0, 1]]\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/math_geometry/#202-happy-number","title":"202. Happy Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, math, two pointers</p> </li> <li>Return <code>True</code> if the number is a happy number, otherwise, return <code>False</code>.</li> <li>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.</li> </ul> 202. Happy Number - Python Solution<pre><code>def isHappy(n: int) -&gt; bool:\n\n    def getSum(n):\n        sum_of_squares = 0\n        while n:\n            a, b = divmod(n, 10)\n            sum_of_squares += b**2\n            n = a\n        return sum_of_squares\n\n    record = set()\n\n    while True:\n        if n == 1:\n            return True\n\n        if n in record:\n            return False\n        else:\n            record.add(n)\n\n        n = getSum(n)\n\n\nn = 19\nprint(isHappy(n))  # True\n</code></pre>"},{"location":"content/neetcode150/math_geometry/#66-plus-one","title":"66. Plus One","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, math 66. Plus One - Python Solution<pre><code>from typing import List\n\n\n# Math\ndef plusOne(digits: List[int]) -&gt; List[int]:\n    n = len(digits)\n\n    for i in range(n - 1, -1, -1):\n        if digits[i] &lt; 9:\n            digits[i] += 1\n            return digits\n        else:\n            digits[i] = 0\n\n    return [1] + digits\n\n\ndigits = [4, 3, 2, 1]\nprint(plusOne(digits))  # [4, 3, 2, 2]\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/math_geometry/#50-powx-n","title":"50. Pow(x, n)","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, recursion 50. Pow(x, n) - Python Solution<pre><code># Iterative\ndef myPowIterative(x: float, n: int) -&gt; float:\n    if n == 0:\n        return 1\n    if n &lt; 0:\n        x = 1 / x\n        n = -n\n\n    result = 1\n    cur = x\n\n    while n &gt; 0:\n        if n % 2 == 1:\n            result *= cur\n\n        cur *= cur\n        n //= 2\n\n    return result\n\n\n# Recursive\ndef myPowRecursive(x: float, n: int) -&gt; float:\n    if n == 0:\n        return 1\n    if n &lt; 0:\n        x = 1 / x\n        n = -n\n\n    if n % 2 == 0:\n        return myPowRecursive(x * x, n // 2)\n    else:\n        return x * myPowRecursive(x * x, n // 2)\n\n\nx = 2.00000\nn = 10\nprint(myPowIterative(x, n))  # 1024.0\nprint(myPowRecursive(x, n))  # 1024.0\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/math_geometry/#43-multiply-strings","title":"43. Multiply Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, string, simulation 43. Multiply Strings - Python Solution<pre><code># Math\ndef multiply(num1: str, num2: str) -&gt; str:\n    if num1 == \"0\" or num2 == \"0\":\n        return \"0\"\n\n    m, n = len(num1), len(num2)\n    result = [0 for _ in range(m + n)]\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            mul = int(num1[i]) * int(num2[j])\n            sum = mul + result[i + j + 1]\n\n            result[i + j + 1] = sum % 10\n            result[i + j] += sum // 10\n\n    result_str = \"\".join(map(str, result)).lstrip(\"0\")\n\n    return result_str if result_str else \"0\"\n\n\nnum1 = \"2\"\nnum2 = \"3\"\nprint(multiply(num1, num2))  # \"6\"\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/math_geometry/#166-fraction-to-recurring-decimal","title":"166. Fraction to Recurring Decimal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, math, string 166. Fraction to Recurring Decimal - Python Solution<pre><code># Math\ndef fractionToDecimal(numerator: int, denominator: int) -&gt; str:\n    if numerator == 0:\n        return \"0\"\n\n    res = []\n\n    if (numerator &lt; 0) ^ (denominator &lt; 0):\n        res.append(\"-\")\n\n    numerator, denominator = abs(numerator), abs(denominator)\n\n    # Integer part\n    res.append(str(numerator // denominator))\n    remainder = numerator % denominator\n\n    if remainder == 0:\n        return \"\".join(res)\n\n    res.append(\".\")\n\n    # Dictionary to store remainders and their corresponding indices\n    remainder_map = {}\n\n    while remainder != 0:\n        if remainder in remainder_map:\n            res.insert(remainder_map[remainder], \"(\")\n            res.append(\")\")\n            break\n\n        remainder_map[remainder] = len(res)\n        remainder *= 10\n        res.append(str(remainder // denominator))\n        remainder %= denominator\n\n    return \"\".join(res)\n\n\nnumerator = 4\ndenominator = 333\nprint(fractionToDecimal(numerator, denominator))  # 0.(012)\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/sliding_window/","title":"Sliding Window","text":""},{"location":"content/neetcode150/sliding_window/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 121. Best Time to Buy and Sell Stock (Easy)</li> <li> 3. Longest Substring Without Repeating Characters (Medium)</li> <li> 424. Longest Repeating Character Replacement (Medium)</li> <li> 76. Minimum Window Substring (Hard)</li> <li> 567. Permutation in String (Medium)</li> <li> 239. Sliding Window Maximum (Hard)</li> </ul>"},{"location":"content/neetcode150/sliding_window/#121-best-time-to-buy-and-sell-stock","title":"121. Best Time to Buy and Sell Stock","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li>Return the maximum profit that can be achieved from buying on one day and selling on another day.</li> </ul> 121. Best Time to Buy and Sell Stock - Python Solution<pre><code>from typing import List\n\n\n# Brute Force\ndef maxProfitBF(prices: List[int]) -&gt; int:\n    max_profit = 0\n    n = len(prices)\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_profit = max(max_profit, prices[j] - prices[i])\n\n    return max_profit\n\n\n# DP\ndef maxProfitDP(prices: List[int]) -&gt; int:\n    dp = [[0] * 2 for _ in range(len(prices))]\n    dp[0][0] = -prices[0]  # buy\n    dp[0][1] = 0  # sell\n\n    for i in range(1, len(prices)):\n        dp[i][0] = max(dp[i - 1][0], -prices[i])  # the lowest price to buy\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    max_profit = 0\n    seen_min = prices[0]\n\n    for i in range(1, len(prices)):\n        max_profit = max(max_profit, prices[i] - seen_min)\n        seen_min = min(seen_min, prices[i])\n\n    return max_profit\n\n\n# Fast Slow Pointers\ndef maxProfitFS(prices: List[int]) -&gt; int:\n    max_profit = 0\n    slow, fast = 0, 1\n\n    while fast &lt; len(prices):\n        if prices[fast] &gt; prices[slow]:\n            max_profit = max(max_profit, prices[fast] - prices[slow])\n        else:\n            slow = fast\n        fast += 1\n\n    return max_profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force|  O(n^2)|  O(1)   |\n# | DP         |  O(n)  |  O(n)   |\n# | Greedy     |  O(n)  |  O(1)   |\n# | Fast Slow  |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitBF(prices))  # 5\nprint(maxProfitDP(prices))  # 5\nprint(maxProfitGreedy(prices))  # 5\nprint(maxProfitFS(prices))  # 5\n</code></pre> 121. Best Time to Buy and Sell Stock - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int maxProfit(vector&lt;int&gt; &amp;prices)\n    {\n        if (prices.size() &lt;= 1)\n            return 0;\n\n        int seen_min = prices[0];\n        int res = 0;\n\n        for (int &amp;price : prices)\n        {\n            res = max(res, price - seen_min);\n            seen_min = min(seen_min, price);\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    vector&lt;int&gt; prices = {7, 1, 5, 3, 6, 4};\n    Solution obj;\n    cout &lt;&lt; obj.maxProfit(prices) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/neetcode150/sliding_window/#3-longest-substring-without-repeating-characters","title":"3. Longest Substring Without Repeating Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> <li>Classic variable sliding window problem. Use a set to keep track of the characters in the current window.</li> <li>Return the length of the longest substring without repeating characters.</li> <li>Template tutorial by \u7075\u5c71\u8336\u827e\u5e9c</li> </ul> 3. Longest Substring Without Repeating Characters - Python Solution<pre><code>from collections import defaultdict\n\n\n# Sliding Window Variable Max - HashMap\ndef lengthOfLongestSubstringHash(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    left = 0\n    cnt = defaultdict(int)\n    res = 0\n\n    for right in range(n):\n        cnt[s[right]] += 1\n\n        while cnt[s[right]] &gt; 1:\n            cnt[s[left]] -= 1\n            left += 1\n\n        res = max(res, right - left + 1)\n\n    return res\n\n\n# Sliding Window Variable Max - Set\ndef lengthOfLongestSubstringSet(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    left = 0\n    res = 0\n    window = set()\n\n    for right in range(n):\n        while left &lt; right and s[right] in window:\n            window.remove(s[left])\n            left += 1\n        window.add(s[right])\n        res = max(res, right - left + 1)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    s = \"abcabcbb\"\n    assert lengthOfLongestSubstringHash(s) == 3\n    assert lengthOfLongestSubstringSet(s) == 3\n</code></pre> 3. Longest Substring Without Repeating Characters - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;unordered_set&gt;\nusing namespace std;\n\nint lengthOfLongestSubstring(string s) {\n    int n = s.length();\n    int res = 0;\n    int left = 0;\n    unordered_set&lt;char&gt; window;\n\n    for (int right = 0; right &lt; n; right++) {\n        char ch = s[right];\n\n        while (window.find(ch) != window.end()) {\n            window.erase(s[left]);\n            left++;\n        }\n\n        window.insert(ch);\n        res = max(res, right - left + 1);\n    }\n    return (int)res;\n}\n\nint main() {\n    string s = \"abcabcbb\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 3\n    s = \"bbbbb\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 1\n    s = \"pwwkew\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 3\n    return 0;\n}\n</code></pre>"},{"location":"content/neetcode150/sliding_window/#424-longest-repeating-character-replacement","title":"424. Longest Repeating Character Replacement","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window 424. Longest Repeating Character Replacement - Python Solution<pre><code>from collections import defaultdict\n\n\n# Sliding Window - Variable\ndef characterReplacement(s: str, k: int) -&gt; int:\n    left = 0\n    maxCount = 0\n    counts = defaultdict(int)\n    maxLen = 0\n\n    for right in range(len(s)):\n        counts[s[right]] += 1\n        maxCount = max(maxCount, counts[s[right]])\n\n        while right - left + 1 - maxCount &gt; k:\n            counts[s[left]] -= 1\n            left += 1\n\n        maxLen = max(maxLen, right - left + 1)\n\n    return maxLen\n\n\ns = \"ABAB\"\nk = 2\nprint(characterReplacement(s, k))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/sliding_window/#76-minimum-window-substring","title":"76. Minimum Window Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, sliding window 76. Minimum Window Substring - Python Solution<pre><code>from collections import Counter\n\n\ndef minWindow(s: str, t: str) -&gt; str:\n    if not t or not s:\n        return \"\"\n\n    counts = Counter(t)\n    required = len(counts)\n\n    left, right = 0, 0\n    formed = 0\n    window_counts = dict()\n\n    result = float(\"inf\"), None, None\n\n    while right &lt; len(s):\n        char = s[right]\n        window_counts[char] = window_counts.get(char, 0) + 1\n        if char in counts and window_counts[char] == counts[char]:\n            formed += 1\n\n        while left &lt;= right and formed == required:\n            char = s[left]\n            if right - left + 1 &lt; result[0]:\n                result = (right - left + 1, left, right)\n            window_counts[char] -= 1\n            if char in counts and window_counts[char] &lt; counts[char]:\n                formed -= 1\n            left += 1\n\n        right += 1\n\n    return \"\" if result[0] == float(\"inf\") else s[result[1] : result[2] + 1]\n\n\ns = \"ADOBECODEBANC\"\nt = \"ABC\"\nprint(minWindow(s, t))  # BANC\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/sliding_window/#567-permutation-in-string","title":"567. Permutation in String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, two pointers, string, sliding window 567. Permutation in String - Python Solution<pre><code>def checkInclusion(s1: str, s2: str) -&gt; bool:\n    if len(s1) &gt; len(s2):\n        return False\n\n    count1 = [0] * 26\n    count2 = [0] * 26\n\n    for i in range(len(s1)):\n        count1[ord(s1[i]) - ord(\"a\")] += 1\n        count2[ord(s2[i]) - ord(\"a\")] += 1\n\n    matches = 0\n    for i in range(26):\n        if count1[i] == count2[i]:\n            matches += 1\n\n    l = 0\n    for r in range(len(s1), len(s2)):\n        if matches == 26:\n            return True\n\n        index = ord(s2[r]) - ord(\"a\")\n        count2[index] += 1\n        if count1[index] == count2[index]:\n            matches += 1\n        elif count1[index] + 1 == count2[index]:\n            matches -= 1\n\n        index = ord(s2[l]) - ord(\"a\")\n        count2[index] -= 1\n        if count1[index] == count2[index]:\n            matches += 1\n        elif count1[index] - 1 == count2[index]:\n            matches -= 1\n\n        l += 1\n\n    return matches == 26\n\n\ns1 = \"ab\"\ns2 = \"eidba\"\nprint(checkInclusion(s1, s2))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/sliding_window/#239-sliding-window-maximum","title":"239. Sliding Window Maximum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, queue, sliding window, heap priority queue, monotonic queue 239. Sliding Window Maximum - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# Monotonic Queue\ndef maxSlidingWindow(nums: List[int], k: int) -&gt; List[int]:\n    q = deque()\n    res = []\n\n    for i, num in enumerate(nums):\n        if q and q[0] &lt; i - k + 1:\n            q.popleft()\n\n        while q and nums[q[-1]] &lt; num:\n            q.pop()\n\n        q.append(i)\n\n        if i &gt;= k - 1:\n            res.append(nums[q[0]])\n\n    return res\n\n\nnums = [1, 3, -1, -3, 5, 3, 6, 7]\nk = 3\nprint(maxSlidingWindow(nums, k))  # [3, 3, 5, 5, 6, 7]\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/stack/","title":"Stack","text":""},{"location":"content/neetcode150/stack/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 20. Valid Parentheses (Easy)</li> <li> 155. Min Stack (Medium)</li> <li> 150. Evaluate Reverse Polish Notation (Medium)</li> <li> 22. Generate Parentheses (Medium)</li> <li> 739. Daily Temperatures (Medium)</li> <li> 853. Car Fleet (Medium)</li> <li> 84. Largest Rectangle in Histogram (Hard)</li> </ul>"},{"location":"content/neetcode150/stack/#20-valid-parentheses","title":"20. Valid Parentheses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, stack</p> </li> <li>Determine if the input string is valid.</li> <li>Steps for the string <code>()[]{}</code>:</li> </ul> char action stack <code>(</code> push \"(\" <code>)</code> pop \"\" <code>[</code> push \"[\" <code>]</code> pop \"\" <code>{</code> push \"{\" <code>}</code> pop \"\" 20. Valid Parentheses - Python Solution<pre><code># Stack\ndef isValid(s: str) -&gt; bool:\n    hashmap = {\n        \")\": \"(\",\n        \"]\": \"[\",\n        \"}\": \"{\",\n    }\n    stack = []\n\n    for ch in s:\n        if ch in hashmap:\n            if stack and stack[-1] == hashmap[ch]:\n                stack.pop()\n            else:\n                return False\n        else:\n            stack.append(ch)\n\n    return True if not stack else False\n\n\nif __name__ == \"__main__\":\n    assert isValid(\"()[]{}\")\n    assert not isValid(\"(]\")\n    assert not isValid(\"([)]\")\n    assert isValid(\"{[]}\")\n    assert isValid(\"\")\n</code></pre> 20. Valid Parentheses - C++ Solution<pre><code>#include &lt;cassert&gt;\n#include &lt;stack&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool isValid(string s) {\n        unordered_map&lt;char, char&gt; map{{')', '('}, {'}', '{'}, {']', '['}};\n        stack&lt;char&gt; stack;\n        if (s.length() % 2 == 1) return false;\n\n        for (char&amp; ch : s) {\n            if (stack.empty() || map.find(ch) == map.end()) {\n                stack.push(ch);\n            } else {\n                if (map[ch] != stack.top()) {\n                    return false;\n                }\n                stack.pop();\n            }\n        }\n        return stack.empty();\n    }\n};\n\nint main() {\n    Solution s;\n    assert(s.isValid(\"()\") == true);\n    assert(s.isValid(\"()[]{}\") == true);\n    assert(s.isValid(\"(]\") == false);\n    assert(s.isValid(\"([)]\") == false);\n    assert(s.isValid(\"{[]}\") == true);\n    return 0;\n}\n</code></pre>"},{"location":"content/neetcode150/stack/#155-min-stack","title":"155. Min Stack","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: stack, design</p> </li> <li>Implement a stack that supports push, pop, top, and retrieving the minimum element in constant time.</li> </ul> 155. Min Stack - Python Solution<pre><code># Stack\nclass MinStack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, val: int) -&gt; None:\n        if self.stack:\n            self.stack.append((val, min(val, self.getMin())))\n        else:\n            self.stack.append((val, val))\n\n    def pop(self) -&gt; None:\n        self.stack.pop()\n\n    def top(self) -&gt; int:\n        return self.stack[-1][0]\n\n    def getMin(self) -&gt; int:\n        return self.stack[-1][1]\n\n\nobj = MinStack()\nobj.push(3)\nobj.push(2)\nobj.pop()\nprint(obj.top())  # 3\nprint(obj.getMin())  # 3\n</code></pre> 155. Min Stack - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;climits&gt;\n#include &lt;iostream&gt;\n#include &lt;stack&gt;\n#include &lt;utility&gt;\nusing namespace std;\n\nclass MinStack {\n    stack&lt;pair&lt;int, int&gt;&gt; st;\n\n   public:\n    MinStack() { st.emplace(0, INT_MAX); }\n\n    void push(int val) { st.emplace(val, min(getMin(), val)); }\n\n    void pop() { st.pop(); }\n\n    int top() { return st.top().first; }\n\n    int getMin() { return st.top().second; }\n};\n\nint main() {\n    MinStack minStack;\n    minStack.push(-2);\n    minStack.push(0);\n    minStack.push(-3);\n    cout &lt;&lt; minStack.getMin() &lt;&lt; endl;  // -3\n    minStack.pop();\n    cout &lt;&lt; minStack.top() &lt;&lt; endl;     // 0\n    cout &lt;&lt; minStack.getMin() &lt;&lt; endl;  // -2\n    return 0;\n}\n</code></pre>"},{"location":"content/neetcode150/stack/#150-evaluate-reverse-polish-notation","title":"150. Evaluate Reverse Polish Notation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, stack</p> </li> <li>Steps for the list <code>[\"2\", \"1\", \"+\", \"3\", \"*\"]</code>:</li> </ul> token action stack <code>2</code> push <code>[2]</code> <code>1</code> push <code>[2, 1]</code> <code>+</code> pop <code>[3]</code> <code>3</code> push <code>[3, 3]</code> <code>*</code> pop <code>[9]</code> 150. Evaluate Reverse Polish Notation - Python Solution<pre><code>from typing import List\n\n\n# Stack\ndef evalRPN(tokens: List[str]) -&gt; int:\n    stack = []\n\n    for c in tokens:\n        if c == \"+\":\n            stack.append(stack.pop() + stack.pop())\n        elif c == \"-\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(b - a)\n        elif c == \"*\":\n            stack.append(stack.pop() * stack.pop())\n        elif c == \"/\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(int(b / a))\n        else:\n            stack.append(int(c))\n\n    return stack[0]\n\n\nprint(evalRPN([\"2\", \"1\", \"+\", \"3\", \"*\"]))  # 9\nprint(evalRPN([\"4\", \"13\", \"5\", \"/\", \"-\"]))  # 2\nprint(evalRPN([\"18\"]))  # 18\nprint(evalRPN([\"4\", \"3\", \"-\"]))  # 1\n</code></pre>"},{"location":"content/neetcode150/stack/#22-generate-parentheses","title":"22. Generate Parentheses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming, backtracking 22. Generate Parentheses - Python Solution<pre><code>from typing import List\n\n\n# Backtracking\ndef generateParenthesis1(n: int) -&gt; List[str]:\n    path, res = [], []\n\n    def dfs(openN, closeN):\n        if openN == closeN == n:\n            res.append(\"\".join(path))\n            return\n\n        if openN &lt; n:\n            path.append(\"(\")\n            dfs(openN + 1, closeN)\n            path.pop()\n\n        if closeN &lt; openN:\n            path.append(\")\")\n            dfs(openN, closeN + 1)\n            path.pop()\n\n    dfs(0, 0)\n\n    return res\n\n\n# Backtracking\ndef generateParenthesis2(n: int) -&gt; List[str]:\n    m = n * 2\n    res, path = [], [\"\"] * m\n\n    def dfs(i, left):\n        if i == m:\n            res.append(\"\".join(path))\n            return\n\n        if left &lt; n:\n            path[i] = \"(\"\n            dfs(i + 1, left + 1)\n        if i - left &lt; left:\n            path[i] = \")\"\n            dfs(i + 1, left)\n\n    dfs(0, 0)\n    return res\n\n\nif __name__ == \"__main__\":\n    print(generateParenthesis1(3))\n    # ['((()))', '(()())', '(())()', '()(())', '()()()']\n    print(generateParenthesis2(3))\n    # ['((()))', '(()())', '(())()', '()(())', '()()()']\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/stack/#739-daily-temperatures","title":"739. Daily Temperatures","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, monotonic stack</p> </li> <li>Return an array <code>res</code> such that <code>res[i]</code> is the number of days you have to wait after the <code>ith</code> day to get a warmer temperature.</li> </ul> Index Temp &gt; stack last stack result 0 73 False <code>[ [73, 0] ]</code> 1 - 0 = 1 1 74 True <code>[ [74, 1] ]</code> 2 - 1 = 1 2 75 True <code>[ [75, 2] ]</code> 6 - 2 = 4 3 71 False <code>[ [75, 2], [71, 3] ]</code> 5 - 3 = 2 4 69 False <code>[ [75, 2], [71, 3], [69, 4] ]</code> 5 - 4 = 1 5 72 True <code>[ [75, 2], [72, 5] ]</code> 6 - 5 = 1 6 76 True <code>[ [76, 6] ]</code> 0 7 73 False <code>[[76, 6], [73, 7]]</code> 0 739. Daily Temperatures - Python Solution<pre><code>from typing import List\n\n\n# Monotonic Stack\ndef dailyTemperatures(temperatures: List[int]) -&gt; List[int]:\n    res = [0 for _ in range(len(temperatures))]\n    stack = []  # [temp, index]\n\n    for i, temp in enumerate(temperatures):\n        while stack and temp &gt; stack[-1][0]:\n            _, idx = stack.pop()\n            res[idx] = i - idx\n\n        stack.append([temp, i])\n\n    return res\n\n\nprint(dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73]))\n# [1, 1, 4, 2, 1, 1, 0, 0]\n</code></pre>"},{"location":"content/neetcode150/stack/#853-car-fleet","title":"853. Car Fleet","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, sorting, monotonic stack 853. Car Fleet - Python Solution<pre><code>from typing import List\n\n\n# Stack\ndef carFleet(target: int, position: List[int], speed: List[int]) -&gt; int:\n    cars = sorted(zip(position, speed), reverse=True)\n    stack = []\n\n    for p, s in cars:\n        time = (target - p) / s\n\n        if not stack or time &gt; stack[-1]:\n            stack.append(time)\n\n    return len(stack)\n\n\nprint(carFleet(12, [10, 8, 0, 5, 3], [2, 4, 1, 1, 3]))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/stack/#84-largest-rectangle-in-histogram","title":"84. Largest Rectangle in Histogram","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, stack, monotonic stack 84. Largest Rectangle in Histogram - Python Solution<pre><code>from typing import List\n\n\n# Monotonic Stack\ndef largestRectangleArea(heights: List[int]) -&gt; int:\n    stack = []\n    max_area = 0\n    n = len(heights)\n\n    for i in range(n + 1):\n        h = 0 if i == n else heights[i]\n\n        while stack and h &lt; heights[stack[-1]]:\n            height = heights[stack.pop()]\n            width = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, height * width)\n\n        stack.append(i)\n\n    return max_area\n\n\nprint(largestRectangleArea([2, 1, 5, 6, 2, 3]))  # 10\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/trees/","title":"Trees","text":""},{"location":"content/neetcode150/trees/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 226. Invert Binary Tree (Easy)</li> <li> 104. Maximum Depth of Binary Tree (Easy)</li> <li> 543. Diameter of Binary Tree (Easy)</li> <li> 110. Balanced Binary Tree (Easy)</li> <li> 100. Same Tree (Easy)</li> <li> 572. Subtree of Another Tree (Easy)</li> <li> 235. Lowest Common Ancestor of a Binary Search Tree (Medium)</li> <li> 102. Binary Tree Level Order Traversal (Medium)</li> <li> 199. Binary Tree Right Side View (Medium)</li> <li> 1448. Count Good Nodes in Binary Tree (Medium)</li> <li> 98. Validate Binary Search Tree (Medium)</li> <li> 230. Kth Smallest Element in a BST (Medium)</li> <li> 105. Construct Binary Tree from Preorder and Inorder Traversal (Medium)</li> <li> 124. Binary Tree Maximum Path Sum (Hard)</li> <li> 297. Serialize and Deserialize Binary Tree (Hard)</li> </ul>"},{"location":"content/neetcode150/trees/#226-invert-binary-tree","title":"226. Invert Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 226. Invert Binary Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef invertTreeRecursive(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    root.left, root.right = root.right, root.left\n\n    invertTreeRecursive(root.left)\n    invertTreeRecursive(root.right)\n\n    return root\n\n\n# Iterative\ndef invertTreeIterative(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    stack = [root]\n\n    while stack:\n        node = stack.pop()\n\n        node.left, node.right = node.right, node.left\n        if node.left:\n            stack.append(node.left)\n        if node.right:\n            stack.append(node.right)\n\n    return root\n\n\nroot = build([4, 2, 7, 1, 3, 6, 9])\nprint(root)\n#     __4__\n#    /     \\\n#   2       7\n#  / \\     / \\\n# 1   3   6   9\ninvertedRecursive = invertTreeRecursive(root)\nprint(invertedRecursive)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\nroot = build([4, 2, 7, 1, 3, 6, 9])\ninvertedIterative = invertTreeIterative(root)\nprint(invertedIterative)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/trees/#104-maximum-depth-of-binary-tree","title":"104. Maximum Depth of Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 104. Maximum Depth of Binary Tree - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef maxDepthRecursive(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    left = maxDepthRecursive(root.left)\n    right = maxDepthRecursive(root.right)\n\n    return 1 + max(left, right)\n\n\n# DFS\ndef maxDepthDFS(root: Optional[TreeNode]) -&gt; int:\n    res = 0\n\n    def dfs(node, cnt):\n        if node is None:\n            return\n        cnt += 1\n        nonlocal res\n        res = max(res, cnt)\n\n        dfs(node.left, cnt)\n        dfs(node.right, cnt)\n\n    dfs(root, 0)\n\n    return res\n\n\n# Iterative\ndef maxDepthIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n    res = 0\n\n    while q:\n        res += 1\n        n = len(q)\n\n        for _ in range(n):\n            node = q.popleft()\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    root = [1, 2, 2, 3, 4, None, None, None, None, 5]\n    root = build(root)\n    print(root)\n    #     ____1\n    #    /     \\\n    #   2__     2\n    #  /   \\\n    # 3     4\n    #      /\n    #     5\n    assert maxDepthRecursive(root) == 4\n    assert maxDepthDFS(root) == 4\n    assert maxDepthIterative(root) == 4\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/trees/#543-diameter-of-binary-tree","title":"543. Diameter of Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, binary tree 543. Diameter of Binary Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Tree DFS\nclass Solution:\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -&gt; int:\n        self.diameter = 0\n\n        def dfs(node):\n            if not node:\n                return 0\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n            self.diameter = max(self.diameter, left + right)\n\n            return 1 + max(left, right)\n\n        dfs(root)\n\n        return self.diameter\n\n\nroot = build([1, 2, 3, 4, 5])\nprint(root)\n#     __1\n#    /   \\\n#   2     3\n#  / \\\n# 4   5\nobj = Solution()\nprint(obj.diameterOfBinaryTree(root))  # 3\n</code></pre></p> </li> </ul> 543. Diameter of Binary Tree - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nint diameterOfBinaryTree(TreeNode* root) {\n    int diameter = 0;\n\n    auto dfs = [&amp;](auto&amp;&amp; self, TreeNode* node) -&gt; int {\n        if (!node) return 0;\n        int left = self(self, node-&gt;left);\n        int right = self(self, node-&gt;right);\n\n        diameter = max(diameter, left + right);\n\n        return 1 + max(left, right);\n    };\n\n    dfs(dfs, root);\n    return diameter;\n}\n\nint main() {\n    // [1, 2, 3, 4, 5]\n    TreeNode* root = new TreeNode(1);\n    root-&gt;left = new TreeNode(2);\n    root-&gt;right = new TreeNode(3);\n    root-&gt;left-&gt;left = new TreeNode(4);\n    root-&gt;left-&gt;right = new TreeNode(5);\n    cout &lt;&lt; diameterOfBinaryTree(root) &lt;&lt; endl;  // 3\n\n    return 0;\n}\n</code></pre>"},{"location":"content/neetcode150/trees/#110-balanced-binary-tree","title":"110. Balanced Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, binary tree 110. Balanced Binary Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef isBalanced(root: Optional[TreeNode]) -&gt; bool:\n    def getHeight(node):\n        if not node:\n            return 0\n\n        # post order\n        leftHeight = getHeight(node.left)\n        rightHeight = getHeight(node.right)\n\n        if leftHeight == -1 or rightHeight == -1:\n            return -1\n\n        if abs(leftHeight - rightHeight) &gt; 1:\n            return -1\n        else:\n            return 1 + max(leftHeight, rightHeight)\n\n    if getHeight(root) != -1:\n        return True\n    else:\n        return False\n\n\nroot = [3, 9, 20, None, None, 15, 7]\nroot = build(root)\nprint(root)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(isBalanced(root))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/trees/#100-same-tree","title":"100. Same Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 100. Same Tree - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# 1. Recursive\ndef isSameTreeRecursive(p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:\n    if not p and not q:\n        return True\n    elif not p or not q:\n        return False\n    elif p.val != q.val:\n        return False\n\n    return isSameTreeRecursive(p.left, q.left) and isSameTreeRecursive(\n        p.right, q.right\n    )\n\n\n# 2. Iterative with queue\ndef isSameTreeIterativeQueue(\n    p: Optional[TreeNode], q: Optional[TreeNode]\n) -&gt; bool:\n    queue = deque([(p, q)])\n\n    while queue:\n        p, q = queue.popleft()\n\n        if not p and not q:\n            continue\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n\n        queue.append((p.left, q.left))\n        queue.append((p.right, q.right))\n\n    return True\n\n\n# 3. Iterative with stack\ndef isSameTreeIterativeStack(\n    p: Optional[TreeNode], q: Optional[TreeNode]\n) -&gt; bool:\n    stack = [(p, q)]\n\n    while stack:\n        n1, n2 = stack.pop()\n\n        if not n1 and not n2:\n            continue\n        if not n1 or not n2:\n            return False\n        if n1.val != n2.val:\n            return False\n\n        stack.append((n1.left, n2.left))\n        stack.append((n1.right, n2.right))\n\n    return True\n\n\nif __name__ == \"__main__\":\n    p1 = build([1, 2, 3])\n    q1 = build([1, 2, 3])\n    p2 = build([1, 2])\n    q2 = build([1, None, 2])\n\n    assert isSameTreeRecursive(p1, q1) is True\n    assert isSameTreeRecursive(p2, q2) is False\n    assert isSameTreeIterativeQueue(p1, q1) is True\n    assert isSameTreeIterativeQueue(p2, q2) is False\n    assert isSameTreeIterativeStack(p1, q1) is True\n    assert isSameTreeIterativeStack(p2, q2) is False\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/trees/#572-subtree-of-another-tree","title":"572. Subtree of Another Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, string matching, binary tree, hash function 572. Subtree of Another Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# DFS - Tree\ndef isSubtree(root: Optional[TreeNode], subRoot: Optional[TreeNode]) -&gt; bool:\n    def isSameTree(p, q):\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n\n        return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)\n\n    if not root:\n        return False\n\n    return (\n        isSameTree(root, subRoot)\n        or isSubtree(root.left, subRoot)\n        or isSubtree(root.right, subRoot)\n    )\n\n\n# |------------|---------|----------|\n# | Approach   | Time    | Space    |\n# |------------|---------|----------|\n# | DFS        | O(n * m)| O(n)     |\n# |------------|---------|----------|\n\n\nroot = build([3, 4, 5, 1, 2, None, None, None, None, 0])\nsubRoot = build([4, 1, 2])\nprint(root)\n#     ____3\n#    /     \\\n#   4__     5\n#  /   \\\n# 1     2\n#      /\n#     0\nprint(subRoot)\n#   4\n#  / \\\n# 1   2\nprint(isSubtree(root, subRoot))  # False\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/trees/#235-lowest-common-ancestor-of-a-binary-search-tree","title":"235. Lowest Common Ancestor of a Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree 235. Lowest Common Ancestor of a Binary Search Tree - Python Solution<pre><code>from binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef lowestCommonAncestor(\n    root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n) -&gt; \"TreeNode\":\n    while root:\n        if root.val &gt; p.val and root.val &gt; q.val:\n            root = root.left\n        elif root.val &lt; p.val and root.val &lt; q.val:\n            root = root.right\n        else:\n            return root\n\n\nroot = [6, 2, 8, 0, 4, 7, 9, None, None, 3, 5]\nroot = build(root)\np = root.left\nq = root.right\nprint(root)\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\nprint(lowestCommonAncestor(root, p, q))\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/trees/#102-binary-tree-level-order-traversal","title":"102. Binary Tree Level Order Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, breadth first search, binary tree 102. Binary Tree Level Order Traversal - Python Solution<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef levelOrder(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        level = []\n        size = len(q)\n\n        for _ in range(size):\n            cur = q.popleft()\n            level.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(level)\n\n    return res\n\n\ntree = build([3, 9, 20, None, None, 15, 7])\nprint(tree)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(levelOrder(tree))  # [[3], [9, 20], [15, 7]]\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/trees/#199-binary-tree-right-side-view","title":"199. Binary Tree Right Side View","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 199. Binary Tree Right Side View - Python Solution<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Binary Tree BFS\ndef rightSideViewBFS(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        n = len(q)\n        for i in range(n):\n            node = q.popleft()\n            if i == n - 1:\n                res.append(node.val)\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return res\n\n\n# Binary Tree DFS\ndef rightSideViewDFS(root: Optional[TreeNode]) -&gt; List[int]:\n    \"\"\"\u540e\u5e8f\u904d\u5386\uff0c\u5148\u53f3\u540e\u5de6\uff0c\u9047\u5230\u7684\u7b2c\u4e00\u4e2a\u8282\u70b9\u5c31\u662f\u8be5\u6df1\u5ea6\u7684\u6700\u53f3\u4fa7\u8282\u70b9\"\"\"\n    ans = []\n\n    def dfs(node, depth):\n        if node is None:\n            return\n        if depth == len(ans):  # \u8fd9\u4e2a\u6df1\u5ea6\u9996\u6b21\u9047\u5230\n            ans.append(node.val)\n\n        dfs(node.right, depth + 1)\n        dfs(node.left, depth + 1)\n\n    dfs(root, 0)\n\n    return ans\n\n\nif __name__ == \"__main__\":\n    root = [1, 2, 2, 3, 4, None, 3, None, None, 5]\n    root = build(root)\n    print(root)\n    #     ____1\n    #    /     \\\n    #   2__     2\n    #  /   \\     \\\n    # 3     4     3\n    #      /\n    #     5\n    assert rightSideViewBFS(root) == [1, 2, 3, 5]\n    assert rightSideViewDFS(root) == [1, 2, 3, 5]\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/trees/#1448-count-good-nodes-in-binary-tree","title":"1448. Count Good Nodes in Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 1448. Count Good Nodes in Binary Tree - Python Solution<pre><code>from typing import List\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Tree\ndef goodNodes(root: TreeNode) -&gt; int:\n    def dfs(node, max_val):\n        if not node:\n            return 0\n\n        good = 1 if node.val &gt;= max_val else 0\n\n        max_val = max(max_val, node.val)\n\n        good += dfs(node.left, max_val)\n        good += dfs(node.right, max_val)\n\n        return good\n\n    return dfs(root, root.val)\n\n\nroot = build([3, 1, 4, 3, None, 1, 5])\nprint(root)\n#     3__\n#    /   \\\n#   1     4\n#  /     / \\\n# 3     1   5\nprint(goodNodes(root))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/trees/#98-validate-binary-search-tree","title":"98. Validate Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree 98. Validate Binary Search Tree - Python Solution<pre><code>from itertools import pairwise\nfrom math import inf\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef isValidBST1(root: Optional[TreeNode]) -&gt; bool:\n    inorder = []  # inorder traversal\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    for a, b in pairwise(inorder):\n        if a &gt;= b:\n            return False\n\n    return True\n\n\ndef isValidBST2(root: Optional[TreeNode]) -&gt; bool:\n    if not root:\n        return True\n    pre = -inf\n\n    def dfs(node):\n        if not node:\n            return True\n        if not dfs(node.left):\n            return False\n\n        nonlocal pre\n        if node.val &lt;= pre:\n            return False\n        pre = node.val\n\n        return dfs(node.right)\n\n    return dfs(root)\n\n\nif __name__ == \"__main__\":\n    root = [5, 1, 4, None, None, 3, 6]\n    root = build(root)\n    print(root)\n    #   5__\n    #  /   \\\n    # 1     4\n    #      / \\\n    #     3   6\n    assert not isValidBST1(root)  # [1, 5, 3, 4, 6]\n    assert not isValidBST2(root)  # [1, 5, 3, 4, 6]\n</code></pre></p> </li> </ul> 98. Validate Binary Search Tree - C++ Solution<pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   private:\n    vector&lt;int&gt; inorder;\n    bool check(vector&lt;int&gt; inorder) {\n        int n = inorder.size();\n        if (n &lt;= 1) return true;\n        for (int i = 1; i &lt; n; i++) {\n            if (inorder[i] &lt;= inorder[i - 1]) return false;\n        }\n        return true;\n    }\n\n   public:\n    bool isValidBST(TreeNode *root) {\n        auto dfs = [&amp;](auto &amp;&amp;self, TreeNode *node) -&gt; void {\n            if (!node) return;\n\n            self(self, node-&gt;left);\n            inorder.push_back(node-&gt;val);\n            self(self, node-&gt;right);\n        };\n\n        dfs(dfs, root);\n\n        return check(inorder);\n    }\n};\n\nint main() {\n    Solution s;\n    TreeNode *root = new TreeNode(2);\n    root-&gt;left = new TreeNode(1);\n    root-&gt;right = new TreeNode(3);\n    assert(s.isValidBST(root) == true);\n\n    root = new TreeNode(5);\n    root-&gt;left = new TreeNode(1);\n    root-&gt;right = new TreeNode(4);\n    root-&gt;right-&gt;left = new TreeNode(3);\n    root-&gt;right-&gt;right = new TreeNode(6);\n    assert(s.isValidBST(root) == false);\n\n    root = new TreeNode(5);\n    root-&gt;left = new TreeNode(4);\n    root-&gt;right = new TreeNode(6);\n    root-&gt;right-&gt;left = new TreeNode(3);\n    root-&gt;right-&gt;right = new TreeNode(7);\n    assert(s.isValidBST(root) == false);\n\n    return 0;\n}\n</code></pre>"},{"location":"content/neetcode150/trees/#230-kth-smallest-element-in-a-bst","title":"230. Kth Smallest Element in a BST","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree 230. Kth Smallest Element in a BST - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef kthSmallestRecursive(root: Optional[TreeNode], k: int) -&gt; int:\n    inorder = []\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n    return inorder[k - 1]\n\n\n# Iteratve\ndef kthSmallestIteratve(root: Optional[TreeNode], k: int) -&gt; int:\n    stack = []\n    while True:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        k -= 1\n        if not k:\n            return root.val\n        root = root.right\n\n\nif __name__ == \"__main__\":\n    root = build([3, 1, 4, None, 2])\n    k = 1\n    assert kthSmallestRecursive(root, k) == 1\n    assert kthSmallestIteratve(root, k) == 1\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/trees/#105-construct-binary-tree-from-preorder-and-inorder-traversal","title":"105. Construct Binary Tree from Preorder and Inorder Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, divide and conquer, tree, binary tree 105. Construct Binary Tree from Preorder and Inorder Traversal - Python Solution<pre><code>from typing import List, Optional\n\nfrom helper import TreeNode\n\n\ndef buildTree(preorder: List[int], inorder: List[int]) -&gt; Optional[TreeNode]:\n    \"\"\"\n    preorder  root left right  1  2  3\n    inorder   left root right  4  5  6\n    \"\"\"\n    if len(preorder) == 0:\n        return None\n\n    root_val = preorder[0]  # 1\n    root = TreeNode(root_val)\n\n    separator_idx = inorder.index(root_val)  # 5\n\n    left_inorder = inorder[:separator_idx]  # 4\n    right_inorder = inorder[separator_idx + 1 :]  # 6\n\n    left_preorder = preorder[1 : 1 + len(left_inorder)]  # 2\n    right_preorder = preorder[1 + len(left_inorder) :]  # 3\n\n    root.left = buildTree(left_preorder, left_inorder)\n    root.right = buildTree(right_preorder, right_inorder)\n\n    return root\n\n\npreorder = [3, 9, 20, 15, 7]\ninorder = [9, 3, 15, 20, 7]\nroot = buildTree(preorder, inorder)\nprint(root)\n#     3\n#    / \\\n#   9  20\n#     /  \\\n#    15   7\n</code></pre></p> </li> </ul> 105. Construct Binary Tree from Preorder and Inorder Traversal - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   public:\n    vector&lt;int&gt; preorder;\n    unordered_map&lt;int, int&gt; inorderMap;\n\n    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {\n        this-&gt;preorder = preorder;\n        for (size_t i = 0; i &lt; inorder.size(); i++) {\n            inorderMap[inorder[i]] = i;\n        }\n        return buildSubtree(0, 0, inorder.size() - 1);\n    }\n\n   private:\n    TreeNode* buildSubtree(int rootIndex, int left, int right) {\n        if (left &gt; right) return nullptr;\n\n        TreeNode* root = new TreeNode(preorder[rootIndex]);\n        int inorderIndex = inorderMap[preorder[rootIndex]];\n\n        root-&gt;left = buildSubtree(rootIndex + 1, left, inorderIndex - 1);\n        root-&gt;right = buildSubtree(rootIndex + (inorderIndex - left + 1),\n                                   inorderIndex + 1, right);\n\n        return root;\n    }\n};\n\nint main() {\n    vector&lt;int&gt; preorder = {3, 9, 20, 15, 7};\n    vector&lt;int&gt; inorder = {9, 3, 15, 20, 7};\n    Solution solution;\n    TreeNode* root = solution.buildTree(preorder, inorder);\n    cout &lt;&lt; root-&gt;val &lt;&lt; endl;                // 3\n    cout &lt;&lt; root-&gt;left-&gt;val &lt;&lt; endl;          // 9\n    cout &lt;&lt; root-&gt;right-&gt;val &lt;&lt; endl;         // 20\n    cout &lt;&lt; root-&gt;right-&gt;left-&gt;val &lt;&lt; endl;   // 15\n    cout &lt;&lt; root-&gt;right-&gt;right-&gt;val &lt;&lt; endl;  // 7\n    return 0;\n}\n</code></pre>"},{"location":"content/neetcode150/trees/#124-binary-tree-maximum-path-sum","title":"124. Binary Tree Maximum Path Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, tree, depth first search, binary tree 124. Binary Tree Maximum Path Sum - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef maxPathSum(root: Optional[TreeNode]) -&gt; int:\n    res = float(\"-inf\")\n\n    def dfs(node):\n        if not node:\n            return 0\n\n        leftMax = max(dfs(node.left), 0)\n        rightMax = max(dfs(node.right), 0)\n\n        cur = node.val + leftMax + rightMax\n        nonlocal res\n        res = max(res, cur)\n\n        return node.val + max(leftMax, rightMax)\n\n    dfs(root)\n\n    return res\n\n\nroot = build([-10, 9, 20, None, None, 15, 7])\nprint(root)\n#   -10___\n#  /      \\\n# 9       _20\n#        /   \\\n#       15    7\nprint(maxPathSum(root))  # 42\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/trees/#297-serialize-and-deserialize-binary-tree","title":"297. Serialize and Deserialize Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, tree, depth first search, breadth first search, design, binary tree 297. Serialize and Deserialize Binary Tree - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BFS\nclass BFS:\n    def serialize(self, root: Optional[TreeNode]) -&gt; str:\n        if not root:\n            return \"\"\n\n        res = []\n        q = deque([root])\n\n        while q:\n            node = q.popleft()\n\n            if node:\n                res.append(str(node.val))\n                q.append(node.left)\n                q.append(node.right)\n            else:\n                res.append(\"null\")\n\n        return \",\".join(res)\n\n    def deserialize(self, data: str) -&gt; Optional[TreeNode]:\n        if not data:\n            return None\n\n        nodes = data.split(\",\")\n        root = TreeNode(int(nodes[0]))\n        q = deque([root])\n        index = 1\n\n        while q:\n            node = q.popleft()\n\n            if nodes[index] != \"null\":\n                node.left = TreeNode(int(nodes[index]))\n                q.append(node.left)\n            index += 1\n\n            if nodes[index] != \"null\":\n                node.right = TreeNode(int(nodes[index]))\n                q.append(node.right)\n            index += 1\n\n        return root\n\n\n# DFS\nclass DFS:\n    def serialize(self, root: Optional[TreeNode]) -&gt; str:\n        def dfs(node):\n            if not node:\n                return [\"null\"]\n            return [str(node.val)] + dfs(node.left) + dfs(node.right)\n\n        return \",\".join(dfs(root))\n\n    def deserialize(self, data: str) -&gt; Optional[TreeNode]:\n        nodes = data.split(\",\")\n        self.index = 0\n\n        def dfs():\n            if nodes[self.index] == \"null\":\n                self.index += 1\n                return None\n\n            node = TreeNode(int(nodes[self.index]))\n            self.index += 1\n\n            node.left = dfs()\n            node.right = dfs()\n\n            return node\n\n        root = dfs()\n        return root\n\n\nroot = build([1, 2, 3, None, None, 4, 5])\nprint(root)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n\nbfs = BFS()\ndata1 = bfs.serialize(root)\nprint(data1)  # \"1,2,3,null,null,4,5,null,null,null,null\"\nroot1 = bfs.deserialize(data1)\nprint(root1)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n\ndfs = DFS()\ndata2 = dfs.serialize(root)\nprint(data2)  # \"1,2,null,null,3,4,null,null,5,null,null\"\nroot2 = dfs.deserialize(data2)\nprint(root2)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/tries/","title":"Tries","text":""},{"location":"content/neetcode150/tries/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 208. Implement Trie (Prefix Tree) (Medium)</li> <li> 211. Design Add and Search Words Data Structure (Medium)</li> <li> 212. Word Search II (Hard)</li> </ul>"},{"location":"content/neetcode150/tries/#208-implement-trie-prefix-tree","title":"208. Implement Trie (Prefix Tree)","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, design, trie</p> </li> </ul>"},{"location":"content/neetcode150/tries/#trie","title":"Trie","text":"<ul> <li>A trie is a tree-like data structure whose nodes store the letters of an alphabet.</li> </ul> <pre><code>flowchart TD\nRoot(( ))\nRoot --- C1((\"C\"))\nRoot --- D((D))\nC1 --- A1((\"A\"))\nA1 --- T1((\"T\"))\nA1 --- R1((\"R\"))\nA1 --- N((N))\nRoot --- B1((B))\nB1 --- A2((A))\nA2 --- T2((T))\nA2 --- R2((R))</code></pre> 208. Implement Trie (Prefix Tree) - Python Solution<pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.endOfWord = None\n\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.endOfWord = True\n\n    def search(self, word: str) -&gt; bool:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return node.endOfWord\n\n    def startsWith(self, prefix: str) -&gt; bool:\n        node = self.root\n\n        for c in prefix:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return True\n\n\n# Your Trie object will be instantiated and called as such:\nobj = Trie()\nobj.insert(\"apple\")\nprint(obj.search(\"word\"))  # False\nprint(obj.startsWith(\"app\"))  # True\n</code></pre>"},{"location":"content/neetcode150/tries/#211-design-add-and-search-words-data-structure","title":"211. Design Add and Search Words Data Structure","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, depth first search, design, trie 211. Design Add and Search Words Data Structure - Python Solution<pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.word = False\n\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.word = True\n\n    def search(self, word: str) -&gt; bool:\n\n        def dfs(j, root):\n            node = root\n\n            for i in range(j, len(word)):\n                c = word[i]\n\n                if c == \".\":\n                    for child in node.children.values():\n                        if dfs(i + 1, child):\n                            return True\n                    return False\n                else:\n                    if c not in node.children:\n                        return False\n                    node = node.children[c]\n            return node.word\n\n        return dfs(0, self.root)\n\n\n# Your WordDictionary object will be instantiated and called as such:\nobj = WordDictionary()\nobj.addWord(\"word\")\nprint(obj.search(\"word\"))\nprint(obj.search(\"w.rd\"))\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/tries/#212-word-search-ii","title":"212. Word Search II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, backtracking, trie, matrix 212. Word Search II - Python Solution<pre><code>from typing import List\n\nfrom template import TrieNode\n\n\n# Backtracking + Trie\ndef findWords(board: List[List[str]], words: List[str]) -&gt; List[str]:\n    root = TrieNode()\n    for word in words:\n        root.addWord(word)\n\n    m, n = len(board), len(board[0])\n    result, visit = set(), set()\n\n    def dfs(r, c, node, word):\n        if (\n            r &lt; 0\n            or r &gt;= m\n            or c &lt; 0\n            or c &gt;= n\n            or (r, c) in visit\n            or board[r][c] not in node.children\n        ):\n            return None\n\n        visit.add((r, c))\n\n        node = node.children[board[r][c]]\n        word += board[r][c]\n        if node.isWord:\n            result.add(word)\n\n        dfs(r - 1, c, node, word)\n        dfs(r + 1, c, node, word)\n        dfs(r, c - 1, node, word)\n        dfs(r, c + 1, node, word)\n\n        visit.remove((r, c))\n\n    for r in range(m):\n        for c in range(n):\n            dfs(r, c, root, \"\")\n\n    return list(result)\n\n\nboard = [\n    [\"o\", \"a\", \"a\", \"n\"],\n    [\"e\", \"t\", \"a\", \"e\"],\n    [\"i\", \"h\", \"k\", \"r\"],\n    [\"i\", \"f\", \"l\", \"v\"],\n]\nwords = [\"oath\", \"pea\", \"eat\", \"rain\"]\nprint(findWords(board, words))\n# ['eat', 'oath']\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/two_pointers/","title":"Two Pointers","text":""},{"location":"content/neetcode150/two_pointers/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 125. Valid Palindrome (Easy)</li> <li> 167. Two Sum II - Input Array Is Sorted (Medium)</li> <li> 15. 3Sum (Medium)</li> <li> 11. Container With Most Water (Medium)</li> <li> 42. Trapping Rain Water (Hard)</li> </ul>"},{"location":"content/neetcode150/two_pointers/#125-valid-palindrome","title":"125. Valid Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string 125. Valid Palindrome - Python Solution<pre><code># List Comprehension\ndef isPalindrome(s: str) -&gt; bool:\n    s = [char.lower() for char in s if char.isalnum()]\n    return s == s[::-1]\n\n\n# Left Right Pointers\ndef isPalindromeLR(s: str) -&gt; bool:\n    left, right = 0, len(s) - 1\n\n    while left &lt; right:\n        while left &lt; right and not s[left].isalnum():\n            left += 1\n        while left &lt; right and not s[right].isalnum():\n            right -= 1\n\n        if s[left].lower() != s[right].lower():\n            return False\n\n        left += 1\n        right -= 1\n\n    return True\n\n\ns = \"A man, a plan, a canal: Panama\"\nprint(isPalindrome(s))  # True\nprint(isPalindromeLR(s))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/two_pointers/#167-two-sum-ii-input-array-is-sorted","title":"167. Two Sum II - Input Array Is Sorted","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search 167. Two Sum II - Input Array Is Sorted - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef twoSum(numbers: List[int], target: int) -&gt; List[int]:\n    left, right = 0, len(numbers) - 1\n\n    while left &lt; right:\n        total = numbers[left] + numbers[right]\n\n        if total &gt; target:\n            right -= 1\n        elif total &lt; target:\n            left += 1\n        else:\n            return [left + 1, right + 1]\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nnumbers = [2, 7, 11, 15]\ntarget = 9\nprint(twoSum(numbers, target))  # [1, 2]\n</code></pre></p> </li> </ul>"},{"location":"content/neetcode150/two_pointers/#15-3sum","title":"15. 3Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, sorting 15. 3Sum - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef threeSum(nums: List[int]) -&gt; List[List[int]]:\n    nums.sort()\n    res = []\n    n = len(nums)\n\n    for i in range(n - 2):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        left, right = i + 1, n - 1\n\n        while left &lt; right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total &gt; 0:\n                right -= 1\n            elif total &lt; 0:\n                left += 1\n            else:\n                res.append([nums[i], nums[left], nums[right]])\n\n                while left &lt; right and nums[left] == nums[left + 1]:\n                    left += 1\n\n                while left &lt; right and nums[right] == nums[right - 1]:\n                    right -= 1\n\n                left += 1\n                right -= 1\n\n    return res\n\n\nnums = [-1, 0, 1, 2, -1, -4]\nassert threeSum(nums) == [[-1, -1, 2], [-1, 0, 1]]\n</code></pre></p> </li> </ul> 15. 3Sum - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {\n    sort(nums.begin(), nums.end());\n    vector&lt;vector&lt;int&gt;&gt; res;\n    int n = nums.size();\n\n    for (int i = 0; i &lt; n - 2; i++) {\n        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) {\n            continue;\n        }\n\n        int left = i + 1, right = n - 1;\n\n        while (left &lt; right) {\n            int total = nums[i] + nums[left] + nums[right];\n\n            if (total &gt; 0)\n                right--;\n            else if (total &lt; 0)\n                left++;\n            else {\n                res.push_back({nums[i], nums[left], nums[right]});\n                while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++;\n                while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--;\n                left++;\n                right--;\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {-1, 0, 1, 2, -1, -4};\n    vector&lt;vector&lt;int&gt;&gt; res = threeSum(nums);\n    for (auto&amp; v : res) {\n        for (int i : v) {\n            cout &lt;&lt; i &lt;&lt; \" \";\n        }\n        cout &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"content/neetcode150/two_pointers/#11-container-with-most-water","title":"11. Container With Most Water","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy</p> </li> <li>Return the maximum area of water that can be trapped between the vertical lines.</li> </ul> <p></p> 11. Container With Most Water - Python Solution<pre><code>from typing import List\n\n\n# Brute Force\ndef maxAreaBF(height: List[int]) -&gt; int:\n    max_area = 0\n\n    for i in range(len(height)):\n        for j in range(i + 1, len(height)):\n            h = min(height[i], height[j])\n            w = j - i\n            max_area = max(max_area, h * w)\n\n    return max_area\n\n\n# Left Right Pointers\ndef maxAreaLR(height: List[int]) -&gt; int:\n    left, right = 0, len(height) - 1\n    res = 0\n\n    while left &lt; right:\n        h = min(height[left], height[right])\n        w = right - left\n        res = max(res, h * w)\n\n        if height[left] &lt; height[right]:\n            left += 1\n        else:\n            right -= 1\n\n    return res\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force| O(n^2) |  O(1)   |\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nheight = [1, 8, 6, 2, 5, 4, 8, 3, 7]\nprint(maxAreaBF(height))  # 49\nprint(maxAreaLR(height))  # 49\n</code></pre> 11. Container With Most Water - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint maxArea(vector&lt;int&gt;&amp; height) {\n    int left = 0, right = height.size() - 1;\n    int res = 0;\n\n    while (left &lt; right) {\n        int h = min(height[left], height[right]);\n        int w = right - left;\n        res = max(res, h * w);\n\n        if (height[left] &lt; height[right])\n            left++;\n        else\n            right--;\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; height = {1, 8, 6, 2, 5, 4, 8, 3, 7};\n    cout &lt;&lt; maxArea(height) &lt;&lt; endl;  // 49\n    return 0;\n}\n</code></pre>"},{"location":"content/neetcode150/two_pointers/#42-trapping-rain-water","title":"42. Trapping Rain Water","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, dynamic programming, stack, monotonic stack</p> </li> <li></li> </ul> Approach Time Space DP O(N) O(N) Left Right O(N) O(1) Monotonic O(N) O(N) 42. Trapping Rain Water - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef trapDP(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    n = len(height)\n    maxLeft, maxRight = [0 for _ in range(n)], [0 for _ in range(n)]\n\n    for i in range(1, n):\n        maxLeft[i] = max(maxLeft[i - 1], height[i - 1])\n\n    for i in range(n - 2, -1, -1):\n        maxRight[i] = max(maxRight[i + 1], height[i + 1])\n\n    res = 0\n    for i in range(n):\n        res += max(0, min(maxLeft[i], maxRight[i]) - height[i])\n\n    return res\n\n\n# Left Right Pointers\ndef trapLR(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    left, right = 0, len(height) - 1\n    maxL, maxR = height[left], height[right]\n    res = 0\n\n    while left &lt; right:\n        if maxL &lt; maxR:\n            left += 1\n            maxL = max(maxL, height[left])\n            res += maxL - height[left]\n        else:\n            right -= 1\n            maxR = max(maxR, height[right])\n            res += maxR - height[right]\n\n    return res\n\n\n# Monotonic Stack\ndef trapStack(height: List[int]) -&gt; int:\n    stack = []\n    total = 0\n\n    for i in range(len(height)):\n        while stack and height[i] &gt; height[stack[-1]]:\n            top = stack.pop()\n            if not stack:\n                break\n            distance = i - stack[-1] - 1\n            bounded_height = min(height[i], height[stack[-1]]) - height[top]\n            total += distance * bounded_height\n        stack.append(i)\n\n    return total\n\n\nheight = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\nprint(trapDP(height))  # 6\nprint(trapLR(height))  # 6\nprint(trapStack(height))  # 6\n</code></pre> 42. Trapping Rain Water - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int trap(vector&lt;int&gt; &amp;height)\n    {\n        if (height.empty())\n            return 0;\n\n        int res = 0;\n        int left = 0, right = height.size() - 1;\n        int maxL = height[left], maxR = height[right];\n\n        while (left &lt; right)\n        {\n            if (maxL &lt; maxR)\n            {\n                left++;\n                maxL = max(maxL, height[left]);\n                res += maxL - height[left];\n            }\n            else\n            {\n                right--;\n                maxR = max(maxR, height[right]);\n                res += maxR - height[right];\n            }\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    vector&lt;int&gt; height = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};\n    Solution solution;\n    cout &lt;&lt; solution.trap(height) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/premium100/","title":"Premium 100","text":"<ul> <li> <p>Premium Algo 100</p> </li> <li> <p>Arrays / Strings</p> <ul> <li> 624. Maximum Distance in Arrays</li> <li> 280. Wiggle Sort</li> <li> 1056. Confusing Number</li> <li> 1427. Perform String Shifts</li> <li> 161. One Edit Distance</li> <li> 186. Reverse Words in a String II</li> <li> 1055. Shortest Way to Form String</li> </ul> </li> <li> <p>Sliding Window</p> <ul> <li> 159. Longest Substring with At Most Two Distinct Characters</li> <li> 340. Longest Substring with At Most K Distinct Characters</li> <li> 487. Max Consecutive Ones II</li> <li> 1100. Find K-Length Substrings With No Repeated Characters</li> </ul> </li> <li> <p>Hashing</p> <ul> <li> 760. Find Anagram Mappings</li> <li> 266. Palindrome Permutation</li> <li> 734. Sentence Similarity</li> <li> 1165. Single-Row Keyboard</li> <li> 249. Group Shifted Strings</li> <li> 1133. Largest Unique Number</li> <li> 1426. Counting Elements</li> <li> 1198. Find Smallest Common Element in All Rows</li> </ul> </li> <li> <p>Matrix</p> <ul> <li> 422. Valid Word Square</li> <li> 531. Lonely Pixel I</li> <li> 311. Sparse Matrix Multiplication</li> <li> 723. Candy Crush</li> </ul> </li> <li> <p>Interval Set</p> <ul> <li> 163. Missing Ranges</li> <li> 252. Meeting Rooms</li> <li> 253. Meeting Rooms II</li> <li> 616. Add Bold Tag in String</li> <li> 1272. Remove Interval</li> </ul> </li> <li> <p>Stack</p> <ul> <li> 439. Ternary Expression Parser</li> <li> 484. Find Permutation</li> <li> 772. Basic Calculator III</li> </ul> </li> <li> <p>Queue</p> <ul> <li> 346. Moving Average from Data Stream</li> <li> 1429. First Unique Number</li> </ul> </li> <li> <p>Linked List</p> <ul> <li> 1474. Delete N Nodes After M Nodes of a Linked List</li> <li> 708. Insert into a Sorted Circular Linked List</li> <li> 369. Plus One Linked List</li> <li> 1265. Print Immutable Linked List in Reverse</li> </ul> </li> <li> <p>Binary Tree</p> <ul> <li> 298. Binary Tree Longest Consecutive Sequence</li> <li> 549. Binary Tree Longest Consecutive Sequence II</li> <li> 250. Count Univalue Subtrees</li> <li> 1120. Maximum Average Subtree</li> <li> 545. Boundary of Binary Tree</li> <li> 366. Find Leaves of Binary Tree</li> <li> 314. Binary Tree Vertical Order Traversal</li> </ul> </li> <li> <p>Binary Search Tree</p> <ul> <li> 270. Closest Binary Search Tree Value</li> <li> 272. Closest Binary Search Tree Value II</li> <li> 255. Verify Preorder Sequence in Binary Search Tree</li> <li> 1214. Two Sum BSTs</li> <li> 333. Largest BST Subtree</li> </ul> </li> <li> <p>N-ary Tree</p> <ul> <li> 1490. Clone N-ary Tree</li> <li> 1506. Find Root of N-Ary Tree</li> <li> 1522. Diameter of N-Ary Tree</li> </ul> </li> <li> <p>Graph</p> <ul> <li> 277. Find the Celebrity</li> <li> 582. Kill Process</li> <li> 323. Number of Connected Components in an Undirected Graph</li> <li> 1059. All Paths from Source Lead to Destination</li> <li> 1236. Web Crawler</li> <li> 305. Number of Islands II</li> <li> 694. Number of Distinct Islands</li> <li> 1136. Parallel Courses</li> </ul> </li> <li> <p>Graph - Breadth-First Search</p> <ul> <li> 490. The Maze</li> <li> 505. The Maze II</li> <li> 499. The Maze III</li> <li> 1197. Minimum Knight Moves</li> <li> 286. Walls and Gates</li> <li> 317. Shortest Distance from All Buildings</li> <li> 269. Alien Dictionary</li> </ul> </li> <li> <p>Trie</p> <ul> <li> 588. Design In-Memory File System</li> <li> 642. Design Search Autocomplete System</li> </ul> </li> <li> <p>Heap</p> <ul> <li> 1086. High Five</li> <li> 1167. Minimum Cost to Connect Sticks</li> <li> 1057. Campus Bikes</li> <li> 358. Rearrange String k Distance Apart</li> </ul> </li> <li> <p>Binary Search</p> <ul> <li> 1228. Missing Number In Arithmetic Progression</li> <li> 1060. Missing Element in Sorted Array</li> <li> 1533. Find the Index of the Large Integer</li> <li> 1150. Check If a Number Is Majority Element in a Sorted Array</li> <li> 1231. Divide Chocolate</li> <li> 644. Maximum Average Subarray II</li> </ul> </li> <li> <p>Design</p> <ul> <li> 348. Design Tic-Tac-Toe</li> <li> 353. Design Snake Game</li> <li> 604. Design Compressed String Iterator</li> <li> 271. Encode and Decode Strings</li> <li> 281. Zigzag Iterator</li> <li> 716. Max Stack</li> <li> 1244. Design A Leaderboard</li> <li> 428. Serialize and Deserialize N-ary Tree</li> <li> 431. Encode N-ary Tree to Binary Tree</li> </ul> </li> <li> <p>Backtracking</p> <ul> <li> 247. Strobogrammatic Number II</li> <li> 254. Factor Combinations</li> <li> 1087. Brace Expansion</li> </ul> </li> <li> <p>Dynamic Programming</p> <ul> <li> 276. Paint Fence</li> <li> 256. Paint House</li> <li> 265. Paint House II</li> <li> 651. 4 Keys Keyboard</li> <li> 1259. Handshakes That Don't Cross</li> </ul> </li> <li> <p>Mathematics</p> <ul> <li> 1134. Armstrong Number</li> <li> 1180. Count Substrings with Only One Distinct Letter</li> <li> 1538. Guess the Majority in a Hidden Array</li> <li> 1183. Maximum Number of Ones</li> </ul> </li> </ul>"},{"location":"content/premium100/arrays_strings/","title":"Arrays Strings","text":""},{"location":"content/premium100/arrays_strings/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 624. Maximum Distance in Arrays (Medium)</li> <li> 280. Wiggle Sort (Medium) \ud83d\udc51</li> <li> 1056. Confusing Number (Easy) \ud83d\udc51</li> <li> 1427. Perform String Shifts (Easy) \ud83d\udc51</li> <li> 161. One Edit Distance (Medium) \ud83d\udc51</li> <li> 186. Reverse Words in a String II (Medium) \ud83d\udc51</li> <li> 1055. Shortest Way to Form String (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/premium100/arrays_strings/#624-maximum-distance-in-arrays","title":"624. Maximum Distance in Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy 624. Maximum Distance in Arrays - Python Solution<pre><code>from typing import List\n\n\n# Array\ndef maxDistance(arrays: List[List[int]]) -&gt; int:\n    mn, mx = float(\"inf\"), float(\"-inf\")\n    res = 0\n\n    for arr in arrays:\n        res = max(res, arr[-1] - mn, mx - arr[0])\n        mn = min(mn, arr[0])\n        mx = max(mx, arr[-1])\n\n    return res\n\n\narrays = [[1, 2, 3], [4, 5], [1, 2, 3]]\nprint(maxDistance(arrays))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/premium100/arrays_strings/#280-wiggle-sort","title":"280. Wiggle Sort","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting 280. Wiggle Sort - Python Solution<pre><code>from typing import List\n\n\ndef wiggleSort(nums: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    n = len(nums)\n    for i in range(n - 1):\n        if i % 2 == 0:\n            if nums[i] &gt; nums[i + 1]:\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]\n        else:\n            if nums[i] &lt; nums[i + 1]:\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]\n\n\nnum = [3, 5, 2, 1, 6, 4]\nwiggleSort(num)\nprint(num)  # [3, 5, 1, 6, 2, 4]\n</code></pre></p> </li> </ul> 280. Wiggle Sort - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvoid wiggleSort(vector&lt;int&gt;&amp; nums) {\n    int n = nums.size();\n\n    for (int i = 0; i &lt; n - 1; i++) {\n        if (i % 2 == 0) {\n            if (nums[i] &gt; nums[i + 1]) swap(nums[i], nums[i + 1]);\n        } else {\n            if (nums[i] &lt; nums[i + 1]) swap(nums[i], nums[i + 1]);\n        }\n    }\n}\n\nint main() {\n    vector&lt;int&gt; nums = {3, 5, 2, 1, 6, 4};\n    wiggleSort(nums);\n    // 3 5 1 6 2 4\n    for (size_t i = 0; i &lt; nums.size(); i++) {\n        cout &lt;&lt; nums[i] &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/premium100/arrays_strings/#1056-confusing-number","title":"1056. Confusing Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math 1056. Confusing Number - Python Solution<pre><code>def confusingNumber(n: int) -&gt; bool:\n    rotate_map = {\"0\": \"0\", \"1\": \"1\", \"6\": \"9\", \"8\": \"8\", \"9\": \"6\"}\n    original = str(n)\n    rotated = \"\"\n\n    for ch in reversed(original):\n        if ch not in rotate_map:\n            return False\n        rotated += rotate_map[ch]\n\n    return rotated != original\n\n\nif __name__ == \"__main__\":\n    print(confusingNumber(6))  # True\n    print(confusingNumber(89))  # True\n    print(confusingNumber(11))  # False\n</code></pre></p> </li> </ul> 1056. Confusing Number - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool confusingNumber(int n) {\n        static const unordered_map&lt;char, char&gt; rotationMap = {\n            {'0', '0'}, {'1', '1'}, {'6', '9'}, {'8', '8'}, {'9', '6'}};\n\n        string numStr = to_string(n);\n        string rotated;\n        rotated.reserve(numStr.size());\n\n        for (int i = numStr.size() - 1; i &gt;= 0; --i) {\n            char currentDigit = numStr[i];\n\n            auto it = rotationMap.find(currentDigit);\n            if (it == rotationMap.end()) {\n                return false;\n            }\n\n            rotated.push_back(it-&gt;second);\n        }\n\n        return rotated != numStr;\n    }\n};\n\nint main() {\n    Solution sol;\n    cout &lt;&lt; boolalpha;  // Print boolean values as true/false\n    cout &lt;&lt; sol.confusingNumber(6) &lt;&lt; endl;    // true\n    cout &lt;&lt; sol.confusingNumber(89) &lt;&lt; endl;   // true\n    cout &lt;&lt; sol.confusingNumber(11) &lt;&lt; endl;   // false\n    cout &lt;&lt; sol.confusingNumber(25) &lt;&lt; endl;   // false\n    cout &lt;&lt; sol.confusingNumber(916) &lt;&lt; endl;  // true\n    cout &lt;&lt; sol.confusingNumber(101) &lt;&lt; endl;  // false\n\n    return 0;\n}\n</code></pre>"},{"location":"content/premium100/arrays_strings/#1427-perform-string-shifts","title":"1427. Perform String Shifts","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, math, string</p> </li> <li>Calculate the net shift direction and amount by combining all operations, then apply a single rotation to the string using slicing.</li> </ul> 1427. Perform String Shifts - Python Solution<pre><code>from typing import List\n\n\ndef stringShift(s: str, shift: List[List[int]]) -&gt; str:\n    total_shift = 0\n    for direction, amount in shift:\n        if direction == 0:\n            total_shift -= amount\n        else:\n            total_shift += amount\n\n    total_shift %= len(s)\n\n    if total_shift == 0:\n        return s\n\n    if total_shift &gt; 0:\n        return s[-total_shift:] + s[:-total_shift]\n    else:\n        total_shift = abs(total_shift)\n        return s[total_shift:] + s[:total_shift]\n</code></pre> 1427. Perform String Shifts - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Solution {\n   public:\n    string stringShift(string s, vector&lt;vector&lt;int&gt;&gt;&amp; shift) {\n        int total_shift = 0;\n        for (const auto&amp; op : shift) {\n            if (op[0] == 0) {\n                total_shift -= op[1];\n            } else {\n                total_shift += op[1];\n            }\n        }\n\n        int n = s.length();\n        total_shift =\n            ((total_shift % n) + n) % n;  // Handle negative shift properly\n\n        if (total_shift == 0) {\n            return s;\n        }\n\n        return s.substr(n - total_shift) + s.substr(0, n - total_shift);\n    }\n};\n\nint main() {\n    Solution solution;\n\n    string s1 = \"abc\";\n    vector&lt;vector&lt;int&gt;&gt; shift1 = {{0, 1}, {1, 2}};\n    cout &lt;&lt; \"Input: s = \\\"abc\\\", shift = [[0,1],[1,2]]\" &lt;&lt; endl;\n    cout &lt;&lt; \"Output: \" &lt;&lt; solution.stringShift(s1, shift1) &lt;&lt; endl;\n\n    string s2 = \"abcdefg\";\n    vector&lt;vector&lt;int&gt;&gt; shift2 = {{1, 1}, {1, 1}, {0, 2}, {1, 3}};\n    cout &lt;&lt; \"Input: s = \\\"abcdefg\\\", shift = [[1,1],[1,1],[0,2],[1,3]]\" &lt;&lt; endl;\n    cout &lt;&lt; \"Output: \" &lt;&lt; solution.stringShift(s2, shift2) &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"content/premium100/arrays_strings/#161-one-edit-distance","title":"161. One Edit Distance","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string</p> </li> </ul>"},{"location":"content/premium100/arrays_strings/#186-reverse-words-in-a-string-ii","title":"186. Reverse Words in a String II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string</p> </li> </ul>"},{"location":"content/premium100/arrays_strings/#1055-shortest-way-to-form-string","title":"1055. Shortest Way to Form String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string, binary search, greedy</p> </li> </ul>"},{"location":"content/premium100/backtracking/","title":"Backtracking","text":""},{"location":"content/premium100/backtracking/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 247. Strobogrammatic Number II (Medium) \ud83d\udc51</li> <li> 254. Factor Combinations (Medium) \ud83d\udc51</li> <li> 1087. Brace Expansion (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/premium100/backtracking/#247-strobogrammatic-number-ii","title":"247. Strobogrammatic Number II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, recursion</p> </li> </ul>"},{"location":"content/premium100/backtracking/#254-factor-combinations","title":"254. Factor Combinations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: backtracking</p> </li> </ul>"},{"location":"content/premium100/backtracking/#1087-brace-expansion","title":"1087. Brace Expansion","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, backtracking, breadth first search</p> </li> </ul>"},{"location":"content/premium100/binary_search/","title":"Binary Search","text":""},{"location":"content/premium100/binary_search/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1228. Missing Number In Arithmetic Progression (Easy) \ud83d\udc51</li> <li> 1060. Missing Element in Sorted Array (Medium) \ud83d\udc51</li> <li> 1533. Find the Index of the Large Integer (Medium) \ud83d\udc51</li> <li> 1150. Check If a Number Is Majority Element in a Sorted Array (Easy) \ud83d\udc51</li> <li> 1231. Divide Chocolate (Hard) \ud83d\udc51</li> <li> 644. Maximum Average Subarray II (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/premium100/binary_search/#1228-missing-number-in-arithmetic-progression","title":"1228. Missing Number In Arithmetic Progression","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, math 1228. Missing Number In Arithmetic Progression - Python Solution<pre><code>from typing import List\n\n\ndef missingNumber(arr: List[int]) -&gt; int:\n    n = len(arr)\n    s1 = (arr[0] + arr[-1]) * (n + 1) // 2\n    s2 = sum(arr)\n    return s1 - s2\n\n\n# Binary Search\ndef missingNumberBS(arr: List[int]) -&gt; int:\n    n = len(arr)\n    diff = (arr[-1] - arr[0]) // n\n\n    left, right = 0, n - 1\n\n    while left &lt; right:\n        mid = left + (right - left) // 2\n        if arr[mid] == arr[0] + mid * diff:\n            left = mid + 1\n        else:\n            right = mid\n\n    return arr[0] + left * diff\n\n\nif __name__ == \"__main__\":\n    assert missingNumber([5, 7, 11, 13]) == 9\n    assert missingNumber([15, 13, 12]) == 14\n    assert missingNumber([1, 3]) == 2\n    assert missingNumberBS([5, 7, 11, 13]) == 9\n    assert missingNumberBS([15, 13, 12]) == 14\n    assert missingNumberBS([1, 3]) == 2\n</code></pre></p> </li> </ul>"},{"location":"content/premium100/binary_search/#1060-missing-element-in-sorted-array","title":"1060. Missing Element in Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"content/premium100/binary_search/#1533-find-the-index-of-the-large-integer","title":"1533. Find the Index of the Large Integer","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, interactive</p> </li> </ul>"},{"location":"content/premium100/binary_search/#1150-check-if-a-number-is-majority-element-in-a-sorted-array","title":"1150. Check If a Number Is Majority Element in a Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"content/premium100/binary_search/#1231-divide-chocolate","title":"1231. Divide Chocolate","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"content/premium100/binary_search/#644-maximum-average-subarray-ii","title":"644. Maximum Average Subarray II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, prefix sum</p> </li> </ul>"},{"location":"content/premium100/binary_search_tree/","title":"Binary Search Tree","text":""},{"location":"content/premium100/binary_search_tree/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 270. Closest Binary Search Tree Value (Easy) \ud83d\udc51</li> <li> 272. Closest Binary Search Tree Value II (Hard) \ud83d\udc51</li> <li> 255. Verify Preorder Sequence in Binary Search Tree (Medium) \ud83d\udc51</li> <li> 1214. Two Sum BSTs (Medium) \ud83d\udc51</li> <li> 333. Largest BST Subtree (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/premium100/binary_search_tree/#270-closest-binary-search-tree-value","title":"270. Closest Binary Search Tree Value","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: binary search, tree, depth first search, binary search tree, binary tree</p> </li> </ul>"},{"location":"content/premium100/binary_search_tree/#272-closest-binary-search-tree-value-ii","title":"272. Closest Binary Search Tree Value II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: two pointers, stack, tree, depth first search, binary search tree, heap priority queue, binary tree</p> </li> </ul>"},{"location":"content/premium100/binary_search_tree/#255-verify-preorder-sequence-in-binary-search-tree","title":"255. Verify Preorder Sequence in Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, tree, binary search tree, recursion, monotonic stack, binary tree 255. Verify Preorder Sequence in Binary Search Tree - Python Solution<pre><code>from typing import List\n\n\n# BST\ndef verifyPreorder(preorder: List[int]) -&gt; bool:\n    stack = []\n    low = float(\"-inf\")\n\n    for value in preorder:\n        if value &lt; low:\n            return False\n        while stack and value &gt; stack[-1]:\n            low = stack.pop()\n        stack.append(value)\n\n    return True\n\n\nif __name__ == \"__main__\":\n    assert verifyPreorder([8, 5, 1, 7, 10, 12]) is True\n    assert verifyPreorder([8, 5, 4, 3, 2, 1]) is True\n</code></pre></p> </li> </ul>"},{"location":"content/premium100/binary_search_tree/#1214-two-sum-bsts","title":"1214. Two Sum BSTs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, binary search, stack, tree, depth first search, binary search tree, binary tree</p> </li> </ul>"},{"location":"content/premium100/binary_search_tree/#333-largest-bst-subtree","title":"333. Largest BST Subtree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming, tree, depth first search, binary search tree, binary tree</p> </li> </ul>"},{"location":"content/premium100/binary_tree/","title":"Binary Tree","text":""},{"location":"content/premium100/binary_tree/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 298. Binary Tree Longest Consecutive Sequence (Medium) \ud83d\udc51</li> <li> 549. Binary Tree Longest Consecutive Sequence II (Medium) \ud83d\udc51</li> <li> 250. Count Univalue Subtrees (Medium) \ud83d\udc51</li> <li> 1120. Maximum Average Subtree (Medium) \ud83d\udc51</li> <li> 545. Boundary of Binary Tree (Medium) \ud83d\udc51</li> <li> 366. Find Leaves of Binary Tree (Medium) \ud83d\udc51</li> <li> 314. Binary Tree Vertical Order Traversal (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/premium100/binary_tree/#298-binary-tree-longest-consecutive-sequence","title":"298. Binary Tree Longest Consecutive Sequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree 298. Binary Tree Longest Consecutive Sequence - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Binary Tree\ndef longestConsecutive(root: Optional[TreeNode]) -&gt; int:\n    res = 0\n\n    def dfs(node):\n        if not node:\n            return 0\n\n        left, right = dfs(node.left), dfs(node.right)\n        cur = 1\n        if node.left and node.left.val == (node.val + 1):\n            cur = max(cur, left + 1)\n        if node.right and node.right.val == (node.val + 1):\n            cur = max(cur, right + 1)\n\n        nonlocal res\n        res = max(res, cur)\n        return cur\n\n    dfs(root)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    root = build([1, 3, 2, 4, None, None, None, 5])\n    print(root)\n    #       1\n    #      / \\\n    #     3   2\n    #    /\n    #   4\n    #  /\n    # 5\n    print(longestConsecutive(root))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/premium100/binary_tree/#549-binary-tree-longest-consecutive-sequence-ii","title":"549. Binary Tree Longest Consecutive Sequence II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/premium100/binary_tree/#250-count-univalue-subtrees","title":"250. Count Univalue Subtrees","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/premium100/binary_tree/#1120-maximum-average-subtree","title":"1120. Maximum Average Subtree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/premium100/binary_tree/#545-boundary-of-binary-tree","title":"545. Boundary of Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"content/premium100/binary_tree/#366-find-leaves-of-binary-tree","title":"366. Find Leaves of Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree 366. Find Leaves of Binary Tree - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef findLeaves(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    depths = defaultdict(list)\n\n    def dfs(node):\n        if not node:\n            return 0\n        l, r = dfs(node.left), dfs(node.right)\n        depth = 1 + max(l, r)\n        depths[depth].append(node.val)\n        return depth\n\n    dfs(root)\n    return [i for i in depths.values()]\n\n\nif __name__ == \"__main__\":\n    root = build([1, 2, 3, 4, 5])\n    print(root)\n    #     __1\n    #    /   \\\n    #   2     3\n    #  / \\\n    # 4   5\n    print(findLeaves(root))  # [[4, 5, 3], [2], [1]]\n</code></pre></p> </li> </ul>"},{"location":"content/premium100/binary_tree/#314-binary-tree-vertical-order-traversal","title":"314. Binary Tree Vertical Order Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, tree, depth first search, breadth first search, sorting, binary tree</p> </li> </ul>"},{"location":"content/premium100/design/","title":"Design","text":""},{"location":"content/premium100/design/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 348. Design Tic-Tac-Toe (Medium) \ud83d\udc51</li> <li> 353. Design Snake Game (Medium) \ud83d\udc51</li> <li> 604. Design Compressed String Iterator (Easy) \ud83d\udc51</li> <li> 271. Encode and Decode Strings (Medium) \ud83d\udc51</li> <li> 281. Zigzag Iterator (Medium) \ud83d\udc51</li> <li> 716. Max Stack (Hard) \ud83d\udc51</li> <li> 1244. Design A Leaderboard (Medium) \ud83d\udc51</li> <li> 428. Serialize and Deserialize N-ary Tree (Hard) \ud83d\udc51</li> <li> 431. Encode N-ary Tree to Binary Tree (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/premium100/design/#348-design-tic-tac-toe","title":"348. Design Tic-Tac-Toe","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, design, matrix, simulation</p> </li> </ul>"},{"location":"content/premium100/design/#353-design-snake-game","title":"353. Design Snake Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, design, queue, simulation 353. Design Snake Game - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\nclass SnakeGame:\n\n    def __init__(self, width: int, height: int, food: List[List[int]]):\n        self.width = width\n        self.height = height\n        self.food = deque(food)\n        self.snake = deque([(0, 0)])  # Snake starts at the top-left corner\n        self.snake_body = set([(0, 0)])  # To quickly check for collisions\n        self.score = 0\n        self.dirs = {\"U\": (-1, 0), \"L\": (0, -1), \"R\": (0, 1), \"D\": (1, 0)}\n\n    def move(self, direction: str) -&gt; int:\n        head = self.snake[0]\n        dx, dy = self.dirs[direction]\n        new_head = (head[0] + dx, head[1] + dy)\n\n        # Check if the new head is out of bounds\n        if not (\n            0 &lt;= new_head[0] &lt; self.height and 0 &lt;= new_head[1] &lt; self.width\n        ):\n            return -1\n\n        # Check if the new head collides with the snake body (excluding the tail)\n        if new_head in self.snake_body and new_head != self.snake[-1]:\n            return -1\n\n        # Check if the new head is on a food cell\n        if self.food and self.food[0] == list(new_head):\n            self.food.popleft()\n            self.score += 1\n        else:\n            tail = self.snake.pop()\n            self.snake_body.remove(tail)\n\n        # Add the new head to the snake\n        self.snake.appendleft(new_head)\n        self.snake_body.add(new_head)\n\n        return self.score\n\n\nsnake = SnakeGame(3, 2, [[1, 2], [0, 1]])\nprint(snake.move(\"R\"))  # 0\nprint(snake.move(\"D\"))  # 0\nprint(snake.move(\"R\"))  # 1\nprint(snake.move(\"U\"))  # 1\nprint(snake.move(\"L\"))  # 2\nprint(snake.move(\"U\"))  # -1\n</code></pre></p> </li> </ul>"},{"location":"content/premium100/design/#604-design-compressed-string-iterator","title":"604. Design Compressed String Iterator","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, string, design, iterator</p> </li> </ul>"},{"location":"content/premium100/design/#271-encode-and-decode-strings","title":"271. Encode and Decode Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, design 271. Encode and Decode Strings - Python Solution<pre><code>from typing import List\n\n\nclass Codec:\n    def encode(self, strs: List[str]) -&gt; str:\n        \"\"\"Encodes a list of strings to a single string.\"\"\"\n        encoded = \"\"\n\n        for s in strs:\n            encoded += str(len(s)) + \"#\" + s\n\n        return encoded\n\n    def decode(self, s: str) -&gt; List[str]:\n        \"\"\"Decodes a single string to a list of strings.\"\"\"\n        decoded = []\n        i = 0\n\n        while i &lt; len(s):\n            j = i\n            while s[j] != \"#\":\n                j += 1\n\n            strLen = int(s[i:j])\n            decoded.append(s[j + 1 : j + 1 + strLen])\n            i = j + 1 + strLen\n\n        return decoded\n\n\n# |-------------|-------------|--------------|\n# |   Approach  |    Time     |    Space     |\n# |-------------|-------------|--------------|\n# | Two pointers|    O(n)     |     O(n)     |\n# |-------------|-------------|--------------|\n\n\ncodec = Codec()\nencoded = codec.encode([\"hello\", \"world\"])\nprint(encoded)  # \"5#hello5#world\"\ndecoded = codec.decode(encoded)\nprint(decoded)  # [\"hello\", \"world\"]\n</code></pre></p> </li> </ul>"},{"location":"content/premium100/design/#281-zigzag-iterator","title":"281. Zigzag Iterator","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, design, queue, iterator</p> </li> </ul>"},{"location":"content/premium100/design/#716-max-stack","title":"716. Max Stack","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: linked list, stack, design, doubly linked list, ordered set</p> </li> </ul>"},{"location":"content/premium100/design/#1244-design-a-leaderboard","title":"1244. Design A Leaderboard","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, design, sorting 1244. Design A Leaderboard - Python Solution<pre><code>class Leaderboard:\n\n    def __init__(self):\n        self.scores = {}\n\n    def addScore(self, playerId: int, score: int) -&gt; None:\n        if playerId in self.scores:\n            self.scores[playerId] += score\n        else:\n            self.scores[playerId] = score\n\n    def top(self, K: int) -&gt; int:\n        topK = sorted(self.scores.values(), reverse=True)[:K]\n        return sum(topK)\n\n    def reset(self, playerId: int) -&gt; None:\n        if playerId in self.scores:\n            self.scores[playerId] = 0\n\n\nboard = Leaderboard()\nboard.addScore(1, 73)\nboard.addScore(2, 56)\nboard.addScore(3, 39)\nboard.addScore(4, 51)\nprint(board.top(1))  # 73\nboard.reset(1)\nboard.reset(2)\nprint(board.top(2))  # 90\n</code></pre></p> </li> </ul>"},{"location":"content/premium100/design/#428-serialize-and-deserialize-n-ary-tree","title":"428. Serialize and Deserialize N-ary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, tree, depth first search, breadth first search 428. Serialize and Deserialize N-ary Tree - Python Solution<pre><code>from typing import List, Optional\n\n\nclass Node(object):\n    def __init__(\n        self,\n        val: Optional[int] = None,\n        children: Optional[List[\"Node\"]] = None,\n    ):\n        if children is None:\n            children = []\n        self.val = val\n        self.children = children\n\n\n# DFS\nclass CodecDFS:\n    def serialize(self, root: \"Node\") -&gt; str:\n        \"\"\"Encodes a tree to a single string.\n\n        :type root: Node\n        :rtype: str\n        \"\"\"\n        if not root:\n            return \"*\"\n\n        data = \"\"\n        data += str(root.val) + \"|\" + str(len(root.children))\n        for child in root.children:\n            data += \"|\" + self.serialize(child)\n        return data\n\n    def deserialize(self, data: str) -&gt; \"Node\":\n        \"\"\"Decodes your encoded data to tree.\n\n        :type data: str\n        :rtype: Node\n        \"\"\"\n        if data == \"*\":\n            return None\n\n        data = data.split(\"|\")[::-1]\n\n        def dfs(data):\n            root = Node(int(data.pop()))\n            size = int(data.pop())\n            for i in range(size):\n                root.children.append(dfs(data))\n            return root\n\n        return dfs(data)\n\n\nif __name__ == \"__main__\":\n    obj = CodecDFS()\n    root = Node(1, [Node(3, [Node(5), Node(6)]), Node(2), Node(4)])\n    data = obj.serialize(root)\n    print(data)  # 1|3|3|2|5|0|6|0|2|0|4|0\n    root = obj.deserialize(data)\n    print(root.val)  # 1\n    print(root.children[0].val)  # 3\n    print(root.children[1].val)  # 2\n    print(root.children[2].val)  # 4\n    print(root.children[0].children[0].val)  # 5\n</code></pre></p> </li> </ul>"},{"location":"content/premium100/design/#431-encode-n-ary-tree-to-binary-tree","title":"431. Encode N-ary Tree to Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, design, binary tree</p> </li> </ul>"},{"location":"content/premium100/dynamic_programming/","title":"Dynamic Programming","text":""},{"location":"content/premium100/dynamic_programming/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 276. Paint Fence (Medium) \ud83d\udc51</li> <li> 256. Paint House (Medium) \ud83d\udc51</li> <li> 265. Paint House II (Hard) \ud83d\udc51</li> <li> 651. 4 Keys Keyboard (Medium) \ud83d\udc51</li> <li> 1259. Handshakes That Don't Cross (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/premium100/dynamic_programming/#276-paint-fence","title":"276. Paint Fence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming</p> </li> </ul>"},{"location":"content/premium100/dynamic_programming/#256-paint-house","title":"256. Paint House","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/premium100/dynamic_programming/#265-paint-house-ii","title":"265. Paint House II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"content/premium100/dynamic_programming/#651-4-keys-keyboard","title":"651. 4 Keys Keyboard","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming</p> </li> </ul>"},{"location":"content/premium100/dynamic_programming/#1259-handshakes-that-dont-cross","title":"1259. Handshakes That Don't Cross","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, dynamic programming</p> </li> </ul>"},{"location":"content/premium100/graph/","title":"Graph","text":""},{"location":"content/premium100/graph/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 277. Find the Celebrity (Medium) \ud83d\udc51</li> <li> 582. Kill Process (Medium) \ud83d\udc51</li> <li> 323. Number of Connected Components in an Undirected Graph (Medium) \ud83d\udc51</li> <li> 1059. All Paths from Source Lead to Destination (Medium) \ud83d\udc51</li> <li> 1236. Web Crawler (Medium) \ud83d\udc51</li> <li> 305. Number of Islands II (Hard) \ud83d\udc51</li> <li> 694. Number of Distinct Islands (Medium) \ud83d\udc51</li> <li> 1136. Parallel Courses (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/premium100/graph/#277-find-the-celebrity","title":"277. Find the Celebrity","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, graph, interactive</p> </li> </ul>"},{"location":"content/premium100/graph/#582-kill-process","title":"582. Kill Process","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, tree, depth first search, breadth first search 582. Kill Process - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef killProcess(pid: List[int], ppid: List[int], kill: int) -&gt; List[int]:\n    graph = defaultdict(list)\n\n    for u, v in zip(ppid, pid):\n        graph[u].append(v)\n\n    q = deque([kill])\n    res = []\n\n    while q:\n        cur = q.popleft()\n        res.append(cur)\n        for nxt in graph[cur]:\n            q.append(nxt)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    pid = [1, 3, 10, 5]\n    ppid = [3, 0, 5, 3]\n    kill = 5\n    assert killProcess(pid, ppid, kill) == [5, 10]\n</code></pre></p> </li> </ul>"},{"location":"content/premium100/graph/#323-number-of-connected-components-in-an-undirected-graph","title":"323. Number of Connected Components in an Undirected Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph 323. Number of Connected Components in an Undirected Graph - Python Solution<pre><code>from typing import List\n\n\n# Union Find\ndef countComponents(n: int, edges: List[List[int]]) -&gt; int:\n    uf = UnionFind(n)\n    count = n\n\n    for u, v in edges:\n        count -= uf.union(u, v)\n\n    return count\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(n)}\n        self.rank = {i: 1 for i in range(n)}\n\n    def find(self, n):\n        p = self.par[n]\n        while self.par[p] != p:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return 0\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.par[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.par[p1] = p2\n        else:\n            self.par[p2] = p1\n            self.rank[p1] += 1\n\n        return 1\n\n\nprint(countComponents(5, [[0, 1], [1, 2], [3, 4]]))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/premium100/graph/#1059-all-paths-from-source-lead-to-destination","title":"1059. All Paths from Source Lead to Destination","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: graph, topological sort</p> </li> </ul>"},{"location":"content/premium100/graph/#1236-web-crawler","title":"1236. Web Crawler","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, depth first search, breadth first search, interactive</p> </li> </ul>"},{"location":"content/premium100/graph/#305-number-of-islands-ii","title":"305. Number of Islands II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, union find 305. Number of Islands II - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef numIslands2(m: int, n: int, positions: List[List[int]]) -&gt; List[int]:\n    parent = defaultdict(tuple)\n    islands = 0\n    result = []\n    visited = set()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def find(node):\n        p = parent[node]\n        while parent[p] != p:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            parent[p1] = p2\n            return True\n        return False\n\n    for r, c in positions:\n        if (r, c) in visited:\n            result.append(islands)\n            continue\n\n        islands += 1\n        parent[(r, c)] = (r, c)\n        visited.add((r, c))\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if (nr, nc) in visited:\n                if union((r, c), (nr, nc)):\n                    islands -= 1\n\n        result.append(islands)\n\n    return result\n\n\nm = 3\nn = 3\npositions = [[0, 0], [0, 1], [1, 2], [2, 1]]\nprint(numIslands2(m, n, positions))  # [1, 1, 2, 3]\n</code></pre></p> </li> </ul>"},{"location":"content/premium100/graph/#694-number-of-distinct-islands","title":"694. Number of Distinct Islands","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, depth first search, breadth first search, union find, hash function 694. Number of Distinct Islands - Python Solution<pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# BFS\ndef numDistinctIslandsBFS(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    shapes = set()\n    dirs = [[1, 0], [0, 1], [0, -1], [-1, 0]]\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        shape = set()\n        grid[r][c] = 0\n\n        while q:\n            row, col = q.popleft()\n            shape.add((row - r, col - c))\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and grid[nr][nc] == 1:\n                    q.append((nr, nc))\n                    grid[nr][nc] = 0\n\n        return tuple(shape)\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                shapes.add(bfs(i, j))\n\n    return len(shapes)\n\n\n# DFS\ndef numDistinctIslandsDFS(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n\n    def dfs(r, c, org, shape):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] != 1:\n            return\n\n        grid[r][c] = 0\n        shape.add((r - org[0], c - org[1]))\n\n        dfs(r - 1, c, org, shape)\n        dfs(r + 1, c, org, shape)\n        dfs(r, c - 1, org, shape)\n        dfs(r, c + 1, org, shape)\n\n    shapes = set()\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                org = [i, j]\n                shape = set()\n                dfs(i, j, org, shape)\n                shapes.add(tuple(shape))\n\n    return len(shapes)\n\n\ngrid = [[1, 1, 0, 1, 1], [1, 0, 0, 0, 0], [0, 0, 0, 0, 1], [1, 1, 0, 1, 1]]\nprint(numDistinctIslandsBFS(deepcopy(grid)))  # 3\nprint(numDistinctIslandsDFS(deepcopy(grid)))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/premium100/graph/#1136-parallel-courses","title":"1136. Parallel Courses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: graph, topological sort</p> </li> <li>Return the minimum number of semesters needed to take all courses.</li> </ul> <p></p> 1136. Parallel Courses - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# Topological Sort\ndef minimumSemesters(n: int, relations: List[List[int]]) -&gt; int:\n    graph = {i: [] for i in range(1, n + 1)}\n    indegree = {i: 0 for i in range(1, n + 1)}\n\n    for pre, nxt in relations:\n        graph[pre].append(nxt)\n        indegree[nxt] += 1\n\n    q = deque([i for i in range(1, n + 1) if indegree[i] == 0])\n    semester = 0\n    done = 0\n\n    while q:\n        semester += 1\n        size = len(q)\n\n        for _ in range(size):\n            pre = q.popleft()\n            done += 1\n\n            for nxt in graph[pre]:\n                indegree[nxt] -= 1\n                if indegree[nxt] == 0:\n                    q.append(nxt)\n\n    return semester if done == n else -1\n\n\nn = 3\nrelations = [[1, 3], [2, 3]]\nprint(minimumSemesters(n, relations))  # 2\n</code></pre>"},{"location":"content/premium100/graph_bfs/","title":"Graph BFS","text":""},{"location":"content/premium100/graph_bfs/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 490. The Maze (Medium) \ud83d\udc51</li> <li> 505. The Maze II (Medium) \ud83d\udc51</li> <li> 499. The Maze III (Hard) \ud83d\udc51</li> <li> 1197. Minimum Knight Moves (Medium) \ud83d\udc51</li> <li> 286. Walls and Gates (Medium) \ud83d\udc51</li> <li> 317. Shortest Distance from All Buildings (Hard) \ud83d\udc51</li> <li> 269. Alien Dictionary (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/premium100/graph_bfs/#490-the-maze","title":"490. The Maze","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, matrix 490. The Maze - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef hasPathBFS(\n    maze: List[List[int]], start: List[int], destination: List[int]\n) -&gt; bool:\n    m, n = len(maze), len(maze[0])\n    dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]]\n    q = deque([start])\n    maze[start[0]][start[1]] = -1\n\n    while q:\n        r, c = q.popleft()\n        if [r, c] == destination:\n            return True\n\n        for dr, dc in dirs:\n            nr, nc = r, c\n\n            while (\n                0 &lt;= nr + dr &lt; m\n                and 0 &lt;= nc + dc &lt; n\n                and maze[nr + dr][nc + dc] != 1\n            ):\n                nr += dr\n                nc += dc\n\n            if maze[nr][nc] != -1:\n                q.append([nr, nc])\n                maze[nr][nc] = -1\n\n    return False\n\n\nmaze = [\n    [0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0],\n    [0, 0, 0, 1, 0],\n    [1, 1, 0, 1, 1],\n    [0, 0, 0, 0, 0],\n]\nstart = [0, 4]\ndestination = [4, 4]\nprint(hasPathBFS(maze, start, destination))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/premium100/graph_bfs/#505-the-maze-ii","title":"505. The Maze II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, graph, heap priority queue, matrix, shortest path 505. The Maze II - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra\ndef shortestDistance(\n    maze: List[List[int]], start: List[int], destination: List[int]\n) -&gt; int:\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    m, n = len(maze), len(maze[0])\n\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    dist[start[0]][start[1]] = 0\n\n    heap = [(0, start[0], start[1])]\n\n    while heap:\n        d, r, c = heapq.heappop(heap)\n\n        if [r, c] == destination:\n            return d\n\n        for dr, dc in directions:\n            nr, nc, nd = r, c, d\n\n            while (\n                0 &lt;= nr + dr &lt; m\n                and 0 &lt;= nc + dc &lt; n\n                and maze[nr + dr][nc + dc] == 0\n            ):\n                nr += dr\n                nc += dc\n                nd += 1\n\n            if nd &lt; dist[nr][nc]:\n                dist[nr][nc] = nd\n                heapq.heappush(heap, (nd, nr, nc))\n\n    return -1\n\n\nmaze = [\n    [0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0],\n    [0, 0, 0, 1, 0],\n    [1, 1, 0, 1, 1],\n    [0, 0, 0, 0, 0],\n]\nstart = [0, 4]\ndestination = [4, 4]\nprint(shortestDistance(maze, start, destination))  # 12\n</code></pre></p> </li> </ul>"},{"location":"content/premium100/graph_bfs/#499-the-maze-iii","title":"499. The Maze III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, depth first search, breadth first search, graph, heap priority queue, matrix, shortest path 499. The Maze III - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra\ndef findShortestWay(\n    maze: List[List[int]], ball: List[int], hole: List[int]\n) -&gt; str:\n    directions = [(-1, 0, \"u\"), (1, 0, \"d\"), (0, -1, \"l\"), (0, 1, \"r\")]\n    m, n = len(maze), len(maze[0])\n\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    dist[ball[0]][ball[1]] = 0\n\n    paths = [[\"\"] * n for _ in range(m)]\n    paths[ball[0]][ball[1]] = \"\"\n\n    heap = [(0, \"\", ball[0], ball[1])]\n\n    while heap:\n        d, path, x, y = heapq.heappop(heap)\n\n        if [x, y] == hole:\n            return path\n\n        for dx, dy, direction in directions:\n            nx, ny, nd = x, y, d\n\n            while (\n                0 &lt;= nx + dx &lt; m\n                and 0 &lt;= ny + dy &lt; n\n                and maze[nx + dx][ny + dy] == 0\n            ):\n                nx += dx\n                ny += dy\n                nd += 1\n\n                if [nx, ny] == hole:\n                    break\n\n            new_path = path + direction\n            if nd &lt; dist[nx][ny] or (\n                nd == dist[nx][ny] and new_path &lt; paths[nx][ny]\n            ):\n                dist[nx][ny] = nd\n                paths[nx][ny] = new_path\n                heapq.heappush(heap, (nd, new_path, nx, ny))\n\n    return \"impossible\"\n\n\nmaze = [\n    [0, 0, 0, 0, 0],\n    [1, 1, 0, 0, 1],\n    [0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 1],\n    [0, 1, 0, 0, 0],\n]\nball = [4, 3]\nhole = [0, 1]\nprint(findShortestWay(maze, ball, hole))  # \"lul\"\n</code></pre></p> </li> </ul>"},{"location":"content/premium100/graph_bfs/#1197-minimum-knight-moves","title":"1197. Minimum Knight Moves","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: breadth first search</p> </li> </ul>"},{"location":"content/premium100/graph_bfs/#286-walls-and-gates","title":"286. Walls and Gates","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, breadth first search, matrix 286. Walls and Gates - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# Multi-Source BFS\ndef wallsAndGates(rooms: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify rooms in-place instead.\n    \"\"\"\n    m, n = len(rooms), len(rooms[0])\n    visited = set()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def addRoom(r, c):\n        if (\n            0 &lt;= r &lt; m\n            and 0 &lt;= c &lt; n\n            and (r, c) not in visited\n            and rooms[r][c] != -1\n        ):\n            q.append((r, c))\n            visited.add((r, c))\n\n    q = deque()\n    for r in range(m):\n        for c in range(n):\n            if rooms[r][c] == 0:\n                q.append((r, c))\n                visited.add((r, c))\n\n    dist = 0\n\n    while q:\n        for _ in range(len(q)):\n            r, c = q.popleft()\n            rooms[r][c] = dist\n\n            for dr, dc in directions:\n                addRoom(r + dr, c + dc)\n        dist += 1\n\n\nif __name__ == \"__main__\":\n    rooms = [\n        [2147483647, -1, 0, 2147483647],\n        [2147483647, 2147483647, 2147483647, -1],\n        [2147483647, -1, 2147483647, -1],\n        [0, -1, 2147483647, 2147483647],\n    ]\n    wallsAndGates(rooms)\n    assert rooms == [\n        [3, -1, 0, 1],\n        [2, 2, 1, -1],\n        [1, -1, 2, -1],\n        [0, -1, 3, 4],\n    ]\n</code></pre></p> </li> </ul>"},{"location":"content/premium100/graph_bfs/#317-shortest-distance-from-all-buildings","title":"317. Shortest Distance from All Buildings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, breadth first search, matrix</p> </li> </ul>"},{"location":"content/premium100/graph_bfs/#269-alien-dictionary","title":"269. Alien Dictionary","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, depth first search, breadth first search, graph, topological sort</p> </li> <li>Return the correct order of characters in the alien language.</li> </ul> 269. Alien Dictionary - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS - Kahn's algorithm (Topological Sort)\ndef alienOrderBFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    indegree = {c: 0 for word in words for c in word}\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                    indegree[w2[j]] += 1\n                break\n\n    q = deque([c for c in indegree if indegree[c] == 0])\n    result = []\n\n    while q:\n        char = q.popleft()\n        result.append(char)\n\n        for neighbor in graph[char]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n\n    return \"\".join(result) if len(result) == len(indegree) else \"\"\n\n\n# DFS - Topological Sort\ndef alienOrderDFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    visited = {}\n    result = []\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                break\n\n    def dfs(c):\n        if c in visited:\n            return visited[c]\n\n        visited[c] = False\n        for neighbor in graph[c]:\n            if not dfs(neighbor):\n                return False\n\n        visited[c] = True\n        result.append(c)\n        return True\n\n    for c in list(graph.keys()):\n        if not dfs(c):\n            return \"\"\n\n    return \"\".join(result[::-1])\n\n\nwords = [\"wrt\", \"wrf\", \"er\", \"ett\", \"rftt\"]\nprint(alienOrderBFS(words))  # wertf\nprint(alienOrderDFS(words))  # wertf\n</code></pre>"},{"location":"content/premium100/hashing/","title":"Hashing","text":""},{"location":"content/premium100/hashing/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 760. Find Anagram Mappings (Easy) \ud83d\udc51</li> <li> 266. Palindrome Permutation (Easy) \ud83d\udc51</li> <li> 734. Sentence Similarity (Easy) \ud83d\udc51</li> <li> 1165. Single-Row Keyboard (Easy) \ud83d\udc51</li> <li> 249. Group Shifted Strings (Medium) \ud83d\udc51</li> <li> 1133. Largest Unique Number (Easy) \ud83d\udc51</li> <li> 1426. Counting Elements (Easy) \ud83d\udc51</li> <li> 1198. Find Smallest Common Element in All Rows (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/premium100/hashing/#760-find-anagram-mappings","title":"760. Find Anagram Mappings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table 760. Find Anagram Mappings - Python Solution<pre><code>from typing import List\n\n\ndef anagramMappings(nums1: List[int], nums2: List[int]) -&gt; List[int]:\n    hashmap = {val: idx for idx, val in enumerate(nums2)}\n\n    return [hashmap[num] for num in nums1]\n\n\nif __name__ == \"__main__\":\n    nums1 = [12, 28, 46, 32, 50]\n    nums2 = [50, 12, 32, 46, 28]\n    print(anagramMappings(nums1, nums2))  # [1, 4, 3, 2, 0]\n    nums1 = [1, 2, 3]\n    nums2 = [3, 2, 1]\n    print(anagramMappings(nums1, nums2))  # [2, 1, 0]\n</code></pre></p> </li> </ul>"},{"location":"content/premium100/hashing/#266-palindrome-permutation","title":"266. Palindrome Permutation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, string, bit manipulation 266. Palindrome Permutation - Python Solution<pre><code>from collections import defaultdict\n\n\n# Hash\ndef canPermutePalindromeDict(s: str) -&gt; bool:\n    if len(s) == 1:\n        return True\n\n    count = defaultdict(int)\n\n    for ch in s:\n        if count[ch] == 1:\n            count[ch] = 0\n            continue\n        count[ch] = 1\n\n    return sum(count.values()) &lt;= 1\n\n\n# Set\ndef canPermutePalindromeSet(s: str) -&gt; bool:\n    if len(s) == 1:\n        return True\n\n    seen = set()\n\n    for ch in s:\n        if ch in seen:\n            seen.remove(ch)\n        else:\n            seen.add(ch)\n\n    return len(seen) &lt;= 1\n\n\nassert canPermutePalindromeDict(\"carerac\") is True\nassert canPermutePalindromeSet(\"carerac\") is True\n</code></pre></p> </li> </ul>"},{"location":"content/premium100/hashing/#734-sentence-similarity","title":"734. Sentence Similarity","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, string 734. Sentence Similarity - Python Solution<pre><code># Hash Set\ndef areSentencesSimilar(sentence1, sentence2, similarPairs):\n    if len(sentence1) != len(sentence2):\n        return False\n\n    sim = set(map(tuple, similarPairs))\n\n    for i in range(len(sentence1)):\n        s1, s2 = sentence1[i], sentence2[i]\n        if s1 == s2 or (s1, s2) in sim or (s2, s1) in sim:\n            continue\n        return False\n\n    return True\n\n\nif __name__ == \"__main__\":\n    sentence1 = [\"great\", \"acting\", \"skills\"]\n    sentence2 = [\"fine\", \"drama\", \"talent\"]\n    similarPairs = [\n        [\"great\", \"fine\"],\n        [\"drama\", \"acting\"],\n        [\"skills\", \"talent\"],\n    ]\n    print(areSentencesSimilar(sentence1, sentence2, similarPairs))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/premium100/hashing/#1165-single-row-keyboard","title":"1165. Single-Row Keyboard","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, string 1165. Single-Row Keyboard - Python Solution<pre><code>def calculateTime(keyboard: str, word: str) -&gt; int:\n    pos = {char: i for i, char in enumerate(keyboard)}\n    cur = 0\n    res = 0\n\n    for ch in word:\n        target = pos[ch]\n        res += abs(target - cur)\n        cur = target\n\n    return res\n\n\nif __name__ == \"__main__\":\n    keyboard = \"pqrstuvwxyzabcdefghijklmno\"\n    word = \"leetcode\"\n    print(calculateTime(keyboard, word))  # 73\n</code></pre></p> </li> </ul>"},{"location":"content/premium100/hashing/#249-group-shifted-strings","title":"249. Group Shifted Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string</p> </li> </ul>"},{"location":"content/premium100/hashing/#1133-largest-unique-number","title":"1133. Largest Unique Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, sorting</p> </li> </ul>"},{"location":"content/premium100/hashing/#1426-counting-elements","title":"1426. Counting Elements","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table</p> </li> </ul>"},{"location":"content/premium100/hashing/#1198-find-smallest-common-element-in-all-rows","title":"1198. Find Smallest Common Element in All Rows","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, binary search, matrix, counting</p> </li> </ul>"},{"location":"content/premium100/heap/","title":"Heap","text":""},{"location":"content/premium100/heap/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1086. High Five (Easy) \ud83d\udc51</li> <li> 1167. Minimum Cost to Connect Sticks (Medium) \ud83d\udc51</li> <li> 1057. Campus Bikes (Medium) \ud83d\udc51</li> <li> 358. Rearrange String k Distance Apart (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/premium100/heap/#1086-high-five","title":"1086. High Five","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, sorting, heap priority queue 1086. High Five - Python Solution<pre><code>from collections import defaultdict\nfrom heapq import heappush, heappushpop\nfrom typing import List\n\n\n# Heap\ndef highFive(items: List[List[int]]) -&gt; List[List[int]]:\n    hashmap = defaultdict(list)  # id: scores\n\n    for idx, score in items:\n        if len(hashmap[idx]) &lt; 5:\n            heappush(hashmap[idx], score)\n        else:\n            heappushpop(hashmap[idx], score)\n\n    res = []\n    for idx in sorted(hashmap.keys()):\n        res.append([idx, sum(hashmap[idx]) // 5])\n    return res\n\n\nif __name__ == \"__main__\":\n    items = [\n        [1, 91],\n        [1, 92],\n        [2, 93],\n        [2, 97],\n        [1, 60],\n        [2, 77],\n        [1, 65],\n        [1, 87],\n        [1, 100],\n        [2, 100],\n        [2, 76],\n    ]\n    assert highFive(items) == [[1, 87], [2, 88]]\n</code></pre></p> </li> </ul>"},{"location":"content/premium100/heap/#1167-minimum-cost-to-connect-sticks","title":"1167. Minimum Cost to Connect Sticks","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, heap priority queue 1167. Minimum Cost to Connect Sticks - Python Solution<pre><code>from heapq import heapify, heappop, heappush\nfrom typing import List\n\n\n# Heap\ndef connectSticks(sticks: List[int]) -&gt; int:\n    n = len(sticks)\n    heapify(sticks)\n    res = 0\n\n    while n &gt; 1:\n        x = heappop(sticks)\n        y = heappop(sticks)\n        res += x + y\n        heappush(sticks, x + y)\n        n -= 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert connectSticks([2, 4, 3]) == 14\n    assert connectSticks([1, 8, 3, 5]) == 30\n    assert connectSticks([5]) == 0\n    assert connectSticks([1, 2, 3, 4, 5]) == 33\n    assert connectSticks([1, 1, 1]) == 5\n</code></pre></p> </li> </ul>"},{"location":"content/premium100/heap/#1057-campus-bikes","title":"1057. Campus Bikes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting 1057. Campus Bikes - Python Solution<pre><code>from heapq import heappop, heappush\nfrom typing import List\n\n\n# Heap\ndef assignBikes(workers: List[List[int]], bikes: List[List[int]]) -&gt; List[int]:\n    dist = []\n    done1, done2 = set(), set()\n    res = [0 for _ in range(len(workers))]\n\n    for i, w in enumerate(workers):\n        for j, b in enumerate(bikes):\n            d = abs(w[0] - b[0]) + abs(w[1] - b[1])\n            heappush(dist, (d, i, j))\n\n    while dist:\n        d, i, j = heappop(dist)\n        if i not in done1 and j not in done2:\n            res[i] = j\n            done1.add(i)\n            done2.add(j)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    workers = [[0, 0], [2, 1]]\n    bikes = [[1, 2], [3, 3]]\n    assert assignBikes(workers, bikes) == [1, 0]\n    workers = [[0, 0], [1, 1], [2, 0]]\n    bikes = [[1, 0], [2, 2], [2, 1]]\n    assert assignBikes(workers, bikes) == [0, 2, 1]\n</code></pre></p> </li> </ul>"},{"location":"content/premium100/heap/#358-rearrange-string-k-distance-apart","title":"358. Rearrange String k Distance Apart","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, greedy, sorting, heap priority queue, counting</p> </li> </ul>"},{"location":"content/premium100/interval/","title":"Interval","text":""},{"location":"content/premium100/interval/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 163. Missing Ranges (Easy) \ud83d\udc51</li> <li> 252. Meeting Rooms (Easy) \ud83d\udc51</li> <li> 253. Meeting Rooms II (Medium) \ud83d\udc51</li> <li> 616. Add Bold Tag in String (Medium) \ud83d\udc51</li> <li> 1272. Remove Interval (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/premium100/interval/#163-missing-ranges","title":"163. Missing Ranges","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array 163. Missing Ranges - Python Solution<pre><code>from typing import List\n\n\ndef findMissingRanges(\n    nums: List[int], lower: int, upper: int\n) -&gt; List[List[int]]:\n    n = len(nums)\n    res = []\n    if n == 0:\n        return [[lower, upper]]\n\n    # start\n    if nums[0] &gt; lower:\n        res.append([lower, nums[0] - 1])\n\n    # middle\n    for i in range(n - 1):\n        if nums[i] + 1 &lt; nums[i + 1]:\n            res.append([nums[i] + 1, nums[i + 1] - 1])\n\n    # end\n    if nums[-1] &lt; upper:\n        res.append([nums[-1] + 1, upper])\n\n    return res\n\n\ndef findMissingRangesCompact(\n    nums: List[int], lower: int, upper: int\n) -&gt; List[List[int]]:\n    res = []\n\n    for num in nums + [upper + 1]:\n        if num &gt; lower:\n            res.append([lower, num - 1])\n        lower = num + 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    nums = [0, 1, 3, 50, 75]\n    lower = 0\n    upper = 99\n    assert findMissingRanges(nums, lower, upper) == [\n        [2, 2],\n        [4, 49],\n        [51, 74],\n        [76, 99],\n    ]\n    assert findMissingRangesCompact(nums, lower, upper) == [\n        [2, 2],\n        [4, 49],\n        [51, 74],\n        [76, 99],\n    ]\n</code></pre></p> </li> </ul>"},{"location":"content/premium100/interval/#252-meeting-rooms","title":"252. Meeting Rooms","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, sorting 252. Meeting Rooms - Python Solution<pre><code>from typing import List\n\n\n# Interval\ndef canAttendMeetings(intervals: List[List[int]]) -&gt; bool:\n    intervals.sort(key=lambda x: x[0])\n    n = len(intervals)\n\n    if n &lt;= 1:\n        return True\n\n    for i in range(1, n):\n        if intervals[i][0] &lt; intervals[i - 1][1]:\n            return False\n\n    return True\n\n\nif __name__ == \"__main__\":\n    intervals = [[0, 30], [5, 10], [15, 20]]\n    assert not canAttendMeetings(intervals)\n</code></pre></p> </li> </ul>"},{"location":"content/premium100/interval/#253-meeting-rooms-ii","title":"253. Meeting Rooms II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy, sorting, heap priority queue, prefix sum</p> </li> <li>Given an array of meeting time <code>intervals</code> where <code>intervals[i] = [start_i, end_i]</code>, return the minimum number of conference rooms required.</li> </ul> 253. Meeting Rooms II - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Heap\ndef minMeetingRooms(intervals: List[List[int]]) -&gt; int:\n    if not intervals:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n    minHeap = [intervals[0][1]]\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &gt;= minHeap[0]:\n            heapq.heappop(minHeap)\n        heapq.heappush(minHeap, intervals[i][1])\n\n    return len(minHeap)\n\n\nif __name__ == \"__main__\":\n    intervals = [[0, 30], [5, 10], [15, 20]]\n    assert minMeetingRooms(intervals) == 2\n</code></pre>"},{"location":"content/premium100/interval/#616-add-bold-tag-in-string","title":"616. Add Bold Tag in String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, trie, string matching</p> </li> </ul>"},{"location":"content/premium100/interval/#1272-remove-interval","title":"1272. Remove Interval","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array</p> </li> </ul>"},{"location":"content/premium100/linked_list/","title":"Linked List","text":""},{"location":"content/premium100/linked_list/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1474. Delete N Nodes After M Nodes of a Linked List (Easy) \ud83d\udc51</li> <li> 708. Insert into a Sorted Circular Linked List (Medium) \ud83d\udc51</li> <li> 369. Plus One Linked List (Medium) \ud83d\udc51</li> <li> 1265. Print Immutable Linked List in Reverse (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/premium100/linked_list/#1474-delete-n-nodes-after-m-nodes-of-a-linked-list","title":"1474. Delete N Nodes After M Nodes of a Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: linked list 1474. Delete N Nodes After M Nodes of a Linked List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef deleteNodes(\n    head: Optional[ListNode], m: int, n: int\n) -&gt; Optional[ListNode]:\n    dummy = ListNode(0, head)\n    cur = dummy\n\n    while cur.next:\n        for _ in range(m):\n            if not cur.next:\n                break\n            cur = cur.next\n\n        for _ in range(n):\n            if not cur.next:\n                break\n            cur.next = cur.next.next\n\n    return dummy.next\n\n\nif __name__ == \"__main__\":\n    head = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\n    m = 2\n    n = 3\n    head = ListNode.create(head)\n    print(head)\n    # 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; 8 -&gt; 9 -&gt; 10 -&gt; 11 -&gt; 12 -&gt; 13\n    head = deleteNodes(head, m, n)\n    print(head)\n    # 1 -&gt; 2 -&gt; 6 -&gt; 7 -&gt; 11 -&gt; 12\n</code></pre></p> </li> </ul>"},{"location":"content/premium100/linked_list/#708-insert-into-a-sorted-circular-linked-list","title":"708. Insert into a Sorted Circular Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list</p> </li> </ul>"},{"location":"content/premium100/linked_list/#369-plus-one-linked-list","title":"369. Plus One Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, math</p> </li> </ul>"},{"location":"content/premium100/linked_list/#1265-print-immutable-linked-list-in-reverse","title":"1265. Print Immutable Linked List in Reverse","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, two pointers, stack, recursion</p> </li> </ul>"},{"location":"content/premium100/math/","title":"Math","text":""},{"location":"content/premium100/math/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1134. Armstrong Number (Easy) \ud83d\udc51</li> <li> 1180. Count Substrings with Only One Distinct Letter (Easy) \ud83d\udc51</li> <li> 1538. Guess the Majority in a Hidden Array (Medium) \ud83d\udc51</li> <li> 1183. Maximum Number of Ones (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/premium100/math/#1134-armstrong-number","title":"1134. Armstrong Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math</p> </li> </ul>"},{"location":"content/premium100/math/#1180-count-substrings-with-only-one-distinct-letter","title":"1180. Count Substrings with Only One Distinct Letter","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, string</p> </li> </ul>"},{"location":"content/premium100/math/#1538-guess-the-majority-in-a-hidden-array","title":"1538. Guess the Majority in a Hidden Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, interactive</p> </li> </ul>"},{"location":"content/premium100/math/#1183-maximum-number-of-ones","title":"1183. Maximum Number of Ones","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, greedy, sorting, heap priority queue</p> </li> </ul>"},{"location":"content/premium100/matrix/","title":"Matrix","text":""},{"location":"content/premium100/matrix/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 422. Valid Word Square (Easy) \ud83d\udc51</li> <li> 531. Lonely Pixel I (Medium) \ud83d\udc51</li> <li> 311. Sparse Matrix Multiplication (Medium) \ud83d\udc51</li> <li> 723. Candy Crush (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/premium100/matrix/#422-valid-word-square","title":"422. Valid Word Square","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, matrix 422. Valid Word Square - Python Solution<pre><code>from typing import List\n\n\ndef validWordSquare(words: List[str]) -&gt; bool:\n    n = len(words)\n\n    for i in range(n):\n        for j in range(len(words[i])):\n            if j &gt;= n or i &gt;= len(words[j]) or words[i][j] != words[j][i]:\n                return False\n    return True\n\n\n# Zip\ndef validWordSquareZip(words: List[str]) -&gt; bool:\n    max_len = max(len(word) for word in words)\n    padded_words = [word.ljust(max_len) for word in words]\n    transposed = [\"\".join(col) for col in zip(*padded_words)]\n    return padded_words == transposed\n\n\nif __name__ == \"__main__\":\n    words1 = [\"abcd\", \"bnrt\", \"crmy\", \"dtye\"]\n    assert validWordSquare(words1)\n    assert validWordSquareZip(words1)\n\n    words2 = [\"abcd\", \"bnrt\", \"crm\", \"dt\"]\n    assert validWordSquare(words2)\n    assert validWordSquareZip(words2)\n\n    words3 = [\"ball\", \"area\", \"read\", \"lady\"]\n    assert not validWordSquare(words3)\n    assert not validWordSquareZip(words3)\n</code></pre></p> </li> </ul>"},{"location":"content/premium100/matrix/#531-lonely-pixel-i","title":"531. Lonely Pixel I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, matrix</p> </li> </ul>"},{"location":"content/premium100/matrix/#311-sparse-matrix-multiplication","title":"311. Sparse Matrix Multiplication","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, matrix</p> </li> </ul>"},{"location":"content/premium100/matrix/#723-candy-crush","title":"723. Candy Crush","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, matrix, simulation</p> </li> </ul>"},{"location":"content/premium100/n-ary_tree/","title":"N-ary Tree","text":""},{"location":"content/premium100/n-ary_tree/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1490. Clone N-ary Tree (Medium) \ud83d\udc51</li> <li> 1506. Find Root of N-Ary Tree (Medium) \ud83d\udc51</li> <li> 1522. Diameter of N-Ary Tree (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/premium100/n-ary_tree/#1490-clone-n-ary-tree","title":"1490. Clone N-ary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, tree, depth first search, breadth first search</p> </li> </ul>"},{"location":"content/premium100/n-ary_tree/#1506-find-root-of-n-ary-tree","title":"1506. Find Root of N-Ary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, bit manipulation, tree, depth first search</p> </li> </ul>"},{"location":"content/premium100/n-ary_tree/#1522-diameter-of-n-ary-tree","title":"1522. Diameter of N-Ary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search 1522. Diameter of N-Ary Tree - Python Solution<pre><code>from typing import List, Optional\n\n\nclass Node:\n    def __init__(\n        self,\n        val: Optional[int] = None,\n        children: Optional[List[\"Node\"]] = None,\n    ):\n        self.val = val\n        self.children = children if children is not None else []\n\n\ndef diameter(root: \"Node\") -&gt; int:\n\n    def dfs(node):\n        if not node.children:\n            return 1, 1\n        mx0, mx1 = 0, 0\n        mxf = 0\n        for child in node.children:\n            hl, fl = dfs(child)\n            mxf = max(mxf, fl)\n            if hl &gt; mx1:\n                if hl &lt; mx0:\n                    mx1 = hl\n                else:\n                    mx0, mx1 = hl, mx0\n        return mx0 + 1, max(mxf, mx0 + mx1 + 1)\n\n    return dfs(root)[1] - 1\n\n\nroot = [1, None, 2, None, 3, 4, None, 5, None, 6]\nroot = Node(1)\nroot.children = [Node(2)]\nroot.children[0].children = [Node(3), Node(4)]\nroot.children[0].children[0].children = [Node(5)]\nroot.children[0].children[1].children = [Node(6)]\nprint(diameter(root))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/premium100/queue/","title":"Queue","text":""},{"location":"content/premium100/queue/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 346. Moving Average from Data Stream (Easy) \ud83d\udc51</li> <li> 1429. First Unique Number (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/premium100/queue/#346-moving-average-from-data-stream","title":"346. Moving Average from Data Stream","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, design, queue, data stream 346. Moving Average from Data Stream - Python Solution<pre><code>from collections import deque\n\n\n# Deque\nclass MovingAverage:\n    def __init__(self, size: int):\n        self.q = deque()\n        self.cur = 0\n        self.sum = 0\n        self.size = size\n\n    def next(self, val: int) -&gt; float:\n        if self.cur &gt;= self.size:\n            self.sum -= self.q.popleft()\n            self.cur -= 1\n\n        self.q.append(val)\n        self.sum += val\n        self.cur += 1\n\n        return self.sum / self.cur\n\n\nif __name__ == \"__main__\":\n    ma = MovingAverage(3)\n    assert ma.next(1) == 1.0\n    assert ma.next(10) == 5.5\n    assert ma.next(3) == 4.666666666666667\n    assert ma.next(5) == 6.0\n</code></pre></p> </li> </ul>"},{"location":"content/premium100/queue/#1429-first-unique-number","title":"1429. First Unique Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, design, queue, data stream 1429. First Unique Number - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# Deque\nclass FirstUnique:\n\n    def __init__(self, nums: List[int]):\n        self.all = set()\n        self.multi = set()\n\n        for num in nums:\n            if num in self.all:\n                self.multi.add(num)\n            self.all.add(num)\n\n        self.q = deque([i for i in nums if i not in self.multi])\n\n    def showFirstUnique(self) -&gt; int:\n        while self.q and self.q[0] in self.multi:\n            self.q.popleft()\n        return self.q[0] if self.q else -1\n\n    def add(self, value: int) -&gt; None:\n        if value not in self.all:\n            self.all.add(value)\n            self.q.append(value)\n        elif value not in self.multi:\n            self.multi.add(value)\n\n\nif __name__ == \"__main__\":\n    nums = [2, 3, 5]\n    firstUnique = FirstUnique(nums)\n    assert firstUnique.showFirstUnique() == 2\n    firstUnique.add(5)\n    assert firstUnique.showFirstUnique() == 2\n    firstUnique.add(2)\n    assert firstUnique.showFirstUnique() == 3\n    firstUnique.add(3)\n    assert firstUnique.showFirstUnique() == -1\n</code></pre></p> </li> </ul>"},{"location":"content/premium100/sliding_window/","title":"Sliding Window","text":""},{"location":"content/premium100/sliding_window/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 159. Longest Substring with At Most Two Distinct Characters (Medium) \ud83d\udc51</li> <li> 340. Longest Substring with At Most K Distinct Characters (Medium) \ud83d\udc51</li> <li> 487. Max Consecutive Ones II (Medium) \ud83d\udc51</li> <li> 1100. Find K-Length Substrings With No Repeated Characters (Medium) \ud83d\udc51</li> </ul>"},{"location":"content/premium100/sliding_window/#159-longest-substring-with-at-most-two-distinct-characters","title":"159. Longest Substring with At Most Two Distinct Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> <li>Prerequisite: 3. Longest Substring Without Repeating Characters</li> </ul> 159. Longest Substring with At Most Two Distinct Characters - Python Solution<pre><code>from collections import defaultdict\n\n\n# Sliding Window - Variable\ndef lengthOfLongestSubstringTwoDistinct(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 2:\n        return n\n\n    window = defaultdict(int)\n    left, res = 0, 0\n\n    for right in range(n):\n        window[s[right]] += 1\n\n        while len(window) &gt; 2:\n            window[s[left]] -= 1\n            if window[s[left]] == 0:\n                del window[s[left]]\n            left += 1\n\n        res = max(res, right - left + 1)\n\n    return res\n\n\ns = \"ccaabbb\"\nassert lengthOfLongestSubstringTwoDistinct(s) == 5\n</code></pre>"},{"location":"content/premium100/sliding_window/#340-longest-substring-with-at-most-k-distinct-characters","title":"340. Longest Substring with At Most K Distinct Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window 340. Longest Substring with At Most K Distinct Characters - Python Solution<pre><code>from collections import defaultdict\n\n\n# Sliding Window Variable\ndef lengthOfLongestSubstringKDistinct(s: str, k: int) -&gt; int:\n    n = len(s)\n    if n &lt;= k:\n        return n\n\n    window = defaultdict(int)\n    left, res = 0, 0\n\n    for right in range(n):\n        window[s[right]] += 1\n        while len(window) &gt; k:\n            window[s[left]] -= 1\n            if window[s[left]] == 0:\n                del window[s[left]]\n            left += 1\n        res = max(res, right - left + 1)\n\n    return res\n\n\ns = \"eceba\"\nk = 2\nassert lengthOfLongestSubstringKDistinct(s, k) == 3\n</code></pre></p> </li> </ul>"},{"location":"content/premium100/sliding_window/#487-max-consecutive-ones-ii","title":"487. Max Consecutive Ones II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, sliding window</p> </li> </ul>"},{"location":"content/premium100/sliding_window/#1100-find-k-length-substrings-with-no-repeated-characters","title":"1100. Find K-Length Substrings With No Repeated Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window 1100. Find K-Length Substrings With No Repeated Characters - Python Solution<pre><code>from collections import defaultdict\n\n\n# Sliding Window Fixed Size\ndef numKLenSubstrNoRepeats(s: str, k: int) -&gt; int:\n    n = len(s)\n    if k &gt; n:\n        return 0\n\n    counts = defaultdict(int)\n    res = 0\n\n    for i, ch in enumerate(s):\n        # add to the window\n        counts[ch] += 1\n\n        # form a valid window\n        if i &lt; k - 1:\n            continue\n\n        # update\n        res += 1 if len(counts) == k else 0\n\n        # remove from the window\n        first = i - k + 1\n        counts[s[first]] -= 1\n        if counts[s[first]] == 0:\n            del counts[s[first]]\n\n    return res\n\n\nif __name__ == \"__main__\":\n    s = \"havefunonleetcode\"\n    k = 5\n\n    assert numKLenSubstrNoRepeats(s, k) == 6\n</code></pre></p> </li> </ul>"},{"location":"content/premium100/stack/","title":"Stack","text":""},{"location":"content/premium100/stack/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 439. Ternary Expression Parser (Medium) \ud83d\udc51</li> <li> 484. Find Permutation (Medium) \ud83d\udc51</li> <li> 772. Basic Calculator III (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/premium100/stack/#439-ternary-expression-parser","title":"439. Ternary Expression Parser","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack, recursion 439. Ternary Expression Parser - Python Solution<pre><code># Stack\ndef parseTernary(expression: str) -&gt; str:\n    stack = []\n    i = len(expression) - 1\n\n    while i &gt;= 0:\n        c = expression[i]\n        if stack and stack[-1] == \"?\":\n            stack.pop()  # remove '?'\n            true_val = stack.pop()\n            stack.pop()  # remove ':'\n            false_val = stack.pop()\n            if c == \"T\":\n                stack.append(true_val)\n            else:\n                stack.append(false_val)\n        else:\n            stack.append(c)\n        i -= 1\n\n    return stack[-1]\n\n\nif __name__ == \"__main__\":\n    assert parseTernary(\"T?2:3\") == \"2\"\n    assert parseTernary(\"F?1:T?4:5\") == \"4\"\n    assert parseTernary(\"T?T?F:5:3\") == \"F\"\n</code></pre></p> </li> </ul>"},{"location":"content/premium100/stack/#484-find-permutation","title":"484. Find Permutation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, stack, greedy</p> </li> </ul>"},{"location":"content/premium100/stack/#772-basic-calculator-iii","title":"772. Basic Calculator III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, string, stack, recursion 772. Basic Calculator III - Python Solution<pre><code># Stack\ndef calculate(s: str) -&gt; int:\n    def helper(index):\n        stack = []\n        num = 0\n        sign = \"+\"\n\n        while index &lt; len(s):\n            char = s[index]\n            if char.isdigit():\n                num = num * 10 + int(char)\n            if char == \"(\":\n                num, index = helper(index + 1)\n            if char in \"+-*/)\" or index == len(s) - 1:\n                if sign == \"+\":\n                    stack.append(num)\n                elif sign == \"-\":\n                    stack.append(-num)\n                elif sign == \"*\":\n                    stack.append(stack.pop() * num)\n                elif sign == \"/\":\n                    stack.append(int(stack.pop() / num))  # \u5411\u96f6\u53d6\u6574\n                num = 0\n                sign = char\n            if char == \")\":\n                break\n            index += 1\n\n        return sum(stack), index\n\n    s = s.replace(\" \", \"\")\n    result, _ = helper(0)\n\n    return result\n\n\ns = \"2*(5+5*2)/3+(6/2+8)\"\nprint(calculate(s))  # 21\n</code></pre></p> </li> </ul>"},{"location":"content/premium100/trie/","title":"Trie","text":""},{"location":"content/premium100/trie/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 588. Design In-Memory File System (Hard) \ud83d\udc51</li> <li> 642. Design Search Autocomplete System (Hard) \ud83d\udc51</li> </ul>"},{"location":"content/premium100/trie/#588-design-in-memory-file-system","title":"588. Design In-Memory File System","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, design, trie, sorting 588. Design In-Memory File System - Python Solution<pre><code>from collections import defaultdict\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children = defaultdict(TrieNode)\n        self.content = \"\"\n\n\n# Trie\nclass FileSystem:\n\n    def __init__(self):\n        self.root = TrieNode()\n\n    def ls(self, path: str) -&gt; list:\n        cur = self.root\n\n        if path != \"/\":\n            paths = path.split(\"/\")[1:]\n            for p in paths:\n                cur = cur.children[p]\n        if cur.content:\n            return [path.split(\"/\")[-1]]\n\n        return sorted(cur.children.keys())\n\n    def mkdir(self, path: str) -&gt; None:\n        cur = self.root\n        paths = path.split(\"/\")[1:]\n        for p in paths:\n            cur = cur.children[p]\n\n    def addContentToFile(self, filePath: str, content: str) -&gt; None:\n        cur = self.root\n        paths = filePath.split(\"/\")[1:]\n        for p in paths:\n            cur = cur.children[p]\n        cur.content += content\n\n    def readContentFromFile(self, filePath: str) -&gt; str:\n        cur = self.root\n        paths = filePath.split(\"/\")[1:]\n        for p in paths:\n            cur = cur.children[p]\n        return cur.content\n\n\nobj = FileSystem()\nobj.mkdir(\"/a/b/c\")\nobj.addContentToFile(\"/a/b/c/d\", \"hello\")\nprint(obj.ls(\"/\"))  # [\"a\"]\nprint(obj.readContentFromFile(\"/a/b/c/d\"))  # \"hello\"\n</code></pre></p> </li> </ul>"},{"location":"content/premium100/trie/#642-design-search-autocomplete-system","title":"642. Design Search Autocomplete System","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, depth first search, design, trie, sorting, heap priority queue, data stream</p> </li> </ul>"},{"location":"content/sql50/","title":"SQL 50","text":"<ul> <li>List: LeetCode SQL 50 | \u9ad8\u9891 SQL 50 \u9898\uff08\u57fa\u7840\u7248\uff09</li> <li>YouTube Playlist: SQL 50 Series by Everyday Data Science</li> </ul>"},{"location":"content/sql50/advanced_select_and_joins/","title":"Advanced Select and Joins","text":""},{"location":"content/sql50/advanced_select_and_joins/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1731. The Number of Employees Which Report to Each Employee (Easy)</li> <li> 1789. Primary Department for Each Employee (Easy)</li> <li> 610. Triangle Judgement (Easy)</li> <li> 180. Consecutive Numbers (Medium)</li> <li> 1164. Product Price at a Given Date (Medium)</li> <li> 1204. Last Person to Fit in the Bus (Medium)</li> <li> 1907. Count Salary Categories (Medium)</li> </ul>"},{"location":"content/sql50/advanced_select_and_joins/#1731-the-number-of-employees-which-report-to-each-employee","title":"1731. The Number of Employees Which Report to Each Employee","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/advanced_select_and_joins/#1789-primary-department-for-each-employee","title":"1789. Primary Department for Each Employee","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/advanced_select_and_joins/#610-triangle-judgement","title":"610. Triangle Judgement","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/advanced_select_and_joins/#180-consecutive-numbers","title":"180. Consecutive Numbers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/advanced_select_and_joins/#1164-product-price-at-a-given-date","title":"1164. Product Price at a Given Date","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/advanced_select_and_joins/#1204-last-person-to-fit-in-the-bus","title":"1204. Last Person to Fit in the Bus","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/advanced_select_and_joins/#1907-count-salary-categories","title":"1907. Count Salary Categories","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/advanced_string_functions_regex_clause/","title":"Advanced String Functions Regex Clause","text":""},{"location":"content/sql50/advanced_string_functions_regex_clause/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1667. Fix Names in a Table (Easy)</li> <li> 1527. Patients With a Condition (Easy)</li> <li> 196. Delete Duplicate Emails (Easy)</li> <li> 176. Second Highest Salary (Medium)</li> <li> 1484. Group Sold Products By The Date (Easy)</li> <li> 1327. List the Products Ordered in a Period (Easy)</li> <li> 1517. Find Users With Valid E-Mails (Easy)</li> </ul>"},{"location":"content/sql50/advanced_string_functions_regex_clause/#1667-fix-names-in-a-table","title":"1667. Fix Names in a Table","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/advanced_string_functions_regex_clause/#1527-patients-with-a-condition","title":"1527. Patients With a Condition","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/advanced_string_functions_regex_clause/#196-delete-duplicate-emails","title":"196. Delete Duplicate Emails","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/advanced_string_functions_regex_clause/#176-second-highest-salary","title":"176. Second Highest Salary","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/advanced_string_functions_regex_clause/#1484-group-sold-products-by-the-date","title":"1484. Group Sold Products By The Date","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/advanced_string_functions_regex_clause/#1327-list-the-products-ordered-in-a-period","title":"1327. List the Products Ordered in a Period","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/advanced_string_functions_regex_clause/#1517-find-users-with-valid-e-mails","title":"1517. Find Users With Valid E-Mails","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/basic_aggregate_functions/","title":"Basic Aggregate Functions","text":""},{"location":"content/sql50/basic_aggregate_functions/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 620. Not Boring Movies (Easy)</li> <li> 1251. Average Selling Price (Easy)</li> <li> 1075. Project Employees I (Easy)</li> <li> 1633. Percentage of Users Attended a Contest (Easy)</li> <li> 1211. Queries Quality and Percentage (Easy)</li> <li> 1193. Monthly Transactions I (Medium)</li> <li> 1174. Immediate Food Delivery II (Medium)</li> <li> 550. Game Play Analysis IV (Medium)</li> </ul>"},{"location":"content/sql50/basic_aggregate_functions/#620-not-boring-movies","title":"620. Not Boring Movies","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/basic_aggregate_functions/#1251-average-selling-price","title":"1251. Average Selling Price","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/basic_aggregate_functions/#1075-project-employees-i","title":"1075. Project Employees I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/basic_aggregate_functions/#1633-percentage-of-users-attended-a-contest","title":"1633. Percentage of Users Attended a Contest","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/basic_aggregate_functions/#1211-queries-quality-and-percentage","title":"1211. Queries Quality and Percentage","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/basic_aggregate_functions/#1193-monthly-transactions-i","title":"1193. Monthly Transactions I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/basic_aggregate_functions/#1174-immediate-food-delivery-ii","title":"1174. Immediate Food Delivery II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/basic_aggregate_functions/#550-game-play-analysis-iv","title":"550. Game Play Analysis IV","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/basic_joins/","title":"Basic Joins","text":""},{"location":"content/sql50/basic_joins/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1378. Replace Employee ID With The Unique Identifier (Easy)</li> <li> 1068. Product Sales Analysis I (Easy)</li> <li> 1581. Customer Who Visited but Did Not Make Any Transactions (Easy)</li> <li> 197. Rising Temperature (Easy)</li> <li> 1661. Average Time of Process per Machine (Easy)</li> <li> 577. Employee Bonus (Easy)</li> <li> 1280. Students and Examinations (Easy)</li> <li> 570. Managers with at Least 5 Direct Reports (Medium)</li> <li> 1934. Confirmation Rate (Medium)</li> </ul>"},{"location":"content/sql50/basic_joins/#1378-replace-employee-id-with-the-unique-identifier","title":"1378. Replace Employee ID With The Unique Identifier","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/basic_joins/#1068-product-sales-analysis-i","title":"1068. Product Sales Analysis I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/basic_joins/#1581-customer-who-visited-but-did-not-make-any-transactions","title":"1581. Customer Who Visited but Did Not Make Any Transactions","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/basic_joins/#197-rising-temperature","title":"197. Rising Temperature","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/basic_joins/#1661-average-time-of-process-per-machine","title":"1661. Average Time of Process per Machine","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/basic_joins/#577-employee-bonus","title":"577. Employee Bonus","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/basic_joins/#1280-students-and-examinations","title":"1280. Students and Examinations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/basic_joins/#570-managers-with-at-least-5-direct-reports","title":"570. Managers with at Least 5 Direct Reports","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/basic_joins/#1934-confirmation-rate","title":"1934. Confirmation Rate","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/select/","title":"Select","text":""},{"location":"content/sql50/select/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1757. Recyclable and Low Fat Products (Easy)</li> <li> 584. Find Customer Referee (Easy)</li> <li> 595. Big Countries (Easy)</li> <li> 1148. Article Views I (Easy)</li> <li> 1683. Invalid Tweets (Easy)</li> </ul>"},{"location":"content/sql50/select/#1757-recyclable-and-low-fat-products","title":"1757. Recyclable and Low Fat Products","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/select/#584-find-customer-referee","title":"584. Find Customer Referee","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/select/#595-big-countries","title":"595. Big Countries","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/select/#1148-article-views-i","title":"1148. Article Views I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/select/#1683-invalid-tweets","title":"1683. Invalid Tweets","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/sorting_and_grouping/","title":"Sorting and Grouping","text":""},{"location":"content/sql50/sorting_and_grouping/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 2356. Number of Unique Subjects Taught by Each Teacher (Easy)</li> <li> 1141. User Activity for the Past 30 Days I (Easy)</li> <li> 1070. Product Sales Analysis III (Medium)</li> <li> 596. Classes More Than 5 Students (Easy)</li> <li> 1729. Find Followers Count (Easy)</li> <li> 619. Biggest Single Number (Easy)</li> <li> 1045. Customers Who Bought All Products (Medium)</li> </ul>"},{"location":"content/sql50/sorting_and_grouping/#2356-number-of-unique-subjects-taught-by-each-teacher","title":"2356. Number of Unique Subjects Taught by Each Teacher","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/sorting_and_grouping/#1141-user-activity-for-the-past-30-days-i","title":"1141. User Activity for the Past 30 Days I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/sorting_and_grouping/#1070-product-sales-analysis-iii","title":"1070. Product Sales Analysis III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/sorting_and_grouping/#596-classes-more-than-5-students","title":"596. Classes More Than 5 Students","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/sorting_and_grouping/#1729-find-followers-count","title":"1729. Find Followers Count","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/sorting_and_grouping/#619-biggest-single-number","title":"619. Biggest Single Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/sorting_and_grouping/#1045-customers-who-bought-all-products","title":"1045. Customers Who Bought All Products","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/subqueries/","title":"Subqueries","text":""},{"location":"content/sql50/subqueries/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1978. Employees Whose Manager Left the Company (Easy)</li> <li> 626. Exchange Seats (Medium)</li> <li> 1341. Movie Rating (Medium)</li> <li> 1321. Restaurant Growth (Medium)</li> <li> 602. Friend Requests II: Who Has the Most Friends (Medium)</li> <li> 585. Investments in 2016 (Medium)</li> <li> 185. Department Top Three Salaries (Hard)</li> </ul>"},{"location":"content/sql50/subqueries/#1978-employees-whose-manager-left-the-company","title":"1978. Employees Whose Manager Left the Company","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/subqueries/#626-exchange-seats","title":"626. Exchange Seats","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/subqueries/#1341-movie-rating","title":"1341. Movie Rating","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/subqueries/#1321-restaurant-growth","title":"1321. Restaurant Growth","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/subqueries/#602-friend-requests-ii-who-has-the-most-friends","title":"602. Friend Requests II: Who Has the Most Friends","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/subqueries/#585-investments-in-2016","title":"585. Investments in 2016","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/sql50/subqueries/#185-department-top-three-salaries","title":"185. Department Top Three Salaries","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"content/top100liked/","title":"Top 100 Liked","text":"<ul> <li>Link: Top 100 Liked | LeetCode \u70ed\u9898 100</li> </ul>"},{"location":"content/top100liked/arrays/","title":"Arrays","text":""},{"location":"content/top100liked/arrays/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 53. Maximum Subarray (Medium)</li> <li> 56. Merge Intervals (Medium)</li> <li> 189. Rotate Array (Medium)</li> <li> 238. Product of Array Except Self (Medium)</li> <li> 41. First Missing Positive (Hard)</li> </ul>"},{"location":"content/top100liked/arrays/#53-maximum-subarray","title":"53. Maximum Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, divide and conquer, dynamic programming 53. Maximum Subarray - Python Solution<pre><code>from typing import List\n\n\n# DP Kadane\ndef maxSubArrayDP(nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n\n    dp[0] = nums[0]\n    maxSum = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(\n            dp[i - 1] + nums[i],  # continue the previous subarray\n            nums[i],  # start a new subarray\n        )\n        maxSum = max(maxSum, dp[i])\n\n    return maxSum\n\n\n# Greedy\ndef maxSubArrayGreedy(nums: List[int]) -&gt; int:\n    max_sum = nums[0]\n    cur_sum = 0\n\n    for num in nums:\n        cur_sum = max(cur_sum + num, num)\n        max_sum = max(max_sum, cur_sum)\n\n    return max_sum\n\n\n# Prefix Sum\ndef maxSubArrayPrefixSum(nums: List[int]) -&gt; int:\n    prefix_sum = 0\n    prefix_sum_min = 0\n    res = float(\"-inf\")\n\n    for num in nums:\n        prefix_sum += num\n        res = max(res, prefix_sum - prefix_sum_min)\n        prefix_sum_min = min(prefix_sum_min, prefix_sum)\n\n    return res\n\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArrayDP(nums))  # 6\nprint(maxSubArrayGreedy(nums))  # 6\nprint(maxSubArrayPrefixSum(nums))  # 6\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/arrays/#56-merge-intervals","title":"56. Merge Intervals","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sorting</p> </li> <li>Merge all overlapping intervals.</li> </ul> 56. Merge Intervals - Python Solution<pre><code>from typing import List\n\n\n# Intervals\ndef merge(intervals: List[List[int]]) -&gt; List[List[int]]:\n    n = len(intervals)\n    if n &lt;= 1:\n        return intervals\n\n    intervals.sort(key=lambda x: x[0])\n    res = [intervals[0]]\n\n    for i in range(1, n):\n        if intervals[i][0] &lt;= res[-1][1]:\n            res[-1][1] = max(res[-1][1], intervals[i][1])\n        else:\n            res.append(intervals[i])\n\n    return res\n\n\nprint(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))\n# [[1, 6], [8, 10], [15, 18]]\n</code></pre> 56. Merge Intervals - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// Interval\nvector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {\n    sort(intervals.begin(), intervals.end());\n    vector&lt;vector&lt;int&gt;&gt; res;\n\n    for (auto&amp; range : intervals) {\n        if (!res.empty() &amp;&amp; range[0] &lt;= res.back()[1]) {\n            res.back()[1] = max(res.back()[1], range[1]);\n        } else {\n            res.emplace_back(range);\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;vector&lt;int&gt;&gt; intervals = {{1, 3}, {2, 6}, {8, 10}, {15, 18}};\n    vector&lt;vector&lt;int&gt;&gt; res = merge(intervals);\n    for (auto&amp; range : res) {\n        cout &lt;&lt; range[0] &lt;&lt; \", \" &lt;&lt; range[1] &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"content/top100liked/arrays/#189-rotate-array","title":"189. Rotate Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, two pointers</p> </li> <li>Rotate array with reversing subarrays</li> </ul> <pre><code>graph TD\n    A[1 2 3 4 5 6 7] --Reverse entire array--&gt; B[7 6 5 4 3 2 1]\n    B --Reverse first k elements--&gt; C[5 6 7 4 3 2 1]\n    C --Reverse remaining n-k elements--&gt; D[5 6 7 1 2 3 4];</code></pre> 189. Rotate Array - Python Solution<pre><code>from typing import List\n\n\n# Array\ndef rotate(nums: List[int], k: int) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n\n    def reverse(i: int, j: int) -&gt; None:\n        while i &lt; j:\n            nums[i], nums[j] = nums[j], nums[i]\n            i += 1\n            j -= 1\n\n    n = len(nums)\n    k %= n\n    reverse(0, n - 1)\n    reverse(0, k - 1)\n    reverse(k, n - 1)\n\n\nnums = [1, 2, 3, 4, 5, 6, 7]\nk = 3\nrotate(nums, k)\nprint(nums)  # [5, 6, 7, 1, 2, 3, 4]\n</code></pre> 189. Rotate Array - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n// Array\nvoid rotate(vector&lt;int&gt;&amp; nums, int k) {\n    k %= nums.size();\n\n    reverse(nums.begin(), nums.end());\n    reverse(nums.begin(), nums.begin() + k);\n    reverse(nums.begin() + k, nums.end());\n}\n\nint main() {\n    vector&lt;int&gt; nums = {1, 2, 3, 4, 5, 6, 7};\n    int k = 3;\n    rotate(nums, k);\n    // [5, 6, 7, 1, 2, 3, 4]\n    for (const auto&amp; num : nums) {\n        cout &lt;&lt; num &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/top100liked/arrays/#238-product-of-array-except-self","title":"238. Product of Array Except Self","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, prefix sum</p> </li> <li>Classic Prefix Sum problem</li> <li>Return an array <code>output</code> such that <code>output[i]</code> is equal to the product of all the elements of <code>nums</code> except <code>nums[i]</code>.</li> </ul> Approach Time Space Prefix O(n) O(n) Prefix (Optimized) O(n) O(1) 238. Product of Array Except Self - Python Solution<pre><code>from typing import List\n\n\n# Prefix\ndef productExceptSelf(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    prefix = [1 for _ in range(n)]\n    suffix = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        prefix[i] = nums[i - 1] * prefix[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        suffix[i] = nums[i + 1] * suffix[i + 1]\n\n    result = [i * j for i, j in zip(prefix, suffix)]\n\n    return result\n\n\n# Prefix (Optimized)\ndef productExceptSelfOptimized(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    result = [1 for _ in range(n)]\n\n    prefix = 1\n    for i in range(n):\n        result[i] = prefix\n        prefix *= nums[i]\n\n    suffix = 1\n    for i in range(n - 1, -1, -1):\n        result[i] *= suffix\n        suffix *= nums[i]\n\n    return result\n\n\nprint(productExceptSelf([1, 2, 3, 4]))\n# [24, 12, 8, 6]\nprint(productExceptSelfOptimized([1, 2, 3, 4]))\n# [24, 12, 8, 6]\n</code></pre> 238. Product of Array Except Self - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\n// Prefix Sum\nclass Solution\n{\npublic:\n    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt; &amp;nums)\n    {\n        int n = nums.size();\n        vector&lt;int&gt; prefix(n, 1);\n        vector&lt;int&gt; suffix(n, 1);\n        vector&lt;int&gt; res(n, 1);\n\n        for (int i = 1; i &lt; n; i++)\n        {\n            prefix[i] = prefix[i - 1] * nums[i - 1];\n        }\n\n        for (int i = n - 2; i &gt;= 0; i--)\n        {\n            suffix[i] = suffix[i + 1] * nums[i + 1];\n        }\n\n        for (int i = 0; i &lt; n; i++)\n        {\n            res[i] = prefix[i] * suffix[i];\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    vector&lt;int&gt; nums = {1, 2, 3, 4};\n    Solution obj;\n    vector&lt;int&gt; result = obj.productExceptSelf(nums);\n\n    for (int i = 0; i &lt; result.size(); i++)\n    {\n        cout &lt;&lt; result[i] &lt;&lt; \"\\n\";\n    }\n    cout &lt;&lt; endl;\n    // 24, 12, 8, 6\n    return 0;\n}\n</code></pre>"},{"location":"content/top100liked/arrays/#41-first-missing-positive","title":"41. First Missing Positive","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table 41. First Missing Positive - Python Solution<pre><code>from typing import List\n\n\n# In-place Hashing\ndef firstMissingPositive(nums: List[int]) -&gt; int:\n    n = len(nums)\n\n    for i in range(n):\n        while 1 &lt;= nums[i] &lt;= n and nums[nums[i] - 1] != nums[i]:\n            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n\n    for i in range(n):\n        if nums[i] != i + 1:\n            return i + 1\n\n    return n + 1\n\n\nif __name__ == \"__main__\":\n    nums = [3, 4, -1, 1]\n    print(firstMissingPositive(nums))  # 2\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/backtracking/","title":"Backtracking","text":""},{"location":"content/top100liked/backtracking/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 46. Permutations (Medium)</li> <li> 78. Subsets (Medium)</li> <li> 17. Letter Combinations of a Phone Number (Medium)</li> <li> 39. Combination Sum (Medium)</li> <li> 22. Generate Parentheses (Medium)</li> <li> 79. Word Search (Medium)</li> <li> 131. Palindrome Partitioning (Medium)</li> <li> 51. N-Queens (Hard)</li> </ul>"},{"location":"content/top100liked/backtracking/#46-permutations","title":"46. Permutations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking 46. Permutations - Python Solution<pre><code>from typing import List\n\n\n# Backtracking\ndef permute(nums: List[int]) -&gt; List[List[int]]:\n    n = len(nums)\n    path, res = [], []\n    used = [False for _ in range(n)]\n\n    def dfs(x: int):\n        if x == n:\n            res.append(path[:])\n            return\n\n        for i in range(n):\n            if used[i]:\n                continue\n            used[i] = True\n            path.append(nums[i])\n            dfs(x + 1)\n            path.pop()\n            used[i] = False\n\n    dfs(0)\n\n    return res\n\n\nprint(permute([1, 2, 3]))\n# [[1, 2, 3], [1, 3, 2], [2, 1, 3],\n#  [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/backtracking/#78-subsets","title":"78. Subsets","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking, bit manipulation 78. Subsets - Python Solution<pre><code>from typing import List\n\n\n# Iterative Inclusion Backtracking\ndef subsets_iterative_inclusion(nums: List[int]) -&gt; List[List[int]]:\n    n = len(nums)\n    res, path = [], []\n\n    def dfs(i):\n        res.append(path.copy())\n\n        for j in range(i, n):\n            path.append(nums[j])\n            dfs(j + 1)\n            path.pop()\n\n    dfs(0)\n\n    return res\n\n\n# Binary Decision Backtracking\ndef subsets_binary_decision(nums: List[int]) -&gt; List[List[int]]:\n    n = len(nums)\n    res, path = [], []\n\n    def dfs(i):\n        if i == n:\n            res.append(path.copy())\n            return\n\n        # Exclude\n        dfs(i + 1)\n\n        # Include\n        path.append(nums[i])\n        dfs(i + 1)\n        path.pop()\n\n    dfs(0)\n\n    return res\n\n\nprint(subsets_iterative_inclusion([1, 2, 3]))\n# [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]\nprint(subsets_binary_decision([1, 2, 3]))\n# [[], [3], [2], [2, 3], [1], [1, 3], [1, 2], [1, 2, 3]]\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/backtracking/#17-letter-combinations-of-a-phone-number","title":"17. Letter Combinations of a Phone Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, backtracking</p> </li> <li>Return all possible letter combinations that the number could represent.</li> </ul> <p></p> 17. Letter Combinations of a Phone Number - Python Solution<pre><code>from typing import List\n\n\n# Backtracking\ndef letterCombinations(digits: str) -&gt; List[str]:\n    letter_map = {\n        \"2\": \"abc\",\n        \"3\": \"def\",\n        \"4\": \"ghi\",\n        \"5\": \"jkl\",\n        \"6\": \"mno\",\n        \"7\": \"pqrs\",\n        \"8\": \"tuv\",\n        \"9\": \"wxyz\",\n    }\n\n    n = len(digits)\n    if n == 0:\n        return []\n\n    res = []\n\n    def dfs(idx, path):\n        if idx == n:\n            res.append(path)\n            return None\n\n        letters = letter_map[digits[idx]]\n\n        for i in range(len(letters)):\n            dfs(idx + 1, path + letters[i])\n\n    dfs(0, \"\")\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert letterCombinations(\"23\") == [\n        \"ad\",\n        \"ae\",\n        \"af\",\n        \"bd\",\n        \"be\",\n        \"bf\",\n        \"cd\",\n        \"ce\",\n        \"cf\",\n    ]\n</code></pre>"},{"location":"content/top100liked/backtracking/#39-combination-sum","title":"39. Combination Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking 39. Combination Sum - Python Solution<pre><code>from typing import List\n\n\ndef combinationSum(candidates: List[int], target: int) -&gt; List[List[int]]:\n    n = len(candidates)\n    res, path = [], []\n\n    def dfs(total, start):\n        if total &gt; target:\n            return\n        if total == target:\n            res.append(path.copy())\n            return\n\n        for i in range(start, n):\n            total += candidates[i]\n            path.append(candidates[i])\n            dfs(total, i)\n            total -= candidates[i]\n            path.pop()\n\n    dfs(0, 0)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(combinationSum([2, 3, 5], 8))\n    # [[2, 2, 2, 2], [2, 3, 3], [3, 5]]\n    print(combinationSum([2, 3, 6, 7], 7))\n    # [[2, 2, 3], [7]]\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/backtracking/#22-generate-parentheses","title":"22. Generate Parentheses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming, backtracking 22. Generate Parentheses - Python Solution<pre><code>from typing import List\n\n\n# Backtracking\ndef generateParenthesis1(n: int) -&gt; List[str]:\n    path, res = [], []\n\n    def dfs(openN, closeN):\n        if openN == closeN == n:\n            res.append(\"\".join(path))\n            return\n\n        if openN &lt; n:\n            path.append(\"(\")\n            dfs(openN + 1, closeN)\n            path.pop()\n\n        if closeN &lt; openN:\n            path.append(\")\")\n            dfs(openN, closeN + 1)\n            path.pop()\n\n    dfs(0, 0)\n\n    return res\n\n\n# Backtracking\ndef generateParenthesis2(n: int) -&gt; List[str]:\n    m = n * 2\n    res, path = [], [\"\"] * m\n\n    def dfs(i, left):\n        if i == m:\n            res.append(\"\".join(path))\n            return\n\n        if left &lt; n:\n            path[i] = \"(\"\n            dfs(i + 1, left + 1)\n        if i - left &lt; left:\n            path[i] = \")\"\n            dfs(i + 1, left)\n\n    dfs(0, 0)\n    return res\n\n\nif __name__ == \"__main__\":\n    print(generateParenthesis1(3))\n    # ['((()))', '(()())', '(())()', '()(())', '()()()']\n    print(generateParenthesis2(3))\n    # ['((()))', '(()())', '(())()', '()(())', '()()()']\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/backtracking/#79-word-search","title":"79. Word Search","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, backtracking, depth first search, matrix 79. Word Search - Python Solution<pre><code>from typing import List\n\n\ndef exist(board: List[List[str]], word: str) -&gt; bool:\n    m, n = len(board), len(board[0])\n    path = set()\n    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\n\n    def dfs(r, c, i):\n        if i == len(word):\n            return True\n\n        if (\n            r &lt; 0\n            or r &gt;= m\n            or c &lt; 0\n            or c &gt;= n\n            or board[r][c] != word[i]\n            or (r, c) in path\n        ):\n            return False\n\n        path.add((r, c))\n\n        for dr, dc in dirs:\n            if dfs(r + dr, c + dc, i + 1):\n                return True\n\n        path.remove((r, c))\n        return False\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, 0):\n                return True\n\n    return False\n\n\nboard = [\n    [\"A\", \"B\", \"C\", \"E\"],\n    [\"S\", \"F\", \"C\", \"S\"],\n    [\"A\", \"D\", \"E\", \"E\"],\n]\nword = \"ABCCED\"\nprint(exist(board, word))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/backtracking/#131-palindrome-partitioning","title":"131. Palindrome Partitioning","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming, backtracking 131. Palindrome Partitioning - Python Solution<pre><code>from typing import List\n\n\n# Backtracking\ndef partition(s: str) -&gt; List[List[str]]:\n    n = len(s)\n    res, path = [], []\n\n    def dfs(start):\n        if start == n:\n            res.append(path.copy())\n            return\n\n        for end in range(start, n):\n            cur = s[start : end + 1]\n            if cur == cur[::-1]:\n                path.append(cur)\n                dfs(end + 1)\n                path.pop()\n\n    dfs(0)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(partition(\"aab\"))\n    # [['a', 'a', 'b'], ['aa', 'b']]\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/backtracking/#51-n-queens","title":"51. N-Queens","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, backtracking</p> </li> <li>Hard</li> <li>N-Queens</li> <li>N \u7687\u540e</li> </ul> 51. N-Queens - Python Solution<pre><code>from typing import List\n\n\n# Backtracking\ndef solveNQueens(n: int) -&gt; List[List[str]]:\n    res = []\n    board = [\".\" * n for _ in range(n)]\n\n    def dfs(row):\n        if row == n:\n            res.append(board[:])\n            return None\n        for col in range(n):\n            if is_valid(row, col, board):\n                board[row] = board[row][:col] + \"Q\" + board[row][col + 1 :]\n                dfs(row + 1)\n                board[row] = board[row][:col] + \".\" + board[row][col + 1 :]\n\n    def is_valid(row, col, chessboard):\n        for i in range(row):\n            if chessboard[i][col] == \"Q\":\n                return False\n\n        i, j = row - 1, col - 1\n        while i &gt;= 0 and j &gt;= 0:\n            if chessboard[i][j] == \"Q\":\n                return False\n            i -= 1\n            j -= 1\n\n        i, j = row - 1, col + 1\n        while i &gt;= 0 and j &lt; len(chessboard):\n            if chessboard[i][j] == \"Q\":\n                return False\n            i -= 1\n            j += 1\n\n        return True\n\n    dfs(0)\n\n    return [[\"\".join(row) for row in i] for i in res]\n\n\n# Backtracking\ndef solveNQueens2(n: int) -&gt; List[List[str]]:\n    res = []\n    queens = [0] * n\n    col = [False] * n\n    diag1 = [False] * (n * 2 - 1)\n    diag2 = [False] * (n * 2 - 1)\n\n    def dfs(r: int) -&gt; None:\n        if r == n:\n            res.append([\".\" * c + \"Q\" + \".\" * (n - 1 - c) for c in queens])\n            return\n\n        for c, ok in enumerate(col):\n            if not ok and not diag1[r + c] and not diag2[r - c]:\n                queens[r] = c\n                col[c] = diag1[r + c] = diag2[r - c] = True\n                dfs(r + 1)\n                col[c] = diag1[r + c] = diag2[r - c] = False\n\n    dfs(0)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(solveNQueens(4))\n    # [['.Q..', '...Q', 'Q...', '..Q.'],\n    #  ['..Q.', 'Q...', '...Q', '.Q..']]\n    print(solveNQueens(1))\n    # [['Q']]\n    print(solveNQueens2(4))\n    # [['.Q..', '...Q', 'Q...', '..Q.'],\n    #  ['..Q.', 'Q...', '...Q', '.Q..']]\n    print(solveNQueens2(1))\n    # [['Q']]\n</code></pre>"},{"location":"content/top100liked/binary_search/","title":"Binary Search","text":""},{"location":"content/top100liked/binary_search/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 35. Search Insert Position (Easy)</li> <li> 74. Search a 2D Matrix (Medium)</li> <li> 34. Find First and Last Position of Element in Sorted Array (Medium)</li> <li> 33. Search in Rotated Sorted Array (Medium)</li> <li> 153. Find Minimum in Rotated Sorted Array (Medium)</li> <li> 4. Median of Two Sorted Arrays (Hard)</li> </ul>"},{"location":"content/top100liked/binary_search/#35-search-insert-position","title":"35. Search Insert Position","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, binary search</p> </li> <li>Return the index of the target if it is found. If not, return the index where it would be if it were inserted in order.</li> </ul> 35. Search Insert Position - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef searchInsert(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        if nums[mid] &lt; target:\n            left = mid + 1\n        elif nums[mid] &gt; target:\n            right = mid - 1\n        else:\n            return mid\n\n    return left\n\n\nnums = [1, 3, 5, 6]\ntarget = 5\nprint(searchInsert(nums, target))  # 2\n</code></pre>"},{"location":"content/top100liked/binary_search/#74-search-a-2d-matrix","title":"74. Search a 2D Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, matrix 74. Search a 2D Matrix - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef searchMatrix(matrix: List[List[int]], target: int) -&gt; bool:\n    if not matrix or not matrix[0]:\n        return False\n\n    m, n = len(matrix), len(matrix[0])\n    left, right = 0, m * n - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        x = matrix[mid // n][mid % n]\n\n        if x &lt; target:\n            left = mid + 1\n        elif x &gt; target:\n            right = mid - 1\n        else:\n            return True\n\n    return False\n\n\nif __name__ == \"__main__\":\n    matrix = [[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]]\n    target = 3\n    print(searchMatrix(matrix, target))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/binary_search/#34-find-first-and-last-position-of-element-in-sorted-array","title":"34. Find First and Last Position of Element in Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> <li>Find the starting and ending position of a given target value in a sorted array.</li> </ul> 34. Find First and Last Position of Element in Sorted Array - Python Solution<pre><code>from bisect import bisect_left\nfrom typing import List\n\n\n# Binary Search\ndef searchRangeBS(nums: List[int], target: int) -&gt; List[int]:\n    def bisect_left(nums, target):\n        left, right = 0, len(nums) - 1\n        while left &lt;= right:\n            mid = left + (right - left) // 2\n            if nums[mid] &lt; target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n\n    left = bisect_left(nums, target)\n    right = bisect_left(nums, target + 1) - 1\n\n    if left &lt;= right:\n        return [left, right]\n\n    return [-1, -1]\n\n\n# Bisect\ndef searchRangeBSBisect(nums: List[int], target: int) -&gt; List[int]:\n    if not nums:\n        return [-1, -1]\n\n    left = bisect_left(nums, target)\n    right = bisect_left(nums, target + 1) - 1\n\n    return [left, right] if left &lt;= right else [-1, -1]\n\n\nnums = [5, 7, 7, 8, 8, 10]\ntarget = 8\nprint(searchRangeBS(nums, target))  # [3, 4]\nprint(searchRangeBSBisect(nums, target))  # [3, 4]\n</code></pre> 34. Find First and Last Position of Element in Sorted Array - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\n  int bisect_left(vector&lt;int&gt; &amp;nums, int target)\n  {\n    int left = 0, right = (int)nums.size() - 1;\n\n    while (left &lt;= right)\n    {\n      int mid = left + (right - left) / 2;\n      if (nums[mid] &lt; target)\n      {\n        left = mid + 1;\n      }\n      else\n      {\n        right = mid - 1;\n      }\n    }\n    return left;\n  }\n\npublic:\n  vector&lt;int&gt; searchRange(vector&lt;int&gt; &amp;nums, int target)\n  {\n    int left = bisect_left(nums, target);\n    if (left == (int)nums.size() || nums[left] != target)\n    {\n      return {-1, -1};\n    }\n    int right = bisect_left(nums, target + 1) - 1;\n    return {left, right};\n  }\n};\n\nint main()\n{\n  vector&lt;int&gt; nums = {5, 7, 7, 8, 8, 10};\n  int target = 8;\n  Solution s;\n  vector&lt;int&gt; res = s.searchRange(nums, target);\n  cout &lt;&lt; res[0] &lt;&lt; \", \" &lt;&lt; res[1] &lt;&lt; endl;\n  return 0;\n}\n</code></pre>"},{"location":"content/top100liked/binary_search/#33-search-in-rotated-sorted-array","title":"33. Search in Rotated Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search 33. Search in Rotated Sorted Array - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef search(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] == target:\n            return mid\n\n        if nums[left] &lt;= nums[mid]:\n            if nums[left] &lt;= target &lt; nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if nums[mid] &lt; target &lt;= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n    return -1\n\n\nnums = [4, 5, 6, 7, 0, 1, 2]\ntarget = 0\nprint(search(nums, target))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/binary_search/#153-find-minimum-in-rotated-sorted-array","title":"153. Find Minimum in Rotated Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search 153. Find Minimum in Rotated Sorted Array - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef findMin(nums: List[int]) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt; right:\n        mid = left + (right - left) // 2\n        if nums[mid] &gt; nums[right]:\n            left = mid + 1\n        else:\n            right = mid\n\n    return nums[right]\n\n\nnums = [4, 5, 6, 7, 0, 1, 2]\nprint(findMin(nums))  # 0\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/binary_search/#4-median-of-two-sorted-arrays","title":"4. Median of Two Sorted Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, divide and conquer 4. Median of Two Sorted Arrays - Python Solution<pre><code>from typing import List\n\n\n# Brute Force\ndef findMedianSortedArraysBF(nums1: List[int], nums2: List[int]) -&gt; float:\n    nums = sorted(nums1 + nums2)\n    n = len(nums)\n    if n % 2 == 0:\n        return (nums[n // 2 - 1] + nums[n // 2]) / 2\n    else:\n        return nums[n // 2]\n\n\n# Binary Search\ndef findMedianSortedArraysBS(nums1: List[int], nums2: List[int]) -&gt; float:\n    if len(nums1) &gt; len(nums2):\n        nums1, nums2 = nums2, nums1\n\n    m, n = len(nums1), len(nums2)\n    imin, imax, half_len = 0, m, (m + n + 1) // 2\n\n    while imin &lt;= imax:\n        i = (imin + imax) // 2\n        j = half_len - i\n\n        if i &lt; m and nums2[j - 1] &gt; nums1[i]:\n            imin = i + 1\n        elif i &gt; 0 and nums1[i - 1] &gt; nums2[j]:\n            imax = i - 1\n        else:\n            if i == 0:\n                max_of_left = nums2[j - 1]\n            elif j == 0:\n                max_of_left = nums1[i - 1]\n            else:\n                max_of_left = max(nums1[i - 1], nums2[j - 1])\n\n            if (m + n) % 2 == 1:\n                return max_of_left\n\n            if i == m:\n                min_of_right = nums2[j]\n            elif j == n:\n                min_of_right = nums1[i]\n            else:\n                min_of_right = min(nums1[i], nums2[j])\n\n            return (max_of_left + min_of_right) / 2\n\n\n# |--------------|-----------------|--------------|\n# | Approach     | Time            | Space        |\n# |--------------|-----------------|--------------|\n# | Brute Force  | O((n+m)log(n+m))| O(n+m)       |\n# | Binary Search| O(log(min(n,m)))| O(1)         |\n# |--------------|-----------------|--------------|\n\n\nnums1 = [1, 3]\nnums2 = [2]\nprint(findMedianSortedArraysBF(nums1, nums2))  # 2.0\nprint(findMedianSortedArraysBS(nums1, nums2))  # 2.0\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/binary_tree/","title":"Binary Tree","text":""},{"location":"content/top100liked/binary_tree/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 94. Binary Tree Inorder Traversal (Easy)</li> <li> 104. Maximum Depth of Binary Tree (Easy)</li> <li> 226. Invert Binary Tree (Easy)</li> <li> 101. Symmetric Tree (Easy)</li> <li> 543. Diameter of Binary Tree (Easy)</li> <li> 102. Binary Tree Level Order Traversal (Medium)</li> <li> 108. Convert Sorted Array to Binary Search Tree (Easy)</li> <li> 98. Validate Binary Search Tree (Medium)</li> <li> 230. Kth Smallest Element in a BST (Medium)</li> <li> 199. Binary Tree Right Side View (Medium)</li> <li> 114. Flatten Binary Tree to Linked List (Medium)</li> <li> 105. Construct Binary Tree from Preorder and Inorder Traversal (Medium)</li> <li> 437. Path Sum III (Medium)</li> <li> 236. Lowest Common Ancestor of a Binary Tree (Medium)</li> <li> 124. Binary Tree Maximum Path Sum (Hard)</li> </ul>"},{"location":"content/top100liked/binary_tree/#94-binary-tree-inorder-traversal","title":"94. Binary Tree Inorder Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: stack, tree, depth first search, binary tree 94. Binary Tree Inorder Traversal - Python Solution<pre><code>from typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef inorderTraversalRecursive(root: TreeNode) -&gt; List[int]:\n    res = []\n\n    def dfs(node):\n        if not node:\n            return\n\n        dfs(node.left)\n        res.append(node.val)  # &lt;--\n        dfs(node.right)\n\n    dfs(root)\n\n    return res\n\n\n# Iterative\ndef inorderTraversalIterative(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    stack = []\n    res = []\n    cur = root\n\n    while cur or stack:\n        if cur:\n            stack.append(cur)\n            cur = cur.left\n        else:\n            cur = stack.pop()\n            res.append(cur.val)\n            cur = cur.right\n\n    return res\n\n\ntree = build([0, 1, 2, 3, 4, 5, 6])\nprint(tree)\n#     __0__\n#    /     \\\n#   1       2\n#  / \\     / \\\n# 3   4   5   6\nprint(inorderTraversalRecursive(tree))  # [3, 1, 4, 0, 5, 2, 6]\nprint(inorderTraversalIterative(tree))  # [3, 1, 4, 0, 5, 2, 6]\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/binary_tree/#104-maximum-depth-of-binary-tree","title":"104. Maximum Depth of Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 104. Maximum Depth of Binary Tree - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef maxDepthRecursive(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    left = maxDepthRecursive(root.left)\n    right = maxDepthRecursive(root.right)\n\n    return 1 + max(left, right)\n\n\n# DFS\ndef maxDepthDFS(root: Optional[TreeNode]) -&gt; int:\n    res = 0\n\n    def dfs(node, cnt):\n        if node is None:\n            return\n        cnt += 1\n        nonlocal res\n        res = max(res, cnt)\n\n        dfs(node.left, cnt)\n        dfs(node.right, cnt)\n\n    dfs(root, 0)\n\n    return res\n\n\n# Iterative\ndef maxDepthIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n    res = 0\n\n    while q:\n        res += 1\n        n = len(q)\n\n        for _ in range(n):\n            node = q.popleft()\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    root = [1, 2, 2, 3, 4, None, None, None, None, 5]\n    root = build(root)\n    print(root)\n    #     ____1\n    #    /     \\\n    #   2__     2\n    #  /   \\\n    # 3     4\n    #      /\n    #     5\n    assert maxDepthRecursive(root) == 4\n    assert maxDepthDFS(root) == 4\n    assert maxDepthIterative(root) == 4\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/binary_tree/#226-invert-binary-tree","title":"226. Invert Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 226. Invert Binary Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef invertTreeRecursive(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    root.left, root.right = root.right, root.left\n\n    invertTreeRecursive(root.left)\n    invertTreeRecursive(root.right)\n\n    return root\n\n\n# Iterative\ndef invertTreeIterative(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    stack = [root]\n\n    while stack:\n        node = stack.pop()\n\n        node.left, node.right = node.right, node.left\n        if node.left:\n            stack.append(node.left)\n        if node.right:\n            stack.append(node.right)\n\n    return root\n\n\nroot = build([4, 2, 7, 1, 3, 6, 9])\nprint(root)\n#     __4__\n#    /     \\\n#   2       7\n#  / \\     / \\\n# 1   3   6   9\ninvertedRecursive = invertTreeRecursive(root)\nprint(invertedRecursive)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\nroot = build([4, 2, 7, 1, 3, 6, 9])\ninvertedIterative = invertTreeIterative(root)\nprint(invertedIterative)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/binary_tree/#101-symmetric-tree","title":"101. Symmetric Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 101. Symmetric Tree - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef is_symmetric_recursive(root: Optional[TreeNode]) -&gt; bool:\n    if not root:\n        return True\n\n    def check(left, right):\n        if left is right:\n            return True\n        if not left or not right or left.val != right.val:\n            return False\n        outside = check(left.left, right.right)\n        inside = check(left.right, right.left)\n        return outside and inside\n\n    return check(root.left, root.right)\n\n\n# Iterative\ndef is_symmetric_iterative(root: Optional[TreeNode]) -&gt; bool:\n    if not root:\n        return True\n\n    q = deque()\n    q.append(root.left)\n    q.append(root.right)\n\n    while q:\n        left = q.popleft()\n        right = q.popleft()\n\n        if not left and not right:\n            continue\n\n        if not left or not right or left.val != right.val:\n            return False\n\n        q.append(left.left)\n        q.append(right.right)\n        q.append(left.right)\n        q.append(right.left)\n\n    return True\n\n\nif __name__ == \"__main__\":\n    root = [1, 2, 2, 3, 4, 4, 3]\n    root = build(root)\n    print(root)\n    #     __1__\n    #    /     \\\n    #   2       2\n    #  / \\     / \\\n    # 3   4   4   3\n    assert is_symmetric_recursive(root) is True\n    assert is_symmetric_iterative(root) is True\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/binary_tree/#543-diameter-of-binary-tree","title":"543. Diameter of Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, binary tree 543. Diameter of Binary Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Tree DFS\nclass Solution:\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -&gt; int:\n        self.diameter = 0\n\n        def dfs(node):\n            if not node:\n                return 0\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n            self.diameter = max(self.diameter, left + right)\n\n            return 1 + max(left, right)\n\n        dfs(root)\n\n        return self.diameter\n\n\nroot = build([1, 2, 3, 4, 5])\nprint(root)\n#     __1\n#    /   \\\n#   2     3\n#  / \\\n# 4   5\nobj = Solution()\nprint(obj.diameterOfBinaryTree(root))  # 3\n</code></pre></p> </li> </ul> 543. Diameter of Binary Tree - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nint diameterOfBinaryTree(TreeNode* root) {\n    int diameter = 0;\n\n    auto dfs = [&amp;](auto&amp;&amp; self, TreeNode* node) -&gt; int {\n        if (!node) return 0;\n        int left = self(self, node-&gt;left);\n        int right = self(self, node-&gt;right);\n\n        diameter = max(diameter, left + right);\n\n        return 1 + max(left, right);\n    };\n\n    dfs(dfs, root);\n    return diameter;\n}\n\nint main() {\n    // [1, 2, 3, 4, 5]\n    TreeNode* root = new TreeNode(1);\n    root-&gt;left = new TreeNode(2);\n    root-&gt;right = new TreeNode(3);\n    root-&gt;left-&gt;left = new TreeNode(4);\n    root-&gt;left-&gt;right = new TreeNode(5);\n    cout &lt;&lt; diameterOfBinaryTree(root) &lt;&lt; endl;  // 3\n\n    return 0;\n}\n</code></pre>"},{"location":"content/top100liked/binary_tree/#102-binary-tree-level-order-traversal","title":"102. Binary Tree Level Order Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, breadth first search, binary tree 102. Binary Tree Level Order Traversal - Python Solution<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef levelOrder(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        level = []\n        size = len(q)\n\n        for _ in range(size):\n            cur = q.popleft()\n            level.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(level)\n\n    return res\n\n\ntree = build([3, 9, 20, None, None, 15, 7])\nprint(tree)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(levelOrder(tree))  # [[3], [9, 20], [15, 7]]\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/binary_tree/#108-convert-sorted-array-to-binary-search-tree","title":"108. Convert Sorted Array to Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, divide and conquer, tree, binary search tree, binary tree 108. Convert Sorted Array to Binary Search Tree - Python Solution<pre><code>from typing import List, Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef sortedArrayToBST(nums: List[int]) -&gt; Optional[TreeNode]:\n    if len(nums) == 0:\n        return None\n\n    mid = len(nums) // 2\n    root = TreeNode(nums[mid])\n\n    root.left = sortedArrayToBST(nums[:mid])\n    root.right = sortedArrayToBST(nums[mid + 1 :])\n\n    return root\n\n\nnums = [-10, -3, 0, 5, 9]\nroot = sortedArrayToBST(nums)\n#      0\n#     / \\\n#   -3   9\n#   /   /\n# -10  5\n</code></pre></p> </li> </ul> 108. Convert Sorted Array to Binary Search Tree - C++ Solution<pre><code>#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   public:\n    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) {\n        if (nums.size() == 0) return nullptr;\n\n        int mid = nums.size() / 2;\n        TreeNode* root = new TreeNode(nums[mid]);\n\n        vector&lt;int&gt; left(nums.begin(), nums.begin() + mid);\n        vector&lt;int&gt; right(nums.begin() + mid + 1, nums.end());\n\n        root-&gt;left = sortedArrayToBST(left);\n        root-&gt;right = sortedArrayToBST(right);\n\n        return root;\n    }\n};\n\nint main() { return 0; }\n</code></pre>"},{"location":"content/top100liked/binary_tree/#98-validate-binary-search-tree","title":"98. Validate Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree 98. Validate Binary Search Tree - Python Solution<pre><code>from itertools import pairwise\nfrom math import inf\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef isValidBST1(root: Optional[TreeNode]) -&gt; bool:\n    inorder = []  # inorder traversal\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    for a, b in pairwise(inorder):\n        if a &gt;= b:\n            return False\n\n    return True\n\n\ndef isValidBST2(root: Optional[TreeNode]) -&gt; bool:\n    if not root:\n        return True\n    pre = -inf\n\n    def dfs(node):\n        if not node:\n            return True\n        if not dfs(node.left):\n            return False\n\n        nonlocal pre\n        if node.val &lt;= pre:\n            return False\n        pre = node.val\n\n        return dfs(node.right)\n\n    return dfs(root)\n\n\nif __name__ == \"__main__\":\n    root = [5, 1, 4, None, None, 3, 6]\n    root = build(root)\n    print(root)\n    #   5__\n    #  /   \\\n    # 1     4\n    #      / \\\n    #     3   6\n    assert not isValidBST1(root)  # [1, 5, 3, 4, 6]\n    assert not isValidBST2(root)  # [1, 5, 3, 4, 6]\n</code></pre></p> </li> </ul> 98. Validate Binary Search Tree - C++ Solution<pre><code>#include &lt;cassert&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   private:\n    vector&lt;int&gt; inorder;\n    bool check(vector&lt;int&gt; inorder) {\n        int n = inorder.size();\n        if (n &lt;= 1) return true;\n        for (int i = 1; i &lt; n; i++) {\n            if (inorder[i] &lt;= inorder[i - 1]) return false;\n        }\n        return true;\n    }\n\n   public:\n    bool isValidBST(TreeNode *root) {\n        auto dfs = [&amp;](auto &amp;&amp;self, TreeNode *node) -&gt; void {\n            if (!node) return;\n\n            self(self, node-&gt;left);\n            inorder.push_back(node-&gt;val);\n            self(self, node-&gt;right);\n        };\n\n        dfs(dfs, root);\n\n        return check(inorder);\n    }\n};\n\nint main() {\n    Solution s;\n    TreeNode *root = new TreeNode(2);\n    root-&gt;left = new TreeNode(1);\n    root-&gt;right = new TreeNode(3);\n    assert(s.isValidBST(root) == true);\n\n    root = new TreeNode(5);\n    root-&gt;left = new TreeNode(1);\n    root-&gt;right = new TreeNode(4);\n    root-&gt;right-&gt;left = new TreeNode(3);\n    root-&gt;right-&gt;right = new TreeNode(6);\n    assert(s.isValidBST(root) == false);\n\n    root = new TreeNode(5);\n    root-&gt;left = new TreeNode(4);\n    root-&gt;right = new TreeNode(6);\n    root-&gt;right-&gt;left = new TreeNode(3);\n    root-&gt;right-&gt;right = new TreeNode(7);\n    assert(s.isValidBST(root) == false);\n\n    return 0;\n}\n</code></pre>"},{"location":"content/top100liked/binary_tree/#230-kth-smallest-element-in-a-bst","title":"230. Kth Smallest Element in a BST","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree 230. Kth Smallest Element in a BST - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef kthSmallestRecursive(root: Optional[TreeNode], k: int) -&gt; int:\n    inorder = []\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n    return inorder[k - 1]\n\n\n# Iteratve\ndef kthSmallestIteratve(root: Optional[TreeNode], k: int) -&gt; int:\n    stack = []\n    while True:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        k -= 1\n        if not k:\n            return root.val\n        root = root.right\n\n\nif __name__ == \"__main__\":\n    root = build([3, 1, 4, None, 2])\n    k = 1\n    assert kthSmallestRecursive(root, k) == 1\n    assert kthSmallestIteratve(root, k) == 1\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/binary_tree/#199-binary-tree-right-side-view","title":"199. Binary Tree Right Side View","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree 199. Binary Tree Right Side View - Python Solution<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Binary Tree BFS\ndef rightSideViewBFS(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        n = len(q)\n        for i in range(n):\n            node = q.popleft()\n            if i == n - 1:\n                res.append(node.val)\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return res\n\n\n# Binary Tree DFS\ndef rightSideViewDFS(root: Optional[TreeNode]) -&gt; List[int]:\n    \"\"\"\u540e\u5e8f\u904d\u5386\uff0c\u5148\u53f3\u540e\u5de6\uff0c\u9047\u5230\u7684\u7b2c\u4e00\u4e2a\u8282\u70b9\u5c31\u662f\u8be5\u6df1\u5ea6\u7684\u6700\u53f3\u4fa7\u8282\u70b9\"\"\"\n    ans = []\n\n    def dfs(node, depth):\n        if node is None:\n            return\n        if depth == len(ans):  # \u8fd9\u4e2a\u6df1\u5ea6\u9996\u6b21\u9047\u5230\n            ans.append(node.val)\n\n        dfs(node.right, depth + 1)\n        dfs(node.left, depth + 1)\n\n    dfs(root, 0)\n\n    return ans\n\n\nif __name__ == \"__main__\":\n    root = [1, 2, 2, 3, 4, None, 3, None, None, 5]\n    root = build(root)\n    print(root)\n    #     ____1\n    #    /     \\\n    #   2__     2\n    #  /   \\     \\\n    # 3     4     3\n    #      /\n    #     5\n    assert rightSideViewBFS(root) == [1, 2, 3, 5]\n    assert rightSideViewDFS(root) == [1, 2, 3, 5]\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/binary_tree/#114-flatten-binary-tree-to-linked-list","title":"114. Flatten Binary Tree to Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, stack, tree, depth first search, binary tree 114. Flatten Binary Tree to Linked List - C++ Solution<pre><code>struct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n    TreeNode* head;\n\n   public:\n    void flatten(TreeNode* root) {\n        if (!root) return;\n\n        flatten(root-&gt;right);\n        flatten(root-&gt;left);\n        root-&gt;left = nullptr;\n        root-&gt;right = head;\n        head = root;\n    }\n};\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/binary_tree/#105-construct-binary-tree-from-preorder-and-inorder-traversal","title":"105. Construct Binary Tree from Preorder and Inorder Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, divide and conquer, tree, binary tree 105. Construct Binary Tree from Preorder and Inorder Traversal - Python Solution<pre><code>from typing import List, Optional\n\nfrom helper import TreeNode\n\n\ndef buildTree(preorder: List[int], inorder: List[int]) -&gt; Optional[TreeNode]:\n    \"\"\"\n    preorder  root left right  1  2  3\n    inorder   left root right  4  5  6\n    \"\"\"\n    if len(preorder) == 0:\n        return None\n\n    root_val = preorder[0]  # 1\n    root = TreeNode(root_val)\n\n    separator_idx = inorder.index(root_val)  # 5\n\n    left_inorder = inorder[:separator_idx]  # 4\n    right_inorder = inorder[separator_idx + 1 :]  # 6\n\n    left_preorder = preorder[1 : 1 + len(left_inorder)]  # 2\n    right_preorder = preorder[1 + len(left_inorder) :]  # 3\n\n    root.left = buildTree(left_preorder, left_inorder)\n    root.right = buildTree(right_preorder, right_inorder)\n\n    return root\n\n\npreorder = [3, 9, 20, 15, 7]\ninorder = [9, 3, 15, 20, 7]\nroot = buildTree(preorder, inorder)\nprint(root)\n#     3\n#    / \\\n#   9  20\n#     /  \\\n#    15   7\n</code></pre></p> </li> </ul> 105. Construct Binary Tree from Preorder and Inorder Traversal - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   public:\n    vector&lt;int&gt; preorder;\n    unordered_map&lt;int, int&gt; inorderMap;\n\n    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {\n        this-&gt;preorder = preorder;\n        for (size_t i = 0; i &lt; inorder.size(); i++) {\n            inorderMap[inorder[i]] = i;\n        }\n        return buildSubtree(0, 0, inorder.size() - 1);\n    }\n\n   private:\n    TreeNode* buildSubtree(int rootIndex, int left, int right) {\n        if (left &gt; right) return nullptr;\n\n        TreeNode* root = new TreeNode(preorder[rootIndex]);\n        int inorderIndex = inorderMap[preorder[rootIndex]];\n\n        root-&gt;left = buildSubtree(rootIndex + 1, left, inorderIndex - 1);\n        root-&gt;right = buildSubtree(rootIndex + (inorderIndex - left + 1),\n                                   inorderIndex + 1, right);\n\n        return root;\n    }\n};\n\nint main() {\n    vector&lt;int&gt; preorder = {3, 9, 20, 15, 7};\n    vector&lt;int&gt; inorder = {9, 3, 15, 20, 7};\n    Solution solution;\n    TreeNode* root = solution.buildTree(preorder, inorder);\n    cout &lt;&lt; root-&gt;val &lt;&lt; endl;                // 3\n    cout &lt;&lt; root-&gt;left-&gt;val &lt;&lt; endl;          // 9\n    cout &lt;&lt; root-&gt;right-&gt;val &lt;&lt; endl;         // 20\n    cout &lt;&lt; root-&gt;right-&gt;left-&gt;val &lt;&lt; endl;   // 15\n    cout &lt;&lt; root-&gt;right-&gt;right-&gt;val &lt;&lt; endl;  // 7\n    return 0;\n}\n</code></pre>"},{"location":"content/top100liked/binary_tree/#437-path-sum-iii","title":"437. Path Sum III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree 437. Path Sum III - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   public:\n    int pathSum(TreeNode *root, int targetSum) {\n        int res = 0;\n        unordered_map&lt;long long, int&gt; cnt{{0, 1}};\n\n        auto dfs = [&amp;](auto &amp;&amp;self, TreeNode *node, long long cur) {\n            if (!node) return;\n            cur += node-&gt;val;\n\n            if (cnt.find(cur - targetSum) != cnt.end())\n                res += cnt[cur - targetSum];\n\n            cnt[cur]++;\n            self(self, node-&gt;left, cur);\n            self(self, node-&gt;right, cur);\n            cnt[cur]--;\n        };\n\n        dfs(dfs, root, 0);\n        return res;\n    }\n};\n\nint main() {\n    Solution s;\n    {\n        TreeNode *root = new TreeNode(10);\n        root-&gt;left = new TreeNode(5);\n        root-&gt;right = new TreeNode(-3);\n        root-&gt;left-&gt;left = new TreeNode(3);\n        root-&gt;left-&gt;right = new TreeNode(2);\n        root-&gt;right-&gt;right = new TreeNode(11);\n        root-&gt;left-&gt;left-&gt;left = new TreeNode(3);\n        root-&gt;left-&gt;left-&gt;right = new TreeNode(-2);\n        root-&gt;left-&gt;right-&gt;right = new TreeNode(1);\n        cout &lt;&lt; s.pathSum(root, 8) &lt;&lt; endl;  // 3\n    }\n    {\n        TreeNode *root = new TreeNode(5);\n        root-&gt;left = new TreeNode(4);\n        root-&gt;right = new TreeNode(8);\n        root-&gt;left-&gt;left = new TreeNode(11);\n        root-&gt;right-&gt;left = new TreeNode(13);\n        root-&gt;right-&gt;right = new TreeNode(4);\n        root-&gt;left-&gt;left-&gt;left = new TreeNode(7);\n        root-&gt;left-&gt;left-&gt;right = new TreeNode(2);\n        root-&gt;right-&gt;right-&gt;left = new TreeNode(5);\n        root-&gt;right-&gt;right-&gt;right = new TreeNode(1);\n        cout &lt;&lt; s.pathSum(root, 22) &lt;&lt; endl;  // 3\n    }\n    return 0;\n}\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/binary_tree/#236-lowest-common-ancestor-of-a-binary-tree","title":"236. Lowest Common Ancestor of a Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree 236. Lowest Common Ancestor of a Binary Tree - Python Solution<pre><code>from typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef lowestCommonAncestor(\n    root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n) -&gt; \"TreeNode\":\n    if not root or q == root or p == root:\n        return root\n\n    left = lowestCommonAncestor(root.left, p, q)\n    right = lowestCommonAncestor(root.right, p, q)\n\n    if left and right:\n        return root\n\n    return left or right\n\n\nroot = build([3, 5, 1, 6, 2, 0, 8, None, None, 7, 4])\nprint(root)\n#     ______3__\n#    /         \\\n#   5__         1\n#  /   \\       / \\\n# 6     2     0   8\n#      / \\\n#     7   4\np = root.left  # 5\nq = root.right  # 1\nprint(lowestCommonAncestor(root, p, q))  # 3\n#     ______3__\n#    /         \\\n#   5__         1\n#  /   \\       / \\\n# 6     2     0   8\n#      / \\\n#     7   4\nr = root.left.right.right  # 4\nprint(lowestCommonAncestor(root, p, r))  # 5\n#   5__\n#  /   \\\n# 6     2\n#      / \\\n#     7   4\n</code></pre></p> </li> </ul> 236. Lowest Common Ancestor of a Binary Tree - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\n   public:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if (root == nullptr || root == p || root == q) {\n            return root;\n        }\n\n        TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);\n        TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);\n\n        if (left &amp;&amp; right) {\n            return root;\n        }\n\n        return left ? left : right;\n    }\n};\n\nint main() { return 0; }\n</code></pre>"},{"location":"content/top100liked/binary_tree/#124-binary-tree-maximum-path-sum","title":"124. Binary Tree Maximum Path Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, tree, depth first search, binary tree 124. Binary Tree Maximum Path Sum - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef maxPathSum(root: Optional[TreeNode]) -&gt; int:\n    res = float(\"-inf\")\n\n    def dfs(node):\n        if not node:\n            return 0\n\n        leftMax = max(dfs(node.left), 0)\n        rightMax = max(dfs(node.right), 0)\n\n        cur = node.val + leftMax + rightMax\n        nonlocal res\n        res = max(res, cur)\n\n        return node.val + max(leftMax, rightMax)\n\n    dfs(root)\n\n    return res\n\n\nroot = build([-10, 9, 20, None, None, 15, 7])\nprint(root)\n#   -10___\n#  /      \\\n# 9       _20\n#        /   \\\n#       15    7\nprint(maxPathSum(root))  # 42\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/dynamic_programming/","title":"Dynamic Programming","text":""},{"location":"content/top100liked/dynamic_programming/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 70. Climbing Stairs (Easy)</li> <li> 118. Pascal's Triangle (Easy)</li> <li> 198. House Robber (Medium)</li> <li> 279. Perfect Squares (Medium)</li> <li> 322. Coin Change (Medium)</li> <li> 139. Word Break (Medium)</li> <li> 300. Longest Increasing Subsequence (Medium)</li> <li> 152. Maximum Product Subarray (Medium)</li> <li> 416. Partition Equal Subset Sum (Medium)</li> <li> 32. Longest Valid Parentheses (Hard)</li> </ul>"},{"location":"content/top100liked/dynamic_programming/#70-climbing-stairs","title":"70. Climbing Stairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, dynamic programming, memoization</p> </li> <li>Return the number of distinct ways to reach the top of the stairs.</li> <li><code>dp[n]</code> stores the number of distinct ways to reach the <code>n-th</code> stair.</li> <li>Formula: <code>dp[n] = dp[n - 1] + dp[n - 2]</code>.</li> <li>Initialize <code>dp[0] = 0</code>, <code>dp[1] = 1</code>, and <code>dp[2] = 2</code>.</li> </ul> 70. Climbing Stairs - Python Solution<pre><code>from functools import cache\n\n\n# DP\ndef climbStairsDP(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    dp = [i for i in range(n + 1)]\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\n# DP (Optimized)\ndef climbStairsDPOptimized(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    first, second = 1, 2\n\n    for _ in range(3, n + 1):\n        first, second = second, first + second\n\n    return second\n\n\n# Recursion\ndef climbStairsRecursion(n: int) -&gt; int:\n    @cache\n    def dfs(i: int) -&gt; int:\n        if i &lt;= 1:\n            return 1\n        return dfs(i - 1) + dfs(i - 2)\n\n    return dfs(n)\n\n\n# Greedy\ndef climbStairsGreedy(n: int) -&gt; int:\n    if n &lt;= 2:\n        return n\n\n    p1, p2 = 1, 2\n\n    for _ in range(3, n + 1):\n        p1, p2 = p2, p1 + p2\n\n    return p2\n\n\nif __name__ == \"__main__\":\n    assert climbStairsDP(10) == 89\n    assert climbStairsDPOptimized(10) == 89\n    assert climbStairsRecursion(10) == 89\n    assert climbStairsGreedy(10) == 89\n</code></pre> 70. Climbing Stairs - C++ Solution<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint climbStairs(int n) {\n    if (n &lt;= 2) return n;\n    int f1 = 1, f2 = 2;\n    int res;\n\n    int i = 3;\n    while (i &lt;= n) {\n        res = f1 + f2;\n        f1 = f2;\n        f2 = res;\n        ++i;\n    }\n    return res;\n}\n\nint main() {\n    cout &lt;&lt; climbStairs(2) &lt;&lt; endl;  // 2\n    cout &lt;&lt; climbStairs(3) &lt;&lt; endl;  // 3\n    cout &lt;&lt; climbStairs(6) &lt;&lt; endl;  // 13\n    return 0;\n}\n</code></pre>"},{"location":"content/top100liked/dynamic_programming/#118-pascals-triangle","title":"118. Pascal's Triangle","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li>Generate the first <code>numRows</code> of Pascal's triangle.</li> </ul> <pre><code>                 numRows\n     1              1\n    1 1             2\n   1 2 1            3\n  1 3 3 1           4\n 1 4 6 4 1          5\n</code></pre> 118. Pascal's Triangle - Python Solution<pre><code>from typing import List\n\n\ndef generate(numRows: int) -&gt; List[List[int]]:\n    dp = [[1] * i for i in range(1, numRows + 1)]\n\n    if numRows &lt;= 2:\n        return dp\n\n    for i in range(2, numRows):\n        for j in range(1, i):\n            dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n\n    return dp\n\n\nif __name__ == \"__main__\":\n    print(generate(numRows=5))\n    # [[1],\n    #  [1, 1],\n    #  [1, 2, 1],\n    #  [1, 3, 3, 1],\n    #  [1, 4, 6, 4, 1]]\n</code></pre>"},{"location":"content/top100liked/dynamic_programming/#198-house-robber","title":"198. House Robber","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li> <p>Return the maximum amount of money that can be robbed from the houses. No two adjacent houses can be robbed.</p> </li> <li> <p><code>dp[n]</code> stores the maximum amount of money that can be robbed from the first <code>n</code> houses.</p> </li> <li>Formula: <code>dp[n] = max(dp[n - 1], dp[n - 2] + nums[n])</code>.<ul> <li>Skip: <code>dp[n]</code> \u2192 <code>dp[n - 1]</code></li> <li>Rob: <code>dp[n]</code> \u2192 <code>dp[n - 2] + nums[n]</code></li> </ul> </li> <li>Initialize <code>dp[0] = nums[0]</code> and <code>dp[1] = max(nums[0], nums[1])</code>.</li> <li>Return <code>dp[-1]</code>.</li> <li>Example: <code>nums = [2, 7, 9, 3, 1]</code></li> </ul> n <code>nums[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n-2] + nums[n]</code> <code>dp[n]</code> 0 2 - 2 - 2 1 7 - 7 - 7 2 9 2 7 11 11 3 3 7 11 10 11 4 1 11 11 12 12 198. House Robber - Python Solution<pre><code>from typing import List\n\n\n# DP (House Robber)\ndef rob1(nums: List[int]) -&gt; int:\n    if len(nums) &lt; 3:\n        return max(nums)\n\n    dp = [0 for _ in range(len(nums))]\n    dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n    for i in range(2, len(nums)):\n        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n    return dp[-1]\n\n\n# DP (House Robber) Optimized\ndef rob2(nums: List[int]) -&gt; int:\n    f0, f1 = 0, 0\n\n    for num in nums:\n        f0, f1 = f1, max(f1, f0 + num)\n\n    return f1\n\n\nnums = [2, 7, 9, 3, 1]\nprint(rob1(nums))  # 12\nprint(rob2(nums))  # 12\n</code></pre> 198. House Robber - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint rob(vector&lt;int&gt; &amp;nums) {\n    int prev = 0, cur = 0, temp = 0;\n\n    for (int num : nums) {\n        temp = cur;\n        cur = max(cur, prev + num);\n        prev = temp;\n    }\n    return cur;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {2, 7, 9, 3, 1};\n    cout &lt;&lt; rob(nums) &lt;&lt; endl;  // 12\n    return 0;\n}\n</code></pre>"},{"location":"content/top100liked/dynamic_programming/#279-perfect-squares","title":"279. Perfect Squares","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, breadth first search 279. Perfect Squares - Python Solution<pre><code>import math\n\n\n# DP - Knapsack Unbounded\ndef numSquares(n: int) -&gt; int:\n    dp = [float(\"inf\") for _ in range(n + 1)]\n    dp[0] = 0\n\n    for i in range(1, n + 1):\n        for j in range(1, int(math.sqrt(n)) + 1):\n            dp[i] = min(dp[i], dp[i - j**2] + 1)\n\n    return dp[n]\n\n\nn = 12\nprint(numSquares(n))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/dynamic_programming/#322-coin-change","title":"322. Coin Change","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, breadth first search 322. Coin Change - Python Solution<pre><code>from typing import List\n\n\ndef coinChange(coins: List[int], amount: int) -&gt; int:\n    dp = [float(\"inf\") for _ in range(amount + 1)]\n\n    dp[0] = 0\n\n    for i in range(1, amount + 1):\n        for c in coins:\n            if i - c &gt;= 0:\n                dp[i] = min(dp[i], 1 + dp[i - c])\n\n    return dp[amount] if dp[amount] != float(\"inf\") else -1\n\n\ncoins = [1, 2, 5]\namount = 11\nprint(coinChange(coins, amount))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/dynamic_programming/#139-word-break","title":"139. Word Break","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, dynamic programming, trie, memoization 139. Word Break - Python Solution<pre><code>from typing import List\n\n\n# DP (Unbounded Knapsack)\ndef wordBreak(s: str, wordDict: List[str]) -&gt; bool:\n    n = len(s)\n    dp = [False for _ in range(n + 1)]\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for word in wordDict:\n            m = len(word)\n            if s[i - m : i] == word and dp[i - m]:\n                dp[i] = True\n    return dp[-1]\n\n\ns = \"leetcode\"\nwordDict = [\"leet\", \"code\"]\nprint(wordBreak(s, wordDict))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/dynamic_programming/#300-longest-increasing-subsequence","title":"300. Longest Increasing Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, dynamic programming 300. Longest Increasing Subsequence - Python Solution<pre><code>from functools import cache\nfrom typing import List\n\n\n# DP - LIS\ndef lengthOfLISMemo(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return n\n\n    @cache\n    def dfs(i: int) -&gt; int:\n        res = 0\n        for j in range(i):\n            if nums[j] &lt; nums[i]:\n                res = max(res, dfs(j))\n        return res + 1\n\n    return max(dfs(i) for i in range(n))\n\n\n# DP - LIS\ndef lengthOfLISTable(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return n\n\n    dp = [1 for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i):\n            if nums[i] &gt; nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\n\nif __name__ == \"__main__\":\n    assert lengthOfLISMemo([10, 9, 2, 5, 3, 7, 101, 18]) == 4\n    assert lengthOfLISTable([10, 9, 2, 5, 3, 7, 101, 18]) == 4\n    assert lengthOfLISMemo([0, 1, 0, 3, 2, 3]) == 4\n    assert lengthOfLISTable([0, 1, 0, 3, 2, 3]) == 4\n    assert lengthOfLISMemo([7, 7, 7, 7]) == 1\n    assert lengthOfLISTable([7, 7, 7, 7]) == 1\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/dynamic_programming/#152-maximum-product-subarray","title":"152. Maximum Product Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming 152. Maximum Product Subarray - Python Solution<pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxProduct(nums: List[int]) -&gt; int:\n    n = len(nums)\n    dp_max = [0 for _ in range(n)]\n    dp_min = [0 for _ in range(n)]\n\n    dp_max[0] = nums[0]\n    dp_min[0] = nums[0]\n    max_product = nums[0]\n\n    for i in range(1, n):\n        dp_max[i] = max(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n        dp_min[i] = min(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n\n        max_product = max(max_product, dp_max[i])\n\n    return max_product\n\n\nnums = [2, 3, -2, 4]\nprint(maxProduct(nums))  # 6\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/dynamic_programming/#416-partition-equal-subset-sum","title":"416. Partition Equal Subset Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming 416. Partition Equal Subset Sum - Python Solution<pre><code>from functools import cache\nfrom typing import List\n\nfrom template import knapsack01\n\n\n# Memoization\ndef canPartitionMemoization(nums: List[int]) -&gt; bool:\n    total = sum(nums)\n    n = len(nums)\n\n    if total % 2 == 1 or n &lt;= 1:\n        return False\n\n    @cache\n    def dfs(i, j):\n        if i &lt; 0:\n            return j == 0\n        return j &gt;= nums[i] and dfs(i - 1, j - nums[i]) or dfs(i - 1, j)\n\n    return dfs(n - 1, total // 2)\n\n\n# DP - Knapsack 01\ndef canPartitionTemplate(nums: List[int]) -&gt; bool:\n    total = sum(nums)\n\n    if total % 2 == 1 or len(nums) &lt; 2:\n        return False\n\n    target = total // 2\n\n    return knapsack01(nums, nums, target) == target\n\n\n# DP - Knapsack 01\ndef canPartition(nums: List[int]) -&gt; bool:\n    total = sum(nums)\n\n    if total % 2 == 1 or len(nums) &lt; 2:\n        return False\n\n    target = total // 2\n\n    dp = [0 for _ in range(target + 1)]\n\n    for i in range(len(nums)):\n        for j in range(target, nums[i] - 1, -1):\n            dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])\n\n    return dp[target] == target\n\n\nif __name__ == \"__main__\":\n    nums = [1, 5, 11, 5]\n    print(canPartitionTemplate(nums))  # True\n    print(canPartition(nums))  # True\n    print(canPartitionMemoization(nums))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/dynamic_programming/#32-longest-valid-parentheses","title":"32. Longest Valid Parentheses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming, stack 32. Longest Valid Parentheses - Python Solution<pre><code># Stack\ndef longestValidParentheses(s: str) -&gt; int:\n    stack = [-1]\n    res = 0\n\n    for i, ch in enumerate(s):\n        if ch == \"(\":\n            stack.append(i)\n        elif ch == \")\":\n            stack.pop()\n            if stack:\n                res = max(res, i - stack[-1])\n            else:\n                stack.append(i)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    print(longestValidParentheses(\"(()\"))  # 2\n    print(longestValidParentheses(\")()())\"))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/graph/","title":"Graph","text":""},{"location":"content/top100liked/graph/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 200. Number of Islands (Medium)</li> <li> 994. Rotting Oranges (Medium)</li> <li> 207. Course Schedule (Medium)</li> <li> 208. Implement Trie (Prefix Tree) (Medium)</li> </ul>"},{"location":"content/top100liked/graph/#200-number-of-islands","title":"200. Number of Islands","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix</p> </li> <li>Count the number of islands in a 2D grid.</li> <li>Method 1: DFS</li> <li> <p>Method 2: BFS (use a queue to traverse the grid)</p> </li> <li> <p>How to keep track of visited cells?</p> <ol> <li>Mark the visited cell as <code>0</code> (or any other value) to avoid revisiting it.</li> <li>Use a set to store the visited cells.</li> </ol> </li> <li> <p>Steps:</p> <ol> <li>Init: variables</li> <li>DFS/BFS: starting from the cell with <code>1</code>, turn all the connected <code>1</code>s to <code>0</code>.</li> <li>Traverse the grid, and if the cell is <code>1</code>, increment the count and call DFS/BFS.</li> </ol> </li> </ul> <p></p> 200. Number of Islands - Python Solution<pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef numIslandsDFS(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    res = 0\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] != \"1\":\n            return\n\n        grid[r][c] = \"2\"\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                dfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Set\ndef numIslandsBFS1(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == \"0\"\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\" and (r, c) not in visited:\n                visited.add((r, c))\n                bfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = dr + row, dc + col\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] != \"1\"\n                ):\n                    continue\n                grid[nr][nc] = \"2\"\n                q.append((nr, nc))\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == \"1\":\n                grid[i][j] = \"2\"\n                bfs(i, j)\n                res += 1\n\n    return res\n\n\ngrid = [\n    [\"1\", \"1\", \"1\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"0\", \"0\", \"0\", \"0\", \"0\"],\n]\n\nprint(numIslandsDFS(deepcopy(grid)))  # 1\nprint(numIslandsBFS1(deepcopy(grid)))  # 1\nprint(numIslandsBFS2(deepcopy(grid)))  # 1\n</code></pre> 200. Number of Islands - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\nprivate:\n    void dfs(vector&lt;vector&lt;char&gt;&gt; &amp;grid, int r, int c)\n    {\n        int row = grid.size();\n        int col = grid[0].size();\n\n        if (r &lt; 0 || r &gt;= row || c &lt; 0 || c &gt;= col || grid[r][c] != '1')\n        {\n            return;\n        }\n        grid[r][c] = '0';\n\n        dfs(grid, r - 1, c);\n        dfs(grid, r + 1, c);\n        dfs(grid, r, c - 1);\n        dfs(grid, r, c + 1);\n    }\n\npublic:\n    int numIslands(vector&lt;vector&lt;char&gt;&gt; &amp;grid)\n    {\n        int m = grid.size(), n = grid[0].size();\n        int res = 0;\n        for (int i = 0; i &lt; m; i++)\n        {\n            for (int j = 0; j &lt; n; j++)\n            {\n                if (grid[i][j] == '1')\n                {\n                    res++;\n                    dfs(grid, i, j);\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    Solution s;\n    vector&lt;vector&lt;char&gt;&gt; grid = {\n        {'1', '1', '0', '0', '0'},\n        {'1', '1', '0', '0', '0'},\n        {'0', '0', '1', '0', '0'},\n        {'0', '0', '0', '1', '1'}};\n    cout &lt;&lt; s.numIslands(grid) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/top100liked/graph/#994-rotting-oranges","title":"994. Rotting Oranges","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, breadth first search, matrix</p> </li> <li>Return the minimum number of minutes that must elapse until no cell has a fresh orange.</li> <li>Hint: Multi-source BFS to count the level.</li> </ul> <p></p> 994. Rotting Oranges - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef orangesRotting(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    fresh = 0\n    q = deque()\n    dirs = [[1, 0], [0, 1], [0, -1], [-1, 0]]\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 2:\n                q.append([i, j])\n            elif grid[i][j] == 1:\n                fresh += 1\n    res = 0\n\n    while q and fresh &gt; 0:\n        size = len(q)\n        for _ in range(size):\n            r, c = q.popleft()\n            for dr, dc in dirs:\n                nr, nc = dr + r, dc + c\n                if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and grid[nr][nc] == 1:\n                    q.append([nr, nc])\n                    grid[nr][nc] = 2\n                    fresh -= 1\n        res += 1\n\n    return res if fresh == 0 else -1\n\n\ngrid = [[2, 1, 1], [1, 1, 0], [0, 1, 1]]\nassert orangesRotting(grid) == 4\n</code></pre>"},{"location":"content/top100liked/graph/#207-course-schedule","title":"207. Course Schedule","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort</p> </li> <li>Return true if it is possible to finish all courses, otherwise return false.</li> <li>Dependency relationships imply the topological sort algorithm.</li> <li>Cycle detection</li> <li>Topological Sort</li> <li>DAG (Directed Acyclic Graph)</li> <li>Time complexity: O(V+E)</li> <li>Space complexity: O(V+E)</li> <li>Prerequisites: Indegree (Look at the problem 1557. Minimum Number of Vertices to Reach All Nodes)<ul> <li>Indegree: Number of incoming edges to a vertex</li> </ul> </li> <li>Applications: task scheduling, course scheduling, build systems, dependency resolution, compiler optimization, etc.</li> </ul> <p></p> <p></p> <p>Course to prerequisites mapping</p> <pre><code>flowchart LR\n    0((0)) --&gt; 1((1))\n    0((0)) --&gt; 2((2))\n    1((1)) --&gt; 3((3))\n    3((3)) --&gt; 4((4))\n    1((1)) --&gt; 4((4))</code></pre> <p>Prerequisites to course mapping</p> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    2((2)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))\n    4((4)) --&gt; 3((3))\n    4((4)) --&gt; 1((1))</code></pre> course 0 0 1 1 3 prerequisite 1 2 3 4 4 index 0 1 2 3 4 in-degree 0 0 0 0 0 <p>Initialize</p> <ul> <li>graph</li> </ul> prerequisite 1 2 3 4 course <code>[0]</code> <code>[0]</code> <code>[1]</code> <code>[1, 3]</code> <ul> <li>in-degree</li> </ul> 0 1 2 3 4 in-degree 2 2 0 1 0 <ul> <li>queue: <code>[2, 4]</code></li> <li>pop <code>2</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))\n    4((4)) --&gt; 3((3))\n    4((4)) --&gt; 1((1))</code></pre> 0 1 2 3 4 in-degree 1 2 0 1 0 <ul> <li>queue: <code>[4]</code></li> <li>pop <code>4</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))</code></pre> 0 1 2 3 4 in-degree 1 1 0 0 0 <ul> <li>queue: <code>[3]</code></li> <li>pop <code>3</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))</code></pre> 0 1 2 3 4 in-degree 1 0 0 0 0 <ul> <li>queue: <code>[1]</code></li> <li>pop <code>1</code> from the queue</li> </ul> <pre><code>flowchart LR\n    0((0))</code></pre> 0 1 2 3 4 in-degree 0 0 0 0 0 <ul> <li>queue: <code>[0]</code></li> <li>pop <code>0</code> from the queue</li> <li>All courses are taken. Return <code>True</code>.</li> </ul> 207. Course Schedule - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS (Kahn's Algorithm)\ndef canFinishBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    count = 0\n\n    while q:\n        crs = q.popleft()\n        count += 1\n\n        for nxt in graph[crs]:\n            indegree[nxt] -= 1\n\n            if indegree[nxt] == 0:\n                q.append(nxt)\n\n    return count == numCourses\n\n\n# DFS + Set\ndef canFinishDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for crs, pre in prerequisites:\n        graph[crs].append(pre)\n\n    visiting = set()\n\n    def dfs(crs):\n        if crs in visiting:  # cycle detected\n            return False\n        if graph[crs] == []:\n            return True\n\n        visiting.add(crs)\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        visiting.remove(crs)\n        graph[crs] = []\n\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\n# DFS + List\ndef canFinishDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for pre, crs in prerequisites:\n        graph[crs].append(pre)\n\n    # 0: init, 1: visiting, 2: visited\n    status = [0] * numCourses\n\n    def dfs(crs):\n        if status[crs] == 1:  # cycle detected\n            return False\n        if status[crs] == 2:\n            return True\n\n        status[crs] = 1\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        status[crs] = 2\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(canFinishBFS(5, prerequisites))  # True\nprint(canFinishDFS1(5, prerequisites))  # True\nprint(canFinishDFS2(5, prerequisites))  # True\n</code></pre> 207. Course Schedule - C++ Solution<pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    // BFS\n    bool canFinishBFS(int numCourses, vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        vector&lt;int&gt; indegree(numCourses, 0);\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n            indegree[pre[0]]++;\n        }\n\n        queue&lt;int&gt; q;\n        for (int i = 0; i &lt; numCourses; i++) {\n            if (indegree[i] == 0) {\n                q.push(i);\n            }\n        }\n\n        int cnt = 0;\n        while (!q.empty()) {\n            int cur = q.front();\n            q.pop();\n            cnt++;\n\n            for (int nxt : graph[cur]) {\n                indegree[nxt]--;\n                if (indegree[nxt] == 0) {\n                    q.push(nxt);\n                }\n            }\n        }\n        return cnt == numCourses;\n    }\n\n    // DFS\n    bool canFinishDFS(int numCourses, vector&lt;vector&lt;int&gt;&gt; &amp;prerequisites) {\n        vector&lt;vector&lt;int&gt;&gt; graph(numCourses);\n        for (auto &amp;pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n        }\n        // 0: not visited, 1: visiting, 2: visited\n        vector&lt;int&gt; state(numCourses, 0);\n\n        function&lt;bool(int)&gt; dfs = [&amp;](int pre) -&gt; bool {\n            state[pre] = 1;  // visiting\n            for (int crs : graph[pre]) {\n                if (state[crs] == 1 || (state[crs] == 0 &amp;&amp; dfs(crs))) {\n                    return true;\n                }\n            }\n            state[pre] = 2;  // visited\n            return false;\n        };\n\n        for (int i = 0; i &lt; numCourses; i++) {\n            if (state[i] == 0 &amp;&amp; dfs(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution sol;\n    vector&lt;vector&lt;int&gt;&gt; prerequisites = {{1, 0}, {2, 1}, {3, 2}, {4, 3},\n                                         {5, 4}, {6, 5}, {7, 6}, {8, 7},\n                                         {9, 8}, {10, 9}};\n    int numCourses = 11;\n    cout &lt;&lt; sol.canFinishBFS(numCourses, prerequisites) &lt;&lt; endl;\n    cout &lt;&lt; sol.canFinishDFS(numCourses, prerequisites) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/top100liked/graph/#208-implement-trie-prefix-tree","title":"208. Implement Trie (Prefix Tree)","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, design, trie</p> </li> </ul>"},{"location":"content/top100liked/graph/#trie","title":"Trie","text":"<ul> <li>A trie is a tree-like data structure whose nodes store the letters of an alphabet.</li> </ul> <pre><code>flowchart TD\nRoot(( ))\nRoot --- C1((\"C\"))\nRoot --- D((D))\nC1 --- A1((\"A\"))\nA1 --- T1((\"T\"))\nA1 --- R1((\"R\"))\nA1 --- N((N))\nRoot --- B1((B))\nB1 --- A2((A))\nA2 --- T2((T))\nA2 --- R2((R))</code></pre> 208. Implement Trie (Prefix Tree) - Python Solution<pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.endOfWord = None\n\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.endOfWord = True\n\n    def search(self, word: str) -&gt; bool:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return node.endOfWord\n\n    def startsWith(self, prefix: str) -&gt; bool:\n        node = self.root\n\n        for c in prefix:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return True\n\n\n# Your Trie object will be instantiated and called as such:\nobj = Trie()\nobj.insert(\"apple\")\nprint(obj.search(\"word\"))  # False\nprint(obj.startsWith(\"app\"))  # True\n</code></pre>"},{"location":"content/top100liked/greedy/","title":"Greedy","text":""},{"location":"content/top100liked/greedy/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 121. Best Time to Buy and Sell Stock (Easy)</li> <li> 55. Jump Game (Medium)</li> <li> 45. Jump Game II (Medium)</li> <li> 763. Partition Labels (Medium)</li> </ul>"},{"location":"content/top100liked/greedy/#121-best-time-to-buy-and-sell-stock","title":"121. Best Time to Buy and Sell Stock","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li>Return the maximum profit that can be achieved from buying on one day and selling on another day.</li> </ul> 121. Best Time to Buy and Sell Stock - Python Solution<pre><code>from typing import List\n\n\n# Brute Force\ndef maxProfitBF(prices: List[int]) -&gt; int:\n    max_profit = 0\n    n = len(prices)\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_profit = max(max_profit, prices[j] - prices[i])\n\n    return max_profit\n\n\n# DP\ndef maxProfitDP(prices: List[int]) -&gt; int:\n    dp = [[0] * 2 for _ in range(len(prices))]\n    dp[0][0] = -prices[0]  # buy\n    dp[0][1] = 0  # sell\n\n    for i in range(1, len(prices)):\n        dp[i][0] = max(dp[i - 1][0], -prices[i])  # the lowest price to buy\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    max_profit = 0\n    seen_min = prices[0]\n\n    for i in range(1, len(prices)):\n        max_profit = max(max_profit, prices[i] - seen_min)\n        seen_min = min(seen_min, prices[i])\n\n    return max_profit\n\n\n# Fast Slow Pointers\ndef maxProfitFS(prices: List[int]) -&gt; int:\n    max_profit = 0\n    slow, fast = 0, 1\n\n    while fast &lt; len(prices):\n        if prices[fast] &gt; prices[slow]:\n            max_profit = max(max_profit, prices[fast] - prices[slow])\n        else:\n            slow = fast\n        fast += 1\n\n    return max_profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force|  O(n^2)|  O(1)   |\n# | DP         |  O(n)  |  O(n)   |\n# | Greedy     |  O(n)  |  O(1)   |\n# | Fast Slow  |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitBF(prices))  # 5\nprint(maxProfitDP(prices))  # 5\nprint(maxProfitGreedy(prices))  # 5\nprint(maxProfitFS(prices))  # 5\n</code></pre> 121. Best Time to Buy and Sell Stock - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int maxProfit(vector&lt;int&gt; &amp;prices)\n    {\n        if (prices.size() &lt;= 1)\n            return 0;\n\n        int seen_min = prices[0];\n        int res = 0;\n\n        for (int &amp;price : prices)\n        {\n            res = max(res, price - seen_min);\n            seen_min = min(seen_min, price);\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    vector&lt;int&gt; prices = {7, 1, 5, 3, 6, 4};\n    Solution obj;\n    cout &lt;&lt; obj.maxProfit(prices) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/top100liked/greedy/#55-jump-game","title":"55. Jump Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> <li>Return <code>True</code> if you can reach the last index, otherwise <code>False</code>.</li> </ul> 55. Jump Game - Python Solution<pre><code>from typing import List\n\n\n# Greedy - Interval\ndef canJump(nums: List[int]) -&gt; bool:\n    n = len(nums)\n    reach = 0\n    i = 0\n\n    while reach &gt;= i:\n        if reach &gt;= n - 1:\n            return True\n        reach = max(reach, i + nums[i])\n        i += 1\n\n    return False\n\n\nif __name__ == \"__main__\":\n    assert canJump([2, 3, 1, 1, 4]) is True\n    assert canJump([3, 2, 1, 0, 4]) is False\n</code></pre> 55. Jump Game - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool canJump(vector&lt;int&gt;&amp; nums) {\n        int canReach = 0;\n        int n = nums.size();\n\n        for (int i = 0; i &lt; n; i++) {\n            if (i &gt; canReach) return false;\n            canReach = max(canReach, i + nums[i]);\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution obj;\n    vector&lt;int&gt; nums = {2, 3, 1, 1, 4};\n    cout &lt;&lt; obj.canJump(nums) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/top100liked/greedy/#45-jump-game-ii","title":"45. Jump Game II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> <li>Return the minimum number of jumps to reach the last index.</li> </ul> 45. Jump Game II - Python Solution<pre><code>from typing import List\n\n\n# Greedy - Interval\ndef jump(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n == 1:\n        return 0\n\n    reach = 0\n    left, right = 0, 0\n    res = 0\n\n    while right &lt; n - 1:\n        for i in range(left, right + 1):\n            reach = max(reach, i + nums[i])\n\n        left = right + 1\n        right = reach\n        res += 1\n\n    return res\n\n\nif __name__ == \"__main__\":\n    assert jump([2, 3, 1, 1, 4]) == 2\n    assert jump([2, 3, 0, 1, 4]) == 2\n</code></pre>"},{"location":"content/top100liked/greedy/#763-partition-labels","title":"763. Partition Labels","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, two pointers, string, greedy 763. Partition Labels - Python Solution<pre><code>from typing import List\n\n\n# 1. Hashmap\ndef partitionLabels1(s: str) -&gt; List[int]:\n    hashmap = {}\n\n    for i, j in enumerate(s):\n        if j not in hashmap:\n            hashmap[j] = [i, i]\n        else:\n            hashmap[j][1] = i\n\n    intervals = list(hashmap.values())\n    intervals.sort(key=lambda x: x[0])\n\n    if len(intervals) &lt; 2:\n        return len(intervals)\n\n    res = []\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &lt; intervals[i - 1][1]:\n            intervals[i][1] = max(intervals[i][1], intervals[i - 1][1])\n        else:\n            res.append(intervals[i][0])\n\n    res.append(intervals[-1][1] + 1)\n\n    if len(res) == 1:\n        return res\n    else:\n        for i in range(len(res) - 1, 0, -1):\n            res[i] -= res[i - 1]\n        return res\n\n\n# Single Pass Partitioning\ndef partitionLabels2(s: str) -&gt; List[int]:\n    last = {c: i for i, c in enumerate(s)}\n    res = []\n    start, end = 0, 0\n\n    for i, c in enumerate(s):\n        end = max(end, last[c])\n        if end == i:\n            res.append(end - start + 1)\n            start = i + 1\n\n    return res\n\n\nprint(partitionLabels1(\"abaccd\"))  # [3, 2, 1]\nprint(partitionLabels2(\"abaccd\"))  # [3, 2, 1]\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/hash/","title":"Hash","text":""},{"location":"content/top100liked/hash/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 1. Two Sum (Easy)</li> <li> 49. Group Anagrams (Medium)</li> <li> 128. Longest Consecutive Sequence (Medium)</li> </ul>"},{"location":"content/top100liked/hash/#1-two-sum","title":"1. Two Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table</p> </li> <li>Return the indices of the two numbers such that they add up to a specific target.</li> <li>Approach: Use a hashmap to store the indices of the numbers.</li> <li>Time Complexity: O(n)</li> <li>Space Complexity: O(n)</li> </ul> 1. Two Sum - Python Solution<pre><code>from typing import List\n\n\ndef twoSum(nums: List[int], target: int) -&gt; List[int]:\n    hashmap = {}  # val: idx\n\n    for idx, val in enumerate(nums):\n        if (target - val) in hashmap:\n            return [hashmap[target - val], idx]\n\n        hashmap[val] = idx\n\n\nif __name__ == \"__main__\":\n    nums = [2, 7, 11, 15]\n    target = 9\n    assert twoSum(nums, target) == [0, 1]\n</code></pre> 1. Two Sum - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;nums, int target) {\n    unordered_map&lt;int, int&gt; hashmap;\n\n    for (size_t i = 0; i &lt; nums.size(); i++) {\n        int complement = target - nums[i];\n\n        if (hashmap.find(complement) != hashmap.end()) {\n            return {hashmap[complement], (int)i};\n        }\n        hashmap[nums[i]] = (int)i;\n    }\n\n    return {-1, -1};\n}\n\nint main() {\n    vector&lt;int&gt; nums = {2, 7, 11, 15};\n    int target = 9;\n    vector&lt;int&gt; result = twoSum(nums, target);\n    cout &lt;&lt; result[0] &lt;&lt; \", \" &lt;&lt; result[1] &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/top100liked/hash/#49-group-anagrams","title":"49. Group Anagrams","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, sorting 49. Group Anagrams - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash - List\ndef groupAnagrams(strs: List[str]) -&gt; List[List[str]]:\n    result = defaultdict(list)\n\n    for s in strs:\n        count = [0] * 26\n        for i in s:\n            count[ord(i) - ord(\"a\")] += 1\n\n        result[tuple(count)].append(s)\n\n    return list(result.values())\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Hash     |     O(n * k)    |     O(n)     |\n# |-------------|-----------------|--------------|\n\n\nstrs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\nprint(groupAnagrams(strs))\n# [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/hash/#128-longest-consecutive-sequence","title":"128. Longest Consecutive Sequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, union find 128. Longest Consecutive Sequence - Python Solution<pre><code>from typing import List\n\n\n# Set\ndef longestConsecutiveSet(nums: List[int]) -&gt; int:\n    num_set = set(nums)  # O(n)\n    longest = 0\n\n    for n in nums:\n        if (n - 1) not in num_set:  # left boundary\n            length = 1\n\n            while (n + length) in num_set:\n                length += 1\n\n            longest = max(longest, length)\n\n    return longest\n\n\n# Union Find\ndef longestConsecutiveUF(nums: List[int]) -&gt; int:\n    if not nums:\n        return 0\n\n    par = {num: num for num in nums}\n    rank = {num: 1 for num in nums}\n\n    def find(num):\n        p = par[num]\n        while p != par[p]:\n            p = par[p]\n        return p\n\n    def union(num1, num2):\n        p1, p2 = find(num1), find(num2)\n        if p1 == p2:\n            return\n\n        if rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n            rank[p2] += rank[p1]\n        else:\n            par[p2] = p1\n            rank[p1] += rank[p2]\n\n    for num in nums:\n        if num - 1 in par:\n            union(num, num - 1)\n\n    return max(rank.values())\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |  Set       |  O(N)  |  O(N)   |\n# | Union Find |  O(N)  |  O(N)   |\n# |------------|--------|---------|\n\n\nnums = [100, 4, 200, 1, 3, 2]\nprint(longestConsecutiveSet(nums))  # 4\nprint(longestConsecutiveUF(nums))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/heap/","title":"Heap","text":""},{"location":"content/top100liked/heap/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 215. Kth Largest Element in an Array (Medium)</li> <li> 347. Top K Frequent Elements (Medium)</li> <li> 295. Find Median from Data Stream (Hard)</li> </ul>"},{"location":"content/top100liked/heap/#215-kth-largest-element-in-an-array","title":"215. Kth Largest Element in an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, divide and conquer, sorting, heap priority queue, quickselect 215. Kth Largest Element in an Array - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\ndef findKthLargest(nums: List[int], k: int) -&gt; int:\n    min_heap = []\n\n    for i, num in enumerate(nums):\n        heapq.heappush(min_heap, num)\n        if i &gt;= k:\n            heapq.heappop(min_heap)\n\n    return min_heap[0]\n\n\nif __name__ == \"__main__\":\n    assert findKthLargest([3, 2, 1, 5, 6, 4], 2) == 5\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/heap/#347-top-k-frequent-elements","title":"347. Top K Frequent Elements","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, divide and conquer, sorting, heap priority queue, bucket sort, counting, quickselect 347. Top K Frequent Elements - Python Solution<pre><code>import heapq\nfrom collections import Counter\nfrom typing import List\n\n\n# Heap + Counter\ndef topKFrequent(nums: List[int], k: int) -&gt; List[int]:\n    minHeap = []\n\n    for val, freq in Counter(nums).items():\n        if len(minHeap) &lt; k:\n            heapq.heappush(minHeap, (freq, val))\n        else:\n            heapq.heappushpop(minHeap, (freq, val))\n\n    return [i for _, i in minHeap]\n\n\n# Counter (Most Common)\ndef topKFrequentCounter(nums: List[int], k: int) -&gt; List[int]:\n    commons = Counter(nums).most_common(k)\n    return [i for i, _ in commons]\n\n\nnums = [1, 1, 1, 2, 2, 3]\nk = 2\nprint(topKFrequent(nums, k))  # [1, 2]\nprint(topKFrequentCounter(nums, k))  # [1, 2]\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/heap/#295-find-median-from-data-stream","title":"295. Find Median from Data Stream","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: two pointers, design, sorting, heap priority queue, data stream 295. Find Median from Data Stream - Python Solution<pre><code>from heapq import heappop, heappush\n\n\n# Dual Heaps\nclass MedianFinder:\n\n    def __init__(self):\n        self.minHeap = []\n        self.maxHeap = []\n        self.min_size = 0\n        self.max_size = 0\n\n    def addNum(self, num: int) -&gt; None:\n        heappush(self.maxHeap, -num)\n        heappush(self.minHeap, -heappop(self.maxHeap))\n        self.min_size += 1\n\n        if self.min_size &gt; self.max_size:\n            heappush(self.maxHeap, -heappop(self.minHeap))\n            self.min_size -= 1\n            self.max_size += 1\n\n    def findMedian(self) -&gt; float:\n        if self.min_size == self.max_size:\n            return (-self.maxHeap[0] + self.minHeap[0]) / 2.0\n        return -self.maxHeap[0]\n\n\nobj = MedianFinder()\nobj.addNum(1)\nobj.addNum(2)\nassert obj.findMedian() == 1.5\nobj.addNum(3)\nassert obj.findMedian() == 2\nobj.addNum(4)\nassert obj.findMedian() == 2.5\nobj.addNum(5)\nassert obj.findMedian() == 3\nprint(\"All Passed.\")\n</code></pre></p> </li> </ul> 295. Find Median from Data Stream - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass MedianFinder {\n   private:\n    priority_queue&lt;int&gt; maxHeap;\n    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;\n    int max_size = 0;\n    int min_size = 0;\n\n   public:\n    MedianFinder() {}\n\n    void addNum(int num) {\n        if (min_size == max_size) {\n            minHeap.push(num);\n            maxHeap.push(minHeap.top());\n            minHeap.pop();\n            max_size++;\n        } else {\n            maxHeap.push(num);\n            minHeap.push(maxHeap.top());\n            maxHeap.pop();\n            min_size++;\n        }\n    }\n\n    double findMedian() {\n        if (min_size == max_size) {\n            return (maxHeap.top() + minHeap.top()) / 2.0;\n        } else {\n            return (double)maxHeap.top();\n        }\n    }\n};\n\nint main() {\n    MedianFinder* obj = new MedianFinder();\n    obj-&gt;addNum(1);\n    obj-&gt;addNum(2);\n    cout &lt;&lt; obj-&gt;findMedian() &lt;&lt; endl;  // 1.5\n    obj-&gt;addNum(3);\n    cout &lt;&lt; obj-&gt;findMedian() &lt;&lt; endl;  // 2\n    return 0;\n}\n</code></pre>"},{"location":"content/top100liked/linked_list/","title":"Linked List","text":""},{"location":"content/top100liked/linked_list/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 160. Intersection of Two Linked Lists (Easy)</li> <li> 206. Reverse Linked List (Easy)</li> <li> 234. Palindrome Linked List (Easy)</li> <li> 141. Linked List Cycle (Easy)</li> <li> 142. Linked List Cycle II (Medium)</li> <li> 21. Merge Two Sorted Lists (Easy)</li> <li> 2. Add Two Numbers (Medium)</li> <li> 19. Remove Nth Node From End of List (Medium)</li> <li> 24. Swap Nodes in Pairs (Medium)</li> <li> 25. Reverse Nodes in k-Group (Hard)</li> <li> 138. Copy List with Random Pointer (Medium)</li> <li> 148. Sort List (Medium)</li> <li> 23. Merge k Sorted Lists (Hard)</li> <li> 146. LRU Cache (Medium)</li> </ul>"},{"location":"content/top100liked/linked_list/#160-intersection-of-two-linked-lists","title":"160. Intersection of Two Linked Lists","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, linked list, two pointers</p> </li> <li>Find the node at which the intersection of two singly linked lists begins.</li> </ul> <pre><code>graph LR\n    a1((a1)) --&gt; a2((a2))\n    a2 --&gt; c1((c1))\n    b1((b1)) --&gt; b2((b2))\n    b2 --&gt; b3((b3))\n    b3 --&gt; c1\n    c1 --&gt; c2((c2))\n    c2 --&gt; c3((c3))</code></pre> 160. Intersection of Two Linked Lists - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Hash Set\ndef getIntersectionNodeHash(\n    headA: ListNode, headB: ListNode\n) -&gt; Optional[ListNode]:\n    if not headA or not headB:\n        return None\n\n    visited = set()\n    cur = headA\n    while cur:\n        visited.add(cur)\n        cur = cur.next\n\n    cur = headB\n    while cur:\n        if cur in visited:\n            return cur\n        cur = cur.next\n\n    return None\n\n\n# Two Pointers\ndef getIntersectionNodeTP(\n    headA: ListNode, headB: ListNode\n) -&gt; Optional[ListNode]:\n    if not headA or not headB:\n        return None\n\n    a, b = headA, headB\n\n    while a != b:\n        a = a.next if a else headB\n        b = b.next if b else headA\n\n    return a\n\n\nlistA = [4, 1, 8, 4, 5]\nlistB = [5, 6, 1, 8, 4, 5]\nheadA = ListNode.create(listA)\nprint(headA)\n# 4 -&gt; 1 -&gt; 8 -&gt; 4 -&gt; 5\nheadB = ListNode.create(listB)\nprint(headB)\n# 5 -&gt; 6 -&gt; 1 -&gt; 8 -&gt; 4 -&gt; 5\n\nheadA.intersect(headB, 8)\n\nprint(getIntersectionNodeHash(headA, headB))\n# 8 -&gt; 4 -&gt; 5\nprint(getIntersectionNodeTP(headA, headB))\n# 8 -&gt; 4 -&gt; 5\n</code></pre>"},{"location":"content/top100liked/linked_list/#206-reverse-linked-list","title":"206. Reverse Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: linked list, recursion</p> </li> <li>Reverse a singly linked list.</li> </ul> <pre><code>graph LR\nA((1)) --&gt; B((2))\nB --&gt; C((3))\nC --&gt; D((4))\nD --&gt; E((5))</code></pre> <pre><code>graph RL\nE((5)) --&gt; D((4))\nD --&gt; C((3))\nC --&gt; B((2))\nB --&gt; A((1))</code></pre> 206. Reverse Linked List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Iterative\ndef reverseListIterative(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    cur = head\n    prev = None\n\n    while cur:\n        temp = cur.next\n        cur.next = prev\n\n        prev = cur\n        cur = temp\n\n    return prev\n\n\n# Recursive\ndef reverseListRecursive(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    def reverse(cur, prev):\n        if not cur:\n            return prev\n\n        temp = cur.next\n        cur.next = prev\n\n        return reverse(temp, cur)\n\n    return reverse(head, None)\n\n\nnums = [1, 2, 3, 4, 5]\nhead1 = ListNode.create(nums)\nprint(head1)\n# 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(reverseListIterative(head1))\n# 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1\nhead2 = ListNode.create(nums)\nprint(reverseListRecursive(head2))\n# 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1\n</code></pre>"},{"location":"content/top100liked/linked_list/#234-palindrome-linked-list","title":"234. Palindrome Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: linked list, two pointers, stack, recursion 234. Palindrome Linked List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef isPalindrome(head: Optional[ListNode]) -&gt; bool:\n    if not head or not head.next:\n        return True\n\n    def middle(node):\n        fast, slow = node, node\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n        return slow\n\n    def reverse(node):\n        cur, pre = node, None\n        while cur:\n            nxt = cur.next\n            cur.next = pre\n            pre = cur\n            cur = nxt\n        return pre\n\n    mid1 = head\n    mid2 = reverse(middle(head))\n\n    while mid2:\n        if mid1.val != mid2.val:\n            return False\n        mid1 = mid1.next\n        mid2 = mid2.next\n\n    return True\n\n\nhead = ListNode().create([1, 2, 2, 1])\nprint(isPalindrome(head))  # True\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/linked_list/#141-linked-list-cycle","title":"141. Linked List Cycle","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, linked list, two pointers</p> </li> <li>Determine if a linked list has a cycle in it.</li> </ul> <pre><code>graph LR\n    A((3)) --&gt; B((2))\n    B --&gt; C((0))\n    C --&gt; D((4))</code></pre> <pre><code>graph LR\n    A((3)) --&gt; B((2))\n    B --&gt; C((0))\n    C --&gt; D((4))\n    D --&gt; B</code></pre> 141. Linked List Cycle - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\ndef hasCycle(head: Optional[ListNode]) -&gt; bool:\n    slow, fast = head, head\n\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n        if slow == fast:\n            return True\n\n    return False\n\n\nprint(hasCycle(ListNode.create([3, 2, 0, -4])))  # False\nprint(hasCycle(ListNode.create([3, 2, 0, -4], 1)))  # True\n</code></pre> 141. Linked List Cycle - C++ Solution<pre><code>#include &lt;iostream&gt;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nclass Solution {\n   public:\n    bool hasCycle(ListNode* head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while (fast &amp;&amp; fast-&gt;next) {\n            slow = slow-&gt;next;\n            fast = fast-&gt;next-&gt;next;\n\n            if (fast == slow) return true;\n        }\n        return false;\n    }\n};\n</code></pre>"},{"location":"content/top100liked/linked_list/#142-linked-list-cycle-ii","title":"142. Linked List Cycle II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, linked list, two pointers</p> </li> <li>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>None</code>.</li> </ul> <pre><code>graph LR\nA[3] --&gt; B[2]\nB --&gt; C[0]\nC --&gt; D[-4]\nD --&gt; B</code></pre> 142. Linked List Cycle II - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\ndef detectCycle(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    slow, fast = head, head\n\n    while fast and fast.next:\n        fast = fast.next.next\n        slow = slow.next\n\n        if slow == fast:\n            slow = head\n            while slow != fast:\n                slow = slow.next\n                fast = fast.next\n            return slow\n\n    return None\n\n\nhead1 = ListNode.create([3, 2, 0, -4], 1)\nprint(detectCycle(head1).val)  # 2\nhead2 = ListNode.create([3, 2, 0, -4])\nprint(detectCycle(head2))  # None\n</code></pre> 142. Linked List Cycle II - C++ Solution<pre><code>#include &lt;iostream&gt;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nclass Solution {\n   public:\n    ListNode* detectCycle(ListNode* head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        while (fast &amp;&amp; fast-&gt;next) {\n            slow = slow-&gt;next;\n            fast = fast-&gt;next-&gt;next;\n\n            if (fast == slow) {\n                slow = head;\n                while (slow != fast) {\n                    slow = slow-&gt;next;\n                    fast = fast-&gt;next;\n                }\n                return slow;\n            }\n        }\n        return nullptr;\n    }\n};\n</code></pre>"},{"location":"content/top100liked/linked_list/#21-merge-two-sorted-lists","title":"21. Merge Two Sorted Lists","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: linked list, recursion</p> </li> <li>Merge the two lists into one sorted list.</li> </ul> 21. Merge Two Sorted Lists - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef mergeTwoLists(\n    list1: Optional[ListNode], list2: Optional[ListNode]\n) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    while list1 and list2:\n        if list1.val &lt; list2.val:\n            cur.next = list1\n            list1 = list1.next\n        else:\n            cur.next = list2\n            list2 = list2.next\n        cur = cur.next\n\n    if list1:\n        cur.next = list1\n    elif list2:\n        cur.next = list2\n\n    return dummy.next\n\n\nlist1 = ListNode.create([1, 2, 4])\nlist2 = ListNode.create([1, 3, 4])\nprint(mergeTwoLists(list1, list2))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4\n</code></pre> 21. Merge Two Sorted Lists - C++ Solution<pre><code>struct ListNode {\n    int val;\n    ListNode* next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode* next) : val(x), next(next) {}\n};\n\nclass Solution {\n   public:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        ListNode dummy;\n        ListNode* cur = &amp;dummy;\n\n        while (list1 &amp;&amp; list2) {\n            if (list1-&gt;val &lt; list2-&gt;val) {\n                cur-&gt;next = list1;\n                list1 = list1-&gt;next;\n            } else {\n                cur-&gt;next = list2;\n                list2 = list2-&gt;next;\n            }\n            cur = cur-&gt;next;\n        }\n\n        cur-&gt;next = list1 ? list1 : list2;\n\n        return dummy.next;\n    }\n};\n</code></pre>"},{"location":"content/top100liked/linked_list/#2-add-two-numbers","title":"2. Add Two Numbers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, math, recursion</p> </li> <li>Represent the sum of two numbers as a linked list.</li> </ul> 2. Add Two Numbers - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef addTwoNumbers(\n    l1: Optional[ListNode], l2: Optional[ListNode]\n) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n    carry = 0\n\n    while l1 or l2:\n        v1 = l1.val if l1 else 0\n        v2 = l2.val if l2 else 0\n\n        carry, val = divmod(v1 + v2 + carry, 10)\n        cur.next = ListNode(val)\n        cur = cur.next\n\n        if l1:\n            l1 = l1.next\n        if l2:\n            l2 = l2.next\n\n    if carry:\n        cur.next = ListNode(val=carry)\n\n    return dummy.next\n\n\nl1 = ListNode.create([2, 4, 3])\nl2 = ListNode.create([5, 6, 4])\nprint(addTwoNumbers(l1, l2))  # 7 -&gt; 0 -&gt; 8\n</code></pre> 2. Add Two Numbers - C++ Solution<pre><code>struct ListNode {\n    int val;\n    ListNode* next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode* next) : val(x), next(next) {}\n};\n\nclass Solution {\n   public:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode dummy;\n        ListNode* cur = &amp;dummy;\n        int carry = 0;\n\n        while (l1 || l2 || carry) {\n            if (l1) {\n                carry += l1-&gt;val;\n                l1 = l1-&gt;next;\n            }\n            if (l2) {\n                carry += l2-&gt;val;\n                l2 = l2-&gt;next;\n            }\n            cur-&gt;next = new ListNode(carry % 10);\n            cur = cur-&gt;next;\n            carry /= 10;\n        }\n        return dummy.next;\n    }\n};\n</code></pre>"},{"location":"content/top100liked/linked_list/#19-remove-nth-node-from-end-of-list","title":"19. Remove Nth Node From End of List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, two pointers</p> </li> <li>Given the <code>head</code> of a linked list, remove the <code>n-th</code> node from the end of the list and return its head.</li> </ul> 19. Remove Nth Node From End of List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef removeNthFromEnd(head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:\n    dummy = ListNode(0, head)\n    fast, slow = dummy, dummy\n\n    for _ in range(n):\n        fast = fast.next\n\n    while fast.next:\n        fast = fast.next\n        slow = slow.next\n\n    slow.next = slow.next.next\n\n    return dummy.next\n\n\nhead = [1, 2, 3, 4, 5]\nn = 2\nhead = ListNode.create(head)\nprint(head)  # 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(removeNthFromEnd(head, n))  # 1 -&gt; 2 -&gt; 3 -&gt; 5\n</code></pre>"},{"location":"content/top100liked/linked_list/#24-swap-nodes-in-pairs","title":"24. Swap Nodes in Pairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, recursion</p> </li> <li>Given a linked list, swap every two adjacent nodes and return its head.</li> </ul> 24. Swap Nodes in Pairs - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef swapPairs(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    dummy = ListNode(0, head)\n    n0 = dummy\n    n1 = dummy.next\n\n    while n1 and n1.next:\n        n2 = n1.next\n        n3 = n2.next\n\n        n0.next = n2\n        n2.next = n1\n        n1.next = n3\n\n        n0 = n1\n        n1 = n3\n\n    return dummy.next\n\n\nnums = [1, 2, 3, 4, 5]\nhead = ListNode.create(nums)\nprint(head)\n# 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(swapPairs(head))\n# 2 -&gt; 1 -&gt; 4 -&gt; 3 -&gt; 5\n</code></pre>"},{"location":"content/top100liked/linked_list/#25-reverse-nodes-in-k-group","title":"25. Reverse Nodes in k-Group","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: linked list, recursion 25. Reverse Nodes in k-Group - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef reverseKGroup(head: Optional[ListNode], k: int) -&gt; Optional[ListNode]:\n    n = 0\n    cur = head\n    while cur:\n        n += 1\n        cur = cur.next\n\n    p0 = dummy = ListNode(next=head)\n    pre = None\n    cur = head\n\n    while n &gt;= k:\n        n -= k\n        for _ in range(k):\n            nxt = cur.next\n            cur.next = pre\n            pre = cur\n            cur = nxt\n\n        nxt = p0.next\n        nxt.next = cur\n        p0.next = pre\n        p0 = nxt\n\n    return dummy.next\n\n\nif __name__ == \"__main__\":\n    head = [1, 2, 3, 4, 5]\n    k = 2\n    head = ListNode.create(head)\n    print(head)  # 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\n    print(reverseKGroup(head, k))  # 2 -&gt; 1 -&gt; 4 -&gt; 3 -&gt; 5\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/linked_list/#138-copy-list-with-random-pointer","title":"138. Copy List with Random Pointer","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, linked list 138. Copy List with Random Pointer - Python Solution<pre><code>from typing import Optional\n\n\nclass Node:\n    def __init__(self, x: int, next: \"Node\" = None, random: \"Node\" = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\n\ndef copyRandomList(head: \"Optional[Node]\") -&gt; \"Optional[Node]\":\n    if not head:\n        return None\n\n    # Copy nodes and link them together\n    cur = head\n    while cur:\n        new_node = Node(cur.val)\n        new_node.next = cur.next\n        cur.next = new_node\n        cur = new_node.next\n\n    # Copy random pointers\n    cur = head\n    while cur:\n        cur.next.random = cur.random.next if cur.random else None\n        cur = cur.next.next\n\n    # Separate the original and copied lists\n    cur = head\n    new_head = head.next\n    while cur:\n        new_node = cur.next\n        cur.next = new_node.next\n        new_node.next = new_node.next.next if new_node.next else None\n        cur = cur.next\n\n    return new_head\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/linked_list/#148-sort-list","title":"148. Sort List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, two pointers, divide and conquer, sorting, merge sort 148. Sort List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef sortListSort(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    nums = []\n\n    while head:\n        nums.append(head.val)\n        head = head.next\n\n    dummy = ListNode()\n    cur = dummy\n    nums.sort()\n\n    for num in nums:\n        cur.next = ListNode(val=num)\n        cur = cur.next\n\n    return dummy.next\n\n\n# Linked List\ndef sortListDivideConquer(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    def middle(node):\n        fast, slow = node, node\n        while fast and fast.next:\n            pre = slow\n            slow = slow.next\n            fast = fast.next.next\n        pre.next = None\n        return slow\n\n    def merge_two_lists(l1, l2):\n        dummy = ListNode()\n        cur = dummy\n        while l1 and l2:\n            if l1.val &lt; l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n            cur = cur.next\n\n        cur.next = l1 if l1 else l2\n        return dummy.next\n\n    if not head or not head.next:\n        return head\n\n    head2 = middle(head)\n    head = sortListDivideConquer(head)\n    head2 = sortListDivideConquer(head2)\n\n    return merge_two_lists(head, head2)\n\n\nhead = ListNode().create([4, 2, 1, 3])\nprint(head)  # 4 -&gt; 2 -&gt; 1 -&gt; 3\nprint(sortListSort(head))  # 1 -&gt; 2 -&gt; 3 -&gt; 4\nprint(sortListDivideConquer(head))  # 1 -&gt; 2 -&gt; 3 -&gt; 4\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/linked_list/#23-merge-k-sorted-lists","title":"23. Merge k Sorted Lists","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: linked list, divide and conquer, heap priority queue, merge sort</p> </li> <li>Prerequisite: 21. Merge Two Sorted Lists</li> <li>Video explanation: 23. Merge K Sorted Lists - NeetCode</li> </ul> 23. Merge k Sorted Lists - Python Solution<pre><code>import copy\nimport heapq\nfrom typing import List, Optional\n\nfrom template import ListNode\n\n\n# Divide and Conquer\ndef mergeKListsDC(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    if not lists or len(lists) == 0:\n        return None\n\n    def mergeTwo(l1, l2):\n        dummy = ListNode()\n        cur = dummy\n\n        while l1 and l2:\n            if l1.val &lt; l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n\n            cur = cur.next\n\n        cur.next = l1 if l1 else l2\n\n        return dummy.next\n\n    while len(lists) &gt; 1:\n        merged = []\n\n        for i in range(0, len(lists), 2):\n            l1 = lists[i]\n            l2 = lists[i + 1] if i + 1 &lt; len(lists) else None\n            merged.append(mergeTwo(l1, l2))\n\n        lists = merged\n\n    return lists[0]\n\n\n# Heap - Merge k Sorted\ndef mergeKLists(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    minHeap = []  # (val, idx, node)\n\n    for idx, head in enumerate(lists):\n        if head:\n            heapq.heappush(minHeap, (head.val, idx, head))\n\n    while minHeap:\n        _, idx, node = heapq.heappop(minHeap)\n        cur.next = node\n        cur = cur.next\n\n        node = node.next\n        if node:\n            heapq.heappush(minHeap, (node.val, idx, node))\n\n    return dummy.next\n\n\nn1 = ListNode.create([1, 4, 5])\nn2 = ListNode.create([1, 3, 4])\nn3 = ListNode.create([2, 6])\nlists = [n1, n2, n3]\nlists1 = copy.deepcopy(lists)\nlists2 = copy.deepcopy(lists)\nprint(mergeKListsDC(lists1))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6\nprint(mergeKLists(lists2))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6\n</code></pre>"},{"location":"content/top100liked/linked_list/#146-lru-cache","title":"146. LRU Cache","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, linked list, design, doubly linked list</p> </li> <li>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.</li> <li>lru</li> <li></li> </ul> Data structure Description Doubly Linked List To store the key-value pairs. Hash Map To store the key-node pairs. 146. LRU Cache - Python Solution<pre><code>from collections import OrderedDict\n\n\n# Doubly Linked List\nclass Node:\n    def __init__(self, key=0, val=0):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.cache = {}\n        self.head = Node()\n        self.tail = Node()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def add_to_last(self, node):\n        self.tail.prev.next = node\n        node.prev = self.tail.prev\n        node.next = self.tail\n        self.tail.prev = node\n\n    def move_to_last(self, node):\n        self.remove(node)\n        self.add_to_last(node)\n\n    def get(self, key: int) -&gt; int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self.move_to_last(node)\n        return node.val\n\n    def put(self, key: int, value: int) -&gt; None:\n        if key in self.cache:\n            node = self.cache[key]\n            node.val = value\n            self.move_to_last(node)\n            return None\n\n        if len(self.cache) == self.cap:\n            del self.cache[self.head.next.key]\n            self.remove(self.head.next)\n\n        node = Node(key=key, val=value)\n        self.cache[key] = node\n        self.add_to_last(node)\n\n\n# OrderedDict\nclass LRUCacheOrderedDict:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.cap = capacity\n\n    def get(self, key: int):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key, last=True)\n        return self.cache[key]\n\n    def put(self, key: int, value: int):\n        if key in self.cache:\n            self.cache.move_to_end(key, last=True)\n        elif len(self.cache) &gt;= self.cap:\n            self.cache.popitem(last=False)\n\n        self.cache[key] = value\n\n\ncache = LRUCache(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\n\ncache = LRUCacheOrderedDict(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\nprint(\"LRU Cache passed\")\nprint(\"LRU Cache Ordered Dict passed\")\n</code></pre> 146. LRU Cache - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nclass Node {\n   public:\n    int key;\n    int val;\n    Node *prev;\n    Node *next;\n\n    Node(int k = 0, int v = 0) : key(k), val(v), prev(nullptr), next(nullptr) {}\n};\n\nclass LRUCache {\n   private:\n    int cap;\n    unordered_map&lt;int, Node *&gt; cache;\n    Node *head;\n    Node *tail;\n\n    void remove(Node *node) {\n        node-&gt;prev-&gt;next = node-&gt;next;\n        node-&gt;next-&gt;prev = node-&gt;prev;\n    }\n\n    void insert_to_last(Node *node) {\n        tail-&gt;prev-&gt;next = node;\n        node-&gt;prev = tail-&gt;prev;\n        tail-&gt;prev = node;\n        node-&gt;next = tail;\n    }\n\n    void move_to_last(Node *node) {\n        remove(node);\n        insert_to_last(node);\n    }\n\n   public:\n    LRUCache(int capacity) {\n        this-&gt;cap = capacity;\n        head = new Node();\n        tail = new Node();\n        head-&gt;next = tail;\n        tail-&gt;prev = head;\n    }\n\n    int get(int key) {\n        if (cache.find(key) != cache.end()) {\n            Node *node = cache[key];\n            move_to_last(node);\n            return node-&gt;val;\n        }\n        return -1;\n    }\n\n    void put(int key, int value) {\n        if (cache.find(key) != cache.end()) {\n            Node *node = cache[key];\n            node-&gt;val = value;\n            move_to_last(node);\n        } else {\n            Node *newNode = new Node(key, value);\n            cache[key] = newNode;\n            insert_to_last(newNode);\n\n            if ((int)cache.size() &gt; cap) {\n                Node *removed = head-&gt;next;\n                remove(removed);\n                cache.erase(removed-&gt;key);\n                delete removed;\n            }\n        }\n    }\n};\n\nint main() {\n    LRUCache lru(2);\n    lru.put(1, 1);\n    lru.put(2, 2);\n    cout &lt;&lt; lru.get(1) &lt;&lt; endl;  // 1\n    lru.put(3, 3);\n    cout &lt;&lt; lru.get(2) &lt;&lt; endl;  // -1\n    lru.put(4, 4);\n    cout &lt;&lt; lru.get(1) &lt;&lt; endl;  // -1\n    cout &lt;&lt; lru.get(3) &lt;&lt; endl;  // 3\n    cout &lt;&lt; lru.get(4) &lt;&lt; endl;  // 4\n    return 0;\n}\n</code></pre>"},{"location":"content/top100liked/matrix/","title":"Matrix","text":""},{"location":"content/top100liked/matrix/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 73. Set Matrix Zeroes (Medium)</li> <li> 54. Spiral Matrix (Medium)</li> <li> 48. Rotate Image (Medium)</li> <li> 240. Search a 2D Matrix II (Medium)</li> </ul>"},{"location":"content/top100liked/matrix/#73-set-matrix-zeroes","title":"73. Set Matrix Zeroes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, matrix 73. Set Matrix Zeroes - Python Solution<pre><code>from copy import deepcopy\nfrom typing import List\n\n\n# Math\ndef setZeroes1(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    m, n = len(matrix), len(matrix[0])\n\n    rows, cols = set(), set()\n\n    for i in range(m):\n        for j in range(n):\n            if matrix[i][j] == 0:\n                rows.add(i)\n                cols.add(j)\n\n    for i in rows:\n        for j in range(n):\n            matrix[i][j] = 0\n\n    for i in range(m):\n        for j in cols:\n            matrix[i][j] = 0\n\n\n# Math - Optimized\ndef setZeroes2(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    m, n = len(matrix), len(matrix[0])\n    row_zero, col_zero = False, False\n\n    for i in range(m):\n        if matrix[i][0] == 0:\n            col_zero = True\n            break\n\n    for j in range(n):\n        if matrix[0][j] == 0:\n            row_zero = True\n            break\n\n    for i in range(1, m):\n        for j in range(1, n):\n            if matrix[i][j] == 0:\n                matrix[i][0] = 0\n                matrix[0][j] = 0\n\n    for i in range(1, m):\n        if matrix[i][0] == 0:\n            for j in range(1, n):\n                matrix[i][j] = 0\n\n    for j in range(1, n):\n        if matrix[0][j] == 0:\n            for i in range(1, m):\n                matrix[i][j] = 0\n\n    if col_zero:\n        for i in range(m):\n            matrix[i][0] = 0\n\n    if row_zero:\n        for j in range(n):\n            matrix[0][j] = 0\n\n\nmatrix = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]\nprint(matrix)\n# [[1, 1, 1],\n#  [1, 0, 1],\n#  [1, 1, 1]]\nmatrix1 = deepcopy(matrix)\nsetZeroes1(matrix1)\nprint(matrix1)\n# [[1, 0, 1],\n#  [0, 0, 0],\n#  [1, 0, 1]]\nmatrix2 = deepcopy(matrix)\nsetZeroes2(matrix2)\nprint(matrix2)\n# [[1, 0, 1],\n#  [0, 0, 0],\n#  [1, 0, 1]]\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/matrix/#54-spiral-matrix","title":"54. Spiral Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, matrix, simulation</p> </li> <li>Return all elements of the matrix in spiral order.</li> </ul> 54. Spiral Matrix - Python Solution<pre><code>from typing import List\n\n\n# Array\ndef spiralOrder(matrix: List[List[int]]) -&gt; List[int]:\n    if not matrix or not matrix[0]:\n        return []\n\n    res = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n\n    while top &lt;= bottom and left &lt;= right:\n\n        for i in range(left, right + 1):\n            res.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            res.append(matrix[i][right])\n        right -= 1\n\n        if top &lt;= bottom:\n\n            for i in range(right, left - 1, -1):\n                res.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left &lt;= right:\n\n            for i in range(bottom, top - 1, -1):\n                res.append(matrix[i][left])\n            left += 1\n\n    return res\n\n\n# Math\ndef spiralOrderMath(matrix: List[List[int]]) -&gt; List[int]:\n    dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]]  # Right Down Left Up\n    m, n = len(matrix), len(matrix[0])\n    size = m * n\n    res = []\n    i, j, di = 0, -1, 0\n\n    while len(res) &lt; size:\n        dx, dy = dirs[di]\n        for _ in range(n):\n            i += dx\n            j += dy\n            res.append(matrix[i][j])\n        di = (di + 1) % 4\n        n, m = m - 1, n\n\n    return res\n\n\nprint(spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n# [1, 2, 3, 6, 9, 8, 7, 4, 5]\nprint(spiralOrderMath([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]))\n# [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]\n</code></pre>"},{"location":"content/top100liked/matrix/#48-rotate-image","title":"48. Rotate Image","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, matrix 48. Rotate Image - Python Solution<pre><code>from copy import deepcopy\nfrom typing import List\n\n\n# Math\ndef rotate1(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    n = len(matrix)\n\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n\n\ndef rotate2(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    n = len(matrix)\n    for i in range(n):\n        for j in range(i, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\n    for i in range(n):\n        matrix[i].reverse()\n\n\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nprint(matrix)\n# [[1, 2, 3],\n#  [4, 5, 6],\n#  [7, 8, 9]]\nmatrix1 = deepcopy(matrix)\nrotate1(matrix1)\nprint(matrix1)\n# [[7, 4, 1],\n#  [8, 5, 2],\n#  [9, 6, 3]]\nmatrix2 = deepcopy(matrix)\nrotate2(matrix2)\nprint(matrix2)\n# [[7, 4, 1],\n#  [8, 5, 2],\n#  [9, 6, 3]]\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/matrix/#240-search-a-2d-matrix-ii","title":"240. Search a 2D Matrix II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, divide and conquer, matrix 240. Search a 2D Matrix II - Python Solution<pre><code>from typing import List\n\n\n# Matrix\ndef searchMatrix(matrix: List[List[int]], target: int) -&gt; bool:\n    m, n = len(matrix), len(matrix[0])\n    i, j = 0, n - 1\n\n    while i &lt; m and j &gt;= 0:\n        if matrix[i][j] == target:\n            return True\n        elif matrix[i][j] &lt; target:\n            i += 1\n        else:\n            j -= 1\n\n    return False\n\n\nmatrix = [\n    [1, 4, 7, 11, 15],\n    [2, 5, 8, 12, 19],\n    [3, 6, 9, 16, 22],\n    [10, 13, 14, 17, 24],\n    [18, 21, 23, 26, 30],\n]\ntarget = 20\nprint(searchMatrix(matrix, target))  # False\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/multi-dimensional_dynamic_programming/","title":"Multi-dimensional Dynamic Programming","text":""},{"location":"content/top100liked/multi-dimensional_dynamic_programming/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 62. Unique Paths (Medium)</li> <li> 64. Minimum Path Sum (Medium)</li> <li> 5. Longest Palindromic Substring (Medium)</li> <li> 1143. Longest Common Subsequence (Medium)</li> <li> 72. Edit Distance (Medium)</li> </ul>"},{"location":"content/top100liked/multi-dimensional_dynamic_programming/#62-unique-paths","title":"62. Unique Paths","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, combinatorics</p> </li> <li>Count the number of unique paths to reach the bottom-right corner of a <code>m x n</code> grid.</li> </ul> <p></p> 62. Unique Paths - Python Solution<pre><code># DP - 2D\ndef uniquePaths(m: int, n: int) -&gt; int:\n    if m == 1 or n == 1:\n        return 1\n\n    dp = [[1] * n for _ in range(m)]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]\n\n\nprint(uniquePaths(m=3, n=7))  # 28\n# [[1, 1, 1,  1,  1,  1,  1],\n#  [1, 2, 3,  4,  5,  6,  7],\n#  [1, 3, 6, 10, 15, 21, 28]]\n</code></pre> 62. Unique Paths - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint uniquePaths(int m, int n) {\n    vector dp(m, vector&lt;int&gt;(n, 1));\n\n    for (int i = 1; i &lt; m; i++) {\n        for (int j = 1; j &lt; n; j++) {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n\n    return dp[m - 1][n - 1];\n}\n\nint main() {\n    int m = 3, n = 7;\n    cout &lt;&lt; uniquePaths(m, n) &lt;&lt; endl;  // 28\n    return 0;\n}\n</code></pre>"},{"location":"content/top100liked/multi-dimensional_dynamic_programming/#64-minimum-path-sum","title":"64. Minimum Path Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, matrix 64. Minimum Path Sum - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef minPathSum(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, m):\n        dp[i][0] = grid[i][0] + dp[i - 1][0]\n    for j in range(1, n):\n        dp[0][j] = grid[0][j] + dp[0][j - 1]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[-1][-1]\n\n\ngrid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\nprint(minPathSum(grid))  # 7\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/multi-dimensional_dynamic_programming/#5-longest-palindromic-substring","title":"5. Longest Palindromic Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string, dynamic programming</p> </li> <li>Return the longest palindromic substring in <code>s</code>.</li> </ul> 5. Longest Palindromic Substring - Python Solution<pre><code># DP - Interval\ndef longestPalindromeDP(s: str) -&gt; str:\n    n = len(s)\n    if n &lt;= 1:\n        return s\n\n    start, maxLen = 0, 1\n\n    # Init\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for j in range(1, n):\n        for i in range(j):\n            if s[i] == s[j]:\n                if j - i &lt;= 2:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1]\n\n                if dp[i][j] and j - i + 1 &gt; maxLen:\n                    maxLen = j - i + 1\n                    start = i\n\n    return s[start : start + maxLen]\n\n\n# Expand Around Center\ndef longestPalindromeCenter(s: str) -&gt; str:\n    def expand_around_center(left, right):\n        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n\n    if len(s) &lt;= 1:\n        return s\n\n    start, end = 0, 0\n    for i in range(len(s)):\n        len1 = expand_around_center(i, i)  # odd\n        len2 = expand_around_center(i, i + 1)  # even\n\n        maxLen = max(len1, len2)\n        if maxLen &gt; end - start:\n            start = i - (maxLen - 1) // 2\n            end = i + maxLen // 2\n\n    return s[start : end + 1]\n\n\ns = \"babad\"\nprint(longestPalindromeDP(s))  # \"bab\"\nprint(longestPalindromeCenter(s))  # \"aba\"\n</code></pre>"},{"location":"content/top100liked/multi-dimensional_dynamic_programming/#1143-longest-common-subsequence","title":"1143. Longest Common Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming 1143. Longest Common Subsequence - Python Solution<pre><code>from functools import cache\n\n\n# DP - LCS\ndef longestCommonSubsequenceMemo(text1: str, text2: str) -&gt; int:\n    m, n = len(text1), len(text2)\n\n    @cache\n    def dfs(i: int, j: int) -&gt; int:\n        if i &lt; 0 or j &lt; 0:\n            return 0\n        if text1[i] == text2[j]:\n            return dfs(i - 1, j - 1) + 1\n        return max(dfs(i - 1, j), dfs(i, j - 1))\n\n    return dfs(m - 1, n - 1)\n\n\n# DP - LCS\ndef longestCommonSubsequenceTable(text1: str, text2: str) -&gt; int:\n    m, n = len(text1), len(text2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i - 1] == text2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    assert longestCommonSubsequenceMemo(\"abcde\", \"ace\") == 3\n    assert longestCommonSubsequenceTable(\"abcde\", \"ace\") == 3\n    assert longestCommonSubsequenceMemo(\"abc\", \"abc\") == 3\n    assert longestCommonSubsequenceTable(\"abc\", \"abc\") == 3\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/multi-dimensional_dynamic_programming/#72-edit-distance","title":"72. Edit Distance","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming 72. Edit Distance - Python Solution<pre><code>from functools import cache\n\n\n# Recursive\ndef minDistanceDFS(word1: str, word2: str) -&gt; int:\n    n, m = len(word1), len(word2)\n\n    @cache\n    def dfs(i: int, j: int) -&gt; int:\n        if i &lt; 0:\n            return j + 1\n        if j &lt; 0:\n            return i + 1\n        if word1[i] == word2[j]:\n            return dfs(i - 1, j - 1)\n\n        return 1 + min(dfs(i - 1, j), dfs(i, j - 1), dfs(i - 1, j - 1))\n\n    return dfs(n - 1, m - 1)\n\n\n# Iterative\ndef minDistanceDP(word1: str, word2: str) -&gt; int:\n    m, n = len(word1), len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]  # no operation\n            else:\n                dp[i][j] = 1 + min(\n                    dp[i - 1][j],  # delete\n                    dp[i][j - 1],  # insert\n                    dp[i - 1][j - 1],  # replace\n                )\n    return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    word1 = \"horse\"\n    word2 = \"ros\"\n    print(minDistanceDFS(word1, word2))  # 3\n    print(minDistanceDP(word1, word2))  # 3\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/sliding_window/","title":"Sliding Window","text":""},{"location":"content/top100liked/sliding_window/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 3. Longest Substring Without Repeating Characters (Medium)</li> <li> 438. Find All Anagrams in a String (Medium)</li> </ul>"},{"location":"content/top100liked/sliding_window/#3-longest-substring-without-repeating-characters","title":"3. Longest Substring Without Repeating Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> <li>Classic variable sliding window problem. Use a set to keep track of the characters in the current window.</li> <li>Return the length of the longest substring without repeating characters.</li> <li>Template tutorial by \u7075\u5c71\u8336\u827e\u5e9c</li> </ul> 3. Longest Substring Without Repeating Characters - Python Solution<pre><code>from collections import defaultdict\n\n\n# Sliding Window Variable Max - HashMap\ndef lengthOfLongestSubstringHash(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    left = 0\n    cnt = defaultdict(int)\n    res = 0\n\n    for right in range(n):\n        cnt[s[right]] += 1\n\n        while cnt[s[right]] &gt; 1:\n            cnt[s[left]] -= 1\n            left += 1\n\n        res = max(res, right - left + 1)\n\n    return res\n\n\n# Sliding Window Variable Max - Set\ndef lengthOfLongestSubstringSet(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    left = 0\n    res = 0\n    window = set()\n\n    for right in range(n):\n        while left &lt; right and s[right] in window:\n            window.remove(s[left])\n            left += 1\n        window.add(s[right])\n        res = max(res, right - left + 1)\n\n    return res\n\n\nif __name__ == \"__main__\":\n    s = \"abcabcbb\"\n    assert lengthOfLongestSubstringHash(s) == 3\n    assert lengthOfLongestSubstringSet(s) == 3\n</code></pre> 3. Longest Substring Without Repeating Characters - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;unordered_set&gt;\nusing namespace std;\n\nint lengthOfLongestSubstring(string s) {\n    int n = s.length();\n    int res = 0;\n    int left = 0;\n    unordered_set&lt;char&gt; window;\n\n    for (int right = 0; right &lt; n; right++) {\n        char ch = s[right];\n\n        while (window.find(ch) != window.end()) {\n            window.erase(s[left]);\n            left++;\n        }\n\n        window.insert(ch);\n        res = max(res, right - left + 1);\n    }\n    return (int)res;\n}\n\nint main() {\n    string s = \"abcabcbb\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 3\n    s = \"bbbbb\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 1\n    s = \"pwwkew\";\n    cout &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; endl;  // 3\n    return 0;\n}\n</code></pre>"},{"location":"content/top100liked/sliding_window/#438-find-all-anagrams-in-a-string","title":"438. Find All Anagrams in a String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window 438. Find All Anagrams in a String - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window Fixed Size\ndef findAnagrams(s: str, p: str) -&gt; List[int]:\n    n, k = len(s), len(p)\n    target = [0 for _ in range(26)]\n    for ch in p:\n        target[ord(ch) - ord(\"a\")] += 1\n\n    count = [0 for _ in range(26)]\n    left = 0\n    res = []\n\n    for right in range(n):\n        count[ord(s[right]) - ord(\"a\")] += 1\n        if right &lt; k - 1:\n            continue\n\n        if count == target:\n            res.append(left)\n\n        count[ord(s[left]) - ord(\"a\")] -= 1\n        left += 1\n\n    return res\n\n\ns = \"cbaebabacd\"\np = \"abc\"\nprint(findAnagrams(s, p))  # [0, 6]\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/stack/","title":"Stack","text":""},{"location":"content/top100liked/stack/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 20. Valid Parentheses (Easy)</li> <li> 155. Min Stack (Medium)</li> <li> 394. Decode String (Medium)</li> <li> 739. Daily Temperatures (Medium)</li> <li> 84. Largest Rectangle in Histogram (Hard)</li> </ul>"},{"location":"content/top100liked/stack/#20-valid-parentheses","title":"20. Valid Parentheses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, stack</p> </li> <li>Determine if the input string is valid.</li> <li>Steps for the string <code>()[]{}</code>:</li> </ul> char action stack <code>(</code> push \"(\" <code>)</code> pop \"\" <code>[</code> push \"[\" <code>]</code> pop \"\" <code>{</code> push \"{\" <code>}</code> pop \"\" 20. Valid Parentheses - Python Solution<pre><code># Stack\ndef isValid(s: str) -&gt; bool:\n    hashmap = {\n        \")\": \"(\",\n        \"]\": \"[\",\n        \"}\": \"{\",\n    }\n    stack = []\n\n    for ch in s:\n        if ch in hashmap:\n            if stack and stack[-1] == hashmap[ch]:\n                stack.pop()\n            else:\n                return False\n        else:\n            stack.append(ch)\n\n    return True if not stack else False\n\n\nif __name__ == \"__main__\":\n    assert isValid(\"()[]{}\")\n    assert not isValid(\"(]\")\n    assert not isValid(\"([)]\")\n    assert isValid(\"{[]}\")\n    assert isValid(\"\")\n</code></pre> 20. Valid Parentheses - C++ Solution<pre><code>#include &lt;cassert&gt;\n#include &lt;stack&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n\nclass Solution {\n   public:\n    bool isValid(string s) {\n        unordered_map&lt;char, char&gt; map{{')', '('}, {'}', '{'}, {']', '['}};\n        stack&lt;char&gt; stack;\n        if (s.length() % 2 == 1) return false;\n\n        for (char&amp; ch : s) {\n            if (stack.empty() || map.find(ch) == map.end()) {\n                stack.push(ch);\n            } else {\n                if (map[ch] != stack.top()) {\n                    return false;\n                }\n                stack.pop();\n            }\n        }\n        return stack.empty();\n    }\n};\n\nint main() {\n    Solution s;\n    assert(s.isValid(\"()\") == true);\n    assert(s.isValid(\"()[]{}\") == true);\n    assert(s.isValid(\"(]\") == false);\n    assert(s.isValid(\"([)]\") == false);\n    assert(s.isValid(\"{[]}\") == true);\n    return 0;\n}\n</code></pre>"},{"location":"content/top100liked/stack/#155-min-stack","title":"155. Min Stack","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: stack, design</p> </li> <li>Implement a stack that supports push, pop, top, and retrieving the minimum element in constant time.</li> </ul> 155. Min Stack - Python Solution<pre><code># Stack\nclass MinStack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, val: int) -&gt; None:\n        if self.stack:\n            self.stack.append((val, min(val, self.getMin())))\n        else:\n            self.stack.append((val, val))\n\n    def pop(self) -&gt; None:\n        self.stack.pop()\n\n    def top(self) -&gt; int:\n        return self.stack[-1][0]\n\n    def getMin(self) -&gt; int:\n        return self.stack[-1][1]\n\n\nobj = MinStack()\nobj.push(3)\nobj.push(2)\nobj.pop()\nprint(obj.top())  # 3\nprint(obj.getMin())  # 3\n</code></pre> 155. Min Stack - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;climits&gt;\n#include &lt;iostream&gt;\n#include &lt;stack&gt;\n#include &lt;utility&gt;\nusing namespace std;\n\nclass MinStack {\n    stack&lt;pair&lt;int, int&gt;&gt; st;\n\n   public:\n    MinStack() { st.emplace(0, INT_MAX); }\n\n    void push(int val) { st.emplace(val, min(getMin(), val)); }\n\n    void pop() { st.pop(); }\n\n    int top() { return st.top().first; }\n\n    int getMin() { return st.top().second; }\n};\n\nint main() {\n    MinStack minStack;\n    minStack.push(-2);\n    minStack.push(0);\n    minStack.push(-3);\n    cout &lt;&lt; minStack.getMin() &lt;&lt; endl;  // -3\n    minStack.pop();\n    cout &lt;&lt; minStack.top() &lt;&lt; endl;     // 0\n    cout &lt;&lt; minStack.getMin() &lt;&lt; endl;  // -2\n    return 0;\n}\n</code></pre>"},{"location":"content/top100liked/stack/#394-decode-string","title":"394. Decode String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack, recursion 394. Decode String - Python Solution<pre><code># Stack\ndef decodeString(s: str) -&gt; str:\n    stack = []  # (str, int)\n    num = 0\n    res = \"\"\n\n    for c in s:\n        if c.isdigit():\n            num = num * 10 + int(c)\n        elif c == \"[\":\n            stack.append((res, num))\n            res, num = \"\", 0\n        elif c == \"]\":\n            top = stack.pop()\n            res = top[0] + res * top[1]\n        else:\n            res += c\n\n    return res\n\n\ns = \"3[a2[c]]\"\nprint(decodeString(s))  # accaccacc\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/stack/#739-daily-temperatures","title":"739. Daily Temperatures","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, monotonic stack</p> </li> <li>Return an array <code>res</code> such that <code>res[i]</code> is the number of days you have to wait after the <code>ith</code> day to get a warmer temperature.</li> </ul> Index Temp &gt; stack last stack result 0 73 False <code>[ [73, 0] ]</code> 1 - 0 = 1 1 74 True <code>[ [74, 1] ]</code> 2 - 1 = 1 2 75 True <code>[ [75, 2] ]</code> 6 - 2 = 4 3 71 False <code>[ [75, 2], [71, 3] ]</code> 5 - 3 = 2 4 69 False <code>[ [75, 2], [71, 3], [69, 4] ]</code> 5 - 4 = 1 5 72 True <code>[ [75, 2], [72, 5] ]</code> 6 - 5 = 1 6 76 True <code>[ [76, 6] ]</code> 0 7 73 False <code>[[76, 6], [73, 7]]</code> 0 739. Daily Temperatures - Python Solution<pre><code>from typing import List\n\n\n# Monotonic Stack\ndef dailyTemperatures(temperatures: List[int]) -&gt; List[int]:\n    res = [0 for _ in range(len(temperatures))]\n    stack = []  # [temp, index]\n\n    for i, temp in enumerate(temperatures):\n        while stack and temp &gt; stack[-1][0]:\n            _, idx = stack.pop()\n            res[idx] = i - idx\n\n        stack.append([temp, i])\n\n    return res\n\n\nprint(dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73]))\n# [1, 1, 4, 2, 1, 1, 0, 0]\n</code></pre>"},{"location":"content/top100liked/stack/#84-largest-rectangle-in-histogram","title":"84. Largest Rectangle in Histogram","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, stack, monotonic stack 84. Largest Rectangle in Histogram - Python Solution<pre><code>from typing import List\n\n\n# Monotonic Stack\ndef largestRectangleArea(heights: List[int]) -&gt; int:\n    stack = []\n    max_area = 0\n    n = len(heights)\n\n    for i in range(n + 1):\n        h = 0 if i == n else heights[i]\n\n        while stack and h &lt; heights[stack[-1]]:\n            height = heights[stack.pop()]\n            width = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, height * width)\n\n        stack.append(i)\n\n    return max_area\n\n\nprint(largestRectangleArea([2, 1, 5, 6, 2, 3]))  # 10\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/subarray/","title":"Subarray","text":""},{"location":"content/top100liked/subarray/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 560. Subarray Sum Equals K (Medium)</li> <li> 239. Sliding Window Maximum (Hard)</li> <li> 76. Minimum Window Substring (Hard)</li> </ul>"},{"location":"content/top100liked/subarray/#560-subarray-sum-equals-k","title":"560. Subarray Sum Equals K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, prefix sum 560. Subarray Sum Equals K - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Prefix Sum\ndef subarraySum(nums: List[int], k: int) -&gt; int:\n    preSums = defaultdict(int)\n    preSums[0] = 1\n    curSum = 0\n    res = 0\n\n    for num in nums:\n        curSum += num\n        res += preSums[curSum - k]\n        preSums[curSum] += 1\n\n    return res\n\n\nnums = [1, 1, 1]\nk = 2\nprint(subarraySum(nums, k))  # 2\n</code></pre></p> </li> </ul> 560. Subarray Sum Equals K - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint subarraySum(vector&lt;int&gt;&amp; nums, int k) {\n    int n = nums.size();\n    vector&lt;int&gt; prefixSum(n + 1);\n    for (int i = 0; i &lt; n; i++) {\n        prefixSum[i + 1] = prefixSum[i] + nums[i];\n    }\n\n    int res = 0;\n    unordered_map&lt;int, int&gt; cnt;\n\n    for (int ps : prefixSum) {\n        if (cnt.find(ps - k) != cnt.end()) res += cnt[ps - k];\n        cnt[ps]++;\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {1, 1, 1};\n    int k = 2;\n    cout &lt;&lt; subarraySum(nums, k) &lt;&lt; endl;  // 2\n    return 0;\n}\n</code></pre>"},{"location":"content/top100liked/subarray/#239-sliding-window-maximum","title":"239. Sliding Window Maximum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, queue, sliding window, heap priority queue, monotonic queue 239. Sliding Window Maximum - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# Monotonic Queue\ndef maxSlidingWindow(nums: List[int], k: int) -&gt; List[int]:\n    q = deque()\n    res = []\n\n    for i, num in enumerate(nums):\n        if q and q[0] &lt; i - k + 1:\n            q.popleft()\n\n        while q and nums[q[-1]] &lt; num:\n            q.pop()\n\n        q.append(i)\n\n        if i &gt;= k - 1:\n            res.append(nums[q[0]])\n\n    return res\n\n\nnums = [1, 3, -1, -3, 5, 3, 6, 7]\nk = 3\nprint(maxSlidingWindow(nums, k))  # [3, 3, 5, 5, 6, 7]\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/subarray/#76-minimum-window-substring","title":"76. Minimum Window Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, sliding window 76. Minimum Window Substring - Python Solution<pre><code>from collections import Counter\n\n\ndef minWindow(s: str, t: str) -&gt; str:\n    if not t or not s:\n        return \"\"\n\n    counts = Counter(t)\n    required = len(counts)\n\n    left, right = 0, 0\n    formed = 0\n    window_counts = dict()\n\n    result = float(\"inf\"), None, None\n\n    while right &lt; len(s):\n        char = s[right]\n        window_counts[char] = window_counts.get(char, 0) + 1\n        if char in counts and window_counts[char] == counts[char]:\n            formed += 1\n\n        while left &lt;= right and formed == required:\n            char = s[left]\n            if right - left + 1 &lt; result[0]:\n                result = (right - left + 1, left, right)\n            window_counts[char] -= 1\n            if char in counts and window_counts[char] &lt; counts[char]:\n                formed -= 1\n            left += 1\n\n        right += 1\n\n    return \"\" if result[0] == float(\"inf\") else s[result[1] : result[2] + 1]\n\n\ns = \"ADOBECODEBANC\"\nt = \"ABC\"\nprint(minWindow(s, t))  # BANC\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/techniques/","title":"Techniques","text":""},{"location":"content/top100liked/techniques/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 136. Single Number (Easy)</li> <li> 169. Majority Element (Easy)</li> <li> 75. Sort Colors (Medium)</li> <li> 31. Next Permutation (Medium)</li> <li> 287. Find the Duplicate Number (Medium)</li> </ul>"},{"location":"content/top100liked/techniques/#136-single-number","title":"136. Single Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, bit manipulation 136. Single Number - Python Solution<pre><code>from functools import reduce\nfrom operator import xor\nfrom typing import List\n\n\n# XOR\ndef singleNumber(nums: List[int]) -&gt; int:\n    res = 0\n    for num in nums:\n        res ^= num\n    return res\n\n\n# XOR\ndef singleNumberXOR(nums: List[int]) -&gt; int:\n    return reduce(xor, nums)\n\n\n# XOR\ndef singleNumberXORLambda(nums: List[int]) -&gt; int:\n    return reduce(lambda x, y: x ^ y, nums)\n\n\nnums = [4, 1, 2, 1, 2]\nprint(singleNumber(nums))  # 4\nprint(singleNumberXOR(nums))  # 4\nprint(singleNumberXORLambda(nums))  # 4\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/techniques/#169-majority-element","title":"169. Majority Element","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, divide and conquer, sorting, counting</p> </li> <li>Return the majority element in an array. The majority element is the element that appears more than <code>n // 2</code> times.</li> </ul> <code>num</code> <code>count</code> <code>res</code> 2 1 2 2 2 2 1 1 2 1 0 2 1 1 1 2 0 1 2 1 2 169. Majority Element - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash Map\ndef majorityElementHashMap(nums: List[int]) -&gt; int:\n    n = len(nums)\n    freq = defaultdict(int)\n\n    for num in nums:\n        freq[num] += 1\n        if freq[num] &gt; n // 2:\n            return num\n\n\n# Array - Boyer-Moore Voting Algorithm\ndef majorityElementArray(nums: List[int]) -&gt; int:\n    res = None\n    count = 0\n\n    for num in nums:\n        if count == 0:\n            res = num\n        count += 1 if num == res else -1\n\n    return res\n\n\n# | Algorithm | Time Complexity | Space Complexity |\n# |-----------|-----------------|------------------|\n# | HashMap   | O(N)            | O(N)             |\n# | Array     | O(N)            | O(1)             |\n# |-----------|-----------------|------------------|\n\n\nnums = [2, 2, 1, 1, 1, 2, 2]\nprint(majorityElementArray(nums))  # 2\nprint(majorityElementHashMap(nums))  # 2\n</code></pre>"},{"location":"content/top100liked/techniques/#75-sort-colors","title":"75. Sort Colors","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, sorting 75. Sort Colors - Python Solution<pre><code>from copy import deepcopy\nfrom typing import List\n\n\n# Left Right Pointers\ndef sort_colors_lr_pointers(nums: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    n = len(nums)\n    left = 0\n    for right in range(n):\n        if nums[right] == 0:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n\n    for right in range(left, n):\n        if nums[right] == 1:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n\n\n# Three Pointers\ndef sort_colors_three_pointers(nums: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    cur = 0\n\n    while cur &lt;= right:\n        if nums[cur] == 0:\n            nums[left], nums[cur] = nums[cur], nums[left]\n            left += 1\n            cur += 1\n        elif nums[cur] == 2:\n            nums[right], nums[cur] = nums[cur], nums[right]\n            right -= 1\n        else:\n            cur += 1\n\n\nnums = [2, 0, 2, 1, 1, 0]\nnums1, nums2 = deepcopy(nums), deepcopy(nums)\nsort_colors_lr_pointers(nums1)\nprint(nums1)  # [0, 0, 1, 1, 2, 2]\nsort_colors_three_pointers(nums2)\nprint(nums2)  # [0, 0, 1, 1, 2, 2]\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/techniques/#31-next-permutation","title":"31. Next Permutation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers 31. Next Permutation - Python Solution<pre><code>from typing import List\n\n\ndef nextPermutation(nums: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    n = len(nums)\n    i = n - 1\n    while i &gt; 0 and nums[i - 1] &gt;= nums[i]:\n        i -= 1\n    if i != 0:\n        j = n - 1\n        while nums[j] &lt;= nums[i - 1]:\n            j -= 1\n        nums[i - 1], nums[j] = nums[j], nums[i - 1]\n\n    left, right = i, n - 1\n    while left &lt; right:\n        nums[left], nums[right] = nums[right], nums[left]\n        left += 1\n        right -= 1\n\n\nnums = [1, 2, 3]\nnextPermutation(nums)\nprint(nums)  # [1, 3, 2]\nnums = [1, 2, 3, 4, 6, 5]\nnextPermutation(nums)\nprint(nums)  # [1, 2, 3, 5, 4, 6]\n</code></pre></p> </li> </ul>"},{"location":"content/top100liked/techniques/#287-find-the-duplicate-number","title":"287. Find the Duplicate Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, bit manipulation</p> </li> <li>Find the duplicate number in an array containing <code>n + 1</code> integers where each integer is between <code>1</code> and <code>n</code> inclusive.</li> <li>Floyd's Tortoise and Hare (Cycle Detection)<ul> <li> <ol> <li>Linked List Cycle</li> </ol> </li> <li> <ol> <li>Linked List Cycle II</li> </ol> </li> </ul> </li> <li>Time Complexity: O(n)</li> <li>Space Complexity: O(1)</li> </ul> <p>Example: <code>nums = [1, 3, 4, 2, 2]</code></p> 0 1 2 3 4 1 3 4 2 2 <pre><code>graph LR\n0((0)) --&gt; 1((1))\n1 --&gt; 3((3))\n2((2))--&gt; 4((4))\n3 --&gt; 2\n4 --&gt; 2</code></pre> 287. Find the Duplicate Number - Python Solution<pre><code>from typing import List\n\n\n# Floyd Cycle Detection Algorithm\ndef findDuplicate(nums: List[int]) -&gt; int:\n    fast, slow = nums[0], nums[0]\n\n    while True:\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n        if slow == fast:\n            break\n\n    slow = nums[0]\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[fast]\n\n    return slow\n\n\nnums = [1, 3, 4, 2, 2]\nprint(findDuplicate(nums))  # 2\n</code></pre>"},{"location":"content/top100liked/two_pointers/","title":"Two Pointers","text":""},{"location":"content/top100liked/two_pointers/#table-of-contents","title":"Table of Contents","text":"<ul> <li> 283. Move Zeroes (Easy)</li> <li> 11. Container With Most Water (Medium)</li> <li> 15. 3Sum (Medium)</li> <li> 42. Trapping Rain Water (Hard)</li> </ul>"},{"location":"content/top100liked/two_pointers/#283-move-zeroes","title":"283. Move Zeroes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers</p> </li> <li>Move all zeroes to the end of the array while maintaining the relative order of the non-zero elements.</li> </ul> 283. Move Zeroes - Python Solution<pre><code>from typing import List\n\n\ndef moveZeroes(nums: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    fast, slow = 0, 0\n\n    while fast &lt; len(nums):\n        if nums[fast] != 0:\n            nums[slow], nums[fast] = nums[fast], nums[slow]\n            slow += 1\n        fast += 1\n\n\nnums = [0, 1, 0, 3, 12]\nmoveZeroes(nums)\nprint(nums)  # [1, 3, 12, 0, 0]\n</code></pre> 283. Move Zeroes - C++ Solution<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvoid moveZeroes(vector&lt;int&gt;&amp; nums) {\n    size_t n = nums.size();\n    size_t fast = 0, slow = 0;\n\n    while (fast &lt; n) {\n        if (nums[fast] != 0) {\n            swap(nums[slow], nums[fast]);\n            slow++;\n        }\n        fast++;\n    }\n}\n\nint main() {\n    vector&lt;int&gt; nums = {0, 1, 0, 3, 12};\n    moveZeroes(nums);\n    // [1, 3, 12, 0, 0]\n    for (size_t i = 0; i &lt; nums.size(); i++) {\n        cout &lt;&lt; nums[i] &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"content/top100liked/two_pointers/#11-container-with-most-water","title":"11. Container With Most Water","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy</p> </li> <li>Return the maximum area of water that can be trapped between the vertical lines.</li> </ul> <p></p> 11. Container With Most Water - Python Solution<pre><code>from typing import List\n\n\n# Brute Force\ndef maxAreaBF(height: List[int]) -&gt; int:\n    max_area = 0\n\n    for i in range(len(height)):\n        for j in range(i + 1, len(height)):\n            h = min(height[i], height[j])\n            w = j - i\n            max_area = max(max_area, h * w)\n\n    return max_area\n\n\n# Left Right Pointers\ndef maxAreaLR(height: List[int]) -&gt; int:\n    left, right = 0, len(height) - 1\n    res = 0\n\n    while left &lt; right:\n        h = min(height[left], height[right])\n        w = right - left\n        res = max(res, h * w)\n\n        if height[left] &lt; height[right]:\n            left += 1\n        else:\n            right -= 1\n\n    return res\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force| O(n^2) |  O(1)   |\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nheight = [1, 8, 6, 2, 5, 4, 8, 3, 7]\nprint(maxAreaBF(height))  # 49\nprint(maxAreaLR(height))  # 49\n</code></pre> 11. Container With Most Water - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint maxArea(vector&lt;int&gt;&amp; height) {\n    int left = 0, right = height.size() - 1;\n    int res = 0;\n\n    while (left &lt; right) {\n        int h = min(height[left], height[right]);\n        int w = right - left;\n        res = max(res, h * w);\n\n        if (height[left] &lt; height[right])\n            left++;\n        else\n            right--;\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; height = {1, 8, 6, 2, 5, 4, 8, 3, 7};\n    cout &lt;&lt; maxArea(height) &lt;&lt; endl;  // 49\n    return 0;\n}\n</code></pre>"},{"location":"content/top100liked/two_pointers/#15-3sum","title":"15. 3Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, sorting 15. 3Sum - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef threeSum(nums: List[int]) -&gt; List[List[int]]:\n    nums.sort()\n    res = []\n    n = len(nums)\n\n    for i in range(n - 2):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        left, right = i + 1, n - 1\n\n        while left &lt; right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total &gt; 0:\n                right -= 1\n            elif total &lt; 0:\n                left += 1\n            else:\n                res.append([nums[i], nums[left], nums[right]])\n\n                while left &lt; right and nums[left] == nums[left + 1]:\n                    left += 1\n\n                while left &lt; right and nums[right] == nums[right - 1]:\n                    right -= 1\n\n                left += 1\n                right -= 1\n\n    return res\n\n\nnums = [-1, 0, 1, 2, -1, -4]\nassert threeSum(nums) == [[-1, -1, 2], [-1, 0, 1]]\n</code></pre></p> </li> </ul> 15. 3Sum - C++ Solution<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {\n    sort(nums.begin(), nums.end());\n    vector&lt;vector&lt;int&gt;&gt; res;\n    int n = nums.size();\n\n    for (int i = 0; i &lt; n - 2; i++) {\n        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) {\n            continue;\n        }\n\n        int left = i + 1, right = n - 1;\n\n        while (left &lt; right) {\n            int total = nums[i] + nums[left] + nums[right];\n\n            if (total &gt; 0)\n                right--;\n            else if (total &lt; 0)\n                left++;\n            else {\n                res.push_back({nums[i], nums[left], nums[right]});\n                while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++;\n                while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--;\n                left++;\n                right--;\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {-1, 0, 1, 2, -1, -4};\n    vector&lt;vector&lt;int&gt;&gt; res = threeSum(nums);\n    for (auto&amp; v : res) {\n        for (int i : v) {\n            cout &lt;&lt; i &lt;&lt; \" \";\n        }\n        cout &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"content/top100liked/two_pointers/#42-trapping-rain-water","title":"42. Trapping Rain Water","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, dynamic programming, stack, monotonic stack</p> </li> <li></li> </ul> Approach Time Space DP O(N) O(N) Left Right O(N) O(1) Monotonic O(N) O(N) 42. Trapping Rain Water - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef trapDP(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    n = len(height)\n    maxLeft, maxRight = [0 for _ in range(n)], [0 for _ in range(n)]\n\n    for i in range(1, n):\n        maxLeft[i] = max(maxLeft[i - 1], height[i - 1])\n\n    for i in range(n - 2, -1, -1):\n        maxRight[i] = max(maxRight[i + 1], height[i + 1])\n\n    res = 0\n    for i in range(n):\n        res += max(0, min(maxLeft[i], maxRight[i]) - height[i])\n\n    return res\n\n\n# Left Right Pointers\ndef trapLR(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    left, right = 0, len(height) - 1\n    maxL, maxR = height[left], height[right]\n    res = 0\n\n    while left &lt; right:\n        if maxL &lt; maxR:\n            left += 1\n            maxL = max(maxL, height[left])\n            res += maxL - height[left]\n        else:\n            right -= 1\n            maxR = max(maxR, height[right])\n            res += maxR - height[right]\n\n    return res\n\n\n# Monotonic Stack\ndef trapStack(height: List[int]) -&gt; int:\n    stack = []\n    total = 0\n\n    for i in range(len(height)):\n        while stack and height[i] &gt; height[stack[-1]]:\n            top = stack.pop()\n            if not stack:\n                break\n            distance = i - stack[-1] - 1\n            bounded_height = min(height[i], height[stack[-1]]) - height[top]\n            total += distance * bounded_height\n        stack.append(i)\n\n    return total\n\n\nheight = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\nprint(trapDP(height))  # 6\nprint(trapLR(height))  # 6\nprint(trapStack(height))  # 6\n</code></pre> 42. Trapping Rain Water - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int trap(vector&lt;int&gt; &amp;height)\n    {\n        if (height.empty())\n            return 0;\n\n        int res = 0;\n        int left = 0, right = height.size() - 1;\n        int maxL = height[left], maxR = height[right];\n\n        while (left &lt; right)\n        {\n            if (maxL &lt; maxR)\n            {\n                left++;\n                maxL = max(maxL, height[left]);\n                res += maxL - height[left];\n            }\n            else\n            {\n                right--;\n                maxR = max(maxR, height[right]);\n                res += maxR - height[right];\n            }\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    vector&lt;int&gt; height = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};\n    Solution solution;\n    cout &lt;&lt; solution.trap(height) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"}]}