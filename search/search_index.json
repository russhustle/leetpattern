{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to \ud83d\ude80LeetPattern","text":"<p>My goal is to help people solve any problems in coding interviews.</p> <p>Thank you for visiting this project! If you find it helpful or interesting, please consider giving it a \u2b50\ufe0f on GitHub. It helps others discover the project and motivates me to keep improving it. Your support means a lot! \ud83d\ude0a</p> <p>\ud83d\udcda This is a collection of patterns for solving LeetCode problems. The goal is to provide a structured approach to solving problems and to help you build a strong foundation in algorithms and data structures.</p>"},{"location":"about/","title":"Meet your Instructor","text":"Hi, I am Sihan. Connect with me on    <p>I've spent my career diving into the world of AI and machine learning, working on everything from optimizing DNN algorithms to deploying AI models on hardware. Right now, I'm at Sony, where I get to play with TensorRT, ONNX, and OpenVINO to create some pretty cool stuff. I\u2019ve built full-stack systems, set up MLOps pipelines, and delivered high-performance models for AI camera chips.</p> <p>Before Sony, I did a bunch of internships and research gigs, working on things like fine-tuning language models and industrial anomaly detection. I also have a Master\u2019s in Electrical and Electronic Engineering from Tokyo Tech, where I focused on self-supervised learning and edge computing.</p> <p>I love tackling tough problems and pushing the boundaries of what AI can do. It's been a fun ride so far, and I'm excited to keep making an impact in the AI world.</p>"},{"location":"blind75/","title":"Blind 75","text":""},{"location":"blind75/1d_dynamic_programming/","title":"1D Dynamic Programming","text":"<ul> <li> 70. Climbing Stairs (Easy)</li> <li> 198. House Robber (Medium)</li> <li> 213. House Robber II (Medium)</li> <li> 5. Longest Palindromic Substring (Medium)</li> <li> 647. Palindromic Substrings (Medium)</li> <li> 91. Decode Ways (Medium)</li> <li> 322. Coin Change (Medium)</li> <li> 152. Maximum Product Subarray (Medium)</li> <li> 139. Word Break (Medium)</li> <li> 300. Longest Increasing Subsequence (Medium)</li> </ul>"},{"location":"blind75/1d_dynamic_programming/#70-climbing-stairs","title":"70. Climbing Stairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, dynamic programming, memoization</p> </li> <li>Return the number of distinct ways to reach the top of the stairs.</li> <li><code>dp[n]</code> stores the number of distinct ways to reach the <code>n-th</code> stair.</li> <li>Formula: <code>dp[n] = dp[n - 1] + dp[n - 2]</code>.</li> <li>Initialize <code>dp[0] = 0</code>, <code>dp[1] = 1</code>, and <code>dp[2] = 2</code>.</li> </ul> n <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n]</code> 0 - - 0 1 - - 1 2 - 1 2 3 1 2 3 4 2 3 5 5 3 5 8 6 5 8 13 7 8 13 21 8 13 21 34 9 21 34 55 10 34 55 89 70. Climbing Stairs - Python Solution<pre><code># DP\ndef climbStairs(n: int) -&gt; int:\n    if n &lt;= 1:\n        return n\n\n    dp = [i for i in range(n + 1)]\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |     DP      |      O(n)       |     O(n)     |\n# |-------------|-----------------|--------------|\n\nprint(climbStairs(10))  # 89\n</code></pre>"},{"location":"blind75/1d_dynamic_programming/#198-house-robber","title":"198. House Robber","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li> <p>Return the maximum amount of money that can be robbed from the houses. No two adjacent houses can be robbed.</p> </li> <li> <p><code>dp[n]</code> stores the maximum amount of money that can be robbed from the first <code>n</code> houses.</p> </li> <li>Formula: <code>dp[n] = max(dp[n - 1], dp[n - 2] + nums[n])</code>.<ul> <li>Skip: <code>dp[n]</code> \u2192 <code>dp[n - 1]</code></li> <li>Rob: <code>dp[n]</code> \u2192 <code>dp[n - 2] + nums[n]</code></li> </ul> </li> <li>Initialize <code>dp[0] = nums[0]</code> and <code>dp[1] = max(nums[0], nums[1])</code>.</li> <li>Return <code>dp[-1]</code>.</li> <li>Example: <code>nums = [2, 7, 9, 3, 1]</code></li> </ul> n <code>nums[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n-2] + nums[n]</code> <code>dp[n]</code> 0 2 - 2 - 2 1 7 - 7 - 7 2 9 2 7 11 11 3 3 7 11 10 11 4 1 11 11 12 12 198. House Robber - Python Solution<pre><code>from typing import List\n\n\n# DP (House Robber)\ndef rob1(nums: List[int]) -&gt; int:\n    if len(nums) &lt; 3:\n        return max(nums)\n\n    dp = [0 for _ in range(len(nums))]\n    dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n    for i in range(2, len(nums)):\n        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n    return dp[-1]\n\n\n# DP (House Robber) Optimized\ndef rob2(nums: List[int]) -&gt; int:\n    f0, f1 = 0, 0\n\n    for num in nums:\n        f0, f1 = f1, max(f1, f0 + num)\n\n    return f1\n\n\nnums = [2, 7, 9, 3, 1]\nprint(rob1(nums))  # 12\nprint(rob2(nums))  # 12\n</code></pre> 198. House Robber - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int rob(vector&lt;int&gt; &amp;nums)\n    {\n        int prev = 0, cur = 0;\n\n        for (int num : nums)\n        {\n            int temp = cur;\n            cur = max(cur, prev + num);\n            prev = temp;\n        }\n        return cur;\n    }\n};\n\nint main()\n{\n    vector&lt;int&gt; nums = {2, 7, 9, 3, 1};\n    Solution obj;\n    int result = obj.rob(nums);\n    cout &lt;&lt; result &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"blind75/1d_dynamic_programming/#213-house-robber-ii","title":"213. House Robber II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li>Return the maximum amount of money that can be robbed from the houses arranged in a circle.</li> <li>Circular \u2192 Linear: <code>nums[0]</code> and <code>nums[-1]</code> cannot be robbed together.</li> <li>Rob from <code>0</code> to <code>n - 2</code></li> </ul> n <code>nums[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n-2] + nums[n]</code> <code>dp[n]</code> 0 2 - 2 - 2 1 7 - 7 - 7 2 9 2 7 11 11 3 3 7 11 10 11 <ul> <li>Rob from <code>1</code> to <code>n - 1</code></li> </ul> n <code>nums[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n-2] + nums[n]</code> <code>dp[n]</code> 1 7 - - - 7 2 9 - 7 - 9 3 3 7 9 10 10 4 1 9 10 10 10 213. House Robber II - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef rob(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 3:\n        return max(nums)\n\n    def robLinear(nums: List[int]) -&gt; int:\n        dp = [0 for _ in range(len(nums))]\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n        return dp[-1]\n\n    # circle -&gt; linear\n    a = robLinear(nums[1:])  # 2nd house to the last house\n    b = robLinear(nums[:-1])  # 1st house to the 2nd last house\n\n    return max(a, b)\n\n\nnums = [2, 7, 9, 3, 1]\nprint(rob(nums))  # 11\n</code></pre>"},{"location":"blind75/1d_dynamic_programming/#5-longest-palindromic-substring","title":"5. Longest Palindromic Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string, dynamic programming</p> </li> <li>Return the longest palindromic substring in <code>s</code>.</li> </ul> 5. Longest Palindromic Substring - Python Solution<pre><code># DP - Interval\ndef longestPalindromeDP(s: str) -&gt; str:\n    n = len(s)\n    if n &lt;= 1:\n        return s\n\n    start, maxLen = 0, 1\n\n    # Init\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for j in range(1, n):\n        for i in range(j):\n            if s[i] == s[j]:\n                if j - i &lt;= 2:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1]\n\n                if dp[i][j] and j - i + 1 &gt; maxLen:\n                    maxLen = j - i + 1\n                    start = i\n\n    return s[start : start + maxLen]\n\n\n# Expand Around Center\ndef longestPalindromeCenter(s: str) -&gt; str:\n    def expand_around_center(left, right):\n        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n\n    if len(s) &lt;= 1:\n        return s\n\n    start, end = 0, 0\n    for i in range(len(s)):\n        len1 = expand_around_center(i, i)  # odd\n        len2 = expand_around_center(i, i + 1)  # even\n\n        maxLen = max(len1, len2)\n        if maxLen &gt; end - start:\n            start = i - (maxLen - 1) // 2\n            end = i + maxLen // 2\n\n    return s[start : end + 1]\n\n\ns = \"babad\"\nprint(longestPalindromeDP(s))  # \"bab\"\nprint(longestPalindromeCenter(s))  # \"aba\"\n</code></pre>"},{"location":"blind75/1d_dynamic_programming/#647-palindromic-substrings","title":"647. Palindromic Substrings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string, dynamic programming</p> </li> <li>Return the number of palindromic substrings in <code>s</code>.</li> <li>Bottom-up DP table</li> </ul> dp a b b a e a 1 0 0 1 0 b 0 1 1 0 0 b 0 0 1 0 0 a 0 0 0 1 0 e 0 0 0 0 1 647. Palindromic Substrings - Python Solution<pre><code>def countSubstrings(s: str) -&gt; int:\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    res = 0\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i, n):\n            if s[i] == s[j]:\n                if j - i &lt;= 1:\n                    dp[i][j] = 1\n                    res += 1\n                elif dp[i + 1][j - 1]:\n                    dp[i][j] = 1\n                    res += 1\n\n    return res\n\n\nprint(countSubstrings(\"abbae\"))  # 7\n</code></pre>"},{"location":"blind75/1d_dynamic_programming/#91-decode-ways","title":"91. Decode Ways","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul> 91. Decode Ways - Python Solution<pre><code># DP\ndef numDecodingsDP(s: str) -&gt; int:\n    if not s or s[0] == \"0\":\n        return 0\n\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for i in range(1, n + 1):\n        # Check single digit decode\n        if s[i - 1] != \"0\":\n            dp[i] += dp[i - 1]\n\n        # Check two digit decode\n        if i &gt; 1 and \"10\" &lt;= s[i - 2 : i] &lt;= \"26\":\n            dp[i] += dp[i - 2]\n\n    return dp[n]\n\n\n# DFS\ndef numDecodingsDFS(s: str) -&gt; int:\n    memo = {}\n\n    def dfs(i):\n        if i == len(s):\n            return 1\n\n        if s[i] == \"0\":\n            return 0\n\n        if i in memo:\n            return memo[i]\n\n        # Single digit decode\n        ways = dfs(i + 1)\n\n        # Two digits decode\n        if i + 1 &lt; len(s) and \"10\" &lt;= s[i : i + 2] &lt;= \"26\":\n            ways += dfs(i + 2)\n\n        memo[i] = ways\n\n        return ways\n\n    return dfs(0)\n\n\ns = \"226\"\nprint(numDecodingsDP(s))  # 3\nprint(numDecodingsDFS(s))  # 3\n</code></pre>"},{"location":"blind75/1d_dynamic_programming/#322-coin-change","title":"322. Coin Change","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, breadth first search</p> </li> </ul> 322. Coin Change - Python Solution<pre><code>from typing import List\n\n\ndef coinChange(coins: List[int], amount: int) -&gt; int:\n    dp = [float(\"inf\") for _ in range(amount + 1)]\n\n    dp[0] = 0\n\n    for i in range(1, amount + 1):\n        for c in coins:\n            if i - c &gt;= 0:\n                dp[i] = min(dp[i], 1 + dp[i - c])\n\n    return dp[amount] if dp[amount] != float(\"inf\") else -1\n\n\ncoins = [1, 2, 5]\namount = 11\nprint(coinChange(coins, amount))  # 3\n</code></pre>"},{"location":"blind75/1d_dynamic_programming/#152-maximum-product-subarray","title":"152. Maximum Product Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul> 152. Maximum Product Subarray - Python Solution<pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxProduct(nums: List[int]) -&gt; int:\n    n = len(nums)\n    dp_max = [0 for _ in range(n)]\n    dp_min = [0 for _ in range(n)]\n\n    dp_max[0] = nums[0]\n    dp_min[0] = nums[0]\n    max_product = nums[0]\n\n    for i in range(1, n):\n        dp_max[i] = max(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n        dp_min[i] = min(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n\n        max_product = max(max_product, dp_max[i])\n\n    return max_product\n\n\nnums = [2, 3, -2, 4]\nprint(maxProduct(nums))  # 6\n</code></pre>"},{"location":"blind75/1d_dynamic_programming/#139-word-break","title":"139. Word Break","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, dynamic programming, trie, memoization</p> </li> </ul> 139. Word Break - Python Solution<pre><code>from typing import List\n\n\n# DP - Knapsack Unbounded\ndef wordBreak(s: str, wordDict: List[str]) -&gt; bool:\n    n = len(s)\n    wordSet = set(wordDict)\n    dp = [False for _ in range(n + 1)]\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in wordSet:\n                dp[i] = True\n                break\n\n    return dp[n]\n\n\ns = \"leetcode\"\nwordDict = [\"leet\", \"code\"]\nprint(wordBreak(s, wordDict))  # True\n</code></pre>"},{"location":"blind75/1d_dynamic_programming/#300-longest-increasing-subsequence","title":"300. Longest Increasing Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, dynamic programming</p> </li> </ul> 300. Longest Increasing Subsequence - Python Solution<pre><code>from typing import List\n\n\n# DP - LIS\ndef lengthOfLIS(nums: List[int]) -&gt; int:\n    # TC: O(n^2)\n    # SC: O(n)\n    n = len(nums)\n    if n &lt;= 1:\n        return n\n\n    dp = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] &gt; nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\n\nnums = [10, 9, 2, 5, 3, 7, 101, 18]\nprint(lengthOfLIS(nums))  # 4\n</code></pre>"},{"location":"blind75/2d_dynamic_programming/","title":"2D Dynamic Programming","text":"<ul> <li> 62. Unique Paths (Medium)</li> <li> 1143. Longest Common Subsequence (Medium)</li> </ul>"},{"location":"blind75/2d_dynamic_programming/#62-unique-paths","title":"62. Unique Paths","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, combinatorics</p> </li> <li>Count the number of unique paths to reach the bottom-right corner of a <code>m x n</code> grid.</li> </ul> <p></p> 62. Unique Paths - Python Solution<pre><code># DP - 2D\ndef uniquePaths(m: int, n: int) -&gt; int:\n    if m == 1 or n == 1:\n        return 1\n\n    dp = [[1] * n for _ in range(m)]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]\n\n\nprint(uniquePaths(m=3, n=7))  # 28\n# [[1, 1, 1,  1,  1,  1,  1],\n#  [1, 2, 3,  4,  5,  6,  7],\n#  [1, 3, 6, 10, 15, 21, 28]]\n</code></pre>"},{"location":"blind75/2d_dynamic_programming/#1143-longest-common-subsequence","title":"1143. Longest Common Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul> 1143. Longest Common Subsequence - Python Solution<pre><code># DP - LCS\ndef longestCommonSubsequence(text1: str, text2: str) -&gt; int:\n    m, n = len(text1), len(text2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    res = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i - 1] == text2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])\n\n            if res &lt; dp[i][j]:\n                res = dp[i][j]\n\n    return res\n\n\ntext1 = \"abcde\"\ntext2 = \"ace\"\nprint(longestCommonSubsequence(text1, text2))  # 3\n</code></pre>"},{"location":"blind75/advanced_graphs/","title":"Advanced Graphs","text":"<ul> <li> 269. Alien Dictionary (Hard)</li> </ul>"},{"location":"blind75/advanced_graphs/#269-alien-dictionary","title":"269. Alien Dictionary","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, depth first search, breadth first search, graph, topological sort</p> </li> <li>Return the correct order of characters in the alien language.</li> </ul> 269. Alien Dictionary - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS - Kahn's algorithm (Topological Sort)\ndef alienOrderBFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    indegree = {c: 0 for word in words for c in word}\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                    indegree[w2[j]] += 1\n                break\n\n    q = deque([c for c in indegree if indegree[c] == 0])\n    result = []\n\n    while q:\n        char = q.popleft()\n        result.append(char)\n\n        for neighbor in graph[char]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n\n    return \"\".join(result) if len(result) == len(indegree) else \"\"\n\n\n# DFS - Topological Sort\ndef alienOrderDFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    visited = {}\n    result = []\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                break\n\n    def dfs(c):\n        if c in visited:\n            return visited[c]\n\n        visited[c] = False\n        for neighbor in graph[c]:\n            if not dfs(neighbor):\n                return False\n\n        visited[c] = True\n        result.append(c)\n        return True\n\n    for c in list(graph.keys()):\n        if not dfs(c):\n            return \"\"\n\n    return \"\".join(result[::-1])\n\n\nwords = [\"wrt\", \"wrf\", \"er\", \"ett\", \"rftt\"]\nprint(alienOrderBFS(words))  # wertf\nprint(alienOrderDFS(words))  # wertf\n</code></pre>"},{"location":"blind75/arrays_hashing/","title":"Arrays Hashing","text":"<ul> <li> 217. Contains Duplicate (Easy)</li> <li> 242. Valid Anagram (Easy)</li> <li> 1. Two Sum (Easy)</li> <li> 49. Group Anagrams (Medium)</li> <li> 347. Top K Frequent Elements (Medium)</li> <li> 271. Encode and Decode Strings (Medium)</li> <li> 238. Product of Array Except Self (Medium)</li> <li> 128. Longest Consecutive Sequence (Medium)</li> </ul>"},{"location":"blind75/arrays_hashing/#217-contains-duplicate","title":"217. Contains Duplicate","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, sorting</p> </li> <li>Return True if the array contains any duplicates, otherwise return False.</li> </ul> 217. Contains Duplicate - Python Solution<pre><code>from typing import List\n\n\n# Brute Force\ndef containsDuplicateBF(nums: List[int]) -&gt; bool:\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] == nums[j]:\n                return True\n\n    return False\n\n\n# Sort\ndef containsDuplicateSort(nums: List[int]) -&gt; bool:\n    nums.sort()\n\n    for i in range(1, len(nums)):\n        if nums[i] == nums[i - 1]:\n            return True\n\n    return False\n\n\n# Set\ndef containsDuplicateSet(nums: List[int]) -&gt; bool:\n    seen = set()\n\n    for i in nums:\n        if i in seen:\n            return True\n        seen.add(i)\n\n    return False\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# | Brute Force |    O(n^2)       |    O(1)      |\n# |     Sort    |    O(n log n)   |    O(1)      |\n# |     Set     |    O(n)         |    O(n)      |\n# |-------------|-----------------|--------------|\n\nprint(containsDuplicateBF([1, 2, 3, 1]))  # True\nprint(containsDuplicateSort([1, 2, 3, 1]))  # True\nprint(containsDuplicateSet([1, 2, 3, 1]))  # True\n</code></pre>"},{"location":"blind75/arrays_hashing/#242-valid-anagram","title":"242. Valid Anagram","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, string, sorting</p> </li> <li>Return true if an input string is an anagram of another string.</li> <li>An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once, e.g., <code>listen</code> is an anagram of <code>silent</code>.</li> </ul> 242. Valid Anagram - Python Solution<pre><code>from collections import Counter\n\n\n# Hashmap\ndef isAnagramHash(s: str, t: str) -&gt; bool:\n    \"\"\"Return True if t is an anagram of s, False otherwise.\"\"\"\n    if len(s) != len(t):\n        return False\n\n    count = dict()\n\n    for i in s:\n        if i in count:\n            count[i] += 1\n        else:\n            count[i] = 1\n\n    for j in t:\n        if j in count:\n            count[j] -= 1\n        else:\n            return False\n\n    for count in count.values():\n        if count != 0:\n            return False\n\n    return True\n\n\n# Array\ndef isAnagramArray(s: str, t: str) -&gt; bool:\n    if len(s) != len(t):\n        return False\n\n    count = [0 for _ in range(26)]\n\n    for i in s:\n        count[ord(i) - ord(\"a\")] += 1\n\n    for j in t:\n        count[ord(j) - ord(\"a\")] -= 1\n\n    for i in count:\n        if i != 0:\n            return False\n\n    return True\n\n\n# Counter\ndef isAnagramCounter(s: str, t: str) -&gt; bool:\n    return Counter(s) == Counter(t)\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |   Hashmap   |       O(n)      |     O(1)     |\n# |    Array    |       O(n)      |     O(1)     |\n# |   Counter   |       O(n)      |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\ns = \"anagram\"\nt = \"nagaram\"\nprint(isAnagramHash(s, t))  # True\nprint(isAnagramArray(s, t))  # True\nprint(isAnagramCounter(s, t))  # True\n</code></pre>"},{"location":"blind75/arrays_hashing/#1-two-sum","title":"1. Two Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table</p> </li> <li>Return the indices of the two numbers such that they add up to a specific target.</li> </ul> Approach Time Complexity Space Complexity Hashmap O(n) O(n) 1. Two Sum - Python Solution<pre><code>from typing import List\n\n\n# Hashmap\ndef twoSum(nums: List[int], target: int) -&gt; List[int]:\n    hashmap = {}  # val: idx\n\n    for idx, val in enumerate(nums):\n        if (target - val) in hashmap:\n            return [hashmap[target - val], idx]\n\n        hashmap[val] = idx\n\n\nnums = [2, 7, 11, 15]\ntarget = 18\nassert twoSum(nums, target) == [1, 2]\n</code></pre>"},{"location":"blind75/arrays_hashing/#49-group-anagrams","title":"49. Group Anagrams","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, sorting</p> </li> </ul> 49. Group Anagrams - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash - List\ndef groupAnagrams(strs: List[str]) -&gt; List[List[str]]:\n    result = defaultdict(list)\n\n    for s in strs:\n        count = [0] * 26\n        for i in s:\n            count[ord(i) - ord(\"a\")] += 1\n\n        result[tuple(count)].append(s)\n\n    return list(result.values())\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Hash     |     O(n * k)    |     O(n)     |\n# |-------------|-----------------|--------------|\n\n\nstrs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\nprint(groupAnagrams(strs))\n# [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n</code></pre>"},{"location":"blind75/arrays_hashing/#347-top-k-frequent-elements","title":"347. Top K Frequent Elements","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, divide and conquer, sorting, heap priority queue, bucket sort, counting, quickselect</p> </li> </ul> 347. Top K Frequent Elements - Python Solution<pre><code>import heapq\nfrom collections import Counter\nfrom typing import List\n\n\n# Heap + Counter\ndef topKFrequent(nums: List[int], k: int) -&gt; List[int]:\n    minHeap = []\n\n    for val, freq in Counter(nums).items():\n        if len(minHeap) &lt; k:\n            heapq.heappush(minHeap, (freq, val))\n        else:\n            heapq.heappushpop(minHeap, (freq, val))\n\n    return [i for _, i in minHeap]\n\n\n# Counter (Most Common)\ndef topKFrequentCounter(nums: List[int], k: int) -&gt; List[int]:\n    commons = Counter(nums).most_common(k)\n    return [i for i, _ in commons]\n\n\nnums = [1, 1, 1, 2, 2, 3]\nk = 2\nprint(topKFrequent(nums, k))  # [1, 2]\nprint(topKFrequentCounter(nums, k))  # [1, 2]\n</code></pre>"},{"location":"blind75/arrays_hashing/#271-encode-and-decode-strings","title":"271. Encode and Decode Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, design</p> </li> </ul> 271. Encode and Decode Strings - Python Solution<pre><code>from typing import List\n\n\nclass Codec:\n    def encode(self, strs: List[str]) -&gt; str:\n        \"\"\"Encodes a list of strings to a single string.\"\"\"\n        encoded = \"\"\n\n        for s in strs:\n            encoded += str(len(s)) + \"#\" + s\n\n        return encoded\n\n    def decode(self, s: str) -&gt; List[str]:\n        \"\"\"Decodes a single string to a list of strings.\"\"\"\n        decoded = []\n        i = 0\n\n        while i &lt; len(s):\n            j = i\n            while s[j] != \"#\":\n                j += 1\n\n            strLen = int(s[i:j])\n            decoded.append(s[j + 1 : j + 1 + strLen])\n            i = j + 1 + strLen\n\n        return decoded\n\n\n# |-------------|-------------|--------------|\n# |   Approach  |    Time     |    Space     |\n# |-------------|-------------|--------------|\n# | Two pointers|    O(n)     |     O(n)     |\n# |-------------|-------------|--------------|\n\n\ncodec = Codec()\nencoded = codec.encode([\"hello\", \"world\"])\nprint(encoded)  # \"5#hello5#world\"\ndecoded = codec.decode(encoded)\nprint(decoded)  # [\"hello\", \"world\"]\n</code></pre>"},{"location":"blind75/arrays_hashing/#238-product-of-array-except-self","title":"238. Product of Array Except Self","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, prefix sum</p> </li> <li>Classic Prefix Sum problem</li> <li>Return an array <code>output</code> such that <code>output[i]</code> is equal to the product of all the elements of <code>nums</code> except <code>nums[i]</code>.</li> </ul> Approach Time Space Prefix O(n) O(n) Prefix (Optimized) O(n) O(1) 238. Product of Array Except Self - Python Solution<pre><code>from typing import List\n\n\n# Prefix\ndef productExceptSelf(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    prefix = [1 for _ in range(n)]\n    suffix = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        prefix[i] = nums[i - 1] * prefix[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        suffix[i] = nums[i + 1] * suffix[i + 1]\n\n    result = [i * j for i, j in zip(prefix, suffix)]\n\n    return result\n\n\n# Prefix (Optimized)\ndef productExceptSelfOptimized(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    result = [1 for _ in range(n)]\n\n    prefix = 1\n    for i in range(n):\n        result[i] = prefix\n        prefix *= nums[i]\n\n    suffix = 1\n    for i in range(n - 1, -1, -1):\n        result[i] *= suffix\n        suffix *= nums[i]\n\n    return result\n\n\nprint(productExceptSelf([1, 2, 3, 4]))\n# [24, 12, 8, 6]\nprint(productExceptSelfOptimized([1, 2, 3, 4]))\n# [24, 12, 8, 6]\n</code></pre>"},{"location":"blind75/arrays_hashing/#128-longest-consecutive-sequence","title":"128. Longest Consecutive Sequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, union find</p> </li> </ul> 128. Longest Consecutive Sequence - Python Solution<pre><code>from typing import List\n\n\n# Set\ndef longestConsecutiveSet(nums: List[int]) -&gt; int:\n    num_set = set(nums)  # O(n)\n    longest = 0\n\n    for n in nums:\n        if (n - 1) not in num_set:  # left boundary\n            length = 1\n\n            while (n + length) in num_set:\n                length += 1\n\n            longest = max(longest, length)\n\n    return longest\n\n\n# Union Find\ndef longestConsecutiveUF(nums: List[int]) -&gt; int:\n    if not nums:\n        return 0\n\n    par = {num: num for num in nums}\n    rank = {num: 1 for num in nums}\n\n    def find(num):\n        p = par[num]\n        while p != par[p]:\n            p = par[p]\n        return p\n\n    def union(num1, num2):\n        p1, p2 = find(num1), find(num2)\n        if p1 == p2:\n            return\n\n        if rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n            rank[p2] += rank[p1]\n        else:\n            par[p2] = p1\n            rank[p1] += rank[p2]\n\n    for num in nums:\n        if num - 1 in par:\n            union(num, num - 1)\n\n    return max(rank.values())\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |  Set       |  O(N)  |  O(N)   |\n# | Union Find |  O(N)  |  O(N)   |\n# |------------|--------|---------|\n\n\nnums = [100, 4, 200, 1, 3, 2]\nprint(longestConsecutiveSet(nums))  # 4\nprint(longestConsecutiveUF(nums))  # 4\n</code></pre>"},{"location":"blind75/backtracking/","title":"Backtracking","text":"<ul> <li> 39. Combination Sum (Medium)</li> <li> 79. Word Search (Medium)</li> </ul>"},{"location":"blind75/backtracking/#39-combination-sum","title":"39. Combination Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking</p> </li> </ul> 39. Combination Sum - Python Solution<pre><code>from typing import List\n\n\ndef combinationSum(candidates: List[int], target: int) -&gt; List[List[int]]:\n    result = []\n    path = []\n\n    def backtracking(total, start):\n        if total &gt; target:\n            return None\n        if total == target:\n            result.append(path[:])\n            return None\n\n        for i in range(start, len(candidates)):\n            total += candidates[i]\n            path.append(candidates[i])\n\n            backtracking(total, i)\n\n            total -= candidates[i]\n            path.pop()\n\n    backtracking(0, 0)\n    return result\n\n\nprint(combinationSum([2, 3, 6, 7], 7))  # [[2, 2, 3], [7]]\n</code></pre>"},{"location":"blind75/backtracking/#79-word-search","title":"79. Word Search","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, backtracking, depth first search, matrix</p> </li> </ul> 79. Word Search - Python Solution<pre><code>from typing import List\n\n\ndef exist(board: List[List[str]], word: str) -&gt; bool:\n    m, n = len(board), len(board[0])\n    path = set()\n    directions = ((0, 1), (1, 0), (0, -1), (-1, 0))\n\n    def dfs(r, c, i):\n        if i == len(word):\n            return True\n\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or board[r][c] != word[i]\n            or (r, c) in path\n        ):\n            return False\n\n        path.add((r, c))\n\n        for dr, dc in directions:\n            if dfs(r + dr, c + dc, i + 1):\n                return True\n\n        path.remove((r, c))\n        return False\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, 0):\n                return True\n\n    return False\n\n\nboard = [\n    [\"A\", \"B\", \"C\", \"E\"],\n    [\"S\", \"F\", \"C\", \"S\"],\n    [\"A\", \"D\", \"E\", \"E\"],\n]\nword = \"ABCCED\"\nprint(exist(board, word))  # True\n</code></pre>"},{"location":"blind75/binary_search/","title":"Binary Search","text":"<ul> <li> 153. Find Minimum in Rotated Sorted Array (Medium)</li> <li> 33. Search in Rotated Sorted Array (Medium)</li> </ul>"},{"location":"blind75/binary_search/#153-find-minimum-in-rotated-sorted-array","title":"153. Find Minimum in Rotated Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul> 153. Find Minimum in Rotated Sorted Array - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef findMin(nums: List[int]) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt; right:\n        mid = left + (right - left) // 2\n        if nums[mid] &gt; nums[right]:\n            left = mid + 1\n        else:\n            right = mid\n\n    return nums[right]\n\n\nnums = [4, 5, 6, 7, 0, 1, 2]\nprint(findMin(nums))  # 0\n</code></pre>"},{"location":"blind75/binary_search/#33-search-in-rotated-sorted-array","title":"33. Search in Rotated Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul> 33. Search in Rotated Sorted Array - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef search(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] == target:\n            return mid\n\n        if nums[left] &lt;= nums[mid]:\n            if nums[left] &lt;= target &lt; nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if nums[mid] &lt; target &lt;= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n    return -1\n\n\nnums = [4, 5, 6, 7, 0, 1, 2]\ntarget = 0\nprint(search(nums, target))  # 4\n</code></pre>"},{"location":"blind75/bit_manipulation/","title":"Bit Manipulation","text":"<ul> <li> 191. Number of 1 Bits (Easy)</li> <li> 338. Counting Bits (Easy)</li> <li> 190. Reverse Bits (Easy)</li> <li> 268. Missing Number (Easy)</li> <li> 371. Sum of Two Integers (Medium)</li> </ul>"},{"location":"blind75/bit_manipulation/#191-number-of-1-bits","title":"191. Number of 1 Bits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: divide and conquer, bit manipulation</p> </li> </ul> 191. Number of 1 Bits - Python Solution<pre><code># Bit Manipulation\ndef hammingWeight1(n: int) -&gt; int:\n    res = 0\n\n    while n != 0:\n        n = n &amp; (n - 1)  # Unset the rightmost 1-bit\n        res += 1\n\n    return res\n\n\ndef hammingWeight2(n: int) -&gt; int:\n    return bin(n).count(\"1\")\n\n\ndef hammingWeight3(n: int) -&gt; int:\n    def decimalToBinary(n: int) -&gt; str:\n        if n == 0:\n            return \"0\"\n\n        binary = \"\"\n        while n &gt; 0:\n            binary = str(n % 2) + binary\n            n //= 2\n\n        return binary\n\n    binary = decimalToBinary(n)\n\n    return binary.count(\"1\")\n\n\nn = 11\nprint(hammingWeight1(n))  # 3\nprint(hammingWeight2(n))  # 3\n\nn = 47\nprint(bin(n))\n</code></pre>"},{"location":"blind75/bit_manipulation/#338-counting-bits","title":"338. Counting Bits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: dynamic programming, bit manipulation</p> </li> </ul> 338. Counting Bits - Python Solution<pre><code>from typing import List\n\n\n# Bit Manipulation\ndef countBits(n: int) -&gt; List[int]:\n    bits = [0 for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        bits[i] = bits[i &gt;&gt; 1] + (i &amp; 1)\n\n    return bits\n\n\nn = 5\nprint(countBits(n))  # [0, 1, 1, 2, 1, 2]\n</code></pre>"},{"location":"blind75/bit_manipulation/#190-reverse-bits","title":"190. Reverse Bits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: divide and conquer, bit manipulation</p> </li> </ul> 190. Reverse Bits - Python Solution<pre><code># Bit Manipulation\ndef reverseBits(n: int) -&gt; int:\n    res = 0\n\n    for i in range(32):\n        res = (res &lt;&lt; 1) | (n &amp; 1)\n        n &gt;&gt;= 1\n\n    return res\n\n\nn = 0b00000010100101000001111010011100\nprint(reverseBits(n))  # 964176192\n</code></pre>"},{"location":"blind75/bit_manipulation/#268-missing-number","title":"268. Missing Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, math, binary search, bit manipulation, sorting</p> </li> </ul> 268. Missing Number - Python Solution<pre><code>from typing import List\n\n\n# Math\ndef missingNumberMath(nums: List[int]) -&gt; int:\n    n = len(nums)\n    return (n * (n + 1)) // 2 - sum(nums)\n\n\n# Bit Manipulation (XOR)\ndef missingNumberXOR(nums: List[int]) -&gt; int:\n    n = len(nums)\n\n    for i, num in enumerate(nums):\n        n ^= i ^ num\n\n    return n\n\n\nnums = [3, 0, 1]\nprint(missingNumberMath(nums))  # 2\nprint(missingNumberXOR(nums))  # 2\n</code></pre>"},{"location":"blind75/bit_manipulation/#371-sum-of-two-integers","title":"371. Sum of Two Integers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, bit manipulation</p> </li> </ul> 371. Sum of Two Integers - Python Solution<pre><code># Bit Manipulation\ndef getSum(a: int, b: int) -&gt; int:\n    MASK = 0xFFFFFFFF\n    MAX_INT = 0x7FFFFFFF\n\n    while b != 0:\n        temp = (a ^ b) &amp; MASK\n        b = ((a &amp; b) &lt;&lt; 1) &amp; MASK\n        a = temp\n\n    return a if a &lt;= MAX_INT else ~(a ^ MASK)\n\n\nprint(getSum(1, 2))  # 3\n</code></pre>"},{"location":"blind75/graphs/","title":"Graphs","text":"<ul> <li> 200. Number of Islands (Medium)</li> <li> 133. Clone Graph (Medium)</li> <li> 417. Pacific Atlantic Water Flow (Medium)</li> <li> 207. Course Schedule (Medium)</li> <li> 261. Graph Valid Tree (Medium)</li> <li> 323. Number of Connected Components in an Undirected Graph (Medium)</li> </ul>"},{"location":"blind75/graphs/#200-number-of-islands","title":"200. Number of Islands","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix</p> </li> <li>Count the number of islands in a 2D grid.</li> <li>Method 1: DFS</li> <li> <p>Method 2: BFS (use a queue to traverse the grid)</p> </li> <li> <p>How to keep track of visited cells?</p> <ol> <li>Mark the visited cell as <code>0</code> (or any other value) to avoid revisiting it.</li> <li>Use a set to store the visited cells.</li> </ol> </li> <li> <p>Steps:</p> <ol> <li>Init: variables</li> <li>DFS/BFS: starting from the cell with <code>1</code>, turn all the connected <code>1</code>s to <code>0</code>.</li> <li>Traverse the grid, and if the cell is <code>1</code>, increment the count and call DFS/BFS.</li> </ol> </li> </ul> <p></p> 200. Number of Islands - Python Solution<pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef numIslandsDFS(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    res = 0\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] != \"1\":\n            return\n\n        grid[r][c] = \"2\"\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                dfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Set\ndef numIslandsBFS1(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == \"0\"\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\" and (r, c) not in visited:\n                visited.add((r, c))\n                bfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = dr + row, dc + col\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] != \"1\"\n                ):\n                    continue\n                grid[nr][nc] = \"2\"\n                q.append((nr, nc))\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == \"1\":\n                grid[i][j] = \"2\"\n                bfs(i, j)\n                res += 1\n\n    return res\n\n\ngrid = [\n    [\"1\", \"1\", \"1\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"0\", \"0\", \"0\", \"0\", \"0\"],\n]\n\nprint(numIslandsDFS(deepcopy(grid)))  # 1\nprint(numIslandsBFS1(deepcopy(grid)))  # 1\nprint(numIslandsBFS2(deepcopy(grid)))  # 1\n</code></pre>"},{"location":"blind75/graphs/#133-clone-graph","title":"133. Clone Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, depth first search, breadth first search, graph</p> </li> </ul> 133. Clone Graph - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\n\nclass Node:\n    def __init__(self, val=0, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\n\n# 1. DFS\ndef cloneGraphDFS(node: Optional[\"Node\"]) -&gt; Optional[\"Node\"]:\n    if not node:\n        return None\n\n    cloned = {}  # {old: new}\n\n    def dfs(node):\n        if node in cloned:\n            return cloned[node]\n\n        new = Node(node.val)\n        cloned[node] = new\n\n        for neighbor in node.neighbors:\n            new.neighbors.append(dfs(neighbor))\n\n        return new\n\n    return dfs(node)\n\n\n# 2. BFS\ndef cloneGraphBFS(node: Optional[\"Node\"]) -&gt; Optional[\"Node\"]:\n    if not node:\n        return None\n\n    cloned = {node: Node(node.val)}\n    q = deque([node])\n\n    while q:\n        cur = q.popleft()\n\n        for neighbor in cur.neighbors:\n            if neighbor not in cloned:\n                cloned[neighbor] = Node(neighbor.val)\n                q.append(neighbor)\n\n            cloned[cur].neighbors.append(cloned[neighbor])\n\n    return cloned[node]\n</code></pre>"},{"location":"blind75/graphs/#417-pacific-atlantic-water-flow","title":"417. Pacific Atlantic Water Flow","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, matrix</p> </li> </ul> 417. Pacific Atlantic Water Flow - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef pacificAtlanticDFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(r, c, visited, prev_height):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or heights[r][c] &lt; prev_height\n            or (r, c) in visited\n        ):\n            return None\n\n        visited.add((r, c))\n        height = heights[r][c]\n        for dr, dc in directions:\n            dfs(dr + r, dc + c, visited, height)\n\n    for c in range(n):\n        dfs(0, c, pac, heights[0][c])\n        dfs(m - 1, c, atl, heights[m - 1][c])\n\n    for r in range(m):\n        dfs(r, 0, pac, heights[r][0])\n        dfs(r, n - 1, atl, heights[r][n - 1])\n\n    return list(pac &amp; atl)\n\n\n# BFS\ndef pacificAtlanticBFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def bfs(r, c, visited):\n        q = deque([(r, c)])\n        visited.add((r, c))\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr in range(m)\n                    and nc in range(n)\n                    and heights[row][col] &lt;= heights[nr][nc]\n                    and (nr, nc) not in visited\n                ):\n                    q.append((nr, nc))\n                    visited.add((nr, nc))\n\n    for c in range(n):\n        bfs(0, c, pac)  # top\n        bfs(m - 1, c, atl)  # bottom\n\n    for r in range(m):\n        bfs(r, 0, pac)  # left\n        bfs(r, n - 1, atl)  # right\n\n    return list(pac &amp; atl)\n\n\nheights = [\n    [1, 2, 2, 3, 5],\n    [3, 2, 3, 4, 4],\n    [2, 4, 5, 3, 1],\n    [6, 7, 1, 4, 5],\n    [5, 1, 1, 2, 4],\n]\nprint(pacificAtlanticDFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\nprint(pacificAtlanticBFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\n</code></pre>"},{"location":"blind75/graphs/#207-course-schedule","title":"207. Course Schedule","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort</p> </li> <li>Return true if it is possible to finish all courses, otherwise return false.</li> <li>Dependency relationships imply the topological sort algorithm.</li> <li>Cycle detection</li> <li>Topological Sort<ul> <li>DAG (Directed Acyclic Graph)</li> <li>Time complexity: O(V+E)</li> <li>Space complexity: O(V+E)</li> <li>Prerequisites: Indegree (Look at the problem 1557. Minimum Number of Vertices to Reach All Nodes)<ul> <li>Indegree: Number of incoming edges to a vertex</li> </ul> </li> <li>Applications: task scheduling, course scheduling, build systems, dependency resolution, compiler optimization, etc.</li> </ul> </li> </ul> <p></p> <p></p> <p>Course to prerequisites mapping</p> <pre><code>flowchart LR\n    0((0)) --&gt; 1((1))\n    0((0)) --&gt; 2((2))\n    1((1)) --&gt; 3((3))\n    3((3)) --&gt; 4((4))\n    1((1)) --&gt; 4((4))</code></pre> <p>Prerequisites to course mapping</p> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    2((2)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))\n    4((4)) --&gt; 3((3))\n    4((4)) --&gt; 1((1))</code></pre> course 0 0 1 1 3 prerequisite 1 2 3 4 4 index 0 1 2 3 4 in-degree 0 0 0 0 0 <p>Initialize</p> <ul> <li>graph</li> </ul> prerequisite 1 2 3 4 course <code>[0]</code> <code>[0]</code> <code>[1]</code> <code>[1, 3]</code> <ul> <li>in-degree</li> </ul> 0 1 2 3 4 in-degree 2 2 0 1 0 <ul> <li>queue: <code>[2, 4]</code></li> <li>pop <code>2</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))\n    4((4)) --&gt; 3((3))\n    4((4)) --&gt; 1((1))</code></pre> 0 1 2 3 4 in-degree 1 2 0 1 0 <ul> <li>queue: <code>[4]</code></li> <li>pop <code>4</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))</code></pre> 0 1 2 3 4 in-degree 1 1 0 0 0 <ul> <li>queue: <code>[3]</code></li> <li>pop <code>3</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))</code></pre> 0 1 2 3 4 in-degree 1 0 0 0 0 <ul> <li>queue: <code>[1]</code></li> <li>pop <code>1</code> from the queue</li> </ul> <pre><code>flowchart LR\n    0((0))</code></pre> 0 1 2 3 4 in-degree 0 0 0 0 0 <ul> <li>queue: <code>[0]</code></li> <li>pop <code>0</code> from the queue</li> <li>All courses are taken. Return <code>True</code>.</li> </ul> 207. Course Schedule - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS (Kahn's Algorithm)\ndef canFinishBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    count = 0\n\n    while q:\n        crs = q.popleft()\n        count += 1\n\n        for nxt in graph[crs]:\n            indegree[nxt] -= 1\n\n            if indegree[nxt] == 0:\n                q.append(nxt)\n\n    return count == numCourses\n\n\n# DFS + Set\ndef canFinishDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for crs, pre in prerequisites:\n        graph[crs].append(pre)\n\n    visiting = set()\n\n    def dfs(crs):\n        if crs in visiting:  # cycle detected\n            return False\n        if graph[crs] == []:\n            return True\n\n        visiting.add(crs)\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        visiting.remove(crs)\n        graph[crs] = []\n\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\n# DFS + List\ndef canFinishDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for pre, crs in prerequisites:\n        graph[crs].append(pre)\n\n    # 0: init, 1: visiting, 2: visited\n    status = [0] * numCourses\n\n    def dfs(crs):\n        if status[crs] == 1:  # cycle detected\n            return False\n        if status[crs] == 2:\n            return True\n\n        status[crs] = 1\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        status[crs] = 2\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(canFinishBFS(5, prerequisites))  # True\nprint(canFinishDFS1(5, prerequisites))  # True\nprint(canFinishDFS2(5, prerequisites))  # True\n</code></pre>"},{"location":"blind75/graphs/#261-graph-valid-tree","title":"261. Graph Valid Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> </ul> 261. Graph Valid Tree - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Graph\ndef validTree(n: int, edges: List[List[int]]) -&gt; bool:\n    if n == 0:\n        return False\n    if len(edges) != n - 1:\n        return False\n\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = set()\n\n    def dfs(node, parent):\n        if node in visited:\n            return False\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor != parent and not dfs(neighbor, node):\n                return False\n        return True\n\n    return dfs(0, -1) and len(visited) == n\n\n\nprint(validTree(5, [[0, 1], [0, 2], [0, 3], [1, 4]]))  # True\nprint(validTree(5, [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]))  # False\n</code></pre>"},{"location":"blind75/graphs/#323-number-of-connected-components-in-an-undirected-graph","title":"323. Number of Connected Components in an Undirected Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> </ul> 323. Number of Connected Components in an Undirected Graph - Python Solution<pre><code>from typing import List\n\n\n# Union Find\ndef countComponents(n: int, edges: List[List[int]]) -&gt; int:\n    uf = UnionFind(n)\n    count = n\n\n    for u, v in edges:\n        count -= uf.union(u, v)\n\n    return count\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(n)}\n        self.rank = {i: 1 for i in range(n)}\n\n    def find(self, n):\n        p = self.par[n]\n        while self.par[p] != p:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return 0\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.par[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.par[p1] = p2\n        else:\n            self.par[p2] = p1\n            self.rank[p1] += 1\n\n        return 1\n\n\nprint(countComponents(5, [[0, 1], [1, 2], [3, 4]]))  # 2\n</code></pre>"},{"location":"blind75/greedy/","title":"Greedy","text":"<ul> <li> 53. Maximum Subarray (Medium)</li> <li> 55. Jump Game (Medium)</li> </ul>"},{"location":"blind75/greedy/#53-maximum-subarray","title":"53. Maximum Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, divide and conquer, dynamic programming</p> </li> </ul> 53. Maximum Subarray - Python Solution<pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxSubArrayDP(nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n\n    dp[0] = nums[0]\n    maxSum = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(\n            dp[i - 1] + nums[i],  # continue the previous subarray\n            nums[i],  # start a new subarray\n        )\n        maxSum = max(maxSum, dp[i])\n\n    return maxSum\n\n\n# Greedy\ndef maxSubArrayGreedy(nums: List[int]) -&gt; int:\n    max_sum = nums[0]\n    cur_sum = 0\n\n    for num in nums:\n        cur_sum = max(cur_sum + num, num)\n        max_sum = max(max_sum, cur_sum)\n\n    return max_sum\n\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArrayDP(nums))  # 6\nprint(maxSubArrayGreedy(nums))  # 6\n</code></pre>"},{"location":"blind75/greedy/#55-jump-game","title":"55. Jump Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> <li>Return <code>True</code> if you can reach the last index, otherwise <code>False</code>.</li> </ul> <ul> <li>Example: <code>[2, 3, 1, 1, 4, 1, 2, 0, 0]</code></li> </ul> Index Value Index + Value Max Reach Max Reach &gt;= Last Index 0 2 2 2 False 1 3 4 4 False 2 1 3 4 False 3 1 4 4 False 4 4 8 8 True 5 1 6 8 True 6 2 8 8 True 7 0 7 8 True 8 0 8 8 True 55. Jump Game - Python Solution<pre><code>from typing import List\n\n\n# Greedy - Interval\ndef canJump(nums: List[int]) -&gt; bool:\n    maxReach = 0\n    i = 0\n    n = len(nums)\n\n    while i &lt;= maxReach:\n        maxReach = max(maxReach, i + nums[i])\n        if maxReach &gt;= n - 1:\n            return True\n        i += 1\n\n    return False\n\n\nprint(canJump([2, 3, 1, 1, 4, 1, 2, 0, 0]))  # True\n</code></pre>"},{"location":"blind75/heap/","title":"Heap","text":"<ul> <li> 295. Find Median from Data Stream (Hard)</li> </ul>"},{"location":"blind75/heap/#295-find-median-from-data-stream","title":"295. Find Median from Data Stream","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: two pointers, design, sorting, heap priority queue, data stream</p> </li> </ul> 295. Find Median from Data Stream - Python Solution<pre><code>from heapq import heappop, heappush\n\n\n# Heap - Two Heaps\nclass MedianFinder:\n    def __init__(self):\n        self.max = []\n        self.min = []\n\n    def addNum(self, num: int) -&gt; None:\n        heappush(self.max, -num)\n        heappush(self.min, -heappop(self.max))\n\n        if len(self.min) &gt; len(self.max):\n            heappush(self.max, -heappop(self.min))\n\n    def findMedian(self) -&gt; float:\n        if len(self.max) == len(self.min):\n            return (-self.max[0] + self.min[0]) / 2.0\n        else:\n            return -self.max[0]\n\n\n# TC: O(log n)\n# SC: O(n)\n\nmedian_finder = MedianFinder()\nmedian_finder.addNum(1)\nmedian_finder.addNum(2)\nassert median_finder.findMedian() == 1.5\nmedian_finder.addNum(3)\nassert median_finder.findMedian() == 2\nmedian_finder.addNum(4)\nassert median_finder.findMedian() == 2.5\nmedian_finder.addNum(5)\nassert median_finder.findMedian() == 3\nprint(\"All Passed.\")\n</code></pre>"},{"location":"blind75/intervals/","title":"Intervals","text":"<ul> <li> 57. Insert Interval (Medium)</li> <li> 56. Merge Intervals (Medium)</li> <li> 252. Meeting Rooms (Easy)</li> <li> 253. Meeting Rooms II (Medium)</li> <li> 254. Factor Combinations (Medium)</li> </ul>"},{"location":"blind75/intervals/#57-insert-interval","title":"57. Insert Interval","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array</p> </li> </ul> 57. Insert Interval - Python Solution<pre><code>from typing import List\n\n\n# Interval\ndef insert(\n    intervals: List[List[int]], newInterval: List[int]\n) -&gt; List[List[int]]:\n    n = len(intervals)\n\n    if n == 0:\n        return [newInterval]\n\n    if newInterval[1] &lt; intervals[0][0]:\n        return [newInterval] + intervals\n\n    if newInterval[0] &gt; intervals[-1][1]:\n        return intervals + [newInterval]\n\n    i = 0\n    result = []\n\n    while i &lt; n and intervals[i][1] &lt; newInterval[0]:\n        result.append(intervals[i])\n        i += 1\n\n    while i &lt; n and intervals[i][0] &lt;= newInterval[1]:\n        newInterval[0] = min(newInterval[0], intervals[i][0])\n        newInterval[1] = max(newInterval[1], intervals[i][1])\n        i += 1\n\n    result.append(newInterval)\n\n    while i &lt; n:\n        result.append(intervals[i])\n        i += 1\n\n    return result\n\n\nintervals = [[1, 3], [6, 9]]\nnewInterval = [2, 5]\nprint(insert(intervals, newInterval))  # [[1, 5], [6, 9]]\n</code></pre>"},{"location":"blind75/intervals/#56-merge-intervals","title":"56. Merge Intervals","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sorting</p> </li> <li>Merge all overlapping intervals.</li> </ul> 56. Merge Intervals - Python Solution<pre><code>from typing import List\n\n\n# Intervals\ndef merge(intervals: List[List[int]]) -&gt; List[List[int]]:\n    n = len(intervals)\n    if n &lt;= 1:\n        return intervals\n\n    intervals.sort(key=lambda x: x[0])\n    res = [intervals[0]]\n\n    for i in range(1, n):\n        if intervals[i][0] &lt;= res[-1][1]:\n            res[-1][1] = max(res[-1][1], intervals[i][1])\n        else:\n            res.append(intervals[i])\n\n    return res\n\n\nprint(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))\n# [[1, 6], [8, 10], [15, 18]]\n</code></pre>"},{"location":"blind75/intervals/#252-meeting-rooms","title":"252. Meeting Rooms","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, sorting</p> </li> </ul> 252. Meeting Rooms - Python Solution<pre><code>from typing import List\n\n\n# Interval\ndef canAttendMeetings(intervals: List[List[int]]) -&gt; bool:\n    intervals.sort(key=lambda x: x[0])\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &lt; intervals[i - 1][1]:\n            return False\n\n    return True\n\n\nintervals = [[0, 30], [5, 10], [15, 20]]\nprint(canAttendMeetings(intervals))  # False\n</code></pre>"},{"location":"blind75/intervals/#253-meeting-rooms-ii","title":"253. Meeting Rooms II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy, sorting, heap priority queue, prefix sum</p> </li> </ul> 253. Meeting Rooms II - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Heap\ndef minMeetingRooms(intervals: List[List[int]]) -&gt; int:\n    if not intervals:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n    heap = [intervals[0][1]]\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &gt;= heap[0]:\n            heapq.heappop(heap)\n        heapq.heappush(heap, intervals[i][1])\n\n    return len(heap)\n\n\nintervals = [[0, 30], [5, 10], [15, 20]]\nprint(minMeetingRooms(intervals))  # 2\n</code></pre>"},{"location":"blind75/intervals/#254-factor-combinations","title":"254. Factor Combinations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: backtracking</p> </li> </ul>"},{"location":"blind75/linked_list/","title":"Linked List","text":"<ul> <li> 206. Reverse Linked List (Easy)</li> <li> 21. Merge Two Sorted Lists (Easy)</li> <li> 143. Reorder List (Medium)</li> <li> 19. Remove Nth Node From End of List (Medium)</li> <li> 141. Linked List Cycle (Easy)</li> <li> 23. Merge k Sorted Lists (Hard)</li> </ul>"},{"location":"blind75/linked_list/#206-reverse-linked-list","title":"206. Reverse Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: linked list, recursion</p> </li> <li>Reverse a singly linked list.</li> </ul> <pre><code>graph LR\nA[1] --&gt; B[2]\nB --&gt; C[3]\nC --&gt; D[4]\nD --&gt; E[5]</code></pre> <pre><code>graph RL\nE[5] --&gt; D[4]\nD --&gt; C[3]\nC --&gt; B[2]\nB --&gt; A[1]</code></pre> 206. Reverse Linked List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Iterative\ndef reverseListIterative(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    cur = head\n    prev = None\n\n    while cur:\n        temp = cur.next\n        cur.next = prev\n\n        prev = cur\n        cur = temp\n\n    return prev\n\n\n# Recursive\ndef reverseListRecursive(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    def reverse(cur, prev=None):\n        if not cur:\n            return prev\n\n        temp = cur.next\n        cur.next = prev\n\n        return reverse(temp, cur)\n\n    return reverse(head)\n\n\nnums = [1, 2, 3, 4, 5]\nhead1 = ListNode.create(nums)\nprint(head1)\n# 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(reverseListIterative(head1))\n# 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1\nhead2 = ListNode.create(nums)\nprint(reverseListRecursive(head2))\n# 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1\n</code></pre>"},{"location":"blind75/linked_list/#21-merge-two-sorted-lists","title":"21. Merge Two Sorted Lists","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: linked list, recursion</p> </li> <li>Merge the two lists into one sorted list.</li> </ul> 21. Merge Two Sorted Lists - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef mergeTwoLists(\n    list1: Optional[ListNode], list2: Optional[ListNode]\n) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    while list1 and list2:\n        if list1.val &lt; list2.val:\n            cur.next = list1\n            list1 = list1.next\n        else:\n            cur.next = list2\n            list2 = list2.next\n        cur = cur.next\n\n    if list1:\n        cur.next = list1\n    elif list2:\n        cur.next = list2\n\n    return dummy.next\n\n\nlist1 = ListNode.create([1, 2, 4])\nlist2 = ListNode.create([1, 3, 4])\nprint(mergeTwoLists(list1, list2))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4\n</code></pre>"},{"location":"blind75/linked_list/#143-reorder-list","title":"143. Reorder List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, two pointers, stack, recursion</p> </li> </ul> 143. Reorder List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef reorderList(head: Optional[ListNode]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify head in-place instead.\n    \"\"\"\n    if not head or not head.next:\n        return\n\n    # Middle of the linked list\n    slow, fast = head, head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n    # Reverse the second half\n    pre, cur = None, slow\n    while cur:\n        temp = cur.next\n        cur.next = pre\n        pre = cur\n        cur = temp\n\n    # Merge two linked lists\n    first, second = head, pre\n    while second.next:\n        temp1, temp2 = first.next, second.next\n        first.next = second\n        second.next = temp1\n        first, second = temp1, temp2\n\n\nhead = ListNode.create([1, 2, 3, 4, 5, 6])\nprint(head)  # 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6\nreorderList(head)\nprint(head)  # 1 -&gt; 6 -&gt; 2 -&gt; 5 -&gt; 3 -&gt; 4\n</code></pre>"},{"location":"blind75/linked_list/#19-remove-nth-node-from-end-of-list","title":"19. Remove Nth Node From End of List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, two pointers</p> </li> <li>Given the <code>head</code> of a linked list, remove the <code>n-th</code> node from the end of the list and return its head.</li> </ul> 19. Remove Nth Node From End of List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef removeNthFromEnd(head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:\n    dummy = ListNode(0, head)\n    fast = slow = dummy\n\n    for _ in range(n + 1):\n        fast = fast.next\n\n    while fast:\n        fast = fast.next\n        slow = slow.next\n\n    slow.next = slow.next.next\n\n    return dummy.next\n\n\nhead = [1, 2, 3, 4, 5]\nn = 2\nhead = ListNode.create(head)\nprint(head)  # 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(removeNthFromEnd(head, n))  # 1 -&gt; 2 -&gt; 3 -&gt; 5\n</code></pre>"},{"location":"blind75/linked_list/#141-linked-list-cycle","title":"141. Linked List Cycle","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, linked list, two pointers</p> </li> <li>Determine if a linked list has a cycle in it.</li> </ul> <pre><code>graph LR\nA[3] --&gt; B[2]\nB --&gt; C[0]\nC --&gt; D[-4]</code></pre> <pre><code>graph LR\nA[3] --&gt; B[2]\nB --&gt; C[0]\nC --&gt; D[-4]\nD --&gt; B</code></pre> 141. Linked List Cycle - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\ndef hasCycle(head: Optional[ListNode]) -&gt; bool:\n    slow, fast = head, head\n\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n        if slow == fast:\n            return True\n\n    return False\n\n\nprint(hasCycle(ListNode.create([3, 2, 0, -4])))  # False\nprint(hasCycle(ListNode.create([3, 2, 0, -4], 1)))  # True\n</code></pre>"},{"location":"blind75/linked_list/#23-merge-k-sorted-lists","title":"23. Merge k Sorted Lists","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: linked list, divide and conquer, heap priority queue, merge sort</p> </li> <li>Prerequisite: 21. Merge Two Sorted Lists</li> </ul> 23. Merge k Sorted Lists - Python Solution<pre><code>import copy\nimport heapq\nfrom typing import List, Optional\n\nfrom template import ListNode\n\n\n# Divide and Conquer\ndef mergeKListsDC(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    if not lists or len(lists) == 0:\n        return None\n\n    def mergeTwo(l1, l2):\n        dummy = ListNode()\n        cur = dummy\n\n        while l1 and l2:\n            if l1.val &lt; l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n\n            cur = cur.next\n\n        cur.next = l1 if l1 else l2\n\n        return dummy.next\n\n    while len(lists) &gt; 1:\n        merged = []\n\n        for i in range(0, len(lists), 2):\n            l1 = lists[i]\n            l2 = lists[i + 1] if i + 1 &lt; len(lists) else None\n            merged.append(mergeTwo(l1, l2))\n\n        lists = merged\n\n    return lists[0]\n\n\n# Heap - Merge k Sorted\ndef mergeKLists(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    minHeap = []  # (val, idx, node)\n\n    for idx, head in enumerate(lists):\n        if head:\n            heapq.heappush(minHeap, (head.val, idx, head))\n\n    while minHeap:\n        _, idx, node = heapq.heappop(minHeap)\n        cur.next = node\n        cur = cur.next\n\n        node = node.next\n        if node:\n            heapq.heappush(minHeap, (node.val, idx, node))\n\n    return dummy.next\n\n\nn1 = ListNode.create([1, 4, 5])\nn2 = ListNode.create([1, 3, 4])\nn3 = ListNode.create([2, 6])\nlists = [n1, n2, n3]\nlists1 = copy.deepcopy(lists)\nlists2 = copy.deepcopy(lists)\nprint(mergeKListsDC(lists1))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6\nprint(mergeKLists(lists2))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6\n</code></pre>"},{"location":"blind75/math_geometry/","title":"Math Geometry","text":"<ul> <li> 48. Rotate Image (Medium)</li> <li> 54. Spiral Matrix (Medium)</li> <li> 73. Set Matrix Zeroes (Medium)</li> </ul>"},{"location":"blind75/math_geometry/#48-rotate-image","title":"48. Rotate Image","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, matrix</p> </li> </ul> 48. Rotate Image - Python Solution<pre><code>from copy import deepcopy\nfrom typing import List\n\n\n# Math\ndef rotate1(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    n = len(matrix)\n\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n\n\ndef rotate2(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    n = len(matrix)\n    for i in range(n):\n        for j in range(i, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\n    for i in range(n):\n        matrix[i].reverse()\n\n\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nprint(matrix)\n# [[1, 2, 3],\n#  [4, 5, 6],\n#  [7, 8, 9]]\nmatrix1 = deepcopy(matrix)\nrotate1(matrix1)\nprint(matrix1)\n# [[7, 4, 1],\n#  [8, 5, 2],\n#  [9, 6, 3]]\nmatrix2 = deepcopy(matrix)\nrotate2(matrix2)\nprint(matrix2)\n# [[7, 4, 1],\n#  [8, 5, 2],\n#  [9, 6, 3]]\n</code></pre>"},{"location":"blind75/math_geometry/#54-spiral-matrix","title":"54. Spiral Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, matrix, simulation</p> </li> <li>Return all elements of the matrix in spiral order.</li> </ul> 54. Spiral Matrix - Python Solution<pre><code>from typing import List\n\n\n# Array\ndef spiralOrder(matrix: List[List[int]]) -&gt; List[int]:\n    if not matrix or not matrix[0]:\n        return []\n\n    result = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n\n    while top &lt;= bottom and left &lt;= right:\n\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n\n        if top &lt;= bottom:\n\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left &lt;= right:\n\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n\n    return result\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Naive    |      O(N)       |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\nprint(spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n# [1, 2, 3, 6, 9, 8, 7, 4, 5]\n</code></pre>"},{"location":"blind75/math_geometry/#73-set-matrix-zeroes","title":"73. Set Matrix Zeroes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, matrix</p> </li> </ul> 73. Set Matrix Zeroes - Python Solution<pre><code>from copy import deepcopy\nfrom typing import List\n\n\n# Math\ndef setZeroes1(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    m, n = len(matrix), len(matrix[0])\n\n    rows, cols = set(), set()\n\n    for i in range(m):\n        for j in range(n):\n            if matrix[i][j] == 0:\n                rows.add(i)\n                cols.add(j)\n\n    for i in rows:\n        for j in range(n):\n            matrix[i][j] = 0\n\n    for i in range(m):\n        for j in cols:\n            matrix[i][j] = 0\n\n\n# Math - Optimized\ndef setZeroes2(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    m, n = len(matrix), len(matrix[0])\n    row_zero, col_zero = False, False\n\n    for i in range(m):\n        if matrix[i][0] == 0:\n            col_zero = True\n            break\n\n    for j in range(n):\n        if matrix[0][j] == 0:\n            row_zero = True\n            break\n\n    for i in range(1, m):\n        for j in range(1, n):\n            if matrix[i][j] == 0:\n                matrix[i][0] = 0\n                matrix[0][j] = 0\n\n    for i in range(1, m):\n        if matrix[i][0] == 0:\n            for j in range(1, n):\n                matrix[i][j] = 0\n\n    for j in range(1, n):\n        if matrix[0][j] == 0:\n            for i in range(1, m):\n                matrix[i][j] = 0\n\n    if col_zero:\n        for i in range(m):\n            matrix[i][0] = 0\n\n    if row_zero:\n        for j in range(n):\n            matrix[0][j] = 0\n\n\nmatrix = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]\nprint(matrix)\n# [[1, 1, 1],\n#  [1, 0, 1],\n#  [1, 1, 1]]\nmatrix1 = deepcopy(matrix)\nsetZeroes1(matrix1)\nprint(matrix1)\n# [[1, 0, 1],\n#  [0, 0, 0],\n#  [1, 0, 1]]\nmatrix2 = deepcopy(matrix)\nsetZeroes2(matrix2)\nprint(matrix2)\n# [[1, 0, 1],\n#  [0, 0, 0],\n#  [1, 0, 1]]\n</code></pre>"},{"location":"blind75/sliding_window/","title":"Sliding Window","text":"<ul> <li> 121. Best Time to Buy and Sell Stock (Easy)</li> <li> 3. Longest Substring Without Repeating Characters (Medium)</li> <li> 424. Longest Repeating Character Replacement (Medium)</li> <li> 76. Minimum Window Substring (Hard)</li> </ul>"},{"location":"blind75/sliding_window/#121-best-time-to-buy-and-sell-stock","title":"121. Best Time to Buy and Sell Stock","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li>Return the maximum profit that can be achieved from buying on one day and selling on another day.</li> </ul> 121. Best Time to Buy and Sell Stock - Python Solution<pre><code>from typing import List\n\n\n# Brute Force\ndef maxProfitBF(prices: List[int]) -&gt; int:\n    max_profit = 0\n    n = len(prices)\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_profit = max(max_profit, prices[j] - prices[i])\n\n    return max_profit\n\n\n# DP\ndef maxProfitDP(prices: List[int]) -&gt; int:\n    dp = [[0] * 2 for _ in range(len(prices))]\n    dp[0][0] = -prices[0]  # buy\n    dp[0][1] = 0  # sell\n\n    for i in range(1, len(prices)):\n        dp[i][0] = max(dp[i - 1][0], -prices[i])  # the lowest price to buy\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    max_profit = 0\n    seen_min = prices[0]\n\n    for i in range(1, len(prices)):\n        max_profit = max(max_profit, prices[i] - seen_min)\n        seen_min = min(seen_min, prices[i])\n\n    return max_profit\n\n\n# Fast Slow Pointers\ndef maxProfitFS(prices: List[int]) -&gt; int:\n    max_profit = 0\n    slow, fast = 0, 1\n\n    while fast &lt; len(prices):\n        if prices[fast] &gt; prices[slow]:\n            max_profit = max(max_profit, prices[fast] - prices[slow])\n        else:\n            slow = fast\n        fast += 1\n\n    return max_profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force|  O(n^2)|  O(1)   |\n# | DP         |  O(n)  |  O(n)   |\n# | Greedy     |  O(n)  |  O(1)   |\n# | Fast Slow  |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitBF(prices))  # 5\nprint(maxProfitDP(prices))  # 5\nprint(maxProfitGreedy(prices))  # 5\nprint(maxProfitFS(prices))  # 5\n</code></pre>"},{"location":"blind75/sliding_window/#3-longest-substring-without-repeating-characters","title":"3. Longest Substring Without Repeating Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> <li>Classic sliding window problem. Use a set to keep track of the characters in the current window.</li> <li>Return the length of the longest substring without repeating characters.</li> </ul> 3. Longest Substring Without Repeating Characters - Python Solution<pre><code># Sliding Window Variable Size\ndef lengthOfLongestSubstring(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    window = set()\n    left = 0\n    res = 0\n\n    for right in range(n):\n        while s[right] in window:\n            window.remove(s[left])\n            left += 1\n        window.add(s[right])\n        res = max(res, right - left + 1)\n\n    return res\n\n\ns = \"abcabcbb\"\nassert lengthOfLongestSubstring(s) == 3\n</code></pre>"},{"location":"blind75/sliding_window/#424-longest-repeating-character-replacement","title":"424. Longest Repeating Character Replacement","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> </ul> 424. Longest Repeating Character Replacement - Python Solution<pre><code>from collections import defaultdict\n\n\n# Sliding Window - Variable\ndef characterReplacement(s: str, k: int) -&gt; int:\n    left = 0\n    maxCount = 0\n    counts = defaultdict(int)\n    maxLen = 0\n\n    for right in range(len(s)):\n        counts[s[right]] += 1\n        maxCount = max(maxCount, counts[s[right]])\n\n        while right - left + 1 - maxCount &gt; k:\n            counts[s[left]] -= 1\n            left += 1\n\n        maxLen = max(maxLen, right - left + 1)\n\n    return maxLen\n\n\ns = \"ABAB\"\nk = 2\nprint(characterReplacement(s, k))  # 4\n</code></pre>"},{"location":"blind75/sliding_window/#76-minimum-window-substring","title":"76. Minimum Window Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> </ul> 76. Minimum Window Substring - Python Solution<pre><code>from collections import Counter\n\n\ndef minWindow(s: str, t: str) -&gt; str:\n    if not t or not s:\n        return \"\"\n\n    counts = Counter(t)\n    required = len(counts)\n\n    left, right = 0, 0\n    formed = 0\n    window_counts = dict()\n\n    result = float(\"inf\"), None, None\n\n    while right &lt; len(s):\n        char = s[right]\n        window_counts[char] = window_counts.get(char, 0) + 1\n        if char in counts and window_counts[char] == counts[char]:\n            formed += 1\n\n        while left &lt;= right and formed == required:\n            char = s[left]\n            if right - left + 1 &lt; result[0]:\n                result = (right - left + 1, left, right)\n            window_counts[char] -= 1\n            if char in counts and window_counts[char] &lt; counts[char]:\n                formed -= 1\n            left += 1\n\n        right += 1\n\n    return \"\" if result[0] == float(\"inf\") else s[result[1] : result[2] + 1]\n\n\ns = \"ADOBECODEBANC\"\nt = \"ABC\"\nprint(minWindow(s, t))  # BANC\n</code></pre>"},{"location":"blind75/stack/","title":"Stack","text":"<ul> <li> 20. Valid Parentheses (Easy)</li> </ul>"},{"location":"blind75/stack/#20-valid-parentheses","title":"20. Valid Parentheses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, stack</p> </li> <li>Determine if the input string is valid.</li> <li>Steps for the string <code>()[]{}</code>:</li> </ul> char action stack <code>(</code> push \"(\" <code>)</code> pop \"\" <code>[</code> push \"[\" <code>]</code> pop \"\" <code>{</code> push \"{\" <code>}</code> pop \"\" 20. Valid Parentheses - Python Solution<pre><code># Stack\ndef isValid(s: str) -&gt; bool:\n    hashmap = {\n        \")\": \"(\",\n        \"]\": \"[\",\n        \"}\": \"{\",\n    }\n    stack = []\n\n    for c in s:\n        if c in hashmap:\n            if stack and stack[-1] == hashmap[c]:\n                stack.pop()\n            else:\n                return False\n        else:\n            stack.append(c)\n\n    return True if not stack else False\n\n\nprint(isValid(\"()\"))  # True\nprint(isValid(\"()[]{}\"))  # True\nprint(isValid(\"(]\"))  # False\n</code></pre>"},{"location":"blind75/trees/","title":"Trees","text":"<ul> <li> 226. Invert Binary Tree (Easy)</li> <li> 104. Maximum Depth of Binary Tree (Easy)</li> <li> 100. Same Tree (Easy)</li> <li> 572. Subtree of Another Tree (Easy)</li> <li> 235. Lowest Common Ancestor of a Binary Search Tree (Medium)</li> <li> 102. Binary Tree Level Order Traversal (Medium)</li> <li> 98. Validate Binary Search Tree (Medium)</li> <li> 230. Kth Smallest Element in a BST (Medium)</li> <li> 105. Construct Binary Tree from Preorder and Inorder Traversal (Medium)</li> <li> 124. Binary Tree Maximum Path Sum (Hard)</li> <li> 298. Binary Tree Longest Consecutive Sequence (Medium)</li> </ul>"},{"location":"blind75/trees/#226-invert-binary-tree","title":"226. Invert Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree</p> </li> </ul> 226. Invert Binary Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef invertTreeRecursive(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    root.left, root.right = root.right, root.left\n\n    invertTreeRecursive(root.left)\n    invertTreeRecursive(root.right)\n\n    return root\n\n\n# Iterative\ndef invertTreeIterative(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    stack = [root]\n\n    while stack:\n        node = stack.pop()\n\n        node.left, node.right = node.right, node.left\n        if node.left:\n            stack.append(node.left)\n        if node.right:\n            stack.append(node.right)\n\n    return root\n\n\nroot = build([4, 2, 7, 1, 3, 6, 9])\nprint(root)\n#     __4__\n#    /     \\\n#   2       7\n#  / \\     / \\\n# 1   3   6   9\ninvertedRecursive = invertTreeRecursive(root)\nprint(invertedRecursive)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\nroot = build([4, 2, 7, 1, 3, 6, 9])\ninvertedIterative = invertTreeIterative(root)\nprint(invertedIterative)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\n</code></pre>"},{"location":"blind75/trees/#104-maximum-depth-of-binary-tree","title":"104. Maximum Depth of Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree</p> </li> </ul> 104. Maximum Depth of Binary Tree - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef maxDepthRecursive(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    left = maxDepthRecursive(root.left)\n    right = maxDepthRecursive(root.right)\n\n    return 1 + max(left, right)\n\n\n# DFS\ndef maxDepthDFS(root: Optional[TreeNode]) -&gt; int:\n    res = 0\n\n    def dfs(node, cnt):\n        if node is None:\n            return\n        cnt += 1\n        nonlocal res\n        res = max(res, cnt)\n\n        dfs(node.left, cnt)\n        dfs(node.right, cnt)\n\n    dfs(root, 0)\n\n    return res\n\n\n# Iterative\ndef maxDepthIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n    res = 0\n\n    while q:\n        res += 1\n        n = len(q)\n\n        for _ in range(n):\n            node = q.popleft()\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return res\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n#     ____1\n#    /     \\\n#   2__     2\n#  /   \\\n# 3     4\n#      /\n#     5\nprint(maxDepthRecursive(root))  # 4\nprint(maxDepthIterative(root))  # 4\nprint(maxDepthDFS(root))  # 4\n</code></pre>"},{"location":"blind75/trees/#100-same-tree","title":"100. Same Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree</p> </li> </ul> 100. Same Tree - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# 1. Recursive\ndef isSameTreeRecursive(p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:\n    if not p and not q:\n        return True\n    if not p or not q:\n        return False\n    if p.val != q.val:\n        return False\n\n    return isSameTreeRecursive(p.left, q.left) and isSameTreeRecursive(\n        p.right, q.right\n    )\n\n\n# 2. Iterative with queue\ndef isSameTreeIterativeQueue(\n    p: Optional[TreeNode], q: Optional[TreeNode]\n) -&gt; bool:\n    queue = deque([(p, q)])\n\n    while queue:\n        p, q = queue.popleft()\n\n        if not p and not q:\n            continue\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n\n        queue.append((p.left, q.left))\n        queue.append((p.right, q.right))\n\n    return True\n\n\n# 3. Iterative with stack\ndef isSameTreeIterativeStack(\n    p: Optional[TreeNode], q: Optional[TreeNode]\n) -&gt; bool:\n    stack = [(p, q)]\n\n    while stack:\n        n1, n2 = stack.pop()\n\n        if not n1 and not n2:\n            continue\n        if not n1 or not n2:\n            return False\n        if n1.val != n2.val:\n            return False\n\n        stack.append((n1.left, n2.left))\n        stack.append((n1.right, n2.right))\n\n    return True\n\n\np1 = build([1, 2, 3])\nq1 = build([1, 2, 3])\np2 = build([1, 2])\nq2 = build([1, None, 2])\n\nprint(isSameTreeRecursive(p1, q1))  # True\nprint(isSameTreeRecursive(p2, q2))  # False\nprint(isSameTreeIterativeQueue(p1, q1))  # True\nprint(isSameTreeIterativeQueue(p2, q2))  # False\nprint(isSameTreeIterativeStack(p1, q1))  # True\nprint(isSameTreeIterativeStack(p2, q2))  # False\n</code></pre>"},{"location":"blind75/trees/#572-subtree-of-another-tree","title":"572. Subtree of Another Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, string matching, binary tree, hash function</p> </li> </ul> 572. Subtree of Another Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# DFS - Tree\ndef isSubtree(root: Optional[TreeNode], subRoot: Optional[TreeNode]) -&gt; bool:\n    def isSameTree(p, q):\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n\n        return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)\n\n    if not root:\n        return False\n\n    return (\n        isSameTree(root, subRoot)\n        or isSubtree(root.left, subRoot)\n        or isSubtree(root.right, subRoot)\n    )\n\n\n# |------------|---------|----------|\n# | Approach   | Time    | Space    |\n# |------------|---------|----------|\n# | DFS        | O(n * m)| O(n)     |\n# |------------|---------|----------|\n\n\nroot = build([3, 4, 5, 1, 2, None, None, None, None, 0])\nsubRoot = build([4, 1, 2])\nprint(root)\n#     ____3\n#    /     \\\n#   4__     5\n#  /   \\\n# 1     2\n#      /\n#     0\nprint(subRoot)\n#   4\n#  / \\\n# 1   2\nprint(isSubtree(root, subRoot))  # False\n</code></pre>"},{"location":"blind75/trees/#235-lowest-common-ancestor-of-a-binary-search-tree","title":"235. Lowest Common Ancestor of a Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree</p> </li> </ul> 235. Lowest Common Ancestor of a Binary Search Tree - Python Solution<pre><code>from binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef lowestCommonAncestor(\n    root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n) -&gt; \"TreeNode\":\n    while root:\n        if root.val &gt; p.val and root.val &gt; q.val:\n            root = root.left\n        elif root.val &lt; p.val and root.val &lt; q.val:\n            root = root.right\n        else:\n            return root\n\n\nroot = [6, 2, 8, 0, 4, 7, 9, None, None, 3, 5]\nroot = build(root)\np = root.left\nq = root.right\nprint(root)\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\nprint(lowestCommonAncestor(root, p, q))\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\n</code></pre>"},{"location":"blind75/trees/#102-binary-tree-level-order-traversal","title":"102. Binary Tree Level Order Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, breadth first search, binary tree</p> </li> </ul> 102. Binary Tree Level Order Traversal - Python Solution<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef levelOrder(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        level = []\n        n = len(q)\n\n        for _ in range(n):\n            cur = q.popleft()\n            level.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(level)\n\n    return res\n\n\ntree = build([3, 9, 20, None, None, 15, 7])\nprint(tree)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(levelOrder(tree))  # [[3], [9, 20], [15, 7]]\n</code></pre>"},{"location":"blind75/trees/#98-validate-binary-search-tree","title":"98. Validate Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree</p> </li> </ul> 98. Validate Binary Search Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef isValidBST(root: Optional[TreeNode]) -&gt; bool:\n    inorder = []  # inorder traversal of BST\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    for i in range(1, len(inorder)):\n        if inorder[i] &lt;= inorder[i - 1]:\n            return False\n\n    return True\n\n\nroot = [5, 1, 4, None, None, 3, 6]\nroot = build(root)\nprint(root)\n#   5__\n#  /   \\\n# 1     4\n#      / \\\n#     3   6\nprint(isValidBST(root))  # False\n# [1, 5, 3, 4, 6]\n</code></pre>"},{"location":"blind75/trees/#230-kth-smallest-element-in-a-bst","title":"230. Kth Smallest Element in a BST","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree</p> </li> </ul> 230. Kth Smallest Element in a BST - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BST\ndef kthSmallest(root: Optional[TreeNode], k: int) -&gt; int:\n    inorder = []\n\n    def dfs(node):\n        if not node:\n            return None\n\n        dfs(node.left)\n        nonlocal inorder\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    return inorder[k - 1]\n\n\n# |----------|------|-------|\n# | Approach | Time | Space |\n# |----------|------|-------|\n# | DFS      | O(n) | O(n)  |\n# |----------|------|-------|\n\n\nroot = build([3, 1, 4, None, 2])\nk = 1\nprint(root)\n#   __3\n#  /   \\\n# 1     4\n#  \\\n#   2\nprint(kthSmallest(root, k))  # 1\n</code></pre>"},{"location":"blind75/trees/#105-construct-binary-tree-from-preorder-and-inorder-traversal","title":"105. Construct Binary Tree from Preorder and Inorder Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, divide and conquer, tree, binary tree</p> </li> </ul> 105. Construct Binary Tree from Preorder and Inorder Traversal - Python Solution<pre><code>from typing import List, Optional\n\nfrom helper import TreeNode\n\n\ndef buildTree(preorder: List[int], inorder: List[int]) -&gt; Optional[TreeNode]:\n    \"\"\"\n    preorder  root left right  1  2  3\n    inorder   left root right  4  5  6\n    \"\"\"\n    if len(preorder) == 0:\n        return None\n\n    root_val = preorder[0]  # 1\n    root = TreeNode(root_val)\n\n    separator_idx = inorder.index(root_val)  # 5\n\n    left_inorder = inorder[:separator_idx]  # 4\n    right_inorder = inorder[separator_idx + 1 :]  # 6\n\n    left_preorder = preorder[1 : 1 + len(left_inorder)]  # 2\n    right_preorder = preorder[1 + len(left_inorder) :]  # 3\n\n    root.left = buildTree(left_preorder, left_inorder)\n    root.right = buildTree(right_preorder, right_inorder)\n\n    return root\n\n\npreorder = [3, 9, 20, 15, 7]\ninorder = [9, 3, 15, 20, 7]\nroot = buildTree(preorder, inorder)\nprint(root)\n#     3\n#    / \\\n#   9  20\n#     /  \\\n#    15   7\n</code></pre>"},{"location":"blind75/trees/#124-binary-tree-maximum-path-sum","title":"124. Binary Tree Maximum Path Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, tree, depth first search, binary tree</p> </li> </ul> 124. Binary Tree Maximum Path Sum - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef maxPathSum(root: Optional[TreeNode]) -&gt; int:\n\n    res = float(\"-inf\")\n\n    def dfs(node):\n        if not node:\n            return 0\n\n        leftMax = max(dfs(node.left), 0)\n        rightMax = max(dfs(node.right), 0)\n\n        cur = node.val + leftMax + rightMax\n        nonlocal res\n        res = max(res, cur)\n\n        return node.val + max(leftMax, rightMax)\n\n    dfs(root)\n\n    return res\n\n\nroot = build([-10, 9, 20, None, None, 15, 7])\nprint(root)\n#   -10___\n#  /      \\\n# 9       _20\n#        /   \\\n#       15    7\nprint(maxPathSum(root))  # 42\n</code></pre>"},{"location":"blind75/trees/#298-binary-tree-longest-consecutive-sequence","title":"298. Binary Tree Longest Consecutive Sequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"blind75/tries/","title":"Tries","text":"<ul> <li> 208. Implement Trie (Prefix Tree) (Medium)</li> <li> 212. Word Search II (Hard)</li> <li> 211. Design Add and Search Words Data Structure (Medium)</li> </ul>"},{"location":"blind75/tries/#208-implement-trie-prefix-tree","title":"208. Implement Trie (Prefix Tree)","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, design, trie</p> </li> </ul>"},{"location":"blind75/tries/#trie","title":"Trie","text":"<ul> <li>A trie is a tree-like data structure whose nodes store the letters of an alphabet.</li> </ul> <pre><code>flowchart TD\nRoot(( ))\nRoot --- C1((\"C\"))\nRoot --- D((D))\nC1 --- A1((\"A\"))\nA1 --- T1((\"T\"))\nA1 --- R1((\"R\"))\nA1 --- N((N))\nRoot --- B1((B))\nB1 --- A2((A))\nA2 --- T2((T))\nA2 --- R2((R))</code></pre> 208. Implement Trie (Prefix Tree) - Python Solution<pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.endOfWord = None\n\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.endOfWord = True\n\n    def search(self, word: str) -&gt; bool:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return node.endOfWord\n\n    def startsWith(self, prefix: str) -&gt; bool:\n        node = self.root\n\n        for c in prefix:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return True\n\n\n# Your Trie object will be instantiated and called as such:\nobj = Trie()\nobj.insert(\"apple\")\nprint(obj.search(\"word\"))  # False\nprint(obj.startsWith(\"app\"))  # True\n</code></pre>"},{"location":"blind75/tries/#212-word-search-ii","title":"212. Word Search II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, backtracking, trie, matrix</p> </li> </ul> 212. Word Search II - Python Solution<pre><code>from typing import List\n\nfrom template import TrieNode\n\n\n# Backtracking + Trie\ndef findWords(board: List[List[str]], words: List[str]) -&gt; List[str]:\n    root = TrieNode()\n    for word in words:\n        root.addWord(word)\n\n    m, n = len(board), len(board[0])\n    result, visit = set(), set()\n\n    def dfs(r, c, node, word):\n        if (\n            r &lt; 0\n            or r &gt;= m\n            or c &lt; 0\n            or c &gt;= n\n            or (r, c) in visit\n            or board[r][c] not in node.children\n        ):\n            return None\n\n        visit.add((r, c))\n\n        node = node.children[board[r][c]]\n        word += board[r][c]\n        if node.isWord:\n            result.add(word)\n\n        dfs(r - 1, c, node, word)\n        dfs(r + 1, c, node, word)\n        dfs(r, c - 1, node, word)\n        dfs(r, c + 1, node, word)\n\n        visit.remove((r, c))\n\n    for r in range(m):\n        for c in range(n):\n            dfs(r, c, root, \"\")\n\n    return list(result)\n\n\nboard = [\n    [\"o\", \"a\", \"a\", \"n\"],\n    [\"e\", \"t\", \"a\", \"e\"],\n    [\"i\", \"h\", \"k\", \"r\"],\n    [\"i\", \"f\", \"l\", \"v\"],\n]\nwords = [\"oath\", \"pea\", \"eat\", \"rain\"]\nprint(findWords(board, words))\n# ['eat', 'oath']\n</code></pre>"},{"location":"blind75/tries/#211-design-add-and-search-words-data-structure","title":"211. Design Add and Search Words Data Structure","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, depth first search, design, trie</p> </li> </ul> 211. Design Add and Search Words Data Structure - Python Solution<pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.word = False\n\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.word = True\n\n    def search(self, word: str) -&gt; bool:\n\n        def dfs(j, root):\n            node = root\n\n            for i in range(j, len(word)):\n                c = word[i]\n\n                if c == \".\":\n                    for child in node.children.values():\n                        if dfs(i + 1, child):\n                            return True\n                    return False\n                else:\n                    if c not in node.children:\n                        return False\n                    node = node.children[c]\n            return node.word\n\n        return dfs(0, self.root)\n\n\n# Your WordDictionary object will be instantiated and called as such:\nobj = WordDictionary()\nobj.addWord(\"word\")\nprint(obj.search(\"word\"))\nprint(obj.search(\"w.rd\"))\n</code></pre>"},{"location":"blind75/two_pointers/","title":"Two Pointers","text":"<ul> <li> 125. Valid Palindrome (Easy)</li> <li> 15. 3Sum (Medium)</li> <li> 11. Container With Most Water (Medium)</li> </ul>"},{"location":"blind75/two_pointers/#125-valid-palindrome","title":"125. Valid Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string</p> </li> </ul> 125. Valid Palindrome - Python Solution<pre><code># List Comprehension\ndef isPalindrome(s: str) -&gt; bool:\n    s = [char.lower() for char in s if char.isalnum()]\n    return s == s[::-1]\n\n\n# Left Right Pointers\ndef isPalindromeLR(s: str) -&gt; bool:\n    left, right = 0, len(s) - 1\n\n    while left &lt; right:\n        while left &lt; right and not s[left].isalnum():\n            left += 1\n        while left &lt; right and not s[right].isalnum():\n            right -= 1\n\n        if s[left].lower() != s[right].lower():\n            return False\n\n        left += 1\n        right -= 1\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\ns = \"A man, a plan, a canal: Panama\"\nprint(isPalindrome(s))  # True\nprint(isPalindromeLR(s))  # True\n</code></pre>"},{"location":"blind75/two_pointers/#15-3sum","title":"15. 3Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, sorting</p> </li> </ul> 15. 3Sum - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef threeSum(nums: List[int]) -&gt; List[List[int]]:\n    nums.sort()\n    res = []\n    n = len(nums)\n\n    for i in range(n - 2):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        left, right = i + 1, n - 1\n\n        while left &lt; right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total &gt; 0:\n                right -= 1\n            elif total &lt; 0:\n                left += 1\n            else:\n                res.append([nums[i], nums[left], nums[right]])\n\n                while left &lt; right and nums[left] == nums[left + 1]:\n                    left += 1\n\n                while left &lt; right and nums[right] == nums[right - 1]:\n                    right -= 1\n\n                left += 1\n                right -= 1\n\n    return res\n\n\nnums = [-1, 0, 1, 2, -1, -4]\nassert threeSum(nums) == [[-1, -1, 2], [-1, 0, 1]]\n</code></pre>"},{"location":"blind75/two_pointers/#11-container-with-most-water","title":"11. Container With Most Water","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy</p> </li> <li>Return the maximum area of water that can be trapped between the vertical lines.</li> </ul> <p></p> 11. Container With Most Water - Python Solution<pre><code>from typing import List\n\n\n# Brute Force\ndef maxAreaBF(height: List[int]) -&gt; int:\n    max_area = 0\n\n    for i in range(len(height)):\n        for j in range(i + 1, len(height)):\n            h = min(height[i], height[j])\n            w = j - i\n            max_area = max(max_area, h * w)\n\n    return max_area\n\n\n# Left Right Pointers\ndef maxAreaLR(height: List[int]) -&gt; int:\n    left, right = 0, len(height) - 1\n    res = 0\n\n    while left &lt; right:\n        h = min(height[left], height[right])\n        w = right - left\n        res = max(res, h * w)\n\n        if height[left] &lt; height[right]:\n            left += 1\n        else:\n            right -= 1\n\n    return res\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force| O(n^2) |  O(1)   |\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nheight = [1, 8, 6, 2, 5, 4, 8, 3, 7]\nprint(maxAreaBF(height))  # 49\nprint(maxAreaLR(height))  # 49\n</code></pre>"},{"location":"company/","title":"Company Wise","text":"<ul> <li> <p>liquidslr/leetcode-company-wise-problems</p> </li> <li> <p>Amazon</p> <ul> <li> 1. Two Sum</li> <li> 146. LRU Cache</li> <li> 200. Number of Islands</li> <li> 42. Trapping Rain Water</li> <li> 49. Group Anagrams</li> <li> 121. Best Time to Buy and Sell Stock</li> <li> 56. Merge Intervals</li> <li> 207. Course Schedule</li> <li> 23. Merge k Sorted Lists</li> <li> 347. Top K Frequent Elements</li> <li> 88. Merge Sorted Array</li> <li> 15. 3Sum</li> <li> 127. Word Ladder</li> <li> 55. Jump Game</li> <li> 210. Course Schedule II</li> <li> 138. Copy List with Random Pointer</li> <li> 20. Valid Parentheses</li> <li> 2. Add Two Numbers</li> <li> 70. Climbing Stairs</li> <li> 238. Product of Array Except Self</li> <li> 560. Subarray Sum Equals K</li> <li> 4. Median of Two Sorted Arrays</li> <li> 79. Word Search</li> <li> 22. Generate Parentheses</li> <li> 215. Kth Largest Element in an Array</li> <li> 295. Find Median from Data Stream</li> <li> 5. Longest Palindromic Substring</li> <li> 33. Search in Rotated Sorted Array</li> </ul> </li> </ul>"},{"location":"company/amazon/","title":"Amazon","text":""},{"location":"company/amazon/#1-two-sum","title":"1. Two Sum","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, hash table</li> <li>Return the indices of the two numbers such that they add up to a specific target.</li> </ul> Approach Time Complexity Space Complexity Hashmap O(n) O(n) <pre><code>from typing import List\n\n\n# Hashmap\ndef twoSum(nums: List[int], target: int) -&gt; List[int]:\n    hashmap = {}  # val: idx\n\n    for idx, val in enumerate(nums):\n        if (target - val) in hashmap:\n            return [hashmap[target - val], idx]\n\n        hashmap[val] = idx\n\n\nnums = [2, 7, 11, 15]\ntarget = 18\nassert twoSum(nums, target) == [1, 2]\n</code></pre>"},{"location":"company/amazon/#146-lru-cache","title":"146. LRU Cache","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, linked list, design, doubly linked list</li> <li>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.</li> </ul> Data structure Description Doubly Linked List To store the key-value pairs. Hash Map To store the key-node pairs. Approach Time Complexity Space Complexity LRU O(1) O(n) <pre><code>from collections import OrderedDict\n\n\n# Doubly Linked List\nclass Node:\n    def __init__(self, key=0, val=0):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.cache = {}\n        self.head = Node()\n        self.tail = Node()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def add_to_last(self, node):\n        self.tail.prev.next = node\n        node.prev = self.tail.prev\n        node.next = self.tail\n        self.tail.prev = node\n\n    def move_to_last(self, node):\n        self.remove(node)\n        self.add_to_last(node)\n\n    def get(self, key: int) -&gt; int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self.move_to_last(node)\n        return node.val\n\n    def put(self, key: int, value: int) -&gt; None:\n        if key in self.cache:\n            node = self.cache[key]\n            node.val = value\n            self.move_to_last(node)\n            return None\n\n        if len(self.cache) == self.cap:\n            del self.cache[self.head.next.key]\n            self.remove(self.head.next)\n\n        node = Node(key=key, val=value)\n        self.cache[key] = node\n        self.add_to_last(node)\n\n\n# OrderedDict\nclass LRUCacheOrderedDict:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.cap = capacity\n\n    def get(self, key: int):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key, last=True)\n        return self.cache[key]\n\n    def put(self, key: int, value: int):\n        if key in self.cache:\n            self.cache.move_to_end(key, last=True)\n        elif len(self.cache) &gt;= self.cap:\n            self.cache.popitem(last=False)\n\n        self.cache[key] = value\n\n\ncache = LRUCache(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\n\ncache = LRUCacheOrderedDict(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\nprint(\"LRU Cache passed\")\nprint(\"LRU Cache Ordered Dict passed\")\n</code></pre>"},{"location":"company/amazon/#200-number-of-islands","title":"200. Number of Islands","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, depth first search, breadth first search, union find, matrix</li> <li>Count the number of islands in a 2D grid.</li> <li>Method 1: DFS</li> <li> <p>Method 2: BFS (use a queue to traverse the grid)</p> </li> <li> <p>How to keep track of visited cells?</p> <ol> <li>Mark the visited cell as <code>0</code> (or any other value) to avoid revisiting it.</li> <li>Use a set to store the visited cells.</li> </ol> </li> <li> <p>Steps:</p> <ol> <li>Init: variables</li> <li>DFS/BFS: starting from the cell with <code>1</code>, turn all the connected <code>1</code>s to <code>0</code>.</li> <li>Traverse the grid, and if the cell is <code>1</code>, increment the count and call DFS/BFS.</li> </ol> </li> </ul> <p></p> <pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef numIslandsDFS(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    res = 0\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] != \"1\":\n            return\n\n        grid[r][c] = \"2\"\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                dfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Set\ndef numIslandsBFS1(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == \"0\"\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\" and (r, c) not in visited:\n                visited.add((r, c))\n                bfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = dr + row, dc + col\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] != \"1\"\n                ):\n                    continue\n                grid[nr][nc] = \"2\"\n                q.append((nr, nc))\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == \"1\":\n                grid[i][j] = \"2\"\n                bfs(i, j)\n                res += 1\n\n    return res\n\n\ngrid = [\n    [\"1\", \"1\", \"1\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"0\", \"0\", \"0\", \"0\", \"0\"],\n]\n\nprint(numIslandsDFS(deepcopy(grid)))  # 1\nprint(numIslandsBFS1(deepcopy(grid)))  # 1\nprint(numIslandsBFS2(deepcopy(grid)))  # 1\n</code></pre>"},{"location":"company/amazon/#42-trapping-rain-water","title":"42. Trapping Rain Water","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, two pointers, dynamic programming, stack, monotonic stack</li> <li></li> </ul> Approach Time Space DP O(N) O(N) Left Right O(N) O(1) Monotonic O(N) O(N) <pre><code>from typing import List\n\n\n# DP\ndef trapDP(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    n = len(height)\n    maxLeft, maxRight = [0 for _ in range(n)], [0 for _ in range(n)]\n\n    for i in range(1, n):\n        maxLeft[i] = max(maxLeft[i - 1], height[i - 1])\n\n    for i in range(n - 2, -1, -1):\n        maxRight[i] = max(maxRight[i + 1], height[i + 1])\n\n    res = 0\n    for i in range(n):\n        res += max(0, min(maxLeft[i], maxRight[i]) - height[i])\n\n    return res\n\n\n# Left Right Pointers\ndef trapLR(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    left, right = 0, len(height) - 1\n    maxL, maxR = height[left], height[right]\n    res = 0\n\n    while left &lt; right:\n        if maxL &lt; maxR:\n            left += 1\n            maxL = max(maxL, height[left])\n            res += maxL - height[left]\n        else:\n            right -= 1\n            maxR = max(maxR, height[right])\n            res += maxR - height[right]\n\n    return res\n\n\n# Monotonic Stack\ndef trapStack(height: List[int]) -&gt; int:\n    stack = []\n    total = 0\n\n    for i in range(len(height)):\n        while stack and height[i] &gt; height[stack[-1]]:\n            top = stack.pop()\n            if not stack:\n                break\n            distance = i - stack[-1] - 1\n            bounded_height = min(height[i], height[stack[-1]]) - height[top]\n            total += distance * bounded_height\n        stack.append(i)\n\n    return total\n\n\nheight = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\nprint(trapDP(height))  # 6\nprint(trapLR(height))  # 6\nprint(trapStack(height))  # 6\n</code></pre>"},{"location":"company/amazon/#49-group-anagrams","title":"49. Group Anagrams","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, string, sorting</li> </ul> <pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash - List\ndef groupAnagrams(strs: List[str]) -&gt; List[List[str]]:\n    result = defaultdict(list)\n\n    for s in strs:\n        count = [0] * 26\n        for i in s:\n            count[ord(i) - ord(\"a\")] += 1\n\n        result[tuple(count)].append(s)\n\n    return list(result.values())\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Hash     |     O(n * k)    |     O(n)     |\n# |-------------|-----------------|--------------|\n\n\nstrs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\nprint(groupAnagrams(strs))\n# [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n</code></pre>"},{"location":"company/amazon/#121-best-time-to-buy-and-sell-stock","title":"121. Best Time to Buy and Sell Stock","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, dynamic programming</li> <li>Return the maximum profit that can be achieved from buying on one day and selling on another day.</li> </ul> <pre><code>from typing import List\n\n\n# Brute Force\ndef maxProfitBF(prices: List[int]) -&gt; int:\n    max_profit = 0\n    n = len(prices)\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_profit = max(max_profit, prices[j] - prices[i])\n\n    return max_profit\n\n\n# DP\ndef maxProfitDP(prices: List[int]) -&gt; int:\n    dp = [[0] * 2 for _ in range(len(prices))]\n    dp[0][0] = -prices[0]  # buy\n    dp[0][1] = 0  # sell\n\n    for i in range(1, len(prices)):\n        dp[i][0] = max(dp[i - 1][0], -prices[i])  # the lowest price to buy\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    max_profit = 0\n    seen_min = prices[0]\n\n    for i in range(1, len(prices)):\n        max_profit = max(max_profit, prices[i] - seen_min)\n        seen_min = min(seen_min, prices[i])\n\n    return max_profit\n\n\n# Fast Slow Pointers\ndef maxProfitFS(prices: List[int]) -&gt; int:\n    max_profit = 0\n    slow, fast = 0, 1\n\n    while fast &lt; len(prices):\n        if prices[fast] &gt; prices[slow]:\n            max_profit = max(max_profit, prices[fast] - prices[slow])\n        else:\n            slow = fast\n        fast += 1\n\n    return max_profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force|  O(n^2)|  O(1)   |\n# | DP         |  O(n)  |  O(n)   |\n# | Greedy     |  O(n)  |  O(1)   |\n# | Fast Slow  |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitBF(prices))  # 5\nprint(maxProfitDP(prices))  # 5\nprint(maxProfitGreedy(prices))  # 5\nprint(maxProfitFS(prices))  # 5\n</code></pre>"},{"location":"company/amazon/#56-merge-intervals","title":"56. Merge Intervals","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, sorting</li> <li>Merge all overlapping intervals.</li> </ul> <pre><code>from typing import List\n\n\n# Intervals\ndef merge(intervals: List[List[int]]) -&gt; List[List[int]]:\n    n = len(intervals)\n    if n &lt;= 1:\n        return intervals\n\n    intervals.sort(key=lambda x: x[0])\n    res = [intervals[0]]\n\n    for i in range(1, n):\n        if intervals[i][0] &lt;= res[-1][1]:\n            res[-1][1] = max(res[-1][1], intervals[i][1])\n        else:\n            res.append(intervals[i])\n\n    return res\n\n\nprint(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))\n# [[1, 6], [8, 10], [15, 18]]\n</code></pre>"},{"location":"company/amazon/#207-course-schedule","title":"207. Course Schedule","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: depth first search, breadth first search, graph, topological sort</li> <li>Return true if it is possible to finish all courses, otherwise return false.</li> <li>Dependency relationships imply the topological sort algorithm.</li> <li>Cycle detection</li> <li>Topological Sort<ul> <li>DAG (Directed Acyclic Graph)</li> <li>Time complexity: O(V+E)</li> <li>Space complexity: O(V+E)</li> <li>Prerequisites: Indegree (Look at the problem 1557. Minimum Number of Vertices to Reach All Nodes)<ul> <li>Indegree: Number of incoming edges to a vertex</li> </ul> </li> <li>Applications: task scheduling, course scheduling, build systems, dependency resolution, compiler optimization, etc.</li> </ul> </li> </ul> <p>Course to prerequisites mapping</p> <pre><code>flowchart LR\n    0((0)) --&gt; 1((1))\n    0((0)) --&gt; 2((2))\n    1((1)) --&gt; 3((3))\n    3((3)) --&gt; 4((4))\n    1((1)) --&gt; 4((4))</code></pre> <p>Prerequisites to course mapping</p> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    2((2)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))\n    4((4)) --&gt; 3((3))\n    4((4)) --&gt; 1((1))</code></pre> course 0 0 1 1 3 prerequisite 1 2 3 4 4 index 0 1 2 3 4 in-degree 0 0 0 0 0 <p>Initialize</p> <ul> <li>graph</li> </ul> prerequisite 1 2 3 4 course <code>[0]</code> <code>[0]</code> <code>[1]</code> <code>[1, 3]</code> <ul> <li>in-degree</li> </ul> 0 1 2 3 4 in-degree 2 2 0 1 0 <ul> <li>queue: <code>[2, 4]</code></li> <li>pop <code>2</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))\n    4((4)) --&gt; 3((3))\n    4((4)) --&gt; 1((1))</code></pre> 0 1 2 3 4 in-degree 1 2 0 1 0 <ul> <li>queue: <code>[4]</code></li> <li>pop <code>4</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))</code></pre> 0 1 2 3 4 in-degree 1 1 0 0 0 <ul> <li>queue: <code>[3]</code></li> <li>pop <code>3</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))</code></pre> 0 1 2 3 4 in-degree 1 0 0 0 0 <ul> <li>queue: <code>[1]</code></li> <li>pop <code>1</code> from the queue</li> </ul> <pre><code>flowchart LR\n    0((0))</code></pre> 0 1 2 3 4 in-degree 0 0 0 0 0 <ul> <li>queue: <code>[0]</code></li> <li>pop <code>0</code> from the queue</li> <li>All courses are taken. Return <code>True</code>.</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS (Kahn's Algorithm)\ndef canFinishBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    count = 0\n\n    while q:\n        crs = q.popleft()\n        count += 1\n\n        for nxt in graph[crs]:\n            indegree[nxt] -= 1\n\n            if indegree[nxt] == 0:\n                q.append(nxt)\n\n    return count == numCourses\n\n\n# DFS + Set\ndef canFinishDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for crs, pre in prerequisites:\n        graph[crs].append(pre)\n\n    visiting = set()\n\n    def dfs(crs):\n        if crs in visiting:  # cycle detected\n            return False\n        if graph[crs] == []:\n            return True\n\n        visiting.add(crs)\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        visiting.remove(crs)\n        graph[crs] = []\n\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\n# DFS + List\ndef canFinishDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for pre, crs in prerequisites:\n        graph[crs].append(pre)\n\n    # 0: init, 1: visiting, 2: visited\n    status = [0] * numCourses\n\n    def dfs(crs):\n        if status[crs] == 1:  # cycle detected\n            return False\n        if status[crs] == 2:\n            return True\n\n        status[crs] = 1\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        status[crs] = 2\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(canFinishBFS(5, prerequisites))  # True\nprint(canFinishDFS1(5, prerequisites))  # True\nprint(canFinishDFS2(5, prerequisites))  # True\n</code></pre>"},{"location":"company/amazon/#23-merge-k-sorted-lists","title":"23. Merge k Sorted Lists","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: linked list, divide and conquer, heap priority queue, merge sort</li> <li>Prerequisite: 21. Merge Two Sorted Lists</li> </ul> <pre><code>import copy\nimport heapq\nfrom typing import List, Optional\n\nfrom template import ListNode\n\n\n# Divide and Conquer\ndef mergeKListsDC(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    if not lists or len(lists) == 0:\n        return None\n\n    def mergeTwo(l1, l2):\n        dummy = ListNode()\n        cur = dummy\n\n        while l1 and l2:\n            if l1.val &lt; l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n\n            cur = cur.next\n\n        cur.next = l1 if l1 else l2\n\n        return dummy.next\n\n    while len(lists) &gt; 1:\n        merged = []\n\n        for i in range(0, len(lists), 2):\n            l1 = lists[i]\n            l2 = lists[i + 1] if i + 1 &lt; len(lists) else None\n            merged.append(mergeTwo(l1, l2))\n\n        lists = merged\n\n    return lists[0]\n\n\n# Heap - Merge k Sorted\ndef mergeKLists(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    minHeap = []  # (val, idx, node)\n\n    for idx, head in enumerate(lists):\n        if head:\n            heapq.heappush(minHeap, (head.val, idx, head))\n\n    while minHeap:\n        _, idx, node = heapq.heappop(minHeap)\n        cur.next = node\n        cur = cur.next\n\n        node = node.next\n        if node:\n            heapq.heappush(minHeap, (node.val, idx, node))\n\n    return dummy.next\n\n\nn1 = ListNode.create([1, 4, 5])\nn2 = ListNode.create([1, 3, 4])\nn3 = ListNode.create([2, 6])\nlists = [n1, n2, n3]\nlists1 = copy.deepcopy(lists)\nlists2 = copy.deepcopy(lists)\nprint(mergeKListsDC(lists1))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6\nprint(mergeKLists(lists2))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6\n</code></pre>"},{"location":"company/amazon/#347-top-k-frequent-elements","title":"347. Top K Frequent Elements","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, divide and conquer, sorting, heap priority queue, bucket sort, counting, quickselect</li> </ul> <pre><code>import heapq\nfrom collections import Counter\nfrom typing import List\n\n\n# Heap + Counter\ndef topKFrequent(nums: List[int], k: int) -&gt; List[int]:\n    minHeap = []\n\n    for val, freq in Counter(nums).items():\n        if len(minHeap) &lt; k:\n            heapq.heappush(minHeap, (freq, val))\n        else:\n            heapq.heappushpop(minHeap, (freq, val))\n\n    return [i for _, i in minHeap]\n\n\n# Counter (Most Common)\ndef topKFrequentCounter(nums: List[int], k: int) -&gt; List[int]:\n    commons = Counter(nums).most_common(k)\n    return [i for i, _ in commons]\n\n\nnums = [1, 1, 1, 2, 2, 3]\nk = 2\nprint(topKFrequent(nums, k))  # [1, 2]\nprint(topKFrequentCounter(nums, k))  # [1, 2]\n</code></pre>"},{"location":"company/amazon/#88-merge-sorted-array","title":"88. Merge Sorted Array","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, two pointers, sorting</li> </ul> <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef merge(nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None:\n    \"\"\"Merges two sorted arrays in-place.\"\"\"\n    p1, p2, t = m - 1, n - 1, m + n - 1\n\n    while p1 &gt;= 0 or p2 &gt;= 0:\n        if p1 == -1:\n            nums1[t] = nums2[p2]\n            p2 -= 1\n        elif p2 == -1:\n            nums1[t] = nums1[p1]\n            p1 -= 1\n        elif nums1[p1] &gt; nums2[p2]:\n            nums1[t] = nums1[p1]\n            p1 -= 1\n        else:\n            nums1[t] = nums2[p2]\n            p2 -= 1\n\n        t -= 1\n\n\nnums1 = [1, 2, 3, 0, 0, 0]\nm = 3\nnums2 = [2, 5, 6]\nn = 3\nmerge(nums1, m, nums2, n)\nprint(nums1)  # [1, 2, 2, 3, 5, 6]\n</code></pre>"},{"location":"company/amazon/#15-3sum","title":"15. 3Sum","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, two pointers, sorting</li> </ul> <pre><code>from typing import List\n\n\n# Left Right Pointers\ndef threeSum(nums: List[int]) -&gt; List[List[int]]:\n    nums.sort()\n    res = []\n    n = len(nums)\n\n    for i in range(n - 2):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        left, right = i + 1, n - 1\n\n        while left &lt; right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total &gt; 0:\n                right -= 1\n            elif total &lt; 0:\n                left += 1\n            else:\n                res.append([nums[i], nums[left], nums[right]])\n\n                while left &lt; right and nums[left] == nums[left + 1]:\n                    left += 1\n\n                while left &lt; right and nums[right] == nums[right - 1]:\n                    right -= 1\n\n                left += 1\n                right -= 1\n\n    return res\n\n\nnums = [-1, 0, 1, 2, -1, -4]\nassert threeSum(nums) == [[-1, -1, 2], [-1, 0, 1]]\n</code></pre>"},{"location":"company/amazon/#127-word-ladder","title":"127. Word Ladder","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: hash table, string, breadth first search</li> <li>The most classic BFS problem.</li> <li>Return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.</li> </ul> Approach Time Space BFS O(n * m^2) O(n * m) <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef ladderLength(beginWord: str, endWord: str, wordList: List[str]) -&gt; int:\n    if endWord not in wordList:\n        return 0\n\n    n = len(beginWord)\n    graph = defaultdict(list)  # pattern: words\n    wordList.append(beginWord)\n\n    for word in wordList:\n        for i in range(n):\n            pattern = word[:i] + \"*\" + word[i + 1 :]\n            graph[pattern].append(word)\n\n    visited = set([beginWord])\n    q = deque([beginWord])\n    res = 1\n\n    while q:\n        size = len(q)\n        for _ in range(size):\n            word = q.popleft()\n            if word == endWord:\n                return res\n\n            for i in range(n):\n                pattern = word[:i] + \"*\" + word[i + 1 :]\n                for neighbor in graph[pattern]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        q.append(neighbor)\n        res += 1\n\n    return 0\n\n\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]\nprint(ladderLength(beginWord, endWord, wordList))  # 5\n</code></pre>"},{"location":"company/amazon/#55-jump-game","title":"55. Jump Game","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, dynamic programming, greedy</li> <li>Return <code>True</code> if you can reach the last index, otherwise <code>False</code>.</li> </ul> <ul> <li>Example: <code>[2, 3, 1, 1, 4, 1, 2, 0, 0]</code></li> </ul> Index Value Index + Value Max Reach Max Reach &gt;= Last Index 0 2 2 2 False 1 3 4 4 False 2 1 3 4 False 3 1 4 4 False 4 4 8 8 True 5 1 6 8 True 6 2 8 8 True 7 0 7 8 True 8 0 8 8 True <pre><code>from typing import List\n\n\n# Greedy - Interval\ndef canJump(nums: List[int]) -&gt; bool:\n    maxReach = 0\n    i = 0\n    n = len(nums)\n\n    while i &lt;= maxReach:\n        maxReach = max(maxReach, i + nums[i])\n        if maxReach &gt;= n - 1:\n            return True\n        i += 1\n\n    return False\n\n\nprint(canJump([2, 3, 1, 1, 4, 1, 2, 0, 0]))  # True\n</code></pre>"},{"location":"company/amazon/#3-longest-substring-without-repeating-characters","title":"3. Longest Substring Without Repeating Characters","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, string, sliding window</li> <li>Classic sliding window problem. Use a set to keep track of the characters in the current window.</li> <li>Return the length of the longest substring without repeating characters.</li> </ul> <pre><code># Sliding Window Variable Size\ndef lengthOfLongestSubstring(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    window = set()\n    left = 0\n    res = 0\n\n    for right in range(n):\n        while s[right] in window:\n            window.remove(s[left])\n            left += 1\n        window.add(s[right])\n        res = max(res, right - left + 1)\n\n    return res\n\n\ns = \"abcabcbb\"\nassert lengthOfLongestSubstring(s) == 3\n</code></pre>"},{"location":"company/amazon/#14-longest-common-prefix","title":"14. Longest Common Prefix","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: string, trie</li> </ul> <pre><code>from typing import List\n\n\n# Horizontal Scanning\ndef longestCommonPrefixHorizontal(strs: List[str]) -&gt; str:\n    if not strs:\n        return \"\"\n\n    prefix = strs[0]\n    for i in range(1, len(strs)):\n        while not strs[i].startswith(prefix):\n            prefix = prefix[:-1]\n            if not prefix:\n                return \"\"\n\n    return prefix\n\n\n# Vertical Scanning\ndef longestCommonPrefixVertical(strs: List[str]) -&gt; str:\n    if not strs:\n        return \"\"\n\n    for i in range(len(strs[0])):\n        char = strs[0][i]\n        for j in range(1, len(strs)):\n            if i &gt;= len(strs[j]) or strs[j][i] != char:\n                return strs[0][:i]\n\n    return strs[0]\n\n\n# Divide and Conquer\ndef longestCommonPrefixDivideConquer(strs: List[str]) -&gt; str:\n    if not strs:\n        return \"\"\n\n    def merge(left, right):\n        n = min(len(left), len(right))\n        for i in range(n):\n            if left[i] != right[i]:\n                return left[:i]\n        return left[:n]\n\n    def helper(strs, start, end):\n        if start == end:\n            return strs[start]\n        mid = start + (end - start) // 2\n        left = helper(strs, start, mid)\n        right = helper(strs, mid + 1, end)\n        return merge(left, right)\n\n    return helper(strs, 0, len(strs) - 1)\n\n\n# Binary Search\ndef longestCommonPrefixBinarySearch(strs: List[str]) -&gt; str:\n    if not strs:\n        return \"\"\n\n    def isCommonPrefix(strs, length):\n        prefix = strs[0][:length]\n        return all(s.startswith(prefix) for s in strs)\n\n    minLen = min(len(s) for s in strs)\n    low, high = 0, minLen\n    while low &lt; high:\n        mid = low + (high - low) // 2\n        if isCommonPrefix(strs, mid + 1):\n            low = mid + 1\n        else:\n            high = mid\n\n    return strs[0][:low]\n\n\nstrs = [\"flower\", \"flow\", \"flight\"]\nprint(longestCommonPrefixHorizontal(strs))  # \"fl\"\nprint(longestCommonPrefixVertical(strs))  # \"fl\"\nprint(longestCommonPrefixDivideConquer(strs))  # \"fl\"\nprint(longestCommonPrefixBinarySearch(strs))  # \"fl\"\n</code></pre>"},{"location":"company/amazon/#210-course-schedule-ii","title":"210. Course Schedule II","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: depth first search, breadth first search, graph, topological sort</li> <li>Return the ordering of courses you should take to finish all courses. If there are multiple valid answers, return any of them.</li> </ul> <pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# 1. BFS - Kahn's Algorithm\ndef findOrderBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    order = []\n\n    while q:\n        pre = q.popleft()\n        order.append(pre)\n\n        for crs in graph[pre]:\n            indegree[crs] -= 1\n            if indegree[crs] == 0:\n                q.append(crs)\n\n    return order if len(order) == numCourses else []\n\n\n# 2. DFS + Set\ndef findOrderDFS1(\n    numCourses: int, prerequisites: List[List[int]]\n) -&gt; List[int]:\n    adj = defaultdict(list)\n    for crs, pre in prerequisites:\n        adj[crs].append(pre)\n\n    visit, cycle = set(), set()\n    order = []\n\n    def dfs(crs):\n        if crs in cycle:\n            return False\n        if crs in visit:\n            return True\n\n        cycle.add(crs)\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        cycle.remove(crs)\n        visit.add(crs)\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order\n\n\n# 3. DFS + List\ndef findOrderDFS2(\n    numCourses: int, prerequisites: List[List[int]]\n) -&gt; List[int]:\n    adj = defaultdict(list)\n    for pre, crs in prerequisites:\n        adj[crs].append(pre)\n\n    # 0: not visited, 1: visiting, 2: visited\n    state = [0] * numCourses\n    order = []\n\n    def dfs(crs):\n        if state[crs] == 1:\n            return False\n        if state[crs] == 2:\n            return True\n\n        state[crs] = 1\n\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        state[crs] = 2\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order[::-1]\n\n\nnumCourses = 5\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(findOrderBFS(numCourses, prerequisites))  # [2, 4, 3, 1, 0]\nprint(findOrderDFS1(numCourses, prerequisites))  # [4, 3, 1, 2, 0]\nprint(findOrderDFS2(numCourses, prerequisites))  # [4, 3, 2, 1, 0]\n</code></pre>"},{"location":"company/amazon/#138-copy-list-with-random-pointer","title":"138. Copy List with Random Pointer","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: hash table, linked list</li> </ul> <pre><code>from typing import Optional\n\n\nclass Node:\n    def __init__(self, x: int, next: \"Node\" = None, random: \"Node\" = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\n\ndef copyRandomList(head: \"Optional[Node]\") -&gt; \"Optional[Node]\":\n    if not head:\n        return None\n\n    # Copy nodes and link them together\n    cur = head\n    while cur:\n        new_node = Node(cur.val)\n        new_node.next = cur.next\n        cur.next = new_node\n        cur = new_node.next\n\n    # Copy random pointers\n    cur = head\n    while cur:\n        cur.next.random = cur.random.next if cur.random else None\n        cur = cur.next.next\n\n    # Separate the original and copied lists\n    cur = head\n    new_head = head.next\n    while cur:\n        new_node = cur.next\n        cur.next = new_node.next\n        new_node.next = new_node.next.next if new_node.next else None\n        cur = cur.next\n\n    return new_head\n</code></pre>"},{"location":"company/amazon/#20-valid-parentheses","title":"20. Valid Parentheses","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: string, stack</li> <li>Determine if the input string is valid.</li> <li>Steps for the string <code>()[]{}</code>:</li> </ul> char action stack <code>(</code> push \"(\" <code>)</code> pop \"\" <code>[</code> push \"[\" <code>]</code> pop \"\" <code>{</code> push \"{\" <code>}</code> pop \"\" <pre><code># Stack\ndef isValid(s: str) -&gt; bool:\n    hashmap = {\n        \")\": \"(\",\n        \"]\": \"[\",\n        \"}\": \"{\",\n    }\n    stack = []\n\n    for c in s:\n        if c in hashmap:\n            if stack and stack[-1] == hashmap[c]:\n                stack.pop()\n            else:\n                return False\n        else:\n            stack.append(c)\n\n    return True if not stack else False\n\n\nprint(isValid(\"()\"))  # True\nprint(isValid(\"()[]{}\"))  # True\nprint(isValid(\"(]\"))  # False\n</code></pre>"},{"location":"company/amazon/#2-add-two-numbers","title":"2. Add Two Numbers","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: linked list, math, recursion</li> <li>Represent the sum of two numbers as a linked list.</li> </ul> <pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef addTwoNumbers(\n    l1: Optional[ListNode], l2: Optional[ListNode]\n) -&gt; Optional[ListNode]:\n    dummy = ListNode(0)\n    cur = dummy\n    carry = 0\n\n    while l1 or l2:\n        v1 = l1.val if l1 else 0\n        v2 = l2.val if l2 else 0\n\n        carry, val = divmod(v1 + v2 + carry, 10)\n        cur.next = ListNode(val)\n        cur = cur.next\n\n        if l1:\n            l1 = l1.next\n        if l2:\n            l2 = l2.next\n\n    if carry:\n        cur.next = ListNode(val=carry)\n\n    return dummy.next\n\n\nl1 = ListNode.create([2, 4, 3])\nl2 = ListNode.create([5, 6, 4])\nprint(addTwoNumbers(l1, l2))  # 7 -&gt; 0 -&gt; 8\n</code></pre>"},{"location":"company/amazon/#70-climbing-stairs","title":"70. Climbing Stairs","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: math, dynamic programming, memoization</li> <li>Return the number of distinct ways to reach the top of the stairs.</li> <li><code>dp[n]</code> stores the number of distinct ways to reach the <code>n-th</code> stair.</li> <li>Formula: <code>dp[n] = dp[n - 1] + dp[n - 2]</code>.</li> <li>Initialize <code>dp[0] = 0</code>, <code>dp[1] = 1</code>, and <code>dp[2] = 2</code>.</li> </ul> n <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n]</code> 0 - - 0 1 - - 1 2 - 1 2 3 1 2 3 4 2 3 5 5 3 5 8 6 5 8 13 7 8 13 21 8 13 21 34 9 21 34 55 10 34 55 89 <pre><code># DP\ndef climbStairs(n: int) -&gt; int:\n    if n &lt;= 1:\n        return n\n\n    dp = [i for i in range(n + 1)]\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |     DP      |      O(n)       |     O(n)     |\n# |-------------|-----------------|--------------|\n\nprint(climbStairs(10))  # 89\n</code></pre>"},{"location":"company/amazon/#238-product-of-array-except-self","title":"238. Product of Array Except Self","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, prefix sum</li> <li>Classic Prefix Sum problem</li> <li>Return an array <code>output</code> such that <code>output[i]</code> is equal to the product of all the elements of <code>nums</code> except <code>nums[i]</code>.</li> </ul> Approach Time Space Prefix O(n) O(n) Prefix (Optimized) O(n) O(1) <pre><code>from typing import List\n\n\n# Prefix\ndef productExceptSelf(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    prefix = [1 for _ in range(n)]\n    suffix = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        prefix[i] = nums[i - 1] * prefix[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        suffix[i] = nums[i + 1] * suffix[i + 1]\n\n    result = [i * j for i, j in zip(prefix, suffix)]\n\n    return result\n\n\n# Prefix (Optimized)\ndef productExceptSelfOptimized(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    result = [1 for _ in range(n)]\n\n    prefix = 1\n    for i in range(n):\n        result[i] = prefix\n        prefix *= nums[i]\n\n    suffix = 1\n    for i in range(n - 1, -1, -1):\n        result[i] *= suffix\n        suffix *= nums[i]\n\n    return result\n\n\nprint(productExceptSelf([1, 2, 3, 4]))\n# [24, 12, 8, 6]\nprint(productExceptSelfOptimized([1, 2, 3, 4]))\n# [24, 12, 8, 6]\n</code></pre>"},{"location":"company/amazon/#560-subarray-sum-equals-k","title":"560. Subarray Sum Equals K","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, prefix sum</li> </ul> <pre><code>from typing import List\n\n\n# 1. Prefix Sum\ndef subarraySum(nums: List[int], k: int) -&gt; int:\n    prefix_sums = {0: 1}\n    currentSum = 0\n    count = 0\n\n    for num in nums:\n        currentSum += num\n        if (currentSum - k) in prefix_sums:\n            count += prefix_sums[currentSum - k]\n\n        if currentSum in prefix_sums:\n            prefix_sums[currentSum] += 1\n        else:\n            prefix_sums[currentSum] = 1\n\n    return count\n\n\n# 2. Optimized Prefix Sum\ndef subarraySumOptimized(nums: List[int], k: int) -&gt; int:\n    prefixSum = 0\n    count = 0\n    prefix_sums = {0: 1}\n\n    for num in nums:\n        prefixSum += num\n        count += prefix_sums.get(prefixSum - k, 0)\n        prefix_sums[prefixSum] = prefix_sums.get(prefixSum, 0) + 1\n\n    return count\n\n\nnums = [1, 1, 1]\nk = 2\nprint(subarraySum(nums, k))  # 2\nprint(subarraySumOptimized(nums, k))  # 2\n</code></pre>"},{"location":"company/amazon/#4-median-of-two-sorted-arrays","title":"4. Median of Two Sorted Arrays","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: array, binary search, divide and conquer</li> </ul> <pre><code>from typing import List\n\n\n# Brute Force\ndef findMedianSortedArraysBF(nums1: List[int], nums2: List[int]) -&gt; float:\n    nums = sorted(nums1 + nums2)\n    n = len(nums)\n    if n % 2 == 0:\n        return (nums[n // 2 - 1] + nums[n // 2]) / 2\n    else:\n        return nums[n // 2]\n\n\n# Binary Search\ndef findMedianSortedArraysBS(nums1: List[int], nums2: List[int]) -&gt; float:\n    if len(nums1) &gt; len(nums2):\n        nums1, nums2 = nums2, nums1\n\n    m, n = len(nums1), len(nums2)\n    imin, imax, half_len = 0, m, (m + n + 1) // 2\n\n    while imin &lt;= imax:\n        i = (imin + imax) // 2\n        j = half_len - i\n\n        if i &lt; m and nums2[j - 1] &gt; nums1[i]:\n            imin = i + 1\n        elif i &gt; 0 and nums1[i - 1] &gt; nums2[j]:\n            imax = i - 1\n        else:\n            if i == 0:\n                max_of_left = nums2[j - 1]\n            elif j == 0:\n                max_of_left = nums1[i - 1]\n            else:\n                max_of_left = max(nums1[i - 1], nums2[j - 1])\n\n            if (m + n) % 2 == 1:\n                return max_of_left\n\n            if i == m:\n                min_of_right = nums2[j]\n            elif j == n:\n                min_of_right = nums1[i]\n            else:\n                min_of_right = min(nums1[i], nums2[j])\n\n            return (max_of_left + min_of_right) / 2\n\n\n# |--------------|-----------------|--------------|\n# | Approach     | Time            | Space        |\n# |--------------|-----------------|--------------|\n# | Brute Force  | O((n+m)log(n+m))| O(n+m)       |\n# | Binary Search| O(log(min(n,m)))| O(1)         |\n# |--------------|-----------------|--------------|\n\n\nnums1 = [1, 3]\nnums2 = [2]\nprint(findMedianSortedArraysBF(nums1, nums2))  # 2.0\nprint(findMedianSortedArraysBS(nums1, nums2))  # 2.0\n</code></pre>"},{"location":"company/amazon/#79-word-search","title":"79. Word Search","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, string, backtracking, depth first search, matrix</li> </ul> <pre><code>from typing import List\n\n\ndef exist(board: List[List[str]], word: str) -&gt; bool:\n    m, n = len(board), len(board[0])\n    path = set()\n    directions = ((0, 1), (1, 0), (0, -1), (-1, 0))\n\n    def dfs(r, c, i):\n        if i == len(word):\n            return True\n\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or board[r][c] != word[i]\n            or (r, c) in path\n        ):\n            return False\n\n        path.add((r, c))\n\n        for dr, dc in directions:\n            if dfs(r + dr, c + dc, i + 1):\n                return True\n\n        path.remove((r, c))\n        return False\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, 0):\n                return True\n\n    return False\n\n\nboard = [\n    [\"A\", \"B\", \"C\", \"E\"],\n    [\"S\", \"F\", \"C\", \"S\"],\n    [\"A\", \"D\", \"E\", \"E\"],\n]\nword = \"ABCCED\"\nprint(exist(board, word))  # True\n</code></pre>"},{"location":"company/amazon/#22-generate-parentheses","title":"22. Generate Parentheses","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: string, dynamic programming, backtracking</li> </ul> <pre><code>from typing import List\n\n\n# Stack\ndef generateParenthesis(n: int) -&gt; List[str]:\n    stack = []\n    result = []\n\n    def backtrack(openN, closeN):\n        if openN == closeN == n:\n            result.append(\"\".join(stack))\n            return None\n\n        if openN &lt; n:\n            stack.append(\"(\")\n            backtrack(openN + 1, closeN)\n            stack.pop()\n\n        if closeN &lt; openN:\n            stack.append(\")\")\n            backtrack(openN, closeN + 1)\n            stack.pop()\n\n    backtrack(0, 0)\n\n    return result\n\n\nprint(generateParenthesis(3))\n# ['((()))', '(()())', '(())()', '()(())', '()()()']\n</code></pre>"},{"location":"company/amazon/#215-kth-largest-element-in-an-array","title":"215. Kth Largest Element in an Array","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, divide and conquer, sorting, heap priority queue, quickselect</li> </ul> <pre><code>import heapq\nfrom typing import List\n\n\ndef findKthLargest(nums: List[int], k: int) -&gt; int:\n    heap = nums[:k]\n    heapq.heapify(heap)  # min heap\n\n    for num in nums[k:]:\n        if num &gt; heap[0]:\n            heapq.heappop(heap)  # pop the smallest element\n            heapq.heappush(heap, num)  # push the new element\n\n    return heap[0]\n\n\n# Time complexity: O(n * log(k))\n#   - O(log(k)) for heapify\n#   - O(n) for iterating through the input list\n# Space complexity: O(k)\n\nnums = [3, 2, 1, 5, 6, 4]\nk = 2\nprint(findKthLargest(nums, k))  # 5\n</code></pre>"},{"location":"company/amazon/#295-find-median-from-data-stream","title":"295. Find Median from Data Stream","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> <li>Tags: two pointers, design, sorting, heap priority queue, data stream</li> </ul> <pre><code>from heapq import heappop, heappush\n\n\n# Heap - Two Heaps\nclass MedianFinder:\n    def __init__(self):\n        self.max = []\n        self.min = []\n\n    def addNum(self, num: int) -&gt; None:\n        heappush(self.max, -num)\n        heappush(self.min, -heappop(self.max))\n\n        if len(self.min) &gt; len(self.max):\n            heappush(self.max, -heappop(self.min))\n\n    def findMedian(self) -&gt; float:\n        if len(self.max) == len(self.min):\n            return (-self.max[0] + self.min[0]) / 2.0\n        else:\n            return -self.max[0]\n\n\n# TC: O(log n)\n# SC: O(n)\n\nmedian_finder = MedianFinder()\nmedian_finder.addNum(1)\nmedian_finder.addNum(2)\nassert median_finder.findMedian() == 1.5\nmedian_finder.addNum(3)\nassert median_finder.findMedian() == 2\nmedian_finder.addNum(4)\nassert median_finder.findMedian() == 2.5\nmedian_finder.addNum(5)\nassert median_finder.findMedian() == 3\nprint(\"All Passed.\")\n</code></pre>"},{"location":"company/amazon/#5-longest-palindromic-substring","title":"5. Longest Palindromic Substring","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: two pointers, string, dynamic programming</li> <li>Return the longest palindromic substring in <code>s</code>.</li> </ul> <pre><code># DP - Interval\ndef longestPalindromeDP(s: str) -&gt; str:\n    n = len(s)\n    if n &lt;= 1:\n        return s\n\n    start, maxLen = 0, 1\n\n    # Init\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for j in range(1, n):\n        for i in range(j):\n            if s[i] == s[j]:\n                if j - i &lt;= 2:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1]\n\n                if dp[i][j] and j - i + 1 &gt; maxLen:\n                    maxLen = j - i + 1\n                    start = i\n\n    return s[start : start + maxLen]\n\n\n# Expand Around Center\ndef longestPalindromeCenter(s: str) -&gt; str:\n    def expand_around_center(left, right):\n        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n\n    if len(s) &lt;= 1:\n        return s\n\n    start, end = 0, 0\n    for i in range(len(s)):\n        len1 = expand_around_center(i, i)  # odd\n        len2 = expand_around_center(i, i + 1)  # even\n\n        maxLen = max(len1, len2)\n        if maxLen &gt; end - start:\n            start = i - (maxLen - 1) // 2\n            end = i + maxLen // 2\n\n    return s[start : end + 1]\n\n\ns = \"babad\"\nprint(longestPalindromeDP(s))  # \"bab\"\nprint(longestPalindromeCenter(s))  # \"aba\"\n</code></pre>"},{"location":"company/amazon/#33-search-in-rotated-sorted-array","title":"33. Search in Rotated Sorted Array","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, binary search</li> </ul> <pre><code>from typing import List\n\n\n# Binary Search\ndef search(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] == target:\n            return mid\n\n        if nums[left] &lt;= nums[mid]:\n            if nums[left] &lt;= target &lt; nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if nums[mid] &lt; target &lt;= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n    return -1\n\n\nnums = [4, 5, 6, 7, 0, 1, 2]\ntarget = 0\nprint(search(nums, target))  # 4\n</code></pre>"},{"location":"endlesscheng/","title":"EndlessCheng \u7075\u8336\u5c71\u827e\u5e9c","text":"<p> (As of 2025 February)</p> <ul> <li>EndlessCheng \u7075\u8336\u5c71\u827e\u5e9c - LeetCode</li> <li> <p>\u9898\u5355</p> </li> <li> <p> \u6ed1\u52a8\u7a97\u53e3\u4e0e\u53cc\u6307\u9488\uff08\u5b9a\u957f/\u4e0d\u5b9a\u957f/\u5355\u5e8f\u5217/\u53cc\u5e8f\u5217/\u4e09\u6307\u9488\uff09</p> </li> <li> \u4e8c\u5206\u7b97\u6cd5\uff08\u4e8c\u5206\u7b54\u6848/\u6700\u5c0f\u5316\u6700\u5927\u503c/\u6700\u5927\u5316\u6700\u5c0f\u503c/\u7b2c K \u5c0f\uff09</li> <li> \u5355\u8c03\u6808\uff08\u57fa\u7840/\u77e9\u5f62\u9762\u79ef/\u8d21\u732e\u6cd5/\u6700\u5c0f\u5b57\u5178\u5e8f\uff09</li> <li> \u7f51\u683c\u56fe\uff08DFS/BFS/\u7efc\u5408\u5e94\u7528\uff09</li> <li> \u4f4d\u8fd0\u7b97\uff08\u57fa\u7840/\u6027\u8d28/\u62c6\u4f4d/\u8bd5\u586b/\u6052\u7b49\u5f0f/\u601d\u7ef4\uff09</li> <li> \u56fe\u8bba\u7b97\u6cd5\uff08DFS/BFS/\u62d3\u6251\u6392\u5e8f/\u6700\u77ed\u8def/\u6700\u5c0f\u751f\u6210\u6811/\u4e8c\u5206\u56fe/\u57fa\u73af\u6811/\u6b27\u62c9\u8def\u5f84\uff09</li> <li> \u52a8\u6001\u89c4\u5212\uff08\u5165\u95e8/\u80cc\u5305/\u72b6\u6001\u673a/\u5212\u5206/\u533a\u95f4/\u72b6\u538b/\u6570\u4f4d/\u6570\u636e\u7ed3\u6784\u4f18\u5316/\u6811\u5f62/\u535a\u5f08/\u6982\u7387\u671f\u671b\uff09</li> <li> \u5e38\u7528\u6570\u636e\u7ed3\u6784\uff08\u524d\u7f00\u548c/\u5dee\u5206/\u6808/\u961f\u5217/\u5806/\u5b57\u5178\u6811/\u5e76\u67e5\u96c6/\u6811\u72b6\u6570\u7ec4/\u7ebf\u6bb5\u6811\uff09</li> <li> \u6570\u5b66\u7b97\u6cd5\uff08\u6570\u8bba/\u7ec4\u5408/\u6982\u7387\u671f\u671b/\u535a\u5f08/\u8ba1\u7b97\u51e0\u4f55/\u968f\u673a\u7b97\u6cd5\uff09</li> <li> \u8d2a\u5fc3\u4e0e\u601d\u7ef4\uff08\u57fa\u672c\u8d2a\u5fc3\u7b56\u7565/\u53cd\u6094/\u533a\u95f4/\u5b57\u5178\u5e8f/\u6570\u5b66/\u601d\u7ef4/\u8111\u7b4b\u6025\u8f6c\u5f2f/\u6784\u9020\uff09</li> <li> \u94fe\u8868\u3001\u4e8c\u53c9\u6811\u4e0e\u4e00\u822c\u6811\uff08\u524d\u540e\u6307\u9488/\u5feb\u6162\u6307\u9488/DFS/BFS/\u76f4\u5f84/LCA\uff09</li> <li> \u5b57\u7b26\u4e32\uff08KMP/Z \u51fd\u6570/Manacher/\u5b57\u7b26\u4e32\u54c8\u5e0c/AC \u81ea\u52a8\u673a/\u540e\u7f00\u6570\u7ec4/\u5b50\u5e8f\u5217\u81ea\u52a8\u673a\uff09</li> </ul>"},{"location":"endlesscheng/1d_difference_array/","title":"1D Difference Array","text":"<ul> <li> 2848. Points That Intersect With Cars (Easy)</li> <li> 1893. Check if All the Integers in a Range Are Covered (Easy)</li> <li> 1854. Maximum Population Year (Easy)</li> <li> 2960. Count Tested Devices After Test Operations (Easy)</li> <li> 1094. Car Pooling (Medium)</li> <li> 1109. Corporate Flight Bookings (Medium)</li> <li> 3355. Zero Array Transformation I (Medium)</li> <li> 56. Merge Intervals (Medium)</li> <li> 57. Insert Interval (Medium)</li> <li> 732. My Calendar III (Hard)</li> <li> 2406. Divide Intervals Into Minimum Number of Groups (Medium)</li> <li> 2381. Shifting Letters II (Medium)</li> <li> 3453. Separate Squares I (Medium)</li> <li> 995. Minimum Number of K Consecutive Bit Flips (Hard)</li> <li> 1589. Maximum Sum Obtained of Any Permutation (Medium)</li> <li> 1526. Minimum Number of Increments on Subarrays to Form a Target Array (Hard)</li> <li> 3356. Zero Array Transformation II (Medium)</li> <li> 1943. Describe the Painting (Medium)</li> <li> 3224. Minimum Array Changes to Make Differences Equal (Medium)</li> <li> 2251. Number of Flowers in Full Bloom (Hard)</li> <li> 2772. Apply Operations to Make All Array Elements Equal to Zero (Medium)</li> <li> 3229. Minimum Operations to Make Array Equal to Target (Hard)</li> <li> 798. Smallest Rotation with Highest Score (Hard)</li> <li> 3347. Maximum Frequency of an Element After Performing Operations II (Hard)</li> <li> 2528. Maximize the Minimum Powered City (Hard)</li> <li> 1674. Minimum Moves to Make Array Complementary (Medium)</li> <li> 3362. Zero Array Transformation III (Medium)</li> <li> 3017. Count the Number of Houses at a Certain Distance II (Hard)</li> <li> 253. Meeting Rooms II (Medium)</li> <li> 370. Range Addition (Medium)</li> <li> 1989. Maximum Number of People That Can Be Caught in Tag (Medium)</li> <li> 759. Employee Free Time (Hard)</li> <li> 2021. Brightest Position on Street (Medium)</li> <li> 2015. Average Height of Buildings in Each Segment (Medium)</li> <li> 2237. Count Positions on Street With Required Brightness (Medium)</li> <li> 3009. Maximum Number of Intersections on the Chart (Hard)</li> <li> 3279. Maximum Total Area Occupied by Pistons (Hard)</li> </ul>"},{"location":"endlesscheng/1d_difference_array/#2848-points-that-intersect-with-cars","title":"2848. Points That Intersect With Cars","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, prefix sum</p> </li> <li>Return the number of points that intersect with cars.</li> </ul> 2848. Points That Intersect With Cars - Python Solution<pre><code>from itertools import accumulate\nfrom typing import List\n\n\n# Differnce Array\ndef numberOfPoints(nums: List[List[int]]) -&gt; int:\n    max_end = max(end for _, end in nums)\n\n    diff = [0] * (max_end + 2)\n\n    for start, end in nums:\n        diff[start] += 1\n        diff[end + 1] -= 1\n\n    return sum(s &gt; 0 for s in accumulate(diff))\n\n\nnums = [[3, 6], [1, 5], [4, 7]]\nprint(numberOfPoints(nums))  # 7\n</code></pre>"},{"location":"endlesscheng/1d_difference_array/#1893-check-if-all-the-integers-in-a-range-are-covered","title":"1893. Check if All the Integers in a Range Are Covered","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/1d_difference_array/#1854-maximum-population-year","title":"1854. Maximum Population Year","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, counting, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/1d_difference_array/#2960-count-tested-devices-after-test-operations","title":"2960. Count Tested Devices After Test Operations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, simulation, counting</p> </li> </ul>"},{"location":"endlesscheng/1d_difference_array/#1094-car-pooling","title":"1094. Car Pooling","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sorting, heap priority queue, simulation, prefix sum</p> </li> <li>Return <code>False</code> if the total number of passengers at any point is greater than <code>capacity</code>. Otherwise, return <code>True</code>.</li> </ul> 1094. Car Pooling - Python Solution<pre><code>from itertools import accumulate\nfrom typing import List\n\n\n# Difference Array\ndef carPooling1(trips: List[List[int]], capacity: int) -&gt; bool:\n    max_location = 0\n    for trip in trips:\n        max_location = max(max_location, trip[2])\n\n    diff = [0] * (max_location + 1)\n    n = len(diff)\n\n    for num, start, end in trips:\n        diff[start] += num\n        if end &lt; n:\n            diff[end] -= num\n\n    cur = 0\n    for i in range(n):\n        cur += diff[i]\n        if cur &gt; capacity:\n            return False\n\n    return True\n\n\n# Difference Array\ndef carPooling2(trips: List[List[int]], capacity: int) -&gt; bool:\n    diff = [0] * 1001\n\n    for num, start, end in trips:\n        diff[start] += num\n        diff[end] -= num\n\n    return all(s &lt;= capacity for s in accumulate(diff))\n\n\ntrips = [[2, 1, 5], [3, 3, 7]]\ncapacity = 4\nprint(carPooling1(trips, capacity))  # False\nprint(carPooling2(trips, capacity))  # False\n</code></pre>"},{"location":"endlesscheng/1d_difference_array/#1109-corporate-flight-bookings","title":"1109. Corporate Flight Bookings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, prefix sum</p> </li> <li>Return the number of seats booked on each flight.</li> </ul> 1109. Corporate Flight Bookings - Python Solution<pre><code>from typing import List\n\n\n# Difference Array\ndef corpFlightBookings(bookings: List[List[int]], n: int) -&gt; List[int]:\n    \"\"\"Return the number of seats booked for each flight.\"\"\"\n    res = [0 for _ in range(n)]\n\n    for i, j, k in bookings:\n        res[i - 1] += k\n        if j &lt; n:\n            res[j] -= k\n\n    for i in range(1, n):\n        res[i] += res[i - 1]\n\n    return res\n\n\nbookings = [[1, 2, 10], [2, 3, 20], [2, 5, 25]]\nn = 5\nprint(corpFlightBookings(bookings, n))  # [10, 55, 45, 25, 25]\n</code></pre>"},{"location":"endlesscheng/1d_difference_array/#3355-zero-array-transformation-i","title":"3355. Zero Array Transformation I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/1d_difference_array/#56-merge-intervals","title":"56. Merge Intervals","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sorting</p> </li> <li>Merge all overlapping intervals.</li> </ul> 56. Merge Intervals - Python Solution<pre><code>from typing import List\n\n\n# Intervals\ndef merge(intervals: List[List[int]]) -&gt; List[List[int]]:\n    n = len(intervals)\n    if n &lt;= 1:\n        return intervals\n\n    intervals.sort(key=lambda x: x[0])\n    res = [intervals[0]]\n\n    for i in range(1, n):\n        if intervals[i][0] &lt;= res[-1][1]:\n            res[-1][1] = max(res[-1][1], intervals[i][1])\n        else:\n            res.append(intervals[i])\n\n    return res\n\n\nprint(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))\n# [[1, 6], [8, 10], [15, 18]]\n</code></pre>"},{"location":"endlesscheng/1d_difference_array/#57-insert-interval","title":"57. Insert Interval","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array</p> </li> </ul> 57. Insert Interval - Python Solution<pre><code>from typing import List\n\n\n# Interval\ndef insert(\n    intervals: List[List[int]], newInterval: List[int]\n) -&gt; List[List[int]]:\n    n = len(intervals)\n\n    if n == 0:\n        return [newInterval]\n\n    if newInterval[1] &lt; intervals[0][0]:\n        return [newInterval] + intervals\n\n    if newInterval[0] &gt; intervals[-1][1]:\n        return intervals + [newInterval]\n\n    i = 0\n    result = []\n\n    while i &lt; n and intervals[i][1] &lt; newInterval[0]:\n        result.append(intervals[i])\n        i += 1\n\n    while i &lt; n and intervals[i][0] &lt;= newInterval[1]:\n        newInterval[0] = min(newInterval[0], intervals[i][0])\n        newInterval[1] = max(newInterval[1], intervals[i][1])\n        i += 1\n\n    result.append(newInterval)\n\n    while i &lt; n:\n        result.append(intervals[i])\n        i += 1\n\n    return result\n\n\nintervals = [[1, 3], [6, 9]]\nnewInterval = [2, 5]\nprint(insert(intervals, newInterval))  # [[1, 5], [6, 9]]\n</code></pre>"},{"location":"endlesscheng/1d_difference_array/#732-my-calendar-iii","title":"732. My Calendar III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: binary search, design, segment tree, prefix sum, ordered set</p> </li> </ul>"},{"location":"endlesscheng/1d_difference_array/#2406-divide-intervals-into-minimum-number-of-groups","title":"2406. Divide Intervals Into Minimum Number of Groups","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy, sorting, heap priority queue, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/1d_difference_array/#2381-shifting-letters-ii","title":"2381. Shifting Letters II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/1d_difference_array/#3453-separate-squares-i","title":"3453. Separate Squares I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"endlesscheng/1d_difference_array/#995-minimum-number-of-k-consecutive-bit-flips","title":"995. Minimum Number of K Consecutive Bit Flips","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, bit manipulation, queue, sliding window, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/1d_difference_array/#1589-maximum-sum-obtained-of-any-permutation","title":"1589. Maximum Sum Obtained of Any Permutation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting, prefix sum</p> </li> </ul> 1589. Maximum Sum Obtained of Any Permutation - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef maxSumRangeQuery(nums: List[int], requests: List[List[int]]) -&gt; int:\n    n = len(nums)\n    freq = [0 for _ in range(n + 1)]\n\n    for start, end in requests:\n        freq[start] += 1\n        if end + 1 &lt; n:\n            freq[end + 1] -= 1\n\n    for i in range(1, n):\n        freq[i] += freq[i - 1]\n\n    freq.pop()\n\n    freq.sort(reverse=True)\n    nums.sort(reverse=True)\n\n    max_sum = 0\n    mod = 10**9 + 7\n\n    for i, j in zip(nums, freq):\n        max_sum += i * j\n        max_sum %= mod\n\n    return max_sum\n\n\nnums = [1, 2, 3, 4, 5]\nrequests = [[1, 3], [0, 1]]\nprint(maxSumRangeQuery(nums, requests))  # 19\n</code></pre>"},{"location":"endlesscheng/1d_difference_array/#1526-minimum-number-of-increments-on-subarrays-to-form-a-target-array","title":"1526. Minimum Number of Increments on Subarrays to Form a Target Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, stack, greedy, monotonic stack</p> </li> </ul>"},{"location":"endlesscheng/1d_difference_array/#3356-zero-array-transformation-ii","title":"3356. Zero Array Transformation II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/1d_difference_array/#1943-describe-the-painting","title":"1943. Describe the Painting","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, sorting, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/1d_difference_array/#3224-minimum-array-changes-to-make-differences-equal","title":"3224. Minimum Array Changes to Make Differences Equal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/1d_difference_array/#2251-number-of-flowers-in-full-bloom","title":"2251. Number of Flowers in Full Bloom","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, binary search, sorting, prefix sum, ordered set</p> </li> </ul>"},{"location":"endlesscheng/1d_difference_array/#2772-apply-operations-to-make-all-array-elements-equal-to-zero","title":"2772. Apply Operations to Make All Array Elements Equal to Zero","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/1d_difference_array/#3229-minimum-operations-to-make-array-equal-to-target","title":"3229. Minimum Operations to Make Array Equal to Target","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, stack, greedy, monotonic stack</p> </li> </ul>"},{"location":"endlesscheng/1d_difference_array/#798-smallest-rotation-with-highest-score","title":"798. Smallest Rotation with Highest Score","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/1d_difference_array/#3347-maximum-frequency-of-an-element-after-performing-operations-ii","title":"3347. Maximum Frequency of an Element After Performing Operations II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, sliding window, sorting, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/1d_difference_array/#2528-maximize-the-minimum-powered-city","title":"2528. Maximize the Minimum Powered City","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, greedy, queue, sliding window, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/1d_difference_array/#1674-minimum-moves-to-make-array-complementary","title":"1674. Minimum Moves to Make Array Complementary","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/1d_difference_array/#3362-zero-array-transformation-iii","title":"3362. Zero Array Transformation III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting, heap priority queue, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/1d_difference_array/#3017-count-the-number-of-houses-at-a-certain-distance-ii","title":"3017. Count the Number of Houses at a Certain Distance II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: graph, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/1d_difference_array/#253-meeting-rooms-ii","title":"253. Meeting Rooms II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy, sorting, heap priority queue, prefix sum</p> </li> </ul> 253. Meeting Rooms II - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Heap\ndef minMeetingRooms(intervals: List[List[int]]) -&gt; int:\n    if not intervals:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n    heap = [intervals[0][1]]\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &gt;= heap[0]:\n            heapq.heappop(heap)\n        heapq.heappush(heap, intervals[i][1])\n\n    return len(heap)\n\n\nintervals = [[0, 30], [5, 10], [15, 20]]\nprint(minMeetingRooms(intervals))  # 2\n</code></pre>"},{"location":"endlesscheng/1d_difference_array/#370-range-addition","title":"370. Range Addition","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, prefix sum</p> </li> <li>Return the final array after applying all the Adition operations.</li> </ul> 370. Range Addition - Python Solution<pre><code>from typing import List\n\n\n# Difference Array\ndef getModifiedArray(length: int, updates: List[List[int]]) -&gt; List[int]:\n    result = [0 for _ in range(length)]\n\n    for start, end, inc in updates:\n        result[start] += inc\n\n        if end + 1 &lt; length:\n            result[end + 1] -= inc\n\n    for i in range(1, length):\n        result[i] += result[i - 1]\n\n    return result\n\n\nlength = 5\nupdates = [[1, 3, 2], [2, 4, 3], [0, 2, -2]]\nprint(getModifiedArray(length, updates))  # [-2, 0, 3, 5, 3]\n</code></pre>"},{"location":"endlesscheng/1d_difference_array/#1989-maximum-number-of-people-that-can-be-caught-in-tag","title":"1989. Maximum Number of People That Can Be Caught in Tag","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy</p> </li> </ul>"},{"location":"endlesscheng/1d_difference_array/#759-employee-free-time","title":"759. Employee Free Time","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, sorting, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/1d_difference_array/#2021-brightest-position-on-street","title":"2021. Brightest Position on Street","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sorting, prefix sum, ordered set</p> </li> </ul>"},{"location":"endlesscheng/1d_difference_array/#2015-average-height-of-buildings-in-each-segment","title":"2015. Average Height of Buildings in Each Segment","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/1d_difference_array/#2237-count-positions-on-street-with-required-brightness","title":"2237. Count Positions on Street With Required Brightness","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/1d_difference_array/#3009-maximum-number-of-intersections-on-the-chart","title":"3009. Maximum Number of Intersections on the Chart","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, binary indexed tree, geometry</p> </li> </ul>"},{"location":"endlesscheng/1d_difference_array/#3279-maximum-total-area-occupied-by-pistons","title":"3279. Maximum Total Area Occupied by Pistons","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, string, simulation, counting, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/1d_prefix_sum/","title":"1D Prefix Sum","text":"<ul> <li> 1310. XOR Queries of a Subarray (Medium)</li> <li> 2438. Range Product Queries of Powers (Medium)</li> <li> 1895. Largest Magic Square (Medium)</li> <li> 1878. Get Biggest Three Rhombus Sums in a Grid (Medium)</li> <li> 1031. Maximum Sum of Two Non-Overlapping Subarrays (Medium)</li> <li> 2245. Maximum Trailing Zeros in a Cornered Path (Medium)</li> <li> 1712. Ways to Split Array Into Three Subarrays (Medium)</li> <li> 1862. Sum of Floored Pairs (Hard)</li> <li> 363. Max Sum of Rectangle No Larger Than K (Hard)</li> <li> 2281. Sum of Total Strength of Wizards (Hard)</li> <li> 3445. Maximum Difference Between Even and Odd Frequency II (Hard)</li> <li> 2983. Palindrome Rearrangement Queries (Hard)</li> <li> 2955. Number of Same-End Substrings (Medium)</li> <li> 1788. Maximize the Beauty of the Garden (Hard)</li> <li> 2819. Minimum Relative Loss After Buying Chocolates (Hard)</li> </ul>"},{"location":"endlesscheng/1d_prefix_sum/#1310-xor-queries-of-a-subarray","title":"1310. XOR Queries of a Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/1d_prefix_sum/#2438-range-product-queries-of-powers","title":"2438. Range Product Queries of Powers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/1d_prefix_sum/#1895-largest-magic-square","title":"1895. Largest Magic Square","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, matrix, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/1d_prefix_sum/#1878-get-biggest-three-rhombus-sums-in-a-grid","title":"1878. Get Biggest Three Rhombus Sums in a Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, sorting, heap priority queue, matrix, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/1d_prefix_sum/#1031-maximum-sum-of-two-non-overlapping-subarrays","title":"1031. Maximum Sum of Two Non-Overlapping Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, sliding window</p> </li> </ul>"},{"location":"endlesscheng/1d_prefix_sum/#2245-maximum-trailing-zeros-in-a-cornered-path","title":"2245. Maximum Trailing Zeros in a Cornered Path","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, matrix, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/1d_prefix_sum/#1712-ways-to-split-array-into-three-subarrays","title":"1712. Ways to Split Array Into Three Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/1d_prefix_sum/#1862-sum-of-floored-pairs","title":"1862. Sum of Floored Pairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, binary search, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/1d_prefix_sum/#363-max-sum-of-rectangle-no-larger-than-k","title":"363. Max Sum of Rectangle No Larger Than K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, matrix, prefix sum, ordered set</p> </li> </ul>"},{"location":"endlesscheng/1d_prefix_sum/#2281-sum-of-total-strength-of-wizards","title":"2281. Sum of Total Strength of Wizards","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, stack, monotonic stack, prefix sum</p> </li> </ul> 2281. Sum of Total Strength of Wizards - Python Solution<pre><code>from itertools import accumulate\nfrom typing import List\n\n\n# Monotonic Stack\ndef totalStrength(strength: List[int]) -&gt; int:\n    n = len(strength)\n    left = [-1 for _ in range(n)]\n    right = [n for _ in range(n)]\n    stack = []\n\n    for i, v in enumerate(strength):\n        while stack and strength[stack[-1]] &gt;= v:\n            right[stack.pop()] = i\n        if stack:\n            left[i] = stack[-1]\n        stack.append(i)\n\n    prefix_sum = list(accumulate(accumulate(strength, initial=0), initial=0))\n\n    ans = 0\n    for i, v in enumerate(strength):\n        l, r = left[i] + 1, right[i] - 1\n        tot = (i - l + 1) * (prefix_sum[r + 2] - prefix_sum[i + 1]) - (\n            r - i + 1\n        ) * (prefix_sum[i + 1] - prefix_sum[l])\n        ans += v * tot\n\n    return ans % (10**9 + 7)\n\n\nstrength = [1, 3, 1, 2]\nprint(totalStrength(strength))  # 44\n</code></pre>"},{"location":"endlesscheng/1d_prefix_sum/#3445-maximum-difference-between-even-and-odd-frequency-ii","title":"3445. Maximum Difference Between Even and Odd Frequency II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, sliding window, enumeration, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/1d_prefix_sum/#2983-palindrome-rearrangement-queries","title":"2983. Palindrome Rearrangement Queries","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/1d_prefix_sum/#2955-number-of-same-end-substrings","title":"2955. Number of Same-End Substrings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, counting, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/1d_prefix_sum/#1788-maximize-the-beauty-of-the-garden","title":"1788. Maximize the Beauty of the Garden","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, greedy, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/1d_prefix_sum/#2819-minimum-relative-loss-after-buying-chocolates","title":"2819. Minimum Relative Loss After Buying Chocolates","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, sorting, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/2d_difference_array/","title":"2D Difference Array","text":"<ul> <li> 2536. Increment Submatrices by One (Medium)</li> <li> 850. Rectangle Area II (Hard)</li> <li> 2132. Stamping the Grid (Hard)</li> </ul>"},{"location":"endlesscheng/2d_difference_array/#2536-increment-submatrices-by-one","title":"2536. Increment Submatrices by One","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, matrix, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/2d_difference_array/#850-rectangle-area-ii","title":"850. Rectangle Area II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, segment tree, line sweep, ordered set</p> </li> </ul>"},{"location":"endlesscheng/2d_difference_array/#2132-stamping-the-grid","title":"2132. Stamping the Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, matrix, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/2d_prefix_sum/","title":"2D Prefix Sum","text":"<ul> <li> 304. Range Sum Query 2D - Immutable (Medium)</li> <li> 1314. Matrix Block Sum (Medium)</li> <li> 3070. Count Submatrices with Top-Left Element and Sum Less Than k (Medium)</li> <li> 1738. Find Kth Largest XOR Coordinate Value (Medium)</li> <li> 3212. Count Submatrices With Equal Frequency of X and Y (Medium)</li> <li> 1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold (Medium)</li> <li> 221. Maximal Square (Medium)</li> <li> 1277. Count Square Submatrices with All Ones (Medium)</li> <li> 1504. Count Submatrices With All Ones (Medium)</li> <li> 1074. Number of Submatrices That Sum to Target (Hard)</li> <li> 3148. Maximum Difference Score in a Grid (Medium)</li> </ul>"},{"location":"endlesscheng/2d_prefix_sum/#304-range-sum-query-2d-immutable","title":"304. Range Sum Query 2D - Immutable","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, design, matrix, prefix sum</p> </li> </ul> 304. Range Sum Query 2D - Immutable - Python Solution<pre><code>from typing import List\n\n\nclass NumMatrix:\n\n    def __init__(self, matrix: List[List[int]]):\n        m, n = len(matrix), len(matrix[0])\n        if m == 0 or n == 0:\n            return None\n\n        self.sum = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                self.sum[i][j] = (\n                    matrix[i - 1][j - 1]\n                    + self.sum[i - 1][j]\n                    + self.sum[i][j - 1]\n                    - self.sum[i - 1][j - 1]  # to avoid double counting\n                )\n\n    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -&gt; int:\n        return (\n            self.sum[row2 + 1][col2 + 1]\n            - self.sum[row1][col2 + 1]\n            - self.sum[row2 + 1][col1]\n            + self.sum[row1][col1]\n        )\n\n\nmatrix = [\n    [3, 0, 1, 4, 2],\n    [5, 6, 3, 2, 1],\n    [1, 2, 0, 1, 5],\n    [4, 1, 0, 1, 7],\n    [1, 0, 3, 0, 5],\n]\nobj = NumMatrix(matrix)\nassert obj.sumRegion(2, 1, 4, 3) == 8\nassert obj.sumRegion(1, 1, 2, 2) == 11\nassert obj.sumRegion(1, 2, 2, 4) == 12\nprint(\"PASSED\")\n</code></pre>"},{"location":"endlesscheng/2d_prefix_sum/#1314-matrix-block-sum","title":"1314. Matrix Block Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, matrix, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/2d_prefix_sum/#3070-count-submatrices-with-top-left-element-and-sum-less-than-k","title":"3070. Count Submatrices with Top-Left Element and Sum Less Than k","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, matrix, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/2d_prefix_sum/#1738-find-kth-largest-xor-coordinate-value","title":"1738. Find Kth Largest XOR Coordinate Value","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, divide and conquer, bit manipulation, sorting, heap priority queue, matrix, prefix sum, quickselect</p> </li> </ul>"},{"location":"endlesscheng/2d_prefix_sum/#3212-count-submatrices-with-equal-frequency-of-x-and-y","title":"3212. Count Submatrices With Equal Frequency of X and Y","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, matrix, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/2d_prefix_sum/#1292-maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold","title":"1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, matrix, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/2d_prefix_sum/#221-maximal-square","title":"221. Maximal Square","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, matrix</p> </li> </ul>"},{"location":"endlesscheng/2d_prefix_sum/#1277-count-square-submatrices-with-all-ones","title":"1277. Count Square Submatrices with All Ones","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, matrix</p> </li> </ul>"},{"location":"endlesscheng/2d_prefix_sum/#1504-count-submatrices-with-all-ones","title":"1504. Count Submatrices With All Ones","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, stack, matrix, monotonic stack</p> </li> </ul>"},{"location":"endlesscheng/2d_prefix_sum/#1074-number-of-submatrices-that-sum-to-target","title":"1074. Number of Submatrices That Sum to Target","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, matrix, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/2d_prefix_sum/#3148-maximum-difference-score-in-a-grid","title":"3148. Maximum Difference Score in a Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, matrix</p> </li> </ul>"},{"location":"endlesscheng/adjacent_different/","title":"Adjacent Different","text":"<ul> <li> 2335. Minimum Amount of Time to Fill Cups (Easy)</li> <li> 1753. Maximum Score From Removing Stones (Medium)</li> <li> 1054. Distant Barcodes (Medium)</li> <li> 2856. Minimum Array Length After Pair Removals (Medium)</li> <li> 1953. Maximum Number of Weeks for Which You Can Work (Medium)</li> <li> 767. Reorganize String (Medium)</li> <li> 3139. Minimum Cost to Equalize Array (Hard)</li> <li> 621. Task Scheduler (Medium)</li> <li> 358. Rearrange String k Distance Apart (Hard)</li> <li> 984. String Without AAA or BBB (Medium)</li> <li> 1405. Longest Happy String (Medium)</li> </ul>"},{"location":"endlesscheng/adjacent_different/#2335-minimum-amount-of-time-to-fill-cups","title":"2335. Minimum Amount of Time to Fill Cups","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, greedy, sorting, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/adjacent_different/#1753-maximum-score-from-removing-stones","title":"1753. Maximum Score From Removing Stones","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, greedy, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/adjacent_different/#1054-distant-barcodes","title":"1054. Distant Barcodes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, greedy, sorting, heap priority queue, counting</p> </li> </ul>"},{"location":"endlesscheng/adjacent_different/#2856-minimum-array-length-after-pair-removals","title":"2856. Minimum Array Length After Pair Removals","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, two pointers, binary search, greedy, counting</p> </li> </ul>"},{"location":"endlesscheng/adjacent_different/#1953-maximum-number-of-weeks-for-which-you-can-work","title":"1953. Maximum Number of Weeks for Which You Can Work","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy</p> </li> </ul>"},{"location":"endlesscheng/adjacent_different/#767-reorganize-string","title":"767. Reorganize String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, greedy, sorting, heap priority queue, counting</p> </li> </ul> 767. Reorganize String - Python Solution<pre><code>import heapq\nfrom collections import Counter\n\n\ndef reorganizeString(s: str) -&gt; str:\n    if not s:\n        return \"\"\n\n    heap = [(-freq, char) for char, freq in Counter(s).items()]  # max heap\n    heapq.heapify(heap)\n\n    result = []\n    prev_count, prev_char = 0, \"\"\n\n    while heap:\n        count, char = heapq.heappop(heap)  # pop the most frequent character\n        result.append(char)  # append the character to the result\n\n        if (\n            prev_count &lt; 0\n        ):  # if the previous character still has remaining count\n            heapq.heappush(heap, (prev_count, prev_char))\n\n        prev_count = (\n            count + 1\n        )  # update the current character's remaining count\n        prev_char = char  # update the current character\n\n    # check if there is any invalid result\n    if len(result) != len(s):\n        return \"\"\n\n    return \"\".join(result)\n\n\nprint(reorganizeString(\"aab\"))\n</code></pre>"},{"location":"endlesscheng/adjacent_different/#3139-minimum-cost-to-equalize-array","title":"3139. Minimum Cost to Equalize Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, enumeration</p> </li> </ul>"},{"location":"endlesscheng/adjacent_different/#621-task-scheduler","title":"621. Task Scheduler","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, greedy, sorting, heap priority queue, counting</p> </li> </ul> 621. Task Scheduler - Python Solution<pre><code>import heapq\nfrom collections import Counter, deque\nfrom typing import List\n\n\n# Heap\ndef leastInterval1(tasks: List[str], n: int) -&gt; int:\n    count = Counter(tasks)\n    heap = [-c for c in count.values()]\n    heapq.heapify(heap)\n\n    time = 0\n\n    q = deque()\n\n    while heap or q:\n        time += 1\n\n        if heap:\n            cnt = 1 + heapq.heappop(heap)\n            if cnt:\n                q.append((cnt, time + n))\n\n        if q and q[0][1] == time:\n            heapq.heappush(heap, q.popleft()[0])\n\n    return time\n\n\ndef leastInterval2(tasks: List[str], n: int) -&gt; int:\n    freq = Counter(tasks)\n\n    maxExec = max(freq.values())\n    maxCount = sum(1 for v in freq.values() if v == maxExec)\n\n    return max((maxExec - 1) * (n + 1) + maxCount, len(tasks))\n\n\ntasks = [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\"]\nn = 2\nprint(leastInterval1(tasks, n))  # 8\nprint(leastInterval2(tasks, n))  # 8\n</code></pre>"},{"location":"endlesscheng/adjacent_different/#358-rearrange-string-k-distance-apart","title":"358. Rearrange String k Distance Apart","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, greedy, sorting, heap priority queue, counting</p> </li> </ul>"},{"location":"endlesscheng/adjacent_different/#984-string-without-aaa-or-bbb","title":"984. String Without AAA or BBB","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, greedy</p> </li> </ul>"},{"location":"endlesscheng/adjacent_different/#1405-longest-happy-string","title":"1405. Longest Happy String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, greedy, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/adjacent_elimination/","title":"Adjacent Elimination","text":"<ul> <li> 2696. Minimum String Length After Removing Substrings (Easy)</li> <li> 1047. Remove All Adjacent Duplicates In String (Easy)</li> <li> 1544. Make The String Great (Easy)</li> <li> 1003. Check If Word Is Valid After Substitutions (Medium)</li> <li> 2216. Minimum Deletions to Make Array Beautiful (Medium)</li> <li> 1209. Remove All Adjacent Duplicates in String II (Medium)</li> <li> 2211. Count Collisions on a Road (Medium)</li> <li> 735. Asteroid Collision (Medium)</li> <li> 1717. Maximum Score From Removing Substrings (Medium)</li> <li> 2197. Replace Non-Coprime Numbers in Array (Hard)</li> <li> 2751. Robot Collisions (Hard)</li> </ul>"},{"location":"endlesscheng/adjacent_elimination/#2696-minimum-string-length-after-removing-substrings","title":"2696. Minimum String Length After Removing Substrings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, stack, simulation</p> </li> </ul>"},{"location":"endlesscheng/adjacent_elimination/#1047-remove-all-adjacent-duplicates-in-string","title":"1047. Remove All Adjacent Duplicates In String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, stack</p> </li> </ul>"},{"location":"endlesscheng/adjacent_elimination/#1544-make-the-string-great","title":"1544. Make The String Great","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, stack</p> </li> <li>Remove all adjacent characters that are the same and have different cases.</li> <li>Steps for the string <code>leEeetcode</code>:</li> </ul> char action stack l push \"l\" e push \"le\" E pop \"l\" e push \"le\" e push \"lee\" t push \"leet\" c push \"leetc\" o push \"leetco\" d push \"leetcod\" e push \"leetcode\" 1544. Make The String Great - Python Solution<pre><code># Stack\ndef makeGood(s: str) -&gt; str:\n    stack = []\n\n    for i in range(len(s)):\n        if stack and stack[-1] == s[i].swapcase():\n            stack.pop()\n        else:\n            stack.append(s[i])\n    return \"\".join(stack)\n\n\nprint(makeGood(\"leEeetcode\"))  # \"leetcode\"\n</code></pre>"},{"location":"endlesscheng/adjacent_elimination/#1003-check-if-word-is-valid-after-substitutions","title":"1003. Check If Word Is Valid After Substitutions","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack</p> </li> </ul>"},{"location":"endlesscheng/adjacent_elimination/#2216-minimum-deletions-to-make-array-beautiful","title":"2216. Minimum Deletions to Make Array Beautiful","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, greedy</p> </li> </ul>"},{"location":"endlesscheng/adjacent_elimination/#1209-remove-all-adjacent-duplicates-in-string-ii","title":"1209. Remove All Adjacent Duplicates in String II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack</p> </li> </ul>"},{"location":"endlesscheng/adjacent_elimination/#2211-count-collisions-on-a-road","title":"2211. Count Collisions on a Road","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack, simulation</p> </li> </ul>"},{"location":"endlesscheng/adjacent_elimination/#735-asteroid-collision","title":"735. Asteroid Collision","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, simulation</p> </li> </ul>"},{"location":"endlesscheng/adjacent_elimination/#1717-maximum-score-from-removing-substrings","title":"1717. Maximum Score From Removing Substrings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack, greedy</p> </li> </ul>"},{"location":"endlesscheng/adjacent_elimination/#2197-replace-non-coprime-numbers-in-array","title":"2197. Replace Non-Coprime Numbers in Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, stack, number theory</p> </li> </ul>"},{"location":"endlesscheng/adjacent_elimination/#2751-robot-collisions","title":"2751. Robot Collisions","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, stack, sorting, simulation</p> </li> </ul>"},{"location":"endlesscheng/basic_inequality/","title":"Basic Inequality","text":"<ul> <li> 3081. Replace Question Marks in String to Minimize Its Value (Medium)</li> <li> 1969. Minimum Non-Zero Product of the Array Elements (Medium)</li> <li> 2939. Maximum Xor Product (Medium)</li> <li> 2897. Apply Operations on Array to Maximize Sum of Squares (Hard)</li> </ul>"},{"location":"endlesscheng/basic_inequality/#3081-replace-question-marks-in-string-to-minimize-its-value","title":"3081. Replace Question Marks in String to Minimize Its Value","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, greedy, sorting, heap priority queue, counting</p> </li> </ul>"},{"location":"endlesscheng/basic_inequality/#1969-minimum-non-zero-product-of-the-array-elements","title":"1969. Minimum Non-Zero Product of the Array Elements","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, greedy, recursion</p> </li> </ul>"},{"location":"endlesscheng/basic_inequality/#2939-maximum-xor-product","title":"2939. Maximum Xor Product","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, greedy, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/basic_inequality/#2897-apply-operations-on-array-to-maximize-sum-of-squares","title":"2897. Apply Operations on Array to Maximize Sum of Squares","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, greedy, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bfs_basics/","title":"BFS Basics","text":"<ul> <li> 3243. Shortest Distance After Road Addition Queries I (Medium)</li> <li> 1311. Get Watched Videos by Your Friends (Medium)</li> <li> 1129. Shortest Path with Alternating Colors (Medium)</li> <li> 1298. Maximum Candies You Can Get from Boxes (Hard)</li> <li> 2039. The Time When the Network Becomes Idle (Medium)</li> <li> 2608. Shortest Cycle in a Graph (Hard)</li> <li> 815. Bus Routes (Hard)</li> </ul>"},{"location":"endlesscheng/bfs_basics/#3243-shortest-distance-after-road-addition-queries-i","title":"3243. Shortest Distance After Road Addition Queries I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, breadth first search, graph</p> </li> <li><code>n=5</code>, <code>queries = [[2,4],[0,2],[0,4]]</code></li> <li></li> <li></li> <li></li> <li>Output: <code>[3,2,1]</code></li> </ul> 3243. Shortest Distance After Road Addition Queries I - Python Solution<pre><code>from collections import deque\nfrom itertools import count\nfrom typing import List\n\n\n# BFS\ndef shortestDistanceAfterQueries(\n    n: int, queries: List[List[int]]\n) -&gt; List[int]:\n    g = [[] for _ in range(n)]\n    for i in range(n - 1):\n        g[i].append(i + 1)\n\n    vis = [-1 for _ in range(n)]\n\n    def bfs(i: int) -&gt; int:\n        q = deque([0])\n        for step in count(1):\n            tmp = q\n            q = deque()\n            for x in tmp:\n                for y in g[x]:\n                    if y == n - 1:\n                        return step\n                    if vis[y] != i:\n                        vis[y] = i\n                        q.append(y)\n        return -1\n\n    res = [0] * len(queries)\n    for i, (l, r) in enumerate(queries):\n        g[l].append(r)\n        res[i] = bfs(i)\n\n    return res\n\n\nn = 5\nqueries = [[2, 4], [0, 2], [0, 4]]\nprint(shortestDistanceAfterQueries(n, queries))  # [3, 2, 1]\n</code></pre>"},{"location":"endlesscheng/bfs_basics/#1311-get-watched-videos-by-your-friends","title":"1311. Get Watched Videos by Your Friends","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, breadth first search, graph, sorting</p> </li> </ul>"},{"location":"endlesscheng/bfs_basics/#1129-shortest-path-with-alternating-colors","title":"1129. Shortest Path with Alternating Colors","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: breadth first search, graph</p> </li> </ul> 1129. Shortest Path with Alternating Colors - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef shortestAlternatingPaths(\n    n: int, redEdges: List[List[int]], blueEdges: List[List[int]]\n) -&gt; List[int]:\n    red_graph = defaultdict(list)\n    blue_graph = defaultdict(list)\n\n    for u, v in redEdges:\n        red_graph[u].append(v)\n    for u, v in blueEdges:\n        blue_graph[u].append(v)\n\n    answer = [-1 for _ in range(n)]\n    q = deque([(0, 0, 0), (0, 0, 1)])  # (node, distance, color)\n    visited = set()\n\n    while q:\n        node, dist, color = q.popleft()\n        if (node, color) in visited:\n            continue\n        visited.add((node, color))\n        if answer[node] == -1:\n            answer[node] = dist\n        if color == 0:\n            for neighbor in blue_graph[node]:\n                q.append((neighbor, dist + 1, 1))\n        else:\n            for neighbor in red_graph[node]:\n                q.append((neighbor, dist + 1, 0))\n\n    return answer\n\n\nn = 3\nred_edges = [[0, 1], [1, 2]]\nblue_edges = []\nprint(shortestAlternatingPaths(n, red_edges, blue_edges))  # [0, 1, -1]\n</code></pre>"},{"location":"endlesscheng/bfs_basics/#1298-maximum-candies-you-can-get-from-boxes","title":"1298. Maximum Candies You Can Get from Boxes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, breadth first search, graph</p> </li> </ul>"},{"location":"endlesscheng/bfs_basics/#2039-the-time-when-the-network-becomes-idle","title":"2039. The Time When the Network Becomes Idle","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, breadth first search, graph</p> </li> </ul>"},{"location":"endlesscheng/bfs_basics/#2608-shortest-cycle-in-a-graph","title":"2608. Shortest Cycle in a Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: breadth first search, graph</p> </li> </ul>"},{"location":"endlesscheng/bfs_basics/#815-bus-routes","title":"815. Bus Routes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, breadth first search</p> </li> </ul> 815. Bus Routes - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef numBusesToDestination(\n    routes: List[List[int]], source: int, target: int\n) -&gt; int:\n    if source == target:\n        return 0\n\n    graph = defaultdict(set)  # {stop: buses}\n    for buses, route in enumerate(routes):\n        for stop in route:\n            graph[stop].add(buses)\n\n    q = deque([(source, 0)])  # (stop, bus)\n    visited_stops = set([source])\n    visited_buses = set()\n\n    while q:\n        stop, bus = q.popleft()\n\n        if stop == target:\n            return bus\n\n        for buses in graph[stop]:\n            if buses not in visited_buses:\n                visited_buses.add(buses)\n                for next_stop in routes[buses]:\n                    if next_stop not in visited_stops:\n                        visited_stops.add(next_stop)\n                        q.append((next_stop, bus + 1))\n\n    return -1\n\n\nroutes = [[1, 2, 7], [3, 6, 7]]\nsource = 1\ntarget = 6\nprint(numBusesToDestination(routes, source, target))  # 2\n</code></pre>"},{"location":"endlesscheng/binary_search_advanced/","title":"Binary Search Advanced","text":"<ul> <li> 2300. Successful Pairs of Spells and Potions (Medium)</li> <li> 1385. Find the Distance Value Between Two Arrays (Easy)</li> <li> 2389. Longest Subsequence With Limited Sum (Easy)</li> <li> 1170. Compare Strings by Frequency of the Smallest Character (Medium)</li> <li> 2080. Range Frequency Queries (Medium)</li> <li> 2563. Count the Number of Fair Pairs (Medium)</li> <li> 2070. Most Beautiful Item for Each Query (Medium)</li> <li> 981. Time Based Key-Value Store (Medium)</li> <li> 1146. Snapshot Array (Medium)</li> <li> 658. Find K Closest Elements (Medium)</li> <li> 1818. Minimum Absolute Sum Difference (Medium)</li> <li> 911. Online Election (Medium)</li> <li> 1182. Shortest Distance to Target Color (Medium)</li> <li> 2819. Minimum Relative Loss After Buying Chocolates (Hard)</li> <li> 1287. Element Appearing More Than 25% In Sorted Array (Easy)</li> <li> 1150. Check If a Number Is Majority Element in a Sorted Array (Easy)</li> </ul>"},{"location":"endlesscheng/binary_search_advanced/#2300-successful-pairs-of-spells-and-potions","title":"2300. Successful Pairs of Spells and Potions","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, sorting</p> </li> </ul> 2300. Successful Pairs of Spells and Potions - Python Solution<pre><code>import bisect\nfrom typing import List\n\n\n# Binary Search\ndef successfulPairs(\n    spells: List[int], potions: List[int], success: int\n) -&gt; List[int]:\n    potions.sort()\n    res = []\n    n = len(potions)\n\n    for spell in spells:\n        target = (success + spell - 1) // spell\n        index = bisect.bisect_left(potions, target)\n        res.append(n - index)\n\n    return res\n\n\nspells = [5, 1, 3]\npotions = [1, 2, 3, 4, 5]\nsuccess = 7\nprint(successfulPairs(spells, potions, success))  # [4, 0, 3]\n</code></pre>"},{"location":"endlesscheng/binary_search_advanced/#1385-find-the-distance-value-between-two-arrays","title":"1385. Find the Distance Value Between Two Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers, binary search, sorting</p> </li> </ul>"},{"location":"endlesscheng/binary_search_advanced/#2389-longest-subsequence-with-limited-sum","title":"2389. Longest Subsequence With Limited Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, binary search, greedy, sorting, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/binary_search_advanced/#1170-compare-strings-by-frequency-of-the-smallest-character","title":"1170. Compare Strings by Frequency of the Smallest Character","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, binary search, sorting</p> </li> </ul>"},{"location":"endlesscheng/binary_search_advanced/#2080-range-frequency-queries","title":"2080. Range Frequency Queries","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, binary search, design, segment tree</p> </li> </ul> 2080. Range Frequency Queries - Python Solution<pre><code>from bisect import bisect_left, bisect_right\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Binary Search\nclass RangeFreqQuery:\n    def __init__(self, arr: List[int]):\n        self.freq = defaultdict(list)\n        for idx, val in enumerate(arr):\n            self.freq[val].append(idx)\n\n    def query(self, left: int, right: int, value: int) -&gt; int:\n        idxs = self.freq[value]\n        return bisect_right(idxs, right) - bisect_left(idxs, left)\n\n\narr = [1, 3, 1, 2, 4, 1, 3, 2, 1]\nrfq = RangeFreqQuery(arr)\nprint(rfq.query(0, 4, 1))  # 2\nprint(rfq.query(2, 8, 1))  # 3\nprint(rfq.query(0, 8, 3))  # 2\nprint(rfq.query(4, 7, 2))  # 1\n</code></pre>"},{"location":"endlesscheng/binary_search_advanced/#2563-count-the-number-of-fair-pairs","title":"2563. Count the Number of Fair Pairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, sorting</p> </li> </ul>"},{"location":"endlesscheng/binary_search_advanced/#2070-most-beautiful-item-for-each-query","title":"2070. Most Beautiful Item for Each Query","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sorting</p> </li> </ul>"},{"location":"endlesscheng/binary_search_advanced/#981-time-based-key-value-store","title":"981. Time Based Key-Value Store","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, binary search, design</p> </li> </ul> 981. Time Based Key-Value Store - Python Solution<pre><code>from collections import defaultdict\n\n\n# Binary Search\nclass TimeMap:\n\n    def __init__(self):\n        self.keys = defaultdict(list)\n        self.times = dict()\n\n    def set(self, key: str, value: str, timestamp: int) -&gt; None:\n        self.keys[key].append(timestamp)\n        self.times[timestamp] = value\n\n    def get(self, key: str, timestamp: int) -&gt; str:\n        tmp = self.keys[key]\n\n        left, right = 0, len(tmp) - 1\n        while left &lt;= right:\n            mid = left + (right - left) // 2\n            if tmp[mid] &gt; timestamp:\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        return self.times[tmp[right]] if right &gt;= 0 else \"\"\n\n\nobj = TimeMap()\nobj.set(\"foo\", \"bar\", 1)\nprint(obj.get(\"foo\", 1))  # bar\nprint(obj.get(\"foo\", 3))  # bar\nobj.set(\"foo\", \"bar2\", 4)\nprint(obj.get(\"foo\", 4))  # bar2\nprint(obj.get(\"foo\", 5))  # bar2\n</code></pre>"},{"location":"endlesscheng/binary_search_advanced/#1146-snapshot-array","title":"1146. Snapshot Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, binary search, design</p> </li> </ul>"},{"location":"endlesscheng/binary_search_advanced/#658-find-k-closest-elements","title":"658. Find K Closest Elements","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, sliding window, sorting, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/binary_search_advanced/#1818-minimum-absolute-sum-difference","title":"1818. Minimum Absolute Sum Difference","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sorting, ordered set</p> </li> </ul>"},{"location":"endlesscheng/binary_search_advanced/#911-online-election","title":"911. Online Election","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, binary search, design</p> </li> </ul>"},{"location":"endlesscheng/binary_search_advanced/#1182-shortest-distance-to-target-color","title":"1182. Shortest Distance to Target Color","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, dynamic programming</p> </li> </ul>"},{"location":"endlesscheng/binary_search_advanced/#2819-minimum-relative-loss-after-buying-chocolates","title":"2819. Minimum Relative Loss After Buying Chocolates","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, sorting, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/binary_search_advanced/#1287-element-appearing-more-than-25-in-sorted-array","title":"1287. Element Appearing More Than 25% In Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array</p> </li> </ul> 1287. Element Appearing More Than 25% In Sorted Array - Python Solution<pre><code>from bisect import bisect_left, bisect_right\nfrom typing import List\n\n\n# Binary Search\ndef findSpecialInteger(arr: List[int]) -&gt; int:\n    n = len(arr)\n    span = n // 4 + 1\n\n    for i in range(0, n, span):\n        left = bisect_left(arr, arr[i])\n        right = bisect_right(arr, arr[i])\n        if right - left &gt;= span:\n            return arr[i]\n\n    return -1\n</code></pre>"},{"location":"endlesscheng/binary_search_advanced/#1150-check-if-a-number-is-majority-element-in-a-sorted-array","title":"1150. Check If a Number Is Majority Element in a Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"endlesscheng/binary_search_basics/","title":"Binary Search Basics","text":"<ul> <li> 34. Find First and Last Position of Element in Sorted Array (Medium)</li> <li> 35. Search Insert Position (Easy)</li> <li> 704. Binary Search (Easy)</li> <li> 744. Find Smallest Letter Greater Than Target (Easy)</li> <li> 2529. Maximum Count of Positive Integer and Negative Integer (Easy)</li> </ul>"},{"location":"endlesscheng/binary_search_basics/#34-find-first-and-last-position-of-element-in-sorted-array","title":"34. Find First and Last Position of Element in Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> <li>Find the starting and ending position of a given target value in a sorted array.</li> </ul> 34. Find First and Last Position of Element in Sorted Array - Python Solution<pre><code>from bisect import bisect_left\nfrom typing import List\n\n\n# Binary Search\ndef searchRangeBS(nums: List[int], target: int) -&gt; List[int]:\n    def bisect_left(nums, target):\n        left, right = 0, len(nums) - 1\n        while left &lt;= right:\n            mid = left + (right - left) // 2\n            if nums[mid] &lt; target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n\n    left = bisect_left(nums, target)\n    right = bisect_left(nums, target + 1) - 1\n\n    if left &lt;= right:\n        return [left, right]\n\n    return [-1, -1]\n\n\n# Bisect\ndef searchRangeBSBisect(nums: List[int], target: int) -&gt; List[int]:\n    left = bisect_left(nums, target)\n    right = bisect_left(nums, target + 1) - 1\n\n    if left &lt;= right:\n        return [left, right]\n\n    return [-1, -1]\n\n\nnums = [5, 7, 7, 8, 8, 10]\ntarget = 8\nprint(searchRangeBS(nums, target))  # [3, 4]\nprint(searchRangeBSBisect(nums, target))  # [3, 4]\n</code></pre> 34. Find First and Last Position of Element in Sorted Array - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\n  int bisect_left(vector&lt;int&gt; &amp;nums, int target)\n  {\n    int left = 0, right = (int)nums.size() - 1;\n\n    while (left &lt;= right)\n    {\n      int mid = left + (right - left) / 2;\n      if (nums[mid] &lt; target)\n      {\n        left = mid + 1;\n      }\n      else\n      {\n        right = mid - 1;\n      }\n    }\n    return left;\n  }\n\npublic:\n  vector&lt;int&gt; searchRange(vector&lt;int&gt; &amp;nums, int target)\n  {\n    int left = bisect_left(nums, target);\n    if (left == (int)nums.size() || nums[left] != target)\n    {\n      return {-1, -1};\n    }\n    int right = bisect_left(nums, target + 1) - 1;\n    return {left, right};\n  }\n};\n\nint main()\n{\n  vector&lt;int&gt; nums = {5, 7, 7, 8, 8, 10};\n  int target = 8;\n  Solution s;\n  vector&lt;int&gt; res = s.searchRange(nums, target);\n  cout &lt;&lt; res[0] &lt;&lt; \", \" &lt;&lt; res[1] &lt;&lt; endl;\n  return 0;\n}\n</code></pre>"},{"location":"endlesscheng/binary_search_basics/#35-search-insert-position","title":"35. Search Insert Position","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, binary search</p> </li> <li>Return the index of the target if it is found. If not, return the index where it would be if it were inserted in order.</li> </ul> 35. Search Insert Position - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef searchInsert(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        if nums[mid] &lt; target:\n            left = mid + 1\n        elif nums[mid] &gt; target:\n            right = mid - 1\n        else:\n            return mid\n\n    return left\n\n\nnums = [1, 3, 5, 6]\ntarget = 5\nprint(searchInsert(nums, target))  # 2\n</code></pre>"},{"location":"endlesscheng/binary_search_basics/#704-binary-search","title":"704. Binary Search","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, binary search</p> </li> <li>Implement binary search algorithm.</li> </ul> 704. Binary Search - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef search(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] &lt; target:\n            left = mid + 1\n        elif nums[mid] &gt; target:\n            right = mid - 1\n        else:\n            return mid\n\n    return -1\n\n\nnums = [-1, 0, 3, 5, 9, 12]\ntarget = 9\nprint(search(nums, target))  # 4\n</code></pre>"},{"location":"endlesscheng/binary_search_basics/#744-find-smallest-letter-greater-than-target","title":"744. Find Smallest Letter Greater Than Target","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul> 744. Find Smallest Letter Greater Than Target - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef nextGreatestLetter(letters: List[str], target: str) -&gt; str:\n    left, right = 0, len(letters)\n\n    while left &lt; right:\n        mid = left + (right - left) // 2\n        if letters[mid] &gt; target:\n            right = mid\n        else:\n            left = mid + 1\n\n    return letters[left] if left &lt; len(letters) else letters[0]\n\n\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"a\"\nprint(nextGreatestLetter(letters, target))  # c\n</code></pre>"},{"location":"endlesscheng/binary_search_basics/#2529-maximum-count-of-positive-integer-and-negative-integer","title":"2529. Maximum Count of Positive Integer and Negative Integer","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, binary search, counting</p> </li> </ul> 2529. Maximum Count of Positive Integer and Negative Integer - Python Solution<pre><code>from bisect import bisect_left, bisect_right\nfrom typing import List\n\n\n# Binary Search\ndef maximumCount(nums: List[int]) -&gt; int:\n    pos = bisect_left(nums, 0)\n    neg = len(nums) - bisect_right(nums, 0)\n\n    return max(pos, neg)\n\n\nnums = [-2, -1, -1, 1, 2, 3]\nprint(maximumCount(nums))  # 3\n</code></pre>"},{"location":"endlesscheng/binary_search_indirect_value/","title":"Binary Search Indirect Value","text":"<ul> <li> 3143. Maximum Points Inside the Square (Medium)</li> <li> 1648. Sell Diminishing-Valued Colored Balls (Medium)</li> </ul>"},{"location":"endlesscheng/binary_search_indirect_value/#3143-maximum-points-inside-the-square","title":"3143. Maximum Points Inside the Square","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, binary search, sorting</p> </li> </ul>"},{"location":"endlesscheng/binary_search_indirect_value/#1648-sell-diminishing-valued-colored-balls","title":"1648. Sell Diminishing-Valued Colored Balls","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, binary search, greedy, sorting, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/binary_search_kth_min_max/","title":"Binary Search Kth Min Max","text":"<ul> <li> 668. Kth Smallest Number in Multiplication Table (Hard)</li> <li> 378. Kth Smallest Element in a Sorted Matrix (Medium)</li> <li> 719. Find K-th Smallest Pair Distance (Hard)</li> <li> 878. Nth Magical Number (Hard)</li> <li> 1201. Ugly Number III (Medium)</li> <li> 793. Preimage Size of Factorial Zeroes Function (Hard)</li> <li> 373. Find K Pairs with Smallest Sums (Medium)</li> <li> 1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows (Hard)</li> <li> 786. K-th Smallest Prime Fraction (Medium)</li> <li> 3116. Kth Smallest Amount With Single Denomination Combination (Hard)</li> <li> 3134. Find the Median of the Uniqueness Array (Hard)</li> <li> 2040. Kth Smallest Product of Two Sorted Arrays (Hard)</li> <li> 2386. Find the K-Sum of an Array (Hard)</li> <li> 1508. Range Sum of Sorted Subarray Sums (Medium)</li> <li> 1918. Kth Smallest Subarray Sum (Medium)</li> </ul>"},{"location":"endlesscheng/binary_search_kth_min_max/#668-kth-smallest-number-in-multiplication-table","title":"668. Kth Smallest Number in Multiplication Table","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, binary search</p> </li> </ul>"},{"location":"endlesscheng/binary_search_kth_min_max/#378-kth-smallest-element-in-a-sorted-matrix","title":"378. Kth Smallest Element in a Sorted Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sorting, heap priority queue, matrix</p> </li> <li>Given an <code>n x n</code> matrix where each of the rows and columns are sorted in ascending order, return the <code>k-th</code> smallest element in the matrix.</li> </ul> 378. Kth Smallest Element in a Sorted Matrix - Python Solution<pre><code>from heapq import heapify, heappop, heappush\nfrom typing import List\n\n\n# Heap - Merge K Sorted\ndef kthSmallestHeap(matrix: List[List[int]], k: int) -&gt; int:\n    n = len(matrix)\n    heap = [(matrix[i][0], i, 0) for i in range(n)]\n    heapify(heap)\n\n    for _ in range(k - 1):\n        _, row, col = heappop(heap)\n\n        if col + 1 &lt; n:\n            heappush(heap, (matrix[row][col + 1], row, col + 1))\n\n    return heappop(heap)[0]\n\n\n# Binary Search\ndef kthSmallestBinarySearch(matrix: List[List[int]], k: int) -&gt; int:\n    n = len(matrix)\n\n    def check(mid):\n        i, j = n - 1, 0\n        num = 0\n\n        while i &gt;= 0 and j &lt; n:\n            if matrix[i][j] &lt;= mid:\n                num += i + 1\n                j += 1\n            else:\n                i -= 1\n\n        return num &gt;= k\n\n    left, right = matrix[0][0], matrix[-1][-1]\n\n    while left &lt; right:\n        mid = (left + right) // 2\n        if check(mid):\n            right = mid\n        else:\n            left = mid + 1\n\n    return left\n\n\nmatrix = [[1, 5, 9], [10, 11, 13], [12, 13, 15]]\nk = 8\n\nprint(kthSmallestHeap(matrix, k))  # 13\nprint(kthSmallestBinarySearch(matrix, k))  # 13\n</code></pre>"},{"location":"endlesscheng/binary_search_kth_min_max/#719-find-k-th-smallest-pair-distance","title":"719. Find K-th Smallest Pair Distance","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, binary search, sorting</p> </li> </ul>"},{"location":"endlesscheng/binary_search_kth_min_max/#878-nth-magical-number","title":"878. Nth Magical Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, binary search</p> </li> </ul>"},{"location":"endlesscheng/binary_search_kth_min_max/#1201-ugly-number-iii","title":"1201. Ugly Number III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, binary search, combinatorics, number theory</p> </li> </ul>"},{"location":"endlesscheng/binary_search_kth_min_max/#793-preimage-size-of-factorial-zeroes-function","title":"793. Preimage Size of Factorial Zeroes Function","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, binary search</p> </li> </ul>"},{"location":"endlesscheng/binary_search_kth_min_max/#373-find-k-pairs-with-smallest-sums","title":"373. Find K Pairs with Smallest Sums","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, heap priority queue</p> </li> </ul> 373. Find K Pairs with Smallest Sums - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Heap - Merge K Sorted\ndef kSmallestPairs(\n    nums1: List[int], nums2: List[int], k: int\n) -&gt; List[List[int]]:\n    if not nums1 or not nums2 or k &lt;= 0:\n        return []\n\n    result = []\n    min_heap = []\n\n    for j in range(min(k, len(nums2))):\n        heapq.heappush(min_heap, (nums1[0] + nums2[j], 0, j))\n\n    while k &gt; 0 and min_heap:\n        _, i, j = heapq.heappop(min_heap)\n        result.append([nums1[i], nums2[j]])\n        k -= 1\n\n        if i + 1 &lt; len(nums1):\n            heapq.heappush(min_heap, (nums1[i + 1] + nums2[j], i + 1, j))\n\n    return result\n\n\nnums1 = [1, 2, 4, 5, 6]\nnums2 = [3, 5, 7, 9]\nk = 3\nprint(kSmallestPairs(nums1, nums2, k))\n# [[1, 3], [2, 3], [1, 5]]\n</code></pre>"},{"location":"endlesscheng/binary_search_kth_min_max/#1439-find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows","title":"1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, heap priority queue, matrix</p> </li> </ul>"},{"location":"endlesscheng/binary_search_kth_min_max/#786-k-th-smallest-prime-fraction","title":"786. K-th Smallest Prime Fraction","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, sorting, heap priority queue</p> </li> </ul> 786. K-th Smallest Prime Fraction - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\ndef kthSmallestPrimeFraction(arr: List[int], k: int) -&gt; List[int]:\n    max_heap = []\n\n    for j in range(1, len(arr)):\n        for i in range(j):\n            heapq.heappush(max_heap, (-arr[i] / arr[j], arr[i], arr[j]))\n\n            if len(max_heap) &gt; k:\n                heapq.heappop(max_heap)\n\n    return [max_heap[0][1], max_heap[0][2]]\n\n\narr = [1, 2, 3, 5]\nk = 3\nprint(kthSmallestPrimeFraction(arr, k))  # [2, 5]\n</code></pre>"},{"location":"endlesscheng/binary_search_kth_min_max/#3116-kth-smallest-amount-with-single-denomination-combination","title":"3116. Kth Smallest Amount With Single Denomination Combination","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, binary search, bit manipulation, combinatorics, number theory</p> </li> </ul>"},{"location":"endlesscheng/binary_search_kth_min_max/#3134-find-the-median-of-the-uniqueness-array","title":"3134. Find the Median of the Uniqueness Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, binary search, sliding window</p> </li> </ul>"},{"location":"endlesscheng/binary_search_kth_min_max/#2040-kth-smallest-product-of-two-sorted-arrays","title":"2040. Kth Smallest Product of Two Sorted Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"endlesscheng/binary_search_kth_min_max/#2386-find-the-k-sum-of-an-array","title":"2386. Find the K-Sum of an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, sorting, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/binary_search_kth_min_max/#1508-range-sum-of-sorted-subarray-sums","title":"1508. Range Sum of Sorted Subarray Sums","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, sorting</p> </li> </ul>"},{"location":"endlesscheng/binary_search_kth_min_max/#1918-kth-smallest-subarray-sum","title":"1918. Kth Smallest Subarray Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sliding window</p> </li> </ul>"},{"location":"endlesscheng/binary_search_max_answer/","title":"Binary Search Max Answer","text":"<ul> <li> 275. H-Index II (Medium)</li> <li> 2226. Maximum Candies Allocated to K Children (Medium)</li> <li> 2982. Find Longest Special Substring That Occurs Thrice II (Medium)</li> <li> 2576. Find the Maximum Number of Marked Indices (Medium)</li> <li> 1898. Maximum Number of Removable Characters (Medium)</li> <li> 1802. Maximum Value at a Given Index in a Bounded Array (Medium)</li> <li> 1642. Furthest Building You Can Reach (Medium)</li> <li> 2861. Maximum Number of Alloys (Medium)</li> <li> 3007. Maximum Number That Sum of the Prices Is Less Than or Equal to K (Medium)</li> <li> 2141. Maximum Running Time of N Computers (Hard)</li> <li> 2258. Escape the Spreading Fire (Hard)</li> <li> 2071. Maximum Number of Tasks You Can Assign (Hard)</li> <li> 1618. Maximum Font to Fit a Sentence in a Screen (Medium)</li> <li> 1891. Cutting Ribbons (Medium)</li> <li> 2137. Pour Water Between Buckets to Make Water Levels Equal (Medium)</li> <li> 644. Maximum Average Subarray II (Hard)</li> </ul>"},{"location":"endlesscheng/binary_search_max_answer/#275-h-index-ii","title":"275. H-Index II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"endlesscheng/binary_search_max_answer/#2226-maximum-candies-allocated-to-k-children","title":"2226. Maximum Candies Allocated to K Children","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"endlesscheng/binary_search_max_answer/#2982-find-longest-special-substring-that-occurs-thrice-ii","title":"2982. Find Longest Special Substring That Occurs Thrice II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, binary search, sliding window, counting</p> </li> </ul>"},{"location":"endlesscheng/binary_search_max_answer/#2576-find-the-maximum-number-of-marked-indices","title":"2576. Find the Maximum Number of Marked Indices","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, greedy, sorting</p> </li> </ul> 2576. Find the Maximum Number of Marked Indices - Python Solution<pre><code>from typing import List\n\n\n# Fast Slow Pointers\ndef maxNumOfMarkedIndices(nums: List[int]) -&gt; int:\n    nums.sort()\n    n = len(nums)\n    slow, fast = 0, n // 2\n    count = 0\n\n    while slow &lt; n // 2 and fast &lt; n:\n        if nums[fast] &gt;= 2 * nums[slow]:\n            count += 2\n            slow += 1\n        fast += 1\n\n    return count\n\n\nnums = [3, 5, 2, 4]\nprint(maxNumOfMarkedIndices(nums))  # 2\n</code></pre>"},{"location":"endlesscheng/binary_search_max_answer/#1898-maximum-number-of-removable-characters","title":"1898. Maximum Number of Removable Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, string, binary search</p> </li> </ul>"},{"location":"endlesscheng/binary_search_max_answer/#1802-maximum-value-at-a-given-index-in-a-bounded-array","title":"1802. Maximum Value at a Given Index in a Bounded Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: binary search, greedy</p> </li> </ul>"},{"location":"endlesscheng/binary_search_max_answer/#1642-furthest-building-you-can-reach","title":"1642. Furthest Building You Can Reach","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/binary_search_max_answer/#2861-maximum-number-of-alloys","title":"2861. Maximum Number of Alloys","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"endlesscheng/binary_search_max_answer/#3007-maximum-number-that-sum-of-the-prices-is-less-than-or-equal-to-k","title":"3007. Maximum Number That Sum of the Prices Is Less Than or Equal to K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: binary search, dynamic programming, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/binary_search_max_answer/#2141-maximum-running-time-of-n-computers","title":"2141. Maximum Running Time of N Computers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/binary_search_max_answer/#2258-escape-the-spreading-fire","title":"2258. Escape the Spreading Fire","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, breadth first search, matrix</p> </li> </ul>"},{"location":"endlesscheng/binary_search_max_answer/#2071-maximum-number-of-tasks-you-can-assign","title":"2071. Maximum Number of Tasks You Can Assign","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, greedy, queue, sorting, monotonic queue</p> </li> </ul>"},{"location":"endlesscheng/binary_search_max_answer/#1618-maximum-font-to-fit-a-sentence-in-a-screen","title":"1618. Maximum Font to Fit a Sentence in a Screen","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, binary search, interactive</p> </li> </ul>"},{"location":"endlesscheng/binary_search_max_answer/#1891-cutting-ribbons","title":"1891. Cutting Ribbons","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"endlesscheng/binary_search_max_answer/#2137-pour-water-between-buckets-to-make-water-levels-equal","title":"2137. Pour Water Between Buckets to Make Water Levels Equal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"endlesscheng/binary_search_max_answer/#644-maximum-average-subarray-ii","title":"644. Maximum Average Subarray II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/binary_search_maximize_min/","title":"Binary Search Maximize Min","text":"<ul> <li> 3281. Maximize Score of Numbers in Ranges (Medium)</li> <li> 2517. Maximum Tastiness of Candy Basket (Medium)</li> <li> 1552. Magnetic Force Between Two Balls (Medium)</li> <li> 2812. Find the Safest Path in a Grid (Medium)</li> <li> 2528. Maximize the Minimum Powered City (Hard)</li> <li> 3449. Maximize the Minimum Game Score (Hard)</li> <li> 1102. Path With Maximum Minimum Value (Medium)</li> <li> 1231. Divide Chocolate (Hard)</li> </ul>"},{"location":"endlesscheng/binary_search_maximize_min/#3281-maximize-score-of-numbers-in-ranges","title":"3281. Maximize Score of Numbers in Ranges","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/binary_search_maximize_min/#2517-maximum-tastiness-of-candy-basket","title":"2517. Maximum Tastiness of Candy Basket","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/binary_search_maximize_min/#1552-magnetic-force-between-two-balls","title":"1552. Magnetic Force Between Two Balls","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sorting</p> </li> </ul>"},{"location":"endlesscheng/binary_search_maximize_min/#2812-find-the-safest-path-in-a-grid","title":"2812. Find the Safest Path in a Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, breadth first search, union find, heap priority queue, matrix</p> </li> </ul>"},{"location":"endlesscheng/binary_search_maximize_min/#2528-maximize-the-minimum-powered-city","title":"2528. Maximize the Minimum Powered City","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, greedy, queue, sliding window, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/binary_search_maximize_min/#3449-maximize-the-minimum-game-score","title":"3449. Maximize the Minimum Game Score","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, greedy</p> </li> </ul>"},{"location":"endlesscheng/binary_search_maximize_min/#1102-path-with-maximum-minimum-value","title":"1102. Path With Maximum Minimum Value","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, depth first search, breadth first search, union find, heap priority queue, matrix</p> </li> </ul>"},{"location":"endlesscheng/binary_search_maximize_min/#1231-divide-chocolate","title":"1231. Divide Chocolate","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"endlesscheng/binary_search_min_answer/","title":"Binary Search Min Answer","text":"<ul> <li> 1283. Find the Smallest Divisor Given a Threshold (Medium)</li> <li> 2187. Minimum Time to Complete Trips (Medium)</li> <li> 1870. Minimum Speed to Arrive on Time (Medium)</li> <li> 1011. Capacity To Ship Packages Within D Days (Medium)</li> <li> 875. Koko Eating Bananas (Medium)</li> <li> 3296. Minimum Number of Seconds to Make Mountain Height Zero (Medium)</li> <li> 475. Heaters (Medium)</li> <li> 2594. Minimum Time to Repair Cars (Medium)</li> <li> 1482. Minimum Number of Days to Make m Bouquets (Medium)</li> <li> 3048. Earliest Second to Mark Indices I (Medium)</li> <li> 2604. Minimum Time to Eat All Grains (Hard)</li> <li> 2702. Minimum Operations to Make Numbers Non-positive (Hard)</li> <li> 3453. Separate Squares I (Medium)</li> </ul>"},{"location":"endlesscheng/binary_search_min_answer/#1283-find-the-smallest-divisor-given-a-threshold","title":"1283. Find the Smallest Divisor Given a Threshold","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"endlesscheng/binary_search_min_answer/#2187-minimum-time-to-complete-trips","title":"2187. Minimum Time to Complete Trips","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"endlesscheng/binary_search_min_answer/#1870-minimum-speed-to-arrive-on-time","title":"1870. Minimum Speed to Arrive on Time","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul> 1870. Minimum Speed to Arrive on Time - Python Solution<pre><code>import math\nfrom typing import List\n\n\n# Binary Search\ndef minSpeedOnTime(dist: List[int], hour: float) -&gt; int:\n    if hour &lt; len(dist) - 1:\n        return -1\n\n    def time_needed(speed):\n        total_time = 0\n        for i in range(len(dist) - 1):\n            total_time += math.ceil(dist[i] / speed)\n        total_time += dist[-1] / speed\n        return total_time\n\n    left, right = 1, 10**7\n    result = -1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        if time_needed(mid) &lt;= hour:\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return result\n\n\ndist = [1, 3, 2]\nhour = 6\nprint(minSpeedOnTime(dist, hour))  # 1\n</code></pre>"},{"location":"endlesscheng/binary_search_min_answer/#1011-capacity-to-ship-packages-within-d-days","title":"1011. Capacity To Ship Packages Within D Days","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> <li>A conveyor belt has packages that must be shipped from one port to another within <code>D</code> days. The <code>i-th</code> package has a weight of <code>weights[i]</code>. Each day, we load the ship with packages on the conveyor belt. The ship will be loaded with packages up to its capacity. The ship will not be loaded beyond its capacity. Return the least weight capacity of the ship.</li> </ul> 1011. Capacity To Ship Packages Within D Days - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef shipWithinDays(weights: List[int], days: int) -&gt; int:\n\n    def canShip(weights, D, capacity):\n        days = 1\n        current_weight = 0\n\n        for weight in weights:\n            if current_weight + weight &gt; capacity:\n                days += 1\n                current_weight = 0\n            current_weight += weight\n\n        return days &lt;= D\n\n    left, right = max(weights), sum(weights)\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if canShip(weights, days, mid):\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return left\n\n\nweights = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\ndays = 5\nprint(shipWithinDays(weights, days))  # 15\n</code></pre>"},{"location":"endlesscheng/binary_search_min_answer/#875-koko-eating-bananas","title":"875. Koko Eating Bananas","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> <li>Koko loves to eat bananas. She wants to eat all the bananas within <code>H</code> hours. Each pile has a number of bananas. The <code>i-th</code> pile has <code>piles[i]</code> bananas. Return the minimum integer <code>K</code> such that she can eat all the bananas within <code>H</code> hours.</li> </ul> 875. Koko Eating Bananas - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef minEatingSpeed(piles: List[int], h: int) -&gt; int:\n    def canEat(piles, k, h):\n        hours = 0\n        for pile in piles:\n            hours += (pile + k - 1) // k\n        return hours &lt;= h\n\n    left, right = 1, max(piles)\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if canEat(piles, mid, h):\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return left\n\n\npiles = [3, 6, 7, 11]\nh = 8\nprint(minEatingSpeed(piles, h))  # 4\n</code></pre>"},{"location":"endlesscheng/binary_search_min_answer/#3296-minimum-number-of-seconds-to-make-mountain-height-zero","title":"3296. Minimum Number of Seconds to Make Mountain Height Zero","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, binary search, greedy, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/binary_search_min_answer/#475-heaters","title":"475. Heaters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, sorting</p> </li> </ul>"},{"location":"endlesscheng/binary_search_min_answer/#2594-minimum-time-to-repair-cars","title":"2594. Minimum Time to Repair Cars","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"endlesscheng/binary_search_min_answer/#1482-minimum-number-of-days-to-make-m-bouquets","title":"1482. Minimum Number of Days to Make m Bouquets","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"endlesscheng/binary_search_min_answer/#3048-earliest-second-to-mark-indices-i","title":"3048. Earliest Second to Mark Indices I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"endlesscheng/binary_search_min_answer/#2604-minimum-time-to-eat-all-grains","title":"2604. Minimum Time to Eat All Grains","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, binary search, sorting</p> </li> </ul>"},{"location":"endlesscheng/binary_search_min_answer/#2702-minimum-operations-to-make-numbers-non-positive","title":"2702. Minimum Operations to Make Numbers Non-positive","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"endlesscheng/binary_search_min_answer/#3453-separate-squares-i","title":"3453. Separate Squares I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"endlesscheng/binary_search_minimize_max/","title":"Binary Search Minimize Max","text":"<ul> <li> 410. Split Array Largest Sum (Hard)</li> <li> 2064. Minimized Maximum of Products Distributed to Any Store (Medium)</li> <li> 1760. Minimum Limit of Balls in a Bag (Medium)</li> <li> 1631. Path With Minimum Effort (Medium)</li> <li> 2439. Minimize Maximum of Array (Medium)</li> <li> 2560. House Robber IV (Medium)</li> <li> 778. Swim in Rising Water (Hard)</li> <li> 2616. Minimize the Maximum Difference of Pairs (Medium)</li> <li> 3419. Minimize the Maximum Edge Weight of Graph (Medium)</li> <li> 2513. Minimize the Maximum of Two Arrays (Medium)</li> <li> 3399. Smallest Substring With Identical Characters II (Hard)</li> <li> 774. Minimize Max Distance to Gas Station (Hard)</li> </ul>"},{"location":"endlesscheng/binary_search_minimize_max/#410-split-array-largest-sum","title":"410. Split Array Largest Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, dynamic programming, greedy, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/binary_search_minimize_max/#2064-minimized-maximum-of-products-distributed-to-any-store","title":"2064. Minimized Maximum of Products Distributed to Any Store","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, greedy</p> </li> </ul>"},{"location":"endlesscheng/binary_search_minimize_max/#1760-minimum-limit-of-balls-in-a-bag","title":"1760. Minimum Limit of Balls in a Bag","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"endlesscheng/binary_search_minimize_max/#1631-path-with-minimum-effort","title":"1631. Path With Minimum Effort","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, depth first search, breadth first search, union find, heap priority queue, matrix</p> </li> <li>Return the minimum effort required to travel from the top-left to the bottom-right corner.</li> </ul> 1631. Path With Minimum Effort - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Prim\ndef minimumEffortPath(heights: List[List[int]]) -&gt; int:\n    m, n = len(heights), len(heights[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * n for _ in range(m)]\n    heap = [(0, 0, 0)]  # (effort, row, col)\n\n    while heap:\n        effort, r, c = heapq.heappop(heap)\n\n        if visited[r][c]:\n            continue\n\n        if r == m - 1 and c == n - 1:\n            return effort\n\n        visited[r][c] = True\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and not visited[nr][nc]:\n                updated = max(effort, abs(heights[r][c] - heights[nr][nc]))\n                heapq.heappush(heap, (updated, nr, nc))\n\n    return -1\n\n\nheights = [[1, 2, 2], [3, 8, 2], [5, 3, 5]]\nprint(minimumEffortPath(heights))  # 2\n</code></pre>"},{"location":"endlesscheng/binary_search_minimize_max/#2439-minimize-maximum-of-array","title":"2439. Minimize Maximum of Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, dynamic programming, greedy, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/binary_search_minimize_max/#2560-house-robber-iv","title":"2560. House Robber IV","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"endlesscheng/binary_search_minimize_max/#778-swim-in-rising-water","title":"778. Swim in Rising Water","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, depth first search, breadth first search, union find, heap priority queue, matrix</p> </li> <li>Return the minimum time when you can reach the target.</li> </ul> <p></p> 778. Swim in Rising Water - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra's\ndef swimInWater(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    visited = set()\n    minHeap = [(grid[0][0], 0, 0)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    visited.add((0, 0))\n\n    while minHeap:\n        time, r, c = heapq.heappop(minHeap)\n\n        if r == n - 1 and c == n - 1:\n            return time\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if nr in range(n) and nc in range(n) and (nr, nc) not in visited:\n                visited.add((nr, nc))\n                heapq.heappush(minHeap, (max(time, grid[nr][nc]), nr, nc))\n\n\ngrid = [\n    [0, 1, 2, 3, 4],\n    [24, 23, 22, 21, 5],\n    [12, 13, 14, 15, 16],\n    [11, 17, 18, 19, 20],\n    [10, 9, 8, 7, 6],\n]\nprint(swimInWater(grid))  # 16\n</code></pre>"},{"location":"endlesscheng/binary_search_minimize_max/#2616-minimize-the-maximum-difference-of-pairs","title":"2616. Minimize the Maximum Difference of Pairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, greedy</p> </li> </ul>"},{"location":"endlesscheng/binary_search_minimize_max/#3419-minimize-the-maximum-edge-weight-of-graph","title":"3419. Minimize the Maximum Edge Weight of Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: binary search, depth first search, breadth first search, graph, shortest path</p> </li> </ul>"},{"location":"endlesscheng/binary_search_minimize_max/#2513-minimize-the-maximum-of-two-arrays","title":"2513. Minimize the Maximum of Two Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, binary search, number theory</p> </li> </ul>"},{"location":"endlesscheng/binary_search_minimize_max/#3399-smallest-substring-with-identical-characters-ii","title":"3399. Smallest Substring With Identical Characters II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, binary search</p> </li> </ul>"},{"location":"endlesscheng/binary_search_minimize_max/#774-minimize-max-distance-to-gas-station","title":"774. Minimize Max Distance to Gas Station","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"endlesscheng/binary_search_others/","title":"Binary Search Others","text":"<ul> <li> 69. Sqrt(x) (Easy)</li> <li> 74. Search a 2D Matrix (Medium)</li> <li> 240. Search a 2D Matrix II (Medium)</li> <li> 2476. Closest Nodes Queries in a Binary Search Tree (Medium)</li> <li> 278. First Bad Version (Easy)</li> <li> 374. Guess Number Higher or Lower (Easy)</li> <li> 162. Find Peak Element (Medium)</li> <li> 1901. Find a Peak Element II (Medium)</li> <li> 852. Peak Index in a Mountain Array (Medium)</li> <li> 1095. Find in Mountain Array (Hard)</li> <li> 153. Find Minimum in Rotated Sorted Array (Medium)</li> <li> 154. Find Minimum in Rotated Sorted Array II (Hard)</li> <li> 33. Search in Rotated Sorted Array (Medium)</li> <li> 81. Search in Rotated Sorted Array II (Medium)</li> <li> 222. Count Complete Tree Nodes (Easy)</li> <li> 1539. Kth Missing Positive Number (Easy)</li> <li> 540. Single Element in a Sorted Array (Medium)</li> <li> 4. Median of Two Sorted Arrays (Hard)</li> <li> 1064. Fixed Point (Easy)</li> <li> 702. Search in a Sorted Array of Unknown Size (Medium)</li> <li> 2936. Number of Equal Numbers Blocks (Medium)</li> <li> 1060. Missing Element in Sorted Array (Medium)</li> <li> 1198. Find Smallest Common Element in All Rows (Medium)</li> <li> 1428. Leftmost Column with at Least a One (Medium)</li> <li> 1533. Find the Index of the Large Integer (Medium)</li> <li> 2387. Median of a Row Wise Sorted Matrix (Medium)</li> <li> 302. Smallest Rectangle Enclosing Black Pixels (Hard)</li> </ul>"},{"location":"endlesscheng/binary_search_others/#69-sqrtx","title":"69. Sqrt(x)","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, binary search</p> </li> </ul> 69. Sqrt(x) - Python Solution<pre><code># Left Right Pointers\ndef mySqrt(x: int) -&gt; int:\n    \"\"\"Returns the square root of a number.\"\"\"\n    if x &lt; 2:\n        return x\n\n    left, right = 0, x // 2\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        if mid * mid &lt;= x &lt; (mid + 1) * (mid + 1):\n            return mid\n        elif mid * mid &lt; x:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n\nx = 8\nprint(mySqrt(x))  # 2\n</code></pre>"},{"location":"endlesscheng/binary_search_others/#74-search-a-2d-matrix","title":"74. Search a 2D Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, matrix</p> </li> </ul> 74. Search a 2D Matrix - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef searchMatrix(matrix: List[List[int]], target: int) -&gt; bool:\n    if not matrix or not matrix[0]:\n        return False\n\n    m, n = len(matrix), len(matrix[0])\n    left, right = 0, m * n - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        mid_value = matrix[mid // n][mid % n]\n\n        if mid_value == target:\n            return True\n        elif mid_value &lt; target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\n\nmatrix = [[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]]\ntarget = 3\nprint(searchMatrix(matrix, target))  # True\n</code></pre>"},{"location":"endlesscheng/binary_search_others/#240-search-a-2d-matrix-ii","title":"240. Search a 2D Matrix II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, divide and conquer, matrix</p> </li> </ul>"},{"location":"endlesscheng/binary_search_others/#2476-closest-nodes-queries-in-a-binary-search-tree","title":"2476. Closest Nodes Queries in a Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, tree, depth first search, binary search tree, binary tree</p> </li> </ul>"},{"location":"endlesscheng/binary_search_others/#278-first-bad-version","title":"278. First Bad Version","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: binary search, interactive</p> </li> <li>Find the first bad version given a function <code>isBadVersion</code>.</li> </ul> 278. First Bad Version - Python Solution<pre><code># Binary Search\ndef firstBadVersion(n: int) -&gt; int:\n    left, right = 1, n\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if isBadVersion(mid):\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return left\n\n\ndef isBadVersion(version: int) -&gt; bool:\n    pass\n</code></pre>"},{"location":"endlesscheng/binary_search_others/#374-guess-number-higher-or-lower","title":"374. Guess Number Higher or Lower","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: binary search, interactive</p> </li> </ul>"},{"location":"endlesscheng/binary_search_others/#162-find-peak-element","title":"162. Find Peak Element","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"endlesscheng/binary_search_others/#1901-find-a-peak-element-ii","title":"1901. Find a Peak Element II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, matrix</p> </li> </ul>"},{"location":"endlesscheng/binary_search_others/#852-peak-index-in-a-mountain-array","title":"852. Peak Index in a Mountain Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"endlesscheng/binary_search_others/#1095-find-in-mountain-array","title":"1095. Find in Mountain Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, interactive</p> </li> </ul>"},{"location":"endlesscheng/binary_search_others/#153-find-minimum-in-rotated-sorted-array","title":"153. Find Minimum in Rotated Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul> 153. Find Minimum in Rotated Sorted Array - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef findMin(nums: List[int]) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt; right:\n        mid = left + (right - left) // 2\n        if nums[mid] &gt; nums[right]:\n            left = mid + 1\n        else:\n            right = mid\n\n    return nums[right]\n\n\nnums = [4, 5, 6, 7, 0, 1, 2]\nprint(findMin(nums))  # 0\n</code></pre>"},{"location":"endlesscheng/binary_search_others/#154-find-minimum-in-rotated-sorted-array-ii","title":"154. Find Minimum in Rotated Sorted Array II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"endlesscheng/binary_search_others/#33-search-in-rotated-sorted-array","title":"33. Search in Rotated Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul> 33. Search in Rotated Sorted Array - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef search(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] == target:\n            return mid\n\n        if nums[left] &lt;= nums[mid]:\n            if nums[left] &lt;= target &lt; nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if nums[mid] &lt; target &lt;= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n    return -1\n\n\nnums = [4, 5, 6, 7, 0, 1, 2]\ntarget = 0\nprint(search(nums, target))  # 4\n</code></pre>"},{"location":"endlesscheng/binary_search_others/#81-search-in-rotated-sorted-array-ii","title":"81. Search in Rotated Sorted Array II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"endlesscheng/binary_search_others/#222-count-complete-tree-nodes","title":"222. Count Complete Tree Nodes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: binary search, bit manipulation, tree, binary tree</p> </li> </ul> 222. Count Complete Tree Nodes - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef countNodesRecursive(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    num = 1 + countNodesRecursive(root.left) + countNodesRecursive(root.right)\n\n    return num\n\n\n# Iterative\ndef countNodesIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n    count = 0\n\n    while q:\n        n = len(q)\n\n        for _ in range(n):\n            node = q.popleft()\n            count += 1\n\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return count\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Recursive  |  O(n)  |  O(n)   |\n# | Iterative  |  O(n)  |  O(n)   |\n# |------------|--------|---------|\n\nroot = [1, 2, 3, 4, 5, 6]\nroot = build(root)\nprint(root)\n#     __1__\n#    /     \\\n#   2       3\n#  / \\     /\n# 4   5   6\nprint(countNodesRecursive(root))  # 6\nprint(countNodesIterative(root))  # 6\n</code></pre>"},{"location":"endlesscheng/binary_search_others/#1539-kth-missing-positive-number","title":"1539. Kth Missing Positive Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"endlesscheng/binary_search_others/#540-single-element-in-a-sorted-array","title":"540. Single Element in a Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"endlesscheng/binary_search_others/#4-median-of-two-sorted-arrays","title":"4. Median of Two Sorted Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, divide and conquer</p> </li> </ul> 4. Median of Two Sorted Arrays - Python Solution<pre><code>from typing import List\n\n\n# Brute Force\ndef findMedianSortedArraysBF(nums1: List[int], nums2: List[int]) -&gt; float:\n    nums = sorted(nums1 + nums2)\n    n = len(nums)\n    if n % 2 == 0:\n        return (nums[n // 2 - 1] + nums[n // 2]) / 2\n    else:\n        return nums[n // 2]\n\n\n# Binary Search\ndef findMedianSortedArraysBS(nums1: List[int], nums2: List[int]) -&gt; float:\n    if len(nums1) &gt; len(nums2):\n        nums1, nums2 = nums2, nums1\n\n    m, n = len(nums1), len(nums2)\n    imin, imax, half_len = 0, m, (m + n + 1) // 2\n\n    while imin &lt;= imax:\n        i = (imin + imax) // 2\n        j = half_len - i\n\n        if i &lt; m and nums2[j - 1] &gt; nums1[i]:\n            imin = i + 1\n        elif i &gt; 0 and nums1[i - 1] &gt; nums2[j]:\n            imax = i - 1\n        else:\n            if i == 0:\n                max_of_left = nums2[j - 1]\n            elif j == 0:\n                max_of_left = nums1[i - 1]\n            else:\n                max_of_left = max(nums1[i - 1], nums2[j - 1])\n\n            if (m + n) % 2 == 1:\n                return max_of_left\n\n            if i == m:\n                min_of_right = nums2[j]\n            elif j == n:\n                min_of_right = nums1[i]\n            else:\n                min_of_right = min(nums1[i], nums2[j])\n\n            return (max_of_left + min_of_right) / 2\n\n\n# |--------------|-----------------|--------------|\n# | Approach     | Time            | Space        |\n# |--------------|-----------------|--------------|\n# | Brute Force  | O((n+m)log(n+m))| O(n+m)       |\n# | Binary Search| O(log(min(n,m)))| O(1)         |\n# |--------------|-----------------|--------------|\n\n\nnums1 = [1, 3]\nnums2 = [2]\nprint(findMedianSortedArraysBF(nums1, nums2))  # 2.0\nprint(findMedianSortedArraysBS(nums1, nums2))  # 2.0\n</code></pre>"},{"location":"endlesscheng/binary_search_others/#1064-fixed-point","title":"1064. Fixed Point","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"endlesscheng/binary_search_others/#702-search-in-a-sorted-array-of-unknown-size","title":"702. Search in a Sorted Array of Unknown Size","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, interactive</p> </li> </ul>"},{"location":"endlesscheng/binary_search_others/#2936-number-of-equal-numbers-blocks","title":"2936. Number of Equal Numbers Blocks","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, interactive</p> </li> </ul>"},{"location":"endlesscheng/binary_search_others/#1060-missing-element-in-sorted-array","title":"1060. Missing Element in Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"endlesscheng/binary_search_others/#1198-find-smallest-common-element-in-all-rows","title":"1198. Find Smallest Common Element in All Rows","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, binary search, matrix, counting</p> </li> </ul>"},{"location":"endlesscheng/binary_search_others/#1428-leftmost-column-with-at-least-a-one","title":"1428. Leftmost Column with at Least a One","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, matrix, interactive</p> </li> </ul>"},{"location":"endlesscheng/binary_search_others/#1533-find-the-index-of-the-large-integer","title":"1533. Find the Index of the Large Integer","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, interactive</p> </li> </ul>"},{"location":"endlesscheng/binary_search_others/#2387-median-of-a-row-wise-sorted-matrix","title":"2387. Median of a Row Wise Sorted Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, matrix</p> </li> </ul>"},{"location":"endlesscheng/binary_search_others/#302-smallest-rectangle-enclosing-black-pixels","title":"302. Smallest Rectangle Enclosing Black Pixels","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, depth first search, breadth first search, matrix</p> </li> </ul>"},{"location":"endlesscheng/bipartite_graph_coloring/","title":"Bipartite Graph Coloring","text":"<ul> <li> 785. Is Graph Bipartite? (Medium)</li> <li> 886. Possible Bipartition (Medium)</li> </ul>"},{"location":"endlesscheng/bipartite_graph_coloring/#785-is-graph-bipartite","title":"785. Is Graph Bipartite?","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> <li>Determine if a graph is bipartite.</li> </ul> <p>How to group</p> Uncolored Color 1 Color 2 Operation Method 1 -1 0 1 <code>1 - color</code> Method 2 0 1 -1 <code>-color</code> 785. Is Graph Bipartite? - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef isBipartiteBFS(graph: List[List[int]]) -&gt; bool:\n    n = len(graph)\n    # -1: not colored; 0: blue; 1: red\n    color = [-1 for _ in range(n)]\n\n    def bfs(node):\n        q = deque([node])\n        color[node] = 0\n\n        while q:\n            cur = q.popleft()\n\n            for neighbor in graph[cur]:\n                if color[neighbor] == -1:\n                    color[neighbor] = 1 - color[cur]\n                    q.append(neighbor)\n                elif color[neighbor] == color[cur]:\n                    return False\n        return True\n\n    for i in range(n):\n        if color[i] == -1:\n            if not bfs(i):\n                return False\n\n    return True\n\n\n# DFS\ndef isBipartiteDFS(graph: List[List[int]]) -&gt; bool:\n    n = len(graph)\n    # -1: not colored; 0: blue; 1: red\n    color = [-1] * n\n\n    def dfs(node, c):\n        color[node] = c\n        for neighbor in graph[node]:\n            if color[neighbor] == -1:\n                if not dfs(neighbor, 1 - c):\n                    return False\n            elif color[neighbor] == c:\n                return False\n        return True\n\n    for i in range(n):\n        if color[i] == -1:\n            if not dfs(i, 0):\n                return False\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |    BFS     | O(V+E) |  O(V)   |\n# |    DFS     | O(V+E) |  O(V)   |\n# |------------|--------|---------|\n\n\ngraph = [[1, 2, 3], [0, 2], [0, 1, 3], [0, 2]]\nprint(isBipartiteBFS(graph))  # False\nprint(isBipartiteDFS(graph))  # False\n</code></pre>"},{"location":"endlesscheng/bipartite_graph_coloring/#886-possible-bipartition","title":"886. Possible Bipartition","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> <li>Determine if a graph can be divided into two groups such that no two nodes of the same group are connected.</li> </ul> 886. Possible Bipartition - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef possibleBipartitionBFS(n: int, dislikes: List[List[int]]) -&gt; bool:\n    group = {i: -1 for i in range(1, n + 1)}\n\n    # Undirected graph\n    graph = {i: [] for i in range(1, n + 1)}\n    for i, j in dislikes:\n        graph[i].append(j)\n        graph[j].append(i)\n\n    def bfs(person):\n        q = deque([person])\n        group[person] = 0\n\n        while q:\n            cur = q.popleft()\n\n            for neighbor in graph[cur]:\n                if group[neighbor] == -1:\n                    group[neighbor] = 1 - group[cur]\n                    q.append(neighbor)\n                elif group[neighbor] == group[cur]:\n                    return False\n        return True\n\n    for i in range(1, n + 1):\n        if group[i] == -1:\n            if not bfs(i):\n                return False\n    return True\n\n\n# DFS\ndef possibleBipartitionDFS(n: int, dislikes: List[List[int]]) -&gt; bool:\n    group = {i: -1 for i in range(1, n + 1)}\n    graph = {i: [] for i in range(1, n + 1)}\n    for i, j in dislikes:\n        graph[i].append(j)\n        graph[j].append(i)\n\n    def dfs(person, g):\n        group[person] = g\n\n        for neighbor in graph[person]:\n            if group[neighbor] == -1:\n                if not dfs(neighbor, 1 - g):\n                    return False\n            elif group[neighbor] == g:\n                return False\n\n        return True\n\n    for i in range(1, n + 1):\n        if group[i] == -1:\n            if not dfs(i, 0):\n                return False\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |    BFS     | O(V+E) |  O(V+E) |\n# |    DFS     | O(V+E) |  O(V+E) |\n# |------------|--------|---------|\n\n\nn = 4\ndislikes = [[1, 2], [1, 3], [2, 4]]\nprint(possibleBipartitionBFS(n, dislikes))  # True\nprint(possibleBipartitionDFS(n, dislikes))  # True\n</code></pre>"},{"location":"endlesscheng/bit_and_or/","title":"Bit AND OR","text":"<ul> <li> 2980. Check if Bitwise OR Has Trailing Zeros (Easy)</li> <li> 1318. Minimum Flips to Make a OR b Equal to c (Medium)</li> <li> 2419. Longest Subarray With Maximum Bitwise AND (Medium)</li> <li> 2871. Split Array Into Maximum Number of Subarrays (Medium)</li> <li> 2401. Longest Nice Subarray (Medium)</li> <li> 2680. Maximum OR (Medium)</li> <li> 3133. Minimum Array End (Medium)</li> <li> 3108. Minimum Cost Walk in Weighted Graph (Hard)</li> <li> 3117. Minimum Sum of Values by Dividing Array (Hard)</li> <li> 3125. Maximum Number That Makes Result of Bitwise AND Zero (Medium)</li> </ul>"},{"location":"endlesscheng/bit_and_or/#2980-check-if-bitwise-or-has-trailing-zeros","title":"2980. Check if Bitwise OR Has Trailing Zeros","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_and_or/#1318-minimum-flips-to-make-a-or-b-equal-to-c","title":"1318. Minimum Flips to Make a OR b Equal to c","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_and_or/#2419-longest-subarray-with-maximum-bitwise-and","title":"2419. Longest Subarray With Maximum Bitwise AND","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation, brainteaser</p> </li> </ul>"},{"location":"endlesscheng/bit_and_or/#2871-split-array-into-maximum-number-of-subarrays","title":"2871. Split Array Into Maximum Number of Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_and_or/#2401-longest-nice-subarray","title":"2401. Longest Nice Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation, sliding window</p> </li> </ul>"},{"location":"endlesscheng/bit_and_or/#2680-maximum-or","title":"2680. Maximum OR","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, bit manipulation, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/bit_and_or/#3133-minimum-array-end","title":"3133. Minimum Array End","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_and_or/#3108-minimum-cost-walk-in-weighted-graph","title":"3108. Minimum Cost Walk in Weighted Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, bit manipulation, union find, graph</p> </li> </ul>"},{"location":"endlesscheng/bit_and_or/#3117-minimum-sum-of-values-by-dividing-array","title":"3117. Minimum Sum of Values by Dividing Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, dynamic programming, bit manipulation, segment tree, queue</p> </li> </ul>"},{"location":"endlesscheng/bit_and_or/#3125-maximum-number-that-makes-result-of-bitwise-and-zero","title":"3125. Maximum Number That Makes Result of Bitwise AND Zero","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/bit_basics/","title":"Bit Basics","text":"<ul> <li> 3370. Smallest Number With All Set Bits (Easy)</li> <li> 3226. Number of Bit Changes to Make Two Integers Equal (Easy)</li> <li> 1356. Sort Integers by The Number of 1 Bits (Easy)</li> <li> 461. Hamming Distance (Easy)</li> <li> 2220. Minimum Bit Flips to Convert Number (Easy)</li> <li> 476. Number Complement (Easy)</li> <li> 1009. Complement of Base 10 Integer (Easy)</li> <li> 868. Binary Gap (Easy)</li> <li> 3211. Generate Binary Strings Without Adjacent Zeros (Medium)</li> <li> 2917. Find the K-or of an Array (Easy)</li> <li> 693. Binary Number with Alternating Bits (Easy)</li> <li> 2657. Find the Prefix Common Array of Two Arrays (Medium)</li> <li> 231. Power of Two (Easy)</li> <li> 342. Power of Four (Easy)</li> <li> 191. Number of 1 Bits (Easy)</li> <li> 2595. Number of Even and Odd Bits (Easy)</li> <li> 338. Counting Bits (Easy)</li> </ul>"},{"location":"endlesscheng/bit_basics/#3370-smallest-number-with-all-set-bits","title":"3370. Smallest Number With All Set Bits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_basics/#3226-number-of-bit-changes-to-make-two-integers-equal","title":"3226. Number of Bit Changes to Make Two Integers Equal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_basics/#1356-sort-integers-by-the-number-of-1-bits","title":"1356. Sort Integers by The Number of 1 Bits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, bit manipulation, sorting, counting</p> </li> </ul>"},{"location":"endlesscheng/bit_basics/#461-hamming-distance","title":"461. Hamming Distance","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_basics/#2220-minimum-bit-flips-to-convert-number","title":"2220. Minimum Bit Flips to Convert Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_basics/#476-number-complement","title":"476. Number Complement","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_basics/#1009-complement-of-base-10-integer","title":"1009. Complement of Base 10 Integer","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_basics/#868-binary-gap","title":"868. Binary Gap","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_basics/#3211-generate-binary-strings-without-adjacent-zeros","title":"3211. Generate Binary Strings Without Adjacent Zeros","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, backtracking, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_basics/#2917-find-the-k-or-of-an-array","title":"2917. Find the K-or of an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_basics/#693-binary-number-with-alternating-bits","title":"693. Binary Number with Alternating Bits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_basics/#2657-find-the-prefix-common-array-of-two-arrays","title":"2657. Find the Prefix Common Array of Two Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_basics/#231-power-of-two","title":"231. Power of Two","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, bit manipulation, recursion</p> </li> </ul>"},{"location":"endlesscheng/bit_basics/#342-power-of-four","title":"342. Power of Four","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, bit manipulation, recursion</p> </li> </ul>"},{"location":"endlesscheng/bit_basics/#191-number-of-1-bits","title":"191. Number of 1 Bits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: divide and conquer, bit manipulation</p> </li> </ul> 191. Number of 1 Bits - Python Solution<pre><code># Bit Manipulation\ndef hammingWeight1(n: int) -&gt; int:\n    res = 0\n\n    while n != 0:\n        n = n &amp; (n - 1)  # Unset the rightmost 1-bit\n        res += 1\n\n    return res\n\n\ndef hammingWeight2(n: int) -&gt; int:\n    return bin(n).count(\"1\")\n\n\ndef hammingWeight3(n: int) -&gt; int:\n    def decimalToBinary(n: int) -&gt; str:\n        if n == 0:\n            return \"0\"\n\n        binary = \"\"\n        while n &gt; 0:\n            binary = str(n % 2) + binary\n            n //= 2\n\n        return binary\n\n    binary = decimalToBinary(n)\n\n    return binary.count(\"1\")\n\n\nn = 11\nprint(hammingWeight1(n))  # 3\nprint(hammingWeight2(n))  # 3\n\nn = 47\nprint(bin(n))\n</code></pre>"},{"location":"endlesscheng/bit_basics/#2595-number-of-even-and-odd-bits","title":"2595. Number of Even and Odd Bits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: bit manipulation</p> </li> <li>Topic: Bit Manipulation</li> <li>Difficulty: Easy</li> </ul> <p>You are given a positive integer n. Let even denote the number of even indices in the binary representation of n with value 1. Let odd denote the number of odd indices in the binary representation of n with value 1. Note that bits are indexed from right to left in the binary representation of a number. Return the array [even, odd].</p>"},{"location":"endlesscheng/bit_basics/#338-counting-bits","title":"338. Counting Bits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: dynamic programming, bit manipulation</p> </li> </ul> 338. Counting Bits - Python Solution<pre><code>from typing import List\n\n\n# Bit Manipulation\ndef countBits(n: int) -&gt; List[int]:\n    bits = [0 for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        bits[i] = bits[i &gt;&gt; 1] + (i &amp; 1)\n\n    return bits\n\n\nn = 5\nprint(countBits(n))  # [0, 1, 1, 2, 1, 2]\n</code></pre>"},{"location":"endlesscheng/bit_contribution_method/","title":"Bit Contribution Method","text":"<ul> <li> 477. Total Hamming Distance (Medium)</li> <li> 1863. Sum of All Subset XOR Totals (Easy)</li> <li> 2425. Bitwise XOR of All Pairings (Medium)</li> <li> 2275. Largest Combination With Bitwise AND Greater Than Zero (Medium)</li> <li> 1835. Find XOR Sum of All Pairs Bitwise AND (Hard)</li> <li> 2505. Bitwise OR of All Subsequence Sums (Medium)</li> <li> 3153. Sum of Digit Differences of All Pairs (Medium)</li> </ul>"},{"location":"endlesscheng/bit_contribution_method/#477-total-hamming-distance","title":"477. Total Hamming Distance","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_contribution_method/#1863-sum-of-all-subset-xor-totals","title":"1863. Sum of All Subset XOR Totals","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, math, backtracking, bit manipulation, combinatorics, enumeration</p> </li> </ul>"},{"location":"endlesscheng/bit_contribution_method/#2425-bitwise-xor-of-all-pairings","title":"2425. Bitwise XOR of All Pairings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation, brainteaser</p> </li> </ul>"},{"location":"endlesscheng/bit_contribution_method/#2275-largest-combination-with-bitwise-and-greater-than-zero","title":"2275. Largest Combination With Bitwise AND Greater Than Zero","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, bit manipulation, counting</p> </li> </ul>"},{"location":"endlesscheng/bit_contribution_method/#1835-find-xor-sum-of-all-pairs-bitwise-and","title":"1835. Find XOR Sum of All Pairs Bitwise AND","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_contribution_method/#2505-bitwise-or-of-all-subsequence-sums","title":"2505. Bitwise OR of All Subsequence Sums","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, bit manipulation, brainteaser</p> </li> </ul>"},{"location":"endlesscheng/bit_contribution_method/#3153-sum-of-digit-differences-of-all-pairs","title":"3153. Sum of Digit Differences of All Pairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, counting</p> </li> </ul>"},{"location":"endlesscheng/bit_identity_law/","title":"Bit Identity Law","text":"<ul> <li> 1835. Find XOR Sum of All Pairs Bitwise AND (Hard)</li> <li> 2354. Number of Excellent Pairs (Hard)</li> </ul>"},{"location":"endlesscheng/bit_identity_law/#1835-find-xor-sum-of-all-pairs-bitwise-and","title":"1835. Find XOR Sum of All Pairs Bitwise AND","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_identity_law/#2354-number-of-excellent-pairs","title":"2354. Number of Excellent Pairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, binary search, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_logtrick/","title":"Bit LogTrick","text":"<ul> <li> 3097. Shortest Subarray With OR at Least K II (Medium)</li> <li> 2411. Smallest Subarrays With Maximum Bitwise OR (Medium)</li> <li> 3209. Number of Subarrays With AND Value of K (Hard)</li> <li> 3171. Find Subarray With Bitwise OR Closest to K (Hard)</li> <li> 1521. Find a Value of a Mysterious Function Closest to Target (Hard)</li> <li> 898. Bitwise ORs of Subarrays (Medium)</li> </ul>"},{"location":"endlesscheng/bit_logtrick/#3097-shortest-subarray-with-or-at-least-k-ii","title":"3097. Shortest Subarray With OR at Least K II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation, sliding window</p> </li> </ul>"},{"location":"endlesscheng/bit_logtrick/#2411-smallest-subarrays-with-maximum-bitwise-or","title":"2411. Smallest Subarrays With Maximum Bitwise OR","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, bit manipulation, sliding window</p> </li> </ul>"},{"location":"endlesscheng/bit_logtrick/#3209-number-of-subarrays-with-and-value-of-k","title":"3209. Number of Subarrays With AND Value of K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, bit manipulation, segment tree</p> </li> </ul>"},{"location":"endlesscheng/bit_logtrick/#3171-find-subarray-with-bitwise-or-closest-to-k","title":"3171. Find Subarray With Bitwise OR Closest to K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, bit manipulation, segment tree</p> </li> </ul>"},{"location":"endlesscheng/bit_logtrick/#1521-find-a-value-of-a-mysterious-function-closest-to-target","title":"1521. Find a Value of a Mysterious Function Closest to Target","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, bit manipulation, segment tree</p> </li> </ul>"},{"location":"endlesscheng/bit_logtrick/#898-bitwise-ors-of-subarrays","title":"898. Bitwise ORs of Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_others/","title":"Bit Others","text":"<ul> <li> 136. Single Number (Easy)</li> <li> 287. Find the Duplicate Number (Medium)</li> <li> 260. Single Number III (Medium)</li> <li> 2965. Find Missing and Repeated Values (Easy)</li> <li> 137. Single Number II (Medium)</li> <li> 645. Set Mismatch (Easy)</li> <li> 190. Reverse Bits (Easy)</li> <li> 371. Sum of Two Integers (Medium)</li> <li> 201. Bitwise AND of Numbers Range (Medium)</li> <li> 2154. Keep Multiplying Found Values by Two (Easy)</li> <li> 2044. Count Number of Maximum Bitwise-OR Subsets (Medium)</li> <li> 2438. Range Product Queries of Powers (Medium)</li> <li> 1680. Concatenation of Consecutive Binary Numbers (Medium)</li> <li> 1261. Find Elements in a Contaminated Binary Tree (Medium)</li> <li> 89. Gray Code (Medium)</li> <li> 1238. Circular Permutation in Binary Representation (Medium)</li> <li> 982. Triples with Bitwise AND Equal To Zero (Hard)</li> <li> 3307. Find the K-th Character in String Game II (Hard)</li> <li> 1611. Minimum One Bit Operations to Make Integers Zero (Hard)</li> <li> 751. IP to CIDR (Medium)</li> <li> 3141. Maximum Hamming Distances (Hard)</li> </ul>"},{"location":"endlesscheng/bit_others/#136-single-number","title":"136. Single Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_others/#287-find-the-duplicate-number","title":"287. Find the Duplicate Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, bit manipulation</p> </li> <li>Find the duplicate number in an array containing <code>n + 1</code> integers where each integer is between <code>1</code> and <code>n</code> inclusive.</li> </ul> 287. Find the Duplicate Number - Python Solution<pre><code>from typing import List\n\n\n# Fast Slow Pointer\ndef findDuplicate(nums: List[int]) -&gt; int:\n\n    fast, slow = nums[0], nums[0]\n\n    while True:\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n        if slow == fast:\n            break\n\n    slow = nums[0]\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[fast]\n\n    return slow\n\n\n# | Algorithm          | TC   | SC   |\n# |--------------------|------|------|\n# | Fast Slow Pointer  | O(n) | O(1) |\n# |--------------------|------|------|\n\nnums = [1, 3, 4, 2, 2]\nprint(findDuplicate(nums))  # 2\n</code></pre>"},{"location":"endlesscheng/bit_others/#260-single-number-iii","title":"260. Single Number III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_others/#2965-find-missing-and-repeated-values","title":"2965. Find Missing and Repeated Values","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, math, matrix</p> </li> </ul>"},{"location":"endlesscheng/bit_others/#137-single-number-ii","title":"137. Single Number II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_others/#645-set-mismatch","title":"645. Set Mismatch","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, bit manipulation, sorting</p> </li> </ul>"},{"location":"endlesscheng/bit_others/#190-reverse-bits","title":"190. Reverse Bits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: divide and conquer, bit manipulation</p> </li> </ul> 190. Reverse Bits - Python Solution<pre><code># Bit Manipulation\ndef reverseBits(n: int) -&gt; int:\n    res = 0\n\n    for i in range(32):\n        res = (res &lt;&lt; 1) | (n &amp; 1)\n        n &gt;&gt;= 1\n\n    return res\n\n\nn = 0b00000010100101000001111010011100\nprint(reverseBits(n))  # 964176192\n</code></pre>"},{"location":"endlesscheng/bit_others/#371-sum-of-two-integers","title":"371. Sum of Two Integers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, bit manipulation</p> </li> </ul> 371. Sum of Two Integers - Python Solution<pre><code># Bit Manipulation\ndef getSum(a: int, b: int) -&gt; int:\n    MASK = 0xFFFFFFFF\n    MAX_INT = 0x7FFFFFFF\n\n    while b != 0:\n        temp = (a ^ b) &amp; MASK\n        b = ((a &amp; b) &lt;&lt; 1) &amp; MASK\n        a = temp\n\n    return a if a &lt;= MAX_INT else ~(a ^ MASK)\n\n\nprint(getSum(1, 2))  # 3\n</code></pre>"},{"location":"endlesscheng/bit_others/#201-bitwise-and-of-numbers-range","title":"201. Bitwise AND of Numbers Range","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_others/#2154-keep-multiplying-found-values-by-two","title":"2154. Keep Multiplying Found Values by Two","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, sorting, simulation</p> </li> </ul>"},{"location":"endlesscheng/bit_others/#2044-count-number-of-maximum-bitwise-or-subsets","title":"2044. Count Number of Maximum Bitwise-OR Subsets","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking, bit manipulation, enumeration</p> </li> </ul>"},{"location":"endlesscheng/bit_others/#2438-range-product-queries-of-powers","title":"2438. Range Product Queries of Powers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/bit_others/#1680-concatenation-of-consecutive-binary-numbers","title":"1680. Concatenation of Consecutive Binary Numbers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, bit manipulation, simulation</p> </li> </ul>"},{"location":"endlesscheng/bit_others/#1261-find-elements-in-a-contaminated-binary-tree","title":"1261. Find Elements in a Contaminated Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, tree, depth first search, breadth first search, design, binary tree</p> </li> </ul>"},{"location":"endlesscheng/bit_others/#89-gray-code","title":"89. Gray Code","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, backtracking, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_others/#1238-circular-permutation-in-binary-representation","title":"1238. Circular Permutation in Binary Representation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, backtracking, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_others/#982-triples-with-bitwise-and-equal-to-zero","title":"982. Triples with Bitwise AND Equal To Zero","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_others/#3307-find-the-k-th-character-in-string-game-ii","title":"3307. Find the K-th Character in String Game II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, bit manipulation, recursion</p> </li> </ul>"},{"location":"endlesscheng/bit_others/#1611-minimum-one-bit-operations-to-make-integers-zero","title":"1611. Minimum One Bit Operations to Make Integers Zero","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, bit manipulation, memoization</p> </li> </ul>"},{"location":"endlesscheng/bit_others/#751-ip-to-cidr","title":"751. IP to CIDR","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_others/#3141-maximum-hamming-distances","title":"3141. Maximum Hamming Distances","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, bit manipulation, breadth first search</p> </li> </ul>"},{"location":"endlesscheng/bit_thinking_problems/","title":"Bit Thinking Problems","text":"<ul> <li> 2546. Apply Bitwise Operations to Make Strings Equal (Medium)</li> <li> 1558. Minimum Numbers of Function Calls to Make Target Array (Medium)</li> <li> 2571. Minimum Operations to Reduce an Integer to 0 (Medium)</li> <li> 3315. Construct the Minimum Bitwise Array II (Medium)</li> <li> 2568. Minimum Impossible OR (Medium)</li> <li> 2509. Cycle Length Queries in a Tree (Hard)</li> <li> 2939. Maximum Xor Product (Medium)</li> <li> 2749. Minimum Operations to Make the Integer Zero (Medium)</li> <li> 2835. Minimum Operations to Form Subsequence With Target Sum (Hard)</li> <li> 2897. Apply Operations on Array to Maximize Sum of Squares (Hard)</li> <li> 810. Chalkboard XOR Game (Hard)</li> <li> 3064. Guess the Number Using Bitwise Questions I (Medium)</li> <li> 3094. Guess the Number Using Bitwise Questions II (Medium)</li> </ul>"},{"location":"endlesscheng/bit_thinking_problems/#2546-apply-bitwise-operations-to-make-strings-equal","title":"2546. Apply Bitwise Operations to Make Strings Equal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_thinking_problems/#1558-minimum-numbers-of-function-calls-to-make-target-array","title":"1558. Minimum Numbers of Function Calls to Make Target Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_thinking_problems/#2571-minimum-operations-to-reduce-an-integer-to-0","title":"2571. Minimum Operations to Reduce an Integer to 0","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming, greedy, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_thinking_problems/#3315-construct-the-minimum-bitwise-array-ii","title":"3315. Construct the Minimum Bitwise Array II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_thinking_problems/#2568-minimum-impossible-or","title":"2568. Minimum Impossible OR","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation, brainteaser</p> </li> </ul>"},{"location":"endlesscheng/bit_thinking_problems/#2509-cycle-length-queries-in-a-tree","title":"2509. Cycle Length Queries in a Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, tree, binary tree</p> </li> </ul>"},{"location":"endlesscheng/bit_thinking_problems/#2939-maximum-xor-product","title":"2939. Maximum Xor Product","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, greedy, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_thinking_problems/#2749-minimum-operations-to-make-the-integer-zero","title":"2749. Minimum Operations to Make the Integer Zero","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: bit manipulation, brainteaser, enumeration</p> </li> </ul>"},{"location":"endlesscheng/bit_thinking_problems/#2835-minimum-operations-to-form-subsequence-with-target-sum","title":"2835. Minimum Operations to Form Subsequence With Target Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_thinking_problems/#2897-apply-operations-on-array-to-maximize-sum-of-squares","title":"2897. Apply Operations on Array to Maximize Sum of Squares","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, greedy, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_thinking_problems/#810-chalkboard-xor-game","title":"810. Chalkboard XOR Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, bit manipulation, brainteaser, game theory</p> </li> </ul>"},{"location":"endlesscheng/bit_thinking_problems/#3064-guess-the-number-using-bitwise-questions-i","title":"3064. Guess the Number Using Bitwise Questions I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: bit manipulation, interactive</p> </li> </ul>"},{"location":"endlesscheng/bit_thinking_problems/#3094-guess-the-number-using-bitwise-questions-ii","title":"3094. Guess the Number Using Bitwise Questions II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: bit manipulation, interactive</p> </li> </ul>"},{"location":"endlesscheng/bit_trial_and_error_method/","title":"Bit Trial and Error Method","text":"<ul> <li> 3007. Maximum Number That Sum of the Prices Is Less Than or Equal to K (Medium)</li> <li> 421. Maximum XOR of Two Numbers in an Array (Medium)</li> <li> 2935. Maximum Strong Pair XOR II (Hard)</li> <li> 3145. Find Products of Elements of Big Array (Hard)</li> <li> 3022. Minimize OR of Remaining Elements Using Operations (Hard)</li> <li> 3287. Find the Maximum Sequence Value of Array (Hard)</li> </ul>"},{"location":"endlesscheng/bit_trial_and_error_method/#3007-maximum-number-that-sum-of-the-prices-is-less-than-or-equal-to-k","title":"3007. Maximum Number That Sum of the Prices Is Less Than or Equal to K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: binary search, dynamic programming, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_trial_and_error_method/#421-maximum-xor-of-two-numbers-in-an-array","title":"421. Maximum XOR of Two Numbers in an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, bit manipulation, trie</p> </li> </ul>"},{"location":"endlesscheng/bit_trial_and_error_method/#2935-maximum-strong-pair-xor-ii","title":"2935. Maximum Strong Pair XOR II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, bit manipulation, trie, sliding window</p> </li> </ul>"},{"location":"endlesscheng/bit_trial_and_error_method/#3145-find-products-of-elements-of-big-array","title":"3145. Find Products of Elements of Big Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_trial_and_error_method/#3022-minimize-or-of-remaining-elements-using-operations","title":"3022. Minimize OR of Remaining Elements Using Operations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_trial_and_error_method/#3287-find-the-maximum-sequence-value-of-array","title":"3287. Find the Maximum Sequence Value of Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_xor/","title":"Bit XOR","text":"<ul> <li> 1486. XOR Operation in an Array (Easy)</li> <li> 1720. Decode XORed Array (Easy)</li> <li> 2433. Find The Original Array of Prefix Xor (Medium)</li> <li> 1310. XOR Queries of a Subarray (Medium)</li> <li> 2683. Neighboring Bitwise XOR (Medium)</li> <li> 1829. Maximum XOR for Each Query (Medium)</li> <li> 2997. Minimum Number of Operations to Make Array XOR Equal to K (Medium)</li> <li> 1442. Count Triplets That Can Form Two Arrays of Equal XOR (Medium)</li> <li> 2429. Minimize XOR (Medium)</li> <li> 2527. Find Xor-Beauty of Array (Medium)</li> <li> 2317. Maximum XOR After Operations  (Medium)</li> <li> 2588. Count the Number of Beautiful Subarrays (Medium)</li> <li> 2564. Substring XOR Queries (Medium)</li> <li> 1734. Decode XORed Permutation (Medium)</li> <li> 2857. Count Pairs of Points With Distance k (Medium)</li> <li> 1803. Count Pairs With XOR in a Range (Hard)</li> <li> 3215. Count Triplets with Even XOR Set Bits II (Medium)</li> </ul>"},{"location":"endlesscheng/bit_xor/#1486-xor-operation-in-an-array","title":"1486. XOR Operation in an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_xor/#1720-decode-xored-array","title":"1720. Decode XORed Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_xor/#2433-find-the-original-array-of-prefix-xor","title":"2433. Find The Original Array of Prefix Xor","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_xor/#1310-xor-queries-of-a-subarray","title":"1310. XOR Queries of a Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/bit_xor/#2683-neighboring-bitwise-xor","title":"2683. Neighboring Bitwise XOR","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_xor/#1829-maximum-xor-for-each-query","title":"1829. Maximum XOR for Each Query","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/bit_xor/#2997-minimum-number-of-operations-to-make-array-xor-equal-to-k","title":"2997. Minimum Number of Operations to Make Array XOR Equal to K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_xor/#1442-count-triplets-that-can-form-two-arrays-of-equal-xor","title":"1442. Count Triplets That Can Form Two Arrays of Equal XOR","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, bit manipulation, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/bit_xor/#2429-minimize-xor","title":"2429. Minimize XOR","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: greedy, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_xor/#2527-find-xor-beauty-of-array","title":"2527. Find Xor-Beauty of Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_xor/#2317-maximum-xor-after-operations","title":"2317. Maximum XOR After Operations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_xor/#2588-count-the-number-of-beautiful-subarrays","title":"2588. Count the Number of Beautiful Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, bit manipulation, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/bit_xor/#2564-substring-xor-queries","title":"2564. Substring XOR Queries","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_xor/#1734-decode-xored-permutation","title":"1734. Decode XORed Permutation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_xor/#2857-count-pairs-of-points-with-distance-k","title":"2857. Count Pairs of Points With Distance k","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/bit_xor/#1803-count-pairs-with-xor-in-a-range","title":"1803. Count Pairs With XOR in a Range","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, bit manipulation, trie</p> </li> </ul>"},{"location":"endlesscheng/bit_xor/#3215-count-triplets-with-even-xor-set-bits-ii","title":"3215. Count Triplets with Even XOR Set Bits II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/brain_teasers/","title":"Brain Teasers","text":"<ul> <li> 2733. Neither Minimum nor Maximum (Easy)</li> <li> 1903. Largest Odd Number in String (Easy)</li> <li> 2549. Count Distinct Numbers on Board (Easy)</li> <li> 3432. Count Partitions with Even Sum Difference (Easy)</li> <li> 2396. Strictly Palindromic Number (Medium)</li> <li> 1689. Partitioning Into Minimum Number Of Deci-Binary Numbers (Medium)</li> <li> 598. Range Addition II (Easy)</li> <li> 521. Longest Uncommon Subsequence I (Easy)</li> <li> 3227. Vowels Game in a String (Medium)</li> <li> 2419. Longest Subarray With Maximum Bitwise AND (Medium)</li> <li> 3424. Minimum Cost to Make Arrays Identical (Medium)</li> <li> 1992. Find All Groups of Farmland (Medium)</li> <li> 1007. Minimum Domino Rotations For Equal Row (Medium)</li> <li> 2811. Check if it is Possible to Split Array (Medium)</li> <li> 2211. Count Collisions on a Road (Medium)</li> <li> 3207. Maximum Points After Enemy Battles (Medium)</li> <li> 2546. Apply Bitwise Operations to Make Strings Equal (Medium)</li> <li> 1503. Last Moment Before All Ants Fall Out of a Plank (Medium)</li> <li> 2860. Happy Students (Medium)</li> <li> 1332. Remove Palindromic Subsequences (Easy)</li> <li> 1975. Maximum Matrix Sum (Medium)</li> <li> 1145. Binary Tree Coloring Game (Medium)</li> <li> 1297. Maximum Number of Occurrences of a Substring (Medium)</li> <li> 3282. Reach End of Array With Max Score (Medium)</li> <li> 2332. The Latest Time to Catch a Bus (Medium)</li> <li> 2680. Maximum OR (Medium)</li> <li> 2731. Movement of Robots (Medium)</li> <li> 2556. Disconnect Path in a Binary Matrix by at Most One Flip (Medium)</li> <li> 3125. Maximum Number That Makes Result of Bitwise AND Zero (Medium)</li> <li> 1794. Count Pairs of Equal Substrings With Minimum Difference (Medium)</li> </ul>"},{"location":"endlesscheng/brain_teasers/#2733-neither-minimum-nor-maximum","title":"2733. Neither Minimum nor Maximum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, sorting</p> </li> </ul>"},{"location":"endlesscheng/brain_teasers/#1903-largest-odd-number-in-string","title":"1903. Largest Odd Number in String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, string, greedy</p> </li> </ul>"},{"location":"endlesscheng/brain_teasers/#2549-count-distinct-numbers-on-board","title":"2549. Count Distinct Numbers on Board","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, math, simulation</p> </li> </ul>"},{"location":"endlesscheng/brain_teasers/#3432-count-partitions-with-even-sum-difference","title":"3432. Count Partitions with Even Sum Difference","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, math, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/brain_teasers/#2396-strictly-palindromic-number","title":"2396. Strictly Palindromic Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, two pointers, brainteaser</p> </li> </ul>"},{"location":"endlesscheng/brain_teasers/#1689-partitioning-into-minimum-number-of-deci-binary-numbers","title":"1689. Partitioning Into Minimum Number Of Deci-Binary Numbers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, greedy</p> </li> </ul>"},{"location":"endlesscheng/brain_teasers/#598-range-addition-ii","title":"598. Range Addition II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, math</p> </li> </ul>"},{"location":"endlesscheng/brain_teasers/#521-longest-uncommon-subsequence-i","title":"521. Longest Uncommon Subsequence I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string</p> </li> </ul>"},{"location":"endlesscheng/brain_teasers/#3227-vowels-game-in-a-string","title":"3227. Vowels Game in a String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, string, brainteaser, game theory</p> </li> </ul>"},{"location":"endlesscheng/brain_teasers/#2419-longest-subarray-with-maximum-bitwise-and","title":"2419. Longest Subarray With Maximum Bitwise AND","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation, brainteaser</p> </li> </ul>"},{"location":"endlesscheng/brain_teasers/#3424-minimum-cost-to-make-arrays-identical","title":"3424. Minimum Cost to Make Arrays Identical","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/brain_teasers/#1992-find-all-groups-of-farmland","title":"1992. Find All Groups of Farmland","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, matrix</p> </li> </ul>"},{"location":"endlesscheng/brain_teasers/#1007-minimum-domino-rotations-for-equal-row","title":"1007. Minimum Domino Rotations For Equal Row","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy</p> </li> </ul>"},{"location":"endlesscheng/brain_teasers/#2811-check-if-it-is-possible-to-split-array","title":"2811. Check if it is Possible to Split Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> </ul>"},{"location":"endlesscheng/brain_teasers/#2211-count-collisions-on-a-road","title":"2211. Count Collisions on a Road","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack, simulation</p> </li> </ul>"},{"location":"endlesscheng/brain_teasers/#3207-maximum-points-after-enemy-battles","title":"3207. Maximum Points After Enemy Battles","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy</p> </li> </ul>"},{"location":"endlesscheng/brain_teasers/#2546-apply-bitwise-operations-to-make-strings-equal","title":"2546. Apply Bitwise Operations to Make Strings Equal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/brain_teasers/#1503-last-moment-before-all-ants-fall-out-of-a-plank","title":"1503. Last Moment Before All Ants Fall Out of a Plank","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, brainteaser, simulation</p> </li> </ul>"},{"location":"endlesscheng/brain_teasers/#2860-happy-students","title":"2860. Happy Students","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sorting, enumeration</p> </li> </ul> 2860. Happy Students - Python Solution<pre><code>from typing import List\n\n\n# Sort\ndef countWays(nums: List[int]) -&gt; int:\n    nums.sort()\n    n = len(nums)\n    count = 0\n\n    if nums[0] &gt; 0:\n        count += 1\n\n    for x in range(1, n):\n        if nums[x - 1] &lt; x &lt; nums[x]:\n            count += 1\n\n    if nums[n - 1] &lt; n:\n        count += 1\n\n    return count\n\n\nnums = [6, 0, 3, 3, 6, 7, 2, 7]\nprint(countWays(nums))  # 3\n</code></pre>"},{"location":"endlesscheng/brain_teasers/#1332-remove-palindromic-subsequences","title":"1332. Remove Palindromic Subsequences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string</p> </li> </ul>"},{"location":"endlesscheng/brain_teasers/#1975-maximum-matrix-sum","title":"1975. Maximum Matrix Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, matrix</p> </li> </ul>"},{"location":"endlesscheng/brain_teasers/#1145-binary-tree-coloring-game","title":"1145. Binary Tree Coloring Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"endlesscheng/brain_teasers/#1297-maximum-number-of-occurrences-of-a-substring","title":"1297. Maximum Number of Occurrences of a Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> </ul>"},{"location":"endlesscheng/brain_teasers/#3282-reach-end-of-array-with-max-score","title":"3282. Reach End of Array With Max Score","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy</p> </li> </ul>"},{"location":"endlesscheng/brain_teasers/#2332-the-latest-time-to-catch-a-bus","title":"2332. The Latest Time to Catch a Bus","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, sorting</p> </li> </ul>"},{"location":"endlesscheng/brain_teasers/#2680-maximum-or","title":"2680. Maximum OR","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, bit manipulation, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/brain_teasers/#2731-movement-of-robots","title":"2731. Movement of Robots","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, brainteaser, sorting, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/brain_teasers/#2556-disconnect-path-in-a-binary-matrix-by-at-most-one-flip","title":"2556. Disconnect Path in a Binary Matrix by at Most One Flip","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, depth first search, breadth first search, matrix</p> </li> </ul>"},{"location":"endlesscheng/brain_teasers/#3125-maximum-number-that-makes-result-of-bitwise-and-zero","title":"3125. Maximum Number That Makes Result of Bitwise AND Zero","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/brain_teasers/#1794-count-pairs-of-equal-substrings-with-minimum-difference","title":"1794. Count Pairs of Equal Substrings With Minimum Difference","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, greedy</p> </li> </ul>"},{"location":"endlesscheng/climbing_stairs/","title":"Climbing Stairs","text":"<ul> <li> 70. Climbing Stairs (Easy)</li> <li> 746. Min Cost Climbing Stairs (Easy)</li> <li> 377. Combination Sum IV (Medium)</li> <li> 2466. Count Ways To Build Good Strings (Medium)</li> <li> 2266. Count Number of Texts (Medium)</li> <li> 2533. Number of Good Binary Strings (Medium)</li> </ul>"},{"location":"endlesscheng/climbing_stairs/#70-climbing-stairs","title":"70. Climbing Stairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, dynamic programming, memoization</p> </li> <li>Return the number of distinct ways to reach the top of the stairs.</li> <li><code>dp[n]</code> stores the number of distinct ways to reach the <code>n-th</code> stair.</li> <li>Formula: <code>dp[n] = dp[n - 1] + dp[n - 2]</code>.</li> <li>Initialize <code>dp[0] = 0</code>, <code>dp[1] = 1</code>, and <code>dp[2] = 2</code>.</li> </ul> n <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n]</code> 0 - - 0 1 - - 1 2 - 1 2 3 1 2 3 4 2 3 5 5 3 5 8 6 5 8 13 7 8 13 21 8 13 21 34 9 21 34 55 10 34 55 89 70. Climbing Stairs - Python Solution<pre><code># DP\ndef climbStairs(n: int) -&gt; int:\n    if n &lt;= 1:\n        return n\n\n    dp = [i for i in range(n + 1)]\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |     DP      |      O(n)       |     O(n)     |\n# |-------------|-----------------|--------------|\n\nprint(climbStairs(10))  # 89\n</code></pre>"},{"location":"endlesscheng/climbing_stairs/#746-min-cost-climbing-stairs","title":"746. Min Cost Climbing Stairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li> <p>Return the minimum cost to reach the top of the stairs.</p> </li> <li> <p><code>dp[n]</code> stores the minimum cost to reach the <code>n-th</code> stair.</p> </li> <li>Formula: <code>dp[n] = cost[n] + min(dp[n - 1], dp[n - 2])</code>.</li> <li>Initialize <code>dp[0] = cost[0]</code> and <code>dp[1] = cost[1]</code>.</li> <li> <p>Return <code>min(dp[-1], dp[-2])</code>.</p> </li> <li> <p>Example: <code>cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</code></p> </li> </ul> n <code>cost[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n]</code> 0 1 - - 1 1 100 - 1 100 2 1 1 100 2 3 1 100 2 3 4 1 2 3 3 5 100 3 3 103 6 1 3 103 4 7 1 103 4 5 8 100 4 5 104 9 1 5 104 6 746. Min Cost Climbing Stairs - Python Solution<pre><code>from typing import List\n\n\ndef minCostClimbingStairs(cost: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(cost))]\n\n    dp[0], dp[1] = cost[0], cost[1]\n\n    for i in range(2, len(cost)):\n        dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]\n    print(dp)\n    return min(dp[-1], dp[-2])\n\n\ncost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]\nprint(minCostClimbingStairs(cost))  # 6\n</code></pre>"},{"location":"endlesscheng/climbing_stairs/#377-combination-sum-iv","title":"377. Combination Sum IV","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul> 377. Combination Sum IV - Python Solution<pre><code>from typing import List\n\n\ndef combinationSum4(nums: List[int], target: int) -&gt; int:\n    dp = [0 for _ in range(target + 1)]\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for j in range(len(nums)):\n            if i - nums[j] &gt;= 0:\n                dp[i] += dp[i - nums[j]]\n\n        return dp[target]\n\n\nnums = [1, 2, 3]\ntarget = 4\nprint(combinationSum4(nums, target))  # 7\n</code></pre>"},{"location":"endlesscheng/climbing_stairs/#2466-count-ways-to-build-good-strings","title":"2466. Count Ways To Build Good Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming</p> </li> </ul>"},{"location":"endlesscheng/climbing_stairs/#2266-count-number-of-texts","title":"2266. Count Number of Texts","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, math, string, dynamic programming</p> </li> </ul>"},{"location":"endlesscheng/climbing_stairs/#2533-number-of-good-binary-strings","title":"2533. Number of Good Binary Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming</p> </li> </ul>"},{"location":"endlesscheng/construction_problems/","title":"Construction Problems","text":"<ul> <li> 942. DI String Match (Easy)</li> <li> 1968. Array With Elements Not Equal to Average of Neighbors (Medium)</li> <li> 1253. Reconstruct a 2-Row Binary Matrix (Medium)</li> <li> 2182. Construct String With Repeat Limit (Medium)</li> <li> 969. Pancake Sorting (Medium)</li> <li> 1605. Find Valid Matrix Given Row and Column Sums (Medium)</li> <li> 2375. Construct Smallest Number From DI String (Medium)</li> <li> 324. Wiggle Sort II (Medium)</li> <li> 667. Beautiful Arrangement II (Medium)</li> <li> 2122. Recover the Original Array (Hard)</li> <li> 932. Beautiful Array (Medium)</li> <li> 3311. Construct 2D Grid Matching Graph Layout (Hard)</li> <li> 2573. Find the String with LCP (Hard)</li> <li> 1982. Find Array Given Subset Sums (Hard)</li> <li> 280. Wiggle Sort (Medium)</li> <li> 484. Find Permutation (Medium)</li> <li> 1980. Find Unique Binary String (Medium)</li> </ul>"},{"location":"endlesscheng/construction_problems/#942-di-string-match","title":"942. DI String Match","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers, string, greedy</p> </li> </ul>"},{"location":"endlesscheng/construction_problems/#1968-array-with-elements-not-equal-to-average-of-neighbors","title":"1968. Array With Elements Not Equal to Average of Neighbors","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/construction_problems/#1253-reconstruct-a-2-row-binary-matrix","title":"1253. Reconstruct a 2-Row Binary Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, matrix</p> </li> </ul>"},{"location":"endlesscheng/construction_problems/#2182-construct-string-with-repeat-limit","title":"2182. Construct String With Repeat Limit","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, greedy, heap priority queue, counting</p> </li> </ul>"},{"location":"endlesscheng/construction_problems/#969-pancake-sorting","title":"969. Pancake Sorting","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/construction_problems/#1605-find-valid-matrix-given-row-and-column-sums","title":"1605. Find Valid Matrix Given Row and Column Sums","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, matrix</p> </li> </ul>"},{"location":"endlesscheng/construction_problems/#2375-construct-smallest-number-from-di-string","title":"2375. Construct Smallest Number From DI String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, backtracking, stack, greedy</p> </li> </ul>"},{"location":"endlesscheng/construction_problems/#324-wiggle-sort-ii","title":"324. Wiggle Sort II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, divide and conquer, greedy, sorting, quickselect</p> </li> </ul>"},{"location":"endlesscheng/construction_problems/#667-beautiful-arrangement-ii","title":"667. Beautiful Arrangement II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math</p> </li> </ul>"},{"location":"endlesscheng/construction_problems/#2122-recover-the-original-array","title":"2122. Recover the Original Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, two pointers, sorting, enumeration</p> </li> </ul>"},{"location":"endlesscheng/construction_problems/#932-beautiful-array","title":"932. Beautiful Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, divide and conquer</p> </li> </ul>"},{"location":"endlesscheng/construction_problems/#3311-construct-2d-grid-matching-graph-layout","title":"3311. Construct 2D Grid Matching Graph Layout","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, graph, matrix</p> </li> </ul>"},{"location":"endlesscheng/construction_problems/#2573-find-the-string-with-lcp","title":"2573. Find the String with LCP","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, dynamic programming, greedy, union find, matrix</p> </li> </ul>"},{"location":"endlesscheng/construction_problems/#1982-find-array-given-subset-sums","title":"1982. Find Array Given Subset Sums","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, divide and conquer</p> </li> </ul>"},{"location":"endlesscheng/construction_problems/#280-wiggle-sort","title":"280. Wiggle Sort","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/construction_problems/#484-find-permutation","title":"484. Find Permutation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, stack, greedy</p> </li> </ul>"},{"location":"endlesscheng/construction_problems/#1980-find-unique-binary-string","title":"1980. Find Unique Binary String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, backtracking</p> </li> </ul>"},{"location":"endlesscheng/contribution_method/","title":"Contribution Method","text":"<ul> <li> 907. Sum of Subarray Minimums (Medium)</li> <li> 2104. Sum of Subarray Ranges (Medium)</li> <li> 1856. Maximum Subarray Min-Product (Medium)</li> <li> 2818. Apply Operations to Maximize Score (Hard)</li> <li> 2281. Sum of Total Strength of Wizards (Hard)</li> <li> 3359. Find Sorted Submatrices With Maximum Element at Most K (Hard)</li> <li> 2334. Subarray With Elements Greater Than Varying Threshold (Hard)</li> </ul>"},{"location":"endlesscheng/contribution_method/#907-sum-of-subarray-minimums","title":"907. Sum of Subarray Minimums","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, stack, monotonic stack</p> </li> </ul>"},{"location":"endlesscheng/contribution_method/#2104-sum-of-subarray-ranges","title":"2104. Sum of Subarray Ranges","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, monotonic stack</p> </li> </ul>"},{"location":"endlesscheng/contribution_method/#1856-maximum-subarray-min-product","title":"1856. Maximum Subarray Min-Product","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, monotonic stack, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/contribution_method/#2818-apply-operations-to-maximize-score","title":"2818. Apply Operations to Maximize Score","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, stack, greedy, sorting, monotonic stack, number theory</p> </li> </ul>"},{"location":"endlesscheng/contribution_method/#2281-sum-of-total-strength-of-wizards","title":"2281. Sum of Total Strength of Wizards","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, stack, monotonic stack, prefix sum</p> </li> </ul> 2281. Sum of Total Strength of Wizards - Python Solution<pre><code>from itertools import accumulate\nfrom typing import List\n\n\n# Monotonic Stack\ndef totalStrength(strength: List[int]) -&gt; int:\n    n = len(strength)\n    left = [-1 for _ in range(n)]\n    right = [n for _ in range(n)]\n    stack = []\n\n    for i, v in enumerate(strength):\n        while stack and strength[stack[-1]] &gt;= v:\n            right[stack.pop()] = i\n        if stack:\n            left[i] = stack[-1]\n        stack.append(i)\n\n    prefix_sum = list(accumulate(accumulate(strength, initial=0), initial=0))\n\n    ans = 0\n    for i, v in enumerate(strength):\n        l, r = left[i] + 1, right[i] - 1\n        tot = (i - l + 1) * (prefix_sum[r + 2] - prefix_sum[i + 1]) - (\n            r - i + 1\n        ) * (prefix_sum[i + 1] - prefix_sum[l])\n        ans += v * tot\n\n    return ans % (10**9 + 7)\n\n\nstrength = [1, 3, 1, 2]\nprint(totalStrength(strength))  # 44\n</code></pre>"},{"location":"endlesscheng/contribution_method/#3359-find-sorted-submatrices-with-maximum-element-at-most-k","title":"3359. Find Sorted Submatrices With Maximum Element at Most K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, stack, matrix, monotonic stack</p> </li> </ul>"},{"location":"endlesscheng/contribution_method/#2334-subarray-with-elements-greater-than-varying-threshold","title":"2334. Subarray With Elements Greater Than Varying Threshold","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, stack, union find, monotonic stack</p> </li> </ul>"},{"location":"endlesscheng/deque/","title":"Deque","text":"<ul> <li> 2810. Faulty Keyboard (Easy)</li> </ul>"},{"location":"endlesscheng/deque/#2810-faulty-keyboard","title":"2810. Faulty Keyboard","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, simulation</p> </li> </ul>"},{"location":"endlesscheng/dfs_basics/","title":"DFS Basics","text":"<ul> <li> 547. Number of Provinces (Medium)</li> <li> 1971. Find if Path Exists in Graph (Easy)</li> <li> 797. All Paths From Source to Target (Medium)</li> <li> 841. Keys and Rooms (Medium)</li> <li> 2316. Count Unreachable Pairs of Nodes in an Undirected Graph (Medium)</li> <li> 1319. Number of Operations to Make Network Connected (Medium)</li> <li> 2492. Minimum Score of a Path Between Two Cities (Medium)</li> <li> 3387. Maximize Amount After Two Days of Conversions (Medium)</li> <li> 3310. Remove Methods From Project (Medium)</li> <li> 2685. Count the Number of Complete Components (Medium)</li> <li> 2192. All Ancestors of a Node in a Directed Acyclic Graph (Medium)</li> <li> 924. Minimize Malware Spread (Hard)</li> <li> 2101. Detonate the Maximum Bombs (Medium)</li> <li> 721. Accounts Merge (Medium)</li> <li> 207. Course Schedule (Medium)</li> <li> 802. Find Eventual Safe States (Medium)</li> <li> 928. Minimize Malware Spread II (Hard)</li> <li> 2092. Find All People With Secret (Hard)</li> <li> 3108. Minimum Cost Walk in Weighted Graph (Hard)</li> <li> 261. Graph Valid Tree (Medium)</li> <li> 323. Number of Connected Components in an Undirected Graph (Medium)</li> </ul>"},{"location":"endlesscheng/dfs_basics/#547-number-of-provinces","title":"547. Number of Provinces","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> <li>Return the number of provinces.</li> </ul>"},{"location":"endlesscheng/dfs_basics/#union-find","title":"Union Find","text":"<ul> <li>Find by Path Compression</li> <li>Union by Rank</li> <li>Time Complexity: O(log(n))</li> <li>Space Complexity: O(n)</li> </ul> template/union_find.py<pre><code>class UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(n)}\n        self.rank = {i: 1 for i in range(n)}\n\n    def find(self, n):\n        p = self.par[n]\n        while self.par[p] != p:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return None\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.par[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.par[p1] = p2\n        else:\n            self.par[p2] = p1\n            self.rank[p1] += 1\n\n    def connected(self, n1, n2):\n        return self.find(n1) == self.find(n2)\n</code></pre> 547. Number of Provinces - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\nfrom template import UnionFind\n\n\n# DFS (Adjacency Matrix)\ndef findCircleNumDFSMatrix(isConnected: List[List[int]]) -&gt; int:\n    n = len(isConnected)\n    visited = set()\n\n    def dfs(node):\n        if node in visited:\n            return\n        visited.add(node)\n        for neighbor in range(n):\n            if node != neighbor and isConnected[node][neighbor] == 1:\n                dfs(neighbor)\n\n    res = 0\n    for i in range(n):\n        if i not in visited:\n            dfs(i)\n            res += 1\n\n    return res\n\n\n# DFS (Adjacency List)\ndef findCircleNumDFSList(isConnected: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    n = len(isConnected)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if isConnected[i][j] == 1:\n                graph[i].append(j)\n                graph[j].append(i)\n\n    visited = set()\n\n    def dfs(node):\n        if node in visited:\n            return\n        visited.add(node)\n        for neighbor in graph[node]:\n            dfs(neighbor)\n\n    res = 0\n    for i in range(n):\n        if i not in visited:\n            dfs(i)\n            res += 1\n\n    return res\n\n\n# BFS (Adjacency Matrix)\ndef findCircleNumBFS(isConnected: List[List[int]]) -&gt; int:\n    n = len(isConnected)\n    visited = set()\n    q = deque()\n    res = 0\n\n    for i in range(n):\n        if i not in visited:\n            res += 1\n\n            q.append(i)\n            while q:\n                node = q.popleft()\n                visited.add(node)\n                for node, val in enumerate(isConnected[node]):\n                    if val == 1 and node not in visited:\n                        q.append(node)\n                        visited.add(node)\n\n    return res\n\n\n# Union Find\ndef findCircleNumUF(isConnected: List[List[int]]) -&gt; int:\n    n = len(isConnected)\n    uf = UnionFind(n)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if isConnected[i][j] == 1:\n                uf.union(i, j)\n\n    res = len(set(uf.find(i) for i in range(n)))\n\n    return res\n\n\n# Union Find\ndef findCircleNum(isConnected: List[List[int]]) -&gt; int:\n    n = len(isConnected)\n    par = {i: i for i in range(n)}\n    rank = {i: 0 for i in range(n)}\n\n    def find(n):\n        p = par[n]\n        while par[p] != p:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 == p2:\n            return None\n\n        if rank[p1] &gt; rank[p2]:\n            par[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n        else:\n            par[p2] = p1\n            rank[p1] += 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if isConnected[i][j] == 1:\n                union(i, j)\n\n    res = len(set(find(i) for i in range(n)))\n\n    return res\n\n\nisConnected = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]\nprint(findCircleNumDFSList(isConnected))  # 2\nprint(findCircleNumDFSMatrix(isConnected))  # 2\nprint(findCircleNumBFS(isConnected))  # 2\nprint(findCircleNum(isConnected))  # 2\nprint(findCircleNumUF(isConnected))  # 2\n</code></pre>"},{"location":"endlesscheng/dfs_basics/#1971-find-if-path-exists-in-graph","title":"1971. Find if Path Exists in Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> </ul> 1971. Find if Path Exists in Graph - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# DFS (Adjacency List)\ndef validPathDFS(\n    n: int, edges: List[List[int]], source: int, destination: int\n) -&gt; bool:\n    if not edges and source != destination:\n        return False\n\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = set()\n\n    def dfs(node):\n        if node == destination:\n            return True\n\n        visited.add(node)\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n\n        return False\n\n    return dfs(source)\n\n\nn = 3\nedges = [[0, 1], [1, 2], [2, 0]]\nsource = 0\ndestination = 2\nprint(validPathDFS(n, edges, source, destination))  # True\n</code></pre>"},{"location":"endlesscheng/dfs_basics/#797-all-paths-from-source-to-target","title":"797. All Paths From Source to Target","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: backtracking, depth first search, breadth first search, graph</p> </li> </ul> 797. All Paths From Source to Target - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS (Backtracking)\ndef allPathsSourceTargetDFS(graph: List[List[int]]) -&gt; List[List[int]]:\n    res = []\n    n = len(graph)\n\n    def dfs(node, path):\n        if node == n - 1:\n            res.append(path.copy())\n            return None\n\n        for nei in graph[node]:\n            path.append(nei)\n            dfs(nei, path)\n            path.pop()\n\n    dfs(0, [0])\n\n    return res\n\n\n# BFS\ndef allPathsSourceTargetBFS(graph: List[List[int]]) -&gt; List[List[int]]:\n    n = len(graph)\n    res = []\n    q = deque([(0, [0])])\n\n    while q:\n        node, path = q.popleft()\n\n        if node == n - 1:\n            res.append(path)\n\n        for nei in graph[node]:\n            q.append((nei, path + [nei]))\n\n    return res\n\n\ngraph = [[1, 2], [3], [3], []]\nprint(allPathsSourceTargetDFS(graph))  # [[0, 1, 3], [0, 2, 3]]\nprint(allPathsSourceTargetBFS(graph))  # [[0, 1, 3], [0, 2, 3]]\n</code></pre>"},{"location":"endlesscheng/dfs_basics/#841-keys-and-rooms","title":"841. Keys and Rooms","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph</p> </li> </ul> 841. Keys and Rooms - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef canVisitAllRoomsDFS(rooms: List[List[int]]) -&gt; bool:\n    n = len(rooms)\n    visited = [False for _ in range(n)]\n\n    def dfs(room):\n        visited[room] = True\n        for key in rooms[room]:\n            if not visited[key]:\n                dfs(key)\n\n    dfs(0)\n\n    return all(visited)\n\n\n# BFS\ndef canVisitAllRoomsBFS(rooms):\n    n = len(rooms)\n    visited = [False for _ in range(n)]\n    q = deque([0])\n    visited[0] = True\n\n    while q:\n        room = q.popleft()\n        for key in rooms[room]:\n            if not visited[key]:\n                visited[key] = True\n                q.append(key)\n\n    return all(visited)\n\n\nrooms = [[1, 3], [3, 0, 1], [2], [0]]\nprint(canVisitAllRoomsDFS(rooms))  # False\nprint(canVisitAllRoomsBFS(rooms))  # False\n</code></pre>"},{"location":"endlesscheng/dfs_basics/#2316-count-unreachable-pairs-of-nodes-in-an-undirected-graph","title":"2316. Count Unreachable Pairs of Nodes in an Undirected Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> </ul> 2316. Count Unreachable Pairs of Nodes in an Undirected Graph - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# DFS (Adjacency List)\ndef countPairsList1(n: int, edges: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = set()\n\n    def dfs(node):\n        visited.add(node)\n        size = 1\n\n        for nei in graph[node]:\n            if nei not in visited:\n                size += dfs(nei)\n\n        return size\n\n    res = 0\n    for i in range(n):\n        if i not in visited:\n            size = dfs(i)\n            res += size * (n - size)\n\n    return res // 2\n\n\n# DFS(Adjacency List)\ndef countPairsList2(n: int, edges: List[List[int]]) -&gt; int:\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = [False for _ in range(n)]\n\n    def dfs(node):\n        visited[node] = True\n        size = 1\n        for nei in graph[node]:\n            if not visited[nei]:\n                size += dfs(nei)\n        return size\n\n    res, total = 0, 0\n    for i in range(n):\n        if not visited[i]:\n            size = dfs(i)\n            res += size * total\n            total += size\n\n    return res\n\n\nn = 7\nedges = [[0, 2], [0, 5], [2, 4], [1, 6], [5, 4]]\nprint(countPairsList1(n, edges))  # 14\nprint(countPairsList2(n, edges))  # 14\n</code></pre> 2316. Count Unreachable Pairs of Nodes in an Undirected Graph - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;unordered_set&gt;\n#include &lt;functional&gt;\nusing namespace std;\n\nclass Solution\n{\npublic:\n    long long countPairs(int n, vector&lt;vector&lt;int&gt;&gt; &amp;edges)\n    {\n        unordered_map&lt;int, unordered_set&lt;int&gt;&gt; graph;\n        for (const auto &amp;edge : edges)\n        {\n            graph[edge[0]].insert(edge[1]);\n            graph[edge[1]].insert(edge[0]);\n        }\n\n        unordered_set&lt;int&gt; visited;\n\n        function&lt;int(int)&gt; dfs = [&amp;](int node) -&gt; int\n        {\n            if (visited.count(node))\n            {\n                return 0;\n            }\n            visited.insert(node);\n            int count = 1;\n            for (const auto &amp;neighbor : graph[node])\n            {\n                if (!visited.count(neighbor))\n                {\n                    count += dfs(neighbor);\n                }\n            }\n            return count;\n        };\n\n        long long res = 0;\n        long long total = n;\n\n        for (int i = 0; i &lt; n; ++i)\n        {\n            if (!visited.count(i))\n            {\n                int count = dfs(i);\n                res += count * (total - count);\n            }\n        }\n        return res / 2;\n    }\n};\n\nint main()\n{\n    Solution s;\n    vector&lt;vector&lt;int&gt;&gt; edges = {{0, 2}, {0, 5}, {2, 4}, {1, 6}, {5, 4}};\n    cout &lt;&lt; s.countPairs(7, edges) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"endlesscheng/dfs_basics/#1319-number-of-operations-to-make-network-connected","title":"1319. Number of Operations to Make Network Connected","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> </ul>"},{"location":"endlesscheng/dfs_basics/#2492-minimum-score-of-a-path-between-two-cities","title":"2492. Minimum Score of a Path Between Two Cities","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> </ul>"},{"location":"endlesscheng/dfs_basics/#3387-maximize-amount-after-two-days-of-conversions","title":"3387. Maximize Amount After Two Days of Conversions","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, depth first search, breadth first search, graph</p> </li> </ul>"},{"location":"endlesscheng/dfs_basics/#3310-remove-methods-from-project","title":"3310. Remove Methods From Project","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph</p> </li> </ul>"},{"location":"endlesscheng/dfs_basics/#2685-count-the-number-of-complete-components","title":"2685. Count the Number of Complete Components","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> </ul>"},{"location":"endlesscheng/dfs_basics/#2192-all-ancestors-of-a-node-in-a-directed-acyclic-graph","title":"2192. All Ancestors of a Node in a Directed Acyclic Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort</p> </li> </ul>"},{"location":"endlesscheng/dfs_basics/#924-minimize-malware-spread","title":"924. Minimize Malware Spread","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, depth first search, breadth first search, union find, graph</p> </li> </ul> 924. Minimize Malware Spread - Python Solution<pre><code>from typing import List\n\n\n# Coloring\ndef minMalwareSpread(graph: List[List[int]], initial: List[int]) -&gt; int:\n    n = len(graph)\n    initial = set(initial)\n\n    def dfs(x):\n        visited.add(x)\n        mark[x] = 1\n        if x in initial:\n            v.append(x)\n        for nxt in range(n):\n            if graph[x][nxt] and nxt != x and not mark[nxt]:\n                dfs(nxt)\n\n    ans = min(initial)\n    mx = 0\n    mark = [0] * n\n    for i in range(n):\n        if not mark[i]:\n            visited = set()\n            v = []\n            dfs(i)\n            if len(v) == 1 and (\n                len(visited) &gt; mx or len(visited) == mx and v[0] &lt; ans\n            ):\n                ans, mx = v[0], len(visited)\n    return ans\n\n\ngraph = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]\ninitial = [0, 1]\nprint(minMalwareSpread(graph, initial))  # 0\n</code></pre>"},{"location":"endlesscheng/dfs_basics/#2101-detonate-the-maximum-bombs","title":"2101. Detonate the Maximum Bombs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, depth first search, breadth first search, graph, geometry</p> </li> </ul>"},{"location":"endlesscheng/dfs_basics/#721-accounts-merge","title":"721. Accounts Merge","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, depth first search, breadth first search, union find, sorting</p> </li> </ul> 721. Accounts Merge - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef accountsMerge(accounts: List[List[str]]) -&gt; List[List[str]]:\n    parent = defaultdict(str)\n    rank = defaultdict(int)\n    email_to_name = defaultdict(str)\n    merged_accounts = defaultdict(list)\n\n    def find(n):\n        p = parent[n]\n        while p != parent[p]:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    for account in accounts:\n        name = account[0]\n        first_email = account[1]\n\n        for email in account[1:]:\n            if email not in parent:\n                parent[email] = email\n                rank[email] = 1\n            email_to_name[email] = name\n            union(first_email, email)\n\n    for email in parent:\n        root_email = find(email)\n        merged_accounts[root_email].append(email)\n\n    result = []\n    for root_email, emails in merged_accounts.items():\n        result.append([email_to_name[root_email]] + sorted(emails))\n\n    return result\n\n\naccounts = [\n    [\"John\", \"johnsmith@mail.com\", \"john_newyork@mail.com\"],\n    [\"John\", \"johnsmith@mail.com\", \"john00@mail.com\"],\n    [\"Mary\", \"mary@mail.com\"],\n    [\"John\", \"johnnybravo@mail.com\"],\n]\nprint(accountsMerge(accounts))\n# [['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],\n# ['Mary', 'mary@mail.com'],\n# ['John', 'johnnybravo@mail.com']]\n</code></pre>"},{"location":"endlesscheng/dfs_basics/#207-course-schedule","title":"207. Course Schedule","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort</p> </li> <li>Return true if it is possible to finish all courses, otherwise return false.</li> <li>Dependency relationships imply the topological sort algorithm.</li> <li>Cycle detection</li> <li>Topological Sort<ul> <li>DAG (Directed Acyclic Graph)</li> <li>Time complexity: O(V+E)</li> <li>Space complexity: O(V+E)</li> <li>Prerequisites: Indegree (Look at the problem 1557. Minimum Number of Vertices to Reach All Nodes)<ul> <li>Indegree: Number of incoming edges to a vertex</li> </ul> </li> <li>Applications: task scheduling, course scheduling, build systems, dependency resolution, compiler optimization, etc.</li> </ul> </li> </ul> <p></p> <p></p> <p>Course to prerequisites mapping</p> <pre><code>flowchart LR\n    0((0)) --&gt; 1((1))\n    0((0)) --&gt; 2((2))\n    1((1)) --&gt; 3((3))\n    3((3)) --&gt; 4((4))\n    1((1)) --&gt; 4((4))</code></pre> <p>Prerequisites to course mapping</p> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    2((2)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))\n    4((4)) --&gt; 3((3))\n    4((4)) --&gt; 1((1))</code></pre> course 0 0 1 1 3 prerequisite 1 2 3 4 4 index 0 1 2 3 4 in-degree 0 0 0 0 0 <p>Initialize</p> <ul> <li>graph</li> </ul> prerequisite 1 2 3 4 course <code>[0]</code> <code>[0]</code> <code>[1]</code> <code>[1, 3]</code> <ul> <li>in-degree</li> </ul> 0 1 2 3 4 in-degree 2 2 0 1 0 <ul> <li>queue: <code>[2, 4]</code></li> <li>pop <code>2</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))\n    4((4)) --&gt; 3((3))\n    4((4)) --&gt; 1((1))</code></pre> 0 1 2 3 4 in-degree 1 2 0 1 0 <ul> <li>queue: <code>[4]</code></li> <li>pop <code>4</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))</code></pre> 0 1 2 3 4 in-degree 1 1 0 0 0 <ul> <li>queue: <code>[3]</code></li> <li>pop <code>3</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))</code></pre> 0 1 2 3 4 in-degree 1 0 0 0 0 <ul> <li>queue: <code>[1]</code></li> <li>pop <code>1</code> from the queue</li> </ul> <pre><code>flowchart LR\n    0((0))</code></pre> 0 1 2 3 4 in-degree 0 0 0 0 0 <ul> <li>queue: <code>[0]</code></li> <li>pop <code>0</code> from the queue</li> <li>All courses are taken. Return <code>True</code>.</li> </ul> 207. Course Schedule - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS (Kahn's Algorithm)\ndef canFinishBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    count = 0\n\n    while q:\n        crs = q.popleft()\n        count += 1\n\n        for nxt in graph[crs]:\n            indegree[nxt] -= 1\n\n            if indegree[nxt] == 0:\n                q.append(nxt)\n\n    return count == numCourses\n\n\n# DFS + Set\ndef canFinishDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for crs, pre in prerequisites:\n        graph[crs].append(pre)\n\n    visiting = set()\n\n    def dfs(crs):\n        if crs in visiting:  # cycle detected\n            return False\n        if graph[crs] == []:\n            return True\n\n        visiting.add(crs)\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        visiting.remove(crs)\n        graph[crs] = []\n\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\n# DFS + List\ndef canFinishDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for pre, crs in prerequisites:\n        graph[crs].append(pre)\n\n    # 0: init, 1: visiting, 2: visited\n    status = [0] * numCourses\n\n    def dfs(crs):\n        if status[crs] == 1:  # cycle detected\n            return False\n        if status[crs] == 2:\n            return True\n\n        status[crs] = 1\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        status[crs] = 2\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(canFinishBFS(5, prerequisites))  # True\nprint(canFinishDFS1(5, prerequisites))  # True\nprint(canFinishDFS2(5, prerequisites))  # True\n</code></pre>"},{"location":"endlesscheng/dfs_basics/#802-find-eventual-safe-states","title":"802. Find Eventual Safe States","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort</p> </li> </ul> 802. Find Eventual Safe States - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# Topological Sort\ndef eventualSafeNodesTS(graph: List[List[int]]) -&gt; List[int]:\n    n = len(graph)\n    reverse_graph = defaultdict(list)\n    indegree = [0 for _ in range(n)]\n    safe = [False for _ in range(n)]\n\n    for u in range(n):\n        for v in graph[u]:\n            reverse_graph[v].append(u)\n        indegree[u] = len(graph[u])\n\n    q = deque([i for i in range(n) if indegree[i] == 0])\n\n    while q:\n        node = q.popleft()\n        safe[node] = True\n\n        for neighbor in reverse_graph[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n\n    return [i for i in range(n) if safe[i]]\n\n\n# DFS\ndef eventualSafeNodesDFS(graph: List[List[int]]) -&gt; List[int]:\n    n = len(graph)\n    state = [0 for _ in range(n)]  # 0: unvisited, 1: visiting, 2: visited\n\n    def dfs(node):\n        if state[node] &gt; 0:\n            return state[node] == 2\n        state[node] = 1\n        for neighbor in graph[node]:\n            if state[neighbor] == 1 or not dfs(neighbor):\n                return False\n        state[node] = 2\n        return True\n\n    return [i for i in range(n) if dfs(i)]\n\n\ngraph = [[1, 2], [2, 3], [5], [0], [5], [], []]\nprint(eventualSafeNodesTS(graph))  # [2, 4, 5, 6]\nprint(eventualSafeNodesDFS(graph))  # [2, 4, 5, 6]\n</code></pre>"},{"location":"endlesscheng/dfs_basics/#928-minimize-malware-spread-ii","title":"928. Minimize Malware Spread II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, depth first search, breadth first search, union find, graph</p> </li> </ul>"},{"location":"endlesscheng/dfs_basics/#2092-find-all-people-with-secret","title":"2092. Find All People With Secret","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph, sorting</p> </li> </ul>"},{"location":"endlesscheng/dfs_basics/#3108-minimum-cost-walk-in-weighted-graph","title":"3108. Minimum Cost Walk in Weighted Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, bit manipulation, union find, graph</p> </li> </ul>"},{"location":"endlesscheng/dfs_basics/#261-graph-valid-tree","title":"261. Graph Valid Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> </ul> 261. Graph Valid Tree - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Graph\ndef validTree(n: int, edges: List[List[int]]) -&gt; bool:\n    if n == 0:\n        return False\n    if len(edges) != n - 1:\n        return False\n\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = set()\n\n    def dfs(node, parent):\n        if node in visited:\n            return False\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor != parent and not dfs(neighbor, node):\n                return False\n        return True\n\n    return dfs(0, -1) and len(visited) == n\n\n\nprint(validTree(5, [[0, 1], [0, 2], [0, 3], [1, 4]]))  # True\nprint(validTree(5, [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]))  # False\n</code></pre>"},{"location":"endlesscheng/dfs_basics/#323-number-of-connected-components-in-an-undirected-graph","title":"323. Number of Connected Components in an Undirected Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> </ul> 323. Number of Connected Components in an Undirected Graph - Python Solution<pre><code>from typing import List\n\n\n# Union Find\ndef countComponents(n: int, edges: List[List[int]]) -&gt; int:\n    uf = UnionFind(n)\n    count = n\n\n    for u, v in edges:\n        count -= uf.union(u, v)\n\n    return count\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(n)}\n        self.rank = {i: 1 for i in range(n)}\n\n    def find(self, n):\n        p = self.par[n]\n        while self.par[p] != p:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return 0\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.par[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.par[p1] = p2\n        else:\n            self.par[p2] = p1\n            self.rank[p1] += 1\n\n        return 1\n\n\nprint(countComponents(5, [[0, 1], [1, 2], [3, 4]]))  # 2\n</code></pre>"},{"location":"endlesscheng/distance_sum/","title":"Distance Sum","text":"<ul> <li> 1685. Sum of Absolute Differences in a Sorted Array (Medium)</li> <li> 2615. Sum of Distances (Medium)</li> <li> 2602. Minimum Operations to Make All Array Elements Equal (Medium)</li> <li> 2968. Apply Operations to Maximize Frequency Score (Hard)</li> <li> 1703. Minimum Adjacent Swaps for K Consecutive Ones (Hard)</li> <li> 3086. Minimum Moves to Pick K Ones (Hard)</li> <li> 3422. Minimum Operations to Make Subarray Elements Equal (Medium)</li> </ul>"},{"location":"endlesscheng/distance_sum/#1685-sum-of-absolute-differences-in-a-sorted-array","title":"1685. Sum of Absolute Differences in a Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/distance_sum/#2615-sum-of-distances","title":"2615. Sum of Distances","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/distance_sum/#2602-minimum-operations-to-make-all-array-elements-equal","title":"2602. Minimum Operations to Make All Array Elements Equal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sorting, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/distance_sum/#2968-apply-operations-to-maximize-frequency-score","title":"2968. Apply Operations to Maximize Frequency Score","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, sliding window, sorting, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/distance_sum/#1703-minimum-adjacent-swaps-for-k-consecutive-ones","title":"1703. Minimum Adjacent Swaps for K Consecutive Ones","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sliding window, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/distance_sum/#3086-minimum-moves-to-pick-k-ones","title":"3086. Minimum Moves to Pick K Ones","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sliding window, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/distance_sum/#3422-minimum-operations-to-make-subarray-elements-equal","title":"3422. Minimum Operations to Make Subarray Elements Equal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, sliding window, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/double_sequence_pairing/","title":"Double Sequence Pairing","text":"<ul> <li> 2037. Minimum Number of Moves to Seat Everyone (Easy)</li> <li> 455. Assign Cookies (Easy)</li> <li> 2410. Maximum Matching of Players With Trainers (Medium)</li> <li> 1433. Check If a String Can Break Another String (Medium)</li> <li> 870. Advantage Shuffle (Medium)</li> <li> 826. Most Profit Assigning Work (Medium)</li> <li> 2449. Minimum Number of Operations to Make Arrays Similar (Hard)</li> <li> 1889. Minimum Space Wasted From Packaging (Hard)</li> <li> 2561. Rearranging Fruits (Hard)</li> <li> 2323. Find Minimum Time to Finish All Jobs II (Medium)</li> </ul>"},{"location":"endlesscheng/double_sequence_pairing/#2037-minimum-number-of-moves-to-seat-everyone","title":"2037. Minimum Number of Moves to Seat Everyone","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, greedy, sorting, counting sort</p> </li> <li>Return the minimum number of moves needed to seat everyone.</li> </ul> 2037. Minimum Number of Moves to Seat Everyone - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef minMovesToSeat(seats: List[int], students: List[int]) -&gt; int:\n    seats.sort()\n    students.sort()\n    moves = 0\n\n    for i, j in zip(seats, students):\n        moves += abs(i - j)\n\n    return moves\n\n\nprint(minMovesToSeat([3, 1, 5], [2, 7, 4]))  # 4\n</code></pre>"},{"location":"endlesscheng/double_sequence_pairing/#455-assign-cookies","title":"455. Assign Cookies","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers, greedy, sorting</p> </li> <li>Return the maximum number of your content children that can be satisfied.</li> </ul> 455. Assign Cookies - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef findContentChildren(g: List[int], s: List[int]) -&gt; int:\n    g.sort()\n    s.sort()\n    i, j = 0, 0\n\n    while i &lt; len(g) and j &lt; len(s):\n        if g[i] &lt;= s[j]:\n            i += 1\n        j += 1\n\n    return i\n\n\n# |-------------|-------------|--------------|\n# |   Approach  |    Time     |    Space     |\n# |-------------|-------------|--------------|\n# |   Greedy    | O(N * logN) |    O(1)      |\n# |-------------|-------------|--------------|\n\n\ng = [1, 2, 3]\ns = [1, 1]\nprint(findContentChildren(g, s))  # 1\n</code></pre>"},{"location":"endlesscheng/double_sequence_pairing/#2410-maximum-matching-of-players-with-trainers","title":"2410. Maximum Matching of Players With Trainers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/double_sequence_pairing/#1433-check-if-a-string-can-break-another-string","title":"1433. Check If a String Can Break Another String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/double_sequence_pairing/#870-advantage-shuffle","title":"870. Advantage Shuffle","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/double_sequence_pairing/#826-most-profit-assigning-work","title":"826. Most Profit Assigning Work","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/double_sequence_pairing/#2449-minimum-number-of-operations-to-make-arrays-similar","title":"2449. Minimum Number of Operations to Make Arrays Similar","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/double_sequence_pairing/#1889-minimum-space-wasted-from-packaging","title":"1889. Minimum Space Wasted From Packaging","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, sorting, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/double_sequence_pairing/#2561-rearranging-fruits","title":"2561. Rearranging Fruits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, greedy</p> </li> </ul>"},{"location":"endlesscheng/double_sequence_pairing/#2323-find-minimum-time-to-finish-all-jobs-ii","title":"2323. Find Minimum Time to Finish All Jobs II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/dual_heap/","title":"Dual Heap","text":"<ul> <li> 2102. Sequentially Ordinal Rank Tracker (Hard)</li> <li> 295. Find Median from Data Stream (Hard)</li> <li> 480. Sliding Window Median (Hard)</li> <li> 1825. Finding MK Average (Hard)</li> <li> 3013. Divide an Array Into Subarrays With Minimum Cost II (Hard)</li> <li> 3321. Find X-Sum of All K-Long Subarrays II (Hard)</li> <li> 3369. Design an Array Statistics Tracker  (Hard)</li> <li> 3422. Minimum Operations to Make Subarray Elements Equal (Medium)</li> </ul>"},{"location":"endlesscheng/dual_heap/#2102-sequentially-ordinal-rank-tracker","title":"2102. Sequentially Ordinal Rank Tracker","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: design, heap priority queue, data stream, ordered set</p> </li> </ul>"},{"location":"endlesscheng/dual_heap/#295-find-median-from-data-stream","title":"295. Find Median from Data Stream","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: two pointers, design, sorting, heap priority queue, data stream</p> </li> </ul> 295. Find Median from Data Stream - Python Solution<pre><code>from heapq import heappop, heappush\n\n\n# Heap - Two Heaps\nclass MedianFinder:\n    def __init__(self):\n        self.max = []\n        self.min = []\n\n    def addNum(self, num: int) -&gt; None:\n        heappush(self.max, -num)\n        heappush(self.min, -heappop(self.max))\n\n        if len(self.min) &gt; len(self.max):\n            heappush(self.max, -heappop(self.min))\n\n    def findMedian(self) -&gt; float:\n        if len(self.max) == len(self.min):\n            return (-self.max[0] + self.min[0]) / 2.0\n        else:\n            return -self.max[0]\n\n\n# TC: O(log n)\n# SC: O(n)\n\nmedian_finder = MedianFinder()\nmedian_finder.addNum(1)\nmedian_finder.addNum(2)\nassert median_finder.findMedian() == 1.5\nmedian_finder.addNum(3)\nassert median_finder.findMedian() == 2\nmedian_finder.addNum(4)\nassert median_finder.findMedian() == 2.5\nmedian_finder.addNum(5)\nassert median_finder.findMedian() == 3\nprint(\"All Passed.\")\n</code></pre>"},{"location":"endlesscheng/dual_heap/#480-sliding-window-median","title":"480. Sliding Window Median","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, sliding window, heap priority queue</p> </li> </ul> 480. Sliding Window Median - Python Solution<pre><code>import heapq\nfrom typing import List\n\nfrom sortedcontainers import SortedList\n\n\n# Heap - Two Heaps\ndef medianSlidingWindow1(nums: List[int], k: int) -&gt; List[float]:\n    min_heap, max_heap = [], []\n\n    for i in range(k):\n        heapq.heappush(min_heap, (nums[i], i))\n    for i in range(k // 2):\n        n, idx = heapq.heappop(min_heap)\n        heapq.heappush(max_heap, (-n, idx))\n\n    res = [\n        (\n            (min_heap[0][0] - max_heap[0][0]) / 2\n            if k % 2 == 0\n            else min_heap[0][0] * 1.0\n        )\n    ]\n\n    for i in range(k, len(nums)):\n        if nums[i] &lt; min_heap[0][0]:\n            heapq.heappush(max_heap, (-nums[i], i))\n\n            if nums[i - k] &gt;= min_heap[0][0]:\n                n, idx = heapq.heappop(max_heap)\n                heapq.heappush(min_heap, (-n, idx))\n        else:\n            heapq.heappush(min_heap, (nums[i], i))\n\n            if nums[i - k] &lt;= min_heap[0][0]:\n                n, idx = heapq.heappop(min_heap)\n                heapq.heappush(max_heap, (-n, idx))\n\n        while min_heap and min_heap[0][1] &lt;= i - k:\n            heapq.heappop(min_heap)\n        while max_heap and max_heap[0][1] &lt;= i - k:\n            heapq.heappop(max_heap)\n\n        res.append(\n            (min_heap[0][0] - max_heap[0][0]) / 2\n            if k % 2 == 0\n            else min_heap[0][0] * 1.0\n        )\n\n    return res\n\n\n# Sorted List\ndef medianSlidingWindow2(nums: List[int], k: int) -&gt; List[float]:\n    window = SortedList()\n    res = []\n\n    for i in range(len(nums)):\n        window.add(nums[i])\n\n        if len(window) == k:\n            if k % 2 == 1:\n                res.append(window[k // 2])\n            else:\n                res.append((window[k // 2 - 1] + window[k // 2]) / 2.0)\n\n            window.remove(nums[i - k + 1])\n\n    return res\n\n\nnums = [1, 2, 3, 4, 2, 3, 1, 4, 2]\nk = 3\nprint(medianSlidingWindow1(nums, k))\nprint(medianSlidingWindow2(nums, k))\n</code></pre>"},{"location":"endlesscheng/dual_heap/#1825-finding-mk-average","title":"1825. Finding MK Average","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: design, queue, heap priority queue, data stream, ordered set</p> </li> </ul>"},{"location":"endlesscheng/dual_heap/#3013-divide-an-array-into-subarrays-with-minimum-cost-ii","title":"3013. Divide an Array Into Subarrays With Minimum Cost II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, sliding window, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/dual_heap/#3321-find-x-sum-of-all-k-long-subarrays-ii","title":"3321. Find X-Sum of All K-Long Subarrays II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, sliding window, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/dual_heap/#3369-design-an-array-statistics-tracker","title":"3369. Design an Array Statistics Tracker","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, binary search, design, queue, heap priority queue, data stream, ordered set</p> </li> </ul>"},{"location":"endlesscheng/dual_heap/#3422-minimum-operations-to-make-subarray-elements-equal","title":"3422. Minimum Operations to Make Subarray Elements Equal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, sliding window, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/dual_stack/","title":"Dual Stack","text":"<ul> <li> 2296. Design a Text Editor (Hard)</li> </ul>"},{"location":"endlesscheng/dual_stack/#2296-design-a-text-editor","title":"2296. Design a Text Editor","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: linked list, string, stack, design, simulation, doubly linked list</p> </li> </ul>"},{"location":"endlesscheng/dynamic_segment_tree/","title":"Dynamic Segment Tree","text":"<ul> <li> 699. Falling Squares (Hard)</li> <li> 715. Range Module (Hard)</li> <li> 729. My Calendar I (Medium)</li> <li> 731. My Calendar II (Medium)</li> <li> 732. My Calendar III (Hard)</li> <li> 2276. Count Integers in Intervals (Hard)</li> <li> 2770. Maximum Number of Jumps to Reach the Last Index (Medium)</li> </ul>"},{"location":"endlesscheng/dynamic_segment_tree/#699-falling-squares","title":"699. Falling Squares","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, segment tree, ordered set</p> </li> </ul>"},{"location":"endlesscheng/dynamic_segment_tree/#715-range-module","title":"715. Range Module","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: design, segment tree, ordered set</p> </li> </ul>"},{"location":"endlesscheng/dynamic_segment_tree/#729-my-calendar-i","title":"729. My Calendar I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, design, segment tree, ordered set</p> </li> </ul>"},{"location":"endlesscheng/dynamic_segment_tree/#731-my-calendar-ii","title":"731. My Calendar II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, design, segment tree, prefix sum, ordered set</p> </li> </ul>"},{"location":"endlesscheng/dynamic_segment_tree/#732-my-calendar-iii","title":"732. My Calendar III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: binary search, design, segment tree, prefix sum, ordered set</p> </li> </ul>"},{"location":"endlesscheng/dynamic_segment_tree/#2276-count-integers-in-intervals","title":"2276. Count Integers in Intervals","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: design, segment tree, ordered set</p> </li> </ul>"},{"location":"endlesscheng/dynamic_segment_tree/#2770-maximum-number-of-jumps-to-reach-the-last-index","title":"2770. Maximum Number of Jumps to Reach the Last Index","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"endlesscheng/edge_weighted_union_find/","title":"Edge Weighted Union Find","text":"<ul> <li> 399. Evaluate Division (Medium)</li> <li> 2307. Check for Contradictions in Equations (Hard)</li> </ul>"},{"location":"endlesscheng/edge_weighted_union_find/#399-evaluate-division","title":"399. Evaluate Division","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, depth first search, breadth first search, union find, graph, shortest path</p> </li> </ul> 399. Evaluate Division - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef calcEquation(\n    equations: List[List[str]], values: List[float], queries: List[List[str]]\n) -&gt; List[float]:\n    graph = defaultdict(dict)\n    for (a, b), v in zip(equations, values):\n        graph[a][b] = v\n        graph[b][a] = 1 / v\n\n    def dfs(a, b, visited):\n        if a not in graph or b not in graph:\n            return -1.0\n\n        if b in graph[a]:\n            return graph[a][b]\n\n        for c in graph[a]:\n            if c not in visited:\n                visited.add(c)\n                d = dfs(c, b, visited)\n                if d != -1.0:\n                    return graph[a][c] * d\n        return -1.0\n\n    result = []\n    for a, b in queries:\n        result.append(dfs(a, b, set()))\n\n    return result\n\n\nequations = [[\"a\", \"b\"], [\"b\", \"c\"]]\nvalues = [2.0, 3.0]\nqueries = [[\"a\", \"c\"], [\"b\", \"a\"], [\"a\", \"e\"], [\"a\", \"a\"], [\"x\", \"x\"]]\nprint(calcEquation(equations, values, queries))  # [6.0, 0.5, -1.0, 1.0, -1.0]\n</code></pre>"},{"location":"endlesscheng/edge_weighted_union_find/#2307-check-for-contradictions-in-equations","title":"2307. Check for Contradictions in Equations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, depth first search, union find, graph</p> </li> </ul>"},{"location":"endlesscheng/enumerate_middle/","title":"Enumerate Middle","text":"<ul> <li> 2909. Minimum Sum of Mountain Triplets II (Medium)</li> <li> 1930. Unique Length-3 Palindromic Subsequences (Medium)</li> <li> 3128. Right Triangles (Medium)</li> <li> 2874. Maximum Value of an Ordered Triplet II (Medium)</li> <li> 447. Number of Boomerangs (Medium)</li> <li> 456. 132 Pattern (Medium)</li> <li> 3067. Count Pairs of Connectable Servers in a Weighted Tree Network (Medium)</li> <li> 3455. Shortest Matching Substring (Hard)</li> <li> 2242. Maximum Score of a Node Sequence (Hard)</li> <li> 2867. Count Valid Paths in a Tree (Hard)</li> <li> 2552. Count Increasing Quadruplets (Hard)</li> <li> 3257. Maximum Value Sum by Placing Three Rooks II (Hard)</li> <li> 3073. Maximum Increasing Triplet Value (Medium)</li> </ul>"},{"location":"endlesscheng/enumerate_middle/#2909-minimum-sum-of-mountain-triplets-ii","title":"2909. Minimum Sum of Mountain Triplets II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array</p> </li> </ul>"},{"location":"endlesscheng/enumerate_middle/#1930-unique-length-3-palindromic-subsequences","title":"1930. Unique Length-3 Palindromic Subsequences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, bit manipulation, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/enumerate_middle/#3128-right-triangles","title":"3128. Right Triangles","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, combinatorics, counting</p> </li> </ul>"},{"location":"endlesscheng/enumerate_middle/#2874-maximum-value-of-an-ordered-triplet-ii","title":"2874. Maximum Value of an Ordered Triplet II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array</p> </li> </ul>"},{"location":"endlesscheng/enumerate_middle/#447-number-of-boomerangs","title":"447. Number of Boomerangs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math</p> </li> </ul>"},{"location":"endlesscheng/enumerate_middle/#456-132-pattern","title":"456. 132 Pattern","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, stack, monotonic stack, ordered set</p> </li> </ul> 456. 132 Pattern - Python Solution<pre><code>from typing import List\n\n\n# Monotonic Stack\ndef find132pattern(nums: List[int]) -&gt; bool:\n    n = len(nums)\n    if n &lt; 3:\n        return False\n\n    stack = []\n    second_max = float(\"-inf\")\n\n    for i in range(n - 1, -1, -1):\n        if nums[i] &lt; second_max:\n            return True\n\n        while stack and stack[-1] &lt; nums[i]:\n            second_max = stack.pop()\n\n        stack.append(nums[i])\n\n    return False\n\n\nnums = [-1, 3, 2, 0]\nprint(find132pattern(nums))  # True\n</code></pre>"},{"location":"endlesscheng/enumerate_middle/#3067-count-pairs-of-connectable-servers-in-a-weighted-tree-network","title":"3067. Count Pairs of Connectable Servers in a Weighted Tree Network","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, tree, depth first search</p> </li> </ul>"},{"location":"endlesscheng/enumerate_middle/#3455-shortest-matching-substring","title":"3455. Shortest Matching Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: two pointers, string, binary search, string matching</p> </li> </ul>"},{"location":"endlesscheng/enumerate_middle/#2242-maximum-score-of-a-node-sequence","title":"2242. Maximum Score of a Node Sequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, graph, sorting, enumeration</p> </li> </ul>"},{"location":"endlesscheng/enumerate_middle/#2867-count-valid-paths-in-a-tree","title":"2867. Count Valid Paths in a Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, dynamic programming, tree, depth first search, number theory</p> </li> </ul>"},{"location":"endlesscheng/enumerate_middle/#2552-count-increasing-quadruplets","title":"2552. Count Increasing Quadruplets","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, binary indexed tree, enumeration, prefix sum</p> </li> </ul> 2552. Count Increasing Quadruplets - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef countQuadruplets(nums: List[int]) -&gt; int:\n    n = len(nums)\n    great = [[0] * (n + 1) for _ in range(n)]\n    less = [0 for _ in range(n + 1)]\n\n    for k in range(n - 2, 1, -1):\n        great[k] = great[k + 1].copy()\n        for x in range(1, nums[k + 1]):\n            great[k][x] += 1\n\n    ans = 0\n\n    for j in range(1, n - 1):\n        for x in range(nums[j - 1] + 1, n + 1):\n            less[x] += 1\n        for k in range(j + 1, n - 1):\n            if nums[j] &gt; nums[k]:\n                ans += less[nums[k]] * great[k][nums[j]]\n    return ans\n\n\nnums = [1, 3, 2, 4, 5]\nprint(countQuadruplets(nums))  # 2\n</code></pre>"},{"location":"endlesscheng/enumerate_middle/#3257-maximum-value-sum-by-placing-three-rooks-ii","title":"3257. Maximum Value Sum by Placing Three Rooks II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, matrix, enumeration</p> </li> </ul>"},{"location":"endlesscheng/enumerate_middle/#3073-maximum-increasing-triplet-value","title":"3073. Maximum Increasing Triplet Value","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, ordered set</p> </li> </ul>"},{"location":"endlesscheng/enumerate_right%2C_maintain_left/","title":"Enumerate Right, Maintain Left","text":"<ul> <li> 1. Two Sum (Easy)</li> <li> 1512. Number of Good Pairs (Easy)</li> <li> 2001. Number of Pairs of Interchangeable Rectangles (Medium)</li> <li> 219. Contains Duplicate II (Easy)</li> <li> 121. Best Time to Buy and Sell Stock (Easy)</li> <li> 624. Maximum Distance in Arrays (Medium)</li> <li> 2815. Max Pair Sum in an Array (Easy)</li> <li> 2342. Max Sum of a Pair With Equal Sum of Digits (Medium)</li> <li> 1679. Max Number of K-Sum Pairs (Medium)</li> <li> 2260. Minimum Consecutive Cards to Pick Up (Medium)</li> <li> 1010. Pairs of Songs With Total Durations Divisible by 60 (Medium)</li> <li> 3185. Count Pairs That Form a Complete Day II (Medium)</li> <li> 2506. Count Pairs Of Similar Strings (Easy)</li> <li> 2748. Number of Beautiful Pairs (Easy)</li> <li> 2874. Maximum Value of an Ordered Triplet II (Medium)</li> <li> 1014. Best Sightseeing Pair (Medium)</li> <li> 1814. Count Nice Pairs in an Array (Medium)</li> <li> 2905. Find Indices With Index and Value Difference II (Medium)</li> <li> 1031. Maximum Sum of Two Non-Overlapping Subarrays (Medium)</li> <li> 2555. Maximize Win From Two Segments (Medium)</li> <li> 1995. Count Special Quadruplets (Easy)</li> <li> 3404. Count Special Subsequences (Medium)</li> <li> 3267. Count Almost Equal Pairs II (Hard)</li> <li> 1214. Two Sum BSTs (Medium)</li> <li> 2964. Number of Divisible Triplet Sums (Medium)</li> <li> 2441. Largest Positive Integer That Exists With Its Negative (Easy)</li> <li> 454. 4Sum II (Medium)</li> <li> 3371. Identify the Largest Outlier in an Array (Medium)</li> </ul>"},{"location":"endlesscheng/enumerate_right%2C_maintain_left/#1-two-sum","title":"1. Two Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table</p> </li> <li>Return the indices of the two numbers such that they add up to a specific target.</li> </ul> Approach Time Complexity Space Complexity Hashmap O(n) O(n) 1. Two Sum - Python Solution<pre><code>from typing import List\n\n\n# Hashmap\ndef twoSum(nums: List[int], target: int) -&gt; List[int]:\n    hashmap = {}  # val: idx\n\n    for idx, val in enumerate(nums):\n        if (target - val) in hashmap:\n            return [hashmap[target - val], idx]\n\n        hashmap[val] = idx\n\n\nnums = [2, 7, 11, 15]\ntarget = 18\nassert twoSum(nums, target) == [1, 2]\n</code></pre>"},{"location":"endlesscheng/enumerate_right%2C_maintain_left/#1512-number-of-good-pairs","title":"1512. Number of Good Pairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, math, counting</p> </li> </ul> 1512. Number of Good Pairs - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash\ndef numIdenticalPairs(nums: List[int]) -&gt; int:\n    res = 0\n    counts = defaultdict(int)  # num: count\n\n    for num in nums:\n        res += counts[num]\n        counts[num] += 1\n\n    return res\n\n\nnums = [1, 2, 3, 1, 1, 3]\nprint(numIdenticalPairs(nums))  # 4\n</code></pre>"},{"location":"endlesscheng/enumerate_right%2C_maintain_left/#2001-number-of-pairs-of-interchangeable-rectangles","title":"2001. Number of Pairs of Interchangeable Rectangles","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, counting, number theory</p> </li> </ul> 2001. Number of Pairs of Interchangeable Rectangles - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash\ndef interchangeableRectangles(rectangles: List[List[int]]) -&gt; int:\n    res = 0\n    counts = defaultdict(int)\n\n    for w, h in rectangles:\n        ratio = w / h\n        res += counts[ratio]\n        counts[ratio] += 1\n\n    return res\n\n\nrectangles = [[4, 8], [3, 6], [10, 20], [15, 30]]\nprint(interchangeableRectangles(rectangles))  # 6\n</code></pre>"},{"location":"endlesscheng/enumerate_right%2C_maintain_left/#219-contains-duplicate-ii","title":"219. Contains Duplicate II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, sliding window</p> </li> </ul> 219. Contains Duplicate II - Python Solution<pre><code>from typing import List\n\n\n# Hash\ndef containsNearbyDuplicateHash(nums: List[int], k: int) -&gt; bool:\n    hashmap = {}  # num: last index\n\n    for idx, num in enumerate(nums):\n        if num in hashmap:\n            if idx - hashmap[num] &lt;= k:\n                return True\n\n        hashmap[num] = idx\n\n    return False\n\n\n# Sliding window - Fixed\ndef containsNearbyDuplicateWindow(nums: List[int], k: int) -&gt; bool:\n    window = set()\n    left = 0\n\n    for right in range(len(nums)):\n        if right - left &gt; k:\n            window.remove(nums[left])\n            left += 1\n        if nums[right] in window:\n            return True\n        window.add(nums[right])\n\n    return False\n\n\nnums = [1, 2, 3, 1]\nk = 3\nprint(containsNearbyDuplicateHash(nums, k))  # True\nprint(containsNearbyDuplicateWindow(nums, k))  # True\n</code></pre>"},{"location":"endlesscheng/enumerate_right%2C_maintain_left/#121-best-time-to-buy-and-sell-stock","title":"121. Best Time to Buy and Sell Stock","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li>Return the maximum profit that can be achieved from buying on one day and selling on another day.</li> </ul> 121. Best Time to Buy and Sell Stock - Python Solution<pre><code>from typing import List\n\n\n# Brute Force\ndef maxProfitBF(prices: List[int]) -&gt; int:\n    max_profit = 0\n    n = len(prices)\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_profit = max(max_profit, prices[j] - prices[i])\n\n    return max_profit\n\n\n# DP\ndef maxProfitDP(prices: List[int]) -&gt; int:\n    dp = [[0] * 2 for _ in range(len(prices))]\n    dp[0][0] = -prices[0]  # buy\n    dp[0][1] = 0  # sell\n\n    for i in range(1, len(prices)):\n        dp[i][0] = max(dp[i - 1][0], -prices[i])  # the lowest price to buy\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    max_profit = 0\n    seen_min = prices[0]\n\n    for i in range(1, len(prices)):\n        max_profit = max(max_profit, prices[i] - seen_min)\n        seen_min = min(seen_min, prices[i])\n\n    return max_profit\n\n\n# Fast Slow Pointers\ndef maxProfitFS(prices: List[int]) -&gt; int:\n    max_profit = 0\n    slow, fast = 0, 1\n\n    while fast &lt; len(prices):\n        if prices[fast] &gt; prices[slow]:\n            max_profit = max(max_profit, prices[fast] - prices[slow])\n        else:\n            slow = fast\n        fast += 1\n\n    return max_profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force|  O(n^2)|  O(1)   |\n# | DP         |  O(n)  |  O(n)   |\n# | Greedy     |  O(n)  |  O(1)   |\n# | Fast Slow  |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitBF(prices))  # 5\nprint(maxProfitDP(prices))  # 5\nprint(maxProfitGreedy(prices))  # 5\nprint(maxProfitFS(prices))  # 5\n</code></pre>"},{"location":"endlesscheng/enumerate_right%2C_maintain_left/#624-maximum-distance-in-arrays","title":"624. Maximum Distance in Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy</p> </li> </ul> 624. Maximum Distance in Arrays - Python Solution<pre><code>from typing import List\n\n\n# Array\ndef maxDistance(arrays: List[List[int]]) -&gt; int:\n    mn, mx = float(\"inf\"), float(\"-inf\")\n    res = 0\n\n    for array in arrays:\n        mn = min(mn, array[0])\n        mx = max(mx, array[-1])\n        res = max(res, abs(array[-1] - mn), abs(mx - array[0]))\n\n    return res\n\n\narrays = [[1, 2, 3], [4, 5], [1, 2, 3]]\nprint(maxDistance(arrays))  # 4\n</code></pre>"},{"location":"endlesscheng/enumerate_right%2C_maintain_left/#2815-max-pair-sum-in-an-array","title":"2815. Max Pair Sum in an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table</p> </li> </ul>"},{"location":"endlesscheng/enumerate_right%2C_maintain_left/#2342-max-sum-of-a-pair-with-equal-sum-of-digits","title":"2342. Max Sum of a Pair With Equal Sum of Digits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, sorting, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/enumerate_right%2C_maintain_left/#1679-max-number-of-k-sum-pairs","title":"1679. Max Number of K-Sum Pairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, two pointers, sorting</p> </li> </ul>"},{"location":"endlesscheng/enumerate_right%2C_maintain_left/#2260-minimum-consecutive-cards-to-pick-up","title":"2260. Minimum Consecutive Cards to Pick Up","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, sliding window</p> </li> </ul>"},{"location":"endlesscheng/enumerate_right%2C_maintain_left/#1010-pairs-of-songs-with-total-durations-divisible-by-60","title":"1010. Pairs of Songs With Total Durations Divisible by 60","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, counting</p> </li> </ul>"},{"location":"endlesscheng/enumerate_right%2C_maintain_left/#3185-count-pairs-that-form-a-complete-day-ii","title":"3185. Count Pairs That Form a Complete Day II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, counting</p> </li> </ul>"},{"location":"endlesscheng/enumerate_right%2C_maintain_left/#2506-count-pairs-of-similar-strings","title":"2506. Count Pairs Of Similar Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, string, bit manipulation, counting</p> </li> </ul>"},{"location":"endlesscheng/enumerate_right%2C_maintain_left/#2748-number-of-beautiful-pairs","title":"2748. Number of Beautiful Pairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, math, counting, number theory</p> </li> </ul>"},{"location":"endlesscheng/enumerate_right%2C_maintain_left/#2874-maximum-value-of-an-ordered-triplet-ii","title":"2874. Maximum Value of an Ordered Triplet II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array</p> </li> </ul>"},{"location":"endlesscheng/enumerate_right%2C_maintain_left/#1014-best-sightseeing-pair","title":"1014. Best Sightseeing Pair","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"endlesscheng/enumerate_right%2C_maintain_left/#1814-count-nice-pairs-in-an-array","title":"1814. Count Nice Pairs in an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, counting</p> </li> </ul>"},{"location":"endlesscheng/enumerate_right%2C_maintain_left/#2905-find-indices-with-index-and-value-difference-ii","title":"2905. Find Indices With Index and Value Difference II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers</p> </li> </ul>"},{"location":"endlesscheng/enumerate_right%2C_maintain_left/#1031-maximum-sum-of-two-non-overlapping-subarrays","title":"1031. Maximum Sum of Two Non-Overlapping Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, sliding window</p> </li> </ul>"},{"location":"endlesscheng/enumerate_right%2C_maintain_left/#2555-maximize-win-from-two-segments","title":"2555. Maximize Win From Two Segments","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sliding window</p> </li> </ul> 2555. Maximize Win From Two Segments - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window - Variable\ndef maximizeWin(prizePositions: List[int], k: int) -&gt; int:\n    n = len(prizePositions)\n\n    if 2 * k &gt;= prizePositions[-1] - prizePositions[0]:\n        return n\n\n    ans = left = 0\n    mx = [0] * (n + 1)\n\n    for right, p in enumerate(prizePositions):\n        while p - prizePositions[left] &gt; k:\n            left += 1\n        ans = max(ans, mx[left] + right - left + 1)\n        mx[right + 1] = max(mx[right], right - left + 1)\n\n    return ans\n\n\nprizePositions = [1, 1, 2, 2, 3, 3, 5]\nk = 2\nprint(maximizeWin(prizePositions, k))  # 7\n</code></pre>"},{"location":"endlesscheng/enumerate_right%2C_maintain_left/#1995-count-special-quadruplets","title":"1995. Count Special Quadruplets","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, enumeration</p> </li> </ul>"},{"location":"endlesscheng/enumerate_right%2C_maintain_left/#3404-count-special-subsequences","title":"3404. Count Special Subsequences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, enumeration</p> </li> </ul>"},{"location":"endlesscheng/enumerate_right%2C_maintain_left/#3267-count-almost-equal-pairs-ii","title":"3267. Count Almost Equal Pairs II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, sorting, counting, enumeration</p> </li> </ul>"},{"location":"endlesscheng/enumerate_right%2C_maintain_left/#1214-two-sum-bsts","title":"1214. Two Sum BSTs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, binary search, stack, tree, depth first search, binary search tree, binary tree</p> </li> </ul>"},{"location":"endlesscheng/enumerate_right%2C_maintain_left/#2964-number-of-divisible-triplet-sums","title":"2964. Number of Divisible Triplet Sums","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table</p> </li> </ul>"},{"location":"endlesscheng/enumerate_right%2C_maintain_left/#2441-largest-positive-integer-that-exists-with-its-negative","title":"2441. Largest Positive Integer That Exists With Its Negative","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, two pointers, sorting</p> </li> </ul>"},{"location":"endlesscheng/enumerate_right%2C_maintain_left/#454-4sum-ii","title":"454. 4Sum II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table</p> </li> <li>Return the number of tuples <code>(i, j, k, l)</code> such that <code>A[i] + B[j] + C[k] + D[l] == 0</code>.</li> </ul> 454. 4Sum II - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\ndef fourSumCount(\n    nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]\n) -&gt; int:\n\n    sumAB = defaultdict(int)\n    result = 0\n\n    for i in nums1:\n        for j in nums2:\n            sumAB[i + j] += 1\n\n    for i in nums3:\n        for j in nums4:\n            if -(i + j) in sumAB:\n                result += sumAB[-(i + j)]\n\n    return result\n\n\nnums1 = [1, 2]\nnums2 = [-2, -1]\nnums3 = [-1, 2]\nnums4 = [0, 2]\nprint(fourSumCount(nums1, nums2, nums3, nums4))  # 2\n</code></pre>"},{"location":"endlesscheng/enumerate_right%2C_maintain_left/#3371-identify-the-largest-outlier-in-an-array","title":"3371. Identify the Largest Outlier in an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, counting, enumeration</p> </li> </ul>"},{"location":"endlesscheng/enumerate_right_maintain_left/","title":"Enumerate Right Maintain Left","text":"<ul> <li> 1. Two Sum (Easy)</li> <li> 1512. Number of Good Pairs (Easy)</li> <li> 2001. Number of Pairs of Interchangeable Rectangles (Medium)</li> <li> 219. Contains Duplicate II (Easy)</li> <li> 121. Best Time to Buy and Sell Stock (Easy)</li> <li> 624. Maximum Distance in Arrays (Medium)</li> <li> 2815. Max Pair Sum in an Array (Easy)</li> <li> 2342. Max Sum of a Pair With Equal Sum of Digits (Medium)</li> </ul>"},{"location":"endlesscheng/enumerate_right_maintain_left/#1-two-sum","title":"1. Two Sum","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, hash table</li> <li>Return the indices of the two numbers such that they add up to a specific target.</li> </ul> Approach Time Complexity Space Complexity Hashmap O(n) O(n) 1. Two Sum - Python Solution<pre><code>from typing import List\n\n\n# Hashmap\ndef twoSum(nums: List[int], target: int) -&gt; List[int]:\n    hashmap = {}  # val: idx\n\n    for idx, val in enumerate(nums):\n        if (target - val) in hashmap:\n            return [hashmap[target - val], idx]\n\n        hashmap[val] = idx\n\n\nnums = [2, 7, 11, 15]\ntarget = 18\nassert twoSum(nums, target) == [1, 2]\n</code></pre>"},{"location":"endlesscheng/enumerate_right_maintain_left/#1512-number-of-good-pairs","title":"1512. Number of Good Pairs","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, hash table, math, counting</li> </ul> 1512. Number of Good Pairs - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash\ndef numIdenticalPairs(nums: List[int]) -&gt; int:\n    res = 0\n    counts = defaultdict(int)  # num: count\n\n    for num in nums:\n        res += counts[num]\n        counts[num] += 1\n\n    return res\n\n\nnums = [1, 2, 3, 1, 1, 3]\nprint(numIdenticalPairs(nums))  # 4\n</code></pre>"},{"location":"endlesscheng/enumerate_right_maintain_left/#2001-number-of-pairs-of-interchangeable-rectangles","title":"2001. Number of Pairs of Interchangeable Rectangles","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, math, counting, number theory</li> </ul> 2001. Number of Pairs of Interchangeable Rectangles - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash\ndef interchangeableRectangles(rectangles: List[List[int]]) -&gt; int:\n    res = 0\n    counts = defaultdict(int)\n\n    for w, h in rectangles:\n        ratio = w / h\n        res += counts[ratio]\n        counts[ratio] += 1\n\n    return res\n\n\nrectangles = [[4, 8], [3, 6], [10, 20], [15, 30]]\nprint(interchangeableRectangles(rectangles))  # 6\n</code></pre>"},{"location":"endlesscheng/enumerate_right_maintain_left/#219-contains-duplicate-ii","title":"219. Contains Duplicate II","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, hash table, sliding window</li> </ul> 219. Contains Duplicate II - Python Solution<pre><code>from typing import List\n\n\n# Hash\ndef containsNearbyDuplicateHash(nums: List[int], k: int) -&gt; bool:\n    hashmap = {}  # num: last index\n\n    for idx, num in enumerate(nums):\n        if num in hashmap:\n            if idx - hashmap[num] &lt;= k:\n                return True\n\n        hashmap[num] = idx\n\n    return False\n\n\n# Sliding window - Fixed\ndef containsNearbyDuplicateWindow(nums: List[int], k: int) -&gt; bool:\n    window = set()\n    left = 0\n\n    for right in range(len(nums)):\n        if right - left &gt; k:\n            window.remove(nums[left])\n            left += 1\n        if nums[right] in window:\n            return True\n        window.add(nums[right])\n\n    return False\n\n\nnums = [1, 2, 3, 1]\nk = 3\nprint(containsNearbyDuplicateHash(nums, k))  # True\nprint(containsNearbyDuplicateWindow(nums, k))  # True\n</code></pre>"},{"location":"endlesscheng/enumerate_right_maintain_left/#121-best-time-to-buy-and-sell-stock","title":"121. Best Time to Buy and Sell Stock","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, dynamic programming</li> <li>Return the maximum profit that can be achieved from buying on one day and selling on another day.</li> </ul> 121. Best Time to Buy and Sell Stock - Python Solution<pre><code>from typing import List\n\n\n# Brute Force\ndef maxProfitBF(prices: List[int]) -&gt; int:\n    max_profit = 0\n    n = len(prices)\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_profit = max(max_profit, prices[j] - prices[i])\n\n    return max_profit\n\n\n# DP\ndef maxProfitDP(prices: List[int]) -&gt; int:\n    dp = [[0] * 2 for _ in range(len(prices))]\n    dp[0][0] = -prices[0]  # buy\n    dp[0][1] = 0  # sell\n\n    for i in range(1, len(prices)):\n        dp[i][0] = max(dp[i - 1][0], -prices[i])  # the lowest price to buy\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    max_profit = 0\n    seen_min = prices[0]\n\n    for i in range(1, len(prices)):\n        max_profit = max(max_profit, prices[i] - seen_min)\n        seen_min = min(seen_min, prices[i])\n\n    return max_profit\n\n\n# Fast Slow Pointers\ndef maxProfitFS(prices: List[int]) -&gt; int:\n    max_profit = 0\n    slow, fast = 0, 1\n\n    while fast &lt; len(prices):\n        if prices[fast] &gt; prices[slow]:\n            max_profit = max(max_profit, prices[fast] - prices[slow])\n        else:\n            slow = fast\n        fast += 1\n\n    return max_profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force|  O(n^2)|  O(1)   |\n# | DP         |  O(n)  |  O(n)   |\n# | Greedy     |  O(n)  |  O(1)   |\n# | Fast Slow  |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitBF(prices))  # 5\nprint(maxProfitDP(prices))  # 5\nprint(maxProfitGreedy(prices))  # 5\nprint(maxProfitFS(prices))  # 5\n</code></pre>"},{"location":"endlesscheng/enumerate_right_maintain_left/#624-maximum-distance-in-arrays","title":"624. Maximum Distance in Arrays","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, greedy</li> </ul> 624. Maximum Distance in Arrays - Python Solution<pre><code>from typing import List\n\n\n# Array\ndef maxDistance(arrays: List[List[int]]) -&gt; int:\n    mn, mx = float(\"inf\"), float(\"-inf\")\n    res = 0\n\n    for array in arrays:\n        mn = min(mn, array[0])\n        mx = max(mx, array[-1])\n        res = max(res, abs(array[-1] - mn), abs(mx - array[0]))\n\n    return res\n\n\narrays = [[1, 2, 3], [4, 5], [1, 2, 3]]\nprint(maxDistance(arrays))  # 4\n</code></pre>"},{"location":"endlesscheng/enumerate_right_maintain_left/#2815-max-pair-sum-in-an-array","title":"2815. Max Pair Sum in an Array","text":"<ul> <li>LeetCode | LeetCode CH (Easy)</li> <li>Tags: array, hash table</li> </ul>"},{"location":"endlesscheng/enumerate_right_maintain_left/#2342-max-sum-of-a-pair-with-equal-sum-of-digits","title":"2342. Max Sum of a Pair With Equal Sum of Digits","text":"<ul> <li>LeetCode | LeetCode CH (Medium)</li> <li>Tags: array, hash table, sorting, heap priority queue</li> </ul>"},{"location":"endlesscheng/enumerate_then_greedy/","title":"Enumerate then Greedy","text":"<ul> <li> 2171. Removing Minimum Number of Magic Beans (Medium)</li> <li> 3085. Minimum Deletions to Make String K-Special (Medium)</li> <li> 1727. Largest Submatrix With Rearrangements (Medium)</li> <li> 2749. Minimum Operations to Make the Integer Zero (Medium)</li> <li> 2910. Minimum Number of Groups to Create a Valid Assignment (Medium)</li> <li> 2234. Maximum Total Beauty of the Gardens (Hard)</li> </ul>"},{"location":"endlesscheng/enumerate_then_greedy/#2171-removing-minimum-number-of-magic-beans","title":"2171. Removing Minimum Number of Magic Beans","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting, enumeration, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/enumerate_then_greedy/#3085-minimum-deletions-to-make-string-k-special","title":"3085. Minimum Deletions to Make String K-Special","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, greedy, sorting, counting</p> </li> </ul>"},{"location":"endlesscheng/enumerate_then_greedy/#1727-largest-submatrix-with-rearrangements","title":"1727. Largest Submatrix With Rearrangements","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting, matrix</p> </li> </ul>"},{"location":"endlesscheng/enumerate_then_greedy/#2749-minimum-operations-to-make-the-integer-zero","title":"2749. Minimum Operations to Make the Integer Zero","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: bit manipulation, brainteaser, enumeration</p> </li> </ul>"},{"location":"endlesscheng/enumerate_then_greedy/#2910-minimum-number-of-groups-to-create-a-valid-assignment","title":"2910. Minimum Number of Groups to Create a Valid Assignment","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, greedy</p> </li> </ul>"},{"location":"endlesscheng/enumerate_then_greedy/#2234-maximum-total-beauty-of-the-gardens","title":"2234. Maximum Total Beauty of the Gardens","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, binary search, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/equivalent_transformation/","title":"Equivalent Transformation","text":"<ul> <li> 3375. Minimum Operations to Make Array Values Equal to K (Easy)</li> <li> 2914. Minimum Number of Changes to Make Binary String Beautiful (Medium)</li> <li> 3365. Rearrange K Substrings to Form Target String (Medium)</li> <li> 1657. Determine if Two Strings Are Close (Medium)</li> <li> 2551. Put Marbles in Bags (Hard)</li> <li> 1585. Check If String Is Transformable With Substring Sort Operations (Hard)</li> <li> 1040. Moving Stones Until Consecutive II (Medium)</li> <li> 249. Group Shifted Strings (Medium)</li> <li> 49. Group Anagrams (Medium)</li> <li> 1183. Maximum Number of Ones (Hard)</li> </ul>"},{"location":"endlesscheng/equivalent_transformation/#3375-minimum-operations-to-make-array-values-equal-to-k","title":"3375. Minimum Operations to Make Array Values Equal to K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table</p> </li> </ul>"},{"location":"endlesscheng/equivalent_transformation/#2914-minimum-number-of-changes-to-make-binary-string-beautiful","title":"2914. Minimum Number of Changes to Make Binary String Beautiful","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string</p> </li> </ul>"},{"location":"endlesscheng/equivalent_transformation/#3365-rearrange-k-substrings-to-form-target-string","title":"3365. Rearrange K Substrings to Form Target String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sorting</p> </li> </ul>"},{"location":"endlesscheng/equivalent_transformation/#1657-determine-if-two-strings-are-close","title":"1657. Determine if Two Strings Are Close","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sorting, counting</p> </li> </ul>"},{"location":"endlesscheng/equivalent_transformation/#2551-put-marbles-in-bags","title":"2551. Put Marbles in Bags","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sorting, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/equivalent_transformation/#1585-check-if-string-is-transformable-with-substring-sort-operations","title":"1585. Check If String Is Transformable With Substring Sort Operations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/equivalent_transformation/#1040-moving-stones-until-consecutive-ii","title":"1040. Moving Stones Until Consecutive II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, two pointers, sorting</p> </li> </ul>"},{"location":"endlesscheng/equivalent_transformation/#249-group-shifted-strings","title":"249. Group Shifted Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string</p> </li> </ul>"},{"location":"endlesscheng/equivalent_transformation/#49-group-anagrams","title":"49. Group Anagrams","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, sorting</p> </li> </ul> 49. Group Anagrams - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash - List\ndef groupAnagrams(strs: List[str]) -&gt; List[List[str]]:\n    result = defaultdict(list)\n\n    for s in strs:\n        count = [0] * 26\n        for i in s:\n            count[ord(i) - ord(\"a\")] += 1\n\n        result[tuple(count)].append(s)\n\n    return list(result.values())\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Hash     |     O(n * k)    |     O(n)     |\n# |-------------|-----------------|--------------|\n\n\nstrs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\nprint(groupAnagrams(strs))\n# [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n</code></pre>"},{"location":"endlesscheng/equivalent_transformation/#1183-maximum-number-of-ones","title":"1183. Maximum Number of Ones","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, greedy, sorting, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/eulerian_path_and_circuit/","title":"Eulerian Path and Circuit","text":"<ul> <li> 332. Reconstruct Itinerary (Hard)</li> <li> 753. Cracking the Safe (Hard)</li> <li> 2097. Valid Arrangement of Pairs (Hard)</li> </ul>"},{"location":"endlesscheng/eulerian_path_and_circuit/#332-reconstruct-itinerary","title":"332. Reconstruct Itinerary","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: depth first search, graph, eulerian circuit</p> </li> <li>Return the itinerary in order that visits every airport exactly once.</li> <li>The starting airport is <code>JFK</code>.</li> <li>If there are multiple valid itineraries, return the lexicographically smallest one.</li> <li>Eulerian path: A path that visits every edge exactly once.</li> </ul> <pre><code>graph TD\nJFK((JFK))\nSFO((SFO))\nATL((ATL))\nJFK --&gt; SFO\nSFO --&gt; ATL\nATL --&gt; JFK\nJFK --&gt; ATL\nATL --&gt; SFO</code></pre> 332. Reconstruct Itinerary - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hierholzer\ndef findItinerary1(tickets: List[List[str]]) -&gt; List[str]:\n    graph = defaultdict(list)\n    for u, v in sorted(tickets, reverse=True):\n        graph[u].append(v)\n\n    route = []\n\n    def dfs(node):\n        while graph[node]:\n            dest = graph[node].pop()\n            dfs(dest)\n        route.append(node)\n\n    dfs(\"JFK\")\n\n    return route[::-1]\n\n\n# Backtracking\ndef findItinerary2(tickets: List[List[str]]) -&gt; List[str]:\n    graph = defaultdict(list)\n    tickets.sort()\n    for u, v in tickets:\n        graph[u].append(v)\n\n    route = [\"JFK\"]\n\n    def backtraking(node):\n        if len(route) == len(tickets) + 1:\n            return True\n        if node not in graph:\n            return False\n\n        temp = list(graph[node])\n        for i, v in enumerate(temp):\n            graph[node].pop(i)\n            route.append(v)\n\n            if backtraking(v):\n                return True\n\n            graph[node].insert(i, v)\n            route.pop()\n\n        return False\n\n    backtraking(\"JFK\")\n\n    return route\n\n\ntickets = tickets = [\n    [\"JFK\", \"SFO\"],\n    [\"JFK\", \"ATL\"],\n    [\"SFO\", \"ATL\"],\n    [\"ATL\", \"JFK\"],\n    [\"ATL\", \"SFO\"],\n]\nprint(findItinerary1(tickets))\n# ['JFK', 'ATL', 'JFK', 'SFO', 'ATL', 'SFO']\nprint(findItinerary2(tickets))\n# ['JFK', 'ATL', 'JFK', 'SFO', 'ATL', 'SFO']\n</code></pre>"},{"location":"endlesscheng/eulerian_path_and_circuit/#753-cracking-the-safe","title":"753. Cracking the Safe","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: depth first search, graph, eulerian circuit</p> </li> </ul>"},{"location":"endlesscheng/eulerian_path_and_circuit/#2097-valid-arrangement-of-pairs","title":"2097. Valid Arrangement of Pairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: depth first search, graph, eulerian circuit</p> </li> </ul>"},{"location":"endlesscheng/exchange_argument/","title":"Exchange Argument","text":"<ul> <li> 2895. Minimum Processing Time (Medium)</li> <li> 3457. Eat Pizzas! (Medium)</li> <li> 1665. Minimum Initial Energy to Finish Tasks (Hard)</li> <li> 3273. Minimum Amount of Damage Dealt to Bob (Hard)</li> <li> 2136. Earliest Possible Day of Full Bloom (Hard)</li> <li> 179. Largest Number (Medium)</li> <li> 3309. Maximum Possible Number by Binary Concatenation (Medium)</li> </ul>"},{"location":"endlesscheng/exchange_argument/#2895-minimum-processing-time","title":"2895. Minimum Processing Time","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/exchange_argument/#3457-eat-pizzas","title":"3457. Eat Pizzas!","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/exchange_argument/#1665-minimum-initial-energy-to-finish-tasks","title":"1665. Minimum Initial Energy to Finish Tasks","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/exchange_argument/#3273-minimum-amount-of-damage-dealt-to-bob","title":"3273. Minimum Amount of Damage Dealt to Bob","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/exchange_argument/#2136-earliest-possible-day-of-full-bloom","title":"2136. Earliest Possible Day of Full Bloom","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/exchange_argument/#179-largest-number","title":"179. Largest Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/exchange_argument/#3309-maximum-possible-number-by-binary-concatenation","title":"3309. Maximum Possible Number by Binary Concatenation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation, enumeration</p> </li> </ul>"},{"location":"endlesscheng/expression_parsing/","title":"Expression Parsing","text":"<ul> <li> 150. Evaluate Reverse Polish Notation (Medium)</li> <li> 1006. Clumsy Factorial (Medium)</li> <li> 224. Basic Calculator (Hard)</li> <li> 227. Basic Calculator II (Medium)</li> <li> 726. Number of Atoms (Hard)</li> <li> 1106. Parsing A Boolean Expression (Hard)</li> <li> 591. Tag Validator (Hard)</li> <li> 736. Parse Lisp Expression (Hard)</li> <li> 1096. Brace Expansion II (Hard)</li> <li> 1896. Minimum Cost to Change the Final Value of Expression (Hard)</li> <li> 770. Basic Calculator IV (Hard)</li> <li> 439. Ternary Expression Parser (Medium)</li> <li> 772. Basic Calculator III (Hard)</li> <li> 1087. Brace Expansion (Medium)</li> <li> 1597. Build Binary Expression Tree From Infix Expression (Hard)</li> <li> 1628. Design an Expression Tree With Evaluate Function (Medium)</li> </ul>"},{"location":"endlesscheng/expression_parsing/#150-evaluate-reverse-polish-notation","title":"150. Evaluate Reverse Polish Notation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, stack</p> </li> <li>Steps for the list <code>[\"2\", \"1\", \"+\", \"3\", \"*\"]</code>:</li> </ul> token action stack <code>2</code> push <code>[2]</code> <code>1</code> push <code>[2, 1]</code> <code>+</code> pop <code>[3]</code> <code>3</code> push <code>[3, 3]</code> <code>*</code> pop <code>[9]</code> 150. Evaluate Reverse Polish Notation - Python Solution<pre><code>from typing import List\n\n\n# Stack\ndef evalRPN(tokens: List[str]) -&gt; int:\n    stack = []\n\n    for c in tokens:\n        if c == \"+\":\n            stack.append(stack.pop() + stack.pop())\n        elif c == \"-\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(b - a)\n        elif c == \"*\":\n            stack.append(stack.pop() * stack.pop())\n        elif c == \"/\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(int(b / a))\n        else:\n            stack.append(int(c))\n\n    return stack[0]\n\n\nprint(evalRPN([\"2\", \"1\", \"+\", \"3\", \"*\"]))  # 9\nprint(evalRPN([\"4\", \"13\", \"5\", \"/\", \"-\"]))  # 2\nprint(evalRPN([\"18\"]))  # 18\nprint(evalRPN([\"4\", \"3\", \"-\"]))  # 1\n</code></pre>"},{"location":"endlesscheng/expression_parsing/#1006-clumsy-factorial","title":"1006. Clumsy Factorial","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, stack, simulation</p> </li> </ul>"},{"location":"endlesscheng/expression_parsing/#224-basic-calculator","title":"224. Basic Calculator","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, string, stack, recursion</p> </li> </ul> 224. Basic Calculator - Python Solution<pre><code># Stack\ndef calculate(s: str) -&gt; int:\n    stack = []\n    result = 0\n    number = 0\n    sign = 1\n\n    for char in s:\n        if char.isdigit():\n            number = number * 10 + int(char)\n\n        elif char == \"+\":\n            result += sign * number\n            number = 0\n            sign = 1\n        elif char == \"-\":\n            result += sign * number\n            number = 0\n            sign = -1\n\n        elif char == \"(\":\n            stack.append(result)\n            stack.append(sign)\n            result = 0\n            sign = 1\n        elif char == \")\":\n            result += sign * number\n            number = 0\n            result *= stack.pop()  # pop sign\n            result += stack.pop()  # pop previous result\n\n    result += sign * number\n\n    return result\n\n\nprint(calculate(\"(1+(4+5+2)-3)+(6+8)\"))  # 23\n</code></pre>"},{"location":"endlesscheng/expression_parsing/#227-basic-calculator-ii","title":"227. Basic Calculator II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, string, stack</p> </li> </ul> 227. Basic Calculator II - Python Solution<pre><code># Stack\ndef calculate(s: str) -&gt; int:\n    stack = []\n    num = 0\n    sign = \"+\"\n\n    for index, char in enumerate(s):\n        if char.isdigit():\n            num = num * 10 + int(char)\n\n        if char in \"+-*/\" or index == len(s) - 1:\n            if sign == \"+\":\n                stack.append(num)\n            elif sign == \"-\":\n                stack.append(-num)\n            elif sign == \"*\":\n                stack.append(stack.pop() * num)\n            elif sign == \"/\":\n                stack.append(int(stack.pop() / num))\n            sign = char\n            num = 0\n\n    return sum(stack)\n\n\ns = \"3+2*2\"\nprint(calculate(s))  # 7\n</code></pre>"},{"location":"endlesscheng/expression_parsing/#726-number-of-atoms","title":"726. Number of Atoms","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, stack, sorting</p> </li> </ul>"},{"location":"endlesscheng/expression_parsing/#1106-parsing-a-boolean-expression","title":"1106. Parsing A Boolean Expression","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, stack, recursion</p> </li> </ul>"},{"location":"endlesscheng/expression_parsing/#591-tag-validator","title":"591. Tag Validator","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, stack</p> </li> </ul>"},{"location":"endlesscheng/expression_parsing/#736-parse-lisp-expression","title":"736. Parse Lisp Expression","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, stack, recursion</p> </li> </ul>"},{"location":"endlesscheng/expression_parsing/#1096-brace-expansion-ii","title":"1096. Brace Expansion II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, backtracking, stack, breadth first search</p> </li> </ul>"},{"location":"endlesscheng/expression_parsing/#1896-minimum-cost-to-change-the-final-value-of-expression","title":"1896. Minimum Cost to Change the Final Value of Expression","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, string, dynamic programming, stack</p> </li> </ul>"},{"location":"endlesscheng/expression_parsing/#770-basic-calculator-iv","title":"770. Basic Calculator IV","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, math, string, stack, recursion</p> </li> </ul> 770. Basic Calculator IV - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Stack\nclass Solution:\n    def __init__(self):\n        self.operators = set([\"+\", \"-\", \"*\"])\n\n    def basicCalculatorIV(\n        self, expression: str, evalvars: List[str], evalints: List[int]\n    ) -&gt; List[str]:\n        evalmap = dict(zip(evalvars, evalints))\n        tokens = self.parse_expression(expression)\n        result_terms = self.evaluate(tokens, evalmap)\n        return self.format_result(result_terms)\n\n    def parse_expression(self, expression):\n        tokens = []\n        i = 0\n        while i &lt; len(expression):\n            if expression[i].isalnum():  # Variable or digit\n                start = i\n                while i &lt; len(expression) and (\n                    expression[i].isalnum() or expression[i] == \"_\"\n                ):\n                    i += 1\n                tokens.append(expression[start:i])\n            elif expression[i] in self.operators or expression[i] in \"()\":\n                tokens.append(expression[i])\n                i += 1\n            elif expression[i] == \" \":\n                i += 1  # skip whitespace\n        return tokens\n\n    def evaluate(self, tokens, evalmap):\n        def apply_operator(op, b, a):\n            if op == \"+\":\n                return self.add_terms(a, b)\n            elif op == \"-\":\n                return self.add_terms(a, self.negate_terms(b))\n            elif op == \"*\":\n                return self.multiply_terms(a, b)\n\n        def process_token(token):\n            if token.isalnum():\n                if token in evalmap:\n                    stack.append({(): evalmap[token]})\n                elif token.isdigit():\n                    stack.append({(): int(token)})\n                else:\n                    stack.append({(token,): 1})\n            elif token == \"(\":\n                ops.append(token)\n            elif token == \")\":\n                while ops and ops[-1] != \"(\":\n                    operate()\n                ops.pop()\n            else:\n                while (\n                    ops\n                    and ops[-1] in precedence\n                    and precedence[ops[-1]] &gt;= precedence[token]\n                ):\n                    operate()\n                ops.append(token)\n\n        def operate():\n            if len(stack) &lt; 2 or not ops:\n                return\n            b = stack.pop()\n            a = stack.pop()\n            op = ops.pop()\n            stack.append(apply_operator(op, b, a))\n\n        stack = []\n        ops = []\n        precedence = {\"+\": 1, \"-\": 1, \"*\": 2}\n\n        for token in tokens:\n            process_token(token)\n\n        while ops:\n            operate()\n        return self.combine_terms(stack[-1])\n\n    def add_terms(self, a, b):\n        result = defaultdict(int, a)\n        for term, coef in b.items():\n            result[term] += coef\n        return dict(result)\n\n    def negate_terms(self, a):\n        return {term: -coef for term, coef in a.items()}\n\n    def multiply_terms(self, a, b):\n        result = defaultdict(int)\n        for term1, coef1 in a.items():\n            for term2, coef2 in b.items():\n                new_term = tuple(sorted(term1 + term2))\n                result[new_term] += coef1 * coef2\n        return dict(result)\n\n    def combine_terms(self, terms):\n        result = defaultdict(int)\n        for term, coef in terms.items():\n            if coef != 0:\n                result[term] = coef\n        return dict(result)\n\n    def format_result(self, result_terms):\n        result = []\n        for term in sorted(result_terms.keys(), key=lambda x: (-len(x), x)):\n            coef = result_terms[term]\n            if coef != 0:\n                term_str = \"*\".join(term)\n                if term_str:\n                    result.append(f\"{coef}*{term_str}\")\n                else:\n                    result.append(str(coef))\n        return result\n\n\ncalculator = Solution()\nexpression = \"e + 8 - a + 5\"\nevalvars = [\"e\"]\nevalints = [1]\nprint(calculator.basicCalculatorIV(expression, evalvars, evalints))\n# ['-1*a', '14']\n</code></pre>"},{"location":"endlesscheng/expression_parsing/#439-ternary-expression-parser","title":"439. Ternary Expression Parser","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack, recursion</p> </li> </ul>"},{"location":"endlesscheng/expression_parsing/#772-basic-calculator-iii","title":"772. Basic Calculator III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, string, stack, recursion</p> </li> </ul> 772. Basic Calculator III - Python Solution<pre><code># Stack\ndef calculate(s: str) -&gt; int:\n    def helper(index):\n        stack = []\n        num = 0\n        sign = \"+\"\n\n        while index &lt; len(s):\n            char = s[index]\n            if char.isdigit():\n                num = num * 10 + int(char)\n            if char == \"(\":\n                num, index = helper(index + 1)\n            if char in \"+-*/)\" or index == len(s) - 1:\n                if sign == \"+\":\n                    stack.append(num)\n                elif sign == \"-\":\n                    stack.append(-num)\n                elif sign == \"*\":\n                    stack.append(stack.pop() * num)\n                elif sign == \"/\":\n                    stack.append(int(stack.pop() / num))  # \u5411\u96f6\u53d6\u6574\n                num = 0\n                sign = char\n            if char == \")\":\n                break\n            index += 1\n\n        return sum(stack), index\n\n    s = s.replace(\" \", \"\")\n    result, _ = helper(0)\n\n    return result\n\n\ns = \"2*(5+5*2)/3+(6/2+8)\"\nprint(calculate(s))  # 21\n</code></pre>"},{"location":"endlesscheng/expression_parsing/#1087-brace-expansion","title":"1087. Brace Expansion","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, backtracking, breadth first search</p> </li> </ul>"},{"location":"endlesscheng/expression_parsing/#1597-build-binary-expression-tree-from-infix-expression","title":"1597. Build Binary Expression Tree From Infix Expression","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, stack, tree, binary tree</p> </li> </ul>"},{"location":"endlesscheng/expression_parsing/#1628-design-an-expression-tree-with-evaluate-function","title":"1628. Design an Expression Tree With Evaluate Function","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, stack, tree, design, binary tree</p> </li> </ul>"},{"location":"endlesscheng/fenwick_tree/","title":"Fenwick Tree","text":"<ul> <li> 307. Range Sum Query - Mutable (Medium)</li> <li> 3072. Distribute Elements Into Two Arrays II (Hard)</li> <li> 3187. Peaks in Array (Hard)</li> <li> 1649. Create Sorted Array through Instructions (Hard)</li> <li> 1626. Best Team With No Conflicts (Medium)</li> <li> 1409. Queries on a Permutation With Key (Medium)</li> <li> 2250. Count Number of Rectangles Containing Each Point (Medium)</li> <li> 2179. Count Good Triplets in an Array (Hard)</li> <li> 1395. Count Number of Teams (Medium)</li> <li> 2659. Make Array Empty (Hard)</li> <li> 2653. Sliding Subarray Beauty (Medium)</li> <li> 1505. Minimum Possible Integer After at Most K Adjacent Swaps On Digits (Hard)</li> <li> 2926. Maximum Balanced Subsequence Sum (Hard)</li> <li> 2736. Maximum Sum Queries (Hard)</li> <li> 3382. Maximum Area Rectangle With Point Constraints II (Hard)</li> <li> 3245. Alternating Groups III (Hard)</li> <li> 1756. Design Most Recently Used Queue (Medium)</li> <li> 2519. Count the Number of K-Big Indices (Hard)</li> <li> 2613. Beautiful Pairs (Hard)</li> <li> 2921. Maximum Profitable Triplets With Increasing Prices II (Hard)</li> <li> 308. Range Sum Query 2D - Mutable (Medium)</li> </ul>"},{"location":"endlesscheng/fenwick_tree/#307-range-sum-query-mutable","title":"307. Range Sum Query - Mutable","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, design, binary indexed tree, segment tree</p> </li> </ul>"},{"location":"endlesscheng/fenwick_tree/#3072-distribute-elements-into-two-arrays-ii","title":"3072. Distribute Elements Into Two Arrays II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary indexed tree, segment tree, simulation</p> </li> </ul>"},{"location":"endlesscheng/fenwick_tree/#3187-peaks-in-array","title":"3187. Peaks in Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary indexed tree, segment tree</p> </li> </ul>"},{"location":"endlesscheng/fenwick_tree/#1649-create-sorted-array-through-instructions","title":"1649. Create Sorted Array through Instructions","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, divide and conquer, binary indexed tree, segment tree, merge sort, ordered set</p> </li> </ul>"},{"location":"endlesscheng/fenwick_tree/#1626-best-team-with-no-conflicts","title":"1626. Best Team With No Conflicts","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, sorting</p> </li> </ul>"},{"location":"endlesscheng/fenwick_tree/#1409-queries-on-a-permutation-with-key","title":"1409. Queries on a Permutation With Key","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary indexed tree, simulation</p> </li> </ul>"},{"location":"endlesscheng/fenwick_tree/#2250-count-number-of-rectangles-containing-each-point","title":"2250. Count Number of Rectangles Containing Each Point","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, binary indexed tree, sorting</p> </li> </ul>"},{"location":"endlesscheng/fenwick_tree/#2179-count-good-triplets-in-an-array","title":"2179. Count Good Triplets in an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, divide and conquer, binary indexed tree, segment tree, merge sort, ordered set</p> </li> </ul>"},{"location":"endlesscheng/fenwick_tree/#1395-count-number-of-teams","title":"1395. Count Number of Teams","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, binary indexed tree, segment tree</p> </li> </ul>"},{"location":"endlesscheng/fenwick_tree/#2659-make-array-empty","title":"2659. Make Array Empty","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, greedy, binary indexed tree, segment tree, sorting, ordered set</p> </li> </ul>"},{"location":"endlesscheng/fenwick_tree/#2653-sliding-subarray-beauty","title":"2653. Sliding Subarray Beauty","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, sliding window</p> </li> </ul>"},{"location":"endlesscheng/fenwick_tree/#1505-minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits","title":"1505. Minimum Possible Integer After at Most K Adjacent Swaps On Digits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, greedy, binary indexed tree, segment tree</p> </li> </ul>"},{"location":"endlesscheng/fenwick_tree/#2926-maximum-balanced-subsequence-sum","title":"2926. Maximum Balanced Subsequence Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, dynamic programming, binary indexed tree, segment tree</p> </li> </ul>"},{"location":"endlesscheng/fenwick_tree/#2736-maximum-sum-queries","title":"2736. Maximum Sum Queries","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, stack, binary indexed tree, segment tree, sorting, monotonic stack</p> </li> </ul>"},{"location":"endlesscheng/fenwick_tree/#3382-maximum-area-rectangle-with-point-constraints-ii","title":"3382. Maximum Area Rectangle With Point Constraints II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, binary indexed tree, segment tree, geometry, sorting</p> </li> </ul>"},{"location":"endlesscheng/fenwick_tree/#3245-alternating-groups-iii","title":"3245. Alternating Groups III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary indexed tree</p> </li> </ul>"},{"location":"endlesscheng/fenwick_tree/#1756-design-most-recently-used-queue","title":"1756. Design Most Recently Used Queue","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, stack, design, binary indexed tree, ordered set</p> </li> </ul>"},{"location":"endlesscheng/fenwick_tree/#2519-count-the-number-of-k-big-indices","title":"2519. Count the Number of K-Big Indices","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, divide and conquer, binary indexed tree, segment tree, merge sort, ordered set</p> </li> </ul>"},{"location":"endlesscheng/fenwick_tree/#2613-beautiful-pairs","title":"2613. Beautiful Pairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, divide and conquer, geometry, sorting, ordered set</p> </li> </ul>"},{"location":"endlesscheng/fenwick_tree/#2921-maximum-profitable-triplets-with-increasing-prices-ii","title":"2921. Maximum Profitable Triplets With Increasing Prices II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary indexed tree, segment tree</p> </li> </ul>"},{"location":"endlesscheng/fenwick_tree/#308-range-sum-query-2d-mutable","title":"308. Range Sum Query 2D - Mutable","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, design, binary indexed tree, segment tree, matrix</p> </li> </ul>"},{"location":"endlesscheng/from_special_to_general/","title":"From Special to General","text":"<ul> <li> 2745. Construct the Longest New String (Medium)</li> <li> 2611. Mice and Cheese (Medium)</li> <li> 1029. Two City Scheduling (Medium)</li> <li> 2645. Minimum Additions to Make Valid String (Medium)</li> <li> 2202. Maximize the Topmost Element After K Moves (Medium)</li> <li> 2568. Minimum Impossible OR (Medium)</li> <li> 1702. Maximum Binary String After Change (Medium)</li> <li> 3012. Minimize Length of Array Using Operations (Medium)</li> <li> 1526. Minimum Number of Increments on Subarrays to Form a Target Array (Hard)</li> <li> 2350. Shortest Impossible Sequence of Rolls (Hard)</li> <li> 517. Super Washing Machines (Hard)</li> <li> 2499. Minimum Total Cost to Make Arrays Unequal (Hard)</li> <li> 3357. Minimize the Maximum Adjacent Element Difference (Hard)</li> </ul>"},{"location":"endlesscheng/from_special_to_general/#2745-construct-the-longest-new-string","title":"2745. Construct the Longest New String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, greedy, brainteaser</p> </li> </ul>"},{"location":"endlesscheng/from_special_to_general/#2611-mice-and-cheese","title":"2611. Mice and Cheese","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/from_special_to_general/#1029-two-city-scheduling","title":"1029. Two City Scheduling","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/from_special_to_general/#2645-minimum-additions-to-make-valid-string","title":"2645. Minimum Additions to Make Valid String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming, stack, greedy</p> </li> </ul>"},{"location":"endlesscheng/from_special_to_general/#2202-maximize-the-topmost-element-after-k-moves","title":"2202. Maximize the Topmost Element After K Moves","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy</p> </li> </ul>"},{"location":"endlesscheng/from_special_to_general/#2568-minimum-impossible-or","title":"2568. Minimum Impossible OR","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation, brainteaser</p> </li> </ul>"},{"location":"endlesscheng/from_special_to_general/#1702-maximum-binary-string-after-change","title":"1702. Maximum Binary String After Change","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, greedy</p> </li> </ul>"},{"location":"endlesscheng/from_special_to_general/#3012-minimize-length-of-array-using-operations","title":"3012. Minimize Length of Array Using Operations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, greedy, number theory</p> </li> </ul>"},{"location":"endlesscheng/from_special_to_general/#1526-minimum-number-of-increments-on-subarrays-to-form-a-target-array","title":"1526. Minimum Number of Increments on Subarrays to Form a Target Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, stack, greedy, monotonic stack</p> </li> </ul>"},{"location":"endlesscheng/from_special_to_general/#2350-shortest-impossible-sequence-of-rolls","title":"2350. Shortest Impossible Sequence of Rolls","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, greedy</p> </li> </ul>"},{"location":"endlesscheng/from_special_to_general/#517-super-washing-machines","title":"517. Super Washing Machines","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy</p> </li> </ul>"},{"location":"endlesscheng/from_special_to_general/#2499-minimum-total-cost-to-make-arrays-unequal","title":"2499. Minimum Total Cost to Make Arrays Unequal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, greedy, counting</p> </li> </ul>"},{"location":"endlesscheng/from_special_to_general/#3357-minimize-the-maximum-adjacent-element-difference","title":"3357. Minimize the Maximum Adjacent Element Difference","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, greedy</p> </li> </ul>"},{"location":"endlesscheng/fundamental_cycle/","title":"Fundamental Cycle","text":"<ul> <li> 2359. Find Closest Node to Given Two Nodes (Medium)</li> <li> 2360. Longest Cycle in a Graph (Hard)</li> <li> 684. Redundant Connection (Medium)</li> <li> 685. Redundant Connection II (Hard)</li> <li> 2876. Count Visited Nodes in a Directed Graph (Hard)</li> <li> 2127. Maximum Employees to Be Invited to a Meeting (Hard)</li> <li> 2836. Maximize Value of Function in a Ball Passing Game (Hard)</li> <li> 2204. Distance to a Cycle in Undirected Graph (Hard)</li> </ul>"},{"location":"endlesscheng/fundamental_cycle/#2359-find-closest-node-to-given-two-nodes","title":"2359. Find Closest Node to Given Two Nodes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, graph</p> </li> </ul>"},{"location":"endlesscheng/fundamental_cycle/#2360-longest-cycle-in-a-graph","title":"2360. Longest Cycle in a Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort</p> </li> </ul>"},{"location":"endlesscheng/fundamental_cycle/#684-redundant-connection","title":"684. Redundant Connection","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> </ul> 684. Redundant Connection - Python Solution<pre><code>from typing import List\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(1, n + 1)}\n        self.rank = {i: 1 for i in range(1, n + 1)}\n\n    def find(self, n):\n        p = self.par[n]\n        while self.par[p] != p:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return False\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.par[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.par[p1] = p2\n        else:\n            self.par[p2] = p1\n            self.rank[p1] += 1\n\n        return True\n\n\n# Union Find\ndef findRedundantConnectionUF(edges: List[List[int]]) -&gt; List[int]:\n    n = len(edges)\n    uf = UnionFind(n)\n\n    for u, v in edges:\n        if not uf.union(u, v):\n            return (u, v)\n\n\n# DFS\ndef findRedundantConnectionDFS(edges: List[List[int]]) -&gt; List[int]:\n    graph, cycle = {}, {}\n    for a, b in edges:\n        graph.setdefault(a, []).append(b)\n        graph.setdefault(b, []).append(a)\n\n    def dfs(node, parent):\n        if node in cycle:\n            for k in list(cycle.keys()):\n                if k == node:\n                    return True\n                del cycle[k]\n\n        cycle[node] = None\n        for child in graph[node]:\n            if child != parent and dfs(child, node):\n                return True\n        del cycle[node]\n        return False\n\n    dfs(edges[0][0], -1)\n    for a, b in edges[::-1]:\n        if a in cycle and b in cycle:\n            return (a, b)\n\n\nedges = [[1, 2], [1, 3], [2, 3]]\nprint(findRedundantConnectionUF(edges))  # (2, 3)\nprint(findRedundantConnectionDFS(edges))  # (2, 3)\n</code></pre>"},{"location":"endlesscheng/fundamental_cycle/#685-redundant-connection-ii","title":"685. Redundant Connection II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> </ul> 685. Redundant Connection II - Python Solution<pre><code>from typing import List\n\n\n# Union Find\ndef findRedundantDirectedConnectionUF(edges: List[List[int]]) -&gt; List[int]:\n    n = len(edges)\n    uf = UnionFind(n + 1)\n    parent = list(range(n + 1))\n    candidates = []\n\n    for u, v in edges:\n        if parent[v] != v:\n            candidates.append([parent[v], v])\n            candidates.append([u, v])\n        else:\n            parent[v] = u\n\n    if not candidates:\n        for u, v in edges:\n            if not uf.union(u, v):\n                return [u, v]\n\n    for u, v in edges:\n        if [u, v] == candidates[1]:\n            continue\n        if not uf.union(u, v):\n            return candidates[0]\n\n    return candidates[1]\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(1, n + 1)}\n\n    def find(self, n):\n        p = self.par[n]\n        while p != self.par[p]:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n        if p1 == p2:\n            return False\n        self.par[p1] = p2\n        return True\n\n\nedges = [[1, 2], [1, 3], [2, 3]]\nprint(findRedundantDirectedConnectionUF(edges))\n</code></pre>"},{"location":"endlesscheng/fundamental_cycle/#2876-count-visited-nodes-in-a-directed-graph","title":"2876. Count Visited Nodes in a Directed Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, graph, memoization</p> </li> </ul>"},{"location":"endlesscheng/fundamental_cycle/#2127-maximum-employees-to-be-invited-to-a-meeting","title":"2127. Maximum Employees to Be Invited to a Meeting","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: depth first search, graph, topological sort</p> </li> </ul>"},{"location":"endlesscheng/fundamental_cycle/#2836-maximize-value-of-function-in-a-ball-passing-game","title":"2836. Maximize Value of Function in a Ball Passing Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/fundamental_cycle/#2204-distance-to-a-cycle-in-undirected-graph","title":"2204. Distance to a Cycle in Undirected Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> </ul>"},{"location":"endlesscheng/gcd_union_find/","title":"GCD Union Find","text":"<ul> <li> 2709. Greatest Common Divisor Traversal (Hard)</li> <li> 1627. Graph Connectivity With Threshold (Hard)</li> <li> 952. Largest Component Size by Common Factor (Hard)</li> <li> 1998. GCD Sort of an Array (Hard)</li> <li> 3378. Count Connected Components in LCM Graph (Hard)</li> </ul>"},{"location":"endlesscheng/gcd_union_find/#2709-greatest-common-divisor-traversal","title":"2709. Greatest Common Divisor Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, union find, number theory</p> </li> </ul>"},{"location":"endlesscheng/gcd_union_find/#1627-graph-connectivity-with-threshold","title":"1627. Graph Connectivity With Threshold","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, union find, number theory</p> </li> </ul>"},{"location":"endlesscheng/gcd_union_find/#952-largest-component-size-by-common-factor","title":"952. Largest Component Size by Common Factor","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, math, union find, number theory</p> </li> </ul> 952. Largest Component Size by Common Factor - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef largestComponentSize(nums: List[int]) -&gt; int:\n    par = {i: i for i in nums}\n    rank = {i: 0 for i in nums}\n\n    def find(n):\n        p = par[n]\n        while par[p] != p:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            if rank[p1] &gt; rank[p2]:\n                par[p2] = p1\n            elif rank[p1] &lt; rank[p2]:\n                par[p1] = p2\n            else:\n                par[p2] = p1\n                rank[p1] += 1\n\n    def prime_factors(n):\n        \"\"\"Return the prime factors of n.\"\"\"\n        i = 2\n        factors = set()\n        while i * i &lt;= n:\n            while (n % i) == 0:\n                factors.add(i)\n                n //= i\n            i += 1\n        if n &gt; 1:\n            factors.add(n)\n        return factors\n\n    factor_map = defaultdict(list)  # factor -&gt; [nums]\n    for num in nums:\n        factors = prime_factors(num)\n        for factor in factors:\n            factor_map[factor].append(num)\n\n    for factor, group in factor_map.items():\n        for i in range(1, len(group)):\n            union(group[0], group[i])\n\n    sizes = defaultdict(int)  # component root -&gt; size\n    for num in nums:\n        root = find(num)\n        sizes[root] += 1\n\n    return max(sizes.values())\n\n\nnums = [20, 50, 9, 63]\nprint(largestComponentSize(nums))  # 2\n</code></pre>"},{"location":"endlesscheng/gcd_union_find/#1998-gcd-sort-of-an-array","title":"1998. GCD Sort of an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, union find, sorting, number theory</p> </li> </ul>"},{"location":"endlesscheng/gcd_union_find/#3378-count-connected-components-in-lcm-graph","title":"3378. Count Connected Components in LCM Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, math, union find, number theory</p> </li> </ul>"},{"location":"endlesscheng/graph_others/","title":"Graph Others","text":"<ul> <li> 1042. Flower Planting With No Adjacent (Medium)</li> <li> 1761. Minimum Degree of a Connected Trio in a Graph (Hard)</li> <li> 2508. Add Edges to Make Degrees of All Nodes Even (Hard)</li> <li> 1579. Remove Max Number of Edges to Keep Graph Fully Traversable (Hard)</li> <li> 2065. Maximum Path Quality of a Graph (Hard)</li> <li> 1697. Checking Existence of Edge Length Limited Paths (Hard)</li> <li> 2242. Maximum Score of a Node Sequence (Hard)</li> <li> 2493. Divide Nodes Into the Maximum Number of Groups (Hard)</li> <li> 1782. Count Pairs Of Nodes (Hard)</li> <li> 3435. Frequencies of Shortest Supersequences (Hard)</li> <li> 277. Find the Celebrity (Medium)</li> <li> 1724. Checking Existence of Edge Length Limited Paths II (Hard)</li> <li> 2077. Paths in Maze That Lead to Same Room (Medium)</li> </ul>"},{"location":"endlesscheng/graph_others/#1042-flower-planting-with-no-adjacent","title":"1042. Flower Planting With No Adjacent","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph</p> </li> </ul>"},{"location":"endlesscheng/graph_others/#1761-minimum-degree-of-a-connected-trio-in-a-graph","title":"1761. Minimum Degree of a Connected Trio in a Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: graph</p> </li> </ul>"},{"location":"endlesscheng/graph_others/#2508-add-edges-to-make-degrees-of-all-nodes-even","title":"2508. Add Edges to Make Degrees of All Nodes Even","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, graph</p> </li> </ul>"},{"location":"endlesscheng/graph_others/#1579-remove-max-number-of-edges-to-keep-graph-fully-traversable","title":"1579. Remove Max Number of Edges to Keep Graph Fully Traversable","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: union find, graph</p> </li> <li>Return the maximum number of edges you can remove so that the graph remains fully traversable.</li> </ul> <p></p> 1579. Remove Max Number of Edges to Keep Graph Fully Traversable - Python Solution<pre><code>from typing import List\n\n\n# Kruskal\ndef maxNumEdgesToRemove(n: int, edges: List[List[int]]) -&gt; int:\n    alice, bob = UnionFind(n), UnionFind(n)\n    visited = 0\n\n    for t, u, v in edges:\n        if t == 3:\n            if alice.union(u, v) | bob.union(u, v):\n                visited += 1\n\n    for t, u, v in edges:\n        if t == 1:\n            if alice.union(u, v):\n                visited += 1\n        elif t == 2:\n            if bob.union(u, v):\n                visited += 1\n\n    if alice.components &gt; 1 or bob.components &gt; 1:\n        return -1\n\n    return len(edges) - visited\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = {i: i for i in range(1, n + 1)}\n        self.rank = {i: 0 for i in range(1, n + 1)}\n        self.components = n\n\n    def find(self, n):\n        p = self.parent[n]\n        while self.parent[p] != p:\n            self.parent[p] = self.parent[self.parent[p]]\n            p = self.parent[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return False\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.parent[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.parent[p1] = p2\n        else:\n            self.parent[p2] = p1\n            self.rank[p1] += 1\n\n        self.components -= 1\n\n        return True\n\n\nn = 4\nedges = [[3, 1, 2], [3, 2, 3], [1, 1, 3], [1, 2, 4], [1, 1, 2], [2, 3, 4]]\nprint(maxNumEdgesToRemove(n, edges))  # 2\n</code></pre>"},{"location":"endlesscheng/graph_others/#2065-maximum-path-quality-of-a-graph","title":"2065. Maximum Path Quality of a Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, backtracking, graph</p> </li> </ul>"},{"location":"endlesscheng/graph_others/#1697-checking-existence-of-edge-length-limited-paths","title":"1697. Checking Existence of Edge Length Limited Paths","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, union find, graph, sorting</p> </li> </ul>"},{"location":"endlesscheng/graph_others/#2242-maximum-score-of-a-node-sequence","title":"2242. Maximum Score of a Node Sequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, graph, sorting, enumeration</p> </li> </ul>"},{"location":"endlesscheng/graph_others/#2493-divide-nodes-into-the-maximum-number-of-groups","title":"2493. Divide Nodes Into the Maximum Number of Groups","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> </ul>"},{"location":"endlesscheng/graph_others/#1782-count-pairs-of-nodes","title":"1782. Count Pairs Of Nodes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, binary search, graph, sorting</p> </li> </ul>"},{"location":"endlesscheng/graph_others/#3435-frequencies-of-shortest-supersequences","title":"3435. Frequencies of Shortest Supersequences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, bit manipulation, graph, topological sort, enumeration</p> </li> </ul>"},{"location":"endlesscheng/graph_others/#277-find-the-celebrity","title":"277. Find the Celebrity","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, graph, interactive</p> </li> </ul>"},{"location":"endlesscheng/graph_others/#1724-checking-existence-of-edge-length-limited-paths-ii","title":"1724. Checking Existence of Edge Length Limited Paths II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: union find, graph, minimum spanning tree</p> </li> </ul>"},{"location":"endlesscheng/graph_others/#2077-paths-in-maze-that-lead-to-same-room","title":"2077. Paths in Maze That Lead to Same Room","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: graph</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_left_right/","title":"Greedy from Left Right","text":"<ul> <li> 3402. Minimum Operations to Make Columns Strictly Increasing (Easy)</li> <li> 3191. Minimum Operations to Make Binary Array Elements Equal to One I (Medium)</li> <li> 1827. Minimum Operations to Make the Array Increasing (Easy)</li> <li> 2027. Minimum Moves to Convert String (Easy)</li> <li> 605. Can Place Flowers (Easy)</li> <li> 3111. Minimum Rectangles to Cover Points (Medium)</li> <li> 2957. Remove Adjacent Almost-Equal Characters (Medium)</li> <li> 3192. Minimum Operations to Make Binary Array Elements Equal to One II (Medium)</li> <li> 2789. Largest Element in an Array after Merge Operations (Medium)</li> <li> 1529. Minimum Suffix Flips (Medium)</li> <li> 1144. Decrease Elements To Make Array Zigzag (Medium)</li> <li> 3228. Maximum Number of Operations to Move Ones to the End (Medium)</li> <li> 2086. Minimum Number of Food Buckets to Feed the Hamsters (Medium)</li> <li> 2571. Minimum Operations to Reduce an Integer to 0 (Medium)</li> <li> 2712. Minimum Cost to Make All Characters Equal (Medium)</li> <li> 3326. Minimum Division Operations to Make Array Non Decreasing (Medium)</li> <li> 1536. Minimum Swaps to Arrange a Binary Grid (Medium)</li> <li> 2673. Make Costs of Paths Equal in a Binary Tree (Medium)</li> <li> 861. Score After Flipping Matrix (Medium)</li> <li> 955. Delete Columns to Make Sorted II (Medium)</li> <li> 2366. Minimum Replacements to Sort the Array (Hard)</li> <li> 2193. Minimum Number of Moves to Make Palindrome (Hard)</li> <li> 2528. Maximize the Minimum Powered City (Hard)</li> <li> 3449. Maximize the Minimum Game Score (Hard)</li> <li> 2422. Merge Operations to Turn Array Into a Palindrome (Medium)</li> </ul>"},{"location":"endlesscheng/greedy_from_left_right/#3402-minimum-operations-to-make-columns-strictly-increasing","title":"3402. Minimum Operations to Make Columns Strictly Increasing","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, greedy, matrix</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_left_right/#3191-minimum-operations-to-make-binary-array-elements-equal-to-one-i","title":"3191. Minimum Operations to Make Binary Array Elements Equal to One I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation, queue, sliding window, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_left_right/#1827-minimum-operations-to-make-the-array-increasing","title":"1827. Minimum Operations to Make the Array Increasing","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, greedy</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_left_right/#2027-minimum-moves-to-convert-string","title":"2027. Minimum Moves to Convert String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, greedy</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_left_right/#605-can-place-flowers","title":"605. Can Place Flowers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, greedy</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_left_right/#3111-minimum-rectangles-to-cover-points","title":"3111. Minimum Rectangles to Cover Points","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_left_right/#2957-remove-adjacent-almost-equal-characters","title":"2957. Remove Adjacent Almost-Equal Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming, greedy</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_left_right/#3192-minimum-operations-to-make-binary-array-elements-equal-to-one-ii","title":"3192. Minimum Operations to Make Binary Array Elements Equal to One II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_left_right/#2789-largest-element-in-an-array-after-merge-operations","title":"2789. Largest Element in an Array after Merge Operations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_left_right/#1529-minimum-suffix-flips","title":"1529. Minimum Suffix Flips","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, greedy</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_left_right/#1144-decrease-elements-to-make-array-zigzag","title":"1144. Decrease Elements To Make Array Zigzag","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_left_right/#3228-maximum-number-of-operations-to-move-ones-to-the-end","title":"3228. Maximum Number of Operations to Move Ones to the End","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, greedy, counting</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_left_right/#2086-minimum-number-of-food-buckets-to-feed-the-hamsters","title":"2086. Minimum Number of Food Buckets to Feed the Hamsters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming, greedy</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_left_right/#2571-minimum-operations-to-reduce-an-integer-to-0","title":"2571. Minimum Operations to Reduce an Integer to 0","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming, greedy, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_left_right/#2712-minimum-cost-to-make-all-characters-equal","title":"2712. Minimum Cost to Make All Characters Equal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming, greedy</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_left_right/#3326-minimum-division-operations-to-make-array-non-decreasing","title":"3326. Minimum Division Operations to Make Array Non Decreasing","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, greedy, number theory</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_left_right/#1536-minimum-swaps-to-arrange-a-binary-grid","title":"1536. Minimum Swaps to Arrange a Binary Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, matrix</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_left_right/#2673-make-costs-of-paths-equal-in-a-binary-tree","title":"2673. Make Costs of Paths Equal in a Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy, tree, binary tree</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_left_right/#861-score-after-flipping-matrix","title":"861. Score After Flipping Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, bit manipulation, matrix</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_left_right/#955-delete-columns-to-make-sorted-ii","title":"955. Delete Columns to Make Sorted II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, greedy</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_left_right/#2366-minimum-replacements-to-sort-the-array","title":"2366. Minimum Replacements to Sort the Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, greedy</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_left_right/#2193-minimum-number-of-moves-to-make-palindrome","title":"2193. Minimum Number of Moves to Make Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: two pointers, string, greedy, binary indexed tree</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_left_right/#2528-maximize-the-minimum-powered-city","title":"2528. Maximize the Minimum Powered City","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, greedy, queue, sliding window, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_left_right/#3449-maximize-the-minimum-game-score","title":"3449. Maximize the Minimum Game Score","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, greedy</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_left_right/#2422-merge-operations-to-turn-array-into-a-palindrome","title":"2422. Merge Operations to Turn Array Into a Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_smallest_largest/","title":"Greedy from Smallest Largest","text":"<ul> <li> 3074. Apple Redistribution into Boxes (Easy)</li> <li> 2279. Maximum Bags With Full Capacity of Rocks (Medium)</li> <li> 1833. Maximum Ice Cream Bars (Medium)</li> <li> 1005. Maximize Sum Of Array After K Negations (Easy)</li> <li> 1481. Least Number of Unique Integers after K Removals (Medium)</li> <li> 1403. Minimum Subsequence in Non-Increasing Order (Easy)</li> <li> 3010. Divide an Array Into Subarrays With Minimum Cost I (Easy)</li> <li> 1338. Reduce Array Size to The Half (Medium)</li> <li> 1710. Maximum Units on a Truck (Easy)</li> <li> 3075. Maximize Happiness of Selected Children (Medium)</li> <li> 2554. Maximum Number of Integers to Choose From a Range I (Medium)</li> <li> 2126. Destroying Asteroids (Medium)</li> <li> 2587. Rearrange Array to Maximize Prefix Score (Medium)</li> <li> 976. Largest Perimeter Triangle (Easy)</li> <li> 1561. Maximum Number of Coins You Can Get (Medium)</li> <li> 3301. Maximize the Total Height of Unique Towers (Medium)</li> <li> 945. Minimum Increment to Make Array Unique (Medium)</li> <li> 1846. Maximum Element After Decreasing and Rearranging (Medium)</li> <li> 1647. Minimum Deletions to Make Character Frequencies Unique (Medium)</li> <li> 2971. Find Polygon With the Largest Perimeter (Medium)</li> <li> 2178. Maximum Split of Positive Even Integers (Medium)</li> <li> 2567. Minimum Score by Changing Two Elements (Medium)</li> <li> 1509. Minimum Difference Between Largest and Smallest Value in Three Moves (Medium)</li> <li> 3397. Maximum Number of Distinct Elements After Operations (Medium)</li> <li> 3457. Eat Pizzas! (Medium)</li> <li> 1262. Greatest Sum Divisible by Three (Medium)</li> <li> 948. Bag of Tokens (Medium)</li> <li> 1775. Equal Sum Arrays With Minimum Number of Operations (Medium)</li> <li> 2333. Minimum Sum of Squared Difference (Medium)</li> <li> 3440. Reschedule Meetings for Maximum Free Time II (Medium)</li> <li> 2141. Maximum Running Time of N Computers (Hard)</li> <li> 1196. How Many Apples Can You Put into the Basket (Easy)</li> <li> 2214. Minimum Health to Beat Game (Medium)</li> <li> 2098. Subsequence of Size K With the Largest Even Sum (Medium)</li> <li> 2548. Maximum Price to Fill a Bag (Medium)</li> <li> 3119. Maximum Number of Potholes That Can Be Fixed (Medium)</li> <li> 2557. Maximum Number of Integers to Choose From a Range II (Medium)</li> <li> 624. Maximum Distance in Arrays (Medium)</li> <li> 910. Smallest Range II (Medium)</li> <li> 2835. Minimum Operations to Form Subsequence With Target Sum (Hard)</li> <li> 3366. Minimum Array Sum (Medium)</li> </ul>"},{"location":"endlesscheng/greedy_from_smallest_largest/#3074-apple-redistribution-into-boxes","title":"3074. Apple Redistribution into Boxes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul> 3074. Apple Redistribution into Boxes - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef minimumBoxes(apple: List[int], capacity: List[int]) -&gt; int:\n    target = sum(apple)\n    capacity.sort(reverse=True)\n    res = 0\n\n    for box in capacity:\n        res += 1\n        target -= box\n        if target &lt;= 0:\n            break\n\n    return res\n\n\napple = [1, 3, 2]\ncapacity = [4, 3, 1, 5, 2]\nassert minimumBoxes(apple, capacity) == 2\n</code></pre> 3074. Apple Redistribution into Boxes - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;numeric&gt;\n#include &lt;algorithm&gt;\n#include &lt;functional&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int minimumBoxes(vector&lt;int&gt; &amp;apple, vector&lt;int&gt; &amp;capacity)\n    {\n        int s = accumulate(apple.begin(), apple.end(), 0);\n        sort(capacity.begin(), capacity.end(), greater&lt;int&gt;());\n\n        int i = 0;\n        while (s &gt; 0)\n        {\n            s -= capacity[i++];\n        }\n        return i;\n    }\n};\n\nint main()\n{\n    Solution s;\n    vector&lt;int&gt; apple = {1, 3, 2};\n    vector&lt;int&gt; capacity = {4, 3, 1, 5, 2};\n    cout &lt;&lt; s.minimumBoxes(apple, capacity) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"endlesscheng/greedy_from_smallest_largest/#2279-maximum-bags-with-full-capacity-of-rocks","title":"2279. Maximum Bags With Full Capacity of Rocks","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_smallest_largest/#1833-maximum-ice-cream-bars","title":"1833. Maximum Ice Cream Bars","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting, counting sort</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_smallest_largest/#1005-maximize-sum-of-array-after-k-negations","title":"1005. Maximize Sum Of Array After K Negations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> <li>Return the maximum sum of the array after changing at most <code>k</code> elements.</li> </ul> 1005. Maximize Sum Of Array After K Negations - Python Solution<pre><code>from heapq import heapify, heapreplace\nfrom typing import List\n\n\n# Greedy\ndef largestSumAfterKNegationsGreedy(nums: List[int], k: int) -&gt; int:\n    nums.sort(key=abs, reverse=True)\n\n    for i in range(len(nums)):\n        if nums[i] &lt; 0 and k &gt; 0:\n            nums[i] *= -1\n            k -= 1\n\n    if k % 2:\n        nums[-1] *= -1\n\n    return sum(nums)\n\n\n# Heap\ndef largestSumAfterKNegationsHeap(nums: List[int], k: int) -&gt; int:\n    heapify(nums)\n\n    while k and nums[0] &lt; 0:\n        heapreplace(nums, -nums[0])\n        k -= 1\n\n    if k % 2:\n        heapreplace(nums, -nums[0])\n\n    return sum(nums)\n\n\nprint(largestSumAfterKNegationsGreedy([4, 2, 3], 1))  # 5\nprint(largestSumAfterKNegationsHeap([4, 2, 3], 1))\n</code></pre>"},{"location":"endlesscheng/greedy_from_smallest_largest/#1481-least-number-of-unique-integers-after-k-removals","title":"1481. Least Number of Unique Integers after K Removals","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, greedy, sorting, counting</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_smallest_largest/#1403-minimum-subsequence-in-non-increasing-order","title":"1403. Minimum Subsequence in Non-Increasing Order","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_smallest_largest/#3010-divide-an-array-into-subarrays-with-minimum-cost-i","title":"3010. Divide an Array Into Subarrays With Minimum Cost I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, sorting, enumeration</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_smallest_largest/#1338-reduce-array-size-to-the-half","title":"1338. Reduce Array Size to The Half","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, greedy, sorting, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_smallest_largest/#1710-maximum-units-on-a-truck","title":"1710. Maximum Units on a Truck","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_smallest_largest/#3075-maximize-happiness-of-selected-children","title":"3075. Maximize Happiness of Selected Children","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul> 3075. Maximize Happiness of Selected Children - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef maximumHappinessSum(happiness: List[int], k: int) -&gt; int:\n    selected = 0\n    happinessScore = 0\n    happiness.sort(reverse=True)\n\n    for score in happiness:\n        if selected == k:\n            return happinessScore\n        happinessScore += max(0, score - selected)\n        selected += 1\n\n    return happinessScore\n\n\nhappiness = [1, 2, 3]\nk = 2\nprint(maximumHappinessSum(happiness, k))  # 4\n</code></pre>"},{"location":"endlesscheng/greedy_from_smallest_largest/#2554-maximum-number-of-integers-to-choose-from-a-range-i","title":"2554. Maximum Number of Integers to Choose From a Range I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, binary search, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_smallest_largest/#2126-destroying-asteroids","title":"2126. Destroying Asteroids","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_smallest_largest/#2587-rearrange-array-to-maximize-prefix-score","title":"2587. Rearrange Array to Maximize Prefix Score","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_smallest_largest/#976-largest-perimeter-triangle","title":"976. Largest Perimeter Triangle","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, math, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_smallest_largest/#1561-maximum-number-of-coins-you-can-get","title":"1561. Maximum Number of Coins You Can Get","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, greedy, sorting, game theory</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_smallest_largest/#3301-maximize-the-total-height-of-unique-towers","title":"3301. Maximize the Total Height of Unique Towers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_smallest_largest/#945-minimum-increment-to-make-array-unique","title":"945. Minimum Increment to Make Array Unique","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting, counting</p> </li> </ul> 945. Minimum Increment to Make Array Unique - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef minIncrementForUnique(nums: List[int]) -&gt; int:\n    nums.sort()\n    moves = 0\n\n    for i in range(1, len(nums)):\n        if nums[i] &lt;= nums[i - 1]:\n            moves += nums[i - 1] + 1 - nums[i]\n            nums[i] = nums[i - 1] + 1\n\n    return moves\n\n\nnums = [1, 2, 2]\nprint(minIncrementForUnique(nums))  # 1\n</code></pre>"},{"location":"endlesscheng/greedy_from_smallest_largest/#1846-maximum-element-after-decreasing-and-rearranging","title":"1846. Maximum Element After Decreasing and Rearranging","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_smallest_largest/#1647-minimum-deletions-to-make-character-frequencies-unique","title":"1647. Minimum Deletions to Make Character Frequencies Unique","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_smallest_largest/#2971-find-polygon-with-the-largest-perimeter","title":"2971. Find Polygon With the Largest Perimeter","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_smallest_largest/#2178-maximum-split-of-positive-even-integers","title":"2178. Maximum Split of Positive Even Integers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, backtracking, greedy</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_smallest_largest/#2567-minimum-score-by-changing-two-elements","title":"2567. Minimum Score by Changing Two Elements","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_smallest_largest/#1509-minimum-difference-between-largest-and-smallest-value-in-three-moves","title":"1509. Minimum Difference Between Largest and Smallest Value in Three Moves","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_smallest_largest/#3397-maximum-number-of-distinct-elements-after-operations","title":"3397. Maximum Number of Distinct Elements After Operations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_smallest_largest/#3457-eat-pizzas","title":"3457. Eat Pizzas!","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_smallest_largest/#1262-greatest-sum-divisible-by-three","title":"1262. Greatest Sum Divisible by Three","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_smallest_largest/#948-bag-of-tokens","title":"948. Bag of Tokens","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_smallest_largest/#1775-equal-sum-arrays-with-minimum-number-of-operations","title":"1775. Equal Sum Arrays With Minimum Number of Operations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, greedy, counting</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_smallest_largest/#2333-minimum-sum-of-squared-difference","title":"2333. Minimum Sum of Squared Difference","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, greedy, sorting, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_smallest_largest/#3440-reschedule-meetings-for-maximum-free-time-ii","title":"3440. Reschedule Meetings for Maximum Free Time II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, enumeration</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_smallest_largest/#2141-maximum-running-time-of-n-computers","title":"2141. Maximum Running Time of N Computers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_smallest_largest/#1196-how-many-apples-can-you-put-into-the-basket","title":"1196. How Many Apples Can You Put into the Basket","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_smallest_largest/#2214-minimum-health-to-beat-game","title":"2214. Minimum Health to Beat Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_smallest_largest/#2098-subsequence-of-size-k-with-the-largest-even-sum","title":"2098. Subsequence of Size K With the Largest Even Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_smallest_largest/#2548-maximum-price-to-fill-a-bag","title":"2548. Maximum Price to Fill a Bag","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_smallest_largest/#3119-maximum-number-of-potholes-that-can-be-fixed","title":"3119. Maximum Number of Potholes That Can Be Fixed","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_smallest_largest/#2557-maximum-number-of-integers-to-choose-from-a-range-ii","title":"2557. Maximum Number of Integers to Choose From a Range II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_smallest_largest/#624-maximum-distance-in-arrays","title":"624. Maximum Distance in Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy</p> </li> </ul> 624. Maximum Distance in Arrays - Python Solution<pre><code>from typing import List\n\n\n# Array\ndef maxDistance(arrays: List[List[int]]) -&gt; int:\n    mn, mx = float(\"inf\"), float(\"-inf\")\n    res = 0\n\n    for array in arrays:\n        mn = min(mn, array[0])\n        mx = max(mx, array[-1])\n        res = max(res, abs(array[-1] - mn), abs(mx - array[0]))\n\n    return res\n\n\narrays = [[1, 2, 3], [4, 5], [1, 2, 3]]\nprint(maxDistance(arrays))  # 4\n</code></pre>"},{"location":"endlesscheng/greedy_from_smallest_largest/#910-smallest-range-ii","title":"910. Smallest Range II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_smallest_largest/#2835-minimum-operations-to-form-subsequence-with-target-sum","title":"2835. Minimum Operations to Form Subsequence With Target Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/greedy_from_smallest_largest/#3366-minimum-array-sum","title":"3366. Minimum Array Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"endlesscheng/greedy_others/","title":"Greedy Others","text":"<ul> <li> 2740. Find the Value of the Partition (Medium)</li> <li> 1033. Moving Stones Until Consecutive (Medium)</li> <li> 1864. Minimum Number of Swaps to Make the Binary String Alternating (Medium)</li> <li> 1899. Merge Triplets to Form Target Triplet (Medium)</li> <li> 2498. Frog Jump II (Medium)</li> <li> 134. Gas Station (Medium)</li> <li> 2311. Longest Binary Subsequence Less Than or Equal to K (Medium)</li> <li> 3443. Maximum Manhattan Distance After K Changes (Medium)</li> <li> 3002. Maximum Size of a Set After Removals (Medium)</li> <li> 2412. Minimum Money Required Before Transactions (Hard)</li> <li> 659. Split Array into Consecutive Subsequences (Medium)</li> <li> 2732. Find a Good Subset of the Matrix (Hard)</li> <li> 2790. Maximum Number of Groups With Increasing Length (Hard)</li> <li> 782. Transform to Chessboard (Hard)</li> <li> 420. Strong Password Checker (Hard)</li> <li> 2753. Count Houses in a Circular Street II (Hard)</li> </ul>"},{"location":"endlesscheng/greedy_others/#2740-find-the-value-of-the-partition","title":"2740. Find the Value of the Partition","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sorting</p> </li> </ul>"},{"location":"endlesscheng/greedy_others/#1033-moving-stones-until-consecutive","title":"1033. Moving Stones Until Consecutive","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, brainteaser</p> </li> </ul>"},{"location":"endlesscheng/greedy_others/#1864-minimum-number-of-swaps-to-make-the-binary-string-alternating","title":"1864. Minimum Number of Swaps to Make the Binary String Alternating","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, greedy</p> </li> </ul>"},{"location":"endlesscheng/greedy_others/#1899-merge-triplets-to-form-target-triplet","title":"1899. Merge Triplets to Form Target Triplet","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy</p> </li> </ul> 1899. Merge Triplets to Form Target Triplet - Python Solution<pre><code>from typing import List\n\n\ndef mergeTriplets(triplets: List[List[int]], target: List[int]) -&gt; bool:\n    can_form = [False, False, False]\n\n    for triplet in triplets:\n        if all(triplet[i] &lt;= target[i] for i in range(3)):\n            for i in range(3):\n                if triplet[i] == target[i]:\n                    can_form[i] = True\n\n    return all(can_form)\n\n\ntriplets = [[2, 5, 3], [1, 8, 4], [1, 7, 5]]\ntarget = [2, 7, 5]\nprint(mergeTriplets(triplets, target))  # True\n</code></pre>"},{"location":"endlesscheng/greedy_others/#2498-frog-jump-ii","title":"2498. Frog Jump II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, greedy</p> </li> </ul>"},{"location":"endlesscheng/greedy_others/#134-gas-station","title":"134. Gas Station","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy</p> </li> </ul> 134. Gas Station - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef canCompleteCircuit(gas: List[int], cost: List[int]) -&gt; int:\n    curSum = 0\n    totalSum = 0\n    start = 0\n\n    for i in range(len(gas)):\n        curSum += gas[i] - cost[i]\n        totalSum += gas[i] - cost[i]\n\n        if curSum &lt; 0:\n            start = i + 1\n            curSum = 0\n\n    if totalSum &lt; 0:\n        return -1\n\n    return start\n\n\ngas = [1, 2, 3, 4, 5]\ncost = [3, 4, 5, 1, 2]\nprint(canCompleteCircuit(gas, cost))  # 3\n</code></pre>"},{"location":"endlesscheng/greedy_others/#2311-longest-binary-subsequence-less-than-or-equal-to-k","title":"2311. Longest Binary Subsequence Less Than or Equal to K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming, greedy, memoization</p> </li> </ul>"},{"location":"endlesscheng/greedy_others/#3443-maximum-manhattan-distance-after-k-changes","title":"3443. Maximum Manhattan Distance After K Changes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, math, string, counting</p> </li> </ul>"},{"location":"endlesscheng/greedy_others/#3002-maximum-size-of-a-set-after-removals","title":"3002. Maximum Size of a Set After Removals","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, greedy</p> </li> </ul>"},{"location":"endlesscheng/greedy_others/#2412-minimum-money-required-before-transactions","title":"2412. Minimum Money Required Before Transactions","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/greedy_others/#659-split-array-into-consecutive-subsequences","title":"659. Split Array into Consecutive Subsequences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, greedy, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/greedy_others/#2732-find-a-good-subset-of-the-matrix","title":"2732. Find a Good Subset of the Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, bit manipulation, matrix</p> </li> </ul>"},{"location":"endlesscheng/greedy_others/#2790-maximum-number-of-groups-with-increasing-length","title":"2790. Maximum Number of Groups With Increasing Length","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, binary search, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/greedy_others/#782-transform-to-chessboard","title":"782. Transform to Chessboard","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, bit manipulation, matrix</p> </li> </ul>"},{"location":"endlesscheng/greedy_others/#420-strong-password-checker","title":"420. Strong Password Checker","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, greedy, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/greedy_others/#2753-count-houses-in-a-circular-street-ii","title":"2753. Count Houses in a Circular Street II","text":"<ul> <li>LeetCode | LeetCode CH (Hard)</li> </ul>"},{"location":"endlesscheng/grid_01_bfs/","title":"Grid 01 BFS","text":"<ul> <li> 1368. Minimum Cost to Make at Least One Valid Path in a Grid (Hard)</li> <li> 2290. Minimum Obstacle Removal to Reach Corner (Hard)</li> <li> 3286. Find a Safe Walk Through a Grid (Medium)</li> <li> 1824. Minimum Sideway Jumps (Medium)</li> </ul>"},{"location":"endlesscheng/grid_01_bfs/#1368-minimum-cost-to-make-at-least-one-valid-path-in-a-grid","title":"1368. Minimum Cost to Make at Least One Valid Path in a Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, breadth first search, graph, heap priority queue, matrix, shortest path</p> </li> </ul>"},{"location":"endlesscheng/grid_01_bfs/#2290-minimum-obstacle-removal-to-reach-corner","title":"2290. Minimum Obstacle Removal to Reach Corner","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, breadth first search, graph, heap priority queue, matrix, shortest path</p> </li> </ul>"},{"location":"endlesscheng/grid_01_bfs/#3286-find-a-safe-walk-through-a-grid","title":"3286. Find a Safe Walk Through a Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, breadth first search, graph, heap priority queue, matrix, shortest path</p> </li> </ul>"},{"location":"endlesscheng/grid_01_bfs/#1824-minimum-sideway-jumps","title":"1824. Minimum Sideway Jumps","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> </ul>"},{"location":"endlesscheng/grid_applications/","title":"Grid Applications","text":"<ul> <li> 1631. Path With Minimum Effort (Medium)</li> <li> 778. Swim in Rising Water (Hard)</li> <li> 329. Longest Increasing Path in a Matrix (Hard)</li> <li> 1036. Escape a Large Maze (Hard)</li> <li> 864. Shortest Path to Get All Keys (Hard)</li> <li> 1263. Minimum Moves to Move a Box to Their Target Location (Hard)</li> <li> 2258. Escape the Spreading Fire (Hard)</li> <li> 2556. Disconnect Path in a Binary Matrix by at Most One Flip (Medium)</li> <li> 2577. Minimum Time to Visit a Cell In a Grid (Hard)</li> <li> 2617. Minimum Number of Visited Cells in a Grid (Hard)</li> <li> 694. Number of Distinct Islands (Medium)</li> <li> 711. Number of Distinct Islands II (Hard)</li> <li> 1102. Path With Maximum Minimum Value (Medium)</li> </ul>"},{"location":"endlesscheng/grid_applications/#1631-path-with-minimum-effort","title":"1631. Path With Minimum Effort","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, depth first search, breadth first search, union find, heap priority queue, matrix</p> </li> <li>Return the minimum effort required to travel from the top-left to the bottom-right corner.</li> </ul> 1631. Path With Minimum Effort - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Prim\ndef minimumEffortPath(heights: List[List[int]]) -&gt; int:\n    m, n = len(heights), len(heights[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * n for _ in range(m)]\n    heap = [(0, 0, 0)]  # (effort, row, col)\n\n    while heap:\n        effort, r, c = heapq.heappop(heap)\n\n        if visited[r][c]:\n            continue\n\n        if r == m - 1 and c == n - 1:\n            return effort\n\n        visited[r][c] = True\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and not visited[nr][nc]:\n                updated = max(effort, abs(heights[r][c] - heights[nr][nc]))\n                heapq.heappush(heap, (updated, nr, nc))\n\n    return -1\n\n\nheights = [[1, 2, 2], [3, 8, 2], [5, 3, 5]]\nprint(minimumEffortPath(heights))  # 2\n</code></pre>"},{"location":"endlesscheng/grid_applications/#778-swim-in-rising-water","title":"778. Swim in Rising Water","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, depth first search, breadth first search, union find, heap priority queue, matrix</p> </li> <li>Return the minimum time when you can reach the target.</li> </ul> <p></p> 778. Swim in Rising Water - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra's\ndef swimInWater(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    visited = set()\n    minHeap = [(grid[0][0], 0, 0)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    visited.add((0, 0))\n\n    while minHeap:\n        time, r, c = heapq.heappop(minHeap)\n\n        if r == n - 1 and c == n - 1:\n            return time\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if nr in range(n) and nc in range(n) and (nr, nc) not in visited:\n                visited.add((nr, nc))\n                heapq.heappush(minHeap, (max(time, grid[nr][nc]), nr, nc))\n\n\ngrid = [\n    [0, 1, 2, 3, 4],\n    [24, 23, 22, 21, 5],\n    [12, 13, 14, 15, 16],\n    [11, 17, 18, 19, 20],\n    [10, 9, 8, 7, 6],\n]\nprint(swimInWater(grid))  # 16\n</code></pre>"},{"location":"endlesscheng/grid_applications/#329-longest-increasing-path-in-a-matrix","title":"329. Longest Increasing Path in a Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, depth first search, breadth first search, graph, topological sort, memoization, matrix</p> </li> </ul> 329. Longest Increasing Path in a Matrix - Python Solution<pre><code>from typing import List\n\n\n# DP - 2D\ndef longestIncreasingPath(matrix: List[List[int]]) -&gt; int:\n    if not matrix:\n        return 0\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * n for _ in range(m)]\n    dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(r, c):\n        if dp[r][c]:\n            return dp[r][c]\n        for dr, dc in dirs:\n            nr, nc = r + dr, c + dc\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and matrix[nr][nc] &gt; matrix[r][c]:\n                dp[r][c] = max(dp[r][c], dfs(nr, nc))\n        dp[r][c] += 1\n        return dp[r][c]\n\n    res = float(\"-inf\")\n    for i in range(m):\n        for j in range(n):\n            res = max(res, dfs(i, j))\n\n    return res\n\n\nmatrix = [[9, 9, 4], [6, 6, 8], [2, 1, 1]]\nprint(longestIncreasingPath(matrix))  # 4\n</code></pre>"},{"location":"endlesscheng/grid_applications/#1036-escape-a-large-maze","title":"1036. Escape a Large Maze","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, depth first search, breadth first search</p> </li> </ul>"},{"location":"endlesscheng/grid_applications/#864-shortest-path-to-get-all-keys","title":"864. Shortest Path to Get All Keys","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, bit manipulation, breadth first search, matrix</p> </li> </ul> 864. Shortest Path to Get All Keys - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef shortestPathAllKeys(grid: List[str]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    q = deque()\n    visited = set()\n    total = 0\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"@\":\n                q.append((r, c, 0, 0))\n                visited.add((r, c, 0))\n            if grid[r][c].islower():\n                total += 1\n\n    while q:\n        r, c, keys, steps = q.popleft()\n\n        if keys == (1 &lt;&lt; total) - 1:\n            return steps\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n:\n                cell = grid[nr][nc]\n\n                if cell == \"#\":\n                    continue\n\n                new_keys = keys\n                if cell.islower():\n                    new_keys |= 1 &lt;&lt; (ord(cell) - ord(\"a\"))\n\n                if cell.isupper() and not (\n                    keys &amp; (1 &lt;&lt; (ord(cell) - ord(\"A\")))\n                ):\n                    continue\n\n                if (nr, nc, new_keys) not in visited:\n                    visited.add((nr, nc, new_keys))\n                    q.append((nr, nc, new_keys, steps + 1))\n\n    return -1\n\n\ngrid = [\"@.a..\", \"###.#\", \"b.A.B\"]\nprint(shortestPathAllKeys(grid))  # 8\n</code></pre>"},{"location":"endlesscheng/grid_applications/#1263-minimum-moves-to-move-a-box-to-their-target-location","title":"1263. Minimum Moves to Move a Box to Their Target Location","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, breadth first search, heap priority queue, matrix</p> </li> </ul>"},{"location":"endlesscheng/grid_applications/#2258-escape-the-spreading-fire","title":"2258. Escape the Spreading Fire","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, breadth first search, matrix</p> </li> </ul>"},{"location":"endlesscheng/grid_applications/#2556-disconnect-path-in-a-binary-matrix-by-at-most-one-flip","title":"2556. Disconnect Path in a Binary Matrix by at Most One Flip","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, depth first search, breadth first search, matrix</p> </li> </ul>"},{"location":"endlesscheng/grid_applications/#2577-minimum-time-to-visit-a-cell-in-a-grid","title":"2577. Minimum Time to Visit a Cell In a Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, breadth first search, graph, heap priority queue, matrix, shortest path</p> </li> </ul>"},{"location":"endlesscheng/grid_applications/#2617-minimum-number-of-visited-cells-in-a-grid","title":"2617. Minimum Number of Visited Cells in a Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, stack, breadth first search, union find, heap priority queue, matrix, monotonic stack</p> </li> </ul>"},{"location":"endlesscheng/grid_applications/#694-number-of-distinct-islands","title":"694. Number of Distinct Islands","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, depth first search, breadth first search, union find, hash function</p> </li> </ul>"},{"location":"endlesscheng/grid_applications/#711-number-of-distinct-islands-ii","title":"711. Number of Distinct Islands II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, depth first search, breadth first search, union find, hash function</p> </li> </ul>"},{"location":"endlesscheng/grid_applications/#1102-path-with-maximum-minimum-value","title":"1102. Path With Maximum Minimum Value","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, depth first search, breadth first search, union find, heap priority queue, matrix</p> </li> </ul>"},{"location":"endlesscheng/grid_bfs/","title":"Grid BFS","text":"<ul> <li> 1926. Nearest Exit from Entrance in Maze (Medium)</li> <li> 1091. Shortest Path in Binary Matrix (Medium)</li> <li> 1162. As Far from Land as Possible (Medium)</li> <li> 542. 01 Matrix (Medium)</li> <li> 994. Rotting Oranges (Medium)</li> <li> 1765. Map of Highest Peak (Medium)</li> <li> 934. Shortest Bridge (Medium)</li> <li> 2146. K Highest Ranked Items Within a Price Range (Medium)</li> <li> 1293. Shortest Path in a Grid with Obstacles Elimination (Hard)</li> <li> 909. Snakes and Ladders (Medium)</li> <li> 1210. Minimum Moves to Reach Target with Rotations (Hard)</li> <li> 675. Cut Off Trees for Golf Event (Hard)</li> <li> 749. Contain Virus (Hard)</li> <li> 1730. Shortest Path to Get Food (Medium)</li> <li> 286. Walls and Gates (Medium)</li> <li> 490. The Maze (Medium)</li> <li> 505. The Maze II (Medium)</li> <li> 499. The Maze III (Hard)</li> <li> 317. Shortest Distance from All Buildings (Hard)</li> <li> 2814. Minimum Time Takes to Reach Destination Without Drowning (Hard)</li> </ul>"},{"location":"endlesscheng/grid_bfs/#1926-nearest-exit-from-entrance-in-maze","title":"1926. Nearest Exit from Entrance in Maze","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, breadth first search, matrix</p> </li> </ul> 1926. Nearest Exit from Entrance in Maze - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef nearestExit(maze: List[List[str]], entrance: List[int]) -&gt; int:\n    m, n = len(maze), len(maze[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque([(entrance[0], entrance[1], 0)])\n    maze[entrance[0]][entrance[1]] = \"+\"\n\n    while q:\n        r, c, steps = q.popleft()\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and maze[nr][nc] == \".\":\n                if nr in [0, m - 1] or nc in [0, n - 1]:\n                    return steps + 1\n                q.append((nr, nc, steps + 1))\n                maze[nr][nc] = \"+\"\n\n    return -1\n\n\nmaze = [[\"+\", \"+\", \".\", \"+\"], [\".\", \".\", \".\", \"+\"], [\"+\", \"+\", \"+\", \".\"]]\nentrance = [1, 2]\nprint(nearestExit(maze, entrance))  # 1\n</code></pre>"},{"location":"endlesscheng/grid_bfs/#1091-shortest-path-in-binary-matrix","title":"1091. Shortest Path in Binary Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, breadth first search, matrix</p> </li> </ul> 1091. Shortest Path in Binary Matrix - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    if grid[0][0] == 1 or grid[n - 1][n - 1] == 1:\n        return -1\n    if n == 1:\n        return 1\n\n    directions = [\n        (0, 1),\n        (1, 0),\n        (0, -1),\n        (-1, 0),\n        (1, 1),\n        (-1, -1),\n        (1, -1),\n        (-1, 1),\n    ]\n    q = deque([(0, 0, 1)])  # (row, column, distance)\n    grid[0][0] = 1\n\n    while q:\n        r, c, d = q.popleft()\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 &lt;= nr &lt; n and 0 &lt;= nc &lt; n and grid[nr][nc] == 0:\n                if nr == nc == n - 1:\n                    return d + 1\n                q.append((nr, nc, d + 1))\n                grid[nr][nc] = 1\n\n    return -1\n\n\ngrid = [[0, 0, 0], [1, 1, 0], [1, 1, 0]]\nprint(shortestPathBinaryMatrix(grid))  # 4\n</code></pre>"},{"location":"endlesscheng/grid_bfs/#1162-as-far-from-land-as-possible","title":"1162. As Far from Land as Possible","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, breadth first search, matrix</p> </li> </ul>"},{"location":"endlesscheng/grid_bfs/#542-01-matrix","title":"542. 01 Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, breadth first search, matrix</p> </li> </ul> 542. 01 Matrix - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef updateMatrix(mat: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(mat), len(mat[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    q = deque()\n\n    for i in range(m):\n        for j in range(n):\n            if mat[i][j] == 0:\n                dist[i][j] = 0\n                q.append((i, j))\n\n    while q:\n        r, c = q.popleft()\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and dist[nr][nc] &gt; dist[r][c] + 1:\n                dist[nr][nc] = dist[r][c] + 1\n                q.append((nr, nc))\n\n    return dist\n\n\nmat = [[0, 0, 0], [0, 1, 0], [1, 1, 1]]\nprint(updateMatrix(mat))\n# [[0, 0, 0], [0, 1, 0], [1, 2, 1]]\n</code></pre>"},{"location":"endlesscheng/grid_bfs/#994-rotting-oranges","title":"994. Rotting Oranges","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, breadth first search, matrix</p> </li> <li>Return the minimum number of minutes that must elapse until no cell has a fresh orange.</li> <li>Hint: Multi-source BFS to count the level.</li> </ul> <p></p> 994. Rotting Oranges - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef orangesRotting(grid: List[List[int]]) -&gt; int:\n    # 1. Init\n    q = deque()\n    time, fresh = 0, 0\n    m, n = len(grid), len(grid[0])\n    dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n\n    # 2. Make a queue of rotten oranges and count fresh oranges\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                fresh += 1\n            if grid[r][c] == 2:\n                q.append([r, c])\n\n    # 3. BFS\n    while q and fresh &gt; 0:\n        size = len(q)\n\n        for _ in range(size):\n            r, c = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = r + dr, c + dc\n                if nr &lt; 0 or nc &lt; 0 or nr &gt;= m or nc &gt;= n or grid[nr][nc] != 1:\n                    continue\n                grid[nr][nc] = 2\n                q.append([nr, nc])\n                fresh -= 1\n        time += 1\n\n    return time if fresh == 0 else -1\n\n\ngrid = [[2, 1, 1], [1, 1, 0], [0, 1, 1]]\nprint(orangesRotting(grid))\n</code></pre>"},{"location":"endlesscheng/grid_bfs/#1765-map-of-highest-peak","title":"1765. Map of Highest Peak","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, breadth first search, matrix</p> </li> </ul>"},{"location":"endlesscheng/grid_bfs/#934-shortest-bridge","title":"934. Shortest Bridge","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, matrix</p> </li> </ul> 934. Shortest Bridge - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS + DFS; Coloring\ndef shortestBridge(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(r, c, queue):\n        grid[r][c] = 2\n        queue.append((r, c))\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if nr in range(n) and nc in range(n) and grid[nr][nc] == 1:\n                dfs(nr, nc, queue)\n\n    q = deque()\n    found = False\n    for r in range(n):\n        if found:\n            break\n        for c in range(n):\n            if grid[r][c] == 1:\n                dfs(r, c, q)\n                found = True\n                break\n\n    steps = 0\n    while q:\n        m = len(q)\n        for _ in range(m):\n            r, c = q.popleft()\n            for dr, dc in directions:\n                nr, nc = r + dr, c + dc\n                if nr in range(n) and nc in range(n):\n                    if grid[nr][nc] == 1:\n                        return steps\n                    elif grid[nr][nc] == 0:\n                        grid[nr][nc] = 2\n                        q.append((nr, nc))\n        steps += 1\n\n    return -1\n\n\ngrid = [\n    [1, 1, 1, 1, 1],\n    [1, 0, 0, 0, 1],\n    [1, 0, 1, 0, 1],\n    [1, 0, 0, 0, 1],\n    [1, 1, 1, 1, 1],\n]\nprint(shortestBridge(grid))  # 1\n</code></pre>"},{"location":"endlesscheng/grid_bfs/#2146-k-highest-ranked-items-within-a-price-range","title":"2146. K Highest Ranked Items Within a Price Range","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, breadth first search, sorting, heap priority queue, matrix</p> </li> </ul>"},{"location":"endlesscheng/grid_bfs/#1293-shortest-path-in-a-grid-with-obstacles-elimination","title":"1293. Shortest Path in a Grid with Obstacles Elimination","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, breadth first search, matrix</p> </li> </ul>"},{"location":"endlesscheng/grid_bfs/#909-snakes-and-ladders","title":"909. Snakes and Ladders","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, breadth first search, matrix</p> </li> </ul>"},{"location":"endlesscheng/grid_bfs/#1210-minimum-moves-to-reach-target-with-rotations","title":"1210. Minimum Moves to Reach Target with Rotations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, breadth first search, matrix</p> </li> </ul>"},{"location":"endlesscheng/grid_bfs/#675-cut-off-trees-for-golf-event","title":"675. Cut Off Trees for Golf Event","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, breadth first search, heap priority queue, matrix</p> </li> </ul>"},{"location":"endlesscheng/grid_bfs/#749-contain-virus","title":"749. Contain Virus","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, matrix, simulation</p> </li> </ul>"},{"location":"endlesscheng/grid_bfs/#1730-shortest-path-to-get-food","title":"1730. Shortest Path to Get Food","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, breadth first search, matrix</p> </li> </ul>"},{"location":"endlesscheng/grid_bfs/#286-walls-and-gates","title":"286. Walls and Gates","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, breadth first search, matrix </p> </li> </ul> 286. Walls and Gates - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# Multi-source BFS\ndef wallsAndGates(rooms: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify rooms in-place instead.\n    \"\"\"\n    m, n = len(rooms), len(rooms[0])\n    visited = set()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def addRoom(r, c):\n        if (\n            r in range(m)\n            and c in range(n)\n            and (r, c) not in visited\n            and rooms[r][c] != -1\n        ):\n            q.append((r, c))\n            visited.add((r, c))\n\n    q = deque()\n    for r in range(m):\n        for c in range(n):\n            if rooms[r][c] == 0:\n                q.append((r, c))\n                visited.add((r, c))\n\n    dist = 0\n\n    while q:\n        for _ in range(len(q)):\n            r, c = q.popleft()\n            rooms[r][c] = dist\n\n            for dr, dc in directions:\n                addRoom(r + dr, c + dc)\n        dist += 1\n\n\nrooms = [\n    [2147483647, -1, 0, 2147483647],\n    [2147483647, 2147483647, 2147483647, -1],\n    [2147483647, -1, 2147483647, -1],\n    [0, -1, 2147483647, 2147483647],\n]\nwallsAndGates(rooms)\nprint(rooms)\n# [[3, -1, 0,  1],\n#  [2,  2, 1, -1],\n#  [1, -1, 2, -1],\n#  [0, -1, 3,  4]]\n</code></pre>"},{"location":"endlesscheng/grid_bfs/#490-the-maze","title":"490. The Maze","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, matrix</p> </li> </ul>"},{"location":"endlesscheng/grid_bfs/#505-the-maze-ii","title":"505. The Maze II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, graph, heap priority queue, matrix, shortest path</p> </li> </ul> 505. The Maze II - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra\ndef shortestDistance(\n    maze: List[List[int]], start: List[int], destination: List[int]\n) -&gt; int:\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    m, n = len(maze), len(maze[0])\n\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    dist[start[0]][start[1]] = 0\n\n    heap = [(0, start[0], start[1])]\n\n    while heap:\n        d, r, c = heapq.heappop(heap)\n\n        if [r, c] == destination:\n            return d\n\n        for dr, dc in directions:\n            nr, nc, nd = r, c, d\n\n            while (\n                0 &lt;= nr + dr &lt; m\n                and 0 &lt;= nc + dc &lt; n\n                and maze[nr + dr][nc + dc] == 0\n            ):\n                nr += dr\n                nc += dc\n                nd += 1\n\n            if nd &lt; dist[nr][nc]:\n                dist[nr][nc] = nd\n                heapq.heappush(heap, (nd, nr, nc))\n\n    return -1\n\n\nmaze = [\n    [0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0],\n    [0, 0, 0, 1, 0],\n    [1, 1, 0, 1, 1],\n    [0, 0, 0, 0, 0],\n]\nstart = [0, 4]\ndestination = [4, 4]\nprint(shortestDistance(maze, start, destination))  # 12\n</code></pre>"},{"location":"endlesscheng/grid_bfs/#499-the-maze-iii","title":"499. The Maze III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, depth first search, breadth first search, graph, heap priority queue, matrix, shortest path</p> </li> </ul> 499. The Maze III - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra\ndef findShortestWay(\n    maze: List[List[int]], ball: List[int], hole: List[int]\n) -&gt; str:\n    directions = [(-1, 0, \"u\"), (1, 0, \"d\"), (0, -1, \"l\"), (0, 1, \"r\")]\n    m, n = len(maze), len(maze[0])\n\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    dist[ball[0]][ball[1]] = 0\n\n    paths = [[\"\"] * n for _ in range(m)]\n    paths[ball[0]][ball[1]] = \"\"\n\n    heap = [(0, \"\", ball[0], ball[1])]\n\n    while heap:\n        d, path, x, y = heapq.heappop(heap)\n\n        if [x, y] == hole:\n            return path\n\n        for dx, dy, direction in directions:\n            nx, ny, nd = x, y, d\n\n            while (\n                0 &lt;= nx + dx &lt; m\n                and 0 &lt;= ny + dy &lt; n\n                and maze[nx + dx][ny + dy] == 0\n            ):\n                nx += dx\n                ny += dy\n                nd += 1\n\n                if [nx, ny] == hole:\n                    break\n\n            new_path = path + direction\n            if nd &lt; dist[nx][ny] or (\n                nd == dist[nx][ny] and new_path &lt; paths[nx][ny]\n            ):\n                dist[nx][ny] = nd\n                paths[nx][ny] = new_path\n                heapq.heappush(heap, (nd, new_path, nx, ny))\n\n    return \"impossible\"\n\n\nmaze = [\n    [0, 0, 0, 0, 0],\n    [1, 1, 0, 0, 1],\n    [0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 1],\n    [0, 1, 0, 0, 0],\n]\nball = [4, 3]\nhole = [0, 1]\nprint(findShortestWay(maze, ball, hole))  # \"lul\"\n</code></pre>"},{"location":"endlesscheng/grid_bfs/#317-shortest-distance-from-all-buildings","title":"317. Shortest Distance from All Buildings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, breadth first search, matrix</p> </li> </ul>"},{"location":"endlesscheng/grid_bfs/#2814-minimum-time-takes-to-reach-destination-without-drowning","title":"2814. Minimum Time Takes to Reach Destination Without Drowning","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, breadth first search, matrix</p> </li> </ul>"},{"location":"endlesscheng/grid_dfs/","title":"Grid DFS","text":"<ul> <li> 200. Number of Islands (Medium)</li> <li> 695. Max Area of Island (Medium)</li> <li> 463. Island Perimeter (Easy)</li> <li> 2658. Maximum Number of Fish in a Grid (Medium)</li> <li> 1034. Coloring A Border (Medium)</li> <li> 1020. Number of Enclaves (Medium)</li> <li> 2684. Maximum Number of Moves in a Grid (Medium)</li> <li> 1254. Number of Closed Islands (Medium)</li> <li> 130. Surrounded Regions (Medium)</li> <li> 1905. Count Sub Islands (Medium)</li> <li> 1391. Check if There is a Valid Path in a Grid (Medium)</li> <li> 417. Pacific Atlantic Water Flow (Medium)</li> <li> 529. Minesweeper (Medium)</li> <li> 1559. Detect Cycles in 2D Grid (Medium)</li> <li> 827. Making A Large Island (Hard)</li> <li> 305. Number of Islands II (Hard)</li> <li> 2061. Number of Spaces Cleaning Robot Cleaned (Medium)</li> <li> 2852. Sum of Remoteness of All Cells (Medium)</li> <li> 489. Robot Room Cleaner (Hard)</li> </ul>"},{"location":"endlesscheng/grid_dfs/#200-number-of-islands","title":"200. Number of Islands","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix</p> </li> <li>Count the number of islands in a 2D grid.</li> <li>Method 1: DFS</li> <li> <p>Method 2: BFS (use a queue to traverse the grid)</p> </li> <li> <p>How to keep track of visited cells?</p> <ol> <li>Mark the visited cell as <code>0</code> (or any other value) to avoid revisiting it.</li> <li>Use a set to store the visited cells.</li> </ol> </li> <li> <p>Steps:</p> <ol> <li>Init: variables</li> <li>DFS/BFS: starting from the cell with <code>1</code>, turn all the connected <code>1</code>s to <code>0</code>.</li> <li>Traverse the grid, and if the cell is <code>1</code>, increment the count and call DFS/BFS.</li> </ol> </li> </ul> <p></p> 200. Number of Islands - Python Solution<pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef numIslandsDFS(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    res = 0\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] != \"1\":\n            return\n\n        grid[r][c] = \"2\"\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                dfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Set\ndef numIslandsBFS1(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == \"0\"\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\" and (r, c) not in visited:\n                visited.add((r, c))\n                bfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = dr + row, dc + col\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] != \"1\"\n                ):\n                    continue\n                grid[nr][nc] = \"2\"\n                q.append((nr, nc))\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == \"1\":\n                grid[i][j] = \"2\"\n                bfs(i, j)\n                res += 1\n\n    return res\n\n\ngrid = [\n    [\"1\", \"1\", \"1\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"0\", \"0\", \"0\", \"0\", \"0\"],\n]\n\nprint(numIslandsDFS(deepcopy(grid)))  # 1\nprint(numIslandsBFS1(deepcopy(grid)))  # 1\nprint(numIslandsBFS2(deepcopy(grid)))  # 1\n</code></pre>"},{"location":"endlesscheng/grid_dfs/#695-max-area-of-island","title":"695. Max Area of Island","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix</p> </li> </ul> 695. Max Area of Island - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef maxAreaOfIslandDFS(grid: List[List[int]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] != 1:\n            return 0\n\n        grid[r][c] = 2\n\n        return (\n            1 + dfs(r - 1, c) + dfs(r + 1, c) + dfs(r, c + 1) + dfs(r, c - 1)\n        )\n\n    area = 0\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                area = max(area, dfs(r, c))\n\n    return area\n\n\n# BFS\ndef maxAreaOfIslandBFS1(grid: List[List[int]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        area = 0\n\n        while q:\n            row, col = q.popleft()\n            area += 1\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == 0\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n        return area\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1 and (r, c) not in visited:\n                visited.add((r, c))\n                res = max(res, bfs(r, c))\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        area = 0\n\n        while q:\n            row, col = q.popleft()\n            area += 1\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n\n                if nr &lt; 0 or nr &gt;= m or nc &lt; 0 or nc &gt;= n or grid[nr][nc] == 0:\n                    continue\n\n                q.append((nr, nc))\n                grid[nr][nc] = 0\n\n        return area\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                grid[r][c] = 0\n                res = max(res, bfs(r, c))\n\n    return res\n\n\ngrid = [\n    [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0],\n    [0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],\n]\nprint(maxAreaOfIslandDFS(grid))  # 6\nprint(maxAreaOfIslandBFS1(grid))  # 6\nprint(numIslandsBFS2(grid))  # 6\n</code></pre>"},{"location":"endlesscheng/grid_dfs/#463-island-perimeter","title":"463. Island Perimeter","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, matrix</p> </li> </ul> 463. Island Perimeter - Python Solution<pre><code>from typing import List\n\n\n# DFS\ndef islandPerimeterDFS(grid: List[List[int]]) -&gt; int:\n    # TC: O(m * n)\n    # SC: O(m * n)\n\n    visited = set()\n    m, n = len(grid), len(grid[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def dfs(r, c):\n        if (r, c) in visited or grid[r][c] == 0:\n            return 0\n        visited.add((r, c))\n        perimeter = 0\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if nr not in range(m) or nc not in range(n) or grid[nr][nc] == 0:\n                perimeter += 1\n            else:\n                perimeter += dfs(nr, nc)\n\n        return perimeter\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                return dfs(r, c)\n    return 0\n\n\ndef islandPerimeter(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    perimeter = 0\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                perimeter += 4\n\n                if r &gt; 0 and grid[r - 1][c] == 1:\n                    perimeter -= 2\n\n                if c &gt; 0 and grid[r][c - 1] == 1:\n                    perimeter -= 2\n\n    return perimeter\n\n\ngrid = [[0, 1, 0, 0], [1, 1, 1, 0], [0, 1, 0, 0], [1, 1, 0, 0]]\nprint(islandPerimeterDFS(grid))  # 16\nprint(islandPerimeter(grid))  # 16\n</code></pre>"},{"location":"endlesscheng/grid_dfs/#2658-maximum-number-of-fish-in-a-grid","title":"2658. Maximum Number of Fish in a Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix</p> </li> </ul> 2658. Maximum Number of Fish in a Grid - Python Solution<pre><code>from typing import List\n\n\n# Grid DFS\ndef findMaxFish(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    res = 0\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] == 0:\n            return 0\n        val = grid[r][c]\n        grid[r][c] = 0\n\n        return (\n            val + dfs(r - 1, c) + dfs(r + 1, c) + dfs(r, c - 1) + dfs(r, c + 1)\n        )\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 0:\n                res = max(res, dfs(i, j))\n\n    return res\n\n\ngrid = [[0, 2, 1, 0], [4, 0, 0, 3], [1, 0, 0, 4], [0, 3, 2, 0]]\nprint(findMaxFish(grid))  # 7\n</code></pre>"},{"location":"endlesscheng/grid_dfs/#1034-coloring-a-border","title":"1034. Coloring A Border","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, matrix</p> </li> </ul> 1034. Coloring A Border - Python Solution<pre><code>from typing import List\n\n\n# Grid DFS\ndef colorBorder(\n    grid: List[List[int]], row: int, col: int, color: int\n) -&gt; List[List[int]]:\n\n    dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]]\n    m, n = len(grid), len(grid[0])\n    org = grid[row][col]\n    visited = set()\n    borders = set()\n\n    def dfs(r, c):\n        if (r, c) in visited:\n            return\n\n        visited.add((r, c))\n\n        is_border = False\n        for dr, dc in dirs:\n            nr, nc = dr + r, dc + c\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n:\n                if grid[nr][nc] == org:\n                    dfs(nr, nc)\n                elif (nr, nc) not in visited:\n                    is_border = True\n            else:\n                is_border = True\n\n        if is_border:\n            borders.add((r, c))\n\n    dfs(row, col)\n\n    for r, c in borders:\n        grid[r][c] = color\n\n    return grid\n\n\ngrid = [[1, 2, 2], [2, 3, 2]]\nrow = 0\ncol = 1\ncolor = 3\nprint(colorBorder(grid, row, col, color))  # [[1, 3, 3], [2, 3, 3]]\n</code></pre>"},{"location":"endlesscheng/grid_dfs/#1020-number-of-enclaves","title":"1020. Number of Enclaves","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix</p> </li> </ul> 1020. Number of Enclaves - Python Solution<pre><code>from typing import List\n\n\n# DFS\ndef numEnclaves(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    visited = set()\n\n    def dfs(r, c):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or grid[r][c] == 0\n            or (r, c) in visited\n        ):\n            return\n\n        grid[r][c] = 0\n        visited.add((r, c))\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if (\n                (r in [0, m - 1] or c in [0, n - 1])\n                and grid[r][c] == 1\n                and (r, c) not in visited\n            ):\n                dfs(r, c)\n\n    count = 0\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1 and (r, c) not in visited:\n                count += 1\n\n    return count\n\n\ngrid = [[0, 0, 0, 0], [1, 0, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0]]\nprint(numEnclaves(grid))  # 3\n</code></pre>"},{"location":"endlesscheng/grid_dfs/#2684-maximum-number-of-moves-in-a-grid","title":"2684. Maximum Number of Moves in a Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, matrix</p> </li> </ul>"},{"location":"endlesscheng/grid_dfs/#1254-number-of-closed-islands","title":"1254. Number of Closed Islands","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix</p> </li> </ul> 1254. Number of Closed Islands - Python Solution<pre><code>from typing import List\n\n\n# DFS\ndef closedIsland(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    visited = set()\n\n    def dfs(r, c):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or grid[r][c] == 1\n            or (r, c) in visited\n        ):\n            return\n\n        grid[r][c] = 1\n        visited.add((r, c))\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if (\n                (r in [0, m - 1] or c in [0, n - 1])\n                and grid[r][c] == 0\n                and (r, c) not in visited\n            ):\n                dfs(r, c)\n\n    island = 0\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 0 and (r, c) not in visited:\n                island += 1\n                dfs(r, c)\n\n    return island\n\n\ngrid = [\n    [1, 1, 1, 1, 1, 1, 1, 0],\n    [1, 0, 0, 0, 0, 1, 1, 0],\n    [1, 0, 1, 0, 1, 1, 1, 0],\n    [1, 0, 0, 0, 0, 1, 0, 1],\n    [1, 1, 1, 1, 1, 1, 1, 0],\n]\nprint(closedIsland(grid))  # 2\n</code></pre>"},{"location":"endlesscheng/grid_dfs/#130-surrounded-regions","title":"130. Surrounded Regions","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix</p> </li> </ul> 130. Surrounded Regions - Python Solution<pre><code>from collections import deque\nfrom copy import deepcopy\nfrom pprint import pprint\nfrom typing import List\n\n\n# 1. DFS\ndef solveDFS(board: List[List[str]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n    if not board and not board[0]:\n        return None\n\n    m, n = len(board), len(board[0])\n\n    def capture(r, c):\n        if r not in range(m) or c not in range(n) or board[r][c] != \"O\":\n            return None\n\n        board[r][c] = \"T\"\n        capture(r + 1, c)\n        capture(r - 1, c)\n        capture(r, c + 1)\n        capture(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\" and (r in [0, m - 1] or c in [0, n - 1]):\n                capture(r, c)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\":\n                board[r][c] = \"X\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"T\":\n                board[r][c] = \"O\"\n\n\n# 2. BFS\ndef solveBFS(board: List[List[str]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n    if not board and not board[0]:\n        return None\n\n    m, n = len(board), len(board[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def capture(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr = row + dr\n                nc = col + dc\n                if nr in range(m) and nc in range(n) and board[nr][nc] == \"O\":\n                    q.append((nr, nc))\n                    board[nr][nc] = \"T\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\" and (r in [0, m - 1] or c in [0, n - 1]):\n                board[r][c] = \"T\"\n                capture(r, c)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\":\n                board[r][c] = \"X\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"T\":\n                board[r][c] = \"O\"\n\n\nboard = [\n    [\"X\", \"X\", \"X\", \"X\"],\n    [\"X\", \"O\", \"O\", \"X\"],\n    [\"X\", \"X\", \"O\", \"X\"],\n    [\"X\", \"O\", \"X\", \"X\"],\n]\nboard1 = deepcopy(board)\nsolveDFS(board1)\npprint(board1)\n# [['X', 'X', 'X', 'X'],\n#  ['X', 'X', 'X', 'X'],\n#  ['X', 'X', 'X', 'X'],\n#  ['X', 'O', 'X', 'X']]\n\nboard2 = deepcopy(board)\nsolveBFS(board2)\npprint(board2)\n# [['X', 'X', 'X', 'X'],\n#  ['X', 'X', 'X', 'X'],\n#  ['X', 'X', 'X', 'X'],\n#  ['X', 'O', 'X', 'X']]\n</code></pre>"},{"location":"endlesscheng/grid_dfs/#1905-count-sub-islands","title":"1905. Count Sub Islands","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix</p> </li> </ul>"},{"location":"endlesscheng/grid_dfs/#1391-check-if-there-is-a-valid-path-in-a-grid","title":"1391. Check if There is a Valid Path in a Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix</p> </li> </ul>"},{"location":"endlesscheng/grid_dfs/#417-pacific-atlantic-water-flow","title":"417. Pacific Atlantic Water Flow","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, matrix</p> </li> </ul> 417. Pacific Atlantic Water Flow - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef pacificAtlanticDFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(r, c, visited, prev_height):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or heights[r][c] &lt; prev_height\n            or (r, c) in visited\n        ):\n            return None\n\n        visited.add((r, c))\n        height = heights[r][c]\n        for dr, dc in directions:\n            dfs(dr + r, dc + c, visited, height)\n\n    for c in range(n):\n        dfs(0, c, pac, heights[0][c])\n        dfs(m - 1, c, atl, heights[m - 1][c])\n\n    for r in range(m):\n        dfs(r, 0, pac, heights[r][0])\n        dfs(r, n - 1, atl, heights[r][n - 1])\n\n    return list(pac &amp; atl)\n\n\n# BFS\ndef pacificAtlanticBFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def bfs(r, c, visited):\n        q = deque([(r, c)])\n        visited.add((r, c))\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr in range(m)\n                    and nc in range(n)\n                    and heights[row][col] &lt;= heights[nr][nc]\n                    and (nr, nc) not in visited\n                ):\n                    q.append((nr, nc))\n                    visited.add((nr, nc))\n\n    for c in range(n):\n        bfs(0, c, pac)  # top\n        bfs(m - 1, c, atl)  # bottom\n\n    for r in range(m):\n        bfs(r, 0, pac)  # left\n        bfs(r, n - 1, atl)  # right\n\n    return list(pac &amp; atl)\n\n\nheights = [\n    [1, 2, 2, 3, 5],\n    [3, 2, 3, 4, 4],\n    [2, 4, 5, 3, 1],\n    [6, 7, 1, 4, 5],\n    [5, 1, 1, 2, 4],\n]\nprint(pacificAtlanticDFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\nprint(pacificAtlanticBFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\n</code></pre>"},{"location":"endlesscheng/grid_dfs/#529-minesweeper","title":"529. Minesweeper","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, matrix</p> </li> </ul>"},{"location":"endlesscheng/grid_dfs/#1559-detect-cycles-in-2d-grid","title":"1559. Detect Cycles in 2D Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix</p> </li> </ul>"},{"location":"endlesscheng/grid_dfs/#827-making-a-large-island","title":"827. Making A Large Island","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix</p> </li> </ul> 827. Making A Large Island - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Flood Fill\ndef largestIsland(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    areas = defaultdict(int)  # {index: area}\n    index = 2\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(r, c, index):\n        area = 1\n        grid[r][c] = index\n        for dr, dc in dirs:\n            nr, nc = r + dr, c + dc\n            if 0 &lt;= nr &lt; n and 0 &lt;= nc &lt; n and grid[nr][nc] == 1:\n                area += dfs(nr, nc, index)\n        return area\n\n    for r in range(n):\n        for c in range(n):\n            if grid[r][c] == 1:\n                areas[index] = dfs(r, c, index)\n                index += 1\n\n    if not areas:\n        return 1\n\n    res = max(areas.values())\n\n    for r in range(n):\n        for c in range(n):\n            if grid[r][c] == 0:\n                connected = set()\n                area = 1\n                for dr, dc in dirs:\n                    nr, nc = r + dr, c + dc\n                    if 0 &lt;= nr &lt; n and 0 &lt;= nc &lt; n and grid[nr][nc] &gt; 1:\n                        connected.add(grid[nr][nc])\n\n                for island in connected:\n                    area += areas[island]\n                res = max(res, area)\n\n    return res\n\n\ngrid = [[1, 0], [0, 1]]\nprint(largestIsland(grid))  # 3\n</code></pre>"},{"location":"endlesscheng/grid_dfs/#305-number-of-islands-ii","title":"305. Number of Islands II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, union find</p> </li> </ul> 305. Number of Islands II - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef numIslands2(m: int, n: int, positions: List[List[int]]) -&gt; List[int]:\n    parent = defaultdict(tuple)\n    islands = 0\n    result = []\n    visited = set()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def find(node):\n        p = parent[node]\n        while parent[p] != p:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            parent[p1] = p2\n            return True\n        return False\n\n    for r, c in positions:\n        if (r, c) in visited:\n            result.append(islands)\n            continue\n\n        islands += 1\n        parent[(r, c)] = (r, c)\n        visited.add((r, c))\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if (nr, nc) in visited:\n                if union((r, c), (nr, nc)):\n                    islands -= 1\n\n        result.append(islands)\n\n    return result\n\n\nm = 3\nn = 3\npositions = [[0, 0], [0, 1], [1, 2], [2, 1]]\nprint(numIslands2(m, n, positions))  # [1, 1, 2, 3]\n</code></pre>"},{"location":"endlesscheng/grid_dfs/#2061-number-of-spaces-cleaning-robot-cleaned","title":"2061. Number of Spaces Cleaning Robot Cleaned","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, matrix, simulation</p> </li> </ul>"},{"location":"endlesscheng/grid_dfs/#2852-sum-of-remoteness-of-all-cells","title":"2852. Sum of Remoteness of All Cells","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, depth first search, breadth first search, union find, matrix</p> </li> </ul>"},{"location":"endlesscheng/grid_dfs/#489-robot-room-cleaner","title":"489. Robot Room Cleaner","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: backtracking, interactive</p> </li> </ul>"},{"location":"endlesscheng/grouped_loop/","title":"Grouped Loop","text":"<ul> <li> 1446. Consecutive Characters (Easy)</li> <li> 1869. Longer Contiguous Segments of Ones than Zeros (Easy)</li> <li> 2414. Length of the Longest Alphabetical Continuous Substring (Medium)</li> <li> 3456. Find Special Substring of Length K (Easy)</li> <li> 1957. Delete Characters to Make Fancy String (Easy)</li> <li> 674. Longest Continuous Increasing Subsequence (Easy)</li> <li> 978. Longest Turbulent Subarray (Medium)</li> <li> 2110. Number of Smooth Descent Periods of a Stock (Medium)</li> <li> 228. Summary Ranges (Easy)</li> <li> 2760. Longest Even Odd Subarray With Threshold (Easy)</li> <li> 1887. Reduction Operations to Make the Array Elements Equal (Medium)</li> <li> 845. Longest Mountain in Array (Medium)</li> <li> 2038. Remove Colored Pieces if Both Neighbors are the Same Color (Medium)</li> <li> 1759. Count Number of Homogenous Substrings (Medium)</li> <li> 3011. Find if Array Can Be Sorted (Medium)</li> <li> 1578. Minimum Time to Make Rope Colorful (Medium)</li> <li> 1839. Longest Substring Of All Vowels in Order (Medium)</li> <li> 2765. Longest Alternating Subarray (Easy)</li> <li> 3255. Find the Power of K-Size Subarrays II (Medium)</li> <li> 3350. Adjacent Increasing Subarrays Detection II (Medium)</li> <li> 3105. Longest Strictly Increasing or Strictly Decreasing Subarray (Easy)</li> <li> 467. Unique Substrings in Wraparound String (Medium)</li> <li> 2948. Make Lexicographically Smallest Array by Swapping Elements (Medium)</li> <li> 2593. Find Score of an Array After Marking All Elements (Medium)</li> <li> 2393. Count Strictly Increasing Subarrays (Medium)</li> <li> 2436. Minimum Split Into Subarrays With GCD Greater Than One (Medium)</li> <li> 2495. Number of Subarrays Having Even Product (Medium)</li> <li> 3063. Linked List Frequency (Easy)</li> </ul>"},{"location":"endlesscheng/grouped_loop/#1446-consecutive-characters","title":"1446. Consecutive Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string</p> </li> </ul>"},{"location":"endlesscheng/grouped_loop/#1869-longer-contiguous-segments-of-ones-than-zeros","title":"1869. Longer Contiguous Segments of Ones than Zeros","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string</p> </li> </ul>"},{"location":"endlesscheng/grouped_loop/#2414-length-of-the-longest-alphabetical-continuous-substring","title":"2414. Length of the Longest Alphabetical Continuous Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string</p> </li> </ul>"},{"location":"endlesscheng/grouped_loop/#3456-find-special-substring-of-length-k","title":"3456. Find Special Substring of Length K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string</p> </li> </ul>"},{"location":"endlesscheng/grouped_loop/#1957-delete-characters-to-make-fancy-string","title":"1957. Delete Characters to Make Fancy String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string</p> </li> </ul>"},{"location":"endlesscheng/grouped_loop/#674-longest-continuous-increasing-subsequence","title":"674. Longest Continuous Increasing Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array</p> </li> </ul> 674. Longest Continuous Increasing Subsequence - Python Solution<pre><code>from typing import List\n\n\ndef findLengthOfLCIS(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return n\n\n    dp = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        if nums[i] &gt; nums[i - 1]:\n            dp[i] = dp[i - 1] + 1\n\n    return max(dp)\n\n\nprint(findLengthOfLCIS([1, 3, 5, 4, 7]))  # 3\n</code></pre>"},{"location":"endlesscheng/grouped_loop/#978-longest-turbulent-subarray","title":"978. Longest Turbulent Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, sliding window</p> </li> </ul> 978. Longest Turbulent Subarray - Python Solution<pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxTurbulenceSize(arr: List[int]) -&gt; int:\n    n = len(arr)\n    up = [1 for _ in range(n)]\n    down = [1 for _ in range(n)]\n    maxLen = 1\n\n    for i in range(1, n):\n        if arr[i - 1] &lt; arr[i]:\n            up[i] = down[i - 1] + 1\n            down[i] = 1\n        elif arr[i - 1] &gt; arr[i]:\n            down[i] = up[i - 1] + 1\n            up[i] = 1\n        else:\n            up[i] = 1\n            down[i] = 1\n\n        maxLen = max(maxLen, up[i], down[i])\n\n    return maxLen\n\n\narr = [9, 4, 2, 10, 7, 8, 8, 1, 9]\nprint(maxTurbulenceSize(arr))  # 5\n</code></pre>"},{"location":"endlesscheng/grouped_loop/#2110-number-of-smooth-descent-periods-of-a-stock","title":"2110. Number of Smooth Descent Periods of a Stock","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, dynamic programming</p> </li> </ul>"},{"location":"endlesscheng/grouped_loop/#228-summary-ranges","title":"228. Summary Ranges","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array</p> </li> </ul>"},{"location":"endlesscheng/grouped_loop/#2760-longest-even-odd-subarray-with-threshold","title":"2760. Longest Even Odd Subarray With Threshold","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, sliding window</p> </li> </ul>"},{"location":"endlesscheng/grouped_loop/#1887-reduction-operations-to-make-the-array-elements-equal","title":"1887. Reduction Operations to Make the Array Elements Equal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sorting</p> </li> </ul>"},{"location":"endlesscheng/grouped_loop/#845-longest-mountain-in-array","title":"845. Longest Mountain in Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, dynamic programming, enumeration</p> </li> </ul> 845. Longest Mountain in Array - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef longestMountain(arr: List[int]) -&gt; int:\n    n = len(arr)\n    res = 0\n    left = 0\n\n    while left &lt; n:\n        right = left\n\n        if right &lt; n - 1 and arr[right] &lt; arr[right + 1]:\n            while right &lt; n - 1 and arr[right] &lt; arr[right + 1]:\n                right += 1\n\n            if right &lt; n - 1 and arr[right] &gt; arr[right + 1]:\n                while right &lt; n - 1 and arr[right] &gt; arr[right + 1]:\n                    right += 1\n                res = max(res, right - left + 1)\n\n        left = max(right, left + 1)\n\n    return res\n\n\narr = [2, 1, 4, 7, 3, 2, 5]\nprint(longestMountain(arr))  # 5\n</code></pre>"},{"location":"endlesscheng/grouped_loop/#2038-remove-colored-pieces-if-both-neighbors-are-the-same-color","title":"2038. Remove Colored Pieces if Both Neighbors are the Same Color","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, string, greedy, game theory</p> </li> </ul>"},{"location":"endlesscheng/grouped_loop/#1759-count-number-of-homogenous-substrings","title":"1759. Count Number of Homogenous Substrings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, string</p> </li> </ul>"},{"location":"endlesscheng/grouped_loop/#3011-find-if-array-can-be-sorted","title":"3011. Find if Array Can Be Sorted","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation, sorting</p> </li> </ul>"},{"location":"endlesscheng/grouped_loop/#1578-minimum-time-to-make-rope-colorful","title":"1578. Minimum Time to Make Rope Colorful","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, dynamic programming, greedy</p> </li> </ul>"},{"location":"endlesscheng/grouped_loop/#1839-longest-substring-of-all-vowels-in-order","title":"1839. Longest Substring Of All Vowels in Order","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, sliding window</p> </li> </ul>"},{"location":"endlesscheng/grouped_loop/#2765-longest-alternating-subarray","title":"2765. Longest Alternating Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, enumeration</p> </li> </ul>"},{"location":"endlesscheng/grouped_loop/#3255-find-the-power-of-k-size-subarrays-ii","title":"3255. Find the Power of K-Size Subarrays II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sliding window</p> </li> </ul>"},{"location":"endlesscheng/grouped_loop/#3350-adjacent-increasing-subarrays-detection-ii","title":"3350. Adjacent Increasing Subarrays Detection II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"endlesscheng/grouped_loop/#3105-longest-strictly-increasing-or-strictly-decreasing-subarray","title":"3105. Longest Strictly Increasing or Strictly Decreasing Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array</p> </li> </ul>"},{"location":"endlesscheng/grouped_loop/#467-unique-substrings-in-wraparound-string","title":"467. Unique Substrings in Wraparound String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul>"},{"location":"endlesscheng/grouped_loop/#2948-make-lexicographically-smallest-array-by-swapping-elements","title":"2948. Make Lexicographically Smallest Array by Swapping Elements","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, union find, sorting</p> </li> </ul>"},{"location":"endlesscheng/grouped_loop/#2593-find-score-of-an-array-after-marking-all-elements","title":"2593. Find Score of an Array After Marking All Elements","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, sorting, heap priority queue, simulation</p> </li> </ul>"},{"location":"endlesscheng/grouped_loop/#2393-count-strictly-increasing-subarrays","title":"2393. Count Strictly Increasing Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, dynamic programming</p> </li> </ul>"},{"location":"endlesscheng/grouped_loop/#2436-minimum-split-into-subarrays-with-gcd-greater-than-one","title":"2436. Minimum Split Into Subarrays With GCD Greater Than One","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, dynamic programming, greedy, number theory</p> </li> </ul>"},{"location":"endlesscheng/grouped_loop/#2495-number-of-subarrays-having-even-product","title":"2495. Number of Subarrays Having Even Product","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, dynamic programming</p> </li> </ul>"},{"location":"endlesscheng/grouped_loop/#3063-linked-list-frequency","title":"3063. Linked List Frequency","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, linked list, counting</p> </li> </ul>"},{"location":"endlesscheng/heap_advanced/","title":"Heap Advanced","text":"<ul> <li> 23. Merge k Sorted Lists (Hard)</li> <li> 355. Design Twitter (Medium)</li> <li> 502. IPO (Hard)</li> <li> 1705. Maximum Number of Eaten Apples (Medium)</li> <li> 778. Swim in Rising Water (Hard)</li> <li> 1631. Path With Minimum Effort (Medium)</li> <li> 1354. Construct Target Array With Multiple Sums (Hard)</li> <li> 1353. Maximum Number of Events That Can Be Attended (Medium)</li> <li> 1235. Maximum Profit in Job Scheduling (Hard)</li> <li> 632. Smallest Range Covering Elements from K Lists (Hard)</li> <li> 2542. Maximum Subsequence Score (Medium)</li> <li> 1383. Maximum Performance of a Team (Hard)</li> <li> 2503. Maximum Number of Points From Grid Queries (Hard)</li> <li> 2163. Minimum Difference in Sums After Removal of Elements (Hard)</li> <li> 857. Minimum Cost to Hire K Workers (Hard)</li> <li> 1606. Find Servers That Handled Most Number of Requests (Hard)</li> <li> 1851. Minimum Interval to Include Each Query (Hard)</li> <li> 218. The Skyline Problem (Hard)</li> <li> 407. Trapping Rain Water II (Hard)</li> <li> 2940. Find Building Where Alice and Bob Can Meet (Hard)</li> <li> 3399. Smallest Substring With Identical Characters II (Hard)</li> <li> 2589. Minimum Time to Complete All Tasks (Hard)</li> <li> 3266. Final Array State After K Multiplication Operations II (Hard)</li> <li> 1675. Minimize Deviation in Array (Hard)</li> <li> 2617. Minimum Number of Visited Cells in a Grid (Hard)</li> <li> 2532. Time to Cross a Bridge (Hard)</li> <li> 1199. Minimum Time to Build Blocks (Hard)</li> </ul>"},{"location":"endlesscheng/heap_advanced/#23-merge-k-sorted-lists","title":"23. Merge k Sorted Lists","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: linked list, divide and conquer, heap priority queue, merge sort</p> </li> <li>Prerequisite: 21. Merge Two Sorted Lists</li> </ul> 23. Merge k Sorted Lists - Python Solution<pre><code>import copy\nimport heapq\nfrom typing import List, Optional\n\nfrom template import ListNode\n\n\n# Divide and Conquer\ndef mergeKListsDC(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    if not lists or len(lists) == 0:\n        return None\n\n    def mergeTwo(l1, l2):\n        dummy = ListNode()\n        cur = dummy\n\n        while l1 and l2:\n            if l1.val &lt; l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n\n            cur = cur.next\n\n        cur.next = l1 if l1 else l2\n\n        return dummy.next\n\n    while len(lists) &gt; 1:\n        merged = []\n\n        for i in range(0, len(lists), 2):\n            l1 = lists[i]\n            l2 = lists[i + 1] if i + 1 &lt; len(lists) else None\n            merged.append(mergeTwo(l1, l2))\n\n        lists = merged\n\n    return lists[0]\n\n\n# Heap - Merge k Sorted\ndef mergeKLists(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    minHeap = []  # (val, idx, node)\n\n    for idx, head in enumerate(lists):\n        if head:\n            heapq.heappush(minHeap, (head.val, idx, head))\n\n    while minHeap:\n        _, idx, node = heapq.heappop(minHeap)\n        cur.next = node\n        cur = cur.next\n\n        node = node.next\n        if node:\n            heapq.heappush(minHeap, (node.val, idx, node))\n\n    return dummy.next\n\n\nn1 = ListNode.create([1, 4, 5])\nn2 = ListNode.create([1, 3, 4])\nn3 = ListNode.create([2, 6])\nlists = [n1, n2, n3]\nlists1 = copy.deepcopy(lists)\nlists2 = copy.deepcopy(lists)\nprint(mergeKListsDC(lists1))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6\nprint(mergeKLists(lists2))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6\n</code></pre>"},{"location":"endlesscheng/heap_advanced/#355-design-twitter","title":"355. Design Twitter","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, linked list, design, heap priority queue</p> </li> <li>Similar question: 23. Merge K Sorted Lists (Hard)</li> </ul> 355. Design Twitter - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Design\nclass Twitter:\n\n    def __init__(self):\n        self.tweets = defaultdict(list)\n        self.followees = defaultdict(set)\n        self.time = 0\n\n    def postTweet(self, userId: int, tweetId: int) -&gt; None:\n        self.tweets[userId].append((self.time, tweetId))\n        self.time += 1\n\n    def getNewsFeed(self, userId: int) -&gt; List[int]:\n        news_feed = []\n        news_feed.extend(self.tweets[userId])\n        for followee in self.followees[userId]:\n            news_feed.extend(self.tweets[followee])\n\n        return [tweet for _, tweet in heapq.nlargest(10, news_feed)]\n\n    def follow(self, followerId: int, followeeId: int) -&gt; None:\n        if followerId != followeeId:\n            self.followees[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -&gt; None:\n        if followerId != followeeId:\n            self.followees[followerId].discard(followeeId)\n\n\ntwitter = Twitter()\nprint(twitter.postTweet(1, 5))  # None\nprint(twitter.getNewsFeed(1))  # [5]\nprint(twitter.follow(1, 2))  # None\nprint(twitter.postTweet(2, 6))  # None\nprint(twitter.getNewsFeed(1))  # [6, 5]\nprint(twitter.unfollow(1, 2))  # None\nprint(twitter.getNewsFeed(1))  # [5]\n</code></pre>"},{"location":"endlesscheng/heap_advanced/#502-ipo","title":"502. IPO","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sorting, heap priority queue</p> </li> </ul> 502. IPO - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Heap - Two Heaps\ndef findMaximizedCapital(\n    k: int, w: int, profits: List[int], capital: List[int]\n) -&gt; int:\n    if not profits or not capital:\n        return w\n\n    minHeap = []\n    maxHeap = []\n\n    for i in range(len(profits)):\n        heapq.heappush(minHeap, (capital[i], profits[i]))\n\n    for _ in range(k):\n        while minHeap and minHeap[0][0] &lt;= w:\n            capital, profit = heapq.heappop(minHeap)\n            heapq.heappush(maxHeap, -profit)\n\n        if not maxHeap:\n            break\n\n        w += -heapq.heappop(maxHeap)\n\n    return w\n\n\nk = 2\nw = 0\nprofits = [1, 2, 3]\ncapital = [0, 1, 1]\nprint(findMaximizedCapital(k, w, profits, capital))  # 4\n</code></pre>"},{"location":"endlesscheng/heap_advanced/#1705-maximum-number-of-eaten-apples","title":"1705. Maximum Number of Eaten Apples","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/heap_advanced/#778-swim-in-rising-water","title":"778. Swim in Rising Water","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, depth first search, breadth first search, union find, heap priority queue, matrix</p> </li> <li>Return the minimum time when you can reach the target.</li> </ul> <p></p> 778. Swim in Rising Water - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra's\ndef swimInWater(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    visited = set()\n    minHeap = [(grid[0][0], 0, 0)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    visited.add((0, 0))\n\n    while minHeap:\n        time, r, c = heapq.heappop(minHeap)\n\n        if r == n - 1 and c == n - 1:\n            return time\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if nr in range(n) and nc in range(n) and (nr, nc) not in visited:\n                visited.add((nr, nc))\n                heapq.heappush(minHeap, (max(time, grid[nr][nc]), nr, nc))\n\n\ngrid = [\n    [0, 1, 2, 3, 4],\n    [24, 23, 22, 21, 5],\n    [12, 13, 14, 15, 16],\n    [11, 17, 18, 19, 20],\n    [10, 9, 8, 7, 6],\n]\nprint(swimInWater(grid))  # 16\n</code></pre>"},{"location":"endlesscheng/heap_advanced/#1631-path-with-minimum-effort","title":"1631. Path With Minimum Effort","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, depth first search, breadth first search, union find, heap priority queue, matrix</p> </li> <li>Return the minimum effort required to travel from the top-left to the bottom-right corner.</li> </ul> 1631. Path With Minimum Effort - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Prim\ndef minimumEffortPath(heights: List[List[int]]) -&gt; int:\n    m, n = len(heights), len(heights[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * n for _ in range(m)]\n    heap = [(0, 0, 0)]  # (effort, row, col)\n\n    while heap:\n        effort, r, c = heapq.heappop(heap)\n\n        if visited[r][c]:\n            continue\n\n        if r == m - 1 and c == n - 1:\n            return effort\n\n        visited[r][c] = True\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and not visited[nr][nc]:\n                updated = max(effort, abs(heights[r][c] - heights[nr][nc]))\n                heapq.heappush(heap, (updated, nr, nc))\n\n    return -1\n\n\nheights = [[1, 2, 2], [3, 8, 2], [5, 3, 5]]\nprint(minimumEffortPath(heights))  # 2\n</code></pre>"},{"location":"endlesscheng/heap_advanced/#1354-construct-target-array-with-multiple-sums","title":"1354. Construct Target Array With Multiple Sums","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/heap_advanced/#1353-maximum-number-of-events-that-can-be-attended","title":"1353. Maximum Number of Events That Can Be Attended","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/heap_advanced/#1235-maximum-profit-in-job-scheduling","title":"1235. Maximum Profit in Job Scheduling","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, dynamic programming, sorting</p> </li> </ul>"},{"location":"endlesscheng/heap_advanced/#632-smallest-range-covering-elements-from-k-lists","title":"632. Smallest Range Covering Elements from K Lists","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, greedy, sliding window, sorting, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/heap_advanced/#2542-maximum-subsequence-score","title":"2542. Maximum Subsequence Score","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/heap_advanced/#1383-maximum-performance-of-a-team","title":"1383. Maximum Performance of a Team","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sorting, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/heap_advanced/#2503-maximum-number-of-points-from-grid-queries","title":"2503. Maximum Number of Points From Grid Queries","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, breadth first search, union find, sorting, heap priority queue, matrix</p> </li> </ul>"},{"location":"endlesscheng/heap_advanced/#2163-minimum-difference-in-sums-after-removal-of-elements","title":"2163. Minimum Difference in Sums After Removal of Elements","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/heap_advanced/#857-minimum-cost-to-hire-k-workers","title":"857. Minimum Cost to Hire K Workers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sorting, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/heap_advanced/#1606-find-servers-that-handled-most-number-of-requests","title":"1606. Find Servers That Handled Most Number of Requests","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, heap priority queue, ordered set</p> </li> </ul>"},{"location":"endlesscheng/heap_advanced/#1851-minimum-interval-to-include-each-query","title":"1851. Minimum Interval to Include Each Query","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, line sweep, sorting, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/heap_advanced/#218-the-skyline-problem","title":"218. The Skyline Problem","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, divide and conquer, binary indexed tree, segment tree, line sweep, heap priority queue, ordered set</p> </li> </ul>"},{"location":"endlesscheng/heap_advanced/#407-trapping-rain-water-ii","title":"407. Trapping Rain Water II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, breadth first search, heap priority queue, matrix</p> </li> </ul>"},{"location":"endlesscheng/heap_advanced/#2940-find-building-where-alice-and-bob-can-meet","title":"2940. Find Building Where Alice and Bob Can Meet","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, stack, binary indexed tree, segment tree, heap priority queue, monotonic stack</p> </li> </ul>"},{"location":"endlesscheng/heap_advanced/#3399-smallest-substring-with-identical-characters-ii","title":"3399. Smallest Substring With Identical Characters II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, binary search</p> </li> </ul>"},{"location":"endlesscheng/heap_advanced/#2589-minimum-time-to-complete-all-tasks","title":"2589. Minimum Time to Complete All Tasks","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, stack, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/heap_advanced/#3266-final-array-state-after-k-multiplication-operations-ii","title":"3266. Final Array State After K Multiplication Operations II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, heap priority queue, simulation</p> </li> </ul>"},{"location":"endlesscheng/heap_advanced/#1675-minimize-deviation-in-array","title":"1675. Minimize Deviation in Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, heap priority queue, ordered set</p> </li> </ul>"},{"location":"endlesscheng/heap_advanced/#2617-minimum-number-of-visited-cells-in-a-grid","title":"2617. Minimum Number of Visited Cells in a Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, stack, breadth first search, union find, heap priority queue, matrix, monotonic stack</p> </li> </ul>"},{"location":"endlesscheng/heap_advanced/#2532-time-to-cross-a-bridge","title":"2532. Time to Cross a Bridge","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, heap priority queue, simulation</p> </li> </ul>"},{"location":"endlesscheng/heap_advanced/#1199-minimum-time-to-build-blocks","title":"1199. Minimum Time to Build Blocks","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, greedy, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/heap_basics/","title":"Heap Basics","text":"<ul> <li> 1046. Last Stone Weight (Easy)</li> <li> 3264. Final Array State After K Multiplication Operations I (Easy)</li> <li> 2558. Take Gifts From the Richest Pile (Easy)</li> <li> 2336. Smallest Number in Infinite Set (Medium)</li> <li> 2530. Maximal Score After Applying K Operations (Medium)</li> <li> 3066. Minimum Operations to Exceed Threshold Value II (Medium)</li> <li> 1962. Remove Stones to Minimize the Total (Medium)</li> <li> 703. Kth Largest Element in a Stream (Easy)</li> <li> 3275. K-th Nearest Obstacle Queries (Medium)</li> <li> 2208. Minimum Operations to Halve Array Sum (Medium)</li> <li> 2233. Maximum Product After K Increments (Medium)</li> <li> 3296. Minimum Number of Seconds to Make Mountain Height Zero (Medium)</li> <li> 1942. The Number of the Smallest Unoccupied Chair (Medium)</li> <li> 1801. Number of Orders in the Backlog (Medium)</li> <li> 2406. Divide Intervals Into Minimum Number of Groups (Medium)</li> <li> 2462. Total Cost to Hire K Workers (Medium)</li> <li> 1834. Single-Threaded CPU (Medium)</li> <li> 3408. Design Task Manager (Medium)</li> <li> 1792. Maximum Average Pass Ratio (Medium)</li> <li> 2931. Maximum Spending After Buying Items (Hard)</li> <li> 1882. Process Tasks Using Servers (Medium)</li> <li> 2402. Meeting Rooms III (Hard)</li> <li> 253. Meeting Rooms II (Medium)</li> <li> 1167. Minimum Cost to Connect Sticks (Medium)</li> </ul>"},{"location":"endlesscheng/heap_basics/#1046-last-stone-weight","title":"1046. Last Stone Weight","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, heap priority queue</p> </li> </ul> 1046. Last Stone Weight - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Heap\ndef lastStoneWeightHeap(stones: List[int]) -&gt; int:\n    heap = [-stone for stone in stones]\n    heapq.heapify(heap)\n\n    while len(heap) &gt; 1:\n        s1 = heapq.heappop(heap)\n        s2 = heapq.heappop(heap)\n\n        if s1 != s2:\n            heapq.heappush(heap, s1 - s2)\n\n    return -heap[0] if heap else 0\n\n\n# 0/1 Knapsack\ndef lastStoneWeightKnapsack(stones: List[int]) -&gt; int:\n    total = sum(stones)\n    target = total // 2\n\n    dp = [0 for _ in range(target + 1)]\n\n    for i in stones:\n        for j in range(target, i - 1, -1):\n            dp[j] = max(dp[j], dp[j - i] + i)\n\n    return total - 2 * dp[target]\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Heap     |   O(n log n)    |     O(n)     |\n# |  Knapsack   |      O(n)       |     O(n)     |\n# |-------------|-----------------|--------------|\n\n\nstones = [2, 7, 4, 1, 8, 1]\nprint(lastStoneWeightHeap(stones))  # 1\nprint(lastStoneWeightKnapsack(stones))  # 1\n</code></pre>"},{"location":"endlesscheng/heap_basics/#3264-final-array-state-after-k-multiplication-operations-i","title":"3264. Final Array State After K Multiplication Operations I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, math, heap priority queue, simulation</p> </li> </ul>"},{"location":"endlesscheng/heap_basics/#2558-take-gifts-from-the-richest-pile","title":"2558. Take Gifts From the Richest Pile","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, heap priority queue, simulation</p> </li> </ul>"},{"location":"endlesscheng/heap_basics/#2336-smallest-number-in-infinite-set","title":"2336. Smallest Number in Infinite Set","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, design, heap priority queue, ordered set</p> </li> </ul>"},{"location":"endlesscheng/heap_basics/#2530-maximal-score-after-applying-k-operations","title":"2530. Maximal Score After Applying K Operations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/heap_basics/#3066-minimum-operations-to-exceed-threshold-value-ii","title":"3066. Minimum Operations to Exceed Threshold Value II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, heap priority queue, simulation</p> </li> </ul>"},{"location":"endlesscheng/heap_basics/#1962-remove-stones-to-minimize-the-total","title":"1962. Remove Stones to Minimize the Total","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/heap_basics/#703-kth-largest-element-in-a-stream","title":"703. Kth Largest Element in a Stream","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, design, binary search tree, heap priority queue, binary tree, data stream</p> </li> </ul> 703. Kth Largest Element in a Stream - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Heap\nclass KthLargest:\n\n    def __init__(self, k: int, nums: List[int]):\n        self.k = k\n        self.heap = []\n        for num in nums:\n            self.add(num)\n\n    def add(self, val: int) -&gt; int:\n        heapq.heappush(self.heap, val)\n\n        if len(self.heap) &gt; self.k:\n            heapq.heappop(self.heap)\n\n        return self.heap[0]\n\n\nobj = KthLargest(3, [4, 5, 8, 2])\nprint(obj.add(3))  # 4\nprint(obj.add(5))  # 5\nprint(obj.add(10))  # 5\n</code></pre>"},{"location":"endlesscheng/heap_basics/#3275-k-th-nearest-obstacle-queries","title":"3275. K-th Nearest Obstacle Queries","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/heap_basics/#2208-minimum-operations-to-halve-array-sum","title":"2208. Minimum Operations to Halve Array Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/heap_basics/#2233-maximum-product-after-k-increments","title":"2233. Maximum Product After K Increments","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/heap_basics/#3296-minimum-number-of-seconds-to-make-mountain-height-zero","title":"3296. Minimum Number of Seconds to Make Mountain Height Zero","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, binary search, greedy, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/heap_basics/#1942-the-number-of-the-smallest-unoccupied-chair","title":"1942. The Number of the Smallest Unoccupied Chair","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/heap_basics/#1801-number-of-orders-in-the-backlog","title":"1801. Number of Orders in the Backlog","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, heap priority queue, simulation</p> </li> </ul>"},{"location":"endlesscheng/heap_basics/#2406-divide-intervals-into-minimum-number-of-groups","title":"2406. Divide Intervals Into Minimum Number of Groups","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy, sorting, heap priority queue, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/heap_basics/#2462-total-cost-to-hire-k-workers","title":"2462. Total Cost to Hire K Workers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, heap priority queue, simulation</p> </li> </ul>"},{"location":"endlesscheng/heap_basics/#1834-single-threaded-cpu","title":"1834. Single-Threaded CPU","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sorting, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/heap_basics/#3408-design-task-manager","title":"3408. Design Task Manager","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, design, heap priority queue, ordered set</p> </li> </ul>"},{"location":"endlesscheng/heap_basics/#1792-maximum-average-pass-ratio","title":"1792. Maximum Average Pass Ratio","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/heap_basics/#2931-maximum-spending-after-buying-items","title":"2931. Maximum Spending After Buying Items","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sorting, heap priority queue, matrix</p> </li> </ul>"},{"location":"endlesscheng/heap_basics/#1882-process-tasks-using-servers","title":"1882. Process Tasks Using Servers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/heap_basics/#2402-meeting-rooms-iii","title":"2402. Meeting Rooms III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, sorting, heap priority queue, simulation</p> </li> </ul>"},{"location":"endlesscheng/heap_basics/#253-meeting-rooms-ii","title":"253. Meeting Rooms II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy, sorting, heap priority queue, prefix sum</p> </li> </ul> 253. Meeting Rooms II - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Heap\ndef minMeetingRooms(intervals: List[List[int]]) -&gt; int:\n    if not intervals:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n    heap = [intervals[0][1]]\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &gt;= heap[0]:\n            heapq.heappop(heap)\n        heapq.heappush(heap, intervals[i][1])\n\n    return len(heap)\n\n\nintervals = [[0, 30], [5, 10], [15, 20]]\nprint(minMeetingRooms(intervals))  # 2\n</code></pre>"},{"location":"endlesscheng/heap_basics/#1167-minimum-cost-to-connect-sticks","title":"1167. Minimum Cost to Connect Sticks","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/heap_kth_smallest_largest/","title":"Heap Kth Smallest Largest","text":"<ul> <li> 264. Ugly Number II (Medium)</li> <li> 378. Kth Smallest Element in a Sorted Matrix (Medium)</li> <li> 373. Find K Pairs with Smallest Sums (Medium)</li> <li> 1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows (Hard)</li> <li> 786. K-th Smallest Prime Fraction (Medium)</li> <li> 2386. Find the K-Sum of an Array (Hard)</li> </ul>"},{"location":"endlesscheng/heap_kth_smallest_largest/#264-ugly-number-ii","title":"264. Ugly Number II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, math, dynamic programming, heap priority queue</p> </li> </ul> 264. Ugly Number II - Python Solution<pre><code>import heapq\n\n\ndef nthUglyNumber(n: int) -&gt; int:\n    heap = [1]\n    seen = set(heap)\n\n    factors = [2, 3, 5]\n    current = 1\n\n    # Pop the smallest ugly number n times\n    for _ in range(n):\n        current = heapq.heappop(heap)  # Pop the smallest ugly number\n\n        for factor in factors:\n            new = current * factor\n            if new not in seen:\n                seen.add(new)\n                heapq.heappush(heap, new)\n\n    return current\n\n\nprint(nthUglyNumber(10))  # 12\n</code></pre>"},{"location":"endlesscheng/heap_kth_smallest_largest/#378-kth-smallest-element-in-a-sorted-matrix","title":"378. Kth Smallest Element in a Sorted Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sorting, heap priority queue, matrix</p> </li> <li>Given an <code>n x n</code> matrix where each of the rows and columns are sorted in ascending order, return the <code>k-th</code> smallest element in the matrix.</li> </ul> 378. Kth Smallest Element in a Sorted Matrix - Python Solution<pre><code>from heapq import heapify, heappop, heappush\nfrom typing import List\n\n\n# Heap - Merge K Sorted\ndef kthSmallestHeap(matrix: List[List[int]], k: int) -&gt; int:\n    n = len(matrix)\n    heap = [(matrix[i][0], i, 0) for i in range(n)]\n    heapify(heap)\n\n    for _ in range(k - 1):\n        _, row, col = heappop(heap)\n\n        if col + 1 &lt; n:\n            heappush(heap, (matrix[row][col + 1], row, col + 1))\n\n    return heappop(heap)[0]\n\n\n# Binary Search\ndef kthSmallestBinarySearch(matrix: List[List[int]], k: int) -&gt; int:\n    n = len(matrix)\n\n    def check(mid):\n        i, j = n - 1, 0\n        num = 0\n\n        while i &gt;= 0 and j &lt; n:\n            if matrix[i][j] &lt;= mid:\n                num += i + 1\n                j += 1\n            else:\n                i -= 1\n\n        return num &gt;= k\n\n    left, right = matrix[0][0], matrix[-1][-1]\n\n    while left &lt; right:\n        mid = (left + right) // 2\n        if check(mid):\n            right = mid\n        else:\n            left = mid + 1\n\n    return left\n\n\nmatrix = [[1, 5, 9], [10, 11, 13], [12, 13, 15]]\nk = 8\n\nprint(kthSmallestHeap(matrix, k))  # 13\nprint(kthSmallestBinarySearch(matrix, k))  # 13\n</code></pre>"},{"location":"endlesscheng/heap_kth_smallest_largest/#373-find-k-pairs-with-smallest-sums","title":"373. Find K Pairs with Smallest Sums","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, heap priority queue</p> </li> </ul> 373. Find K Pairs with Smallest Sums - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Heap - Merge K Sorted\ndef kSmallestPairs(\n    nums1: List[int], nums2: List[int], k: int\n) -&gt; List[List[int]]:\n    if not nums1 or not nums2 or k &lt;= 0:\n        return []\n\n    result = []\n    min_heap = []\n\n    for j in range(min(k, len(nums2))):\n        heapq.heappush(min_heap, (nums1[0] + nums2[j], 0, j))\n\n    while k &gt; 0 and min_heap:\n        _, i, j = heapq.heappop(min_heap)\n        result.append([nums1[i], nums2[j]])\n        k -= 1\n\n        if i + 1 &lt; len(nums1):\n            heapq.heappush(min_heap, (nums1[i + 1] + nums2[j], i + 1, j))\n\n    return result\n\n\nnums1 = [1, 2, 4, 5, 6]\nnums2 = [3, 5, 7, 9]\nk = 3\nprint(kSmallestPairs(nums1, nums2, k))\n# [[1, 3], [2, 3], [1, 5]]\n</code></pre>"},{"location":"endlesscheng/heap_kth_smallest_largest/#1439-find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows","title":"1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, heap priority queue, matrix</p> </li> </ul>"},{"location":"endlesscheng/heap_kth_smallest_largest/#786-k-th-smallest-prime-fraction","title":"786. K-th Smallest Prime Fraction","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, sorting, heap priority queue</p> </li> </ul> 786. K-th Smallest Prime Fraction - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\ndef kthSmallestPrimeFraction(arr: List[int], k: int) -&gt; List[int]:\n    max_heap = []\n\n    for j in range(1, len(arr)):\n        for i in range(j):\n            heapq.heappush(max_heap, (-arr[i] / arr[j], arr[i], arr[j]))\n\n            if len(max_heap) &gt; k:\n                heapq.heappop(max_heap)\n\n    return [max_heap[0][1], max_heap[0][2]]\n\n\narr = [1, 2, 3, 5]\nk = 3\nprint(kthSmallestPrimeFraction(arr, k))  # [2, 5]\n</code></pre>"},{"location":"endlesscheng/heap_kth_smallest_largest/#2386-find-the-k-sum-of-an-array","title":"2386. Find the K-Sum of an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, sorting, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/heap_rearrange_elements/","title":"Heap Rearrange Elements","text":"<ul> <li> 984. String Without AAA or BBB (Medium)</li> <li> 767. Reorganize String (Medium)</li> <li> 1054. Distant Barcodes (Medium)</li> <li> 1953. Maximum Number of Weeks for Which You Can Work (Medium)</li> <li> 1405. Longest Happy String (Medium)</li> <li> 3081. Replace Question Marks in String to Minimize Its Value (Medium)</li> <li> 621. Task Scheduler (Medium)</li> <li> 358. Rearrange String k Distance Apart (Hard)</li> </ul>"},{"location":"endlesscheng/heap_rearrange_elements/#984-string-without-aaa-or-bbb","title":"984. String Without AAA or BBB","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, greedy</p> </li> </ul>"},{"location":"endlesscheng/heap_rearrange_elements/#767-reorganize-string","title":"767. Reorganize String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, greedy, sorting, heap priority queue, counting</p> </li> </ul> 767. Reorganize String - Python Solution<pre><code>import heapq\nfrom collections import Counter\n\n\ndef reorganizeString(s: str) -&gt; str:\n    if not s:\n        return \"\"\n\n    heap = [(-freq, char) for char, freq in Counter(s).items()]  # max heap\n    heapq.heapify(heap)\n\n    result = []\n    prev_count, prev_char = 0, \"\"\n\n    while heap:\n        count, char = heapq.heappop(heap)  # pop the most frequent character\n        result.append(char)  # append the character to the result\n\n        if (\n            prev_count &lt; 0\n        ):  # if the previous character still has remaining count\n            heapq.heappush(heap, (prev_count, prev_char))\n\n        prev_count = (\n            count + 1\n        )  # update the current character's remaining count\n        prev_char = char  # update the current character\n\n    # check if there is any invalid result\n    if len(result) != len(s):\n        return \"\"\n\n    return \"\".join(result)\n\n\nprint(reorganizeString(\"aab\"))\n</code></pre>"},{"location":"endlesscheng/heap_rearrange_elements/#1054-distant-barcodes","title":"1054. Distant Barcodes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, greedy, sorting, heap priority queue, counting</p> </li> </ul>"},{"location":"endlesscheng/heap_rearrange_elements/#1953-maximum-number-of-weeks-for-which-you-can-work","title":"1953. Maximum Number of Weeks for Which You Can Work","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy</p> </li> </ul>"},{"location":"endlesscheng/heap_rearrange_elements/#1405-longest-happy-string","title":"1405. Longest Happy String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, greedy, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/heap_rearrange_elements/#3081-replace-question-marks-in-string-to-minimize-its-value","title":"3081. Replace Question Marks in String to Minimize Its Value","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, greedy, sorting, heap priority queue, counting</p> </li> </ul>"},{"location":"endlesscheng/heap_rearrange_elements/#621-task-scheduler","title":"621. Task Scheduler","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, greedy, sorting, heap priority queue, counting</p> </li> </ul> 621. Task Scheduler - Python Solution<pre><code>import heapq\nfrom collections import Counter, deque\nfrom typing import List\n\n\n# Heap\ndef leastInterval1(tasks: List[str], n: int) -&gt; int:\n    count = Counter(tasks)\n    heap = [-c for c in count.values()]\n    heapq.heapify(heap)\n\n    time = 0\n\n    q = deque()\n\n    while heap or q:\n        time += 1\n\n        if heap:\n            cnt = 1 + heapq.heappop(heap)\n            if cnt:\n                q.append((cnt, time + n))\n\n        if q and q[0][1] == time:\n            heapq.heappush(heap, q.popleft()[0])\n\n    return time\n\n\ndef leastInterval2(tasks: List[str], n: int) -&gt; int:\n    freq = Counter(tasks)\n\n    maxExec = max(freq.values())\n    maxCount = sum(1 for v in freq.values() if v == maxExec)\n\n    return max((maxExec - 1) * (n + 1) + maxCount, len(tasks))\n\n\ntasks = [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\"]\nn = 2\nprint(leastInterval1(tasks, n))  # 8\nprint(leastInterval2(tasks, n))  # 8\n</code></pre>"},{"location":"endlesscheng/heap_rearrange_elements/#358-rearrange-string-k-distance-apart","title":"358. Rearrange String k Distance Apart","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, greedy, sorting, heap priority queue, counting</p> </li> </ul>"},{"location":"endlesscheng/house_robber/","title":"House Robber","text":"<ul> <li> 198. House Robber (Medium)</li> <li> 740. Delete and Earn (Medium)</li> <li> 2320. Count Number of Ways to Place Houses (Medium)</li> <li> 213. House Robber II (Medium)</li> <li> 3186. Maximum Total Damage With Spell Casting (Medium)</li> </ul>"},{"location":"endlesscheng/house_robber/#198-house-robber","title":"198. House Robber","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li> <p>Return the maximum amount of money that can be robbed from the houses. No two adjacent houses can be robbed.</p> </li> <li> <p><code>dp[n]</code> stores the maximum amount of money that can be robbed from the first <code>n</code> houses.</p> </li> <li>Formula: <code>dp[n] = max(dp[n - 1], dp[n - 2] + nums[n])</code>.<ul> <li>Skip: <code>dp[n]</code> \u2192 <code>dp[n - 1]</code></li> <li>Rob: <code>dp[n]</code> \u2192 <code>dp[n - 2] + nums[n]</code></li> </ul> </li> <li>Initialize <code>dp[0] = nums[0]</code> and <code>dp[1] = max(nums[0], nums[1])</code>.</li> <li>Return <code>dp[-1]</code>.</li> <li>Example: <code>nums = [2, 7, 9, 3, 1]</code></li> </ul> n <code>nums[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n-2] + nums[n]</code> <code>dp[n]</code> 0 2 - 2 - 2 1 7 - 7 - 7 2 9 2 7 11 11 3 3 7 11 10 11 4 1 11 11 12 12 198. House Robber - Python Solution<pre><code>from typing import List\n\n\n# DP (House Robber)\ndef rob1(nums: List[int]) -&gt; int:\n    if len(nums) &lt; 3:\n        return max(nums)\n\n    dp = [0 for _ in range(len(nums))]\n    dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n    for i in range(2, len(nums)):\n        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n    return dp[-1]\n\n\n# DP (House Robber) Optimized\ndef rob2(nums: List[int]) -&gt; int:\n    f0, f1 = 0, 0\n\n    for num in nums:\n        f0, f1 = f1, max(f1, f0 + num)\n\n    return f1\n\n\nnums = [2, 7, 9, 3, 1]\nprint(rob1(nums))  # 12\nprint(rob2(nums))  # 12\n</code></pre> 198. House Robber - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int rob(vector&lt;int&gt; &amp;nums)\n    {\n        int prev = 0, cur = 0;\n\n        for (int num : nums)\n        {\n            int temp = cur;\n            cur = max(cur, prev + num);\n            prev = temp;\n        }\n        return cur;\n    }\n};\n\nint main()\n{\n    vector&lt;int&gt; nums = {2, 7, 9, 3, 1};\n    Solution obj;\n    int result = obj.rob(nums);\n    cout &lt;&lt; result &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"endlesscheng/house_robber/#740-delete-and-earn","title":"740. Delete and Earn","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, dynamic programming</p> </li> </ul> 740. Delete and Earn - Python Solution<pre><code>from typing import List\n\n\n# DP (House Robber)\ndef deleteAndEarn(nums: List[int]) -&gt; int:\n    def rob(nums):\n        f0, f1 = 0, 0\n        for x in nums:\n            f0, f1 = f1, max(f1, f0 + x)\n        return f1\n\n    res = [0 for _ in range(max(nums) + 1)]\n\n    for x in nums:\n        res[x] += x\n\n    return rob(res)\n\n\nnums = [2, 2, 3, 3, 3, 4]\nprint(deleteAndEarn(nums))  # 9\n</code></pre>"},{"location":"endlesscheng/house_robber/#2320-count-number-of-ways-to-place-houses","title":"2320. Count Number of Ways to Place Houses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming</p> </li> </ul>"},{"location":"endlesscheng/house_robber/#213-house-robber-ii","title":"213. House Robber II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li>Return the maximum amount of money that can be robbed from the houses arranged in a circle.</li> <li>Circular \u2192 Linear: <code>nums[0]</code> and <code>nums[-1]</code> cannot be robbed together.</li> <li>Rob from <code>0</code> to <code>n - 2</code></li> </ul> n <code>nums[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n-2] + nums[n]</code> <code>dp[n]</code> 0 2 - 2 - 2 1 7 - 7 - 7 2 9 2 7 11 11 3 3 7 11 10 11 <ul> <li>Rob from <code>1</code> to <code>n - 1</code></li> </ul> n <code>nums[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n-2] + nums[n]</code> <code>dp[n]</code> 1 7 - - - 7 2 9 - 7 - 9 3 3 7 9 10 10 4 1 9 10 10 10 213. House Robber II - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef rob(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 3:\n        return max(nums)\n\n    def robLinear(nums: List[int]) -&gt; int:\n        dp = [0 for _ in range(len(nums))]\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n        return dp[-1]\n\n    # circle -&gt; linear\n    a = robLinear(nums[1:])  # 2nd house to the last house\n    b = robLinear(nums[:-1])  # 1st house to the 2nd last house\n\n    return max(a, b)\n\n\nnums = [2, 7, 9, 3, 1]\nprint(rob(nums))  # 11\n</code></pre>"},{"location":"endlesscheng/house_robber/#3186-maximum-total-damage-with-spell-casting","title":"3186. Maximum Total Damage With Spell Casting","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, two pointers, binary search, dynamic programming, sorting, counting</p> </li> </ul>"},{"location":"endlesscheng/inductive_method/","title":"Inductive Method","text":"<ul> <li> 2952. Minimum Number of Coins to be Added (Medium)</li> <li> 330. Patching Array (Hard)</li> <li> 1798. Maximum Number of Consecutive Values You Can Make (Medium)</li> </ul>"},{"location":"endlesscheng/inductive_method/#2952-minimum-number-of-coins-to-be-added","title":"2952. Minimum Number of Coins to be Added","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/inductive_method/#330-patching-array","title":"330. Patching Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy</p> </li> </ul>"},{"location":"endlesscheng/inductive_method/#1798-maximum-number-of-consecutive-values-you-can-make","title":"1798. Maximum Number of Consecutive Values You Can Make","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/interval_coverage/","title":"Interval Coverage","text":"<ul> <li> 45. Jump Game II (Medium)</li> <li> 1024. Video Stitching (Medium)</li> <li> 1326. Minimum Number of Taps to Open to Water a Garden (Hard)</li> </ul>"},{"location":"endlesscheng/interval_coverage/#45-jump-game-ii","title":"45. Jump Game II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> <li>Return the minimum number of jumps to reach the last index.</li> </ul> 45. Jump Game II - Python Solution<pre><code>from typing import List\n\n\n# Greedy - Interval\ndef jump(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if len(nums) == 1:\n        return 0\n\n    maxReach = 0\n    step = 0\n    left, right = 0, 0\n\n    while right &lt; n - 1:\n        for i in range(left, right + 1):\n            maxReach = max(maxReach, i + nums[i])\n        left = right + 1\n        right = maxReach\n        step += 1\n\n    return step\n\n\nprint(jump([2, 3, 1, 1, 4, 2, 1]))  # 3\n</code></pre>"},{"location":"endlesscheng/interval_coverage/#1024-video-stitching","title":"1024. Video Stitching","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> </ul>"},{"location":"endlesscheng/interval_coverage/#1326-minimum-number-of-taps-to-open-to-water-a-garden","title":"1326. Minimum Number of Taps to Open to Water a Garden","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> </ul>"},{"location":"endlesscheng/interval_grouping/","title":"Interval Grouping","text":"<ul> <li> 2406. Divide Intervals Into Minimum Number of Groups (Medium)</li> <li> 253. Meeting Rooms II (Medium)</li> </ul>"},{"location":"endlesscheng/interval_grouping/#2406-divide-intervals-into-minimum-number-of-groups","title":"2406. Divide Intervals Into Minimum Number of Groups","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy, sorting, heap priority queue, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/interval_grouping/#253-meeting-rooms-ii","title":"253. Meeting Rooms II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy, sorting, heap priority queue, prefix sum</p> </li> </ul> 253. Meeting Rooms II - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Heap\ndef minMeetingRooms(intervals: List[List[int]]) -&gt; int:\n    if not intervals:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n    heap = [intervals[0][1]]\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &gt;= heap[0]:\n            heapq.heappop(heap)\n        heapq.heappush(heap, intervals[i][1])\n\n    return len(heap)\n\n\nintervals = [[0, 30], [5, 10], [15, 20]]\nprint(minMeetingRooms(intervals))  # 2\n</code></pre>"},{"location":"endlesscheng/interval_selection/","title":"Interval Selection","text":"<ul> <li> 452. Minimum Number of Arrows to Burst Balloons (Medium)</li> <li> 757. Set Intersection Size At Least Two (Hard)</li> </ul>"},{"location":"endlesscheng/interval_selection/#452-minimum-number-of-arrows-to-burst-balloons","title":"452. Minimum Number of Arrows to Burst Balloons","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> <li>Return the minimum number of arrows.</li> </ul> <ul> <li>Differece between two versions<ol> <li>Start from 1: if there is no overlap, we add one more arrow.</li> <li>Start from the number of balloons: if there is overlap, we need to reduce one arrow.</li> </ol> </li> </ul> 452. Minimum Number of Arrows to Burst Balloons - Python Solution<pre><code>from typing import List\n\nimport matplotlib.pyplot as plt\n\n\n# Greedy - Interval\ndef findMinArrowShotsGreedy1(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    if n &lt;= 1:\n        return n\n\n    res = 1\n    points.sort(key=lambda x: x[0])\n\n    for i in range(1, n):\n        if points[i][0] &gt; points[i - 1][1]:\n            res += 1\n        else:\n            points[i][1] = min(points[i][1], points[i - 1][1])\n    return res\n\n\n# Greedy - Interval (Neetcode's version)\ndef findMinArrowShotsGreedy2(points: List[List[int]]) -&gt; int:\n    res = len(points)\n    if res == 0:\n        return 0\n\n    points.sort()\n    prev = points[0]\n\n    for i in range(1, len(points)):\n        cur = points[i]\n        if cur[0] &lt;= prev[1]:\n            res -= 1\n            prev = [cur[0], min(prev[1], cur[1])]\n        else:\n            prev = cur\n\n    return res\n\n\n# Greedy - Interval\ndef findMinArrowShotsGreedy3(points: List[List[int]]) -&gt; int:\n    if not points:\n        return 0\n\n    points.sort(key=lambda x: x[1])\n\n    res = 1\n    cur_end = points[0][1]\n\n    for i in range(1, len(points)):\n        if points[i][0] &gt; cur_end:\n            res += 1\n            cur_end = points[i][1]\n\n    return res\n\n\n# Utility\ndef plot(points, i=None):\n    plt.figure(figsize=(8, 4))\n    for idx in range(len(points)):\n        color = \"b\" if idx == i else \"k\"\n        plt.plot(\n            [points[idx][0], points[idx][1]],\n            [idx + 1, idx + 1],\n            f\"{color}o-\",\n            label=f\"Line {idx + 1}\",\n        )\n\n    plt.title(\"Find Min Arrow Shots\")\n    plt.xlabel(\"X-axis\")\n    plt.xlim(0, 17)\n    plt.grid(True)\n    plt.savefig(f\"find_min_arrow_shots_{i}.png\")\n    plt.show()\n\n\n# |------------|-----------|---------|\n# |  Approach  |  Time     |  Space  |\n# |------------|-----------|---------|\n# |  Greedy    |  O(NlogN) |  O(1)   |\n# |------------|-----------|---------|\n\n\npoints = [[10, 16], [2, 8], [1, 6], [7, 12]]\nprint(findMinArrowShotsGreedy1(points))  # 2\nprint(findMinArrowShotsGreedy2(points))  # 2\n</code></pre>"},{"location":"endlesscheng/interval_selection/#757-set-intersection-size-at-least-two","title":"757. Set Intersection Size At Least Two","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/inversion_count/","title":"Inversion Count","text":"<ul> <li> 315. Count of Smaller Numbers After Self (Hard)</li> <li> 493. Reverse Pairs (Hard)</li> <li> 327. Count of Range Sum (Hard)</li> <li> 2426. Number of Pairs Satisfying Inequality (Hard)</li> <li> 1850. Minimum Adjacent Swaps to Reach the Kth Smallest Number (Medium)</li> <li> 2193. Minimum Number of Moves to Make Palindrome (Hard)</li> <li> 1885. Count Pairs in Two Arrays (Medium)</li> </ul>"},{"location":"endlesscheng/inversion_count/#315-count-of-smaller-numbers-after-self","title":"315. Count of Smaller Numbers After Self","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, divide and conquer, binary indexed tree, segment tree, merge sort, ordered set</p> </li> </ul>"},{"location":"endlesscheng/inversion_count/#493-reverse-pairs","title":"493. Reverse Pairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, divide and conquer, binary indexed tree, segment tree, merge sort, ordered set</p> </li> </ul>"},{"location":"endlesscheng/inversion_count/#327-count-of-range-sum","title":"327. Count of Range Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, divide and conquer, binary indexed tree, segment tree, merge sort, ordered set</p> </li> </ul>"},{"location":"endlesscheng/inversion_count/#2426-number-of-pairs-satisfying-inequality","title":"2426. Number of Pairs Satisfying Inequality","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, divide and conquer, binary indexed tree, segment tree, merge sort, ordered set</p> </li> </ul>"},{"location":"endlesscheng/inversion_count/#1850-minimum-adjacent-swaps-to-reach-the-kth-smallest-number","title":"1850. Minimum Adjacent Swaps to Reach the Kth Smallest Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string, greedy</p> </li> </ul>"},{"location":"endlesscheng/inversion_count/#2193-minimum-number-of-moves-to-make-palindrome","title":"2193. Minimum Number of Moves to Make Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: two pointers, string, greedy, binary indexed tree</p> </li> </ul>"},{"location":"endlesscheng/inversion_count/#1885-count-pairs-in-two-arrays","title":"1885. Count Pairs in Two Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, sorting</p> </li> </ul>"},{"location":"endlesscheng/lazy_deletion_heap/","title":"Lazy Deletion Heap","text":"<ul> <li> 2349. Design a Number Container System (Medium)</li> <li> 2353. Design a Food Rating System (Medium)</li> <li> 3092. Most Frequent IDs (Medium)</li> <li> 2034. Stock Price Fluctuation  (Medium)</li> <li> 1172. Dinner Plate Stacks (Hard)</li> </ul>"},{"location":"endlesscheng/lazy_deletion_heap/#2349-design-a-number-container-system","title":"2349. Design a Number Container System","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, design, heap priority queue, ordered set</p> </li> </ul>"},{"location":"endlesscheng/lazy_deletion_heap/#2353-design-a-food-rating-system","title":"2353. Design a Food Rating System","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, design, heap priority queue, ordered set</p> </li> </ul>"},{"location":"endlesscheng/lazy_deletion_heap/#3092-most-frequent-ids","title":"3092. Most Frequent IDs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, heap priority queue, ordered set</p> </li> </ul>"},{"location":"endlesscheng/lazy_deletion_heap/#2034-stock-price-fluctuation","title":"2034. Stock Price Fluctuation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, design, heap priority queue, data stream, ordered set</p> </li> </ul>"},{"location":"endlesscheng/lazy_deletion_heap/#1172-dinner-plate-stacks","title":"1172. Dinner Plate Stacks","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, stack, design, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/lazy_segment_tree/","title":"Lazy Segment Tree","text":"<ul> <li> 2589. Minimum Time to Complete All Tasks (Hard)</li> <li> 2569. Handling Sum Queries After Update (Hard)</li> <li> 1622. Fancy Sequence (Hard)</li> <li> 850. Rectangle Area II (Hard)</li> <li> 3454. Separate Squares II (Hard)</li> <li> 2916. Subarrays Distinct Element Sum of Squares II (Hard)</li> </ul>"},{"location":"endlesscheng/lazy_segment_tree/#2589-minimum-time-to-complete-all-tasks","title":"2589. Minimum Time to Complete All Tasks","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, stack, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/lazy_segment_tree/#2569-handling-sum-queries-after-update","title":"2569. Handling Sum Queries After Update","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, segment tree</p> </li> </ul>"},{"location":"endlesscheng/lazy_segment_tree/#1622-fancy-sequence","title":"1622. Fancy Sequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, design, segment tree</p> </li> </ul>"},{"location":"endlesscheng/lazy_segment_tree/#850-rectangle-area-ii","title":"850. Rectangle Area II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, segment tree, line sweep, ordered set</p> </li> </ul>"},{"location":"endlesscheng/lazy_segment_tree/#3454-separate-squares-ii","title":"3454. Separate Squares II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, segment tree, line sweep</p> </li> </ul>"},{"location":"endlesscheng/lazy_segment_tree/#2916-subarrays-distinct-element-sum-of-squares-ii","title":"2916. Subarrays Distinct Element Sum of Squares II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, binary indexed tree, segment tree</p> </li> </ul>"},{"location":"endlesscheng/lexicographically_smallest/","title":"Lexicographically Smallest","text":"<ul> <li> 402. Remove K Digits (Medium)</li> <li> 1673. Find the Most Competitive Subsequence (Medium)</li> <li> 316. Remove Duplicate Letters (Medium)</li> <li> 1081. Smallest Subsequence of Distinct Characters (Medium)</li> <li> 321. Create Maximum Number (Hard)</li> <li> 2030. Smallest K-Length Subsequence With Occurrences of a Letter (Hard)</li> </ul>"},{"location":"endlesscheng/lexicographically_smallest/#402-remove-k-digits","title":"402. Remove K Digits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack, greedy, monotonic stack</p> </li> </ul>"},{"location":"endlesscheng/lexicographically_smallest/#1673-find-the-most-competitive-subsequence","title":"1673. Find the Most Competitive Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, greedy, monotonic stack</p> </li> </ul>"},{"location":"endlesscheng/lexicographically_smallest/#316-remove-duplicate-letters","title":"316. Remove Duplicate Letters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack, greedy, monotonic stack</p> </li> </ul> 316. Remove Duplicate Letters - Python Solution<pre><code># Monotonic Stack\ndef removeDuplicateLetters(s: str) -&gt; str:\n    stack = []\n    seen = set()\n    last = {c: i for i, c in enumerate(s)}\n\n    for i, c in enumerate(s):\n        if c not in seen:\n            while stack and c &lt; stack[-1] and i &lt; last[stack[-1]]:\n                seen.discard(stack.pop())\n            seen.add(c)\n            stack.append(c)\n\n    return \"\".join(stack)\n\n\ns = \"cbacdcbc\"\nprint(removeDuplicateLetters(s))  # acdb\n</code></pre>"},{"location":"endlesscheng/lexicographically_smallest/#1081-smallest-subsequence-of-distinct-characters","title":"1081. Smallest Subsequence of Distinct Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack, greedy, monotonic stack</p> </li> </ul>"},{"location":"endlesscheng/lexicographically_smallest/#321-create-maximum-number","title":"321. Create Maximum Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, stack, greedy, monotonic stack</p> </li> </ul>"},{"location":"endlesscheng/lexicographically_smallest/#2030-smallest-k-length-subsequence-with-occurrences-of-a-letter","title":"2030. Smallest K-Length Subsequence With Occurrences of a Letter","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, stack, greedy, monotonic stack</p> </li> </ul>"},{"location":"endlesscheng/lexicographically_smallest_largest/","title":"Lexicographically Smallest Largest","text":"<ul> <li> 1323. Maximum 69 Number (Easy)</li> <li> 3216. Lexicographically Smallest String After a Swap (Easy)</li> <li> 2697. Lexicographically Smallest Palindrome (Easy)</li> <li> 1881. Maximum Value after Insertion (Medium)</li> <li> 2734. Lexicographically Smallest String After Substring Operation (Medium)</li> <li> 1946. Largest Number After Mutating Substring (Medium)</li> <li> 1663. Smallest String With A Given Numeric Value (Medium)</li> <li> 1328. Break a Palindrome (Medium)</li> <li> 2259. Remove Digit From Number to Maximize Result (Easy)</li> <li> 2566. Maximum Difference by Remapping a Digit (Easy)</li> <li> 670. Maximum Swap (Medium)</li> <li> 3106. Lexicographically Smallest String After Operations With Constraint (Medium)</li> <li> 1053. Previous Permutation With One Swap (Medium)</li> <li> 2375. Construct Smallest Number From DI String (Medium)</li> <li> 2182. Construct String With Repeat Limit (Medium)</li> <li> 738. Monotone Increasing Digits (Medium)</li> <li> 3403. Find the Lexicographically Largest String From the Box I (Medium)</li> <li> 3170. Lexicographically Minimum String After Removing Stars (Medium)</li> <li> 1363. Largest Multiple of Three (Hard)</li> <li> 1754. Largest Merge Of Two Strings (Medium)</li> <li> 1202. Smallest String With Swaps (Medium)</li> <li> 2434. Using a Robot to Print the Lexicographically Smallest String (Medium)</li> <li> 1625. Lexicographically Smallest String After Applying Operations (Medium)</li> <li> 2948. Make Lexicographically Smallest Array by Swapping Elements (Medium)</li> <li> 564. Find the Closest Palindrome (Hard)</li> <li> 1505. Minimum Possible Integer After at Most K Adjacent Swaps On Digits (Hard)</li> <li> 2663. Lexicographically Smallest Beautiful String (Hard)</li> <li> 3302. Find the Lexicographically Smallest Valid Sequence (Medium)</li> <li> 555. Split Concatenated Strings (Medium)</li> <li> 3088. Make String Anti-palindrome (Hard)</li> </ul>"},{"location":"endlesscheng/lexicographically_smallest_largest/#1323-maximum-69-number","title":"1323. Maximum 69 Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, greedy</p> </li> </ul>"},{"location":"endlesscheng/lexicographically_smallest_largest/#3216-lexicographically-smallest-string-after-a-swap","title":"3216. Lexicographically Smallest String After a Swap","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, greedy</p> </li> </ul>"},{"location":"endlesscheng/lexicographically_smallest_largest/#2697-lexicographically-smallest-palindrome","title":"2697. Lexicographically Smallest Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string, greedy</p> </li> </ul>"},{"location":"endlesscheng/lexicographically_smallest_largest/#1881-maximum-value-after-insertion","title":"1881. Maximum Value after Insertion","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, greedy</p> </li> </ul>"},{"location":"endlesscheng/lexicographically_smallest_largest/#2734-lexicographically-smallest-string-after-substring-operation","title":"2734. Lexicographically Smallest String After Substring Operation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, greedy</p> </li> </ul>"},{"location":"endlesscheng/lexicographically_smallest_largest/#1946-largest-number-after-mutating-substring","title":"1946. Largest Number After Mutating Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, greedy</p> </li> </ul>"},{"location":"endlesscheng/lexicographically_smallest_largest/#1663-smallest-string-with-a-given-numeric-value","title":"1663. Smallest String With A Given Numeric Value","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, greedy</p> </li> </ul>"},{"location":"endlesscheng/lexicographically_smallest_largest/#1328-break-a-palindrome","title":"1328. Break a Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, greedy</p> </li> </ul>"},{"location":"endlesscheng/lexicographically_smallest_largest/#2259-remove-digit-from-number-to-maximize-result","title":"2259. Remove Digit From Number to Maximize Result","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, greedy, enumeration</p> </li> </ul>"},{"location":"endlesscheng/lexicographically_smallest_largest/#2566-maximum-difference-by-remapping-a-digit","title":"2566. Maximum Difference by Remapping a Digit","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, greedy</p> </li> </ul>"},{"location":"endlesscheng/lexicographically_smallest_largest/#670-maximum-swap","title":"670. Maximum Swap","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, greedy</p> </li> </ul>"},{"location":"endlesscheng/lexicographically_smallest_largest/#3106-lexicographically-smallest-string-after-operations-with-constraint","title":"3106. Lexicographically Smallest String After Operations With Constraint","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, greedy</p> </li> </ul>"},{"location":"endlesscheng/lexicographically_smallest_largest/#1053-previous-permutation-with-one-swap","title":"1053. Previous Permutation With One Swap","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy</p> </li> </ul>"},{"location":"endlesscheng/lexicographically_smallest_largest/#2375-construct-smallest-number-from-di-string","title":"2375. Construct Smallest Number From DI String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, backtracking, stack, greedy</p> </li> </ul>"},{"location":"endlesscheng/lexicographically_smallest_largest/#2182-construct-string-with-repeat-limit","title":"2182. Construct String With Repeat Limit","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, greedy, heap priority queue, counting</p> </li> </ul>"},{"location":"endlesscheng/lexicographically_smallest_largest/#738-monotone-increasing-digits","title":"738. Monotone Increasing Digits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, greedy</p> </li> <li>Return the largest number that is less than or equal to <code>n</code> with monotone increasing digits.</li> </ul> 738. Monotone Increasing Digits - Python Solution<pre><code># Greedy\ndef monotoneIncreasingDigits(n: int) -&gt; int:\n    strNum = list(str(n))\n\n    for i in range(len(strNum) - 2, -1, -1):\n        if int(strNum[i]) &gt; int(strNum[i + 1]):\n            strNum[i] = str(int(strNum[i]) - 1)\n            strNum[i + 1 :] = [\"9\"] * (len(strNum) - (i + 1))\n\n    return int(\"\".join(strNum))\n\n\nn = 332\nprint(monotoneIncreasingDigits(n))  # 299\n</code></pre>"},{"location":"endlesscheng/lexicographically_smallest_largest/#3403-find-the-lexicographically-largest-string-from-the-box-i","title":"3403. Find the Lexicographically Largest String From the Box I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string, enumeration</p> </li> </ul>"},{"location":"endlesscheng/lexicographically_smallest_largest/#3170-lexicographically-minimum-string-after-removing-stars","title":"3170. Lexicographically Minimum String After Removing Stars","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, stack, greedy, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/lexicographically_smallest_largest/#1363-largest-multiple-of-three","title":"1363. Largest Multiple of Three","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> </ul>"},{"location":"endlesscheng/lexicographically_smallest_largest/#1754-largest-merge-of-two-strings","title":"1754. Largest Merge Of Two Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string, greedy</p> </li> </ul>"},{"location":"endlesscheng/lexicographically_smallest_largest/#1202-smallest-string-with-swaps","title":"1202. Smallest String With Swaps","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, depth first search, breadth first search, union find, sorting</p> </li> </ul> 1202. Smallest String With Swaps - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef smallestStringWithSwaps(s: str, pairs: List[List[int]]) -&gt; str:\n    n = len(s)\n    par = list(range(n))\n    components = defaultdict(list)\n\n    def find(node):\n        p = par[node]\n        while par[p] != p:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 != p2:\n            par[p1] = p2\n\n    for index, j in pairs:\n        union(index, j)\n\n    for index in range(n):\n        components[find(index)].append(index)\n\n    res = list(s)\n    for indices in components.values():\n        chars = sorted([s[index] for index in indices])\n        for index, char in zip(indices, chars):\n            res[index] = char\n\n    return \"\".join(res)\n\n\ns = \"dcab\"\npairs = [[0, 3], [1, 2]]\nprint(smallestStringWithSwaps(s, pairs))  # \"bacd\"\n</code></pre>"},{"location":"endlesscheng/lexicographically_smallest_largest/#2434-using-a-robot-to-print-the-lexicographically-smallest-string","title":"2434. Using a Robot to Print the Lexicographically Smallest String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, stack, greedy</p> </li> </ul>"},{"location":"endlesscheng/lexicographically_smallest_largest/#1625-lexicographically-smallest-string-after-applying-operations","title":"1625. Lexicographically Smallest String After Applying Operations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, depth first search, breadth first search, enumeration</p> </li> </ul>"},{"location":"endlesscheng/lexicographically_smallest_largest/#2948-make-lexicographically-smallest-array-by-swapping-elements","title":"2948. Make Lexicographically Smallest Array by Swapping Elements","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, union find, sorting</p> </li> </ul>"},{"location":"endlesscheng/lexicographically_smallest_largest/#564-find-the-closest-palindrome","title":"564. Find the Closest Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, string</p> </li> </ul>"},{"location":"endlesscheng/lexicographically_smallest_largest/#1505-minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits","title":"1505. Minimum Possible Integer After at Most K Adjacent Swaps On Digits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, greedy, binary indexed tree, segment tree</p> </li> </ul>"},{"location":"endlesscheng/lexicographically_smallest_largest/#2663-lexicographically-smallest-beautiful-string","title":"2663. Lexicographically Smallest Beautiful String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, greedy</p> </li> </ul>"},{"location":"endlesscheng/lexicographically_smallest_largest/#3302-find-the-lexicographically-smallest-valid-sequence","title":"3302. Find the Lexicographically Smallest Valid Sequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string, dynamic programming, greedy</p> </li> </ul>"},{"location":"endlesscheng/lexicographically_smallest_largest/#555-split-concatenated-strings","title":"555. Split Concatenated Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, greedy</p> </li> </ul>"},{"location":"endlesscheng/lexicographically_smallest_largest/#3088-make-string-anti-palindrome","title":"3088. Make String Anti-palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, greedy, sorting, counting sort</p> </li> </ul>"},{"location":"endlesscheng/math_greedy_basics/","title":"Math Greedy Basics","text":"<ul> <li> 2160. Minimum Sum of Four Digit Number After Splitting Digits (Easy)</li> <li> 2578. Split With Minimum Sum (Easy)</li> <li> 2244. Minimum Rounds to Complete All Tasks (Medium)</li> <li> 2870. Minimum Number of Operations to Make Array Empty (Medium)</li> <li> 1217. Minimum Cost to Move Chips to The Same Position (Easy)</li> <li> 3091. Apply Operations to Make Sum of Array Greater Than or Equal to k (Medium)</li> <li> 397. Integer Replacement (Medium)</li> </ul>"},{"location":"endlesscheng/math_greedy_basics/#2160-minimum-sum-of-four-digit-number-after-splitting-digits","title":"2160. Minimum Sum of Four Digit Number After Splitting Digits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/math_greedy_basics/#2578-split-with-minimum-sum","title":"2578. Split With Minimum Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/math_greedy_basics/#2244-minimum-rounds-to-complete-all-tasks","title":"2244. Minimum Rounds to Complete All Tasks","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, greedy, counting</p> </li> </ul>"},{"location":"endlesscheng/math_greedy_basics/#2870-minimum-number-of-operations-to-make-array-empty","title":"2870. Minimum Number of Operations to Make Array Empty","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, greedy, counting</p> </li> </ul>"},{"location":"endlesscheng/math_greedy_basics/#1217-minimum-cost-to-move-chips-to-the-same-position","title":"1217. Minimum Cost to Move Chips to The Same Position","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, math, greedy</p> </li> </ul>"},{"location":"endlesscheng/math_greedy_basics/#3091-apply-operations-to-make-sum-of-array-greater-than-or-equal-to-k","title":"3091. Apply Operations to Make Sum of Array Greater Than or Equal to k","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, greedy, enumeration</p> </li> </ul>"},{"location":"endlesscheng/math_greedy_basics/#397-integer-replacement","title":"397. Integer Replacement","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming, greedy, bit manipulation, memoization</p> </li> </ul>"},{"location":"endlesscheng/max_subarray_sum/","title":"Max Subarray Sum","text":"<ul> <li> 53. Maximum Subarray (Medium)</li> <li> 2606. Find the Substring With Maximum Cost (Medium)</li> <li> 1749. Maximum Absolute Sum of Any Subarray (Medium)</li> <li> 1191. K-Concatenation Maximum Sum (Medium)</li> <li> 918. Maximum Sum Circular Subarray (Medium)</li> <li> 2321. Maximum Score Of Spliced Array (Hard)</li> <li> 152. Maximum Product Subarray (Medium)</li> </ul>"},{"location":"endlesscheng/max_subarray_sum/#53-maximum-subarray","title":"53. Maximum Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, divide and conquer, dynamic programming</p> </li> </ul> 53. Maximum Subarray - Python Solution<pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxSubArrayDP(nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n\n    dp[0] = nums[0]\n    maxSum = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(\n            dp[i - 1] + nums[i],  # continue the previous subarray\n            nums[i],  # start a new subarray\n        )\n        maxSum = max(maxSum, dp[i])\n\n    return maxSum\n\n\n# Greedy\ndef maxSubArrayGreedy(nums: List[int]) -&gt; int:\n    max_sum = nums[0]\n    cur_sum = 0\n\n    for num in nums:\n        cur_sum = max(cur_sum + num, num)\n        max_sum = max(max_sum, cur_sum)\n\n    return max_sum\n\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArrayDP(nums))  # 6\nprint(maxSubArrayGreedy(nums))  # 6\n</code></pre>"},{"location":"endlesscheng/max_subarray_sum/#2606-find-the-substring-with-maximum-cost","title":"2606. Find the Substring With Maximum Cost","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, dynamic programming</p> </li> </ul>"},{"location":"endlesscheng/max_subarray_sum/#1749-maximum-absolute-sum-of-any-subarray","title":"1749. Maximum Absolute Sum of Any Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"endlesscheng/max_subarray_sum/#1191-k-concatenation-maximum-sum","title":"1191. K-Concatenation Maximum Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"endlesscheng/max_subarray_sum/#918-maximum-sum-circular-subarray","title":"918. Maximum Sum Circular Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, divide and conquer, dynamic programming, queue, monotonic queue</p> </li> </ul> 918. Maximum Sum Circular Subarray - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# DP - Kadane\ndef maxSubarraySumCircularKadane(nums: List[int]) -&gt; int:\n    max_sum = min_sum = nums[0]\n    max_cur = min_cur = 0\n    total = 0\n\n    for num in nums:\n        max_cur = max(max_cur + num, num)\n        min_cur = min(min_cur + num, num)\n        total += num\n\n        max_sum = max(max_sum, max_cur)\n        min_sum = min(min_sum, min_cur)\n\n    return max(max_sum, total - min_sum) if max_sum &gt; 0 else max_sum\n\n\n# Monotonic Queue\ndef maxSubarraySumCircularMQ(nums: List[int]) -&gt; int:\n    n = len(nums)\n    prefix_sum = [0] * (2 * n + 1)\n\n    for i in range(1, 2 * n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + nums[(i - 1) % n]\n\n    q = deque([0])\n    max_sum = float(\"-inf\")\n\n    for i in range(1, 2 * n + 1):\n        if q[0] &lt; i - n:\n            q.popleft()\n\n        max_sum = max(max_sum, prefix_sum[i] - prefix_sum[q[0]])\n\n        while q and prefix_sum[q[-1]] &gt;= prefix_sum[i]:\n            q.pop()\n\n        q.append(i)\n\n    return max_sum\n\n\nnums = [1, -2, 3, -2]\nprint(maxSubarraySumCircularKadane(nums))  # 3\nprint(maxSubarraySumCircularMQ(nums))  # 3\n</code></pre>"},{"location":"endlesscheng/max_subarray_sum/#2321-maximum-score-of-spliced-array","title":"2321. Maximum Score Of Spliced Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"endlesscheng/max_subarray_sum/#152-maximum-product-subarray","title":"152. Maximum Product Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul> 152. Maximum Product Subarray - Python Solution<pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxProduct(nums: List[int]) -&gt; int:\n    n = len(nums)\n    dp_max = [0 for _ in range(n)]\n    dp_min = [0 for _ in range(n)]\n\n    dp_max[0] = nums[0]\n    dp_min[0] = nums[0]\n    max_product = nums[0]\n\n    for i in range(1, n):\n        dp_max[i] = max(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n        dp_min[i] = min(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n\n        max_product = max(max_product, dp_max[i])\n\n    return max_product\n\n\nnums = [2, 3, -2, 4]\nprint(maxProduct(nums))  # 6\n</code></pre>"},{"location":"endlesscheng/median_greedy/","title":"Median Greedy","text":"<ul> <li> 462. Minimum Moves to Equal Array Elements II (Medium)</li> <li> 2033. Minimum Operations to Make a Uni-Value Grid (Medium)</li> <li> 2448. Minimum Cost to Make Array Equal (Hard)</li> <li> 2607. Make K-Subarray Sums Equal (Medium)</li> <li> 2967. Minimum Cost to Make Array Equalindromic (Medium)</li> <li> 1478. Allocate Mailboxes (Hard)</li> <li> 2968. Apply Operations to Maximize Frequency Score (Hard)</li> <li> 1703. Minimum Adjacent Swaps for K Consecutive Ones (Hard)</li> <li> 3086. Minimum Moves to Pick K Ones (Hard)</li> <li> 3441. Minimum Cost Good Caption (Hard)</li> <li> 296. Best Meeting Point (Hard)</li> </ul>"},{"location":"endlesscheng/median_greedy/#462-minimum-moves-to-equal-array-elements-ii","title":"462. Minimum Moves to Equal Array Elements II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, sorting</p> </li> </ul>"},{"location":"endlesscheng/median_greedy/#2033-minimum-operations-to-make-a-uni-value-grid","title":"2033. Minimum Operations to Make a Uni-Value Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, sorting, matrix</p> </li> </ul>"},{"location":"endlesscheng/median_greedy/#2448-minimum-cost-to-make-array-equal","title":"2448. Minimum Cost to Make Array Equal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, greedy, sorting, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/median_greedy/#2607-make-k-subarray-sums-equal","title":"2607. Make K-Subarray Sums Equal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, greedy, sorting, number theory</p> </li> </ul>"},{"location":"endlesscheng/median_greedy/#2967-minimum-cost-to-make-array-equalindromic","title":"2967. Minimum Cost to Make Array Equalindromic","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, binary search, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/median_greedy/#1478-allocate-mailboxes","title":"1478. Allocate Mailboxes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, dynamic programming, sorting</p> </li> </ul>"},{"location":"endlesscheng/median_greedy/#2968-apply-operations-to-maximize-frequency-score","title":"2968. Apply Operations to Maximize Frequency Score","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, sliding window, sorting, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/median_greedy/#1703-minimum-adjacent-swaps-for-k-consecutive-ones","title":"1703. Minimum Adjacent Swaps for K Consecutive Ones","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sliding window, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/median_greedy/#3086-minimum-moves-to-pick-k-ones","title":"3086. Minimum Moves to Pick K Ones","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sliding window, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/median_greedy/#3441-minimum-cost-good-caption","title":"3441. Minimum Cost Good Caption","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul>"},{"location":"endlesscheng/median_greedy/#296-best-meeting-point","title":"296. Best Meeting Point","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, sorting, matrix</p> </li> </ul>"},{"location":"endlesscheng/merge_intervals/","title":"Merge Intervals","text":"<ul> <li> 56. Merge Intervals (Medium)</li> <li> 57. Insert Interval (Medium)</li> <li> 55. Jump Game (Medium)</li> <li> 763. Partition Labels (Medium)</li> <li> 3169. Count Days Without Meetings (Medium)</li> <li> 2580. Count Ways to Group Overlapping Ranges (Medium)</li> <li> 3394. Check if Grid can be Cut into Sections (Medium)</li> <li> 2963. Count the Number of Good Partitions (Hard)</li> <li> 2584. Split the Array to Make Coprime Products (Hard)</li> <li> 616. Add Bold Tag in String (Medium)</li> <li> 758. Bold Words in String (Medium)</li> <li> 3323. Minimize Connected Groups by Inserting Interval (Medium)</li> <li> 759. Employee Free Time (Hard)</li> <li> 2655. Find Maximal Uncovered Ranges (Medium)</li> </ul>"},{"location":"endlesscheng/merge_intervals/#56-merge-intervals","title":"56. Merge Intervals","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sorting</p> </li> <li>Merge all overlapping intervals.</li> </ul> 56. Merge Intervals - Python Solution<pre><code>from typing import List\n\n\n# Intervals\ndef merge(intervals: List[List[int]]) -&gt; List[List[int]]:\n    n = len(intervals)\n    if n &lt;= 1:\n        return intervals\n\n    intervals.sort(key=lambda x: x[0])\n    res = [intervals[0]]\n\n    for i in range(1, n):\n        if intervals[i][0] &lt;= res[-1][1]:\n            res[-1][1] = max(res[-1][1], intervals[i][1])\n        else:\n            res.append(intervals[i])\n\n    return res\n\n\nprint(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))\n# [[1, 6], [8, 10], [15, 18]]\n</code></pre>"},{"location":"endlesscheng/merge_intervals/#57-insert-interval","title":"57. Insert Interval","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array</p> </li> </ul> 57. Insert Interval - Python Solution<pre><code>from typing import List\n\n\n# Interval\ndef insert(\n    intervals: List[List[int]], newInterval: List[int]\n) -&gt; List[List[int]]:\n    n = len(intervals)\n\n    if n == 0:\n        return [newInterval]\n\n    if newInterval[1] &lt; intervals[0][0]:\n        return [newInterval] + intervals\n\n    if newInterval[0] &gt; intervals[-1][1]:\n        return intervals + [newInterval]\n\n    i = 0\n    result = []\n\n    while i &lt; n and intervals[i][1] &lt; newInterval[0]:\n        result.append(intervals[i])\n        i += 1\n\n    while i &lt; n and intervals[i][0] &lt;= newInterval[1]:\n        newInterval[0] = min(newInterval[0], intervals[i][0])\n        newInterval[1] = max(newInterval[1], intervals[i][1])\n        i += 1\n\n    result.append(newInterval)\n\n    while i &lt; n:\n        result.append(intervals[i])\n        i += 1\n\n    return result\n\n\nintervals = [[1, 3], [6, 9]]\nnewInterval = [2, 5]\nprint(insert(intervals, newInterval))  # [[1, 5], [6, 9]]\n</code></pre>"},{"location":"endlesscheng/merge_intervals/#55-jump-game","title":"55. Jump Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> <li>Return <code>True</code> if you can reach the last index, otherwise <code>False</code>.</li> </ul> <ul> <li>Example: <code>[2, 3, 1, 1, 4, 1, 2, 0, 0]</code></li> </ul> Index Value Index + Value Max Reach Max Reach &gt;= Last Index 0 2 2 2 False 1 3 4 4 False 2 1 3 4 False 3 1 4 4 False 4 4 8 8 True 5 1 6 8 True 6 2 8 8 True 7 0 7 8 True 8 0 8 8 True 55. Jump Game - Python Solution<pre><code>from typing import List\n\n\n# Greedy - Interval\ndef canJump(nums: List[int]) -&gt; bool:\n    maxReach = 0\n    i = 0\n    n = len(nums)\n\n    while i &lt;= maxReach:\n        maxReach = max(maxReach, i + nums[i])\n        if maxReach &gt;= n - 1:\n            return True\n        i += 1\n\n    return False\n\n\nprint(canJump([2, 3, 1, 1, 4, 1, 2, 0, 0]))  # True\n</code></pre>"},{"location":"endlesscheng/merge_intervals/#763-partition-labels","title":"763. Partition Labels","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, two pointers, string, greedy</p> </li> </ul> 763. Partition Labels - Python Solution<pre><code>from typing import List\n\n\n# 1. Hashmap\ndef partitionLabels1(s: str) -&gt; List[int]:\n    # Time complexity: O(nlogn)\n    # Space complexity: O(n)\n    hashmap = {}\n\n    for i, j in enumerate(s):\n        if j not in hashmap:\n            hashmap[j] = [i, i]\n        else:\n            hashmap[j][1] = i\n\n    intervals = list(hashmap.values())\n    intervals.sort(key=lambda x: x[0])\n\n    if len(intervals) &lt; 2:\n        return len(intervals)\n\n    result = []\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &lt; intervals[i - 1][1]:\n            intervals[i][1] = max(intervals[i][1], intervals[i - 1][1])\n        else:\n            result.append(intervals[i][0])\n\n    result.append(intervals[-1][1] + 1)\n\n    if len(result) == 1:\n        return result\n    else:\n        for i in range(len(result) - 1, 0, -1):\n            result[i] -= result[i - 1]\n        return result\n\n\n# 2. Single Pass Partitioning\ndef partitionLabels2(s: str) -&gt; List[int]:\n    # Time complexity: O(n)\n    # Space complexity: O(n)\n    last = {c: i for i, c in enumerate(s)}\n\n    start, end = 0, 0\n    result = []\n\n    for i, c in enumerate(s):\n        end = max(end, last[c])\n        if i == end:\n            result.append(end - start + 1)\n            start = i + 1\n\n    return result\n\n\nprint(partitionLabels1(\"abaccd\"))  # [3, 2, 1]\nprint(partitionLabels2(\"abaccd\"))  # [3, 2, 1]\n</code></pre>"},{"location":"endlesscheng/merge_intervals/#3169-count-days-without-meetings","title":"3169. Count Days Without Meetings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sorting</p> </li> </ul>"},{"location":"endlesscheng/merge_intervals/#2580-count-ways-to-group-overlapping-ranges","title":"2580. Count Ways to Group Overlapping Ranges","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sorting</p> </li> </ul>"},{"location":"endlesscheng/merge_intervals/#3394-check-if-grid-can-be-cut-into-sections","title":"3394. Check if Grid can be Cut into Sections","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sorting</p> </li> </ul>"},{"location":"endlesscheng/merge_intervals/#2963-count-the-number-of-good-partitions","title":"2963. Count the Number of Good Partitions","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, math, combinatorics</p> </li> </ul>"},{"location":"endlesscheng/merge_intervals/#2584-split-the-array-to-make-coprime-products","title":"2584. Split the Array to Make Coprime Products","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, math, number theory</p> </li> </ul>"},{"location":"endlesscheng/merge_intervals/#616-add-bold-tag-in-string","title":"616. Add Bold Tag in String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, trie, string matching</p> </li> </ul>"},{"location":"endlesscheng/merge_intervals/#758-bold-words-in-string","title":"758. Bold Words in String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, trie, string matching</p> </li> </ul>"},{"location":"endlesscheng/merge_intervals/#3323-minimize-connected-groups-by-inserting-interval","title":"3323. Minimize Connected Groups by Inserting Interval","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sliding window, sorting</p> </li> </ul>"},{"location":"endlesscheng/merge_intervals/#759-employee-free-time","title":"759. Employee Free Time","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, sorting, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/merge_intervals/#2655-find-maximal-uncovered-ranges","title":"2655. Find Maximal Uncovered Ranges","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sorting</p> </li> </ul>"},{"location":"endlesscheng/minimum_spanning_tree/","title":"Minimum Spanning Tree","text":"<ul> <li> 1584. Min Cost to Connect All Points (Medium)</li> <li> 1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree (Hard)</li> <li> 1135. Connecting Cities With Minimum Cost (Medium)</li> <li> 1168. Optimize Water Distribution in a Village (Hard)</li> <li> 3219. Minimum Cost for Cutting Cake II (Hard)</li> </ul>"},{"location":"endlesscheng/minimum_spanning_tree/#1584-min-cost-to-connect-all-points","title":"1584. Min Cost to Connect All Points","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, union find, graph, minimum spanning tree</p> </li> <li>Tree: a connected acyclic graph</li> <li>Spanning Tree: a subgraph that is a tree and connects all the vertices together</li> <li>Minimum Spanning Tree (MST): a spanning tree with the minimum possible sum of edge weights</li> <li>Prim's Algorithm<ul> <li>Data Structure: Heap</li> <li>Time Complexity: O(E * logV)</li> <li>Space Complexity: O(V + E)</li> </ul> </li> <li> <p>Kruskal's Algorithm</p> <ul> <li>Union Find</li> <li>Time Complexity: O(E * logV)</li> <li>Space Complexity: O(V + E)</li> </ul> </li> <li> <p>Demonstration</p> </li> </ul> <p>Example graph</p> <p></p> <p>MST</p> <p></p> 1584. Min Cost to Connect All Points - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minCostConnectPointsPrim(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    graph = defaultdict(list)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            dist = abs(x1 - x2) + abs(y1 - y2)\n            graph[i].append((dist, j))\n            graph[j].append((dist, i))\n\n    cost = 0\n    heap = [(0, 0)]  # (cost, node)\n    visited = set()\n\n    while heap:\n        d1, n1 = heapq.heappop(heap)\n        if n1 in visited:\n            continue\n        visited.add(n1)\n        cost += d1\n\n        for d2, n2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (d2, n2))\n\n    return cost\n\n\n# Kruskal\ndef minCostConnectPointsKruskal(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    par = {i: i for i in range(n)}\n    rank = {i: 0 for i in range(n)}\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 == p2:\n            return False\n\n        if rank[p1] &gt; rank[p2]:\n            par[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n        else:\n            par[p2] = p1\n            rank[p1] += 1\n\n        return True\n\n    heap = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            dist = abs(x1 - x2) + abs(y1 - y2)\n            heapq.heappush(heap, (dist, i, j))\n\n    cost = 0\n    while heap:\n        d, n1, n2 = heapq.heappop(heap)\n        if union(n1, n2):\n            cost += d\n\n    return cost\n\n\npoints = [[0, 0], [2, 2], [3, 10], [5, 2], [7, 0]]\nprint(minCostConnectPointsPrim(points))  # 20\nprint(minCostConnectPointsKruskal(points))  # 20\n</code></pre>"},{"location":"endlesscheng/minimum_spanning_tree/#1489-find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree","title":"1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: union find, graph, sorting, minimum spanning tree, strongly connected component</p> </li> </ul> 1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree - Python Solution<pre><code>from typing import List\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [1 for _ in range(n)]\n        self.part = n\n\n    def find(self, n):\n        p = self.parent[n]\n        while p != self.parent[p]:\n            self.parent[p] = self.parent[self.parent[p]]\n            p = self.parent[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return False\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.parent[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.parent[p1] = p2\n        else:\n            self.parent[p2] = p1\n            self.rank[p1] += 1\n\n        self.part -= 1\n        return True\n\n\n# Kruskal\ndef findCriticalAndPseudoCriticalEdges(\n    n: int, edges: List[List[int]]\n) -&gt; List[List[int]]:\n    m = len(edges)\n\n    # Add index to edges\n    lst = list(range(m))\n    lst.sort(key=lambda x: edges[x][2])\n\n    # Calculate minimum cost\n    min_cost = 0\n    uf = UnionFind(n)\n    for i in lst:\n        x, y, cost = edges[i]\n        if uf.union(x, y):\n            min_cost += cost\n\n    # Calculate key edges\n    key = set()\n    for i in lst:\n        cur_cost = 0\n        uf = UnionFind(n)\n        for j in lst:\n            if j != i:\n                x, y, cost = edges[j]\n                if uf.union(x, y):\n                    cur_cost += cost\n        if cur_cost &gt; min_cost or uf.part != 1:\n            key.add(i)\n\n    # Calculate fake edges\n    fake = set()\n    for i in lst:\n        if i not in key:\n            cur_cost = edges[i][2]\n            uf = UnionFind(n)\n            uf.union(edges[i][0], edges[i][1])\n            for j in lst:\n                x, y, cost = edges[j]\n                if uf.union(x, y):\n                    cur_cost += cost\n            if cur_cost == min_cost and uf.part == 1:\n                fake.add(i)\n\n    return [sorted(list(key)), sorted(list(fake))]\n\n\nn = 5\nedges = [\n    [0, 1, 1],\n    [1, 2, 1],\n    [2, 3, 2],\n    [0, 3, 2],\n    [0, 4, 3],\n    [3, 4, 3],\n    [1, 4, 6],\n]\nprint(findCriticalAndPseudoCriticalEdges(n, edges))\n</code></pre>"},{"location":"endlesscheng/minimum_spanning_tree/#1135-connecting-cities-with-minimum-cost","title":"1135. Connecting Cities With Minimum Cost","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: union find, graph, heap priority queue, minimum spanning tree</p> </li> </ul> 1135. Connecting Cities With Minimum Cost - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minimumCost(n: int, connections: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, c in connections:\n        graph[u].append((c, v))\n        graph[v].append((c, u))\n\n    cost = 0\n    heap = [(0, 1)]  # (cost, node)\n    visited = set()\n\n    while heap:\n        c1, n1 = heapq.heappop(heap)\n\n        if n1 in visited:\n            continue\n\n        visited.add(n1)\n\n        cost += c1\n\n        for c2, n2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (c2, n2))\n\n    return cost if len(visited) == n else -1\n\n\nn = 3\nconnections = [[1, 2, 5], [1, 3, 6], [2, 3, 1]]\nprint(minimumCost(n, connections))  # 6\n</code></pre>"},{"location":"endlesscheng/minimum_spanning_tree/#1168-optimize-water-distribution-in-a-village","title":"1168. Optimize Water Distribution in a Village","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: union find, graph, heap priority queue, minimum spanning tree </p> </li> </ul> <p></p> 1168. Optimize Water Distribution in a Village - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minCostToSupplyWater1(\n    n: int, wells: List[int], pipes: List[List[int]]\n) -&gt; int:\n    graph = defaultdict(list)\n\n    for h1, h2, cost in pipes:\n        graph[h1].append((h2, cost))\n        graph[h2].append((h1, cost))\n\n    # Add the cost of the wells to the graph (house 0)\n    for i in range(n):\n        graph[0].append((i + 1, wells[i]))\n        graph[i + 1].append((0, wells[i]))\n\n    visited = set([0])\n    heap = [(cost, dest) for dest, cost in graph[0]]\n    heapq.heapify(heap)\n\n    cost = 0\n\n    while heap:\n        c1, n1 = heapq.heappop(heap)\n        if n1 in visited:\n            continue\n        visited.add(n1)\n        cost += c1\n\n        for n2, c2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (c2, n2))\n\n    return cost\n\n\n# Kruskal\ndef minCostToSupplyWater2(\n    n: int, wells: List[int], pipes: List[List[int]]\n) -&gt; int:\n    par = list(range(n + 1))\n    rank = [0] * (n + 1)\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            if rank[p1] &lt; rank[p2]:\n                par[p1] = p2\n            elif rank[p1] &gt; rank[p2]:\n                par[p2] = p1\n            else:\n                par[p1] = p2\n                rank[p2] += 1\n            return True\n        return False\n\n    graph = [(c, 0, i + 1) for i, c in enumerate(wells)]\n    for h1, h2, c in pipes:\n        graph.append((c, h1, h2))\n\n    graph.sort()\n\n    cost = 0\n\n    for c, h1, h2 in graph:\n        if union(h1, h2):\n            cost += c\n\n    return cost\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |    Prim    | O((V + E) log V) | O(V + E)|\n# |  Kruskal   |     O(E log E)   | O(V + E)|\n# |------------|------------------|---------|\n\n\nn = 3\nwells = [1, 2, 2]\npipes = [[1, 2, 1], [2, 3, 1]]\nprint(minCostToSupplyWater1(n, wells, pipes))  # 3\nprint(minCostToSupplyWater2(n, wells, pipes))  # 3\n</code></pre>"},{"location":"endlesscheng/minimum_spanning_tree/#3219-minimum-cost-for-cutting-cake-ii","title":"3219. Minimum Cost for Cutting Cake II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/monotonic_queue/","title":"Monotonic Queue","text":"<ul> <li> 239. Sliding Window Maximum (Hard)</li> <li> 1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit (Medium)</li> <li> 2762. Continuous Subarrays (Medium)</li> <li> 2398. Maximum Number of Robots Within Budget (Hard)</li> <li> 862. Shortest Subarray with Sum at Least K (Hard)</li> <li> 1499. Max Value of Equation (Hard)</li> <li> 2071. Maximum Number of Tasks You Can Assign (Hard)</li> </ul>"},{"location":"endlesscheng/monotonic_queue/#239-sliding-window-maximum","title":"239. Sliding Window Maximum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, queue, sliding window, heap priority queue, monotonic queue</p> </li> </ul> 239. Sliding Window Maximum - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# Monotonic Queue\ndef maxSlidingWindow(nums: List[int], k: int) -&gt; List[int]:\n    q = deque()\n    res = []\n\n    for i, num in enumerate(nums):\n        if q and q[0] &lt; i - k + 1:\n            q.popleft()\n\n        while q and nums[q[-1]] &lt; num:\n            q.pop()\n\n        q.append(i)\n\n        if i &gt;= k - 1:\n            res.append(nums[q[0]])\n\n    return res\n\n\nnums = [1, 3, -1, -3, 5, 3, 6, 7]\nk = 3\nprint(maxSlidingWindow(nums, k))  # [3, 3, 5, 5, 6, 7]\n</code></pre>"},{"location":"endlesscheng/monotonic_queue/#1438-longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit","title":"1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, queue, sliding window, heap priority queue, ordered set, monotonic queue</p> </li> </ul>"},{"location":"endlesscheng/monotonic_queue/#2762-continuous-subarrays","title":"2762. Continuous Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, queue, sliding window, heap priority queue, ordered set, monotonic queue</p> </li> </ul>"},{"location":"endlesscheng/monotonic_queue/#2398-maximum-number-of-robots-within-budget","title":"2398. Maximum Number of Robots Within Budget","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, queue, sliding window, heap priority queue, prefix sum, monotonic queue</p> </li> </ul> 2398. Maximum Number of Robots Within Budget - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# Monotonic Queue\ndef maximumRobots(\n    chargeTimes: List[int], runningCosts: List[int], budget: int\n) -&gt; int:\n    ans = sum_cost = left = 0\n    q = deque()\n\n    for right, (time, cost) in enumerate(zip(chargeTimes, runningCosts)):\n        # 1. Add\n        while q and time &gt;= chargeTimes[q[-1]]:\n            q.pop()\n        q.append(right)\n        sum_cost += cost\n\n        # 2. Remove\n        while q and chargeTimes[q[0]] + (right - left + 1) * sum_cost &gt; budget:\n            if q[0] == left:\n                q.popleft()\n            sum_cost -= runningCosts[left]\n            left += 1\n\n        # 3. Update\n        ans = max(ans, right - left + 1)\n    return ans\n\n\nchargeTimes = [3, 6, 1, 3, 4]\nrunningCosts = [2, 1, 3, 4, 5]\nbudget = 25\nprint(maximumRobots(chargeTimes, runningCosts, budget))  # 3\n</code></pre>"},{"location":"endlesscheng/monotonic_queue/#862-shortest-subarray-with-sum-at-least-k","title":"862. Shortest Subarray with Sum at Least K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, queue, sliding window, heap priority queue, prefix sum, monotonic queue</p> </li> </ul> 862. Shortest Subarray with Sum at Least K - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# Prefix Sum + Monotonic Queue\ndef shortestSubarray(nums: List[int], k: int) -&gt; int:\n    n = len(nums)\n    ps = [0 for _ in range(n + 1)]\n\n    for i in range(n):\n        ps[i + 1] = ps[i] + nums[i]\n\n    res = float(\"inf\")\n    q = deque()\n\n    for i in range(n + 1):\n        while q and ps[i] - ps[q[0]] &gt;= k:\n            res = min(res, i - q.popleft())\n        while q and ps[i] &lt;= ps[q[-1]]:\n            q.pop()\n        q.append(i)\n\n    return res if res != float(\"inf\") else -1\n\n\nnums = [2, -1, 2]\nk = 3\nprint(shortestSubarray(nums, k))  # 3\n</code></pre>"},{"location":"endlesscheng/monotonic_queue/#1499-max-value-of-equation","title":"1499. Max Value of Equation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, queue, sliding window, heap priority queue, monotonic queue</p> </li> </ul>"},{"location":"endlesscheng/monotonic_queue/#2071-maximum-number-of-tasks-you-can-assign","title":"2071. Maximum Number of Tasks You Can Assign","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, greedy, queue, sorting, monotonic queue</p> </li> </ul>"},{"location":"endlesscheng/monotonic_queue_optimized_dp/","title":"Monotonic Queue Optimized DP","text":"<ul> <li> 2944. Minimum Number of Coins for Fruits (Medium)</li> <li> 1696. Jump Game VI (Medium)</li> <li> 1425. Constrained Subsequence Sum (Hard)</li> <li> 375. Guess Number Higher or Lower II (Medium)</li> <li> 1687. Delivering Boxes from Storage to Ports (Hard)</li> <li> 3117. Minimum Sum of Values by Dividing Array (Hard)</li> <li> 2945. Find Maximum Non-decreasing Array Length (Hard)</li> <li> 2969. Minimum Number of Coins for Fruits II (Hard)</li> </ul>"},{"location":"endlesscheng/monotonic_queue_optimized_dp/#2944-minimum-number-of-coins-for-fruits","title":"2944. Minimum Number of Coins for Fruits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, queue, heap priority queue, monotonic queue</p> </li> </ul>"},{"location":"endlesscheng/monotonic_queue_optimized_dp/#1696-jump-game-vi","title":"1696. Jump Game VI","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, queue, heap priority queue, monotonic queue</p> </li> </ul>"},{"location":"endlesscheng/monotonic_queue_optimized_dp/#1425-constrained-subsequence-sum","title":"1425. Constrained Subsequence Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, queue, sliding window, heap priority queue, monotonic queue</p> </li> </ul>"},{"location":"endlesscheng/monotonic_queue_optimized_dp/#375-guess-number-higher-or-lower-ii","title":"375. Guess Number Higher or Lower II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, game theory</p> </li> </ul>"},{"location":"endlesscheng/monotonic_queue_optimized_dp/#1687-delivering-boxes-from-storage-to-ports","title":"1687. Delivering Boxes from Storage to Ports","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, segment tree, queue, heap priority queue, prefix sum, monotonic queue</p> </li> </ul>"},{"location":"endlesscheng/monotonic_queue_optimized_dp/#3117-minimum-sum-of-values-by-dividing-array","title":"3117. Minimum Sum of Values by Dividing Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, dynamic programming, bit manipulation, segment tree, queue</p> </li> </ul>"},{"location":"endlesscheng/monotonic_queue_optimized_dp/#2945-find-maximum-non-decreasing-array-length","title":"2945. Find Maximum Non-decreasing Array Length","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, dynamic programming, stack, queue, monotonic stack, monotonic queue</p> </li> </ul>"},{"location":"endlesscheng/monotonic_queue_optimized_dp/#2969-minimum-number-of-coins-for-fruits-ii","title":"2969. Minimum Number of Coins for Fruits II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, queue, heap priority queue, monotonic queue</p> </li> </ul>"},{"location":"endlesscheng/monotonic_stack/","title":"Monotonic Stack","text":"<ul> <li> 739. Daily Temperatures (Medium)</li> <li> 1475. Final Prices With a Special Discount in a Shop (Easy)</li> <li> 496. Next Greater Element I (Easy)</li> <li> 503. Next Greater Element II (Medium)</li> <li> 1019. Next Greater Node In Linked List (Medium)</li> <li> 962. Maximum Width Ramp (Medium)</li> <li> 853. Car Fleet (Medium)</li> <li> 901. Online Stock Span (Medium)</li> <li> 1124. Longest Well-Performing Interval (Medium)</li> <li> 1793. Maximum Score of a Good Subarray (Hard)</li> <li> 456. 132 Pattern (Medium)</li> <li> 3113. Find the Number of Subarrays Where Boundary Elements Are Maximum (Hard)</li> <li> 2866. Beautiful Towers II (Medium)</li> <li> 1944. Number of Visible People in a Queue (Hard)</li> <li> 2454. Next Greater Element IV (Hard)</li> <li> 1130. Minimum Cost Tree From Leaf Values (Medium)</li> <li> 2289. Steps to Make Array Non-decreasing (Medium)</li> <li> 1776. Car Fleet II (Hard)</li> <li> 3221. Maximum Array Hopping Score II (Medium)</li> <li> 1966. Binary Searchable Numbers in an Unsorted Array (Medium)</li> <li> 2832. Maximal Range That Each Element Is Maximum in It (Medium)</li> <li> 2282. Number of People That Can Be Seen in a Grid (Medium)</li> </ul>"},{"location":"endlesscheng/monotonic_stack/#739-daily-temperatures","title":"739. Daily Temperatures","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, monotonic stack</p> </li> <li>Return an array <code>res</code> such that <code>res[i]</code> is the number of days you have to wait after the <code>ith</code> day to get a warmer temperature.</li> </ul> Index Temp &gt; stack last stack result 0 73 False <code>[ [73, 0] ]</code> 1 - 0 = 1 1 74 True <code>[ [74, 1] ]</code> 2 - 1 = 1 2 75 True <code>[ [75, 2] ]</code> 6 - 2 = 4 3 71 False <code>[ [75, 2], [71, 3] ]</code> 5 - 3 = 2 4 69 False <code>[ [75, 2], [71, 3], [69, 4] ]</code> 5 - 4 = 1 5 72 True <code>[ [75, 2], [72, 5] ]</code> 6 - 5 = 1 6 76 True <code>[ [76, 6] ]</code> 0 7 73 False <code>[[76, 6], [73, 7]]</code> 0 739. Daily Temperatures - Python Solution<pre><code>from typing import List\n\nimport matplotlib.pyplot as plt\n\n\n# Monotonic Stack\ndef dailyTemperatures(temperatures: List[int]) -&gt; List[int]:\n    res = [0 for _ in range(len(temperatures))]\n    stack = []\n\n    for idx, temp in enumerate(temperatures):\n        while stack and temp &gt; stack[-1][0]:\n            _, last_index = stack.pop()\n            res[last_index] = idx - last_index\n\n        stack.append([temp, idx])\n\n    return res\n\n\ndef utils_plot(idx: int, temps: List[int], stack: List[List[int]]) -&gt; None:\n    \"\"\"Plot the current state of the stack and the temperatures.\"\"\"\n    plt.figure(figsize=(8, 3))\n    plt.plot(\n        range(len(temps)),\n        temps,\n        marker=\"o\",\n        linestyle=\"-\",\n        color=\"b\",\n        label=\"Temperatures\",\n    )\n\n    # Highlight the current temperature in red\n    plt.scatter(idx, temps[idx], color=\"r\", s=100, label=\"Current\")\n\n    # Display the current state of the stack\n    for temp, stack_idx in stack:\n        plt.scatter(stack_idx, temp, color=\"g\", s=70)\n        plt.text(\n            stack_idx,\n            temp,\n            f\"({temp}, {stack_idx})\",\n            fontsize=10,\n            ha=\"center\",\n            va=\"bottom\",\n            color=\"red\",\n        )\n\n    plt.title(f\"Day {idx}\")\n    plt.xlabel(\"Days\")\n    plt.ylabel(\"Temperature\")\n    plt.legend()\n    plt.grid(True)\n    plt.show()\n\n\nprint(dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73]))\n# [1, 1, 4, 2, 1, 1, 0, 0]\n</code></pre>"},{"location":"endlesscheng/monotonic_stack/#1475-final-prices-with-a-special-discount-in-a-shop","title":"1475. Final Prices With a Special Discount in a Shop","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, stack, monotonic stack</p> </li> </ul>"},{"location":"endlesscheng/monotonic_stack/#496-next-greater-element-i","title":"496. Next Greater Element I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, stack, monotonic stack</p> </li> </ul> 496. Next Greater Element I - Python Solution<pre><code>from typing import List\n\n\n# Monotonic Stack\ndef nextGreaterElement(nums1: List[int], nums2: List[int]) -&gt; List[int]:\n    next_greater = {}\n    stack = []\n    result = []\n\n    for num in nums2:\n        while stack and num &gt; stack[-1]:\n            next_greater[stack.pop()] = num\n        stack.append(num)\n\n    for num in nums1:\n        result.append(next_greater.get(num, -1))\n\n    return result\n\n\nnums1 = [4, 1, 2]\nnums2 = [1, 3, 4, 2]\nprint(nextGreaterElement(nums1, nums2))  # [3, -1, -1]\n</code></pre>"},{"location":"endlesscheng/monotonic_stack/#503-next-greater-element-ii","title":"503. Next Greater Element II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, monotonic stack</p> </li> </ul> 503. Next Greater Element II - Python Solution<pre><code>from typing import List\n\n\n# Monotonic Stack\ndef nextGreaterElements(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    result = [-1] * n\n    stack = []\n\n    for i in range(2 * n):\n        while stack and nums[stack[-1]] &lt; nums[i % n]:\n            result[stack.pop()] = nums[i % n]\n        if i &lt; n:\n            stack.append(i)\n\n    return result\n\n\nnums = [1, 2, 1]\nprint(nextGreaterElements(nums))  # [2, -1, 2]\n</code></pre>"},{"location":"endlesscheng/monotonic_stack/#1019-next-greater-node-in-linked-list","title":"1019. Next Greater Node In Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, linked list, stack, monotonic stack</p> </li> </ul>"},{"location":"endlesscheng/monotonic_stack/#962-maximum-width-ramp","title":"962. Maximum Width Ramp","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, stack, monotonic stack</p> </li> </ul>"},{"location":"endlesscheng/monotonic_stack/#853-car-fleet","title":"853. Car Fleet","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, sorting, monotonic stack</p> </li> </ul> 853. Car Fleet - Python Solution<pre><code>from typing import List\n\n\n# Stack\ndef carFleet(target: int, position: List[int], speed: List[int]) -&gt; int:\n    cars = sorted(zip(position, speed), reverse=True)\n    stack = []\n\n    for p, s in cars:\n        time = (target - p) / s\n\n        if not stack or time &gt; stack[-1]:\n            stack.append(time)\n\n    return len(stack)\n\n\nprint(carFleet(12, [10, 8, 0, 5, 3], [2, 4, 1, 1, 3]))  # 3\n</code></pre>"},{"location":"endlesscheng/monotonic_stack/#901-online-stock-span","title":"901. Online Stock Span","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: stack, design, monotonic stack, data stream</p> </li> <li>Design a class <code>StockSpanner</code> to return the number of consecutive days (including the current day) the price of the stock has been less than or equal to the current price.</li> </ul> 901. Online Stock Span - Python Solution<pre><code>from typing import List\n\n\n# Monotonic Stack\nclass StockSpanner:\n\n    def __init__(self):\n        self.stack = [(-1, float(\"inf\"))]\n        self.cur_day = -1\n\n    def next(self, price: int) -&gt; int:\n        while price &gt;= self.stack[-1][1]:\n            self.stack.pop()\n        self.cur_day += 1\n        self.stack.append((self.cur_day, price))\n        return self.cur_day - self.stack[-2][0]\n\n\nobj = StockSpanner()\nprices = [100, 80, 60, 70, 60, 75, 85]\nprint([obj.next(price) for price in prices])  # [1, 1, 1, 2, 1, 4, 6]\n</code></pre>"},{"location":"endlesscheng/monotonic_stack/#1124-longest-well-performing-interval","title":"1124. Longest Well-Performing Interval","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, stack, monotonic stack, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/monotonic_stack/#1793-maximum-score-of-a-good-subarray","title":"1793. Maximum Score of a Good Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, binary search, stack, monotonic stack</p> </li> </ul>"},{"location":"endlesscheng/monotonic_stack/#456-132-pattern","title":"456. 132 Pattern","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, stack, monotonic stack, ordered set</p> </li> </ul> 456. 132 Pattern - Python Solution<pre><code>from typing import List\n\n\n# Monotonic Stack\ndef find132pattern(nums: List[int]) -&gt; bool:\n    n = len(nums)\n    if n &lt; 3:\n        return False\n\n    stack = []\n    second_max = float(\"-inf\")\n\n    for i in range(n - 1, -1, -1):\n        if nums[i] &lt; second_max:\n            return True\n\n        while stack and stack[-1] &lt; nums[i]:\n            second_max = stack.pop()\n\n        stack.append(nums[i])\n\n    return False\n\n\nnums = [-1, 3, 2, 0]\nprint(find132pattern(nums))  # True\n</code></pre>"},{"location":"endlesscheng/monotonic_stack/#3113-find-the-number-of-subarrays-where-boundary-elements-are-maximum","title":"3113. Find the Number of Subarrays Where Boundary Elements Are Maximum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, stack, monotonic stack</p> </li> </ul>"},{"location":"endlesscheng/monotonic_stack/#2866-beautiful-towers-ii","title":"2866. Beautiful Towers II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, monotonic stack</p> </li> </ul>"},{"location":"endlesscheng/monotonic_stack/#1944-number-of-visible-people-in-a-queue","title":"1944. Number of Visible People in a Queue","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, stack, monotonic stack</p> </li> </ul>"},{"location":"endlesscheng/monotonic_stack/#2454-next-greater-element-iv","title":"2454. Next Greater Element IV","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, stack, sorting, heap priority queue, monotonic stack</p> </li> </ul>"},{"location":"endlesscheng/monotonic_stack/#1130-minimum-cost-tree-from-leaf-values","title":"1130. Minimum Cost Tree From Leaf Values","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, stack, greedy, monotonic stack</p> </li> </ul>"},{"location":"endlesscheng/monotonic_stack/#2289-steps-to-make-array-non-decreasing","title":"2289. Steps to Make Array Non-decreasing","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, linked list, stack, monotonic stack</p> </li> </ul>"},{"location":"endlesscheng/monotonic_stack/#1776-car-fleet-ii","title":"1776. Car Fleet II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, stack, heap priority queue, monotonic stack</p> </li> </ul>"},{"location":"endlesscheng/monotonic_stack/#3221-maximum-array-hopping-score-ii","title":"3221. Maximum Array Hopping Score II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, greedy, monotonic stack</p> </li> </ul>"},{"location":"endlesscheng/monotonic_stack/#1966-binary-searchable-numbers-in-an-unsorted-array","title":"1966. Binary Searchable Numbers in an Unsorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"endlesscheng/monotonic_stack/#2832-maximal-range-that-each-element-is-maximum-in-it","title":"2832. Maximal Range That Each Element Is Maximum in It","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, monotonic stack</p> </li> </ul>"},{"location":"endlesscheng/monotonic_stack/#2282-number-of-people-that-can-be-seen-in-a-grid","title":"2282. Number of People That Can Be Seen in a Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, matrix, monotonic stack</p> </li> </ul>"},{"location":"endlesscheng/network_flow/","title":"Network Flow","text":"<ul> <li> 3376. Minimum Time to Break Locks I (Medium)</li> <li> 1947. Maximum Compatibility Score Sum (Medium)</li> <li> 2850. Minimum Moves to Spread Stones Over Grid (Medium)</li> <li> 1879. Minimum XOR Sum of Two Arrays (Hard)</li> <li> 1349. Maximum Students Taking Exam (Hard)</li> <li> 2172. Maximum AND Sum of Array (Hard)</li> <li> 3276. Select Cells in Grid With Maximum Score (Hard)</li> <li> 1595. Minimum Cost to Connect Two Groups of Points (Hard)</li> <li> 3257. Maximum Value Sum by Placing Three Rooks II (Hard)</li> <li> 1820. Maximum Number of Accepted Invitations (Medium)</li> <li> 2403. Minimum Time to Kill All Monsters (Hard)</li> <li> 3385. Minimum Time to Break Locks II (Hard)</li> <li> 1066. Campus Bikes II (Medium)</li> <li> 2123. Minimum Operations to Remove Adjacent Ones in Matrix (Hard)</li> <li> 2463. Minimum Total Distance Traveled (Hard)</li> </ul>"},{"location":"endlesscheng/network_flow/#3376-minimum-time-to-break-locks-i","title":"3376. Minimum Time to Break Locks I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, backtracking, bit manipulation, depth first search, bitmask</p> </li> </ul>"},{"location":"endlesscheng/network_flow/#1947-maximum-compatibility-score-sum","title":"1947. Maximum Compatibility Score Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, backtracking, bit manipulation, bitmask</p> </li> </ul>"},{"location":"endlesscheng/network_flow/#2850-minimum-moves-to-spread-stones-over-grid","title":"2850. Minimum Moves to Spread Stones Over Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, breadth first search, matrix</p> </li> </ul>"},{"location":"endlesscheng/network_flow/#1879-minimum-xor-sum-of-two-arrays","title":"1879. Minimum XOR Sum of Two Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, bit manipulation, bitmask</p> </li> </ul>"},{"location":"endlesscheng/network_flow/#1349-maximum-students-taking-exam","title":"1349. Maximum Students Taking Exam","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, bit manipulation, matrix, bitmask</p> </li> </ul>"},{"location":"endlesscheng/network_flow/#2172-maximum-and-sum-of-array","title":"2172. Maximum AND Sum of Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, bit manipulation, bitmask</p> </li> </ul>"},{"location":"endlesscheng/network_flow/#3276-select-cells-in-grid-with-maximum-score","title":"3276. Select Cells in Grid With Maximum Score","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, bit manipulation, matrix, bitmask</p> </li> </ul>"},{"location":"endlesscheng/network_flow/#1595-minimum-cost-to-connect-two-groups-of-points","title":"1595. Minimum Cost to Connect Two Groups of Points","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, bit manipulation, matrix, bitmask</p> </li> </ul>"},{"location":"endlesscheng/network_flow/#3257-maximum-value-sum-by-placing-three-rooks-ii","title":"3257. Maximum Value Sum by Placing Three Rooks II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, matrix, enumeration</p> </li> </ul>"},{"location":"endlesscheng/network_flow/#1820-maximum-number-of-accepted-invitations","title":"1820. Maximum Number of Accepted Invitations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, graph, matrix</p> </li> </ul>"},{"location":"endlesscheng/network_flow/#2403-minimum-time-to-kill-all-monsters","title":"2403. Minimum Time to Kill All Monsters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, bit manipulation, bitmask</p> </li> </ul>"},{"location":"endlesscheng/network_flow/#3385-minimum-time-to-break-locks-ii","title":"3385. Minimum Time to Break Locks II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, depth first search, graph</p> </li> </ul>"},{"location":"endlesscheng/network_flow/#1066-campus-bikes-ii","title":"1066. Campus Bikes II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, backtracking, bit manipulation, bitmask</p> </li> </ul>"},{"location":"endlesscheng/network_flow/#2123-minimum-operations-to-remove-adjacent-ones-in-matrix","title":"2123. Minimum Operations to Remove Adjacent Ones in Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, graph, matrix</p> </li> </ul>"},{"location":"endlesscheng/network_flow/#2463-minimum-total-distance-traveled","title":"2463. Minimum Total Distance Traveled","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, sorting</p> </li> </ul>"},{"location":"endlesscheng/non-overlapping_intervals/","title":"Non-Overlapping Intervals","text":"<ul> <li> 435. Non-overlapping Intervals (Medium)</li> <li> 646. Maximum Length of Pair Chain (Medium)</li> <li> 1520. Maximum Number of Non-Overlapping Substrings (Hard)</li> <li> 3458. Select K Disjoint Special Substrings (Medium)</li> </ul>"},{"location":"endlesscheng/non-overlapping_intervals/#435-non-overlapping-intervals","title":"435. Non-overlapping Intervals","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy, sorting</p> </li> </ul> 435. Non-overlapping Intervals - Python Solution<pre><code>from typing import List\n\n\ndef eraseOverlapIntervals(intervals: List[List[int]]) -&gt; int:\n    if len(intervals) &lt;= 1:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n    result = 0\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &gt;= intervals[i - 1][1]:\n            continue\n        else:\n            result += 1\n            intervals[i][1] = min(intervals[i][1], intervals[i - 1][1])\n\n    return result\n\n\nprint(eraseOverlapIntervals([[1, 2], [2, 3], [3, 4], [1, 3]]))  # 1\n</code></pre>"},{"location":"endlesscheng/non-overlapping_intervals/#646-maximum-length-of-pair-chain","title":"646. Maximum Length of Pair Chain","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/non-overlapping_intervals/#1520-maximum-number-of-non-overlapping-substrings","title":"1520. Maximum Number of Non-Overlapping Substrings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, greedy</p> </li> </ul>"},{"location":"endlesscheng/non-overlapping_intervals/#3458-select-k-disjoint-special-substrings","title":"3458. Select K Disjoint Special Substrings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, dynamic programming, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/offline_algorithm/","title":"Offline Algorithm","text":"<ul> <li> 2343. Query Kth Smallest Trimmed Number (Medium)</li> <li> 2070. Most Beautiful Item for Each Query (Medium)</li> <li> 1847. Closest Room (Hard)</li> <li> 2503. Maximum Number of Points From Grid Queries (Hard)</li> <li> 1851. Minimum Interval to Include Each Query (Hard)</li> <li> 1697. Checking Existence of Edge Length Limited Paths (Hard)</li> <li> 2940. Find Building Where Alice and Bob Can Meet (Hard)</li> <li> 2747. Count Zero Request Servers (Medium)</li> <li> 1938. Maximum Genetic Difference Query (Hard)</li> <li> 2736. Maximum Sum Queries (Hard)</li> <li> 3382. Maximum Area Rectangle With Point Constraints II (Hard)</li> </ul>"},{"location":"endlesscheng/offline_algorithm/#2343-query-kth-smallest-trimmed-number","title":"2343. Query Kth Smallest Trimmed Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, divide and conquer, sorting, heap priority queue, radix sort, quickselect</p> </li> </ul>"},{"location":"endlesscheng/offline_algorithm/#2070-most-beautiful-item-for-each-query","title":"2070. Most Beautiful Item for Each Query","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sorting</p> </li> </ul>"},{"location":"endlesscheng/offline_algorithm/#1847-closest-room","title":"1847. Closest Room","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, sorting, ordered set</p> </li> </ul>"},{"location":"endlesscheng/offline_algorithm/#2503-maximum-number-of-points-from-grid-queries","title":"2503. Maximum Number of Points From Grid Queries","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, breadth first search, union find, sorting, heap priority queue, matrix</p> </li> </ul>"},{"location":"endlesscheng/offline_algorithm/#1851-minimum-interval-to-include-each-query","title":"1851. Minimum Interval to Include Each Query","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, line sweep, sorting, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/offline_algorithm/#1697-checking-existence-of-edge-length-limited-paths","title":"1697. Checking Existence of Edge Length Limited Paths","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, union find, graph, sorting</p> </li> </ul>"},{"location":"endlesscheng/offline_algorithm/#2940-find-building-where-alice-and-bob-can-meet","title":"2940. Find Building Where Alice and Bob Can Meet","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, stack, binary indexed tree, segment tree, heap priority queue, monotonic stack</p> </li> </ul>"},{"location":"endlesscheng/offline_algorithm/#2747-count-zero-request-servers","title":"2747. Count Zero Request Servers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, sliding window, sorting</p> </li> </ul>"},{"location":"endlesscheng/offline_algorithm/#1938-maximum-genetic-difference-query","title":"1938. Maximum Genetic Difference Query","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, bit manipulation, depth first search, trie</p> </li> </ul>"},{"location":"endlesscheng/offline_algorithm/#2736-maximum-sum-queries","title":"2736. Maximum Sum Queries","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, stack, binary indexed tree, segment tree, sorting, monotonic stack</p> </li> </ul>"},{"location":"endlesscheng/offline_algorithm/#3382-maximum-area-rectangle-with-point-constraints-ii","title":"3382. Maximum Area Rectangle With Point Constraints II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, binary indexed tree, segment tree, geometry, sorting</p> </li> </ul>"},{"location":"endlesscheng/one_sequence_two_pointers_backward/","title":"One Sequence Two Pointers Backward","text":"<ul> <li> 1793. Maximum Score of a Good Subarray (Hard)</li> </ul>"},{"location":"endlesscheng/one_sequence_two_pointers_backward/#1793-maximum-score-of-a-good-subarray","title":"1793. Maximum Score of a Good Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, binary search, stack, monotonic stack</p> </li> </ul>"},{"location":"endlesscheng/one_sequence_two_pointers_in-place_modification/","title":"One Sequence Two Pointers In-Place Modification","text":"<ul> <li> 27. Remove Element (Easy)</li> <li> 26. Remove Duplicates from Sorted Array (Easy)</li> <li> 80. Remove Duplicates from Sorted Array II (Medium)</li> <li> 283. Move Zeroes (Easy)</li> <li> 905. Sort Array By Parity (Easy)</li> <li> 922. Sort Array By Parity II (Easy)</li> <li> 2460. Apply Operations to an Array (Easy)</li> <li> 1089. Duplicate Zeros (Easy)</li> </ul>"},{"location":"endlesscheng/one_sequence_two_pointers_in-place_modification/#27-remove-element","title":"27. Remove Element","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers</p> </li> <li>Remove all instances of a given value in-place.</li> </ul> 27. Remove Element - Python Solution<pre><code>from typing import List\n\n\n# Fast Slow Pointers\ndef removeElement(nums: List[int], val: int) -&gt; int:\n    fast, slow = 0, 0\n\n    while fast &lt; len(nums):\n        if nums[fast] != val:\n            nums[slow] = nums[fast]\n            slow += 1\n        fast += 1\n\n    return slow\n\n\nnums = [0, 1, 2, 2, 3, 0, 4, 2]\nval = 2\nprint(removeElement(nums, val))  # 5\n</code></pre>"},{"location":"endlesscheng/one_sequence_two_pointers_in-place_modification/#26-remove-duplicates-from-sorted-array","title":"26. Remove Duplicates from Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers</p> </li> <li>Remove duplicates in-place.</li> </ul> 26. Remove Duplicates from Sorted Array - Python Solution<pre><code>from typing import List\n\n\ndef removeDuplicates(nums: List[int]) -&gt; int:\n    fast, slow = 1, 1\n\n    while fast &lt; len(nums):\n        if nums[fast] != nums[fast - 1]:\n            nums[slow] = nums[fast]\n            slow += 1\n        fast += 1\n\n    return slow\n\n\nnums = [1, 1, 2]\nprint(removeDuplicates(nums))  # 2\n</code></pre>"},{"location":"endlesscheng/one_sequence_two_pointers_in-place_modification/#80-remove-duplicates-from-sorted-array-ii","title":"80. Remove Duplicates from Sorted Array II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers</p> </li> <li>Allow at most two duplicates.</li> <li>fast pointer: explore the array</li> <li>slow pointer: point to the position to be replaced</li> </ul> 80. Remove Duplicates from Sorted Array II - Python Solution<pre><code>from typing import List\n\n\ndef removeDuplicates(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 2:\n        return len(nums)\n\n    fast, slow = 2, 2\n\n    while fast &lt; len(nums):\n        if nums[fast] != nums[slow - 2]:\n            nums[slow] = nums[fast]\n            slow += 1\n        fast += 1\n\n    return slow\n\n\nnums = [1, 1, 1, 2, 2, 3]\nprint(removeDuplicates(nums))\n</code></pre>"},{"location":"endlesscheng/one_sequence_two_pointers_in-place_modification/#283-move-zeroes","title":"283. Move Zeroes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers</p> </li> <li>Move all zeroes to the end of the array while maintaining the relative order of the non-zero elements.</li> </ul> 283. Move Zeroes - Python Solution<pre><code>from typing import List\n\n\ndef moveZeroes(nums: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    fast, slow = 0, 0\n\n    while fast &lt; len(nums):\n        if nums[fast] != 0:\n            nums[slow], nums[fast] = nums[fast], nums[slow]\n            slow += 1\n        fast += 1\n\n\nnums = [0, 1, 0, 3, 12]\nmoveZeroes(nums)\nprint(nums)  # [1, 3, 12, 0, 0]\n</code></pre>"},{"location":"endlesscheng/one_sequence_two_pointers_in-place_modification/#905-sort-array-by-parity","title":"905. Sort Array By Parity","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers, sorting</p> </li> </ul>"},{"location":"endlesscheng/one_sequence_two_pointers_in-place_modification/#922-sort-array-by-parity-ii","title":"922. Sort Array By Parity II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers, sorting</p> </li> </ul>"},{"location":"endlesscheng/one_sequence_two_pointers_in-place_modification/#2460-apply-operations-to-an-array","title":"2460. Apply Operations to an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers, simulation</p> </li> </ul>"},{"location":"endlesscheng/one_sequence_two_pointers_in-place_modification/#1089-duplicate-zeros","title":"1089. Duplicate Zeros","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers</p> </li> <li>Duplicate each occurrence of zero, shifting the remaining elements to the right.</li> </ul> 1089. Duplicate Zeros - Python Solution<pre><code>from typing import List\n\n\ndef duplicateZeros(arr: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify arr in-place instead.\n    \"\"\"\n    n = len(arr)\n    fast, slow = 0, 0\n\n    # First pass: find the position\n    # where the last element would be in the expanded array\n    while fast &lt; n:\n        if arr[slow] == 0:\n            fast += 1\n        slow += 1\n        fast += 1\n\n    slow -= 1\n    fast -= 1\n\n    # Second pass: move elements backwards\n    while slow &gt;= 0:\n        if fast &lt; n:\n            arr[fast] = arr[slow]\n\n        if arr[slow] == 0:\n            fast -= 1\n            if fast &lt; n:\n                arr[fast] = 0\n\n        slow -= 1\n        fast -= 1\n\n\narr = [1, 0, 2, 3, 0, 4, 5, 0]\nduplicateZeros(arr)\nprint(arr)  # [1, 0, 0, 2, 3, 0, 0, 4]\n</code></pre>"},{"location":"endlesscheng/one_sequence_two_pointers_opposite_direction/","title":"One Sequence Two Pointers Opposite Direction","text":"<ul> <li> 344. Reverse String (Easy)</li> <li> 125. Valid Palindrome (Easy)</li> <li> 1750. Minimum Length of String After Deleting Similar Ends (Medium)</li> <li> 2105. Watering Plants II (Medium)</li> <li> 977. Squares of a Sorted Array (Easy)</li> <li> 658. Find K Closest Elements (Medium)</li> <li> 1471. The k Strongest Values in an Array (Medium)</li> <li> 167. Two Sum II - Input Array Is Sorted (Medium)</li> <li> 633. Sum of Square Numbers (Medium)</li> <li> 2824. Count Pairs Whose Sum is Less than Target (Easy)</li> <li> 15. 3Sum (Medium)</li> <li> 16. 3Sum Closest (Medium)</li> <li> 18. 4Sum (Medium)</li> <li> 611. Valid Triangle Number (Medium)</li> <li> 1577. Number of Ways Where Square of Number Is Equal to Product of Two Numbers (Medium)</li> <li> 923. 3Sum With Multiplicity (Medium)</li> <li> 948. Bag of Tokens (Medium)</li> <li> 11. Container With Most Water (Medium)</li> <li> 42. Trapping Rain Water (Hard)</li> <li> 1616. Split Two Strings to Make Palindrome (Medium)</li> <li> 1498. Number of Subsequences That Satisfy the Given Sum Condition (Medium)</li> <li> 1782. Count Pairs Of Nodes (Hard)</li> <li> 1099. Two Sum Less Than K (Easy)</li> <li> 360. Sort Transformed Array (Medium)</li> <li> 2422. Merge Operations to Turn Array Into a Palindrome (Medium)</li> <li> 259. 3Sum Smaller (Medium)</li> </ul>"},{"location":"endlesscheng/one_sequence_two_pointers_opposite_direction/#344-reverse-string","title":"344. Reverse String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string</p> </li> </ul> 344. Reverse String - Python Solution<pre><code>from typing import List\n\n\ndef reverseString(s: List[str]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify s in-place instead.\n    \"\"\"\n    left, right = 0, len(s) - 1\n\n    while left &lt; right:\n        s[left], s[right] = s[right], s[left]\n        left += 1\n        right -= 1\n\n\ns = [\"h\", \"e\", \"l\", \"l\", \"o\"]\nreverseString(s)\nprint(s)  # ['o', 'l', 'l', 'e', 'h']\n</code></pre>"},{"location":"endlesscheng/one_sequence_two_pointers_opposite_direction/#125-valid-palindrome","title":"125. Valid Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string</p> </li> </ul> 125. Valid Palindrome - Python Solution<pre><code># List Comprehension\ndef isPalindrome(s: str) -&gt; bool:\n    s = [char.lower() for char in s if char.isalnum()]\n    return s == s[::-1]\n\n\n# Left Right Pointers\ndef isPalindromeLR(s: str) -&gt; bool:\n    left, right = 0, len(s) - 1\n\n    while left &lt; right:\n        while left &lt; right and not s[left].isalnum():\n            left += 1\n        while left &lt; right and not s[right].isalnum():\n            right -= 1\n\n        if s[left].lower() != s[right].lower():\n            return False\n\n        left += 1\n        right -= 1\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\ns = \"A man, a plan, a canal: Panama\"\nprint(isPalindrome(s))  # True\nprint(isPalindromeLR(s))  # True\n</code></pre>"},{"location":"endlesscheng/one_sequence_two_pointers_opposite_direction/#1750-minimum-length-of-string-after-deleting-similar-ends","title":"1750. Minimum Length of String After Deleting Similar Ends","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string</p> </li> </ul>"},{"location":"endlesscheng/one_sequence_two_pointers_opposite_direction/#2105-watering-plants-ii","title":"2105. Watering Plants II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, simulation</p> </li> </ul>"},{"location":"endlesscheng/one_sequence_two_pointers_opposite_direction/#977-squares-of-a-sorted-array","title":"977. Squares of a Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers, sorting</p> </li> </ul> 977. Squares of a Sorted Array - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef sortedSquares(nums: List[int]) -&gt; List[int]:\n    \"\"\"Returns the squares of the sorted array.\"\"\"\n    n = len(nums)\n    result = [0 for _ in range(n)]\n\n    left, right, tail = 0, n - 1, n - 1\n\n    while left &lt;= right:\n        if abs(nums[left]) &gt;= abs(nums[right]):\n            result[tail] = nums[left] ** 2\n            left += 1\n        else:\n            result[tail] = nums[right] ** 2\n            right -= 1\n        tail -= 1\n\n    return result\n\n\n# |---------------------|------|-------|\n# | Approach            | Time | Space |\n# |---------------------|------|-------|\n# | Left Right Pointers | O(n) | O(n)  |\n# |---------------------|------|-------|\n\n\nnums = [-4, -1, 0, 3, 10]\nprint(sortedSquares(nums))  # [0, 1, 9, 16, 100]\n</code></pre>"},{"location":"endlesscheng/one_sequence_two_pointers_opposite_direction/#658-find-k-closest-elements","title":"658. Find K Closest Elements","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, sliding window, sorting, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/one_sequence_two_pointers_opposite_direction/#1471-the-k-strongest-values-in-an-array","title":"1471. The k Strongest Values in an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, sorting</p> </li> </ul>"},{"location":"endlesscheng/one_sequence_two_pointers_opposite_direction/#167-two-sum-ii-input-array-is-sorted","title":"167. Two Sum II - Input Array Is Sorted","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search</p> </li> </ul> 167. Two Sum II - Input Array Is Sorted - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef twoSum(numbers: List[int], target: int) -&gt; List[int]:\n    left, right = 0, len(numbers) - 1\n\n    while left &lt; right:\n        total = numbers[left] + numbers[right]\n\n        if total &gt; target:\n            right -= 1\n        elif total &lt; target:\n            left += 1\n        else:\n            return [left + 1, right + 1]\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nnumbers = [2, 7, 11, 15]\ntarget = 9\nprint(twoSum(numbers, target))  # [1, 2]\n</code></pre>"},{"location":"endlesscheng/one_sequence_two_pointers_opposite_direction/#633-sum-of-square-numbers","title":"633. Sum of Square Numbers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, two pointers, binary search</p> </li> </ul>"},{"location":"endlesscheng/one_sequence_two_pointers_opposite_direction/#2824-count-pairs-whose-sum-is-less-than-target","title":"2824. Count Pairs Whose Sum is Less than Target","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers, binary search, sorting</p> </li> </ul>"},{"location":"endlesscheng/one_sequence_two_pointers_opposite_direction/#15-3sum","title":"15. 3Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, sorting</p> </li> </ul> 15. 3Sum - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef threeSum(nums: List[int]) -&gt; List[List[int]]:\n    nums.sort()\n    res = []\n    n = len(nums)\n\n    for i in range(n - 2):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        left, right = i + 1, n - 1\n\n        while left &lt; right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total &gt; 0:\n                right -= 1\n            elif total &lt; 0:\n                left += 1\n            else:\n                res.append([nums[i], nums[left], nums[right]])\n\n                while left &lt; right and nums[left] == nums[left + 1]:\n                    left += 1\n\n                while left &lt; right and nums[right] == nums[right - 1]:\n                    right -= 1\n\n                left += 1\n                right -= 1\n\n    return res\n\n\nnums = [-1, 0, 1, 2, -1, -4]\nassert threeSum(nums) == [[-1, -1, 2], [-1, 0, 1]]\n</code></pre>"},{"location":"endlesscheng/one_sequence_two_pointers_opposite_direction/#16-3sum-closest","title":"16. 3Sum Closest","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, sorting</p> </li> </ul> 16. 3Sum Closest - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef threeSumClosest(nums: List[int], target: int) -&gt; int:\n    nums.sort()\n    n = len(nums)\n    res = 0\n    minDiff = float(\"inf\")\n\n    for i in range(n - 2):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        left, right = i + 1, n - 1\n\n        while left &lt; right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total &gt; target:\n                if total - target &lt; minDiff:\n                    minDiff = total - target\n                    res = total\n                right -= 1\n\n            elif total &lt; target:\n                if target - total &lt; minDiff:\n                    minDiff = target - total\n                    res = total\n                left += 1\n\n            else:\n                return total\n\n    return res\n\n\nnums = [-1, 2, 1, -4]\ntarget = 1\nassert threeSumClosest(nums, target) == 2\n</code></pre>"},{"location":"endlesscheng/one_sequence_two_pointers_opposite_direction/#18-4sum","title":"18. 4Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, sorting</p> </li> </ul> 18. 4Sum - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef fourSum(nums: List[int], target: int) -&gt; List[List[int]]:\n    \"\"\"Returns all unique quadruplets that sum up to the target.\"\"\"\n    nums.sort()\n    result = []\n\n    for i in range(len(nums) - 3):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        for j in range(i + 1, len(nums) - 2):\n            if j &gt; i + 1 and nums[j] == nums[j - 1]:\n                continue\n\n            left = j + 1\n            right = len(nums) - 1\n\n            while left &lt; right:\n                total = nums[i] + nums[j] + nums[left] + nums[right]\n\n                if total &gt; target:\n                    right -= 1\n                elif total &lt; target:\n                    left += 1\n                else:\n                    result.append([nums[i], nums[j], nums[left], nums[right]])\n                    while left &lt; right and nums[left] == nums[left + 1]:\n                        left += 1\n                    while left &lt; right and nums[right] == nums[right - 1]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n\n    return result\n\n\nnums = [1, 0, -1, 0, -2, 2]\ntarget = 0\nprint(fourSum(nums, target))\n# [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]\n</code></pre>"},{"location":"endlesscheng/one_sequence_two_pointers_opposite_direction/#611-valid-triangle-number","title":"611. Valid Triangle Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/one_sequence_two_pointers_opposite_direction/#1577-number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers","title":"1577. Number of Ways Where Square of Number Is Equal to Product of Two Numbers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, two pointers</p> </li> </ul>"},{"location":"endlesscheng/one_sequence_two_pointers_opposite_direction/#923-3sum-with-multiplicity","title":"923. 3Sum With Multiplicity","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, two pointers, sorting, counting</p> </li> </ul>"},{"location":"endlesscheng/one_sequence_two_pointers_opposite_direction/#948-bag-of-tokens","title":"948. Bag of Tokens","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/one_sequence_two_pointers_opposite_direction/#11-container-with-most-water","title":"11. Container With Most Water","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy</p> </li> <li>Return the maximum area of water that can be trapped between the vertical lines.</li> </ul> <p></p> 11. Container With Most Water - Python Solution<pre><code>from typing import List\n\n\n# Brute Force\ndef maxAreaBF(height: List[int]) -&gt; int:\n    max_area = 0\n\n    for i in range(len(height)):\n        for j in range(i + 1, len(height)):\n            h = min(height[i], height[j])\n            w = j - i\n            max_area = max(max_area, h * w)\n\n    return max_area\n\n\n# Left Right Pointers\ndef maxAreaLR(height: List[int]) -&gt; int:\n    left, right = 0, len(height) - 1\n    res = 0\n\n    while left &lt; right:\n        h = min(height[left], height[right])\n        w = right - left\n        res = max(res, h * w)\n\n        if height[left] &lt; height[right]:\n            left += 1\n        else:\n            right -= 1\n\n    return res\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force| O(n^2) |  O(1)   |\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nheight = [1, 8, 6, 2, 5, 4, 8, 3, 7]\nprint(maxAreaBF(height))  # 49\nprint(maxAreaLR(height))  # 49\n</code></pre>"},{"location":"endlesscheng/one_sequence_two_pointers_opposite_direction/#42-trapping-rain-water","title":"42. Trapping Rain Water","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, dynamic programming, stack, monotonic stack</p> </li> <li></li> </ul> Approach Time Space DP O(N) O(N) Left Right O(N) O(1) Monotonic O(N) O(N) 42. Trapping Rain Water - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef trapDP(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    n = len(height)\n    maxLeft, maxRight = [0 for _ in range(n)], [0 for _ in range(n)]\n\n    for i in range(1, n):\n        maxLeft[i] = max(maxLeft[i - 1], height[i - 1])\n\n    for i in range(n - 2, -1, -1):\n        maxRight[i] = max(maxRight[i + 1], height[i + 1])\n\n    res = 0\n    for i in range(n):\n        res += max(0, min(maxLeft[i], maxRight[i]) - height[i])\n\n    return res\n\n\n# Left Right Pointers\ndef trapLR(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    left, right = 0, len(height) - 1\n    maxL, maxR = height[left], height[right]\n    res = 0\n\n    while left &lt; right:\n        if maxL &lt; maxR:\n            left += 1\n            maxL = max(maxL, height[left])\n            res += maxL - height[left]\n        else:\n            right -= 1\n            maxR = max(maxR, height[right])\n            res += maxR - height[right]\n\n    return res\n\n\n# Monotonic Stack\ndef trapStack(height: List[int]) -&gt; int:\n    stack = []\n    total = 0\n\n    for i in range(len(height)):\n        while stack and height[i] &gt; height[stack[-1]]:\n            top = stack.pop()\n            if not stack:\n                break\n            distance = i - stack[-1] - 1\n            bounded_height = min(height[i], height[stack[-1]]) - height[top]\n            total += distance * bounded_height\n        stack.append(i)\n\n    return total\n\n\nheight = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\nprint(trapDP(height))  # 6\nprint(trapLR(height))  # 6\nprint(trapStack(height))  # 6\n</code></pre>"},{"location":"endlesscheng/one_sequence_two_pointers_opposite_direction/#1616-split-two-strings-to-make-palindrome","title":"1616. Split Two Strings to Make Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string</p> </li> </ul>"},{"location":"endlesscheng/one_sequence_two_pointers_opposite_direction/#1498-number-of-subsequences-that-satisfy-the-given-sum-condition","title":"1498. Number of Subsequences That Satisfy the Given Sum Condition","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, sorting</p> </li> </ul>"},{"location":"endlesscheng/one_sequence_two_pointers_opposite_direction/#1782-count-pairs-of-nodes","title":"1782. Count Pairs Of Nodes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, binary search, graph, sorting</p> </li> </ul>"},{"location":"endlesscheng/one_sequence_two_pointers_opposite_direction/#1099-two-sum-less-than-k","title":"1099. Two Sum Less Than K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers, binary search, sorting</p> </li> </ul>"},{"location":"endlesscheng/one_sequence_two_pointers_opposite_direction/#360-sort-transformed-array","title":"360. Sort Transformed Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, two pointers, sorting</p> </li> </ul>"},{"location":"endlesscheng/one_sequence_two_pointers_opposite_direction/#2422-merge-operations-to-turn-array-into-a-palindrome","title":"2422. Merge Operations to Turn Array Into a Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy</p> </li> </ul>"},{"location":"endlesscheng/one_sequence_two_pointers_opposite_direction/#259-3sum-smaller","title":"259. 3Sum Smaller","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, sorting</p> </li> </ul>"},{"location":"endlesscheng/one_sequence_two_pointers_same_direction/","title":"One Sequence Two Pointers Same Direction","text":"<ul> <li> 1574. Shortest Subarray to be Removed to Make Array Sorted (Medium)</li> <li> 2972. Count the Number of Incremovable Subarrays II (Hard)</li> <li> 2122. Recover the Original Array (Hard)</li> <li> 2234. Maximum Total Beauty of the Gardens (Hard)</li> <li> 3323. Minimize Connected Groups by Inserting Interval (Medium)</li> <li> 581. Shortest Unsorted Continuous Subarray (Medium)</li> </ul>"},{"location":"endlesscheng/one_sequence_two_pointers_same_direction/#1574-shortest-subarray-to-be-removed-to-make-array-sorted","title":"1574. Shortest Subarray to be Removed to Make Array Sorted","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, stack, monotonic stack</p> </li> </ul>"},{"location":"endlesscheng/one_sequence_two_pointers_same_direction/#2972-count-the-number-of-incremovable-subarrays-ii","title":"2972. Count the Number of Incremovable Subarrays II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, binary search</p> </li> </ul>"},{"location":"endlesscheng/one_sequence_two_pointers_same_direction/#2122-recover-the-original-array","title":"2122. Recover the Original Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, two pointers, sorting, enumeration</p> </li> </ul>"},{"location":"endlesscheng/one_sequence_two_pointers_same_direction/#2234-maximum-total-beauty-of-the-gardens","title":"2234. Maximum Total Beauty of the Gardens","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, binary search, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/one_sequence_two_pointers_same_direction/#3323-minimize-connected-groups-by-inserting-interval","title":"3323. Minimize Connected Groups by Inserting Interval","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sliding window, sorting</p> </li> </ul>"},{"location":"endlesscheng/one_sequence_two_pointers_same_direction/#581-shortest-unsorted-continuous-subarray","title":"581. Shortest Unsorted Continuous Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, stack, greedy, sorting, monotonic stack</p> </li> </ul>"},{"location":"endlesscheng/other_interval_greedy/","title":"Other Interval Greedy","text":"<ul> <li> 1288. Remove Covered Intervals (Medium)</li> <li> 2054. Two Best Non-Overlapping Events (Medium)</li> <li> 1705. Maximum Number of Eaten Apples (Medium)</li> <li> 1353. Maximum Number of Events That Can Be Attended (Medium)</li> <li> 2589. Minimum Time to Complete All Tasks (Hard)</li> </ul>"},{"location":"endlesscheng/other_interval_greedy/#1288-remove-covered-intervals","title":"1288. Remove Covered Intervals","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sorting</p> </li> </ul>"},{"location":"endlesscheng/other_interval_greedy/#2054-two-best-non-overlapping-events","title":"2054. Two Best Non-Overlapping Events","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, dynamic programming, sorting, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/other_interval_greedy/#1705-maximum-number-of-eaten-apples","title":"1705. Maximum Number of Eaten Apples","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/other_interval_greedy/#1353-maximum-number-of-events-that-can-be-attended","title":"1353. Maximum Number of Events That Can Be Attended","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/other_interval_greedy/#2589-minimum-time-to-complete-all-tasks","title":"2589. Minimum Time to Complete All Tasks","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, stack, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/other_math_greedy/","title":"Other Math Greedy","text":"<ul> <li> 1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K (Medium)</li> <li> 3107. Minimum Operations to Make Median of Array Equal to K (Medium)</li> <li> 754. Reach a Number (Medium)</li> <li> 1058. Minimize Rounding Error to Meet Target (Medium)</li> </ul>"},{"location":"endlesscheng/other_math_greedy/#1414-find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k","title":"1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, greedy</p> </li> </ul>"},{"location":"endlesscheng/other_math_greedy/#3107-minimum-operations-to-make-median-of-array-equal-to-k","title":"3107. Minimum Operations to Make Median of Array Equal to K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/other_math_greedy/#754-reach-a-number","title":"754. Reach a Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, binary search</p> </li> </ul>"},{"location":"endlesscheng/other_math_greedy/#1058-minimize-rounding-error-to-meet-target","title":"1058. Minimize Rounding Error to Meet Target","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, string, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/palindrome_greedy/","title":"Palindrome Greedy","text":"<ul> <li> 409. Longest Palindrome (Easy)</li> <li> 2697. Lexicographically Smallest Palindrome (Easy)</li> <li> 680. Valid Palindrome II (Easy)</li> <li> 1328. Break a Palindrome (Medium)</li> <li> 1400. Construct K Palindrome Strings (Medium)</li> <li> 2131. Longest Palindrome by Concatenating Two Letter Words (Medium)</li> <li> 2384. Largest Palindromic Number (Medium)</li> <li> 3035. Maximum Palindromes After Operations (Medium)</li> <li> 1616. Split Two Strings to Make Palindrome (Medium)</li> <li> 1147. Longest Chunked Palindrome Decomposition (Hard)</li> <li> 2193. Minimum Number of Moves to Make Palindrome (Hard)</li> <li> 564. Find the Closest Palindrome (Hard)</li> <li> 266. Palindrome Permutation (Easy)</li> <li> 2422. Merge Operations to Turn Array Into a Palindrome (Medium)</li> <li> 1842. Next Palindrome Using Same Digits (Hard)</li> <li> 3088. Make String Anti-palindrome (Hard)</li> </ul>"},{"location":"endlesscheng/palindrome_greedy/#409-longest-palindrome","title":"409. Longest Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, string, greedy</p> </li> <li>Return the length of the longest palindrome that can be built with the characters in the string.</li> </ul> 409. Longest Palindrome - Python Solution<pre><code>def longestPalindrome(s: str) -&gt; int:\n    hashmap = dict()\n    result = 0\n\n    for char in s:\n        if char not in hashmap or hashmap[char] == 0:\n            hashmap[char] = 1\n        else:\n            result += 2\n            hashmap[char] = 0\n\n    if any(hashmap.values()):\n        result += 1\n\n    return result\n\n\nprint(longestPalindrome(\"abccccdd\"))  # 7\n</code></pre>"},{"location":"endlesscheng/palindrome_greedy/#2697-lexicographically-smallest-palindrome","title":"2697. Lexicographically Smallest Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string, greedy</p> </li> </ul>"},{"location":"endlesscheng/palindrome_greedy/#680-valid-palindrome-ii","title":"680. Valid Palindrome II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string, greedy</p> </li> </ul>"},{"location":"endlesscheng/palindrome_greedy/#1328-break-a-palindrome","title":"1328. Break a Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, greedy</p> </li> </ul>"},{"location":"endlesscheng/palindrome_greedy/#1400-construct-k-palindrome-strings","title":"1400. Construct K Palindrome Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, greedy, counting</p> </li> </ul>"},{"location":"endlesscheng/palindrome_greedy/#2131-longest-palindrome-by-concatenating-two-letter-words","title":"2131. Longest Palindrome by Concatenating Two Letter Words","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, greedy, counting</p> </li> </ul>"},{"location":"endlesscheng/palindrome_greedy/#2384-largest-palindromic-number","title":"2384. Largest Palindromic Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, greedy, counting</p> </li> </ul>"},{"location":"endlesscheng/palindrome_greedy/#3035-maximum-palindromes-after-operations","title":"3035. Maximum Palindromes After Operations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, greedy, sorting, counting</p> </li> </ul>"},{"location":"endlesscheng/palindrome_greedy/#1616-split-two-strings-to-make-palindrome","title":"1616. Split Two Strings to Make Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string</p> </li> </ul>"},{"location":"endlesscheng/palindrome_greedy/#1147-longest-chunked-palindrome-decomposition","title":"1147. Longest Chunked Palindrome Decomposition","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: two pointers, string, dynamic programming, greedy, rolling hash, hash function</p> </li> </ul>"},{"location":"endlesscheng/palindrome_greedy/#2193-minimum-number-of-moves-to-make-palindrome","title":"2193. Minimum Number of Moves to Make Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: two pointers, string, greedy, binary indexed tree</p> </li> </ul>"},{"location":"endlesscheng/palindrome_greedy/#564-find-the-closest-palindrome","title":"564. Find the Closest Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, string</p> </li> </ul>"},{"location":"endlesscheng/palindrome_greedy/#266-palindrome-permutation","title":"266. Palindrome Permutation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, string, bit manipulation</p> </li> </ul> 266. Palindrome Permutation - Python Solution<pre><code>from collections import defaultdict\n\n\n# Hash\ndef canPermutePalindromeDict(s: str) -&gt; bool:\n    if len(s) == 1:\n        return True\n\n    count = defaultdict(int)\n\n    for ch in s:\n        if count[ch] == 1:\n            count[ch] = 0\n            continue\n        count[ch] = 1\n\n    return sum(count.values()) &lt;= 1\n\n\n# Set\ndef canPermutePalindromeSet(s: str) -&gt; bool:\n    if len(s) == 1:\n        return True\n\n    seen = set()\n\n    for ch in s:\n        if ch in seen:\n            seen.remove(ch)\n        else:\n            seen.add(ch)\n\n    return len(seen) &lt;= 1\n\n\nassert canPermutePalindromeDict(\"carerac\") is True\nassert canPermutePalindromeSet(\"carerac\") is True\n</code></pre>"},{"location":"endlesscheng/palindrome_greedy/#2422-merge-operations-to-turn-array-into-a-palindrome","title":"2422. Merge Operations to Turn Array Into a Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy</p> </li> </ul>"},{"location":"endlesscheng/palindrome_greedy/#1842-next-palindrome-using-same-digits","title":"1842. Next Palindrome Using Same Digits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: two pointers, string</p> </li> </ul>"},{"location":"endlesscheng/palindrome_greedy/#3088-make-string-anti-palindrome","title":"3088. Make String Anti-palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, greedy, sorting, counting sort</p> </li> </ul>"},{"location":"endlesscheng/partitioning_greedy/","title":"Partitioning Greedy","text":"<ul> <li> 1221. Split a String in Balanced Strings (Easy)</li> <li> 2405. Optimal Partition of String (Medium)</li> <li> 2294. Partition Array Such That Maximum Difference Is K (Medium)</li> <li> 2358. Maximum Number of Groups Entering a Competition (Medium)</li> <li> 2522. Partition String Into Substrings With Values at Most K (Medium)</li> <li> 1546. Maximum Number of Non-Overlapping Subarrays With Sum Equals Target (Medium)</li> <li> 2436. Minimum Split Into Subarrays With GCD Greater Than One (Medium)</li> <li> 2892. Minimizing Array After Replacing Pairs With Their Product (Medium)</li> </ul>"},{"location":"endlesscheng/partitioning_greedy/#1221-split-a-string-in-balanced-strings","title":"1221. Split a String in Balanced Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, greedy, counting</p> </li> </ul>"},{"location":"endlesscheng/partitioning_greedy/#2405-optimal-partition-of-string","title":"2405. Optimal Partition of String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, greedy</p> </li> </ul>"},{"location":"endlesscheng/partitioning_greedy/#2294-partition-array-such-that-maximum-difference-is-k","title":"2294. Partition Array Such That Maximum Difference Is K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/partitioning_greedy/#2358-maximum-number-of-groups-entering-a-competition","title":"2358. Maximum Number of Groups Entering a Competition","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, binary search, greedy</p> </li> </ul>"},{"location":"endlesscheng/partitioning_greedy/#2522-partition-string-into-substrings-with-values-at-most-k","title":"2522. Partition String Into Substrings With Values at Most K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming, greedy</p> </li> </ul>"},{"location":"endlesscheng/partitioning_greedy/#1546-maximum-number-of-non-overlapping-subarrays-with-sum-equals-target","title":"1546. Maximum Number of Non-Overlapping Subarrays With Sum Equals Target","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, greedy, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/partitioning_greedy/#2436-minimum-split-into-subarrays-with-gcd-greater-than-one","title":"2436. Minimum Split Into Subarrays With GCD Greater Than One","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, dynamic programming, greedy, number theory</p> </li> </ul>"},{"location":"endlesscheng/partitioning_greedy/#2892-minimizing-array-after-replacing-pairs-with-their-product","title":"2892. Minimizing Array After Replacing Pairs With Their Product","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> </ul>"},{"location":"endlesscheng/prefix_sum_basics/","title":"Prefix Sum Basics","text":"<ul> <li> 303. Range Sum Query - Immutable (Easy)</li> <li> 3427. Sum of Variable Length Subarrays (Easy)</li> <li> 2559. Count Vowel Strings in Ranges (Medium)</li> <li> 3152. Special Array II (Medium)</li> <li> 1749. Maximum Absolute Sum of Any Subarray (Medium)</li> <li> 2389. Longest Subsequence With Limited Sum (Easy)</li> <li> 3361. Shift Distance Between Two Strings (Medium)</li> <li> 2055. Plates Between Candles (Medium)</li> <li> 1744. Can You Eat Your Favorite Candy on Your Favorite Day? (Medium)</li> <li> 53. Maximum Subarray (Medium)</li> <li> 1523. Count Odd Numbers in an Interval Range (Easy)</li> </ul>"},{"location":"endlesscheng/prefix_sum_basics/#303-range-sum-query-immutable","title":"303. Range Sum Query - Immutable","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, design, prefix sum</p> </li> </ul> 303. Range Sum Query - Immutable - Python Solution<pre><code>from typing import List\n\n\nclass NumArray:\n\n    def __init__(self, nums: List[int]):\n        self.prefix_sum = [0 for _ in range(len(nums) + 1)]\n\n        for i in range(1, len(nums) + 1):\n            self.prefix_sum[i] = self.prefix_sum[i - 1] + nums[i - 1]\n\n    def sumRange(self, left: int, right: int) -&gt; int:\n        return self.prefix_sum[right + 1] - self.prefix_sum[left]\n\n\nnums = [-2, 0, 3, -5, 2, -1]\nobj = NumArray(nums)\nassert obj.sumRange(0, 2) == 1\nassert obj.sumRange(2, 5) == -1\nassert obj.sumRange(0, 5) == -3\nprint(\"PASSED\")\n</code></pre>"},{"location":"endlesscheng/prefix_sum_basics/#3427-sum-of-variable-length-subarrays","title":"3427. Sum of Variable Length Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/prefix_sum_basics/#2559-count-vowel-strings-in-ranges","title":"2559. Count Vowel Strings in Ranges","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/prefix_sum_basics/#3152-special-array-ii","title":"3152. Special Array II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/prefix_sum_basics/#1749-maximum-absolute-sum-of-any-subarray","title":"1749. Maximum Absolute Sum of Any Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"endlesscheng/prefix_sum_basics/#2389-longest-subsequence-with-limited-sum","title":"2389. Longest Subsequence With Limited Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, binary search, greedy, sorting, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/prefix_sum_basics/#3361-shift-distance-between-two-strings","title":"3361. Shift Distance Between Two Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/prefix_sum_basics/#2055-plates-between-candles","title":"2055. Plates Between Candles","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, binary search, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/prefix_sum_basics/#1744-can-you-eat-your-favorite-candy-on-your-favorite-day","title":"1744. Can You Eat Your Favorite Candy on Your Favorite Day?","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/prefix_sum_basics/#53-maximum-subarray","title":"53. Maximum Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, divide and conquer, dynamic programming</p> </li> </ul> 53. Maximum Subarray - Python Solution<pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxSubArrayDP(nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n\n    dp[0] = nums[0]\n    maxSum = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(\n            dp[i - 1] + nums[i],  # continue the previous subarray\n            nums[i],  # start a new subarray\n        )\n        maxSum = max(maxSum, dp[i])\n\n    return maxSum\n\n\n# Greedy\ndef maxSubArrayGreedy(nums: List[int]) -&gt; int:\n    max_sum = nums[0]\n    cur_sum = 0\n\n    for num in nums:\n        cur_sum = max(cur_sum + num, num)\n        max_sum = max(max_sum, cur_sum)\n\n    return max_sum\n\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArrayDP(nums))  # 6\nprint(maxSubArrayGreedy(nums))  # 6\n</code></pre>"},{"location":"endlesscheng/prefix_sum_basics/#1523-count-odd-numbers-in-an-interval-range","title":"1523. Count Odd Numbers in an Interval Range","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math</p> </li> </ul>"},{"location":"endlesscheng/prefix_sum_with_hash_table/","title":"Prefix Sum with Hash Table","text":"<ul> <li> 930. Binary Subarrays With Sum (Medium)</li> <li> 560. Subarray Sum Equals K (Medium)</li> <li> 1524. Number of Sub-arrays With Odd Sum (Medium)</li> <li> 974. Subarray Sums Divisible by K (Medium)</li> <li> 523. Continuous Subarray Sum (Medium)</li> <li> 437. Path Sum III (Medium)</li> <li> 2588. Count the Number of Beautiful Subarrays (Medium)</li> <li> 525. Contiguous Array (Medium)</li> <li> 3026. Maximum Good Subarray Sum (Medium)</li> <li> 1477. Find Two Non-overlapping Sub-arrays Each With Target Sum (Medium)</li> <li> 1546. Maximum Number of Non-Overlapping Subarrays With Sum Equals Target (Medium)</li> <li> 1124. Longest Well-Performing Interval (Medium)</li> <li> 3381. Maximum Subarray Sum With Length Divisible by K (Medium)</li> <li> 2488. Count Subarrays With Median K (Hard)</li> <li> 1590. Make Sum Divisible by P (Medium)</li> <li> 2845. Count of Interesting Subarrays (Medium)</li> <li> 1442. Count Triplets That Can Form Two Arrays of Equal XOR (Medium)</li> <li> 2949. Count Beautiful Substrings II (Hard)</li> <li> 325. Maximum Size Subarray Sum Equals k (Medium)</li> <li> 548. Split Array with Equal Sum (Hard)</li> <li> 1983. Widest Pair of Indices With Equal Range Sum (Medium)</li> <li> 2489. Number of Substrings With Fixed Ratio (Medium)</li> <li> 2950. Number of Divisible Substrings (Medium)</li> <li> 3364. Minimum Positive Sum Subarray  (Easy)</li> <li> 2025. Maximum Number of Ways to Partition an Array (Hard)</li> </ul>"},{"location":"endlesscheng/prefix_sum_with_hash_table/#930-binary-subarrays-with-sum","title":"930. Binary Subarrays With Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, sliding window, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/prefix_sum_with_hash_table/#560-subarray-sum-equals-k","title":"560. Subarray Sum Equals K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, prefix sum</p> </li> </ul> 560. Subarray Sum Equals K - Python Solution<pre><code>from typing import List\n\n\n# 1. Prefix Sum\ndef subarraySum(nums: List[int], k: int) -&gt; int:\n    prefix_sums = {0: 1}\n    currentSum = 0\n    count = 0\n\n    for num in nums:\n        currentSum += num\n        if (currentSum - k) in prefix_sums:\n            count += prefix_sums[currentSum - k]\n\n        if currentSum in prefix_sums:\n            prefix_sums[currentSum] += 1\n        else:\n            prefix_sums[currentSum] = 1\n\n    return count\n\n\n# 2. Optimized Prefix Sum\ndef subarraySumOptimized(nums: List[int], k: int) -&gt; int:\n    prefixSum = 0\n    count = 0\n    prefix_sums = {0: 1}\n\n    for num in nums:\n        prefixSum += num\n        count += prefix_sums.get(prefixSum - k, 0)\n        prefix_sums[prefixSum] = prefix_sums.get(prefixSum, 0) + 1\n\n    return count\n\n\nnums = [1, 1, 1]\nk = 2\nprint(subarraySum(nums, k))  # 2\nprint(subarraySumOptimized(nums, k))  # 2\n</code></pre>"},{"location":"endlesscheng/prefix_sum_with_hash_table/#1524-number-of-sub-arrays-with-odd-sum","title":"1524. Number of Sub-arrays With Odd Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, dynamic programming, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/prefix_sum_with_hash_table/#974-subarray-sums-divisible-by-k","title":"974. Subarray Sums Divisible by K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, prefix sum</p> </li> </ul> 974. Subarray Sums Divisible by K - Python Solution<pre><code>from typing import List\n\n\ndef subarraysDivByK_1(nums: List[int], k: int) -&gt; int:\n    mods = {0: 1}\n    prefixSum, result = 0, 0\n\n    for num in nums:\n        prefixSum += num\n        mod = prefixSum % k\n\n        if mod &lt; 0:\n            mod += k\n\n        if mod in mods:\n            result += mods[mod]\n\n        if mod in mods:\n            mods[mod] += 1\n        else:\n            mods[mod] = 1\n\n    return result\n\n\ndef subarraysDivByK_2(nums: List[int], k: int) -&gt; int:\n    mods = {0: 1}\n    prefixSum, result = 0, 0\n\n    for num in nums:\n        prefixSum += num\n        mod = prefixSum % k\n        result += mods.get(mod, 0)\n        mods[mod] = mods.get(mod, 0) + 1\n\n    return result\n\n\nnums = [4, 5, 0, -2, -3, 1]\nk = 5\nprint(subarraysDivByK_1(nums, k))  # 7\nprint(subarraysDivByK_2(nums, k))  # 7\n</code></pre>"},{"location":"endlesscheng/prefix_sum_with_hash_table/#523-continuous-subarray-sum","title":"523. Continuous Subarray Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, prefix sum</p> </li> </ul> 523. Continuous Subarray Sum - Python Solution<pre><code>from typing import List\n\n\n# Prefix Sum\ndef checkSubarraySum(nums: List[int], k: int) -&gt; bool:\n    if k == 0:\n        for i in range(1, len(nums)):\n            if nums[i - 1] == 0 and nums[i] == 0:\n                return True\n\n    prefix_sum = 0\n    mod_dict = {0: -1}\n\n    for i, num in enumerate(nums):\n        prefix_sum += num\n        mod = prefix_sum % k\n\n        if mod in mod_dict:\n            if i - mod_dict[mod] &gt; 1:\n                return True\n        else:\n            mod_dict[mod] = i\n\n    return False\n\n\nnums = [23, 2, 4, 6, 7]\nk = 6\nprint(checkSubarraySum(nums, k))  # True\n</code></pre>"},{"location":"endlesscheng/prefix_sum_with_hash_table/#437-path-sum-iii","title":"437. Path Sum III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"endlesscheng/prefix_sum_with_hash_table/#2588-count-the-number-of-beautiful-subarrays","title":"2588. Count the Number of Beautiful Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, bit manipulation, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/prefix_sum_with_hash_table/#525-contiguous-array","title":"525. Contiguous Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/prefix_sum_with_hash_table/#3026-maximum-good-subarray-sum","title":"3026. Maximum Good Subarray Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/prefix_sum_with_hash_table/#1477-find-two-non-overlapping-sub-arrays-each-with-target-sum","title":"1477. Find Two Non-overlapping Sub-arrays Each With Target Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, binary search, dynamic programming, sliding window</p> </li> </ul>"},{"location":"endlesscheng/prefix_sum_with_hash_table/#1546-maximum-number-of-non-overlapping-subarrays-with-sum-equals-target","title":"1546. Maximum Number of Non-Overlapping Subarrays With Sum Equals Target","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, greedy, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/prefix_sum_with_hash_table/#1124-longest-well-performing-interval","title":"1124. Longest Well-Performing Interval","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, stack, monotonic stack, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/prefix_sum_with_hash_table/#3381-maximum-subarray-sum-with-length-divisible-by-k","title":"3381. Maximum Subarray Sum With Length Divisible by K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/prefix_sum_with_hash_table/#2488-count-subarrays-with-median-k","title":"2488. Count Subarrays With Median K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/prefix_sum_with_hash_table/#1590-make-sum-divisible-by-p","title":"1590. Make Sum Divisible by P","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/prefix_sum_with_hash_table/#2845-count-of-interesting-subarrays","title":"2845. Count of Interesting Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/prefix_sum_with_hash_table/#1442-count-triplets-that-can-form-two-arrays-of-equal-xor","title":"1442. Count Triplets That Can Form Two Arrays of Equal XOR","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, bit manipulation, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/prefix_sum_with_hash_table/#2949-count-beautiful-substrings-ii","title":"2949. Count Beautiful Substrings II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, math, string, number theory, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/prefix_sum_with_hash_table/#325-maximum-size-subarray-sum-equals-k","title":"325. Maximum Size Subarray Sum Equals k","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, prefix sum</p> </li> </ul> 325. Maximum Size Subarray Sum Equals k - Python Solution<pre><code>from typing import List\n\n\n# Prefix Sum\ndef maxSubArrayLen(nums: List[int], k: int) -&gt; int:\n    res = 0\n    prefix = 0\n    sumMap = {0: -1}  # sum -&gt; index\n\n    for i, num in enumerate(nums):\n        prefix += num\n        if prefix - k in sumMap:\n            res = max(res, i - sumMap[prefix - k])\n        if prefix not in sumMap:\n            sumMap[prefix] = i\n\n    return res\n\n\nnums = [1, -1, 5, -2, 3]\nk = 3\nprint(maxSubArrayLen(nums, k))  # 4\n</code></pre>"},{"location":"endlesscheng/prefix_sum_with_hash_table/#548-split-array-with-equal-sum","title":"548. Split Array with Equal Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/prefix_sum_with_hash_table/#1983-widest-pair-of-indices-with-equal-range-sum","title":"1983. Widest Pair of Indices With Equal Range Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/prefix_sum_with_hash_table/#2489-number-of-substrings-with-fixed-ratio","title":"2489. Number of Substrings With Fixed Ratio","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, math, string, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/prefix_sum_with_hash_table/#2950-number-of-divisible-substrings","title":"2950. Number of Divisible Substrings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, counting, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/prefix_sum_with_hash_table/#3364-minimum-positive-sum-subarray","title":"3364. Minimum Positive Sum Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, sliding window, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/prefix_sum_with_hash_table/#2025-maximum-number-of-ways-to-partition-an-array","title":"2025. Maximum Number of Ways to Partition an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, counting, enumeration, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/prefix_xor_sum/","title":"Prefix XOR Sum","text":"<ul> <li> 1177. Can Make Palindrome from Substring (Medium)</li> <li> 1371. Find the Longest Substring Containing Vowels in Even Counts (Medium)</li> <li> 1542. Find Longest Awesome Substring (Hard)</li> <li> 1915. Number of Wonderful Substrings (Medium)</li> <li> 2791. Count Paths That Can Form a Palindrome in a Tree (Hard)</li> </ul>"},{"location":"endlesscheng/prefix_xor_sum/#1177-can-make-palindrome-from-substring","title":"1177. Can Make Palindrome from Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, bit manipulation, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/prefix_xor_sum/#1371-find-the-longest-substring-containing-vowels-in-even-counts","title":"1371. Find the Longest Substring Containing Vowels in Even Counts","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, bit manipulation, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/prefix_xor_sum/#1542-find-longest-awesome-substring","title":"1542. Find Longest Awesome Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/prefix_xor_sum/#1915-number-of-wonderful-substrings","title":"1915. Number of Wonderful Substrings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, bit manipulation, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/prefix_xor_sum/#2791-count-paths-that-can-form-a-palindrome-in-a-tree","title":"2791. Count Paths That Can Form a Palindrome in a Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, bit manipulation, tree, depth first search, bitmask</p> </li> </ul>"},{"location":"endlesscheng/product_greedy/","title":"Product Greedy","text":"<ul> <li> 628. Maximum Product of Three Numbers (Easy)</li> <li> 1567. Maximum Length of Subarray With Positive Product (Medium)</li> </ul>"},{"location":"endlesscheng/product_greedy/#628-maximum-product-of-three-numbers","title":"628. Maximum Product of Three Numbers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, math, sorting</p> </li> </ul>"},{"location":"endlesscheng/product_greedy/#1567-maximum-length-of-subarray-with-positive-product","title":"1567. Maximum Length of Subarray With Positive Product","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> </ul>"},{"location":"endlesscheng/queue_basics/","title":"Queue Basics","text":"<ul> <li> 933. Number of Recent Calls (Easy)</li> <li> 950. Reveal Cards In Increasing Order (Medium)</li> <li> 649. Dota2 Senate (Medium)</li> <li> 346. Moving Average from Data Stream (Easy)</li> <li> 362. Design Hit Counter (Medium)</li> <li> 379. Design Phone Directory (Medium)</li> <li> 1429. First Unique Number (Medium)</li> <li> 2534. Time Taken to Cross the Door (Hard)</li> </ul>"},{"location":"endlesscheng/queue_basics/#933-number-of-recent-calls","title":"933. Number of Recent Calls","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: design, queue, data stream</p> </li> </ul>"},{"location":"endlesscheng/queue_basics/#950-reveal-cards-in-increasing-order","title":"950. Reveal Cards In Increasing Order","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, queue, sorting, simulation</p> </li> </ul>"},{"location":"endlesscheng/queue_basics/#649-dota2-senate","title":"649. Dota2 Senate","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, greedy, queue</p> </li> </ul>"},{"location":"endlesscheng/queue_basics/#346-moving-average-from-data-stream","title":"346. Moving Average from Data Stream","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, design, queue, data stream</p> </li> </ul>"},{"location":"endlesscheng/queue_basics/#362-design-hit-counter","title":"362. Design Hit Counter","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, design, queue, data stream</p> </li> </ul> 362. Design Hit Counter - Python Solution<pre><code>from collections import deque\n\n\nclass HitCounter:\n\n    def __init__(self):\n        self.hits = deque()\n\n    def hit(self, timestamp: int) -&gt; None:\n        self.hits.append(timestamp)\n\n    def getHits(self, timestamp: int) -&gt; int:\n        # Remove hits that are older than 5 minutes (300 seconds)\n        while self.hits and self.hits[0] &lt;= timestamp - 300:\n            self.hits.popleft()\n        return len(self.hits)\n\n\nobj = HitCounter()\nobj.hit(1)\nobj.hit(2)\nobj.hit(3)\nprint(obj.getHits(4))  # 3\nobj.hit(300)\nprint(obj.getHits(300))  # 4\nprint(obj.getHits(301))  # 3\n</code></pre>"},{"location":"endlesscheng/queue_basics/#379-design-phone-directory","title":"379. Design Phone Directory","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, linked list, design, queue</p> </li> </ul>"},{"location":"endlesscheng/queue_basics/#1429-first-unique-number","title":"1429. First Unique Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, design, queue, data stream</p> </li> </ul>"},{"location":"endlesscheng/queue_basics/#2534-time-taken-to-cross-the-door","title":"2534. Time Taken to Cross the Door","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, queue, simulation</p> </li> </ul>"},{"location":"endlesscheng/queue_design/","title":"Queue Design","text":"<ul> <li> 225. Implement Stack using Queues (Easy)</li> <li> 232. Implement Queue using Stacks (Easy)</li> <li> 622. Design Circular Queue (Medium)</li> <li> 641. Design Circular Deque (Medium)</li> <li> 1670. Design Front Middle Back Queue (Medium)</li> </ul>"},{"location":"endlesscheng/queue_design/#225-implement-stack-using-queues","title":"225. Implement Stack using Queues","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: stack, design, queue</p> </li> </ul> 225. Implement Stack using Queues - Python Solution<pre><code>from collections import deque\n\n\n# Queue\nclass MyStack:\n\n    def __init__(self):\n        self.q1 = deque()  # main queue\n        self.q2 = deque()  # auxiliary queue\n\n    def push(self, x: int) -&gt; None:\n        self.q1.append(x)\n\n    def pop(self) -&gt; int:\n        while len(self.q1) &gt; 1:\n            self.q2.append(self.q1.popleft())\n        res = self.q1.popleft()\n        self.q1, self.q2 = self.q2, self.q1\n        return res\n\n    def top(self) -&gt; int:\n        while len(self.q1) &gt; 1:\n            self.q2.append(self.q1.popleft())\n        res = self.q1[0]\n        self.q2.append(self.q1.popleft())\n        self.q1, self.q2 = self.q2, self.q1\n        return res\n\n    def empty(self) -&gt; bool:\n        return not self.q1\n\n\nobj = MyStack()\nobj.push(1)\nobj.push(2)\nobj.push(3)\nobj.push(4)\nprint(obj.pop())  # 4\nprint(obj.top())  # 3\nprint(obj.empty())  # False\nprint(obj.pop())  # 3\n</code></pre>"},{"location":"endlesscheng/queue_design/#232-implement-queue-using-stacks","title":"232. Implement Queue using Stacks","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: stack, design, queue</p> </li> <li>Implement the following operations of a queue using stacks.<ul> <li><code>push(x)</code> - Push element x to the back of queue.</li> <li><code>pop()</code> - Removes the element from in front of queue.</li> <li><code>peek()</code> - Get the front element.</li> <li><code>empty()</code> - Return whether the queue is empty.</li> </ul> </li> </ul> 232. Implement Queue using Stacks - Python Solution<pre><code>class MyQueue:\n    def __init__(self):\n        self.stack_in = []\n        self.stack_out = []\n\n    def push(self, x: int) -&gt; None:\n        self.stack_in.append(x)\n\n    def pop(self) -&gt; int:\n        if self.empty():\n            return None\n\n        if self.stack_out:\n            return self.stack_out.pop()\n        else:\n            for _ in range(len(self.stack_in)):\n                self.stack_out.append(self.stack_in.pop())\n            return self.stack_out.pop()\n\n    def peek(self) -&gt; int:\n        answer = self.pop()\n        self.stack_out.append(answer)\n        return answer\n\n    def empty(self) -&gt; bool:\n        return not (self.stack_in or self.stack_out)\n\n\nobj = MyQueue()\nobj.push(1)\nprint(obj.pop())  # 1\nprint(obj.peek())  # None\nprint(obj.empty())  # False\n</code></pre>"},{"location":"endlesscheng/queue_design/#622-design-circular-queue","title":"622. Design Circular Queue","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, linked list, design, queue</p> </li> </ul> 622. Design Circular Queue - Python Solution<pre><code># Design\nclass MyCircularQueue:\n\n    def __init__(self, k: int):\n        self.queue = [0] * k\n        self.head = 0\n        self.tail = -1\n        self.size = 0\n        self.capacity = k\n\n    def enQueue(self, value: int) -&gt; bool:\n        if self.isFull():\n            return False\n        self.tail = (self.tail + 1) % self.capacity\n        self.queue[self.tail] = value\n        self.size += 1\n        return True\n\n    def deQueue(self) -&gt; bool:\n        if self.isEmpty():\n            return False\n        self.head = (self.head + 1) % self.capacity\n        self.size -= 1\n        return True\n\n    def Front(self) -&gt; int:\n        if self.isEmpty():\n            return -1\n        return self.queue[self.head]\n\n    def Rear(self) -&gt; int:\n        if self.isEmpty():\n            return -1\n        return self.queue[self.tail]\n\n    def isEmpty(self) -&gt; bool:\n        return self.size == 0\n\n    def isFull(self) -&gt; bool:\n        return self.size == self.capacity\n\n\nobj = MyCircularQueue(3)\nprint(obj.enQueue(1))  # True\nprint(obj.enQueue(2))  # True\nprint(obj.enQueue(3))  # True\nprint(obj.enQueue(4))  # False\nprint(obj.Rear())  # 3\nprint(obj.isFull())  # True\nprint(obj.deQueue())  # True\n</code></pre>"},{"location":"endlesscheng/queue_design/#641-design-circular-deque","title":"641. Design Circular Deque","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, linked list, design, queue</p> </li> </ul>"},{"location":"endlesscheng/queue_design/#1670-design-front-middle-back-queue","title":"1670. Design Front Middle Back Queue","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, linked list, design, queue, data stream</p> </li> </ul>"},{"location":"endlesscheng/rectangle/","title":"Rectangle","text":"<ul> <li> 84. Largest Rectangle in Histogram (Hard)</li> <li> 1793. Maximum Score of a Good Subarray (Hard)</li> <li> 85. Maximal Rectangle (Hard)</li> <li> 1504. Count Submatrices With All Ones (Medium)</li> <li> 42. Trapping Rain Water (Hard)</li> <li> 755. Pour Water (Medium)</li> </ul>"},{"location":"endlesscheng/rectangle/#84-largest-rectangle-in-histogram","title":"84. Largest Rectangle in Histogram","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, stack, monotonic stack</p> </li> </ul> 84. Largest Rectangle in Histogram - Python Solution<pre><code>from typing import List\n\n\ndef largestRectangleArea(heights: List[int]) -&gt; int:\n    maxArea = 0\n    stack = []  # pair: (index, height)\n\n    for i, h in enumerate(heights):\n        start = i\n        while stack and stack[-1][1] &gt; h:\n            index, height = stack.pop()\n            maxArea = max(maxArea, height * (i - index))\n            start = index\n        stack.append((start, h))\n\n    for i, h in stack:\n        maxArea = max(maxArea, h * (len(heights) - i))\n\n    return maxArea\n\n\nprint(largestRectangleArea([2, 1, 5, 6, 2, 3]))  # 10\n</code></pre>"},{"location":"endlesscheng/rectangle/#1793-maximum-score-of-a-good-subarray","title":"1793. Maximum Score of a Good Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, binary search, stack, monotonic stack</p> </li> </ul>"},{"location":"endlesscheng/rectangle/#85-maximal-rectangle","title":"85. Maximal Rectangle","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, stack, matrix, monotonic stack</p> </li> <li>Return the area of the largest rectangle that can be formed within a rectangle of 1's.</li> </ul> <p></p> 85. Maximal Rectangle - Python Solution<pre><code>from typing import List\n\n\n# Monotonic Stack\ndef maximalRectangle(matrix: List[List[str]]) -&gt; int:\n    if not matrix or not matrix[0]:\n        return 0\n\n    n = len(matrix[0])\n    heights = [0] * (n + 1)\n    max_area = 0\n\n    for row in matrix:\n        for i in range(n):\n            if row[i] == \"1\":\n                heights[i] += 1\n            else:\n                heights[i] = 0\n\n        stack = [-1]\n        for i in range(n + 1):\n            while heights[i] &lt; heights[stack[-1]]:\n                h = heights[stack.pop()]\n                w = i - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            stack.append(i)\n\n    return max_area\n\n\nmatrix = [\n    [\"1\", \"0\", \"1\", \"0\", \"0\"],\n    [\"1\", \"0\", \"1\", \"1\", \"1\"],\n    [\"1\", \"1\", \"1\", \"1\", \"1\"],\n    [\"1\", \"0\", \"0\", \"1\", \"0\"],\n]\nprint(maximalRectangle(matrix))  # 6\n</code></pre>"},{"location":"endlesscheng/rectangle/#1504-count-submatrices-with-all-ones","title":"1504. Count Submatrices With All Ones","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, stack, matrix, monotonic stack</p> </li> </ul>"},{"location":"endlesscheng/rectangle/#42-trapping-rain-water","title":"42. Trapping Rain Water","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, dynamic programming, stack, monotonic stack</p> </li> <li></li> </ul> Approach Time Space DP O(N) O(N) Left Right O(N) O(1) Monotonic O(N) O(N) 42. Trapping Rain Water - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef trapDP(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    n = len(height)\n    maxLeft, maxRight = [0 for _ in range(n)], [0 for _ in range(n)]\n\n    for i in range(1, n):\n        maxLeft[i] = max(maxLeft[i - 1], height[i - 1])\n\n    for i in range(n - 2, -1, -1):\n        maxRight[i] = max(maxRight[i + 1], height[i + 1])\n\n    res = 0\n    for i in range(n):\n        res += max(0, min(maxLeft[i], maxRight[i]) - height[i])\n\n    return res\n\n\n# Left Right Pointers\ndef trapLR(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    left, right = 0, len(height) - 1\n    maxL, maxR = height[left], height[right]\n    res = 0\n\n    while left &lt; right:\n        if maxL &lt; maxR:\n            left += 1\n            maxL = max(maxL, height[left])\n            res += maxL - height[left]\n        else:\n            right -= 1\n            maxR = max(maxR, height[right])\n            res += maxR - height[right]\n\n    return res\n\n\n# Monotonic Stack\ndef trapStack(height: List[int]) -&gt; int:\n    stack = []\n    total = 0\n\n    for i in range(len(height)):\n        while stack and height[i] &gt; height[stack[-1]]:\n            top = stack.pop()\n            if not stack:\n                break\n            distance = i - stack[-1] - 1\n            bounded_height = min(height[i], height[stack[-1]]) - height[top]\n            total += distance * bounded_height\n        stack.append(i)\n\n    return total\n\n\nheight = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\nprint(trapDP(height))  # 6\nprint(trapLR(height))  # 6\nprint(trapStack(height))  # 6\n</code></pre>"},{"location":"endlesscheng/rectangle/#755-pour-water","title":"755. Pour Water","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, simulation</p> </li> </ul>"},{"location":"endlesscheng/regret_greedy/","title":"Regret Greedy","text":"<ul> <li> 1642. Furthest Building You Can Reach (Medium)</li> <li> 630. Course Schedule III (Hard)</li> <li> 871. Minimum Number of Refueling Stops (Hard)</li> <li> 3362. Zero Array Transformation III (Medium)</li> <li> 2813. Maximum Elegance of a K-Length Subsequence (Hard)</li> <li> 3049. Earliest Second to Mark Indices II (Hard)</li> <li> 2599. Make the Prefix Sum Non-negative (Medium)</li> <li> 2463. Minimum Total Distance Traveled (Hard)</li> </ul>"},{"location":"endlesscheng/regret_greedy/#1642-furthest-building-you-can-reach","title":"1642. Furthest Building You Can Reach","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/regret_greedy/#630-course-schedule-iii","title":"630. Course Schedule III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sorting, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/regret_greedy/#871-minimum-number-of-refueling-stops","title":"871. Minimum Number of Refueling Stops","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, greedy, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/regret_greedy/#3362-zero-array-transformation-iii","title":"3362. Zero Array Transformation III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting, heap priority queue, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/regret_greedy/#2813-maximum-elegance-of-a-k-length-subsequence","title":"2813. Maximum Elegance of a K-Length Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, stack, greedy, sorting, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/regret_greedy/#3049-earliest-second-to-mark-indices-ii","title":"3049. Earliest Second to Mark Indices II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, greedy, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/regret_greedy/#2599-make-the-prefix-sum-non-negative","title":"2599. Make the Prefix Sum Non-negative","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/regret_greedy/#2463-minimum-total-distance-traveled","title":"2463. Minimum Total Distance Traveled","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, sorting</p> </li> </ul>"},{"location":"endlesscheng/regret_heap/","title":"Regret Heap","text":"<ul> <li> 1642. Furthest Building You Can Reach (Medium)</li> <li> 630. Course Schedule III (Hard)</li> <li> 871. Minimum Number of Refueling Stops (Hard)</li> <li> 3362. Zero Array Transformation III (Medium)</li> <li> 2813. Maximum Elegance of a K-Length Subsequence (Hard)</li> <li> 3049. Earliest Second to Mark Indices II (Hard)</li> <li> 2599. Make the Prefix Sum Non-negative (Medium)</li> </ul>"},{"location":"endlesscheng/regret_heap/#1642-furthest-building-you-can-reach","title":"1642. Furthest Building You Can Reach","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/regret_heap/#630-course-schedule-iii","title":"630. Course Schedule III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sorting, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/regret_heap/#871-minimum-number-of-refueling-stops","title":"871. Minimum Number of Refueling Stops","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, greedy, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/regret_heap/#3362-zero-array-transformation-iii","title":"3362. Zero Array Transformation III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting, heap priority queue, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/regret_heap/#2813-maximum-elegance-of-a-k-length-subsequence","title":"2813. Maximum Elegance of a K-Length Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, stack, greedy, sorting, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/regret_heap/#3049-earliest-second-to-mark-indices-ii","title":"3049. Earliest Second to Mark Indices II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, greedy, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/regret_heap/#2599-make-the-prefix-sum-non-negative","title":"2599. Make the Prefix Sum Non-negative","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/reverse_thinking/","title":"Reverse Thinking","text":"<ul> <li> 2139. Minimum Moves to Reach Target Score (Medium)</li> <li> 1558. Minimum Numbers of Function Calls to Make Target Array (Medium)</li> <li> 554. Brick Wall (Medium)</li> <li> 2718. Sum of Matrix After Queries (Medium)</li> <li> 417. Pacific Atlantic Water Flow (Medium)</li> <li> 991. Broken Calculator (Medium)</li> <li> 2227. Encrypt and Decrypt Strings (Hard)</li> <li> 3419. Minimize the Maximum Edge Weight of Graph (Medium)</li> <li> 936. Stamping The Sequence (Hard)</li> </ul>"},{"location":"endlesscheng/reverse_thinking/#2139-minimum-moves-to-reach-target-score","title":"2139. Minimum Moves to Reach Target Score","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, greedy</p> </li> </ul>"},{"location":"endlesscheng/reverse_thinking/#1558-minimum-numbers-of-function-calls-to-make-target-array","title":"1558. Minimum Numbers of Function Calls to Make Target Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, bit manipulation</p> </li> </ul>"},{"location":"endlesscheng/reverse_thinking/#554-brick-wall","title":"554. Brick Wall","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table</p> </li> </ul>"},{"location":"endlesscheng/reverse_thinking/#2718-sum-of-matrix-after-queries","title":"2718. Sum of Matrix After Queries","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table</p> </li> </ul>"},{"location":"endlesscheng/reverse_thinking/#417-pacific-atlantic-water-flow","title":"417. Pacific Atlantic Water Flow","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, matrix</p> </li> </ul> 417. Pacific Atlantic Water Flow - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef pacificAtlanticDFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(r, c, visited, prev_height):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or heights[r][c] &lt; prev_height\n            or (r, c) in visited\n        ):\n            return None\n\n        visited.add((r, c))\n        height = heights[r][c]\n        for dr, dc in directions:\n            dfs(dr + r, dc + c, visited, height)\n\n    for c in range(n):\n        dfs(0, c, pac, heights[0][c])\n        dfs(m - 1, c, atl, heights[m - 1][c])\n\n    for r in range(m):\n        dfs(r, 0, pac, heights[r][0])\n        dfs(r, n - 1, atl, heights[r][n - 1])\n\n    return list(pac &amp; atl)\n\n\n# BFS\ndef pacificAtlanticBFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def bfs(r, c, visited):\n        q = deque([(r, c)])\n        visited.add((r, c))\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr in range(m)\n                    and nc in range(n)\n                    and heights[row][col] &lt;= heights[nr][nc]\n                    and (nr, nc) not in visited\n                ):\n                    q.append((nr, nc))\n                    visited.add((nr, nc))\n\n    for c in range(n):\n        bfs(0, c, pac)  # top\n        bfs(m - 1, c, atl)  # bottom\n\n    for r in range(m):\n        bfs(r, 0, pac)  # left\n        bfs(r, n - 1, atl)  # right\n\n    return list(pac &amp; atl)\n\n\nheights = [\n    [1, 2, 2, 3, 5],\n    [3, 2, 3, 4, 4],\n    [2, 4, 5, 3, 1],\n    [6, 7, 1, 4, 5],\n    [5, 1, 1, 2, 4],\n]\nprint(pacificAtlanticDFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\nprint(pacificAtlanticBFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\n</code></pre>"},{"location":"endlesscheng/reverse_thinking/#991-broken-calculator","title":"991. Broken Calculator","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, greedy</p> </li> </ul>"},{"location":"endlesscheng/reverse_thinking/#2227-encrypt-and-decrypt-strings","title":"2227. Encrypt and Decrypt Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, string, design, trie</p> </li> </ul>"},{"location":"endlesscheng/reverse_thinking/#3419-minimize-the-maximum-edge-weight-of-graph","title":"3419. Minimize the Maximum Edge Weight of Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: binary search, depth first search, breadth first search, graph, shortest path</p> </li> </ul>"},{"location":"endlesscheng/reverse_thinking/#936-stamping-the-sequence","title":"936. Stamping The Sequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, stack, greedy, queue</p> </li> </ul>"},{"location":"endlesscheng/segment_tree/","title":"Segment Tree","text":"<ul> <li> 1157. Online Majority Element In Subarray (Hard)</li> <li> 2407. Longest Increasing Subsequence II (Hard)</li> <li> 2940. Find Building Where Alice and Bob Can Meet (Hard)</li> <li> 2286. Booking Concert Tickets in Groups (Hard)</li> <li> 3161. Block Placement Queries (Hard)</li> <li> 2213. Longest Substring of One Repeating Character (Hard)</li> <li> 3165. Maximum Sum of Subsequence With Non-adjacent Elements (Hard)</li> </ul>"},{"location":"endlesscheng/segment_tree/#1157-online-majority-element-in-subarray","title":"1157. Online Majority Element In Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, design, binary indexed tree, segment tree</p> </li> </ul>"},{"location":"endlesscheng/segment_tree/#2407-longest-increasing-subsequence-ii","title":"2407. Longest Increasing Subsequence II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, divide and conquer, dynamic programming, binary indexed tree, segment tree, queue, monotonic queue</p> </li> </ul>"},{"location":"endlesscheng/segment_tree/#2940-find-building-where-alice-and-bob-can-meet","title":"2940. Find Building Where Alice and Bob Can Meet","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, stack, binary indexed tree, segment tree, heap priority queue, monotonic stack</p> </li> </ul>"},{"location":"endlesscheng/segment_tree/#2286-booking-concert-tickets-in-groups","title":"2286. Booking Concert Tickets in Groups","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: binary search, design, binary indexed tree, segment tree</p> </li> </ul>"},{"location":"endlesscheng/segment_tree/#3161-block-placement-queries","title":"3161. Block Placement Queries","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, binary indexed tree, segment tree</p> </li> </ul>"},{"location":"endlesscheng/segment_tree/#2213-longest-substring-of-one-repeating-character","title":"2213. Longest Substring of One Repeating Character","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, segment tree, ordered set</p> </li> </ul>"},{"location":"endlesscheng/segment_tree/#3165-maximum-sum-of-subsequence-with-non-adjacent-elements","title":"3165. Maximum Sum of Subsequence With Non-adjacent Elements","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, divide and conquer, dynamic programming, segment tree</p> </li> </ul>"},{"location":"endlesscheng/shortest_path_all_pairs_floyd/","title":"Shortest Path All Pairs Floyd","text":"<ul> <li> 2642. Design Graph With Shortest Path Calculator (Hard)</li> <li> 1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance (Medium)</li> <li> 2976. Minimum Cost to Convert String I (Medium)</li> <li> 2959. Number of Possible Sets of Closing Branches (Hard)</li> <li> 2977. Minimum Cost to Convert String II (Hard)</li> <li> 2101. Detonate the Maximum Bombs (Medium)</li> </ul>"},{"location":"endlesscheng/shortest_path_all_pairs_floyd/#2642-design-graph-with-shortest-path-calculator","title":"2642. Design Graph With Shortest Path Calculator","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: graph, design, heap priority queue, shortest path</p> </li> </ul>"},{"location":"endlesscheng/shortest_path_all_pairs_floyd/#1334-find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance","title":"1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming, graph, shortest path</p> </li> </ul>"},{"location":"endlesscheng/shortest_path_all_pairs_floyd/#2976-minimum-cost-to-convert-string-i","title":"2976. Minimum Cost to Convert String I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, graph, shortest path</p> </li> </ul>"},{"location":"endlesscheng/shortest_path_all_pairs_floyd/#2959-number-of-possible-sets-of-closing-branches","title":"2959. Number of Possible Sets of Closing Branches","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: bit manipulation, graph, heap priority queue, enumeration, shortest path</p> </li> </ul>"},{"location":"endlesscheng/shortest_path_all_pairs_floyd/#2977-minimum-cost-to-convert-string-ii","title":"2977. Minimum Cost to Convert String II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, dynamic programming, graph, trie, shortest path</p> </li> </ul>"},{"location":"endlesscheng/shortest_path_all_pairs_floyd/#2101-detonate-the-maximum-bombs","title":"2101. Detonate the Maximum Bombs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, depth first search, breadth first search, graph, geometry</p> </li> </ul>"},{"location":"endlesscheng/shortest_path_single_source_dijkstra/","title":"Shortest Path Single Source Dijkstra","text":"<ul> <li> 743. Network Delay Time (Medium)</li> <li> 3341. Find Minimum Time to Reach Last Room I (Medium)</li> <li> 3112. Minimum Time to Visit Disappearing Nodes (Medium)</li> <li> 2642. Design Graph With Shortest Path Calculator (Hard)</li> <li> 1514. Path with Maximum Probability (Medium)</li> <li> 3342. Find Minimum Time to Reach Last Room II (Medium)</li> <li> 1631. Path With Minimum Effort (Medium)</li> <li> 1786. Number of Restricted Paths From First to Last Node (Medium)</li> <li> 3123. Find Edges in Shortest Paths (Hard)</li> <li> 1976. Number of Ways to Arrive at Destination (Medium)</li> <li> 778. Swim in Rising Water (Hard)</li> <li> 2662. Minimum Cost of a Path With Special Roads (Medium)</li> <li> 3377. Digit Operations to Make Two Integers Equal (Medium)</li> <li> 2045. Second Minimum Time to Reach Destination (Hard)</li> <li> 3419. Minimize the Maximum Edge Weight of Graph (Medium)</li> <li> 882. Reachable Nodes In Subdivided Graph (Hard)</li> <li> 2203. Minimum Weighted Subgraph With the Required Paths (Hard)</li> <li> 2577. Minimum Time to Visit a Cell In a Grid (Hard)</li> <li> 1928. Minimum Cost to Reach Destination in Time (Hard)</li> <li> 787. Cheapest Flights Within K Stops (Medium)</li> <li> 2699. Modify Graph Edge Weights (Hard)</li> <li> 1810. Minimum Path Cost in a Hidden Grid (Medium)</li> <li> 2093. Minimum Cost to Reach City With Discounts (Medium)</li> <li> 2473. Minimum Cost to Buy Apples (Medium)</li> <li> 2714. Find Shortest Path with K Hops (Hard)</li> <li> 2737. Find the Closest Marked Node (Medium)</li> </ul>"},{"location":"endlesscheng/shortest_path_single_source_dijkstra/#743-network-delay-time","title":"743. Network Delay Time","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, heap priority queue, shortest path</p> </li> <li>Return the minimum time taken to reach all nodes in a network.</li> </ul> <pre><code>graph LR\n1((1))\n2((2))\n3((3))\n4((4))\n2 --&gt; |1| 1\n2 --&gt; |1| 3\n3 --&gt; |1| 4</code></pre> <ul> <li>Shortest Path Problem: Find the shortest path between two vertices in a graph.</li> <li>Dijkstra's Algorithm<ul> <li>Shortest path algorithm</li> <li>Weighted graph (non-negative weights)</li> <li>Data Structure: Heap; Hash Set</li> <li>Time Complexity: O(E * logV)</li> <li>Space Complexity: O(V)</li> </ul> </li> </ul> 743. Network Delay Time - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\nfrom helper import complexity\n\n\n# 1. Dijkstra - Set\ndef networkDelayTime1(times: List[List[int]], n: int, k: int) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    heap = [(0, k)]\n    visit = set()\n    t = 0\n\n    while heap:\n        w1, n1 = heapq.heappop(heap)\n        if n1 in visit:\n            continue\n\n        visit.add(n1)\n        t = w1\n\n        for n2, w2 in graph[n1]:\n            heapq.heappush(heap, (w1 + w2, n2))\n\n    return t if len(visit) == n else -1\n\n\n# 2. Dijkstra - Dict\ndef networkDelayTime2(times: List[List[int]], n: int, k: int) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    heap = [(0, k)]\n    dist = defaultdict(int)\n\n    while heap:\n        w1, n1 = heapq.heappop(heap)\n        if n1 in dist:\n            continue\n\n        dist[n1] = w1\n\n        for n2, w2 in graph[n1]:\n            heapq.heappush(heap, (w1 + w2, n2))\n\n    return max(dist.values()) if len(dist) == n else -1\n\n\n# Bellman-Ford\ndef networkDelayTimeBF(times: List[List[int]], n: int, k: int) -&gt; int:\n    delay = {i: float(\"inf\") for i in range(1, n + 1)}\n    delay[k] = 0\n\n    for _ in range(n - 1):\n        for u, v, t in times:\n            delay[v] = min(delay[v], delay[u] + t)\n\n    max_delay = max(delay.values())\n    return max_delay if max_delay &lt; float(\"inf\") else -1\n\n\ntable = [\n    [\"Dijkstra\", \"O(E*logV)\", \"O(V+E)\"],\n    [\"Bellman-Ford\", \"O(E*V)\", \"O(V)\"],\n]\ncomplexity(table)\n# |--------------|-----------|--------|\n# | Approach     | Time      | Space  |\n# |--------------|-----------|--------|\n# | Dijkstra     | O(E*logV) | O(V+E) |\n# | Bellman-Ford | O(E*V)    | O(V)   |\n# |--------------|-----------|--------|\n\n\ntimes = [[2, 1, 1], [2, 3, 1], [3, 4, 1]]\nn = 4\nk = 2\nprint(networkDelayTime1(times, n, k))  # 2\nprint(networkDelayTime2(times, n, k))  # 2\nprint(networkDelayTimeBF(times, n, k))  # 2\n</code></pre>"},{"location":"endlesscheng/shortest_path_single_source_dijkstra/#3341-find-minimum-time-to-reach-last-room-i","title":"3341. Find Minimum Time to Reach Last Room I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, graph, heap priority queue, matrix, shortest path</p> </li> </ul>"},{"location":"endlesscheng/shortest_path_single_source_dijkstra/#3112-minimum-time-to-visit-disappearing-nodes","title":"3112. Minimum Time to Visit Disappearing Nodes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, graph, heap priority queue, shortest path</p> </li> </ul>"},{"location":"endlesscheng/shortest_path_single_source_dijkstra/#2642-design-graph-with-shortest-path-calculator","title":"2642. Design Graph With Shortest Path Calculator","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: graph, design, heap priority queue, shortest path</p> </li> </ul>"},{"location":"endlesscheng/shortest_path_single_source_dijkstra/#1514-path-with-maximum-probability","title":"1514. Path with Maximum Probability","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, graph, heap priority queue, shortest path</p> </li> </ul> 1514. Path with Maximum Probability - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Dijkstra - Dict\ndef maxProbability1(\n    n: int,\n    edges: List[List[int]],\n    succProb: List[float],\n    start_node: int,\n    end_node: int,\n) -&gt; float:\n    graph = defaultdict(list)\n    for i, (u, v) in enumerate(edges):\n        graph[u].append((v, succProb[i]))\n        graph[v].append((u, succProb[i]))\n\n    heap = [(-1, start_node)]\n    max_prob = {i: 0.0 for i in range(n)}\n    max_prob[start_node] = 1.0\n\n    while heap:\n        p1, n1 = heapq.heappop(heap)\n\n        if n1 == end_node:\n            return -p1\n\n        for n2, p2 in graph[n1]:\n            p2 *= -p1\n            if p2 &gt; max_prob[n2]:\n                max_prob[n2] = p2\n                heapq.heappush(heap, (-p2, n2))\n\n    return 0.0\n\n\n# Dijkstra - Set\ndef maxProbability2(\n    n: int,\n    edges: List[List[int]],\n    succProb: List[float],\n    start_node: int,\n    end_node: int,\n) -&gt; float:\n    graph = defaultdict(list)\n    for i, (u, v) in enumerate(edges):\n        graph[u].append((v, succProb[i]))\n        graph[v].append((u, succProb[i]))\n\n    heap = [(-1, start_node)]\n    visited = set()\n\n    while heap:\n        p1, n1 = heapq.heappop(heap)\n        visited.add(n1)\n\n        if n1 == end_node:\n            return -p1\n\n        for n2, p2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (p1 * p2, n2))\n\n    return 0.0\n\n\n# |------------|-----------|-----------|\n# |  Approach  |    Time   |   Space   |\n# |------------|-----------|-----------|\n# |  Dijkstra  | O(E log V)|   O(E)    |\n# |------------|-----------|-----------|\n\n\nn = 3\nedges = [[0, 1], [1, 2], [0, 2]]\nsuccProb = [0.5, 0.5, 0.2]\nstart = 0\nend = 2\n\nprint(maxProbability1(n, edges, succProb, start, end))  # 0.25\nprint(maxProbability2(n, edges, succProb, start, end))  # 0.25\n</code></pre>"},{"location":"endlesscheng/shortest_path_single_source_dijkstra/#3342-find-minimum-time-to-reach-last-room-ii","title":"3342. Find Minimum Time to Reach Last Room II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, graph, heap priority queue, matrix, shortest path</p> </li> </ul>"},{"location":"endlesscheng/shortest_path_single_source_dijkstra/#1631-path-with-minimum-effort","title":"1631. Path With Minimum Effort","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, depth first search, breadth first search, union find, heap priority queue, matrix</p> </li> <li>Return the minimum effort required to travel from the top-left to the bottom-right corner.</li> </ul> 1631. Path With Minimum Effort - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Prim\ndef minimumEffortPath(heights: List[List[int]]) -&gt; int:\n    m, n = len(heights), len(heights[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * n for _ in range(m)]\n    heap = [(0, 0, 0)]  # (effort, row, col)\n\n    while heap:\n        effort, r, c = heapq.heappop(heap)\n\n        if visited[r][c]:\n            continue\n\n        if r == m - 1 and c == n - 1:\n            return effort\n\n        visited[r][c] = True\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and not visited[nr][nc]:\n                updated = max(effort, abs(heights[r][c] - heights[nr][nc]))\n                heapq.heappush(heap, (updated, nr, nc))\n\n    return -1\n\n\nheights = [[1, 2, 2], [3, 8, 2], [5, 3, 5]]\nprint(minimumEffortPath(heights))  # 2\n</code></pre>"},{"location":"endlesscheng/shortest_path_single_source_dijkstra/#1786-number-of-restricted-paths-from-first-to-last-node","title":"1786. Number of Restricted Paths From First to Last Node","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming, graph, topological sort, heap priority queue, shortest path</p> </li> </ul>"},{"location":"endlesscheng/shortest_path_single_source_dijkstra/#3123-find-edges-in-shortest-paths","title":"3123. Find Edges in Shortest Paths","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, heap priority queue, shortest path</p> </li> </ul>"},{"location":"endlesscheng/shortest_path_single_source_dijkstra/#1976-number-of-ways-to-arrive-at-destination","title":"1976. Number of Ways to Arrive at Destination","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming, graph, topological sort, shortest path</p> </li> </ul> 1976. Number of Ways to Arrive at Destination - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra\ndef countPaths(n: int, roads: List[List[int]]) -&gt; int:\n    mod = 10**9 + 7\n    graph = [[] for _ in range(n)]\n    for u, v, w in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n\n    dist = [float(\"inf\") for _ in range(n)]\n    dist[0] = 0\n    count = [0 for _ in range(n)]\n    count[0] = 1\n\n    heap = [(0, 0)]\n\n    while heap:\n        d, u = heapq.heappop(heap)\n        if d &gt; dist[u]:\n            continue\n\n        for v, w in graph[u]:\n            if dist[u] + w &lt; dist[v]:\n                dist[v] = dist[u] + w\n                count[v] = count[u]\n                heapq.heappush(heap, (dist[v], v))\n            elif dist[u] + w == dist[v]:\n                count[v] += count[u]\n                count[v] %= mod\n\n    return count[-1]\n\n\nn = 7\nroads = [\n    [0, 6, 7],\n    [0, 1, 2],\n    [1, 2, 3],\n    [1, 3, 3],\n    [6, 3, 3],\n    [3, 5, 1],\n    [6, 5, 1],\n    [2, 5, 1],\n    [0, 4, 5],\n    [4, 6, 2],\n]\nprint(countPaths(n, roads))  # 4\n</code></pre>"},{"location":"endlesscheng/shortest_path_single_source_dijkstra/#778-swim-in-rising-water","title":"778. Swim in Rising Water","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, depth first search, breadth first search, union find, heap priority queue, matrix</p> </li> <li>Return the minimum time when you can reach the target.</li> </ul> <p></p> 778. Swim in Rising Water - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra's\ndef swimInWater(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    visited = set()\n    minHeap = [(grid[0][0], 0, 0)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    visited.add((0, 0))\n\n    while minHeap:\n        time, r, c = heapq.heappop(minHeap)\n\n        if r == n - 1 and c == n - 1:\n            return time\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if nr in range(n) and nc in range(n) and (nr, nc) not in visited:\n                visited.add((nr, nc))\n                heapq.heappush(minHeap, (max(time, grid[nr][nc]), nr, nc))\n\n\ngrid = [\n    [0, 1, 2, 3, 4],\n    [24, 23, 22, 21, 5],\n    [12, 13, 14, 15, 16],\n    [11, 17, 18, 19, 20],\n    [10, 9, 8, 7, 6],\n]\nprint(swimInWater(grid))  # 16\n</code></pre>"},{"location":"endlesscheng/shortest_path_single_source_dijkstra/#2662-minimum-cost-of-a-path-with-special-roads","title":"2662. Minimum Cost of a Path With Special Roads","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, graph, heap priority queue, shortest path</p> </li> </ul>"},{"location":"endlesscheng/shortest_path_single_source_dijkstra/#3377-digit-operations-to-make-two-integers-equal","title":"3377. Digit Operations to Make Two Integers Equal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, graph, heap priority queue, number theory, shortest path</p> </li> </ul>"},{"location":"endlesscheng/shortest_path_single_source_dijkstra/#2045-second-minimum-time-to-reach-destination","title":"2045. Second Minimum Time to Reach Destination","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: breadth first search, graph, shortest path</p> </li> </ul>"},{"location":"endlesscheng/shortest_path_single_source_dijkstra/#3419-minimize-the-maximum-edge-weight-of-graph","title":"3419. Minimize the Maximum Edge Weight of Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: binary search, depth first search, breadth first search, graph, shortest path</p> </li> </ul>"},{"location":"endlesscheng/shortest_path_single_source_dijkstra/#882-reachable-nodes-in-subdivided-graph","title":"882. Reachable Nodes In Subdivided Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: graph, heap priority queue, shortest path</p> </li> </ul> 882. Reachable Nodes In Subdivided Graph - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra's\ndef reachableNodes(self, edges: List[List[int]], maxMoves: int, n: int) -&gt; int:\n    graph = {i: {} for i in range(n)}\n    for u, v, cnt in edges:\n        graph[u][v] = cnt\n        graph[v][u] = cnt\n\n    heap = [(-maxMoves, 0)]\n    seen = {}\n\n    while heap:\n        moves, node = heapq.heappop(heap)\n        if node in seen:\n            continue\n        seen[node] = -moves\n        for nxt, cnt in graph[node].items():\n            movesLeft = -moves - cnt - 1\n            if nxt not in seen and movesLeft &gt;= 0:\n                heapq.heappush(heap, (-movesLeft, nxt))\n\n    res = len(seen)\n    for u, v, cnt in edges:\n        res += min(seen.get(u, 0) + seen.get(v, 0), cnt)\n\n    return res\n\n\nedges = [[0, 1, 10], [0, 2, 1], [1, 2, 2]]\nmaxMoves = 6\nn = 3\nprint(reachableNodes(None, edges, maxMoves, n))  # 13\n</code></pre>"},{"location":"endlesscheng/shortest_path_single_source_dijkstra/#2203-minimum-weighted-subgraph-with-the-required-paths","title":"2203. Minimum Weighted Subgraph With the Required Paths","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: graph, shortest path</p> </li> </ul>"},{"location":"endlesscheng/shortest_path_single_source_dijkstra/#2577-minimum-time-to-visit-a-cell-in-a-grid","title":"2577. Minimum Time to Visit a Cell In a Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, breadth first search, graph, heap priority queue, matrix, shortest path</p> </li> </ul>"},{"location":"endlesscheng/shortest_path_single_source_dijkstra/#1928-minimum-cost-to-reach-destination-in-time","title":"1928. Minimum Cost to Reach Destination in Time","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, graph</p> </li> </ul>"},{"location":"endlesscheng/shortest_path_single_source_dijkstra/#787-cheapest-flights-within-k-stops","title":"787. Cheapest Flights Within K Stops","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming, depth first search, breadth first search, graph, heap priority queue, shortest path</p> </li> <li>Return the cheapest price from <code>src</code> to <code>dst</code> with at most <code>K</code> stops.</li> </ul> <pre><code>graph TD\n0((0))\n1((1))\n2((2))\n3((3))\n0 --&gt; |100| 1\n1 --&gt; |600| 3\n1 --&gt; |100| 2\n2 --&gt; |100| 0\n2 --&gt; |200| 3</code></pre> 787. Cheapest Flights Within K Stops - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Bellman-Ford\ndef findCheapestPriceBF(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    prices = [float(\"inf\") for _ in range(n)]\n    prices[src] = 0\n\n    for _ in range(k + 1):\n        temp = prices[:]\n        for u, v, w in flights:\n            temp[v] = min(temp[v], prices[u] + w)\n        prices = temp\n\n    return prices[dst] if prices[dst] != float(\"inf\") else -1\n\n\n# Dijkstra\ndef findCheapestPriceDijkstra(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in flights:\n        graph[u].append((v, w))\n\n    heap = [(0, src, 0)]  # (price, city, stops)\n    visited = defaultdict(int)  # {city: stops}\n\n    while heap:\n        price, city, stops = heapq.heappop(heap)\n\n        if city == dst:\n            return price\n\n        if stops &gt; k:\n            continue\n\n        if city in visited and visited[city] &lt;= stops:\n            continue\n\n        visited[city] = stops\n\n        for neighbor, cost in graph[city]:\n            heapq.heappush(heap, (price + cost, neighbor, stops + 1))\n\n    return -1\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |Bellman-Ford|    O(k * E)      |  O(n)   |\n# | Dijkstra   | O(E * log(V))    |  O(n)   |\n# |------------|------------------|---------|\n\n\nn = 4\nflights = [[0, 1, 100], [1, 2, 100], [2, 0, 100], [1, 3, 600], [2, 3, 200]]\nsrc = 0\ndst = 3\nk = 1\nprint(findCheapestPriceBF(n, flights, src, dst, k))  # 700\nprint(findCheapestPriceDijkstra(n, flights, src, dst, k))  # 700\n</code></pre>"},{"location":"endlesscheng/shortest_path_single_source_dijkstra/#2699-modify-graph-edge-weights","title":"2699. Modify Graph Edge Weights","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: graph, heap priority queue, shortest path</p> </li> </ul>"},{"location":"endlesscheng/shortest_path_single_source_dijkstra/#1810-minimum-path-cost-in-a-hidden-grid","title":"1810. Minimum Path Cost in a Hidden Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, heap priority queue, interactive</p> </li> </ul>"},{"location":"endlesscheng/shortest_path_single_source_dijkstra/#2093-minimum-cost-to-reach-city-with-discounts","title":"2093. Minimum Cost to Reach City With Discounts","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: graph, heap priority queue, shortest path</p> </li> </ul>"},{"location":"endlesscheng/shortest_path_single_source_dijkstra/#2473-minimum-cost-to-buy-apples","title":"2473. Minimum Cost to Buy Apples","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, graph, heap priority queue, shortest path</p> </li> </ul>"},{"location":"endlesscheng/shortest_path_single_source_dijkstra/#2714-find-shortest-path-with-k-hops","title":"2714. Find Shortest Path with K Hops","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: graph, heap priority queue, shortest path</p> </li> </ul>"},{"location":"endlesscheng/shortest_path_single_source_dijkstra/#2737-find-the-closest-marked-node","title":"2737. Find the Closest Marked Node","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, graph, heap priority queue, shortest path</p> </li> </ul>"},{"location":"endlesscheng/single_sequence_pairing/","title":"Single Sequence Pairing","text":"<ul> <li> 2144. Minimum Cost of Buying Candies With Discount (Easy)</li> <li> 561. Array Partition (Easy)</li> <li> 1877. Minimize Maximum Pair Sum in Array (Medium)</li> <li> 881. Boats to Save People (Medium)</li> <li> 2592. Maximize Greatness of an Array (Medium)</li> <li> 2576. Find the Maximum Number of Marked Indices (Medium)</li> </ul>"},{"location":"endlesscheng/single_sequence_pairing/#2144-minimum-cost-of-buying-candies-with-discount","title":"2144. Minimum Cost of Buying Candies With Discount","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/single_sequence_pairing/#561-array-partition","title":"561. Array Partition","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, greedy, sorting, counting sort</p> </li> </ul>"},{"location":"endlesscheng/single_sequence_pairing/#1877-minimize-maximum-pair-sum-in-array","title":"1877. Minimize Maximum Pair Sum in Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/single_sequence_pairing/#881-boats-to-save-people","title":"881. Boats to Save People","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy, sorting</p> </li> </ul> 881. Boats to Save People - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef numRescueBoats(people: List[int], limit: int) -&gt; int:\n    \"\"\"Returns the minimum number of boats to rescue people.\"\"\"\n    people.sort()\n    left, right = 0, len(people) - 1\n    boats = 0\n\n    while left &lt;= right:\n        if people[left] + people[right] &lt;= limit:\n            left += 1\n        right -= 1\n        boats += 1\n\n    return boats\n\n\npeople = [3, 2, 2, 1]\nlimit = 3\nprint(numRescueBoats(people, limit))  # 3\n</code></pre>"},{"location":"endlesscheng/single_sequence_pairing/#2592-maximize-greatness-of-an-array","title":"2592. Maximize Greatness of an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/single_sequence_pairing/#2576-find-the-maximum-number-of-marked-indices","title":"2576. Find the Maximum Number of Marked Indices","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, greedy, sorting</p> </li> </ul> 2576. Find the Maximum Number of Marked Indices - Python Solution<pre><code>from typing import List\n\n\n# Fast Slow Pointers\ndef maxNumOfMarkedIndices(nums: List[int]) -&gt; int:\n    nums.sort()\n    n = len(nums)\n    slow, fast = 0, n // 2\n    count = 0\n\n    while slow &lt; n // 2 and fast &lt; n:\n        if nums[fast] &gt;= 2 * nums[slow]:\n            count += 2\n            slow += 1\n        fast += 1\n\n    return count\n\n\nnums = [3, 5, 2, 4]\nprint(maxNumOfMarkedIndices(nums))  # 2\n</code></pre>"},{"location":"endlesscheng/sliding_window_fixed_size_advanced/","title":"Sliding Window Fixed Size Advanced","text":"<ul> <li> 1461. Check If a String Contains All Binary Codes of Size K (Medium)</li> <li> 2134. Minimum Swaps to Group All 1's Together II (Medium)</li> <li> 1297. Maximum Number of Occurrences of a Substring (Medium)</li> <li> 2653. Sliding Subarray Beauty (Medium)</li> <li> 3439. Reschedule Meetings for Maximum Free Time I (Medium)</li> <li> 1888. Minimum Number of Flips to Make the Binary String Alternating (Medium)</li> <li> 567. Permutation in String (Medium)</li> <li> 438. Find All Anagrams in a String (Medium)</li> <li> 30. Substring with Concatenation of All Words (Hard)</li> <li> 2156. Find Substring With Given Hash Value (Hard)</li> <li> 2953. Count Complete Substrings (Hard)</li> <li> 1016. Binary String With Substrings Representing 1 To N (Medium)</li> <li> 683. K Empty Slots (Hard)</li> <li> 2067. Number of Equal Count Substrings (Medium)</li> <li> 2524. Maximum Frequency Score of a Subarray (Hard)</li> </ul>"},{"location":"endlesscheng/sliding_window_fixed_size_advanced/#1461-check-if-a-string-contains-all-binary-codes-of-size-k","title":"1461. Check If a String Contains All Binary Codes of Size K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, bit manipulation, rolling hash, hash function</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_fixed_size_advanced/#2134-minimum-swaps-to-group-all-1s-together-ii","title":"2134. Minimum Swaps to Group All 1's Together II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sliding window</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_fixed_size_advanced/#1297-maximum-number-of-occurrences-of-a-substring","title":"1297. Maximum Number of Occurrences of a Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_fixed_size_advanced/#2653-sliding-subarray-beauty","title":"2653. Sliding Subarray Beauty","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, sliding window</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_fixed_size_advanced/#3439-reschedule-meetings-for-maximum-free-time-i","title":"3439. Reschedule Meetings for Maximum Free Time I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sliding window</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_fixed_size_advanced/#1888-minimum-number-of-flips-to-make-the-binary-string-alternating","title":"1888. Minimum Number of Flips to Make the Binary String Alternating","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming, greedy, sliding window</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_fixed_size_advanced/#567-permutation-in-string","title":"567. Permutation in String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, two pointers, string, sliding window</p> </li> </ul> 567. Permutation in String - Python Solution<pre><code>def checkInclusion(s1: str, s2: str) -&gt; bool:\n    if len(s1) &gt; len(s2):\n        return False\n\n    count1 = [0] * 26\n    count2 = [0] * 26\n\n    for i in range(len(s1)):\n        count1[ord(s1[i]) - ord(\"a\")] += 1\n        count2[ord(s2[i]) - ord(\"a\")] += 1\n\n    matches = 0\n    for i in range(26):\n        if count1[i] == count2[i]:\n            matches += 1\n\n    l = 0\n    for r in range(len(s1), len(s2)):\n        if matches == 26:\n            return True\n\n        index = ord(s2[r]) - ord(\"a\")\n        count2[index] += 1\n        if count1[index] == count2[index]:\n            matches += 1\n        elif count1[index] + 1 == count2[index]:\n            matches -= 1\n\n        index = ord(s2[l]) - ord(\"a\")\n        count2[index] -= 1\n        if count1[index] == count2[index]:\n            matches += 1\n        elif count1[index] - 1 == count2[index]:\n            matches -= 1\n\n        l += 1\n\n    return matches == 26\n\n\ns1 = \"ab\"\ns2 = \"eidba\"\nprint(checkInclusion(s1, s2))  # True\n</code></pre>"},{"location":"endlesscheng/sliding_window_fixed_size_advanced/#438-find-all-anagrams-in-a-string","title":"438. Find All Anagrams in a String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> </ul> 438. Find All Anagrams in a String - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window - Variable\ndef findAnagrams(s: str, p: str) -&gt; List[int]:\n    result = []\n    if len(s) &lt; len(p):\n        return result\n\n    countP = [0] * 26\n    for i in p:\n        countP[ord(i) - ord(\"a\")] += 1\n\n    countS = [0] * 26\n    for i in range(len(p)):\n        countS[ord(s[i]) - ord(\"a\")] += 1\n\n    if countS == countP:\n        result.append(0)\n\n    # sliding window\n    for i in range(len(p), len(s)):\n        countS[ord(s[i]) - ord(\"a\")] += 1  # add new character\n        countS[ord(s[i - len(p)]) - ord(\"a\")] -= 1  # remove old character\n        if countS == countP:\n            result.append(i - len(p) + 1)  # append the starting index\n\n    return result\n\n\ns = \"cbaebabacd\"\np = \"abc\"\nprint(findAnagrams(s, p))  # [0, 6]\n</code></pre>"},{"location":"endlesscheng/sliding_window_fixed_size_advanced/#30-substring-with-concatenation-of-all-words","title":"30. Substring with Concatenation of All Words","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_fixed_size_advanced/#2156-find-substring-with-given-hash-value","title":"2156. Find Substring With Given Hash Value","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, sliding window, rolling hash, hash function</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_fixed_size_advanced/#2953-count-complete-substrings","title":"2953. Count Complete Substrings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_fixed_size_advanced/#1016-binary-string-with-substrings-representing-1-to-n","title":"1016. Binary String With Substrings Representing 1 To N","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_fixed_size_advanced/#683-k-empty-slots","title":"683. K Empty Slots","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary indexed tree, segment tree, queue, sliding window, heap priority queue, ordered set, monotonic queue</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_fixed_size_advanced/#2067-number-of-equal-count-substrings","title":"2067. Number of Equal Count Substrings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, counting, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_fixed_size_advanced/#2524-maximum-frequency-score-of-a-subarray","title":"2524. Maximum Frequency Score of a Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, math, stack, sliding window</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_fixed_size_basics/","title":"Sliding Window Fixed Size Basics","text":"<ul> <li> 1456. Maximum Number of Vowels in a Substring of Given Length (Medium)</li> <li> 643. Maximum Average Subarray I (Easy)</li> <li> 1343. Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold (Medium)</li> <li> 2090. K Radius Subarray Averages (Medium)</li> <li> 2379. Minimum Recolors to Get K Consecutive Black Blocks (Easy)</li> <li> 2841. Maximum Sum of Almost Unique Subarray (Medium)</li> <li> 2461. Maximum Sum of Distinct Subarrays With Length K (Medium)</li> <li> 1423. Maximum Points You Can Obtain from Cards (Medium)</li> <li> 1052. Grumpy Bookstore Owner (Medium)</li> <li> 1652. Defuse the Bomb (Easy)</li> <li> 1176. Diet Plan Performance (Easy)</li> <li> 1100. Find K-Length Substrings With No Repeated Characters (Medium)</li> <li> 1852. Distinct Numbers in Each Subarray (Medium)</li> <li> 1151. Minimum Swaps to Group All 1's Together (Medium)</li> <li> 2107. Number of Unique Flavors After Sharing K Candies (Medium)</li> </ul>"},{"location":"endlesscheng/sliding_window_fixed_size_basics/#1456-maximum-number-of-vowels-in-a-substring-of-given-length","title":"1456. Maximum Number of Vowels in a Substring of Given Length","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, sliding window</p> </li> </ul> 1456. Maximum Number of Vowels in a Substring of Given Length - Python Solution<pre><code># Sliding Window Fixed Size\ndef maxVowels1(s: str, k: int) -&gt; int:\n    res, cnt = 0, 0\n\n    for idx, ch in enumerate(s):\n        if ch in \"aeiou\":\n            cnt += 1\n\n        if idx &lt; k - 1:\n            continue\n\n        res = max(res, cnt)\n\n        if s[idx - k + 1] in \"aeiou\":\n            cnt -= 1\n\n    return res\n\n\n# Sliding Window Fixed Size\ndef maxVowels2(s: str, k: int) -&gt; int:\n    vowels = set(\"aeiou\")\n    n = len(s)\n    cnt, res = 0, 0\n\n    for i in range(k):\n        if s[i] in vowels:\n            cnt += 1\n\n    res = cnt\n\n    for i in range(k, n):\n        if s[i] in vowels:\n            cnt += 1\n        if s[i - k] in vowels:\n            cnt -= 1\n        res = max(res, cnt)\n\n    return res\n\n\ns = \"abciiidef\"\nk = 3\nprint(maxVowels1(s, k))  # 3\nprint(maxVowels2(s, k))  # 3\n</code></pre>"},{"location":"endlesscheng/sliding_window_fixed_size_basics/#643-maximum-average-subarray-i","title":"643. Maximum Average Subarray I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, sliding window</p> </li> </ul> 643. Maximum Average Subarray I - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window Fixed Size\ndef findMaxAverage1(nums: List[int], k: int) -&gt; float:\n    maxSum = float(\"-inf\")\n    cur = 0\n\n    for idx, num in enumerate(nums):\n        cur += num\n\n        if idx &lt; k - 1:\n            continue\n\n        maxSum = max(maxSum, cur)\n        cur -= nums[idx - k + 1]\n\n    return maxSum / k\n\n\n# Sliding Window Fixed Size\ndef findMaxAverage2(nums: List[int], k: int) -&gt; float:\n    n = len(nums)\n    if n == 1:\n        return float(nums[0])\n\n    cur = sum(nums[:k])\n\n    maxSum = cur\n    for i in range(k, n):\n        cur += nums[i] - nums[i - k]\n        maxSum = max(maxSum, cur)\n\n    return maxSum / k\n\n\nnums = [1, 12, -5, -6, 50, 3]\nk = 4\nprint(findMaxAverage1(nums, k))  # 12.75\nprint(findMaxAverage2(nums, k))  # 12.75\n</code></pre>"},{"location":"endlesscheng/sliding_window_fixed_size_basics/#1343-number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold","title":"1343. Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sliding window</p> </li> </ul> 1343. Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window Fixed Size\ndef numOfSubarrays(arr: List[int], k: int, threshold: int) -&gt; int:\n    target = k * threshold\n    res, cur = 0, 0\n\n    for idx, num in enumerate(arr):\n        cur += num\n\n        if idx &lt; k - 1:\n            continue\n\n        if cur &gt;= target:\n            res += 1\n\n        cur -= arr[idx - k + 1]\n\n    return res\n\n\narr = [2, 2, 2, 2, 5, 5, 5, 8]\nk = 3\nthreshold = 4\nprint(numOfSubarrays(arr, k, threshold))  # 3\n</code></pre>"},{"location":"endlesscheng/sliding_window_fixed_size_basics/#2090-k-radius-subarray-averages","title":"2090. K Radius Subarray Averages","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sliding window</p> </li> </ul> 2090. K Radius Subarray Averages - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window Fixed Size\ndef getAverages(nums: List[int], k: int) -&gt; List[int]:\n    n = len(nums)\n    res = [-1 for _ in range(n)]\n    size = 2 * k + 1\n\n    if size &gt; n:\n        return res\n    if k == 0:\n        return nums\n\n    cur = 0\n    for idx, num in enumerate(nums):\n        cur += num\n\n        if idx &lt; 2 * k:\n            continue\n\n        res[idx - k] = cur // size\n        cur -= nums[idx - 2 * k]\n\n    return res\n\n\nnums = [7, 4, 3, 9, 1, 8, 5, 2, 6]\nk = 3\nprint(getAverages(nums, k))\n# [-1, -1, -1, 5, 4, 4, -1, -1, -1]\n</code></pre>"},{"location":"endlesscheng/sliding_window_fixed_size_basics/#2379-minimum-recolors-to-get-k-consecutive-black-blocks","title":"2379. Minimum Recolors to Get K Consecutive Black Blocks","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, sliding window</p> </li> </ul> 2379. Minimum Recolors to Get K Consecutive Black Blocks - Python Solution<pre><code># Sliding Window Fixed Size\ndef minimumRecolors(blocks: str, k: int) -&gt; int:\n    cnt, res = 0, float(\"inf\")\n\n    for idx, block in enumerate(blocks):\n        if block == \"W\":\n            cnt += 1\n\n        if idx &lt; k - 1:\n            continue\n\n        res = min(res, cnt)\n\n        if blocks[idx - k + 1] == \"W\":\n            cnt -= 1\n\n    return res\n\n\nblocks = \"WBBWWBBWBW\"\nk = 7\nprint(minimumRecolors(blocks, k))  # 3\n</code></pre>"},{"location":"endlesscheng/sliding_window_fixed_size_basics/#2841-maximum-sum-of-almost-unique-subarray","title":"2841. Maximum Sum of Almost Unique Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, sliding window</p> </li> </ul> 2841. Maximum Sum of Almost Unique Subarray - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Sliding Window Fixed Size\ndef maxSum(nums: List[int], m: int, k: int) -&gt; int:\n    counts = defaultdict(int)\n    cur, res = 0, 0\n\n    for idx, num in enumerate(nums):\n        counts[num] += 1\n        cur += num\n\n        if idx &lt; k - 1:\n            continue\n\n        if len(counts) &gt;= m:\n            res = max(res, cur)\n\n        first = idx - k + 1\n        cur -= nums[first]\n        counts[nums[first]] -= 1\n        if counts[nums[first]] == 0:\n            del counts[nums[first]]\n\n    return res\n\n\nnums = [2, 6, 7, 3, 1, 7]\nm = 3\nk = 4\nprint(maxSum(nums, m, k))  # 18\n</code></pre>"},{"location":"endlesscheng/sliding_window_fixed_size_basics/#2461-maximum-sum-of-distinct-subarrays-with-length-k","title":"2461. Maximum Sum of Distinct Subarrays With Length K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, sliding window</p> </li> </ul> 2461. Maximum Sum of Distinct Subarrays With Length K - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Sliding Window Fixed Size\ndef maximumSubarraySum(nums: List[int], k: int) -&gt; int:\n    counts = defaultdict(int)\n    res = 0\n    cur = 0\n\n    for idx, num in enumerate(nums):\n        counts[num] += 1\n        cur += num\n\n        if idx &lt; k - 1:\n            continue\n\n        if len(counts) == k:\n            res = max(res, cur)\n\n        first = idx - k + 1\n        cur -= nums[first]\n        counts[nums[first]] -= 1\n        if counts[nums[first]] == 0:\n            del counts[nums[first]]\n\n    return res\n\n\nnums = [1, 5, 4, 2, 9, 9, 9]\nk = 3\nprint(maximumSubarraySum(nums, k))  # 15\n</code></pre>"},{"location":"endlesscheng/sliding_window_fixed_size_basics/#1423-maximum-points-you-can-obtain-from-cards","title":"1423. Maximum Points You Can Obtain from Cards","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sliding window, prefix sum</p> </li> </ul> 1423. Maximum Points You Can Obtain from Cards - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window Fixed Size\ndef maxScore(cardPoints: List[int], k: int) -&gt; int:\n    n = len(cardPoints)\n    j = n - k\n    total = sum(cardPoints)\n\n    if j == 0:\n        return total\n\n    curSum, minSum = 0, float(\"inf\")\n\n    for idx, point in enumerate(cardPoints):\n        curSum += point\n\n        if idx &lt; j - 1:\n            continue\n\n        minSum = min(minSum, curSum)\n        curSum -= cardPoints[idx - j + 1]\n\n    return total - minSum\n\n\ncardPoints = [1, 2, 3, 4, 5, 6, 1]\nk = 3\nprint(maxScore(cardPoints, k))  # 12\n</code></pre>"},{"location":"endlesscheng/sliding_window_fixed_size_basics/#1052-grumpy-bookstore-owner","title":"1052. Grumpy Bookstore Owner","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sliding window</p> </li> <li>Hint: Maximize the number of unsatisfied customers in the fixed window of <code>minutes</code>.</li> </ul> 1052. Grumpy Bookstore Owner - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window Fixed Size\ndef maxSatisfied(customers: List[int], grumpy: List[int], minutes: int) -&gt; int:\n    n = len(customers)\n    k = minutes\n    if k &gt;= n:\n        return sum(customers)\n\n    total_satisfied = sum(customers[i] for i in range(n) if not grumpy[i])\n\n    cur, maxGrumpy = 0, 0\n\n    for idx, customer in enumerate(customers):\n        cur += customer if grumpy[idx] else 0\n\n        if idx &lt; k - 1:\n            continue\n\n        maxGrumpy = max(maxGrumpy, cur)\n\n        cur -= customers[idx - k + 1] if grumpy[idx - k + 1] else 0\n\n    return total_satisfied + maxGrumpy\n\n\ncustomers = [1, 0, 1, 2, 1, 1, 7, 5]\ngrumpy = [0, 1, 0, 1, 0, 1, 0, 1]\nminutes = 3\nprint(maxSatisfied(customers, grumpy, minutes))  # 16\n</code></pre>"},{"location":"endlesscheng/sliding_window_fixed_size_basics/#1652-defuse-the-bomb","title":"1652. Defuse the Bomb","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, sliding window</p> </li> <li>How to deal with the circular array?<ul> <li>Trick: mod (index % length)</li> </ul> </li> </ul> 1652. Defuse the Bomb - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window Fixed Size\ndef decrypt(code: List[int], k: int) -&gt; List[int]:\n    n = len(code)\n    res = [0 for _ in range(n)]\n    if k == 0:\n        return res\n\n    left, right = (1, k) if k &gt; 0 else (n + k, n - 1)\n\n    curSum = 0\n    for i in range(left, right + 1):\n        curSum += code[i % n]\n\n    for i in range(n):\n        res[i] = curSum\n\n        curSum -= code[left % n]\n        left += 1\n        right += 1\n        curSum += code[right % n]\n\n    return res\n\n\ncode = [2, 4, 9, 3]\nk = -2\nprint(decrypt(code, k))  # [12, 5, 6, 13]\n</code></pre>"},{"location":"endlesscheng/sliding_window_fixed_size_basics/#1176-diet-plan-performance","title":"1176. Diet Plan Performance","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, sliding window</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_fixed_size_basics/#1100-find-k-length-substrings-with-no-repeated-characters","title":"1100. Find K-Length Substrings With No Repeated Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_fixed_size_basics/#1852-distinct-numbers-in-each-subarray","title":"1852. Distinct Numbers in Each Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, sliding window</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_fixed_size_basics/#1151-minimum-swaps-to-group-all-1s-together","title":"1151. Minimum Swaps to Group All 1's Together","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sliding window</p> </li> </ul> 1151. Minimum Swaps to Group All 1's Together - Python Solution<pre><code>from typing import List\n\n\ndef minSwaps(data: List[int]) -&gt; int:\n    n = len(data)\n    total = sum(data)\n\n    if total == 0 or total == 1 or total == n:\n        return 0\n\n    max_count = 0\n    cur = 0\n    left = 0\n\n    for right in range(n):\n        cur += data[right]\n\n        if right - left + 1 &gt; total:\n            cur -= data[left]\n            left += 1\n\n        max_count = max(max_count, cur)\n\n    return total - max_count\n\n\ndata = [1, 0, 1, 0, 1]\nprint(minSwaps(data))  # 1\n</code></pre>"},{"location":"endlesscheng/sliding_window_fixed_size_basics/#2107-number-of-unique-flavors-after-sharing-k-candies","title":"2107. Number of Unique Flavors After Sharing K Candies","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, sliding window</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_fixed_size_others/","title":"Sliding Window Fixed Size Others","text":"<ul> <li> 2269. Find the K-Beauty of a Number (Easy)</li> <li> 1984. Minimum Difference Between Highest and Lowest of K Scores (Easy)</li> <li> 220. Contains Duplicate III (Hard)</li> </ul>"},{"location":"endlesscheng/sliding_window_fixed_size_others/#2269-find-the-k-beauty-of-a-number","title":"2269. Find the K-Beauty of a Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, string, sliding window</p> </li> </ul> 2269. Find the K-Beauty of a Number - Python Solution<pre><code>def divisorSubstrings(num: int, k: int) -&gt; int:\n    numStr = str(num)\n    n = len(numStr)\n    res = 0\n\n    for i in range(n - k + 1):\n        x = int(numStr[i : i + k])\n        if x &gt; 0 and num % x == 0:\n            res += 1\n\n    return res\n\n\nnum = 240\nk = 2\nprint(divisorSubstrings(num, k))  # 2\n</code></pre>"},{"location":"endlesscheng/sliding_window_fixed_size_others/#1984-minimum-difference-between-highest-and-lowest-of-k-scores","title":"1984. Minimum Difference Between Highest and Lowest of K Scores","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, sliding window, sorting</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_fixed_size_others/#220-contains-duplicate-iii","title":"220. Contains Duplicate III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, sliding window, sorting, bucket sort, ordered set</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_max_advanced/","title":"Sliding Window Variable Max Advanced","text":"<ul> <li> 2730. Find the Longest Semi-Repetitive Substring (Medium)</li> <li> 2779. Maximum Beauty of an Array After Applying Operation (Medium)</li> <li> 1838. Frequency of the Most Frequent Element (Medium)</li> <li> 2516. Take K of Each Character From Left and Right (Medium)</li> <li> 2831. Find the Longest Equal Subarray (Medium)</li> <li> 2271. Maximum White Tiles Covered by a Carpet (Medium)</li> <li> 2106. Maximum Fruits Harvested After at Most K Steps (Hard)</li> <li> 2555. Maximize Win From Two Segments (Medium)</li> <li> 2009. Minimum Number of Operations to Make Array Continuous (Hard)</li> <li> 1610. Maximum Number of Visible Points (Hard)</li> <li> 2781. Length of the Longest Valid Substring (Hard)</li> <li> 3411. Maximum Subarray With Equal Products (Easy)</li> <li> 2968. Apply Operations to Maximize Frequency Score (Hard)</li> <li> 1040. Moving Stones Until Consecutive II (Medium)</li> <li> 3413. Maximum Coins From K Consecutive Bags (Medium)</li> <li> 395. Longest Substring with At Least K Repeating Characters (Medium)</li> <li> 1763. Longest Nice Substring (Easy)</li> <li> 487. Max Consecutive Ones II (Medium)</li> <li> 159. Longest Substring with At Most Two Distinct Characters (Medium)</li> <li> 340. Longest Substring with At Most K Distinct Characters (Medium)</li> </ul>"},{"location":"endlesscheng/sliding_window_variable_max_advanced/#2730-find-the-longest-semi-repetitive-substring","title":"2730. Find the Longest Semi-Repetitive Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, sliding window</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_max_advanced/#2779-maximum-beauty-of-an-array-after-applying-operation","title":"2779. Maximum Beauty of an Array After Applying Operation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sliding window, sorting</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_max_advanced/#1838-frequency-of-the-most-frequent-element","title":"1838. Frequency of the Most Frequent Element","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, greedy, sliding window, sorting, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_max_advanced/#2516-take-k-of-each-character-from-left-and-right","title":"2516. Take K of Each Character From Left and Right","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_max_advanced/#2831-find-the-longest-equal-subarray","title":"2831. Find the Longest Equal Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, binary search, sliding window</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_max_advanced/#2271-maximum-white-tiles-covered-by-a-carpet","title":"2271. Maximum White Tiles Covered by a Carpet","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, greedy, sliding window, sorting, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_max_advanced/#2106-maximum-fruits-harvested-after-at-most-k-steps","title":"2106. Maximum Fruits Harvested After at Most K Steps","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, sliding window, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_max_advanced/#2555-maximize-win-from-two-segments","title":"2555. Maximize Win From Two Segments","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sliding window</p> </li> </ul> 2555. Maximize Win From Two Segments - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window - Variable\ndef maximizeWin(prizePositions: List[int], k: int) -&gt; int:\n    n = len(prizePositions)\n\n    if 2 * k &gt;= prizePositions[-1] - prizePositions[0]:\n        return n\n\n    ans = left = 0\n    mx = [0] * (n + 1)\n\n    for right, p in enumerate(prizePositions):\n        while p - prizePositions[left] &gt; k:\n            left += 1\n        ans = max(ans, mx[left] + right - left + 1)\n        mx[right + 1] = max(mx[right], right - left + 1)\n\n    return ans\n\n\nprizePositions = [1, 1, 2, 2, 3, 3, 5]\nk = 2\nprint(maximizeWin(prizePositions, k))  # 7\n</code></pre>"},{"location":"endlesscheng/sliding_window_variable_max_advanced/#2009-minimum-number-of-operations-to-make-array-continuous","title":"2009. Minimum Number of Operations to Make Array Continuous","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, binary search, sliding window</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_max_advanced/#1610-maximum-number-of-visible-points","title":"1610. Maximum Number of Visible Points","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, geometry, sliding window, sorting</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_max_advanced/#2781-length-of-the-longest-valid-substring","title":"2781. Length of the Longest Valid Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, string, sliding window</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_max_advanced/#3411-maximum-subarray-with-equal-products","title":"3411. Maximum Subarray With Equal Products","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, math, sliding window, enumeration, number theory</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_max_advanced/#2968-apply-operations-to-maximize-frequency-score","title":"2968. Apply Operations to Maximize Frequency Score","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, sliding window, sorting, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_max_advanced/#1040-moving-stones-until-consecutive-ii","title":"1040. Moving Stones Until Consecutive II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, two pointers, sorting</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_max_advanced/#3413-maximum-coins-from-k-consecutive-bags","title":"3413. Maximum Coins From K Consecutive Bags","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, greedy, sliding window, sorting, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_max_advanced/#395-longest-substring-with-at-least-k-repeating-characters","title":"395. Longest Substring with At Least K Repeating Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, divide and conquer, sliding window</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_max_advanced/#1763-longest-nice-substring","title":"1763. Longest Nice Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, string, divide and conquer, bit manipulation, sliding window</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_max_advanced/#487-max-consecutive-ones-ii","title":"487. Max Consecutive Ones II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, sliding window</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_max_advanced/#159-longest-substring-with-at-most-two-distinct-characters","title":"159. Longest Substring with At Most Two Distinct Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> <li>Prerequisite: 3. Longest Substring Without Repeating Characters</li> </ul> 159. Longest Substring with At Most Two Distinct Characters - Python Solution<pre><code>from collections import defaultdict\n\n\n# Sliding Window - Variable\ndef lengthOfLongestSubstringTwoDistinct(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 2:\n        return n\n\n    window = defaultdict(int)\n    left, res = 0, 0\n\n    for right in range(n):\n        window[s[right]] += 1\n\n        while len(window) &gt; 2:\n            window[s[left]] -= 1\n            if window[s[left]] == 0:\n                del window[s[left]]\n            left += 1\n\n        res = max(res, right - left + 1)\n\n    return res\n\n\ns = \"ccaabbb\"\nassert lengthOfLongestSubstringTwoDistinct(s) == 5\n</code></pre>"},{"location":"endlesscheng/sliding_window_variable_max_advanced/#340-longest-substring-with-at-most-k-distinct-characters","title":"340. Longest Substring with At Most K Distinct Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> </ul> 340. Longest Substring with At Most K Distinct Characters - Python Solution<pre><code>from collections import defaultdict\n\n\n# Sliding Window Variable\ndef lengthOfLongestSubstringKDistinct(s: str, k: int) -&gt; int:\n    n = len(s)\n    if n &lt;= k:\n        return n\n\n    window = defaultdict(int)\n    left, res = 0, 0\n\n    for right in range(n):\n        window[s[right]] += 1\n        while len(window) &gt; k:\n            window[s[left]] -= 1\n            if window[s[left]] == 0:\n                del window[s[left]]\n            left += 1\n        res = max(res, right - left + 1)\n\n    return res\n\n\ns = \"eceba\"\nk = 2\nassert lengthOfLongestSubstringKDistinct(s, k) == 3\n</code></pre>"},{"location":"endlesscheng/sliding_window_variable_max_basics/","title":"Sliding Window Variable Max Basics","text":"<ul> <li> 3. Longest Substring Without Repeating Characters (Medium)</li> <li> 3090. Maximum Length Substring With Two Occurrences (Easy)</li> <li> 1493. Longest Subarray of 1's After Deleting One Element (Medium)</li> <li> 1208. Get Equal Substrings Within Budget (Medium)</li> <li> 904. Fruit Into Baskets (Medium)</li> <li> 1695. Maximum Erasure Value (Medium)</li> <li> 2958. Length of Longest Subarray With at Most K Frequency (Medium)</li> <li> 2024. Maximize the Confusion of an Exam (Medium)</li> <li> 1004. Max Consecutive Ones III (Medium)</li> <li> 1658. Minimum Operations to Reduce X to Zero (Medium)</li> </ul>"},{"location":"endlesscheng/sliding_window_variable_max_basics/#3-longest-substring-without-repeating-characters","title":"3. Longest Substring Without Repeating Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> <li>Classic sliding window problem. Use a set to keep track of the characters in the current window.</li> <li>Return the length of the longest substring without repeating characters.</li> </ul> 3. Longest Substring Without Repeating Characters - Python Solution<pre><code># Sliding Window Variable Size\ndef lengthOfLongestSubstring(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    window = set()\n    left = 0\n    res = 0\n\n    for right in range(n):\n        while s[right] in window:\n            window.remove(s[left])\n            left += 1\n        window.add(s[right])\n        res = max(res, right - left + 1)\n\n    return res\n\n\ns = \"abcabcbb\"\nassert lengthOfLongestSubstring(s) == 3\n</code></pre>"},{"location":"endlesscheng/sliding_window_variable_max_basics/#3090-maximum-length-substring-with-two-occurrences","title":"3090. Maximum Length Substring With Two Occurrences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> </ul> 3090. Maximum Length Substring With Two Occurrences - Python Solution<pre><code>from collections import defaultdict\n\n\n# Sliding Window Variable Size\ndef maximumLengthSubstring(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 2:\n        return n\n\n    counts = defaultdict(int)\n    left = 0\n    res = 0\n\n    for right in range(n):\n        while left &lt; right and counts[s[right]] == 2:\n            counts[s[left]] -= 1\n            if counts[s[left]] == 0:\n                del counts[s[left]]\n            left += 1\n\n        res = max(res, right - left + 1)\n        counts[s[right]] += 1\n\n    return res\n\n\ns = \"bcbbbcba\"\nprint(maximumLengthSubstring(s))  # 4\n</code></pre>"},{"location":"endlesscheng/sliding_window_variable_max_basics/#1493-longest-subarray-of-1s-after-deleting-one-element","title":"1493. Longest Subarray of 1's After Deleting One Element","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, sliding window</p> </li> </ul> 1493. Longest Subarray of 1's After Deleting One Element - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window Variable Size\ndef longestSubarray(nums: List[int]) -&gt; int:\n    zeroCount = 0\n    res = 0\n    left = 0\n\n    for right in range(len(nums)):\n        if nums[right] == 0:\n            zeroCount += 1\n\n        while zeroCount &gt; 1:\n            if nums[left] == 0:\n                zeroCount -= 1\n            left += 1\n\n        res = max(res, right - left)\n\n    return res\n\n\nnums = [1, 1, 0, 1]\nprint(longestSubarray(nums))  # 3\n</code></pre>"},{"location":"endlesscheng/sliding_window_variable_max_basics/#1208-get-equal-substrings-within-budget","title":"1208. Get Equal Substrings Within Budget","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, binary search, sliding window, prefix sum</p> </li> </ul> 1208. Get Equal Substrings Within Budget - Python Solution<pre><code># Sliding Window - Variable\ndef equalSubstring(s: str, t: str, maxCost: int) -&gt; int:\n    left = 0\n    maxLen = 0\n    currentCost = 0\n\n    for right in range(len(s)):\n        currentCost += abs(ord(s[right]) - ord(t[right]))\n\n        while currentCost &gt; maxCost:\n            currentCost -= abs(ord(s[left]) - ord(t[left]))\n            left += 1\n\n        maxLen = max(maxLen, right - left + 1)\n\n    return maxLen\n\n\ns = \"abcd\"\nt = \"bcdf\"\nmaxCost = 3\nprint(equalSubstring(s, t, maxCost))  # 3\n</code></pre>"},{"location":"endlesscheng/sliding_window_variable_max_basics/#904-fruit-into-baskets","title":"904. Fruit Into Baskets","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, sliding window</p> </li> </ul> 904. Fruit Into Baskets - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Sliding Window Variable Size\ndef totalFruit(fruits: List[int]) -&gt; int:\n    n = len(fruits)\n    if n &lt;= 2:\n        return n\n\n    baskets = defaultdict(int)\n    res, left = 0, 0\n\n    for right in range(n):\n        baskets[fruits[right]] += 1\n\n        while len(baskets) &gt; 2:\n            baskets[fruits[left]] -= 1\n            if baskets[fruits[left]] == 0:\n                del baskets[fruits[left]]\n            left += 1\n\n        res = max(res, right - left + 1)\n\n    return res\n\n\nfruits = [1, 2, 3, 2, 2]\nprint(totalFruit(fruits))  # 4\n</code></pre>"},{"location":"endlesscheng/sliding_window_variable_max_basics/#1695-maximum-erasure-value","title":"1695. Maximum Erasure Value","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, sliding window</p> </li> </ul> 1695. Maximum Erasure Value - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window Variable Size\ndef maximumUniqueSubarray(nums: List[int]) -&gt; int:\n    n = len(nums)\n    left = 0\n    cur, res = 0, 0\n    sub = set()\n\n    for right in range(n):\n        while left &lt; right and nums[right] in sub:\n            sub.remove(nums[left])\n            cur -= nums[left]\n            left += 1\n\n        sub.add(nums[right])\n        cur += nums[right]\n        res = max(res, cur)\n\n    return res\n\n\nnums = [4, 2, 4, 5, 6]\nprint(maximumUniqueSubarray(nums))  # 17\n</code></pre>"},{"location":"endlesscheng/sliding_window_variable_max_basics/#2958-length-of-longest-subarray-with-at-most-k-frequency","title":"2958. Length of Longest Subarray With at Most K Frequency","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, sliding window</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_max_basics/#2024-maximize-the-confusion-of-an-exam","title":"2024. Maximize the Confusion of an Exam","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, binary search, sliding window, prefix sum</p> </li> </ul> 2024. Maximize the Confusion of an Exam - Python Solution<pre><code># Sliding Window - Variable\ndef maxConsecutiveAnswers1(answerKey: str, k: int) -&gt; int:\n    def maxConsecutiveChar(s: str, k: int, char: str) -&gt; int:\n        max_len = 0\n        left = 0\n        count = 0  # num of str != char\n\n        for right in range(len(s)):\n            if s[right] != char:\n                count += 1\n\n            while count &gt; k:\n                if s[left] != char:\n                    count -= 1\n                left += 1\n\n            max_len = max(max_len, right - left + 1)\n\n        return max_len\n\n    max_t = maxConsecutiveChar(answerKey, k, \"T\")\n    max_f = maxConsecutiveChar(answerKey, k, \"F\")\n\n    return max(max_t, max_f)\n\n\n# Sliding Window - Variable\ndef maxConsecutiveAnswers2(answerKey: str, k: int) -&gt; int:\n    def maxConsecutiveChar(s: str, k: int, char: str) -&gt; int:\n        max_len = 0\n        left, right = 0, 0\n\n        while right &lt; len(s):\n            if s[right] != char:\n                k -= 1\n\n            while k &lt; 0:\n                if s[left] != char:\n                    k += 1\n                left += 1\n\n            max_len = max(max_len, right - left + 1)\n            right += 1\n\n        return max_len\n\n    max_t = maxConsecutiveChar(answerKey, k, \"T\")\n    max_f = maxConsecutiveChar(answerKey, k, \"F\")\n\n    return max(max_t, max_f)\n\n\n# |-----------------|---------|------------|\n# |  Approach       |  Time   |  Space     |\n# |-----------------|---------|------------|\n# | Sliding Window  |  O(N)   |  O(1)      |\n# |-----------------|---------|------------|\n\n\nanswerKey = \"TTFF\"\nk = 2\nprint(maxConsecutiveAnswers1(answerKey, k))  # 4\nprint(maxConsecutiveAnswers2(answerKey, k))  # 4\n</code></pre>"},{"location":"endlesscheng/sliding_window_variable_max_basics/#1004-max-consecutive-ones-iii","title":"1004. Max Consecutive Ones III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sliding window, prefix sum</p> </li> </ul> 1004. Max Consecutive Ones III - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window - Variable\ndef longestOnes(nums: List[int], k: int) -&gt; int:\n    left = 0\n    maxLen = 0\n    zero_count = 0\n\n    for right in range(len(nums)):\n        if nums[right] == 0:\n            zero_count += 1\n\n        while zero_count &gt; k:\n            if nums[left] == 0:\n                zero_count -= 1\n            left += 1\n\n        maxLen = max(maxLen, right - left + 1)\n\n    return maxLen\n\n\nnums = [1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0]\nk = 2\nprint(longestOnes(nums, k))  # 6\n</code></pre>"},{"location":"endlesscheng/sliding_window_variable_max_basics/#1658-minimum-operations-to-reduce-x-to-zero","title":"1658. Minimum Operations to Reduce X to Zero","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, binary search, sliding window, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_min/","title":"Sliding Window Variable Min","text":"<ul> <li> 209. Minimum Size Subarray Sum (Medium)</li> <li> 2904. Shortest and Lexicographically Smallest Beautiful String (Medium)</li> <li> 1234. Replace the Substring for Balanced String (Medium)</li> <li> 2875. Minimum Size Subarray in Infinite Array (Medium)</li> <li> 76. Minimum Window Substring (Hard)</li> <li> 632. Smallest Range Covering Elements from K Lists (Hard)</li> </ul>"},{"location":"endlesscheng/sliding_window_variable_min/#209-minimum-size-subarray-sum","title":"209. Minimum Size Subarray Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sliding window, prefix sum</p> </li> </ul> 209. Minimum Size Subarray Sum - Python Solution<pre><code>import bisect\nfrom typing import List\n\n\n# Prefix Sum\ndef minSubArrayLenPS(target: int, nums: List[int]) -&gt; int:\n    n = len(nums)\n    prefix_sums = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        prefix_sums[i] = prefix_sums[i - 1] + nums[i - 1]\n\n    minLen = float(\"inf\")\n\n    for i in range(n + 1):\n        new_target = target + prefix_sums[i]\n        bound = bisect.bisect_left(prefix_sums, new_target)\n        if bound != len(prefix_sums):\n            minLen = min(minLen, bound - i)\n\n    return 0 if minLen == float(\"inf\") else minLen\n\n\n# Sliding Window Variable Size\ndef minSubArrayLenSW(target: int, nums: List[int]) -&gt; int:\n    res, cur = float(\"inf\"), 0\n    left = 0\n\n    for right in range(len(nums)):\n        cur += nums[right]\n\n        while cur &gt;= target:\n            res = min(res, right - left + 1)\n            cur -= nums[left]\n            left += 1\n\n    return res if res != float(\"inf\") else 0\n\n\ntarget = 7\nnums = [2, 3, 1, 2, 4, 3]\nprint(minSubArrayLenPS(target, nums))  # 2\nprint(minSubArrayLenSW(target, nums))  # 2\n</code></pre>"},{"location":"endlesscheng/sliding_window_variable_min/#2904-shortest-and-lexicographically-smallest-beautiful-string","title":"2904. Shortest and Lexicographically Smallest Beautiful String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, sliding window</p> </li> </ul> 2904. Shortest and Lexicographically Smallest Beautiful String - Python Solution<pre><code># Sliding Window Variable Size\ndef shortestBeautifulSubstring(s: str, k: int) -&gt; str:\n    n = len(s)\n    left = 0\n    oneCount = 0\n    minLen = float(\"inf\")\n    res = \"\"\n\n    for right in range(n):\n        if s[right] == \"1\":\n            oneCount += 1\n\n        while oneCount == k:\n            size = right - left + 1\n\n            if size &lt; minLen:\n                minLen = size\n                res = s[left : right + 1]\n            elif size == minLen:\n                res = min(res, s[left : right + 1])\n\n            if s[left] == \"1\":\n                oneCount -= 1\n            left += 1\n\n    return res\n\n\ns = \"100011001\"\nk = 3\nprint(shortestBeautifulSubstring(s, k))  # 11001\n</code></pre>"},{"location":"endlesscheng/sliding_window_variable_min/#1234-replace-the-substring-for-balanced-string","title":"1234. Replace the Substring for Balanced String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, sliding window</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_min/#2875-minimum-size-subarray-in-infinite-array","title":"2875. Minimum Size Subarray in Infinite Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, sliding window, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_min/#76-minimum-window-substring","title":"76. Minimum Window Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> </ul> 76. Minimum Window Substring - Python Solution<pre><code>from collections import Counter\n\n\ndef minWindow(s: str, t: str) -&gt; str:\n    if not t or not s:\n        return \"\"\n\n    counts = Counter(t)\n    required = len(counts)\n\n    left, right = 0, 0\n    formed = 0\n    window_counts = dict()\n\n    result = float(\"inf\"), None, None\n\n    while right &lt; len(s):\n        char = s[right]\n        window_counts[char] = window_counts.get(char, 0) + 1\n        if char in counts and window_counts[char] == counts[char]:\n            formed += 1\n\n        while left &lt;= right and formed == required:\n            char = s[left]\n            if right - left + 1 &lt; result[0]:\n                result = (right - left + 1, left, right)\n            window_counts[char] -= 1\n            if char in counts and window_counts[char] &lt; counts[char]:\n                formed -= 1\n            left += 1\n\n        right += 1\n\n    return \"\" if result[0] == float(\"inf\") else s[result[1] : result[2] + 1]\n\n\ns = \"ADOBECODEBANC\"\nt = \"ABC\"\nprint(minWindow(s, t))  # BANC\n</code></pre>"},{"location":"endlesscheng/sliding_window_variable_min/#632-smallest-range-covering-elements-from-k-lists","title":"632. Smallest Range Covering Elements from K Lists","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, greedy, sliding window, sorting, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_others/","title":"Sliding Window Variable Others","text":"<ul> <li> 1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit (Medium)</li> <li> 825. Friends Of Appropriate Ages (Medium)</li> <li> 2401. Longest Nice Subarray (Medium)</li> <li> 1156. Swap For Longest Repeated Character Substring (Medium)</li> <li> 424. Longest Repeating Character Replacement (Medium)</li> <li> 438. Find All Anagrams in a String (Medium)</li> <li> 1712. Ways to Split Array Into Three Subarrays (Medium)</li> <li> 1918. Kth Smallest Subarray Sum (Medium)</li> </ul>"},{"location":"endlesscheng/sliding_window_variable_others/#1438-longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit","title":"1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, queue, sliding window, heap priority queue, ordered set, monotonic queue</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_others/#825-friends-of-appropriate-ages","title":"825. Friends Of Appropriate Ages","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, sorting</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_others/#2401-longest-nice-subarray","title":"2401. Longest Nice Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, bit manipulation, sliding window</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_others/#1156-swap-for-longest-repeated-character-substring","title":"1156. Swap For Longest Repeated Character Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_others/#424-longest-repeating-character-replacement","title":"424. Longest Repeating Character Replacement","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> </ul> 424. Longest Repeating Character Replacement - Python Solution<pre><code>from collections import defaultdict\n\n\n# Sliding Window - Variable\ndef characterReplacement(s: str, k: int) -&gt; int:\n    left = 0\n    maxCount = 0\n    counts = defaultdict(int)\n    maxLen = 0\n\n    for right in range(len(s)):\n        counts[s[right]] += 1\n        maxCount = max(maxCount, counts[s[right]])\n\n        while right - left + 1 - maxCount &gt; k:\n            counts[s[left]] -= 1\n            left += 1\n\n        maxLen = max(maxLen, right - left + 1)\n\n    return maxLen\n\n\ns = \"ABAB\"\nk = 2\nprint(characterReplacement(s, k))  # 4\n</code></pre>"},{"location":"endlesscheng/sliding_window_variable_others/#438-find-all-anagrams-in-a-string","title":"438. Find All Anagrams in a String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> </ul> 438. Find All Anagrams in a String - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window - Variable\ndef findAnagrams(s: str, p: str) -&gt; List[int]:\n    result = []\n    if len(s) &lt; len(p):\n        return result\n\n    countP = [0] * 26\n    for i in p:\n        countP[ord(i) - ord(\"a\")] += 1\n\n    countS = [0] * 26\n    for i in range(len(p)):\n        countS[ord(s[i]) - ord(\"a\")] += 1\n\n    if countS == countP:\n        result.append(0)\n\n    # sliding window\n    for i in range(len(p), len(s)):\n        countS[ord(s[i]) - ord(\"a\")] += 1  # add new character\n        countS[ord(s[i - len(p)]) - ord(\"a\")] -= 1  # remove old character\n        if countS == countP:\n            result.append(i - len(p) + 1)  # append the starting index\n\n    return result\n\n\ns = \"cbaebabacd\"\np = \"abc\"\nprint(findAnagrams(s, p))  # [0, 6]\n</code></pre>"},{"location":"endlesscheng/sliding_window_variable_others/#1712-ways-to-split-array-into-three-subarrays","title":"1712. Ways to Split Array Into Three Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_others/#1918-kth-smallest-subarray-sum","title":"1918. Kth Smallest Subarray Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sliding window</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_subarrays_exact/","title":"Sliding Window Variable Subarrays Exact","text":"<ul> <li> 930. Binary Subarrays With Sum (Medium)</li> <li> 1248. Count Number of Nice Subarrays (Medium)</li> <li> 3306. Count of Substrings Containing Every Vowel and K Consonants II (Medium)</li> <li> 992. Subarrays with K Different Integers (Hard)</li> </ul>"},{"location":"endlesscheng/sliding_window_variable_subarrays_exact/#930-binary-subarrays-with-sum","title":"930. Binary Subarrays With Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, sliding window, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_subarrays_exact/#1248-count-number-of-nice-subarrays","title":"1248. Count Number of Nice Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, sliding window, prefix sum</p> </li> </ul> 1248. Count Number of Nice Subarrays - Python Solution<pre><code>from typing import List\n\n\n# Prefix Sum\ndef numberOfSubarrays(nums: List[int], k: int) -&gt; int:\n    count = 0\n    odd_counts = {0: 1}  # odd_count -&gt; count\n    odd_count = 0\n\n    for num in nums:\n        if num % 2 == 1:\n            odd_count += 1\n        if odd_count - k in odd_counts:\n            count += odd_counts[odd_count - k]\n        if odd_count in odd_counts:\n            odd_counts[odd_count] += 1\n        else:\n            odd_counts[odd_count] = 1\n\n    return count\n\n\nnums = [1, 1, 2, 1, 1]\nk = 3\nprint(numberOfSubarrays(nums, k))  # 2\n</code></pre>"},{"location":"endlesscheng/sliding_window_variable_subarrays_exact/#3306-count-of-substrings-containing-every-vowel-and-k-consonants-ii","title":"3306. Count of Substrings Containing Every Vowel and K Consonants II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_subarrays_exact/#992-subarrays-with-k-different-integers","title":"992. Subarrays with K Different Integers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, sliding window, counting</p> </li> </ul> 992. Subarrays with K Different Integers - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window - Variable\ndef subarraysWithKDistinct(nums: List[int], k: int) -&gt; int:\n    def atMost(k: int) -&gt; int:\n        count = 0\n        left = 0\n        freq = {}\n\n        for right in range(len(nums)):\n            if nums[right] not in freq:\n                freq[nums[right]] = 0\n            freq[nums[right]] += 1\n\n            while len(freq) &gt; k:\n                freq[nums[left]] -= 1\n                if freq[nums[left]] == 0:\n                    del freq[nums[left]]\n                left += 1\n\n            count += right - left + 1\n\n        return count\n\n    return atMost(k) - atMost(k - 1)\n\n\nnums = [1, 2, 1, 2, 3]\nk = 2\nprint(subarraysWithKDistinct(nums, k))  # 7\n</code></pre>"},{"location":"endlesscheng/sliding_window_variable_subarrays_longer/","title":"Sliding Window Variable Subarrays Longer","text":"<ul> <li> 1358. Number of Substrings Containing All Three Characters (Medium)</li> <li> 2962. Count Subarrays Where Max Element Appears at Least K Times (Medium)</li> <li> 3325. Count Substrings With K-Frequency Characters I (Medium)</li> <li> 2799. Count Complete Subarrays in an Array (Medium)</li> <li> 2537. Count the Number of Good Subarrays (Medium)</li> <li> 3298. Count Substrings That Can Be Rearranged to Contain a String II (Hard)</li> <li> 2495. Number of Subarrays Having Even Product (Medium)</li> </ul>"},{"location":"endlesscheng/sliding_window_variable_subarrays_longer/#1358-number-of-substrings-containing-all-three-characters","title":"1358. Number of Substrings Containing All Three Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_subarrays_longer/#2962-count-subarrays-where-max-element-appears-at-least-k-times","title":"2962. Count Subarrays Where Max Element Appears at Least K Times","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sliding window</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_subarrays_longer/#3325-count-substrings-with-k-frequency-characters-i","title":"3325. Count Substrings With K-Frequency Characters I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_subarrays_longer/#2799-count-complete-subarrays-in-an-array","title":"2799. Count Complete Subarrays in an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, sliding window</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_subarrays_longer/#2537-count-the-number-of-good-subarrays","title":"2537. Count the Number of Good Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, sliding window</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_subarrays_longer/#3298-count-substrings-that-can-be-rearranged-to-contain-a-string-ii","title":"3298. Count Substrings That Can Be Rearranged to Contain a String II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_subarrays_longer/#2495-number-of-subarrays-having-even-product","title":"2495. Number of Subarrays Having Even Product","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, dynamic programming</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_subarrays_shorter/","title":"Sliding Window Variable Subarrays Shorter","text":"<ul> <li> 713. Subarray Product Less Than K (Medium)</li> <li> 3258. Count Substrings That Satisfy K-Constraint I (Easy)</li> <li> 2302. Count Subarrays With Score Less Than K (Hard)</li> <li> 2762. Continuous Subarrays (Medium)</li> <li> 3134. Find the Median of the Uniqueness Array (Hard)</li> <li> 3261. Count Substrings That Satisfy K-Constraint II (Hard)</li> <li> 2743. Count Substrings Without Repeating Character (Medium)</li> </ul>"},{"location":"endlesscheng/sliding_window_variable_subarrays_shorter/#713-subarray-product-less-than-k","title":"713. Subarray Product Less Than K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sliding window, prefix sum</p> </li> </ul> 713. Subarray Product Less Than K - Python Solution<pre><code>from typing import List\n\n\n# Sliding window - Fixed\ndef numSubarrayProductLessThanK(nums: List[int], k: int) -&gt; int:\n    if k &lt;= 1:\n        return 0\n\n    left = 0\n    product = 1\n    count = 0\n\n    for right in range(len(nums)):\n        product *= nums[right]\n\n        while product &gt;= k:\n            product //= nums[left]\n            left += 1\n\n        count += right - left + 1\n\n    return count\n\n\nnums = [10, 5, 2, 6]\nk = 100\nprint(numSubarrayProductLessThanK(nums, k))  # 8\n</code></pre>"},{"location":"endlesscheng/sliding_window_variable_subarrays_shorter/#3258-count-substrings-that-satisfy-k-constraint-i","title":"3258. Count Substrings That Satisfy K-Constraint I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, sliding window</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_subarrays_shorter/#2302-count-subarrays-with-score-less-than-k","title":"2302. Count Subarrays With Score Less Than K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, sliding window, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_subarrays_shorter/#2762-continuous-subarrays","title":"2762. Continuous Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, queue, sliding window, heap priority queue, ordered set, monotonic queue</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_subarrays_shorter/#3134-find-the-median-of-the-uniqueness-array","title":"3134. Find the Median of the Uniqueness Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, binary search, sliding window</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_subarrays_shorter/#3261-count-substrings-that-satisfy-k-constraint-ii","title":"3261. Count Substrings That Satisfy K-Constraint II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, binary search, sliding window, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/sliding_window_variable_subarrays_shorter/#2743-count-substrings-without-repeating-character","title":"2743. Count Substrings Without Repeating Character","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> </ul>"},{"location":"endlesscheng/sorting_inequality/","title":"Sorting Inequality","text":"<ul> <li> 2285. Maximum Total Importance of Roads (Medium)</li> <li> 3016. Minimum Number of Pushes to Type Word II (Medium)</li> <li> 1402. Reducing Dishes (Hard)</li> <li> 2931. Maximum Spending After Buying Items (Hard)</li> <li> 1589. Maximum Sum Obtained of Any Permutation (Medium)</li> <li> 1874. Minimize Product Sum of Two Arrays (Medium)</li> <li> 2268. Minimum Number of Keypresses (Medium)</li> </ul>"},{"location":"endlesscheng/sorting_inequality/#2285-maximum-total-importance-of-roads","title":"2285. Maximum Total Importance of Roads","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: greedy, graph, sorting, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/sorting_inequality/#3016-minimum-number-of-pushes-to-type-word-ii","title":"3016. Minimum Number of Pushes to Type Word II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, greedy, sorting, counting</p> </li> </ul>"},{"location":"endlesscheng/sorting_inequality/#1402-reducing-dishes","title":"1402. Reducing Dishes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/sorting_inequality/#2931-maximum-spending-after-buying-items","title":"2931. Maximum Spending After Buying Items","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sorting, heap priority queue, matrix</p> </li> </ul>"},{"location":"endlesscheng/sorting_inequality/#1589-maximum-sum-obtained-of-any-permutation","title":"1589. Maximum Sum Obtained of Any Permutation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting, prefix sum</p> </li> </ul> 1589. Maximum Sum Obtained of Any Permutation - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef maxSumRangeQuery(nums: List[int], requests: List[List[int]]) -&gt; int:\n    n = len(nums)\n    freq = [0 for _ in range(n + 1)]\n\n    for start, end in requests:\n        freq[start] += 1\n        if end + 1 &lt; n:\n            freq[end + 1] -= 1\n\n    for i in range(1, n):\n        freq[i] += freq[i - 1]\n\n    freq.pop()\n\n    freq.sort(reverse=True)\n    nums.sort(reverse=True)\n\n    max_sum = 0\n    mod = 10**9 + 7\n\n    for i, j in zip(nums, freq):\n        max_sum += i * j\n        max_sum %= mod\n\n    return max_sum\n\n\nnums = [1, 2, 3, 4, 5]\nrequests = [[1, 3], [0, 1]]\nprint(maxSumRangeQuery(nums, requests))  # 19\n</code></pre>"},{"location":"endlesscheng/sorting_inequality/#1874-minimize-product-sum-of-two-arrays","title":"1874. Minimize Product Sum of Two Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/sorting_inequality/#2268-minimum-number-of-keypresses","title":"2268. Minimum Number of Keypresses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, greedy, sorting, counting</p> </li> </ul>"},{"location":"endlesscheng/stack_advanced/","title":"Stack Advanced","text":"<ul> <li> 3170. Lexicographically Minimum String After Removing Stars (Medium)</li> <li> 155. Min Stack (Medium)</li> <li> 1381. Design a Stack With Increment Operation (Medium)</li> <li> 636. Exclusive Time of Functions (Medium)</li> <li> 2434. Using a Robot to Print the Lexicographically Smallest String (Medium)</li> <li> 895. Maximum Frequency Stack (Hard)</li> <li> 1172. Dinner Plate Stacks (Hard)</li> <li> 2589. Minimum Time to Complete All Tasks (Hard)</li> <li> 716. Max Stack (Hard)</li> </ul>"},{"location":"endlesscheng/stack_advanced/#3170-lexicographically-minimum-string-after-removing-stars","title":"3170. Lexicographically Minimum String After Removing Stars","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, stack, greedy, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/stack_advanced/#155-min-stack","title":"155. Min Stack","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: stack, design</p> </li> <li>Implement a stack that supports push, pop, top, and retrieving the minimum element in constant time.</li> </ul> 155. Min Stack - Python Solution<pre><code># Stack\nclass MinStack:\n\n    def __init__(self):\n        self.stack = []\n        self.minStack = []\n\n    def push(self, val: int) -&gt; None:\n        self.stack.append(val)\n        val = min(val, self.minStack[-1] if self.minStack else val)\n        self.minStack.append(val)\n\n    def pop(self) -&gt; None:\n        if self.stack:\n            self.stack.pop()\n        if self.minStack:\n            self.minStack.pop()\n\n    def top(self) -&gt; int:\n        return self.stack[-1] if self.stack else None\n\n    def getMin(self) -&gt; int:\n        return self.minStack[-1] if self.minStack else None\n\n\n# Your MinStack object will be instantiated and called as such:\nobj = MinStack()\nobj.push(3)\nobj.push(2)\nobj.pop()\nprint(obj.top())  # 3\nprint(obj.getMin())  # 3\n</code></pre>"},{"location":"endlesscheng/stack_advanced/#1381-design-a-stack-with-increment-operation","title":"1381. Design a Stack With Increment Operation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, design</p> </li> </ul>"},{"location":"endlesscheng/stack_advanced/#636-exclusive-time-of-functions","title":"636. Exclusive Time of Functions","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack</p> </li> </ul>"},{"location":"endlesscheng/stack_advanced/#2434-using-a-robot-to-print-the-lexicographically-smallest-string","title":"2434. Using a Robot to Print the Lexicographically Smallest String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, stack, greedy</p> </li> </ul>"},{"location":"endlesscheng/stack_advanced/#895-maximum-frequency-stack","title":"895. Maximum Frequency Stack","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, stack, design, ordered set</p> </li> </ul>"},{"location":"endlesscheng/stack_advanced/#1172-dinner-plate-stacks","title":"1172. Dinner Plate Stacks","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, stack, design, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/stack_advanced/#2589-minimum-time-to-complete-all-tasks","title":"2589. Minimum Time to Complete All Tasks","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, stack, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/stack_advanced/#716-max-stack","title":"716. Max Stack","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: linked list, stack, design, doubly linked list, ordered set</p> </li> </ul>"},{"location":"endlesscheng/stack_basics/","title":"Stack Basics","text":"<ul> <li> 1441. Build an Array With Stack Operations (Medium)</li> <li> 844. Backspace String Compare (Easy)</li> <li> 682. Baseball Game (Easy)</li> <li> 2390. Removing Stars From a String (Medium)</li> <li> 1472. Design Browser History (Medium)</li> <li> 946. Validate Stack Sequences (Medium)</li> <li> 3412. Find Mirror Score of a String (Medium)</li> <li> 71. Simplify Path (Medium)</li> </ul>"},{"location":"endlesscheng/stack_basics/#1441-build-an-array-with-stack-operations","title":"1441. Build an Array With Stack Operations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, simulation</p> </li> </ul>"},{"location":"endlesscheng/stack_basics/#844-backspace-string-compare","title":"844. Backspace String Compare","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string, stack, simulation</p> </li> </ul> 844. Backspace String Compare - Python Solution<pre><code>def backspaceCompare(s: str, t: str) -&gt; bool:\n\n    def build(text):\n        stack = []\n\n        for char in text:\n            if char != \"#\":\n                stack.append(char)\n            elif stack:\n                stack.pop()\n\n        return \"\".join(stack)\n\n    return build(s) == build(t)\n\n\nprint(backspaceCompare(\"ab#c\", \"ad#c\"))  # True\n</code></pre>"},{"location":"endlesscheng/stack_basics/#682-baseball-game","title":"682. Baseball Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, stack, simulation</p> </li> </ul>"},{"location":"endlesscheng/stack_basics/#2390-removing-stars-from-a-string","title":"2390. Removing Stars From a String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack, simulation</p> </li> <li> <p>Remove all <code>*</code> characters and their adjacent characters from the string.</p> </li> <li> <p>Steps for the string <code>leet**cod*e</code>:</p> </li> </ul> char action stack l push \"l\" e push \"le\" e push \"lee\" t push \"leet\" * pop \"lee\" * pop \"le\" c push \"lec\" o push \"leco\" d push \"lecod\" * pop \"leco\" e push \"lecoe\" 2390. Removing Stars From a String - Python Solution<pre><code># Stack\ndef removeStars(s: str) -&gt; str:\n    stack = []\n\n    for char in s:\n        if char == \"*\":\n            stack.pop()\n        else:\n            stack.append(char)\n\n    return \"\".join(stack)\n\n\ns = \"leet**cod*e\"\nprint(removeStars(s))  # \"lecoe\"\n</code></pre>"},{"location":"endlesscheng/stack_basics/#1472-design-browser-history","title":"1472. Design Browser History","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, linked list, stack, design, doubly linked list, data stream</p> </li> </ul>"},{"location":"endlesscheng/stack_basics/#946-validate-stack-sequences","title":"946. Validate Stack Sequences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, simulation</p> </li> </ul>"},{"location":"endlesscheng/stack_basics/#3412-find-mirror-score-of-a-string","title":"3412. Find Mirror Score of a String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, stack, simulation</p> </li> </ul>"},{"location":"endlesscheng/stack_basics/#71-simplify-path","title":"71. Simplify Path","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack</p> </li> </ul>"},{"location":"endlesscheng/strongly_and_biconnected_components/","title":"Strongly and Biconnected Components","text":"<ul> <li> 1192. Critical Connections in a Network (Hard)</li> <li> 1568. Minimum Number of Days to Disconnect Island (Hard)</li> <li> 3383. Minimum Runes to Add to Cast Spell (Hard)</li> </ul>"},{"location":"endlesscheng/strongly_and_biconnected_components/#1192-critical-connections-in-a-network","title":"1192. Critical Connections in a Network","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: depth first search, graph, biconnected component</p> </li> </ul> 1192. Critical Connections in a Network - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Tarjan\ndef criticalConnections(\n    n: int, connections: List[List[int]]\n) -&gt; List[List[int]]:\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    disc = [-1] * n\n    low = [-1] * n\n    bridges = []\n    time = 0\n\n    def dfs(n1, prev):\n        nonlocal time\n        disc[n1], low[n1] = time, time\n        time += 1\n\n        for n2 in graph[n1]:\n            if n2 == prev:\n                continue\n            if disc[n2] == -1:\n                dfs(n2, n1)\n                low[n1] = min(low[n1], low[n2])\n\n                if low[n2] &gt; disc[n1]:\n                    bridges.append([n1, n2])\n            else:\n                low[n1] = min(low[n1], disc[n2])\n\n    for i in range(n):\n        if disc[i] == -1:\n            dfs(i, -1)\n\n    return bridges\n\n\nn = 4\nconnections = [[0, 1], [1, 2], [2, 0], [1, 3]]\nprint(criticalConnections(n, connections))  # [[1, 3]]\n</code></pre>"},{"location":"endlesscheng/strongly_and_biconnected_components/#1568-minimum-number-of-days-to-disconnect-island","title":"1568. Minimum Number of Days to Disconnect Island","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, matrix, strongly connected component</p> </li> </ul>"},{"location":"endlesscheng/strongly_and_biconnected_components/#3383-minimum-runes-to-add-to-cast-spell","title":"3383. Minimum Runes to Add to Cast Spell","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, graph, topological sort</p> </li> </ul>"},{"location":"endlesscheng/three_pointers/","title":"Three Pointers","text":"<ul> <li> 2367. Number of Arithmetic Triplets (Easy)</li> <li> 2563. Count the Number of Fair Pairs (Medium)</li> <li> 795. Number of Subarrays with Bounded Maximum (Medium)</li> <li> 2444. Count Subarrays With Fixed Bounds (Hard)</li> <li> 3347. Maximum Frequency of an Element After Performing Operations II (Hard)</li> <li> 1213. Intersection of Three Sorted Arrays (Easy)</li> </ul>"},{"location":"endlesscheng/three_pointers/#2367-number-of-arithmetic-triplets","title":"2367. Number of Arithmetic Triplets","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, two pointers, enumeration</p> </li> </ul>"},{"location":"endlesscheng/three_pointers/#2563-count-the-number-of-fair-pairs","title":"2563. Count the Number of Fair Pairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, sorting</p> </li> </ul>"},{"location":"endlesscheng/three_pointers/#795-number-of-subarrays-with-bounded-maximum","title":"795. Number of Subarrays with Bounded Maximum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers</p> </li> </ul>"},{"location":"endlesscheng/three_pointers/#2444-count-subarrays-with-fixed-bounds","title":"2444. Count Subarrays With Fixed Bounds","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, queue, sliding window, monotonic queue</p> </li> </ul>"},{"location":"endlesscheng/three_pointers/#3347-maximum-frequency-of-an-element-after-performing-operations-ii","title":"3347. Maximum Frequency of an Element After Performing Operations II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, sliding window, sorting, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/three_pointers/#1213-intersection-of-three-sorted-arrays","title":"1213. Intersection of Three Sorted Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, binary search, counting</p> </li> </ul>"},{"location":"endlesscheng/topological_order_dp/","title":"Topological Order DP","text":"<ul> <li> 2050. Parallel Courses III (Hard)</li> <li> 1857. Largest Color Value in a Directed Graph (Hard)</li> </ul>"},{"location":"endlesscheng/topological_order_dp/#2050-parallel-courses-iii","title":"2050. Parallel Courses III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, graph, topological sort</p> </li> </ul>"},{"location":"endlesscheng/topological_order_dp/#1857-largest-color-value-in-a-directed-graph","title":"1857. Largest Color Value in a Directed Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, dynamic programming, graph, topological sort, memoization, counting</p> </li> </ul> 1857. Largest Color Value in a Directed Graph - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# Topological Sort\ndef largestPathValue(colors: str, edges: List[List[int]]) -&gt; int:\n    n = len(colors)\n    graph = defaultdict(list)\n    indegree = [0 for _ in range(n)]\n\n    for u, v in edges:\n        graph[u].append(v)\n        indegree[v] += 1\n\n    q = deque([i for i in range(n) if indegree[i] == 0])\n\n    dp = [[0] * 26 for _ in range(n)]\n\n    for i in range(n):\n        dp[i][ord(colors[i]) - ord(\"a\")] = 1\n\n    processed, max_color = 0, 0\n\n    while q:\n        n1 = q.popleft()\n        processed += 1\n        max_color = max(max_color, max(dp[n1]))\n\n        for n2 in graph[n1]:\n            indegree[n2] -= 1\n            for i in range(26):\n                dp[n2][i] = max(\n                    dp[n2][i],\n                    dp[n1][i] + (1 if i == ord(colors[n2]) - ord(\"a\") else 0),\n                )\n            if indegree[n2] == 0:\n                q.append(n2)\n\n    return max_color if processed == n else -1\n\n\ncolors = \"abaca\"\nedges = [[0, 1], [0, 2], [2, 3], [3, 4]]\nprint(largestPathValue(colors, edges))  # 3\n</code></pre>"},{"location":"endlesscheng/topological_sorting/","title":"Topological Sorting","text":"<ul> <li> 1557. Minimum Number of Vertices to Reach All Nodes (Medium)</li> <li> 210. Course Schedule II (Medium)</li> <li> 1462. Course Schedule IV (Medium)</li> <li> 2115. Find All Possible Recipes from Given Supplies (Medium)</li> <li> 851. Loud and Rich (Medium)</li> <li> 310. Minimum Height Trees (Medium)</li> <li> 2392. Build a Matrix With Conditions (Hard)</li> <li> 802. Find Eventual Safe States (Medium)</li> <li> 1591. Strange Printer II (Hard)</li> <li> 1203. Sort Items by Groups Respecting Dependencies (Hard)</li> <li> 2603. Collect Coins in a Tree (Hard)</li> <li> 269. Alien Dictionary (Hard)</li> <li> 444. Sequence Reconstruction (Medium)</li> <li> 1059. All Paths from Source Lead to Destination (Medium)</li> <li> 1136. Parallel Courses (Medium)</li> </ul>"},{"location":"endlesscheng/topological_sorting/#1557-minimum-number-of-vertices-to-reach-all-nodes","title":"1557. Minimum Number of Vertices to Reach All Nodes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: graph</p> </li> <li>Return a list of integers representing the minimum number of vertices needed to traverse all the nodes.</li> <li>\u2705 Return the vertices with indegree 0.</li> </ul> <p></p> <ul> <li><code>edges = [[0, 1], [0, 2], [2, 5], [3, 4], [4, 2]]</code></li> <li>Initialization</li> </ul> <code>src</code> 0 0 2 3 4 <code>dst</code> 1 2 5 4 2 node 0 1 2 3 4 5 in-degree 0 0 0 0 0 0 <code>src</code> 0 0 2 3 4 <code>dst</code> 1 2 5 4 2 node 0 1 2 3 4 5 in-degree 0 1 0 0 0 0 <code>src</code> 0 0 2 3 4 <code>dst</code> 1 2 5 4 2 node 0 1 2 3 4 5 in-degree 0 1 1 0 0 0 <code>src</code> 0 0 2 3 4 <code>dst</code> 1 2 5 4 2 node 0 1 2 3 4 5 in-degree 0 1 1 0 0 1 <code>src</code> 0 0 2 3 4 <code>dst</code> 1 2 5 4 2 node 0 1 2 3 4 5 in-degree 0 1 1 0 1 1 <code>src</code> 0 0 2 3 4 <code>dst</code> 1 2 5 4 2 node 0 1 2 3 4 5 in-degree 0 1 2 0 1 1 1557. Minimum Number of Vertices to Reach All Nodes - Python Solution<pre><code>from typing import List\n\n\n# Graph\ndef findSmallestSetOfVertices(n: int, edges: List[List[int]]) -&gt; List[int]:\n    indegree = {i: 0 for i in range(n)}\n\n    for a, b in edges:\n        indegree[b] += 1\n\n    return [i for i in range(n) if indegree[i] == 0]\n\n\nn = 6\nedges = [[0, 1], [0, 2], [2, 5], [3, 4], [4, 2]]\nprint(findSmallestSetOfVertices(n, edges))  # [0, 3]\n</code></pre>"},{"location":"endlesscheng/topological_sorting/#210-course-schedule-ii","title":"210. Course Schedule II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort</p> </li> <li>Return the ordering of courses you should take to finish all courses. If there are multiple valid answers, return any of them.</li> </ul> <p></p> 210. Course Schedule II - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# 1. BFS - Kahn's Algorithm\ndef findOrderBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    order = []\n\n    while q:\n        pre = q.popleft()\n        order.append(pre)\n\n        for crs in graph[pre]:\n            indegree[crs] -= 1\n            if indegree[crs] == 0:\n                q.append(crs)\n\n    return order if len(order) == numCourses else []\n\n\n# 2. DFS + Set\ndef findOrderDFS1(\n    numCourses: int, prerequisites: List[List[int]]\n) -&gt; List[int]:\n    adj = defaultdict(list)\n    for crs, pre in prerequisites:\n        adj[crs].append(pre)\n\n    visit, cycle = set(), set()\n    order = []\n\n    def dfs(crs):\n        if crs in cycle:\n            return False\n        if crs in visit:\n            return True\n\n        cycle.add(crs)\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        cycle.remove(crs)\n        visit.add(crs)\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order\n\n\n# 3. DFS + List\ndef findOrderDFS2(\n    numCourses: int, prerequisites: List[List[int]]\n) -&gt; List[int]:\n    adj = defaultdict(list)\n    for pre, crs in prerequisites:\n        adj[crs].append(pre)\n\n    # 0: not visited, 1: visiting, 2: visited\n    state = [0] * numCourses\n    order = []\n\n    def dfs(crs):\n        if state[crs] == 1:\n            return False\n        if state[crs] == 2:\n            return True\n\n        state[crs] = 1\n\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        state[crs] = 2\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order[::-1]\n\n\nnumCourses = 5\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(findOrderBFS(numCourses, prerequisites))  # [2, 4, 3, 1, 0]\nprint(findOrderDFS1(numCourses, prerequisites))  # [4, 3, 1, 2, 0]\nprint(findOrderDFS2(numCourses, prerequisites))  # [4, 3, 2, 1, 0]\n</code></pre>"},{"location":"endlesscheng/topological_sorting/#1462-course-schedule-iv","title":"1462. Course Schedule IV","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort</p> </li> </ul>"},{"location":"endlesscheng/topological_sorting/#2115-find-all-possible-recipes-from-given-supplies","title":"2115. Find All Possible Recipes from Given Supplies","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, graph, topological sort</p> </li> </ul>"},{"location":"endlesscheng/topological_sorting/#851-loud-and-rich","title":"851. Loud and Rich","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, graph, topological sort</p> </li> </ul>"},{"location":"endlesscheng/topological_sorting/#310-minimum-height-trees","title":"310. Minimum Height Trees","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort</p> </li> </ul>"},{"location":"endlesscheng/topological_sorting/#2392-build-a-matrix-with-conditions","title":"2392. Build a Matrix With Conditions","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, graph, topological sort, matrix</p> </li> </ul>"},{"location":"endlesscheng/topological_sorting/#802-find-eventual-safe-states","title":"802. Find Eventual Safe States","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort</p> </li> </ul> 802. Find Eventual Safe States - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# Topological Sort\ndef eventualSafeNodesTS(graph: List[List[int]]) -&gt; List[int]:\n    n = len(graph)\n    reverse_graph = defaultdict(list)\n    indegree = [0 for _ in range(n)]\n    safe = [False for _ in range(n)]\n\n    for u in range(n):\n        for v in graph[u]:\n            reverse_graph[v].append(u)\n        indegree[u] = len(graph[u])\n\n    q = deque([i for i in range(n) if indegree[i] == 0])\n\n    while q:\n        node = q.popleft()\n        safe[node] = True\n\n        for neighbor in reverse_graph[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n\n    return [i for i in range(n) if safe[i]]\n\n\n# DFS\ndef eventualSafeNodesDFS(graph: List[List[int]]) -&gt; List[int]:\n    n = len(graph)\n    state = [0 for _ in range(n)]  # 0: unvisited, 1: visiting, 2: visited\n\n    def dfs(node):\n        if state[node] &gt; 0:\n            return state[node] == 2\n        state[node] = 1\n        for neighbor in graph[node]:\n            if state[neighbor] == 1 or not dfs(neighbor):\n                return False\n        state[node] = 2\n        return True\n\n    return [i for i in range(n) if dfs(i)]\n\n\ngraph = [[1, 2], [2, 3], [5], [0], [5], [], []]\nprint(eventualSafeNodesTS(graph))  # [2, 4, 5, 6]\nprint(eventualSafeNodesDFS(graph))  # [2, 4, 5, 6]\n</code></pre>"},{"location":"endlesscheng/topological_sorting/#1591-strange-printer-ii","title":"1591. Strange Printer II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, graph, topological sort, matrix</p> </li> </ul>"},{"location":"endlesscheng/topological_sorting/#1203-sort-items-by-groups-respecting-dependencies","title":"1203. Sort Items by Groups Respecting Dependencies","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort</p> </li> <li>Return any permutation of the items that satisfies the requirements.</li> </ul> 1203. Sort Items by Groups Respecting Dependencies - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS - Kahn's algorithm (Topological Sort)\ndef sortItems(\n    n: int, m: int, group: List[int], beforeItems: List[List[int]]\n) -&gt; List[int]:\n    def topological_sort(graph, indegree, nodes):\n        q = deque([node for node in nodes if indegree[node] == 0])\n        result = []\n\n        while q:\n            node = q.popleft()\n            result.append(node)\n\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    q.append(neighbor)\n\n        return result if len(result) == len(nodes) else []\n\n    groupItems = defaultdict(list)\n    groupGraph = defaultdict(set)\n    groupIndegree = defaultdict(int)\n    itemGraph = defaultdict(set)\n    itemIndegree = defaultdict(int)\n\n    for i in range(n):\n        if group[i] == -1:\n            group[i] = m\n            m += 1\n        groupItems[group[i]].append(i)\n\n    for i, beforeItem in enumerate(beforeItems):\n        for before in beforeItem:\n            if group[before] != group[i]:\n                if group[i] not in groupGraph[group[before]]:\n                    groupGraph[group[before]].add(group[i])\n                    groupIndegree[group[i]] += 1\n            else:\n                itemGraph[before].add(i)\n                itemIndegree[i] += 1\n\n    allGroups = list(set(group))\n    groupOrder = topological_sort(groupGraph, groupIndegree, allGroups)\n    if not groupOrder:\n        return []\n\n    result = []\n    for g in groupOrder:\n        items = groupItems[g]\n        itemOrder = topological_sort(itemGraph, itemIndegree, items)\n        if not itemOrder:\n            return []\n        result.extend(itemOrder)\n\n    return result\n\n\nn = 8\nm = 2\ngroup = [-1, -1, 1, 0, 0, 1, 0, -1]\nbeforeItems = [[], [6], [5], [6], [3, 6], [], [], []]\nprint(sortItems(n, m, group, beforeItems))\n</code></pre>"},{"location":"endlesscheng/topological_sorting/#2603-collect-coins-in-a-tree","title":"2603. Collect Coins in a Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, tree, graph, topological sort</p> </li> </ul>"},{"location":"endlesscheng/topological_sorting/#269-alien-dictionary","title":"269. Alien Dictionary","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, depth first search, breadth first search, graph, topological sort</p> </li> <li>Return the correct order of characters in the alien language.</li> </ul> 269. Alien Dictionary - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS - Kahn's algorithm (Topological Sort)\ndef alienOrderBFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    indegree = {c: 0 for word in words for c in word}\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                    indegree[w2[j]] += 1\n                break\n\n    q = deque([c for c in indegree if indegree[c] == 0])\n    result = []\n\n    while q:\n        char = q.popleft()\n        result.append(char)\n\n        for neighbor in graph[char]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n\n    return \"\".join(result) if len(result) == len(indegree) else \"\"\n\n\n# DFS - Topological Sort\ndef alienOrderDFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    visited = {}\n    result = []\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                break\n\n    def dfs(c):\n        if c in visited:\n            return visited[c]\n\n        visited[c] = False\n        for neighbor in graph[c]:\n            if not dfs(neighbor):\n                return False\n\n        visited[c] = True\n        result.append(c)\n        return True\n\n    for c in list(graph.keys()):\n        if not dfs(c):\n            return \"\"\n\n    return \"\".join(result[::-1])\n\n\nwords = [\"wrt\", \"wrf\", \"er\", \"ett\", \"rftt\"]\nprint(alienOrderBFS(words))  # wertf\nprint(alienOrderDFS(words))  # wertf\n</code></pre>"},{"location":"endlesscheng/topological_sorting/#444-sequence-reconstruction","title":"444. Sequence Reconstruction","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, graph, topological sort</p> </li> </ul>"},{"location":"endlesscheng/topological_sorting/#1059-all-paths-from-source-lead-to-destination","title":"1059. All Paths from Source Lead to Destination","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: graph, topological sort</p> </li> </ul>"},{"location":"endlesscheng/topological_sorting/#1136-parallel-courses","title":"1136. Parallel Courses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: graph, topological sort</p> </li> <li>Return the minimum number of semesters needed to take all courses.</li> </ul> <p></p> 1136. Parallel Courses - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# Topological Sort\ndef minimumSemesters(n: int, relations: List[List[int]]) -&gt; int:\n    graph = {i: [] for i in range(1, n + 1)}\n    indegree = {i: 0 for i in range(1, n + 1)}\n\n    for pre, nxt in relations:\n        graph[pre].append(nxt)\n        indegree[nxt] += 1\n\n    q = deque([i for i in range(1, n + 1) if indegree[i] == 0])\n    semester = 0\n    done = 0\n\n    while q:\n        semester += 1\n        size = len(q)\n\n        for _ in range(size):\n            pre = q.popleft()\n            done += 1\n\n            for nxt in graph[pre]:\n                indegree[nxt] -= 1\n                if indegree[nxt] == 0:\n                    q.append(nxt)\n\n    return semester if done == n else -1\n\n\nn = 3\nrelations = [[1, 3], [2, 3]]\nprint(minimumSemesters(n, relations))  # 2\n</code></pre>"},{"location":"endlesscheng/trie_advanced/","title":"Trie Advanced","text":"<ul> <li> 676. Implement Magic Dictionary (Medium)</li> <li> 212. Word Search II (Hard)</li> <li> 3093. Longest Common Suffix Queries (Hard)</li> <li> 745. Prefix and Suffix Search (Hard)</li> <li> 3045. Count Prefix and Suffix Pairs II (Hard)</li> <li> 336. Palindrome Pairs (Hard)</li> <li> 1948. Delete Duplicate Folders in System (Hard)</li> <li> 425. Word Squares (Hard)</li> <li> 527. Word Abbreviation (Hard)</li> <li> 588. Design In-Memory File System (Hard)</li> <li> 616. Add Bold Tag in String (Medium)</li> <li> 758. Bold Words in String (Medium)</li> <li> 642. Design Search Autocomplete System (Hard)</li> <li> 1065. Index Pairs of a String (Easy)</li> <li> 1166. Design File System (Medium)</li> <li> 1858. Longest Word With All Prefixes (Medium)</li> </ul>"},{"location":"endlesscheng/trie_advanced/#676-implement-magic-dictionary","title":"676. Implement Magic Dictionary","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, depth first search, design, trie</p> </li> </ul>"},{"location":"endlesscheng/trie_advanced/#212-word-search-ii","title":"212. Word Search II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, backtracking, trie, matrix</p> </li> </ul> 212. Word Search II - Python Solution<pre><code>from typing import List\n\nfrom template import TrieNode\n\n\n# Backtracking + Trie\ndef findWords(board: List[List[str]], words: List[str]) -&gt; List[str]:\n    root = TrieNode()\n    for word in words:\n        root.addWord(word)\n\n    m, n = len(board), len(board[0])\n    result, visit = set(), set()\n\n    def dfs(r, c, node, word):\n        if (\n            r &lt; 0\n            or r &gt;= m\n            or c &lt; 0\n            or c &gt;= n\n            or (r, c) in visit\n            or board[r][c] not in node.children\n        ):\n            return None\n\n        visit.add((r, c))\n\n        node = node.children[board[r][c]]\n        word += board[r][c]\n        if node.isWord:\n            result.add(word)\n\n        dfs(r - 1, c, node, word)\n        dfs(r + 1, c, node, word)\n        dfs(r, c - 1, node, word)\n        dfs(r, c + 1, node, word)\n\n        visit.remove((r, c))\n\n    for r in range(m):\n        for c in range(n):\n            dfs(r, c, root, \"\")\n\n    return list(result)\n\n\nboard = [\n    [\"o\", \"a\", \"a\", \"n\"],\n    [\"e\", \"t\", \"a\", \"e\"],\n    [\"i\", \"h\", \"k\", \"r\"],\n    [\"i\", \"f\", \"l\", \"v\"],\n]\nwords = [\"oath\", \"pea\", \"eat\", \"rain\"]\nprint(findWords(board, words))\n# ['eat', 'oath']\n</code></pre>"},{"location":"endlesscheng/trie_advanced/#3093-longest-common-suffix-queries","title":"3093. Longest Common Suffix Queries","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, trie</p> </li> </ul>"},{"location":"endlesscheng/trie_advanced/#745-prefix-and-suffix-search","title":"745. Prefix and Suffix Search","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, string, design, trie</p> </li> </ul>"},{"location":"endlesscheng/trie_advanced/#3045-count-prefix-and-suffix-pairs-ii","title":"3045. Count Prefix and Suffix Pairs II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, trie, rolling hash, string matching, hash function</p> </li> </ul>"},{"location":"endlesscheng/trie_advanced/#336-palindrome-pairs","title":"336. Palindrome Pairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, string, trie</p> </li> </ul>"},{"location":"endlesscheng/trie_advanced/#1948-delete-duplicate-folders-in-system","title":"1948. Delete Duplicate Folders in System","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, string, trie, hash function</p> </li> </ul>"},{"location":"endlesscheng/trie_advanced/#425-word-squares","title":"425. Word Squares","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, backtracking, trie</p> </li> </ul>"},{"location":"endlesscheng/trie_advanced/#527-word-abbreviation","title":"527. Word Abbreviation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, greedy, trie, sorting</p> </li> </ul>"},{"location":"endlesscheng/trie_advanced/#588-design-in-memory-file-system","title":"588. Design In-Memory File System","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, design, trie, sorting</p> </li> </ul> 588. Design In-Memory File System - Python Solution<pre><code>from collections import defaultdict\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children = defaultdict(TrieNode)\n        self.content = \"\"\n\n\n# Trie\nclass FileSystem:\n\n    def __init__(self):\n        self.root = TrieNode()\n\n    def ls(self, path: str) -&gt; list:\n        cur = self.root\n\n        if path != \"/\":\n            paths = path.split(\"/\")[1:]\n            for p in paths:\n                cur = cur.children[p]\n        if cur.content:\n            return [path.split(\"/\")[-1]]\n\n        return sorted(cur.children.keys())\n\n    def mkdir(self, path: str) -&gt; None:\n        cur = self.root\n        paths = path.split(\"/\")[1:]\n        for p in paths:\n            cur = cur.children[p]\n\n    def addContentToFile(self, filePath: str, content: str) -&gt; None:\n        cur = self.root\n        paths = filePath.split(\"/\")[1:]\n        for p in paths:\n            cur = cur.children[p]\n        cur.content += content\n\n    def readContentFromFile(self, filePath: str) -&gt; str:\n        cur = self.root\n        paths = filePath.split(\"/\")[1:]\n        for p in paths:\n            cur = cur.children[p]\n        return cur.content\n\n\nobj = FileSystem()\nobj.mkdir(\"/a/b/c\")\nobj.addContentToFile(\"/a/b/c/d\", \"hello\")\nprint(obj.ls(\"/\"))  # [\"a\"]\nprint(obj.readContentFromFile(\"/a/b/c/d\"))  # \"hello\"\n</code></pre>"},{"location":"endlesscheng/trie_advanced/#616-add-bold-tag-in-string","title":"616. Add Bold Tag in String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, trie, string matching</p> </li> </ul>"},{"location":"endlesscheng/trie_advanced/#758-bold-words-in-string","title":"758. Bold Words in String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, trie, string matching</p> </li> </ul>"},{"location":"endlesscheng/trie_advanced/#642-design-search-autocomplete-system","title":"642. Design Search Autocomplete System","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, depth first search, design, trie, sorting, heap priority queue, data stream</p> </li> </ul>"},{"location":"endlesscheng/trie_advanced/#1065-index-pairs-of-a-string","title":"1065. Index Pairs of a String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, string, trie, sorting</p> </li> </ul>"},{"location":"endlesscheng/trie_advanced/#1166-design-file-system","title":"1166. Design File System","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, design, trie</p> </li> </ul> 1166. Design File System - Python Solution<pre><code>from collections import defaultdict\n\n\nclass TrieNode:\n    def __init__(self, name):\n        self.name = name\n        self.children = defaultdict(TrieNode)\n        self.value = -1\n\n\n# Trie\nclass FileSystem:\n    def __init__(self):\n        self.root = TrieNode(\"\")\n\n    def createPath(self, path: str, value: int) -&gt; bool:\n        paths = path.split(\"/\")[1:]\n        cur = self.root\n\n        for idx, path in enumerate(paths):\n            if path not in cur.children:\n                if idx == len(paths) - 1:\n                    cur.children[path] = TrieNode(path)\n                else:\n                    return False\n            cur = cur.children[path]\n\n        if cur.value != -1:\n            return False\n        cur.value = value\n        return True\n\n    def get(self, path: str) -&gt; int:\n        cur = self.root\n        paths = path.split(\"/\")[1:]\n\n        for path in paths:\n            if path not in cur.children:\n                return -1\n            cur = cur.children[path]\n\n        return cur.value\n\n\n# Your FileSystem object will be instantiated and called as such:\npath = \"/a\"\nvalue = 1\nobj = FileSystem()\nprint(obj.createPath(path, value))  # False\nprint(obj.get(path))  # 1\n</code></pre>"},{"location":"endlesscheng/trie_advanced/#1858-longest-word-with-all-prefixes","title":"1858. Longest Word With All Prefixes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, trie</p> </li> </ul>"},{"location":"endlesscheng/trie_basics/","title":"Trie Basics","text":"<ul> <li> 208. Implement Trie (Prefix Tree) (Medium)</li> <li> 211. Design Add and Search Words Data Structure (Medium)</li> <li> 14. Longest Common Prefix (Easy)</li> <li> 648. Replace Words (Medium)</li> <li> 677. Map Sum Pairs (Medium)</li> <li> 720. Longest Word in Dictionary (Medium)</li> <li> 1268. Search Suggestions System (Medium)</li> <li> 1233. Remove Sub-Folders from the Filesystem (Medium)</li> <li> 820. Short Encoding of Words (Medium)</li> <li> 2416. Sum of Prefix Scores of Strings (Hard)</li> <li> 2261. K Divisible Elements Subarrays (Medium)</li> <li> 1804. Implement Trie II (Prefix Tree) (Medium)</li> <li> 2168. Unique Substrings With Equal Digit Frequency (Medium)</li> </ul>"},{"location":"endlesscheng/trie_basics/#208-implement-trie-prefix-tree","title":"208. Implement Trie (Prefix Tree)","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, design, trie</p> </li> </ul>"},{"location":"endlesscheng/trie_basics/#trie","title":"Trie","text":"<ul> <li>A trie is a tree-like data structure whose nodes store the letters of an alphabet.</li> </ul> <pre><code>flowchart TD\nRoot(( ))\nRoot --- C1((\"C\"))\nRoot --- D((D))\nC1 --- A1((\"A\"))\nA1 --- T1((\"T\"))\nA1 --- R1((\"R\"))\nA1 --- N((N))\nRoot --- B1((B))\nB1 --- A2((A))\nA2 --- T2((T))\nA2 --- R2((R))</code></pre> 208. Implement Trie (Prefix Tree) - Python Solution<pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.endOfWord = None\n\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.endOfWord = True\n\n    def search(self, word: str) -&gt; bool:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return node.endOfWord\n\n    def startsWith(self, prefix: str) -&gt; bool:\n        node = self.root\n\n        for c in prefix:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return True\n\n\n# Your Trie object will be instantiated and called as such:\nobj = Trie()\nobj.insert(\"apple\")\nprint(obj.search(\"word\"))  # False\nprint(obj.startsWith(\"app\"))  # True\n</code></pre>"},{"location":"endlesscheng/trie_basics/#211-design-add-and-search-words-data-structure","title":"211. Design Add and Search Words Data Structure","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, depth first search, design, trie</p> </li> </ul> 211. Design Add and Search Words Data Structure - Python Solution<pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.word = False\n\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.word = True\n\n    def search(self, word: str) -&gt; bool:\n\n        def dfs(j, root):\n            node = root\n\n            for i in range(j, len(word)):\n                c = word[i]\n\n                if c == \".\":\n                    for child in node.children.values():\n                        if dfs(i + 1, child):\n                            return True\n                    return False\n                else:\n                    if c not in node.children:\n                        return False\n                    node = node.children[c]\n            return node.word\n\n        return dfs(0, self.root)\n\n\n# Your WordDictionary object will be instantiated and called as such:\nobj = WordDictionary()\nobj.addWord(\"word\")\nprint(obj.search(\"word\"))\nprint(obj.search(\"w.rd\"))\n</code></pre>"},{"location":"endlesscheng/trie_basics/#14-longest-common-prefix","title":"14. Longest Common Prefix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, trie</p> </li> </ul> 14. Longest Common Prefix - Python Solution<pre><code>from typing import List\n\n\n# Horizontal Scanning\ndef longestCommonPrefixHorizontal(strs: List[str]) -&gt; str:\n    if not strs:\n        return \"\"\n\n    prefix = strs[0]\n    for i in range(1, len(strs)):\n        while not strs[i].startswith(prefix):\n            prefix = prefix[:-1]\n            if not prefix:\n                return \"\"\n\n    return prefix\n\n\n# Vertical Scanning\ndef longestCommonPrefixVertical(strs: List[str]) -&gt; str:\n    if not strs:\n        return \"\"\n\n    for i in range(len(strs[0])):\n        char = strs[0][i]\n        for j in range(1, len(strs)):\n            if i &gt;= len(strs[j]) or strs[j][i] != char:\n                return strs[0][:i]\n\n    return strs[0]\n\n\n# Divide and Conquer\ndef longestCommonPrefixDivideConquer(strs: List[str]) -&gt; str:\n    if not strs:\n        return \"\"\n\n    def merge(left, right):\n        n = min(len(left), len(right))\n        for i in range(n):\n            if left[i] != right[i]:\n                return left[:i]\n        return left[:n]\n\n    def helper(strs, start, end):\n        if start == end:\n            return strs[start]\n        mid = start + (end - start) // 2\n        left = helper(strs, start, mid)\n        right = helper(strs, mid + 1, end)\n        return merge(left, right)\n\n    return helper(strs, 0, len(strs) - 1)\n\n\n# Binary Search\ndef longestCommonPrefixBinarySearch(strs: List[str]) -&gt; str:\n    if not strs:\n        return \"\"\n\n    def isCommonPrefix(strs, length):\n        prefix = strs[0][:length]\n        return all(s.startswith(prefix) for s in strs)\n\n    minLen = min(len(s) for s in strs)\n    low, high = 0, minLen\n    while low &lt; high:\n        mid = low + (high - low) // 2\n        if isCommonPrefix(strs, mid + 1):\n            low = mid + 1\n        else:\n            high = mid\n\n    return strs[0][:low]\n\n\nstrs = [\"flower\", \"flow\", \"flight\"]\nprint(longestCommonPrefixHorizontal(strs))  # \"fl\"\nprint(longestCommonPrefixVertical(strs))  # \"fl\"\nprint(longestCommonPrefixDivideConquer(strs))  # \"fl\"\nprint(longestCommonPrefixBinarySearch(strs))  # \"fl\"\n</code></pre>"},{"location":"endlesscheng/trie_basics/#648-replace-words","title":"648. Replace Words","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, trie</p> </li> </ul>"},{"location":"endlesscheng/trie_basics/#677-map-sum-pairs","title":"677. Map Sum Pairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, design, trie</p> </li> </ul>"},{"location":"endlesscheng/trie_basics/#720-longest-word-in-dictionary","title":"720. Longest Word in Dictionary","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, trie, sorting</p> </li> </ul>"},{"location":"endlesscheng/trie_basics/#1268-search-suggestions-system","title":"1268. Search Suggestions System","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, binary search, trie, sorting, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/trie_basics/#1233-remove-sub-folders-from-the-filesystem","title":"1233. Remove Sub-Folders from the Filesystem","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, depth first search, trie</p> </li> </ul>"},{"location":"endlesscheng/trie_basics/#820-short-encoding-of-words","title":"820. Short Encoding of Words","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, trie</p> </li> </ul>"},{"location":"endlesscheng/trie_basics/#2416-sum-of-prefix-scores-of-strings","title":"2416. Sum of Prefix Scores of Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, trie, counting</p> </li> </ul>"},{"location":"endlesscheng/trie_basics/#2261-k-divisible-elements-subarrays","title":"2261. K Divisible Elements Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, trie, rolling hash, hash function, enumeration</p> </li> </ul>"},{"location":"endlesscheng/trie_basics/#1804-implement-trie-ii-prefix-tree","title":"1804. Implement Trie II (Prefix Tree)","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, design, trie</p> </li> </ul>"},{"location":"endlesscheng/trie_basics/#2168-unique-substrings-with-equal-digit-frequency","title":"2168. Unique Substrings With Equal Digit Frequency","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, rolling hash, counting, hash function</p> </li> </ul>"},{"location":"endlesscheng/trie_optimized_dp/","title":"Trie Optimized DP","text":"<ul> <li> 139. Word Break (Medium)</li> <li> 140. Word Break II (Hard)</li> <li> 472. Concatenated Words (Hard)</li> <li> 2977. Minimum Cost to Convert String II (Hard)</li> </ul>"},{"location":"endlesscheng/trie_optimized_dp/#139-word-break","title":"139. Word Break","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, dynamic programming, trie, memoization</p> </li> </ul> 139. Word Break - Python Solution<pre><code>from typing import List\n\n\n# DP - Knapsack Unbounded\ndef wordBreak(s: str, wordDict: List[str]) -&gt; bool:\n    n = len(s)\n    wordSet = set(wordDict)\n    dp = [False for _ in range(n + 1)]\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in wordSet:\n                dp[i] = True\n                break\n\n    return dp[n]\n\n\ns = \"leetcode\"\nwordDict = [\"leet\", \"code\"]\nprint(wordBreak(s, wordDict))  # True\n</code></pre>"},{"location":"endlesscheng/trie_optimized_dp/#140-word-break-ii","title":"140. Word Break II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, string, dynamic programming, backtracking, trie, memoization</p> </li> </ul>"},{"location":"endlesscheng/trie_optimized_dp/#472-concatenated-words","title":"472. Concatenated Words","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, dynamic programming, depth first search, trie</p> </li> </ul>"},{"location":"endlesscheng/trie_optimized_dp/#2977-minimum-cost-to-convert-string-ii","title":"2977. Minimum Cost to Convert String II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, dynamic programming, graph, trie, shortest path</p> </li> </ul>"},{"location":"endlesscheng/two_sequences_subsequence_checking/","title":"Two Sequences Subsequence Checking","text":"<ul> <li> 392. Is Subsequence (Easy)</li> <li> 524. Longest Word in Dictionary through Deleting (Medium)</li> <li> 2486. Append Characters to String to Make Subsequence (Medium)</li> <li> 2825. Make String a Subsequence Using Cyclic Increments (Medium)</li> <li> 1023. Camelcase Matching (Medium)</li> <li> 3132. Find the Integer Added to Array II (Medium)</li> <li> 522. Longest Uncommon Subsequence II (Medium)</li> <li> 1898. Maximum Number of Removable Characters (Medium)</li> <li> 2565. Subsequence With the Minimum Score (Hard)</li> <li> 3302. Find the Lexicographically Smallest Valid Sequence (Medium)</li> </ul>"},{"location":"endlesscheng/two_sequences_subsequence_checking/#392-is-subsequence","title":"392. Is Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string, dynamic programming</p> </li> </ul> 392. Is Subsequence - Python Solution<pre><code># DP - LCS\ndef isSubsequenceLCS(s: str, t: str) -&gt; bool:\n    m = len(s)\n    n = len(t)\n\n    if m &gt; n:\n        return False\n\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    length = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = dp[i][j - 1]  # only delete t string\n\n            if length &lt; dp[i][j]:\n                length = dp[i][j]\n\n    return length == m\n\n\n# Two Pointers\ndef isSubsequenceTP(s: str, t: str) -&gt; bool:\n    i, j = 0, 0\n\n    while i &lt; len(s) and j &lt; len(t):\n        if s[i] == t[j]:\n            i += 1\n        j += 1\n\n    return i == len(s)\n\n\ns = \"abc\"\nt = \"ahbgdc\"\nprint(isSubsequenceLCS(s, t))  # True\nprint(isSubsequenceTP(s, t))  # True\n</code></pre>"},{"location":"endlesscheng/two_sequences_subsequence_checking/#524-longest-word-in-dictionary-through-deleting","title":"524. Longest Word in Dictionary through Deleting","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, string, sorting</p> </li> </ul>"},{"location":"endlesscheng/two_sequences_subsequence_checking/#2486-append-characters-to-string-to-make-subsequence","title":"2486. Append Characters to String to Make Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string, greedy</p> </li> </ul>"},{"location":"endlesscheng/two_sequences_subsequence_checking/#2825-make-string-a-subsequence-using-cyclic-increments","title":"2825. Make String a Subsequence Using Cyclic Increments","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string</p> </li> </ul>"},{"location":"endlesscheng/two_sequences_subsequence_checking/#1023-camelcase-matching","title":"1023. Camelcase Matching","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, string, trie, string matching</p> </li> </ul>"},{"location":"endlesscheng/two_sequences_subsequence_checking/#3132-find-the-integer-added-to-array-ii","title":"3132. Find the Integer Added to Array II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, sorting, enumeration</p> </li> </ul>"},{"location":"endlesscheng/two_sequences_subsequence_checking/#522-longest-uncommon-subsequence-ii","title":"522. Longest Uncommon Subsequence II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, two pointers, string, sorting</p> </li> </ul>"},{"location":"endlesscheng/two_sequences_subsequence_checking/#1898-maximum-number-of-removable-characters","title":"1898. Maximum Number of Removable Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, string, binary search</p> </li> </ul>"},{"location":"endlesscheng/two_sequences_subsequence_checking/#2565-subsequence-with-the-minimum-score","title":"2565. Subsequence With the Minimum Score","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: two pointers, string, binary search</p> </li> </ul>"},{"location":"endlesscheng/two_sequences_subsequence_checking/#3302-find-the-lexicographically-smallest-valid-sequence","title":"3302. Find the Lexicographically Smallest Valid Sequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string, dynamic programming, greedy</p> </li> </ul>"},{"location":"endlesscheng/two_sequences_two_pointers/","title":"Two Sequences Two Pointers","text":"<ul> <li> 2540. Minimum Common Value (Easy)</li> <li> 88. Merge Sorted Array (Easy)</li> <li> 2570. Merge Two 2D Arrays by Summing Values (Easy)</li> <li> 1855. Maximum Distance Between a Pair of Values (Medium)</li> <li> 1385. Find the Distance Value Between Two Arrays (Easy)</li> <li> 925. Long Pressed Name (Easy)</li> <li> 809. Expressive Words (Medium)</li> <li> 2337. Move Pieces to Obtain a String (Medium)</li> <li> 777. Swap Adjacent in LR String (Medium)</li> <li> 844. Backspace String Compare (Easy)</li> <li> 986. Interval List Intersections (Medium)</li> <li> 1537. Get the Maximum Score (Hard)</li> <li> 244. Shortest Word Distance II (Medium)</li> <li> 2838. Maximum Coins Heroes Can Collect (Medium)</li> <li> 1229. Meeting Scheduler (Medium)</li> <li> 1570. Dot Product of Two Sparse Vectors (Medium)</li> <li> 1868. Product of Two Run-Length Encoded Arrays (Medium)</li> </ul>"},{"location":"endlesscheng/two_sequences_two_pointers/#2540-minimum-common-value","title":"2540. Minimum Common Value","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, two pointers, binary search</p> </li> </ul>"},{"location":"endlesscheng/two_sequences_two_pointers/#88-merge-sorted-array","title":"88. Merge Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers, sorting</p> </li> </ul> 88. Merge Sorted Array - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef merge(nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None:\n    \"\"\"Merges two sorted arrays in-place.\"\"\"\n    p1, p2, t = m - 1, n - 1, m + n - 1\n\n    while p1 &gt;= 0 or p2 &gt;= 0:\n        if p1 == -1:\n            nums1[t] = nums2[p2]\n            p2 -= 1\n        elif p2 == -1:\n            nums1[t] = nums1[p1]\n            p1 -= 1\n        elif nums1[p1] &gt; nums2[p2]:\n            nums1[t] = nums1[p1]\n            p1 -= 1\n        else:\n            nums1[t] = nums2[p2]\n            p2 -= 1\n\n        t -= 1\n\n\nnums1 = [1, 2, 3, 0, 0, 0]\nm = 3\nnums2 = [2, 5, 6]\nn = 3\nmerge(nums1, m, nums2, n)\nprint(nums1)  # [1, 2, 2, 3, 5, 6]\n</code></pre>"},{"location":"endlesscheng/two_sequences_two_pointers/#2570-merge-two-2d-arrays-by-summing-values","title":"2570. Merge Two 2D Arrays by Summing Values","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, two pointers</p> </li> </ul>"},{"location":"endlesscheng/two_sequences_two_pointers/#1855-maximum-distance-between-a-pair-of-values","title":"1855. Maximum Distance Between a Pair of Values","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search</p> </li> </ul>"},{"location":"endlesscheng/two_sequences_two_pointers/#1385-find-the-distance-value-between-two-arrays","title":"1385. Find the Distance Value Between Two Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers, binary search, sorting</p> </li> </ul>"},{"location":"endlesscheng/two_sequences_two_pointers/#925-long-pressed-name","title":"925. Long Pressed Name","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string</p> </li> </ul>"},{"location":"endlesscheng/two_sequences_two_pointers/#809-expressive-words","title":"809. Expressive Words","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, string</p> </li> </ul>"},{"location":"endlesscheng/two_sequences_two_pointers/#2337-move-pieces-to-obtain-a-string","title":"2337. Move Pieces to Obtain a String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string</p> </li> </ul>"},{"location":"endlesscheng/two_sequences_two_pointers/#777-swap-adjacent-in-lr-string","title":"777. Swap Adjacent in LR String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string</p> </li> </ul>"},{"location":"endlesscheng/two_sequences_two_pointers/#844-backspace-string-compare","title":"844. Backspace String Compare","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string, stack, simulation</p> </li> </ul> 844. Backspace String Compare - Python Solution<pre><code>def backspaceCompare(s: str, t: str) -&gt; bool:\n\n    def build(text):\n        stack = []\n\n        for char in text:\n            if char != \"#\":\n                stack.append(char)\n            elif stack:\n                stack.pop()\n\n        return \"\".join(stack)\n\n    return build(s) == build(t)\n\n\nprint(backspaceCompare(\"ab#c\", \"ad#c\"))  # True\n</code></pre>"},{"location":"endlesscheng/two_sequences_two_pointers/#986-interval-list-intersections","title":"986. Interval List Intersections","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, line sweep</p> </li> </ul>"},{"location":"endlesscheng/two_sequences_two_pointers/#1537-get-the-maximum-score","title":"1537. Get the Maximum Score","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, dynamic programming, greedy</p> </li> </ul>"},{"location":"endlesscheng/two_sequences_two_pointers/#244-shortest-word-distance-ii","title":"244. Shortest Word Distance II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, two pointers, string, design</p> </li> </ul>"},{"location":"endlesscheng/two_sequences_two_pointers/#2838-maximum-coins-heroes-can-collect","title":"2838. Maximum Coins Heroes Can Collect","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, sorting, prefix sum</p> </li> </ul>"},{"location":"endlesscheng/two_sequences_two_pointers/#1229-meeting-scheduler","title":"1229. Meeting Scheduler","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, sorting</p> </li> </ul>"},{"location":"endlesscheng/two_sequences_two_pointers/#1570-dot-product-of-two-sparse-vectors","title":"1570. Dot Product of Two Sparse Vectors","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, two pointers, design</p> </li> </ul>"},{"location":"endlesscheng/two_sequences_two_pointers/#1868-product-of-two-run-length-encoded-arrays","title":"1868. Product of Two Run-Length Encoded Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers</p> </li> </ul>"},{"location":"endlesscheng/union_find_advanced/","title":"Union Find Advanced","text":"<ul> <li> 1202. Smallest String With Swaps (Medium)</li> <li> 1061. Lexicographically Smallest Equivalent String (Medium)</li> <li> 1722. Minimize Hamming Distance After Swap Operations (Medium)</li> <li> 765. Couples Holding Hands (Hard)</li> <li> 684. Redundant Connection (Medium)</li> <li> 685. Redundant Connection II (Hard)</li> <li> 947. Most Stones Removed with Same Row or Column (Medium)</li> <li> 839. Similar String Groups (Hard)</li> <li> 1970. Last Day Where You Can Still Cross (Hard)</li> <li> 2076. Process Restricted Friend Requests (Hard)</li> <li> 1579. Remove Max Number of Edges to Keep Graph Fully Traversable (Hard)</li> <li> 959. Regions Cut By Slashes (Medium)</li> <li> 2812. Find the Safest Path in a Grid (Medium)</li> <li> 2503. Maximum Number of Points From Grid Queries (Hard)</li> <li> 2867. Count Valid Paths in a Tree (Hard)</li> <li> 2421. Number of Good Paths (Hard)</li> <li> 2157. Groups of Strings (Hard)</li> <li> 1632. Rank Transform of a Matrix (Hard)</li> <li> 803. Bricks Falling When Hit (Hard)</li> <li> 1569. Number of Ways to Reorder Array to Get Same BST (Hard)</li> <li> 3235. Check if the Rectangle Corner Is Reachable (Hard)</li> <li> 2371. Minimize Maximum Value in a Grid (Hard)</li> <li> 2459. Sort Array by Moving Items to Empty Space (Hard)</li> </ul>"},{"location":"endlesscheng/union_find_advanced/#1202-smallest-string-with-swaps","title":"1202. Smallest String With Swaps","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, depth first search, breadth first search, union find, sorting</p> </li> </ul> 1202. Smallest String With Swaps - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef smallestStringWithSwaps(s: str, pairs: List[List[int]]) -&gt; str:\n    n = len(s)\n    par = list(range(n))\n    components = defaultdict(list)\n\n    def find(node):\n        p = par[node]\n        while par[p] != p:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 != p2:\n            par[p1] = p2\n\n    for index, j in pairs:\n        union(index, j)\n\n    for index in range(n):\n        components[find(index)].append(index)\n\n    res = list(s)\n    for indices in components.values():\n        chars = sorted([s[index] for index in indices])\n        for index, char in zip(indices, chars):\n            res[index] = char\n\n    return \"\".join(res)\n\n\ns = \"dcab\"\npairs = [[0, 3], [1, 2]]\nprint(smallestStringWithSwaps(s, pairs))  # \"bacd\"\n</code></pre>"},{"location":"endlesscheng/union_find_advanced/#1061-lexicographically-smallest-equivalent-string","title":"1061. Lexicographically Smallest Equivalent String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, union find</p> </li> </ul> 1061. Lexicographically Smallest Equivalent String - Python Solution<pre><code># Union Find\ndef smallestEquivalentString(s1: str, s2: str, baseStr: str) -&gt; str:\n    parent = {chr(i): chr(i) for i in range(ord(\"a\"), ord(\"z\") + 1)}\n\n    def find(n):\n        p = parent[n]\n        while parent[p] != p:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            if p1 &lt; p2:\n                parent[p2] = p1\n            else:\n                parent[p1] = p2\n\n    for i in range(len(s1)):\n        union(s1[i], s2[i])\n\n    result = []\n    for c in baseStr:\n        result.append(find(c))\n\n    return \"\".join(result)\n\n\ns1 = \"parker\"\ns2 = \"morris\"\nbaseStr = \"parser\"\nprint(smallestEquivalentString(s1, s2, baseStr))  # \"makkek\"\n</code></pre>"},{"location":"endlesscheng/union_find_advanced/#1722-minimize-hamming-distance-after-swap-operations","title":"1722. Minimize Hamming Distance After Swap Operations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, union find</p> </li> </ul>"},{"location":"endlesscheng/union_find_advanced/#765-couples-holding-hands","title":"765. Couples Holding Hands","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: greedy, depth first search, breadth first search, union find, graph</p> </li> </ul>"},{"location":"endlesscheng/union_find_advanced/#684-redundant-connection","title":"684. Redundant Connection","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> </ul> 684. Redundant Connection - Python Solution<pre><code>from typing import List\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(1, n + 1)}\n        self.rank = {i: 1 for i in range(1, n + 1)}\n\n    def find(self, n):\n        p = self.par[n]\n        while self.par[p] != p:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return False\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.par[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.par[p1] = p2\n        else:\n            self.par[p2] = p1\n            self.rank[p1] += 1\n\n        return True\n\n\n# Union Find\ndef findRedundantConnectionUF(edges: List[List[int]]) -&gt; List[int]:\n    n = len(edges)\n    uf = UnionFind(n)\n\n    for u, v in edges:\n        if not uf.union(u, v):\n            return (u, v)\n\n\n# DFS\ndef findRedundantConnectionDFS(edges: List[List[int]]) -&gt; List[int]:\n    graph, cycle = {}, {}\n    for a, b in edges:\n        graph.setdefault(a, []).append(b)\n        graph.setdefault(b, []).append(a)\n\n    def dfs(node, parent):\n        if node in cycle:\n            for k in list(cycle.keys()):\n                if k == node:\n                    return True\n                del cycle[k]\n\n        cycle[node] = None\n        for child in graph[node]:\n            if child != parent and dfs(child, node):\n                return True\n        del cycle[node]\n        return False\n\n    dfs(edges[0][0], -1)\n    for a, b in edges[::-1]:\n        if a in cycle and b in cycle:\n            return (a, b)\n\n\nedges = [[1, 2], [1, 3], [2, 3]]\nprint(findRedundantConnectionUF(edges))  # (2, 3)\nprint(findRedundantConnectionDFS(edges))  # (2, 3)\n</code></pre>"},{"location":"endlesscheng/union_find_advanced/#685-redundant-connection-ii","title":"685. Redundant Connection II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> </ul> 685. Redundant Connection II - Python Solution<pre><code>from typing import List\n\n\n# Union Find\ndef findRedundantDirectedConnectionUF(edges: List[List[int]]) -&gt; List[int]:\n    n = len(edges)\n    uf = UnionFind(n + 1)\n    parent = list(range(n + 1))\n    candidates = []\n\n    for u, v in edges:\n        if parent[v] != v:\n            candidates.append([parent[v], v])\n            candidates.append([u, v])\n        else:\n            parent[v] = u\n\n    if not candidates:\n        for u, v in edges:\n            if not uf.union(u, v):\n                return [u, v]\n\n    for u, v in edges:\n        if [u, v] == candidates[1]:\n            continue\n        if not uf.union(u, v):\n            return candidates[0]\n\n    return candidates[1]\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(1, n + 1)}\n\n    def find(self, n):\n        p = self.par[n]\n        while p != self.par[p]:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n        if p1 == p2:\n            return False\n        self.par[p1] = p2\n        return True\n\n\nedges = [[1, 2], [1, 3], [2, 3]]\nprint(findRedundantDirectedConnectionUF(edges))\n</code></pre>"},{"location":"endlesscheng/union_find_advanced/#947-most-stones-removed-with-same-row-or-column","title":"947. Most Stones Removed with Same Row or Column","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, depth first search, union find, graph</p> </li> </ul>"},{"location":"endlesscheng/union_find_advanced/#839-similar-string-groups","title":"839. Similar String Groups","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, string, depth first search, breadth first search, union find</p> </li> </ul> 839. Similar String Groups - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef numSimilarGroups(strs: List[str]) -&gt; int:\n    n = len(strs)\n    parent = list(range(n))\n    rank = [0 for _ in range(n)]\n\n    def find(n):\n        p = parent[n]\n        while parent[p] != p:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    def is_similar(s1, s2):\n        diff = 0\n        for c1, c2 in zip(s1, s2):\n            if c1 != c2:\n                diff += 1\n            if diff &gt; 2:\n                return False\n        return True\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_similar(strs[i], strs[j]):\n                union(i, j)\n\n    return sum(find(i) == i for i in range(n))\n\n\nstrs = [\"tars\", \"rats\", \"arts\", \"star\"]\nprint(numSimilarGroups(strs))  # 2\n</code></pre>"},{"location":"endlesscheng/union_find_advanced/#1970-last-day-where-you-can-still-cross","title":"1970. Last Day Where You Can Still Cross","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, depth first search, breadth first search, union find, matrix</p> </li> </ul>"},{"location":"endlesscheng/union_find_advanced/#2076-process-restricted-friend-requests","title":"2076. Process Restricted Friend Requests","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: union find, graph</p> </li> </ul>"},{"location":"endlesscheng/union_find_advanced/#1579-remove-max-number-of-edges-to-keep-graph-fully-traversable","title":"1579. Remove Max Number of Edges to Keep Graph Fully Traversable","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: union find, graph</p> </li> <li>Return the maximum number of edges you can remove so that the graph remains fully traversable.</li> </ul> <p></p> 1579. Remove Max Number of Edges to Keep Graph Fully Traversable - Python Solution<pre><code>from typing import List\n\n\n# Kruskal\ndef maxNumEdgesToRemove(n: int, edges: List[List[int]]) -&gt; int:\n    alice, bob = UnionFind(n), UnionFind(n)\n    visited = 0\n\n    for t, u, v in edges:\n        if t == 3:\n            if alice.union(u, v) | bob.union(u, v):\n                visited += 1\n\n    for t, u, v in edges:\n        if t == 1:\n            if alice.union(u, v):\n                visited += 1\n        elif t == 2:\n            if bob.union(u, v):\n                visited += 1\n\n    if alice.components &gt; 1 or bob.components &gt; 1:\n        return -1\n\n    return len(edges) - visited\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = {i: i for i in range(1, n + 1)}\n        self.rank = {i: 0 for i in range(1, n + 1)}\n        self.components = n\n\n    def find(self, n):\n        p = self.parent[n]\n        while self.parent[p] != p:\n            self.parent[p] = self.parent[self.parent[p]]\n            p = self.parent[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return False\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.parent[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.parent[p1] = p2\n        else:\n            self.parent[p2] = p1\n            self.rank[p1] += 1\n\n        self.components -= 1\n\n        return True\n\n\nn = 4\nedges = [[3, 1, 2], [3, 2, 3], [1, 1, 3], [1, 2, 4], [1, 1, 2], [2, 3, 4]]\nprint(maxNumEdgesToRemove(n, edges))  # 2\n</code></pre>"},{"location":"endlesscheng/union_find_advanced/#959-regions-cut-by-slashes","title":"959. Regions Cut By Slashes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, depth first search, breadth first search, union find, matrix</p> </li> </ul>"},{"location":"endlesscheng/union_find_advanced/#2812-find-the-safest-path-in-a-grid","title":"2812. Find the Safest Path in a Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, breadth first search, union find, heap priority queue, matrix</p> </li> </ul>"},{"location":"endlesscheng/union_find_advanced/#2503-maximum-number-of-points-from-grid-queries","title":"2503. Maximum Number of Points From Grid Queries","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, breadth first search, union find, sorting, heap priority queue, matrix</p> </li> </ul>"},{"location":"endlesscheng/union_find_advanced/#2867-count-valid-paths-in-a-tree","title":"2867. Count Valid Paths in a Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, dynamic programming, tree, depth first search, number theory</p> </li> </ul>"},{"location":"endlesscheng/union_find_advanced/#2421-number-of-good-paths","title":"2421. Number of Good Paths","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, tree, union find, graph, sorting</p> </li> </ul>"},{"location":"endlesscheng/union_find_advanced/#2157-groups-of-strings","title":"2157. Groups of Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, bit manipulation, union find</p> </li> </ul>"},{"location":"endlesscheng/union_find_advanced/#1632-rank-transform-of-a-matrix","title":"1632. Rank Transform of a Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, union find, graph, topological sort, sorting, matrix</p> </li> </ul>"},{"location":"endlesscheng/union_find_advanced/#803-bricks-falling-when-hit","title":"803. Bricks Falling When Hit","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, union find, matrix</p> </li> </ul>"},{"location":"endlesscheng/union_find_advanced/#1569-number-of-ways-to-reorder-array-to-get-same-bst","title":"1569. Number of Ways to Reorder Array to Get Same BST","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, divide and conquer, dynamic programming, tree, union find, binary search tree, memoization, combinatorics, binary tree</p> </li> </ul>"},{"location":"endlesscheng/union_find_advanced/#3235-check-if-the-rectangle-corner-is-reachable","title":"3235. Check if the Rectangle Corner Is Reachable","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, math, depth first search, breadth first search, union find, geometry</p> </li> </ul>"},{"location":"endlesscheng/union_find_advanced/#2371-minimize-maximum-value-in-a-grid","title":"2371. Minimize Maximum Value in a Grid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, union find, graph, topological sort, sorting, matrix</p> </li> </ul>"},{"location":"endlesscheng/union_find_advanced/#2459-sort-array-by-moving-items-to-empty-space","title":"2459. Sort Array by Moving Items to Empty Space","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"endlesscheng/union_find_basics/","title":"Union Find Basics","text":"<ul> <li> 990. Satisfiability of Equality Equations (Medium)</li> <li> 721. Accounts Merge (Medium)</li> <li> 737. Sentence Similarity II (Medium)</li> <li> 1101. The Earliest Moment When Everyone Become Friends (Medium)</li> <li> 1258. Synonymous Sentences (Medium)</li> </ul>"},{"location":"endlesscheng/union_find_basics/#990-satisfiability-of-equality-equations","title":"990. Satisfiability of Equality Equations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, union find, graph</p> </li> </ul> 990. Satisfiability of Equality Equations - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef equationsPossible(equations: List[str]) -&gt; bool:\n    parent = defaultdict(str)\n    rank = defaultdict(int)\n\n    def find(n):\n        p = parent[n]\n        while p != parent[p]:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    for equation in equations:\n        if equation[0] not in parent:\n            parent[equation[0]] = equation[0]\n            rank[equation[0]] = 1\n        if equation[3] not in parent:\n            parent[equation[3]] = equation[3]\n            rank[equation[3]] = 1\n\n    for equation in equations:\n        if equation[1] == \"=\":\n            union(equation[0], equation[3])\n\n    for equation in equations:\n        if equation[1] == \"!\":\n            if find(equation[0]) == find(equation[3]):\n                return False\n\n    return True\n\n\nequations = [\"a==b\", \"b!=a\"]\nprint(equationsPossible(equations))  # False\n</code></pre>"},{"location":"endlesscheng/union_find_basics/#721-accounts-merge","title":"721. Accounts Merge","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, depth first search, breadth first search, union find, sorting</p> </li> </ul> 721. Accounts Merge - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef accountsMerge(accounts: List[List[str]]) -&gt; List[List[str]]:\n    parent = defaultdict(str)\n    rank = defaultdict(int)\n    email_to_name = defaultdict(str)\n    merged_accounts = defaultdict(list)\n\n    def find(n):\n        p = parent[n]\n        while p != parent[p]:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    for account in accounts:\n        name = account[0]\n        first_email = account[1]\n\n        for email in account[1:]:\n            if email not in parent:\n                parent[email] = email\n                rank[email] = 1\n            email_to_name[email] = name\n            union(first_email, email)\n\n    for email in parent:\n        root_email = find(email)\n        merged_accounts[root_email].append(email)\n\n    result = []\n    for root_email, emails in merged_accounts.items():\n        result.append([email_to_name[root_email]] + sorted(emails))\n\n    return result\n\n\naccounts = [\n    [\"John\", \"johnsmith@mail.com\", \"john_newyork@mail.com\"],\n    [\"John\", \"johnsmith@mail.com\", \"john00@mail.com\"],\n    [\"Mary\", \"mary@mail.com\"],\n    [\"John\", \"johnnybravo@mail.com\"],\n]\nprint(accountsMerge(accounts))\n# [['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],\n# ['Mary', 'mary@mail.com'],\n# ['John', 'johnnybravo@mail.com']]\n</code></pre>"},{"location":"endlesscheng/union_find_basics/#737-sentence-similarity-ii","title":"737. Sentence Similarity II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, depth first search, breadth first search, union find</p> </li> </ul>"},{"location":"endlesscheng/union_find_basics/#1101-the-earliest-moment-when-everyone-become-friends","title":"1101. The Earliest Moment When Everyone Become Friends","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, union find, sorting</p> </li> </ul> 1101. The Earliest Moment When Everyone Become Friends - Python Solution<pre><code>from typing import List\n\n\n# Union Find\ndef earliestAcq(logs: List[List[int]], n: int) -&gt; int:\n    logs.sort()\n    par = {i: i for i in range(n)}\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    for time, a, b in logs:\n        pa, pb = find(a), find(b)\n        if pa != pb:\n            par[pa] = pb\n            n -= 1\n        if n == 1:\n            return time\n    return -1\n\n\nlogs = [[0, 2, 0], [1, 0, 1], [3, 0, 3], [4, 1, 2], [7, 3, 1]]\nn = 4\nprint(earliestAcq(logs, n))  # 3\n</code></pre>"},{"location":"endlesscheng/union_find_basics/#1258-synonymous-sentences","title":"1258. Synonymous Sentences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, backtracking, union find</p> </li> </ul>"},{"location":"endlesscheng/union_find_interval/","title":"Union Find Interval","text":"<ul> <li> 1851. Minimum Interval to Include Each Query (Hard)</li> <li> 3244. Shortest Distance After Road Addition Queries II (Hard)</li> <li> 2158. Amount of New Area Painted Each Day (Hard)</li> </ul>"},{"location":"endlesscheng/union_find_interval/#1851-minimum-interval-to-include-each-query","title":"1851. Minimum Interval to Include Each Query","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, line sweep, sorting, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/union_find_interval/#3244-shortest-distance-after-road-addition-queries-ii","title":"3244. Shortest Distance After Road Addition Queries II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, graph, ordered set</p> </li> </ul>"},{"location":"endlesscheng/union_find_interval/#2158-amount-of-new-area-painted-each-day","title":"2158. Amount of New Area Painted Each Day","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, segment tree, ordered set</p> </li> </ul>"},{"location":"endlesscheng/union_find_on_arrays/","title":"Union Find on Arrays","text":"<ul> <li> 1562. Find Latest Group of Size M (Medium)</li> <li> 1488. Avoid Flood in The City (Medium)</li> <li> 2382. Maximum Segment Sum After Removals (Hard)</li> <li> 2334. Subarray With Elements Greater Than Varying Threshold (Hard)</li> </ul>"},{"location":"endlesscheng/union_find_on_arrays/#1562-find-latest-group-of-size-m","title":"1562. Find Latest Group of Size M","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, binary search, simulation</p> </li> </ul>"},{"location":"endlesscheng/union_find_on_arrays/#1488-avoid-flood-in-the-city","title":"1488. Avoid Flood in The City","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, binary search, greedy, heap priority queue</p> </li> </ul>"},{"location":"endlesscheng/union_find_on_arrays/#2382-maximum-segment-sum-after-removals","title":"2382. Maximum Segment Sum After Removals","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, union find, prefix sum, ordered set</p> </li> </ul>"},{"location":"endlesscheng/union_find_on_arrays/#2334-subarray-with-elements-greater-than-varying-threshold","title":"2334. Subarray With Elements Greater Than Varying Threshold","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, stack, union find, monotonic stack</p> </li> </ul>"},{"location":"endlesscheng/valid_parentheses_strings/","title":"Valid Parentheses Strings","text":"<ul> <li> 20. Valid Parentheses (Easy)</li> <li> 921. Minimum Add to Make Parentheses Valid (Medium)</li> <li> 1021. Remove Outermost Parentheses (Easy)</li> <li> 1614. Maximum Nesting Depth of the Parentheses (Easy)</li> <li> 1190. Reverse Substrings Between Each Pair of Parentheses (Medium)</li> <li> 856. Score of Parentheses (Medium)</li> <li> 1249. Minimum Remove to Make Valid Parentheses (Medium)</li> <li> 1963. Minimum Number of Swaps to Make the String Balanced (Medium)</li> <li> 678. Valid Parenthesis String (Medium)</li> <li> 1111. Maximum Nesting Depth of Two Valid Parentheses Strings (Medium)</li> <li> 1541. Minimum Insertions to Balance a Parentheses String (Medium)</li> <li> 2116. Check if a Parentheses String Can Be Valid (Medium)</li> <li> 32. Longest Valid Parentheses (Hard)</li> </ul>"},{"location":"endlesscheng/valid_parentheses_strings/#20-valid-parentheses","title":"20. Valid Parentheses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, stack</p> </li> <li>Determine if the input string is valid.</li> <li>Steps for the string <code>()[]{}</code>:</li> </ul> char action stack <code>(</code> push \"(\" <code>)</code> pop \"\" <code>[</code> push \"[\" <code>]</code> pop \"\" <code>{</code> push \"{\" <code>}</code> pop \"\" 20. Valid Parentheses - Python Solution<pre><code># Stack\ndef isValid(s: str) -&gt; bool:\n    hashmap = {\n        \")\": \"(\",\n        \"]\": \"[\",\n        \"}\": \"{\",\n    }\n    stack = []\n\n    for c in s:\n        if c in hashmap:\n            if stack and stack[-1] == hashmap[c]:\n                stack.pop()\n            else:\n                return False\n        else:\n            stack.append(c)\n\n    return True if not stack else False\n\n\nprint(isValid(\"()\"))  # True\nprint(isValid(\"()[]{}\"))  # True\nprint(isValid(\"(]\"))  # False\n</code></pre>"},{"location":"endlesscheng/valid_parentheses_strings/#921-minimum-add-to-make-parentheses-valid","title":"921. Minimum Add to Make Parentheses Valid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack, greedy</p> </li> </ul>"},{"location":"endlesscheng/valid_parentheses_strings/#1021-remove-outermost-parentheses","title":"1021. Remove Outermost Parentheses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, stack</p> </li> </ul>"},{"location":"endlesscheng/valid_parentheses_strings/#1614-maximum-nesting-depth-of-the-parentheses","title":"1614. Maximum Nesting Depth of the Parentheses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, stack</p> </li> </ul>"},{"location":"endlesscheng/valid_parentheses_strings/#1190-reverse-substrings-between-each-pair-of-parentheses","title":"1190. Reverse Substrings Between Each Pair of Parentheses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack</p> </li> </ul>"},{"location":"endlesscheng/valid_parentheses_strings/#856-score-of-parentheses","title":"856. Score of Parentheses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack</p> </li> </ul>"},{"location":"endlesscheng/valid_parentheses_strings/#1249-minimum-remove-to-make-valid-parentheses","title":"1249. Minimum Remove to Make Valid Parentheses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack</p> </li> </ul>"},{"location":"endlesscheng/valid_parentheses_strings/#1963-minimum-number-of-swaps-to-make-the-string-balanced","title":"1963. Minimum Number of Swaps to Make the String Balanced","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string, stack, greedy</p> </li> </ul>"},{"location":"endlesscheng/valid_parentheses_strings/#678-valid-parenthesis-string","title":"678. Valid Parenthesis String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming, stack, greedy</p> </li> </ul> 678. Valid Parenthesis String - Python Solution<pre><code># Greedy\ndef checkValidString(s: str) -&gt; bool:\n    min_open, max_open = 0, 0\n\n    for char in s:\n        if char == \"(\":\n            min_open += 1\n            max_open += 1\n        elif char == \")\":\n            min_open = max(min_open - 1, 0)\n            max_open -= 1\n        elif char == \"*\":\n            min_open = max(min_open - 1, 0)\n            max_open += 1\n\n        if max_open &lt; 0:\n            return False\n\n    return min_open == 0\n\n\ns = \"(*))\"\nprint(checkValidString(s))  # True\n</code></pre>"},{"location":"endlesscheng/valid_parentheses_strings/#1111-maximum-nesting-depth-of-two-valid-parentheses-strings","title":"1111. Maximum Nesting Depth of Two Valid Parentheses Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack</p> </li> </ul>"},{"location":"endlesscheng/valid_parentheses_strings/#1541-minimum-insertions-to-balance-a-parentheses-string","title":"1541. Minimum Insertions to Balance a Parentheses String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack, greedy</p> </li> </ul>"},{"location":"endlesscheng/valid_parentheses_strings/#2116-check-if-a-parentheses-string-can-be-valid","title":"2116. Check if a Parentheses String Can Be Valid","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack, greedy</p> </li> </ul>"},{"location":"endlesscheng/valid_parentheses_strings/#32-longest-valid-parentheses","title":"32. Longest Valid Parentheses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming, stack</p> </li> </ul>"},{"location":"endlesscheng/xor_trie/","title":"XOR Trie","text":"<ul> <li> 421. Maximum XOR of Two Numbers in an Array (Medium)</li> <li> 2935. Maximum Strong Pair XOR II (Hard)</li> <li> 1707. Maximum XOR With an Element From Array (Hard)</li> <li> 1803. Count Pairs With XOR in a Range (Hard)</li> <li> 1938. Maximum Genetic Difference Query (Hard)</li> <li> 2479. Maximum XOR of Two Non-Overlapping Subtrees (Hard)</li> </ul>"},{"location":"endlesscheng/xor_trie/#421-maximum-xor-of-two-numbers-in-an-array","title":"421. Maximum XOR of Two Numbers in an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, bit manipulation, trie</p> </li> </ul>"},{"location":"endlesscheng/xor_trie/#2935-maximum-strong-pair-xor-ii","title":"2935. Maximum Strong Pair XOR II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, bit manipulation, trie, sliding window</p> </li> </ul>"},{"location":"endlesscheng/xor_trie/#1707-maximum-xor-with-an-element-from-array","title":"1707. Maximum XOR With an Element From Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, bit manipulation, trie</p> </li> </ul>"},{"location":"endlesscheng/xor_trie/#1803-count-pairs-with-xor-in-a-range","title":"1803. Count Pairs With XOR in a Range","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, bit manipulation, trie</p> </li> </ul>"},{"location":"endlesscheng/xor_trie/#1938-maximum-genetic-difference-query","title":"1938. Maximum Genetic Difference Query","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, bit manipulation, depth first search, trie</p> </li> </ul>"},{"location":"endlesscheng/xor_trie/#2479-maximum-xor-of-two-non-overlapping-subtrees","title":"2479. Maximum XOR of Two Non-Overlapping Subtrees","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: tree, depth first search, graph, trie</p> </li> </ul>"},{"location":"graph_theory/","title":"Graph Theory","text":""},{"location":"graph_theory/#resources","title":"Resources","text":"<ul> <li>Graph Editor: Create and visualize graphs.</li> <li>\u3010\u9898\u5355\u3011\u56fe\u8bba\u7b97\u6cd5\uff08DFS/BFS/\u62d3\u6251\u6392\u5e8f/\u6700\u77ed\u8def/\u6700\u5c0f\u751f\u6210\u6811/\u4e8c\u5206\u56fe/\u57fa\u73af\u6811/\u6b27\u62c9\u8def\u5f84\uff09</li> </ul>"},{"location":"graph_theory/#concepts","title":"Concepts","text":"<ul> <li>Graph</li> <li>Vertex (Node)</li> <li>Edge</li> <li>Weight</li> </ul>"},{"location":"graph_theory/#types","title":"Types","text":"<ul> <li>Undirected graph: A graph in which edges have no direction.</li> </ul> <ul> <li>Directed graph: A graph in which edges have direction.</li> </ul> <pre><code>flowchart LR\nA((1)) --&gt; B((2)) &amp; C((3))\nC --&gt; B &amp; D((4))\nD --&gt; C</code></pre> <ul> <li>Cyclic graph: A graph in which there is a cycle. A cycle is a path of edges that starts and ends at the same vertex, e.g., <code>1 -&gt; 3 -&gt; 4 -&gt; 1</code>.</li> </ul> <pre><code>flowchart LR\nA((1)) --&gt; B((2)) &amp; C((3))\nB --&gt; C\nC --&gt; D((4))\nD --&gt; A</code></pre> <ul> <li>Acyclic graph: A graph in which there is no cycle.</li> </ul> <ul> <li>Directed Acyclic Graph (DAG): A directed graph with no cycles.<ul> <li>Topological sort</li> </ul> </li> </ul> <ul> <li>Weighted graph: A graph in which edges have weights.</li> </ul> <ul> <li>Connected Graph: A graph in which there is a path between every pair of vertices.</li> </ul> <ul> <li>Disconnected Graph: A graph in which there is no path between some pairs of vertices.</li> </ul> <ul> <li>Eulerian path: A path that visits every edge exactly once, e.g., <code>5 -&gt; 4 -&gt; 1 -&gt; 2 -&gt; 3</code>.</li> </ul>"},{"location":"graph_theory/#representation","title":"Representation","text":"<ol> <li>Adjacency Matrix</li> <li>Adjacency List</li> </ol> <pre><code>flowchart LR\n1((1))\n2((2))\n3((3))\n4((4))\n1 --&gt; 3\n1 --&gt; 2\n3 --&gt; 4\n2 --&gt; 3</code></pre> <p>Adjacency Matrix</p> Node 1 Node 2 Node 3 Node 4 Node 1 0 1 1 0 Node 2 0 0 1 0 Node 3 0 0 0 1 Node 4 0 0 0 0 <pre><code>grid = [\n    [0, 1, 1, 0],\n    [0, 0, 1, 0],\n    [0, 0, 0, 1],\n    [0, 0, 0, 0]\n]\n</code></pre> <p>Adjacency List</p> <pre><code>classDiagram\ndirection LR\nclass 1{2, 3}\nclass 2{3}\nclass 3{4}\nclass 4{-}\n1 -- 2\n2 -- 3\n3 -- 4</code></pre> <pre><code>graph = {\n    1: [2, 3],\n    2: [3],\n    3: [4],\n    4: []\n}\n</code></pre>"},{"location":"graph_theory/#degree","title":"Degree","text":"<ol> <li>Degree: Number of edges connected to a node</li> <li>In-degree: Number of edges coming into a node</li> <li>Out-degree: Number of edges going out of a node</li> </ol> <pre><code>flowchart LR\n1((1))\n2((2))\n3((3))\n4((4))\n1 --&gt; 3\n1 --&gt; 2\n3 --&gt; 4\n2 --&gt; 3</code></pre> <ul> <li>In-degree of Node 1: 0</li> <li>Out-degree of Node 1: 2</li> <li>In-degree of Node 2: 1</li> <li>Out-degree of Node 2: 1</li> </ul> <pre><code># List\nin_degree = [0, 1, 2, 1]\nout_degree = [2, 1, 1, 0]\n\n# Dict\nin_degree = {1: 0, 2: 1, 3: 2, 4: 1}\nout_degree = {1: 2, 2: 1, 3: 1, 4: 0}\n</code></pre>"},{"location":"graph_theory/#graph-bellman-ford-algorithm","title":"Graph - Bellman-Ford Algorithm","text":"<ul> <li>The Bellman-Ford algorithm is used to find the shortest path from a source vertex to all other vertices in a weighted graph.</li> <li>It is slower than Dijkstra's algorithm, but it is more versatile, as it is able to handle graphs with negative edge weights.</li> <li>Time Complexity: O(V x E), where V is the number of vertices and E is the number of edges in the graph.</li> <li>Space Complexity: O(V), where V is the number of vertices in the graph.</li> </ul>"},{"location":"graph_theory/bfs/","title":"BFS","text":"<ul> <li> 1926. Nearest Exit from Entrance in Maze (Medium)</li> <li> 934. Shortest Bridge (Medium)</li> <li> 433. Minimum Genetic Mutation (Medium)</li> <li> 127. Word Ladder (Hard)</li> <li> 1306. Jump Game III (Medium)</li> <li> 542. 01 Matrix (Medium)</li> <li> 1091. Shortest Path in Binary Matrix (Medium)</li> <li> 863. All Nodes Distance K in Binary Tree (Medium)</li> <li> 864. Shortest Path to Get All Keys (Hard)</li> </ul>"},{"location":"graph_theory/bfs/#1926-nearest-exit-from-entrance-in-maze","title":"1926. Nearest Exit from Entrance in Maze","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, breadth first search, matrix</p> </li> </ul> 1926. Nearest Exit from Entrance in Maze - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef nearestExit(maze: List[List[str]], entrance: List[int]) -&gt; int:\n    m, n = len(maze), len(maze[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    q = deque([(entrance[0], entrance[1], 0)])\n    maze[entrance[0]][entrance[1]] = \"+\"\n\n    while q:\n        r, c, steps = q.popleft()\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and maze[nr][nc] == \".\":\n                if nr in [0, m - 1] or nc in [0, n - 1]:\n                    return steps + 1\n                q.append((nr, nc, steps + 1))\n                maze[nr][nc] = \"+\"\n\n    return -1\n\n\nmaze = [[\"+\", \"+\", \".\", \"+\"], [\".\", \".\", \".\", \"+\"], [\"+\", \"+\", \"+\", \".\"]]\nentrance = [1, 2]\nprint(nearestExit(maze, entrance))  # 1\n</code></pre>"},{"location":"graph_theory/bfs/#934-shortest-bridge","title":"934. Shortest Bridge","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, matrix</p> </li> </ul> 934. Shortest Bridge - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS + DFS; Coloring\ndef shortestBridge(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(r, c, queue):\n        grid[r][c] = 2\n        queue.append((r, c))\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if nr in range(n) and nc in range(n) and grid[nr][nc] == 1:\n                dfs(nr, nc, queue)\n\n    q = deque()\n    found = False\n    for r in range(n):\n        if found:\n            break\n        for c in range(n):\n            if grid[r][c] == 1:\n                dfs(r, c, q)\n                found = True\n                break\n\n    steps = 0\n    while q:\n        m = len(q)\n        for _ in range(m):\n            r, c = q.popleft()\n            for dr, dc in directions:\n                nr, nc = r + dr, c + dc\n                if nr in range(n) and nc in range(n):\n                    if grid[nr][nc] == 1:\n                        return steps\n                    elif grid[nr][nc] == 0:\n                        grid[nr][nc] = 2\n                        q.append((nr, nc))\n        steps += 1\n\n    return -1\n\n\ngrid = [\n    [1, 1, 1, 1, 1],\n    [1, 0, 0, 0, 1],\n    [1, 0, 1, 0, 1],\n    [1, 0, 0, 0, 1],\n    [1, 1, 1, 1, 1],\n]\nprint(shortestBridge(grid))  # 1\n</code></pre>"},{"location":"graph_theory/bfs/#433-minimum-genetic-mutation","title":"433. Minimum Genetic Mutation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, breadth first search</p> </li> </ul> 433. Minimum Genetic Mutation - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef minMutation(startGene: str, endGene: str, bank: List[str]) -&gt; int:\n    if endGene not in bank:\n        return -1\n\n    bank = set(bank)\n    q = deque([(startGene, 0)])\n\n    while q:\n        gene, step = q.popleft()\n        if gene == endGene:\n            return step\n\n        for i in range(8):\n            for c in \"ACGT\":\n                if gene[i] == c:\n                    continue\n                newGene = gene[:i] + c + gene[i + 1 :]\n                if newGene in bank:\n                    bank.remove(newGene)\n                    q.append((newGene, step + 1))\n    return -1\n\n\nstartGene = \"AACCGGTT\"\nendGene = \"AAACGGTA\"\nbank = [\"AACCGGTA\", \"AACCGCTA\", \"AAACGGTA\"]\nprint(minMutation(startGene, endGene, bank))  # 2\n</code></pre>"},{"location":"graph_theory/bfs/#127-word-ladder","title":"127. Word Ladder","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, breadth first search</p> </li> <li>The most classic BFS problem.</li> <li>Return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.</li> </ul> Approach Time Space BFS O(n * m^2) O(n * m) 127. Word Ladder - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef ladderLength(beginWord: str, endWord: str, wordList: List[str]) -&gt; int:\n    if endWord not in wordList:\n        return 0\n\n    n = len(beginWord)\n    graph = defaultdict(list)  # pattern: words\n    wordList.append(beginWord)\n\n    for word in wordList:\n        for i in range(n):\n            pattern = word[:i] + \"*\" + word[i + 1 :]\n            graph[pattern].append(word)\n\n    visited = set([beginWord])\n    q = deque([beginWord])\n    res = 1\n\n    while q:\n        size = len(q)\n        for _ in range(size):\n            word = q.popleft()\n            if word == endWord:\n                return res\n\n            for i in range(n):\n                pattern = word[:i] + \"*\" + word[i + 1 :]\n                for neighbor in graph[pattern]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        q.append(neighbor)\n        res += 1\n\n    return 0\n\n\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]\nprint(ladderLength(beginWord, endWord, wordList))  # 5\n</code></pre>"},{"location":"graph_theory/bfs/#1306-jump-game-iii","title":"1306. Jump Game III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search</p> </li> </ul> 1306. Jump Game III - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef canReach(arr: List[int], start: int) -&gt; bool:\n    n = len(arr)\n    visited = [False for _ in range(n)]\n    q = deque([start])\n\n    while q:\n        i = q.popleft()\n\n        if arr[i] == 0:\n            return True\n\n        visited[i] = True\n\n        for j in [i - arr[i], i + arr[i]]:\n            if j in range(n) and not visited[j]:\n                q.append(j)\n\n    return False\n\n\narr = [4, 2, 3, 0, 3, 1, 2]\nstart = 5\nprint(canReach(arr, start))  # True\n</code></pre>"},{"location":"graph_theory/bfs/#542-01-matrix","title":"542. 01 Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, breadth first search, matrix</p> </li> </ul> 542. 01 Matrix - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef updateMatrix(mat: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(mat), len(mat[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    q = deque()\n\n    for i in range(m):\n        for j in range(n):\n            if mat[i][j] == 0:\n                dist[i][j] = 0\n                q.append((i, j))\n\n    while q:\n        r, c = q.popleft()\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and dist[nr][nc] &gt; dist[r][c] + 1:\n                dist[nr][nc] = dist[r][c] + 1\n                q.append((nr, nc))\n\n    return dist\n\n\nmat = [[0, 0, 0], [0, 1, 0], [1, 1, 1]]\nprint(updateMatrix(mat))\n# [[0, 0, 0], [0, 1, 0], [1, 2, 1]]\n</code></pre>"},{"location":"graph_theory/bfs/#1091-shortest-path-in-binary-matrix","title":"1091. Shortest Path in Binary Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, breadth first search, matrix</p> </li> </ul> 1091. Shortest Path in Binary Matrix - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef shortestPathBinaryMatrix(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    if grid[0][0] == 1 or grid[n - 1][n - 1] == 1:\n        return -1\n    if n == 1:\n        return 1\n\n    directions = [\n        (0, 1),\n        (1, 0),\n        (0, -1),\n        (-1, 0),\n        (1, 1),\n        (-1, -1),\n        (1, -1),\n        (-1, 1),\n    ]\n    q = deque([(0, 0, 1)])  # (row, column, distance)\n    grid[0][0] = 1\n\n    while q:\n        r, c, d = q.popleft()\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 &lt;= nr &lt; n and 0 &lt;= nc &lt; n and grid[nr][nc] == 0:\n                if nr == nc == n - 1:\n                    return d + 1\n                q.append((nr, nc, d + 1))\n                grid[nr][nc] = 1\n\n    return -1\n\n\ngrid = [[0, 0, 0], [1, 1, 0], [1, 1, 0]]\nprint(shortestPathBinaryMatrix(grid))  # 4\n</code></pre>"},{"location":"graph_theory/bfs/#863-all-nodes-distance-k-in-binary-tree","title":"863. All Nodes Distance K in Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, tree, depth first search, breadth first search, binary tree</p> </li> </ul> 863. All Nodes Distance K in Binary Tree - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BFS\ndef distanceK(root: TreeNode, target: TreeNode, k: int) -&gt; List[int]:\n    parent = dict()\n\n    def dfs(node, par=None):\n        if node:\n            parent[node] = par\n            dfs(node.left, node)\n            dfs(node.right, node)\n\n    dfs(root)\n\n    q = deque([(target, 0)])\n    seen = set([target])\n\n    while q:\n        node, dist = q.popleft()\n\n        if dist == k:\n            return [node.val] + [node.val for node, _ in q]\n\n        for nei in (node.left, node.right, parent[node]):\n            if nei and nei not in seen:\n                seen.add(nei)\n                q.append((nei, dist + 1))\n\n    return []\n\n\nroot = build([3, 5, 1, 6, 2, 0, 8, None, None, 7, 4])\nprint(root)\n#     ______3__\n#    /         \\\n#   5__         1\n#  /   \\       / \\\n# 6     2     0   8\n#      / \\\n#     7   4\ntarget = root.left\nk = 2\nprint(distanceK(root, target, k))  # [7, 4, 1]\n</code></pre>"},{"location":"graph_theory/bfs/#864-shortest-path-to-get-all-keys","title":"864. Shortest Path to Get All Keys","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, bit manipulation, breadth first search, matrix</p> </li> </ul> 864. Shortest Path to Get All Keys - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef shortestPathAllKeys(grid: List[str]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    q = deque()\n    visited = set()\n    total = 0\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"@\":\n                q.append((r, c, 0, 0))\n                visited.add((r, c, 0))\n            if grid[r][c].islower():\n                total += 1\n\n    while q:\n        r, c, keys, steps = q.popleft()\n\n        if keys == (1 &lt;&lt; total) - 1:\n            return steps\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n:\n                cell = grid[nr][nc]\n\n                if cell == \"#\":\n                    continue\n\n                new_keys = keys\n                if cell.islower():\n                    new_keys |= 1 &lt;&lt; (ord(cell) - ord(\"a\"))\n\n                if cell.isupper() and not (\n                    keys &amp; (1 &lt;&lt; (ord(cell) - ord(\"A\")))\n                ):\n                    continue\n\n                if (nr, nc, new_keys) not in visited:\n                    visited.add((nr, nc, new_keys))\n                    q.append((nr, nc, new_keys, steps + 1))\n\n    return -1\n\n\ngrid = [\"@.a..\", \"###.#\", \"b.A.B\"]\nprint(shortestPathAllKeys(grid))  # 8\n</code></pre>"},{"location":"graph_theory/dijkstra%27s/","title":"Dijkstra's","text":"<ul> <li> 787. Cheapest Flights Within K Stops (Medium)</li> <li> 1514. Path with Maximum Probability (Medium)</li> <li> 505. The Maze II (Medium)</li> <li> 499. The Maze III (Hard)</li> </ul>"},{"location":"graph_theory/dijkstra%27s/#787-cheapest-flights-within-k-stops","title":"787. Cheapest Flights Within K Stops","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming, depth first search, breadth first search, graph, heap priority queue, shortest path</p> </li> <li>Return the cheapest price from <code>src</code> to <code>dst</code> with at most <code>K</code> stops.</li> </ul> <pre><code>graph TD\n0((0))\n1((1))\n2((2))\n3((3))\n0 --&gt; |100| 1\n1 --&gt; |600| 3\n1 --&gt; |100| 2\n2 --&gt; |100| 0\n2 --&gt; |200| 3</code></pre> 787. Cheapest Flights Within K Stops - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Bellman-Ford\ndef findCheapestPriceBF(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    prices = [float(\"inf\") for _ in range(n)]\n    prices[src] = 0\n\n    for _ in range(k + 1):\n        temp = prices[:]\n        for u, v, w in flights:\n            temp[v] = min(temp[v], prices[u] + w)\n        prices = temp\n\n    return prices[dst] if prices[dst] != float(\"inf\") else -1\n\n\n# Dijkstra\ndef findCheapestPriceDijkstra(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in flights:\n        graph[u].append((v, w))\n\n    heap = [(0, src, 0)]  # (price, city, stops)\n    visited = defaultdict(int)  # {city: stops}\n\n    while heap:\n        price, city, stops = heapq.heappop(heap)\n\n        if city == dst:\n            return price\n\n        if stops &gt; k:\n            continue\n\n        if city in visited and visited[city] &lt;= stops:\n            continue\n\n        visited[city] = stops\n\n        for neighbor, cost in graph[city]:\n            heapq.heappush(heap, (price + cost, neighbor, stops + 1))\n\n    return -1\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |Bellman-Ford|    O(k * E)      |  O(n)   |\n# | Dijkstra   | O(E * log(V))    |  O(n)   |\n# |------------|------------------|---------|\n\n\nn = 4\nflights = [[0, 1, 100], [1, 2, 100], [2, 0, 100], [1, 3, 600], [2, 3, 200]]\nsrc = 0\ndst = 3\nk = 1\nprint(findCheapestPriceBF(n, flights, src, dst, k))  # 700\nprint(findCheapestPriceDijkstra(n, flights, src, dst, k))  # 700\n</code></pre>"},{"location":"graph_theory/dijkstra%27s/#1514-path-with-maximum-probability","title":"1514. Path with Maximum Probability","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, graph, heap priority queue, shortest path</p> </li> </ul> 1514. Path with Maximum Probability - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Dijkstra - Dict\ndef maxProbability1(\n    n: int,\n    edges: List[List[int]],\n    succProb: List[float],\n    start_node: int,\n    end_node: int,\n) -&gt; float:\n    graph = defaultdict(list)\n    for i, (u, v) in enumerate(edges):\n        graph[u].append((v, succProb[i]))\n        graph[v].append((u, succProb[i]))\n\n    heap = [(-1, start_node)]\n    max_prob = {i: 0.0 for i in range(n)}\n    max_prob[start_node] = 1.0\n\n    while heap:\n        p1, n1 = heapq.heappop(heap)\n\n        if n1 == end_node:\n            return -p1\n\n        for n2, p2 in graph[n1]:\n            p2 *= -p1\n            if p2 &gt; max_prob[n2]:\n                max_prob[n2] = p2\n                heapq.heappush(heap, (-p2, n2))\n\n    return 0.0\n\n\n# Dijkstra - Set\ndef maxProbability2(\n    n: int,\n    edges: List[List[int]],\n    succProb: List[float],\n    start_node: int,\n    end_node: int,\n) -&gt; float:\n    graph = defaultdict(list)\n    for i, (u, v) in enumerate(edges):\n        graph[u].append((v, succProb[i]))\n        graph[v].append((u, succProb[i]))\n\n    heap = [(-1, start_node)]\n    visited = set()\n\n    while heap:\n        p1, n1 = heapq.heappop(heap)\n        visited.add(n1)\n\n        if n1 == end_node:\n            return -p1\n\n        for n2, p2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (p1 * p2, n2))\n\n    return 0.0\n\n\n# |------------|-----------|-----------|\n# |  Approach  |    Time   |   Space   |\n# |------------|-----------|-----------|\n# |  Dijkstra  | O(E log V)|   O(E)    |\n# |------------|-----------|-----------|\n\n\nn = 3\nedges = [[0, 1], [1, 2], [0, 2]]\nsuccProb = [0.5, 0.5, 0.2]\nstart = 0\nend = 2\n\nprint(maxProbability1(n, edges, succProb, start, end))  # 0.25\nprint(maxProbability2(n, edges, succProb, start, end))  # 0.25\n</code></pre>"},{"location":"graph_theory/dijkstra%27s/#505-the-maze-ii","title":"505. The Maze II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, graph, heap priority queue, matrix, shortest path</p> </li> </ul> 505. The Maze II - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra\ndef shortestDistance(\n    maze: List[List[int]], start: List[int], destination: List[int]\n) -&gt; int:\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    m, n = len(maze), len(maze[0])\n\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    dist[start[0]][start[1]] = 0\n\n    heap = [(0, start[0], start[1])]\n\n    while heap:\n        d, r, c = heapq.heappop(heap)\n\n        if [r, c] == destination:\n            return d\n\n        for dr, dc in directions:\n            nr, nc, nd = r, c, d\n\n            while (\n                0 &lt;= nr + dr &lt; m\n                and 0 &lt;= nc + dc &lt; n\n                and maze[nr + dr][nc + dc] == 0\n            ):\n                nr += dr\n                nc += dc\n                nd += 1\n\n            if nd &lt; dist[nr][nc]:\n                dist[nr][nc] = nd\n                heapq.heappush(heap, (nd, nr, nc))\n\n    return -1\n\n\nmaze = [\n    [0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0],\n    [0, 0, 0, 1, 0],\n    [1, 1, 0, 1, 1],\n    [0, 0, 0, 0, 0],\n]\nstart = [0, 4]\ndestination = [4, 4]\nprint(shortestDistance(maze, start, destination))  # 12\n</code></pre>"},{"location":"graph_theory/dijkstra%27s/#499-the-maze-iii","title":"499. The Maze III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, depth first search, breadth first search, graph, heap priority queue, matrix, shortest path</p> </li> </ul> 499. The Maze III - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra\ndef findShortestWay(\n    maze: List[List[int]], ball: List[int], hole: List[int]\n) -&gt; str:\n    directions = [(-1, 0, \"u\"), (1, 0, \"d\"), (0, -1, \"l\"), (0, 1, \"r\")]\n    m, n = len(maze), len(maze[0])\n\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    dist[ball[0]][ball[1]] = 0\n\n    paths = [[\"\"] * n for _ in range(m)]\n    paths[ball[0]][ball[1]] = \"\"\n\n    heap = [(0, \"\", ball[0], ball[1])]\n\n    while heap:\n        d, path, x, y = heapq.heappop(heap)\n\n        if [x, y] == hole:\n            return path\n\n        for dx, dy, direction in directions:\n            nx, ny, nd = x, y, d\n\n            while (\n                0 &lt;= nx + dx &lt; m\n                and 0 &lt;= ny + dy &lt; n\n                and maze[nx + dx][ny + dy] == 0\n            ):\n                nx += dx\n                ny += dy\n                nd += 1\n\n                if [nx, ny] == hole:\n                    break\n\n            new_path = path + direction\n            if nd &lt; dist[nx][ny] or (\n                nd == dist[nx][ny] and new_path &lt; paths[nx][ny]\n            ):\n                dist[nx][ny] = nd\n                paths[nx][ny] = new_path\n                heapq.heappush(heap, (nd, new_path, nx, ny))\n\n    return \"impossible\"\n\n\nmaze = [\n    [0, 0, 0, 0, 0],\n    [1, 1, 0, 0, 1],\n    [0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 1],\n    [0, 1, 0, 0, 0],\n]\nball = [4, 3]\nhole = [0, 1]\nprint(findShortestWay(maze, ball, hole))  # \"lul\"\n</code></pre>"},{"location":"graph_theory/graph_theory/","title":"Graph Theory","text":"<ul> <li> 997. Find the Town Judge (Easy)</li> <li> 1557. Minimum Number of Vertices to Reach All Nodes (Medium)</li> <li> 1615. Maximal Network Rank (Medium)</li> <li> 785. Is Graph Bipartite? (Medium)</li> <li> 261. Graph Valid Tree (Medium)</li> </ul>"},{"location":"graph_theory/graph_theory/#997-find-the-town-judge","title":"997. Find the Town Judge","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, graph</p> </li> <li><code>trust = [[1, 3], [2, 3], [1, 2], [4, 3]]</code></li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 3((3))\n    2((2)) --&gt; 3((3))\n    1((1)) --&gt; 2((2))\n    4((4)) --&gt; 3((3))</code></pre> 997. Find the Town Judge - Python Solution<pre><code>from typing import List\n\n\n# Graph\ndef findJudge(n: int, trust: List[List[int]]) -&gt; int:\n    indegree = {i: 0 for i in range(1, n + 1)}\n    outdegree = {i: 0 for i in range(1, n + 1)}\n\n    for a, b in trust:\n        outdegree[a] += 1\n        indegree[b] += 1\n\n    for i in range(1, n + 1):\n        if indegree[i] == n - 1 and outdegree[i] == 0:\n            return i\n\n    return -1\n\n\nn = 4\ntrust = [[1, 3], [2, 3], [1, 2], [4, 3]]\nprint(findJudge(n, trust))  # 4\n</code></pre>"},{"location":"graph_theory/graph_theory/#1557-minimum-number-of-vertices-to-reach-all-nodes","title":"1557. Minimum Number of Vertices to Reach All Nodes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: graph</p> </li> <li>Return a list of integers representing the minimum number of vertices needed to traverse all the nodes.</li> <li>\u2705 Return the vertices with indegree 0.</li> </ul> <p></p> <ul> <li><code>edges = [[0, 1], [0, 2], [2, 5], [3, 4], [4, 2]]</code></li> <li>Initialization</li> </ul> <code>src</code> 0 0 2 3 4 <code>dst</code> 1 2 5 4 2 node 0 1 2 3 4 5 in-degree 0 0 0 0 0 0 <code>src</code> 0 0 2 3 4 <code>dst</code> 1 2 5 4 2 node 0 1 2 3 4 5 in-degree 0 1 0 0 0 0 <code>src</code> 0 0 2 3 4 <code>dst</code> 1 2 5 4 2 node 0 1 2 3 4 5 in-degree 0 1 1 0 0 0 <code>src</code> 0 0 2 3 4 <code>dst</code> 1 2 5 4 2 node 0 1 2 3 4 5 in-degree 0 1 1 0 0 1 <code>src</code> 0 0 2 3 4 <code>dst</code> 1 2 5 4 2 node 0 1 2 3 4 5 in-degree 0 1 1 0 1 1 <code>src</code> 0 0 2 3 4 <code>dst</code> 1 2 5 4 2 node 0 1 2 3 4 5 in-degree 0 1 2 0 1 1 1557. Minimum Number of Vertices to Reach All Nodes - Python Solution<pre><code>from typing import List\n\n\n# Graph\ndef findSmallestSetOfVertices(n: int, edges: List[List[int]]) -&gt; List[int]:\n    indegree = {i: 0 for i in range(n)}\n\n    for a, b in edges:\n        indegree[b] += 1\n\n    return [i for i in range(n) if indegree[i] == 0]\n\n\nn = 6\nedges = [[0, 1], [0, 2], [2, 5], [3, 4], [4, 2]]\nprint(findSmallestSetOfVertices(n, edges))  # [0, 3]\n</code></pre>"},{"location":"graph_theory/graph_theory/#1615-maximal-network-rank","title":"1615. Maximal Network Rank","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: graph</p> </li> </ul> 1615. Maximal Network Rank - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Graph\ndef maximalNetworkRank(n: int, roads: List[List[int]]) -&gt; int:\n    degree = defaultdict(int)\n    roads_set = set(map(tuple, roads))\n\n    for a, b in roads_set:\n        degree[a] += 1\n        degree[b] += 1\n\n    rank = 0\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if (i, j) in roads_set or (j, i) in roads_set:\n                rank = max(rank, degree[i] + degree[j] - 1)\n            else:\n                rank = max(rank, degree[i] + degree[j])\n\n    return rank\n\n\nn = 4\nroads = [[0, 1], [0, 3], [1, 2], [1, 3]]\nprint(maximalNetworkRank(n, roads))  # 4\n</code></pre>"},{"location":"graph_theory/graph_theory/#785-is-graph-bipartite","title":"785. Is Graph Bipartite?","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> <li>Determine if a graph is bipartite.</li> </ul> <p>How to group</p> Uncolored Color 1 Color 2 Operation Method 1 -1 0 1 <code>1 - color</code> Method 2 0 1 -1 <code>-color</code> 785. Is Graph Bipartite? - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef isBipartiteBFS(graph: List[List[int]]) -&gt; bool:\n    n = len(graph)\n    # -1: not colored; 0: blue; 1: red\n    color = [-1 for _ in range(n)]\n\n    def bfs(node):\n        q = deque([node])\n        color[node] = 0\n\n        while q:\n            cur = q.popleft()\n\n            for neighbor in graph[cur]:\n                if color[neighbor] == -1:\n                    color[neighbor] = 1 - color[cur]\n                    q.append(neighbor)\n                elif color[neighbor] == color[cur]:\n                    return False\n        return True\n\n    for i in range(n):\n        if color[i] == -1:\n            if not bfs(i):\n                return False\n\n    return True\n\n\n# DFS\ndef isBipartiteDFS(graph: List[List[int]]) -&gt; bool:\n    n = len(graph)\n    # -1: not colored; 0: blue; 1: red\n    color = [-1] * n\n\n    def dfs(node, c):\n        color[node] = c\n        for neighbor in graph[node]:\n            if color[neighbor] == -1:\n                if not dfs(neighbor, 1 - c):\n                    return False\n            elif color[neighbor] == c:\n                return False\n        return True\n\n    for i in range(n):\n        if color[i] == -1:\n            if not dfs(i, 0):\n                return False\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |    BFS     | O(V+E) |  O(V)   |\n# |    DFS     | O(V+E) |  O(V)   |\n# |------------|--------|---------|\n\n\ngraph = [[1, 2, 3], [0, 2], [0, 1, 3], [0, 2]]\nprint(isBipartiteBFS(graph))  # False\nprint(isBipartiteDFS(graph))  # False\n</code></pre>"},{"location":"graph_theory/graph_theory/#261-graph-valid-tree","title":"261. Graph Valid Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> </ul> 261. Graph Valid Tree - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Graph\ndef validTree(n: int, edges: List[List[int]]) -&gt; bool:\n    if n == 0:\n        return False\n    if len(edges) != n - 1:\n        return False\n\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = set()\n\n    def dfs(node, parent):\n        if node in visited:\n            return False\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor != parent and not dfs(neighbor, node):\n                return False\n        return True\n\n    return dfs(0, -1) and len(visited) == n\n\n\nprint(validTree(5, [[0, 1], [0, 2], [0, 3], [1, 4]]))  # True\nprint(validTree(5, [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]))  # False\n</code></pre>"},{"location":"graph_theory/matrix_graphs/","title":"Matrix Graphs","text":"<ul> <li> 200. Number of Islands (Medium)</li> <li> 1020. Number of Enclaves (Medium)</li> <li> 1254. Number of Closed Islands (Medium)</li> <li> 695. Max Area of Island (Medium)</li> <li> 417. Pacific Atlantic Water Flow (Medium)</li> </ul>"},{"location":"graph_theory/matrix_graphs/#200-number-of-islands","title":"200. Number of Islands","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix</p> </li> <li>Count the number of islands in a 2D grid.</li> <li>Method 1: DFS</li> <li> <p>Method 2: BFS (use a queue to traverse the grid)</p> </li> <li> <p>How to keep track of visited cells?</p> <ol> <li>Mark the visited cell as <code>0</code> (or any other value) to avoid revisiting it.</li> <li>Use a set to store the visited cells.</li> </ol> </li> <li> <p>Steps:</p> <ol> <li>Init: variables</li> <li>DFS/BFS: starting from the cell with <code>1</code>, turn all the connected <code>1</code>s to <code>0</code>.</li> <li>Traverse the grid, and if the cell is <code>1</code>, increment the count and call DFS/BFS.</li> </ol> </li> </ul> <p></p> 200. Number of Islands - Python Solution<pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef numIslandsDFS(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    res = 0\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] != \"1\":\n            return\n\n        grid[r][c] = \"2\"\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                dfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Set\ndef numIslandsBFS1(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == \"0\"\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\" and (r, c) not in visited:\n                visited.add((r, c))\n                bfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = dr + row, dc + col\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] != \"1\"\n                ):\n                    continue\n                grid[nr][nc] = \"2\"\n                q.append((nr, nc))\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == \"1\":\n                grid[i][j] = \"2\"\n                bfs(i, j)\n                res += 1\n\n    return res\n\n\ngrid = [\n    [\"1\", \"1\", \"1\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"0\", \"0\", \"0\", \"0\", \"0\"],\n]\n\nprint(numIslandsDFS(deepcopy(grid)))  # 1\nprint(numIslandsBFS1(deepcopy(grid)))  # 1\nprint(numIslandsBFS2(deepcopy(grid)))  # 1\n</code></pre>"},{"location":"graph_theory/matrix_graphs/#1020-number-of-enclaves","title":"1020. Number of Enclaves","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix</p> </li> </ul> 1020. Number of Enclaves - Python Solution<pre><code>from typing import List\n\n\n# DFS\ndef numEnclaves(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    visited = set()\n\n    def dfs(r, c):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or grid[r][c] == 0\n            or (r, c) in visited\n        ):\n            return\n\n        grid[r][c] = 0\n        visited.add((r, c))\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if (\n                (r in [0, m - 1] or c in [0, n - 1])\n                and grid[r][c] == 1\n                and (r, c) not in visited\n            ):\n                dfs(r, c)\n\n    count = 0\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1 and (r, c) not in visited:\n                count += 1\n\n    return count\n\n\ngrid = [[0, 0, 0, 0], [1, 0, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0]]\nprint(numEnclaves(grid))  # 3\n</code></pre>"},{"location":"graph_theory/matrix_graphs/#1254-number-of-closed-islands","title":"1254. Number of Closed Islands","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix</p> </li> </ul> 1254. Number of Closed Islands - Python Solution<pre><code>from typing import List\n\n\n# DFS\ndef closedIsland(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    visited = set()\n\n    def dfs(r, c):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or grid[r][c] == 1\n            or (r, c) in visited\n        ):\n            return\n\n        grid[r][c] = 1\n        visited.add((r, c))\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if (\n                (r in [0, m - 1] or c in [0, n - 1])\n                and grid[r][c] == 0\n                and (r, c) not in visited\n            ):\n                dfs(r, c)\n\n    island = 0\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 0 and (r, c) not in visited:\n                island += 1\n                dfs(r, c)\n\n    return island\n\n\ngrid = [\n    [1, 1, 1, 1, 1, 1, 1, 0],\n    [1, 0, 0, 0, 0, 1, 1, 0],\n    [1, 0, 1, 0, 1, 1, 1, 0],\n    [1, 0, 0, 0, 0, 1, 0, 1],\n    [1, 1, 1, 1, 1, 1, 1, 0],\n]\nprint(closedIsland(grid))  # 2\n</code></pre>"},{"location":"graph_theory/matrix_graphs/#695-max-area-of-island","title":"695. Max Area of Island","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix</p> </li> </ul> 695. Max Area of Island - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef maxAreaOfIslandDFS(grid: List[List[int]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] != 1:\n            return 0\n\n        grid[r][c] = 2\n\n        return (\n            1 + dfs(r - 1, c) + dfs(r + 1, c) + dfs(r, c + 1) + dfs(r, c - 1)\n        )\n\n    area = 0\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                area = max(area, dfs(r, c))\n\n    return area\n\n\n# BFS\ndef maxAreaOfIslandBFS1(grid: List[List[int]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        area = 0\n\n        while q:\n            row, col = q.popleft()\n            area += 1\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == 0\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n        return area\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1 and (r, c) not in visited:\n                visited.add((r, c))\n                res = max(res, bfs(r, c))\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        area = 0\n\n        while q:\n            row, col = q.popleft()\n            area += 1\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n\n                if nr &lt; 0 or nr &gt;= m or nc &lt; 0 or nc &gt;= n or grid[nr][nc] == 0:\n                    continue\n\n                q.append((nr, nc))\n                grid[nr][nc] = 0\n\n        return area\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                grid[r][c] = 0\n                res = max(res, bfs(r, c))\n\n    return res\n\n\ngrid = [\n    [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0],\n    [0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],\n]\nprint(maxAreaOfIslandDFS(grid))  # 6\nprint(maxAreaOfIslandBFS1(grid))  # 6\nprint(numIslandsBFS2(grid))  # 6\n</code></pre>"},{"location":"graph_theory/matrix_graphs/#417-pacific-atlantic-water-flow","title":"417. Pacific Atlantic Water Flow","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, matrix</p> </li> </ul> 417. Pacific Atlantic Water Flow - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef pacificAtlanticDFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(r, c, visited, prev_height):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or heights[r][c] &lt; prev_height\n            or (r, c) in visited\n        ):\n            return None\n\n        visited.add((r, c))\n        height = heights[r][c]\n        for dr, dc in directions:\n            dfs(dr + r, dc + c, visited, height)\n\n    for c in range(n):\n        dfs(0, c, pac, heights[0][c])\n        dfs(m - 1, c, atl, heights[m - 1][c])\n\n    for r in range(m):\n        dfs(r, 0, pac, heights[r][0])\n        dfs(r, n - 1, atl, heights[r][n - 1])\n\n    return list(pac &amp; atl)\n\n\n# BFS\ndef pacificAtlanticBFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def bfs(r, c, visited):\n        q = deque([(r, c)])\n        visited.add((r, c))\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr in range(m)\n                    and nc in range(n)\n                    and heights[row][col] &lt;= heights[nr][nc]\n                    and (nr, nc) not in visited\n                ):\n                    q.append((nr, nc))\n                    visited.add((nr, nc))\n\n    for c in range(n):\n        bfs(0, c, pac)  # top\n        bfs(m - 1, c, atl)  # bottom\n\n    for r in range(m):\n        bfs(r, 0, pac)  # left\n        bfs(r, n - 1, atl)  # right\n\n    return list(pac &amp; atl)\n\n\nheights = [\n    [1, 2, 2, 3, 5],\n    [3, 2, 3, 4, 4],\n    [2, 4, 5, 3, 1],\n    [6, 7, 1, 4, 5],\n    [5, 1, 1, 2, 4],\n]\nprint(pacificAtlanticDFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\nprint(pacificAtlanticBFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\n</code></pre>"},{"location":"graph_theory/mst/","title":"MST","text":"<ul> <li> 1135. Connecting Cities With Minimum Cost (Medium)</li> <li> 1584. Min Cost to Connect All Points (Medium)</li> <li> 1168. Optimize Water Distribution in a Village (Hard)</li> <li> 1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree (Hard)</li> </ul>"},{"location":"graph_theory/mst/#1135-connecting-cities-with-minimum-cost","title":"1135. Connecting Cities With Minimum Cost","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: union find, graph, heap priority queue, minimum spanning tree</p> </li> </ul> 1135. Connecting Cities With Minimum Cost - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minimumCost(n: int, connections: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, c in connections:\n        graph[u].append((c, v))\n        graph[v].append((c, u))\n\n    cost = 0\n    heap = [(0, 1)]  # (cost, node)\n    visited = set()\n\n    while heap:\n        c1, n1 = heapq.heappop(heap)\n\n        if n1 in visited:\n            continue\n\n        visited.add(n1)\n\n        cost += c1\n\n        for c2, n2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (c2, n2))\n\n    return cost if len(visited) == n else -1\n\n\nn = 3\nconnections = [[1, 2, 5], [1, 3, 6], [2, 3, 1]]\nprint(minimumCost(n, connections))  # 6\n</code></pre>"},{"location":"graph_theory/mst/#1584-min-cost-to-connect-all-points","title":"1584. Min Cost to Connect All Points","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, union find, graph, minimum spanning tree</p> </li> <li>Tree: a connected acyclic graph</li> <li>Spanning Tree: a subgraph that is a tree and connects all the vertices together</li> <li>Minimum Spanning Tree (MST): a spanning tree with the minimum possible sum of edge weights</li> <li>Prim's Algorithm<ul> <li>Data Structure: Heap</li> <li>Time Complexity: O(E * logV)</li> <li>Space Complexity: O(V + E)</li> </ul> </li> <li> <p>Kruskal's Algorithm</p> <ul> <li>Union Find</li> <li>Time Complexity: O(E * logV)</li> <li>Space Complexity: O(V + E)</li> </ul> </li> <li> <p>Demonstration</p> </li> </ul> <p>Example graph</p> <p></p> <p>MST</p> <p></p> 1584. Min Cost to Connect All Points - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minCostConnectPointsPrim(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    graph = defaultdict(list)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            dist = abs(x1 - x2) + abs(y1 - y2)\n            graph[i].append((dist, j))\n            graph[j].append((dist, i))\n\n    cost = 0\n    heap = [(0, 0)]  # (cost, node)\n    visited = set()\n\n    while heap:\n        d1, n1 = heapq.heappop(heap)\n        if n1 in visited:\n            continue\n        visited.add(n1)\n        cost += d1\n\n        for d2, n2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (d2, n2))\n\n    return cost\n\n\n# Kruskal\ndef minCostConnectPointsKruskal(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    par = {i: i for i in range(n)}\n    rank = {i: 0 for i in range(n)}\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 == p2:\n            return False\n\n        if rank[p1] &gt; rank[p2]:\n            par[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n        else:\n            par[p2] = p1\n            rank[p1] += 1\n\n        return True\n\n    heap = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            dist = abs(x1 - x2) + abs(y1 - y2)\n            heapq.heappush(heap, (dist, i, j))\n\n    cost = 0\n    while heap:\n        d, n1, n2 = heapq.heappop(heap)\n        if union(n1, n2):\n            cost += d\n\n    return cost\n\n\npoints = [[0, 0], [2, 2], [3, 10], [5, 2], [7, 0]]\nprint(minCostConnectPointsPrim(points))  # 20\nprint(minCostConnectPointsKruskal(points))  # 20\n</code></pre>"},{"location":"graph_theory/mst/#1168-optimize-water-distribution-in-a-village","title":"1168. Optimize Water Distribution in a Village","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: union find, graph, heap priority queue, minimum spanning tree </p> </li> </ul> <p></p> 1168. Optimize Water Distribution in a Village - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minCostToSupplyWater1(\n    n: int, wells: List[int], pipes: List[List[int]]\n) -&gt; int:\n    graph = defaultdict(list)\n\n    for h1, h2, cost in pipes:\n        graph[h1].append((h2, cost))\n        graph[h2].append((h1, cost))\n\n    # Add the cost of the wells to the graph (house 0)\n    for i in range(n):\n        graph[0].append((i + 1, wells[i]))\n        graph[i + 1].append((0, wells[i]))\n\n    visited = set([0])\n    heap = [(cost, dest) for dest, cost in graph[0]]\n    heapq.heapify(heap)\n\n    cost = 0\n\n    while heap:\n        c1, n1 = heapq.heappop(heap)\n        if n1 in visited:\n            continue\n        visited.add(n1)\n        cost += c1\n\n        for n2, c2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (c2, n2))\n\n    return cost\n\n\n# Kruskal\ndef minCostToSupplyWater2(\n    n: int, wells: List[int], pipes: List[List[int]]\n) -&gt; int:\n    par = list(range(n + 1))\n    rank = [0] * (n + 1)\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            if rank[p1] &lt; rank[p2]:\n                par[p1] = p2\n            elif rank[p1] &gt; rank[p2]:\n                par[p2] = p1\n            else:\n                par[p1] = p2\n                rank[p2] += 1\n            return True\n        return False\n\n    graph = [(c, 0, i + 1) for i, c in enumerate(wells)]\n    for h1, h2, c in pipes:\n        graph.append((c, h1, h2))\n\n    graph.sort()\n\n    cost = 0\n\n    for c, h1, h2 in graph:\n        if union(h1, h2):\n            cost += c\n\n    return cost\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |    Prim    | O((V + E) log V) | O(V + E)|\n# |  Kruskal   |     O(E log E)   | O(V + E)|\n# |------------|------------------|---------|\n\n\nn = 3\nwells = [1, 2, 2]\npipes = [[1, 2, 1], [2, 3, 1]]\nprint(minCostToSupplyWater1(n, wells, pipes))  # 3\nprint(minCostToSupplyWater2(n, wells, pipes))  # 3\n</code></pre>"},{"location":"graph_theory/mst/#1489-find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree","title":"1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: union find, graph, sorting, minimum spanning tree, strongly connected component</p> </li> </ul> 1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree - Python Solution<pre><code>from typing import List\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [1 for _ in range(n)]\n        self.part = n\n\n    def find(self, n):\n        p = self.parent[n]\n        while p != self.parent[p]:\n            self.parent[p] = self.parent[self.parent[p]]\n            p = self.parent[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return False\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.parent[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.parent[p1] = p2\n        else:\n            self.parent[p2] = p1\n            self.rank[p1] += 1\n\n        self.part -= 1\n        return True\n\n\n# Kruskal\ndef findCriticalAndPseudoCriticalEdges(\n    n: int, edges: List[List[int]]\n) -&gt; List[List[int]]:\n    m = len(edges)\n\n    # Add index to edges\n    lst = list(range(m))\n    lst.sort(key=lambda x: edges[x][2])\n\n    # Calculate minimum cost\n    min_cost = 0\n    uf = UnionFind(n)\n    for i in lst:\n        x, y, cost = edges[i]\n        if uf.union(x, y):\n            min_cost += cost\n\n    # Calculate key edges\n    key = set()\n    for i in lst:\n        cur_cost = 0\n        uf = UnionFind(n)\n        for j in lst:\n            if j != i:\n                x, y, cost = edges[j]\n                if uf.union(x, y):\n                    cur_cost += cost\n        if cur_cost &gt; min_cost or uf.part != 1:\n            key.add(i)\n\n    # Calculate fake edges\n    fake = set()\n    for i in lst:\n        if i not in key:\n            cur_cost = edges[i][2]\n            uf = UnionFind(n)\n            uf.union(edges[i][0], edges[i][1])\n            for j in lst:\n                x, y, cost = edges[j]\n                if uf.union(x, y):\n                    cur_cost += cost\n            if cur_cost == min_cost and uf.part == 1:\n                fake.add(i)\n\n    return [sorted(list(key)), sorted(list(fake))]\n\n\nn = 5\nedges = [\n    [0, 1, 1],\n    [1, 2, 1],\n    [2, 3, 2],\n    [0, 3, 2],\n    [0, 4, 3],\n    [3, 4, 3],\n    [1, 4, 6],\n]\nprint(findCriticalAndPseudoCriticalEdges(n, edges))\n</code></pre>"},{"location":"graph_theory/standard_traversal/","title":"Standard Traversal","text":"<ul> <li> 547. Number of Provinces (Medium)</li> <li> 802. Find Eventual Safe States (Medium)</li> <li> 841. Keys and Rooms (Medium)</li> <li> 1129. Shortest Path with Alternating Colors (Medium)</li> <li> 1376. Time Needed to Inform All Employees (Medium)</li> <li> 1466. Reorder Routes to Make All Paths Lead to the City Zero (Medium)</li> <li> 797. All Paths From Source to Target (Medium)</li> <li> 1192. Critical Connections in a Network (Hard)</li> </ul>"},{"location":"graph_theory/standard_traversal/#547-number-of-provinces","title":"547. Number of Provinces","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> <li>Return the number of provinces.</li> </ul>"},{"location":"graph_theory/standard_traversal/#union-find","title":"Union Find","text":"<ul> <li>Find by Path Compression</li> <li>Union by Rank</li> <li>Time Complexity: O(log(n))</li> <li>Space Complexity: O(n)</li> </ul> template/union_find.py<pre><code>class UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(n)}\n        self.rank = {i: 1 for i in range(n)}\n\n    def find(self, n):\n        p = self.par[n]\n        while self.par[p] != p:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return None\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.par[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.par[p1] = p2\n        else:\n            self.par[p2] = p1\n            self.rank[p1] += 1\n\n    def connected(self, n1, n2):\n        return self.find(n1) == self.find(n2)\n</code></pre> 547. Number of Provinces - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\nfrom template import UnionFind\n\n\n# DFS (Adjacency Matrix)\ndef findCircleNumDFSMatrix(isConnected: List[List[int]]) -&gt; int:\n    n = len(isConnected)\n    visited = set()\n\n    def dfs(node):\n        if node in visited:\n            return\n        visited.add(node)\n        for neighbor in range(n):\n            if node != neighbor and isConnected[node][neighbor] == 1:\n                dfs(neighbor)\n\n    res = 0\n    for i in range(n):\n        if i not in visited:\n            dfs(i)\n            res += 1\n\n    return res\n\n\n# DFS (Adjacency List)\ndef findCircleNumDFSList(isConnected: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    n = len(isConnected)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if isConnected[i][j] == 1:\n                graph[i].append(j)\n                graph[j].append(i)\n\n    visited = set()\n\n    def dfs(node):\n        if node in visited:\n            return\n        visited.add(node)\n        for neighbor in graph[node]:\n            dfs(neighbor)\n\n    res = 0\n    for i in range(n):\n        if i not in visited:\n            dfs(i)\n            res += 1\n\n    return res\n\n\n# BFS (Adjacency Matrix)\ndef findCircleNumBFS(isConnected: List[List[int]]) -&gt; int:\n    n = len(isConnected)\n    visited = set()\n    q = deque()\n    res = 0\n\n    for i in range(n):\n        if i not in visited:\n            res += 1\n\n            q.append(i)\n            while q:\n                node = q.popleft()\n                visited.add(node)\n                for node, val in enumerate(isConnected[node]):\n                    if val == 1 and node not in visited:\n                        q.append(node)\n                        visited.add(node)\n\n    return res\n\n\n# Union Find\ndef findCircleNumUF(isConnected: List[List[int]]) -&gt; int:\n    n = len(isConnected)\n    uf = UnionFind(n)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if isConnected[i][j] == 1:\n                uf.union(i, j)\n\n    res = len(set(uf.find(i) for i in range(n)))\n\n    return res\n\n\n# Union Find\ndef findCircleNum(isConnected: List[List[int]]) -&gt; int:\n    n = len(isConnected)\n    par = {i: i for i in range(n)}\n    rank = {i: 0 for i in range(n)}\n\n    def find(n):\n        p = par[n]\n        while par[p] != p:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 == p2:\n            return None\n\n        if rank[p1] &gt; rank[p2]:\n            par[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n        else:\n            par[p2] = p1\n            rank[p1] += 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if isConnected[i][j] == 1:\n                union(i, j)\n\n    res = len(set(find(i) for i in range(n)))\n\n    return res\n\n\nisConnected = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]\nprint(findCircleNumDFSList(isConnected))  # 2\nprint(findCircleNumDFSMatrix(isConnected))  # 2\nprint(findCircleNumBFS(isConnected))  # 2\nprint(findCircleNum(isConnected))  # 2\nprint(findCircleNumUF(isConnected))  # 2\n</code></pre>"},{"location":"graph_theory/standard_traversal/#802-find-eventual-safe-states","title":"802. Find Eventual Safe States","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort</p> </li> </ul> 802. Find Eventual Safe States - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# Topological Sort\ndef eventualSafeNodesTS(graph: List[List[int]]) -&gt; List[int]:\n    n = len(graph)\n    reverse_graph = defaultdict(list)\n    indegree = [0 for _ in range(n)]\n    safe = [False for _ in range(n)]\n\n    for u in range(n):\n        for v in graph[u]:\n            reverse_graph[v].append(u)\n        indegree[u] = len(graph[u])\n\n    q = deque([i for i in range(n) if indegree[i] == 0])\n\n    while q:\n        node = q.popleft()\n        safe[node] = True\n\n        for neighbor in reverse_graph[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n\n    return [i for i in range(n) if safe[i]]\n\n\n# DFS\ndef eventualSafeNodesDFS(graph: List[List[int]]) -&gt; List[int]:\n    n = len(graph)\n    state = [0 for _ in range(n)]  # 0: unvisited, 1: visiting, 2: visited\n\n    def dfs(node):\n        if state[node] &gt; 0:\n            return state[node] == 2\n        state[node] = 1\n        for neighbor in graph[node]:\n            if state[neighbor] == 1 or not dfs(neighbor):\n                return False\n        state[node] = 2\n        return True\n\n    return [i for i in range(n) if dfs(i)]\n\n\ngraph = [[1, 2], [2, 3], [5], [0], [5], [], []]\nprint(eventualSafeNodesTS(graph))  # [2, 4, 5, 6]\nprint(eventualSafeNodesDFS(graph))  # [2, 4, 5, 6]\n</code></pre>"},{"location":"graph_theory/standard_traversal/#841-keys-and-rooms","title":"841. Keys and Rooms","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph</p> </li> </ul> 841. Keys and Rooms - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef canVisitAllRoomsDFS(rooms: List[List[int]]) -&gt; bool:\n    n = len(rooms)\n    visited = [False for _ in range(n)]\n\n    def dfs(room):\n        visited[room] = True\n        for key in rooms[room]:\n            if not visited[key]:\n                dfs(key)\n\n    dfs(0)\n\n    return all(visited)\n\n\n# BFS\ndef canVisitAllRoomsBFS(rooms):\n    n = len(rooms)\n    visited = [False for _ in range(n)]\n    q = deque([0])\n    visited[0] = True\n\n    while q:\n        room = q.popleft()\n        for key in rooms[room]:\n            if not visited[key]:\n                visited[key] = True\n                q.append(key)\n\n    return all(visited)\n\n\nrooms = [[1, 3], [3, 0, 1], [2], [0]]\nprint(canVisitAllRoomsDFS(rooms))  # False\nprint(canVisitAllRoomsBFS(rooms))  # False\n</code></pre>"},{"location":"graph_theory/standard_traversal/#1129-shortest-path-with-alternating-colors","title":"1129. Shortest Path with Alternating Colors","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: breadth first search, graph</p> </li> </ul> 1129. Shortest Path with Alternating Colors - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef shortestAlternatingPaths(\n    n: int, redEdges: List[List[int]], blueEdges: List[List[int]]\n) -&gt; List[int]:\n    red_graph = defaultdict(list)\n    blue_graph = defaultdict(list)\n\n    for u, v in redEdges:\n        red_graph[u].append(v)\n    for u, v in blueEdges:\n        blue_graph[u].append(v)\n\n    answer = [-1 for _ in range(n)]\n    q = deque([(0, 0, 0), (0, 0, 1)])  # (node, distance, color)\n    visited = set()\n\n    while q:\n        node, dist, color = q.popleft()\n        if (node, color) in visited:\n            continue\n        visited.add((node, color))\n        if answer[node] == -1:\n            answer[node] = dist\n        if color == 0:\n            for neighbor in blue_graph[node]:\n                q.append((neighbor, dist + 1, 1))\n        else:\n            for neighbor in red_graph[node]:\n                q.append((neighbor, dist + 1, 0))\n\n    return answer\n\n\nn = 3\nred_edges = [[0, 1], [1, 2]]\nblue_edges = []\nprint(shortestAlternatingPaths(n, red_edges, blue_edges))  # [0, 1, -1]\n</code></pre>"},{"location":"graph_theory/standard_traversal/#1376-time-needed-to-inform-all-employees","title":"1376. Time Needed to Inform All Employees","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search</p> </li> </ul> 1376. Time Needed to Inform All Employees - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# DFS\ndef numOfMinutesDFS(\n    n: int, headID: int, manager: List[int], informTime: List[int]\n) -&gt; int:\n    graph = defaultdict(list)\n    for i in range(n):\n        if manager[i] != -1:\n            graph[manager[i]].append(i)\n\n    def dfs(node):\n        time = 0\n        for sub in graph[node]:\n            time = max(time, dfs(sub))\n        return time + informTime[node]\n\n    return dfs(headID)\n\n\n# BFS\ndef numOfMinutesBFS(\n    n: int, headID: int, manager: List[int], informTime: List[int]\n) -&gt; int:\n    graph = defaultdict(list)\n    for i in range(n):\n        if manager[i] != -1:\n            graph[manager[i]].append(i)\n\n    q = deque([(headID, 0)])\n    max_time = 0\n\n    while q:\n        node, time = q.popleft()\n        max_time = max(max_time, time)\n        for sub in graph[node]:\n            q.append((sub, time + informTime[node]))\n\n    return max_time\n\n\nn = 6\nheadID = 2\nmanager = [2, 2, -1, 2, 2, 2]\ninformTime = [0, 0, 1, 0, 0, 0]\nprint(numOfMinutesDFS(n, headID, manager, informTime))  # 1\nprint(numOfMinutesBFS(n, headID, manager, informTime))  # 1\n</code></pre>"},{"location":"graph_theory/standard_traversal/#1466-reorder-routes-to-make-all-paths-lead-to-the-city-zero","title":"1466. Reorder Routes to Make All Paths Lead to the City Zero","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph</p> </li> <li></li> </ul> 1466. Reorder Routes to Make All Paths Lead to the City Zero - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef minReorderBFS(n: int, connections: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append((v, 1))  # go\n        graph[v].append((u, 0))  # come\n\n    changes = 0\n    q = deque([(0, -1)])\n\n    while q:\n        n1, d1 = q.popleft()\n\n        for n2, d2 in graph[n1]:\n            if n2 != d1:\n                changes += d2\n                q.append((n2, n1))\n\n    return changes\n\n\n# DFS\ndef minReorderDFS(n: int, connections: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append((v, 1))  # go\n        graph[v].append((u, 0))  # come\n\n    def dfs(n1, d1):\n        changes = 0\n        for n2, d2 in graph[n1]:\n            if n2 != d1:\n                changes += d2 + dfs(n2, n1)\n        return changes\n\n    return dfs(0, -1)\n\n\nn = 5\nconnections = [[1, 0], [1, 2], [3, 2], [3, 4]]\nprint(minReorderBFS(n, connections))  # 2\nprint(minReorderDFS(n, connections))  # 2\n</code></pre>"},{"location":"graph_theory/standard_traversal/#797-all-paths-from-source-to-target","title":"797. All Paths From Source to Target","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: backtracking, depth first search, breadth first search, graph</p> </li> </ul> 797. All Paths From Source to Target - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS (Backtracking)\ndef allPathsSourceTargetDFS(graph: List[List[int]]) -&gt; List[List[int]]:\n    res = []\n    n = len(graph)\n\n    def dfs(node, path):\n        if node == n - 1:\n            res.append(path.copy())\n            return None\n\n        for nei in graph[node]:\n            path.append(nei)\n            dfs(nei, path)\n            path.pop()\n\n    dfs(0, [0])\n\n    return res\n\n\n# BFS\ndef allPathsSourceTargetBFS(graph: List[List[int]]) -&gt; List[List[int]]:\n    n = len(graph)\n    res = []\n    q = deque([(0, [0])])\n\n    while q:\n        node, path = q.popleft()\n\n        if node == n - 1:\n            res.append(path)\n\n        for nei in graph[node]:\n            q.append((nei, path + [nei]))\n\n    return res\n\n\ngraph = [[1, 2], [3], [3], []]\nprint(allPathsSourceTargetDFS(graph))  # [[0, 1, 3], [0, 2, 3]]\nprint(allPathsSourceTargetBFS(graph))  # [[0, 1, 3], [0, 2, 3]]\n</code></pre>"},{"location":"graph_theory/standard_traversal/#1192-critical-connections-in-a-network","title":"1192. Critical Connections in a Network","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: depth first search, graph, biconnected component</p> </li> </ul> 1192. Critical Connections in a Network - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Tarjan\ndef criticalConnections(\n    n: int, connections: List[List[int]]\n) -&gt; List[List[int]]:\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    disc = [-1] * n\n    low = [-1] * n\n    bridges = []\n    time = 0\n\n    def dfs(n1, prev):\n        nonlocal time\n        disc[n1], low[n1] = time, time\n        time += 1\n\n        for n2 in graph[n1]:\n            if n2 == prev:\n                continue\n            if disc[n2] == -1:\n                dfs(n2, n1)\n                low[n1] = min(low[n1], low[n2])\n\n                if low[n2] &gt; disc[n1]:\n                    bridges.append([n1, n2])\n            else:\n                low[n1] = min(low[n1], disc[n2])\n\n    for i in range(n):\n        if disc[i] == -1:\n            dfs(i, -1)\n\n    return bridges\n\n\nn = 4\nconnections = [[0, 1], [1, 2], [2, 0], [1, 3]]\nprint(criticalConnections(n, connections))  # [[1, 3]]\n</code></pre>"},{"location":"graph_theory/topological_sort/","title":"Topological Sort","text":"<ul> <li> 207. Course Schedule (Medium)</li> <li> 210. Course Schedule II (Medium)</li> <li> 269. Alien Dictionary (Hard)</li> <li> 1203. Sort Items by Groups Respecting Dependencies (Hard)</li> <li> 1857. Largest Color Value in a Directed Graph (Hard)</li> </ul>"},{"location":"graph_theory/topological_sort/#207-course-schedule","title":"207. Course Schedule","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort</p> </li> <li>Return true if it is possible to finish all courses, otherwise return false.</li> <li>Dependency relationships imply the topological sort algorithm.</li> <li>Cycle detection</li> <li>Topological Sort<ul> <li>DAG (Directed Acyclic Graph)</li> <li>Time complexity: O(V+E)</li> <li>Space complexity: O(V+E)</li> <li>Prerequisites: Indegree (Look at the problem 1557. Minimum Number of Vertices to Reach All Nodes)<ul> <li>Indegree: Number of incoming edges to a vertex</li> </ul> </li> <li>Applications: task scheduling, course scheduling, build systems, dependency resolution, compiler optimization, etc.</li> </ul> </li> </ul> <p></p> <p></p> <p>Course to prerequisites mapping</p> <pre><code>flowchart LR\n    0((0)) --&gt; 1((1))\n    0((0)) --&gt; 2((2))\n    1((1)) --&gt; 3((3))\n    3((3)) --&gt; 4((4))\n    1((1)) --&gt; 4((4))</code></pre> <p>Prerequisites to course mapping</p> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    2((2)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))\n    4((4)) --&gt; 3((3))\n    4((4)) --&gt; 1((1))</code></pre> course 0 0 1 1 3 prerequisite 1 2 3 4 4 index 0 1 2 3 4 in-degree 0 0 0 0 0 <p>Initialize</p> <ul> <li>graph</li> </ul> prerequisite 1 2 3 4 course <code>[0]</code> <code>[0]</code> <code>[1]</code> <code>[1, 3]</code> <ul> <li>in-degree</li> </ul> 0 1 2 3 4 in-degree 2 2 0 1 0 <ul> <li>queue: <code>[2, 4]</code></li> <li>pop <code>2</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))\n    4((4)) --&gt; 3((3))\n    4((4)) --&gt; 1((1))</code></pre> 0 1 2 3 4 in-degree 1 2 0 1 0 <ul> <li>queue: <code>[4]</code></li> <li>pop <code>4</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))</code></pre> 0 1 2 3 4 in-degree 1 1 0 0 0 <ul> <li>queue: <code>[3]</code></li> <li>pop <code>3</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))</code></pre> 0 1 2 3 4 in-degree 1 0 0 0 0 <ul> <li>queue: <code>[1]</code></li> <li>pop <code>1</code> from the queue</li> </ul> <pre><code>flowchart LR\n    0((0))</code></pre> 0 1 2 3 4 in-degree 0 0 0 0 0 <ul> <li>queue: <code>[0]</code></li> <li>pop <code>0</code> from the queue</li> <li>All courses are taken. Return <code>True</code>.</li> </ul> 207. Course Schedule - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS (Kahn's Algorithm)\ndef canFinishBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    count = 0\n\n    while q:\n        crs = q.popleft()\n        count += 1\n\n        for nxt in graph[crs]:\n            indegree[nxt] -= 1\n\n            if indegree[nxt] == 0:\n                q.append(nxt)\n\n    return count == numCourses\n\n\n# DFS + Set\ndef canFinishDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for crs, pre in prerequisites:\n        graph[crs].append(pre)\n\n    visiting = set()\n\n    def dfs(crs):\n        if crs in visiting:  # cycle detected\n            return False\n        if graph[crs] == []:\n            return True\n\n        visiting.add(crs)\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        visiting.remove(crs)\n        graph[crs] = []\n\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\n# DFS + List\ndef canFinishDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for pre, crs in prerequisites:\n        graph[crs].append(pre)\n\n    # 0: init, 1: visiting, 2: visited\n    status = [0] * numCourses\n\n    def dfs(crs):\n        if status[crs] == 1:  # cycle detected\n            return False\n        if status[crs] == 2:\n            return True\n\n        status[crs] = 1\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        status[crs] = 2\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(canFinishBFS(5, prerequisites))  # True\nprint(canFinishDFS1(5, prerequisites))  # True\nprint(canFinishDFS2(5, prerequisites))  # True\n</code></pre>"},{"location":"graph_theory/topological_sort/#210-course-schedule-ii","title":"210. Course Schedule II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort</p> </li> <li>Return the ordering of courses you should take to finish all courses. If there are multiple valid answers, return any of them.</li> </ul> <p></p> 210. Course Schedule II - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# 1. BFS - Kahn's Algorithm\ndef findOrderBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    order = []\n\n    while q:\n        pre = q.popleft()\n        order.append(pre)\n\n        for crs in graph[pre]:\n            indegree[crs] -= 1\n            if indegree[crs] == 0:\n                q.append(crs)\n\n    return order if len(order) == numCourses else []\n\n\n# 2. DFS + Set\ndef findOrderDFS1(\n    numCourses: int, prerequisites: List[List[int]]\n) -&gt; List[int]:\n    adj = defaultdict(list)\n    for crs, pre in prerequisites:\n        adj[crs].append(pre)\n\n    visit, cycle = set(), set()\n    order = []\n\n    def dfs(crs):\n        if crs in cycle:\n            return False\n        if crs in visit:\n            return True\n\n        cycle.add(crs)\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        cycle.remove(crs)\n        visit.add(crs)\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order\n\n\n# 3. DFS + List\ndef findOrderDFS2(\n    numCourses: int, prerequisites: List[List[int]]\n) -&gt; List[int]:\n    adj = defaultdict(list)\n    for pre, crs in prerequisites:\n        adj[crs].append(pre)\n\n    # 0: not visited, 1: visiting, 2: visited\n    state = [0] * numCourses\n    order = []\n\n    def dfs(crs):\n        if state[crs] == 1:\n            return False\n        if state[crs] == 2:\n            return True\n\n        state[crs] = 1\n\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        state[crs] = 2\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order[::-1]\n\n\nnumCourses = 5\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(findOrderBFS(numCourses, prerequisites))  # [2, 4, 3, 1, 0]\nprint(findOrderDFS1(numCourses, prerequisites))  # [4, 3, 1, 2, 0]\nprint(findOrderDFS2(numCourses, prerequisites))  # [4, 3, 2, 1, 0]\n</code></pre>"},{"location":"graph_theory/topological_sort/#269-alien-dictionary","title":"269. Alien Dictionary","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, depth first search, breadth first search, graph, topological sort</p> </li> <li>Return the correct order of characters in the alien language.</li> </ul> 269. Alien Dictionary - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS - Kahn's algorithm (Topological Sort)\ndef alienOrderBFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    indegree = {c: 0 for word in words for c in word}\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                    indegree[w2[j]] += 1\n                break\n\n    q = deque([c for c in indegree if indegree[c] == 0])\n    result = []\n\n    while q:\n        char = q.popleft()\n        result.append(char)\n\n        for neighbor in graph[char]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n\n    return \"\".join(result) if len(result) == len(indegree) else \"\"\n\n\n# DFS - Topological Sort\ndef alienOrderDFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    visited = {}\n    result = []\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                break\n\n    def dfs(c):\n        if c in visited:\n            return visited[c]\n\n        visited[c] = False\n        for neighbor in graph[c]:\n            if not dfs(neighbor):\n                return False\n\n        visited[c] = True\n        result.append(c)\n        return True\n\n    for c in list(graph.keys()):\n        if not dfs(c):\n            return \"\"\n\n    return \"\".join(result[::-1])\n\n\nwords = [\"wrt\", \"wrf\", \"er\", \"ett\", \"rftt\"]\nprint(alienOrderBFS(words))  # wertf\nprint(alienOrderDFS(words))  # wertf\n</code></pre>"},{"location":"graph_theory/topological_sort/#1203-sort-items-by-groups-respecting-dependencies","title":"1203. Sort Items by Groups Respecting Dependencies","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort</p> </li> <li>Return any permutation of the items that satisfies the requirements.</li> </ul> 1203. Sort Items by Groups Respecting Dependencies - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS - Kahn's algorithm (Topological Sort)\ndef sortItems(\n    n: int, m: int, group: List[int], beforeItems: List[List[int]]\n) -&gt; List[int]:\n    def topological_sort(graph, indegree, nodes):\n        q = deque([node for node in nodes if indegree[node] == 0])\n        result = []\n\n        while q:\n            node = q.popleft()\n            result.append(node)\n\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    q.append(neighbor)\n\n        return result if len(result) == len(nodes) else []\n\n    groupItems = defaultdict(list)\n    groupGraph = defaultdict(set)\n    groupIndegree = defaultdict(int)\n    itemGraph = defaultdict(set)\n    itemIndegree = defaultdict(int)\n\n    for i in range(n):\n        if group[i] == -1:\n            group[i] = m\n            m += 1\n        groupItems[group[i]].append(i)\n\n    for i, beforeItem in enumerate(beforeItems):\n        for before in beforeItem:\n            if group[before] != group[i]:\n                if group[i] not in groupGraph[group[before]]:\n                    groupGraph[group[before]].add(group[i])\n                    groupIndegree[group[i]] += 1\n            else:\n                itemGraph[before].add(i)\n                itemIndegree[i] += 1\n\n    allGroups = list(set(group))\n    groupOrder = topological_sort(groupGraph, groupIndegree, allGroups)\n    if not groupOrder:\n        return []\n\n    result = []\n    for g in groupOrder:\n        items = groupItems[g]\n        itemOrder = topological_sort(itemGraph, itemIndegree, items)\n        if not itemOrder:\n            return []\n        result.extend(itemOrder)\n\n    return result\n\n\nn = 8\nm = 2\ngroup = [-1, -1, 1, 0, 0, 1, 0, -1]\nbeforeItems = [[], [6], [5], [6], [3, 6], [], [], []]\nprint(sortItems(n, m, group, beforeItems))\n</code></pre>"},{"location":"graph_theory/topological_sort/#1857-largest-color-value-in-a-directed-graph","title":"1857. Largest Color Value in a Directed Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, dynamic programming, graph, topological sort, memoization, counting</p> </li> </ul> 1857. Largest Color Value in a Directed Graph - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# Topological Sort\ndef largestPathValue(colors: str, edges: List[List[int]]) -&gt; int:\n    n = len(colors)\n    graph = defaultdict(list)\n    indegree = [0 for _ in range(n)]\n\n    for u, v in edges:\n        graph[u].append(v)\n        indegree[v] += 1\n\n    q = deque([i for i in range(n) if indegree[i] == 0])\n\n    dp = [[0] * 26 for _ in range(n)]\n\n    for i in range(n):\n        dp[i][ord(colors[i]) - ord(\"a\")] = 1\n\n    processed, max_color = 0, 0\n\n    while q:\n        n1 = q.popleft()\n        processed += 1\n        max_color = max(max_color, max(dp[n1]))\n\n        for n2 in graph[n1]:\n            indegree[n2] -= 1\n            for i in range(26):\n                dp[n2][i] = max(\n                    dp[n2][i],\n                    dp[n1][i] + (1 if i == ord(colors[n2]) - ord(\"a\") else 0),\n                )\n            if indegree[n2] == 0:\n                q.append(n2)\n\n    return max_color if processed == n else -1\n\n\ncolors = \"abaca\"\nedges = [[0, 1], [0, 2], [2, 3], [3, 4]]\nprint(largestPathValue(colors, edges))  # 3\n</code></pre>"},{"location":"graph_theory/union_find/","title":"Union Find","text":"<ul> <li> 721. Accounts Merge (Medium)</li> <li> 990. Satisfiability of Equality Equations (Medium)</li> <li> 1061. Lexicographically Smallest Equivalent String (Medium)</li> <li> 839. Similar String Groups (Hard)</li> </ul>"},{"location":"graph_theory/union_find/#721-accounts-merge","title":"721. Accounts Merge","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, depth first search, breadth first search, union find, sorting</p> </li> </ul> 721. Accounts Merge - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef accountsMerge(accounts: List[List[str]]) -&gt; List[List[str]]:\n    parent = defaultdict(str)\n    rank = defaultdict(int)\n    email_to_name = defaultdict(str)\n    merged_accounts = defaultdict(list)\n\n    def find(n):\n        p = parent[n]\n        while p != parent[p]:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    for account in accounts:\n        name = account[0]\n        first_email = account[1]\n\n        for email in account[1:]:\n            if email not in parent:\n                parent[email] = email\n                rank[email] = 1\n            email_to_name[email] = name\n            union(first_email, email)\n\n    for email in parent:\n        root_email = find(email)\n        merged_accounts[root_email].append(email)\n\n    result = []\n    for root_email, emails in merged_accounts.items():\n        result.append([email_to_name[root_email]] + sorted(emails))\n\n    return result\n\n\naccounts = [\n    [\"John\", \"johnsmith@mail.com\", \"john_newyork@mail.com\"],\n    [\"John\", \"johnsmith@mail.com\", \"john00@mail.com\"],\n    [\"Mary\", \"mary@mail.com\"],\n    [\"John\", \"johnnybravo@mail.com\"],\n]\nprint(accountsMerge(accounts))\n# [['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],\n# ['Mary', 'mary@mail.com'],\n# ['John', 'johnnybravo@mail.com']]\n</code></pre>"},{"location":"graph_theory/union_find/#990-satisfiability-of-equality-equations","title":"990. Satisfiability of Equality Equations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, union find, graph</p> </li> </ul> 990. Satisfiability of Equality Equations - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef equationsPossible(equations: List[str]) -&gt; bool:\n    parent = defaultdict(str)\n    rank = defaultdict(int)\n\n    def find(n):\n        p = parent[n]\n        while p != parent[p]:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    for equation in equations:\n        if equation[0] not in parent:\n            parent[equation[0]] = equation[0]\n            rank[equation[0]] = 1\n        if equation[3] not in parent:\n            parent[equation[3]] = equation[3]\n            rank[equation[3]] = 1\n\n    for equation in equations:\n        if equation[1] == \"=\":\n            union(equation[0], equation[3])\n\n    for equation in equations:\n        if equation[1] == \"!\":\n            if find(equation[0]) == find(equation[3]):\n                return False\n\n    return True\n\n\nequations = [\"a==b\", \"b!=a\"]\nprint(equationsPossible(equations))  # False\n</code></pre>"},{"location":"graph_theory/union_find/#1061-lexicographically-smallest-equivalent-string","title":"1061. Lexicographically Smallest Equivalent String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, union find</p> </li> </ul> 1061. Lexicographically Smallest Equivalent String - Python Solution<pre><code># Union Find\ndef smallestEquivalentString(s1: str, s2: str, baseStr: str) -&gt; str:\n    parent = {chr(i): chr(i) for i in range(ord(\"a\"), ord(\"z\") + 1)}\n\n    def find(n):\n        p = parent[n]\n        while parent[p] != p:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            if p1 &lt; p2:\n                parent[p2] = p1\n            else:\n                parent[p1] = p2\n\n    for i in range(len(s1)):\n        union(s1[i], s2[i])\n\n    result = []\n    for c in baseStr:\n        result.append(find(c))\n\n    return \"\".join(result)\n\n\ns1 = \"parker\"\ns2 = \"morris\"\nbaseStr = \"parser\"\nprint(smallestEquivalentString(s1, s2, baseStr))  # \"makkek\"\n</code></pre>"},{"location":"graph_theory/union_find/#839-similar-string-groups","title":"839. Similar String Groups","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, string, depth first search, breadth first search, union find</p> </li> </ul> 839. Similar String Groups - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef numSimilarGroups(strs: List[str]) -&gt; int:\n    n = len(strs)\n    parent = list(range(n))\n    rank = [0 for _ in range(n)]\n\n    def find(n):\n        p = parent[n]\n        while parent[p] != p:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    def is_similar(s1, s2):\n        diff = 0\n        for c1, c2 in zip(s1, s2):\n            if c1 != c2:\n                diff += 1\n            if diff &gt; 2:\n                return False\n        return True\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_similar(strs[i], strs[j]):\n                union(i, j)\n\n    return sum(find(i) == i for i in range(n))\n\n\nstrs = [\"tars\", \"rats\", \"arts\", \"star\"]\nprint(numSimilarGroups(strs))  # 2\n</code></pre>"},{"location":"grind75/","title":"Grind 75","text":""},{"location":"grind75/array/","title":"Array","text":"<ul> <li> 1. Two Sum (Easy)</li> <li> 121. Best Time to Buy and Sell Stock (Easy)</li> <li> 169. Majority Element (Easy)</li> <li> 217. Contains Duplicate (Easy)</li> <li> 57. Insert Interval (Medium)</li> <li> 15. 3Sum (Medium)</li> <li> 238. Product of Array Except Self (Medium)</li> <li> 39. Combination Sum (Medium)</li> <li> 56. Merge Intervals (Medium)</li> <li> 75. Sort Colors (Medium)</li> <li> 11. Container With Most Water (Medium)</li> </ul>"},{"location":"grind75/array/#1-two-sum","title":"1. Two Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table</p> </li> <li>Return the indices of the two numbers such that they add up to a specific target.</li> </ul> Approach Time Complexity Space Complexity Hashmap O(n) O(n) 1. Two Sum - Python Solution<pre><code>from typing import List\n\n\n# Hashmap\ndef twoSum(nums: List[int], target: int) -&gt; List[int]:\n    hashmap = {}  # val: idx\n\n    for idx, val in enumerate(nums):\n        if (target - val) in hashmap:\n            return [hashmap[target - val], idx]\n\n        hashmap[val] = idx\n\n\nnums = [2, 7, 11, 15]\ntarget = 18\nassert twoSum(nums, target) == [1, 2]\n</code></pre>"},{"location":"grind75/array/#121-best-time-to-buy-and-sell-stock","title":"121. Best Time to Buy and Sell Stock","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li>Return the maximum profit that can be achieved from buying on one day and selling on another day.</li> </ul> 121. Best Time to Buy and Sell Stock - Python Solution<pre><code>from typing import List\n\n\n# Brute Force\ndef maxProfitBF(prices: List[int]) -&gt; int:\n    max_profit = 0\n    n = len(prices)\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_profit = max(max_profit, prices[j] - prices[i])\n\n    return max_profit\n\n\n# DP\ndef maxProfitDP(prices: List[int]) -&gt; int:\n    dp = [[0] * 2 for _ in range(len(prices))]\n    dp[0][0] = -prices[0]  # buy\n    dp[0][1] = 0  # sell\n\n    for i in range(1, len(prices)):\n        dp[i][0] = max(dp[i - 1][0], -prices[i])  # the lowest price to buy\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    max_profit = 0\n    seen_min = prices[0]\n\n    for i in range(1, len(prices)):\n        max_profit = max(max_profit, prices[i] - seen_min)\n        seen_min = min(seen_min, prices[i])\n\n    return max_profit\n\n\n# Fast Slow Pointers\ndef maxProfitFS(prices: List[int]) -&gt; int:\n    max_profit = 0\n    slow, fast = 0, 1\n\n    while fast &lt; len(prices):\n        if prices[fast] &gt; prices[slow]:\n            max_profit = max(max_profit, prices[fast] - prices[slow])\n        else:\n            slow = fast\n        fast += 1\n\n    return max_profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force|  O(n^2)|  O(1)   |\n# | DP         |  O(n)  |  O(n)   |\n# | Greedy     |  O(n)  |  O(1)   |\n# | Fast Slow  |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitBF(prices))  # 5\nprint(maxProfitDP(prices))  # 5\nprint(maxProfitGreedy(prices))  # 5\nprint(maxProfitFS(prices))  # 5\n</code></pre>"},{"location":"grind75/array/#169-majority-element","title":"169. Majority Element","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, divide and conquer, sorting, counting</p> </li> <li>Return the majority element in an array. The majority element is the element that appears more than <code>n // 2</code> times.</li> </ul> <code>num</code> <code>count</code> <code>res</code> 2 1 2 2 2 2 1 1 2 1 0 2 1 1 1 2 0 1 2 1 2 169. Majority Element - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash Map\ndef majorityElementHashMap(nums: List[int]) -&gt; int:\n    n = len(nums)\n    freq = defaultdict(int)\n\n    for num in nums:\n        freq[num] += 1\n        if freq[num] &gt; n // 2:\n            return num\n\n\n# Array - Boyer-Moore Voting Algorithm\ndef majorityElementArray(nums: List[int]) -&gt; int:\n    res = None\n    count = 0\n\n    for num in nums:\n        if count == 0:\n            res = num\n        count += 1 if num == res else -1\n\n    return res\n\n\n# | Algorithm | Time Complexity | Space Complexity |\n# |-----------|-----------------|------------------|\n# | HashMap   | O(N)            | O(N)             |\n# | Array     | O(N)            | O(1)             |\n# |-----------|-----------------|------------------|\n\n\nnums = [2, 2, 1, 1, 1, 2, 2]\nprint(majorityElementArray(nums))  # 2\nprint(majorityElementHashMap(nums))  # 2\n</code></pre>"},{"location":"grind75/array/#217-contains-duplicate","title":"217. Contains Duplicate","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, sorting</p> </li> <li>Return True if the array contains any duplicates, otherwise return False.</li> </ul> 217. Contains Duplicate - Python Solution<pre><code>from typing import List\n\n\n# Brute Force\ndef containsDuplicateBF(nums: List[int]) -&gt; bool:\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] == nums[j]:\n                return True\n\n    return False\n\n\n# Sort\ndef containsDuplicateSort(nums: List[int]) -&gt; bool:\n    nums.sort()\n\n    for i in range(1, len(nums)):\n        if nums[i] == nums[i - 1]:\n            return True\n\n    return False\n\n\n# Set\ndef containsDuplicateSet(nums: List[int]) -&gt; bool:\n    seen = set()\n\n    for i in nums:\n        if i in seen:\n            return True\n        seen.add(i)\n\n    return False\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# | Brute Force |    O(n^2)       |    O(1)      |\n# |     Sort    |    O(n log n)   |    O(1)      |\n# |     Set     |    O(n)         |    O(n)      |\n# |-------------|-----------------|--------------|\n\nprint(containsDuplicateBF([1, 2, 3, 1]))  # True\nprint(containsDuplicateSort([1, 2, 3, 1]))  # True\nprint(containsDuplicateSet([1, 2, 3, 1]))  # True\n</code></pre>"},{"location":"grind75/array/#57-insert-interval","title":"57. Insert Interval","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array</p> </li> </ul> 57. Insert Interval - Python Solution<pre><code>from typing import List\n\n\n# Interval\ndef insert(\n    intervals: List[List[int]], newInterval: List[int]\n) -&gt; List[List[int]]:\n    n = len(intervals)\n\n    if n == 0:\n        return [newInterval]\n\n    if newInterval[1] &lt; intervals[0][0]:\n        return [newInterval] + intervals\n\n    if newInterval[0] &gt; intervals[-1][1]:\n        return intervals + [newInterval]\n\n    i = 0\n    result = []\n\n    while i &lt; n and intervals[i][1] &lt; newInterval[0]:\n        result.append(intervals[i])\n        i += 1\n\n    while i &lt; n and intervals[i][0] &lt;= newInterval[1]:\n        newInterval[0] = min(newInterval[0], intervals[i][0])\n        newInterval[1] = max(newInterval[1], intervals[i][1])\n        i += 1\n\n    result.append(newInterval)\n\n    while i &lt; n:\n        result.append(intervals[i])\n        i += 1\n\n    return result\n\n\nintervals = [[1, 3], [6, 9]]\nnewInterval = [2, 5]\nprint(insert(intervals, newInterval))  # [[1, 5], [6, 9]]\n</code></pre>"},{"location":"grind75/array/#15-3sum","title":"15. 3Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, sorting</p> </li> </ul> 15. 3Sum - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef threeSum(nums: List[int]) -&gt; List[List[int]]:\n    nums.sort()\n    res = []\n    n = len(nums)\n\n    for i in range(n - 2):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        left, right = i + 1, n - 1\n\n        while left &lt; right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total &gt; 0:\n                right -= 1\n            elif total &lt; 0:\n                left += 1\n            else:\n                res.append([nums[i], nums[left], nums[right]])\n\n                while left &lt; right and nums[left] == nums[left + 1]:\n                    left += 1\n\n                while left &lt; right and nums[right] == nums[right - 1]:\n                    right -= 1\n\n                left += 1\n                right -= 1\n\n    return res\n\n\nnums = [-1, 0, 1, 2, -1, -4]\nassert threeSum(nums) == [[-1, -1, 2], [-1, 0, 1]]\n</code></pre>"},{"location":"grind75/array/#238-product-of-array-except-self","title":"238. Product of Array Except Self","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, prefix sum</p> </li> <li>Classic Prefix Sum problem</li> <li>Return an array <code>output</code> such that <code>output[i]</code> is equal to the product of all the elements of <code>nums</code> except <code>nums[i]</code>.</li> </ul> Approach Time Space Prefix O(n) O(n) Prefix (Optimized) O(n) O(1) 238. Product of Array Except Self - Python Solution<pre><code>from typing import List\n\n\n# Prefix\ndef productExceptSelf(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    prefix = [1 for _ in range(n)]\n    suffix = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        prefix[i] = nums[i - 1] * prefix[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        suffix[i] = nums[i + 1] * suffix[i + 1]\n\n    result = [i * j for i, j in zip(prefix, suffix)]\n\n    return result\n\n\n# Prefix (Optimized)\ndef productExceptSelfOptimized(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    result = [1 for _ in range(n)]\n\n    prefix = 1\n    for i in range(n):\n        result[i] = prefix\n        prefix *= nums[i]\n\n    suffix = 1\n    for i in range(n - 1, -1, -1):\n        result[i] *= suffix\n        suffix *= nums[i]\n\n    return result\n\n\nprint(productExceptSelf([1, 2, 3, 4]))\n# [24, 12, 8, 6]\nprint(productExceptSelfOptimized([1, 2, 3, 4]))\n# [24, 12, 8, 6]\n</code></pre>"},{"location":"grind75/array/#39-combination-sum","title":"39. Combination Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking</p> </li> </ul> 39. Combination Sum - Python Solution<pre><code>from typing import List\n\n\ndef combinationSum(candidates: List[int], target: int) -&gt; List[List[int]]:\n    result = []\n    path = []\n\n    def backtracking(total, start):\n        if total &gt; target:\n            return None\n        if total == target:\n            result.append(path[:])\n            return None\n\n        for i in range(start, len(candidates)):\n            total += candidates[i]\n            path.append(candidates[i])\n\n            backtracking(total, i)\n\n            total -= candidates[i]\n            path.pop()\n\n    backtracking(0, 0)\n    return result\n\n\nprint(combinationSum([2, 3, 6, 7], 7))  # [[2, 2, 3], [7]]\n</code></pre>"},{"location":"grind75/array/#56-merge-intervals","title":"56. Merge Intervals","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sorting</p> </li> <li>Merge all overlapping intervals.</li> </ul> 56. Merge Intervals - Python Solution<pre><code>from typing import List\n\n\n# Intervals\ndef merge(intervals: List[List[int]]) -&gt; List[List[int]]:\n    n = len(intervals)\n    if n &lt;= 1:\n        return intervals\n\n    intervals.sort(key=lambda x: x[0])\n    res = [intervals[0]]\n\n    for i in range(1, n):\n        if intervals[i][0] &lt;= res[-1][1]:\n            res[-1][1] = max(res[-1][1], intervals[i][1])\n        else:\n            res.append(intervals[i])\n\n    return res\n\n\nprint(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))\n# [[1, 6], [8, 10], [15, 18]]\n</code></pre>"},{"location":"grind75/array/#75-sort-colors","title":"75. Sort Colors","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, sorting</p> </li> </ul> 75. Sort Colors - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef sortColors(nums: List[int]) -&gt; None:\n    \"\"\"Sorts an array of 0, 1, and 2 in-place.\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    current = 0\n\n    while current &lt;= right:\n        if nums[current] == 0:\n            nums[left], nums[current] = nums[current], nums[left]\n            left += 1\n            current += 1\n        elif nums[current] == 2:\n            nums[right], nums[current] = nums[current], nums[right]\n            right -= 1\n        else:\n            current += 1\n\n\nnums = [2, 0, 2, 1, 1, 0]\nsortColors(nums)\nprint(nums)  # [0, 0, 1, 1, 2, 2]\n</code></pre>"},{"location":"grind75/array/#11-container-with-most-water","title":"11. Container With Most Water","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy</p> </li> <li>Return the maximum area of water that can be trapped between the vertical lines.</li> </ul> <p></p> 11. Container With Most Water - Python Solution<pre><code>from typing import List\n\n\n# Brute Force\ndef maxAreaBF(height: List[int]) -&gt; int:\n    max_area = 0\n\n    for i in range(len(height)):\n        for j in range(i + 1, len(height)):\n            h = min(height[i], height[j])\n            w = j - i\n            max_area = max(max_area, h * w)\n\n    return max_area\n\n\n# Left Right Pointers\ndef maxAreaLR(height: List[int]) -&gt; int:\n    left, right = 0, len(height) - 1\n    res = 0\n\n    while left &lt; right:\n        h = min(height[left], height[right])\n        w = right - left\n        res = max(res, h * w)\n\n        if height[left] &lt; height[right]:\n            left += 1\n        else:\n            right -= 1\n\n    return res\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force| O(n^2) |  O(1)   |\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nheight = [1, 8, 6, 2, 5, 4, 8, 3, 7]\nprint(maxAreaBF(height))  # 49\nprint(maxAreaLR(height))  # 49\n</code></pre>"},{"location":"grind75/binary/","title":"Binary","text":"<ul> <li> 67. Add Binary (Easy)</li> </ul>"},{"location":"grind75/binary/#67-add-binary","title":"67. Add Binary","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, string, bit manipulation, simulation</p> </li> </ul>"},{"location":"grind75/binary_search/","title":"Binary Search","text":"<ul> <li> 704. Binary Search (Easy)</li> <li> 278. First Bad Version (Easy)</li> <li> 33. Search in Rotated Sorted Array (Medium)</li> <li> 981. Time Based Key-Value Store (Medium)</li> <li> 1235. Maximum Profit in Job Scheduling (Hard)</li> </ul>"},{"location":"grind75/binary_search/#704-binary-search","title":"704. Binary Search","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, binary search</p> </li> <li>Implement binary search algorithm.</li> </ul> 704. Binary Search - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef search(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] &lt; target:\n            left = mid + 1\n        elif nums[mid] &gt; target:\n            right = mid - 1\n        else:\n            return mid\n\n    return -1\n\n\nnums = [-1, 0, 3, 5, 9, 12]\ntarget = 9\nprint(search(nums, target))  # 4\n</code></pre>"},{"location":"grind75/binary_search/#278-first-bad-version","title":"278. First Bad Version","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: binary search, interactive</p> </li> <li>Find the first bad version given a function <code>isBadVersion</code>.</li> </ul> 278. First Bad Version - Python Solution<pre><code># Binary Search\ndef firstBadVersion(n: int) -&gt; int:\n    left, right = 1, n\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if isBadVersion(mid):\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return left\n\n\ndef isBadVersion(version: int) -&gt; bool:\n    pass\n</code></pre>"},{"location":"grind75/binary_search/#33-search-in-rotated-sorted-array","title":"33. Search in Rotated Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul> 33. Search in Rotated Sorted Array - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef search(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] == target:\n            return mid\n\n        if nums[left] &lt;= nums[mid]:\n            if nums[left] &lt;= target &lt; nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if nums[mid] &lt; target &lt;= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n    return -1\n\n\nnums = [4, 5, 6, 7, 0, 1, 2]\ntarget = 0\nprint(search(nums, target))  # 4\n</code></pre>"},{"location":"grind75/binary_search/#981-time-based-key-value-store","title":"981. Time Based Key-Value Store","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, binary search, design</p> </li> </ul> 981. Time Based Key-Value Store - Python Solution<pre><code>from collections import defaultdict\n\n\n# Binary Search\nclass TimeMap:\n\n    def __init__(self):\n        self.keys = defaultdict(list)\n        self.times = dict()\n\n    def set(self, key: str, value: str, timestamp: int) -&gt; None:\n        self.keys[key].append(timestamp)\n        self.times[timestamp] = value\n\n    def get(self, key: str, timestamp: int) -&gt; str:\n        tmp = self.keys[key]\n\n        left, right = 0, len(tmp) - 1\n        while left &lt;= right:\n            mid = left + (right - left) // 2\n            if tmp[mid] &gt; timestamp:\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        return self.times[tmp[right]] if right &gt;= 0 else \"\"\n\n\nobj = TimeMap()\nobj.set(\"foo\", \"bar\", 1)\nprint(obj.get(\"foo\", 1))  # bar\nprint(obj.get(\"foo\", 3))  # bar\nobj.set(\"foo\", \"bar2\", 4)\nprint(obj.get(\"foo\", 4))  # bar2\nprint(obj.get(\"foo\", 5))  # bar2\n</code></pre>"},{"location":"grind75/binary_search/#1235-maximum-profit-in-job-scheduling","title":"1235. Maximum Profit in Job Scheduling","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, dynamic programming, sorting</p> </li> </ul>"},{"location":"grind75/binary_search_tree/","title":"Binary Search Tree","text":"<ul> <li> 235. Lowest Common Ancestor of a Binary Search Tree (Medium)</li> <li> 98. Validate Binary Search Tree (Medium)</li> <li> 230. Kth Smallest Element in a BST (Medium)</li> </ul>"},{"location":"grind75/binary_search_tree/#235-lowest-common-ancestor-of-a-binary-search-tree","title":"235. Lowest Common Ancestor of a Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree</p> </li> </ul> 235. Lowest Common Ancestor of a Binary Search Tree - Python Solution<pre><code>from binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef lowestCommonAncestor(\n    root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n) -&gt; \"TreeNode\":\n    while root:\n        if root.val &gt; p.val and root.val &gt; q.val:\n            root = root.left\n        elif root.val &lt; p.val and root.val &lt; q.val:\n            root = root.right\n        else:\n            return root\n\n\nroot = [6, 2, 8, 0, 4, 7, 9, None, None, 3, 5]\nroot = build(root)\np = root.left\nq = root.right\nprint(root)\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\nprint(lowestCommonAncestor(root, p, q))\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\n</code></pre>"},{"location":"grind75/binary_search_tree/#98-validate-binary-search-tree","title":"98. Validate Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree</p> </li> </ul> 98. Validate Binary Search Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef isValidBST(root: Optional[TreeNode]) -&gt; bool:\n    inorder = []  # inorder traversal of BST\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    for i in range(1, len(inorder)):\n        if inorder[i] &lt;= inorder[i - 1]:\n            return False\n\n    return True\n\n\nroot = [5, 1, 4, None, None, 3, 6]\nroot = build(root)\nprint(root)\n#   5__\n#  /   \\\n# 1     4\n#      / \\\n#     3   6\nprint(isValidBST(root))  # False\n# [1, 5, 3, 4, 6]\n</code></pre>"},{"location":"grind75/binary_search_tree/#230-kth-smallest-element-in-a-bst","title":"230. Kth Smallest Element in a BST","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree</p> </li> </ul> 230. Kth Smallest Element in a BST - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BST\ndef kthSmallest(root: Optional[TreeNode], k: int) -&gt; int:\n    inorder = []\n\n    def dfs(node):\n        if not node:\n            return None\n\n        dfs(node.left)\n        nonlocal inorder\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    return inorder[k - 1]\n\n\n# |----------|------|-------|\n# | Approach | Time | Space |\n# |----------|------|-------|\n# | DFS      | O(n) | O(n)  |\n# |----------|------|-------|\n\n\nroot = build([3, 1, 4, None, 2])\nk = 1\nprint(root)\n#   __3\n#  /   \\\n# 1     4\n#  \\\n#   2\nprint(kthSmallest(root, k))  # 1\n</code></pre>"},{"location":"grind75/binary_tree/","title":"Binary Tree","text":"<ul> <li> 226. Invert Binary Tree (Easy)</li> <li> 110. Balanced Binary Tree (Easy)</li> <li> 543. Diameter of Binary Tree (Easy)</li> <li> 104. Maximum Depth of Binary Tree (Easy)</li> <li> 102. Binary Tree Level Order Traversal (Medium)</li> <li> 236. Lowest Common Ancestor of a Binary Tree (Medium)</li> <li> 199. Binary Tree Right Side View (Medium)</li> <li> 105. Construct Binary Tree from Preorder and Inorder Traversal (Medium)</li> <li> 297. Serialize and Deserialize Binary Tree (Hard)</li> </ul>"},{"location":"grind75/binary_tree/#226-invert-binary-tree","title":"226. Invert Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree</p> </li> </ul> 226. Invert Binary Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef invertTreeRecursive(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    root.left, root.right = root.right, root.left\n\n    invertTreeRecursive(root.left)\n    invertTreeRecursive(root.right)\n\n    return root\n\n\n# Iterative\ndef invertTreeIterative(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    stack = [root]\n\n    while stack:\n        node = stack.pop()\n\n        node.left, node.right = node.right, node.left\n        if node.left:\n            stack.append(node.left)\n        if node.right:\n            stack.append(node.right)\n\n    return root\n\n\nroot = build([4, 2, 7, 1, 3, 6, 9])\nprint(root)\n#     __4__\n#    /     \\\n#   2       7\n#  / \\     / \\\n# 1   3   6   9\ninvertedRecursive = invertTreeRecursive(root)\nprint(invertedRecursive)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\nroot = build([4, 2, 7, 1, 3, 6, 9])\ninvertedIterative = invertTreeIterative(root)\nprint(invertedIterative)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\n</code></pre>"},{"location":"grind75/binary_tree/#110-balanced-binary-tree","title":"110. Balanced Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul> 110. Balanced Binary Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef isBalanced(root: Optional[TreeNode]) -&gt; bool:\n    def getHeight(node):\n        if not node:\n            return 0\n\n        # post order\n        leftHeight = getHeight(node.left)\n        rightHeight = getHeight(node.right)\n\n        if leftHeight == -1 or rightHeight == -1:\n            return -1\n\n        if abs(leftHeight - rightHeight) &gt; 1:\n            return -1\n        else:\n            return 1 + max(leftHeight, rightHeight)\n\n    if getHeight(root) != -1:\n        return True\n    else:\n        return False\n\n\nroot = [3, 9, 20, None, None, 15, 7]\nroot = build(root)\nprint(root)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(isBalanced(root))  # True\n</code></pre>"},{"location":"grind75/binary_tree/#543-diameter-of-binary-tree","title":"543. Diameter of Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul> 543. Diameter of Binary Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Tree DFS\ndef diameterOfBinaryTree(root: Optional[TreeNode]) -&gt; int:\n    diameter = 0\n\n    def dfs(node):\n        if not node:\n            return 0\n\n        left = dfs(node.left)\n        right = dfs(node.right)\n\n        nonlocal diameter\n        diameter = max(diameter, left + right)\n\n        return 1 + max(left, right)\n\n    dfs(root)\n    return diameter\n\n\nroot = build([1, 2, 3, 4, 5])\nprint(root)\n#     __1\n#    /   \\\n#   2     3\n#  / \\\n# 4   5\nprint(diameterOfBinaryTree(root))  # 3\n</code></pre>"},{"location":"grind75/binary_tree/#104-maximum-depth-of-binary-tree","title":"104. Maximum Depth of Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree</p> </li> </ul> 104. Maximum Depth of Binary Tree - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef maxDepthRecursive(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    left = maxDepthRecursive(root.left)\n    right = maxDepthRecursive(root.right)\n\n    return 1 + max(left, right)\n\n\n# DFS\ndef maxDepthDFS(root: Optional[TreeNode]) -&gt; int:\n    res = 0\n\n    def dfs(node, cnt):\n        if node is None:\n            return\n        cnt += 1\n        nonlocal res\n        res = max(res, cnt)\n\n        dfs(node.left, cnt)\n        dfs(node.right, cnt)\n\n    dfs(root, 0)\n\n    return res\n\n\n# Iterative\ndef maxDepthIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n    res = 0\n\n    while q:\n        res += 1\n        n = len(q)\n\n        for _ in range(n):\n            node = q.popleft()\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return res\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n#     ____1\n#    /     \\\n#   2__     2\n#  /   \\\n# 3     4\n#      /\n#     5\nprint(maxDepthRecursive(root))  # 4\nprint(maxDepthIterative(root))  # 4\nprint(maxDepthDFS(root))  # 4\n</code></pre>"},{"location":"grind75/binary_tree/#102-binary-tree-level-order-traversal","title":"102. Binary Tree Level Order Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, breadth first search, binary tree</p> </li> </ul> 102. Binary Tree Level Order Traversal - Python Solution<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef levelOrder(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        level = []\n        n = len(q)\n\n        for _ in range(n):\n            cur = q.popleft()\n            level.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(level)\n\n    return res\n\n\ntree = build([3, 9, 20, None, None, 15, 7])\nprint(tree)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(levelOrder(tree))  # [[3], [9, 20], [15, 7]]\n</code></pre>"},{"location":"grind75/binary_tree/#236-lowest-common-ancestor-of-a-binary-tree","title":"236. Lowest Common Ancestor of a Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul> 236. Lowest Common Ancestor of a Binary Tree - Python Solution<pre><code>from typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef lowestCommonAncestor(\n    root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n) -&gt; \"TreeNode\":\n    if not root or q == root or p == root:\n        return root\n\n    left = lowestCommonAncestor(root.left, p, q)\n    right = lowestCommonAncestor(root.right, p, q)\n\n    if left and right:\n        return root\n\n    return left or right\n\n\nroot = build([3, 5, 1, 6, 2, 0, 8, None, None, 7, 4])\nprint(root)\n#     ______3__\n#    /         \\\n#   5__         1\n#  /   \\       / \\\n# 6     2     0   8\n#      / \\\n#     7   4\np = root.left  # 5\nq = root.right  # 1\nprint(lowestCommonAncestor(root, p, q))  # 3\n#     ______3__\n#    /         \\\n#   5__         1\n#  /   \\       / \\\n# 6     2     0   8\n#      / \\\n#     7   4\nr = root.left.right.right  # 4\nprint(lowestCommonAncestor(root, p, r))  # 5\n#   5__\n#  /   \\\n# 6     2\n#      / \\\n#     7   4\n</code></pre>"},{"location":"grind75/binary_tree/#199-binary-tree-right-side-view","title":"199. Binary Tree Right Side View","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree <pre><code>    ____1       &lt;---\n   /     \\\n  2__     2     &lt;--- Look at the rightmost node at each level\n /   \\     \\\n3     4     3   &lt;---\n     /\n    5           &lt;---\n</code></pre></p> </li> </ul> 199. Binary Tree Right Side View - Python Solution<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Binary Tree\ndef rightSideView(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        n = len(q)\n\n        for i in range(n):\n            cur = q.popleft()\n\n            # rightmost element\n            if i == n - 1:\n                res.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n    return res\n\n\nroot = [1, 2, 2, 3, 4, None, 3, None, None, 5]\nroot = build(root)\nprint(root)\n#     ____1\n#    /     \\\n#   2__     2\n#  /   \\     \\\n# 3     4     3\n#      /\n#     5\nprint(rightSideView(root))  # [1, 2, 3, 5]\n</code></pre>"},{"location":"grind75/binary_tree/#105-construct-binary-tree-from-preorder-and-inorder-traversal","title":"105. Construct Binary Tree from Preorder and Inorder Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, divide and conquer, tree, binary tree</p> </li> </ul> 105. Construct Binary Tree from Preorder and Inorder Traversal - Python Solution<pre><code>from typing import List, Optional\n\nfrom helper import TreeNode\n\n\ndef buildTree(preorder: List[int], inorder: List[int]) -&gt; Optional[TreeNode]:\n    \"\"\"\n    preorder  root left right  1  2  3\n    inorder   left root right  4  5  6\n    \"\"\"\n    if len(preorder) == 0:\n        return None\n\n    root_val = preorder[0]  # 1\n    root = TreeNode(root_val)\n\n    separator_idx = inorder.index(root_val)  # 5\n\n    left_inorder = inorder[:separator_idx]  # 4\n    right_inorder = inorder[separator_idx + 1 :]  # 6\n\n    left_preorder = preorder[1 : 1 + len(left_inorder)]  # 2\n    right_preorder = preorder[1 + len(left_inorder) :]  # 3\n\n    root.left = buildTree(left_preorder, left_inorder)\n    root.right = buildTree(right_preorder, right_inorder)\n\n    return root\n\n\npreorder = [3, 9, 20, 15, 7]\ninorder = [9, 3, 15, 20, 7]\nroot = buildTree(preorder, inorder)\nprint(root)\n#     3\n#    / \\\n#   9  20\n#     /  \\\n#    15   7\n</code></pre>"},{"location":"grind75/binary_tree/#297-serialize-and-deserialize-binary-tree","title":"297. Serialize and Deserialize Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, tree, depth first search, breadth first search, design, binary tree</p> </li> </ul> 297. Serialize and Deserialize Binary Tree - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BFS\nclass BFS:\n    def serialize(self, root: Optional[TreeNode]) -&gt; str:\n        if not root:\n            return \"\"\n\n        res = []\n        q = deque([root])\n\n        while q:\n            node = q.popleft()\n\n            if node:\n                res.append(str(node.val))\n                q.append(node.left)\n                q.append(node.right)\n            else:\n                res.append(\"null\")\n\n        return \",\".join(res)\n\n    def deserialize(self, data: str) -&gt; Optional[TreeNode]:\n        if not data:\n            return None\n\n        nodes = data.split(\",\")\n        root = TreeNode(int(nodes[0]))\n        q = deque([root])\n        index = 1\n\n        while q:\n            node = q.popleft()\n\n            if nodes[index] != \"null\":\n                node.left = TreeNode(int(nodes[index]))\n                q.append(node.left)\n            index += 1\n\n            if nodes[index] != \"null\":\n                node.right = TreeNode(int(nodes[index]))\n                q.append(node.right)\n            index += 1\n\n        return root\n\n\n# DFS\nclass DFS:\n    def serialize(self, root: Optional[TreeNode]) -&gt; str:\n        def dfs(node):\n            if not node:\n                return [\"null\"]\n            return [str(node.val)] + dfs(node.left) + dfs(node.right)\n\n        return \",\".join(dfs(root))\n\n    def deserialize(self, data: str) -&gt; Optional[TreeNode]:\n        nodes = data.split(\",\")\n        self.index = 0\n\n        def dfs():\n            if nodes[self.index] == \"null\":\n                self.index += 1\n                return None\n\n            node = TreeNode(int(nodes[self.index]))\n            self.index += 1\n\n            node.left = dfs()\n            node.right = dfs()\n\n            return node\n\n        root = dfs()\n        return root\n\n\nroot = build([1, 2, 3, None, None, 4, 5])\nprint(root)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n\nbfs = BFS()\ndata1 = bfs.serialize(root)\nprint(data1)  # \"1,2,3,null,null,4,5,null,null,null,null\"\nroot1 = bfs.deserialize(data1)\nprint(root1)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n\ndfs = DFS()\ndata2 = dfs.serialize(root)\nprint(data2)  # \"1,2,null,null,3,4,null,null,5,null,null\"\nroot2 = dfs.deserialize(data2)\nprint(root2)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n</code></pre>"},{"location":"grind75/dynamic_programming/","title":"Dynamic Programming","text":"<ul> <li> 70. Climbing Stairs (Easy)</li> <li> 53. Maximum Subarray (Medium)</li> <li> 322. Coin Change (Medium)</li> <li> 416. Partition Equal Subset Sum (Medium)</li> <li> 62. Unique Paths (Medium)</li> </ul>"},{"location":"grind75/dynamic_programming/#70-climbing-stairs","title":"70. Climbing Stairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, dynamic programming, memoization</p> </li> <li>Return the number of distinct ways to reach the top of the stairs.</li> <li><code>dp[n]</code> stores the number of distinct ways to reach the <code>n-th</code> stair.</li> <li>Formula: <code>dp[n] = dp[n - 1] + dp[n - 2]</code>.</li> <li>Initialize <code>dp[0] = 0</code>, <code>dp[1] = 1</code>, and <code>dp[2] = 2</code>.</li> </ul> n <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n]</code> 0 - - 0 1 - - 1 2 - 1 2 3 1 2 3 4 2 3 5 5 3 5 8 6 5 8 13 7 8 13 21 8 13 21 34 9 21 34 55 10 34 55 89 70. Climbing Stairs - Python Solution<pre><code># DP\ndef climbStairs(n: int) -&gt; int:\n    if n &lt;= 1:\n        return n\n\n    dp = [i for i in range(n + 1)]\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |     DP      |      O(n)       |     O(n)     |\n# |-------------|-----------------|--------------|\n\nprint(climbStairs(10))  # 89\n</code></pre>"},{"location":"grind75/dynamic_programming/#53-maximum-subarray","title":"53. Maximum Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, divide and conquer, dynamic programming</p> </li> </ul> 53. Maximum Subarray - Python Solution<pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxSubArrayDP(nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n\n    dp[0] = nums[0]\n    maxSum = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(\n            dp[i - 1] + nums[i],  # continue the previous subarray\n            nums[i],  # start a new subarray\n        )\n        maxSum = max(maxSum, dp[i])\n\n    return maxSum\n\n\n# Greedy\ndef maxSubArrayGreedy(nums: List[int]) -&gt; int:\n    max_sum = nums[0]\n    cur_sum = 0\n\n    for num in nums:\n        cur_sum = max(cur_sum + num, num)\n        max_sum = max(max_sum, cur_sum)\n\n    return max_sum\n\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArrayDP(nums))  # 6\nprint(maxSubArrayGreedy(nums))  # 6\n</code></pre>"},{"location":"grind75/dynamic_programming/#322-coin-change","title":"322. Coin Change","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, breadth first search</p> </li> </ul> 322. Coin Change - Python Solution<pre><code>from typing import List\n\n\ndef coinChange(coins: List[int], amount: int) -&gt; int:\n    dp = [float(\"inf\") for _ in range(amount + 1)]\n\n    dp[0] = 0\n\n    for i in range(1, amount + 1):\n        for c in coins:\n            if i - c &gt;= 0:\n                dp[i] = min(dp[i], 1 + dp[i - c])\n\n    return dp[amount] if dp[amount] != float(\"inf\") else -1\n\n\ncoins = [1, 2, 5]\namount = 11\nprint(coinChange(coins, amount))  # 3\n</code></pre>"},{"location":"grind75/dynamic_programming/#416-partition-equal-subset-sum","title":"416. Partition Equal Subset Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul> 416. Partition Equal Subset Sum - Python Solution<pre><code>from typing import List\n\nfrom template import knapsack01\n\n\n# DP - Knapsack 01\ndef canPartitionTemplate(nums: List[int]) -&gt; bool:\n    total = sum(nums)\n\n    if total % 2 == 1 or len(nums) &lt; 2:\n        return False\n\n    target = total // 2\n\n    return knapsack01(nums, nums, target) == target\n\n\n# DP - Knapsack 01\ndef canPartition(nums: List[int]) -&gt; bool:\n    total = sum(nums)\n\n    if total % 2 == 1 or len(nums) &lt; 2:\n        return False\n\n    target = total // 2\n\n    dp = [0 for _ in range(target + 1)]\n\n    for i in range(len(nums)):\n        for j in range(target, nums[i] - 1, -1):\n            dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])\n\n    return dp[target] == target\n\n\nnums = [1, 5, 11, 5]\nprint(canPartitionTemplate(nums))  # True\nprint(canPartition(nums))  # True\n</code></pre>"},{"location":"grind75/dynamic_programming/#62-unique-paths","title":"62. Unique Paths","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, combinatorics</p> </li> <li>Count the number of unique paths to reach the bottom-right corner of a <code>m x n</code> grid.</li> </ul> <p></p> 62. Unique Paths - Python Solution<pre><code># DP - 2D\ndef uniquePaths(m: int, n: int) -&gt; int:\n    if m == 1 or n == 1:\n        return 1\n\n    dp = [[1] * n for _ in range(m)]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]\n\n\nprint(uniquePaths(m=3, n=7))  # 28\n# [[1, 1, 1,  1,  1,  1,  1],\n#  [1, 2, 3,  4,  5,  6,  7],\n#  [1, 3, 6, 10, 15, 21, 28]]\n</code></pre>"},{"location":"grind75/graph/","title":"Graph","text":"<ul> <li> 733. Flood Fill (Easy)</li> <li> 542. 01 Matrix (Medium)</li> <li> 133. Clone Graph (Medium)</li> <li> 207. Course Schedule (Medium)</li> <li> 200. Number of Islands (Medium)</li> <li> 994. Rotting Oranges (Medium)</li> <li> 721. Accounts Merge (Medium)</li> <li> 79. Word Search (Medium)</li> <li> 310. Minimum Height Trees (Medium)</li> <li> 127. Word Ladder (Hard)</li> </ul>"},{"location":"grind75/graph/#733-flood-fill","title":"733. Flood Fill","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, matrix</p> </li> <li>Replace all the pixels of the same color starting from the given pixel.</li> <li>In other words, find the connected component of the starting pixel and change the color of all the pixels in that component.</li> <li>Edge cases: If the starting pixel is already the target color, return the image as it is.</li> <li>Flood Fill is essentially a graph traversal algorithm (like BFS or DFS) applied to matrices (2D grids).     It checks adjacent cells (up, down, left, right) of a starting point to determine whether they belong to the same region.     Typically, it involves modifying or marking the cells that belong to the same connected component.</li> </ul> <p></p> <p></p> 1 1 1 1 1 0 1 0 1 1 1 1 1 2 0 1 0 1 1 2 1 2 2 0 1 0 1 2 2 2 2 2 0 2 0 1 733. Flood Fill - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef floodFillDFS(\n    image: List[List[int]], sr: int, sc: int, color: int\n) -&gt; List[List[int]]:\n\n    org = image[sr][sc]\n    m, n = len(image), len(image[0])\n\n    if org == color:\n        return image\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or image[r][c] != org:\n            return None\n\n        image[r][c] = color\n\n        dfs(r - 1, c)\n        dfs(r + 1, c)\n        dfs(r, c - 1)\n        dfs(r, c + 1)\n\n    dfs(sr, sc)\n\n    return image\n\n\n# BFS\ndef floodFillBFS(\n    image: List[List[int]], sr: int, sc: int, color: int\n) -&gt; List[List[int]]:\n\n    org = image[sr][sc]\n    m, n = len(image), len(image[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    if org == color:\n        return image\n\n    q = deque([(sr, sc)])\n\n    while q:\n        r, c = q.popleft()\n        image[r][c] = color\n\n        for dr, dc in dirs:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and image[nr][nc] == org:\n                q.append((nr, nc))\n\n    return image\n\n\nimage = [[1, 1, 1], [1, 1, 0], [1, 0, 1]]\nsr = 1\nsc = 1\n\nprint(floodFillDFS(image, sr, sc, 2))\n# [[2, 2, 2], [2, 2, 0], [2, 0, 1]]\nprint(floodFillBFS(image, sr, sc, 2))\n# [[2, 2, 2], [2, 2, 0], [2, 0, 1]]\n</code></pre>"},{"location":"grind75/graph/#542-01-matrix","title":"542. 01 Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, breadth first search, matrix</p> </li> </ul> 542. 01 Matrix - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef updateMatrix(mat: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(mat), len(mat[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    q = deque()\n\n    for i in range(m):\n        for j in range(n):\n            if mat[i][j] == 0:\n                dist[i][j] = 0\n                q.append((i, j))\n\n    while q:\n        r, c = q.popleft()\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and dist[nr][nc] &gt; dist[r][c] + 1:\n                dist[nr][nc] = dist[r][c] + 1\n                q.append((nr, nc))\n\n    return dist\n\n\nmat = [[0, 0, 0], [0, 1, 0], [1, 1, 1]]\nprint(updateMatrix(mat))\n# [[0, 0, 0], [0, 1, 0], [1, 2, 1]]\n</code></pre>"},{"location":"grind75/graph/#133-clone-graph","title":"133. Clone Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, depth first search, breadth first search, graph</p> </li> </ul> 133. Clone Graph - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\n\nclass Node:\n    def __init__(self, val=0, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\n\n# 1. DFS\ndef cloneGraphDFS(node: Optional[\"Node\"]) -&gt; Optional[\"Node\"]:\n    if not node:\n        return None\n\n    cloned = {}  # {old: new}\n\n    def dfs(node):\n        if node in cloned:\n            return cloned[node]\n\n        new = Node(node.val)\n        cloned[node] = new\n\n        for neighbor in node.neighbors:\n            new.neighbors.append(dfs(neighbor))\n\n        return new\n\n    return dfs(node)\n\n\n# 2. BFS\ndef cloneGraphBFS(node: Optional[\"Node\"]) -&gt; Optional[\"Node\"]:\n    if not node:\n        return None\n\n    cloned = {node: Node(node.val)}\n    q = deque([node])\n\n    while q:\n        cur = q.popleft()\n\n        for neighbor in cur.neighbors:\n            if neighbor not in cloned:\n                cloned[neighbor] = Node(neighbor.val)\n                q.append(neighbor)\n\n            cloned[cur].neighbors.append(cloned[neighbor])\n\n    return cloned[node]\n</code></pre>"},{"location":"grind75/graph/#207-course-schedule","title":"207. Course Schedule","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort</p> </li> <li>Return true if it is possible to finish all courses, otherwise return false.</li> <li>Dependency relationships imply the topological sort algorithm.</li> <li>Cycle detection</li> <li>Topological Sort<ul> <li>DAG (Directed Acyclic Graph)</li> <li>Time complexity: O(V+E)</li> <li>Space complexity: O(V+E)</li> <li>Prerequisites: Indegree (Look at the problem 1557. Minimum Number of Vertices to Reach All Nodes)<ul> <li>Indegree: Number of incoming edges to a vertex</li> </ul> </li> <li>Applications: task scheduling, course scheduling, build systems, dependency resolution, compiler optimization, etc.</li> </ul> </li> </ul> <p></p> <p></p> <p>Course to prerequisites mapping</p> <pre><code>flowchart LR\n    0((0)) --&gt; 1((1))\n    0((0)) --&gt; 2((2))\n    1((1)) --&gt; 3((3))\n    3((3)) --&gt; 4((4))\n    1((1)) --&gt; 4((4))</code></pre> <p>Prerequisites to course mapping</p> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    2((2)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))\n    4((4)) --&gt; 3((3))\n    4((4)) --&gt; 1((1))</code></pre> course 0 0 1 1 3 prerequisite 1 2 3 4 4 index 0 1 2 3 4 in-degree 0 0 0 0 0 <p>Initialize</p> <ul> <li>graph</li> </ul> prerequisite 1 2 3 4 course <code>[0]</code> <code>[0]</code> <code>[1]</code> <code>[1, 3]</code> <ul> <li>in-degree</li> </ul> 0 1 2 3 4 in-degree 2 2 0 1 0 <ul> <li>queue: <code>[2, 4]</code></li> <li>pop <code>2</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))\n    4((4)) --&gt; 3((3))\n    4((4)) --&gt; 1((1))</code></pre> 0 1 2 3 4 in-degree 1 2 0 1 0 <ul> <li>queue: <code>[4]</code></li> <li>pop <code>4</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))</code></pre> 0 1 2 3 4 in-degree 1 1 0 0 0 <ul> <li>queue: <code>[3]</code></li> <li>pop <code>3</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))</code></pre> 0 1 2 3 4 in-degree 1 0 0 0 0 <ul> <li>queue: <code>[1]</code></li> <li>pop <code>1</code> from the queue</li> </ul> <pre><code>flowchart LR\n    0((0))</code></pre> 0 1 2 3 4 in-degree 0 0 0 0 0 <ul> <li>queue: <code>[0]</code></li> <li>pop <code>0</code> from the queue</li> <li>All courses are taken. Return <code>True</code>.</li> </ul> 207. Course Schedule - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS (Kahn's Algorithm)\ndef canFinishBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    count = 0\n\n    while q:\n        crs = q.popleft()\n        count += 1\n\n        for nxt in graph[crs]:\n            indegree[nxt] -= 1\n\n            if indegree[nxt] == 0:\n                q.append(nxt)\n\n    return count == numCourses\n\n\n# DFS + Set\ndef canFinishDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for crs, pre in prerequisites:\n        graph[crs].append(pre)\n\n    visiting = set()\n\n    def dfs(crs):\n        if crs in visiting:  # cycle detected\n            return False\n        if graph[crs] == []:\n            return True\n\n        visiting.add(crs)\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        visiting.remove(crs)\n        graph[crs] = []\n\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\n# DFS + List\ndef canFinishDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for pre, crs in prerequisites:\n        graph[crs].append(pre)\n\n    # 0: init, 1: visiting, 2: visited\n    status = [0] * numCourses\n\n    def dfs(crs):\n        if status[crs] == 1:  # cycle detected\n            return False\n        if status[crs] == 2:\n            return True\n\n        status[crs] = 1\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        status[crs] = 2\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(canFinishBFS(5, prerequisites))  # True\nprint(canFinishDFS1(5, prerequisites))  # True\nprint(canFinishDFS2(5, prerequisites))  # True\n</code></pre>"},{"location":"grind75/graph/#200-number-of-islands","title":"200. Number of Islands","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix</p> </li> <li>Count the number of islands in a 2D grid.</li> <li>Method 1: DFS</li> <li> <p>Method 2: BFS (use a queue to traverse the grid)</p> </li> <li> <p>How to keep track of visited cells?</p> <ol> <li>Mark the visited cell as <code>0</code> (or any other value) to avoid revisiting it.</li> <li>Use a set to store the visited cells.</li> </ol> </li> <li> <p>Steps:</p> <ol> <li>Init: variables</li> <li>DFS/BFS: starting from the cell with <code>1</code>, turn all the connected <code>1</code>s to <code>0</code>.</li> <li>Traverse the grid, and if the cell is <code>1</code>, increment the count and call DFS/BFS.</li> </ol> </li> </ul> <p></p> 200. Number of Islands - Python Solution<pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef numIslandsDFS(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    res = 0\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] != \"1\":\n            return\n\n        grid[r][c] = \"2\"\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                dfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Set\ndef numIslandsBFS1(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == \"0\"\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\" and (r, c) not in visited:\n                visited.add((r, c))\n                bfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = dr + row, dc + col\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] != \"1\"\n                ):\n                    continue\n                grid[nr][nc] = \"2\"\n                q.append((nr, nc))\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == \"1\":\n                grid[i][j] = \"2\"\n                bfs(i, j)\n                res += 1\n\n    return res\n\n\ngrid = [\n    [\"1\", \"1\", \"1\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"0\", \"0\", \"0\", \"0\", \"0\"],\n]\n\nprint(numIslandsDFS(deepcopy(grid)))  # 1\nprint(numIslandsBFS1(deepcopy(grid)))  # 1\nprint(numIslandsBFS2(deepcopy(grid)))  # 1\n</code></pre>"},{"location":"grind75/graph/#994-rotting-oranges","title":"994. Rotting Oranges","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, breadth first search, matrix</p> </li> <li>Return the minimum number of minutes that must elapse until no cell has a fresh orange.</li> <li>Hint: Multi-source BFS to count the level.</li> </ul> <p></p> 994. Rotting Oranges - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef orangesRotting(grid: List[List[int]]) -&gt; int:\n    # 1. Init\n    q = deque()\n    time, fresh = 0, 0\n    m, n = len(grid), len(grid[0])\n    dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n\n    # 2. Make a queue of rotten oranges and count fresh oranges\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                fresh += 1\n            if grid[r][c] == 2:\n                q.append([r, c])\n\n    # 3. BFS\n    while q and fresh &gt; 0:\n        size = len(q)\n\n        for _ in range(size):\n            r, c = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = r + dr, c + dc\n                if nr &lt; 0 or nc &lt; 0 or nr &gt;= m or nc &gt;= n or grid[nr][nc] != 1:\n                    continue\n                grid[nr][nc] = 2\n                q.append([nr, nc])\n                fresh -= 1\n        time += 1\n\n    return time if fresh == 0 else -1\n\n\ngrid = [[2, 1, 1], [1, 1, 0], [0, 1, 1]]\nprint(orangesRotting(grid))\n</code></pre>"},{"location":"grind75/graph/#721-accounts-merge","title":"721. Accounts Merge","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, depth first search, breadth first search, union find, sorting</p> </li> </ul> 721. Accounts Merge - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef accountsMerge(accounts: List[List[str]]) -&gt; List[List[str]]:\n    parent = defaultdict(str)\n    rank = defaultdict(int)\n    email_to_name = defaultdict(str)\n    merged_accounts = defaultdict(list)\n\n    def find(n):\n        p = parent[n]\n        while p != parent[p]:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    for account in accounts:\n        name = account[0]\n        first_email = account[1]\n\n        for email in account[1:]:\n            if email not in parent:\n                parent[email] = email\n                rank[email] = 1\n            email_to_name[email] = name\n            union(first_email, email)\n\n    for email in parent:\n        root_email = find(email)\n        merged_accounts[root_email].append(email)\n\n    result = []\n    for root_email, emails in merged_accounts.items():\n        result.append([email_to_name[root_email]] + sorted(emails))\n\n    return result\n\n\naccounts = [\n    [\"John\", \"johnsmith@mail.com\", \"john_newyork@mail.com\"],\n    [\"John\", \"johnsmith@mail.com\", \"john00@mail.com\"],\n    [\"Mary\", \"mary@mail.com\"],\n    [\"John\", \"johnnybravo@mail.com\"],\n]\nprint(accountsMerge(accounts))\n# [['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],\n# ['Mary', 'mary@mail.com'],\n# ['John', 'johnnybravo@mail.com']]\n</code></pre>"},{"location":"grind75/graph/#79-word-search","title":"79. Word Search","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, backtracking, depth first search, matrix</p> </li> </ul> 79. Word Search - Python Solution<pre><code>from typing import List\n\n\ndef exist(board: List[List[str]], word: str) -&gt; bool:\n    m, n = len(board), len(board[0])\n    path = set()\n    directions = ((0, 1), (1, 0), (0, -1), (-1, 0))\n\n    def dfs(r, c, i):\n        if i == len(word):\n            return True\n\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or board[r][c] != word[i]\n            or (r, c) in path\n        ):\n            return False\n\n        path.add((r, c))\n\n        for dr, dc in directions:\n            if dfs(r + dr, c + dc, i + 1):\n                return True\n\n        path.remove((r, c))\n        return False\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, 0):\n                return True\n\n    return False\n\n\nboard = [\n    [\"A\", \"B\", \"C\", \"E\"],\n    [\"S\", \"F\", \"C\", \"S\"],\n    [\"A\", \"D\", \"E\", \"E\"],\n]\nword = \"ABCCED\"\nprint(exist(board, word))  # True\n</code></pre>"},{"location":"grind75/graph/#310-minimum-height-trees","title":"310. Minimum Height Trees","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort</p> </li> </ul>"},{"location":"grind75/graph/#127-word-ladder","title":"127. Word Ladder","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, breadth first search</p> </li> <li>The most classic BFS problem.</li> <li>Return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.</li> </ul> Approach Time Space BFS O(n * m^2) O(n * m) 127. Word Ladder - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef ladderLength(beginWord: str, endWord: str, wordList: List[str]) -&gt; int:\n    if endWord not in wordList:\n        return 0\n\n    n = len(beginWord)\n    graph = defaultdict(list)  # pattern: words\n    wordList.append(beginWord)\n\n    for word in wordList:\n        for i in range(n):\n            pattern = word[:i] + \"*\" + word[i + 1 :]\n            graph[pattern].append(word)\n\n    visited = set([beginWord])\n    q = deque([beginWord])\n    res = 1\n\n    while q:\n        size = len(q)\n        for _ in range(size):\n            word = q.popleft()\n            if word == endWord:\n                return res\n\n            for i in range(n):\n                pattern = word[:i] + \"*\" + word[i + 1 :]\n                for neighbor in graph[pattern]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        q.append(neighbor)\n        res += 1\n\n    return 0\n\n\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]\nprint(ladderLength(beginWord, endWord, wordList))  # 5\n</code></pre>"},{"location":"grind75/hash_table/","title":"Hash Table","text":"<ul> <li> 383. Ransom Note (Easy)</li> </ul>"},{"location":"grind75/hash_table/#383-ransom-note","title":"383. Ransom Note","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, string, counting</p> </li> <li>Return <code>True</code> if the ransom note can be constructed from the magazines, otherwise, return <code>False</code>.</li> </ul> <pre><code>graph LR\n    A[\"Magazine: abcdef\"] --&gt; C(True)\n    B[\"Ransom Note: abc\"] --&gt; C</code></pre> 383. Ransom Note - Python Solution<pre><code>from collections import Counter, defaultdict\n\n\n# Array\ndef canConstructArray(ransomNote: str, magazine: str) -&gt; bool:\n    if len(ransomNote) &gt; len(magazine):\n        return False\n\n    record = [0 for _ in range(26)]\n\n    for i in magazine:\n        record[ord(i) - ord(\"a\")] += 1\n\n    for j in ransomNote:\n        record[ord(j) - ord(\"a\")] -= 1\n\n    for i in record:\n        if i &lt; 0:\n            return False\n\n    return True\n\n\n# Dict\ndef canConstructDict(ransomNote: str, magazine: str) -&gt; bool:\n    if len(ransomNote) &gt; len(magazine):\n        return False\n\n    record = defaultdict(int)\n\n    for i in magazine:\n        record[i] += 1\n\n    for j in ransomNote:\n        if j not in record or record[j] == 0:\n            return False\n        record[j] -= 1\n\n    return True\n\n\n# Counter\ndef canConstructCounter(ransomNote: str, magazine: str) -&gt; bool:\n    return not Counter(ransomNote) - Counter(magazine)\n\n\nransomNote = \"aa\"\nmagazine = \"aab\"\nprint(canConstructArray(ransomNote, magazine))  # True\nprint(canConstructDict(ransomNote, magazine))  # True\nprint(canConstructCounter(ransomNote, magazine))  # True\n</code></pre>"},{"location":"grind75/heap/","title":"Heap","text":"<ul> <li> 973. K Closest Points to Origin (Medium)</li> <li> 621. Task Scheduler (Medium)</li> <li> 295. Find Median from Data Stream (Hard)</li> <li> 23. Merge k Sorted Lists (Hard)</li> </ul>"},{"location":"grind75/heap/#973-k-closest-points-to-origin","title":"973. K Closest Points to Origin","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, divide and conquer, geometry, sorting, heap priority queue, quickselect</p> </li> </ul> 973. K Closest Points to Origin - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\ndef kClosest(points: List[List[int]], k: int) -&gt; List[List[int]]:\n    heap = []\n\n    for x, y in points:\n        dist = -(x**2 + y**2)  # max heap\n        if len(heap) &lt; k:\n            heapq.heappush(heap, (dist, x, y))\n        else:\n            heapq.heappushpop(heap, (dist, x, y))  # push and pop the smallest\n\n    return [[x, y] for (_, x, y) in heap]\n\n\n# Time complexity: O(n * log(k))\n#   - O(log(k)) for heapify\n#   - O(n) for iterating through the input list\n# Space complexity: O(k)\n\npoints = [[1, 3], [-2, 2]]\nk = 1\nprint(kClosest(points, k))  # [[-2, 2]]\n</code></pre>"},{"location":"grind75/heap/#621-task-scheduler","title":"621. Task Scheduler","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, greedy, sorting, heap priority queue, counting</p> </li> </ul> 621. Task Scheduler - Python Solution<pre><code>import heapq\nfrom collections import Counter, deque\nfrom typing import List\n\n\n# Heap\ndef leastInterval1(tasks: List[str], n: int) -&gt; int:\n    count = Counter(tasks)\n    heap = [-c for c in count.values()]\n    heapq.heapify(heap)\n\n    time = 0\n\n    q = deque()\n\n    while heap or q:\n        time += 1\n\n        if heap:\n            cnt = 1 + heapq.heappop(heap)\n            if cnt:\n                q.append((cnt, time + n))\n\n        if q and q[0][1] == time:\n            heapq.heappush(heap, q.popleft()[0])\n\n    return time\n\n\ndef leastInterval2(tasks: List[str], n: int) -&gt; int:\n    freq = Counter(tasks)\n\n    maxExec = max(freq.values())\n    maxCount = sum(1 for v in freq.values() if v == maxExec)\n\n    return max((maxExec - 1) * (n + 1) + maxCount, len(tasks))\n\n\ntasks = [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\"]\nn = 2\nprint(leastInterval1(tasks, n))  # 8\nprint(leastInterval2(tasks, n))  # 8\n</code></pre>"},{"location":"grind75/heap/#295-find-median-from-data-stream","title":"295. Find Median from Data Stream","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: two pointers, design, sorting, heap priority queue, data stream</p> </li> </ul> 295. Find Median from Data Stream - Python Solution<pre><code>from heapq import heappop, heappush\n\n\n# Heap - Two Heaps\nclass MedianFinder:\n    def __init__(self):\n        self.max = []\n        self.min = []\n\n    def addNum(self, num: int) -&gt; None:\n        heappush(self.max, -num)\n        heappush(self.min, -heappop(self.max))\n\n        if len(self.min) &gt; len(self.max):\n            heappush(self.max, -heappop(self.min))\n\n    def findMedian(self) -&gt; float:\n        if len(self.max) == len(self.min):\n            return (-self.max[0] + self.min[0]) / 2.0\n        else:\n            return -self.max[0]\n\n\n# TC: O(log n)\n# SC: O(n)\n\nmedian_finder = MedianFinder()\nmedian_finder.addNum(1)\nmedian_finder.addNum(2)\nassert median_finder.findMedian() == 1.5\nmedian_finder.addNum(3)\nassert median_finder.findMedian() == 2\nmedian_finder.addNum(4)\nassert median_finder.findMedian() == 2.5\nmedian_finder.addNum(5)\nassert median_finder.findMedian() == 3\nprint(\"All Passed.\")\n</code></pre>"},{"location":"grind75/heap/#23-merge-k-sorted-lists","title":"23. Merge k Sorted Lists","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: linked list, divide and conquer, heap priority queue, merge sort</p> </li> <li>Prerequisite: 21. Merge Two Sorted Lists</li> </ul> 23. Merge k Sorted Lists - Python Solution<pre><code>import copy\nimport heapq\nfrom typing import List, Optional\n\nfrom template import ListNode\n\n\n# Divide and Conquer\ndef mergeKListsDC(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    if not lists or len(lists) == 0:\n        return None\n\n    def mergeTwo(l1, l2):\n        dummy = ListNode()\n        cur = dummy\n\n        while l1 and l2:\n            if l1.val &lt; l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n\n            cur = cur.next\n\n        cur.next = l1 if l1 else l2\n\n        return dummy.next\n\n    while len(lists) &gt; 1:\n        merged = []\n\n        for i in range(0, len(lists), 2):\n            l1 = lists[i]\n            l2 = lists[i + 1] if i + 1 &lt; len(lists) else None\n            merged.append(mergeTwo(l1, l2))\n\n        lists = merged\n\n    return lists[0]\n\n\n# Heap - Merge k Sorted\ndef mergeKLists(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    minHeap = []  # (val, idx, node)\n\n    for idx, head in enumerate(lists):\n        if head:\n            heapq.heappush(minHeap, (head.val, idx, head))\n\n    while minHeap:\n        _, idx, node = heapq.heappop(minHeap)\n        cur.next = node\n        cur = cur.next\n\n        node = node.next\n        if node:\n            heapq.heappush(minHeap, (node.val, idx, node))\n\n    return dummy.next\n\n\nn1 = ListNode.create([1, 4, 5])\nn2 = ListNode.create([1, 3, 4])\nn3 = ListNode.create([2, 6])\nlists = [n1, n2, n3]\nlists1 = copy.deepcopy(lists)\nlists2 = copy.deepcopy(lists)\nprint(mergeKListsDC(lists1))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6\nprint(mergeKLists(lists2))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6\n</code></pre>"},{"location":"grind75/linked_list/","title":"Linked List","text":"<ul> <li> 21. Merge Two Sorted Lists (Easy)</li> <li> 141. Linked List Cycle (Easy)</li> <li> 206. Reverse Linked List (Easy)</li> <li> 876. Middle of the Linked List (Easy)</li> <li> 146. LRU Cache (Medium)</li> </ul>"},{"location":"grind75/linked_list/#21-merge-two-sorted-lists","title":"21. Merge Two Sorted Lists","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: linked list, recursion</p> </li> <li>Merge the two lists into one sorted list.</li> </ul> 21. Merge Two Sorted Lists - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef mergeTwoLists(\n    list1: Optional[ListNode], list2: Optional[ListNode]\n) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    while list1 and list2:\n        if list1.val &lt; list2.val:\n            cur.next = list1\n            list1 = list1.next\n        else:\n            cur.next = list2\n            list2 = list2.next\n        cur = cur.next\n\n    if list1:\n        cur.next = list1\n    elif list2:\n        cur.next = list2\n\n    return dummy.next\n\n\nlist1 = ListNode.create([1, 2, 4])\nlist2 = ListNode.create([1, 3, 4])\nprint(mergeTwoLists(list1, list2))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4\n</code></pre>"},{"location":"grind75/linked_list/#141-linked-list-cycle","title":"141. Linked List Cycle","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, linked list, two pointers</p> </li> <li>Determine if a linked list has a cycle in it.</li> </ul> <pre><code>graph LR\nA[3] --&gt; B[2]\nB --&gt; C[0]\nC --&gt; D[-4]</code></pre> <pre><code>graph LR\nA[3] --&gt; B[2]\nB --&gt; C[0]\nC --&gt; D[-4]\nD --&gt; B</code></pre> 141. Linked List Cycle - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\ndef hasCycle(head: Optional[ListNode]) -&gt; bool:\n    slow, fast = head, head\n\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n        if slow == fast:\n            return True\n\n    return False\n\n\nprint(hasCycle(ListNode.create([3, 2, 0, -4])))  # False\nprint(hasCycle(ListNode.create([3, 2, 0, -4], 1)))  # True\n</code></pre>"},{"location":"grind75/linked_list/#206-reverse-linked-list","title":"206. Reverse Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: linked list, recursion</p> </li> <li>Reverse a singly linked list.</li> </ul> <pre><code>graph LR\nA[1] --&gt; B[2]\nB --&gt; C[3]\nC --&gt; D[4]\nD --&gt; E[5]</code></pre> <pre><code>graph RL\nE[5] --&gt; D[4]\nD --&gt; C[3]\nC --&gt; B[2]\nB --&gt; A[1]</code></pre> 206. Reverse Linked List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Iterative\ndef reverseListIterative(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    cur = head\n    prev = None\n\n    while cur:\n        temp = cur.next\n        cur.next = prev\n\n        prev = cur\n        cur = temp\n\n    return prev\n\n\n# Recursive\ndef reverseListRecursive(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    def reverse(cur, prev=None):\n        if not cur:\n            return prev\n\n        temp = cur.next\n        cur.next = prev\n\n        return reverse(temp, cur)\n\n    return reverse(head)\n\n\nnums = [1, 2, 3, 4, 5]\nhead1 = ListNode.create(nums)\nprint(head1)\n# 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(reverseListIterative(head1))\n# 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1\nhead2 = ListNode.create(nums)\nprint(reverseListRecursive(head2))\n# 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1\n</code></pre>"},{"location":"grind75/linked_list/#876-middle-of-the-linked-list","title":"876. Middle of the Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: linked list, two pointers</p> </li> </ul>"},{"location":"grind75/linked_list/#146-lru-cache","title":"146. LRU Cache","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, linked list, design, doubly linked list</p> </li> <li>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.</li> </ul> <p></p> Data structure Description Doubly Linked List To store the key-value pairs. Hash Map To store the key-node pairs. Approach Time Complexity Space Complexity LRU O(1) O(n) 146. LRU Cache - Python Solution<pre><code>from collections import OrderedDict\n\n\n# Doubly Linked List\nclass Node:\n    def __init__(self, key=0, val=0):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.cache = {}\n        self.head = Node()\n        self.tail = Node()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def add_to_last(self, node):\n        self.tail.prev.next = node\n        node.prev = self.tail.prev\n        node.next = self.tail\n        self.tail.prev = node\n\n    def move_to_last(self, node):\n        self.remove(node)\n        self.add_to_last(node)\n\n    def get(self, key: int) -&gt; int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self.move_to_last(node)\n        return node.val\n\n    def put(self, key: int, value: int) -&gt; None:\n        if key in self.cache:\n            node = self.cache[key]\n            node.val = value\n            self.move_to_last(node)\n            return None\n\n        if len(self.cache) == self.cap:\n            del self.cache[self.head.next.key]\n            self.remove(self.head.next)\n\n        node = Node(key=key, val=value)\n        self.cache[key] = node\n        self.add_to_last(node)\n\n\n# OrderedDict\nclass LRUCacheOrderedDict:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.cap = capacity\n\n    def get(self, key: int):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key, last=True)\n        return self.cache[key]\n\n    def put(self, key: int, value: int):\n        if key in self.cache:\n            self.cache.move_to_end(key, last=True)\n        elif len(self.cache) &gt;= self.cap:\n            self.cache.popitem(last=False)\n\n        self.cache[key] = value\n\n\ncache = LRUCache(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\n\ncache = LRUCacheOrderedDict(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\nprint(\"LRU Cache passed\")\nprint(\"LRU Cache Ordered Dict passed\")\n</code></pre>"},{"location":"grind75/matrix/","title":"Matrix","text":"<ul> <li> 54. Spiral Matrix (Medium)</li> </ul>"},{"location":"grind75/matrix/#54-spiral-matrix","title":"54. Spiral Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, matrix, simulation</p> </li> <li>Return all elements of the matrix in spiral order.</li> </ul> 54. Spiral Matrix - Python Solution<pre><code>from typing import List\n\n\n# Array\ndef spiralOrder(matrix: List[List[int]]) -&gt; List[int]:\n    if not matrix or not matrix[0]:\n        return []\n\n    result = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n\n    while top &lt;= bottom and left &lt;= right:\n\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n\n        if top &lt;= bottom:\n\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left &lt;= right:\n\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n\n    return result\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Naive    |      O(N)       |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\nprint(spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n# [1, 2, 3, 6, 9, 8, 7, 4, 5]\n</code></pre>"},{"location":"grind75/recursion/","title":"Recursion","text":"<ul> <li> 46. Permutations (Medium)</li> <li> 78. Subsets (Medium)</li> <li> 17. Letter Combinations of a Phone Number (Medium)</li> </ul>"},{"location":"grind75/recursion/#46-permutations","title":"46. Permutations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking</p> </li> </ul> 46. Permutations - Python Solution<pre><code>from typing import List\n\n\ndef permute(nums: List[int]) -&gt; List[List[int]]:\n    path, result = [], []\n    used = [False for _ in range(len(nums))]\n\n    def backtracking():\n        if len(path) == len(nums):\n            result.append(path[:])\n\n        for i in range(len(nums)):\n            if used[i]:\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtracking()\n            path.pop()\n            used[i] = False\n\n    backtracking()\n\n    return result\n\n\nprint(permute([1, 2, 3]))\n# [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n</code></pre>"},{"location":"grind75/recursion/#78-subsets","title":"78. Subsets","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking, bit manipulation</p> </li> </ul> 78. Subsets - Python Solution<pre><code>from typing import List\n\n\ndef subsets(nums: List[int]) -&gt; List[List[int]]:\n    path, result = [], []\n\n    def backtracking(startIndex):\n        result.append(path[:])\n\n        for i in range(startIndex, len(nums)):\n            path.append(nums[i])\n            backtracking(i + 1)\n            path.pop()\n\n    backtracking(startIndex=0)\n\n    return result\n\n\nprint(subsets([1, 2, 3]))\n# [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]\n</code></pre>"},{"location":"grind75/recursion/#17-letter-combinations-of-a-phone-number","title":"17. Letter Combinations of a Phone Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, backtracking</p> </li> </ul> 17. Letter Combinations of a Phone Number - Python Solution<pre><code>from typing import List\n\n\ndef letterCombinations(digits: str) -&gt; List[str]:\n    letterMap = [\n        \"\",  # 0\n        \"\",  # 1\n        \"abc\",  # 2\n        \"def\",  # 3\n        \"ghi\",  # 4\n        \"jkl\",  # 5\n        \"mno\",  # 6\n        \"pqrs\",  # 7\n        \"tuv\",  # 8\n        \"wxyz\",  # 9\n    ]\n    res = []\n\n    def backtracking(index, s):\n        if index == len(digits):\n            res.append(s)\n            return None\n\n        digit = int(digits[index])\n        letters = letterMap[digit]\n\n        for i in range(len(letters)):\n            backtracking(index + 1, s + letters[i])\n\n    if len(digits) == 0:\n        return res\n\n    backtracking(0, \"\")\n\n    return res\n\n\nprint(letterCombinations(\"23\"))\n# ['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf']\n</code></pre>"},{"location":"grind75/stack/","title":"Stack","text":"<ul> <li> 20. Valid Parentheses (Easy)</li> <li> 232. Implement Queue using Stacks (Easy)</li> <li> 150. Evaluate Reverse Polish Notation (Medium)</li> <li> 155. Min Stack (Medium)</li> <li> 42. Trapping Rain Water (Hard)</li> <li> 224. Basic Calculator (Hard)</li> <li> 84. Largest Rectangle in Histogram (Hard)</li> </ul>"},{"location":"grind75/stack/#20-valid-parentheses","title":"20. Valid Parentheses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, stack</p> </li> <li>Determine if the input string is valid.</li> <li>Steps for the string <code>()[]{}</code>:</li> </ul> char action stack <code>(</code> push \"(\" <code>)</code> pop \"\" <code>[</code> push \"[\" <code>]</code> pop \"\" <code>{</code> push \"{\" <code>}</code> pop \"\" 20. Valid Parentheses - Python Solution<pre><code># Stack\ndef isValid(s: str) -&gt; bool:\n    hashmap = {\n        \")\": \"(\",\n        \"]\": \"[\",\n        \"}\": \"{\",\n    }\n    stack = []\n\n    for c in s:\n        if c in hashmap:\n            if stack and stack[-1] == hashmap[c]:\n                stack.pop()\n            else:\n                return False\n        else:\n            stack.append(c)\n\n    return True if not stack else False\n\n\nprint(isValid(\"()\"))  # True\nprint(isValid(\"()[]{}\"))  # True\nprint(isValid(\"(]\"))  # False\n</code></pre>"},{"location":"grind75/stack/#232-implement-queue-using-stacks","title":"232. Implement Queue using Stacks","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: stack, design, queue</p> </li> <li>Implement the following operations of a queue using stacks.<ul> <li><code>push(x)</code> - Push element x to the back of queue.</li> <li><code>pop()</code> - Removes the element from in front of queue.</li> <li><code>peek()</code> - Get the front element.</li> <li><code>empty()</code> - Return whether the queue is empty.</li> </ul> </li> </ul> 232. Implement Queue using Stacks - Python Solution<pre><code>class MyQueue:\n    def __init__(self):\n        self.stack_in = []\n        self.stack_out = []\n\n    def push(self, x: int) -&gt; None:\n        self.stack_in.append(x)\n\n    def pop(self) -&gt; int:\n        if self.empty():\n            return None\n\n        if self.stack_out:\n            return self.stack_out.pop()\n        else:\n            for _ in range(len(self.stack_in)):\n                self.stack_out.append(self.stack_in.pop())\n            return self.stack_out.pop()\n\n    def peek(self) -&gt; int:\n        answer = self.pop()\n        self.stack_out.append(answer)\n        return answer\n\n    def empty(self) -&gt; bool:\n        return not (self.stack_in or self.stack_out)\n\n\nobj = MyQueue()\nobj.push(1)\nprint(obj.pop())  # 1\nprint(obj.peek())  # None\nprint(obj.empty())  # False\n</code></pre>"},{"location":"grind75/stack/#150-evaluate-reverse-polish-notation","title":"150. Evaluate Reverse Polish Notation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, stack</p> </li> <li>Steps for the list <code>[\"2\", \"1\", \"+\", \"3\", \"*\"]</code>:</li> </ul> token action stack <code>2</code> push <code>[2]</code> <code>1</code> push <code>[2, 1]</code> <code>+</code> pop <code>[3]</code> <code>3</code> push <code>[3, 3]</code> <code>*</code> pop <code>[9]</code> 150. Evaluate Reverse Polish Notation - Python Solution<pre><code>from typing import List\n\n\n# Stack\ndef evalRPN(tokens: List[str]) -&gt; int:\n    stack = []\n\n    for c in tokens:\n        if c == \"+\":\n            stack.append(stack.pop() + stack.pop())\n        elif c == \"-\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(b - a)\n        elif c == \"*\":\n            stack.append(stack.pop() * stack.pop())\n        elif c == \"/\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(int(b / a))\n        else:\n            stack.append(int(c))\n\n    return stack[0]\n\n\nprint(evalRPN([\"2\", \"1\", \"+\", \"3\", \"*\"]))  # 9\nprint(evalRPN([\"4\", \"13\", \"5\", \"/\", \"-\"]))  # 2\nprint(evalRPN([\"18\"]))  # 18\nprint(evalRPN([\"4\", \"3\", \"-\"]))  # 1\n</code></pre>"},{"location":"grind75/stack/#155-min-stack","title":"155. Min Stack","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: stack, design</p> </li> <li>Implement a stack that supports push, pop, top, and retrieving the minimum element in constant time.</li> </ul> 155. Min Stack - Python Solution<pre><code># Stack\nclass MinStack:\n\n    def __init__(self):\n        self.stack = []\n        self.minStack = []\n\n    def push(self, val: int) -&gt; None:\n        self.stack.append(val)\n        val = min(val, self.minStack[-1] if self.minStack else val)\n        self.minStack.append(val)\n\n    def pop(self) -&gt; None:\n        if self.stack:\n            self.stack.pop()\n        if self.minStack:\n            self.minStack.pop()\n\n    def top(self) -&gt; int:\n        return self.stack[-1] if self.stack else None\n\n    def getMin(self) -&gt; int:\n        return self.minStack[-1] if self.minStack else None\n\n\n# Your MinStack object will be instantiated and called as such:\nobj = MinStack()\nobj.push(3)\nobj.push(2)\nobj.pop()\nprint(obj.top())  # 3\nprint(obj.getMin())  # 3\n</code></pre>"},{"location":"grind75/stack/#42-trapping-rain-water","title":"42. Trapping Rain Water","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, dynamic programming, stack, monotonic stack</p> </li> <li></li> </ul> Approach Time Space DP O(N) O(N) Left Right O(N) O(1) Monotonic O(N) O(N) 42. Trapping Rain Water - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef trapDP(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    n = len(height)\n    maxLeft, maxRight = [0 for _ in range(n)], [0 for _ in range(n)]\n\n    for i in range(1, n):\n        maxLeft[i] = max(maxLeft[i - 1], height[i - 1])\n\n    for i in range(n - 2, -1, -1):\n        maxRight[i] = max(maxRight[i + 1], height[i + 1])\n\n    res = 0\n    for i in range(n):\n        res += max(0, min(maxLeft[i], maxRight[i]) - height[i])\n\n    return res\n\n\n# Left Right Pointers\ndef trapLR(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    left, right = 0, len(height) - 1\n    maxL, maxR = height[left], height[right]\n    res = 0\n\n    while left &lt; right:\n        if maxL &lt; maxR:\n            left += 1\n            maxL = max(maxL, height[left])\n            res += maxL - height[left]\n        else:\n            right -= 1\n            maxR = max(maxR, height[right])\n            res += maxR - height[right]\n\n    return res\n\n\n# Monotonic Stack\ndef trapStack(height: List[int]) -&gt; int:\n    stack = []\n    total = 0\n\n    for i in range(len(height)):\n        while stack and height[i] &gt; height[stack[-1]]:\n            top = stack.pop()\n            if not stack:\n                break\n            distance = i - stack[-1] - 1\n            bounded_height = min(height[i], height[stack[-1]]) - height[top]\n            total += distance * bounded_height\n        stack.append(i)\n\n    return total\n\n\nheight = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\nprint(trapDP(height))  # 6\nprint(trapLR(height))  # 6\nprint(trapStack(height))  # 6\n</code></pre>"},{"location":"grind75/stack/#224-basic-calculator","title":"224. Basic Calculator","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, string, stack, recursion</p> </li> </ul> 224. Basic Calculator - Python Solution<pre><code># Stack\ndef calculate(s: str) -&gt; int:\n    stack = []\n    result = 0\n    number = 0\n    sign = 1\n\n    for char in s:\n        if char.isdigit():\n            number = number * 10 + int(char)\n\n        elif char == \"+\":\n            result += sign * number\n            number = 0\n            sign = 1\n        elif char == \"-\":\n            result += sign * number\n            number = 0\n            sign = -1\n\n        elif char == \"(\":\n            stack.append(result)\n            stack.append(sign)\n            result = 0\n            sign = 1\n        elif char == \")\":\n            result += sign * number\n            number = 0\n            result *= stack.pop()  # pop sign\n            result += stack.pop()  # pop previous result\n\n    result += sign * number\n\n    return result\n\n\nprint(calculate(\"(1+(4+5+2)-3)+(6+8)\"))  # 23\n</code></pre>"},{"location":"grind75/stack/#84-largest-rectangle-in-histogram","title":"84. Largest Rectangle in Histogram","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, stack, monotonic stack</p> </li> </ul> 84. Largest Rectangle in Histogram - Python Solution<pre><code>from typing import List\n\n\ndef largestRectangleArea(heights: List[int]) -&gt; int:\n    maxArea = 0\n    stack = []  # pair: (index, height)\n\n    for i, h in enumerate(heights):\n        start = i\n        while stack and stack[-1][1] &gt; h:\n            index, height = stack.pop()\n            maxArea = max(maxArea, height * (i - index))\n            start = index\n        stack.append((start, h))\n\n    for i, h in stack:\n        maxArea = max(maxArea, h * (len(heights) - i))\n\n    return maxArea\n\n\nprint(largestRectangleArea([2, 1, 5, 6, 2, 3]))  # 10\n</code></pre>"},{"location":"grind75/string/","title":"String","text":"<ul> <li> 125. Valid Palindrome (Easy)</li> <li> 242. Valid Anagram (Easy)</li> <li> 409. Longest Palindrome (Easy)</li> <li> 3. Longest Substring Without Repeating Characters (Medium)</li> <li> 8. String to Integer (atoi) (Medium)</li> <li> 5. Longest Palindromic Substring (Medium)</li> <li> 438. Find All Anagrams in a String (Medium)</li> <li> 76. Minimum Window Substring (Hard)</li> </ul>"},{"location":"grind75/string/#125-valid-palindrome","title":"125. Valid Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string</p> </li> </ul> 125. Valid Palindrome - Python Solution<pre><code># List Comprehension\ndef isPalindrome(s: str) -&gt; bool:\n    s = [char.lower() for char in s if char.isalnum()]\n    return s == s[::-1]\n\n\n# Left Right Pointers\ndef isPalindromeLR(s: str) -&gt; bool:\n    left, right = 0, len(s) - 1\n\n    while left &lt; right:\n        while left &lt; right and not s[left].isalnum():\n            left += 1\n        while left &lt; right and not s[right].isalnum():\n            right -= 1\n\n        if s[left].lower() != s[right].lower():\n            return False\n\n        left += 1\n        right -= 1\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\ns = \"A man, a plan, a canal: Panama\"\nprint(isPalindrome(s))  # True\nprint(isPalindromeLR(s))  # True\n</code></pre>"},{"location":"grind75/string/#242-valid-anagram","title":"242. Valid Anagram","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, string, sorting</p> </li> <li>Return true if an input string is an anagram of another string.</li> <li>An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once, e.g., <code>listen</code> is an anagram of <code>silent</code>.</li> </ul> 242. Valid Anagram - Python Solution<pre><code>from collections import Counter\n\n\n# Hashmap\ndef isAnagramHash(s: str, t: str) -&gt; bool:\n    \"\"\"Return True if t is an anagram of s, False otherwise.\"\"\"\n    if len(s) != len(t):\n        return False\n\n    count = dict()\n\n    for i in s:\n        if i in count:\n            count[i] += 1\n        else:\n            count[i] = 1\n\n    for j in t:\n        if j in count:\n            count[j] -= 1\n        else:\n            return False\n\n    for count in count.values():\n        if count != 0:\n            return False\n\n    return True\n\n\n# Array\ndef isAnagramArray(s: str, t: str) -&gt; bool:\n    if len(s) != len(t):\n        return False\n\n    count = [0 for _ in range(26)]\n\n    for i in s:\n        count[ord(i) - ord(\"a\")] += 1\n\n    for j in t:\n        count[ord(j) - ord(\"a\")] -= 1\n\n    for i in count:\n        if i != 0:\n            return False\n\n    return True\n\n\n# Counter\ndef isAnagramCounter(s: str, t: str) -&gt; bool:\n    return Counter(s) == Counter(t)\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |   Hashmap   |       O(n)      |     O(1)     |\n# |    Array    |       O(n)      |     O(1)     |\n# |   Counter   |       O(n)      |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\ns = \"anagram\"\nt = \"nagaram\"\nprint(isAnagramHash(s, t))  # True\nprint(isAnagramArray(s, t))  # True\nprint(isAnagramCounter(s, t))  # True\n</code></pre>"},{"location":"grind75/string/#409-longest-palindrome","title":"409. Longest Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, string, greedy</p> </li> <li>Return the length of the longest palindrome that can be built with the characters in the string.</li> </ul> 409. Longest Palindrome - Python Solution<pre><code>def longestPalindrome(s: str) -&gt; int:\n    hashmap = dict()\n    result = 0\n\n    for char in s:\n        if char not in hashmap or hashmap[char] == 0:\n            hashmap[char] = 1\n        else:\n            result += 2\n            hashmap[char] = 0\n\n    if any(hashmap.values()):\n        result += 1\n\n    return result\n\n\nprint(longestPalindrome(\"abccccdd\"))  # 7\n</code></pre>"},{"location":"grind75/string/#3-longest-substring-without-repeating-characters","title":"3. Longest Substring Without Repeating Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> <li>Classic sliding window problem. Use a set to keep track of the characters in the current window.</li> <li>Return the length of the longest substring without repeating characters.</li> </ul> 3. Longest Substring Without Repeating Characters - Python Solution<pre><code># Sliding Window Variable Size\ndef lengthOfLongestSubstring(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    window = set()\n    left = 0\n    res = 0\n\n    for right in range(n):\n        while s[right] in window:\n            window.remove(s[left])\n            left += 1\n        window.add(s[right])\n        res = max(res, right - left + 1)\n\n    return res\n\n\ns = \"abcabcbb\"\nassert lengthOfLongestSubstring(s) == 3\n</code></pre>"},{"location":"grind75/string/#8-string-to-integer-atoi","title":"8. String to Integer (atoi)","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string</p> </li> </ul>"},{"location":"grind75/string/#5-longest-palindromic-substring","title":"5. Longest Palindromic Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string, dynamic programming</p> </li> <li>Return the longest palindromic substring in <code>s</code>.</li> </ul> 5. Longest Palindromic Substring - Python Solution<pre><code># DP - Interval\ndef longestPalindromeDP(s: str) -&gt; str:\n    n = len(s)\n    if n &lt;= 1:\n        return s\n\n    start, maxLen = 0, 1\n\n    # Init\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for j in range(1, n):\n        for i in range(j):\n            if s[i] == s[j]:\n                if j - i &lt;= 2:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1]\n\n                if dp[i][j] and j - i + 1 &gt; maxLen:\n                    maxLen = j - i + 1\n                    start = i\n\n    return s[start : start + maxLen]\n\n\n# Expand Around Center\ndef longestPalindromeCenter(s: str) -&gt; str:\n    def expand_around_center(left, right):\n        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n\n    if len(s) &lt;= 1:\n        return s\n\n    start, end = 0, 0\n    for i in range(len(s)):\n        len1 = expand_around_center(i, i)  # odd\n        len2 = expand_around_center(i, i + 1)  # even\n\n        maxLen = max(len1, len2)\n        if maxLen &gt; end - start:\n            start = i - (maxLen - 1) // 2\n            end = i + maxLen // 2\n\n    return s[start : end + 1]\n\n\ns = \"babad\"\nprint(longestPalindromeDP(s))  # \"bab\"\nprint(longestPalindromeCenter(s))  # \"aba\"\n</code></pre>"},{"location":"grind75/string/#438-find-all-anagrams-in-a-string","title":"438. Find All Anagrams in a String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> </ul> 438. Find All Anagrams in a String - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window - Variable\ndef findAnagrams(s: str, p: str) -&gt; List[int]:\n    result = []\n    if len(s) &lt; len(p):\n        return result\n\n    countP = [0] * 26\n    for i in p:\n        countP[ord(i) - ord(\"a\")] += 1\n\n    countS = [0] * 26\n    for i in range(len(p)):\n        countS[ord(s[i]) - ord(\"a\")] += 1\n\n    if countS == countP:\n        result.append(0)\n\n    # sliding window\n    for i in range(len(p), len(s)):\n        countS[ord(s[i]) - ord(\"a\")] += 1  # add new character\n        countS[ord(s[i - len(p)]) - ord(\"a\")] -= 1  # remove old character\n        if countS == countP:\n            result.append(i - len(p) + 1)  # append the starting index\n\n    return result\n\n\ns = \"cbaebabacd\"\np = \"abc\"\nprint(findAnagrams(s, p))  # [0, 6]\n</code></pre>"},{"location":"grind75/string/#76-minimum-window-substring","title":"76. Minimum Window Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> </ul> 76. Minimum Window Substring - Python Solution<pre><code>from collections import Counter\n\n\ndef minWindow(s: str, t: str) -&gt; str:\n    if not t or not s:\n        return \"\"\n\n    counts = Counter(t)\n    required = len(counts)\n\n    left, right = 0, 0\n    formed = 0\n    window_counts = dict()\n\n    result = float(\"inf\"), None, None\n\n    while right &lt; len(s):\n        char = s[right]\n        window_counts[char] = window_counts.get(char, 0) + 1\n        if char in counts and window_counts[char] == counts[char]:\n            formed += 1\n\n        while left &lt;= right and formed == required:\n            char = s[left]\n            if right - left + 1 &lt; result[0]:\n                result = (right - left + 1, left, right)\n            window_counts[char] -= 1\n            if char in counts and window_counts[char] &lt; counts[char]:\n                formed -= 1\n            left += 1\n\n        right += 1\n\n    return \"\" if result[0] == float(\"inf\") else s[result[1] : result[2] + 1]\n\n\ns = \"ADOBECODEBANC\"\nt = \"ABC\"\nprint(minWindow(s, t))  # BANC\n</code></pre>"},{"location":"grind75/trie/","title":"Trie","text":"<ul> <li> 208. Implement Trie (Prefix Tree) (Medium)</li> <li> 139. Word Break (Medium)</li> </ul>"},{"location":"grind75/trie/#208-implement-trie-prefix-tree","title":"208. Implement Trie (Prefix Tree)","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, design, trie</p> </li> </ul>"},{"location":"grind75/trie/#trie_1","title":"Trie","text":"<ul> <li>A trie is a tree-like data structure whose nodes store the letters of an alphabet.</li> </ul> <pre><code>flowchart TD\nRoot(( ))\nRoot --- C1((\"C\"))\nRoot --- D((D))\nC1 --- A1((\"A\"))\nA1 --- T1((\"T\"))\nA1 --- R1((\"R\"))\nA1 --- N((N))\nRoot --- B1((B))\nB1 --- A2((A))\nA2 --- T2((T))\nA2 --- R2((R))</code></pre> 208. Implement Trie (Prefix Tree) - Python Solution<pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.endOfWord = None\n\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.endOfWord = True\n\n    def search(self, word: str) -&gt; bool:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return node.endOfWord\n\n    def startsWith(self, prefix: str) -&gt; bool:\n        node = self.root\n\n        for c in prefix:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return True\n\n\n# Your Trie object will be instantiated and called as such:\nobj = Trie()\nobj.insert(\"apple\")\nprint(obj.search(\"word\"))  # False\nprint(obj.startsWith(\"app\"))  # True\n</code></pre>"},{"location":"grind75/trie/#139-word-break","title":"139. Word Break","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, dynamic programming, trie, memoization</p> </li> </ul> 139. Word Break - Python Solution<pre><code>from typing import List\n\n\n# DP - Knapsack Unbounded\ndef wordBreak(s: str, wordDict: List[str]) -&gt; bool:\n    n = len(s)\n    wordSet = set(wordDict)\n    dp = [False for _ in range(n + 1)]\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in wordSet:\n                dp[i] = True\n                break\n\n    return dp[n]\n\n\ns = \"leetcode\"\nwordDict = [\"leet\", \"code\"]\nprint(wordBreak(s, wordDict))  # True\n</code></pre>"},{"location":"leetpattern/","title":"LeetPattern","text":""},{"location":"leetpattern/#resources","title":"Resources","text":"<ul> <li>\u6ed1\u52a8\u7a97\u53e3\u9898\u5355</li> </ul>"},{"location":"leetpattern/#sheet","title":"Sheet","text":"<ul> <li>In order to visualize and practice the algorithm, I use google sheets to make drafts. You also can have access to it here.</li> </ul>"},{"location":"leetpattern/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python Basics: Python Distilled</li> </ul>"},{"location":"leetpattern/#resources_1","title":"Resources","text":"<ul> <li>\u7b97\u6cd5\u7ade\u8d5b\u6a21\u677f\u5e93 by \u7075\u8336\u5c71\u827e\u5e9c</li> <li>[Leetcode Discuss] Solved all two pointers problems in 100 days</li> <li>[Leetcode Discuss] Solved all dynamic programming (dp) problems in 7 months</li> <li>liquidslr/leetcode-company-wise-problems</li> </ul>"},{"location":"leetpattern/#principles","title":"Principles","text":""},{"location":"leetpattern/#dynamic-programming","title":"Dynamic Programming","text":"<p>Steps to Solve DP Problems</p> <ol> <li>Define the <code>dp</code> array and its meaning.</li> <li>Define the <code>dp</code> formula.</li> <li>Initialize the <code>dp</code> array.</li> <li>Determine the traversal direction.</li> <li>Derive the <code>dp</code> array.</li> </ol>"},{"location":"leetpattern/array/","title":"Array","text":"<ul> <li> 414. Third Maximum Number (Easy)</li> <li> 169. Majority Element (Easy)</li> <li> 2022. Convert 1D Array Into 2D Array (Easy)</li> <li> 54. Spiral Matrix (Medium)</li> <li> 59. Spiral Matrix II (Medium)</li> </ul>"},{"location":"leetpattern/array/#414-third-maximum-number","title":"414. Third Maximum Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, sorting</p> </li> <li>Return the third maximum number in an array. If the third maximum does not exist, return the maximum number.</li> </ul> 414. Third Maximum Number - Python Solution<pre><code>from typing import List\n\n\n# Sort\ndef thirdMaxSort(nums: List[int]) -&gt; int:\n    nums = list(set(nums))\n    nums.sort(reverse=True)\n\n    return nums[2] if len(nums) &gt;= 3 else nums[0]\n\n\n# Compare\ndef thirdMaxCompare(nums: List[int]) -&gt; int:\n    first, second, third = float(\"-inf\"), float(\"-inf\"), float(\"-inf\")\n\n    for num in nums:\n        if num &gt; first:\n            first, second, third = num, first, second\n        elif first &gt; num &gt; second:\n            second, third = num, second\n        elif second &gt; num &gt; third:\n            third = num\n\n    return third if third != float(\"-inf\") else first\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Sort     |    O(NlogN)     |     O(N)     |\n# |  Compare    |       O(N)      |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\nprint(thirdMaxSort([3, 2, 1]))  # 1\nprint(thirdMaxCompare([3, 2, 1]))  # 1\n</code></pre>"},{"location":"leetpattern/array/#169-majority-element","title":"169. Majority Element","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, divide and conquer, sorting, counting</p> </li> <li>Return the majority element in an array. The majority element is the element that appears more than <code>n // 2</code> times.</li> </ul> <code>num</code> <code>count</code> <code>res</code> 2 1 2 2 2 2 1 1 2 1 0 2 1 1 1 2 0 1 2 1 2 169. Majority Element - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash Map\ndef majorityElementHashMap(nums: List[int]) -&gt; int:\n    n = len(nums)\n    freq = defaultdict(int)\n\n    for num in nums:\n        freq[num] += 1\n        if freq[num] &gt; n // 2:\n            return num\n\n\n# Array - Boyer-Moore Voting Algorithm\ndef majorityElementArray(nums: List[int]) -&gt; int:\n    res = None\n    count = 0\n\n    for num in nums:\n        if count == 0:\n            res = num\n        count += 1 if num == res else -1\n\n    return res\n\n\n# | Algorithm | Time Complexity | Space Complexity |\n# |-----------|-----------------|------------------|\n# | HashMap   | O(N)            | O(N)             |\n# | Array     | O(N)            | O(1)             |\n# |-----------|-----------------|------------------|\n\n\nnums = [2, 2, 1, 1, 1, 2, 2]\nprint(majorityElementArray(nums))  # 2\nprint(majorityElementHashMap(nums))  # 2\n</code></pre>"},{"location":"leetpattern/array/#2022-convert-1d-array-into-2d-array","title":"2022. Convert 1D Array Into 2D Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, matrix, simulation</p> </li> </ul> 2022. Convert 1D Array Into 2D Array - Python Solution<pre><code>from typing import List\n\n\n# Brute Force\ndef construct2DArray(original: List[int], m: int, n: int) -&gt; List[List[int]]:\n    if len(original) != m * n:\n        return []\n    array = []\n\n    for i in range(m):\n        row = original[n * i : n * (i + 1)]\n        array.append(row)\n\n    return array\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |  Brute     |  O(m)  |  O(1)   |\n# |------------|--------|---------|\n\n\noriginal = [1, 2, 3, 4]\nm = 2\nn = 2\n\nprint(construct2DArray(original, m, n))  # [[1, 2], [3, 4]]\n</code></pre>"},{"location":"leetpattern/array/#54-spiral-matrix","title":"54. Spiral Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, matrix, simulation</p> </li> <li>Return all elements of the matrix in spiral order.</li> </ul> 54. Spiral Matrix - Python Solution<pre><code>from typing import List\n\n\n# Array\ndef spiralOrder(matrix: List[List[int]]) -&gt; List[int]:\n    if not matrix or not matrix[0]:\n        return []\n\n    result = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n\n    while top &lt;= bottom and left &lt;= right:\n\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n\n        if top &lt;= bottom:\n\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left &lt;= right:\n\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n\n    return result\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Naive    |      O(N)       |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\nprint(spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n# [1, 2, 3, 6, 9, 8, 7, 4, 5]\n</code></pre>"},{"location":"leetpattern/array/#59-spiral-matrix-ii","title":"59. Spiral Matrix II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, matrix, simulation</p> </li> <li>Return a square matrix filled with elements from 1 to n^2 in spiral order.</li> </ul> 59. Spiral Matrix II - Python Solution<pre><code>from pprint import pprint\nfrom typing import List\n\n\n# Array\ndef generateMatrix(n: int) -&gt; List[List[int]]:\n    matrix = [[0] * n for _ in range(n)]\n    num = 1\n\n    for layer in range((n + 1) // 2):\n        for i in range(layer, n - layer):\n            matrix[layer][i] = num\n            num += 1\n        for j in range(layer + 1, n - layer):\n            matrix[j][n - 1 - layer] = num\n            num += 1\n        for i in range(n - 2 - layer, layer - 1, -1):\n            matrix[n - 1 - layer][i] = num\n            num += 1\n        for j in range(n - 2 - layer, layer, -1):\n            matrix[j][layer] = num\n            num += 1\n\n    return matrix\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |   Layer     |      O(N^2)     |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\npprint(generateMatrix(5))\n# [[ 1,  2,  3,  4, 5],\n#  [16, 17, 18, 19, 6],\n#  [15, 24, 25, 20, 7],\n#  [14, 23, 22, 21, 8],\n#  [13, 12, 11, 10, 9]]\n</code></pre>"},{"location":"leetpattern/backtracking/","title":"Backtracking","text":"<ul> <li> 77. Combinations (Medium)</li> <li> 17. Letter Combinations of a Phone Number (Medium)</li> <li> 39. Combination Sum (Medium)</li> <li> 40. Combination Sum II (Medium)</li> <li> 216. Combination Sum III (Medium)</li> <li> 131. Palindrome Partitioning (Medium)</li> <li> 93. Restore IP Addresses (Medium)</li> <li> 78. Subsets (Medium)</li> <li> 90. Subsets II (Medium)</li> <li> 491. Non-decreasing Subsequences (Medium)</li> <li> 46. Permutations (Medium)</li> <li> 47. Permutations II (Medium)</li> <li> 51. N-Queens (Hard)</li> <li> 37. Sudoku Solver (Hard)</li> <li> 79. Word Search (Medium)</li> <li> 212. Word Search II (Hard)</li> </ul>"},{"location":"leetpattern/backtracking/#77-combinations","title":"77. Combinations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: backtracking</p> </li> </ul> 77. Combinations - Python Solution<pre><code>import itertools\nfrom typing import List\n\n\n# Backtracking\ndef combine(n: int, k: int) -&gt; List[List[int]]:\n    res = []\n\n    def backtrack(start, path):\n        if len(path) == k:\n            res.append(path[:])\n            return None\n\n        for i in range(start, n + 1):\n            path.append(i)\n            backtrack(i + 1, path)\n            path.pop()\n\n    backtrack(1, [])\n\n    return res\n\n\n# itertools\ndef combineItertools(n: int, k: int) -&gt; List[List[int]]:\n    path = itertools.combinations(range(1, n + 1), k)\n    return path\n\n\nprint(combine(4, 2))\n# [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\nprint(list(combineItertools(4, 2)))\n# [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]\n</code></pre>"},{"location":"leetpattern/backtracking/#17-letter-combinations-of-a-phone-number","title":"17. Letter Combinations of a Phone Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, backtracking</p> </li> </ul> 17. Letter Combinations of a Phone Number - Python Solution<pre><code>from typing import List\n\n\ndef letterCombinations(digits: str) -&gt; List[str]:\n    letterMap = [\n        \"\",  # 0\n        \"\",  # 1\n        \"abc\",  # 2\n        \"def\",  # 3\n        \"ghi\",  # 4\n        \"jkl\",  # 5\n        \"mno\",  # 6\n        \"pqrs\",  # 7\n        \"tuv\",  # 8\n        \"wxyz\",  # 9\n    ]\n    res = []\n\n    def backtracking(index, s):\n        if index == len(digits):\n            res.append(s)\n            return None\n\n        digit = int(digits[index])\n        letters = letterMap[digit]\n\n        for i in range(len(letters)):\n            backtracking(index + 1, s + letters[i])\n\n    if len(digits) == 0:\n        return res\n\n    backtracking(0, \"\")\n\n    return res\n\n\nprint(letterCombinations(\"23\"))\n# ['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf']\n</code></pre>"},{"location":"leetpattern/backtracking/#39-combination-sum","title":"39. Combination Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking</p> </li> </ul> 39. Combination Sum - Python Solution<pre><code>from typing import List\n\n\ndef combinationSum(candidates: List[int], target: int) -&gt; List[List[int]]:\n    result = []\n    path = []\n\n    def backtracking(total, start):\n        if total &gt; target:\n            return None\n        if total == target:\n            result.append(path[:])\n            return None\n\n        for i in range(start, len(candidates)):\n            total += candidates[i]\n            path.append(candidates[i])\n\n            backtracking(total, i)\n\n            total -= candidates[i]\n            path.pop()\n\n    backtracking(0, 0)\n    return result\n\n\nprint(combinationSum([2, 3, 6, 7], 7))  # [[2, 2, 3], [7]]\n</code></pre>"},{"location":"leetpattern/backtracking/#40-combination-sum-ii","title":"40. Combination Sum II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking</p> </li> </ul> 40. Combination Sum II - Python Solution<pre><code>from typing import List\n\n\ndef combinationSum2(candidates: List[int], target: int) -&gt; List[List[int]]:\n    result, path = [], []\n    candidates.sort()\n\n    def backtracking(total, start):\n        if total == target:\n            result.append(path[:])\n            return None\n\n        for i in range(start, len(candidates)):\n\n            if i &gt; start and candidates[i] == candidates[i - 1]:\n                continue\n\n            if total + candidates[i] &gt; target:\n                break\n\n            total += candidates[i]\n            path.append(candidates[i])\n            backtracking(total, i + 1)\n            total -= candidates[i]\n            path.pop()\n\n    backtracking(0, 0)\n\n    return result\n\n\nprint(combinationSum2([10, 1, 2, 7, 6, 1, 5], 8))\n# [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n</code></pre>"},{"location":"leetpattern/backtracking/#216-combination-sum-iii","title":"216. Combination Sum III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking</p> </li> </ul> 216. Combination Sum III - Python Solution<pre><code>import itertools\nfrom typing import List\n\n\n# 1. Backtracking\ndef combinationSum3(k: int, n: int) -&gt; List[List[int]]:\n    path, result = [], []\n\n    def backtracking(start):\n        if len(path) == k and sum(path) == n:\n            result.append(path[:])\n            return\n\n        for i in range(start, 10):\n            path.append(i)\n            backtracking(i + 1)\n            path.pop()\n\n    backtracking(1)\n\n    return result\n\n\n# 2. Itertools\ndef combinationSum3Itertools(k: int, n: int) -&gt; List[List[int]]:\n    combinations = itertools.combinations(range(1, 10), k)\n    result = []\n\n    for i in combinations:\n        if sum(i) == n:\n            result.append(i)\n\n    return result\n\n\nprint(combinationSum3(3, 7))  # [[1, 2, 4]]\nprint(combinationSum3Itertools(3, 7))  # [(1, 2, 4)]\n</code></pre>"},{"location":"leetpattern/backtracking/#131-palindrome-partitioning","title":"131. Palindrome Partitioning","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming, backtracking</p> </li> </ul> 131. Palindrome Partitioning - Python Solution<pre><code>from typing import List\n\n\n# Backtracking\ndef partition(s: str) -&gt; List[List[str]]:\n    res = []\n    n = len(s)\n\n    def backtrack(idx, path):\n        if idx == n:\n            res.append(path[:])\n            return None\n\n        for j in range(idx, n):\n            cur = s[idx : j + 1]\n            if cur == cur[::-1]:\n                path.append(cur)\n                backtrack(j + 1, path)\n                path.pop()\n\n    backtrack(0, [])\n\n    return res\n\n\nprint(partition(\"aab\"))  # [['a', 'a', 'b'], ['aa', 'b']]\n</code></pre>"},{"location":"leetpattern/backtracking/#93-restore-ip-addresses","title":"93. Restore IP Addresses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, backtracking</p> </li> </ul> 93. Restore IP Addresses - Python Solution<pre><code>from typing import List\n\n\ndef restoreIpAddresses(s: str) -&gt; List[str]:\n    result = []\n\n    def backtracking(start_index, point_num, current, result):\n        # stop condition\n        if point_num == 3:\n            if is_valid(s, start_index, len(s) - 1):\n                current += s[start_index:]\n                result.append(current)\n            return\n\n        for i in range(start_index, len(s)):\n            if is_valid(s, start_index, i):\n                sub = s[start_index : i + 1]\n                backtracking(i + 1, point_num + 1, current + sub + \".\", result)\n            else:\n                break\n\n    def is_valid(s, start, end):\n        if start &gt; end:\n            return False\n\n        if s[start] == \"0\" and start != end:\n            return False\n\n        num = 0\n        for i in range(start, end + 1):\n            if not s[i].isdigit():\n                return False\n            num = num * 10 + int(s[i])\n            if num &gt; 255:\n                return False\n        return True\n\n    backtracking(0, 0, \"\", result)\n\n    return result\n\n\nprint(restoreIpAddresses(\"25525511135\"))\n# ['255.255.11.135', '255.255.111.35']\n</code></pre>"},{"location":"leetpattern/backtracking/#78-subsets","title":"78. Subsets","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking, bit manipulation</p> </li> </ul> 78. Subsets - Python Solution<pre><code>from typing import List\n\n\ndef subsets(nums: List[int]) -&gt; List[List[int]]:\n    path, result = [], []\n\n    def backtracking(startIndex):\n        result.append(path[:])\n\n        for i in range(startIndex, len(nums)):\n            path.append(nums[i])\n            backtracking(i + 1)\n            path.pop()\n\n    backtracking(startIndex=0)\n\n    return result\n\n\nprint(subsets([1, 2, 3]))\n# [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]\n</code></pre>"},{"location":"leetpattern/backtracking/#90-subsets-ii","title":"90. Subsets II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking, bit manipulation</p> </li> </ul> 90. Subsets II - Python Solution<pre><code>from typing import List\n\n\ndef subsetsWithDup(nums: List[int]) -&gt; List[List[int]]:\n    path, result = [], []\n    nums.sort()\n\n    def backtracking(startIndex):\n        if path not in result:\n            result.append(path[:])\n\n        for i in range(startIndex, len(nums)):\n            path.append(nums[i])\n            backtracking(i + 1)\n            path.pop()\n\n    backtracking(startIndex=0)\n\n    return result\n\n\nprint(subsetsWithDup([1, 2, 2]))\n# [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]\n</code></pre>"},{"location":"leetpattern/backtracking/#491-non-decreasing-subsequences","title":"491. Non-decreasing Subsequences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, backtracking, bit manipulation</p> </li> </ul> 491. Non-decreasing Subsequences - Python Solution<pre><code>from typing import List\n\n\ndef findSubsequences(nums: List[int]) -&gt; List[List[int]]:\n    path, result = [], []\n\n    def backtracking(startIndex):\n        if len(path) &gt; 1:\n            result.append(path[:])\n\n        used = set()\n        for i in range(startIndex, len(nums)):\n\n            if (path and nums[i] &lt; path[-1]) or nums[i] in used:\n                continue\n\n            used.add(nums[i])\n            path.append(nums[i])\n            backtracking(i + 1)\n            path.pop()\n\n    backtracking(0)\n\n    return result\n\n\nprint(findSubsequences([4, 6, 7, 7]))\n# [[4, 6], [4, 6, 7], [4, 6, 7, 7], [4, 7], [4, 7, 7], [6, 7], [6, 7, 7], [7, 7]]\n</code></pre>"},{"location":"leetpattern/backtracking/#46-permutations","title":"46. Permutations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking</p> </li> </ul> 46. Permutations - Python Solution<pre><code>from typing import List\n\n\ndef permute(nums: List[int]) -&gt; List[List[int]]:\n    path, result = [], []\n    used = [False for _ in range(len(nums))]\n\n    def backtracking():\n        if len(path) == len(nums):\n            result.append(path[:])\n\n        for i in range(len(nums)):\n            if used[i]:\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtracking()\n            path.pop()\n            used[i] = False\n\n    backtracking()\n\n    return result\n\n\nprint(permute([1, 2, 3]))\n# [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n</code></pre>"},{"location":"leetpattern/backtracking/#47-permutations-ii","title":"47. Permutations II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking, sorting</p> </li> </ul> 47. Permutations II - Python Solution<pre><code>from typing import List\n\n\ndef permuteUnique(nums: List[int]) -&gt; List[List[int]]:\n    nums.sort()\n    path, result = [], []\n    used = [False for _ in range(len(nums))]\n\n    def backtracking():\n        if len(path) == len(nums):\n            result.append(path[:])\n\n        for i in range(len(nums)):\n            if used[i]:\n                continue\n            if i &gt; 0 and nums[i] == nums[i - 1] and not used[i - 1]:\n                continue\n\n            used[i] = True\n            path.append(nums[i])\n            backtracking()\n            path.pop()\n            used[i] = False\n\n    backtracking()\n\n    return result\n\n\nprint(permuteUnique([1, 1, 2]))\n# [[1, 1, 2], [1, 2, 1], [2, 1, 1]]\n</code></pre>"},{"location":"leetpattern/backtracking/#51-n-queens","title":"51. N-Queens","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, backtracking</p> </li> <li>Hard</li> <li>N-Queens</li> <li>N \u7687\u540e</li> </ul> 51. N-Queens - Python Solution<pre><code>from typing import List\n\n\n# Backtracking - Board\ndef solveNQueens(n: int) -&gt; List[List[str]]:\n    result = []\n    chessboard = [\".\" * n for _ in range(n)]\n\n    def backtracking(row):\n        if row == n:\n            result.append(chessboard[:])\n            return None\n        for col in range(n):\n            if is_valid(row, col, chessboard):\n                chessboard[row] = (\n                    chessboard[row][:col] + \"Q\" + chessboard[row][col + 1 :]\n                )\n                backtracking(row + 1)\n                chessboard[row] = (\n                    chessboard[row][:col] + \".\" + chessboard[row][col + 1 :]\n                )\n\n    def is_valid(row, col, chessboard):\n        for i in range(row):\n            if chessboard[i][col] == \"Q\":\n                return False\n\n        i, j = row - 1, col - 1\n        while i &gt;= 0 and j &gt;= 0:\n            if chessboard[i][j] == \"Q\":\n                return False\n            i -= 1\n            j -= 1\n\n        i, j = row - 1, col + 1\n        while i &gt;= 0 and j &lt; len(chessboard):\n            if chessboard[i][j] == \"Q\":\n                return False\n            i -= 1\n            j += 1\n\n        return True\n\n    backtracking(0)\n\n    return [[\"\".join(row) for row in solution] for solution in result]\n\n\nprint(solveNQueens(4))\n# [['.Q..', '...Q', 'Q...', '..Q.'],\n#  ['..Q.', 'Q...', '...Q', '.Q..']]\n</code></pre>"},{"location":"leetpattern/backtracking/#37-sudoku-solver","title":"37. Sudoku Solver","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, backtracking, matrix</p> </li> <li>Sudoku Solver</li> <li>\u89e3\u6570\u72ec</li> <li>Hard</li> </ul> 37. Sudoku Solver - Python Solution<pre><code>from pprint import pprint\nfrom typing import List\n\n\n# Backtracking - Board\ndef solveSudoku(board: List[List[str]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n\n    def backtracking(board: List[List[str]]) -&gt; bool:\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] != \".\":\n                    continue\n                for k in range(1, 10):\n                    if is_valid(i, j, k, board):\n                        board[i][j] = str(k)\n                        if backtracking(board):\n                            return True\n                        board[i][j] = \".\"\n                return False\n        return True\n\n    def is_valid(row: int, col: int, val: int, board: List[List[str]]) -&gt; bool:\n        for i in range(9):\n            if board[row][i] == str(val):\n                return False\n        for j in range(9):\n            if board[j][col] == str(val):\n                return False\n        start_row = (row // 3) * 3\n        start_col = (col // 3) * 3\n        for i in range(start_row, start_row + 3):\n            for j in range(start_col, start_col + 3):\n                if board[i][j] == str(val):\n                    return False\n        return True\n\n    backtracking(board)\n\n\nboard = [\n    [\"5\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],\n    [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n    [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n    [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n    [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n    [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n    [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"],\n    [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n    [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"],\n]\n\nsolveSudoku(board)\npprint(board)\n# [['5', '3', '4', '6', '7', '8', '9', '1', '2'],\n#  ['6', '7', '2', '1', '9', '5', '3', '4', '8'],\n#  ['1', '9', '8', '3', '4', '2', '5', '6', '7'],\n#  ['8', '5', '9', '7', '6', '1', '4', '2', '3'],\n#  ['4', '2', '6', '8', '5', '3', '7', '9', '1'],\n#  ['7', '1', '3', '9', '2', '4', '8', '5', '6'],\n#  ['9', '6', '1', '5', '3', '7', '2', '8', '4'],\n#  ['2', '8', '7', '4', '1', '9', '6', '3', '5'],\n#  ['3', '4', '5', '2', '8', '6', '1', '7', '9']]\n</code></pre>"},{"location":"leetpattern/backtracking/#79-word-search","title":"79. Word Search","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, backtracking, depth first search, matrix</p> </li> </ul> 79. Word Search - Python Solution<pre><code>from typing import List\n\n\ndef exist(board: List[List[str]], word: str) -&gt; bool:\n    m, n = len(board), len(board[0])\n    path = set()\n    directions = ((0, 1), (1, 0), (0, -1), (-1, 0))\n\n    def dfs(r, c, i):\n        if i == len(word):\n            return True\n\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or board[r][c] != word[i]\n            or (r, c) in path\n        ):\n            return False\n\n        path.add((r, c))\n\n        for dr, dc in directions:\n            if dfs(r + dr, c + dc, i + 1):\n                return True\n\n        path.remove((r, c))\n        return False\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, 0):\n                return True\n\n    return False\n\n\nboard = [\n    [\"A\", \"B\", \"C\", \"E\"],\n    [\"S\", \"F\", \"C\", \"S\"],\n    [\"A\", \"D\", \"E\", \"E\"],\n]\nword = \"ABCCED\"\nprint(exist(board, word))  # True\n</code></pre>"},{"location":"leetpattern/backtracking/#212-word-search-ii","title":"212. Word Search II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, backtracking, trie, matrix</p> </li> </ul> 212. Word Search II - Python Solution<pre><code>from typing import List\n\nfrom template import TrieNode\n\n\n# Backtracking + Trie\ndef findWords(board: List[List[str]], words: List[str]) -&gt; List[str]:\n    root = TrieNode()\n    for word in words:\n        root.addWord(word)\n\n    m, n = len(board), len(board[0])\n    result, visit = set(), set()\n\n    def dfs(r, c, node, word):\n        if (\n            r &lt; 0\n            or r &gt;= m\n            or c &lt; 0\n            or c &gt;= n\n            or (r, c) in visit\n            or board[r][c] not in node.children\n        ):\n            return None\n\n        visit.add((r, c))\n\n        node = node.children[board[r][c]]\n        word += board[r][c]\n        if node.isWord:\n            result.add(word)\n\n        dfs(r - 1, c, node, word)\n        dfs(r + 1, c, node, word)\n        dfs(r, c - 1, node, word)\n        dfs(r, c + 1, node, word)\n\n        visit.remove((r, c))\n\n    for r in range(m):\n        for c in range(n):\n            dfs(r, c, root, \"\")\n\n    return list(result)\n\n\nboard = [\n    [\"o\", \"a\", \"a\", \"n\"],\n    [\"e\", \"t\", \"a\", \"e\"],\n    [\"i\", \"h\", \"k\", \"r\"],\n    [\"i\", \"f\", \"l\", \"v\"],\n]\nwords = [\"oath\", \"pea\", \"eat\", \"rain\"]\nprint(findWords(board, words))\n# ['eat', 'oath']\n</code></pre>"},{"location":"leetpattern/binary_search/","title":"Binary Search","text":"<ul> <li> 704. Binary Search (Easy)</li> <li> 35. Search Insert Position (Easy)</li> <li> 278. First Bad Version (Easy)</li> <li> 34. Find First and Last Position of Element in Sorted Array (Medium)</li> <li> 367. Valid Perfect Square (Easy)</li> <li> 875. Koko Eating Bananas (Medium)</li> <li> 1011. Capacity To Ship Packages Within D Days (Medium)</li> <li> 378. Kth Smallest Element in a Sorted Matrix (Medium)</li> </ul>"},{"location":"leetpattern/binary_search/#704-binary-search","title":"704. Binary Search","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, binary search</p> </li> <li>Implement binary search algorithm.</li> </ul> 704. Binary Search - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef search(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] &lt; target:\n            left = mid + 1\n        elif nums[mid] &gt; target:\n            right = mid - 1\n        else:\n            return mid\n\n    return -1\n\n\nnums = [-1, 0, 3, 5, 9, 12]\ntarget = 9\nprint(search(nums, target))  # 4\n</code></pre>"},{"location":"leetpattern/binary_search/#35-search-insert-position","title":"35. Search Insert Position","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, binary search</p> </li> <li>Return the index of the target if it is found. If not, return the index where it would be if it were inserted in order.</li> </ul> 35. Search Insert Position - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef searchInsert(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        if nums[mid] &lt; target:\n            left = mid + 1\n        elif nums[mid] &gt; target:\n            right = mid - 1\n        else:\n            return mid\n\n    return left\n\n\nnums = [1, 3, 5, 6]\ntarget = 5\nprint(searchInsert(nums, target))  # 2\n</code></pre>"},{"location":"leetpattern/binary_search/#278-first-bad-version","title":"278. First Bad Version","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: binary search, interactive</p> </li> <li>Find the first bad version given a function <code>isBadVersion</code>.</li> </ul> 278. First Bad Version - Python Solution<pre><code># Binary Search\ndef firstBadVersion(n: int) -&gt; int:\n    left, right = 1, n\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if isBadVersion(mid):\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return left\n\n\ndef isBadVersion(version: int) -&gt; bool:\n    pass\n</code></pre>"},{"location":"leetpattern/binary_search/#34-find-first-and-last-position-of-element-in-sorted-array","title":"34. Find First and Last Position of Element in Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> <li>Find the starting and ending position of a given target value in a sorted array.</li> </ul> 34. Find First and Last Position of Element in Sorted Array - Python Solution<pre><code>from bisect import bisect_left\nfrom typing import List\n\n\n# Binary Search\ndef searchRangeBS(nums: List[int], target: int) -&gt; List[int]:\n    def bisect_left(nums, target):\n        left, right = 0, len(nums) - 1\n        while left &lt;= right:\n            mid = left + (right - left) // 2\n            if nums[mid] &lt; target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n\n    left = bisect_left(nums, target)\n    right = bisect_left(nums, target + 1) - 1\n\n    if left &lt;= right:\n        return [left, right]\n\n    return [-1, -1]\n\n\n# Bisect\ndef searchRangeBSBisect(nums: List[int], target: int) -&gt; List[int]:\n    left = bisect_left(nums, target)\n    right = bisect_left(nums, target + 1) - 1\n\n    if left &lt;= right:\n        return [left, right]\n\n    return [-1, -1]\n\n\nnums = [5, 7, 7, 8, 8, 10]\ntarget = 8\nprint(searchRangeBS(nums, target))  # [3, 4]\nprint(searchRangeBSBisect(nums, target))  # [3, 4]\n</code></pre> 34. Find First and Last Position of Element in Sorted Array - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\n  int bisect_left(vector&lt;int&gt; &amp;nums, int target)\n  {\n    int left = 0, right = (int)nums.size() - 1;\n\n    while (left &lt;= right)\n    {\n      int mid = left + (right - left) / 2;\n      if (nums[mid] &lt; target)\n      {\n        left = mid + 1;\n      }\n      else\n      {\n        right = mid - 1;\n      }\n    }\n    return left;\n  }\n\npublic:\n  vector&lt;int&gt; searchRange(vector&lt;int&gt; &amp;nums, int target)\n  {\n    int left = bisect_left(nums, target);\n    if (left == (int)nums.size() || nums[left] != target)\n    {\n      return {-1, -1};\n    }\n    int right = bisect_left(nums, target + 1) - 1;\n    return {left, right};\n  }\n};\n\nint main()\n{\n  vector&lt;int&gt; nums = {5, 7, 7, 8, 8, 10};\n  int target = 8;\n  Solution s;\n  vector&lt;int&gt; res = s.searchRange(nums, target);\n  cout &lt;&lt; res[0] &lt;&lt; \", \" &lt;&lt; res[1] &lt;&lt; endl;\n  return 0;\n}\n</code></pre>"},{"location":"leetpattern/binary_search/#367-valid-perfect-square","title":"367. Valid Perfect Square","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, binary search</p> </li> <li>Determine if a positive integer is a perfect square without using any built-in library function.</li> </ul> 367. Valid Perfect Square - Python Solution<pre><code># Binary Search\ndef isPerfectSquare(num: int) -&gt; bool:\n    if num &lt; 2:\n        return True\n\n    left, right = 0, num // 2\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if mid * mid == num:\n            return True\n        elif mid * mid &lt; num:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\n\nnum = 16\nprint(isPerfectSquare(num))  # True\n</code></pre>"},{"location":"leetpattern/binary_search/#875-koko-eating-bananas","title":"875. Koko Eating Bananas","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> <li>Koko loves to eat bananas. She wants to eat all the bananas within <code>H</code> hours. Each pile has a number of bananas. The <code>i-th</code> pile has <code>piles[i]</code> bananas. Return the minimum integer <code>K</code> such that she can eat all the bananas within <code>H</code> hours.</li> </ul> 875. Koko Eating Bananas - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef minEatingSpeed(piles: List[int], h: int) -&gt; int:\n    def canEat(piles, k, h):\n        hours = 0\n        for pile in piles:\n            hours += (pile + k - 1) // k\n        return hours &lt;= h\n\n    left, right = 1, max(piles)\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if canEat(piles, mid, h):\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return left\n\n\npiles = [3, 6, 7, 11]\nh = 8\nprint(minEatingSpeed(piles, h))  # 4\n</code></pre>"},{"location":"leetpattern/binary_search/#1011-capacity-to-ship-packages-within-d-days","title":"1011. Capacity To Ship Packages Within D Days","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> <li>A conveyor belt has packages that must be shipped from one port to another within <code>D</code> days. The <code>i-th</code> package has a weight of <code>weights[i]</code>. Each day, we load the ship with packages on the conveyor belt. The ship will be loaded with packages up to its capacity. The ship will not be loaded beyond its capacity. Return the least weight capacity of the ship.</li> </ul> 1011. Capacity To Ship Packages Within D Days - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef shipWithinDays(weights: List[int], days: int) -&gt; int:\n\n    def canShip(weights, D, capacity):\n        days = 1\n        current_weight = 0\n\n        for weight in weights:\n            if current_weight + weight &gt; capacity:\n                days += 1\n                current_weight = 0\n            current_weight += weight\n\n        return days &lt;= D\n\n    left, right = max(weights), sum(weights)\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if canShip(weights, days, mid):\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return left\n\n\nweights = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\ndays = 5\nprint(shipWithinDays(weights, days))  # 15\n</code></pre>"},{"location":"leetpattern/binary_search/#378-kth-smallest-element-in-a-sorted-matrix","title":"378. Kth Smallest Element in a Sorted Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sorting, heap priority queue, matrix</p> </li> <li>Given an <code>n x n</code> matrix where each of the rows and columns are sorted in ascending order, return the <code>k-th</code> smallest element in the matrix.</li> </ul> 378. Kth Smallest Element in a Sorted Matrix - Python Solution<pre><code>from heapq import heapify, heappop, heappush\nfrom typing import List\n\n\n# Heap - Merge K Sorted\ndef kthSmallestHeap(matrix: List[List[int]], k: int) -&gt; int:\n    n = len(matrix)\n    heap = [(matrix[i][0], i, 0) for i in range(n)]\n    heapify(heap)\n\n    for _ in range(k - 1):\n        _, row, col = heappop(heap)\n\n        if col + 1 &lt; n:\n            heappush(heap, (matrix[row][col + 1], row, col + 1))\n\n    return heappop(heap)[0]\n\n\n# Binary Search\ndef kthSmallestBinarySearch(matrix: List[List[int]], k: int) -&gt; int:\n    n = len(matrix)\n\n    def check(mid):\n        i, j = n - 1, 0\n        num = 0\n\n        while i &gt;= 0 and j &lt; n:\n            if matrix[i][j] &lt;= mid:\n                num += i + 1\n                j += 1\n            else:\n                i -= 1\n\n        return num &gt;= k\n\n    left, right = matrix[0][0], matrix[-1][-1]\n\n    while left &lt; right:\n        mid = (left + right) // 2\n        if check(mid):\n            right = mid\n        else:\n            left = mid + 1\n\n    return left\n\n\nmatrix = [[1, 5, 9], [10, 11, 13], [12, 13, 15]]\nk = 8\n\nprint(kthSmallestHeap(matrix, k))  # 13\nprint(kthSmallestBinarySearch(matrix, k))  # 13\n</code></pre>"},{"location":"leetpattern/bit_manipulation/","title":"Bit Manipulation","text":"<ul> <li> 2595. Number of Even and Odd Bits (Easy)</li> </ul>"},{"location":"leetpattern/bit_manipulation/#2595-number-of-even-and-odd-bits","title":"2595. Number of Even and Odd Bits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: bit manipulation</p> </li> <li>Topic: Bit Manipulation</li> <li>Difficulty: Easy</li> </ul> <p>You are given a positive integer n. Let even denote the number of even indices in the binary representation of n with value 1. Let odd denote the number of odd indices in the binary representation of n with value 1. Note that bits are indexed from right to left in the binary representation of a number. Return the array [even, odd].</p>"},{"location":"leetpattern/boyer_moore/","title":"Boyer Moore","text":"<ul> <li> 169. Majority Element (Easy)</li> <li> 229. Majority Element II (Medium)</li> <li> 287. Find the Duplicate Number (Medium)</li> <li> 1150. Check If a Number Is Majority Element in a Sorted Array (Easy)</li> <li> 1157. Online Majority Element In Subarray (Hard)</li> <li> 495. Teemo Attacking (Easy)</li> </ul>"},{"location":"leetpattern/boyer_moore/#169-majority-element","title":"169. Majority Element","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, divide and conquer, sorting, counting</p> </li> <li>Return the majority element in an array. The majority element is the element that appears more than <code>n // 2</code> times.</li> </ul> <code>num</code> <code>count</code> <code>res</code> 2 1 2 2 2 2 1 1 2 1 0 2 1 1 1 2 0 1 2 1 2 169. Majority Element - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash Map\ndef majorityElementHashMap(nums: List[int]) -&gt; int:\n    n = len(nums)\n    freq = defaultdict(int)\n\n    for num in nums:\n        freq[num] += 1\n        if freq[num] &gt; n // 2:\n            return num\n\n\n# Array - Boyer-Moore Voting Algorithm\ndef majorityElementArray(nums: List[int]) -&gt; int:\n    res = None\n    count = 0\n\n    for num in nums:\n        if count == 0:\n            res = num\n        count += 1 if num == res else -1\n\n    return res\n\n\n# | Algorithm | Time Complexity | Space Complexity |\n# |-----------|-----------------|------------------|\n# | HashMap   | O(N)            | O(N)             |\n# | Array     | O(N)            | O(1)             |\n# |-----------|-----------------|------------------|\n\n\nnums = [2, 2, 1, 1, 1, 2, 2]\nprint(majorityElementArray(nums))  # 2\nprint(majorityElementHashMap(nums))  # 2\n</code></pre>"},{"location":"leetpattern/boyer_moore/#229-majority-element-ii","title":"229. Majority Element II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, sorting, counting</p> </li> </ul> 229. Majority Element II - Python Solution<pre><code>from collections import Counter\nfrom typing import List\n\n\n# Hash Map\ndef majorityElementHash(nums: List[int]) -&gt; List[int]:\n    counts = Counter(nums)\n    target = len(nums) // 3\n    res = []\n\n    for num in nums:\n        if counts[num] &gt; target and num not in res:\n            res.append(num)\n\n    return res\n\n\n# Boyer-Moore\ndef majorityElementMoore(nums: List[int]) -&gt; List[int]:\n    if not nums:\n        return []\n\n    cdt1, cnt1 = None, 0\n    cdt2, cnt2 = None, 0\n\n    for num in nums:\n        if num == cdt1:\n            cnt1 += 1\n        elif num == cdt2:\n            cnt2 += 1\n        elif cnt1 == 0:\n            cdt1, cnt1 = num, 1\n        elif cnt2 == 0:\n            cdt2, cnt2 = num, 1\n        else:\n            cnt1 -= 1\n            cnt2 -= 1\n\n    return [n for n in (cdt1, cdt2) if nums.count(n) &gt; len(nums) // 3]\n\n\nnums = [3, 2, 3]\nprint(majorityElementHash(nums))  # [3]\nprint(majorityElementMoore(nums))  # [3]\n</code></pre>"},{"location":"leetpattern/boyer_moore/#287-find-the-duplicate-number","title":"287. Find the Duplicate Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, bit manipulation</p> </li> <li>Find the duplicate number in an array containing <code>n + 1</code> integers where each integer is between <code>1</code> and <code>n</code> inclusive.</li> </ul> 287. Find the Duplicate Number - Python Solution<pre><code>from typing import List\n\n\n# Fast Slow Pointer\ndef findDuplicate(nums: List[int]) -&gt; int:\n\n    fast, slow = nums[0], nums[0]\n\n    while True:\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n        if slow == fast:\n            break\n\n    slow = nums[0]\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[fast]\n\n    return slow\n\n\n# | Algorithm          | TC   | SC   |\n# |--------------------|------|------|\n# | Fast Slow Pointer  | O(n) | O(1) |\n# |--------------------|------|------|\n\nnums = [1, 3, 4, 2, 2]\nprint(findDuplicate(nums))  # 2\n</code></pre>"},{"location":"leetpattern/boyer_moore/#1150-check-if-a-number-is-majority-element-in-a-sorted-array","title":"1150. Check If a Number Is Majority Element in a Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"leetpattern/boyer_moore/#1157-online-majority-element-in-subarray","title":"1157. Online Majority Element In Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, design, binary indexed tree, segment tree</p> </li> </ul>"},{"location":"leetpattern/boyer_moore/#495-teemo-attacking","title":"495. Teemo Attacking","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, simulation</p> </li> </ul>"},{"location":"leetpattern/bst/","title":"BST","text":"<ul> <li> 700. Search in a Binary Search Tree (Easy)</li> <li> 98. Validate Binary Search Tree (Medium)</li> <li> 530. Minimum Absolute Difference in BST (Easy)</li> <li> 501. Find Mode in Binary Search Tree (Easy)</li> <li> 235. Lowest Common Ancestor of a Binary Search Tree (Medium)</li> <li> 701. Insert into a Binary Search Tree (Medium)</li> <li> 450. Delete Node in a BST (Medium)</li> <li> 669. Trim a Binary Search Tree (Medium)</li> <li> 108. Convert Sorted Array to Binary Search Tree (Easy)</li> <li> 109. Convert Sorted List to Binary Search Tree (Medium)</li> <li> 538. Convert BST to Greater Tree (Medium)</li> <li> 230. Kth Smallest Element in a BST (Medium)</li> <li> 173. Binary Search Tree Iterator (Medium)</li> <li> 1586. Binary Search Tree Iterator II (Medium)</li> </ul>"},{"location":"leetpattern/bst/#700-search-in-a-binary-search-tree","title":"700. Search in a Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, binary search tree, binary tree</p> </li> </ul>"},{"location":"leetpattern/bst/#binary-search-tree","title":"Binary Search Tree","text":"<ol> <li>Binary Tree</li> <li>Left subtree of a node contains only nodes with keys less than the node's key</li> <li>Right subtree of a node contains only nodes with keys greater than the node's key</li> <li>The left and right subtree each must also be a binary search tree</li> <li>There must be no duplicate nodes</li> <li>Inorder traversal of a BST gives a sorted list of keys</li> </ol> <pre><code>graph TD\n4((4)) --- 2((2))\n4 --- 7((7))\n2 --- 1((1))\n2 --- 3((3))</code></pre> 700. Search in a Binary Search Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# 1. Recursive\ndef searchBSTRecursive(\n    root: Optional[TreeNode], val: int\n) -&gt; Optional[TreeNode]:\n    if not root:\n        return None\n\n    if root.val &gt; val:\n        return searchBSTRecursive(root.left, val)\n\n    elif root.val &lt; val:\n        return searchBSTRecursive(root.right, val)\n\n    else:\n        return root\n\n\n# 2. Iterative\ndef searchBSTIterative(\n    root: Optional[TreeNode], val: int\n) -&gt; Optional[TreeNode]:\n    while root:\n        if root.val &gt; val:\n            root = root.left\n        elif root.val &lt; val:\n            root = root.right\n        else:\n            return root\n    return None\n\n\nroot = [4, 2, 7, 1, 3]\nval = 2\nroot = build(root)\nprint(root)\n#     __4\n#    /   \\\n#   2     7\n#  / \\\n# 1   3\nprint(searchBSTRecursive(root, val))\n#   2\n#  / \\\n# 1   3\nprint(searchBSTIterative(root, val))\n#   2\n#  / \\\n# 1   3\n</code></pre>"},{"location":"leetpattern/bst/#98-validate-binary-search-tree","title":"98. Validate Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree</p> </li> </ul> 98. Validate Binary Search Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef isValidBST(root: Optional[TreeNode]) -&gt; bool:\n    inorder = []  # inorder traversal of BST\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    for i in range(1, len(inorder)):\n        if inorder[i] &lt;= inorder[i - 1]:\n            return False\n\n    return True\n\n\nroot = [5, 1, 4, None, None, 3, 6]\nroot = build(root)\nprint(root)\n#   5__\n#  /   \\\n# 1     4\n#      / \\\n#     3   6\nprint(isValidBST(root))  # False\n# [1, 5, 3, 4, 6]\n</code></pre>"},{"location":"leetpattern/bst/#530-minimum-absolute-difference-in-bst","title":"530. Minimum Absolute Difference in BST","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary search tree, binary tree</p> </li> </ul> 530. Minimum Absolute Difference in BST - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef getMinimumDifference(root: Optional[TreeNode]) -&gt; int:\n\n    inorder = []\n    result = float(\"inf\")\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    for i in range(1, len(inorder)):\n        result = min(result, abs(inorder[i] - inorder[i - 1]))\n\n    return result\n\n\nroot = [4, 2, 6, 1, 3]\nroot = build(root)\nprint(root)\n#     __4\n#    /   \\\n#   2     6\n#  / \\\n# 1   3\nprint(getMinimumDifference(root))  # 1\n</code></pre>"},{"location":"leetpattern/bst/#501-find-mode-in-binary-search-tree","title":"501. Find Mode in Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree</p> </li> </ul> 501. Find Mode in Binary Search Tree - Python Solution<pre><code>from typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef findMode(root: Optional[TreeNode]) -&gt; List[int]:\n    hashmap = dict()\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        if node.val not in hashmap:\n            hashmap[node.val] = 1\n        else:\n            hashmap[node.val] += 1\n        dfs(node.right)\n\n    dfs(root)\n    max_counts = max(hashmap.values())\n    result = []\n\n    for key, value in hashmap.items():\n        if value == max_counts:\n            result.append(key)\n\n    return result\n\n\nroot = [1, None, 2, None, None, 2]\nroot = build(root)\nprint(root)\n# 1__\n#    \\\n#     2\n#    /\n#   2\nprint(findMode(root))  # [2]\n</code></pre>"},{"location":"leetpattern/bst/#235-lowest-common-ancestor-of-a-binary-search-tree","title":"235. Lowest Common Ancestor of a Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree</p> </li> </ul> 235. Lowest Common Ancestor of a Binary Search Tree - Python Solution<pre><code>from binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef lowestCommonAncestor(\n    root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n) -&gt; \"TreeNode\":\n    while root:\n        if root.val &gt; p.val and root.val &gt; q.val:\n            root = root.left\n        elif root.val &lt; p.val and root.val &lt; q.val:\n            root = root.right\n        else:\n            return root\n\n\nroot = [6, 2, 8, 0, 4, 7, 9, None, None, 3, 5]\nroot = build(root)\np = root.left\nq = root.right\nprint(root)\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\nprint(lowestCommonAncestor(root, p, q))\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\n</code></pre>"},{"location":"leetpattern/bst/#701-insert-into-a-binary-search-tree","title":"701. Insert into a Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, binary search tree, binary tree</p> </li> </ul> 701. Insert into a Binary Search Tree - Python Solution<pre><code>from typing import Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef insertIntoBST(root: Optional[TreeNode], val: int) -&gt; Optional[TreeNode]:\n    if root is None:\n        return TreeNode(val)\n\n    if root.val &gt; val:\n        root.left = insertIntoBST(root.left, val)\n    if root.val &lt; val:\n        root.right = insertIntoBST(root.right, val)\n\n    return root\n\n\nroot = TreeNode(4)\nroot.left = TreeNode(2)\nroot.right = TreeNode(6)\nroot.left.left = TreeNode(1)\nroot.left.right = TreeNode(3)\n#     __4\n#    /   \\\n#   2     6\n#  / \\\n# 1   3\n\ninsertIntoBST(root, 5)\n#     __4\n#    /   \\\n#   2     6\n#  / \\   /\n# 1   3 5\n</code></pre>"},{"location":"leetpattern/bst/#450-delete-node-in-a-bst","title":"450. Delete Node in a BST","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, binary search tree, binary tree</p> </li> </ul> 450. Delete Node in a BST - Python Solution<pre><code>from typing import Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef deleteNode(root: Optional[TreeNode], key: int) -&gt; Optional[TreeNode]:\n    if root is None:\n        return root\n\n    if root.val == key:\n        if root.left is None and root.right is None:\n            return None\n        elif root.left is None:\n            return root.right\n        elif root.right is None:\n            return root.left\n        else:\n            cur = root.right\n            while cur.left is not None:\n                cur = cur.left\n            cur.left = root.left\n            return root.right\n\n    if root.val &gt; key:\n        root.left = deleteNode(root.left, key)\n    if root.val &lt; key:\n        root.right = deleteNode(root.right, key)\n\n    return root\n\n\nroot = TreeNode(5)\nroot.left = TreeNode(3)\nroot.right = TreeNode(6)\nroot.left.left = TreeNode(2)\nroot.left.right = TreeNode(4)\nroot.right.right = TreeNode(7)\n#     __5\n#    /   \\\n#   3     6\n#  / \\     \\\n# 2   4     7\n\ndeleteNode(root, 3)\n#     __5\n#    /   \\\n#   4     6\n#  /       \\\n# 2         7\n</code></pre>"},{"location":"leetpattern/bst/#669-trim-a-binary-search-tree","title":"669. Trim a Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree</p> </li> </ul> 669. Trim a Binary Search Tree - Python Solution<pre><code>from typing import Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef trimBST(\n    root: Optional[TreeNode], low: int, high: int\n) -&gt; Optional[TreeNode]:\n    if root is None:\n        return None\n\n    if root.val &lt; low:\n        return trimBST(root.right, low, high)\n    if root.val &gt; high:\n        return trimBST(root.left, low, high)\n\n    root.left = trimBST(root.left, low, high)\n    root.right = trimBST(root.right, low, high)\n\n    return root\n\n\nroot = TreeNode(3)\nroot.left = TreeNode(0)\nroot.right = TreeNode(4)\nroot.left.right = TreeNode(2)\nroot.left.right.left = TreeNode(1)\n#     __3\n#    /   \\\n#   0     4\n#    \\\n#     2\n#    /\n#   1\n\ntrimBST(root, 1, 3)\n#     __3\n#    /\n#   2\n#  /\n# 1\n</code></pre>"},{"location":"leetpattern/bst/#108-convert-sorted-array-to-binary-search-tree","title":"108. Convert Sorted Array to Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, divide and conquer, tree, binary search tree, binary tree</p> </li> </ul> 108. Convert Sorted Array to Binary Search Tree - Python Solution<pre><code>from typing import List, Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef sortedArrayToBST(nums: List[int]) -&gt; Optional[TreeNode]:\n    if len(nums) == 0:\n        return None\n\n    mid = len(nums) // 2\n    root = TreeNode(nums[mid])\n\n    root.left = sortedArrayToBST(nums[:mid])\n    root.right = sortedArrayToBST(nums[mid + 1 :])\n\n    return root\n\n\nnums = [-10, -3, 0, 5, 9]\nroot = sortedArrayToBST(nums)\n#      0\n#     / \\\n#   -3   9\n#   /   /\n# -10  5\n</code></pre>"},{"location":"leetpattern/bst/#109-convert-sorted-list-to-binary-search-tree","title":"109. Convert Sorted List to Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, divide and conquer, tree, binary search tree, binary tree </p> </li> </ul> 109. Convert Sorted List to Binary Search Tree - Python Solution<pre><code>from typing import Optional\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef sortedListToBST(head: Optional[ListNode]) -&gt; Optional[TreeNode]:\n    if not head:\n        return None\n\n    def find_mid(head: ListNode) -&gt; ListNode:\n        prev = None\n        slow = head\n        fast = head\n\n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n\n        if prev:\n            prev.next = None\n\n        return slow\n\n    mid = find_mid(head)\n\n    node = TreeNode(mid.val)\n\n    if head == mid:\n        return node\n\n    node.left = sortedListToBST(head)\n    node.right = sortedListToBST(mid.next)\n\n    return node\n\n\nhead = ListNode(-10)\nhead.next = ListNode(-3)\nhead.next.next = ListNode(0)\nhead.next.next.next = ListNode(5)\nhead.next.next.next.next = ListNode(9)\n\nroot = sortedListToBST(head)\nassert root.val == 0\nassert root.left.val == -3\nassert root.left.left.val == -10\nassert root.right.val == 9\nassert root.right.left.val == 5\nprint(\"All passed\")\n\n#      0\n#     / \\\n#   -3   9\n#   /   /\n# -10  5\n</code></pre>"},{"location":"leetpattern/bst/#538-convert-bst-to-greater-tree","title":"538. Convert BST to Greater Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree </p> </li> </ul> 538. Convert BST to Greater Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef convertBST(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    prev = 0\n\n    def dfs(node):\n        if not node:\n            return None\n        nonlocal prev\n\n        dfs(node.right)\n\n        node.val += prev\n        prev = node.val\n\n        dfs(node.left)\n\n    dfs(root)\n\n    return root\n\n\nroot = [4, 1, 6, 0, 2, 5, 7, None, None, None, 3, None, None, None, 8]\nroot = build(root)\nprint(root)\n#     ____4__\n#    /       \\\n#   1         6\n#  / \\       / \\\n# 0   2     5   7\n#      \\         \\\n#       3         8\ngreater_tree = convertBST(root)\nprint(greater_tree)\n#      _______30___\n#     /            \\\n#   _36            _21\n#  /   \\          /   \\\n# 36    35       26    15\n#         \\              \\\n#          33             8\n</code></pre>"},{"location":"leetpattern/bst/#230-kth-smallest-element-in-a-bst","title":"230. Kth Smallest Element in a BST","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree</p> </li> </ul> 230. Kth Smallest Element in a BST - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BST\ndef kthSmallest(root: Optional[TreeNode], k: int) -&gt; int:\n    inorder = []\n\n    def dfs(node):\n        if not node:\n            return None\n\n        dfs(node.left)\n        nonlocal inorder\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    return inorder[k - 1]\n\n\n# |----------|------|-------|\n# | Approach | Time | Space |\n# |----------|------|-------|\n# | DFS      | O(n) | O(n)  |\n# |----------|------|-------|\n\n\nroot = build([3, 1, 4, None, 2])\nk = 1\nprint(root)\n#   __3\n#  /   \\\n# 1     4\n#  \\\n#   2\nprint(kthSmallest(root, k))  # 1\n</code></pre>"},{"location":"leetpattern/bst/#173-binary-search-tree-iterator","title":"173. Binary Search Tree Iterator","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: stack, tree, design, binary search tree, binary tree, iterator</p> </li> </ul> 173. Binary Search Tree Iterator - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BST\nclass BSTIterator:\n\n    def __init__(self, root: Optional[TreeNode]):\n        self.stack = []\n        self._leftmost_inorder(root)\n\n    def _leftmost_inorder(self, root):\n        while root:\n            self.stack.append(root)\n            root = root.left\n\n    def next(self) -&gt; int:\n        topmost_node = self.stack.pop()\n\n        if topmost_node.right:\n            self._leftmost_inorder(topmost_node.right)\n\n        return topmost_node.val\n\n    def hasNext(self) -&gt; bool:\n        return len(self.stack) &gt; 0\n\n\nroot = build([7, 3, 15, None, None, 9, 20])\nprint(root)\n#   7__\n#  /   \\\n# 3     15\n#      /  \\\n#     9    20\nobj = BSTIterator(root)\nprint(obj.next())  # 3\nprint(obj.next())  # 7\nprint(obj.hasNext())  # True\n</code></pre>"},{"location":"leetpattern/bst/#1586-binary-search-tree-iterator-ii","title":"1586. Binary Search Tree Iterator II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: stack, tree, design, binary search tree, binary tree, iterator</p> </li> </ul> 1586. Binary Search Tree Iterator II - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BST\nclass BSTIterator:\n    def __init__(self, root: Optional[TreeNode]):\n        self.nodes = self._inorder(root)\n        self.index = -1\n        self.size = len(self.nodes)\n\n    def _inorder(self, node):\n        if not node:\n            return []\n        return (\n            self._inorder(node.left) + [node.val] + self._inorder(node.right)\n        )\n\n    def hasNext(self) -&gt; bool:\n        return self.index &lt; self.size - 1\n\n    def next(self) -&gt; int:\n        self.index += 1\n        return self.nodes[min(self.index, self.size - 1)]\n\n    def hasPrev(self) -&gt; bool:\n        return self.index &gt; 0\n\n    def prev(self) -&gt; int:\n        self.index -= 1\n        return self.nodes[max(self.index, 0)]\n\n\nroot = build([7, 3, 15, None, None, 9, 20])\nprint(root)\n#   7__\n#  /   \\\n# 3     15\n#      /  \\\n#     9    20\nobj = BSTIterator(root)\nprint(obj.next())  # 3\nprint(obj.next())  # 7\nprint(obj.hasNext())  # True\nprint(obj.prev())  # 3\nprint(obj.prev())  # None\n</code></pre>"},{"location":"leetpattern/design/","title":"Design","text":"<ul> <li> 146. LRU Cache (Medium)</li> <li> 355. Design Twitter (Medium)</li> <li> 588. Design In-Memory File System (Hard)</li> <li> 460. LFU Cache (Hard)</li> <li> 1166. Design File System (Medium)</li> <li> 380. Insert Delete GetRandom O(1) (Medium)</li> <li> 362. Design Hit Counter (Medium)</li> <li> 297. Serialize and Deserialize Binary Tree (Hard)</li> <li> 622. Design Circular Queue (Medium)</li> <li> 353. Design Snake Game (Medium)</li> <li> 1244. Design A Leaderboard (Medium)</li> </ul>"},{"location":"leetpattern/design/#146-lru-cache","title":"146. LRU Cache","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, linked list, design, doubly linked list</p> </li> <li>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.</li> </ul> <p></p> Data structure Description Doubly Linked List To store the key-value pairs. Hash Map To store the key-node pairs. Approach Time Complexity Space Complexity LRU O(1) O(n) 146. LRU Cache - Python Solution<pre><code>from collections import OrderedDict\n\n\n# Doubly Linked List\nclass Node:\n    def __init__(self, key=0, val=0):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.cache = {}\n        self.head = Node()\n        self.tail = Node()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def add_to_last(self, node):\n        self.tail.prev.next = node\n        node.prev = self.tail.prev\n        node.next = self.tail\n        self.tail.prev = node\n\n    def move_to_last(self, node):\n        self.remove(node)\n        self.add_to_last(node)\n\n    def get(self, key: int) -&gt; int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self.move_to_last(node)\n        return node.val\n\n    def put(self, key: int, value: int) -&gt; None:\n        if key in self.cache:\n            node = self.cache[key]\n            node.val = value\n            self.move_to_last(node)\n            return None\n\n        if len(self.cache) == self.cap:\n            del self.cache[self.head.next.key]\n            self.remove(self.head.next)\n\n        node = Node(key=key, val=value)\n        self.cache[key] = node\n        self.add_to_last(node)\n\n\n# OrderedDict\nclass LRUCacheOrderedDict:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.cap = capacity\n\n    def get(self, key: int):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key, last=True)\n        return self.cache[key]\n\n    def put(self, key: int, value: int):\n        if key in self.cache:\n            self.cache.move_to_end(key, last=True)\n        elif len(self.cache) &gt;= self.cap:\n            self.cache.popitem(last=False)\n\n        self.cache[key] = value\n\n\ncache = LRUCache(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\n\ncache = LRUCacheOrderedDict(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\nprint(\"LRU Cache passed\")\nprint(\"LRU Cache Ordered Dict passed\")\n</code></pre>"},{"location":"leetpattern/design/#355-design-twitter","title":"355. Design Twitter","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, linked list, design, heap priority queue</p> </li> <li>Similar question: 23. Merge K Sorted Lists (Hard)</li> </ul> 355. Design Twitter - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Design\nclass Twitter:\n\n    def __init__(self):\n        self.tweets = defaultdict(list)\n        self.followees = defaultdict(set)\n        self.time = 0\n\n    def postTweet(self, userId: int, tweetId: int) -&gt; None:\n        self.tweets[userId].append((self.time, tweetId))\n        self.time += 1\n\n    def getNewsFeed(self, userId: int) -&gt; List[int]:\n        news_feed = []\n        news_feed.extend(self.tweets[userId])\n        for followee in self.followees[userId]:\n            news_feed.extend(self.tweets[followee])\n\n        return [tweet for _, tweet in heapq.nlargest(10, news_feed)]\n\n    def follow(self, followerId: int, followeeId: int) -&gt; None:\n        if followerId != followeeId:\n            self.followees[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -&gt; None:\n        if followerId != followeeId:\n            self.followees[followerId].discard(followeeId)\n\n\ntwitter = Twitter()\nprint(twitter.postTweet(1, 5))  # None\nprint(twitter.getNewsFeed(1))  # [5]\nprint(twitter.follow(1, 2))  # None\nprint(twitter.postTweet(2, 6))  # None\nprint(twitter.getNewsFeed(1))  # [6, 5]\nprint(twitter.unfollow(1, 2))  # None\nprint(twitter.getNewsFeed(1))  # [5]\n</code></pre>"},{"location":"leetpattern/design/#588-design-in-memory-file-system","title":"588. Design In-Memory File System","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, design, trie, sorting</p> </li> </ul> 588. Design In-Memory File System - Python Solution<pre><code>from collections import defaultdict\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children = defaultdict(TrieNode)\n        self.content = \"\"\n\n\n# Trie\nclass FileSystem:\n\n    def __init__(self):\n        self.root = TrieNode()\n\n    def ls(self, path: str) -&gt; list:\n        cur = self.root\n\n        if path != \"/\":\n            paths = path.split(\"/\")[1:]\n            for p in paths:\n                cur = cur.children[p]\n        if cur.content:\n            return [path.split(\"/\")[-1]]\n\n        return sorted(cur.children.keys())\n\n    def mkdir(self, path: str) -&gt; None:\n        cur = self.root\n        paths = path.split(\"/\")[1:]\n        for p in paths:\n            cur = cur.children[p]\n\n    def addContentToFile(self, filePath: str, content: str) -&gt; None:\n        cur = self.root\n        paths = filePath.split(\"/\")[1:]\n        for p in paths:\n            cur = cur.children[p]\n        cur.content += content\n\n    def readContentFromFile(self, filePath: str) -&gt; str:\n        cur = self.root\n        paths = filePath.split(\"/\")[1:]\n        for p in paths:\n            cur = cur.children[p]\n        return cur.content\n\n\nobj = FileSystem()\nobj.mkdir(\"/a/b/c\")\nobj.addContentToFile(\"/a/b/c/d\", \"hello\")\nprint(obj.ls(\"/\"))  # [\"a\"]\nprint(obj.readContentFromFile(\"/a/b/c/d\"))  # \"hello\"\n</code></pre>"},{"location":"leetpattern/design/#460-lfu-cache","title":"460. LFU Cache","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, linked list, design, doubly linked list</p> </li> </ul> 460. LFU Cache - Python Solution<pre><code>from collections import OrderedDict, defaultdict\n\n\nclass LFUCache:\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        # key -&gt; [val, freq]\n        self.key_to_val_freq = {}\n        # freq -&gt; OrderedDict of keys\n        self.freq_to_keys = defaultdict(OrderedDict)\n        self.min_freq = 0\n\n    def remove_least_frequent(self):\n\n        lfu_key, _ = self.freq_to_keys[self.min_freq].popitem(last=False)\n        del self.key_to_val_freq[lfu_key]\n\n        # If the frequency list is empty after removal, delete it\n        if not self.freq_to_keys[self.min_freq]:\n            del self.freq_to_keys[self.min_freq]\n\n    def update_freq(self, key):\n        \"\"\"Updates the frequency of an existing key.\"\"\"\n        value, freq = self.key_to_val_freq[key]\n\n        # Remove key from current frequency group\n        del self.freq_to_keys[freq][key]\n        if not self.freq_to_keys[freq]:\n            del self.freq_to_keys[freq]\n            if self.min_freq == freq:\n                self.min_freq += 1\n\n        # Update key frequency\n        new_freq = freq + 1\n        self.key_to_val_freq[key] = [value, new_freq]\n        self.freq_to_keys[new_freq][key] = None\n\n    def add_new_key(self, key, value):\n        if len(self.key_to_val_freq) &gt;= self.cap:\n            self.remove_least_frequent()\n\n        # Insert the new key with frequency 1\n        self.key_to_val_freq[key] = [value, 1]\n        self.freq_to_keys[1][key] = None\n        self.min_freq = 1\n\n    def get(self, key: int) -&gt; int:\n        if key not in self.key_to_val_freq:\n            return -1\n        self.update_freq(key)\n        return self.key_to_val_freq[key][0]\n\n    def put(self, key: int, value: int) -&gt; None:\n        if self.cap == 0:\n            return\n\n        if key in self.key_to_val_freq:\n            self.key_to_val_freq[key][0] = value\n            self.update_freq(key)\n        else:\n            self.add_new_key(key, value)\n\n\nlfu = LFUCache(2)\nlfu.put(1, 1)\nlfu.put(2, 2)\nprint(lfu.get(1))  # 1\nlfu.put(3, 3)\nprint(lfu.get(2))  # -1\nprint(lfu.get(3))  # 3\nlfu.put(4, 4)\nprint(lfu.get(1))  # -1\nprint(lfu.get(3))  # 3\n</code></pre>"},{"location":"leetpattern/design/#1166-design-file-system","title":"1166. Design File System","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, design, trie</p> </li> </ul> 1166. Design File System - Python Solution<pre><code>from collections import defaultdict\n\n\nclass TrieNode:\n    def __init__(self, name):\n        self.name = name\n        self.children = defaultdict(TrieNode)\n        self.value = -1\n\n\n# Trie\nclass FileSystem:\n    def __init__(self):\n        self.root = TrieNode(\"\")\n\n    def createPath(self, path: str, value: int) -&gt; bool:\n        paths = path.split(\"/\")[1:]\n        cur = self.root\n\n        for idx, path in enumerate(paths):\n            if path not in cur.children:\n                if idx == len(paths) - 1:\n                    cur.children[path] = TrieNode(path)\n                else:\n                    return False\n            cur = cur.children[path]\n\n        if cur.value != -1:\n            return False\n        cur.value = value\n        return True\n\n    def get(self, path: str) -&gt; int:\n        cur = self.root\n        paths = path.split(\"/\")[1:]\n\n        for path in paths:\n            if path not in cur.children:\n                return -1\n            cur = cur.children[path]\n\n        return cur.value\n\n\n# Your FileSystem object will be instantiated and called as such:\npath = \"/a\"\nvalue = 1\nobj = FileSystem()\nprint(obj.createPath(path, value))  # False\nprint(obj.get(path))  # 1\n</code></pre>"},{"location":"leetpattern/design/#380-insert-delete-getrandom-o1","title":"380. Insert Delete GetRandom O(1)","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, design, randomized</p> </li> </ul> 380. Insert Delete GetRandom O(1) - Python Solution<pre><code>import random\n\n\nclass RandomizedSet:\n    def __init__(self):\n        self.dict = {}\n        self.list = []\n\n    def insert(self, val: int) -&gt; bool:\n        if val in self.dict:\n            return False\n        self.dict[val] = len(self.list)\n        self.list.append(val)\n\n        return True\n\n    def remove(self, val: int) -&gt; bool:\n        if val not in self.dict:\n            return False\n        last_element = self.list[-1]\n        idx = self.dict[val]\n        self.list[idx] = last_element\n        self.dict[last_element] = idx\n        self.list.pop()\n        del self.dict[val]\n        return True\n\n    def getRandom(self) -&gt; int:\n        return random.choice(self.list)\n\n\nobj = RandomizedSet()\nprint(obj.insert(1))  # True\nprint(obj.remove(2))  # False\nprint(obj.insert(2))  # True\nprint(obj.getRandom())  # 1 or 2\nprint(obj.remove(1))  # True\n</code></pre>"},{"location":"leetpattern/design/#362-design-hit-counter","title":"362. Design Hit Counter","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, design, queue, data stream</p> </li> </ul> 362. Design Hit Counter - Python Solution<pre><code>from collections import deque\n\n\nclass HitCounter:\n\n    def __init__(self):\n        self.hits = deque()\n\n    def hit(self, timestamp: int) -&gt; None:\n        self.hits.append(timestamp)\n\n    def getHits(self, timestamp: int) -&gt; int:\n        # Remove hits that are older than 5 minutes (300 seconds)\n        while self.hits and self.hits[0] &lt;= timestamp - 300:\n            self.hits.popleft()\n        return len(self.hits)\n\n\nobj = HitCounter()\nobj.hit(1)\nobj.hit(2)\nobj.hit(3)\nprint(obj.getHits(4))  # 3\nobj.hit(300)\nprint(obj.getHits(300))  # 4\nprint(obj.getHits(301))  # 3\n</code></pre>"},{"location":"leetpattern/design/#297-serialize-and-deserialize-binary-tree","title":"297. Serialize and Deserialize Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, tree, depth first search, breadth first search, design, binary tree</p> </li> </ul> 297. Serialize and Deserialize Binary Tree - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BFS\nclass BFS:\n    def serialize(self, root: Optional[TreeNode]) -&gt; str:\n        if not root:\n            return \"\"\n\n        res = []\n        q = deque([root])\n\n        while q:\n            node = q.popleft()\n\n            if node:\n                res.append(str(node.val))\n                q.append(node.left)\n                q.append(node.right)\n            else:\n                res.append(\"null\")\n\n        return \",\".join(res)\n\n    def deserialize(self, data: str) -&gt; Optional[TreeNode]:\n        if not data:\n            return None\n\n        nodes = data.split(\",\")\n        root = TreeNode(int(nodes[0]))\n        q = deque([root])\n        index = 1\n\n        while q:\n            node = q.popleft()\n\n            if nodes[index] != \"null\":\n                node.left = TreeNode(int(nodes[index]))\n                q.append(node.left)\n            index += 1\n\n            if nodes[index] != \"null\":\n                node.right = TreeNode(int(nodes[index]))\n                q.append(node.right)\n            index += 1\n\n        return root\n\n\n# DFS\nclass DFS:\n    def serialize(self, root: Optional[TreeNode]) -&gt; str:\n        def dfs(node):\n            if not node:\n                return [\"null\"]\n            return [str(node.val)] + dfs(node.left) + dfs(node.right)\n\n        return \",\".join(dfs(root))\n\n    def deserialize(self, data: str) -&gt; Optional[TreeNode]:\n        nodes = data.split(\",\")\n        self.index = 0\n\n        def dfs():\n            if nodes[self.index] == \"null\":\n                self.index += 1\n                return None\n\n            node = TreeNode(int(nodes[self.index]))\n            self.index += 1\n\n            node.left = dfs()\n            node.right = dfs()\n\n            return node\n\n        root = dfs()\n        return root\n\n\nroot = build([1, 2, 3, None, None, 4, 5])\nprint(root)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n\nbfs = BFS()\ndata1 = bfs.serialize(root)\nprint(data1)  # \"1,2,3,null,null,4,5,null,null,null,null\"\nroot1 = bfs.deserialize(data1)\nprint(root1)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n\ndfs = DFS()\ndata2 = dfs.serialize(root)\nprint(data2)  # \"1,2,null,null,3,4,null,null,5,null,null\"\nroot2 = dfs.deserialize(data2)\nprint(root2)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n</code></pre>"},{"location":"leetpattern/design/#622-design-circular-queue","title":"622. Design Circular Queue","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, linked list, design, queue</p> </li> </ul> 622. Design Circular Queue - Python Solution<pre><code># Design\nclass MyCircularQueue:\n\n    def __init__(self, k: int):\n        self.queue = [0] * k\n        self.head = 0\n        self.tail = -1\n        self.size = 0\n        self.capacity = k\n\n    def enQueue(self, value: int) -&gt; bool:\n        if self.isFull():\n            return False\n        self.tail = (self.tail + 1) % self.capacity\n        self.queue[self.tail] = value\n        self.size += 1\n        return True\n\n    def deQueue(self) -&gt; bool:\n        if self.isEmpty():\n            return False\n        self.head = (self.head + 1) % self.capacity\n        self.size -= 1\n        return True\n\n    def Front(self) -&gt; int:\n        if self.isEmpty():\n            return -1\n        return self.queue[self.head]\n\n    def Rear(self) -&gt; int:\n        if self.isEmpty():\n            return -1\n        return self.queue[self.tail]\n\n    def isEmpty(self) -&gt; bool:\n        return self.size == 0\n\n    def isFull(self) -&gt; bool:\n        return self.size == self.capacity\n\n\nobj = MyCircularQueue(3)\nprint(obj.enQueue(1))  # True\nprint(obj.enQueue(2))  # True\nprint(obj.enQueue(3))  # True\nprint(obj.enQueue(4))  # False\nprint(obj.Rear())  # 3\nprint(obj.isFull())  # True\nprint(obj.deQueue())  # True\n</code></pre>"},{"location":"leetpattern/design/#353-design-snake-game","title":"353. Design Snake Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, design, queue, simulation</p> </li> </ul> 353. Design Snake Game - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\nclass SnakeGame:\n\n    def __init__(self, width: int, height: int, food: List[List[int]]):\n        self.width = width\n        self.height = height\n        self.food = deque(food)\n        self.snake = deque([(0, 0)])  # Snake starts at the top-left corner\n        self.snake_body = set([(0, 0)])  # To quickly check for collisions\n        self.score = 0\n        self.dirs = {\"U\": (-1, 0), \"L\": (0, -1), \"R\": (0, 1), \"D\": (1, 0)}\n\n    def move(self, direction: str) -&gt; int:\n        head = self.snake[0]\n        dx, dy = self.dirs[direction]\n        new_head = (head[0] + dx, head[1] + dy)\n\n        # Check if the new head is out of bounds\n        if not (\n            0 &lt;= new_head[0] &lt; self.height and 0 &lt;= new_head[1] &lt; self.width\n        ):\n            return -1\n\n        # Check if the new head collides with the snake body (excluding the tail)\n        if new_head in self.snake_body and new_head != self.snake[-1]:\n            return -1\n\n        # Check if the new head is on a food cell\n        if self.food and self.food[0] == list(new_head):\n            self.food.popleft()\n            self.score += 1\n        else:\n            tail = self.snake.pop()\n            self.snake_body.remove(tail)\n\n        # Add the new head to the snake\n        self.snake.appendleft(new_head)\n        self.snake_body.add(new_head)\n\n        return self.score\n\n\nsnake = SnakeGame(3, 2, [[1, 2], [0, 1]])\nprint(snake.move(\"R\"))  # 0\nprint(snake.move(\"D\"))  # 0\nprint(snake.move(\"R\"))  # 1\nprint(snake.move(\"U\"))  # 1\nprint(snake.move(\"L\"))  # 2\nprint(snake.move(\"U\"))  # -1\n</code></pre>"},{"location":"leetpattern/design/#1244-design-a-leaderboard","title":"1244. Design A Leaderboard","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, design, sorting</p> </li> </ul> 1244. Design A Leaderboard - Python Solution<pre><code>class Leaderboard:\n\n    def __init__(self):\n        self.scores = {}\n\n    def addScore(self, playerId: int, score: int) -&gt; None:\n        if playerId in self.scores:\n            self.scores[playerId] += score\n        else:\n            self.scores[playerId] = score\n\n    def top(self, K: int) -&gt; int:\n        topK = sorted(self.scores.values(), reverse=True)[:K]\n        return sum(topK)\n\n    def reset(self, playerId: int) -&gt; None:\n        if playerId in self.scores:\n            self.scores[playerId] = 0\n\n\nboard = Leaderboard()\nboard.addScore(1, 73)\nboard.addScore(2, 56)\nboard.addScore(3, 39)\nboard.addScore(4, 51)\nprint(board.top(1))  # 73\nboard.reset(1)\nboard.reset(2)\nprint(board.top(2))  # 90\n</code></pre>"},{"location":"leetpattern/difference_array/","title":"Difference Array","text":"<ul> <li> 1094. Car Pooling (Medium)</li> <li> 370. Range Addition (Medium)</li> <li> 1109. Corporate Flight Bookings (Medium)</li> <li> 2848. Points That Intersect With Cars (Easy)</li> </ul>"},{"location":"leetpattern/difference_array/#1094-car-pooling","title":"1094. Car Pooling","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sorting, heap priority queue, simulation, prefix sum</p> </li> <li>Return <code>False</code> if the total number of passengers at any point is greater than <code>capacity</code>. Otherwise, return <code>True</code>.</li> </ul> 1094. Car Pooling - Python Solution<pre><code>from itertools import accumulate\nfrom typing import List\n\n\n# Difference Array\ndef carPooling1(trips: List[List[int]], capacity: int) -&gt; bool:\n    max_location = 0\n    for trip in trips:\n        max_location = max(max_location, trip[2])\n\n    diff = [0] * (max_location + 1)\n    n = len(diff)\n\n    for num, start, end in trips:\n        diff[start] += num\n        if end &lt; n:\n            diff[end] -= num\n\n    cur = 0\n    for i in range(n):\n        cur += diff[i]\n        if cur &gt; capacity:\n            return False\n\n    return True\n\n\n# Difference Array\ndef carPooling2(trips: List[List[int]], capacity: int) -&gt; bool:\n    diff = [0] * 1001\n\n    for num, start, end in trips:\n        diff[start] += num\n        diff[end] -= num\n\n    return all(s &lt;= capacity for s in accumulate(diff))\n\n\ntrips = [[2, 1, 5], [3, 3, 7]]\ncapacity = 4\nprint(carPooling1(trips, capacity))  # False\nprint(carPooling2(trips, capacity))  # False\n</code></pre>"},{"location":"leetpattern/difference_array/#370-range-addition","title":"370. Range Addition","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, prefix sum</p> </li> <li>Return the final array after applying all the Adition operations.</li> </ul> 370. Range Addition - Python Solution<pre><code>from typing import List\n\n\n# Difference Array\ndef getModifiedArray(length: int, updates: List[List[int]]) -&gt; List[int]:\n    result = [0 for _ in range(length)]\n\n    for start, end, inc in updates:\n        result[start] += inc\n\n        if end + 1 &lt; length:\n            result[end + 1] -= inc\n\n    for i in range(1, length):\n        result[i] += result[i - 1]\n\n    return result\n\n\nlength = 5\nupdates = [[1, 3, 2], [2, 4, 3], [0, 2, -2]]\nprint(getModifiedArray(length, updates))  # [-2, 0, 3, 5, 3]\n</code></pre>"},{"location":"leetpattern/difference_array/#1109-corporate-flight-bookings","title":"1109. Corporate Flight Bookings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, prefix sum</p> </li> <li>Return the number of seats booked on each flight.</li> </ul> 1109. Corporate Flight Bookings - Python Solution<pre><code>from typing import List\n\n\n# Difference Array\ndef corpFlightBookings(bookings: List[List[int]], n: int) -&gt; List[int]:\n    \"\"\"Return the number of seats booked for each flight.\"\"\"\n    res = [0 for _ in range(n)]\n\n    for i, j, k in bookings:\n        res[i - 1] += k\n        if j &lt; n:\n            res[j] -= k\n\n    for i in range(1, n):\n        res[i] += res[i - 1]\n\n    return res\n\n\nbookings = [[1, 2, 10], [2, 3, 20], [2, 5, 25]]\nn = 5\nprint(corpFlightBookings(bookings, n))  # [10, 55, 45, 25, 25]\n</code></pre>"},{"location":"leetpattern/difference_array/#2848-points-that-intersect-with-cars","title":"2848. Points That Intersect With Cars","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, prefix sum</p> </li> <li>Return the number of points that intersect with cars.</li> </ul> 2848. Points That Intersect With Cars - Python Solution<pre><code>from itertools import accumulate\nfrom typing import List\n\n\n# Differnce Array\ndef numberOfPoints(nums: List[List[int]]) -&gt; int:\n    max_end = max(end for _, end in nums)\n\n    diff = [0] * (max_end + 2)\n\n    for start, end in nums:\n        diff[start] += 1\n        diff[end + 1] -= 1\n\n    return sum(s &gt; 0 for s in accumulate(diff))\n\n\nnums = [[3, 6], [1, 5], [4, 7]]\nprint(numberOfPoints(nums))  # 7\n</code></pre>"},{"location":"leetpattern/dp_01_knapsack/","title":"DP 01 Knapsack","text":"<ul> <li> 416. Partition Equal Subset Sum (Medium)</li> <li> 474. Ones and Zeroes (Medium)</li> <li> 494. Target Sum (Medium)</li> <li> 1046. Last Stone Weight (Easy)</li> <li> 1049. Last Stone Weight II (Medium)</li> </ul>"},{"location":"leetpattern/dp_01_knapsack/#416-partition-equal-subset-sum","title":"416. Partition Equal Subset Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul> 416. Partition Equal Subset Sum - Python Solution<pre><code>from typing import List\n\nfrom template import knapsack01\n\n\n# DP - Knapsack 01\ndef canPartitionTemplate(nums: List[int]) -&gt; bool:\n    total = sum(nums)\n\n    if total % 2 == 1 or len(nums) &lt; 2:\n        return False\n\n    target = total // 2\n\n    return knapsack01(nums, nums, target) == target\n\n\n# DP - Knapsack 01\ndef canPartition(nums: List[int]) -&gt; bool:\n    total = sum(nums)\n\n    if total % 2 == 1 or len(nums) &lt; 2:\n        return False\n\n    target = total // 2\n\n    dp = [0 for _ in range(target + 1)]\n\n    for i in range(len(nums)):\n        for j in range(target, nums[i] - 1, -1):\n            dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])\n\n    return dp[target] == target\n\n\nnums = [1, 5, 11, 5]\nprint(canPartitionTemplate(nums))  # True\nprint(canPartition(nums))  # True\n</code></pre>"},{"location":"leetpattern/dp_01_knapsack/#474-ones-and-zeroes","title":"474. Ones and Zeroes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, dynamic programming</p> </li> </ul> 474. Ones and Zeroes - Python Solution<pre><code>from typing import List\n\n\ndef findMaxForm(strs: List[str], m: int, n: int) -&gt; int:\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for s in strs:\n        zerosNum = s.count(\"0\")\n        onesNum = len(s) - zerosNum\n\n        for i in range(m, zerosNum - 1, -1):\n            for j in range(n, onesNum - 1, -1):\n                dp[i][j] = max(dp[i][j], dp[i - zerosNum][j - onesNum] + 1)\n\n    return dp[m][n]\n\n\nstrs = [\"10\", \"0001\", \"111001\", \"1\", \"0\"]\nm = 5\nn = 3\nprint(findMaxForm(strs, m, n))  # 4\n</code></pre>"},{"location":"leetpattern/dp_01_knapsack/#494-target-sum","title":"494. Target Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, backtracking</p> </li> </ul> 494. Target Sum - Python Solution<pre><code>from typing import List\n\n\ndef findTargetSumWays(nums: List[int], target: int) -&gt; int:\n\n    totalSum = sum(nums)\n\n    if abs(target) &gt; totalSum:\n        return 0\n    if (target + totalSum) % 2 == 1:\n        return 0\n\n    targetSum = (target + totalSum) // 2\n    dp = [0] * (targetSum + 1)\n    dp[0] = 1\n\n    for i in range(len(nums)):\n        for j in range(targetSum, nums[i] - 1, -1):\n            dp[j] += dp[j - nums[i]]\n\n    return dp[targetSum]\n\n\nnums = [1, 1, 1, 1, 1]\ntarget = 3\nprint(findTargetSumWays(nums, target))  # 5\n</code></pre>"},{"location":"leetpattern/dp_01_knapsack/#1046-last-stone-weight","title":"1046. Last Stone Weight","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, heap priority queue</p> </li> </ul> 1046. Last Stone Weight - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Heap\ndef lastStoneWeightHeap(stones: List[int]) -&gt; int:\n    heap = [-stone for stone in stones]\n    heapq.heapify(heap)\n\n    while len(heap) &gt; 1:\n        s1 = heapq.heappop(heap)\n        s2 = heapq.heappop(heap)\n\n        if s1 != s2:\n            heapq.heappush(heap, s1 - s2)\n\n    return -heap[0] if heap else 0\n\n\n# 0/1 Knapsack\ndef lastStoneWeightKnapsack(stones: List[int]) -&gt; int:\n    total = sum(stones)\n    target = total // 2\n\n    dp = [0 for _ in range(target + 1)]\n\n    for i in stones:\n        for j in range(target, i - 1, -1):\n            dp[j] = max(dp[j], dp[j - i] + i)\n\n    return total - 2 * dp[target]\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Heap     |   O(n log n)    |     O(n)     |\n# |  Knapsack   |      O(n)       |     O(n)     |\n# |-------------|-----------------|--------------|\n\n\nstones = [2, 7, 4, 1, 8, 1]\nprint(lastStoneWeightHeap(stones))  # 1\nprint(lastStoneWeightKnapsack(stones))  # 1\n</code></pre>"},{"location":"leetpattern/dp_01_knapsack/#1049-last-stone-weight-ii","title":"1049. Last Stone Weight II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul> 1049. Last Stone Weight II - Python Solution<pre><code>from typing import List\n\n\ndef lastStoneWeightII(stones: List[int]) -&gt; int:\n    target = sum(stones) // 2\n\n    dp = [0 for _ in range(target + 1)]\n\n    for i in range(len(stones)):\n        for j in range(target, stones[i] - 1, -1):\n            dp[j] = max(dp[j], dp[j - stones[i]] + stones[i])\n\n    result = (sum(stones) - dp[target]) - dp[target]\n\n    return result\n\n\nstones = [2, 7, 4, 1, 8, 1]\nprint(lastStoneWeightII(stones))  # 1\n</code></pre>"},{"location":"leetpattern/dp_2d/","title":"DP 2D","text":"<ul> <li> 118. Pascal's Triangle (Easy)</li> <li> 119. Pascal's Triangle II (Easy)</li> <li> 62. Unique Paths (Medium)</li> <li> 63. Unique Paths II (Medium)</li> </ul>"},{"location":"leetpattern/dp_2d/#118-pascals-triangle","title":"118. Pascal's Triangle","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li>Generate the first <code>numRows</code> of Pascal's triangle.</li> </ul> <pre><code>                 numRows    index\n     1              1         0\n    1 1             2         1\n   1 2 1            3         2\n  1 3 3 1           4         3\n 1 4 6 4 1          5         4\n</code></pre> 118. Pascal's Triangle - Python Solution<pre><code>from typing import List\n\n\ndef generate(numRows: int) -&gt; List[List[int]]:\n    dp = [[1] * i for i in range(1, numRows + 1)]\n\n    if numRows &lt;= 2:\n        return dp\n\n    for i in range(2, numRows):\n        for j in range(1, i):\n            dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n\n    return dp\n\n\nprint(generate(numRows=5))\n#     [[1],\n#    [1, 1],\n#   [1, 2, 1],\n#  [1, 3, 3, 1],\n# [1, 4, 6, 4, 1]]\n</code></pre>"},{"location":"leetpattern/dp_2d/#119-pascals-triangle-ii","title":"119. Pascal's Triangle II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li>Return the <code>rowIndex</code>th row of Pascal's triangle.</li> </ul> 119. Pascal's Triangle II - Python Solution<pre><code>from typing import List\n\n\ndef getRow(rowIndex: int) -&gt; List[int]:\n    dp = [[1] * (i + 1) for i in range(rowIndex + 1)]\n\n    if rowIndex &lt;= 1:\n        return dp[rowIndex]\n\n    for i in range(2, rowIndex + 1):\n        for j in range(1, i):\n            dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n\n    return dp[-1]\n\n\nprint(getRow(rowIndex=3))  # [1, 3, 3, 1]\n</code></pre>"},{"location":"leetpattern/dp_2d/#62-unique-paths","title":"62. Unique Paths","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, combinatorics</p> </li> <li>Count the number of unique paths to reach the bottom-right corner of a <code>m x n</code> grid.</li> </ul> <p></p> 62. Unique Paths - Python Solution<pre><code># DP - 2D\ndef uniquePaths(m: int, n: int) -&gt; int:\n    if m == 1 or n == 1:\n        return 1\n\n    dp = [[1] * n for _ in range(m)]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]\n\n\nprint(uniquePaths(m=3, n=7))  # 28\n# [[1, 1, 1,  1,  1,  1,  1],\n#  [1, 2, 3,  4,  5,  6,  7],\n#  [1, 3, 6, 10, 15, 21, 28]]\n</code></pre>"},{"location":"leetpattern/dp_2d/#63-unique-paths-ii","title":"63. Unique Paths II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, matrix</p> </li> <li>Count the number of unique paths to reach the bottom-right corner of a <code>m x n</code> grid with obstacles.</li> </ul> <p></p> 63. Unique Paths II - Python Solution<pre><code>from typing import List\n\n\n# DP - 2D\ndef uniquePathsWithObstacles(obstacleGrid: List[List[int]]) -&gt; int:\n    if obstacleGrid[0][0] == 1 or obstacleGrid[-1][-1] == 1:\n        return 0\n\n    m, n = len(obstacleGrid), len(obstacleGrid[0])\n    dp = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n        if obstacleGrid[i][0] == 0:\n            dp[i][0] = 1\n        else:\n            break\n\n    for j in range(n):\n        if obstacleGrid[0][j] == 0:\n            dp[0][j] = 1\n        else:\n            break\n\n    for i in range(1, m):\n        for j in range(1, n):\n            if obstacleGrid[i][j] == 1:\n                continue\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]\n\n\nobstacleGrid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\nprint(uniquePathsWithObstacles(obstacleGrid))  # 2\n# [[1, 1, 1],\n#  [1, 0, 1],\n#  [1, 1, 2]]\n</code></pre>"},{"location":"leetpattern/dp_basic/","title":"DP Basic","text":"<ul> <li> 509. Fibonacci Number (Easy)</li> <li> 70. Climbing Stairs (Easy)</li> <li> 746. Min Cost Climbing Stairs (Easy)</li> <li> 198. House Robber (Medium)</li> <li> 213. House Robber II (Medium)</li> <li> 376. Wiggle Subsequence (Medium)</li> <li> 343. Integer Break (Medium)</li> <li> 1025. Divisor Game (Easy)</li> </ul>"},{"location":"leetpattern/dp_basic/#509-fibonacci-number","title":"509. Fibonacci Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, dynamic programming, recursion, memoization</p> </li> <li>Return the <code>n-th</code> Fibonacci number.</li> <li><code>dp[n]</code> stores the <code>n-th</code> Fibonacci number.</li> <li>Formula: <code>dp[n] = dp[n - 1] + dp[n - 2]</code>.</li> <li>Initialize <code>dp[0] = 0</code> and <code>dp[1] = 1</code>.</li> </ul> n <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n]</code> 0 - - 0 1 - 0 1 2 0 1 1 3 1 1 2 4 1 2 3 5 2 3 5 6 3 5 8 7 5 8 13 8 8 13 21 9 13 21 34 10 21 34 55 509. Fibonacci Number - Python Solution<pre><code># DP\ndef fibDP(n: int) -&gt; int:\n    if n &lt;= 1:\n        return n\n\n    dp = [i for i in range(n + 1)]\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\n# Recursive\ndef fibRecursive(n: int) -&gt; int:\n    if n &lt;= 1:\n        return n\n\n    return fibRecursive(n - 1) + fibRecursive(n - 2)\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |     DP      |      O(n)       |     O(n)     |\n# |  Recursive  |     O(2^n)      |     O(n)     |\n# |-------------|-----------------|--------------|\n\n\nn = 10\nprint(fibDP(n))  # 55\nprint(fibRecursive(n))  # 55\n</code></pre>"},{"location":"leetpattern/dp_basic/#70-climbing-stairs","title":"70. Climbing Stairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, dynamic programming, memoization</p> </li> <li>Return the number of distinct ways to reach the top of the stairs.</li> <li><code>dp[n]</code> stores the number of distinct ways to reach the <code>n-th</code> stair.</li> <li>Formula: <code>dp[n] = dp[n - 1] + dp[n - 2]</code>.</li> <li>Initialize <code>dp[0] = 0</code>, <code>dp[1] = 1</code>, and <code>dp[2] = 2</code>.</li> </ul> n <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n]</code> 0 - - 0 1 - - 1 2 - 1 2 3 1 2 3 4 2 3 5 5 3 5 8 6 5 8 13 7 8 13 21 8 13 21 34 9 21 34 55 10 34 55 89 70. Climbing Stairs - Python Solution<pre><code># DP\ndef climbStairs(n: int) -&gt; int:\n    if n &lt;= 1:\n        return n\n\n    dp = [i for i in range(n + 1)]\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |     DP      |      O(n)       |     O(n)     |\n# |-------------|-----------------|--------------|\n\nprint(climbStairs(10))  # 89\n</code></pre>"},{"location":"leetpattern/dp_basic/#746-min-cost-climbing-stairs","title":"746. Min Cost Climbing Stairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li> <p>Return the minimum cost to reach the top of the stairs.</p> </li> <li> <p><code>dp[n]</code> stores the minimum cost to reach the <code>n-th</code> stair.</p> </li> <li>Formula: <code>dp[n] = cost[n] + min(dp[n - 1], dp[n - 2])</code>.</li> <li>Initialize <code>dp[0] = cost[0]</code> and <code>dp[1] = cost[1]</code>.</li> <li> <p>Return <code>min(dp[-1], dp[-2])</code>.</p> </li> <li> <p>Example: <code>cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</code></p> </li> </ul> n <code>cost[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n]</code> 0 1 - - 1 1 100 - 1 100 2 1 1 100 2 3 1 100 2 3 4 1 2 3 3 5 100 3 3 103 6 1 3 103 4 7 1 103 4 5 8 100 4 5 104 9 1 5 104 6 746. Min Cost Climbing Stairs - Python Solution<pre><code>from typing import List\n\n\ndef minCostClimbingStairs(cost: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(cost))]\n\n    dp[0], dp[1] = cost[0], cost[1]\n\n    for i in range(2, len(cost)):\n        dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]\n    print(dp)\n    return min(dp[-1], dp[-2])\n\n\ncost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]\nprint(minCostClimbingStairs(cost))  # 6\n</code></pre>"},{"location":"leetpattern/dp_basic/#198-house-robber","title":"198. House Robber","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li> <p>Return the maximum amount of money that can be robbed from the houses. No two adjacent houses can be robbed.</p> </li> <li> <p><code>dp[n]</code> stores the maximum amount of money that can be robbed from the first <code>n</code> houses.</p> </li> <li>Formula: <code>dp[n] = max(dp[n - 1], dp[n - 2] + nums[n])</code>.<ul> <li>Skip: <code>dp[n]</code> \u2192 <code>dp[n - 1]</code></li> <li>Rob: <code>dp[n]</code> \u2192 <code>dp[n - 2] + nums[n]</code></li> </ul> </li> <li>Initialize <code>dp[0] = nums[0]</code> and <code>dp[1] = max(nums[0], nums[1])</code>.</li> <li>Return <code>dp[-1]</code>.</li> <li>Example: <code>nums = [2, 7, 9, 3, 1]</code></li> </ul> n <code>nums[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n-2] + nums[n]</code> <code>dp[n]</code> 0 2 - 2 - 2 1 7 - 7 - 7 2 9 2 7 11 11 3 3 7 11 10 11 4 1 11 11 12 12 198. House Robber - Python Solution<pre><code>from typing import List\n\n\n# DP (House Robber)\ndef rob1(nums: List[int]) -&gt; int:\n    if len(nums) &lt; 3:\n        return max(nums)\n\n    dp = [0 for _ in range(len(nums))]\n    dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n    for i in range(2, len(nums)):\n        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n    return dp[-1]\n\n\n# DP (House Robber) Optimized\ndef rob2(nums: List[int]) -&gt; int:\n    f0, f1 = 0, 0\n\n    for num in nums:\n        f0, f1 = f1, max(f1, f0 + num)\n\n    return f1\n\n\nnums = [2, 7, 9, 3, 1]\nprint(rob1(nums))  # 12\nprint(rob2(nums))  # 12\n</code></pre> 198. House Robber - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int rob(vector&lt;int&gt; &amp;nums)\n    {\n        int prev = 0, cur = 0;\n\n        for (int num : nums)\n        {\n            int temp = cur;\n            cur = max(cur, prev + num);\n            prev = temp;\n        }\n        return cur;\n    }\n};\n\nint main()\n{\n    vector&lt;int&gt; nums = {2, 7, 9, 3, 1};\n    Solution obj;\n    int result = obj.rob(nums);\n    cout &lt;&lt; result &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"leetpattern/dp_basic/#213-house-robber-ii","title":"213. House Robber II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li>Return the maximum amount of money that can be robbed from the houses arranged in a circle.</li> <li>Circular \u2192 Linear: <code>nums[0]</code> and <code>nums[-1]</code> cannot be robbed together.</li> <li>Rob from <code>0</code> to <code>n - 2</code></li> </ul> n <code>nums[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n-2] + nums[n]</code> <code>dp[n]</code> 0 2 - 2 - 2 1 7 - 7 - 7 2 9 2 7 11 11 3 3 7 11 10 11 <ul> <li>Rob from <code>1</code> to <code>n - 1</code></li> </ul> n <code>nums[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n-2] + nums[n]</code> <code>dp[n]</code> 1 7 - - - 7 2 9 - 7 - 9 3 3 7 9 10 10 4 1 9 10 10 10 213. House Robber II - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef rob(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 3:\n        return max(nums)\n\n    def robLinear(nums: List[int]) -&gt; int:\n        dp = [0 for _ in range(len(nums))]\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n        return dp[-1]\n\n    # circle -&gt; linear\n    a = robLinear(nums[1:])  # 2nd house to the last house\n    b = robLinear(nums[:-1])  # 1st house to the 2nd last house\n\n    return max(a, b)\n\n\nnums = [2, 7, 9, 3, 1]\nprint(rob(nums))  # 11\n</code></pre>"},{"location":"leetpattern/dp_basic/#376-wiggle-subsequence","title":"376. Wiggle Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> <li>Return the length of the longest wiggle subsequence.</li> <li><code>up[n]</code> stores the length of the longest wiggle subsequence ending at <code>n</code> with a rising wiggle.</li> <li><code>down[n]</code> stores the length of the longest wiggle subsequence ending at <code>n</code> with a falling wiggle.</li> <li>Initialize <code>up[0] = 1</code> and <code>down[0] = 1</code>.</li> <li>Example: <code>nums = [1, 7, 4, 9, 2, 5]</code></li> </ul> <code>nums[n]</code> <code>nums[n-1]</code> <code>up[n-1]</code> <code>down[n-1]</code> <code>up[n]</code> <code>down[n]</code> 1 - - - 1 1 7 1 1 1 2 1 4 7 2 1 2 3 9 4 2 3 4 3 2 9 4 3 4 5 5 2 4 5 6 5 376. Wiggle Subsequence - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef wiggleMaxLengthDP(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 1:\n        return len(nums)\n\n    up = [0 for _ in range(len(nums))]\n    down = [0 for _ in range(len(nums))]\n\n    up[0], down[0] = 1, 1\n\n    for i in range(1, len(nums)):\n        if nums[i] &gt; nums[i - 1]:\n            up[i] = down[i - 1] + 1\n            down[i] = down[i - 1]\n        elif nums[i] &lt; nums[i - 1]:\n            down[i] = up[i - 1] + 1\n            up[i] = up[i - 1]\n        else:\n            up[i] = up[i - 1]\n            down[i] = down[i - 1]\n\n    return max(up[-1], down[-1])\n\n\n# Greedy\ndef wiggleMaxLengthGreedy(nums: List[int]) -&gt; int:\n    if len(nums) &lt; 2:\n        return len(nums)\n\n    prev_diff = nums[1] - nums[0]\n    count = 2 if prev_diff != 0 else 1\n\n    for i in range(2, len(nums)):\n        diff = nums[i] - nums[i - 1]\n        if (diff &gt; 0 and prev_diff &lt;= 0) or (diff &lt; 0 and prev_diff &gt;= 0):\n            count += 1\n            prev_diff = diff\n\n    return count\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    DP       |      O(n)       |     O(n)     |\n# |  Greedy     |      O(n)       |     O(1)     |\n# |-------------|-----------------|--------------|\n\nnums = [1, 7, 4, 9, 2, 5]\nprint(wiggleMaxLengthDP(nums))  # 6\nprint(wiggleMaxLengthGreedy(nums))  # 6\n</code></pre>"},{"location":"leetpattern/dp_basic/#343-integer-break","title":"343. Integer Break","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming</p> </li> <li>Return the maximum product of the integer after breaking it into at least two positive integers.</li> <li><code>dp[i]</code> stores the maximum product of the integer <code>i</code>.</li> <li>Formula: <code>dp[i] = max(dp[i - j] * j, (i - j) * j)</code></li> </ul> dp 3 4 5 6 7 8 2 2*1=2 2*2=4 2*3=6 2*4=8 2*5=10 2*6=12 dp[2]=1 1*1=2 1*2=2 1*3=3 1*4=4 1*5=5 1*6=6 3 3*1=3 3*2=6 3*3=9 3*4=12 3*5=15 dp[3]=2 2*1=2 2*2=4 2*3=6 2*4=8 2*5=10 4 4*1=4 4*2=8 4*3=12 4*4=16 dp[4]=4 4*1=4 4*2=8 4*3=12 4*4=16 5 5*1=5 5*2=10 5*3=15 dp[5]=6 6*1=6 6*2=12 6*3=18 6 6*1=6 6*2=12 dp[6]=9 9*1=9 9*2=18 7 7*1=7 dp[7]=12 12*1=12 <code>dp[n]</code> 2 4 6 9 12 18 343. Integer Break - Python Solution<pre><code>def integerBreak(n: int) -&gt; int:\n    dp = [0 for _ in range(n + 1)]\n    dp[2] = 1\n\n    for i in range(3, n + 1):\n        for j in range(2, i):\n            dp[i] = max(dp[i], dp[i - j] * j, (i - j) * j)\n\n    return dp[n]\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    DP       |      O(n^2)     |     O(n)     |\n# |-------------|-----------------|--------------|\n\nn = 8\nprint(integerBreak(n))  # 18\n</code></pre>"},{"location":"leetpattern/dp_basic/#1025-divisor-game","title":"1025. Divisor Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, dynamic programming, brainteaser, game theory</p> </li> <li>Return <code>True</code> if Alice wins the game, assuming both players play optimally.</li> <li><code>dp[n]</code> stores the result of the game when the number is <code>n</code>.</li> <li>Initialize <code>dp[1] = False</code>.</li> </ul> 1025. Divisor Game - Python Solution<pre><code># DP\ndef divisorGameDP(n: int) -&gt; bool:\n    if n &lt;= 1:\n        return False\n\n    dp = [False for _ in range(n + 1)]\n\n    for i in range(2, n + 1):\n        for j in range(1, i):\n            if i % j == 0 and not dp[i - j]:\n                dp[i] = True\n                break\n\n    return dp[n]\n\n\n# Math\ndef divisorGameDPMath(n: int) -&gt; bool:\n    return n % 2 == 0\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |  DP         |      O(n^2)     |    O(n)      |\n# |  Math       |      O(1)       |    O(1)      |\n# |-------------|-----------------|--------------|\n\nn = 2\nprint(divisorGameDP(n))  # True\nprint(divisorGameDPMath(n))  # True\n</code></pre>"},{"location":"leetpattern/dp_interval/","title":"DP Interval","text":"<ul> <li> 516. Longest Palindromic Subsequence (Medium)</li> <li> 647. Palindromic Substrings (Medium)</li> <li> 5. Longest Palindromic Substring (Medium)</li> </ul>"},{"location":"leetpattern/dp_interval/#516-longest-palindromic-subsequence","title":"516. Longest Palindromic Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> <li>Return the length of the longest palindromic subsequence in <code>s</code>.</li> <li>Bottom-up DP table</li> </ul> dp b b b a b b 1 2 3 3 4 b 0 1 2 2 3 <code>dp[i][j]</code> b 0 0 1 1 <code>dp[i+1][j-1]</code> 2 a 0 0 0 1 1 b 0 0 0 0 1 516. Longest Palindromic Subsequence - Python Solution<pre><code>def longestPalindromeSubseq(s: str) -&gt; int:\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            if s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])\n\n    return dp[0][-1]\n\n\nprint(longestPalindromeSubseq(\"bbbab\"))  # 4\n</code></pre>"},{"location":"leetpattern/dp_interval/#647-palindromic-substrings","title":"647. Palindromic Substrings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string, dynamic programming</p> </li> <li>Return the number of palindromic substrings in <code>s</code>.</li> <li>Bottom-up DP table</li> </ul> dp a b b a e a 1 0 0 1 0 b 0 1 1 0 0 b 0 0 1 0 0 a 0 0 0 1 0 e 0 0 0 0 1 647. Palindromic Substrings - Python Solution<pre><code>def countSubstrings(s: str) -&gt; int:\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    res = 0\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i, n):\n            if s[i] == s[j]:\n                if j - i &lt;= 1:\n                    dp[i][j] = 1\n                    res += 1\n                elif dp[i + 1][j - 1]:\n                    dp[i][j] = 1\n                    res += 1\n\n    return res\n\n\nprint(countSubstrings(\"abbae\"))  # 7\n</code></pre>"},{"location":"leetpattern/dp_interval/#5-longest-palindromic-substring","title":"5. Longest Palindromic Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string, dynamic programming</p> </li> <li>Return the longest palindromic substring in <code>s</code>.</li> </ul> 5. Longest Palindromic Substring - Python Solution<pre><code># DP - Interval\ndef longestPalindromeDP(s: str) -&gt; str:\n    n = len(s)\n    if n &lt;= 1:\n        return s\n\n    start, maxLen = 0, 1\n\n    # Init\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for j in range(1, n):\n        for i in range(j):\n            if s[i] == s[j]:\n                if j - i &lt;= 2:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1]\n\n                if dp[i][j] and j - i + 1 &gt; maxLen:\n                    maxLen = j - i + 1\n                    start = i\n\n    return s[start : start + maxLen]\n\n\n# Expand Around Center\ndef longestPalindromeCenter(s: str) -&gt; str:\n    def expand_around_center(left, right):\n        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n\n    if len(s) &lt;= 1:\n        return s\n\n    start, end = 0, 0\n    for i in range(len(s)):\n        len1 = expand_around_center(i, i)  # odd\n        len2 = expand_around_center(i, i + 1)  # even\n\n        maxLen = max(len1, len2)\n        if maxLen &gt; end - start:\n            start = i - (maxLen - 1) // 2\n            end = i + maxLen // 2\n\n    return s[start : end + 1]\n\n\ns = \"babad\"\nprint(longestPalindromeDP(s))  # \"bab\"\nprint(longestPalindromeCenter(s))  # \"aba\"\n</code></pre>"},{"location":"leetpattern/dp_kadane/","title":"DP Kadane","text":"<ul> <li> 53. Maximum Subarray (Medium)</li> <li> 918. Maximum Sum Circular Subarray (Medium)</li> <li> 152. Maximum Product Subarray (Medium)</li> <li> 978. Longest Turbulent Subarray (Medium)</li> <li> 1186. Maximum Subarray Sum with One Deletion (Medium)</li> </ul>"},{"location":"leetpattern/dp_kadane/#53-maximum-subarray","title":"53. Maximum Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, divide and conquer, dynamic programming</p> </li> </ul> 53. Maximum Subarray - Python Solution<pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxSubArrayDP(nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n\n    dp[0] = nums[0]\n    maxSum = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(\n            dp[i - 1] + nums[i],  # continue the previous subarray\n            nums[i],  # start a new subarray\n        )\n        maxSum = max(maxSum, dp[i])\n\n    return maxSum\n\n\n# Greedy\ndef maxSubArrayGreedy(nums: List[int]) -&gt; int:\n    max_sum = nums[0]\n    cur_sum = 0\n\n    for num in nums:\n        cur_sum = max(cur_sum + num, num)\n        max_sum = max(max_sum, cur_sum)\n\n    return max_sum\n\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArrayDP(nums))  # 6\nprint(maxSubArrayGreedy(nums))  # 6\n</code></pre>"},{"location":"leetpattern/dp_kadane/#918-maximum-sum-circular-subarray","title":"918. Maximum Sum Circular Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, divide and conquer, dynamic programming, queue, monotonic queue</p> </li> </ul> 918. Maximum Sum Circular Subarray - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# DP - Kadane\ndef maxSubarraySumCircularKadane(nums: List[int]) -&gt; int:\n    max_sum = min_sum = nums[0]\n    max_cur = min_cur = 0\n    total = 0\n\n    for num in nums:\n        max_cur = max(max_cur + num, num)\n        min_cur = min(min_cur + num, num)\n        total += num\n\n        max_sum = max(max_sum, max_cur)\n        min_sum = min(min_sum, min_cur)\n\n    return max(max_sum, total - min_sum) if max_sum &gt; 0 else max_sum\n\n\n# Monotonic Queue\ndef maxSubarraySumCircularMQ(nums: List[int]) -&gt; int:\n    n = len(nums)\n    prefix_sum = [0] * (2 * n + 1)\n\n    for i in range(1, 2 * n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + nums[(i - 1) % n]\n\n    q = deque([0])\n    max_sum = float(\"-inf\")\n\n    for i in range(1, 2 * n + 1):\n        if q[0] &lt; i - n:\n            q.popleft()\n\n        max_sum = max(max_sum, prefix_sum[i] - prefix_sum[q[0]])\n\n        while q and prefix_sum[q[-1]] &gt;= prefix_sum[i]:\n            q.pop()\n\n        q.append(i)\n\n    return max_sum\n\n\nnums = [1, -2, 3, -2]\nprint(maxSubarraySumCircularKadane(nums))  # 3\nprint(maxSubarraySumCircularMQ(nums))  # 3\n</code></pre>"},{"location":"leetpattern/dp_kadane/#152-maximum-product-subarray","title":"152. Maximum Product Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul> 152. Maximum Product Subarray - Python Solution<pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxProduct(nums: List[int]) -&gt; int:\n    n = len(nums)\n    dp_max = [0 for _ in range(n)]\n    dp_min = [0 for _ in range(n)]\n\n    dp_max[0] = nums[0]\n    dp_min[0] = nums[0]\n    max_product = nums[0]\n\n    for i in range(1, n):\n        dp_max[i] = max(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n        dp_min[i] = min(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n\n        max_product = max(max_product, dp_max[i])\n\n    return max_product\n\n\nnums = [2, 3, -2, 4]\nprint(maxProduct(nums))  # 6\n</code></pre>"},{"location":"leetpattern/dp_kadane/#978-longest-turbulent-subarray","title":"978. Longest Turbulent Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, sliding window</p> </li> </ul> 978. Longest Turbulent Subarray - Python Solution<pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxTurbulenceSize(arr: List[int]) -&gt; int:\n    n = len(arr)\n    up = [1 for _ in range(n)]\n    down = [1 for _ in range(n)]\n    maxLen = 1\n\n    for i in range(1, n):\n        if arr[i - 1] &lt; arr[i]:\n            up[i] = down[i - 1] + 1\n            down[i] = 1\n        elif arr[i - 1] &gt; arr[i]:\n            down[i] = up[i - 1] + 1\n            up[i] = 1\n        else:\n            up[i] = 1\n            down[i] = 1\n\n        maxLen = max(maxLen, up[i], down[i])\n\n    return maxLen\n\n\narr = [9, 4, 2, 10, 7, 8, 8, 1, 9]\nprint(maxTurbulenceSize(arr))  # 5\n</code></pre>"},{"location":"leetpattern/dp_kadane/#1186-maximum-subarray-sum-with-one-deletion","title":"1186. Maximum Subarray Sum with One Deletion","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul> 1186. Maximum Subarray Sum with One Deletion - Python Solution<pre><code>from typing import List\n\n\n# DP - Kadane\ndef maximumSum(arr: List[int]) -&gt; int:\n    dp0 = arr[0]\n    dp1 = 0\n    maxSum = dp0\n\n    for i in range(1, len(arr)):\n        dp1 = max(dp1 + arr[i], dp0)  # delete previous element or not\n        dp0 = max(dp0, 0) + arr[i]  # delete current element or not\n        maxSum = max(maxSum, dp0, dp1)  # update result\n\n    return maxSum\n\n\narr = [1, -2, 0, 3]\nprint(maximumSum(arr))  # 4\n</code></pre>"},{"location":"leetpattern/dp_lcs/","title":"DP LCS","text":"<ul> <li> 1143. Longest Common Subsequence (Medium)</li> <li> 72. Edit Distance (Medium)</li> <li> 115. Distinct Subsequences (Hard)</li> <li> 392. Is Subsequence (Easy)</li> <li> 583. Delete Operation for Two Strings (Medium)</li> <li> 674. Longest Continuous Increasing Subsequence (Easy)</li> <li> 718. Maximum Length of Repeated Subarray (Medium)</li> <li> 1035. Uncrossed Lines (Medium)</li> </ul>"},{"location":"leetpattern/dp_lcs/#1143-longest-common-subsequence","title":"1143. Longest Common Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul> 1143. Longest Common Subsequence - Python Solution<pre><code># DP - LCS\ndef longestCommonSubsequence(text1: str, text2: str) -&gt; int:\n    m, n = len(text1), len(text2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    res = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i - 1] == text2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])\n\n            if res &lt; dp[i][j]:\n                res = dp[i][j]\n\n    return res\n\n\ntext1 = \"abcde\"\ntext2 = \"ace\"\nprint(longestCommonSubsequence(text1, text2))  # 3\n</code></pre>"},{"location":"leetpattern/dp_lcs/#72-edit-distance","title":"72. Edit Distance","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul> 72. Edit Distance - Python Solution<pre><code>def minDistance(word1: str, word2: str) -&gt; int:\n    m = len(word1)\n    n = len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]  # no operation\n            else:\n                dp[i][j] = 1 + min(\n                    dp[i - 1][j],  # delete\n                    dp[i][j - 1],  # insert\n                    dp[i - 1][j - 1],  # replace\n                )\n    return dp[-1][-1]\n\n\nword1 = \"horse\"\nword2 = \"ros\"\nprint(minDistance(word1, word2))  # 3\n</code></pre>"},{"location":"leetpattern/dp_lcs/#115-distinct-subsequences","title":"115. Distinct Subsequences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul> 115. Distinct Subsequences - Python Solution<pre><code>def numDistinct(s: str, t: str) -&gt; int:\n    m = len(s)\n    n = len(t)\n    dp = [[0] * (n + 1) for _ in range((m + 1))]\n\n    for i in range(m):\n        dp[i][0] = 1\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                # include and exclude s[i-1]\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]  # exclude s[i-1]\n\n    return dp[-1][-1]\n\n\ns = \"rabbbit\"\nt = \"rabbit\"\nprint(numDistinct(s, t))  # 3\n</code></pre>"},{"location":"leetpattern/dp_lcs/#392-is-subsequence","title":"392. Is Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string, dynamic programming</p> </li> </ul> 392. Is Subsequence - Python Solution<pre><code># DP - LCS\ndef isSubsequenceLCS(s: str, t: str) -&gt; bool:\n    m = len(s)\n    n = len(t)\n\n    if m &gt; n:\n        return False\n\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    length = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = dp[i][j - 1]  # only delete t string\n\n            if length &lt; dp[i][j]:\n                length = dp[i][j]\n\n    return length == m\n\n\n# Two Pointers\ndef isSubsequenceTP(s: str, t: str) -&gt; bool:\n    i, j = 0, 0\n\n    while i &lt; len(s) and j &lt; len(t):\n        if s[i] == t[j]:\n            i += 1\n        j += 1\n\n    return i == len(s)\n\n\ns = \"abc\"\nt = \"ahbgdc\"\nprint(isSubsequenceLCS(s, t))  # True\nprint(isSubsequenceTP(s, t))  # True\n</code></pre>"},{"location":"leetpattern/dp_lcs/#583-delete-operation-for-two-strings","title":"583. Delete Operation for Two Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul> 583. Delete Operation for Two Strings - Python Solution<pre><code># DP - LCS\ndef minDistance1(word1: str, word2: str) -&gt; int:\n    m = len(word1)\n    n = len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]  # no need to delete\n            else:\n                dp[i][j] = min(\n                    dp[i - 1][j] + 1,  # delete word1[i]\n                    dp[i][j - 1] + 1,  # delete word2[j]\n                    dp[i - 1][j - 1] + 2,  # delete both\n                )\n    return dp[-1][-1]\n\n\n# DP - LCS\ndef minDistance2(word1: str, word2: str) -&gt; int:\n    def LCS(word1: str, word2: str) -&gt; int:\n        m = len(word1)\n        n = len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        lcs = 0\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n                if lcs &lt; dp[i][j]:\n                    lcs = dp[i][j]\n        return lcs\n\n    lcs = LCS(word1, word2)\n    return len(word1) + len(word2) - 2 * lcs\n\n\nword1 = \"sea\"\nword2 = \"eat\"\nprint(minDistance1(word1, word2))  # 2\nprint(minDistance2(word1, word2))  # 2\n</code></pre>"},{"location":"leetpattern/dp_lcs/#674-longest-continuous-increasing-subsequence","title":"674. Longest Continuous Increasing Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array</p> </li> </ul> 674. Longest Continuous Increasing Subsequence - Python Solution<pre><code>from typing import List\n\n\ndef findLengthOfLCIS(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1:\n        return n\n\n    dp = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        if nums[i] &gt; nums[i - 1]:\n            dp[i] = dp[i - 1] + 1\n\n    return max(dp)\n\n\nprint(findLengthOfLCIS([1, 3, 5, 4, 7]))  # 3\n</code></pre>"},{"location":"leetpattern/dp_lcs/#718-maximum-length-of-repeated-subarray","title":"718. Maximum Length of Repeated Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, dynamic programming, sliding window, rolling hash, hash function</p> </li> </ul> 718. Maximum Length of Repeated Subarray - Python Solution<pre><code>from typing import List\n\n\ndef findLength(nums1: List[int], nums2: List[int]) -&gt; int:\n    m = len(nums1)\n    n = len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    length = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if nums1[i - 1] == nums2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            if length &lt; dp[i][j]:\n                length = dp[i][j]\n\n    return length\n\n\nprint(findLength([1, 2, 3, 2, 1], [3, 2, 1, 4, 7]))  # 3\n</code></pre>"},{"location":"leetpattern/dp_lcs/#1035-uncrossed-lines","title":"1035. Uncrossed Lines","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul> 1035. Uncrossed Lines - Python Solution<pre><code>from typing import List\n\n\ndef maxUncrossedLines(nums1: List[int], nums2: List[int]) -&gt; int:\n    m = len(nums1)\n    n = len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    num = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if nums1[i - 1] == nums2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n            if num &lt; dp[i][j]:\n                num = dp[i][j]\n\n    return num\n\n\nprint(maxUncrossedLines([1, 4, 2], [1, 2, 4]))  # 2\n</code></pre>"},{"location":"leetpattern/dp_lis/","title":"DP LIS","text":"<ul> <li> 300. Longest Increasing Subsequence (Medium)</li> <li> 673. Number of Longest Increasing Subsequence (Medium)</li> <li> 354. Russian Doll Envelopes (Hard)</li> <li> 960. Delete Columns to Make Sorted III (Hard)</li> <li> 1671. Minimum Number of Removals to Make Mountain Array (Hard)</li> <li> 941. Valid Mountain Array (Easy)</li> <li> 845. Longest Mountain in Array (Medium)</li> </ul>"},{"location":"leetpattern/dp_lis/#300-longest-increasing-subsequence","title":"300. Longest Increasing Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, dynamic programming</p> </li> </ul> 300. Longest Increasing Subsequence - Python Solution<pre><code>from typing import List\n\n\n# DP - LIS\ndef lengthOfLIS(nums: List[int]) -&gt; int:\n    # TC: O(n^2)\n    # SC: O(n)\n    n = len(nums)\n    if n &lt;= 1:\n        return n\n\n    dp = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] &gt; nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\n\nnums = [10, 9, 2, 5, 3, 7, 101, 18]\nprint(lengthOfLIS(nums))  # 4\n</code></pre>"},{"location":"leetpattern/dp_lis/#673-number-of-longest-increasing-subsequence","title":"673. Number of Longest Increasing Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, binary indexed tree, segment tree</p> </li> </ul> 673. Number of Longest Increasing Subsequence - Python Solution<pre><code>from typing import List\n\n\n# DP - LIS\ndef findNumberOfLIS(nums: List[int]) -&gt; int:\n    if not nums:\n        return 0\n\n    n = len(nums)\n    dp = [1 for _ in range(n)]\n    counts = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] &gt; nums[j]:\n                if dp[j] + 1 &gt; dp[i]:\n                    dp[i] = dp[j] + 1\n                    counts[i] = counts[j]\n                elif dp[j] + 1 == dp[i]:\n                    counts[i] += counts[j]\n\n    longest = max(dp)\n    return sum(c for i, c in enumerate(counts) if dp[i] == longest)\n\n\nnums = [1, 3, 5, 4, 7]\nprint(findNumberOfLIS(nums))  # 2\n</code></pre>"},{"location":"leetpattern/dp_lis/#354-russian-doll-envelopes","title":"354. Russian Doll Envelopes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, dynamic programming, sorting</p> </li> </ul> 354. Russian Doll Envelopes - Python Solution<pre><code>from typing import List\n\n\n# DP - LIS\ndef maxEnvelopes(envelopes: List[List[int]]) -&gt; int:\n    envelopes.sort(key=lambda x: (x[0], -x[1]))\n    dp = []\n\n    for w, h in envelopes:\n        left, right = 0, len(dp)\n        while left &lt; right:\n            mid = left + (right - left) // 2\n            if dp[mid][1] &lt; h:\n                left = mid + 1\n            else:\n                right = mid\n        if right == len(dp):\n            dp.append((w, h))\n        else:\n            dp[right] = (w, h)\n\n    return len(dp)\n\n\nenvelopes = [[5, 4], [6, 4], [6, 7], [2, 3]]\nprint(maxEnvelopes(envelopes))  # 3\n</code></pre>"},{"location":"leetpattern/dp_lis/#960-delete-columns-to-make-sorted-iii","title":"960. Delete Columns to Make Sorted III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, dynamic programming</p> </li> </ul> 960. Delete Columns to Make Sorted III - Python Solution<pre><code>from typing import List\n\n\n# DP - LIS\ndef minDeletionSize(strs: List[str]) -&gt; int:\n    if not strs:\n        return 0\n\n    n = len(strs[0])\n    dp = [1 for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i):\n            if all(row[j] &lt;= row[i] for row in strs):\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return n - max(dp)\n</code></pre>"},{"location":"leetpattern/dp_lis/#1671-minimum-number-of-removals-to-make-mountain-array","title":"1671. Minimum Number of Removals to Make Mountain Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, dynamic programming, greedy</p> </li> </ul> 1671. Minimum Number of Removals to Make Mountain Array - Python Solution<pre><code>from typing import List\n\n\n# DP - LIS\ndef minimumMountainRemovals(nums: List[int]) -&gt; int:\n    n = len(nums)\n    lis = [1 for _ in range(n)]\n    lds = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] &gt; nums[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    for i in range(n - 2, -1, -1):\n        for j in range(n - 1, i, -1):\n            if nums[i] &gt; nums[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    maxLen = 0\n    for i in range(1, n - 1):\n        if lis[i] &gt; 1 and lds[i] &gt; 1:\n            maxLen = max(maxLen, lis[i] + lds[i] - 1)\n\n    return n - maxLen\n\n\nnums = [2, 1, 1, 5, 6, 2, 3, 1]\nprint(minimumMountainRemovals(nums))  # 3\n</code></pre>"},{"location":"leetpattern/dp_lis/#941-valid-mountain-array","title":"941. Valid Mountain Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array</p> </li> </ul> 941. Valid Mountain Array - Python Solution<pre><code>from typing import List\n\n\n# Array\ndef validMountainArray(arr: List[int]) -&gt; bool:\n    n = len(arr)\n    i = 0\n\n    while i &lt; n - 1 and arr[i] &lt; arr[i + 1]:\n        i += 1\n\n    if i == 0 or i == n - 1:\n        return False\n\n    while i &lt; n - 1 and arr[i] &gt; arr[i + 1]:\n        i += 1\n\n    return i == n - 1\n\n\n# Left Right Pointers\ndef validMountainArrayLP(arr: List[int]) -&gt; bool:\n    n = len(arr)\n\n    if n &lt; 3:\n        return False\n\n    left, right = 0, n - 1\n\n    while left &lt; n - 1 and arr[left] &lt; arr[left + 1]:\n        left += 1\n\n    while right &gt; 0 and arr[right] &lt; arr[right - 1]:\n        right -= 1\n\n    return 0 &lt; left == right &lt; n - 1\n\n\narr = [0, 3, 2, 1]\nprint(validMountainArray(arr))  # True\nprint(validMountainArrayLP(arr))  # True\n</code></pre>"},{"location":"leetpattern/dp_lis/#845-longest-mountain-in-array","title":"845. Longest Mountain in Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, dynamic programming, enumeration</p> </li> </ul> 845. Longest Mountain in Array - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef longestMountain(arr: List[int]) -&gt; int:\n    n = len(arr)\n    res = 0\n    left = 0\n\n    while left &lt; n:\n        right = left\n\n        if right &lt; n - 1 and arr[right] &lt; arr[right + 1]:\n            while right &lt; n - 1 and arr[right] &lt; arr[right + 1]:\n                right += 1\n\n            if right &lt; n - 1 and arr[right] &gt; arr[right + 1]:\n                while right &lt; n - 1 and arr[right] &gt; arr[right + 1]:\n                    right += 1\n                res = max(res, right - left + 1)\n\n        left = max(right, left + 1)\n\n    return res\n\n\narr = [2, 1, 4, 7, 3, 2, 5]\nprint(longestMountain(arr))  # 5\n</code></pre>"},{"location":"leetpattern/dp_stock/","title":"DP Stock","text":"<ul> <li> 121. Best Time to Buy and Sell Stock (Easy)</li> <li> 122. Best Time to Buy and Sell Stock II (Medium)</li> <li> 123. Best Time to Buy and Sell Stock III (Hard)</li> <li> 188. Best Time to Buy and Sell Stock IV (Hard)</li> <li> 309. Best Time to Buy and Sell Stock with Cooldown (Medium)</li> <li> 714. Best Time to Buy and Sell Stock with Transaction Fee (Medium)</li> </ul>"},{"location":"leetpattern/dp_stock/#121-best-time-to-buy-and-sell-stock","title":"121. Best Time to Buy and Sell Stock","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li>Return the maximum profit that can be achieved from buying on one day and selling on another day.</li> </ul> 121. Best Time to Buy and Sell Stock - Python Solution<pre><code>from typing import List\n\n\n# Brute Force\ndef maxProfitBF(prices: List[int]) -&gt; int:\n    max_profit = 0\n    n = len(prices)\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_profit = max(max_profit, prices[j] - prices[i])\n\n    return max_profit\n\n\n# DP\ndef maxProfitDP(prices: List[int]) -&gt; int:\n    dp = [[0] * 2 for _ in range(len(prices))]\n    dp[0][0] = -prices[0]  # buy\n    dp[0][1] = 0  # sell\n\n    for i in range(1, len(prices)):\n        dp[i][0] = max(dp[i - 1][0], -prices[i])  # the lowest price to buy\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    max_profit = 0\n    seen_min = prices[0]\n\n    for i in range(1, len(prices)):\n        max_profit = max(max_profit, prices[i] - seen_min)\n        seen_min = min(seen_min, prices[i])\n\n    return max_profit\n\n\n# Fast Slow Pointers\ndef maxProfitFS(prices: List[int]) -&gt; int:\n    max_profit = 0\n    slow, fast = 0, 1\n\n    while fast &lt; len(prices):\n        if prices[fast] &gt; prices[slow]:\n            max_profit = max(max_profit, prices[fast] - prices[slow])\n        else:\n            slow = fast\n        fast += 1\n\n    return max_profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force|  O(n^2)|  O(1)   |\n# | DP         |  O(n)  |  O(n)   |\n# | Greedy     |  O(n)  |  O(1)   |\n# | Fast Slow  |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitBF(prices))  # 5\nprint(maxProfitDP(prices))  # 5\nprint(maxProfitGreedy(prices))  # 5\nprint(maxProfitFS(prices))  # 5\n</code></pre>"},{"location":"leetpattern/dp_stock/#122-best-time-to-buy-and-sell-stock-ii","title":"122. Best Time to Buy and Sell Stock II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> <li>Return the maximum profit you can achieve.</li> </ul> 122. Best Time to Buy and Sell Stock II - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef maxProfitDP1(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 2 for _ in range(n)]\n    dp[0][0] = -prices[0]\n    dp[0][1] = 0\n\n    for i in range(1, n):\n        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i])\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# DP - Optimized\ndef maxProfitDP2(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    hold = -prices[0]\n    profit = 0\n\n    for i in range(1, n):\n        hold = max(hold, profit - prices[i])\n        profit = max(profit, hold + prices[i])\n\n    return profit\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    profit = 0\n\n    for i in range(1, len(prices)):\n        profit += max(prices[i] - prices[i - 1], 0)\n\n    return profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |     DP1    |  O(n)  |   O(n)  |\n# |     DP2    |  O(n)  |   O(1)  |\n# |   Greedy   |  O(n)  |   O(1)  |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitDP1(prices))  # 7\nprint(maxProfitDP2(prices))  # 7\nprint(maxProfitGreedy(prices))  # 7\n</code></pre>"},{"location":"leetpattern/dp_stock/#123-best-time-to-buy-and-sell-stock-iii","title":"123. Best Time to Buy and Sell Stock III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul> 123. Best Time to Buy and Sell Stock III - Python Solution<pre><code>from typing import List\n\n\n# 1. DP\ndef maxProfitDP1(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 5 for _ in range(n)]\n\n    dp[0][0] = 0  # no transaction\n    dp[0][1] = -prices[0]  # buy 1\n    dp[0][2] = 0  # sell 1\n    dp[0][3] = -prices[0]  # buy 2\n    dp[0][4] = 0  # sell 2\n\n    for i in range(1, n):\n        dp[i][0] = dp[i - 1][0]\n        dp[i][1] = max(dp[i - 1][1], -prices[i])\n        dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i])\n        dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i])\n        dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i])\n\n    return dp[-1][4]\n\n\n# 2. DP - Optimized\ndef maxProfitDP2(prices: List[int]) -&gt; int:\n    b1, b2 = float(\"inf\"), float(\"inf\")\n    s1, s2 = 0, 0\n\n    for price in prices:\n        b1 = min(b1, price)\n        s1 = max(s1, price - b1)\n        b2 = min(b2, price - s1)\n        s2 = max(s2, price - b2)\n\n    return s2\n\n\nprices = [3, 3, 5, 0, 0, 3, 1, 4]\nprint(maxProfitDP1(prices))  # 6\nprint(maxProfitDP2(prices))  # 6\n</code></pre>"},{"location":"leetpattern/dp_stock/#188-best-time-to-buy-and-sell-stock-iv","title":"188. Best Time to Buy and Sell Stock IV","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul> 188. Best Time to Buy and Sell Stock IV - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef maxProfit(k: int, prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * (2 * k + 1) for _ in range(n)]\n\n    for j in range(1, 2 * k, 2):\n        dp[0][j] = -prices[0]\n\n    for i in range(1, n):\n        for j in range(0, 2 * k - 1, 2):\n            dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i])\n            dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i])\n\n    return dp[-1][2 * k]\n\n\nk = 2\nprices = [2, 4, 1]\nprint(maxProfit(k, prices))  # 2\n</code></pre>"},{"location":"leetpattern/dp_stock/#309-best-time-to-buy-and-sell-stock-with-cooldown","title":"309. Best Time to Buy and Sell Stock with Cooldown","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul> 309. Best Time to Buy and Sell Stock with Cooldown - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef maxProfit(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 4 for _ in range(n)]\n\n    dp[0][0] = -prices[0]  # poessess\n    dp[0][1] = 0  # stay sold\n    dp[0][2] = 0  # sell\n    dp[0][3] = 0  # cooldown\n\n    for i in range(1, n):\n        dp[i][0] = max(\n            dp[i - 1][0],  # stay poessess\n            dp[i - 1][1] - prices[i],  # buy after stay sold\n            dp[i - 1][3] - prices[i],  # buy after cooldown\n        )\n        dp[i][1] = max(\n            dp[i - 1][1],  # stay sold\n            dp[i - 1][3],  # stay cooldown\n        )\n        dp[i][2] = dp[i - 1][0] + prices[i]\n        dp[i][3] = dp[i - 1][2]\n\n    return max(dp[-1])\n\n\nprices = [1, 2, 3, 0, 2]\nprint(maxProfit(prices))  # 3\n</code></pre>"},{"location":"leetpattern/dp_stock/#714-best-time-to-buy-and-sell-stock-with-transaction-fee","title":"714. Best Time to Buy and Sell Stock with Transaction Fee","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> <li>Return the maximum profit you can achieve with the given transaction fee.</li> </ul> 714. Best Time to Buy and Sell Stock with Transaction Fee - Python Solution<pre><code>from typing import List\n\n\n# 1. DP\ndef maxProfitDP(prices: List[int], fee: int) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 2 for _ in range(n)]\n\n    dp[0][0] = -prices[0] - fee\n    dp[0][1] = 0\n\n    for i in range(1, n):\n        dp[i][0] = max(\n            dp[i - 1][0],  # hold\n            dp[i - 1][1] - prices[i] - fee,  # buy\n        )\n        dp[i][1] = max(\n            dp[i - 1][1],  # hold\n            dp[i - 1][0] + prices[i],  # sell\n        )\n\n    return max(dp[-1])\n\n\n# 2. Greedy\ndef maxProfitGreedy(prices: List[int], fee: int) -&gt; int:\n    n = len(prices)\n    if n == 0:\n        return 0\n\n    buy = prices[0]\n    profit = 0\n\n    for i in range(1, n):\n        if prices[i] &lt; buy:\n            buy = prices[i]\n        elif prices[i] &gt; buy + fee:\n            profit += prices[i] - buy - fee\n            buy = prices[i] - fee\n\n    return profit\n\n\nprices = [1, 3, 2, 8, 4, 9]\nfee = 2\nprint(maxProfitDP(prices, fee))  # 8\nprint(maxProfitGreedy(prices, fee))  # 8\n</code></pre>"},{"location":"leetpattern/dp_unbounded_knapsack/","title":"DP Unbounded Knapsack","text":"<ul> <li> 139. Word Break (Medium)</li> <li> 279. Perfect Squares (Medium)</li> <li> 322. Coin Change (Medium)</li> <li> 518. Coin Change II (Medium)</li> <li> 377. Combination Sum IV (Medium)</li> </ul>"},{"location":"leetpattern/dp_unbounded_knapsack/#139-word-break","title":"139. Word Break","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, dynamic programming, trie, memoization</p> </li> </ul> 139. Word Break - Python Solution<pre><code>from typing import List\n\n\n# DP - Knapsack Unbounded\ndef wordBreak(s: str, wordDict: List[str]) -&gt; bool:\n    n = len(s)\n    wordSet = set(wordDict)\n    dp = [False for _ in range(n + 1)]\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in wordSet:\n                dp[i] = True\n                break\n\n    return dp[n]\n\n\ns = \"leetcode\"\nwordDict = [\"leet\", \"code\"]\nprint(wordBreak(s, wordDict))  # True\n</code></pre>"},{"location":"leetpattern/dp_unbounded_knapsack/#279-perfect-squares","title":"279. Perfect Squares","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, breadth first search</p> </li> </ul> 279. Perfect Squares - Python Solution<pre><code>import math\n\n\n# DP - Knapsack Unbounded\ndef numSquares(n: int) -&gt; int:\n    dp = [float(\"inf\") for _ in range(n + 1)]\n    dp[0] = 0\n\n    for i in range(1, n + 1):\n        for j in range(1, int(math.sqrt(n)) + 1):\n            dp[i] = min(dp[i], dp[i - j**2] + 1)\n\n    return dp[n]\n\n\nn = 12\nprint(numSquares(n))  # 3\n</code></pre>"},{"location":"leetpattern/dp_unbounded_knapsack/#322-coin-change","title":"322. Coin Change","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, breadth first search</p> </li> </ul> 322. Coin Change - Python Solution<pre><code>from typing import List\n\n\ndef coinChange(coins: List[int], amount: int) -&gt; int:\n    dp = [float(\"inf\") for _ in range(amount + 1)]\n\n    dp[0] = 0\n\n    for i in range(1, amount + 1):\n        for c in coins:\n            if i - c &gt;= 0:\n                dp[i] = min(dp[i], 1 + dp[i - c])\n\n    return dp[amount] if dp[amount] != float(\"inf\") else -1\n\n\ncoins = [1, 2, 5]\namount = 11\nprint(coinChange(coins, amount))  # 3\n</code></pre>"},{"location":"leetpattern/dp_unbounded_knapsack/#518-coin-change-ii","title":"518. Coin Change II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul> 518. Coin Change II - Python Solution<pre><code>from typing import List\n\n\ndef change(amount: int, coins: List[int]) -&gt; int:\n    dp = [0 for _ in range(amount + 1)]\n    dp[0] = 1\n\n    for i in range(len(coins)):\n        for j in range(coins[i], amount + 1):\n            dp[j] += dp[j - coins[i]]\n\n    return dp[-1]\n\n\namount = 5\ncoins = [1, 2, 5]\nprint(change(amount, coins))  # 4\n</code></pre>"},{"location":"leetpattern/dp_unbounded_knapsack/#377-combination-sum-iv","title":"377. Combination Sum IV","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul> 377. Combination Sum IV - Python Solution<pre><code>from typing import List\n\n\ndef combinationSum4(nums: List[int], target: int) -&gt; int:\n    dp = [0 for _ in range(target + 1)]\n    dp[0] = 1\n\n    for i in range(1, target + 1):\n        for j in range(len(nums)):\n            if i - nums[j] &gt;= 0:\n                dp[i] += dp[i - nums[j]]\n\n        return dp[target]\n\n\nnums = [1, 2, 3]\ntarget = 4\nprint(combinationSum4(nums, target))  # 7\n</code></pre>"},{"location":"leetpattern/fast_slow_pointers/","title":"Fast Slow Pointers","text":"<ul> <li> 27. Remove Element (Easy)</li> <li> 26. Remove Duplicates from Sorted Array (Easy)</li> <li> 80. Remove Duplicates from Sorted Array II (Medium)</li> <li> 283. Move Zeroes (Easy)</li> <li> 1089. Duplicate Zeros (Easy)</li> <li> 287. Find the Duplicate Number (Medium)</li> </ul>"},{"location":"leetpattern/fast_slow_pointers/#27-remove-element","title":"27. Remove Element","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers</p> </li> <li>Remove all instances of a given value in-place.</li> </ul> 27. Remove Element - Python Solution<pre><code>from typing import List\n\n\n# Fast Slow Pointers\ndef removeElement(nums: List[int], val: int) -&gt; int:\n    fast, slow = 0, 0\n\n    while fast &lt; len(nums):\n        if nums[fast] != val:\n            nums[slow] = nums[fast]\n            slow += 1\n        fast += 1\n\n    return slow\n\n\nnums = [0, 1, 2, 2, 3, 0, 4, 2]\nval = 2\nprint(removeElement(nums, val))  # 5\n</code></pre>"},{"location":"leetpattern/fast_slow_pointers/#26-remove-duplicates-from-sorted-array","title":"26. Remove Duplicates from Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers</p> </li> <li>Remove duplicates in-place.</li> </ul> 26. Remove Duplicates from Sorted Array - Python Solution<pre><code>from typing import List\n\n\ndef removeDuplicates(nums: List[int]) -&gt; int:\n    fast, slow = 1, 1\n\n    while fast &lt; len(nums):\n        if nums[fast] != nums[fast - 1]:\n            nums[slow] = nums[fast]\n            slow += 1\n        fast += 1\n\n    return slow\n\n\nnums = [1, 1, 2]\nprint(removeDuplicates(nums))  # 2\n</code></pre>"},{"location":"leetpattern/fast_slow_pointers/#80-remove-duplicates-from-sorted-array-ii","title":"80. Remove Duplicates from Sorted Array II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers</p> </li> <li>Allow at most two duplicates.</li> <li>fast pointer: explore the array</li> <li>slow pointer: point to the position to be replaced</li> </ul> 80. Remove Duplicates from Sorted Array II - Python Solution<pre><code>from typing import List\n\n\ndef removeDuplicates(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 2:\n        return len(nums)\n\n    fast, slow = 2, 2\n\n    while fast &lt; len(nums):\n        if nums[fast] != nums[slow - 2]:\n            nums[slow] = nums[fast]\n            slow += 1\n        fast += 1\n\n    return slow\n\n\nnums = [1, 1, 1, 2, 2, 3]\nprint(removeDuplicates(nums))\n</code></pre>"},{"location":"leetpattern/fast_slow_pointers/#283-move-zeroes","title":"283. Move Zeroes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers</p> </li> <li>Move all zeroes to the end of the array while maintaining the relative order of the non-zero elements.</li> </ul> 283. Move Zeroes - Python Solution<pre><code>from typing import List\n\n\ndef moveZeroes(nums: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    fast, slow = 0, 0\n\n    while fast &lt; len(nums):\n        if nums[fast] != 0:\n            nums[slow], nums[fast] = nums[fast], nums[slow]\n            slow += 1\n        fast += 1\n\n\nnums = [0, 1, 0, 3, 12]\nmoveZeroes(nums)\nprint(nums)  # [1, 3, 12, 0, 0]\n</code></pre>"},{"location":"leetpattern/fast_slow_pointers/#1089-duplicate-zeros","title":"1089. Duplicate Zeros","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers</p> </li> <li>Duplicate each occurrence of zero, shifting the remaining elements to the right.</li> </ul> 1089. Duplicate Zeros - Python Solution<pre><code>from typing import List\n\n\ndef duplicateZeros(arr: List[int]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify arr in-place instead.\n    \"\"\"\n    n = len(arr)\n    fast, slow = 0, 0\n\n    # First pass: find the position\n    # where the last element would be in the expanded array\n    while fast &lt; n:\n        if arr[slow] == 0:\n            fast += 1\n        slow += 1\n        fast += 1\n\n    slow -= 1\n    fast -= 1\n\n    # Second pass: move elements backwards\n    while slow &gt;= 0:\n        if fast &lt; n:\n            arr[fast] = arr[slow]\n\n        if arr[slow] == 0:\n            fast -= 1\n            if fast &lt; n:\n                arr[fast] = 0\n\n        slow -= 1\n        fast -= 1\n\n\narr = [1, 0, 2, 3, 0, 4, 5, 0]\nduplicateZeros(arr)\nprint(arr)  # [1, 0, 0, 2, 3, 0, 0, 4]\n</code></pre>"},{"location":"leetpattern/fast_slow_pointers/#287-find-the-duplicate-number","title":"287. Find the Duplicate Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, bit manipulation</p> </li> <li>Find the duplicate number in an array containing <code>n + 1</code> integers where each integer is between <code>1</code> and <code>n</code> inclusive.</li> </ul> 287. Find the Duplicate Number - Python Solution<pre><code>from typing import List\n\n\n# Fast Slow Pointer\ndef findDuplicate(nums: List[int]) -&gt; int:\n\n    fast, slow = nums[0], nums[0]\n\n    while True:\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n        if slow == fast:\n            break\n\n    slow = nums[0]\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[fast]\n\n    return slow\n\n\n# | Algorithm          | TC   | SC   |\n# |--------------------|------|------|\n# | Fast Slow Pointer  | O(n) | O(1) |\n# |--------------------|------|------|\n\nnums = [1, 3, 4, 2, 2]\nprint(findDuplicate(nums))  # 2\n</code></pre>"},{"location":"leetpattern/graph_bellman_ford/","title":"Graph Bellman Ford","text":"<ul> <li> 743. Network Delay Time (Medium)</li> <li> 787. Cheapest Flights Within K Stops (Medium)</li> </ul>"},{"location":"leetpattern/graph_bellman_ford/#743-network-delay-time","title":"743. Network Delay Time","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, heap priority queue, shortest path</p> </li> <li>Return the minimum time taken to reach all nodes in a network.</li> </ul> <pre><code>graph LR\n1((1))\n2((2))\n3((3))\n4((4))\n2 --&gt; |1| 1\n2 --&gt; |1| 3\n3 --&gt; |1| 4</code></pre> <ul> <li>Shortest Path Problem: Find the shortest path between two vertices in a graph.</li> <li>Dijkstra's Algorithm<ul> <li>Shortest path algorithm</li> <li>Weighted graph (non-negative weights)</li> <li>Data Structure: Heap; Hash Set</li> <li>Time Complexity: O(E * logV)</li> <li>Space Complexity: O(V)</li> </ul> </li> </ul> 743. Network Delay Time - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\nfrom helper import complexity\n\n\n# 1. Dijkstra - Set\ndef networkDelayTime1(times: List[List[int]], n: int, k: int) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    heap = [(0, k)]\n    visit = set()\n    t = 0\n\n    while heap:\n        w1, n1 = heapq.heappop(heap)\n        if n1 in visit:\n            continue\n\n        visit.add(n1)\n        t = w1\n\n        for n2, w2 in graph[n1]:\n            heapq.heappush(heap, (w1 + w2, n2))\n\n    return t if len(visit) == n else -1\n\n\n# 2. Dijkstra - Dict\ndef networkDelayTime2(times: List[List[int]], n: int, k: int) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    heap = [(0, k)]\n    dist = defaultdict(int)\n\n    while heap:\n        w1, n1 = heapq.heappop(heap)\n        if n1 in dist:\n            continue\n\n        dist[n1] = w1\n\n        for n2, w2 in graph[n1]:\n            heapq.heappush(heap, (w1 + w2, n2))\n\n    return max(dist.values()) if len(dist) == n else -1\n\n\n# Bellman-Ford\ndef networkDelayTimeBF(times: List[List[int]], n: int, k: int) -&gt; int:\n    delay = {i: float(\"inf\") for i in range(1, n + 1)}\n    delay[k] = 0\n\n    for _ in range(n - 1):\n        for u, v, t in times:\n            delay[v] = min(delay[v], delay[u] + t)\n\n    max_delay = max(delay.values())\n    return max_delay if max_delay &lt; float(\"inf\") else -1\n\n\ntable = [\n    [\"Dijkstra\", \"O(E*logV)\", \"O(V+E)\"],\n    [\"Bellman-Ford\", \"O(E*V)\", \"O(V)\"],\n]\ncomplexity(table)\n# |--------------|-----------|--------|\n# | Approach     | Time      | Space  |\n# |--------------|-----------|--------|\n# | Dijkstra     | O(E*logV) | O(V+E) |\n# | Bellman-Ford | O(E*V)    | O(V)   |\n# |--------------|-----------|--------|\n\n\ntimes = [[2, 1, 1], [2, 3, 1], [3, 4, 1]]\nn = 4\nk = 2\nprint(networkDelayTime1(times, n, k))  # 2\nprint(networkDelayTime2(times, n, k))  # 2\nprint(networkDelayTimeBF(times, n, k))  # 2\n</code></pre>"},{"location":"leetpattern/graph_bellman_ford/#787-cheapest-flights-within-k-stops","title":"787. Cheapest Flights Within K Stops","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming, depth first search, breadth first search, graph, heap priority queue, shortest path</p> </li> <li>Return the cheapest price from <code>src</code> to <code>dst</code> with at most <code>K</code> stops.</li> </ul> <pre><code>graph TD\n0((0))\n1((1))\n2((2))\n3((3))\n0 --&gt; |100| 1\n1 --&gt; |600| 3\n1 --&gt; |100| 2\n2 --&gt; |100| 0\n2 --&gt; |200| 3</code></pre> 787. Cheapest Flights Within K Stops - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Bellman-Ford\ndef findCheapestPriceBF(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    prices = [float(\"inf\") for _ in range(n)]\n    prices[src] = 0\n\n    for _ in range(k + 1):\n        temp = prices[:]\n        for u, v, w in flights:\n            temp[v] = min(temp[v], prices[u] + w)\n        prices = temp\n\n    return prices[dst] if prices[dst] != float(\"inf\") else -1\n\n\n# Dijkstra\ndef findCheapestPriceDijkstra(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in flights:\n        graph[u].append((v, w))\n\n    heap = [(0, src, 0)]  # (price, city, stops)\n    visited = defaultdict(int)  # {city: stops}\n\n    while heap:\n        price, city, stops = heapq.heappop(heap)\n\n        if city == dst:\n            return price\n\n        if stops &gt; k:\n            continue\n\n        if city in visited and visited[city] &lt;= stops:\n            continue\n\n        visited[city] = stops\n\n        for neighbor, cost in graph[city]:\n            heapq.heappush(heap, (price + cost, neighbor, stops + 1))\n\n    return -1\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |Bellman-Ford|    O(k * E)      |  O(n)   |\n# | Dijkstra   | O(E * log(V))    |  O(n)   |\n# |------------|------------------|---------|\n\n\nn = 4\nflights = [[0, 1, 100], [1, 2, 100], [2, 0, 100], [1, 3, 600], [2, 3, 200]]\nsrc = 0\ndst = 3\nk = 1\nprint(findCheapestPriceBF(n, flights, src, dst, k))  # 700\nprint(findCheapestPriceDijkstra(n, flights, src, dst, k))  # 700\n</code></pre>"},{"location":"leetpattern/graph_bfs/","title":"Graph BFS","text":"<ul> <li> 994. Rotting Oranges (Medium)</li> <li> 127. Word Ladder (Hard)</li> <li> 1466. Reorder Routes to Make All Paths Lead to the City Zero (Medium)</li> <li> 286. Walls and Gates (Medium)</li> <li> 815. Bus Routes (Hard)</li> </ul>"},{"location":"leetpattern/graph_bfs/#994-rotting-oranges","title":"994. Rotting Oranges","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, breadth first search, matrix</p> </li> <li>Return the minimum number of minutes that must elapse until no cell has a fresh orange.</li> <li>Hint: Multi-source BFS to count the level.</li> </ul> <p></p> 994. Rotting Oranges - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef orangesRotting(grid: List[List[int]]) -&gt; int:\n    # 1. Init\n    q = deque()\n    time, fresh = 0, 0\n    m, n = len(grid), len(grid[0])\n    dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n\n    # 2. Make a queue of rotten oranges and count fresh oranges\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                fresh += 1\n            if grid[r][c] == 2:\n                q.append([r, c])\n\n    # 3. BFS\n    while q and fresh &gt; 0:\n        size = len(q)\n\n        for _ in range(size):\n            r, c = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = r + dr, c + dc\n                if nr &lt; 0 or nc &lt; 0 or nr &gt;= m or nc &gt;= n or grid[nr][nc] != 1:\n                    continue\n                grid[nr][nc] = 2\n                q.append([nr, nc])\n                fresh -= 1\n        time += 1\n\n    return time if fresh == 0 else -1\n\n\ngrid = [[2, 1, 1], [1, 1, 0], [0, 1, 1]]\nprint(orangesRotting(grid))\n</code></pre>"},{"location":"leetpattern/graph_bfs/#127-word-ladder","title":"127. Word Ladder","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, breadth first search</p> </li> <li>The most classic BFS problem.</li> <li>Return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.</li> </ul> Approach Time Space BFS O(n * m^2) O(n * m) 127. Word Ladder - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef ladderLength(beginWord: str, endWord: str, wordList: List[str]) -&gt; int:\n    if endWord not in wordList:\n        return 0\n\n    n = len(beginWord)\n    graph = defaultdict(list)  # pattern: words\n    wordList.append(beginWord)\n\n    for word in wordList:\n        for i in range(n):\n            pattern = word[:i] + \"*\" + word[i + 1 :]\n            graph[pattern].append(word)\n\n    visited = set([beginWord])\n    q = deque([beginWord])\n    res = 1\n\n    while q:\n        size = len(q)\n        for _ in range(size):\n            word = q.popleft()\n            if word == endWord:\n                return res\n\n            for i in range(n):\n                pattern = word[:i] + \"*\" + word[i + 1 :]\n                for neighbor in graph[pattern]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        q.append(neighbor)\n        res += 1\n\n    return 0\n\n\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]\nprint(ladderLength(beginWord, endWord, wordList))  # 5\n</code></pre>"},{"location":"leetpattern/graph_bfs/#1466-reorder-routes-to-make-all-paths-lead-to-the-city-zero","title":"1466. Reorder Routes to Make All Paths Lead to the City Zero","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph</p> </li> <li></li> </ul> 1466. Reorder Routes to Make All Paths Lead to the City Zero - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef minReorderBFS(n: int, connections: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append((v, 1))  # go\n        graph[v].append((u, 0))  # come\n\n    changes = 0\n    q = deque([(0, -1)])\n\n    while q:\n        n1, d1 = q.popleft()\n\n        for n2, d2 in graph[n1]:\n            if n2 != d1:\n                changes += d2\n                q.append((n2, n1))\n\n    return changes\n\n\n# DFS\ndef minReorderDFS(n: int, connections: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append((v, 1))  # go\n        graph[v].append((u, 0))  # come\n\n    def dfs(n1, d1):\n        changes = 0\n        for n2, d2 in graph[n1]:\n            if n2 != d1:\n                changes += d2 + dfs(n2, n1)\n        return changes\n\n    return dfs(0, -1)\n\n\nn = 5\nconnections = [[1, 0], [1, 2], [3, 2], [3, 4]]\nprint(minReorderBFS(n, connections))  # 2\nprint(minReorderDFS(n, connections))  # 2\n</code></pre>"},{"location":"leetpattern/graph_bfs/#286-walls-and-gates","title":"286. Walls and Gates","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, breadth first search, matrix </p> </li> </ul> 286. Walls and Gates - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# Multi-source BFS\ndef wallsAndGates(rooms: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify rooms in-place instead.\n    \"\"\"\n    m, n = len(rooms), len(rooms[0])\n    visited = set()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def addRoom(r, c):\n        if (\n            r in range(m)\n            and c in range(n)\n            and (r, c) not in visited\n            and rooms[r][c] != -1\n        ):\n            q.append((r, c))\n            visited.add((r, c))\n\n    q = deque()\n    for r in range(m):\n        for c in range(n):\n            if rooms[r][c] == 0:\n                q.append((r, c))\n                visited.add((r, c))\n\n    dist = 0\n\n    while q:\n        for _ in range(len(q)):\n            r, c = q.popleft()\n            rooms[r][c] = dist\n\n            for dr, dc in directions:\n                addRoom(r + dr, c + dc)\n        dist += 1\n\n\nrooms = [\n    [2147483647, -1, 0, 2147483647],\n    [2147483647, 2147483647, 2147483647, -1],\n    [2147483647, -1, 2147483647, -1],\n    [0, -1, 2147483647, 2147483647],\n]\nwallsAndGates(rooms)\nprint(rooms)\n# [[3, -1, 0,  1],\n#  [2,  2, 1, -1],\n#  [1, -1, 2, -1],\n#  [0, -1, 3,  4]]\n</code></pre>"},{"location":"leetpattern/graph_bfs/#815-bus-routes","title":"815. Bus Routes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, breadth first search</p> </li> </ul> 815. Bus Routes - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef numBusesToDestination(\n    routes: List[List[int]], source: int, target: int\n) -&gt; int:\n    if source == target:\n        return 0\n\n    graph = defaultdict(set)  # {stop: buses}\n    for buses, route in enumerate(routes):\n        for stop in route:\n            graph[stop].add(buses)\n\n    q = deque([(source, 0)])  # (stop, bus)\n    visited_stops = set([source])\n    visited_buses = set()\n\n    while q:\n        stop, bus = q.popleft()\n\n        if stop == target:\n            return bus\n\n        for buses in graph[stop]:\n            if buses not in visited_buses:\n                visited_buses.add(buses)\n                for next_stop in routes[buses]:\n                    if next_stop not in visited_stops:\n                        visited_stops.add(next_stop)\n                        q.append((next_stop, bus + 1))\n\n    return -1\n\n\nroutes = [[1, 2, 7], [3, 6, 7]]\nsource = 1\ntarget = 6\nprint(numBusesToDestination(routes, source, target))  # 2\n</code></pre>"},{"location":"leetpattern/graph_coloring/","title":"Graph Coloring","text":"<ul> <li> 785. Is Graph Bipartite? (Medium)</li> <li> 886. Possible Bipartition (Medium)</li> <li> 924. Minimize Malware Spread (Hard)</li> </ul>"},{"location":"leetpattern/graph_coloring/#785-is-graph-bipartite","title":"785. Is Graph Bipartite?","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> <li>Determine if a graph is bipartite.</li> </ul> <p>How to group</p> Uncolored Color 1 Color 2 Operation Method 1 -1 0 1 <code>1 - color</code> Method 2 0 1 -1 <code>-color</code> 785. Is Graph Bipartite? - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef isBipartiteBFS(graph: List[List[int]]) -&gt; bool:\n    n = len(graph)\n    # -1: not colored; 0: blue; 1: red\n    color = [-1 for _ in range(n)]\n\n    def bfs(node):\n        q = deque([node])\n        color[node] = 0\n\n        while q:\n            cur = q.popleft()\n\n            for neighbor in graph[cur]:\n                if color[neighbor] == -1:\n                    color[neighbor] = 1 - color[cur]\n                    q.append(neighbor)\n                elif color[neighbor] == color[cur]:\n                    return False\n        return True\n\n    for i in range(n):\n        if color[i] == -1:\n            if not bfs(i):\n                return False\n\n    return True\n\n\n# DFS\ndef isBipartiteDFS(graph: List[List[int]]) -&gt; bool:\n    n = len(graph)\n    # -1: not colored; 0: blue; 1: red\n    color = [-1] * n\n\n    def dfs(node, c):\n        color[node] = c\n        for neighbor in graph[node]:\n            if color[neighbor] == -1:\n                if not dfs(neighbor, 1 - c):\n                    return False\n            elif color[neighbor] == c:\n                return False\n        return True\n\n    for i in range(n):\n        if color[i] == -1:\n            if not dfs(i, 0):\n                return False\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |    BFS     | O(V+E) |  O(V)   |\n# |    DFS     | O(V+E) |  O(V)   |\n# |------------|--------|---------|\n\n\ngraph = [[1, 2, 3], [0, 2], [0, 1, 3], [0, 2]]\nprint(isBipartiteBFS(graph))  # False\nprint(isBipartiteDFS(graph))  # False\n</code></pre>"},{"location":"leetpattern/graph_coloring/#886-possible-bipartition","title":"886. Possible Bipartition","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> <li>Determine if a graph can be divided into two groups such that no two nodes of the same group are connected.</li> </ul> 886. Possible Bipartition - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef possibleBipartitionBFS(n: int, dislikes: List[List[int]]) -&gt; bool:\n    group = {i: -1 for i in range(1, n + 1)}\n\n    # Undirected graph\n    graph = {i: [] for i in range(1, n + 1)}\n    for i, j in dislikes:\n        graph[i].append(j)\n        graph[j].append(i)\n\n    def bfs(person):\n        q = deque([person])\n        group[person] = 0\n\n        while q:\n            cur = q.popleft()\n\n            for neighbor in graph[cur]:\n                if group[neighbor] == -1:\n                    group[neighbor] = 1 - group[cur]\n                    q.append(neighbor)\n                elif group[neighbor] == group[cur]:\n                    return False\n        return True\n\n    for i in range(1, n + 1):\n        if group[i] == -1:\n            if not bfs(i):\n                return False\n    return True\n\n\n# DFS\ndef possibleBipartitionDFS(n: int, dislikes: List[List[int]]) -&gt; bool:\n    group = {i: -1 for i in range(1, n + 1)}\n    graph = {i: [] for i in range(1, n + 1)}\n    for i, j in dislikes:\n        graph[i].append(j)\n        graph[j].append(i)\n\n    def dfs(person, g):\n        group[person] = g\n\n        for neighbor in graph[person]:\n            if group[neighbor] == -1:\n                if not dfs(neighbor, 1 - g):\n                    return False\n            elif group[neighbor] == g:\n                return False\n\n        return True\n\n    for i in range(1, n + 1):\n        if group[i] == -1:\n            if not dfs(i, 0):\n                return False\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |    BFS     | O(V+E) |  O(V+E) |\n# |    DFS     | O(V+E) |  O(V+E) |\n# |------------|--------|---------|\n\n\nn = 4\ndislikes = [[1, 2], [1, 3], [2, 4]]\nprint(possibleBipartitionBFS(n, dislikes))  # True\nprint(possibleBipartitionDFS(n, dislikes))  # True\n</code></pre>"},{"location":"leetpattern/graph_coloring/#924-minimize-malware-spread","title":"924. Minimize Malware Spread","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, depth first search, breadth first search, union find, graph</p> </li> </ul> 924. Minimize Malware Spread - Python Solution<pre><code>from typing import List\n\n\n# Coloring\ndef minMalwareSpread(graph: List[List[int]], initial: List[int]) -&gt; int:\n    n = len(graph)\n    initial = set(initial)\n\n    def dfs(x):\n        visited.add(x)\n        mark[x] = 1\n        if x in initial:\n            v.append(x)\n        for nxt in range(n):\n            if graph[x][nxt] and nxt != x and not mark[nxt]:\n                dfs(nxt)\n\n    ans = min(initial)\n    mx = 0\n    mark = [0] * n\n    for i in range(n):\n        if not mark[i]:\n            visited = set()\n            v = []\n            dfs(i)\n            if len(v) == 1 and (\n                len(visited) &gt; mx or len(visited) == mx and v[0] &lt; ans\n            ):\n                ans, mx = v[0], len(visited)\n    return ans\n\n\ngraph = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]\ninitial = [0, 1]\nprint(minMalwareSpread(graph, initial))  # 0\n</code></pre>"},{"location":"leetpattern/graph_flood_fill/","title":"Graph Flood Fill","text":"<ul> <li> 733. Flood Fill (Easy)</li> <li> 200. Number of Islands (Medium)</li> <li> 695. Max Area of Island (Medium)</li> <li> 463. Island Perimeter (Easy)</li> <li> 130. Surrounded Regions (Medium)</li> <li> 417. Pacific Atlantic Water Flow (Medium)</li> <li> 827. Making A Large Island (Hard)</li> </ul>"},{"location":"leetpattern/graph_flood_fill/#733-flood-fill","title":"733. Flood Fill","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, matrix</p> </li> <li>Replace all the pixels of the same color starting from the given pixel.</li> <li>In other words, find the connected component of the starting pixel and change the color of all the pixels in that component.</li> <li>Edge cases: If the starting pixel is already the target color, return the image as it is.</li> <li>Flood Fill is essentially a graph traversal algorithm (like BFS or DFS) applied to matrices (2D grids).     It checks adjacent cells (up, down, left, right) of a starting point to determine whether they belong to the same region.     Typically, it involves modifying or marking the cells that belong to the same connected component.</li> </ul> <p></p> <p></p> 1 1 1 1 1 0 1 0 1 1 1 1 1 2 0 1 0 1 1 2 1 2 2 0 1 0 1 2 2 2 2 2 0 2 0 1 733. Flood Fill - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef floodFillDFS(\n    image: List[List[int]], sr: int, sc: int, color: int\n) -&gt; List[List[int]]:\n\n    org = image[sr][sc]\n    m, n = len(image), len(image[0])\n\n    if org == color:\n        return image\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or image[r][c] != org:\n            return None\n\n        image[r][c] = color\n\n        dfs(r - 1, c)\n        dfs(r + 1, c)\n        dfs(r, c - 1)\n        dfs(r, c + 1)\n\n    dfs(sr, sc)\n\n    return image\n\n\n# BFS\ndef floodFillBFS(\n    image: List[List[int]], sr: int, sc: int, color: int\n) -&gt; List[List[int]]:\n\n    org = image[sr][sc]\n    m, n = len(image), len(image[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    if org == color:\n        return image\n\n    q = deque([(sr, sc)])\n\n    while q:\n        r, c = q.popleft()\n        image[r][c] = color\n\n        for dr, dc in dirs:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and image[nr][nc] == org:\n                q.append((nr, nc))\n\n    return image\n\n\nimage = [[1, 1, 1], [1, 1, 0], [1, 0, 1]]\nsr = 1\nsc = 1\n\nprint(floodFillDFS(image, sr, sc, 2))\n# [[2, 2, 2], [2, 2, 0], [2, 0, 1]]\nprint(floodFillBFS(image, sr, sc, 2))\n# [[2, 2, 2], [2, 2, 0], [2, 0, 1]]\n</code></pre>"},{"location":"leetpattern/graph_flood_fill/#200-number-of-islands","title":"200. Number of Islands","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix</p> </li> <li>Count the number of islands in a 2D grid.</li> <li>Method 1: DFS</li> <li> <p>Method 2: BFS (use a queue to traverse the grid)</p> </li> <li> <p>How to keep track of visited cells?</p> <ol> <li>Mark the visited cell as <code>0</code> (or any other value) to avoid revisiting it.</li> <li>Use a set to store the visited cells.</li> </ol> </li> <li> <p>Steps:</p> <ol> <li>Init: variables</li> <li>DFS/BFS: starting from the cell with <code>1</code>, turn all the connected <code>1</code>s to <code>0</code>.</li> <li>Traverse the grid, and if the cell is <code>1</code>, increment the count and call DFS/BFS.</li> </ol> </li> </ul> <p></p> 200. Number of Islands - Python Solution<pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef numIslandsDFS(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    res = 0\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] != \"1\":\n            return\n\n        grid[r][c] = \"2\"\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                dfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Set\ndef numIslandsBFS1(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == \"0\"\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\" and (r, c) not in visited:\n                visited.add((r, c))\n                bfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = dr + row, dc + col\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] != \"1\"\n                ):\n                    continue\n                grid[nr][nc] = \"2\"\n                q.append((nr, nc))\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == \"1\":\n                grid[i][j] = \"2\"\n                bfs(i, j)\n                res += 1\n\n    return res\n\n\ngrid = [\n    [\"1\", \"1\", \"1\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"0\", \"0\", \"0\", \"0\", \"0\"],\n]\n\nprint(numIslandsDFS(deepcopy(grid)))  # 1\nprint(numIslandsBFS1(deepcopy(grid)))  # 1\nprint(numIslandsBFS2(deepcopy(grid)))  # 1\n</code></pre>"},{"location":"leetpattern/graph_flood_fill/#695-max-area-of-island","title":"695. Max Area of Island","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix</p> </li> </ul> 695. Max Area of Island - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef maxAreaOfIslandDFS(grid: List[List[int]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] != 1:\n            return 0\n\n        grid[r][c] = 2\n\n        return (\n            1 + dfs(r - 1, c) + dfs(r + 1, c) + dfs(r, c + 1) + dfs(r, c - 1)\n        )\n\n    area = 0\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                area = max(area, dfs(r, c))\n\n    return area\n\n\n# BFS\ndef maxAreaOfIslandBFS1(grid: List[List[int]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        area = 0\n\n        while q:\n            row, col = q.popleft()\n            area += 1\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == 0\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n        return area\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1 and (r, c) not in visited:\n                visited.add((r, c))\n                res = max(res, bfs(r, c))\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        area = 0\n\n        while q:\n            row, col = q.popleft()\n            area += 1\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n\n                if nr &lt; 0 or nr &gt;= m or nc &lt; 0 or nc &gt;= n or grid[nr][nc] == 0:\n                    continue\n\n                q.append((nr, nc))\n                grid[nr][nc] = 0\n\n        return area\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                grid[r][c] = 0\n                res = max(res, bfs(r, c))\n\n    return res\n\n\ngrid = [\n    [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0],\n    [0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],\n]\nprint(maxAreaOfIslandDFS(grid))  # 6\nprint(maxAreaOfIslandBFS1(grid))  # 6\nprint(numIslandsBFS2(grid))  # 6\n</code></pre>"},{"location":"leetpattern/graph_flood_fill/#463-island-perimeter","title":"463. Island Perimeter","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, matrix</p> </li> </ul> 463. Island Perimeter - Python Solution<pre><code>from typing import List\n\n\n# DFS\ndef islandPerimeterDFS(grid: List[List[int]]) -&gt; int:\n    # TC: O(m * n)\n    # SC: O(m * n)\n\n    visited = set()\n    m, n = len(grid), len(grid[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def dfs(r, c):\n        if (r, c) in visited or grid[r][c] == 0:\n            return 0\n        visited.add((r, c))\n        perimeter = 0\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if nr not in range(m) or nc not in range(n) or grid[nr][nc] == 0:\n                perimeter += 1\n            else:\n                perimeter += dfs(nr, nc)\n\n        return perimeter\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                return dfs(r, c)\n    return 0\n\n\ndef islandPerimeter(grid: List[List[int]]) -&gt; int:\n    m, n = len(grid), len(grid[0])\n    perimeter = 0\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                perimeter += 4\n\n                if r &gt; 0 and grid[r - 1][c] == 1:\n                    perimeter -= 2\n\n                if c &gt; 0 and grid[r][c - 1] == 1:\n                    perimeter -= 2\n\n    return perimeter\n\n\ngrid = [[0, 1, 0, 0], [1, 1, 1, 0], [0, 1, 0, 0], [1, 1, 0, 0]]\nprint(islandPerimeterDFS(grid))  # 16\nprint(islandPerimeter(grid))  # 16\n</code></pre>"},{"location":"leetpattern/graph_flood_fill/#130-surrounded-regions","title":"130. Surrounded Regions","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix</p> </li> </ul> 130. Surrounded Regions - Python Solution<pre><code>from collections import deque\nfrom copy import deepcopy\nfrom pprint import pprint\nfrom typing import List\n\n\n# 1. DFS\ndef solveDFS(board: List[List[str]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n    if not board and not board[0]:\n        return None\n\n    m, n = len(board), len(board[0])\n\n    def capture(r, c):\n        if r not in range(m) or c not in range(n) or board[r][c] != \"O\":\n            return None\n\n        board[r][c] = \"T\"\n        capture(r + 1, c)\n        capture(r - 1, c)\n        capture(r, c + 1)\n        capture(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\" and (r in [0, m - 1] or c in [0, n - 1]):\n                capture(r, c)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\":\n                board[r][c] = \"X\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"T\":\n                board[r][c] = \"O\"\n\n\n# 2. BFS\ndef solveBFS(board: List[List[str]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n    if not board and not board[0]:\n        return None\n\n    m, n = len(board), len(board[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def capture(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr = row + dr\n                nc = col + dc\n                if nr in range(m) and nc in range(n) and board[nr][nc] == \"O\":\n                    q.append((nr, nc))\n                    board[nr][nc] = \"T\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\" and (r in [0, m - 1] or c in [0, n - 1]):\n                board[r][c] = \"T\"\n                capture(r, c)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\":\n                board[r][c] = \"X\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"T\":\n                board[r][c] = \"O\"\n\n\nboard = [\n    [\"X\", \"X\", \"X\", \"X\"],\n    [\"X\", \"O\", \"O\", \"X\"],\n    [\"X\", \"X\", \"O\", \"X\"],\n    [\"X\", \"O\", \"X\", \"X\"],\n]\nboard1 = deepcopy(board)\nsolveDFS(board1)\npprint(board1)\n# [['X', 'X', 'X', 'X'],\n#  ['X', 'X', 'X', 'X'],\n#  ['X', 'X', 'X', 'X'],\n#  ['X', 'O', 'X', 'X']]\n\nboard2 = deepcopy(board)\nsolveBFS(board2)\npprint(board2)\n# [['X', 'X', 'X', 'X'],\n#  ['X', 'X', 'X', 'X'],\n#  ['X', 'X', 'X', 'X'],\n#  ['X', 'O', 'X', 'X']]\n</code></pre>"},{"location":"leetpattern/graph_flood_fill/#417-pacific-atlantic-water-flow","title":"417. Pacific Atlantic Water Flow","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, matrix</p> </li> </ul> 417. Pacific Atlantic Water Flow - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef pacificAtlanticDFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(r, c, visited, prev_height):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or heights[r][c] &lt; prev_height\n            or (r, c) in visited\n        ):\n            return None\n\n        visited.add((r, c))\n        height = heights[r][c]\n        for dr, dc in directions:\n            dfs(dr + r, dc + c, visited, height)\n\n    for c in range(n):\n        dfs(0, c, pac, heights[0][c])\n        dfs(m - 1, c, atl, heights[m - 1][c])\n\n    for r in range(m):\n        dfs(r, 0, pac, heights[r][0])\n        dfs(r, n - 1, atl, heights[r][n - 1])\n\n    return list(pac &amp; atl)\n\n\n# BFS\ndef pacificAtlanticBFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def bfs(r, c, visited):\n        q = deque([(r, c)])\n        visited.add((r, c))\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr in range(m)\n                    and nc in range(n)\n                    and heights[row][col] &lt;= heights[nr][nc]\n                    and (nr, nc) not in visited\n                ):\n                    q.append((nr, nc))\n                    visited.add((nr, nc))\n\n    for c in range(n):\n        bfs(0, c, pac)  # top\n        bfs(m - 1, c, atl)  # bottom\n\n    for r in range(m):\n        bfs(r, 0, pac)  # left\n        bfs(r, n - 1, atl)  # right\n\n    return list(pac &amp; atl)\n\n\nheights = [\n    [1, 2, 2, 3, 5],\n    [3, 2, 3, 4, 4],\n    [2, 4, 5, 3, 1],\n    [6, 7, 1, 4, 5],\n    [5, 1, 1, 2, 4],\n]\nprint(pacificAtlanticDFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\nprint(pacificAtlanticBFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\n</code></pre>"},{"location":"leetpattern/graph_flood_fill/#827-making-a-large-island","title":"827. Making A Large Island","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix</p> </li> </ul> 827. Making A Large Island - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Flood Fill\ndef largestIsland(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    areas = defaultdict(int)  # {index: area}\n    index = 2\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(r, c, index):\n        area = 1\n        grid[r][c] = index\n        for dr, dc in dirs:\n            nr, nc = r + dr, c + dc\n            if 0 &lt;= nr &lt; n and 0 &lt;= nc &lt; n and grid[nr][nc] == 1:\n                area += dfs(nr, nc, index)\n        return area\n\n    for r in range(n):\n        for c in range(n):\n            if grid[r][c] == 1:\n                areas[index] = dfs(r, c, index)\n                index += 1\n\n    if not areas:\n        return 1\n\n    res = max(areas.values())\n\n    for r in range(n):\n        for c in range(n):\n            if grid[r][c] == 0:\n                connected = set()\n                area = 1\n                for dr, dc in dirs:\n                    nr, nc = r + dr, c + dc\n                    if 0 &lt;= nr &lt; n and 0 &lt;= nc &lt; n and grid[nr][nc] &gt; 1:\n                        connected.add(grid[nr][nc])\n\n                for island in connected:\n                    area += areas[island]\n                res = max(res, area)\n\n    return res\n\n\ngrid = [[1, 0], [0, 1]]\nprint(largestIsland(grid))  # 3\n</code></pre>"},{"location":"leetpattern/graph_minimum_spanning_tree/","title":"Graph Minimum Spanning Tree","text":"<ul> <li> 1584. Min Cost to Connect All Points (Medium)</li> <li> 1135. Connecting Cities With Minimum Cost (Medium)</li> <li> 1168. Optimize Water Distribution in a Village (Hard)</li> <li> 1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree (Hard)</li> <li> 1631. Path With Minimum Effort (Medium)</li> <li> 1579. Remove Max Number of Edges to Keep Graph Fully Traversable (Hard)</li> </ul>"},{"location":"leetpattern/graph_minimum_spanning_tree/#1584-min-cost-to-connect-all-points","title":"1584. Min Cost to Connect All Points","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, union find, graph, minimum spanning tree</p> </li> <li>Tree: a connected acyclic graph</li> <li>Spanning Tree: a subgraph that is a tree and connects all the vertices together</li> <li>Minimum Spanning Tree (MST): a spanning tree with the minimum possible sum of edge weights</li> <li>Prim's Algorithm<ul> <li>Data Structure: Heap</li> <li>Time Complexity: O(E * logV)</li> <li>Space Complexity: O(V + E)</li> </ul> </li> <li> <p>Kruskal's Algorithm</p> <ul> <li>Union Find</li> <li>Time Complexity: O(E * logV)</li> <li>Space Complexity: O(V + E)</li> </ul> </li> <li> <p>Demonstration</p> </li> </ul> <p>Example graph</p> <p></p> <p>MST</p> <p></p> 1584. Min Cost to Connect All Points - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minCostConnectPointsPrim(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    graph = defaultdict(list)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            dist = abs(x1 - x2) + abs(y1 - y2)\n            graph[i].append((dist, j))\n            graph[j].append((dist, i))\n\n    cost = 0\n    heap = [(0, 0)]  # (cost, node)\n    visited = set()\n\n    while heap:\n        d1, n1 = heapq.heappop(heap)\n        if n1 in visited:\n            continue\n        visited.add(n1)\n        cost += d1\n\n        for d2, n2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (d2, n2))\n\n    return cost\n\n\n# Kruskal\ndef minCostConnectPointsKruskal(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    par = {i: i for i in range(n)}\n    rank = {i: 0 for i in range(n)}\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 == p2:\n            return False\n\n        if rank[p1] &gt; rank[p2]:\n            par[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n        else:\n            par[p2] = p1\n            rank[p1] += 1\n\n        return True\n\n    heap = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            dist = abs(x1 - x2) + abs(y1 - y2)\n            heapq.heappush(heap, (dist, i, j))\n\n    cost = 0\n    while heap:\n        d, n1, n2 = heapq.heappop(heap)\n        if union(n1, n2):\n            cost += d\n\n    return cost\n\n\npoints = [[0, 0], [2, 2], [3, 10], [5, 2], [7, 0]]\nprint(minCostConnectPointsPrim(points))  # 20\nprint(minCostConnectPointsKruskal(points))  # 20\n</code></pre>"},{"location":"leetpattern/graph_minimum_spanning_tree/#1135-connecting-cities-with-minimum-cost","title":"1135. Connecting Cities With Minimum Cost","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: union find, graph, heap priority queue, minimum spanning tree</p> </li> </ul> 1135. Connecting Cities With Minimum Cost - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minimumCost(n: int, connections: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, c in connections:\n        graph[u].append((c, v))\n        graph[v].append((c, u))\n\n    cost = 0\n    heap = [(0, 1)]  # (cost, node)\n    visited = set()\n\n    while heap:\n        c1, n1 = heapq.heappop(heap)\n\n        if n1 in visited:\n            continue\n\n        visited.add(n1)\n\n        cost += c1\n\n        for c2, n2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (c2, n2))\n\n    return cost if len(visited) == n else -1\n\n\nn = 3\nconnections = [[1, 2, 5], [1, 3, 6], [2, 3, 1]]\nprint(minimumCost(n, connections))  # 6\n</code></pre>"},{"location":"leetpattern/graph_minimum_spanning_tree/#1168-optimize-water-distribution-in-a-village","title":"1168. Optimize Water Distribution in a Village","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: union find, graph, heap priority queue, minimum spanning tree </p> </li> </ul> <p></p> 1168. Optimize Water Distribution in a Village - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minCostToSupplyWater1(\n    n: int, wells: List[int], pipes: List[List[int]]\n) -&gt; int:\n    graph = defaultdict(list)\n\n    for h1, h2, cost in pipes:\n        graph[h1].append((h2, cost))\n        graph[h2].append((h1, cost))\n\n    # Add the cost of the wells to the graph (house 0)\n    for i in range(n):\n        graph[0].append((i + 1, wells[i]))\n        graph[i + 1].append((0, wells[i]))\n\n    visited = set([0])\n    heap = [(cost, dest) for dest, cost in graph[0]]\n    heapq.heapify(heap)\n\n    cost = 0\n\n    while heap:\n        c1, n1 = heapq.heappop(heap)\n        if n1 in visited:\n            continue\n        visited.add(n1)\n        cost += c1\n\n        for n2, c2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (c2, n2))\n\n    return cost\n\n\n# Kruskal\ndef minCostToSupplyWater2(\n    n: int, wells: List[int], pipes: List[List[int]]\n) -&gt; int:\n    par = list(range(n + 1))\n    rank = [0] * (n + 1)\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            if rank[p1] &lt; rank[p2]:\n                par[p1] = p2\n            elif rank[p1] &gt; rank[p2]:\n                par[p2] = p1\n            else:\n                par[p1] = p2\n                rank[p2] += 1\n            return True\n        return False\n\n    graph = [(c, 0, i + 1) for i, c in enumerate(wells)]\n    for h1, h2, c in pipes:\n        graph.append((c, h1, h2))\n\n    graph.sort()\n\n    cost = 0\n\n    for c, h1, h2 in graph:\n        if union(h1, h2):\n            cost += c\n\n    return cost\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |    Prim    | O((V + E) log V) | O(V + E)|\n# |  Kruskal   |     O(E log E)   | O(V + E)|\n# |------------|------------------|---------|\n\n\nn = 3\nwells = [1, 2, 2]\npipes = [[1, 2, 1], [2, 3, 1]]\nprint(minCostToSupplyWater1(n, wells, pipes))  # 3\nprint(minCostToSupplyWater2(n, wells, pipes))  # 3\n</code></pre>"},{"location":"leetpattern/graph_minimum_spanning_tree/#1489-find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree","title":"1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: union find, graph, sorting, minimum spanning tree, strongly connected component</p> </li> </ul> 1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree - Python Solution<pre><code>from typing import List\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [1 for _ in range(n)]\n        self.part = n\n\n    def find(self, n):\n        p = self.parent[n]\n        while p != self.parent[p]:\n            self.parent[p] = self.parent[self.parent[p]]\n            p = self.parent[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return False\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.parent[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.parent[p1] = p2\n        else:\n            self.parent[p2] = p1\n            self.rank[p1] += 1\n\n        self.part -= 1\n        return True\n\n\n# Kruskal\ndef findCriticalAndPseudoCriticalEdges(\n    n: int, edges: List[List[int]]\n) -&gt; List[List[int]]:\n    m = len(edges)\n\n    # Add index to edges\n    lst = list(range(m))\n    lst.sort(key=lambda x: edges[x][2])\n\n    # Calculate minimum cost\n    min_cost = 0\n    uf = UnionFind(n)\n    for i in lst:\n        x, y, cost = edges[i]\n        if uf.union(x, y):\n            min_cost += cost\n\n    # Calculate key edges\n    key = set()\n    for i in lst:\n        cur_cost = 0\n        uf = UnionFind(n)\n        for j in lst:\n            if j != i:\n                x, y, cost = edges[j]\n                if uf.union(x, y):\n                    cur_cost += cost\n        if cur_cost &gt; min_cost or uf.part != 1:\n            key.add(i)\n\n    # Calculate fake edges\n    fake = set()\n    for i in lst:\n        if i not in key:\n            cur_cost = edges[i][2]\n            uf = UnionFind(n)\n            uf.union(edges[i][0], edges[i][1])\n            for j in lst:\n                x, y, cost = edges[j]\n                if uf.union(x, y):\n                    cur_cost += cost\n            if cur_cost == min_cost and uf.part == 1:\n                fake.add(i)\n\n    return [sorted(list(key)), sorted(list(fake))]\n\n\nn = 5\nedges = [\n    [0, 1, 1],\n    [1, 2, 1],\n    [2, 3, 2],\n    [0, 3, 2],\n    [0, 4, 3],\n    [3, 4, 3],\n    [1, 4, 6],\n]\nprint(findCriticalAndPseudoCriticalEdges(n, edges))\n</code></pre>"},{"location":"leetpattern/graph_minimum_spanning_tree/#1631-path-with-minimum-effort","title":"1631. Path With Minimum Effort","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, depth first search, breadth first search, union find, heap priority queue, matrix</p> </li> <li>Return the minimum effort required to travel from the top-left to the bottom-right corner.</li> </ul> 1631. Path With Minimum Effort - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Prim\ndef minimumEffortPath(heights: List[List[int]]) -&gt; int:\n    m, n = len(heights), len(heights[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * n for _ in range(m)]\n    heap = [(0, 0, 0)]  # (effort, row, col)\n\n    while heap:\n        effort, r, c = heapq.heappop(heap)\n\n        if visited[r][c]:\n            continue\n\n        if r == m - 1 and c == n - 1:\n            return effort\n\n        visited[r][c] = True\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and not visited[nr][nc]:\n                updated = max(effort, abs(heights[r][c] - heights[nr][nc]))\n                heapq.heappush(heap, (updated, nr, nc))\n\n    return -1\n\n\nheights = [[1, 2, 2], [3, 8, 2], [5, 3, 5]]\nprint(minimumEffortPath(heights))  # 2\n</code></pre>"},{"location":"leetpattern/graph_minimum_spanning_tree/#1579-remove-max-number-of-edges-to-keep-graph-fully-traversable","title":"1579. Remove Max Number of Edges to Keep Graph Fully Traversable","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: union find, graph</p> </li> <li>Return the maximum number of edges you can remove so that the graph remains fully traversable.</li> </ul> <p></p> 1579. Remove Max Number of Edges to Keep Graph Fully Traversable - Python Solution<pre><code>from typing import List\n\n\n# Kruskal\ndef maxNumEdgesToRemove(n: int, edges: List[List[int]]) -&gt; int:\n    alice, bob = UnionFind(n), UnionFind(n)\n    visited = 0\n\n    for t, u, v in edges:\n        if t == 3:\n            if alice.union(u, v) | bob.union(u, v):\n                visited += 1\n\n    for t, u, v in edges:\n        if t == 1:\n            if alice.union(u, v):\n                visited += 1\n        elif t == 2:\n            if bob.union(u, v):\n                visited += 1\n\n    if alice.components &gt; 1 or bob.components &gt; 1:\n        return -1\n\n    return len(edges) - visited\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = {i: i for i in range(1, n + 1)}\n        self.rank = {i: 0 for i in range(1, n + 1)}\n        self.components = n\n\n    def find(self, n):\n        p = self.parent[n]\n        while self.parent[p] != p:\n            self.parent[p] = self.parent[self.parent[p]]\n            p = self.parent[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return False\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.parent[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.parent[p1] = p2\n        else:\n            self.parent[p2] = p1\n            self.rank[p1] += 1\n\n        self.components -= 1\n\n        return True\n\n\nn = 4\nedges = [[3, 1, 2], [3, 2, 3], [1, 1, 3], [1, 2, 4], [1, 1, 2], [2, 3, 4]]\nprint(maxNumEdgesToRemove(n, edges))  # 2\n</code></pre>"},{"location":"leetpattern/graph_shortest_path/","title":"Graph Shortest Path","text":"<ul> <li> 743. Network Delay Time (Medium)</li> <li> 778. Swim in Rising Water (Hard)</li> <li> 1631. Path With Minimum Effort (Medium)</li> <li> 787. Cheapest Flights Within K Stops (Medium)</li> <li> 1514. Path with Maximum Probability (Medium)</li> <li> 505. The Maze II (Medium)</li> <li> 499. The Maze III (Hard)</li> <li> 882. Reachable Nodes In Subdivided Graph (Hard)</li> <li> 1376. Time Needed to Inform All Employees (Medium)</li> <li> 1168. Optimize Water Distribution in a Village (Hard)</li> <li> 1976. Number of Ways to Arrive at Destination (Medium)</li> </ul>"},{"location":"leetpattern/graph_shortest_path/#743-network-delay-time","title":"743. Network Delay Time","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, heap priority queue, shortest path</p> </li> <li>Return the minimum time taken to reach all nodes in a network.</li> </ul> <pre><code>graph LR\n1((1))\n2((2))\n3((3))\n4((4))\n2 --&gt; |1| 1\n2 --&gt; |1| 3\n3 --&gt; |1| 4</code></pre> <ul> <li>Shortest Path Problem: Find the shortest path between two vertices in a graph.</li> <li>Dijkstra's Algorithm<ul> <li>Shortest path algorithm</li> <li>Weighted graph (non-negative weights)</li> <li>Data Structure: Heap; Hash Set</li> <li>Time Complexity: O(E * logV)</li> <li>Space Complexity: O(V)</li> </ul> </li> </ul> 743. Network Delay Time - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\nfrom helper import complexity\n\n\n# 1. Dijkstra - Set\ndef networkDelayTime1(times: List[List[int]], n: int, k: int) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    heap = [(0, k)]\n    visit = set()\n    t = 0\n\n    while heap:\n        w1, n1 = heapq.heappop(heap)\n        if n1 in visit:\n            continue\n\n        visit.add(n1)\n        t = w1\n\n        for n2, w2 in graph[n1]:\n            heapq.heappush(heap, (w1 + w2, n2))\n\n    return t if len(visit) == n else -1\n\n\n# 2. Dijkstra - Dict\ndef networkDelayTime2(times: List[List[int]], n: int, k: int) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    heap = [(0, k)]\n    dist = defaultdict(int)\n\n    while heap:\n        w1, n1 = heapq.heappop(heap)\n        if n1 in dist:\n            continue\n\n        dist[n1] = w1\n\n        for n2, w2 in graph[n1]:\n            heapq.heappush(heap, (w1 + w2, n2))\n\n    return max(dist.values()) if len(dist) == n else -1\n\n\n# Bellman-Ford\ndef networkDelayTimeBF(times: List[List[int]], n: int, k: int) -&gt; int:\n    delay = {i: float(\"inf\") for i in range(1, n + 1)}\n    delay[k] = 0\n\n    for _ in range(n - 1):\n        for u, v, t in times:\n            delay[v] = min(delay[v], delay[u] + t)\n\n    max_delay = max(delay.values())\n    return max_delay if max_delay &lt; float(\"inf\") else -1\n\n\ntable = [\n    [\"Dijkstra\", \"O(E*logV)\", \"O(V+E)\"],\n    [\"Bellman-Ford\", \"O(E*V)\", \"O(V)\"],\n]\ncomplexity(table)\n# |--------------|-----------|--------|\n# | Approach     | Time      | Space  |\n# |--------------|-----------|--------|\n# | Dijkstra     | O(E*logV) | O(V+E) |\n# | Bellman-Ford | O(E*V)    | O(V)   |\n# |--------------|-----------|--------|\n\n\ntimes = [[2, 1, 1], [2, 3, 1], [3, 4, 1]]\nn = 4\nk = 2\nprint(networkDelayTime1(times, n, k))  # 2\nprint(networkDelayTime2(times, n, k))  # 2\nprint(networkDelayTimeBF(times, n, k))  # 2\n</code></pre>"},{"location":"leetpattern/graph_shortest_path/#778-swim-in-rising-water","title":"778. Swim in Rising Water","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, depth first search, breadth first search, union find, heap priority queue, matrix</p> </li> <li>Return the minimum time when you can reach the target.</li> </ul> <p></p> 778. Swim in Rising Water - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra's\ndef swimInWater(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    visited = set()\n    minHeap = [(grid[0][0], 0, 0)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    visited.add((0, 0))\n\n    while minHeap:\n        time, r, c = heapq.heappop(minHeap)\n\n        if r == n - 1 and c == n - 1:\n            return time\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if nr in range(n) and nc in range(n) and (nr, nc) not in visited:\n                visited.add((nr, nc))\n                heapq.heappush(minHeap, (max(time, grid[nr][nc]), nr, nc))\n\n\ngrid = [\n    [0, 1, 2, 3, 4],\n    [24, 23, 22, 21, 5],\n    [12, 13, 14, 15, 16],\n    [11, 17, 18, 19, 20],\n    [10, 9, 8, 7, 6],\n]\nprint(swimInWater(grid))  # 16\n</code></pre>"},{"location":"leetpattern/graph_shortest_path/#1631-path-with-minimum-effort","title":"1631. Path With Minimum Effort","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, depth first search, breadth first search, union find, heap priority queue, matrix</p> </li> <li>Return the minimum effort required to travel from the top-left to the bottom-right corner.</li> </ul> 1631. Path With Minimum Effort - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Prim\ndef minimumEffortPath(heights: List[List[int]]) -&gt; int:\n    m, n = len(heights), len(heights[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = [[False] * n for _ in range(m)]\n    heap = [(0, 0, 0)]  # (effort, row, col)\n\n    while heap:\n        effort, r, c = heapq.heappop(heap)\n\n        if visited[r][c]:\n            continue\n\n        if r == m - 1 and c == n - 1:\n            return effort\n\n        visited[r][c] = True\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and not visited[nr][nc]:\n                updated = max(effort, abs(heights[r][c] - heights[nr][nc]))\n                heapq.heappush(heap, (updated, nr, nc))\n\n    return -1\n\n\nheights = [[1, 2, 2], [3, 8, 2], [5, 3, 5]]\nprint(minimumEffortPath(heights))  # 2\n</code></pre>"},{"location":"leetpattern/graph_shortest_path/#787-cheapest-flights-within-k-stops","title":"787. Cheapest Flights Within K Stops","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming, depth first search, breadth first search, graph, heap priority queue, shortest path</p> </li> <li>Return the cheapest price from <code>src</code> to <code>dst</code> with at most <code>K</code> stops.</li> </ul> <pre><code>graph TD\n0((0))\n1((1))\n2((2))\n3((3))\n0 --&gt; |100| 1\n1 --&gt; |600| 3\n1 --&gt; |100| 2\n2 --&gt; |100| 0\n2 --&gt; |200| 3</code></pre> 787. Cheapest Flights Within K Stops - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Bellman-Ford\ndef findCheapestPriceBF(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    prices = [float(\"inf\") for _ in range(n)]\n    prices[src] = 0\n\n    for _ in range(k + 1):\n        temp = prices[:]\n        for u, v, w in flights:\n            temp[v] = min(temp[v], prices[u] + w)\n        prices = temp\n\n    return prices[dst] if prices[dst] != float(\"inf\") else -1\n\n\n# Dijkstra\ndef findCheapestPriceDijkstra(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in flights:\n        graph[u].append((v, w))\n\n    heap = [(0, src, 0)]  # (price, city, stops)\n    visited = defaultdict(int)  # {city: stops}\n\n    while heap:\n        price, city, stops = heapq.heappop(heap)\n\n        if city == dst:\n            return price\n\n        if stops &gt; k:\n            continue\n\n        if city in visited and visited[city] &lt;= stops:\n            continue\n\n        visited[city] = stops\n\n        for neighbor, cost in graph[city]:\n            heapq.heappush(heap, (price + cost, neighbor, stops + 1))\n\n    return -1\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |Bellman-Ford|    O(k * E)      |  O(n)   |\n# | Dijkstra   | O(E * log(V))    |  O(n)   |\n# |------------|------------------|---------|\n\n\nn = 4\nflights = [[0, 1, 100], [1, 2, 100], [2, 0, 100], [1, 3, 600], [2, 3, 200]]\nsrc = 0\ndst = 3\nk = 1\nprint(findCheapestPriceBF(n, flights, src, dst, k))  # 700\nprint(findCheapestPriceDijkstra(n, flights, src, dst, k))  # 700\n</code></pre>"},{"location":"leetpattern/graph_shortest_path/#1514-path-with-maximum-probability","title":"1514. Path with Maximum Probability","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, graph, heap priority queue, shortest path</p> </li> </ul> 1514. Path with Maximum Probability - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Dijkstra - Dict\ndef maxProbability1(\n    n: int,\n    edges: List[List[int]],\n    succProb: List[float],\n    start_node: int,\n    end_node: int,\n) -&gt; float:\n    graph = defaultdict(list)\n    for i, (u, v) in enumerate(edges):\n        graph[u].append((v, succProb[i]))\n        graph[v].append((u, succProb[i]))\n\n    heap = [(-1, start_node)]\n    max_prob = {i: 0.0 for i in range(n)}\n    max_prob[start_node] = 1.0\n\n    while heap:\n        p1, n1 = heapq.heappop(heap)\n\n        if n1 == end_node:\n            return -p1\n\n        for n2, p2 in graph[n1]:\n            p2 *= -p1\n            if p2 &gt; max_prob[n2]:\n                max_prob[n2] = p2\n                heapq.heappush(heap, (-p2, n2))\n\n    return 0.0\n\n\n# Dijkstra - Set\ndef maxProbability2(\n    n: int,\n    edges: List[List[int]],\n    succProb: List[float],\n    start_node: int,\n    end_node: int,\n) -&gt; float:\n    graph = defaultdict(list)\n    for i, (u, v) in enumerate(edges):\n        graph[u].append((v, succProb[i]))\n        graph[v].append((u, succProb[i]))\n\n    heap = [(-1, start_node)]\n    visited = set()\n\n    while heap:\n        p1, n1 = heapq.heappop(heap)\n        visited.add(n1)\n\n        if n1 == end_node:\n            return -p1\n\n        for n2, p2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (p1 * p2, n2))\n\n    return 0.0\n\n\n# |------------|-----------|-----------|\n# |  Approach  |    Time   |   Space   |\n# |------------|-----------|-----------|\n# |  Dijkstra  | O(E log V)|   O(E)    |\n# |------------|-----------|-----------|\n\n\nn = 3\nedges = [[0, 1], [1, 2], [0, 2]]\nsuccProb = [0.5, 0.5, 0.2]\nstart = 0\nend = 2\n\nprint(maxProbability1(n, edges, succProb, start, end))  # 0.25\nprint(maxProbability2(n, edges, succProb, start, end))  # 0.25\n</code></pre>"},{"location":"leetpattern/graph_shortest_path/#505-the-maze-ii","title":"505. The Maze II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, graph, heap priority queue, matrix, shortest path</p> </li> </ul> 505. The Maze II - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra\ndef shortestDistance(\n    maze: List[List[int]], start: List[int], destination: List[int]\n) -&gt; int:\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    m, n = len(maze), len(maze[0])\n\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    dist[start[0]][start[1]] = 0\n\n    heap = [(0, start[0], start[1])]\n\n    while heap:\n        d, r, c = heapq.heappop(heap)\n\n        if [r, c] == destination:\n            return d\n\n        for dr, dc in directions:\n            nr, nc, nd = r, c, d\n\n            while (\n                0 &lt;= nr + dr &lt; m\n                and 0 &lt;= nc + dc &lt; n\n                and maze[nr + dr][nc + dc] == 0\n            ):\n                nr += dr\n                nc += dc\n                nd += 1\n\n            if nd &lt; dist[nr][nc]:\n                dist[nr][nc] = nd\n                heapq.heappush(heap, (nd, nr, nc))\n\n    return -1\n\n\nmaze = [\n    [0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0],\n    [0, 0, 0, 1, 0],\n    [1, 1, 0, 1, 1],\n    [0, 0, 0, 0, 0],\n]\nstart = [0, 4]\ndestination = [4, 4]\nprint(shortestDistance(maze, start, destination))  # 12\n</code></pre>"},{"location":"leetpattern/graph_shortest_path/#499-the-maze-iii","title":"499. The Maze III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, depth first search, breadth first search, graph, heap priority queue, matrix, shortest path</p> </li> </ul> 499. The Maze III - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra\ndef findShortestWay(\n    maze: List[List[int]], ball: List[int], hole: List[int]\n) -&gt; str:\n    directions = [(-1, 0, \"u\"), (1, 0, \"d\"), (0, -1, \"l\"), (0, 1, \"r\")]\n    m, n = len(maze), len(maze[0])\n\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    dist[ball[0]][ball[1]] = 0\n\n    paths = [[\"\"] * n for _ in range(m)]\n    paths[ball[0]][ball[1]] = \"\"\n\n    heap = [(0, \"\", ball[0], ball[1])]\n\n    while heap:\n        d, path, x, y = heapq.heappop(heap)\n\n        if [x, y] == hole:\n            return path\n\n        for dx, dy, direction in directions:\n            nx, ny, nd = x, y, d\n\n            while (\n                0 &lt;= nx + dx &lt; m\n                and 0 &lt;= ny + dy &lt; n\n                and maze[nx + dx][ny + dy] == 0\n            ):\n                nx += dx\n                ny += dy\n                nd += 1\n\n                if [nx, ny] == hole:\n                    break\n\n            new_path = path + direction\n            if nd &lt; dist[nx][ny] or (\n                nd == dist[nx][ny] and new_path &lt; paths[nx][ny]\n            ):\n                dist[nx][ny] = nd\n                paths[nx][ny] = new_path\n                heapq.heappush(heap, (nd, new_path, nx, ny))\n\n    return \"impossible\"\n\n\nmaze = [\n    [0, 0, 0, 0, 0],\n    [1, 1, 0, 0, 1],\n    [0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 1],\n    [0, 1, 0, 0, 0],\n]\nball = [4, 3]\nhole = [0, 1]\nprint(findShortestWay(maze, ball, hole))  # \"lul\"\n</code></pre>"},{"location":"leetpattern/graph_shortest_path/#882-reachable-nodes-in-subdivided-graph","title":"882. Reachable Nodes In Subdivided Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: graph, heap priority queue, shortest path</p> </li> </ul> 882. Reachable Nodes In Subdivided Graph - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra's\ndef reachableNodes(self, edges: List[List[int]], maxMoves: int, n: int) -&gt; int:\n    graph = {i: {} for i in range(n)}\n    for u, v, cnt in edges:\n        graph[u][v] = cnt\n        graph[v][u] = cnt\n\n    heap = [(-maxMoves, 0)]\n    seen = {}\n\n    while heap:\n        moves, node = heapq.heappop(heap)\n        if node in seen:\n            continue\n        seen[node] = -moves\n        for nxt, cnt in graph[node].items():\n            movesLeft = -moves - cnt - 1\n            if nxt not in seen and movesLeft &gt;= 0:\n                heapq.heappush(heap, (-movesLeft, nxt))\n\n    res = len(seen)\n    for u, v, cnt in edges:\n        res += min(seen.get(u, 0) + seen.get(v, 0), cnt)\n\n    return res\n\n\nedges = [[0, 1, 10], [0, 2, 1], [1, 2, 2]]\nmaxMoves = 6\nn = 3\nprint(reachableNodes(None, edges, maxMoves, n))  # 13\n</code></pre>"},{"location":"leetpattern/graph_shortest_path/#1376-time-needed-to-inform-all-employees","title":"1376. Time Needed to Inform All Employees","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search</p> </li> </ul> 1376. Time Needed to Inform All Employees - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# DFS\ndef numOfMinutesDFS(\n    n: int, headID: int, manager: List[int], informTime: List[int]\n) -&gt; int:\n    graph = defaultdict(list)\n    for i in range(n):\n        if manager[i] != -1:\n            graph[manager[i]].append(i)\n\n    def dfs(node):\n        time = 0\n        for sub in graph[node]:\n            time = max(time, dfs(sub))\n        return time + informTime[node]\n\n    return dfs(headID)\n\n\n# BFS\ndef numOfMinutesBFS(\n    n: int, headID: int, manager: List[int], informTime: List[int]\n) -&gt; int:\n    graph = defaultdict(list)\n    for i in range(n):\n        if manager[i] != -1:\n            graph[manager[i]].append(i)\n\n    q = deque([(headID, 0)])\n    max_time = 0\n\n    while q:\n        node, time = q.popleft()\n        max_time = max(max_time, time)\n        for sub in graph[node]:\n            q.append((sub, time + informTime[node]))\n\n    return max_time\n\n\nn = 6\nheadID = 2\nmanager = [2, 2, -1, 2, 2, 2]\ninformTime = [0, 0, 1, 0, 0, 0]\nprint(numOfMinutesDFS(n, headID, manager, informTime))  # 1\nprint(numOfMinutesBFS(n, headID, manager, informTime))  # 1\n</code></pre>"},{"location":"leetpattern/graph_shortest_path/#1168-optimize-water-distribution-in-a-village","title":"1168. Optimize Water Distribution in a Village","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: union find, graph, heap priority queue, minimum spanning tree </p> </li> </ul> <p></p> 1168. Optimize Water Distribution in a Village - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minCostToSupplyWater1(\n    n: int, wells: List[int], pipes: List[List[int]]\n) -&gt; int:\n    graph = defaultdict(list)\n\n    for h1, h2, cost in pipes:\n        graph[h1].append((h2, cost))\n        graph[h2].append((h1, cost))\n\n    # Add the cost of the wells to the graph (house 0)\n    for i in range(n):\n        graph[0].append((i + 1, wells[i]))\n        graph[i + 1].append((0, wells[i]))\n\n    visited = set([0])\n    heap = [(cost, dest) for dest, cost in graph[0]]\n    heapq.heapify(heap)\n\n    cost = 0\n\n    while heap:\n        c1, n1 = heapq.heappop(heap)\n        if n1 in visited:\n            continue\n        visited.add(n1)\n        cost += c1\n\n        for n2, c2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (c2, n2))\n\n    return cost\n\n\n# Kruskal\ndef minCostToSupplyWater2(\n    n: int, wells: List[int], pipes: List[List[int]]\n) -&gt; int:\n    par = list(range(n + 1))\n    rank = [0] * (n + 1)\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            if rank[p1] &lt; rank[p2]:\n                par[p1] = p2\n            elif rank[p1] &gt; rank[p2]:\n                par[p2] = p1\n            else:\n                par[p1] = p2\n                rank[p2] += 1\n            return True\n        return False\n\n    graph = [(c, 0, i + 1) for i, c in enumerate(wells)]\n    for h1, h2, c in pipes:\n        graph.append((c, h1, h2))\n\n    graph.sort()\n\n    cost = 0\n\n    for c, h1, h2 in graph:\n        if union(h1, h2):\n            cost += c\n\n    return cost\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |    Prim    | O((V + E) log V) | O(V + E)|\n# |  Kruskal   |     O(E log E)   | O(V + E)|\n# |------------|------------------|---------|\n\n\nn = 3\nwells = [1, 2, 2]\npipes = [[1, 2, 1], [2, 3, 1]]\nprint(minCostToSupplyWater1(n, wells, pipes))  # 3\nprint(minCostToSupplyWater2(n, wells, pipes))  # 3\n</code></pre>"},{"location":"leetpattern/graph_shortest_path/#1976-number-of-ways-to-arrive-at-destination","title":"1976. Number of Ways to Arrive at Destination","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming, graph, topological sort, shortest path</p> </li> </ul> 1976. Number of Ways to Arrive at Destination - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra\ndef countPaths(n: int, roads: List[List[int]]) -&gt; int:\n    mod = 10**9 + 7\n    graph = [[] for _ in range(n)]\n    for u, v, w in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n\n    dist = [float(\"inf\") for _ in range(n)]\n    dist[0] = 0\n    count = [0 for _ in range(n)]\n    count[0] = 1\n\n    heap = [(0, 0)]\n\n    while heap:\n        d, u = heapq.heappop(heap)\n        if d &gt; dist[u]:\n            continue\n\n        for v, w in graph[u]:\n            if dist[u] + w &lt; dist[v]:\n                dist[v] = dist[u] + w\n                count[v] = count[u]\n                heapq.heappush(heap, (dist[v], v))\n            elif dist[u] + w == dist[v]:\n                count[v] += count[u]\n                count[v] %= mod\n\n    return count[-1]\n\n\nn = 7\nroads = [\n    [0, 6, 7],\n    [0, 1, 2],\n    [1, 2, 3],\n    [1, 3, 3],\n    [6, 3, 3],\n    [3, 5, 1],\n    [6, 5, 1],\n    [2, 5, 1],\n    [0, 4, 5],\n    [4, 6, 2],\n]\nprint(countPaths(n, roads))  # 4\n</code></pre>"},{"location":"leetpattern/graph_tarjan/","title":"Graph Tarjan","text":"<ul> <li> 1192. Critical Connections in a Network (Hard)</li> </ul>"},{"location":"leetpattern/graph_tarjan/#1192-critical-connections-in-a-network","title":"1192. Critical Connections in a Network","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: depth first search, graph, biconnected component</p> </li> </ul> 1192. Critical Connections in a Network - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Tarjan\ndef criticalConnections(\n    n: int, connections: List[List[int]]\n) -&gt; List[List[int]]:\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    disc = [-1] * n\n    low = [-1] * n\n    bridges = []\n    time = 0\n\n    def dfs(n1, prev):\n        nonlocal time\n        disc[n1], low[n1] = time, time\n        time += 1\n\n        for n2 in graph[n1]:\n            if n2 == prev:\n                continue\n            if disc[n2] == -1:\n                dfs(n2, n1)\n                low[n1] = min(low[n1], low[n2])\n\n                if low[n2] &gt; disc[n1]:\n                    bridges.append([n1, n2])\n            else:\n                low[n1] = min(low[n1], disc[n2])\n\n    for i in range(n):\n        if disc[i] == -1:\n            dfs(i, -1)\n\n    return bridges\n\n\nn = 4\nconnections = [[0, 1], [1, 2], [2, 0], [1, 3]]\nprint(criticalConnections(n, connections))  # [[1, 3]]\n</code></pre>"},{"location":"leetpattern/graph_topological_sort/","title":"Graph Topological Sort","text":"<ul> <li> 1557. Minimum Number of Vertices to Reach All Nodes (Medium)</li> <li> 207. Course Schedule (Medium)</li> <li> 210. Course Schedule II (Medium)</li> <li> 269. Alien Dictionary (Hard)</li> <li> 1203. Sort Items by Groups Respecting Dependencies (Hard)</li> <li> 1857. Largest Color Value in a Directed Graph (Hard)</li> <li> 1136. Parallel Courses (Medium)</li> </ul>"},{"location":"leetpattern/graph_topological_sort/#1557-minimum-number-of-vertices-to-reach-all-nodes","title":"1557. Minimum Number of Vertices to Reach All Nodes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: graph</p> </li> <li>Return a list of integers representing the minimum number of vertices needed to traverse all the nodes.</li> <li>\u2705 Return the vertices with indegree 0.</li> </ul> <p></p> <ul> <li><code>edges = [[0, 1], [0, 2], [2, 5], [3, 4], [4, 2]]</code></li> <li>Initialization</li> </ul> <code>src</code> 0 0 2 3 4 <code>dst</code> 1 2 5 4 2 node 0 1 2 3 4 5 in-degree 0 0 0 0 0 0 <code>src</code> 0 0 2 3 4 <code>dst</code> 1 2 5 4 2 node 0 1 2 3 4 5 in-degree 0 1 0 0 0 0 <code>src</code> 0 0 2 3 4 <code>dst</code> 1 2 5 4 2 node 0 1 2 3 4 5 in-degree 0 1 1 0 0 0 <code>src</code> 0 0 2 3 4 <code>dst</code> 1 2 5 4 2 node 0 1 2 3 4 5 in-degree 0 1 1 0 0 1 <code>src</code> 0 0 2 3 4 <code>dst</code> 1 2 5 4 2 node 0 1 2 3 4 5 in-degree 0 1 1 0 1 1 <code>src</code> 0 0 2 3 4 <code>dst</code> 1 2 5 4 2 node 0 1 2 3 4 5 in-degree 0 1 2 0 1 1 1557. Minimum Number of Vertices to Reach All Nodes - Python Solution<pre><code>from typing import List\n\n\n# Graph\ndef findSmallestSetOfVertices(n: int, edges: List[List[int]]) -&gt; List[int]:\n    indegree = {i: 0 for i in range(n)}\n\n    for a, b in edges:\n        indegree[b] += 1\n\n    return [i for i in range(n) if indegree[i] == 0]\n\n\nn = 6\nedges = [[0, 1], [0, 2], [2, 5], [3, 4], [4, 2]]\nprint(findSmallestSetOfVertices(n, edges))  # [0, 3]\n</code></pre>"},{"location":"leetpattern/graph_topological_sort/#207-course-schedule","title":"207. Course Schedule","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort</p> </li> <li>Return true if it is possible to finish all courses, otherwise return false.</li> <li>Dependency relationships imply the topological sort algorithm.</li> <li>Cycle detection</li> <li>Topological Sort<ul> <li>DAG (Directed Acyclic Graph)</li> <li>Time complexity: O(V+E)</li> <li>Space complexity: O(V+E)</li> <li>Prerequisites: Indegree (Look at the problem 1557. Minimum Number of Vertices to Reach All Nodes)<ul> <li>Indegree: Number of incoming edges to a vertex</li> </ul> </li> <li>Applications: task scheduling, course scheduling, build systems, dependency resolution, compiler optimization, etc.</li> </ul> </li> </ul> <p></p> <p></p> <p>Course to prerequisites mapping</p> <pre><code>flowchart LR\n    0((0)) --&gt; 1((1))\n    0((0)) --&gt; 2((2))\n    1((1)) --&gt; 3((3))\n    3((3)) --&gt; 4((4))\n    1((1)) --&gt; 4((4))</code></pre> <p>Prerequisites to course mapping</p> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    2((2)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))\n    4((4)) --&gt; 3((3))\n    4((4)) --&gt; 1((1))</code></pre> course 0 0 1 1 3 prerequisite 1 2 3 4 4 index 0 1 2 3 4 in-degree 0 0 0 0 0 <p>Initialize</p> <ul> <li>graph</li> </ul> prerequisite 1 2 3 4 course <code>[0]</code> <code>[0]</code> <code>[1]</code> <code>[1, 3]</code> <ul> <li>in-degree</li> </ul> 0 1 2 3 4 in-degree 2 2 0 1 0 <ul> <li>queue: <code>[2, 4]</code></li> <li>pop <code>2</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))\n    4((4)) --&gt; 3((3))\n    4((4)) --&gt; 1((1))</code></pre> 0 1 2 3 4 in-degree 1 2 0 1 0 <ul> <li>queue: <code>[4]</code></li> <li>pop <code>4</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))</code></pre> 0 1 2 3 4 in-degree 1 1 0 0 0 <ul> <li>queue: <code>[3]</code></li> <li>pop <code>3</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))</code></pre> 0 1 2 3 4 in-degree 1 0 0 0 0 <ul> <li>queue: <code>[1]</code></li> <li>pop <code>1</code> from the queue</li> </ul> <pre><code>flowchart LR\n    0((0))</code></pre> 0 1 2 3 4 in-degree 0 0 0 0 0 <ul> <li>queue: <code>[0]</code></li> <li>pop <code>0</code> from the queue</li> <li>All courses are taken. Return <code>True</code>.</li> </ul> 207. Course Schedule - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS (Kahn's Algorithm)\ndef canFinishBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    count = 0\n\n    while q:\n        crs = q.popleft()\n        count += 1\n\n        for nxt in graph[crs]:\n            indegree[nxt] -= 1\n\n            if indegree[nxt] == 0:\n                q.append(nxt)\n\n    return count == numCourses\n\n\n# DFS + Set\ndef canFinishDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for crs, pre in prerequisites:\n        graph[crs].append(pre)\n\n    visiting = set()\n\n    def dfs(crs):\n        if crs in visiting:  # cycle detected\n            return False\n        if graph[crs] == []:\n            return True\n\n        visiting.add(crs)\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        visiting.remove(crs)\n        graph[crs] = []\n\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\n# DFS + List\ndef canFinishDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for pre, crs in prerequisites:\n        graph[crs].append(pre)\n\n    # 0: init, 1: visiting, 2: visited\n    status = [0] * numCourses\n\n    def dfs(crs):\n        if status[crs] == 1:  # cycle detected\n            return False\n        if status[crs] == 2:\n            return True\n\n        status[crs] = 1\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        status[crs] = 2\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(canFinishBFS(5, prerequisites))  # True\nprint(canFinishDFS1(5, prerequisites))  # True\nprint(canFinishDFS2(5, prerequisites))  # True\n</code></pre>"},{"location":"leetpattern/graph_topological_sort/#210-course-schedule-ii","title":"210. Course Schedule II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort</p> </li> <li>Return the ordering of courses you should take to finish all courses. If there are multiple valid answers, return any of them.</li> </ul> <p></p> 210. Course Schedule II - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# 1. BFS - Kahn's Algorithm\ndef findOrderBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    order = []\n\n    while q:\n        pre = q.popleft()\n        order.append(pre)\n\n        for crs in graph[pre]:\n            indegree[crs] -= 1\n            if indegree[crs] == 0:\n                q.append(crs)\n\n    return order if len(order) == numCourses else []\n\n\n# 2. DFS + Set\ndef findOrderDFS1(\n    numCourses: int, prerequisites: List[List[int]]\n) -&gt; List[int]:\n    adj = defaultdict(list)\n    for crs, pre in prerequisites:\n        adj[crs].append(pre)\n\n    visit, cycle = set(), set()\n    order = []\n\n    def dfs(crs):\n        if crs in cycle:\n            return False\n        if crs in visit:\n            return True\n\n        cycle.add(crs)\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        cycle.remove(crs)\n        visit.add(crs)\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order\n\n\n# 3. DFS + List\ndef findOrderDFS2(\n    numCourses: int, prerequisites: List[List[int]]\n) -&gt; List[int]:\n    adj = defaultdict(list)\n    for pre, crs in prerequisites:\n        adj[crs].append(pre)\n\n    # 0: not visited, 1: visiting, 2: visited\n    state = [0] * numCourses\n    order = []\n\n    def dfs(crs):\n        if state[crs] == 1:\n            return False\n        if state[crs] == 2:\n            return True\n\n        state[crs] = 1\n\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        state[crs] = 2\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order[::-1]\n\n\nnumCourses = 5\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(findOrderBFS(numCourses, prerequisites))  # [2, 4, 3, 1, 0]\nprint(findOrderDFS1(numCourses, prerequisites))  # [4, 3, 1, 2, 0]\nprint(findOrderDFS2(numCourses, prerequisites))  # [4, 3, 2, 1, 0]\n</code></pre>"},{"location":"leetpattern/graph_topological_sort/#269-alien-dictionary","title":"269. Alien Dictionary","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, depth first search, breadth first search, graph, topological sort</p> </li> <li>Return the correct order of characters in the alien language.</li> </ul> 269. Alien Dictionary - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS - Kahn's algorithm (Topological Sort)\ndef alienOrderBFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    indegree = {c: 0 for word in words for c in word}\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                    indegree[w2[j]] += 1\n                break\n\n    q = deque([c for c in indegree if indegree[c] == 0])\n    result = []\n\n    while q:\n        char = q.popleft()\n        result.append(char)\n\n        for neighbor in graph[char]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n\n    return \"\".join(result) if len(result) == len(indegree) else \"\"\n\n\n# DFS - Topological Sort\ndef alienOrderDFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    visited = {}\n    result = []\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                break\n\n    def dfs(c):\n        if c in visited:\n            return visited[c]\n\n        visited[c] = False\n        for neighbor in graph[c]:\n            if not dfs(neighbor):\n                return False\n\n        visited[c] = True\n        result.append(c)\n        return True\n\n    for c in list(graph.keys()):\n        if not dfs(c):\n            return \"\"\n\n    return \"\".join(result[::-1])\n\n\nwords = [\"wrt\", \"wrf\", \"er\", \"ett\", \"rftt\"]\nprint(alienOrderBFS(words))  # wertf\nprint(alienOrderDFS(words))  # wertf\n</code></pre>"},{"location":"leetpattern/graph_topological_sort/#1203-sort-items-by-groups-respecting-dependencies","title":"1203. Sort Items by Groups Respecting Dependencies","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort</p> </li> <li>Return any permutation of the items that satisfies the requirements.</li> </ul> 1203. Sort Items by Groups Respecting Dependencies - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS - Kahn's algorithm (Topological Sort)\ndef sortItems(\n    n: int, m: int, group: List[int], beforeItems: List[List[int]]\n) -&gt; List[int]:\n    def topological_sort(graph, indegree, nodes):\n        q = deque([node for node in nodes if indegree[node] == 0])\n        result = []\n\n        while q:\n            node = q.popleft()\n            result.append(node)\n\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    q.append(neighbor)\n\n        return result if len(result) == len(nodes) else []\n\n    groupItems = defaultdict(list)\n    groupGraph = defaultdict(set)\n    groupIndegree = defaultdict(int)\n    itemGraph = defaultdict(set)\n    itemIndegree = defaultdict(int)\n\n    for i in range(n):\n        if group[i] == -1:\n            group[i] = m\n            m += 1\n        groupItems[group[i]].append(i)\n\n    for i, beforeItem in enumerate(beforeItems):\n        for before in beforeItem:\n            if group[before] != group[i]:\n                if group[i] not in groupGraph[group[before]]:\n                    groupGraph[group[before]].add(group[i])\n                    groupIndegree[group[i]] += 1\n            else:\n                itemGraph[before].add(i)\n                itemIndegree[i] += 1\n\n    allGroups = list(set(group))\n    groupOrder = topological_sort(groupGraph, groupIndegree, allGroups)\n    if not groupOrder:\n        return []\n\n    result = []\n    for g in groupOrder:\n        items = groupItems[g]\n        itemOrder = topological_sort(itemGraph, itemIndegree, items)\n        if not itemOrder:\n            return []\n        result.extend(itemOrder)\n\n    return result\n\n\nn = 8\nm = 2\ngroup = [-1, -1, 1, 0, 0, 1, 0, -1]\nbeforeItems = [[], [6], [5], [6], [3, 6], [], [], []]\nprint(sortItems(n, m, group, beforeItems))\n</code></pre>"},{"location":"leetpattern/graph_topological_sort/#1857-largest-color-value-in-a-directed-graph","title":"1857. Largest Color Value in a Directed Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, dynamic programming, graph, topological sort, memoization, counting</p> </li> </ul> 1857. Largest Color Value in a Directed Graph - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# Topological Sort\ndef largestPathValue(colors: str, edges: List[List[int]]) -&gt; int:\n    n = len(colors)\n    graph = defaultdict(list)\n    indegree = [0 for _ in range(n)]\n\n    for u, v in edges:\n        graph[u].append(v)\n        indegree[v] += 1\n\n    q = deque([i for i in range(n) if indegree[i] == 0])\n\n    dp = [[0] * 26 for _ in range(n)]\n\n    for i in range(n):\n        dp[i][ord(colors[i]) - ord(\"a\")] = 1\n\n    processed, max_color = 0, 0\n\n    while q:\n        n1 = q.popleft()\n        processed += 1\n        max_color = max(max_color, max(dp[n1]))\n\n        for n2 in graph[n1]:\n            indegree[n2] -= 1\n            for i in range(26):\n                dp[n2][i] = max(\n                    dp[n2][i],\n                    dp[n1][i] + (1 if i == ord(colors[n2]) - ord(\"a\") else 0),\n                )\n            if indegree[n2] == 0:\n                q.append(n2)\n\n    return max_color if processed == n else -1\n\n\ncolors = \"abaca\"\nedges = [[0, 1], [0, 2], [2, 3], [3, 4]]\nprint(largestPathValue(colors, edges))  # 3\n</code></pre>"},{"location":"leetpattern/graph_topological_sort/#1136-parallel-courses","title":"1136. Parallel Courses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: graph, topological sort</p> </li> <li>Return the minimum number of semesters needed to take all courses.</li> </ul> <p></p> 1136. Parallel Courses - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# Topological Sort\ndef minimumSemesters(n: int, relations: List[List[int]]) -&gt; int:\n    graph = {i: [] for i in range(1, n + 1)}\n    indegree = {i: 0 for i in range(1, n + 1)}\n\n    for pre, nxt in relations:\n        graph[pre].append(nxt)\n        indegree[nxt] += 1\n\n    q = deque([i for i in range(1, n + 1) if indegree[i] == 0])\n    semester = 0\n    done = 0\n\n    while q:\n        semester += 1\n        size = len(q)\n\n        for _ in range(size):\n            pre = q.popleft()\n            done += 1\n\n            for nxt in graph[pre]:\n                indegree[nxt] -= 1\n                if indegree[nxt] == 0:\n                    q.append(nxt)\n\n    return semester if done == n else -1\n\n\nn = 3\nrelations = [[1, 3], [2, 3]]\nprint(minimumSemesters(n, relations))  # 2\n</code></pre>"},{"location":"leetpattern/graph_union_find/","title":"Graph Union Find","text":"<ul> <li> 547. Number of Provinces (Medium)</li> <li> 684. Redundant Connection (Medium)</li> <li> 323. Number of Connected Components in an Undirected Graph (Medium)</li> <li> 721. Accounts Merge (Medium)</li> <li> 990. Satisfiability of Equality Equations (Medium)</li> <li> 952. Largest Component Size by Common Factor (Hard)</li> <li> 839. Similar String Groups (Hard)</li> <li> 305. Number of Islands II (Hard)</li> <li> 1202. Smallest String With Swaps (Medium)</li> <li> 685. Redundant Connection II (Hard)</li> <li> 399. Evaluate Division (Medium)</li> <li> 1101. The Earliest Moment When Everyone Become Friends (Medium)</li> </ul>"},{"location":"leetpattern/graph_union_find/#547-number-of-provinces","title":"547. Number of Provinces","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> <li>Return the number of provinces.</li> </ul>"},{"location":"leetpattern/graph_union_find/#union-find","title":"Union Find","text":"<ul> <li>Find by Path Compression</li> <li>Union by Rank</li> <li>Time Complexity: O(log(n))</li> <li>Space Complexity: O(n)</li> </ul> template/union_find.py<pre><code>class UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(n)}\n        self.rank = {i: 1 for i in range(n)}\n\n    def find(self, n):\n        p = self.par[n]\n        while self.par[p] != p:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return None\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.par[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.par[p1] = p2\n        else:\n            self.par[p2] = p1\n            self.rank[p1] += 1\n\n    def connected(self, n1, n2):\n        return self.find(n1) == self.find(n2)\n</code></pre> 547. Number of Provinces - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\nfrom template import UnionFind\n\n\n# DFS (Adjacency Matrix)\ndef findCircleNumDFSMatrix(isConnected: List[List[int]]) -&gt; int:\n    n = len(isConnected)\n    visited = set()\n\n    def dfs(node):\n        if node in visited:\n            return\n        visited.add(node)\n        for neighbor in range(n):\n            if node != neighbor and isConnected[node][neighbor] == 1:\n                dfs(neighbor)\n\n    res = 0\n    for i in range(n):\n        if i not in visited:\n            dfs(i)\n            res += 1\n\n    return res\n\n\n# DFS (Adjacency List)\ndef findCircleNumDFSList(isConnected: List[List[int]]) -&gt; int:\n    graph = defaultdict(list)\n    n = len(isConnected)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if isConnected[i][j] == 1:\n                graph[i].append(j)\n                graph[j].append(i)\n\n    visited = set()\n\n    def dfs(node):\n        if node in visited:\n            return\n        visited.add(node)\n        for neighbor in graph[node]:\n            dfs(neighbor)\n\n    res = 0\n    for i in range(n):\n        if i not in visited:\n            dfs(i)\n            res += 1\n\n    return res\n\n\n# BFS (Adjacency Matrix)\ndef findCircleNumBFS(isConnected: List[List[int]]) -&gt; int:\n    n = len(isConnected)\n    visited = set()\n    q = deque()\n    res = 0\n\n    for i in range(n):\n        if i not in visited:\n            res += 1\n\n            q.append(i)\n            while q:\n                node = q.popleft()\n                visited.add(node)\n                for node, val in enumerate(isConnected[node]):\n                    if val == 1 and node not in visited:\n                        q.append(node)\n                        visited.add(node)\n\n    return res\n\n\n# Union Find\ndef findCircleNumUF(isConnected: List[List[int]]) -&gt; int:\n    n = len(isConnected)\n    uf = UnionFind(n)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if isConnected[i][j] == 1:\n                uf.union(i, j)\n\n    res = len(set(uf.find(i) for i in range(n)))\n\n    return res\n\n\n# Union Find\ndef findCircleNum(isConnected: List[List[int]]) -&gt; int:\n    n = len(isConnected)\n    par = {i: i for i in range(n)}\n    rank = {i: 0 for i in range(n)}\n\n    def find(n):\n        p = par[n]\n        while par[p] != p:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 == p2:\n            return None\n\n        if rank[p1] &gt; rank[p2]:\n            par[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n        else:\n            par[p2] = p1\n            rank[p1] += 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if isConnected[i][j] == 1:\n                union(i, j)\n\n    res = len(set(find(i) for i in range(n)))\n\n    return res\n\n\nisConnected = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]\nprint(findCircleNumDFSList(isConnected))  # 2\nprint(findCircleNumDFSMatrix(isConnected))  # 2\nprint(findCircleNumBFS(isConnected))  # 2\nprint(findCircleNum(isConnected))  # 2\nprint(findCircleNumUF(isConnected))  # 2\n</code></pre>"},{"location":"leetpattern/graph_union_find/#684-redundant-connection","title":"684. Redundant Connection","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> </ul> 684. Redundant Connection - Python Solution<pre><code>from typing import List\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(1, n + 1)}\n        self.rank = {i: 1 for i in range(1, n + 1)}\n\n    def find(self, n):\n        p = self.par[n]\n        while self.par[p] != p:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return False\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.par[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.par[p1] = p2\n        else:\n            self.par[p2] = p1\n            self.rank[p1] += 1\n\n        return True\n\n\n# Union Find\ndef findRedundantConnectionUF(edges: List[List[int]]) -&gt; List[int]:\n    n = len(edges)\n    uf = UnionFind(n)\n\n    for u, v in edges:\n        if not uf.union(u, v):\n            return (u, v)\n\n\n# DFS\ndef findRedundantConnectionDFS(edges: List[List[int]]) -&gt; List[int]:\n    graph, cycle = {}, {}\n    for a, b in edges:\n        graph.setdefault(a, []).append(b)\n        graph.setdefault(b, []).append(a)\n\n    def dfs(node, parent):\n        if node in cycle:\n            for k in list(cycle.keys()):\n                if k == node:\n                    return True\n                del cycle[k]\n\n        cycle[node] = None\n        for child in graph[node]:\n            if child != parent and dfs(child, node):\n                return True\n        del cycle[node]\n        return False\n\n    dfs(edges[0][0], -1)\n    for a, b in edges[::-1]:\n        if a in cycle and b in cycle:\n            return (a, b)\n\n\nedges = [[1, 2], [1, 3], [2, 3]]\nprint(findRedundantConnectionUF(edges))  # (2, 3)\nprint(findRedundantConnectionDFS(edges))  # (2, 3)\n</code></pre>"},{"location":"leetpattern/graph_union_find/#323-number-of-connected-components-in-an-undirected-graph","title":"323. Number of Connected Components in an Undirected Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> </ul> 323. Number of Connected Components in an Undirected Graph - Python Solution<pre><code>from typing import List\n\n\n# Union Find\ndef countComponents(n: int, edges: List[List[int]]) -&gt; int:\n    uf = UnionFind(n)\n    count = n\n\n    for u, v in edges:\n        count -= uf.union(u, v)\n\n    return count\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(n)}\n        self.rank = {i: 1 for i in range(n)}\n\n    def find(self, n):\n        p = self.par[n]\n        while self.par[p] != p:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return 0\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.par[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.par[p1] = p2\n        else:\n            self.par[p2] = p1\n            self.rank[p1] += 1\n\n        return 1\n\n\nprint(countComponents(5, [[0, 1], [1, 2], [3, 4]]))  # 2\n</code></pre>"},{"location":"leetpattern/graph_union_find/#721-accounts-merge","title":"721. Accounts Merge","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, depth first search, breadth first search, union find, sorting</p> </li> </ul> 721. Accounts Merge - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef accountsMerge(accounts: List[List[str]]) -&gt; List[List[str]]:\n    parent = defaultdict(str)\n    rank = defaultdict(int)\n    email_to_name = defaultdict(str)\n    merged_accounts = defaultdict(list)\n\n    def find(n):\n        p = parent[n]\n        while p != parent[p]:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    for account in accounts:\n        name = account[0]\n        first_email = account[1]\n\n        for email in account[1:]:\n            if email not in parent:\n                parent[email] = email\n                rank[email] = 1\n            email_to_name[email] = name\n            union(first_email, email)\n\n    for email in parent:\n        root_email = find(email)\n        merged_accounts[root_email].append(email)\n\n    result = []\n    for root_email, emails in merged_accounts.items():\n        result.append([email_to_name[root_email]] + sorted(emails))\n\n    return result\n\n\naccounts = [\n    [\"John\", \"johnsmith@mail.com\", \"john_newyork@mail.com\"],\n    [\"John\", \"johnsmith@mail.com\", \"john00@mail.com\"],\n    [\"Mary\", \"mary@mail.com\"],\n    [\"John\", \"johnnybravo@mail.com\"],\n]\nprint(accountsMerge(accounts))\n# [['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],\n# ['Mary', 'mary@mail.com'],\n# ['John', 'johnnybravo@mail.com']]\n</code></pre>"},{"location":"leetpattern/graph_union_find/#990-satisfiability-of-equality-equations","title":"990. Satisfiability of Equality Equations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, union find, graph</p> </li> </ul> 990. Satisfiability of Equality Equations - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef equationsPossible(equations: List[str]) -&gt; bool:\n    parent = defaultdict(str)\n    rank = defaultdict(int)\n\n    def find(n):\n        p = parent[n]\n        while p != parent[p]:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    for equation in equations:\n        if equation[0] not in parent:\n            parent[equation[0]] = equation[0]\n            rank[equation[0]] = 1\n        if equation[3] not in parent:\n            parent[equation[3]] = equation[3]\n            rank[equation[3]] = 1\n\n    for equation in equations:\n        if equation[1] == \"=\":\n            union(equation[0], equation[3])\n\n    for equation in equations:\n        if equation[1] == \"!\":\n            if find(equation[0]) == find(equation[3]):\n                return False\n\n    return True\n\n\nequations = [\"a==b\", \"b!=a\"]\nprint(equationsPossible(equations))  # False\n</code></pre>"},{"location":"leetpattern/graph_union_find/#952-largest-component-size-by-common-factor","title":"952. Largest Component Size by Common Factor","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, math, union find, number theory</p> </li> </ul> 952. Largest Component Size by Common Factor - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef largestComponentSize(nums: List[int]) -&gt; int:\n    par = {i: i for i in nums}\n    rank = {i: 0 for i in nums}\n\n    def find(n):\n        p = par[n]\n        while par[p] != p:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            if rank[p1] &gt; rank[p2]:\n                par[p2] = p1\n            elif rank[p1] &lt; rank[p2]:\n                par[p1] = p2\n            else:\n                par[p2] = p1\n                rank[p1] += 1\n\n    def prime_factors(n):\n        \"\"\"Return the prime factors of n.\"\"\"\n        i = 2\n        factors = set()\n        while i * i &lt;= n:\n            while (n % i) == 0:\n                factors.add(i)\n                n //= i\n            i += 1\n        if n &gt; 1:\n            factors.add(n)\n        return factors\n\n    factor_map = defaultdict(list)  # factor -&gt; [nums]\n    for num in nums:\n        factors = prime_factors(num)\n        for factor in factors:\n            factor_map[factor].append(num)\n\n    for factor, group in factor_map.items():\n        for i in range(1, len(group)):\n            union(group[0], group[i])\n\n    sizes = defaultdict(int)  # component root -&gt; size\n    for num in nums:\n        root = find(num)\n        sizes[root] += 1\n\n    return max(sizes.values())\n\n\nnums = [20, 50, 9, 63]\nprint(largestComponentSize(nums))  # 2\n</code></pre>"},{"location":"leetpattern/graph_union_find/#839-similar-string-groups","title":"839. Similar String Groups","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, string, depth first search, breadth first search, union find</p> </li> </ul> 839. Similar String Groups - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef numSimilarGroups(strs: List[str]) -&gt; int:\n    n = len(strs)\n    parent = list(range(n))\n    rank = [0 for _ in range(n)]\n\n    def find(n):\n        p = parent[n]\n        while parent[p] != p:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return\n        if rank[p1] &gt; rank[p2]:\n            parent[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            parent[p1] = p2\n        else:\n            parent[p2] = p1\n            rank[p1] += 1\n\n    def is_similar(s1, s2):\n        diff = 0\n        for c1, c2 in zip(s1, s2):\n            if c1 != c2:\n                diff += 1\n            if diff &gt; 2:\n                return False\n        return True\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_similar(strs[i], strs[j]):\n                union(i, j)\n\n    return sum(find(i) == i for i in range(n))\n\n\nstrs = [\"tars\", \"rats\", \"arts\", \"star\"]\nprint(numSimilarGroups(strs))  # 2\n</code></pre>"},{"location":"leetpattern/graph_union_find/#305-number-of-islands-ii","title":"305. Number of Islands II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, union find</p> </li> </ul> 305. Number of Islands II - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef numIslands2(m: int, n: int, positions: List[List[int]]) -&gt; List[int]:\n    parent = defaultdict(tuple)\n    islands = 0\n    result = []\n    visited = set()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def find(node):\n        p = parent[node]\n        while parent[p] != p:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            parent[p1] = p2\n            return True\n        return False\n\n    for r, c in positions:\n        if (r, c) in visited:\n            result.append(islands)\n            continue\n\n        islands += 1\n        parent[(r, c)] = (r, c)\n        visited.add((r, c))\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if (nr, nc) in visited:\n                if union((r, c), (nr, nc)):\n                    islands -= 1\n\n        result.append(islands)\n\n    return result\n\n\nm = 3\nn = 3\npositions = [[0, 0], [0, 1], [1, 2], [2, 1]]\nprint(numIslands2(m, n, positions))  # [1, 1, 2, 3]\n</code></pre>"},{"location":"leetpattern/graph_union_find/#1202-smallest-string-with-swaps","title":"1202. Smallest String With Swaps","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, depth first search, breadth first search, union find, sorting</p> </li> </ul> 1202. Smallest String With Swaps - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef smallestStringWithSwaps(s: str, pairs: List[List[int]]) -&gt; str:\n    n = len(s)\n    par = list(range(n))\n    components = defaultdict(list)\n\n    def find(node):\n        p = par[node]\n        while par[p] != p:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 != p2:\n            par[p1] = p2\n\n    for index, j in pairs:\n        union(index, j)\n\n    for index in range(n):\n        components[find(index)].append(index)\n\n    res = list(s)\n    for indices in components.values():\n        chars = sorted([s[index] for index in indices])\n        for index, char in zip(indices, chars):\n            res[index] = char\n\n    return \"\".join(res)\n\n\ns = \"dcab\"\npairs = [[0, 3], [1, 2]]\nprint(smallestStringWithSwaps(s, pairs))  # \"bacd\"\n</code></pre>"},{"location":"leetpattern/graph_union_find/#685-redundant-connection-ii","title":"685. Redundant Connection II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> </ul> 685. Redundant Connection II - Python Solution<pre><code>from typing import List\n\n\n# Union Find\ndef findRedundantDirectedConnectionUF(edges: List[List[int]]) -&gt; List[int]:\n    n = len(edges)\n    uf = UnionFind(n + 1)\n    parent = list(range(n + 1))\n    candidates = []\n\n    for u, v in edges:\n        if parent[v] != v:\n            candidates.append([parent[v], v])\n            candidates.append([u, v])\n        else:\n            parent[v] = u\n\n    if not candidates:\n        for u, v in edges:\n            if not uf.union(u, v):\n                return [u, v]\n\n    for u, v in edges:\n        if [u, v] == candidates[1]:\n            continue\n        if not uf.union(u, v):\n            return candidates[0]\n\n    return candidates[1]\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(1, n + 1)}\n\n    def find(self, n):\n        p = self.par[n]\n        while p != self.par[p]:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n        if p1 == p2:\n            return False\n        self.par[p1] = p2\n        return True\n\n\nedges = [[1, 2], [1, 3], [2, 3]]\nprint(findRedundantDirectedConnectionUF(edges))\n</code></pre>"},{"location":"leetpattern/graph_union_find/#399-evaluate-division","title":"399. Evaluate Division","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, depth first search, breadth first search, union find, graph, shortest path</p> </li> </ul> 399. Evaluate Division - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef calcEquation(\n    equations: List[List[str]], values: List[float], queries: List[List[str]]\n) -&gt; List[float]:\n    graph = defaultdict(dict)\n    for (a, b), v in zip(equations, values):\n        graph[a][b] = v\n        graph[b][a] = 1 / v\n\n    def dfs(a, b, visited):\n        if a not in graph or b not in graph:\n            return -1.0\n\n        if b in graph[a]:\n            return graph[a][b]\n\n        for c in graph[a]:\n            if c not in visited:\n                visited.add(c)\n                d = dfs(c, b, visited)\n                if d != -1.0:\n                    return graph[a][c] * d\n        return -1.0\n\n    result = []\n    for a, b in queries:\n        result.append(dfs(a, b, set()))\n\n    return result\n\n\nequations = [[\"a\", \"b\"], [\"b\", \"c\"]]\nvalues = [2.0, 3.0]\nqueries = [[\"a\", \"c\"], [\"b\", \"a\"], [\"a\", \"e\"], [\"a\", \"a\"], [\"x\", \"x\"]]\nprint(calcEquation(equations, values, queries))  # [6.0, 0.5, -1.0, 1.0, -1.0]\n</code></pre>"},{"location":"leetpattern/graph_union_find/#1101-the-earliest-moment-when-everyone-become-friends","title":"1101. The Earliest Moment When Everyone Become Friends","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, union find, sorting</p> </li> </ul> 1101. The Earliest Moment When Everyone Become Friends - Python Solution<pre><code>from typing import List\n\n\n# Union Find\ndef earliestAcq(logs: List[List[int]], n: int) -&gt; int:\n    logs.sort()\n    par = {i: i for i in range(n)}\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    for time, a, b in logs:\n        pa, pb = find(a), find(b)\n        if pa != pb:\n            par[pa] = pb\n            n -= 1\n        if n == 1:\n            return time\n    return -1\n\n\nlogs = [[0, 2, 0], [1, 0, 1], [3, 0, 3], [4, 1, 2], [7, 3, 1]]\nn = 4\nprint(earliestAcq(logs, n))  # 3\n</code></pre>"},{"location":"leetpattern/greedy/","title":"Greedy","text":"<ul> <li> 455. Assign Cookies (Easy)</li> <li> 1005. Maximize Sum Of Array After K Negations (Easy)</li> <li> 860. Lemonade Change (Easy)</li> <li> 2037. Minimum Number of Moves to Seat Everyone (Easy)</li> <li> 376. Wiggle Subsequence (Medium)</li> <li> 738. Monotone Increasing Digits (Medium)</li> <li> 122. Best Time to Buy and Sell Stock II (Medium)</li> <li> 714. Best Time to Buy and Sell Stock with Transaction Fee (Medium)</li> <li> 135. Candy (Hard)</li> <li> 406. Queue Reconstruction by Height (Medium)</li> <li> 3075. Maximize Happiness of Selected Children (Medium)</li> <li> 945. Minimum Increment to Make Array Unique (Medium)</li> <li> 53. Maximum Subarray (Medium)</li> <li> 134. Gas Station (Medium)</li> <li> 968. Binary Tree Cameras (Hard)</li> <li> 1589. Maximum Sum Obtained of Any Permutation (Medium)</li> </ul>"},{"location":"leetpattern/greedy/#455-assign-cookies","title":"455. Assign Cookies","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers, greedy, sorting</p> </li> <li>Return the maximum number of your content children that can be satisfied.</li> </ul> 455. Assign Cookies - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef findContentChildren(g: List[int], s: List[int]) -&gt; int:\n    g.sort()\n    s.sort()\n    i, j = 0, 0\n\n    while i &lt; len(g) and j &lt; len(s):\n        if g[i] &lt;= s[j]:\n            i += 1\n        j += 1\n\n    return i\n\n\n# |-------------|-------------|--------------|\n# |   Approach  |    Time     |    Space     |\n# |-------------|-------------|--------------|\n# |   Greedy    | O(N * logN) |    O(1)      |\n# |-------------|-------------|--------------|\n\n\ng = [1, 2, 3]\ns = [1, 1]\nprint(findContentChildren(g, s))  # 1\n</code></pre>"},{"location":"leetpattern/greedy/#1005-maximize-sum-of-array-after-k-negations","title":"1005. Maximize Sum Of Array After K Negations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> <li>Return the maximum sum of the array after changing at most <code>k</code> elements.</li> </ul> 1005. Maximize Sum Of Array After K Negations - Python Solution<pre><code>from heapq import heapify, heapreplace\nfrom typing import List\n\n\n# Greedy\ndef largestSumAfterKNegationsGreedy(nums: List[int], k: int) -&gt; int:\n    nums.sort(key=abs, reverse=True)\n\n    for i in range(len(nums)):\n        if nums[i] &lt; 0 and k &gt; 0:\n            nums[i] *= -1\n            k -= 1\n\n    if k % 2:\n        nums[-1] *= -1\n\n    return sum(nums)\n\n\n# Heap\ndef largestSumAfterKNegationsHeap(nums: List[int], k: int) -&gt; int:\n    heapify(nums)\n\n    while k and nums[0] &lt; 0:\n        heapreplace(nums, -nums[0])\n        k -= 1\n\n    if k % 2:\n        heapreplace(nums, -nums[0])\n\n    return sum(nums)\n\n\nprint(largestSumAfterKNegationsGreedy([4, 2, 3], 1))  # 5\nprint(largestSumAfterKNegationsHeap([4, 2, 3], 1))\n</code></pre>"},{"location":"leetpattern/greedy/#860-lemonade-change","title":"860. Lemonade Change","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, greedy</p> </li> <li>Return <code>True</code> if and only if you can provide every customer with correct change.</li> </ul> 860. Lemonade Change - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef lemonadeChange(bills: List[int]) -&gt; bool:\n    hashmap = {5: 0, 10: 0, 20: 0}\n\n    for i in bills:\n        if i == 5:\n            hashmap[5] += 1\n\n        if i == 10:\n            if hashmap[5] &lt; 1:\n                return False\n\n            hashmap[5] -= 1\n            hashmap[10] += 1\n\n        if i == 20:\n            if hashmap[5] &gt;= 1 and hashmap[10] &gt;= 1:\n                hashmap[5] -= 1\n                hashmap[10] -= 1\n                hashmap[20] += 1\n\n            elif hashmap[5] &gt;= 3:\n                hashmap[5] -= 3\n                hashmap[20] += 1\n\n            else:\n                return False\n\n    return True\n\n\nprint(lemonadeChange([5, 5, 5, 10, 20]))  # True\n</code></pre>"},{"location":"leetpattern/greedy/#2037-minimum-number-of-moves-to-seat-everyone","title":"2037. Minimum Number of Moves to Seat Everyone","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, greedy, sorting, counting sort</p> </li> <li>Return the minimum number of moves needed to seat everyone.</li> </ul> 2037. Minimum Number of Moves to Seat Everyone - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef minMovesToSeat(seats: List[int], students: List[int]) -&gt; int:\n    seats.sort()\n    students.sort()\n    moves = 0\n\n    for i, j in zip(seats, students):\n        moves += abs(i - j)\n\n    return moves\n\n\nprint(minMovesToSeat([3, 1, 5], [2, 7, 4]))  # 4\n</code></pre>"},{"location":"leetpattern/greedy/#376-wiggle-subsequence","title":"376. Wiggle Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> <li>Return the length of the longest wiggle subsequence.</li> <li><code>up[n]</code> stores the length of the longest wiggle subsequence ending at <code>n</code> with a rising wiggle.</li> <li><code>down[n]</code> stores the length of the longest wiggle subsequence ending at <code>n</code> with a falling wiggle.</li> <li>Initialize <code>up[0] = 1</code> and <code>down[0] = 1</code>.</li> <li>Example: <code>nums = [1, 7, 4, 9, 2, 5]</code></li> </ul> <code>nums[n]</code> <code>nums[n-1]</code> <code>up[n-1]</code> <code>down[n-1]</code> <code>up[n]</code> <code>down[n]</code> 1 - - - 1 1 7 1 1 1 2 1 4 7 2 1 2 3 9 4 2 3 4 3 2 9 4 3 4 5 5 2 4 5 6 5 376. Wiggle Subsequence - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef wiggleMaxLengthDP(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 1:\n        return len(nums)\n\n    up = [0 for _ in range(len(nums))]\n    down = [0 for _ in range(len(nums))]\n\n    up[0], down[0] = 1, 1\n\n    for i in range(1, len(nums)):\n        if nums[i] &gt; nums[i - 1]:\n            up[i] = down[i - 1] + 1\n            down[i] = down[i - 1]\n        elif nums[i] &lt; nums[i - 1]:\n            down[i] = up[i - 1] + 1\n            up[i] = up[i - 1]\n        else:\n            up[i] = up[i - 1]\n            down[i] = down[i - 1]\n\n    return max(up[-1], down[-1])\n\n\n# Greedy\ndef wiggleMaxLengthGreedy(nums: List[int]) -&gt; int:\n    if len(nums) &lt; 2:\n        return len(nums)\n\n    prev_diff = nums[1] - nums[0]\n    count = 2 if prev_diff != 0 else 1\n\n    for i in range(2, len(nums)):\n        diff = nums[i] - nums[i - 1]\n        if (diff &gt; 0 and prev_diff &lt;= 0) or (diff &lt; 0 and prev_diff &gt;= 0):\n            count += 1\n            prev_diff = diff\n\n    return count\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    DP       |      O(n)       |     O(n)     |\n# |  Greedy     |      O(n)       |     O(1)     |\n# |-------------|-----------------|--------------|\n\nnums = [1, 7, 4, 9, 2, 5]\nprint(wiggleMaxLengthDP(nums))  # 6\nprint(wiggleMaxLengthGreedy(nums))  # 6\n</code></pre>"},{"location":"leetpattern/greedy/#738-monotone-increasing-digits","title":"738. Monotone Increasing Digits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, greedy</p> </li> <li>Return the largest number that is less than or equal to <code>n</code> with monotone increasing digits.</li> </ul> 738. Monotone Increasing Digits - Python Solution<pre><code># Greedy\ndef monotoneIncreasingDigits(n: int) -&gt; int:\n    strNum = list(str(n))\n\n    for i in range(len(strNum) - 2, -1, -1):\n        if int(strNum[i]) &gt; int(strNum[i + 1]):\n            strNum[i] = str(int(strNum[i]) - 1)\n            strNum[i + 1 :] = [\"9\"] * (len(strNum) - (i + 1))\n\n    return int(\"\".join(strNum))\n\n\nn = 332\nprint(monotoneIncreasingDigits(n))  # 299\n</code></pre>"},{"location":"leetpattern/greedy/#122-best-time-to-buy-and-sell-stock-ii","title":"122. Best Time to Buy and Sell Stock II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> <li>Return the maximum profit you can achieve.</li> </ul> 122. Best Time to Buy and Sell Stock II - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef maxProfitDP1(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 2 for _ in range(n)]\n    dp[0][0] = -prices[0]\n    dp[0][1] = 0\n\n    for i in range(1, n):\n        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i])\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# DP - Optimized\ndef maxProfitDP2(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    hold = -prices[0]\n    profit = 0\n\n    for i in range(1, n):\n        hold = max(hold, profit - prices[i])\n        profit = max(profit, hold + prices[i])\n\n    return profit\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    profit = 0\n\n    for i in range(1, len(prices)):\n        profit += max(prices[i] - prices[i - 1], 0)\n\n    return profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |     DP1    |  O(n)  |   O(n)  |\n# |     DP2    |  O(n)  |   O(1)  |\n# |   Greedy   |  O(n)  |   O(1)  |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitDP1(prices))  # 7\nprint(maxProfitDP2(prices))  # 7\nprint(maxProfitGreedy(prices))  # 7\n</code></pre>"},{"location":"leetpattern/greedy/#714-best-time-to-buy-and-sell-stock-with-transaction-fee","title":"714. Best Time to Buy and Sell Stock with Transaction Fee","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> <li>Return the maximum profit you can achieve with the given transaction fee.</li> </ul> 714. Best Time to Buy and Sell Stock with Transaction Fee - Python Solution<pre><code>from typing import List\n\n\n# 1. DP\ndef maxProfitDP(prices: List[int], fee: int) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 2 for _ in range(n)]\n\n    dp[0][0] = -prices[0] - fee\n    dp[0][1] = 0\n\n    for i in range(1, n):\n        dp[i][0] = max(\n            dp[i - 1][0],  # hold\n            dp[i - 1][1] - prices[i] - fee,  # buy\n        )\n        dp[i][1] = max(\n            dp[i - 1][1],  # hold\n            dp[i - 1][0] + prices[i],  # sell\n        )\n\n    return max(dp[-1])\n\n\n# 2. Greedy\ndef maxProfitGreedy(prices: List[int], fee: int) -&gt; int:\n    n = len(prices)\n    if n == 0:\n        return 0\n\n    buy = prices[0]\n    profit = 0\n\n    for i in range(1, n):\n        if prices[i] &lt; buy:\n            buy = prices[i]\n        elif prices[i] &gt; buy + fee:\n            profit += prices[i] - buy - fee\n            buy = prices[i] - fee\n\n    return profit\n\n\nprices = [1, 3, 2, 8, 4, 9]\nfee = 2\nprint(maxProfitDP(prices, fee))  # 8\nprint(maxProfitGreedy(prices, fee))  # 8\n</code></pre>"},{"location":"leetpattern/greedy/#135-candy","title":"135. Candy","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy</p> </li> <li>Return the minimum number of candies you must give.</li> </ul> 135. Candy - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef candy(ratings: List[int]) -&gt; int:\n    # TC: O(n)\n    # SC: O(n)\n    n = len(ratings)\n\n    if n &lt;= 1:\n        return n\n\n    candy = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        if ratings[i] &gt; ratings[i - 1]:\n            candy[i] = candy[i - 1] + 1\n\n    for j in range(n - 2, -1, -1):\n        if ratings[j] &gt; ratings[j + 1]:\n            candy[j] = max(candy[j], candy[j + 1] + 1)\n\n    return sum(candy)\n\n\nratings = [1, 0, 2]\nprint(candy(ratings))  # 5\n</code></pre>"},{"location":"leetpattern/greedy/#406-queue-reconstruction-by-height","title":"406. Queue Reconstruction by Height","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary indexed tree, segment tree, sorting</p> </li> <li>Reconstruct the queue.</li> </ul> 406. Queue Reconstruction by Height - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef reconstructQueue(people: List[List[int]]) -&gt; List[List[int]]:\n    queue = []\n    people.sort(key=lambda x: (-x[0], x[1]))\n\n    for i in people:\n        queue.insert(i[1], i)\n\n    return queue\n\n\npeople = [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]\nprint(reconstructQueue(people))\n# [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]\n</code></pre>"},{"location":"leetpattern/greedy/#3075-maximize-happiness-of-selected-children","title":"3075. Maximize Happiness of Selected Children","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul> 3075. Maximize Happiness of Selected Children - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef maximumHappinessSum(happiness: List[int], k: int) -&gt; int:\n    selected = 0\n    happinessScore = 0\n    happiness.sort(reverse=True)\n\n    for score in happiness:\n        if selected == k:\n            return happinessScore\n        happinessScore += max(0, score - selected)\n        selected += 1\n\n    return happinessScore\n\n\nhappiness = [1, 2, 3]\nk = 2\nprint(maximumHappinessSum(happiness, k))  # 4\n</code></pre>"},{"location":"leetpattern/greedy/#945-minimum-increment-to-make-array-unique","title":"945. Minimum Increment to Make Array Unique","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting, counting</p> </li> </ul> 945. Minimum Increment to Make Array Unique - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef minIncrementForUnique(nums: List[int]) -&gt; int:\n    nums.sort()\n    moves = 0\n\n    for i in range(1, len(nums)):\n        if nums[i] &lt;= nums[i - 1]:\n            moves += nums[i - 1] + 1 - nums[i]\n            nums[i] = nums[i - 1] + 1\n\n    return moves\n\n\nnums = [1, 2, 2]\nprint(minIncrementForUnique(nums))  # 1\n</code></pre>"},{"location":"leetpattern/greedy/#53-maximum-subarray","title":"53. Maximum Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, divide and conquer, dynamic programming</p> </li> </ul> 53. Maximum Subarray - Python Solution<pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxSubArrayDP(nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n\n    dp[0] = nums[0]\n    maxSum = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(\n            dp[i - 1] + nums[i],  # continue the previous subarray\n            nums[i],  # start a new subarray\n        )\n        maxSum = max(maxSum, dp[i])\n\n    return maxSum\n\n\n# Greedy\ndef maxSubArrayGreedy(nums: List[int]) -&gt; int:\n    max_sum = nums[0]\n    cur_sum = 0\n\n    for num in nums:\n        cur_sum = max(cur_sum + num, num)\n        max_sum = max(max_sum, cur_sum)\n\n    return max_sum\n\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArrayDP(nums))  # 6\nprint(maxSubArrayGreedy(nums))  # 6\n</code></pre>"},{"location":"leetpattern/greedy/#134-gas-station","title":"134. Gas Station","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy</p> </li> </ul> 134. Gas Station - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef canCompleteCircuit(gas: List[int], cost: List[int]) -&gt; int:\n    curSum = 0\n    totalSum = 0\n    start = 0\n\n    for i in range(len(gas)):\n        curSum += gas[i] - cost[i]\n        totalSum += gas[i] - cost[i]\n\n        if curSum &lt; 0:\n            start = i + 1\n            curSum = 0\n\n    if totalSum &lt; 0:\n        return -1\n\n    return start\n\n\ngas = [1, 2, 3, 4, 5]\ncost = [3, 4, 5, 1, 2]\nprint(canCompleteCircuit(gas, cost))  # 3\n</code></pre>"},{"location":"leetpattern/greedy/#968-binary-tree-cameras","title":"968. Binary Tree Cameras","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, tree, depth first search, binary tree</p> </li> </ul> 968. Binary Tree Cameras - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef minCameraCover(root: Optional[TreeNode]) -&gt; int:\n    res = 0\n\n    def dfs(node, hasParent):\n        if not node:\n            return -1\n\n        nonlocal res\n        left, right = dfs(node.left, True), dfs(node.right, True)\n\n        if left == -1 and right == -1:\n            if hasParent:\n                return 0\n            res += 1\n            return 2\n        if left == 0 or right == 0:\n            res += 1\n            return 2\n        if left == 2 or right == 2:\n            return 1\n        if hasParent:\n            return 0\n        res += 1\n        return 2\n\n    dfs(root, False)\n\n    return res\n\n\nroot = build([0, 0, None, 0, 0])\nprint(root)\nprint(minCameraCover(root))  # 1\n</code></pre>"},{"location":"leetpattern/greedy/#1589-maximum-sum-obtained-of-any-permutation","title":"1589. Maximum Sum Obtained of Any Permutation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting, prefix sum</p> </li> </ul> 1589. Maximum Sum Obtained of Any Permutation - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef maxSumRangeQuery(nums: List[int], requests: List[List[int]]) -&gt; int:\n    n = len(nums)\n    freq = [0 for _ in range(n + 1)]\n\n    for start, end in requests:\n        freq[start] += 1\n        if end + 1 &lt; n:\n            freq[end + 1] -= 1\n\n    for i in range(1, n):\n        freq[i] += freq[i - 1]\n\n    freq.pop()\n\n    freq.sort(reverse=True)\n    nums.sort(reverse=True)\n\n    max_sum = 0\n    mod = 10**9 + 7\n\n    for i, j in zip(nums, freq):\n        max_sum += i * j\n        max_sum %= mod\n\n    return max_sum\n\n\nnums = [1, 2, 3, 4, 5]\nrequests = [[1, 3], [0, 1]]\nprint(maxSumRangeQuery(nums, requests))  # 19\n</code></pre>"},{"location":"leetpattern/hash_counting/","title":"Hash Counting","text":"<ul> <li> 242. Valid Anagram (Easy)</li> <li> 560. Subarray Sum Equals K (Medium)</li> <li> 49. Group Anagrams (Medium)</li> <li> 438. Find All Anagrams in a String (Medium)</li> </ul>"},{"location":"leetpattern/hash_counting/#242-valid-anagram","title":"242. Valid Anagram","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, string, sorting</p> </li> <li>Return true if an input string is an anagram of another string.</li> <li>An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once, e.g., <code>listen</code> is an anagram of <code>silent</code>.</li> </ul> 242. Valid Anagram - Python Solution<pre><code>from collections import Counter\n\n\n# Hashmap\ndef isAnagramHash(s: str, t: str) -&gt; bool:\n    \"\"\"Return True if t is an anagram of s, False otherwise.\"\"\"\n    if len(s) != len(t):\n        return False\n\n    count = dict()\n\n    for i in s:\n        if i in count:\n            count[i] += 1\n        else:\n            count[i] = 1\n\n    for j in t:\n        if j in count:\n            count[j] -= 1\n        else:\n            return False\n\n    for count in count.values():\n        if count != 0:\n            return False\n\n    return True\n\n\n# Array\ndef isAnagramArray(s: str, t: str) -&gt; bool:\n    if len(s) != len(t):\n        return False\n\n    count = [0 for _ in range(26)]\n\n    for i in s:\n        count[ord(i) - ord(\"a\")] += 1\n\n    for j in t:\n        count[ord(j) - ord(\"a\")] -= 1\n\n    for i in count:\n        if i != 0:\n            return False\n\n    return True\n\n\n# Counter\ndef isAnagramCounter(s: str, t: str) -&gt; bool:\n    return Counter(s) == Counter(t)\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |   Hashmap   |       O(n)      |     O(1)     |\n# |    Array    |       O(n)      |     O(1)     |\n# |   Counter   |       O(n)      |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\ns = \"anagram\"\nt = \"nagaram\"\nprint(isAnagramHash(s, t))  # True\nprint(isAnagramArray(s, t))  # True\nprint(isAnagramCounter(s, t))  # True\n</code></pre>"},{"location":"leetpattern/hash_counting/#560-subarray-sum-equals-k","title":"560. Subarray Sum Equals K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, prefix sum</p> </li> </ul> 560. Subarray Sum Equals K - Python Solution<pre><code>from typing import List\n\n\n# 1. Prefix Sum\ndef subarraySum(nums: List[int], k: int) -&gt; int:\n    prefix_sums = {0: 1}\n    currentSum = 0\n    count = 0\n\n    for num in nums:\n        currentSum += num\n        if (currentSum - k) in prefix_sums:\n            count += prefix_sums[currentSum - k]\n\n        if currentSum in prefix_sums:\n            prefix_sums[currentSum] += 1\n        else:\n            prefix_sums[currentSum] = 1\n\n    return count\n\n\n# 2. Optimized Prefix Sum\ndef subarraySumOptimized(nums: List[int], k: int) -&gt; int:\n    prefixSum = 0\n    count = 0\n    prefix_sums = {0: 1}\n\n    for num in nums:\n        prefixSum += num\n        count += prefix_sums.get(prefixSum - k, 0)\n        prefix_sums[prefixSum] = prefix_sums.get(prefixSum, 0) + 1\n\n    return count\n\n\nnums = [1, 1, 1]\nk = 2\nprint(subarraySum(nums, k))  # 2\nprint(subarraySumOptimized(nums, k))  # 2\n</code></pre>"},{"location":"leetpattern/hash_counting/#49-group-anagrams","title":"49. Group Anagrams","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, sorting</p> </li> </ul> 49. Group Anagrams - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash - List\ndef groupAnagrams(strs: List[str]) -&gt; List[List[str]]:\n    result = defaultdict(list)\n\n    for s in strs:\n        count = [0] * 26\n        for i in s:\n            count[ord(i) - ord(\"a\")] += 1\n\n        result[tuple(count)].append(s)\n\n    return list(result.values())\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Hash     |     O(n * k)    |     O(n)     |\n# |-------------|-----------------|--------------|\n\n\nstrs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\nprint(groupAnagrams(strs))\n# [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n</code></pre>"},{"location":"leetpattern/hash_counting/#438-find-all-anagrams-in-a-string","title":"438. Find All Anagrams in a String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> </ul> 438. Find All Anagrams in a String - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window - Variable\ndef findAnagrams(s: str, p: str) -&gt; List[int]:\n    result = []\n    if len(s) &lt; len(p):\n        return result\n\n    countP = [0] * 26\n    for i in p:\n        countP[ord(i) - ord(\"a\")] += 1\n\n    countS = [0] * 26\n    for i in range(len(p)):\n        countS[ord(s[i]) - ord(\"a\")] += 1\n\n    if countS == countP:\n        result.append(0)\n\n    # sliding window\n    for i in range(len(p), len(s)):\n        countS[ord(s[i]) - ord(\"a\")] += 1  # add new character\n        countS[ord(s[i - len(p)]) - ord(\"a\")] -= 1  # remove old character\n        if countS == countP:\n            result.append(i - len(p) + 1)  # append the starting index\n\n    return result\n\n\ns = \"cbaebabacd\"\np = \"abc\"\nprint(findAnagrams(s, p))  # [0, 6]\n</code></pre>"},{"location":"leetpattern/hash_map/","title":"Hash Map","text":"<ul> <li> 383. Ransom Note (Easy)</li> <li> 350. Intersection of Two Arrays II (Easy)</li> <li> 1. Two Sum (Easy)</li> <li> 409. Longest Palindrome (Easy)</li> <li> 1365. How Many Numbers Are Smaller Than the Current Number (Easy)</li> <li> 202. Happy Number (Easy)</li> <li> 454. 4Sum II (Medium)</li> </ul>"},{"location":"leetpattern/hash_map/#383-ransom-note","title":"383. Ransom Note","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, string, counting</p> </li> <li>Return <code>True</code> if the ransom note can be constructed from the magazines, otherwise, return <code>False</code>.</li> </ul> <pre><code>graph LR\n    A[\"Magazine: abcdef\"] --&gt; C(True)\n    B[\"Ransom Note: abc\"] --&gt; C</code></pre> 383. Ransom Note - Python Solution<pre><code>from collections import Counter, defaultdict\n\n\n# Array\ndef canConstructArray(ransomNote: str, magazine: str) -&gt; bool:\n    if len(ransomNote) &gt; len(magazine):\n        return False\n\n    record = [0 for _ in range(26)]\n\n    for i in magazine:\n        record[ord(i) - ord(\"a\")] += 1\n\n    for j in ransomNote:\n        record[ord(j) - ord(\"a\")] -= 1\n\n    for i in record:\n        if i &lt; 0:\n            return False\n\n    return True\n\n\n# Dict\ndef canConstructDict(ransomNote: str, magazine: str) -&gt; bool:\n    if len(ransomNote) &gt; len(magazine):\n        return False\n\n    record = defaultdict(int)\n\n    for i in magazine:\n        record[i] += 1\n\n    for j in ransomNote:\n        if j not in record or record[j] == 0:\n            return False\n        record[j] -= 1\n\n    return True\n\n\n# Counter\ndef canConstructCounter(ransomNote: str, magazine: str) -&gt; bool:\n    return not Counter(ransomNote) - Counter(magazine)\n\n\nransomNote = \"aa\"\nmagazine = \"aab\"\nprint(canConstructArray(ransomNote, magazine))  # True\nprint(canConstructDict(ransomNote, magazine))  # True\nprint(canConstructCounter(ransomNote, magazine))  # True\n</code></pre>"},{"location":"leetpattern/hash_map/#350-intersection-of-two-arrays-ii","title":"350. Intersection of Two Arrays II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, two pointers, binary search, sorting</p> </li> <li>Return the intersection of two arrays.</li> </ul> 350. Intersection of Two Arrays II - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hashmap\ndef intersect(nums1: List[int], nums2: List[int]) -&gt; List[int]:\n    hashmap = defaultdict(int)  # {num: count}\n    result = []\n\n    for i in nums1:\n        hashmap[i] += 1\n\n    for i in nums2:\n        if hashmap[i] &gt; 0:\n            result.append(i)\n            hashmap[i] -= 1\n\n    return result\n\n\n# |-------------|-------------|--------------|\n# |   Approach  |    Time     |    Space     |\n# |-------------|-------------|--------------|\n# |   Hashmap   |   O(n + m)  | O(min(n, m)) |\n# |-------------|-------------|--------------|\n\nnums1 = [1, 2, 2, 1]\nnums2 = [2, 2]\nprint(intersect(nums1, nums2))  # [2, 2]\n</code></pre>"},{"location":"leetpattern/hash_map/#1-two-sum","title":"1. Two Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table</p> </li> <li>Return the indices of the two numbers such that they add up to a specific target.</li> </ul> Approach Time Complexity Space Complexity Hashmap O(n) O(n) 1. Two Sum - Python Solution<pre><code>from typing import List\n\n\n# Hashmap\ndef twoSum(nums: List[int], target: int) -&gt; List[int]:\n    hashmap = {}  # val: idx\n\n    for idx, val in enumerate(nums):\n        if (target - val) in hashmap:\n            return [hashmap[target - val], idx]\n\n        hashmap[val] = idx\n\n\nnums = [2, 7, 11, 15]\ntarget = 18\nassert twoSum(nums, target) == [1, 2]\n</code></pre>"},{"location":"leetpattern/hash_map/#409-longest-palindrome","title":"409. Longest Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, string, greedy</p> </li> <li>Return the length of the longest palindrome that can be built with the characters in the string.</li> </ul> 409. Longest Palindrome - Python Solution<pre><code>def longestPalindrome(s: str) -&gt; int:\n    hashmap = dict()\n    result = 0\n\n    for char in s:\n        if char not in hashmap or hashmap[char] == 0:\n            hashmap[char] = 1\n        else:\n            result += 2\n            hashmap[char] = 0\n\n    if any(hashmap.values()):\n        result += 1\n\n    return result\n\n\nprint(longestPalindrome(\"abccccdd\"))  # 7\n</code></pre>"},{"location":"leetpattern/hash_map/#1365-how-many-numbers-are-smaller-than-the-current-number","title":"1365. How Many Numbers Are Smaller Than the Current Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, sorting, counting</p> </li> <li>For each number in the array, return how many numbers are smaller than it.</li> </ul> 1365. How Many Numbers Are Smaller Than the Current Number - Python Solution<pre><code>from typing import List\n\n\ndef smallerNumbersThanCurrent(nums: List[int]) -&gt; List[int]:\n    sortedNums = sorted(nums)\n\n    hashmap = dict()\n\n    for i, num in enumerate(sortedNums):\n        if num not in hashmap:\n            hashmap[num] = i\n\n    result = []\n    for i in range(len(sortedNums)):\n        result.append(hashmap[nums[i]])\n\n    return result\n\n\nnums = [8, 1, 2, 2, 3]\nprint(smallerNumbersThanCurrent(nums))  # [4, 0, 1, 1, 3]\n</code></pre>"},{"location":"leetpattern/hash_map/#202-happy-number","title":"202. Happy Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, math, two pointers</p> </li> <li>Return <code>True</code> if the number is a happy number, otherwise, return <code>False</code>.</li> <li>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.</li> </ul> 202. Happy Number - Python Solution<pre><code>def isHappy(n: int) -&gt; bool:\n\n    def getSum(n):\n        sum_of_squares = 0\n        while n:\n            a, b = divmod(n, 10)\n            sum_of_squares += b**2\n            n = a\n        return sum_of_squares\n\n    record = set()\n\n    while True:\n        if n == 1:\n            return True\n\n        if n in record:\n            return False\n        else:\n            record.add(n)\n\n        n = getSum(n)\n\n\nn = 19\nprint(isHappy(n))  # True\n</code></pre>"},{"location":"leetpattern/hash_map/#454-4sum-ii","title":"454. 4Sum II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table</p> </li> <li>Return the number of tuples <code>(i, j, k, l)</code> such that <code>A[i] + B[j] + C[k] + D[l] == 0</code>.</li> </ul> 454. 4Sum II - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\ndef fourSumCount(\n    nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]\n) -&gt; int:\n\n    sumAB = defaultdict(int)\n    result = 0\n\n    for i in nums1:\n        for j in nums2:\n            sumAB[i + j] += 1\n\n    for i in nums3:\n        for j in nums4:\n            if -(i + j) in sumAB:\n                result += sumAB[-(i + j)]\n\n    return result\n\n\nnums1 = [1, 2]\nnums2 = [-2, -1]\nnums3 = [-1, 2]\nnums4 = [0, 2]\nprint(fourSumCount(nums1, nums2, nums3, nums4))  # 2\n</code></pre>"},{"location":"leetpattern/hash_set/","title":"Hash Set","text":"<ul> <li> 349. Intersection of Two Arrays (Easy)</li> </ul>"},{"location":"leetpattern/hash_set/#349-intersection-of-two-arrays","title":"349. Intersection of Two Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, two pointers, binary search, sorting</p> </li> </ul> 349. Intersection of Two Arrays - Python Solution<pre><code>from typing import List\n\n\n# Set\ndef intersectionSet(nums1: List[int], nums2: List[int]) -&gt; List[int]:\n    set1 = set(nums1)\n    set2 = set(nums2)\n    return list(set1 &amp; set2)\n\n\n# Hash\ndef intersectionHash(nums1: List[int], nums2: List[int]) -&gt; List[int]:\n    set1 = set(nums1)\n    result = set()\n\n    for num in nums2:\n        if num in set1:\n            result.add(num)\n\n    return list(result)\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |     Set    | O(n+m) |  O(n+m) |\n# |    Hash    | O(n+m) |   O(n)  |\n# |------------|--------|---------|\n\n\nnums1 = [1, 2, 2, 1]\nnums2 = [2, 2]\nprint(intersectionSet(nums1, nums2))  # [2]\nprint(intersectionHash(nums1, nums2))  # [2]\n</code></pre>"},{"location":"leetpattern/heap/","title":"Heap","text":"<ul> <li> 1046. Last Stone Weight (Easy)</li> </ul>"},{"location":"leetpattern/heap/#1046-last-stone-weight","title":"1046. Last Stone Weight","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, heap priority queue</p> </li> </ul> 1046. Last Stone Weight - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Heap\ndef lastStoneWeightHeap(stones: List[int]) -&gt; int:\n    heap = [-stone for stone in stones]\n    heapq.heapify(heap)\n\n    while len(heap) &gt; 1:\n        s1 = heapq.heappop(heap)\n        s2 = heapq.heappop(heap)\n\n        if s1 != s2:\n            heapq.heappush(heap, s1 - s2)\n\n    return -heap[0] if heap else 0\n\n\n# 0/1 Knapsack\ndef lastStoneWeightKnapsack(stones: List[int]) -&gt; int:\n    total = sum(stones)\n    target = total // 2\n\n    dp = [0 for _ in range(target + 1)]\n\n    for i in stones:\n        for j in range(target, i - 1, -1):\n            dp[j] = max(dp[j], dp[j - i] + i)\n\n    return total - 2 * dp[target]\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Heap     |   O(n log n)    |     O(n)     |\n# |  Knapsack   |      O(n)       |     O(n)     |\n# |-------------|-----------------|--------------|\n\n\nstones = [2, 7, 4, 1, 8, 1]\nprint(lastStoneWeightHeap(stones))  # 1\nprint(lastStoneWeightKnapsack(stones))  # 1\n</code></pre>"},{"location":"leetpattern/heap_merge_k_sorted/","title":"Heap Merge K Sorted","text":"<ul> <li> 23. Merge k Sorted Lists (Hard)</li> <li> 373. Find K Pairs with Smallest Sums (Medium)</li> <li> 378. Kth Smallest Element in a Sorted Matrix (Medium)</li> </ul>"},{"location":"leetpattern/heap_merge_k_sorted/#23-merge-k-sorted-lists","title":"23. Merge k Sorted Lists","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: linked list, divide and conquer, heap priority queue, merge sort</p> </li> <li>Prerequisite: 21. Merge Two Sorted Lists</li> </ul> 23. Merge k Sorted Lists - Python Solution<pre><code>import copy\nimport heapq\nfrom typing import List, Optional\n\nfrom template import ListNode\n\n\n# Divide and Conquer\ndef mergeKListsDC(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    if not lists or len(lists) == 0:\n        return None\n\n    def mergeTwo(l1, l2):\n        dummy = ListNode()\n        cur = dummy\n\n        while l1 and l2:\n            if l1.val &lt; l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n\n            cur = cur.next\n\n        cur.next = l1 if l1 else l2\n\n        return dummy.next\n\n    while len(lists) &gt; 1:\n        merged = []\n\n        for i in range(0, len(lists), 2):\n            l1 = lists[i]\n            l2 = lists[i + 1] if i + 1 &lt; len(lists) else None\n            merged.append(mergeTwo(l1, l2))\n\n        lists = merged\n\n    return lists[0]\n\n\n# Heap - Merge k Sorted\ndef mergeKLists(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    minHeap = []  # (val, idx, node)\n\n    for idx, head in enumerate(lists):\n        if head:\n            heapq.heappush(minHeap, (head.val, idx, head))\n\n    while minHeap:\n        _, idx, node = heapq.heappop(minHeap)\n        cur.next = node\n        cur = cur.next\n\n        node = node.next\n        if node:\n            heapq.heappush(minHeap, (node.val, idx, node))\n\n    return dummy.next\n\n\nn1 = ListNode.create([1, 4, 5])\nn2 = ListNode.create([1, 3, 4])\nn3 = ListNode.create([2, 6])\nlists = [n1, n2, n3]\nlists1 = copy.deepcopy(lists)\nlists2 = copy.deepcopy(lists)\nprint(mergeKListsDC(lists1))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6\nprint(mergeKLists(lists2))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6\n</code></pre>"},{"location":"leetpattern/heap_merge_k_sorted/#373-find-k-pairs-with-smallest-sums","title":"373. Find K Pairs with Smallest Sums","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, heap priority queue</p> </li> </ul> 373. Find K Pairs with Smallest Sums - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Heap - Merge K Sorted\ndef kSmallestPairs(\n    nums1: List[int], nums2: List[int], k: int\n) -&gt; List[List[int]]:\n    if not nums1 or not nums2 or k &lt;= 0:\n        return []\n\n    result = []\n    min_heap = []\n\n    for j in range(min(k, len(nums2))):\n        heapq.heappush(min_heap, (nums1[0] + nums2[j], 0, j))\n\n    while k &gt; 0 and min_heap:\n        _, i, j = heapq.heappop(min_heap)\n        result.append([nums1[i], nums2[j]])\n        k -= 1\n\n        if i + 1 &lt; len(nums1):\n            heapq.heappush(min_heap, (nums1[i + 1] + nums2[j], i + 1, j))\n\n    return result\n\n\nnums1 = [1, 2, 4, 5, 6]\nnums2 = [3, 5, 7, 9]\nk = 3\nprint(kSmallestPairs(nums1, nums2, k))\n# [[1, 3], [2, 3], [1, 5]]\n</code></pre>"},{"location":"leetpattern/heap_merge_k_sorted/#378-kth-smallest-element-in-a-sorted-matrix","title":"378. Kth Smallest Element in a Sorted Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sorting, heap priority queue, matrix</p> </li> <li>Given an <code>n x n</code> matrix where each of the rows and columns are sorted in ascending order, return the <code>k-th</code> smallest element in the matrix.</li> </ul> 378. Kth Smallest Element in a Sorted Matrix - Python Solution<pre><code>from heapq import heapify, heappop, heappush\nfrom typing import List\n\n\n# Heap - Merge K Sorted\ndef kthSmallestHeap(matrix: List[List[int]], k: int) -&gt; int:\n    n = len(matrix)\n    heap = [(matrix[i][0], i, 0) for i in range(n)]\n    heapify(heap)\n\n    for _ in range(k - 1):\n        _, row, col = heappop(heap)\n\n        if col + 1 &lt; n:\n            heappush(heap, (matrix[row][col + 1], row, col + 1))\n\n    return heappop(heap)[0]\n\n\n# Binary Search\ndef kthSmallestBinarySearch(matrix: List[List[int]], k: int) -&gt; int:\n    n = len(matrix)\n\n    def check(mid):\n        i, j = n - 1, 0\n        num = 0\n\n        while i &gt;= 0 and j &lt; n:\n            if matrix[i][j] &lt;= mid:\n                num += i + 1\n                j += 1\n            else:\n                i -= 1\n\n        return num &gt;= k\n\n    left, right = matrix[0][0], matrix[-1][-1]\n\n    while left &lt; right:\n        mid = (left + right) // 2\n        if check(mid):\n            right = mid\n        else:\n            left = mid + 1\n\n    return left\n\n\nmatrix = [[1, 5, 9], [10, 11, 13], [12, 13, 15]]\nk = 8\n\nprint(kthSmallestHeap(matrix, k))  # 13\nprint(kthSmallestBinarySearch(matrix, k))  # 13\n</code></pre>"},{"location":"leetpattern/heap_top_k/","title":"Heap Top K","text":"<ul> <li> 215. Kth Largest Element in an Array (Medium)</li> <li> 973. K Closest Points to Origin (Medium)</li> <li> 347. Top K Frequent Elements (Medium)</li> <li> 692. Top K Frequent Words (Medium)</li> <li> 264. Ugly Number II (Medium)</li> <li> 451. Sort Characters By Frequency (Medium)</li> <li> 703. Kth Largest Element in a Stream (Easy)</li> <li> 767. Reorganize String (Medium)</li> <li> 786. K-th Smallest Prime Fraction (Medium)</li> </ul>"},{"location":"leetpattern/heap_top_k/#215-kth-largest-element-in-an-array","title":"215. Kth Largest Element in an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, divide and conquer, sorting, heap priority queue, quickselect</p> </li> </ul> 215. Kth Largest Element in an Array - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\ndef findKthLargest(nums: List[int], k: int) -&gt; int:\n    heap = nums[:k]\n    heapq.heapify(heap)  # min heap\n\n    for num in nums[k:]:\n        if num &gt; heap[0]:\n            heapq.heappop(heap)  # pop the smallest element\n            heapq.heappush(heap, num)  # push the new element\n\n    return heap[0]\n\n\n# Time complexity: O(n * log(k))\n#   - O(log(k)) for heapify\n#   - O(n) for iterating through the input list\n# Space complexity: O(k)\n\nnums = [3, 2, 1, 5, 6, 4]\nk = 2\nprint(findKthLargest(nums, k))  # 5\n</code></pre>"},{"location":"leetpattern/heap_top_k/#973-k-closest-points-to-origin","title":"973. K Closest Points to Origin","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, divide and conquer, geometry, sorting, heap priority queue, quickselect</p> </li> </ul> 973. K Closest Points to Origin - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\ndef kClosest(points: List[List[int]], k: int) -&gt; List[List[int]]:\n    heap = []\n\n    for x, y in points:\n        dist = -(x**2 + y**2)  # max heap\n        if len(heap) &lt; k:\n            heapq.heappush(heap, (dist, x, y))\n        else:\n            heapq.heappushpop(heap, (dist, x, y))  # push and pop the smallest\n\n    return [[x, y] for (_, x, y) in heap]\n\n\n# Time complexity: O(n * log(k))\n#   - O(log(k)) for heapify\n#   - O(n) for iterating through the input list\n# Space complexity: O(k)\n\npoints = [[1, 3], [-2, 2]]\nk = 1\nprint(kClosest(points, k))  # [[-2, 2]]\n</code></pre>"},{"location":"leetpattern/heap_top_k/#347-top-k-frequent-elements","title":"347. Top K Frequent Elements","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, divide and conquer, sorting, heap priority queue, bucket sort, counting, quickselect</p> </li> </ul> 347. Top K Frequent Elements - Python Solution<pre><code>import heapq\nfrom collections import Counter\nfrom typing import List\n\n\n# Heap + Counter\ndef topKFrequent(nums: List[int], k: int) -&gt; List[int]:\n    minHeap = []\n\n    for val, freq in Counter(nums).items():\n        if len(minHeap) &lt; k:\n            heapq.heappush(minHeap, (freq, val))\n        else:\n            heapq.heappushpop(minHeap, (freq, val))\n\n    return [i for _, i in minHeap]\n\n\n# Counter (Most Common)\ndef topKFrequentCounter(nums: List[int], k: int) -&gt; List[int]:\n    commons = Counter(nums).most_common(k)\n    return [i for i, _ in commons]\n\n\nnums = [1, 1, 1, 2, 2, 3]\nk = 2\nprint(topKFrequent(nums, k))  # [1, 2]\nprint(topKFrequentCounter(nums, k))  # [1, 2]\n</code></pre>"},{"location":"leetpattern/heap_top_k/#692-top-k-frequent-words","title":"692. Top K Frequent Words","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, trie, sorting, heap priority queue, bucket sort, counting</p> </li> </ul> 692. Top K Frequent Words - Python Solution<pre><code>import heapq\nfrom collections import Counter\nfrom typing import List\n\n\nclass WordFrequency:\n    def __init__(self, word, freq):\n        self.word = word\n        self.freq = freq\n\n    def __lt__(self, other):\n        # If the frequency is different\n        if self.freq != other.freq:\n            # The word with the lower frequency comes first\n            return self.freq &lt; other.freq\n        else:\n            # The word with the lower alphabetical order comes first\n            return self.word &gt; other.word\n\n\ndef topKFrequent(words: List[str], k: int) -&gt; List[str]:\n    heap = []\n\n    for word, freq in Counter(words).items():\n        heapq.heappush(heap, WordFrequency(word, freq))\n\n        if len(heap) &gt; k:\n            heapq.heappop(heap)\n\n    heap.sort(reverse=True)\n    return [x.word for x in heap]\n\n\nwords = [\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"]\nk = 2\nprint(topKFrequent(words, k))  # [\"i\", \"love\"]\n</code></pre>"},{"location":"leetpattern/heap_top_k/#264-ugly-number-ii","title":"264. Ugly Number II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, math, dynamic programming, heap priority queue</p> </li> </ul> 264. Ugly Number II - Python Solution<pre><code>import heapq\n\n\ndef nthUglyNumber(n: int) -&gt; int:\n    heap = [1]\n    seen = set(heap)\n\n    factors = [2, 3, 5]\n    current = 1\n\n    # Pop the smallest ugly number n times\n    for _ in range(n):\n        current = heapq.heappop(heap)  # Pop the smallest ugly number\n\n        for factor in factors:\n            new = current * factor\n            if new not in seen:\n                seen.add(new)\n                heapq.heappush(heap, new)\n\n    return current\n\n\nprint(nthUglyNumber(10))  # 12\n</code></pre>"},{"location":"leetpattern/heap_top_k/#451-sort-characters-by-frequency","title":"451. Sort Characters By Frequency","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sorting, heap priority queue, bucket sort, counting</p> </li> </ul> 451. Sort Characters By Frequency - Python Solution<pre><code>import heapq\nfrom collections import Counter\n\n\ndef frequencySort(s: str) -&gt; str:\n    result = \"\"\n\n    # Max Heap\n    heap = [(-freq, val) for val, freq in Counter(s).items()]\n    heapq.heapify(heap)\n\n    while heap:\n        freq, val = heapq.heappop(heap)\n        result += val * -freq\n\n    return result\n\n\nprint(frequencySort(\"tree\"))  # eert\n</code></pre>"},{"location":"leetpattern/heap_top_k/#703-kth-largest-element-in-a-stream","title":"703. Kth Largest Element in a Stream","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, design, binary search tree, heap priority queue, binary tree, data stream</p> </li> </ul> 703. Kth Largest Element in a Stream - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Heap\nclass KthLargest:\n\n    def __init__(self, k: int, nums: List[int]):\n        self.k = k\n        self.heap = []\n        for num in nums:\n            self.add(num)\n\n    def add(self, val: int) -&gt; int:\n        heapq.heappush(self.heap, val)\n\n        if len(self.heap) &gt; self.k:\n            heapq.heappop(self.heap)\n\n        return self.heap[0]\n\n\nobj = KthLargest(3, [4, 5, 8, 2])\nprint(obj.add(3))  # 4\nprint(obj.add(5))  # 5\nprint(obj.add(10))  # 5\n</code></pre>"},{"location":"leetpattern/heap_top_k/#767-reorganize-string","title":"767. Reorganize String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, greedy, sorting, heap priority queue, counting</p> </li> </ul> 767. Reorganize String - Python Solution<pre><code>import heapq\nfrom collections import Counter\n\n\ndef reorganizeString(s: str) -&gt; str:\n    if not s:\n        return \"\"\n\n    heap = [(-freq, char) for char, freq in Counter(s).items()]  # max heap\n    heapq.heapify(heap)\n\n    result = []\n    prev_count, prev_char = 0, \"\"\n\n    while heap:\n        count, char = heapq.heappop(heap)  # pop the most frequent character\n        result.append(char)  # append the character to the result\n\n        if (\n            prev_count &lt; 0\n        ):  # if the previous character still has remaining count\n            heapq.heappush(heap, (prev_count, prev_char))\n\n        prev_count = (\n            count + 1\n        )  # update the current character's remaining count\n        prev_char = char  # update the current character\n\n    # check if there is any invalid result\n    if len(result) != len(s):\n        return \"\"\n\n    return \"\".join(result)\n\n\nprint(reorganizeString(\"aab\"))\n</code></pre>"},{"location":"leetpattern/heap_top_k/#786-k-th-smallest-prime-fraction","title":"786. K-th Smallest Prime Fraction","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, sorting, heap priority queue</p> </li> </ul> 786. K-th Smallest Prime Fraction - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\ndef kthSmallestPrimeFraction(arr: List[int], k: int) -&gt; List[int]:\n    max_heap = []\n\n    for j in range(1, len(arr)):\n        for i in range(j):\n            heapq.heappush(max_heap, (-arr[i] / arr[j], arr[i], arr[j]))\n\n            if len(max_heap) &gt; k:\n                heapq.heappop(max_heap)\n\n    return [max_heap[0][1], max_heap[0][2]]\n\n\narr = [1, 2, 3, 5]\nk = 3\nprint(kthSmallestPrimeFraction(arr, k))  # [2, 5]\n</code></pre>"},{"location":"leetpattern/heap_two_heaps/","title":"Heap Two Heaps","text":"<ul> <li> 295. Find Median from Data Stream (Hard)</li> <li> 480. Sliding Window Median (Hard)</li> <li> 502. IPO (Hard)</li> </ul>"},{"location":"leetpattern/heap_two_heaps/#295-find-median-from-data-stream","title":"295. Find Median from Data Stream","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: two pointers, design, sorting, heap priority queue, data stream</p> </li> </ul> 295. Find Median from Data Stream - Python Solution<pre><code>from heapq import heappop, heappush\n\n\n# Heap - Two Heaps\nclass MedianFinder:\n    def __init__(self):\n        self.max = []\n        self.min = []\n\n    def addNum(self, num: int) -&gt; None:\n        heappush(self.max, -num)\n        heappush(self.min, -heappop(self.max))\n\n        if len(self.min) &gt; len(self.max):\n            heappush(self.max, -heappop(self.min))\n\n    def findMedian(self) -&gt; float:\n        if len(self.max) == len(self.min):\n            return (-self.max[0] + self.min[0]) / 2.0\n        else:\n            return -self.max[0]\n\n\n# TC: O(log n)\n# SC: O(n)\n\nmedian_finder = MedianFinder()\nmedian_finder.addNum(1)\nmedian_finder.addNum(2)\nassert median_finder.findMedian() == 1.5\nmedian_finder.addNum(3)\nassert median_finder.findMedian() == 2\nmedian_finder.addNum(4)\nassert median_finder.findMedian() == 2.5\nmedian_finder.addNum(5)\nassert median_finder.findMedian() == 3\nprint(\"All Passed.\")\n</code></pre>"},{"location":"leetpattern/heap_two_heaps/#480-sliding-window-median","title":"480. Sliding Window Median","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, sliding window, heap priority queue</p> </li> </ul> 480. Sliding Window Median - Python Solution<pre><code>import heapq\nfrom typing import List\n\nfrom sortedcontainers import SortedList\n\n\n# Heap - Two Heaps\ndef medianSlidingWindow1(nums: List[int], k: int) -&gt; List[float]:\n    min_heap, max_heap = [], []\n\n    for i in range(k):\n        heapq.heappush(min_heap, (nums[i], i))\n    for i in range(k // 2):\n        n, idx = heapq.heappop(min_heap)\n        heapq.heappush(max_heap, (-n, idx))\n\n    res = [\n        (\n            (min_heap[0][0] - max_heap[0][0]) / 2\n            if k % 2 == 0\n            else min_heap[0][0] * 1.0\n        )\n    ]\n\n    for i in range(k, len(nums)):\n        if nums[i] &lt; min_heap[0][0]:\n            heapq.heappush(max_heap, (-nums[i], i))\n\n            if nums[i - k] &gt;= min_heap[0][0]:\n                n, idx = heapq.heappop(max_heap)\n                heapq.heappush(min_heap, (-n, idx))\n        else:\n            heapq.heappush(min_heap, (nums[i], i))\n\n            if nums[i - k] &lt;= min_heap[0][0]:\n                n, idx = heapq.heappop(min_heap)\n                heapq.heappush(max_heap, (-n, idx))\n\n        while min_heap and min_heap[0][1] &lt;= i - k:\n            heapq.heappop(min_heap)\n        while max_heap and max_heap[0][1] &lt;= i - k:\n            heapq.heappop(max_heap)\n\n        res.append(\n            (min_heap[0][0] - max_heap[0][0]) / 2\n            if k % 2 == 0\n            else min_heap[0][0] * 1.0\n        )\n\n    return res\n\n\n# Sorted List\ndef medianSlidingWindow2(nums: List[int], k: int) -&gt; List[float]:\n    window = SortedList()\n    res = []\n\n    for i in range(len(nums)):\n        window.add(nums[i])\n\n        if len(window) == k:\n            if k % 2 == 1:\n                res.append(window[k // 2])\n            else:\n                res.append((window[k // 2 - 1] + window[k // 2]) / 2.0)\n\n            window.remove(nums[i - k + 1])\n\n    return res\n\n\nnums = [1, 2, 3, 4, 2, 3, 1, 4, 2]\nk = 3\nprint(medianSlidingWindow1(nums, k))\nprint(medianSlidingWindow2(nums, k))\n</code></pre>"},{"location":"leetpattern/heap_two_heaps/#502-ipo","title":"502. IPO","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, greedy, sorting, heap priority queue</p> </li> </ul> 502. IPO - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Heap - Two Heaps\ndef findMaximizedCapital(\n    k: int, w: int, profits: List[int], capital: List[int]\n) -&gt; int:\n    if not profits or not capital:\n        return w\n\n    minHeap = []\n    maxHeap = []\n\n    for i in range(len(profits)):\n        heapq.heappush(minHeap, (capital[i], profits[i]))\n\n    for _ in range(k):\n        while minHeap and minHeap[0][0] &lt;= w:\n            capital, profit = heapq.heappop(minHeap)\n            heapq.heappush(maxHeap, -profit)\n\n        if not maxHeap:\n            break\n\n        w += -heapq.heappop(maxHeap)\n\n    return w\n\n\nk = 2\nw = 0\nprofits = [1, 2, 3]\ncapital = [0, 1, 1]\nprint(findMaximizedCapital(k, w, profits, capital))  # 4\n</code></pre>"},{"location":"leetpattern/intervals/","title":"Intervals","text":"<ul> <li> 55. Jump Game (Medium)</li> <li> 45. Jump Game II (Medium)</li> <li> 452. Minimum Number of Arrows to Burst Balloons (Medium)</li> <li> 435. Non-overlapping Intervals (Medium)</li> <li> 763. Partition Labels (Medium)</li> <li> 56. Merge Intervals (Medium)</li> </ul>"},{"location":"leetpattern/intervals/#55-jump-game","title":"55. Jump Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> <li>Return <code>True</code> if you can reach the last index, otherwise <code>False</code>.</li> </ul> <ul> <li>Example: <code>[2, 3, 1, 1, 4, 1, 2, 0, 0]</code></li> </ul> Index Value Index + Value Max Reach Max Reach &gt;= Last Index 0 2 2 2 False 1 3 4 4 False 2 1 3 4 False 3 1 4 4 False 4 4 8 8 True 5 1 6 8 True 6 2 8 8 True 7 0 7 8 True 8 0 8 8 True 55. Jump Game - Python Solution<pre><code>from typing import List\n\n\n# Greedy - Interval\ndef canJump(nums: List[int]) -&gt; bool:\n    maxReach = 0\n    i = 0\n    n = len(nums)\n\n    while i &lt;= maxReach:\n        maxReach = max(maxReach, i + nums[i])\n        if maxReach &gt;= n - 1:\n            return True\n        i += 1\n\n    return False\n\n\nprint(canJump([2, 3, 1, 1, 4, 1, 2, 0, 0]))  # True\n</code></pre>"},{"location":"leetpattern/intervals/#45-jump-game-ii","title":"45. Jump Game II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> <li>Return the minimum number of jumps to reach the last index.</li> </ul> 45. Jump Game II - Python Solution<pre><code>from typing import List\n\n\n# Greedy - Interval\ndef jump(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if len(nums) == 1:\n        return 0\n\n    maxReach = 0\n    step = 0\n    left, right = 0, 0\n\n    while right &lt; n - 1:\n        for i in range(left, right + 1):\n            maxReach = max(maxReach, i + nums[i])\n        left = right + 1\n        right = maxReach\n        step += 1\n\n    return step\n\n\nprint(jump([2, 3, 1, 1, 4, 2, 1]))  # 3\n</code></pre>"},{"location":"leetpattern/intervals/#452-minimum-number-of-arrows-to-burst-balloons","title":"452. Minimum Number of Arrows to Burst Balloons","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> <li>Return the minimum number of arrows.</li> </ul> <ul> <li>Differece between two versions<ol> <li>Start from 1: if there is no overlap, we add one more arrow.</li> <li>Start from the number of balloons: if there is overlap, we need to reduce one arrow.</li> </ol> </li> </ul> 452. Minimum Number of Arrows to Burst Balloons - Python Solution<pre><code>from typing import List\n\nimport matplotlib.pyplot as plt\n\n\n# Greedy - Interval\ndef findMinArrowShotsGreedy1(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    if n &lt;= 1:\n        return n\n\n    res = 1\n    points.sort(key=lambda x: x[0])\n\n    for i in range(1, n):\n        if points[i][0] &gt; points[i - 1][1]:\n            res += 1\n        else:\n            points[i][1] = min(points[i][1], points[i - 1][1])\n    return res\n\n\n# Greedy - Interval (Neetcode's version)\ndef findMinArrowShotsGreedy2(points: List[List[int]]) -&gt; int:\n    res = len(points)\n    if res == 0:\n        return 0\n\n    points.sort()\n    prev = points[0]\n\n    for i in range(1, len(points)):\n        cur = points[i]\n        if cur[0] &lt;= prev[1]:\n            res -= 1\n            prev = [cur[0], min(prev[1], cur[1])]\n        else:\n            prev = cur\n\n    return res\n\n\n# Greedy - Interval\ndef findMinArrowShotsGreedy3(points: List[List[int]]) -&gt; int:\n    if not points:\n        return 0\n\n    points.sort(key=lambda x: x[1])\n\n    res = 1\n    cur_end = points[0][1]\n\n    for i in range(1, len(points)):\n        if points[i][0] &gt; cur_end:\n            res += 1\n            cur_end = points[i][1]\n\n    return res\n\n\n# Utility\ndef plot(points, i=None):\n    plt.figure(figsize=(8, 4))\n    for idx in range(len(points)):\n        color = \"b\" if idx == i else \"k\"\n        plt.plot(\n            [points[idx][0], points[idx][1]],\n            [idx + 1, idx + 1],\n            f\"{color}o-\",\n            label=f\"Line {idx + 1}\",\n        )\n\n    plt.title(\"Find Min Arrow Shots\")\n    plt.xlabel(\"X-axis\")\n    plt.xlim(0, 17)\n    plt.grid(True)\n    plt.savefig(f\"find_min_arrow_shots_{i}.png\")\n    plt.show()\n\n\n# |------------|-----------|---------|\n# |  Approach  |  Time     |  Space  |\n# |------------|-----------|---------|\n# |  Greedy    |  O(NlogN) |  O(1)   |\n# |------------|-----------|---------|\n\n\npoints = [[10, 16], [2, 8], [1, 6], [7, 12]]\nprint(findMinArrowShotsGreedy1(points))  # 2\nprint(findMinArrowShotsGreedy2(points))  # 2\n</code></pre>"},{"location":"leetpattern/intervals/#435-non-overlapping-intervals","title":"435. Non-overlapping Intervals","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy, sorting</p> </li> </ul> 435. Non-overlapping Intervals - Python Solution<pre><code>from typing import List\n\n\ndef eraseOverlapIntervals(intervals: List[List[int]]) -&gt; int:\n    if len(intervals) &lt;= 1:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n    result = 0\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &gt;= intervals[i - 1][1]:\n            continue\n        else:\n            result += 1\n            intervals[i][1] = min(intervals[i][1], intervals[i - 1][1])\n\n    return result\n\n\nprint(eraseOverlapIntervals([[1, 2], [2, 3], [3, 4], [1, 3]]))  # 1\n</code></pre>"},{"location":"leetpattern/intervals/#763-partition-labels","title":"763. Partition Labels","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, two pointers, string, greedy</p> </li> </ul> 763. Partition Labels - Python Solution<pre><code>from typing import List\n\n\n# 1. Hashmap\ndef partitionLabels1(s: str) -&gt; List[int]:\n    # Time complexity: O(nlogn)\n    # Space complexity: O(n)\n    hashmap = {}\n\n    for i, j in enumerate(s):\n        if j not in hashmap:\n            hashmap[j] = [i, i]\n        else:\n            hashmap[j][1] = i\n\n    intervals = list(hashmap.values())\n    intervals.sort(key=lambda x: x[0])\n\n    if len(intervals) &lt; 2:\n        return len(intervals)\n\n    result = []\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &lt; intervals[i - 1][1]:\n            intervals[i][1] = max(intervals[i][1], intervals[i - 1][1])\n        else:\n            result.append(intervals[i][0])\n\n    result.append(intervals[-1][1] + 1)\n\n    if len(result) == 1:\n        return result\n    else:\n        for i in range(len(result) - 1, 0, -1):\n            result[i] -= result[i - 1]\n        return result\n\n\n# 2. Single Pass Partitioning\ndef partitionLabels2(s: str) -&gt; List[int]:\n    # Time complexity: O(n)\n    # Space complexity: O(n)\n    last = {c: i for i, c in enumerate(s)}\n\n    start, end = 0, 0\n    result = []\n\n    for i, c in enumerate(s):\n        end = max(end, last[c])\n        if i == end:\n            result.append(end - start + 1)\n            start = i + 1\n\n    return result\n\n\nprint(partitionLabels1(\"abaccd\"))  # [3, 2, 1]\nprint(partitionLabels2(\"abaccd\"))  # [3, 2, 1]\n</code></pre>"},{"location":"leetpattern/intervals/#56-merge-intervals","title":"56. Merge Intervals","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sorting</p> </li> <li>Merge all overlapping intervals.</li> </ul> 56. Merge Intervals - Python Solution<pre><code>from typing import List\n\n\n# Intervals\ndef merge(intervals: List[List[int]]) -&gt; List[List[int]]:\n    n = len(intervals)\n    if n &lt;= 1:\n        return intervals\n\n    intervals.sort(key=lambda x: x[0])\n    res = [intervals[0]]\n\n    for i in range(1, n):\n        if intervals[i][0] &lt;= res[-1][1]:\n            res[-1][1] = max(res[-1][1], intervals[i][1])\n        else:\n            res.append(intervals[i])\n\n    return res\n\n\nprint(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))\n# [[1, 6], [8, 10], [15, 18]]\n</code></pre>"},{"location":"leetpattern/kmp/","title":"KMP","text":"<ul> <li> 28. Find the Index of the First Occurrence in a String (Easy)</li> <li> 459. Repeated Substring Pattern (Easy)</li> <li> 686. Repeated String Match (Medium)</li> <li> 1392. Longest Happy Prefix (Hard)</li> <li> 214. Shortest Palindrome (Hard)</li> </ul>"},{"location":"leetpattern/kmp/#28-find-the-index-of-the-first-occurrence-in-a-string","title":"28. Find the Index of the First Occurrence in a String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string, string matching</p> </li> </ul> 28. Find the Index of the First Occurrence in a String - Python Solution<pre><code>from template import LPS\n\n\n# Brute Force\ndef strStrBF(haystack: str, needle: str) -&gt; int:\n    m, n = len(haystack), len(needle)\n    for i in range(m - n + 1):\n        if haystack[i : i + n] == needle:\n            return i\n    return -1\n\n\n# KMP\ndef strStrKMP(haystack: str, needle: str) -&gt; int:\n    lps = LPS(needle)\n    m, n = len(haystack), len(needle)\n    j = 0\n\n    for i in range(m):\n        while j &gt; 0 and haystack[i] != needle[j]:\n            j = lps[j - 1]\n        if haystack[i] == needle[j]:\n            j += 1\n        if j == n:\n            return i - n + 1\n    return -1\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# | Brute Force| O((m - n) * n)   | O(1)    |\n# | KMP        | O(m + n)         | O(n)    |\n# |------------|------------------|---------|\n\n\nhaystack = \"hello\"\nneedle = \"ll\"\nprint(strStrBF(haystack, needle))  # 2\nprint(strStrKMP(haystack, needle))  # 2\n</code></pre>"},{"location":"leetpattern/kmp/#459-repeated-substring-pattern","title":"459. Repeated Substring Pattern","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, string matching</p> </li> </ul> 459. Repeated Substring Pattern - Python Solution<pre><code>from template import LPS\n\n\n# KMP\ndef repeatedSubstringPattern(s: str) -&gt; bool:\n    lps = LPS(s)\n    length = len(s)\n\n    if lps[-1] != 0 and length % (length - lps[-1]) == 0:\n        return True\n\n    return False\n\n\ns = \"abab\"\nprint(repeatedSubstringPattern(s))  # True\n</code></pre>"},{"location":"leetpattern/kmp/#686-repeated-string-match","title":"686. Repeated String Match","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, string matching</p> </li> </ul> 686. Repeated String Match - Python Solution<pre><code>import math\n\nfrom template import LPS\n\n\n# KMP\ndef repeatedStringMatch(a: str, b: str) -&gt; int:\n    min_repeat = math.ceil(len(b) / len(a))\n\n    def kmp(text, pattern):\n        n, m = len(text), len(pattern)\n        lps = LPS(pattern)\n        j = 0\n\n        for i in range(n):\n            while j &gt; 0 and text[i] != pattern[j]:\n                j = lps[j - 1]\n            if text[i] == pattern[j]:\n                j += 1\n            if j == m:\n                return i - j + 1\n        return -1\n\n    for i in range(min_repeat, min_repeat + 2):\n        if kmp(a * i, b) != -1:\n            return i\n    return -1\n\n\nprint(repeatedStringMatch(\"abcd\", \"cdabcdab\"))  # 3\n</code></pre>"},{"location":"leetpattern/kmp/#1392-longest-happy-prefix","title":"1392. Longest Happy Prefix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, rolling hash, string matching, hash function</p> </li> </ul> 1392. Longest Happy Prefix - Python Solution<pre><code>from template import LPS\n\n\n# KMP\ndef longestPrefix(s: str) -&gt; str:\n    if len(s) &lt;= 1:\n        return \"\"\n\n    lps = LPS(s)\n\n    return s[: lps[-1]]\n\n\nprint(longestPrefix(\"ababab\"))  # abab\n</code></pre>"},{"location":"leetpattern/kmp/#214-shortest-palindrome","title":"214. Shortest Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, rolling hash, string matching, hash function</p> </li> </ul> 214. Shortest Palindrome - Python Solution<pre><code>from template import LPS\n\n\n# KMP\ndef shortestPalindrome(s: str) -&gt; str:\n    if not s:\n        return s\n\n    new = s + \"#\" + s[::-1]\n    lps = LPS(new)\n\n    add_len = len(s) - lps[-1]\n\n    return s[::-1][:add_len] + s\n\n\nprint(shortestPalindrome(\"aacecaaa\"))  # aaacecaaa\n</code></pre>"},{"location":"leetpattern/left_right_pointers/","title":"Left Right Pointers","text":"<ul> <li> 9. Palindrome Number (Easy)</li> <li> 15. 3Sum (Medium)</li> <li> 18. 4Sum (Medium)</li> <li> 69. Sqrt(x) (Easy)</li> <li> 88. Merge Sorted Array (Easy)</li> <li> 977. Squares of a Sorted Array (Easy)</li> <li> 881. Boats to Save People (Medium)</li> <li> 75. Sort Colors (Medium)</li> <li> 125. Valid Palindrome (Easy)</li> <li> 167. Two Sum II - Input Array Is Sorted (Medium)</li> <li> 11. Container With Most Water (Medium)</li> </ul>"},{"location":"leetpattern/left_right_pointers/#9-palindrome-number","title":"9. Palindrome Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math</p> </li> <li>Return true if the given number is a palindrome. Otherwise, return false.</li> </ul> 9. Palindrome Number - Python Solution<pre><code># Reverse\ndef isPalindromeReverse(x: int) -&gt; bool:\n    if x &lt; 0:\n        return False\n\n    return str(x) == str(x)[::-1]\n\n\n# Left Right Pointers\ndef isPalindromeLR(x: int) -&gt; bool:\n    if x &lt; 0:\n        return False\n\n    x = list(str(x))  # 121 -&gt; ['1', '2', '1']\n\n    left, right = 0, len(x) - 1\n\n    while left &lt; right:\n        if x[left] != x[right]:\n            return False\n        left += 1\n        right -= 1\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |  Reverse   |  O(N)  |   O(N)  |\n# | Left Right |  O(N)  |   O(1)  |\n# |------------|--------|---------|\n\n\nx = 121\nprint(isPalindromeReverse(x))  # True\nprint(isPalindromeLR(x))  # True\n</code></pre>"},{"location":"leetpattern/left_right_pointers/#15-3sum","title":"15. 3Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, sorting</p> </li> </ul> 15. 3Sum - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef threeSum(nums: List[int]) -&gt; List[List[int]]:\n    nums.sort()\n    res = []\n    n = len(nums)\n\n    for i in range(n - 2):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        left, right = i + 1, n - 1\n\n        while left &lt; right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total &gt; 0:\n                right -= 1\n            elif total &lt; 0:\n                left += 1\n            else:\n                res.append([nums[i], nums[left], nums[right]])\n\n                while left &lt; right and nums[left] == nums[left + 1]:\n                    left += 1\n\n                while left &lt; right and nums[right] == nums[right - 1]:\n                    right -= 1\n\n                left += 1\n                right -= 1\n\n    return res\n\n\nnums = [-1, 0, 1, 2, -1, -4]\nassert threeSum(nums) == [[-1, -1, 2], [-1, 0, 1]]\n</code></pre>"},{"location":"leetpattern/left_right_pointers/#18-4sum","title":"18. 4Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, sorting</p> </li> </ul> 18. 4Sum - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef fourSum(nums: List[int], target: int) -&gt; List[List[int]]:\n    \"\"\"Returns all unique quadruplets that sum up to the target.\"\"\"\n    nums.sort()\n    result = []\n\n    for i in range(len(nums) - 3):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        for j in range(i + 1, len(nums) - 2):\n            if j &gt; i + 1 and nums[j] == nums[j - 1]:\n                continue\n\n            left = j + 1\n            right = len(nums) - 1\n\n            while left &lt; right:\n                total = nums[i] + nums[j] + nums[left] + nums[right]\n\n                if total &gt; target:\n                    right -= 1\n                elif total &lt; target:\n                    left += 1\n                else:\n                    result.append([nums[i], nums[j], nums[left], nums[right]])\n                    while left &lt; right and nums[left] == nums[left + 1]:\n                        left += 1\n                    while left &lt; right and nums[right] == nums[right - 1]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n\n    return result\n\n\nnums = [1, 0, -1, 0, -2, 2]\ntarget = 0\nprint(fourSum(nums, target))\n# [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]\n</code></pre>"},{"location":"leetpattern/left_right_pointers/#69-sqrtx","title":"69. Sqrt(x)","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, binary search</p> </li> </ul> 69. Sqrt(x) - Python Solution<pre><code># Left Right Pointers\ndef mySqrt(x: int) -&gt; int:\n    \"\"\"Returns the square root of a number.\"\"\"\n    if x &lt; 2:\n        return x\n\n    left, right = 0, x // 2\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        if mid * mid &lt;= x &lt; (mid + 1) * (mid + 1):\n            return mid\n        elif mid * mid &lt; x:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n\nx = 8\nprint(mySqrt(x))  # 2\n</code></pre>"},{"location":"leetpattern/left_right_pointers/#88-merge-sorted-array","title":"88. Merge Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers, sorting</p> </li> </ul> 88. Merge Sorted Array - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef merge(nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None:\n    \"\"\"Merges two sorted arrays in-place.\"\"\"\n    p1, p2, t = m - 1, n - 1, m + n - 1\n\n    while p1 &gt;= 0 or p2 &gt;= 0:\n        if p1 == -1:\n            nums1[t] = nums2[p2]\n            p2 -= 1\n        elif p2 == -1:\n            nums1[t] = nums1[p1]\n            p1 -= 1\n        elif nums1[p1] &gt; nums2[p2]:\n            nums1[t] = nums1[p1]\n            p1 -= 1\n        else:\n            nums1[t] = nums2[p2]\n            p2 -= 1\n\n        t -= 1\n\n\nnums1 = [1, 2, 3, 0, 0, 0]\nm = 3\nnums2 = [2, 5, 6]\nn = 3\nmerge(nums1, m, nums2, n)\nprint(nums1)  # [1, 2, 2, 3, 5, 6]\n</code></pre>"},{"location":"leetpattern/left_right_pointers/#977-squares-of-a-sorted-array","title":"977. Squares of a Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, two pointers, sorting</p> </li> </ul> 977. Squares of a Sorted Array - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef sortedSquares(nums: List[int]) -&gt; List[int]:\n    \"\"\"Returns the squares of the sorted array.\"\"\"\n    n = len(nums)\n    result = [0 for _ in range(n)]\n\n    left, right, tail = 0, n - 1, n - 1\n\n    while left &lt;= right:\n        if abs(nums[left]) &gt;= abs(nums[right]):\n            result[tail] = nums[left] ** 2\n            left += 1\n        else:\n            result[tail] = nums[right] ** 2\n            right -= 1\n        tail -= 1\n\n    return result\n\n\n# |---------------------|------|-------|\n# | Approach            | Time | Space |\n# |---------------------|------|-------|\n# | Left Right Pointers | O(n) | O(n)  |\n# |---------------------|------|-------|\n\n\nnums = [-4, -1, 0, 3, 10]\nprint(sortedSquares(nums))  # [0, 1, 9, 16, 100]\n</code></pre>"},{"location":"leetpattern/left_right_pointers/#881-boats-to-save-people","title":"881. Boats to Save People","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy, sorting</p> </li> </ul> 881. Boats to Save People - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef numRescueBoats(people: List[int], limit: int) -&gt; int:\n    \"\"\"Returns the minimum number of boats to rescue people.\"\"\"\n    people.sort()\n    left, right = 0, len(people) - 1\n    boats = 0\n\n    while left &lt;= right:\n        if people[left] + people[right] &lt;= limit:\n            left += 1\n        right -= 1\n        boats += 1\n\n    return boats\n\n\npeople = [3, 2, 2, 1]\nlimit = 3\nprint(numRescueBoats(people, limit))  # 3\n</code></pre>"},{"location":"leetpattern/left_right_pointers/#75-sort-colors","title":"75. Sort Colors","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, sorting</p> </li> </ul> 75. Sort Colors - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef sortColors(nums: List[int]) -&gt; None:\n    \"\"\"Sorts an array of 0, 1, and 2 in-place.\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    current = 0\n\n    while current &lt;= right:\n        if nums[current] == 0:\n            nums[left], nums[current] = nums[current], nums[left]\n            left += 1\n            current += 1\n        elif nums[current] == 2:\n            nums[right], nums[current] = nums[current], nums[right]\n            right -= 1\n        else:\n            current += 1\n\n\nnums = [2, 0, 2, 1, 1, 0]\nsortColors(nums)\nprint(nums)  # [0, 0, 1, 1, 2, 2]\n</code></pre>"},{"location":"leetpattern/left_right_pointers/#125-valid-palindrome","title":"125. Valid Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string</p> </li> </ul> 125. Valid Palindrome - Python Solution<pre><code># List Comprehension\ndef isPalindrome(s: str) -&gt; bool:\n    s = [char.lower() for char in s if char.isalnum()]\n    return s == s[::-1]\n\n\n# Left Right Pointers\ndef isPalindromeLR(s: str) -&gt; bool:\n    left, right = 0, len(s) - 1\n\n    while left &lt; right:\n        while left &lt; right and not s[left].isalnum():\n            left += 1\n        while left &lt; right and not s[right].isalnum():\n            right -= 1\n\n        if s[left].lower() != s[right].lower():\n            return False\n\n        left += 1\n        right -= 1\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\ns = \"A man, a plan, a canal: Panama\"\nprint(isPalindrome(s))  # True\nprint(isPalindromeLR(s))  # True\n</code></pre>"},{"location":"leetpattern/left_right_pointers/#167-two-sum-ii-input-array-is-sorted","title":"167. Two Sum II - Input Array Is Sorted","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search</p> </li> </ul> 167. Two Sum II - Input Array Is Sorted - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef twoSum(numbers: List[int], target: int) -&gt; List[int]:\n    left, right = 0, len(numbers) - 1\n\n    while left &lt; right:\n        total = numbers[left] + numbers[right]\n\n        if total &gt; target:\n            right -= 1\n        elif total &lt; target:\n            left += 1\n        else:\n            return [left + 1, right + 1]\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nnumbers = [2, 7, 11, 15]\ntarget = 9\nprint(twoSum(numbers, target))  # [1, 2]\n</code></pre>"},{"location":"leetpattern/left_right_pointers/#11-container-with-most-water","title":"11. Container With Most Water","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy</p> </li> <li>Return the maximum area of water that can be trapped between the vertical lines.</li> </ul> <p></p> 11. Container With Most Water - Python Solution<pre><code>from typing import List\n\n\n# Brute Force\ndef maxAreaBF(height: List[int]) -&gt; int:\n    max_area = 0\n\n    for i in range(len(height)):\n        for j in range(i + 1, len(height)):\n            h = min(height[i], height[j])\n            w = j - i\n            max_area = max(max_area, h * w)\n\n    return max_area\n\n\n# Left Right Pointers\ndef maxAreaLR(height: List[int]) -&gt; int:\n    left, right = 0, len(height) - 1\n    res = 0\n\n    while left &lt; right:\n        h = min(height[left], height[right])\n        w = right - left\n        res = max(res, h * w)\n\n        if height[left] &lt; height[right]:\n            left += 1\n        else:\n            right -= 1\n\n    return res\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force| O(n^2) |  O(1)   |\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nheight = [1, 8, 6, 2, 5, 4, 8, 3, 7]\nprint(maxAreaBF(height))  # 49\nprint(maxAreaLR(height))  # 49\n</code></pre>"},{"location":"leetpattern/linked_list/","title":"Linked List","text":"<ul> <li> 203. Remove Linked List Elements (Easy)</li> <li> 707. Design Linked List (Medium)</li> <li> 206. Reverse Linked List (Easy)</li> <li> 237. Delete Node in a Linked List (Medium)</li> <li> 2487. Remove Nodes From Linked List (Medium)</li> <li> 24. Swap Nodes in Pairs (Medium)</li> <li> 19. Remove Nth Node From End of List (Medium)</li> <li> 160. Intersection of Two Linked Lists (Easy)</li> <li> 141. Linked List Cycle (Easy)</li> <li> 142. Linked List Cycle II (Medium)</li> <li> 2816. Double a Number Represented as a Linked List (Medium)</li> <li> 2. Add Two Numbers (Medium)</li> </ul>"},{"location":"leetpattern/linked_list/#203-remove-linked-list-elements","title":"203. Remove Linked List Elements","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: linked list, recursion</p> </li> <li> <p>Remove all elements from a linked list of integers that have value <code>val</code>.</p> </li> <li> <p>Before</p> </li> </ul> <pre><code>graph LR\nA((1)) --&gt; B((2))\nB --&gt; C((6))\nC --&gt; D((3))\nD --&gt; E((4))\nE --&gt; F((5))\nF --&gt; G((6))\nG --&gt; H((None))</code></pre> <ul> <li>After</li> </ul> <pre><code>graph LR\nA((1)) --&gt; B((2))\nB -.-&gt; C((6))\nC -.-&gt; D((3))\nD --&gt; E((4))\nE --&gt; F((5))\nF -.-&gt; G((6))\nB --&gt; D((3))\nF --&gt; I((None))</code></pre> 203. Remove Linked List Elements - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Iterative\ndef removeElements(head: Optional[ListNode], val: int) -&gt; Optional[ListNode]:\n    dummy = ListNode(0)\n    dummy.next = head\n    cur = dummy\n\n    while cur.next:\n        if cur.next.val == val:\n            cur.next = cur.next.next\n        else:\n            cur = cur.next\n\n    return dummy.next\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |  Iterative  |      O(N)       |    O(1)      |\n# |-------------|-----------------|--------------|\n\n\nnums = [1, 2, 6, 3, 4, 5, 6]\nval = 6\nhead = ListNode.create(nums)\nprint(head)\n# 1 -&gt; 2 -&gt; 6 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6\nprint(removeElements(head, val))\n# 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\n</code></pre>"},{"location":"leetpattern/linked_list/#707-design-linked-list","title":"707. Design Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, design</p> </li> <li>Design your implementation of the linked list. You can choose to use a singly or doubly linked list.</li> </ul> 707. Design Linked List - Python Solution<pre><code>class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass MyLinkedList:\n\n    def __init__(self):\n        self.dummy = ListNode()\n        self.size = 0\n\n    def get(self, index: int) -&gt; int:\n        if index &lt; 0 or index &gt;= self.size:\n            return -1\n\n        current = self.dummy.next\n        for _ in range(index):\n            current = current.next\n\n        return current.val\n\n    def addAtHead(self, val: int) -&gt; None:\n        self.dummy.next = ListNode(val, self.dummy.next)\n        self.size += 1\n\n    def addAtTail(self, val: int) -&gt; None:\n        current = self.dummy\n        while current.next:\n            current = current.next\n        current.next = ListNode(val)\n        self.size += 1\n\n    def addAtIndex(self, index: int, val: int) -&gt; None:\n        if index &lt; 0 or index &gt; self.size:\n            return\n\n        current = self.dummy\n        for i in range(index):\n            current = current.next\n        current.next = ListNode(val, current.next)\n        self.size += 1\n\n    def deleteAtIndex(self, index: int) -&gt; None:\n        if index &lt; 0 or index &gt;= self.size:\n            return\n\n        current = self.dummy\n        for i in range(index):\n            current = current.next\n        current.next = current.next.next\n        self.size -= 1\n\n\nll = MyLinkedList()\nll.addAtHead(1)\nll.addAtTail(3)\nll.addAtIndex(1, 2)  # 1 -&gt; 2 -&gt; 3\nprint(ll.get(1))  # 2\n</code></pre>"},{"location":"leetpattern/linked_list/#206-reverse-linked-list","title":"206. Reverse Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: linked list, recursion</p> </li> <li>Reverse a singly linked list.</li> </ul> <pre><code>graph LR\nA[1] --&gt; B[2]\nB --&gt; C[3]\nC --&gt; D[4]\nD --&gt; E[5]</code></pre> <pre><code>graph RL\nE[5] --&gt; D[4]\nD --&gt; C[3]\nC --&gt; B[2]\nB --&gt; A[1]</code></pre> 206. Reverse Linked List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Iterative\ndef reverseListIterative(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    cur = head\n    prev = None\n\n    while cur:\n        temp = cur.next\n        cur.next = prev\n\n        prev = cur\n        cur = temp\n\n    return prev\n\n\n# Recursive\ndef reverseListRecursive(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    def reverse(cur, prev=None):\n        if not cur:\n            return prev\n\n        temp = cur.next\n        cur.next = prev\n\n        return reverse(temp, cur)\n\n    return reverse(head)\n\n\nnums = [1, 2, 3, 4, 5]\nhead1 = ListNode.create(nums)\nprint(head1)\n# 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(reverseListIterative(head1))\n# 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1\nhead2 = ListNode.create(nums)\nprint(reverseListRecursive(head2))\n# 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1\n</code></pre>"},{"location":"leetpattern/linked_list/#237-delete-node-in-a-linked-list","title":"237. Delete Node in a Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list</p> </li> <li>Delete a node in a singly linked list. You are given only the node to be deleted.</li> </ul> 237. Delete Node in a Linked List - Python Solution<pre><code>from template import ListNode\n\n\ndef deleteNode(node: ListNode) -&gt; None:\n    node.val = node.next.val\n    node.next = node.next.next\n\n\nhead = ListNode.create([4, 5, 1, 9])\nnode = head.next\ndeleteNode(node)\nprint(head)  # 4 -&gt; 1 -&gt; 9\n</code></pre>"},{"location":"leetpattern/linked_list/#2487-remove-nodes-from-linked-list","title":"2487. Remove Nodes From Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, stack, recursion, monotonic stack</p> </li> <li>Remove all nodes from a linked list that have a value greater than <code>maxValue</code>.</li> </ul> 2487. Remove Nodes From Linked List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Recursive\ndef removeNodesRecursive(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    if not head:\n        return None\n\n    head.next = removeNodesRecursive(head.next)\n\n    if head.next and head.val &lt; head.next.val:\n        return head.next\n\n    return head\n\n\n# Iterative\ndef removeNodesIterative(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    stack = []\n    cur = head\n\n    while cur:\n        # pop all nodes in stack that are smaller than cur\n        while stack and cur.val &gt; stack[-1].val:\n            stack.pop()\n\n        stack.append(cur)\n        cur = cur.next\n\n    # link all nodes in stack\n    dummy = ListNode()\n    cur = dummy\n\n    for node in stack:\n        cur.next = node\n        cur = cur.next\n\n    return dummy.next\n\n\nhead = [5, 2, 13, 3, 8]\nhead1 = ListNode.create(head)\nprint(head1)  # 5 -&gt; 2 -&gt; 13 -&gt; 3 -&gt; 8\nprint(removeNodesRecursive(head1))  # 13 -&gt; 8\nhead2 = ListNode.create(head)\nprint(removeNodesIterative(head2))  # 13 -&gt; 8\n</code></pre>"},{"location":"leetpattern/linked_list/#24-swap-nodes-in-pairs","title":"24. Swap Nodes in Pairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, recursion</p> </li> <li>Given a linked list, swap every two adjacent nodes and return its head.</li> </ul> 24. Swap Nodes in Pairs - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\ndef swapPairs(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    dummy = ListNode(next=head)\n    cur = dummy\n\n    while cur.next and cur.next.next:\n        temp = cur.next\n        temp1 = cur.next.next.next\n\n        cur.next = cur.next.next\n        cur.next.next = temp\n        temp.next = temp1\n        cur = cur.next.next\n\n    return dummy.next\n\n\nnums = [1, 2, 3, 4, 5]\nhead = ListNode.create(nums)\nprint(head)\n# 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(swapPairs(head))\n# 2 -&gt; 1 -&gt; 4 -&gt; 3 -&gt; 5\n</code></pre>"},{"location":"leetpattern/linked_list/#19-remove-nth-node-from-end-of-list","title":"19. Remove Nth Node From End of List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, two pointers</p> </li> <li>Given the <code>head</code> of a linked list, remove the <code>n-th</code> node from the end of the list and return its head.</li> </ul> 19. Remove Nth Node From End of List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef removeNthFromEnd(head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:\n    dummy = ListNode(0, head)\n    fast = slow = dummy\n\n    for _ in range(n + 1):\n        fast = fast.next\n\n    while fast:\n        fast = fast.next\n        slow = slow.next\n\n    slow.next = slow.next.next\n\n    return dummy.next\n\n\nhead = [1, 2, 3, 4, 5]\nn = 2\nhead = ListNode.create(head)\nprint(head)  # 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(removeNthFromEnd(head, n))  # 1 -&gt; 2 -&gt; 3 -&gt; 5\n</code></pre>"},{"location":"leetpattern/linked_list/#160-intersection-of-two-linked-lists","title":"160. Intersection of Two Linked Lists","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, linked list, two pointers</p> </li> <li>Find the node at which the intersection of two singly linked lists begins.</li> </ul> <pre><code>graph LR\na1((a1)) --&gt; a2((a2))\na2 --&gt; c1((c1))\nb1((b1)) --&gt; b2((b2))\nb2 --&gt; b3((b3))\nb3 --&gt; c1\nc1 --&gt; c2((c2))\nc2 --&gt; c3((c3))</code></pre> 160. Intersection of Two Linked Lists - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Hash Set\ndef getIntersectionNodeHash(\n    headA: ListNode, headB: ListNode\n) -&gt; Optional[ListNode]:\n    \"\"\"Return the intersection node of two linked lists.\"\"\"\n    if not headA or not headB:\n        return None\n\n    visited = set()\n    cur = headA\n    while cur:\n        visited.add(cur)\n        cur = cur.next\n\n    cur = headB\n    while cur:\n        if cur in visited:\n            return cur\n        cur = cur.next\n\n    return None\n\n\n# Two Pointers\ndef getIntersectionNodeTP(\n    headA: ListNode, headB: ListNode\n) -&gt; Optional[ListNode]:\n    \"\"\"Return the intersection node of two linked lists.\"\"\"\n    if not headA or not headB:\n        return None\n\n    a, b = headA, headB\n\n    while a != b:\n        a = a.next if a else headB\n        b = b.next if b else headA\n\n    return a\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |  Hash Set  | O(n+m) |  O(n)   |\n# |Two Pointers| O(n+m) |  O(1)   |\n# |------------|--------|---------|\n\n\nlistA = [4, 1, 8, 4, 5]\nlistB = [5, 6, 1, 8, 4, 5]\nheadA = ListNode.create(listA)\nprint(headA)\n# 4 -&gt; 1 -&gt; 8 -&gt; 4 -&gt; 5\nheadB = ListNode.create(listB)\nprint(headB)\n# 5 -&gt; 6 -&gt; 1 -&gt; 8 -&gt; 4 -&gt; 5\n\nheadA.intersect(headB, 8)\n\nprint(getIntersectionNodeHash(headA, headB))\n# 8 -&gt; 4 -&gt; 5\nprint(getIntersectionNodeTP(headA, headB))\n# 8 -&gt; 4 -&gt; 5\n</code></pre>"},{"location":"leetpattern/linked_list/#141-linked-list-cycle","title":"141. Linked List Cycle","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, linked list, two pointers</p> </li> <li>Determine if a linked list has a cycle in it.</li> </ul> <pre><code>graph LR\nA[3] --&gt; B[2]\nB --&gt; C[0]\nC --&gt; D[-4]</code></pre> <pre><code>graph LR\nA[3] --&gt; B[2]\nB --&gt; C[0]\nC --&gt; D[-4]\nD --&gt; B</code></pre> 141. Linked List Cycle - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\ndef hasCycle(head: Optional[ListNode]) -&gt; bool:\n    slow, fast = head, head\n\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n        if slow == fast:\n            return True\n\n    return False\n\n\nprint(hasCycle(ListNode.create([3, 2, 0, -4])))  # False\nprint(hasCycle(ListNode.create([3, 2, 0, -4], 1)))  # True\n</code></pre>"},{"location":"leetpattern/linked_list/#142-linked-list-cycle-ii","title":"142. Linked List Cycle II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, linked list, two pointers</p> </li> <li>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>None</code>.</li> </ul> <pre><code>graph LR\nA[3] --&gt; B[2]\nB --&gt; C[0]\nC --&gt; D[-4]\nD --&gt; B</code></pre> 142. Linked List Cycle II - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\ndef detectCycle(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    slow, fast = head, head\n\n    while fast and fast.next:\n        fast = fast.next.next\n        slow = slow.next\n\n        if slow == fast:\n            slow = head\n            while slow != fast:\n                slow = slow.next\n                fast = fast.next\n            return slow\n\n    return None\n\n\nhead1 = ListNode.create([3, 2, 0, -4], 1)\nprint(detectCycle(head1).val)  # 2\nhead2 = ListNode.create([3, 2, 0, -4])\nprint(detectCycle(head2))  # None\n</code></pre>"},{"location":"leetpattern/linked_list/#2816-double-a-number-represented-as-a-linked-list","title":"2816. Double a Number Represented as a Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, math, stack</p> </li> <li>Given a number represented as a linked list, double it and return the resulting linked list.</li> </ul> 2816. Double a Number Represented as a Linked List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\ndef doubleIt(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n\n    def twice(node):\n        if not node:\n            return 0\n        doubled_value = node.val * 2 + twice(node.next)\n        node.val = doubled_value % 10\n        return doubled_value // 10\n\n    carry = twice(head)\n\n    if carry:\n        head = ListNode(val=carry, next=head)\n\n    return head\n\n\nhead = ListNode.create([1, 2, 3, 4])\nprint(head)\n# 1 -&gt; 2 -&gt; 3 -&gt; 4\nprint(doubleIt(head))\n# 2 -&gt; 4 -&gt; 6 -&gt; 8\n</code></pre>"},{"location":"leetpattern/linked_list/#2-add-two-numbers","title":"2. Add Two Numbers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, math, recursion</p> </li> <li>Represent the sum of two numbers as a linked list.</li> </ul> 2. Add Two Numbers - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef addTwoNumbers(\n    l1: Optional[ListNode], l2: Optional[ListNode]\n) -&gt; Optional[ListNode]:\n    dummy = ListNode(0)\n    cur = dummy\n    carry = 0\n\n    while l1 or l2:\n        v1 = l1.val if l1 else 0\n        v2 = l2.val if l2 else 0\n\n        carry, val = divmod(v1 + v2 + carry, 10)\n        cur.next = ListNode(val)\n        cur = cur.next\n\n        if l1:\n            l1 = l1.next\n        if l2:\n            l2 = l2.next\n\n    if carry:\n        cur.next = ListNode(val=carry)\n\n    return dummy.next\n\n\nl1 = ListNode.create([2, 4, 3])\nl2 = ListNode.create([5, 6, 4])\nprint(addTwoNumbers(l1, l2))  # 7 -&gt; 0 -&gt; 8\n</code></pre>"},{"location":"leetpattern/math/","title":"Math","text":"<ul> <li> 1945. Sum of Digits of String After Convert (Easy)</li> <li> 1894. Find the Student that Will Replace the Chalk (Medium)</li> <li> 7. Reverse Integer (Medium)</li> </ul>"},{"location":"leetpattern/math/#1945-sum-of-digits-of-string-after-convert","title":"1945. Sum of Digits of String After Convert","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, simulation</p> </li> </ul> 1945. Sum of Digits of String After Convert - Python Solution<pre><code># Math\ndef getLucky(s: str, k: int) -&gt; int:\n    def getSum(n: int) -&gt; int:\n        total = 0\n        while n != 0:\n            n, m = divmod(n, 10)\n            total += m\n        return total\n\n    result = \"\"\n    for i in s:\n        result += str(ord(i) - ord(\"a\") + 1)\n    result = int(result)\n\n    for _ in range(k):\n        result = getSum(result)\n\n    return result\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |    Math    |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\ns = \"iiii\"\nk = 1\n\nprint(getLucky(s, k))  # 36\n</code></pre>"},{"location":"leetpattern/math/#1894-find-the-student-that-will-replace-the-chalk","title":"1894. Find the Student that Will Replace the Chalk","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, simulation, prefix sum</p> </li> </ul> 1894. Find the Student that Will Replace the Chalk - Python Solution<pre><code>from typing import List\n\n\n# Math\ndef chalkReplacer(chalk: List[int], k: int) -&gt; int:\n    total = sum(chalk)\n\n    k %= total\n\n    for i, c in enumerate(chalk):\n        k -= c\n\n        if k &lt; 0:\n            return i\n\n    return -1\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |    Math    |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nchalk = [5, 1, 5]\nk = 22\n\nprint(chalkReplacer(chalk, k))  # 0\n</code></pre>"},{"location":"leetpattern/math/#7-reverse-integer","title":"7. Reverse Integer","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math</p> </li> </ul> 7. Reverse Integer - Python Solution<pre><code># Math\ndef reverse(x: int) -&gt; int:\n    INT_MAX = 2**31 - 1\n\n    sign = -1 if x &lt; 0 else 1\n    x = abs(x)\n    res = 0\n\n    while x != 0:\n        x, pop = divmod(x, 10)\n\n        if res &gt; (INT_MAX - pop) // 10:\n            return 0\n\n        res = res * 10 + pop\n\n    return res * sign\n\n\nprint(reverse(123))  # 321\nprint(reverse(-123))  # -321\n</code></pre>"},{"location":"leetpattern/prefix_sum/","title":"Prefix Sum","text":"<ul> <li> 2574. Left and Right Sum Differences (Easy)</li> <li> 1732. Find the Highest Altitude (Easy)</li> <li> 303. Range Sum Query - Immutable (Easy)</li> <li> 304. Range Sum Query 2D - Immutable (Medium)</li> <li> 560. Subarray Sum Equals K (Medium)</li> <li> 238. Product of Array Except Self (Medium)</li> <li> 974. Subarray Sums Divisible by K (Medium)</li> <li> 209. Minimum Size Subarray Sum (Medium)</li> <li> 523. Continuous Subarray Sum (Medium)</li> <li> 1248. Count Number of Nice Subarrays (Medium)</li> <li> 325. Maximum Size Subarray Sum Equals k (Medium)</li> <li> 862. Shortest Subarray with Sum at Least K (Hard)</li> <li> 1171. Remove Zero Sum Consecutive Nodes from Linked List (Medium)</li> </ul>"},{"location":"leetpattern/prefix_sum/#2574-left-and-right-sum-differences","title":"2574. Left and Right Sum Differences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, prefix sum</p> </li> </ul> 2574. Left and Right Sum Differences - Python Solution<pre><code>from typing import List\n\n\n# Prefix Sum\ndef leftRightDifferenceSum(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    left = [0 for _ in range(n)]\n    right = [0 for _ in range(n)]\n\n    for i in range(1, n):\n        left[i] = left[i - 1] + nums[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        right[i] = right[i + 1] + nums[i + 1]\n\n    return [abs(left[i] - right[i]) for i in range(n)]\n\n\n# Left Right Pointers\ndef leftRightDifferencePointer(nums: List[int]) -&gt; List[int]:\n    left, right = 0, sum(nums)\n    result = []\n\n    for num in nums:\n        right -= num\n        result.append(abs(left - right))\n        left += num\n\n    return result\n\n\nnums = [10, 4, 8, 3]\nprint(leftRightDifferenceSum(nums))  # [15, 1, 11, 22]\nprint(leftRightDifferencePointer(nums))  # [15, 1, 11, 22]\n</code></pre>"},{"location":"leetpattern/prefix_sum/#1732-find-the-highest-altitude","title":"1732. Find the Highest Altitude","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, prefix sum</p> </li> </ul> 1732. Find the Highest Altitude - Python Solution<pre><code>from typing import List\n\n\ndef largestAltitude(gain: List[int]) -&gt; int:\n    result, altitude = 0, 0\n\n    for i in gain:\n        altitude += i\n        result = max(result, altitude)\n\n    return result\n\n\ngain = [-5, 1, 5, 0, -7]\nprint(largestAltitude(gain))  # 1\n</code></pre>"},{"location":"leetpattern/prefix_sum/#303-range-sum-query-immutable","title":"303. Range Sum Query - Immutable","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, design, prefix sum</p> </li> </ul> 303. Range Sum Query - Immutable - Python Solution<pre><code>from typing import List\n\n\nclass NumArray:\n\n    def __init__(self, nums: List[int]):\n        self.prefix_sum = [0 for _ in range(len(nums) + 1)]\n\n        for i in range(1, len(nums) + 1):\n            self.prefix_sum[i] = self.prefix_sum[i - 1] + nums[i - 1]\n\n    def sumRange(self, left: int, right: int) -&gt; int:\n        return self.prefix_sum[right + 1] - self.prefix_sum[left]\n\n\nnums = [-2, 0, 3, -5, 2, -1]\nobj = NumArray(nums)\nassert obj.sumRange(0, 2) == 1\nassert obj.sumRange(2, 5) == -1\nassert obj.sumRange(0, 5) == -3\nprint(\"PASSED\")\n</code></pre>"},{"location":"leetpattern/prefix_sum/#304-range-sum-query-2d-immutable","title":"304. Range Sum Query 2D - Immutable","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, design, matrix, prefix sum</p> </li> </ul> 304. Range Sum Query 2D - Immutable - Python Solution<pre><code>from typing import List\n\n\nclass NumMatrix:\n\n    def __init__(self, matrix: List[List[int]]):\n        m, n = len(matrix), len(matrix[0])\n        if m == 0 or n == 0:\n            return None\n\n        self.sum = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                self.sum[i][j] = (\n                    matrix[i - 1][j - 1]\n                    + self.sum[i - 1][j]\n                    + self.sum[i][j - 1]\n                    - self.sum[i - 1][j - 1]  # to avoid double counting\n                )\n\n    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -&gt; int:\n        return (\n            self.sum[row2 + 1][col2 + 1]\n            - self.sum[row1][col2 + 1]\n            - self.sum[row2 + 1][col1]\n            + self.sum[row1][col1]\n        )\n\n\nmatrix = [\n    [3, 0, 1, 4, 2],\n    [5, 6, 3, 2, 1],\n    [1, 2, 0, 1, 5],\n    [4, 1, 0, 1, 7],\n    [1, 0, 3, 0, 5],\n]\nobj = NumMatrix(matrix)\nassert obj.sumRegion(2, 1, 4, 3) == 8\nassert obj.sumRegion(1, 1, 2, 2) == 11\nassert obj.sumRegion(1, 2, 2, 4) == 12\nprint(\"PASSED\")\n</code></pre>"},{"location":"leetpattern/prefix_sum/#560-subarray-sum-equals-k","title":"560. Subarray Sum Equals K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, prefix sum</p> </li> </ul> 560. Subarray Sum Equals K - Python Solution<pre><code>from typing import List\n\n\n# 1. Prefix Sum\ndef subarraySum(nums: List[int], k: int) -&gt; int:\n    prefix_sums = {0: 1}\n    currentSum = 0\n    count = 0\n\n    for num in nums:\n        currentSum += num\n        if (currentSum - k) in prefix_sums:\n            count += prefix_sums[currentSum - k]\n\n        if currentSum in prefix_sums:\n            prefix_sums[currentSum] += 1\n        else:\n            prefix_sums[currentSum] = 1\n\n    return count\n\n\n# 2. Optimized Prefix Sum\ndef subarraySumOptimized(nums: List[int], k: int) -&gt; int:\n    prefixSum = 0\n    count = 0\n    prefix_sums = {0: 1}\n\n    for num in nums:\n        prefixSum += num\n        count += prefix_sums.get(prefixSum - k, 0)\n        prefix_sums[prefixSum] = prefix_sums.get(prefixSum, 0) + 1\n\n    return count\n\n\nnums = [1, 1, 1]\nk = 2\nprint(subarraySum(nums, k))  # 2\nprint(subarraySumOptimized(nums, k))  # 2\n</code></pre>"},{"location":"leetpattern/prefix_sum/#238-product-of-array-except-self","title":"238. Product of Array Except Self","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, prefix sum</p> </li> <li>Classic Prefix Sum problem</li> <li>Return an array <code>output</code> such that <code>output[i]</code> is equal to the product of all the elements of <code>nums</code> except <code>nums[i]</code>.</li> </ul> Approach Time Space Prefix O(n) O(n) Prefix (Optimized) O(n) O(1) 238. Product of Array Except Self - Python Solution<pre><code>from typing import List\n\n\n# Prefix\ndef productExceptSelf(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    prefix = [1 for _ in range(n)]\n    suffix = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        prefix[i] = nums[i - 1] * prefix[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        suffix[i] = nums[i + 1] * suffix[i + 1]\n\n    result = [i * j for i, j in zip(prefix, suffix)]\n\n    return result\n\n\n# Prefix (Optimized)\ndef productExceptSelfOptimized(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    result = [1 for _ in range(n)]\n\n    prefix = 1\n    for i in range(n):\n        result[i] = prefix\n        prefix *= nums[i]\n\n    suffix = 1\n    for i in range(n - 1, -1, -1):\n        result[i] *= suffix\n        suffix *= nums[i]\n\n    return result\n\n\nprint(productExceptSelf([1, 2, 3, 4]))\n# [24, 12, 8, 6]\nprint(productExceptSelfOptimized([1, 2, 3, 4]))\n# [24, 12, 8, 6]\n</code></pre>"},{"location":"leetpattern/prefix_sum/#974-subarray-sums-divisible-by-k","title":"974. Subarray Sums Divisible by K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, prefix sum</p> </li> </ul> 974. Subarray Sums Divisible by K - Python Solution<pre><code>from typing import List\n\n\ndef subarraysDivByK_1(nums: List[int], k: int) -&gt; int:\n    mods = {0: 1}\n    prefixSum, result = 0, 0\n\n    for num in nums:\n        prefixSum += num\n        mod = prefixSum % k\n\n        if mod &lt; 0:\n            mod += k\n\n        if mod in mods:\n            result += mods[mod]\n\n        if mod in mods:\n            mods[mod] += 1\n        else:\n            mods[mod] = 1\n\n    return result\n\n\ndef subarraysDivByK_2(nums: List[int], k: int) -&gt; int:\n    mods = {0: 1}\n    prefixSum, result = 0, 0\n\n    for num in nums:\n        prefixSum += num\n        mod = prefixSum % k\n        result += mods.get(mod, 0)\n        mods[mod] = mods.get(mod, 0) + 1\n\n    return result\n\n\nnums = [4, 5, 0, -2, -3, 1]\nk = 5\nprint(subarraysDivByK_1(nums, k))  # 7\nprint(subarraysDivByK_2(nums, k))  # 7\n</code></pre>"},{"location":"leetpattern/prefix_sum/#209-minimum-size-subarray-sum","title":"209. Minimum Size Subarray Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sliding window, prefix sum</p> </li> </ul> 209. Minimum Size Subarray Sum - Python Solution<pre><code>import bisect\nfrom typing import List\n\n\n# Prefix Sum\ndef minSubArrayLenPS(target: int, nums: List[int]) -&gt; int:\n    n = len(nums)\n    prefix_sums = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        prefix_sums[i] = prefix_sums[i - 1] + nums[i - 1]\n\n    minLen = float(\"inf\")\n\n    for i in range(n + 1):\n        new_target = target + prefix_sums[i]\n        bound = bisect.bisect_left(prefix_sums, new_target)\n        if bound != len(prefix_sums):\n            minLen = min(minLen, bound - i)\n\n    return 0 if minLen == float(\"inf\") else minLen\n\n\n# Sliding Window Variable Size\ndef minSubArrayLenSW(target: int, nums: List[int]) -&gt; int:\n    res, cur = float(\"inf\"), 0\n    left = 0\n\n    for right in range(len(nums)):\n        cur += nums[right]\n\n        while cur &gt;= target:\n            res = min(res, right - left + 1)\n            cur -= nums[left]\n            left += 1\n\n    return res if res != float(\"inf\") else 0\n\n\ntarget = 7\nnums = [2, 3, 1, 2, 4, 3]\nprint(minSubArrayLenPS(target, nums))  # 2\nprint(minSubArrayLenSW(target, nums))  # 2\n</code></pre>"},{"location":"leetpattern/prefix_sum/#523-continuous-subarray-sum","title":"523. Continuous Subarray Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, prefix sum</p> </li> </ul> 523. Continuous Subarray Sum - Python Solution<pre><code>from typing import List\n\n\n# Prefix Sum\ndef checkSubarraySum(nums: List[int], k: int) -&gt; bool:\n    if k == 0:\n        for i in range(1, len(nums)):\n            if nums[i - 1] == 0 and nums[i] == 0:\n                return True\n\n    prefix_sum = 0\n    mod_dict = {0: -1}\n\n    for i, num in enumerate(nums):\n        prefix_sum += num\n        mod = prefix_sum % k\n\n        if mod in mod_dict:\n            if i - mod_dict[mod] &gt; 1:\n                return True\n        else:\n            mod_dict[mod] = i\n\n    return False\n\n\nnums = [23, 2, 4, 6, 7]\nk = 6\nprint(checkSubarraySum(nums, k))  # True\n</code></pre>"},{"location":"leetpattern/prefix_sum/#1248-count-number-of-nice-subarrays","title":"1248. Count Number of Nice Subarrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, math, sliding window, prefix sum</p> </li> </ul> 1248. Count Number of Nice Subarrays - Python Solution<pre><code>from typing import List\n\n\n# Prefix Sum\ndef numberOfSubarrays(nums: List[int], k: int) -&gt; int:\n    count = 0\n    odd_counts = {0: 1}  # odd_count -&gt; count\n    odd_count = 0\n\n    for num in nums:\n        if num % 2 == 1:\n            odd_count += 1\n        if odd_count - k in odd_counts:\n            count += odd_counts[odd_count - k]\n        if odd_count in odd_counts:\n            odd_counts[odd_count] += 1\n        else:\n            odd_counts[odd_count] = 1\n\n    return count\n\n\nnums = [1, 1, 2, 1, 1]\nk = 3\nprint(numberOfSubarrays(nums, k))  # 2\n</code></pre>"},{"location":"leetpattern/prefix_sum/#325-maximum-size-subarray-sum-equals-k","title":"325. Maximum Size Subarray Sum Equals k","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, prefix sum</p> </li> </ul> 325. Maximum Size Subarray Sum Equals k - Python Solution<pre><code>from typing import List\n\n\n# Prefix Sum\ndef maxSubArrayLen(nums: List[int], k: int) -&gt; int:\n    res = 0\n    prefix = 0\n    sumMap = {0: -1}  # sum -&gt; index\n\n    for i, num in enumerate(nums):\n        prefix += num\n        if prefix - k in sumMap:\n            res = max(res, i - sumMap[prefix - k])\n        if prefix not in sumMap:\n            sumMap[prefix] = i\n\n    return res\n\n\nnums = [1, -1, 5, -2, 3]\nk = 3\nprint(maxSubArrayLen(nums, k))  # 4\n</code></pre>"},{"location":"leetpattern/prefix_sum/#862-shortest-subarray-with-sum-at-least-k","title":"862. Shortest Subarray with Sum at Least K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, queue, sliding window, heap priority queue, prefix sum, monotonic queue</p> </li> </ul> 862. Shortest Subarray with Sum at Least K - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# Prefix Sum + Monotonic Queue\ndef shortestSubarray(nums: List[int], k: int) -&gt; int:\n    n = len(nums)\n    ps = [0 for _ in range(n + 1)]\n\n    for i in range(n):\n        ps[i + 1] = ps[i] + nums[i]\n\n    res = float(\"inf\")\n    q = deque()\n\n    for i in range(n + 1):\n        while q and ps[i] - ps[q[0]] &gt;= k:\n            res = min(res, i - q.popleft())\n        while q and ps[i] &lt;= ps[q[-1]]:\n            q.pop()\n        q.append(i)\n\n    return res if res != float(\"inf\") else -1\n\n\nnums = [2, -1, 2]\nk = 3\nprint(shortestSubarray(nums, k))  # 3\n</code></pre>"},{"location":"leetpattern/prefix_sum/#1171-remove-zero-sum-consecutive-nodes-from-linked-list","title":"1171. Remove Zero Sum Consecutive Nodes from Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, linked list</p> </li> </ul> 1171. Remove Zero Sum Consecutive Nodes from Linked List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Prefix Sum\ndef removeZeroSumSublists(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    dummy = ListNode(0)\n    dummy.next = head\n    cur = head\n    prefix_sum = 0\n    seen = {0: dummy}\n\n    while cur:\n        prefix_sum += cur.val\n        if prefix_sum in seen:\n            node = seen[prefix_sum].next\n            temp_sum = prefix_sum\n            while node != cur:\n                temp_sum += node.val\n                del seen[temp_sum]\n                node = node.next\n            seen[prefix_sum].next = cur.next\n        else:\n            seen[prefix_sum] = cur\n        cur = cur.next\n\n    return dummy.next\n\n\nhead = ListNode().create([1, 2, -3, 3, 1])\nprint(removeZeroSumSublists(head))  # 3 -&gt; 1\n</code></pre>"},{"location":"leetpattern/queue/","title":"Queue","text":"<ul> <li> 232. Implement Queue using Stacks (Easy)</li> <li> 225. Implement Stack using Queues (Easy)</li> </ul>"},{"location":"leetpattern/queue/#232-implement-queue-using-stacks","title":"232. Implement Queue using Stacks","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: stack, design, queue</p> </li> <li>Implement the following operations of a queue using stacks.<ul> <li><code>push(x)</code> - Push element x to the back of queue.</li> <li><code>pop()</code> - Removes the element from in front of queue.</li> <li><code>peek()</code> - Get the front element.</li> <li><code>empty()</code> - Return whether the queue is empty.</li> </ul> </li> </ul> 232. Implement Queue using Stacks - Python Solution<pre><code>class MyQueue:\n    def __init__(self):\n        self.stack_in = []\n        self.stack_out = []\n\n    def push(self, x: int) -&gt; None:\n        self.stack_in.append(x)\n\n    def pop(self) -&gt; int:\n        if self.empty():\n            return None\n\n        if self.stack_out:\n            return self.stack_out.pop()\n        else:\n            for _ in range(len(self.stack_in)):\n                self.stack_out.append(self.stack_in.pop())\n            return self.stack_out.pop()\n\n    def peek(self) -&gt; int:\n        answer = self.pop()\n        self.stack_out.append(answer)\n        return answer\n\n    def empty(self) -&gt; bool:\n        return not (self.stack_in or self.stack_out)\n\n\nobj = MyQueue()\nobj.push(1)\nprint(obj.pop())  # 1\nprint(obj.peek())  # None\nprint(obj.empty())  # False\n</code></pre>"},{"location":"leetpattern/queue/#225-implement-stack-using-queues","title":"225. Implement Stack using Queues","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: stack, design, queue</p> </li> </ul> 225. Implement Stack using Queues - Python Solution<pre><code>from collections import deque\n\n\n# Queue\nclass MyStack:\n\n    def __init__(self):\n        self.q1 = deque()  # main queue\n        self.q2 = deque()  # auxiliary queue\n\n    def push(self, x: int) -&gt; None:\n        self.q1.append(x)\n\n    def pop(self) -&gt; int:\n        while len(self.q1) &gt; 1:\n            self.q2.append(self.q1.popleft())\n        res = self.q1.popleft()\n        self.q1, self.q2 = self.q2, self.q1\n        return res\n\n    def top(self) -&gt; int:\n        while len(self.q1) &gt; 1:\n            self.q2.append(self.q1.popleft())\n        res = self.q1[0]\n        self.q2.append(self.q1.popleft())\n        self.q1, self.q2 = self.q2, self.q1\n        return res\n\n    def empty(self) -&gt; bool:\n        return not self.q1\n\n\nobj = MyStack()\nobj.push(1)\nobj.push(2)\nobj.push(3)\nobj.push(4)\nprint(obj.pop())  # 4\nprint(obj.top())  # 3\nprint(obj.empty())  # False\nprint(obj.pop())  # 3\n</code></pre>"},{"location":"leetpattern/queue_monotonic/","title":"Queue Monotonic","text":"<ul> <li> 918. Maximum Sum Circular Subarray (Medium)</li> <li> 862. Shortest Subarray with Sum at Least K (Hard)</li> <li> 239. Sliding Window Maximum (Hard)</li> <li> 2398. Maximum Number of Robots Within Budget (Hard)</li> </ul>"},{"location":"leetpattern/queue_monotonic/#918-maximum-sum-circular-subarray","title":"918. Maximum Sum Circular Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, divide and conquer, dynamic programming, queue, monotonic queue</p> </li> </ul> 918. Maximum Sum Circular Subarray - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# DP - Kadane\ndef maxSubarraySumCircularKadane(nums: List[int]) -&gt; int:\n    max_sum = min_sum = nums[0]\n    max_cur = min_cur = 0\n    total = 0\n\n    for num in nums:\n        max_cur = max(max_cur + num, num)\n        min_cur = min(min_cur + num, num)\n        total += num\n\n        max_sum = max(max_sum, max_cur)\n        min_sum = min(min_sum, min_cur)\n\n    return max(max_sum, total - min_sum) if max_sum &gt; 0 else max_sum\n\n\n# Monotonic Queue\ndef maxSubarraySumCircularMQ(nums: List[int]) -&gt; int:\n    n = len(nums)\n    prefix_sum = [0] * (2 * n + 1)\n\n    for i in range(1, 2 * n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + nums[(i - 1) % n]\n\n    q = deque([0])\n    max_sum = float(\"-inf\")\n\n    for i in range(1, 2 * n + 1):\n        if q[0] &lt; i - n:\n            q.popleft()\n\n        max_sum = max(max_sum, prefix_sum[i] - prefix_sum[q[0]])\n\n        while q and prefix_sum[q[-1]] &gt;= prefix_sum[i]:\n            q.pop()\n\n        q.append(i)\n\n    return max_sum\n\n\nnums = [1, -2, 3, -2]\nprint(maxSubarraySumCircularKadane(nums))  # 3\nprint(maxSubarraySumCircularMQ(nums))  # 3\n</code></pre>"},{"location":"leetpattern/queue_monotonic/#862-shortest-subarray-with-sum-at-least-k","title":"862. Shortest Subarray with Sum at Least K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, queue, sliding window, heap priority queue, prefix sum, monotonic queue</p> </li> </ul> 862. Shortest Subarray with Sum at Least K - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# Prefix Sum + Monotonic Queue\ndef shortestSubarray(nums: List[int], k: int) -&gt; int:\n    n = len(nums)\n    ps = [0 for _ in range(n + 1)]\n\n    for i in range(n):\n        ps[i + 1] = ps[i] + nums[i]\n\n    res = float(\"inf\")\n    q = deque()\n\n    for i in range(n + 1):\n        while q and ps[i] - ps[q[0]] &gt;= k:\n            res = min(res, i - q.popleft())\n        while q and ps[i] &lt;= ps[q[-1]]:\n            q.pop()\n        q.append(i)\n\n    return res if res != float(\"inf\") else -1\n\n\nnums = [2, -1, 2]\nk = 3\nprint(shortestSubarray(nums, k))  # 3\n</code></pre>"},{"location":"leetpattern/queue_monotonic/#239-sliding-window-maximum","title":"239. Sliding Window Maximum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, queue, sliding window, heap priority queue, monotonic queue</p> </li> </ul> 239. Sliding Window Maximum - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# Monotonic Queue\ndef maxSlidingWindow(nums: List[int], k: int) -&gt; List[int]:\n    q = deque()\n    res = []\n\n    for i, num in enumerate(nums):\n        if q and q[0] &lt; i - k + 1:\n            q.popleft()\n\n        while q and nums[q[-1]] &lt; num:\n            q.pop()\n\n        q.append(i)\n\n        if i &gt;= k - 1:\n            res.append(nums[q[0]])\n\n    return res\n\n\nnums = [1, 3, -1, -3, 5, 3, 6, 7]\nk = 3\nprint(maxSlidingWindow(nums, k))  # [3, 3, 5, 5, 6, 7]\n</code></pre>"},{"location":"leetpattern/queue_monotonic/#2398-maximum-number-of-robots-within-budget","title":"2398. Maximum Number of Robots Within Budget","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, queue, sliding window, heap priority queue, prefix sum, monotonic queue</p> </li> </ul> 2398. Maximum Number of Robots Within Budget - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# Monotonic Queue\ndef maximumRobots(\n    chargeTimes: List[int], runningCosts: List[int], budget: int\n) -&gt; int:\n    ans = sum_cost = left = 0\n    q = deque()\n\n    for right, (time, cost) in enumerate(zip(chargeTimes, runningCosts)):\n        # 1. Add\n        while q and time &gt;= chargeTimes[q[-1]]:\n            q.pop()\n        q.append(right)\n        sum_cost += cost\n\n        # 2. Remove\n        while q and chargeTimes[q[0]] + (right - left + 1) * sum_cost &gt; budget:\n            if q[0] == left:\n                q.popleft()\n            sum_cost -= runningCosts[left]\n            left += 1\n\n        # 3. Update\n        ans = max(ans, right - left + 1)\n    return ans\n\n\nchargeTimes = [3, 6, 1, 3, 4]\nrunningCosts = [2, 1, 3, 4, 5]\nbudget = 25\nprint(maximumRobots(chargeTimes, runningCosts, budget))  # 3\n</code></pre>"},{"location":"leetpattern/simulation/","title":"Simulation","text":"<ul> <li> 874. Walking Robot Simulation (Medium)</li> </ul>"},{"location":"leetpattern/simulation/#874-walking-robot-simulation","title":"874. Walking Robot Simulation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, simulation</p> </li> </ul> 874. Walking Robot Simulation - Python Solution<pre><code>from typing import List\n\n\n# Simulation\ndef robotSim(commands: List[int], obstacles: List[List[int]]) -&gt; int:\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    obstacles_set = set(map(tuple, obstacles))\n\n    x, y, d = 0, 0, 0\n    res = 0\n\n    for command in commands:\n        if command == -2:  # Turn left\n            d = (d - 1) % 4\n        elif command == -1:  # Turn right\n            d = (d + 1) % 4\n        else:\n            dx, dy = dirs[d]\n            for _ in range(command):\n                if (x + dx, y + dy) not in obstacles_set:\n                    x += dx\n                    y += dy\n                    res = max(res, x**2 + y**2)\n                else:\n                    break\n\n    return res\n\n\ncommands = [4, -1, 4, -2, 4]\nobstacles = [[2, 4]]\nprint(robotSim(commands, obstacles))  # 65\n</code></pre>"},{"location":"leetpattern/sliding_window_fixed/","title":"Sliding Window Fixed","text":"<ul> <li> 643. Maximum Average Subarray I (Easy)</li> <li> 219. Contains Duplicate II (Easy)</li> <li> 1456. Maximum Number of Vowels in a Substring of Given Length (Medium)</li> <li> 567. Permutation in String (Medium)</li> <li> 713. Subarray Product Less Than K (Medium)</li> <li> 1151. Minimum Swaps to Group All 1's Together (Medium)</li> <li> 209. Minimum Size Subarray Sum (Medium)</li> <li> 76. Minimum Window Substring (Hard)</li> </ul>"},{"location":"leetpattern/sliding_window_fixed/#643-maximum-average-subarray-i","title":"643. Maximum Average Subarray I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, sliding window</p> </li> </ul> 643. Maximum Average Subarray I - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window Fixed Size\ndef findMaxAverage1(nums: List[int], k: int) -&gt; float:\n    maxSum = float(\"-inf\")\n    cur = 0\n\n    for idx, num in enumerate(nums):\n        cur += num\n\n        if idx &lt; k - 1:\n            continue\n\n        maxSum = max(maxSum, cur)\n        cur -= nums[idx - k + 1]\n\n    return maxSum / k\n\n\n# Sliding Window Fixed Size\ndef findMaxAverage2(nums: List[int], k: int) -&gt; float:\n    n = len(nums)\n    if n == 1:\n        return float(nums[0])\n\n    cur = sum(nums[:k])\n\n    maxSum = cur\n    for i in range(k, n):\n        cur += nums[i] - nums[i - k]\n        maxSum = max(maxSum, cur)\n\n    return maxSum / k\n\n\nnums = [1, 12, -5, -6, 50, 3]\nk = 4\nprint(findMaxAverage1(nums, k))  # 12.75\nprint(findMaxAverage2(nums, k))  # 12.75\n</code></pre>"},{"location":"leetpattern/sliding_window_fixed/#219-contains-duplicate-ii","title":"219. Contains Duplicate II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, sliding window</p> </li> </ul> 219. Contains Duplicate II - Python Solution<pre><code>from typing import List\n\n\n# Hash\ndef containsNearbyDuplicateHash(nums: List[int], k: int) -&gt; bool:\n    hashmap = {}  # num: last index\n\n    for idx, num in enumerate(nums):\n        if num in hashmap:\n            if idx - hashmap[num] &lt;= k:\n                return True\n\n        hashmap[num] = idx\n\n    return False\n\n\n# Sliding window - Fixed\ndef containsNearbyDuplicateWindow(nums: List[int], k: int) -&gt; bool:\n    window = set()\n    left = 0\n\n    for right in range(len(nums)):\n        if right - left &gt; k:\n            window.remove(nums[left])\n            left += 1\n        if nums[right] in window:\n            return True\n        window.add(nums[right])\n\n    return False\n\n\nnums = [1, 2, 3, 1]\nk = 3\nprint(containsNearbyDuplicateHash(nums, k))  # True\nprint(containsNearbyDuplicateWindow(nums, k))  # True\n</code></pre>"},{"location":"leetpattern/sliding_window_fixed/#1456-maximum-number-of-vowels-in-a-substring-of-given-length","title":"1456. Maximum Number of Vowels in a Substring of Given Length","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, sliding window</p> </li> </ul> 1456. Maximum Number of Vowels in a Substring of Given Length - Python Solution<pre><code># Sliding Window Fixed Size\ndef maxVowels1(s: str, k: int) -&gt; int:\n    res, cnt = 0, 0\n\n    for idx, ch in enumerate(s):\n        if ch in \"aeiou\":\n            cnt += 1\n\n        if idx &lt; k - 1:\n            continue\n\n        res = max(res, cnt)\n\n        if s[idx - k + 1] in \"aeiou\":\n            cnt -= 1\n\n    return res\n\n\n# Sliding Window Fixed Size\ndef maxVowels2(s: str, k: int) -&gt; int:\n    vowels = set(\"aeiou\")\n    n = len(s)\n    cnt, res = 0, 0\n\n    for i in range(k):\n        if s[i] in vowels:\n            cnt += 1\n\n    res = cnt\n\n    for i in range(k, n):\n        if s[i] in vowels:\n            cnt += 1\n        if s[i - k] in vowels:\n            cnt -= 1\n        res = max(res, cnt)\n\n    return res\n\n\ns = \"abciiidef\"\nk = 3\nprint(maxVowels1(s, k))  # 3\nprint(maxVowels2(s, k))  # 3\n</code></pre>"},{"location":"leetpattern/sliding_window_fixed/#567-permutation-in-string","title":"567. Permutation in String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, two pointers, string, sliding window</p> </li> </ul> 567. Permutation in String - Python Solution<pre><code>def checkInclusion(s1: str, s2: str) -&gt; bool:\n    if len(s1) &gt; len(s2):\n        return False\n\n    count1 = [0] * 26\n    count2 = [0] * 26\n\n    for i in range(len(s1)):\n        count1[ord(s1[i]) - ord(\"a\")] += 1\n        count2[ord(s2[i]) - ord(\"a\")] += 1\n\n    matches = 0\n    for i in range(26):\n        if count1[i] == count2[i]:\n            matches += 1\n\n    l = 0\n    for r in range(len(s1), len(s2)):\n        if matches == 26:\n            return True\n\n        index = ord(s2[r]) - ord(\"a\")\n        count2[index] += 1\n        if count1[index] == count2[index]:\n            matches += 1\n        elif count1[index] + 1 == count2[index]:\n            matches -= 1\n\n        index = ord(s2[l]) - ord(\"a\")\n        count2[index] -= 1\n        if count1[index] == count2[index]:\n            matches += 1\n        elif count1[index] - 1 == count2[index]:\n            matches -= 1\n\n        l += 1\n\n    return matches == 26\n\n\ns1 = \"ab\"\ns2 = \"eidba\"\nprint(checkInclusion(s1, s2))  # True\n</code></pre>"},{"location":"leetpattern/sliding_window_fixed/#713-subarray-product-less-than-k","title":"713. Subarray Product Less Than K","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sliding window, prefix sum</p> </li> </ul> 713. Subarray Product Less Than K - Python Solution<pre><code>from typing import List\n\n\n# Sliding window - Fixed\ndef numSubarrayProductLessThanK(nums: List[int], k: int) -&gt; int:\n    if k &lt;= 1:\n        return 0\n\n    left = 0\n    product = 1\n    count = 0\n\n    for right in range(len(nums)):\n        product *= nums[right]\n\n        while product &gt;= k:\n            product //= nums[left]\n            left += 1\n\n        count += right - left + 1\n\n    return count\n\n\nnums = [10, 5, 2, 6]\nk = 100\nprint(numSubarrayProductLessThanK(nums, k))  # 8\n</code></pre>"},{"location":"leetpattern/sliding_window_fixed/#1151-minimum-swaps-to-group-all-1s-together","title":"1151. Minimum Swaps to Group All 1's Together","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sliding window</p> </li> </ul> 1151. Minimum Swaps to Group All 1's Together - Python Solution<pre><code>from typing import List\n\n\ndef minSwaps(data: List[int]) -&gt; int:\n    n = len(data)\n    total = sum(data)\n\n    if total == 0 or total == 1 or total == n:\n        return 0\n\n    max_count = 0\n    cur = 0\n    left = 0\n\n    for right in range(n):\n        cur += data[right]\n\n        if right - left + 1 &gt; total:\n            cur -= data[left]\n            left += 1\n\n        max_count = max(max_count, cur)\n\n    return total - max_count\n\n\ndata = [1, 0, 1, 0, 1]\nprint(minSwaps(data))  # 1\n</code></pre>"},{"location":"leetpattern/sliding_window_fixed/#209-minimum-size-subarray-sum","title":"209. Minimum Size Subarray Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sliding window, prefix sum</p> </li> </ul> 209. Minimum Size Subarray Sum - Python Solution<pre><code>import bisect\nfrom typing import List\n\n\n# Prefix Sum\ndef minSubArrayLenPS(target: int, nums: List[int]) -&gt; int:\n    n = len(nums)\n    prefix_sums = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        prefix_sums[i] = prefix_sums[i - 1] + nums[i - 1]\n\n    minLen = float(\"inf\")\n\n    for i in range(n + 1):\n        new_target = target + prefix_sums[i]\n        bound = bisect.bisect_left(prefix_sums, new_target)\n        if bound != len(prefix_sums):\n            minLen = min(minLen, bound - i)\n\n    return 0 if minLen == float(\"inf\") else minLen\n\n\n# Sliding Window Variable Size\ndef minSubArrayLenSW(target: int, nums: List[int]) -&gt; int:\n    res, cur = float(\"inf\"), 0\n    left = 0\n\n    for right in range(len(nums)):\n        cur += nums[right]\n\n        while cur &gt;= target:\n            res = min(res, right - left + 1)\n            cur -= nums[left]\n            left += 1\n\n    return res if res != float(\"inf\") else 0\n\n\ntarget = 7\nnums = [2, 3, 1, 2, 4, 3]\nprint(minSubArrayLenPS(target, nums))  # 2\nprint(minSubArrayLenSW(target, nums))  # 2\n</code></pre>"},{"location":"leetpattern/sliding_window_fixed/#76-minimum-window-substring","title":"76. Minimum Window Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> </ul> 76. Minimum Window Substring - Python Solution<pre><code>from collections import Counter\n\n\ndef minWindow(s: str, t: str) -&gt; str:\n    if not t or not s:\n        return \"\"\n\n    counts = Counter(t)\n    required = len(counts)\n\n    left, right = 0, 0\n    formed = 0\n    window_counts = dict()\n\n    result = float(\"inf\"), None, None\n\n    while right &lt; len(s):\n        char = s[right]\n        window_counts[char] = window_counts.get(char, 0) + 1\n        if char in counts and window_counts[char] == counts[char]:\n            formed += 1\n\n        while left &lt;= right and formed == required:\n            char = s[left]\n            if right - left + 1 &lt; result[0]:\n                result = (right - left + 1, left, right)\n            window_counts[char] -= 1\n            if char in counts and window_counts[char] &lt; counts[char]:\n                formed -= 1\n            left += 1\n\n        right += 1\n\n    return \"\" if result[0] == float(\"inf\") else s[result[1] : result[2] + 1]\n\n\ns = \"ADOBECODEBANC\"\nt = \"ABC\"\nprint(minWindow(s, t))  # BANC\n</code></pre>"},{"location":"leetpattern/sliding_window_variable/","title":"Sliding Window Variable","text":"<ul> <li> 3. Longest Substring Without Repeating Characters (Medium)</li> <li> 159. Longest Substring with At Most Two Distinct Characters (Medium)</li> <li> 424. Longest Repeating Character Replacement (Medium)</li> <li> 1208. Get Equal Substrings Within Budget (Medium)</li> <li> 1004. Max Consecutive Ones III (Medium)</li> <li> 438. Find All Anagrams in a String (Medium)</li> <li> 992. Subarrays with K Different Integers (Hard)</li> <li> 2024. Maximize the Confusion of an Exam (Medium)</li> </ul>"},{"location":"leetpattern/sliding_window_variable/#3-longest-substring-without-repeating-characters","title":"3. Longest Substring Without Repeating Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> <li>Classic sliding window problem. Use a set to keep track of the characters in the current window.</li> <li>Return the length of the longest substring without repeating characters.</li> </ul> 3. Longest Substring Without Repeating Characters - Python Solution<pre><code># Sliding Window Variable Size\ndef lengthOfLongestSubstring(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    window = set()\n    left = 0\n    res = 0\n\n    for right in range(n):\n        while s[right] in window:\n            window.remove(s[left])\n            left += 1\n        window.add(s[right])\n        res = max(res, right - left + 1)\n\n    return res\n\n\ns = \"abcabcbb\"\nassert lengthOfLongestSubstring(s) == 3\n</code></pre>"},{"location":"leetpattern/sliding_window_variable/#159-longest-substring-with-at-most-two-distinct-characters","title":"159. Longest Substring with At Most Two Distinct Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> <li>Prerequisite: 3. Longest Substring Without Repeating Characters</li> </ul> 159. Longest Substring with At Most Two Distinct Characters - Python Solution<pre><code>from collections import defaultdict\n\n\n# Sliding Window - Variable\ndef lengthOfLongestSubstringTwoDistinct(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 2:\n        return n\n\n    window = defaultdict(int)\n    left, res = 0, 0\n\n    for right in range(n):\n        window[s[right]] += 1\n\n        while len(window) &gt; 2:\n            window[s[left]] -= 1\n            if window[s[left]] == 0:\n                del window[s[left]]\n            left += 1\n\n        res = max(res, right - left + 1)\n\n    return res\n\n\ns = \"ccaabbb\"\nassert lengthOfLongestSubstringTwoDistinct(s) == 5\n</code></pre>"},{"location":"leetpattern/sliding_window_variable/#424-longest-repeating-character-replacement","title":"424. Longest Repeating Character Replacement","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> </ul> 424. Longest Repeating Character Replacement - Python Solution<pre><code>from collections import defaultdict\n\n\n# Sliding Window - Variable\ndef characterReplacement(s: str, k: int) -&gt; int:\n    left = 0\n    maxCount = 0\n    counts = defaultdict(int)\n    maxLen = 0\n\n    for right in range(len(s)):\n        counts[s[right]] += 1\n        maxCount = max(maxCount, counts[s[right]])\n\n        while right - left + 1 - maxCount &gt; k:\n            counts[s[left]] -= 1\n            left += 1\n\n        maxLen = max(maxLen, right - left + 1)\n\n    return maxLen\n\n\ns = \"ABAB\"\nk = 2\nprint(characterReplacement(s, k))  # 4\n</code></pre>"},{"location":"leetpattern/sliding_window_variable/#1208-get-equal-substrings-within-budget","title":"1208. Get Equal Substrings Within Budget","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, binary search, sliding window, prefix sum</p> </li> </ul> 1208. Get Equal Substrings Within Budget - Python Solution<pre><code># Sliding Window - Variable\ndef equalSubstring(s: str, t: str, maxCost: int) -&gt; int:\n    left = 0\n    maxLen = 0\n    currentCost = 0\n\n    for right in range(len(s)):\n        currentCost += abs(ord(s[right]) - ord(t[right]))\n\n        while currentCost &gt; maxCost:\n            currentCost -= abs(ord(s[left]) - ord(t[left]))\n            left += 1\n\n        maxLen = max(maxLen, right - left + 1)\n\n    return maxLen\n\n\ns = \"abcd\"\nt = \"bcdf\"\nmaxCost = 3\nprint(equalSubstring(s, t, maxCost))  # 3\n</code></pre>"},{"location":"leetpattern/sliding_window_variable/#1004-max-consecutive-ones-iii","title":"1004. Max Consecutive Ones III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, sliding window, prefix sum</p> </li> </ul> 1004. Max Consecutive Ones III - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window - Variable\ndef longestOnes(nums: List[int], k: int) -&gt; int:\n    left = 0\n    maxLen = 0\n    zero_count = 0\n\n    for right in range(len(nums)):\n        if nums[right] == 0:\n            zero_count += 1\n\n        while zero_count &gt; k:\n            if nums[left] == 0:\n                zero_count -= 1\n            left += 1\n\n        maxLen = max(maxLen, right - left + 1)\n\n    return maxLen\n\n\nnums = [1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0]\nk = 2\nprint(longestOnes(nums, k))  # 6\n</code></pre>"},{"location":"leetpattern/sliding_window_variable/#438-find-all-anagrams-in-a-string","title":"438. Find All Anagrams in a String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> </ul> 438. Find All Anagrams in a String - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window - Variable\ndef findAnagrams(s: str, p: str) -&gt; List[int]:\n    result = []\n    if len(s) &lt; len(p):\n        return result\n\n    countP = [0] * 26\n    for i in p:\n        countP[ord(i) - ord(\"a\")] += 1\n\n    countS = [0] * 26\n    for i in range(len(p)):\n        countS[ord(s[i]) - ord(\"a\")] += 1\n\n    if countS == countP:\n        result.append(0)\n\n    # sliding window\n    for i in range(len(p), len(s)):\n        countS[ord(s[i]) - ord(\"a\")] += 1  # add new character\n        countS[ord(s[i - len(p)]) - ord(\"a\")] -= 1  # remove old character\n        if countS == countP:\n            result.append(i - len(p) + 1)  # append the starting index\n\n    return result\n\n\ns = \"cbaebabacd\"\np = \"abc\"\nprint(findAnagrams(s, p))  # [0, 6]\n</code></pre>"},{"location":"leetpattern/sliding_window_variable/#992-subarrays-with-k-different-integers","title":"992. Subarrays with K Different Integers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, sliding window, counting</p> </li> </ul> 992. Subarrays with K Different Integers - Python Solution<pre><code>from typing import List\n\n\n# Sliding Window - Variable\ndef subarraysWithKDistinct(nums: List[int], k: int) -&gt; int:\n    def atMost(k: int) -&gt; int:\n        count = 0\n        left = 0\n        freq = {}\n\n        for right in range(len(nums)):\n            if nums[right] not in freq:\n                freq[nums[right]] = 0\n            freq[nums[right]] += 1\n\n            while len(freq) &gt; k:\n                freq[nums[left]] -= 1\n                if freq[nums[left]] == 0:\n                    del freq[nums[left]]\n                left += 1\n\n            count += right - left + 1\n\n        return count\n\n    return atMost(k) - atMost(k - 1)\n\n\nnums = [1, 2, 1, 2, 3]\nk = 2\nprint(subarraysWithKDistinct(nums, k))  # 7\n</code></pre>"},{"location":"leetpattern/sliding_window_variable/#2024-maximize-the-confusion-of-an-exam","title":"2024. Maximize the Confusion of an Exam","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, binary search, sliding window, prefix sum</p> </li> </ul> 2024. Maximize the Confusion of an Exam - Python Solution<pre><code># Sliding Window - Variable\ndef maxConsecutiveAnswers1(answerKey: str, k: int) -&gt; int:\n    def maxConsecutiveChar(s: str, k: int, char: str) -&gt; int:\n        max_len = 0\n        left = 0\n        count = 0  # num of str != char\n\n        for right in range(len(s)):\n            if s[right] != char:\n                count += 1\n\n            while count &gt; k:\n                if s[left] != char:\n                    count -= 1\n                left += 1\n\n            max_len = max(max_len, right - left + 1)\n\n        return max_len\n\n    max_t = maxConsecutiveChar(answerKey, k, \"T\")\n    max_f = maxConsecutiveChar(answerKey, k, \"F\")\n\n    return max(max_t, max_f)\n\n\n# Sliding Window - Variable\ndef maxConsecutiveAnswers2(answerKey: str, k: int) -&gt; int:\n    def maxConsecutiveChar(s: str, k: int, char: str) -&gt; int:\n        max_len = 0\n        left, right = 0, 0\n\n        while right &lt; len(s):\n            if s[right] != char:\n                k -= 1\n\n            while k &lt; 0:\n                if s[left] != char:\n                    k += 1\n                left += 1\n\n            max_len = max(max_len, right - left + 1)\n            right += 1\n\n        return max_len\n\n    max_t = maxConsecutiveChar(answerKey, k, \"T\")\n    max_f = maxConsecutiveChar(answerKey, k, \"F\")\n\n    return max(max_t, max_f)\n\n\n# |-----------------|---------|------------|\n# |  Approach       |  Time   |  Space     |\n# |-----------------|---------|------------|\n# | Sliding Window  |  O(N)   |  O(1)      |\n# |-----------------|---------|------------|\n\n\nanswerKey = \"TTFF\"\nk = 2\nprint(maxConsecutiveAnswers1(answerKey, k))  # 4\nprint(maxConsecutiveAnswers2(answerKey, k))  # 4\n</code></pre>"},{"location":"leetpattern/stack/","title":"Stack","text":"<ul> <li> 2390. Removing Stars From a String (Medium)</li> <li> 1544. Make The String Great (Easy)</li> <li> 20. Valid Parentheses (Easy)</li> <li> 155. Min Stack (Medium)</li> <li> 150. Evaluate Reverse Polish Notation (Medium)</li> <li> 394. Decode String (Medium)</li> <li> 22. Generate Parentheses (Medium)</li> <li> 853. Car Fleet (Medium)</li> <li> 224. Basic Calculator (Hard)</li> <li> 227. Basic Calculator II (Medium)</li> <li> 772. Basic Calculator III (Hard)</li> <li> 770. Basic Calculator IV (Hard)</li> </ul>"},{"location":"leetpattern/stack/#2390-removing-stars-from-a-string","title":"2390. Removing Stars From a String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack, simulation</p> </li> <li> <p>Remove all <code>*</code> characters and their adjacent characters from the string.</p> </li> <li> <p>Steps for the string <code>leet**cod*e</code>:</p> </li> </ul> char action stack l push \"l\" e push \"le\" e push \"lee\" t push \"leet\" * pop \"lee\" * pop \"le\" c push \"lec\" o push \"leco\" d push \"lecod\" * pop \"leco\" e push \"lecoe\" 2390. Removing Stars From a String - Python Solution<pre><code># Stack\ndef removeStars(s: str) -&gt; str:\n    stack = []\n\n    for char in s:\n        if char == \"*\":\n            stack.pop()\n        else:\n            stack.append(char)\n\n    return \"\".join(stack)\n\n\ns = \"leet**cod*e\"\nprint(removeStars(s))  # \"lecoe\"\n</code></pre>"},{"location":"leetpattern/stack/#1544-make-the-string-great","title":"1544. Make The String Great","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, stack</p> </li> <li>Remove all adjacent characters that are the same and have different cases.</li> <li>Steps for the string <code>leEeetcode</code>:</li> </ul> char action stack l push \"l\" e push \"le\" E pop \"l\" e push \"le\" e push \"lee\" t push \"leet\" c push \"leetc\" o push \"leetco\" d push \"leetcod\" e push \"leetcode\" 1544. Make The String Great - Python Solution<pre><code># Stack\ndef makeGood(s: str) -&gt; str:\n    stack = []\n\n    for i in range(len(s)):\n        if stack and stack[-1] == s[i].swapcase():\n            stack.pop()\n        else:\n            stack.append(s[i])\n    return \"\".join(stack)\n\n\nprint(makeGood(\"leEeetcode\"))  # \"leetcode\"\n</code></pre>"},{"location":"leetpattern/stack/#20-valid-parentheses","title":"20. Valid Parentheses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, stack</p> </li> <li>Determine if the input string is valid.</li> <li>Steps for the string <code>()[]{}</code>:</li> </ul> char action stack <code>(</code> push \"(\" <code>)</code> pop \"\" <code>[</code> push \"[\" <code>]</code> pop \"\" <code>{</code> push \"{\" <code>}</code> pop \"\" 20. Valid Parentheses - Python Solution<pre><code># Stack\ndef isValid(s: str) -&gt; bool:\n    hashmap = {\n        \")\": \"(\",\n        \"]\": \"[\",\n        \"}\": \"{\",\n    }\n    stack = []\n\n    for c in s:\n        if c in hashmap:\n            if stack and stack[-1] == hashmap[c]:\n                stack.pop()\n            else:\n                return False\n        else:\n            stack.append(c)\n\n    return True if not stack else False\n\n\nprint(isValid(\"()\"))  # True\nprint(isValid(\"()[]{}\"))  # True\nprint(isValid(\"(]\"))  # False\n</code></pre>"},{"location":"leetpattern/stack/#155-min-stack","title":"155. Min Stack","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: stack, design</p> </li> <li>Implement a stack that supports push, pop, top, and retrieving the minimum element in constant time.</li> </ul> 155. Min Stack - Python Solution<pre><code># Stack\nclass MinStack:\n\n    def __init__(self):\n        self.stack = []\n        self.minStack = []\n\n    def push(self, val: int) -&gt; None:\n        self.stack.append(val)\n        val = min(val, self.minStack[-1] if self.minStack else val)\n        self.minStack.append(val)\n\n    def pop(self) -&gt; None:\n        if self.stack:\n            self.stack.pop()\n        if self.minStack:\n            self.minStack.pop()\n\n    def top(self) -&gt; int:\n        return self.stack[-1] if self.stack else None\n\n    def getMin(self) -&gt; int:\n        return self.minStack[-1] if self.minStack else None\n\n\n# Your MinStack object will be instantiated and called as such:\nobj = MinStack()\nobj.push(3)\nobj.push(2)\nobj.pop()\nprint(obj.top())  # 3\nprint(obj.getMin())  # 3\n</code></pre>"},{"location":"leetpattern/stack/#150-evaluate-reverse-polish-notation","title":"150. Evaluate Reverse Polish Notation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, stack</p> </li> <li>Steps for the list <code>[\"2\", \"1\", \"+\", \"3\", \"*\"]</code>:</li> </ul> token action stack <code>2</code> push <code>[2]</code> <code>1</code> push <code>[2, 1]</code> <code>+</code> pop <code>[3]</code> <code>3</code> push <code>[3, 3]</code> <code>*</code> pop <code>[9]</code> 150. Evaluate Reverse Polish Notation - Python Solution<pre><code>from typing import List\n\n\n# Stack\ndef evalRPN(tokens: List[str]) -&gt; int:\n    stack = []\n\n    for c in tokens:\n        if c == \"+\":\n            stack.append(stack.pop() + stack.pop())\n        elif c == \"-\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(b - a)\n        elif c == \"*\":\n            stack.append(stack.pop() * stack.pop())\n        elif c == \"/\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(int(b / a))\n        else:\n            stack.append(int(c))\n\n    return stack[0]\n\n\nprint(evalRPN([\"2\", \"1\", \"+\", \"3\", \"*\"]))  # 9\nprint(evalRPN([\"4\", \"13\", \"5\", \"/\", \"-\"]))  # 2\nprint(evalRPN([\"18\"]))  # 18\nprint(evalRPN([\"4\", \"3\", \"-\"]))  # 1\n</code></pre>"},{"location":"leetpattern/stack/#394-decode-string","title":"394. Decode String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack, recursion</p> </li> </ul> 394. Decode String - Python Solution<pre><code># Stack\ndef decodeString(s: str) -&gt; str:\n    stack = []  # (str, int)\n    num = 0\n    res = \"\"\n\n    for c in s:\n        if c.isdigit():\n            num = num * 10 + int(c)\n        elif c == \"[\":\n            stack.append((res, num))\n            res, num = \"\", 0\n        elif c == \"]\":\n            top = stack.pop()\n            res = top[0] + res * top[1]\n        else:\n            res += c\n\n    return res\n\n\ns = \"3[a2[c]]\"\nprint(decodeString(s))  # accaccacc\n</code></pre>"},{"location":"leetpattern/stack/#22-generate-parentheses","title":"22. Generate Parentheses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming, backtracking</p> </li> </ul> 22. Generate Parentheses - Python Solution<pre><code>from typing import List\n\n\n# Stack\ndef generateParenthesis(n: int) -&gt; List[str]:\n    stack = []\n    result = []\n\n    def backtrack(openN, closeN):\n        if openN == closeN == n:\n            result.append(\"\".join(stack))\n            return None\n\n        if openN &lt; n:\n            stack.append(\"(\")\n            backtrack(openN + 1, closeN)\n            stack.pop()\n\n        if closeN &lt; openN:\n            stack.append(\")\")\n            backtrack(openN, closeN + 1)\n            stack.pop()\n\n    backtrack(0, 0)\n\n    return result\n\n\nprint(generateParenthesis(3))\n# ['((()))', '(()())', '(())()', '()(())', '()()()']\n</code></pre>"},{"location":"leetpattern/stack/#853-car-fleet","title":"853. Car Fleet","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, sorting, monotonic stack</p> </li> </ul> 853. Car Fleet - Python Solution<pre><code>from typing import List\n\n\n# Stack\ndef carFleet(target: int, position: List[int], speed: List[int]) -&gt; int:\n    cars = sorted(zip(position, speed), reverse=True)\n    stack = []\n\n    for p, s in cars:\n        time = (target - p) / s\n\n        if not stack or time &gt; stack[-1]:\n            stack.append(time)\n\n    return len(stack)\n\n\nprint(carFleet(12, [10, 8, 0, 5, 3], [2, 4, 1, 1, 3]))  # 3\n</code></pre>"},{"location":"leetpattern/stack/#224-basic-calculator","title":"224. Basic Calculator","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, string, stack, recursion</p> </li> </ul> 224. Basic Calculator - Python Solution<pre><code># Stack\ndef calculate(s: str) -&gt; int:\n    stack = []\n    result = 0\n    number = 0\n    sign = 1\n\n    for char in s:\n        if char.isdigit():\n            number = number * 10 + int(char)\n\n        elif char == \"+\":\n            result += sign * number\n            number = 0\n            sign = 1\n        elif char == \"-\":\n            result += sign * number\n            number = 0\n            sign = -1\n\n        elif char == \"(\":\n            stack.append(result)\n            stack.append(sign)\n            result = 0\n            sign = 1\n        elif char == \")\":\n            result += sign * number\n            number = 0\n            result *= stack.pop()  # pop sign\n            result += stack.pop()  # pop previous result\n\n    result += sign * number\n\n    return result\n\n\nprint(calculate(\"(1+(4+5+2)-3)+(6+8)\"))  # 23\n</code></pre>"},{"location":"leetpattern/stack/#227-basic-calculator-ii","title":"227. Basic Calculator II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, string, stack</p> </li> </ul> 227. Basic Calculator II - Python Solution<pre><code># Stack\ndef calculate(s: str) -&gt; int:\n    stack = []\n    num = 0\n    sign = \"+\"\n\n    for index, char in enumerate(s):\n        if char.isdigit():\n            num = num * 10 + int(char)\n\n        if char in \"+-*/\" or index == len(s) - 1:\n            if sign == \"+\":\n                stack.append(num)\n            elif sign == \"-\":\n                stack.append(-num)\n            elif sign == \"*\":\n                stack.append(stack.pop() * num)\n            elif sign == \"/\":\n                stack.append(int(stack.pop() / num))\n            sign = char\n            num = 0\n\n    return sum(stack)\n\n\ns = \"3+2*2\"\nprint(calculate(s))  # 7\n</code></pre>"},{"location":"leetpattern/stack/#772-basic-calculator-iii","title":"772. Basic Calculator III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, string, stack, recursion</p> </li> </ul> 772. Basic Calculator III - Python Solution<pre><code># Stack\ndef calculate(s: str) -&gt; int:\n    def helper(index):\n        stack = []\n        num = 0\n        sign = \"+\"\n\n        while index &lt; len(s):\n            char = s[index]\n            if char.isdigit():\n                num = num * 10 + int(char)\n            if char == \"(\":\n                num, index = helper(index + 1)\n            if char in \"+-*/)\" or index == len(s) - 1:\n                if sign == \"+\":\n                    stack.append(num)\n                elif sign == \"-\":\n                    stack.append(-num)\n                elif sign == \"*\":\n                    stack.append(stack.pop() * num)\n                elif sign == \"/\":\n                    stack.append(int(stack.pop() / num))  # \u5411\u96f6\u53d6\u6574\n                num = 0\n                sign = char\n            if char == \")\":\n                break\n            index += 1\n\n        return sum(stack), index\n\n    s = s.replace(\" \", \"\")\n    result, _ = helper(0)\n\n    return result\n\n\ns = \"2*(5+5*2)/3+(6/2+8)\"\nprint(calculate(s))  # 21\n</code></pre>"},{"location":"leetpattern/stack/#770-basic-calculator-iv","title":"770. Basic Calculator IV","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, math, string, stack, recursion</p> </li> </ul> 770. Basic Calculator IV - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Stack\nclass Solution:\n    def __init__(self):\n        self.operators = set([\"+\", \"-\", \"*\"])\n\n    def basicCalculatorIV(\n        self, expression: str, evalvars: List[str], evalints: List[int]\n    ) -&gt; List[str]:\n        evalmap = dict(zip(evalvars, evalints))\n        tokens = self.parse_expression(expression)\n        result_terms = self.evaluate(tokens, evalmap)\n        return self.format_result(result_terms)\n\n    def parse_expression(self, expression):\n        tokens = []\n        i = 0\n        while i &lt; len(expression):\n            if expression[i].isalnum():  # Variable or digit\n                start = i\n                while i &lt; len(expression) and (\n                    expression[i].isalnum() or expression[i] == \"_\"\n                ):\n                    i += 1\n                tokens.append(expression[start:i])\n            elif expression[i] in self.operators or expression[i] in \"()\":\n                tokens.append(expression[i])\n                i += 1\n            elif expression[i] == \" \":\n                i += 1  # skip whitespace\n        return tokens\n\n    def evaluate(self, tokens, evalmap):\n        def apply_operator(op, b, a):\n            if op == \"+\":\n                return self.add_terms(a, b)\n            elif op == \"-\":\n                return self.add_terms(a, self.negate_terms(b))\n            elif op == \"*\":\n                return self.multiply_terms(a, b)\n\n        def process_token(token):\n            if token.isalnum():\n                if token in evalmap:\n                    stack.append({(): evalmap[token]})\n                elif token.isdigit():\n                    stack.append({(): int(token)})\n                else:\n                    stack.append({(token,): 1})\n            elif token == \"(\":\n                ops.append(token)\n            elif token == \")\":\n                while ops and ops[-1] != \"(\":\n                    operate()\n                ops.pop()\n            else:\n                while (\n                    ops\n                    and ops[-1] in precedence\n                    and precedence[ops[-1]] &gt;= precedence[token]\n                ):\n                    operate()\n                ops.append(token)\n\n        def operate():\n            if len(stack) &lt; 2 or not ops:\n                return\n            b = stack.pop()\n            a = stack.pop()\n            op = ops.pop()\n            stack.append(apply_operator(op, b, a))\n\n        stack = []\n        ops = []\n        precedence = {\"+\": 1, \"-\": 1, \"*\": 2}\n\n        for token in tokens:\n            process_token(token)\n\n        while ops:\n            operate()\n        return self.combine_terms(stack[-1])\n\n    def add_terms(self, a, b):\n        result = defaultdict(int, a)\n        for term, coef in b.items():\n            result[term] += coef\n        return dict(result)\n\n    def negate_terms(self, a):\n        return {term: -coef for term, coef in a.items()}\n\n    def multiply_terms(self, a, b):\n        result = defaultdict(int)\n        for term1, coef1 in a.items():\n            for term2, coef2 in b.items():\n                new_term = tuple(sorted(term1 + term2))\n                result[new_term] += coef1 * coef2\n        return dict(result)\n\n    def combine_terms(self, terms):\n        result = defaultdict(int)\n        for term, coef in terms.items():\n            if coef != 0:\n                result[term] = coef\n        return dict(result)\n\n    def format_result(self, result_terms):\n        result = []\n        for term in sorted(result_terms.keys(), key=lambda x: (-len(x), x)):\n            coef = result_terms[term]\n            if coef != 0:\n                term_str = \"*\".join(term)\n                if term_str:\n                    result.append(f\"{coef}*{term_str}\")\n                else:\n                    result.append(str(coef))\n        return result\n\n\ncalculator = Solution()\nexpression = \"e + 8 - a + 5\"\nevalvars = [\"e\"]\nevalints = [1]\nprint(calculator.basicCalculatorIV(expression, evalvars, evalints))\n# ['-1*a', '14']\n</code></pre>"},{"location":"leetpattern/stack_monotonic/","title":"Stack Monotonic","text":"<ul> <li> 739. Daily Temperatures (Medium)</li> <li> 496. Next Greater Element I (Easy)</li> <li> 503. Next Greater Element II (Medium)</li> <li> 84. Largest Rectangle in Histogram (Hard)</li> <li> 85. Maximal Rectangle (Hard)</li> <li> 42. Trapping Rain Water (Hard)</li> <li> 901. Online Stock Span (Medium)</li> <li> 316. Remove Duplicate Letters (Medium)</li> <li> 456. 132 Pattern (Medium)</li> <li> 2281. Sum of Total Strength of Wizards (Hard)</li> </ul>"},{"location":"leetpattern/stack_monotonic/#739-daily-temperatures","title":"739. Daily Temperatures","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, monotonic stack</p> </li> <li>Return an array <code>res</code> such that <code>res[i]</code> is the number of days you have to wait after the <code>ith</code> day to get a warmer temperature.</li> </ul> Index Temp &gt; stack last stack result 0 73 False <code>[ [73, 0] ]</code> 1 - 0 = 1 1 74 True <code>[ [74, 1] ]</code> 2 - 1 = 1 2 75 True <code>[ [75, 2] ]</code> 6 - 2 = 4 3 71 False <code>[ [75, 2], [71, 3] ]</code> 5 - 3 = 2 4 69 False <code>[ [75, 2], [71, 3], [69, 4] ]</code> 5 - 4 = 1 5 72 True <code>[ [75, 2], [72, 5] ]</code> 6 - 5 = 1 6 76 True <code>[ [76, 6] ]</code> 0 7 73 False <code>[[76, 6], [73, 7]]</code> 0 739. Daily Temperatures - Python Solution<pre><code>from typing import List\n\nimport matplotlib.pyplot as plt\n\n\n# Monotonic Stack\ndef dailyTemperatures(temperatures: List[int]) -&gt; List[int]:\n    res = [0 for _ in range(len(temperatures))]\n    stack = []\n\n    for idx, temp in enumerate(temperatures):\n        while stack and temp &gt; stack[-1][0]:\n            _, last_index = stack.pop()\n            res[last_index] = idx - last_index\n\n        stack.append([temp, idx])\n\n    return res\n\n\ndef utils_plot(idx: int, temps: List[int], stack: List[List[int]]) -&gt; None:\n    \"\"\"Plot the current state of the stack and the temperatures.\"\"\"\n    plt.figure(figsize=(8, 3))\n    plt.plot(\n        range(len(temps)),\n        temps,\n        marker=\"o\",\n        linestyle=\"-\",\n        color=\"b\",\n        label=\"Temperatures\",\n    )\n\n    # Highlight the current temperature in red\n    plt.scatter(idx, temps[idx], color=\"r\", s=100, label=\"Current\")\n\n    # Display the current state of the stack\n    for temp, stack_idx in stack:\n        plt.scatter(stack_idx, temp, color=\"g\", s=70)\n        plt.text(\n            stack_idx,\n            temp,\n            f\"({temp}, {stack_idx})\",\n            fontsize=10,\n            ha=\"center\",\n            va=\"bottom\",\n            color=\"red\",\n        )\n\n    plt.title(f\"Day {idx}\")\n    plt.xlabel(\"Days\")\n    plt.ylabel(\"Temperature\")\n    plt.legend()\n    plt.grid(True)\n    plt.show()\n\n\nprint(dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73]))\n# [1, 1, 4, 2, 1, 1, 0, 0]\n</code></pre>"},{"location":"leetpattern/stack_monotonic/#496-next-greater-element-i","title":"496. Next Greater Element I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, stack, monotonic stack</p> </li> </ul> 496. Next Greater Element I - Python Solution<pre><code>from typing import List\n\n\n# Monotonic Stack\ndef nextGreaterElement(nums1: List[int], nums2: List[int]) -&gt; List[int]:\n    next_greater = {}\n    stack = []\n    result = []\n\n    for num in nums2:\n        while stack and num &gt; stack[-1]:\n            next_greater[stack.pop()] = num\n        stack.append(num)\n\n    for num in nums1:\n        result.append(next_greater.get(num, -1))\n\n    return result\n\n\nnums1 = [4, 1, 2]\nnums2 = [1, 3, 4, 2]\nprint(nextGreaterElement(nums1, nums2))  # [3, -1, -1]\n</code></pre>"},{"location":"leetpattern/stack_monotonic/#503-next-greater-element-ii","title":"503. Next Greater Element II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, monotonic stack</p> </li> </ul> 503. Next Greater Element II - Python Solution<pre><code>from typing import List\n\n\n# Monotonic Stack\ndef nextGreaterElements(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    result = [-1] * n\n    stack = []\n\n    for i in range(2 * n):\n        while stack and nums[stack[-1]] &lt; nums[i % n]:\n            result[stack.pop()] = nums[i % n]\n        if i &lt; n:\n            stack.append(i)\n\n    return result\n\n\nnums = [1, 2, 1]\nprint(nextGreaterElements(nums))  # [2, -1, 2]\n</code></pre>"},{"location":"leetpattern/stack_monotonic/#84-largest-rectangle-in-histogram","title":"84. Largest Rectangle in Histogram","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, stack, monotonic stack</p> </li> </ul> 84. Largest Rectangle in Histogram - Python Solution<pre><code>from typing import List\n\n\ndef largestRectangleArea(heights: List[int]) -&gt; int:\n    maxArea = 0\n    stack = []  # pair: (index, height)\n\n    for i, h in enumerate(heights):\n        start = i\n        while stack and stack[-1][1] &gt; h:\n            index, height = stack.pop()\n            maxArea = max(maxArea, height * (i - index))\n            start = index\n        stack.append((start, h))\n\n    for i, h in stack:\n        maxArea = max(maxArea, h * (len(heights) - i))\n\n    return maxArea\n\n\nprint(largestRectangleArea([2, 1, 5, 6, 2, 3]))  # 10\n</code></pre>"},{"location":"leetpattern/stack_monotonic/#85-maximal-rectangle","title":"85. Maximal Rectangle","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, stack, matrix, monotonic stack</p> </li> <li>Return the area of the largest rectangle that can be formed within a rectangle of 1's.</li> </ul> <p></p> 85. Maximal Rectangle - Python Solution<pre><code>from typing import List\n\n\n# Monotonic Stack\ndef maximalRectangle(matrix: List[List[str]]) -&gt; int:\n    if not matrix or not matrix[0]:\n        return 0\n\n    n = len(matrix[0])\n    heights = [0] * (n + 1)\n    max_area = 0\n\n    for row in matrix:\n        for i in range(n):\n            if row[i] == \"1\":\n                heights[i] += 1\n            else:\n                heights[i] = 0\n\n        stack = [-1]\n        for i in range(n + 1):\n            while heights[i] &lt; heights[stack[-1]]:\n                h = heights[stack.pop()]\n                w = i - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            stack.append(i)\n\n    return max_area\n\n\nmatrix = [\n    [\"1\", \"0\", \"1\", \"0\", \"0\"],\n    [\"1\", \"0\", \"1\", \"1\", \"1\"],\n    [\"1\", \"1\", \"1\", \"1\", \"1\"],\n    [\"1\", \"0\", \"0\", \"1\", \"0\"],\n]\nprint(maximalRectangle(matrix))  # 6\n</code></pre>"},{"location":"leetpattern/stack_monotonic/#42-trapping-rain-water","title":"42. Trapping Rain Water","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, dynamic programming, stack, monotonic stack</p> </li> <li></li> </ul> Approach Time Space DP O(N) O(N) Left Right O(N) O(1) Monotonic O(N) O(N) 42. Trapping Rain Water - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef trapDP(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    n = len(height)\n    maxLeft, maxRight = [0 for _ in range(n)], [0 for _ in range(n)]\n\n    for i in range(1, n):\n        maxLeft[i] = max(maxLeft[i - 1], height[i - 1])\n\n    for i in range(n - 2, -1, -1):\n        maxRight[i] = max(maxRight[i + 1], height[i + 1])\n\n    res = 0\n    for i in range(n):\n        res += max(0, min(maxLeft[i], maxRight[i]) - height[i])\n\n    return res\n\n\n# Left Right Pointers\ndef trapLR(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    left, right = 0, len(height) - 1\n    maxL, maxR = height[left], height[right]\n    res = 0\n\n    while left &lt; right:\n        if maxL &lt; maxR:\n            left += 1\n            maxL = max(maxL, height[left])\n            res += maxL - height[left]\n        else:\n            right -= 1\n            maxR = max(maxR, height[right])\n            res += maxR - height[right]\n\n    return res\n\n\n# Monotonic Stack\ndef trapStack(height: List[int]) -&gt; int:\n    stack = []\n    total = 0\n\n    for i in range(len(height)):\n        while stack and height[i] &gt; height[stack[-1]]:\n            top = stack.pop()\n            if not stack:\n                break\n            distance = i - stack[-1] - 1\n            bounded_height = min(height[i], height[stack[-1]]) - height[top]\n            total += distance * bounded_height\n        stack.append(i)\n\n    return total\n\n\nheight = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\nprint(trapDP(height))  # 6\nprint(trapLR(height))  # 6\nprint(trapStack(height))  # 6\n</code></pre>"},{"location":"leetpattern/stack_monotonic/#901-online-stock-span","title":"901. Online Stock Span","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: stack, design, monotonic stack, data stream</p> </li> <li>Design a class <code>StockSpanner</code> to return the number of consecutive days (including the current day) the price of the stock has been less than or equal to the current price.</li> </ul> 901. Online Stock Span - Python Solution<pre><code>from typing import List\n\n\n# Monotonic Stack\nclass StockSpanner:\n\n    def __init__(self):\n        self.stack = [(-1, float(\"inf\"))]\n        self.cur_day = -1\n\n    def next(self, price: int) -&gt; int:\n        while price &gt;= self.stack[-1][1]:\n            self.stack.pop()\n        self.cur_day += 1\n        self.stack.append((self.cur_day, price))\n        return self.cur_day - self.stack[-2][0]\n\n\nobj = StockSpanner()\nprices = [100, 80, 60, 70, 60, 75, 85]\nprint([obj.next(price) for price in prices])  # [1, 1, 1, 2, 1, 4, 6]\n</code></pre>"},{"location":"leetpattern/stack_monotonic/#316-remove-duplicate-letters","title":"316. Remove Duplicate Letters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack, greedy, monotonic stack</p> </li> </ul> 316. Remove Duplicate Letters - Python Solution<pre><code># Monotonic Stack\ndef removeDuplicateLetters(s: str) -&gt; str:\n    stack = []\n    seen = set()\n    last = {c: i for i, c in enumerate(s)}\n\n    for i, c in enumerate(s):\n        if c not in seen:\n            while stack and c &lt; stack[-1] and i &lt; last[stack[-1]]:\n                seen.discard(stack.pop())\n            seen.add(c)\n            stack.append(c)\n\n    return \"\".join(stack)\n\n\ns = \"cbacdcbc\"\nprint(removeDuplicateLetters(s))  # acdb\n</code></pre>"},{"location":"leetpattern/stack_monotonic/#456-132-pattern","title":"456. 132 Pattern","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, stack, monotonic stack, ordered set</p> </li> </ul> 456. 132 Pattern - Python Solution<pre><code>from typing import List\n\n\n# Monotonic Stack\ndef find132pattern(nums: List[int]) -&gt; bool:\n    n = len(nums)\n    if n &lt; 3:\n        return False\n\n    stack = []\n    second_max = float(\"-inf\")\n\n    for i in range(n - 1, -1, -1):\n        if nums[i] &lt; second_max:\n            return True\n\n        while stack and stack[-1] &lt; nums[i]:\n            second_max = stack.pop()\n\n        stack.append(nums[i])\n\n    return False\n\n\nnums = [-1, 3, 2, 0]\nprint(find132pattern(nums))  # True\n</code></pre>"},{"location":"leetpattern/stack_monotonic/#2281-sum-of-total-strength-of-wizards","title":"2281. Sum of Total Strength of Wizards","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, stack, monotonic stack, prefix sum</p> </li> </ul> 2281. Sum of Total Strength of Wizards - Python Solution<pre><code>from itertools import accumulate\nfrom typing import List\n\n\n# Monotonic Stack\ndef totalStrength(strength: List[int]) -&gt; int:\n    n = len(strength)\n    left = [-1 for _ in range(n)]\n    right = [n for _ in range(n)]\n    stack = []\n\n    for i, v in enumerate(strength):\n        while stack and strength[stack[-1]] &gt;= v:\n            right[stack.pop()] = i\n        if stack:\n            left[i] = stack[-1]\n        stack.append(i)\n\n    prefix_sum = list(accumulate(accumulate(strength, initial=0), initial=0))\n\n    ans = 0\n    for i, v in enumerate(strength):\n        l, r = left[i] + 1, right[i] - 1\n        tot = (i - l + 1) * (prefix_sum[r + 2] - prefix_sum[i + 1]) - (\n            r - i + 1\n        ) * (prefix_sum[i + 1] - prefix_sum[l])\n        ans += v * tot\n\n    return ans % (10**9 + 7)\n\n\nstrength = [1, 3, 1, 2]\nprint(totalStrength(strength))  # 44\n</code></pre>"},{"location":"leetpattern/string/","title":"String","text":"<ul> <li> 344. Reverse String (Easy)</li> <li> 541. Reverse String II (Easy)</li> <li> 151. Reverse Words in a String (Medium)</li> <li> 58. Length of Last Word (Easy)</li> <li> 844. Backspace String Compare (Easy)</li> <li> 2185. Counting Words With a Given Prefix (Easy)</li> <li> 2000. Reverse Prefix of Word (Easy)</li> </ul>"},{"location":"leetpattern/string/#344-reverse-string","title":"344. Reverse String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string</p> </li> </ul> 344. Reverse String - Python Solution<pre><code>from typing import List\n\n\ndef reverseString(s: List[str]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify s in-place instead.\n    \"\"\"\n    left, right = 0, len(s) - 1\n\n    while left &lt; right:\n        s[left], s[right] = s[right], s[left]\n        left += 1\n        right -= 1\n\n\ns = [\"h\", \"e\", \"l\", \"l\", \"o\"]\nreverseString(s)\nprint(s)  # ['o', 'l', 'l', 'e', 'h']\n</code></pre>"},{"location":"leetpattern/string/#541-reverse-string-ii","title":"541. Reverse String II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string</p> </li> </ul> 541. Reverse String II - Python Solution<pre><code>def reverseStr(s: str, k: int) -&gt; str:\n    def reverse_substring(text):\n        left, right = 0, len(text) - 1\n        while left &lt; right:\n            text[left], text[right] = text[right], text[left]\n            left += 1\n            right -= 1\n        return text\n\n    result = list(s)\n\n    for i in range(0, len(s), 2 * k):\n        result[i : i + k] = reverse_substring(result[i : i + k])\n\n    return \"\".join(result)\n\n\ns = \"abcdefg\"\nk = 2\nprint(reverseStr(s, k))  # \"bacdfeg\"\n</code></pre>"},{"location":"leetpattern/string/#151-reverse-words-in-a-string","title":"151. Reverse Words in a String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string</p> </li> </ul> 151. Reverse Words in a String - Python Solution<pre><code>def reverseWords(s: str) -&gt; str:\n    words = s.split()\n\n    left, right = 0, len(words) - 1\n\n    while left &lt; right:\n        words[left], words[right] = words[right], words[left]\n        left += 1\n        right -= 1\n\n    return \" \".join(words)\n\n\ns = \"the sky is blue\"\nprint(reverseWords(s))  # \"blue is sky the\"\n</code></pre>"},{"location":"leetpattern/string/#58-length-of-last-word","title":"58. Length of Last Word","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string</p> </li> </ul> 58. Length of Last Word - Python Solution<pre><code>def lengthOfLastWord(s: str) -&gt; int:\n    n = 0\n\n    for i in range(len(s) - 1, -1, -1):\n        if s[i] != \" \":\n            n += 1\n        if s[i] == \" \" and n &gt; 0:\n            return n\n\n    return n\n\n\nprint(lengthOfLastWord(\"Hello World\"))  # 5\n</code></pre>"},{"location":"leetpattern/string/#844-backspace-string-compare","title":"844. Backspace String Compare","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string, stack, simulation</p> </li> </ul> 844. Backspace String Compare - Python Solution<pre><code>def backspaceCompare(s: str, t: str) -&gt; bool:\n\n    def build(text):\n        stack = []\n\n        for char in text:\n            if char != \"#\":\n                stack.append(char)\n            elif stack:\n                stack.pop()\n\n        return \"\".join(stack)\n\n    return build(s) == build(t)\n\n\nprint(backspaceCompare(\"ab#c\", \"ad#c\"))  # True\n</code></pre>"},{"location":"leetpattern/string/#2185-counting-words-with-a-given-prefix","title":"2185. Counting Words With a Given Prefix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, string, string matching</p> </li> </ul> 2185. Counting Words With a Given Prefix - Python Solution<pre><code>from typing import List\n\n\n# 1\ndef prefixCount1(words: List[str], pref: str) -&gt; int:\n    count = 0\n\n    for word in words:\n        if word.startswith(pref):\n            count += 1\n\n    return count\n\n\n# 2\ndef prefixCount2(words: List[str], pref: str) -&gt; int:\n    count = 0\n\n    for word in words:\n        n = len(pref)\n\n        if len(word) &lt; n:\n            continue\n\n        if word[:n] == pref:\n            count += 1\n\n    return count\n\n\nwords = [\"pay\", \"attention\", \"practice\", \"attend\"]\npref = \"at\"\nprint(prefixCount1(words, pref))  # 2\nprint(prefixCount2(words, pref))  # 2\n</code></pre>"},{"location":"leetpattern/string/#2000-reverse-prefix-of-word","title":"2000. Reverse Prefix of Word","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string, stack</p> </li> </ul> 2000. Reverse Prefix of Word - Python Solution<pre><code>def reversePrefix(word: str, ch: str) -&gt; str:\n    if ch not in word:\n        return word\n\n    wordList = list(word)\n    left, right = 0, 0\n\n    for i in range(len(wordList)):\n        if wordList[i] == ch:\n            right = i\n            break\n\n    while left &lt; right:\n        wordList[left], wordList[right] = wordList[right], wordList[left]\n        left += 1\n        right -= 1\n\n    return \"\".join(wordList)\n\n\nword = \"abcdefd\"\nch = \"d\"\nprint(reversePrefix(word, ch))  # \"dcbaefd\"\n</code></pre>"},{"location":"leetpattern/tree_bfs/","title":"Tree BFS","text":"<ul> <li> 199. Binary Tree Right Side View (Medium)</li> <li> 111. Minimum Depth of Binary Tree (Easy)</li> <li> 104. Maximum Depth of Binary Tree (Easy)</li> <li> 637. Average of Levels in Binary Tree (Easy)</li> <li> 429. N-ary Tree Level Order Traversal (Medium)</li> <li> 515. Find Largest Value in Each Tree Row (Medium)</li> <li> 116. Populating Next Right Pointers in Each Node (Medium)</li> <li> 117. Populating Next Right Pointers in Each Node II (Medium)</li> <li> 513. Find Bottom Left Tree Value (Medium)</li> <li> 863. All Nodes Distance K in Binary Tree (Medium)</li> </ul>"},{"location":"leetpattern/tree_bfs/#199-binary-tree-right-side-view","title":"199. Binary Tree Right Side View","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree <pre><code>    ____1       &lt;---\n   /     \\\n  2__     2     &lt;--- Look at the rightmost node at each level\n /   \\     \\\n3     4     3   &lt;---\n     /\n    5           &lt;---\n</code></pre></p> </li> </ul> 199. Binary Tree Right Side View - Python Solution<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Binary Tree\ndef rightSideView(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        n = len(q)\n\n        for i in range(n):\n            cur = q.popleft()\n\n            # rightmost element\n            if i == n - 1:\n                res.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n    return res\n\n\nroot = [1, 2, 2, 3, 4, None, 3, None, None, 5]\nroot = build(root)\nprint(root)\n#     ____1\n#    /     \\\n#   2__     2\n#  /   \\     \\\n# 3     4     3\n#      /\n#     5\nprint(rightSideView(root))  # [1, 2, 3, 5]\n</code></pre>"},{"location":"leetpattern/tree_bfs/#111-minimum-depth-of-binary-tree","title":"111. Minimum Depth of Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree</p> </li> </ul> 111. Minimum Depth of Binary Tree - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Iterative\ndef minDepthIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n    res = 0\n\n    while q:\n        res += 1\n\n        for _ in range(len(q)):\n            node = q.popleft()\n\n            if not node.left and not node.right:\n                return res\n\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n\n# Recursive\ndef minDepthRecursive(root: Optional[TreeNode]) -&gt; int:\n    if root is None:\n        return 0\n\n    if root.left is None and root.right is not None:\n        return 1 + minDepthRecursive(root.right)\n    if root.left is not None and root.right is None:\n        return 1 + minDepthRecursive(root.left)\n\n    return 1 + min(minDepthRecursive(root.left), minDepthRecursive(root.right))\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n\"\"\"\n    ____1\n   /     \\\n  2__     2\n /   \\\n3     4\n     /\n    5\n\n\"\"\"\nprint(minDepthIterative(root))  # 2\nprint(minDepthRecursive(root))  # 2\n</code></pre>"},{"location":"leetpattern/tree_bfs/#104-maximum-depth-of-binary-tree","title":"104. Maximum Depth of Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree</p> </li> </ul> 104. Maximum Depth of Binary Tree - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef maxDepthRecursive(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    left = maxDepthRecursive(root.left)\n    right = maxDepthRecursive(root.right)\n\n    return 1 + max(left, right)\n\n\n# DFS\ndef maxDepthDFS(root: Optional[TreeNode]) -&gt; int:\n    res = 0\n\n    def dfs(node, cnt):\n        if node is None:\n            return\n        cnt += 1\n        nonlocal res\n        res = max(res, cnt)\n\n        dfs(node.left, cnt)\n        dfs(node.right, cnt)\n\n    dfs(root, 0)\n\n    return res\n\n\n# Iterative\ndef maxDepthIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n    res = 0\n\n    while q:\n        res += 1\n        n = len(q)\n\n        for _ in range(n):\n            node = q.popleft()\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return res\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n#     ____1\n#    /     \\\n#   2__     2\n#  /   \\\n# 3     4\n#      /\n#     5\nprint(maxDepthRecursive(root))  # 4\nprint(maxDepthIterative(root))  # 4\nprint(maxDepthDFS(root))  # 4\n</code></pre>"},{"location":"leetpattern/tree_bfs/#637-average-of-levels-in-binary-tree","title":"637. Average of Levels in Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree</p> </li> </ul> 637. Average of Levels in Binary Tree - Python Solution<pre><code>from collections import deque\nfrom statistics import mean\nfrom typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef averageOfLevels(root: Optional[TreeNode]) -&gt; List[float]:\n    if not root:\n        return []\n\n    queue = deque([root])\n    result = []\n\n    while queue:\n        level = []\n        size = len(queue)\n\n        for _ in range(size):\n            node = queue.popleft()\n            level.append(node.val)\n\n            if node.left:\n                queue.append(node.left)\n\n            if node.right:\n                queue.append(node.right)\n\n        result.append(mean(level))\n\n    return result\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n\"\"\"\n    ____1\n   /     \\\n  2__     2\n /   \\\n3     4\n     /\n    5\n\"\"\"\nprint(averageOfLevels(root))  # [1, 2, 3.5, 5]\n</code></pre>"},{"location":"leetpattern/tree_bfs/#429-n-ary-tree-level-order-traversal","title":"429. N-ary Tree Level Order Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, breadth first search</p> </li> </ul> 429. N-ary Tree Level Order Traversal - Python Solution<pre><code>from collections import deque\nfrom typing import List, Optional\n\n\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\n\ndef levelOrder(root: Optional[Node]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    queue = deque([root])\n    result = []\n\n    while queue:\n        level = []\n        size = len(queue)\n\n        for _ in range(size):\n            node = queue.popleft()\n            level.append(node.val)\n\n            for child in node.children:\n                queue.append(child)\n\n        result.append(level)\n\n    return result\n\n\nroot = Node(\n    1,\n    [\n        Node(\n            3,\n            [\n                Node(5, []),\n                Node(6, []),\n            ],\n        ),\n        Node(2, []),\n        Node(4, []),\n    ],\n)\nprint(levelOrder(root))  # [[1], [3, 2, 4], [5, 6]]\n</code></pre>"},{"location":"leetpattern/tree_bfs/#515-find-largest-value-in-each-tree-row","title":"515. Find Largest Value in Each Tree Row","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree</p> </li> </ul> 515. Find Largest Value in Each Tree Row - Python Solution<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef largestValues(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    queue = deque([root])\n    result = []\n\n    while queue:\n        levelMax = float(\"-inf\")\n        for _ in range(len(queue)):\n            node = queue.popleft()\n\n            levelMax = max(levelMax, node.val)\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n        result.append(levelMax)\n\n    return result\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n#     ____1\n#    /     \\\n#   2__     2\n#  /   \\\n# 3     4\n#      /\n#     5\nprint(largestValues(root))  # [1, 2, 4, 5]\n</code></pre>"},{"location":"leetpattern/tree_bfs/#116-populating-next-right-pointers-in-each-node","title":"116. Populating Next Right Pointers in Each Node","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, tree, depth first search, breadth first search, binary tree</p> </li> <li>Perfect Binary Tree</li> </ul> 116. Populating Next Right Pointers in Each Node - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\n\nclass Node:\n    def __init__(\n        self,\n        val: int = 0,\n        left: \"Node\" = None,\n        right: \"Node\" = None,\n        next: \"Node\" = None,\n    ):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\n\ndef connect(root: \"Optional[Node]\") -&gt; \"Optional[Node]\":\n    if not root:\n        return root\n\n    queue = deque([root])\n\n    while queue:\n        size = len(queue)\n        prev = None\n\n        for _ in range(size):\n            node = queue.popleft()\n\n            if prev:\n                prev.next = node\n            prev = node\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n    return root\n\n\n# Perfect binary tree creation\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.right.left = Node(6)\nroot.right.right = Node(7)\n#     __1__\n#    /     \\\n#   2__     3\n#  /   \\   / \\\n# 4     5 6   7\n\n\n# Connect the nodes\nconnect(root)\n#      __1__ -&gt; None\n#     /     \\\n#   _2_ -&gt;  3 -&gt; None\n#  /   \\   / \\\n# 4 -&gt; 5-&gt;6-&gt; 7 -&gt; None\n\n\nassert root.next is None\nassert root.left.next == root.right\nassert root.left.left.next == root.left.right\nassert root.left.right.next == root.right.left\nassert root.right.left.next == root.right.right\nassert root.right.right.next is None\nprint(\"All tests passed.\")\n</code></pre>"},{"location":"leetpattern/tree_bfs/#117-populating-next-right-pointers-in-each-node-ii","title":"117. Populating Next Right Pointers in Each Node II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, tree, depth first search, breadth first search, binary tree</p> </li> </ul> 117. Populating Next Right Pointers in Each Node II - Python Solution<pre><code>from collections import deque\n\n\nclass Node:\n    def __init__(\n        self,\n        val: int = 0,\n        left: \"Node\" = None,\n        right: \"Node\" = None,\n        next: \"Node\" = None,\n    ):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\n\ndef connect(root: \"Node\") -&gt; \"Node\":\n    if not root:\n        return root\n\n    queue = deque([root])\n\n    while queue:\n        size = len(queue)\n        prev = None\n\n        for _ in range(size):\n            node = queue.popleft()\n\n            if prev:\n                prev.next = node\n\n            prev = node\n\n            if node.left:\n                queue.append(node.left)\n\n            if node.right:\n                queue.append(node.right)\n\n    return root\n\n\n# Binary tree creation\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.right.right = Node(7)\n#       1\n#      / \\\n#     2   3\n#    / \\   \\\n#   4   5   7\n\n# Connect the nodes\nconnect(root)\n#       1 -&gt; None\n#      / \\\n#     2 -&gt; 3 -&gt; None\n#    / \\    \\\n#   4 -&gt; 5 -&gt; 7 -&gt; None\n\nassert root.next is None\nassert root.left.next == root.right\nassert root.right.next is None\nassert root.left.left.next == root.left.right\nassert root.left.right.next == root.right.right\nassert root.right.right.next is None\n\nprint(\"All tests passed.\")\n</code></pre>"},{"location":"leetpattern/tree_bfs/#513-find-bottom-left-tree-value","title":"513. Find Bottom Left Tree Value","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree</p> </li> </ul> 513. Find Bottom Left Tree Value - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef findBottomLeftValue(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    queue = deque([root])\n    result = 0\n\n    while queue:\n        size = len(queue)\n\n        for i in range(size):\n            node = queue.popleft()\n            if i == 0:\n                result = node.val\n\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n    return result\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n#     ____1\n#    /     \\\n#   2__     2\n#  /   \\\n# 3     4\n#      /\n#     5\n\nprint(findBottomLeftValue(root))  # 5\n</code></pre>"},{"location":"leetpattern/tree_bfs/#863-all-nodes-distance-k-in-binary-tree","title":"863. All Nodes Distance K in Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, tree, depth first search, breadth first search, binary tree</p> </li> </ul> 863. All Nodes Distance K in Binary Tree - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BFS\ndef distanceK(root: TreeNode, target: TreeNode, k: int) -&gt; List[int]:\n    parent = dict()\n\n    def dfs(node, par=None):\n        if node:\n            parent[node] = par\n            dfs(node.left, node)\n            dfs(node.right, node)\n\n    dfs(root)\n\n    q = deque([(target, 0)])\n    seen = set([target])\n\n    while q:\n        node, dist = q.popleft()\n\n        if dist == k:\n            return [node.val] + [node.val for node, _ in q]\n\n        for nei in (node.left, node.right, parent[node]):\n            if nei and nei not in seen:\n                seen.add(nei)\n                q.append((nei, dist + 1))\n\n    return []\n\n\nroot = build([3, 5, 1, 6, 2, 0, 8, None, None, 7, 4])\nprint(root)\n#     ______3__\n#    /         \\\n#   5__         1\n#  /   \\       / \\\n# 6     2     0   8\n#      / \\\n#     7   4\ntarget = root.left\nk = 2\nprint(distanceK(root, target, k))  # [7, 4, 1]\n</code></pre>"},{"location":"leetpattern/tree_feature/","title":"Tree Feature","text":"<ul> <li> 101. Symmetric Tree (Easy)</li> <li> 222. Count Complete Tree Nodes (Easy)</li> <li> 110. Balanced Binary Tree (Easy)</li> <li> 257. Binary Tree Paths (Easy)</li> <li> 404. Sum of Left Leaves (Easy)</li> <li> 112. Path Sum (Easy)</li> <li> 2331. Evaluate Boolean Binary Tree (Easy)</li> <li> 100. Same Tree (Easy)</li> <li> 235. Lowest Common Ancestor of a Binary Search Tree (Medium)</li> <li> 236. Lowest Common Ancestor of a Binary Tree (Medium)</li> </ul>"},{"location":"leetpattern/tree_feature/#101-symmetric-tree","title":"101. Symmetric Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree</p> </li> </ul> 101. Symmetric Tree - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef isSymmetricRecursive(root: Optional[TreeNode]) -&gt; bool:\n    \"\"\"Determine if a tree is symmetric.\"\"\"\n    if not root:\n        return True\n\n    def compare(left, right):\n        if left is None and right is not None:\n            return False\n        elif left is not None and right is None:\n            return False\n        elif left is None and right is None:\n            return True\n        elif left.val != right.val:\n            return False\n\n        outside = compare(left.left, right.right)\n        inside = compare(left.right, right.left)\n\n        return outside and inside\n\n    return compare(root.left, root.right)\n\n\n# Iterative\ndef isSymmetricIterative(root: Optional[TreeNode]) -&gt; bool:\n    \"\"\"Determine if a tree is symmetric.\"\"\"\n    if not root:\n        return True\n\n    q = deque()\n    q.append(root.left)\n    q.append(root.right)\n\n    while q:\n        leftNode = q.popleft()\n        rightNode = q.popleft()\n\n        if not leftNode and not rightNode:\n            continue\n\n        if not leftNode or not rightNode or leftNode.val != rightNode.val:\n            return False\n\n        q.append(leftNode.left)\n        q.append(rightNode.right)\n        q.append(leftNode.right)\n        q.append(rightNode.left)\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Recursive  |  O(n)  |   O(n)  |\n# | Iterative  |  O(n)  |   O(n)  |\n# |------------|--------|---------|\n\n\nroot = [1, 2, 2, 3, 4, 4, 3]\nroot = build(root)\nprint(root)\n#     __1__\n#    /     \\\n#   2       2\n#  / \\     / \\\n# 3   4   4   3\nprint(isSymmetricRecursive(root))  # True\nprint(isSymmetricIterative(root))  # True\n</code></pre>"},{"location":"leetpattern/tree_feature/#222-count-complete-tree-nodes","title":"222. Count Complete Tree Nodes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: binary search, bit manipulation, tree, binary tree</p> </li> </ul> 222. Count Complete Tree Nodes - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef countNodesRecursive(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    num = 1 + countNodesRecursive(root.left) + countNodesRecursive(root.right)\n\n    return num\n\n\n# Iterative\ndef countNodesIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n    count = 0\n\n    while q:\n        n = len(q)\n\n        for _ in range(n):\n            node = q.popleft()\n            count += 1\n\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return count\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Recursive  |  O(n)  |  O(n)   |\n# | Iterative  |  O(n)  |  O(n)   |\n# |------------|--------|---------|\n\nroot = [1, 2, 3, 4, 5, 6]\nroot = build(root)\nprint(root)\n#     __1__\n#    /     \\\n#   2       3\n#  / \\     /\n# 4   5   6\nprint(countNodesRecursive(root))  # 6\nprint(countNodesIterative(root))  # 6\n</code></pre>"},{"location":"leetpattern/tree_feature/#110-balanced-binary-tree","title":"110. Balanced Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul> 110. Balanced Binary Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef isBalanced(root: Optional[TreeNode]) -&gt; bool:\n    def getHeight(node):\n        if not node:\n            return 0\n\n        # post order\n        leftHeight = getHeight(node.left)\n        rightHeight = getHeight(node.right)\n\n        if leftHeight == -1 or rightHeight == -1:\n            return -1\n\n        if abs(leftHeight - rightHeight) &gt; 1:\n            return -1\n        else:\n            return 1 + max(leftHeight, rightHeight)\n\n    if getHeight(root) != -1:\n        return True\n    else:\n        return False\n\n\nroot = [3, 9, 20, None, None, 15, 7]\nroot = build(root)\nprint(root)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(isBalanced(root))  # True\n</code></pre>"},{"location":"leetpattern/tree_feature/#257-binary-tree-paths","title":"257. Binary Tree Paths","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, backtracking, tree, depth first search, binary tree</p> </li> </ul> 257. Binary Tree Paths - Python Solution<pre><code>from typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef binaryTreePaths(root: Optional[TreeNode]) -&gt; List[str]:\n    res = []\n\n    def dfs(node, path):\n        if not node:\n            return\n        path += str(node.val)\n\n        if not node.left and not node.right:\n            res.append(path)\n            return\n\n        path += \"-&gt;\"\n\n        dfs(node.left, path)\n        dfs(node.right, path)\n\n    dfs(root, \"\")\n\n    return res\n\n\nroot = build([1, 2, 3, None, 5])\nprint(root)\n#   __1\n#  /   \\\n# 2     3\n#  \\\n#   5\nprint(binaryTreePaths(root))  # ['1-&gt;2-&gt;5', '1-&gt;3']\n</code></pre>"},{"location":"leetpattern/tree_feature/#404-sum-of-left-leaves","title":"404. Sum of Left Leaves","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree</p> </li> </ul> 404. Sum of Left Leaves - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Iterative\ndef sumOfLeftLeaves(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    stack = [root]\n    sumLL = 0\n\n    while stack:\n        node = stack.pop()\n\n        if node.left and not node.left.left and not node.left.right:\n            sumLL += node.left.val\n\n        if node.right:\n            stack.append(node.right)\n        if node.left:\n            stack.append(node.left)\n\n    return sumLL\n\n\n# Left Leave None:\n#   - node.left is not None\n#   - node.left.left is None\n#   - node.left.right is None\n\nroot = build([3, 9, 20, None, None, 15, 7])\nprint(root)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(sumOfLeftLeaves(root))  # 24\n</code></pre>"},{"location":"leetpattern/tree_feature/#112-path-sum","title":"112. Path Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree</p> </li> </ul> 112. Path Sum - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef hasPathSum(root: Optional[TreeNode], targetSum: int) -&gt; bool:\n    if not root:\n        return False\n\n    if not root.left and not root.right:\n        return root.val == targetSum\n\n    targetSum -= root.val\n\n    return hasPathSum(root.left, targetSum) or hasPathSum(\n        root.right, targetSum\n    )\n\n\nroot = build([5, 4, 8, 11, None, 13, 4, 7, 2, None, None, None, None, None, 1])\nprint(root)\n#          5___\n#         /    \\\n#     ___4     _8\n#    /        /  \\\n#   11       13   4\n#  /  \\            \\\n# 7    2            1\nprint(hasPathSum(root, 22))  # True\n</code></pre>"},{"location":"leetpattern/tree_feature/#2331-evaluate-boolean-binary-tree","title":"2331. Evaluate Boolean Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul> 2331. Evaluate Boolean Binary Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef evaluateTree(root: Optional[TreeNode]) -&gt; bool:\n    if not root.left and not root.right:\n        return root.val\n\n    left = evaluateTree(root.left)\n    right = evaluateTree(root.right)\n\n    if root.val == 2:\n        return left or right\n    elif root.val == 3:\n        return left and right\n\n\nroot = build([2, 1, 3, None, None, 0, 1])\nprint(root)\n#   2__\n#  /   \\\n# 1     3\n#      / \\\n#     0   1\nboolTree = build([\"OR\", \"True\", \"AND\", None, None, \"False\", \"True\"])\nprint(boolTree)\n#    __OR_______\n#   /           \\\n# True        __AND_\n#            /      \\\n#         False     True\nprint(evaluateTree(root))  # 1\n</code></pre>"},{"location":"leetpattern/tree_feature/#100-same-tree","title":"100. Same Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree</p> </li> </ul> 100. Same Tree - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# 1. Recursive\ndef isSameTreeRecursive(p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:\n    if not p and not q:\n        return True\n    if not p or not q:\n        return False\n    if p.val != q.val:\n        return False\n\n    return isSameTreeRecursive(p.left, q.left) and isSameTreeRecursive(\n        p.right, q.right\n    )\n\n\n# 2. Iterative with queue\ndef isSameTreeIterativeQueue(\n    p: Optional[TreeNode], q: Optional[TreeNode]\n) -&gt; bool:\n    queue = deque([(p, q)])\n\n    while queue:\n        p, q = queue.popleft()\n\n        if not p and not q:\n            continue\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n\n        queue.append((p.left, q.left))\n        queue.append((p.right, q.right))\n\n    return True\n\n\n# 3. Iterative with stack\ndef isSameTreeIterativeStack(\n    p: Optional[TreeNode], q: Optional[TreeNode]\n) -&gt; bool:\n    stack = [(p, q)]\n\n    while stack:\n        n1, n2 = stack.pop()\n\n        if not n1 and not n2:\n            continue\n        if not n1 or not n2:\n            return False\n        if n1.val != n2.val:\n            return False\n\n        stack.append((n1.left, n2.left))\n        stack.append((n1.right, n2.right))\n\n    return True\n\n\np1 = build([1, 2, 3])\nq1 = build([1, 2, 3])\np2 = build([1, 2])\nq2 = build([1, None, 2])\n\nprint(isSameTreeRecursive(p1, q1))  # True\nprint(isSameTreeRecursive(p2, q2))  # False\nprint(isSameTreeIterativeQueue(p1, q1))  # True\nprint(isSameTreeIterativeQueue(p2, q2))  # False\nprint(isSameTreeIterativeStack(p1, q1))  # True\nprint(isSameTreeIterativeStack(p2, q2))  # False\n</code></pre>"},{"location":"leetpattern/tree_feature/#235-lowest-common-ancestor-of-a-binary-search-tree","title":"235. Lowest Common Ancestor of a Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree</p> </li> </ul> 235. Lowest Common Ancestor of a Binary Search Tree - Python Solution<pre><code>from binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef lowestCommonAncestor(\n    root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n) -&gt; \"TreeNode\":\n    while root:\n        if root.val &gt; p.val and root.val &gt; q.val:\n            root = root.left\n        elif root.val &lt; p.val and root.val &lt; q.val:\n            root = root.right\n        else:\n            return root\n\n\nroot = [6, 2, 8, 0, 4, 7, 9, None, None, 3, 5]\nroot = build(root)\np = root.left\nq = root.right\nprint(root)\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\nprint(lowestCommonAncestor(root, p, q))\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\n</code></pre>"},{"location":"leetpattern/tree_feature/#236-lowest-common-ancestor-of-a-binary-tree","title":"236. Lowest Common Ancestor of a Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul> 236. Lowest Common Ancestor of a Binary Tree - Python Solution<pre><code>from typing import List, Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef lowestCommonAncestor(\n    root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n) -&gt; \"TreeNode\":\n    if not root or q == root or p == root:\n        return root\n\n    left = lowestCommonAncestor(root.left, p, q)\n    right = lowestCommonAncestor(root.right, p, q)\n\n    if left and right:\n        return root\n\n    return left or right\n\n\nroot = build([3, 5, 1, 6, 2, 0, 8, None, None, 7, 4])\nprint(root)\n#     ______3__\n#    /         \\\n#   5__         1\n#  /   \\       / \\\n# 6     2     0   8\n#      / \\\n#     7   4\np = root.left  # 5\nq = root.right  # 1\nprint(lowestCommonAncestor(root, p, q))  # 3\n#     ______3__\n#    /         \\\n#   5__         1\n#  /   \\       / \\\n# 6     2     0   8\n#      / \\\n#     7   4\nr = root.left.right.right  # 4\nprint(lowestCommonAncestor(root, p, r))  # 5\n#   5__\n#  /   \\\n# 6     2\n#      / \\\n#     7   4\n</code></pre>"},{"location":"leetpattern/tree_modification/","title":"Tree Modification","text":"<ul> <li> 226. Invert Binary Tree (Easy)</li> <li> 105. Construct Binary Tree from Preorder and Inorder Traversal (Medium)</li> <li> 106. Construct Binary Tree from Inorder and Postorder Traversal (Medium)</li> <li> 654. Maximum Binary Tree (Medium)</li> <li> 617. Merge Two Binary Trees (Easy)</li> </ul>"},{"location":"leetpattern/tree_modification/#226-invert-binary-tree","title":"226. Invert Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree</p> </li> </ul> 226. Invert Binary Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef invertTreeRecursive(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    root.left, root.right = root.right, root.left\n\n    invertTreeRecursive(root.left)\n    invertTreeRecursive(root.right)\n\n    return root\n\n\n# Iterative\ndef invertTreeIterative(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    stack = [root]\n\n    while stack:\n        node = stack.pop()\n\n        node.left, node.right = node.right, node.left\n        if node.left:\n            stack.append(node.left)\n        if node.right:\n            stack.append(node.right)\n\n    return root\n\n\nroot = build([4, 2, 7, 1, 3, 6, 9])\nprint(root)\n#     __4__\n#    /     \\\n#   2       7\n#  / \\     / \\\n# 1   3   6   9\ninvertedRecursive = invertTreeRecursive(root)\nprint(invertedRecursive)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\nroot = build([4, 2, 7, 1, 3, 6, 9])\ninvertedIterative = invertTreeIterative(root)\nprint(invertedIterative)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\n</code></pre>"},{"location":"leetpattern/tree_modification/#105-construct-binary-tree-from-preorder-and-inorder-traversal","title":"105. Construct Binary Tree from Preorder and Inorder Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, divide and conquer, tree, binary tree</p> </li> </ul> 105. Construct Binary Tree from Preorder and Inorder Traversal - Python Solution<pre><code>from typing import List, Optional\n\nfrom helper import TreeNode\n\n\ndef buildTree(preorder: List[int], inorder: List[int]) -&gt; Optional[TreeNode]:\n    \"\"\"\n    preorder  root left right  1  2  3\n    inorder   left root right  4  5  6\n    \"\"\"\n    if len(preorder) == 0:\n        return None\n\n    root_val = preorder[0]  # 1\n    root = TreeNode(root_val)\n\n    separator_idx = inorder.index(root_val)  # 5\n\n    left_inorder = inorder[:separator_idx]  # 4\n    right_inorder = inorder[separator_idx + 1 :]  # 6\n\n    left_preorder = preorder[1 : 1 + len(left_inorder)]  # 2\n    right_preorder = preorder[1 + len(left_inorder) :]  # 3\n\n    root.left = buildTree(left_preorder, left_inorder)\n    root.right = buildTree(right_preorder, right_inorder)\n\n    return root\n\n\npreorder = [3, 9, 20, 15, 7]\ninorder = [9, 3, 15, 20, 7]\nroot = buildTree(preorder, inorder)\nprint(root)\n#     3\n#    / \\\n#   9  20\n#     /  \\\n#    15   7\n</code></pre>"},{"location":"leetpattern/tree_modification/#106-construct-binary-tree-from-inorder-and-postorder-traversal","title":"106. Construct Binary Tree from Inorder and Postorder Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, divide and conquer, tree, binary tree</p> </li> </ul> 106. Construct Binary Tree from Inorder and Postorder Traversal - Python Solution<pre><code>from typing import List, Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef buildTree(inorder: List[int], postorder: List[int]) -&gt; Optional[TreeNode]:\n    \"\"\"\n    inorder:    left root  right   1  2  3\n    postorder:  left right root    4  5  6\n    \"\"\"\n\n    if not postorder:\n        return None\n\n    root_val = postorder[-1]  # 6\n    root = TreeNode(root_val)\n\n    separator_idx = inorder.index(root_val)  # 2\n\n    left_inorder = inorder[:separator_idx]  # 1\n    right_inorder = inorder[separator_idx + 1 :]  # 3\n\n    left_postorder = postorder[: len(left_inorder)]  # 4\n    right_postorder = postorder[len(left_inorder) : -1]  # 5\n\n    root.left = buildTree(left_inorder, left_postorder)\n    root.right = buildTree(right_inorder, right_postorder)\n\n    return root\n\n\ninorder = [9, 3, 15, 20, 7]\npostorder = [9, 15, 7, 20, 3]\nroot = buildTree(inorder, postorder)\nprint(root)\n#     3\n#    / \\\n#   9  20\n#     /  \\\n#    15   7\n</code></pre>"},{"location":"leetpattern/tree_modification/#654-maximum-binary-tree","title":"654. Maximum Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, divide and conquer, stack, tree, monotonic stack, binary tree</p> </li> </ul> 654. Maximum Binary Tree - Python Solution<pre><code>from typing import List, Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef constructMaximumBinaryTree(nums: List[int]) -&gt; Optional[TreeNode]:\n    if len(nums) == 0:\n        return None\n\n    maximum = max(nums)\n    rootIndex = nums.index(maximum)\n\n    root = TreeNode(maximum)\n\n    left_nums = nums[:rootIndex]\n    right_nums = nums[rootIndex + 1 :]\n\n    root.left = constructMaximumBinaryTree(left_nums)\n    root.right = constructMaximumBinaryTree(right_nums)\n\n    return root\n\n\nnums = [3, 2, 1, 6, 0, 5]\nroot = constructMaximumBinaryTree(nums)\n#     __6__\n#    /     \\\n#   3       5\n#    \\     /\n#     2   0\n#      \\\n#       1\n</code></pre>"},{"location":"leetpattern/tree_modification/#617-merge-two-binary-trees","title":"617. Merge Two Binary Trees","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree</p> </li> </ul> 617. Merge Two Binary Trees - Python Solution<pre><code>from typing import List, Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef mergeTrees(\n    root1: Optional[TreeNode], root2: Optional[TreeNode]\n) -&gt; Optional[TreeNode]:\n\n    if not root1:\n        return root2\n    if not root2:\n        return root1\n\n    root = TreeNode()\n\n    root.val += root1.val + root2.val\n    root.left = mergeTrees(root1.left, root2.left)\n    root.right = mergeTrees(root1.right, root2.right)\n\n    return root\n\n\nroot1 = TreeNode(1)\nroot1.left = TreeNode(3)\nroot1.right = TreeNode(2)\nroot1.left.left = TreeNode(5)\n#     1\n#    / \\\n#   3   2\n#  /\n# 5\n\nroot2 = TreeNode(2)\nroot2.left = TreeNode(1)\nroot2.right = TreeNode(3)\nroot2.left.right = TreeNode(4)\nroot2.right.right = TreeNode(7)\n#     2\n#    / \\\n#   1   3\n#    \\   \\\n#     4   7\n\nroot = mergeTrees(root1, root2)\n#     3\n#    / \\\n#   4   5\n#  / \\   \\\n# 5   4   7\n</code></pre>"},{"location":"leetpattern/tree_traversal/","title":"Tree Traversal","text":"<ul> <li> 144. Binary Tree Preorder Traversal (Easy)</li> <li> 94. Binary Tree Inorder Traversal (Easy)</li> <li> 145. Binary Tree Postorder Traversal (Easy)</li> <li> 102. Binary Tree Level Order Traversal (Medium)</li> <li> 107. Binary Tree Level Order Traversal II (Medium)</li> <li> 103. Binary Tree Zigzag Level Order Traversal (Medium)</li> </ul>"},{"location":"leetpattern/tree_traversal/#144-binary-tree-preorder-traversal","title":"144. Binary Tree Preorder Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: stack, tree, depth first search, binary tree </p> </li> </ul>"},{"location":"leetpattern/tree_traversal/#example-1","title":"Example 1","text":"<pre><code>graph TD\nA(( ))\nB(( ))\nC(( ))\nD(( ))\nE(( ))\nF(( ))\nG(( ))\nA --- B\nA --- E\nB --- C\nB --- D\nE --- F\nE --- G</code></pre> <p>Pre-order Traversal</p> <pre><code>graph TD\n0((0))\n1((1))\n2((2))\n3((3))\n4((4))\n5((5))\n6((6))\n0 --- 1\n0 --- 4\n1 --- 2\n1 --- 3\n4 --- 5\n4 --- 6</code></pre> <p>In-order Traversal</p> <pre><code>graph TD\n0((0))\n1((1))\n2((2))\n3((3))\n4((4))\n5((5))\n6((6))\n3 --- 1\n3 --- 5\n1 --- 0\n1 --- 2\n5 --- 4\n5 --- 6</code></pre> <p>Post-order Traversal</p> <pre><code>graph TD\n0((0))\n1((1))\n2((2))\n3((3))\n4((4))\n5((5))\n6((6))\n6 --- 2\n6 --- 5\n2 --- 0\n2 --- 1\n5 --- 3\n5 --- 4</code></pre> <p>Level Order Traversal</p> <pre><code>graph TD\n0((0))\n1((1))\n2((1))\n3((2))\n4((2))\n5((2))\n6((2))\n0 --- 1\n0 --- 2\n1 --- 3\n1 --- 4\n2 --- 5\n2 --- 6</code></pre>"},{"location":"leetpattern/tree_traversal/#example-2","title":"Example 2","text":"<pre><code>graph TD\n0((0))\n1((1))\n2((2))\n3((3))\n4((4))\n5((5))\n6((6))\n0 --- 1\n0 --- 2\n1 --- 3\n1 --- 4\n2 --- 5\n2 --- 6</code></pre> Traversal Order Method Result Preorder Root, Left, Right DFS or Stack <code>[0, 1, 3, 4, 2, 5, 6]</code> Inorder Left, Root, Right DFS or Stack <code>[3, 1, 4, 0, 5, 2, 6]</code> Postorder Left, Right, Root DFS or Stack <code>[3, 4, 1, 5, 6, 2, 0]</code> Level Order Level by Level BFS with Queue <code>[[0], [1, 2], [3, 4, 5, 6]]</code> 144. Binary Tree Preorder Traversal - Python Solution<pre><code>from typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef preorderTraversalRecursive(root: Optional[TreeNode]) -&gt; List[int]:\n    res = []\n\n    def dfs(node):\n        if not node:\n            return None\n\n        res.append(node.val)  # &lt;--\n        dfs(node.left)\n        dfs(node.right)\n\n    dfs(root)\n\n    return res\n\n\n# Iterative\ndef preorderTraversalIterative(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    stack = [root]\n    res = []\n\n    while stack:\n        node = stack.pop()\n        res.append(node.val)\n\n        if node.right:\n            stack.append(node.right)\n        if node.left:\n            stack.append(node.left)\n\n    return res\n\n\ntree = build([0, 1, 2, 3, 4, 5, 6])\nprint(tree)\n#     __0__\n#    /     \\\n#   1       2\n#  / \\     / \\\n# 3   4   5   6\nprint(preorderTraversalRecursive(tree))  # [0, 1, 3, 4, 2, 5, 6]\nprint(preorderTraversalIterative(tree))  # [0, 1, 3, 4, 2, 5, 6]\n</code></pre>"},{"location":"leetpattern/tree_traversal/#94-binary-tree-inorder-traversal","title":"94. Binary Tree Inorder Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: stack, tree, depth first search, binary tree</p> </li> </ul> 94. Binary Tree Inorder Traversal - Python Solution<pre><code>from typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef inorderTraversalRecursive(root: TreeNode) -&gt; List[int]:\n    res = []\n\n    def dfs(node):\n        if not node:\n            return\n\n        dfs(node.left)\n        res.append(node.val)  # &lt;--\n        dfs(node.right)\n\n    dfs(root)\n\n    return res\n\n\n# Iterative\ndef inorderTraversalIterative(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    stack = []\n    res = []\n    cur = root\n\n    while cur or stack:\n        if cur:\n            stack.append(cur)\n            cur = cur.left\n        else:\n            cur = stack.pop()\n            res.append(cur.val)\n            cur = cur.right\n\n    return res\n\n\ntree = build([0, 1, 2, 3, 4, 5, 6])\nprint(tree)\n#     __0__\n#    /     \\\n#   1       2\n#  / \\     / \\\n# 3   4   5   6\nprint(inorderTraversalRecursive(tree))  # [3, 1, 4, 0, 5, 2, 6]\nprint(inorderTraversalIterative(tree))  # [3, 1, 4, 0, 5, 2, 6]\n</code></pre>"},{"location":"leetpattern/tree_traversal/#145-binary-tree-postorder-traversal","title":"145. Binary Tree Postorder Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: stack, tree, depth first search, binary tree</p> </li> </ul> 145. Binary Tree Postorder Traversal - Python Solution<pre><code>from typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef postorderTraversalRecursive(root: Optional[TreeNode]) -&gt; List[int]:\n    res = []\n\n    def dfs(node):\n        if not node:\n            return\n\n        dfs(node.left)\n        dfs(node.right)\n        res.append(node.val)  # &lt;--\n\n    dfs(root)\n\n    return res\n\n\n# Iterative\ndef postorderTraversalIterative(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    res = []\n    stack = [root]\n\n    while stack:\n        node = stack.pop()\n        res.append(node.val)\n\n        if node.left:\n            stack.append(node.left)\n        if node.right:\n            stack.append(node.right)\n\n    return res[::-1]\n\n\ntree = build([0, 1, 2, 3, 4, 5, 6])\nprint(tree)\n#     __0__\n#    /     \\\n#   1       2\n#  / \\     / \\\n# 3   4   5   6\nprint(postorderTraversalRecursive(tree))  # [3, 4, 1, 5, 6, 2, 0]\nprint(postorderTraversalIterative(tree))  # [3, 4, 1, 5, 6, 2, 0]\n</code></pre>"},{"location":"leetpattern/tree_traversal/#102-binary-tree-level-order-traversal","title":"102. Binary Tree Level Order Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, breadth first search, binary tree</p> </li> </ul> 102. Binary Tree Level Order Traversal - Python Solution<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef levelOrder(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        level = []\n        n = len(q)\n\n        for _ in range(n):\n            cur = q.popleft()\n            level.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(level)\n\n    return res\n\n\ntree = build([3, 9, 20, None, None, 15, 7])\nprint(tree)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(levelOrder(tree))  # [[3], [9, 20], [15, 7]]\n</code></pre>"},{"location":"leetpattern/tree_traversal/#107-binary-tree-level-order-traversal-ii","title":"107. Binary Tree Level Order Traversal II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, breadth first search, binary tree</p> </li> </ul> 107. Binary Tree Level Order Traversal II - Python Solution<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef levelOrderBottom(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    res = []\n    q = deque([root])\n\n    while q:\n        level = []\n        n = len(q)\n\n        for _ in range(n):\n            cur = q.popleft()\n            level.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(level)\n\n    return res[::-1]\n\n\ntree = build([3, 9, 20, None, None, 15, 7])\nprint(tree)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(levelOrderBottom(tree))  # [[15, 7], [9, 20], [3]]\n</code></pre>"},{"location":"leetpattern/tree_traversal/#103-binary-tree-zigzag-level-order-traversal","title":"103. Binary Tree Zigzag Level Order Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, breadth first search, binary tree</p> </li> </ul> 103. Binary Tree Zigzag Level Order Traversal - Python Solution<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef zigzagLevelOrder(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        level = []\n        n = len(q)\n\n        for _ in range(n):\n            cur = q.popleft()\n            level.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(level if len(res) % 2 == 0 else level[::-1])\n\n    return res\n\n\ntree = build([3, 9, 20, None, None, 15, 7])\nprint(tree)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(zigzagLevelOrder(tree))  # [[3], [20, 9], [15, 7]]\n</code></pre>"},{"location":"leetpattern/trie/","title":"Trie","text":"<ul> <li> 208. Implement Trie (Prefix Tree) (Medium)</li> <li> 211. Design Add and Search Words Data Structure (Medium)</li> <li> 212. Word Search II (Hard)</li> </ul>"},{"location":"leetpattern/trie/#208-implement-trie-prefix-tree","title":"208. Implement Trie (Prefix Tree)","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, design, trie</p> </li> </ul>"},{"location":"leetpattern/trie/#trie_1","title":"Trie","text":"<ul> <li>A trie is a tree-like data structure whose nodes store the letters of an alphabet.</li> </ul> <pre><code>flowchart TD\nRoot(( ))\nRoot --- C1((\"C\"))\nRoot --- D((D))\nC1 --- A1((\"A\"))\nA1 --- T1((\"T\"))\nA1 --- R1((\"R\"))\nA1 --- N((N))\nRoot --- B1((B))\nB1 --- A2((A))\nA2 --- T2((T))\nA2 --- R2((R))</code></pre> 208. Implement Trie (Prefix Tree) - Python Solution<pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.endOfWord = None\n\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.endOfWord = True\n\n    def search(self, word: str) -&gt; bool:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return node.endOfWord\n\n    def startsWith(self, prefix: str) -&gt; bool:\n        node = self.root\n\n        for c in prefix:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return True\n\n\n# Your Trie object will be instantiated and called as such:\nobj = Trie()\nobj.insert(\"apple\")\nprint(obj.search(\"word\"))  # False\nprint(obj.startsWith(\"app\"))  # True\n</code></pre>"},{"location":"leetpattern/trie/#211-design-add-and-search-words-data-structure","title":"211. Design Add and Search Words Data Structure","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, depth first search, design, trie</p> </li> </ul> 211. Design Add and Search Words Data Structure - Python Solution<pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.word = False\n\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.word = True\n\n    def search(self, word: str) -&gt; bool:\n\n        def dfs(j, root):\n            node = root\n\n            for i in range(j, len(word)):\n                c = word[i]\n\n                if c == \".\":\n                    for child in node.children.values():\n                        if dfs(i + 1, child):\n                            return True\n                    return False\n                else:\n                    if c not in node.children:\n                        return False\n                    node = node.children[c]\n            return node.word\n\n        return dfs(0, self.root)\n\n\n# Your WordDictionary object will be instantiated and called as such:\nobj = WordDictionary()\nobj.addWord(\"word\")\nprint(obj.search(\"word\"))\nprint(obj.search(\"w.rd\"))\n</code></pre>"},{"location":"leetpattern/trie/#212-word-search-ii","title":"212. Word Search II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, backtracking, trie, matrix</p> </li> </ul> 212. Word Search II - Python Solution<pre><code>from typing import List\n\nfrom template import TrieNode\n\n\n# Backtracking + Trie\ndef findWords(board: List[List[str]], words: List[str]) -&gt; List[str]:\n    root = TrieNode()\n    for word in words:\n        root.addWord(word)\n\n    m, n = len(board), len(board[0])\n    result, visit = set(), set()\n\n    def dfs(r, c, node, word):\n        if (\n            r &lt; 0\n            or r &gt;= m\n            or c &lt; 0\n            or c &gt;= n\n            or (r, c) in visit\n            or board[r][c] not in node.children\n        ):\n            return None\n\n        visit.add((r, c))\n\n        node = node.children[board[r][c]]\n        word += board[r][c]\n        if node.isWord:\n            result.add(word)\n\n        dfs(r - 1, c, node, word)\n        dfs(r + 1, c, node, word)\n        dfs(r, c - 1, node, word)\n        dfs(r, c + 1, node, word)\n\n        visit.remove((r, c))\n\n    for r in range(m):\n        for c in range(n):\n            dfs(r, c, root, \"\")\n\n    return list(result)\n\n\nboard = [\n    [\"o\", \"a\", \"a\", \"n\"],\n    [\"e\", \"t\", \"a\", \"e\"],\n    [\"i\", \"h\", \"k\", \"r\"],\n    [\"i\", \"f\", \"l\", \"v\"],\n]\nwords = [\"oath\", \"pea\", \"eat\", \"rain\"]\nprint(findWords(board, words))\n# ['eat', 'oath']\n</code></pre>"},{"location":"neetcode150/","title":"Neetcode 150","text":""},{"location":"neetcode150/1d_dynamic_programming/","title":"1D Dynamic Programming","text":"<ul> <li> 70. Climbing Stairs (Easy)</li> <li> 746. Min Cost Climbing Stairs (Easy)</li> <li> 198. House Robber (Medium)</li> <li> 213. House Robber II (Medium)</li> <li> 5. Longest Palindromic Substring (Medium)</li> <li> 647. Palindromic Substrings (Medium)</li> <li> 91. Decode Ways (Medium)</li> <li> 322. Coin Change (Medium)</li> <li> 152. Maximum Product Subarray (Medium)</li> <li> 139. Word Break (Medium)</li> <li> 300. Longest Increasing Subsequence (Medium)</li> <li> 416. Partition Equal Subset Sum (Medium)</li> </ul>"},{"location":"neetcode150/1d_dynamic_programming/#70-climbing-stairs","title":"70. Climbing Stairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, dynamic programming, memoization</p> </li> <li>Return the number of distinct ways to reach the top of the stairs.</li> <li><code>dp[n]</code> stores the number of distinct ways to reach the <code>n-th</code> stair.</li> <li>Formula: <code>dp[n] = dp[n - 1] + dp[n - 2]</code>.</li> <li>Initialize <code>dp[0] = 0</code>, <code>dp[1] = 1</code>, and <code>dp[2] = 2</code>.</li> </ul> n <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n]</code> 0 - - 0 1 - - 1 2 - 1 2 3 1 2 3 4 2 3 5 5 3 5 8 6 5 8 13 7 8 13 21 8 13 21 34 9 21 34 55 10 34 55 89 70. Climbing Stairs - Python Solution<pre><code># DP\ndef climbStairs(n: int) -&gt; int:\n    if n &lt;= 1:\n        return n\n\n    dp = [i for i in range(n + 1)]\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |     DP      |      O(n)       |     O(n)     |\n# |-------------|-----------------|--------------|\n\nprint(climbStairs(10))  # 89\n</code></pre>"},{"location":"neetcode150/1d_dynamic_programming/#746-min-cost-climbing-stairs","title":"746. Min Cost Climbing Stairs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li> <p>Return the minimum cost to reach the top of the stairs.</p> </li> <li> <p><code>dp[n]</code> stores the minimum cost to reach the <code>n-th</code> stair.</p> </li> <li>Formula: <code>dp[n] = cost[n] + min(dp[n - 1], dp[n - 2])</code>.</li> <li>Initialize <code>dp[0] = cost[0]</code> and <code>dp[1] = cost[1]</code>.</li> <li> <p>Return <code>min(dp[-1], dp[-2])</code>.</p> </li> <li> <p>Example: <code>cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</code></p> </li> </ul> n <code>cost[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n]</code> 0 1 - - 1 1 100 - 1 100 2 1 1 100 2 3 1 100 2 3 4 1 2 3 3 5 100 3 3 103 6 1 3 103 4 7 1 103 4 5 8 100 4 5 104 9 1 5 104 6 746. Min Cost Climbing Stairs - Python Solution<pre><code>from typing import List\n\n\ndef minCostClimbingStairs(cost: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(cost))]\n\n    dp[0], dp[1] = cost[0], cost[1]\n\n    for i in range(2, len(cost)):\n        dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]\n    print(dp)\n    return min(dp[-1], dp[-2])\n\n\ncost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]\nprint(minCostClimbingStairs(cost))  # 6\n</code></pre>"},{"location":"neetcode150/1d_dynamic_programming/#198-house-robber","title":"198. House Robber","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li> <p>Return the maximum amount of money that can be robbed from the houses. No two adjacent houses can be robbed.</p> </li> <li> <p><code>dp[n]</code> stores the maximum amount of money that can be robbed from the first <code>n</code> houses.</p> </li> <li>Formula: <code>dp[n] = max(dp[n - 1], dp[n - 2] + nums[n])</code>.<ul> <li>Skip: <code>dp[n]</code> \u2192 <code>dp[n - 1]</code></li> <li>Rob: <code>dp[n]</code> \u2192 <code>dp[n - 2] + nums[n]</code></li> </ul> </li> <li>Initialize <code>dp[0] = nums[0]</code> and <code>dp[1] = max(nums[0], nums[1])</code>.</li> <li>Return <code>dp[-1]</code>.</li> <li>Example: <code>nums = [2, 7, 9, 3, 1]</code></li> </ul> n <code>nums[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n-2] + nums[n]</code> <code>dp[n]</code> 0 2 - 2 - 2 1 7 - 7 - 7 2 9 2 7 11 11 3 3 7 11 10 11 4 1 11 11 12 12 198. House Robber - Python Solution<pre><code>from typing import List\n\n\n# DP (House Robber)\ndef rob1(nums: List[int]) -&gt; int:\n    if len(nums) &lt; 3:\n        return max(nums)\n\n    dp = [0 for _ in range(len(nums))]\n    dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n    for i in range(2, len(nums)):\n        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n    return dp[-1]\n\n\n# DP (House Robber) Optimized\ndef rob2(nums: List[int]) -&gt; int:\n    f0, f1 = 0, 0\n\n    for num in nums:\n        f0, f1 = f1, max(f1, f0 + num)\n\n    return f1\n\n\nnums = [2, 7, 9, 3, 1]\nprint(rob1(nums))  # 12\nprint(rob2(nums))  # 12\n</code></pre> 198. House Robber - C++ Solution<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int rob(vector&lt;int&gt; &amp;nums)\n    {\n        int prev = 0, cur = 0;\n\n        for (int num : nums)\n        {\n            int temp = cur;\n            cur = max(cur, prev + num);\n            prev = temp;\n        }\n        return cur;\n    }\n};\n\nint main()\n{\n    vector&lt;int&gt; nums = {2, 7, 9, 3, 1};\n    Solution obj;\n    int result = obj.rob(nums);\n    cout &lt;&lt; result &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"neetcode150/1d_dynamic_programming/#213-house-robber-ii","title":"213. House Robber II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li>Return the maximum amount of money that can be robbed from the houses arranged in a circle.</li> <li>Circular \u2192 Linear: <code>nums[0]</code> and <code>nums[-1]</code> cannot be robbed together.</li> <li>Rob from <code>0</code> to <code>n - 2</code></li> </ul> n <code>nums[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n-2] + nums[n]</code> <code>dp[n]</code> 0 2 - 2 - 2 1 7 - 7 - 7 2 9 2 7 11 11 3 3 7 11 10 11 <ul> <li>Rob from <code>1</code> to <code>n - 1</code></li> </ul> n <code>nums[n]</code> <code>dp[n-2]</code> <code>dp[n-1]</code> <code>dp[n-2] + nums[n]</code> <code>dp[n]</code> 1 7 - - - 7 2 9 - 7 - 9 3 3 7 9 10 10 4 1 9 10 10 10 213. House Robber II - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef rob(nums: List[int]) -&gt; int:\n    if len(nums) &lt;= 3:\n        return max(nums)\n\n    def robLinear(nums: List[int]) -&gt; int:\n        dp = [0 for _ in range(len(nums))]\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n\n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n        return dp[-1]\n\n    # circle -&gt; linear\n    a = robLinear(nums[1:])  # 2nd house to the last house\n    b = robLinear(nums[:-1])  # 1st house to the 2nd last house\n\n    return max(a, b)\n\n\nnums = [2, 7, 9, 3, 1]\nprint(rob(nums))  # 11\n</code></pre>"},{"location":"neetcode150/1d_dynamic_programming/#5-longest-palindromic-substring","title":"5. Longest Palindromic Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string, dynamic programming</p> </li> <li>Return the longest palindromic substring in <code>s</code>.</li> </ul> 5. Longest Palindromic Substring - Python Solution<pre><code># DP - Interval\ndef longestPalindromeDP(s: str) -&gt; str:\n    n = len(s)\n    if n &lt;= 1:\n        return s\n\n    start, maxLen = 0, 1\n\n    # Init\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for j in range(1, n):\n        for i in range(j):\n            if s[i] == s[j]:\n                if j - i &lt;= 2:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1]\n\n                if dp[i][j] and j - i + 1 &gt; maxLen:\n                    maxLen = j - i + 1\n                    start = i\n\n    return s[start : start + maxLen]\n\n\n# Expand Around Center\ndef longestPalindromeCenter(s: str) -&gt; str:\n    def expand_around_center(left, right):\n        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n\n    if len(s) &lt;= 1:\n        return s\n\n    start, end = 0, 0\n    for i in range(len(s)):\n        len1 = expand_around_center(i, i)  # odd\n        len2 = expand_around_center(i, i + 1)  # even\n\n        maxLen = max(len1, len2)\n        if maxLen &gt; end - start:\n            start = i - (maxLen - 1) // 2\n            end = i + maxLen // 2\n\n    return s[start : end + 1]\n\n\ns = \"babad\"\nprint(longestPalindromeDP(s))  # \"bab\"\nprint(longestPalindromeCenter(s))  # \"aba\"\n</code></pre>"},{"location":"neetcode150/1d_dynamic_programming/#647-palindromic-substrings","title":"647. Palindromic Substrings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string, dynamic programming</p> </li> <li>Return the number of palindromic substrings in <code>s</code>.</li> <li>Bottom-up DP table</li> </ul> dp a b b a e a 1 0 0 1 0 b 0 1 1 0 0 b 0 0 1 0 0 a 0 0 0 1 0 e 0 0 0 0 1 647. Palindromic Substrings - Python Solution<pre><code>def countSubstrings(s: str) -&gt; int:\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    res = 0\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i, n):\n            if s[i] == s[j]:\n                if j - i &lt;= 1:\n                    dp[i][j] = 1\n                    res += 1\n                elif dp[i + 1][j - 1]:\n                    dp[i][j] = 1\n                    res += 1\n\n    return res\n\n\nprint(countSubstrings(\"abbae\"))  # 7\n</code></pre>"},{"location":"neetcode150/1d_dynamic_programming/#91-decode-ways","title":"91. Decode Ways","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul> 91. Decode Ways - Python Solution<pre><code># DP\ndef numDecodingsDP(s: str) -&gt; int:\n    if not s or s[0] == \"0\":\n        return 0\n\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for i in range(1, n + 1):\n        # Check single digit decode\n        if s[i - 1] != \"0\":\n            dp[i] += dp[i - 1]\n\n        # Check two digit decode\n        if i &gt; 1 and \"10\" &lt;= s[i - 2 : i] &lt;= \"26\":\n            dp[i] += dp[i - 2]\n\n    return dp[n]\n\n\n# DFS\ndef numDecodingsDFS(s: str) -&gt; int:\n    memo = {}\n\n    def dfs(i):\n        if i == len(s):\n            return 1\n\n        if s[i] == \"0\":\n            return 0\n\n        if i in memo:\n            return memo[i]\n\n        # Single digit decode\n        ways = dfs(i + 1)\n\n        # Two digits decode\n        if i + 1 &lt; len(s) and \"10\" &lt;= s[i : i + 2] &lt;= \"26\":\n            ways += dfs(i + 2)\n\n        memo[i] = ways\n\n        return ways\n\n    return dfs(0)\n\n\ns = \"226\"\nprint(numDecodingsDP(s))  # 3\nprint(numDecodingsDFS(s))  # 3\n</code></pre>"},{"location":"neetcode150/1d_dynamic_programming/#322-coin-change","title":"322. Coin Change","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, breadth first search</p> </li> </ul> 322. Coin Change - Python Solution<pre><code>from typing import List\n\n\ndef coinChange(coins: List[int], amount: int) -&gt; int:\n    dp = [float(\"inf\") for _ in range(amount + 1)]\n\n    dp[0] = 0\n\n    for i in range(1, amount + 1):\n        for c in coins:\n            if i - c &gt;= 0:\n                dp[i] = min(dp[i], 1 + dp[i - c])\n\n    return dp[amount] if dp[amount] != float(\"inf\") else -1\n\n\ncoins = [1, 2, 5]\namount = 11\nprint(coinChange(coins, amount))  # 3\n</code></pre>"},{"location":"neetcode150/1d_dynamic_programming/#152-maximum-product-subarray","title":"152. Maximum Product Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul> 152. Maximum Product Subarray - Python Solution<pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxProduct(nums: List[int]) -&gt; int:\n    n = len(nums)\n    dp_max = [0 for _ in range(n)]\n    dp_min = [0 for _ in range(n)]\n\n    dp_max[0] = nums[0]\n    dp_min[0] = nums[0]\n    max_product = nums[0]\n\n    for i in range(1, n):\n        dp_max[i] = max(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n        dp_min[i] = min(\n            nums[i],\n            nums[i] * dp_max[i - 1],\n            nums[i] * dp_min[i - 1],\n        )\n\n        max_product = max(max_product, dp_max[i])\n\n    return max_product\n\n\nnums = [2, 3, -2, 4]\nprint(maxProduct(nums))  # 6\n</code></pre>"},{"location":"neetcode150/1d_dynamic_programming/#139-word-break","title":"139. Word Break","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, dynamic programming, trie, memoization</p> </li> </ul> 139. Word Break - Python Solution<pre><code>from typing import List\n\n\n# DP - Knapsack Unbounded\ndef wordBreak(s: str, wordDict: List[str]) -&gt; bool:\n    n = len(s)\n    wordSet = set(wordDict)\n    dp = [False for _ in range(n + 1)]\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in wordSet:\n                dp[i] = True\n                break\n\n    return dp[n]\n\n\ns = \"leetcode\"\nwordDict = [\"leet\", \"code\"]\nprint(wordBreak(s, wordDict))  # True\n</code></pre>"},{"location":"neetcode150/1d_dynamic_programming/#300-longest-increasing-subsequence","title":"300. Longest Increasing Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, dynamic programming</p> </li> </ul> 300. Longest Increasing Subsequence - Python Solution<pre><code>from typing import List\n\n\n# DP - LIS\ndef lengthOfLIS(nums: List[int]) -&gt; int:\n    # TC: O(n^2)\n    # SC: O(n)\n    n = len(nums)\n    if n &lt;= 1:\n        return n\n\n    dp = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] &gt; nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\n\nnums = [10, 9, 2, 5, 3, 7, 101, 18]\nprint(lengthOfLIS(nums))  # 4\n</code></pre>"},{"location":"neetcode150/1d_dynamic_programming/#416-partition-equal-subset-sum","title":"416. Partition Equal Subset Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul> 416. Partition Equal Subset Sum - Python Solution<pre><code>from typing import List\n\nfrom template import knapsack01\n\n\n# DP - Knapsack 01\ndef canPartitionTemplate(nums: List[int]) -&gt; bool:\n    total = sum(nums)\n\n    if total % 2 == 1 or len(nums) &lt; 2:\n        return False\n\n    target = total // 2\n\n    return knapsack01(nums, nums, target) == target\n\n\n# DP - Knapsack 01\ndef canPartition(nums: List[int]) -&gt; bool:\n    total = sum(nums)\n\n    if total % 2 == 1 or len(nums) &lt; 2:\n        return False\n\n    target = total // 2\n\n    dp = [0 for _ in range(target + 1)]\n\n    for i in range(len(nums)):\n        for j in range(target, nums[i] - 1, -1):\n            dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])\n\n    return dp[target] == target\n\n\nnums = [1, 5, 11, 5]\nprint(canPartitionTemplate(nums))  # True\nprint(canPartition(nums))  # True\n</code></pre>"},{"location":"neetcode150/2d_dynamic_programming/","title":"2D Dynamic_Programming","text":"<ul> <li> 62. Unique Paths (Medium)</li> <li> 1143. Longest Common Subsequence (Medium)</li> <li> 309. Best Time to Buy and Sell Stock with Cooldown (Medium)</li> <li> 518. Coin Change II (Medium)</li> <li> 494. Target Sum (Medium)</li> <li> 97. Interleaving String (Medium)</li> <li> 329. Longest Increasing Path in a Matrix (Hard)</li> <li> 115. Distinct Subsequences (Hard)</li> <li> 72. Edit Distance (Medium)</li> <li> 312. Burst Balloons (Hard)</li> <li> 10. Regular Expression Matching (Hard)</li> </ul>"},{"location":"neetcode150/2d_dynamic_programming/#62-unique-paths","title":"62. Unique Paths","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming, combinatorics</p> </li> <li>Count the number of unique paths to reach the bottom-right corner of a <code>m x n</code> grid.</li> </ul> <p></p> 62. Unique Paths - Python Solution<pre><code># DP - 2D\ndef uniquePaths(m: int, n: int) -&gt; int:\n    if m == 1 or n == 1:\n        return 1\n\n    dp = [[1] * n for _ in range(m)]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]\n\n\nprint(uniquePaths(m=3, n=7))  # 28\n# [[1, 1, 1,  1,  1,  1,  1],\n#  [1, 2, 3,  4,  5,  6,  7],\n#  [1, 3, 6, 10, 15, 21, 28]]\n</code></pre>"},{"location":"neetcode150/2d_dynamic_programming/#1143-longest-common-subsequence","title":"1143. Longest Common Subsequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul> 1143. Longest Common Subsequence - Python Solution<pre><code># DP - LCS\ndef longestCommonSubsequence(text1: str, text2: str) -&gt; int:\n    m, n = len(text1), len(text2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    res = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i - 1] == text2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])\n\n            if res &lt; dp[i][j]:\n                res = dp[i][j]\n\n    return res\n\n\ntext1 = \"abcde\"\ntext2 = \"ace\"\nprint(longestCommonSubsequence(text1, text2))  # 3\n</code></pre>"},{"location":"neetcode150/2d_dynamic_programming/#309-best-time-to-buy-and-sell-stock-with-cooldown","title":"309. Best Time to Buy and Sell Stock with Cooldown","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul> 309. Best Time to Buy and Sell Stock with Cooldown - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef maxProfit(prices: List[int]) -&gt; int:\n    n = len(prices)\n    if n &lt;= 1:\n        return 0\n\n    dp = [[0] * 4 for _ in range(n)]\n\n    dp[0][0] = -prices[0]  # poessess\n    dp[0][1] = 0  # stay sold\n    dp[0][2] = 0  # sell\n    dp[0][3] = 0  # cooldown\n\n    for i in range(1, n):\n        dp[i][0] = max(\n            dp[i - 1][0],  # stay poessess\n            dp[i - 1][1] - prices[i],  # buy after stay sold\n            dp[i - 1][3] - prices[i],  # buy after cooldown\n        )\n        dp[i][1] = max(\n            dp[i - 1][1],  # stay sold\n            dp[i - 1][3],  # stay cooldown\n        )\n        dp[i][2] = dp[i - 1][0] + prices[i]\n        dp[i][3] = dp[i - 1][2]\n\n    return max(dp[-1])\n\n\nprices = [1, 2, 3, 0, 2]\nprint(maxProfit(prices))  # 3\n</code></pre>"},{"location":"neetcode150/2d_dynamic_programming/#518-coin-change-ii","title":"518. Coin Change II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul> 518. Coin Change II - Python Solution<pre><code>from typing import List\n\n\ndef change(amount: int, coins: List[int]) -&gt; int:\n    dp = [0 for _ in range(amount + 1)]\n    dp[0] = 1\n\n    for i in range(len(coins)):\n        for j in range(coins[i], amount + 1):\n            dp[j] += dp[j - coins[i]]\n\n    return dp[-1]\n\n\namount = 5\ncoins = [1, 2, 5]\nprint(change(amount, coins))  # 4\n</code></pre>"},{"location":"neetcode150/2d_dynamic_programming/#494-target-sum","title":"494. Target Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, backtracking</p> </li> </ul> 494. Target Sum - Python Solution<pre><code>from typing import List\n\n\ndef findTargetSumWays(nums: List[int], target: int) -&gt; int:\n\n    totalSum = sum(nums)\n\n    if abs(target) &gt; totalSum:\n        return 0\n    if (target + totalSum) % 2 == 1:\n        return 0\n\n    targetSum = (target + totalSum) // 2\n    dp = [0] * (targetSum + 1)\n    dp[0] = 1\n\n    for i in range(len(nums)):\n        for j in range(targetSum, nums[i] - 1, -1):\n            dp[j] += dp[j - nums[i]]\n\n    return dp[targetSum]\n\n\nnums = [1, 1, 1, 1, 1]\ntarget = 3\nprint(findTargetSumWays(nums, target))  # 5\n</code></pre>"},{"location":"neetcode150/2d_dynamic_programming/#97-interleaving-string","title":"97. Interleaving String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul> 97. Interleaving String - Python Solution<pre><code># DP - 2D\ndef isInterleaveDP(s1: str, s2: str, s3: str) -&gt; bool:\n    m, n, k = len(s1), len(s2), len(s3)\n\n    if m + n != k:\n        return False\n\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    for i in range(1, m + 1):\n        dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n\n    for j in range(1, n + 1):\n        dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (\n                dp[i][j - 1] and s2[j - 1] == s3[i + j - 1]\n            )\n\n    return dp[m][n]\n\n\n# DFS\ndef isInterleaveDFS(s1: str, s2: str, s3: str) -&gt; bool:\n    memo = {}\n\n    def dfs(i, j, k):\n        if i == len(s1) and j == len(s2) and k == len(s3):\n            return True\n\n        if (i, j) in memo:\n            return memo[(i, j)]\n\n        res = False\n\n        if i &lt; len(s1) and k &lt; len(s3) and s1[i] == s3[k]:\n            res |= dfs(i + 1, j, k + 1)\n\n        if j &lt; len(s2) and k &lt; len(s3) and s2[j] == s3[k]:\n            res |= dfs(i, j + 1, k + 1)\n\n        memo[(i, j)] = res\n\n        return res\n\n    return dfs(0, 0, 0)\n\n\ns1 = \"aabcc\"\ns2 = \"dbbca\"\ns3 = \"aadbbbaccc\"\nprint(isInterleaveDP(s1, s2, s3))  # False\nprint(isInterleaveDFS(s1, s2, s3))  # False\n</code></pre>"},{"location":"neetcode150/2d_dynamic_programming/#329-longest-increasing-path-in-a-matrix","title":"329. Longest Increasing Path in a Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming, depth first search, breadth first search, graph, topological sort, memoization, matrix</p> </li> </ul> 329. Longest Increasing Path in a Matrix - Python Solution<pre><code>from typing import List\n\n\n# DP - 2D\ndef longestIncreasingPath(matrix: List[List[int]]) -&gt; int:\n    if not matrix:\n        return 0\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * n for _ in range(m)]\n    dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(r, c):\n        if dp[r][c]:\n            return dp[r][c]\n        for dr, dc in dirs:\n            nr, nc = r + dr, c + dc\n            if 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and matrix[nr][nc] &gt; matrix[r][c]:\n                dp[r][c] = max(dp[r][c], dfs(nr, nc))\n        dp[r][c] += 1\n        return dp[r][c]\n\n    res = float(\"-inf\")\n    for i in range(m):\n        for j in range(n):\n            res = max(res, dfs(i, j))\n\n    return res\n\n\nmatrix = [[9, 9, 4], [6, 6, 8], [2, 1, 1]]\nprint(longestIncreasingPath(matrix))  # 4\n</code></pre>"},{"location":"neetcode150/2d_dynamic_programming/#115-distinct-subsequences","title":"115. Distinct Subsequences","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul> 115. Distinct Subsequences - Python Solution<pre><code>def numDistinct(s: str, t: str) -&gt; int:\n    m = len(s)\n    n = len(t)\n    dp = [[0] * (n + 1) for _ in range((m + 1))]\n\n    for i in range(m):\n        dp[i][0] = 1\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                # include and exclude s[i-1]\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]  # exclude s[i-1]\n\n    return dp[-1][-1]\n\n\ns = \"rabbbit\"\nt = \"rabbit\"\nprint(numDistinct(s, t))  # 3\n</code></pre>"},{"location":"neetcode150/2d_dynamic_programming/#72-edit-distance","title":"72. Edit Distance","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming</p> </li> </ul> 72. Edit Distance - Python Solution<pre><code>def minDistance(word1: str, word2: str) -&gt; int:\n    m = len(word1)\n    n = len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]  # no operation\n            else:\n                dp[i][j] = 1 + min(\n                    dp[i - 1][j],  # delete\n                    dp[i][j - 1],  # insert\n                    dp[i - 1][j - 1],  # replace\n                )\n    return dp[-1][-1]\n\n\nword1 = \"horse\"\nword2 = \"ros\"\nprint(minDistance(word1, word2))  # 3\n</code></pre>"},{"location":"neetcode150/2d_dynamic_programming/#312-burst-balloons","title":"312. Burst Balloons","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"neetcode150/2d_dynamic_programming/#10-regular-expression-matching","title":"10. Regular Expression Matching","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, dynamic programming, recursion</p> </li> </ul>"},{"location":"neetcode150/advanced_graphs/","title":"Advanced Graphs","text":"<ul> <li> 332. Reconstruct Itinerary (Hard)</li> <li> 1584. Min Cost to Connect All Points (Medium)</li> <li> 743. Network Delay Time (Medium)</li> <li> 778. Swim in Rising Water (Hard)</li> <li> 269. Alien Dictionary (Hard)</li> <li> 787. Cheapest Flights Within K Stops (Medium)</li> </ul>"},{"location":"neetcode150/advanced_graphs/#332-reconstruct-itinerary","title":"332. Reconstruct Itinerary","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: depth first search, graph, eulerian circuit</p> </li> <li>Return the itinerary in order that visits every airport exactly once.</li> <li>The starting airport is <code>JFK</code>.</li> <li>If there are multiple valid itineraries, return the lexicographically smallest one.</li> <li>Eulerian path: A path that visits every edge exactly once.</li> </ul> <pre><code>graph TD\nJFK((JFK))\nSFO((SFO))\nATL((ATL))\nJFK --&gt; SFO\nSFO --&gt; ATL\nATL --&gt; JFK\nJFK --&gt; ATL\nATL --&gt; SFO</code></pre> 332. Reconstruct Itinerary - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hierholzer\ndef findItinerary1(tickets: List[List[str]]) -&gt; List[str]:\n    graph = defaultdict(list)\n    for u, v in sorted(tickets, reverse=True):\n        graph[u].append(v)\n\n    route = []\n\n    def dfs(node):\n        while graph[node]:\n            dest = graph[node].pop()\n            dfs(dest)\n        route.append(node)\n\n    dfs(\"JFK\")\n\n    return route[::-1]\n\n\n# Backtracking\ndef findItinerary2(tickets: List[List[str]]) -&gt; List[str]:\n    graph = defaultdict(list)\n    tickets.sort()\n    for u, v in tickets:\n        graph[u].append(v)\n\n    route = [\"JFK\"]\n\n    def backtraking(node):\n        if len(route) == len(tickets) + 1:\n            return True\n        if node not in graph:\n            return False\n\n        temp = list(graph[node])\n        for i, v in enumerate(temp):\n            graph[node].pop(i)\n            route.append(v)\n\n            if backtraking(v):\n                return True\n\n            graph[node].insert(i, v)\n            route.pop()\n\n        return False\n\n    backtraking(\"JFK\")\n\n    return route\n\n\ntickets = tickets = [\n    [\"JFK\", \"SFO\"],\n    [\"JFK\", \"ATL\"],\n    [\"SFO\", \"ATL\"],\n    [\"ATL\", \"JFK\"],\n    [\"ATL\", \"SFO\"],\n]\nprint(findItinerary1(tickets))\n# ['JFK', 'ATL', 'JFK', 'SFO', 'ATL', 'SFO']\nprint(findItinerary2(tickets))\n# ['JFK', 'ATL', 'JFK', 'SFO', 'ATL', 'SFO']\n</code></pre>"},{"location":"neetcode150/advanced_graphs/#1584-min-cost-to-connect-all-points","title":"1584. Min Cost to Connect All Points","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, union find, graph, minimum spanning tree</p> </li> <li>Tree: a connected acyclic graph</li> <li>Spanning Tree: a subgraph that is a tree and connects all the vertices together</li> <li>Minimum Spanning Tree (MST): a spanning tree with the minimum possible sum of edge weights</li> <li>Prim's Algorithm<ul> <li>Data Structure: Heap</li> <li>Time Complexity: O(E * logV)</li> <li>Space Complexity: O(V + E)</li> </ul> </li> <li> <p>Kruskal's Algorithm</p> <ul> <li>Union Find</li> <li>Time Complexity: O(E * logV)</li> <li>Space Complexity: O(V + E)</li> </ul> </li> <li> <p>Demonstration</p> </li> </ul> <p>Example graph</p> <p></p> <p>MST</p> <p></p> 1584. Min Cost to Connect All Points - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Prim\ndef minCostConnectPointsPrim(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    graph = defaultdict(list)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            dist = abs(x1 - x2) + abs(y1 - y2)\n            graph[i].append((dist, j))\n            graph[j].append((dist, i))\n\n    cost = 0\n    heap = [(0, 0)]  # (cost, node)\n    visited = set()\n\n    while heap:\n        d1, n1 = heapq.heappop(heap)\n        if n1 in visited:\n            continue\n        visited.add(n1)\n        cost += d1\n\n        for d2, n2 in graph[n1]:\n            if n2 not in visited:\n                heapq.heappush(heap, (d2, n2))\n\n    return cost\n\n\n# Kruskal\ndef minCostConnectPointsKruskal(points: List[List[int]]) -&gt; int:\n    n = len(points)\n    par = {i: i for i in range(n)}\n    rank = {i: 0 for i in range(n)}\n\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n\n        if p1 == p2:\n            return False\n\n        if rank[p1] &gt; rank[p2]:\n            par[p2] = p1\n        elif rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n        else:\n            par[p2] = p1\n            rank[p1] += 1\n\n        return True\n\n    heap = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            dist = abs(x1 - x2) + abs(y1 - y2)\n            heapq.heappush(heap, (dist, i, j))\n\n    cost = 0\n    while heap:\n        d, n1, n2 = heapq.heappop(heap)\n        if union(n1, n2):\n            cost += d\n\n    return cost\n\n\npoints = [[0, 0], [2, 2], [3, 10], [5, 2], [7, 0]]\nprint(minCostConnectPointsPrim(points))  # 20\nprint(minCostConnectPointsKruskal(points))  # 20\n</code></pre>"},{"location":"neetcode150/advanced_graphs/#743-network-delay-time","title":"743. Network Delay Time","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, heap priority queue, shortest path</p> </li> <li>Return the minimum time taken to reach all nodes in a network.</li> </ul> <pre><code>graph LR\n1((1))\n2((2))\n3((3))\n4((4))\n2 --&gt; |1| 1\n2 --&gt; |1| 3\n3 --&gt; |1| 4</code></pre> <ul> <li>Shortest Path Problem: Find the shortest path between two vertices in a graph.</li> <li>Dijkstra's Algorithm<ul> <li>Shortest path algorithm</li> <li>Weighted graph (non-negative weights)</li> <li>Data Structure: Heap; Hash Set</li> <li>Time Complexity: O(E * logV)</li> <li>Space Complexity: O(V)</li> </ul> </li> </ul> 743. Network Delay Time - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\nfrom helper import complexity\n\n\n# 1. Dijkstra - Set\ndef networkDelayTime1(times: List[List[int]], n: int, k: int) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    heap = [(0, k)]\n    visit = set()\n    t = 0\n\n    while heap:\n        w1, n1 = heapq.heappop(heap)\n        if n1 in visit:\n            continue\n\n        visit.add(n1)\n        t = w1\n\n        for n2, w2 in graph[n1]:\n            heapq.heappush(heap, (w1 + w2, n2))\n\n    return t if len(visit) == n else -1\n\n\n# 2. Dijkstra - Dict\ndef networkDelayTime2(times: List[List[int]], n: int, k: int) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n\n    heap = [(0, k)]\n    dist = defaultdict(int)\n\n    while heap:\n        w1, n1 = heapq.heappop(heap)\n        if n1 in dist:\n            continue\n\n        dist[n1] = w1\n\n        for n2, w2 in graph[n1]:\n            heapq.heappush(heap, (w1 + w2, n2))\n\n    return max(dist.values()) if len(dist) == n else -1\n\n\n# Bellman-Ford\ndef networkDelayTimeBF(times: List[List[int]], n: int, k: int) -&gt; int:\n    delay = {i: float(\"inf\") for i in range(1, n + 1)}\n    delay[k] = 0\n\n    for _ in range(n - 1):\n        for u, v, t in times:\n            delay[v] = min(delay[v], delay[u] + t)\n\n    max_delay = max(delay.values())\n    return max_delay if max_delay &lt; float(\"inf\") else -1\n\n\ntable = [\n    [\"Dijkstra\", \"O(E*logV)\", \"O(V+E)\"],\n    [\"Bellman-Ford\", \"O(E*V)\", \"O(V)\"],\n]\ncomplexity(table)\n# |--------------|-----------|--------|\n# | Approach     | Time      | Space  |\n# |--------------|-----------|--------|\n# | Dijkstra     | O(E*logV) | O(V+E) |\n# | Bellman-Ford | O(E*V)    | O(V)   |\n# |--------------|-----------|--------|\n\n\ntimes = [[2, 1, 1], [2, 3, 1], [3, 4, 1]]\nn = 4\nk = 2\nprint(networkDelayTime1(times, n, k))  # 2\nprint(networkDelayTime2(times, n, k))  # 2\nprint(networkDelayTimeBF(times, n, k))  # 2\n</code></pre>"},{"location":"neetcode150/advanced_graphs/#778-swim-in-rising-water","title":"778. Swim in Rising Water","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, depth first search, breadth first search, union find, heap priority queue, matrix</p> </li> <li>Return the minimum time when you can reach the target.</li> </ul> <p></p> 778. Swim in Rising Water - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra's\ndef swimInWater(grid: List[List[int]]) -&gt; int:\n    n = len(grid)\n    visited = set()\n    minHeap = [(grid[0][0], 0, 0)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    visited.add((0, 0))\n\n    while minHeap:\n        time, r, c = heapq.heappop(minHeap)\n\n        if r == n - 1 and c == n - 1:\n            return time\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n\n            if nr in range(n) and nc in range(n) and (nr, nc) not in visited:\n                visited.add((nr, nc))\n                heapq.heappush(minHeap, (max(time, grid[nr][nc]), nr, nc))\n\n\ngrid = [\n    [0, 1, 2, 3, 4],\n    [24, 23, 22, 21, 5],\n    [12, 13, 14, 15, 16],\n    [11, 17, 18, 19, 20],\n    [10, 9, 8, 7, 6],\n]\nprint(swimInWater(grid))  # 16\n</code></pre>"},{"location":"neetcode150/advanced_graphs/#269-alien-dictionary","title":"269. Alien Dictionary","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, depth first search, breadth first search, graph, topological sort</p> </li> <li>Return the correct order of characters in the alien language.</li> </ul> 269. Alien Dictionary - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS - Kahn's algorithm (Topological Sort)\ndef alienOrderBFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    indegree = {c: 0 for word in words for c in word}\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                    indegree[w2[j]] += 1\n                break\n\n    q = deque([c for c in indegree if indegree[c] == 0])\n    result = []\n\n    while q:\n        char = q.popleft()\n        result.append(char)\n\n        for neighbor in graph[char]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n\n    return \"\".join(result) if len(result) == len(indegree) else \"\"\n\n\n# DFS - Topological Sort\ndef alienOrderDFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    visited = {}\n    result = []\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                break\n\n    def dfs(c):\n        if c in visited:\n            return visited[c]\n\n        visited[c] = False\n        for neighbor in graph[c]:\n            if not dfs(neighbor):\n                return False\n\n        visited[c] = True\n        result.append(c)\n        return True\n\n    for c in list(graph.keys()):\n        if not dfs(c):\n            return \"\"\n\n    return \"\".join(result[::-1])\n\n\nwords = [\"wrt\", \"wrf\", \"er\", \"ett\", \"rftt\"]\nprint(alienOrderBFS(words))  # wertf\nprint(alienOrderDFS(words))  # wertf\n</code></pre>"},{"location":"neetcode150/advanced_graphs/#787-cheapest-flights-within-k-stops","title":"787. Cheapest Flights Within K Stops","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming, depth first search, breadth first search, graph, heap priority queue, shortest path</p> </li> <li>Return the cheapest price from <code>src</code> to <code>dst</code> with at most <code>K</code> stops.</li> </ul> <pre><code>graph TD\n0((0))\n1((1))\n2((2))\n3((3))\n0 --&gt; |100| 1\n1 --&gt; |600| 3\n1 --&gt; |100| 2\n2 --&gt; |100| 0\n2 --&gt; |200| 3</code></pre> 787. Cheapest Flights Within K Stops - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Bellman-Ford\ndef findCheapestPriceBF(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    prices = [float(\"inf\") for _ in range(n)]\n    prices[src] = 0\n\n    for _ in range(k + 1):\n        temp = prices[:]\n        for u, v, w in flights:\n            temp[v] = min(temp[v], prices[u] + w)\n        prices = temp\n\n    return prices[dst] if prices[dst] != float(\"inf\") else -1\n\n\n# Dijkstra\ndef findCheapestPriceDijkstra(\n    n: int, flights: List[List[int]], src: int, dst: int, k: int\n) -&gt; int:\n    graph = defaultdict(list)\n    for u, v, w in flights:\n        graph[u].append((v, w))\n\n    heap = [(0, src, 0)]  # (price, city, stops)\n    visited = defaultdict(int)  # {city: stops}\n\n    while heap:\n        price, city, stops = heapq.heappop(heap)\n\n        if city == dst:\n            return price\n\n        if stops &gt; k:\n            continue\n\n        if city in visited and visited[city] &lt;= stops:\n            continue\n\n        visited[city] = stops\n\n        for neighbor, cost in graph[city]:\n            heapq.heappush(heap, (price + cost, neighbor, stops + 1))\n\n    return -1\n\n\n# |------------|------------------|---------|\n# |  Approach  |       Time       |  Space  |\n# |------------|------------------|---------|\n# |Bellman-Ford|    O(k * E)      |  O(n)   |\n# | Dijkstra   | O(E * log(V))    |  O(n)   |\n# |------------|------------------|---------|\n\n\nn = 4\nflights = [[0, 1, 100], [1, 2, 100], [2, 0, 100], [1, 3, 600], [2, 3, 200]]\nsrc = 0\ndst = 3\nk = 1\nprint(findCheapestPriceBF(n, flights, src, dst, k))  # 700\nprint(findCheapestPriceDijkstra(n, flights, src, dst, k))  # 700\n</code></pre>"},{"location":"neetcode150/arrays_hashing/","title":"Arrays Hashing","text":"<ul> <li> 217. Contains Duplicate (Easy)</li> <li> 242. Valid Anagram (Easy)</li> <li> 1. Two Sum (Easy)</li> <li> 49. Group Anagrams (Medium)</li> <li> 347. Top K Frequent Elements (Medium)</li> <li> 271. Encode and Decode Strings (Medium)</li> <li> 238. Product of Array Except Self (Medium)</li> <li> 36. Valid Sudoku (Medium)</li> <li> 128. Longest Consecutive Sequence (Medium)</li> </ul>"},{"location":"neetcode150/arrays_hashing/#217-contains-duplicate","title":"217. Contains Duplicate","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, sorting</p> </li> <li>Return True if the array contains any duplicates, otherwise return False.</li> </ul> 217. Contains Duplicate - Python Solution<pre><code>from typing import List\n\n\n# Brute Force\ndef containsDuplicateBF(nums: List[int]) -&gt; bool:\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] == nums[j]:\n                return True\n\n    return False\n\n\n# Sort\ndef containsDuplicateSort(nums: List[int]) -&gt; bool:\n    nums.sort()\n\n    for i in range(1, len(nums)):\n        if nums[i] == nums[i - 1]:\n            return True\n\n    return False\n\n\n# Set\ndef containsDuplicateSet(nums: List[int]) -&gt; bool:\n    seen = set()\n\n    for i in nums:\n        if i in seen:\n            return True\n        seen.add(i)\n\n    return False\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# | Brute Force |    O(n^2)       |    O(1)      |\n# |     Sort    |    O(n log n)   |    O(1)      |\n# |     Set     |    O(n)         |    O(n)      |\n# |-------------|-----------------|--------------|\n\nprint(containsDuplicateBF([1, 2, 3, 1]))  # True\nprint(containsDuplicateSort([1, 2, 3, 1]))  # True\nprint(containsDuplicateSet([1, 2, 3, 1]))  # True\n</code></pre>"},{"location":"neetcode150/arrays_hashing/#242-valid-anagram","title":"242. Valid Anagram","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, string, sorting</p> </li> <li>Return true if an input string is an anagram of another string.</li> <li>An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once, e.g., <code>listen</code> is an anagram of <code>silent</code>.</li> </ul> 242. Valid Anagram - Python Solution<pre><code>from collections import Counter\n\n\n# Hashmap\ndef isAnagramHash(s: str, t: str) -&gt; bool:\n    \"\"\"Return True if t is an anagram of s, False otherwise.\"\"\"\n    if len(s) != len(t):\n        return False\n\n    count = dict()\n\n    for i in s:\n        if i in count:\n            count[i] += 1\n        else:\n            count[i] = 1\n\n    for j in t:\n        if j in count:\n            count[j] -= 1\n        else:\n            return False\n\n    for count in count.values():\n        if count != 0:\n            return False\n\n    return True\n\n\n# Array\ndef isAnagramArray(s: str, t: str) -&gt; bool:\n    if len(s) != len(t):\n        return False\n\n    count = [0 for _ in range(26)]\n\n    for i in s:\n        count[ord(i) - ord(\"a\")] += 1\n\n    for j in t:\n        count[ord(j) - ord(\"a\")] -= 1\n\n    for i in count:\n        if i != 0:\n            return False\n\n    return True\n\n\n# Counter\ndef isAnagramCounter(s: str, t: str) -&gt; bool:\n    return Counter(s) == Counter(t)\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |   Hashmap   |       O(n)      |     O(1)     |\n# |    Array    |       O(n)      |     O(1)     |\n# |   Counter   |       O(n)      |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\ns = \"anagram\"\nt = \"nagaram\"\nprint(isAnagramHash(s, t))  # True\nprint(isAnagramArray(s, t))  # True\nprint(isAnagramCounter(s, t))  # True\n</code></pre>"},{"location":"neetcode150/arrays_hashing/#1-two-sum","title":"1. Two Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table</p> </li> <li>Return the indices of the two numbers such that they add up to a specific target.</li> </ul> Approach Time Complexity Space Complexity Hashmap O(n) O(n) 1. Two Sum - Python Solution<pre><code>from typing import List\n\n\n# Hashmap\ndef twoSum(nums: List[int], target: int) -&gt; List[int]:\n    hashmap = {}  # val: idx\n\n    for idx, val in enumerate(nums):\n        if (target - val) in hashmap:\n            return [hashmap[target - val], idx]\n\n        hashmap[val] = idx\n\n\nnums = [2, 7, 11, 15]\ntarget = 18\nassert twoSum(nums, target) == [1, 2]\n</code></pre>"},{"location":"neetcode150/arrays_hashing/#49-group-anagrams","title":"49. Group Anagrams","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, sorting</p> </li> </ul> 49. Group Anagrams - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Hash - List\ndef groupAnagrams(strs: List[str]) -&gt; List[List[str]]:\n    result = defaultdict(list)\n\n    for s in strs:\n        count = [0] * 26\n        for i in s:\n            count[ord(i) - ord(\"a\")] += 1\n\n        result[tuple(count)].append(s)\n\n    return list(result.values())\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Hash     |     O(n * k)    |     O(n)     |\n# |-------------|-----------------|--------------|\n\n\nstrs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\nprint(groupAnagrams(strs))\n# [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\n</code></pre>"},{"location":"neetcode150/arrays_hashing/#347-top-k-frequent-elements","title":"347. Top K Frequent Elements","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, divide and conquer, sorting, heap priority queue, bucket sort, counting, quickselect</p> </li> </ul> 347. Top K Frequent Elements - Python Solution<pre><code>import heapq\nfrom collections import Counter\nfrom typing import List\n\n\n# Heap + Counter\ndef topKFrequent(nums: List[int], k: int) -&gt; List[int]:\n    minHeap = []\n\n    for val, freq in Counter(nums).items():\n        if len(minHeap) &lt; k:\n            heapq.heappush(minHeap, (freq, val))\n        else:\n            heapq.heappushpop(minHeap, (freq, val))\n\n    return [i for _, i in minHeap]\n\n\n# Counter (Most Common)\ndef topKFrequentCounter(nums: List[int], k: int) -&gt; List[int]:\n    commons = Counter(nums).most_common(k)\n    return [i for i, _ in commons]\n\n\nnums = [1, 1, 1, 2, 2, 3]\nk = 2\nprint(topKFrequent(nums, k))  # [1, 2]\nprint(topKFrequentCounter(nums, k))  # [1, 2]\n</code></pre>"},{"location":"neetcode150/arrays_hashing/#271-encode-and-decode-strings","title":"271. Encode and Decode Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, design</p> </li> </ul> 271. Encode and Decode Strings - Python Solution<pre><code>from typing import List\n\n\nclass Codec:\n    def encode(self, strs: List[str]) -&gt; str:\n        \"\"\"Encodes a list of strings to a single string.\"\"\"\n        encoded = \"\"\n\n        for s in strs:\n            encoded += str(len(s)) + \"#\" + s\n\n        return encoded\n\n    def decode(self, s: str) -&gt; List[str]:\n        \"\"\"Decodes a single string to a list of strings.\"\"\"\n        decoded = []\n        i = 0\n\n        while i &lt; len(s):\n            j = i\n            while s[j] != \"#\":\n                j += 1\n\n            strLen = int(s[i:j])\n            decoded.append(s[j + 1 : j + 1 + strLen])\n            i = j + 1 + strLen\n\n        return decoded\n\n\n# |-------------|-------------|--------------|\n# |   Approach  |    Time     |    Space     |\n# |-------------|-------------|--------------|\n# | Two pointers|    O(n)     |     O(n)     |\n# |-------------|-------------|--------------|\n\n\ncodec = Codec()\nencoded = codec.encode([\"hello\", \"world\"])\nprint(encoded)  # \"5#hello5#world\"\ndecoded = codec.decode(encoded)\nprint(decoded)  # [\"hello\", \"world\"]\n</code></pre>"},{"location":"neetcode150/arrays_hashing/#238-product-of-array-except-self","title":"238. Product of Array Except Self","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, prefix sum</p> </li> <li>Classic Prefix Sum problem</li> <li>Return an array <code>output</code> such that <code>output[i]</code> is equal to the product of all the elements of <code>nums</code> except <code>nums[i]</code>.</li> </ul> Approach Time Space Prefix O(n) O(n) Prefix (Optimized) O(n) O(1) 238. Product of Array Except Self - Python Solution<pre><code>from typing import List\n\n\n# Prefix\ndef productExceptSelf(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    prefix = [1 for _ in range(n)]\n    suffix = [1 for _ in range(n)]\n\n    for i in range(1, n):\n        prefix[i] = nums[i - 1] * prefix[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        suffix[i] = nums[i + 1] * suffix[i + 1]\n\n    result = [i * j for i, j in zip(prefix, suffix)]\n\n    return result\n\n\n# Prefix (Optimized)\ndef productExceptSelfOptimized(nums: List[int]) -&gt; List[int]:\n    n = len(nums)\n    result = [1 for _ in range(n)]\n\n    prefix = 1\n    for i in range(n):\n        result[i] = prefix\n        prefix *= nums[i]\n\n    suffix = 1\n    for i in range(n - 1, -1, -1):\n        result[i] *= suffix\n        suffix *= nums[i]\n\n    return result\n\n\nprint(productExceptSelf([1, 2, 3, 4]))\n# [24, 12, 8, 6]\nprint(productExceptSelfOptimized([1, 2, 3, 4]))\n# [24, 12, 8, 6]\n</code></pre>"},{"location":"neetcode150/arrays_hashing/#36-valid-sudoku","title":"36. Valid Sudoku","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, matrix</p> </li> </ul> 36. Valid Sudoku - Python Solution<pre><code>from typing import List\n\n\n# Set\ndef isValidSudoku(board: List[List[str]]) -&gt; bool:\n    rows = [set() for _ in range(9)]\n    cols = [set() for _ in range(9)]\n    boxes = [set() for _ in range(9)]\n\n    for i in range(9):\n        for j in range(9):\n            if board[i][j] == \".\":\n                continue\n\n            if board[i][j] in rows[i]:\n                return False\n            rows[i].add(board[i][j])\n\n            if board[i][j] in cols[j]:\n                return False\n            cols[j].add(board[i][j])\n\n            box_index = (i // 3) * 3 + j // 3\n            if board[i][j] in boxes[box_index]:\n                return False\n            boxes[box_index].add(board[i][j])\n\n    return True\n\n\nboard = [\n    [\"5\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],\n    [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n    [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n    [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n    [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n    [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n    [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"],\n    [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n    [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"],\n]\nprint(isValidSudoku(board))  # True\n</code></pre>"},{"location":"neetcode150/arrays_hashing/#128-longest-consecutive-sequence","title":"128. Longest Consecutive Sequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, union find</p> </li> </ul> 128. Longest Consecutive Sequence - Python Solution<pre><code>from typing import List\n\n\n# Set\ndef longestConsecutiveSet(nums: List[int]) -&gt; int:\n    num_set = set(nums)  # O(n)\n    longest = 0\n\n    for n in nums:\n        if (n - 1) not in num_set:  # left boundary\n            length = 1\n\n            while (n + length) in num_set:\n                length += 1\n\n            longest = max(longest, length)\n\n    return longest\n\n\n# Union Find\ndef longestConsecutiveUF(nums: List[int]) -&gt; int:\n    if not nums:\n        return 0\n\n    par = {num: num for num in nums}\n    rank = {num: 1 for num in nums}\n\n    def find(num):\n        p = par[num]\n        while p != par[p]:\n            p = par[p]\n        return p\n\n    def union(num1, num2):\n        p1, p2 = find(num1), find(num2)\n        if p1 == p2:\n            return\n\n        if rank[p1] &lt; rank[p2]:\n            par[p1] = p2\n            rank[p2] += rank[p1]\n        else:\n            par[p2] = p1\n            rank[p1] += rank[p2]\n\n    for num in nums:\n        if num - 1 in par:\n            union(num, num - 1)\n\n    return max(rank.values())\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# |  Set       |  O(N)  |  O(N)   |\n# | Union Find |  O(N)  |  O(N)   |\n# |------------|--------|---------|\n\n\nnums = [100, 4, 200, 1, 3, 2]\nprint(longestConsecutiveSet(nums))  # 4\nprint(longestConsecutiveUF(nums))  # 4\n</code></pre>"},{"location":"neetcode150/backtracking/","title":"Backtracking","text":"<ul> <li> 78. Subsets (Medium)</li> <li> 39. Combination Sum (Medium)</li> <li> 40. Combination Sum II (Medium)</li> <li> 46. Permutations (Medium)</li> <li> 90. Subsets II (Medium)</li> <li> 79. Word Search (Medium)</li> <li> 131. Palindrome Partitioning (Medium)</li> <li> 17. Letter Combinations of a Phone Number (Medium)</li> <li> 51. N-Queens (Hard)</li> </ul>"},{"location":"neetcode150/backtracking/#78-subsets","title":"78. Subsets","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking, bit manipulation</p> </li> </ul> 78. Subsets - Python Solution<pre><code>from typing import List\n\n\ndef subsets(nums: List[int]) -&gt; List[List[int]]:\n    path, result = [], []\n\n    def backtracking(startIndex):\n        result.append(path[:])\n\n        for i in range(startIndex, len(nums)):\n            path.append(nums[i])\n            backtracking(i + 1)\n            path.pop()\n\n    backtracking(startIndex=0)\n\n    return result\n\n\nprint(subsets([1, 2, 3]))\n# [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]\n</code></pre>"},{"location":"neetcode150/backtracking/#39-combination-sum","title":"39. Combination Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking</p> </li> </ul> 39. Combination Sum - Python Solution<pre><code>from typing import List\n\n\ndef combinationSum(candidates: List[int], target: int) -&gt; List[List[int]]:\n    result = []\n    path = []\n\n    def backtracking(total, start):\n        if total &gt; target:\n            return None\n        if total == target:\n            result.append(path[:])\n            return None\n\n        for i in range(start, len(candidates)):\n            total += candidates[i]\n            path.append(candidates[i])\n\n            backtracking(total, i)\n\n            total -= candidates[i]\n            path.pop()\n\n    backtracking(0, 0)\n    return result\n\n\nprint(combinationSum([2, 3, 6, 7], 7))  # [[2, 2, 3], [7]]\n</code></pre>"},{"location":"neetcode150/backtracking/#40-combination-sum-ii","title":"40. Combination Sum II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking</p> </li> </ul> 40. Combination Sum II - Python Solution<pre><code>from typing import List\n\n\ndef combinationSum2(candidates: List[int], target: int) -&gt; List[List[int]]:\n    result, path = [], []\n    candidates.sort()\n\n    def backtracking(total, start):\n        if total == target:\n            result.append(path[:])\n            return None\n\n        for i in range(start, len(candidates)):\n\n            if i &gt; start and candidates[i] == candidates[i - 1]:\n                continue\n\n            if total + candidates[i] &gt; target:\n                break\n\n            total += candidates[i]\n            path.append(candidates[i])\n            backtracking(total, i + 1)\n            total -= candidates[i]\n            path.pop()\n\n    backtracking(0, 0)\n\n    return result\n\n\nprint(combinationSum2([10, 1, 2, 7, 6, 1, 5], 8))\n# [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n</code></pre>"},{"location":"neetcode150/backtracking/#46-permutations","title":"46. Permutations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking</p> </li> </ul> 46. Permutations - Python Solution<pre><code>from typing import List\n\n\ndef permute(nums: List[int]) -&gt; List[List[int]]:\n    path, result = [], []\n    used = [False for _ in range(len(nums))]\n\n    def backtracking():\n        if len(path) == len(nums):\n            result.append(path[:])\n\n        for i in range(len(nums)):\n            if used[i]:\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtracking()\n            path.pop()\n            used[i] = False\n\n    backtracking()\n\n    return result\n\n\nprint(permute([1, 2, 3]))\n# [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n</code></pre>"},{"location":"neetcode150/backtracking/#90-subsets-ii","title":"90. Subsets II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, backtracking, bit manipulation</p> </li> </ul> 90. Subsets II - Python Solution<pre><code>from typing import List\n\n\ndef subsetsWithDup(nums: List[int]) -&gt; List[List[int]]:\n    path, result = [], []\n    nums.sort()\n\n    def backtracking(startIndex):\n        if path not in result:\n            result.append(path[:])\n\n        for i in range(startIndex, len(nums)):\n            path.append(nums[i])\n            backtracking(i + 1)\n            path.pop()\n\n    backtracking(startIndex=0)\n\n    return result\n\n\nprint(subsetsWithDup([1, 2, 2]))\n# [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]\n</code></pre>"},{"location":"neetcode150/backtracking/#79-word-search","title":"79. Word Search","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, backtracking, depth first search, matrix</p> </li> </ul> 79. Word Search - Python Solution<pre><code>from typing import List\n\n\ndef exist(board: List[List[str]], word: str) -&gt; bool:\n    m, n = len(board), len(board[0])\n    path = set()\n    directions = ((0, 1), (1, 0), (0, -1), (-1, 0))\n\n    def dfs(r, c, i):\n        if i == len(word):\n            return True\n\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or board[r][c] != word[i]\n            or (r, c) in path\n        ):\n            return False\n\n        path.add((r, c))\n\n        for dr, dc in directions:\n            if dfs(r + dr, c + dc, i + 1):\n                return True\n\n        path.remove((r, c))\n        return False\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, 0):\n                return True\n\n    return False\n\n\nboard = [\n    [\"A\", \"B\", \"C\", \"E\"],\n    [\"S\", \"F\", \"C\", \"S\"],\n    [\"A\", \"D\", \"E\", \"E\"],\n]\nword = \"ABCCED\"\nprint(exist(board, word))  # True\n</code></pre>"},{"location":"neetcode150/backtracking/#131-palindrome-partitioning","title":"131. Palindrome Partitioning","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming, backtracking</p> </li> </ul> 131. Palindrome Partitioning - Python Solution<pre><code>from typing import List\n\n\n# Backtracking\ndef partition(s: str) -&gt; List[List[str]]:\n    res = []\n    n = len(s)\n\n    def backtrack(idx, path):\n        if idx == n:\n            res.append(path[:])\n            return None\n\n        for j in range(idx, n):\n            cur = s[idx : j + 1]\n            if cur == cur[::-1]:\n                path.append(cur)\n                backtrack(j + 1, path)\n                path.pop()\n\n    backtrack(0, [])\n\n    return res\n\n\nprint(partition(\"aab\"))  # [['a', 'a', 'b'], ['aa', 'b']]\n</code></pre>"},{"location":"neetcode150/backtracking/#17-letter-combinations-of-a-phone-number","title":"17. Letter Combinations of a Phone Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, backtracking</p> </li> </ul> 17. Letter Combinations of a Phone Number - Python Solution<pre><code>from typing import List\n\n\ndef letterCombinations(digits: str) -&gt; List[str]:\n    letterMap = [\n        \"\",  # 0\n        \"\",  # 1\n        \"abc\",  # 2\n        \"def\",  # 3\n        \"ghi\",  # 4\n        \"jkl\",  # 5\n        \"mno\",  # 6\n        \"pqrs\",  # 7\n        \"tuv\",  # 8\n        \"wxyz\",  # 9\n    ]\n    res = []\n\n    def backtracking(index, s):\n        if index == len(digits):\n            res.append(s)\n            return None\n\n        digit = int(digits[index])\n        letters = letterMap[digit]\n\n        for i in range(len(letters)):\n            backtracking(index + 1, s + letters[i])\n\n    if len(digits) == 0:\n        return res\n\n    backtracking(0, \"\")\n\n    return res\n\n\nprint(letterCombinations(\"23\"))\n# ['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf']\n</code></pre>"},{"location":"neetcode150/backtracking/#51-n-queens","title":"51. N-Queens","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, backtracking</p> </li> <li>Hard</li> <li>N-Queens</li> <li>N \u7687\u540e</li> </ul> 51. N-Queens - Python Solution<pre><code>from typing import List\n\n\n# Backtracking - Board\ndef solveNQueens(n: int) -&gt; List[List[str]]:\n    result = []\n    chessboard = [\".\" * n for _ in range(n)]\n\n    def backtracking(row):\n        if row == n:\n            result.append(chessboard[:])\n            return None\n        for col in range(n):\n            if is_valid(row, col, chessboard):\n                chessboard[row] = (\n                    chessboard[row][:col] + \"Q\" + chessboard[row][col + 1 :]\n                )\n                backtracking(row + 1)\n                chessboard[row] = (\n                    chessboard[row][:col] + \".\" + chessboard[row][col + 1 :]\n                )\n\n    def is_valid(row, col, chessboard):\n        for i in range(row):\n            if chessboard[i][col] == \"Q\":\n                return False\n\n        i, j = row - 1, col - 1\n        while i &gt;= 0 and j &gt;= 0:\n            if chessboard[i][j] == \"Q\":\n                return False\n            i -= 1\n            j -= 1\n\n        i, j = row - 1, col + 1\n        while i &gt;= 0 and j &lt; len(chessboard):\n            if chessboard[i][j] == \"Q\":\n                return False\n            i -= 1\n            j += 1\n\n        return True\n\n    backtracking(0)\n\n    return [[\"\".join(row) for row in solution] for solution in result]\n\n\nprint(solveNQueens(4))\n# [['.Q..', '...Q', 'Q...', '..Q.'],\n#  ['..Q.', 'Q...', '...Q', '.Q..']]\n</code></pre>"},{"location":"neetcode150/binary_search/","title":"Binary Search","text":"<ul> <li> 704. Binary Search (Easy)</li> <li> 74. Search a 2D Matrix (Medium)</li> <li> 875. Koko Eating Bananas (Medium)</li> <li> 153. Find Minimum in Rotated Sorted Array (Medium)</li> <li> 33. Search in Rotated Sorted Array (Medium)</li> <li> 981. Time Based Key-Value Store (Medium)</li> <li> 4. Median of Two Sorted Arrays (Hard)</li> </ul>"},{"location":"neetcode150/binary_search/#704-binary-search","title":"704. Binary Search","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, binary search</p> </li> <li>Implement binary search algorithm.</li> </ul> 704. Binary Search - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef search(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] &lt; target:\n            left = mid + 1\n        elif nums[mid] &gt; target:\n            right = mid - 1\n        else:\n            return mid\n\n    return -1\n\n\nnums = [-1, 0, 3, 5, 9, 12]\ntarget = 9\nprint(search(nums, target))  # 4\n</code></pre>"},{"location":"neetcode150/binary_search/#74-search-a-2d-matrix","title":"74. Search a 2D Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, matrix</p> </li> </ul> 74. Search a 2D Matrix - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef searchMatrix(matrix: List[List[int]], target: int) -&gt; bool:\n    if not matrix or not matrix[0]:\n        return False\n\n    m, n = len(matrix), len(matrix[0])\n    left, right = 0, m * n - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n        mid_value = matrix[mid // n][mid % n]\n\n        if mid_value == target:\n            return True\n        elif mid_value &lt; target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\n\nmatrix = [[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]]\ntarget = 3\nprint(searchMatrix(matrix, target))  # True\n</code></pre>"},{"location":"neetcode150/binary_search/#875-koko-eating-bananas","title":"875. Koko Eating Bananas","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> <li>Koko loves to eat bananas. She wants to eat all the bananas within <code>H</code> hours. Each pile has a number of bananas. The <code>i-th</code> pile has <code>piles[i]</code> bananas. Return the minimum integer <code>K</code> such that she can eat all the bananas within <code>H</code> hours.</li> </ul> 875. Koko Eating Bananas - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef minEatingSpeed(piles: List[int], h: int) -&gt; int:\n    def canEat(piles, k, h):\n        hours = 0\n        for pile in piles:\n            hours += (pile + k - 1) // k\n        return hours &lt;= h\n\n    left, right = 1, max(piles)\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if canEat(piles, mid, h):\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return left\n\n\npiles = [3, 6, 7, 11]\nh = 8\nprint(minEatingSpeed(piles, h))  # 4\n</code></pre>"},{"location":"neetcode150/binary_search/#153-find-minimum-in-rotated-sorted-array","title":"153. Find Minimum in Rotated Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul> 153. Find Minimum in Rotated Sorted Array - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef findMin(nums: List[int]) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt; right:\n        mid = left + (right - left) // 2\n        if nums[mid] &gt; nums[right]:\n            left = mid + 1\n        else:\n            right = mid\n\n    return nums[right]\n\n\nnums = [4, 5, 6, 7, 0, 1, 2]\nprint(findMin(nums))  # 0\n</code></pre>"},{"location":"neetcode150/binary_search/#33-search-in-rotated-sorted-array","title":"33. Search in Rotated Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul> 33. Search in Rotated Sorted Array - Python Solution<pre><code>from typing import List\n\n\n# Binary Search\ndef search(nums: List[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] == target:\n            return mid\n\n        if nums[left] &lt;= nums[mid]:\n            if nums[left] &lt;= target &lt; nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if nums[mid] &lt; target &lt;= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n    return -1\n\n\nnums = [4, 5, 6, 7, 0, 1, 2]\ntarget = 0\nprint(search(nums, target))  # 4\n</code></pre>"},{"location":"neetcode150/binary_search/#981-time-based-key-value-store","title":"981. Time Based Key-Value Store","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, binary search, design</p> </li> </ul> 981. Time Based Key-Value Store - Python Solution<pre><code>from collections import defaultdict\n\n\n# Binary Search\nclass TimeMap:\n\n    def __init__(self):\n        self.keys = defaultdict(list)\n        self.times = dict()\n\n    def set(self, key: str, value: str, timestamp: int) -&gt; None:\n        self.keys[key].append(timestamp)\n        self.times[timestamp] = value\n\n    def get(self, key: str, timestamp: int) -&gt; str:\n        tmp = self.keys[key]\n\n        left, right = 0, len(tmp) - 1\n        while left &lt;= right:\n            mid = left + (right - left) // 2\n            if tmp[mid] &gt; timestamp:\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        return self.times[tmp[right]] if right &gt;= 0 else \"\"\n\n\nobj = TimeMap()\nobj.set(\"foo\", \"bar\", 1)\nprint(obj.get(\"foo\", 1))  # bar\nprint(obj.get(\"foo\", 3))  # bar\nobj.set(\"foo\", \"bar2\", 4)\nprint(obj.get(\"foo\", 4))  # bar2\nprint(obj.get(\"foo\", 5))  # bar2\n</code></pre>"},{"location":"neetcode150/binary_search/#4-median-of-two-sorted-arrays","title":"4. Median of Two Sorted Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, divide and conquer</p> </li> </ul> 4. Median of Two Sorted Arrays - Python Solution<pre><code>from typing import List\n\n\n# Brute Force\ndef findMedianSortedArraysBF(nums1: List[int], nums2: List[int]) -&gt; float:\n    nums = sorted(nums1 + nums2)\n    n = len(nums)\n    if n % 2 == 0:\n        return (nums[n // 2 - 1] + nums[n // 2]) / 2\n    else:\n        return nums[n // 2]\n\n\n# Binary Search\ndef findMedianSortedArraysBS(nums1: List[int], nums2: List[int]) -&gt; float:\n    if len(nums1) &gt; len(nums2):\n        nums1, nums2 = nums2, nums1\n\n    m, n = len(nums1), len(nums2)\n    imin, imax, half_len = 0, m, (m + n + 1) // 2\n\n    while imin &lt;= imax:\n        i = (imin + imax) // 2\n        j = half_len - i\n\n        if i &lt; m and nums2[j - 1] &gt; nums1[i]:\n            imin = i + 1\n        elif i &gt; 0 and nums1[i - 1] &gt; nums2[j]:\n            imax = i - 1\n        else:\n            if i == 0:\n                max_of_left = nums2[j - 1]\n            elif j == 0:\n                max_of_left = nums1[i - 1]\n            else:\n                max_of_left = max(nums1[i - 1], nums2[j - 1])\n\n            if (m + n) % 2 == 1:\n                return max_of_left\n\n            if i == m:\n                min_of_right = nums2[j]\n            elif j == n:\n                min_of_right = nums1[i]\n            else:\n                min_of_right = min(nums1[i], nums2[j])\n\n            return (max_of_left + min_of_right) / 2\n\n\n# |--------------|-----------------|--------------|\n# | Approach     | Time            | Space        |\n# |--------------|-----------------|--------------|\n# | Brute Force  | O((n+m)log(n+m))| O(n+m)       |\n# | Binary Search| O(log(min(n,m)))| O(1)         |\n# |--------------|-----------------|--------------|\n\n\nnums1 = [1, 3]\nnums2 = [2]\nprint(findMedianSortedArraysBF(nums1, nums2))  # 2.0\nprint(findMedianSortedArraysBS(nums1, nums2))  # 2.0\n</code></pre>"},{"location":"neetcode150/bit_manipulation/","title":"Bit Manipulation","text":"<ul> <li> 136. Single Number (Easy)</li> <li> 191. Number of 1 Bits (Easy)</li> <li> 338. Counting Bits (Easy)</li> <li> 190. Reverse Bits (Easy)</li> <li> 268. Missing Number (Easy)</li> <li> 371. Sum of Two Integers (Medium)</li> <li> 7. Reverse Integer (Medium)</li> </ul>"},{"location":"neetcode150/bit_manipulation/#136-single-number","title":"136. Single Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, bit manipulation</p> </li> </ul>"},{"location":"neetcode150/bit_manipulation/#191-number-of-1-bits","title":"191. Number of 1 Bits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: divide and conquer, bit manipulation</p> </li> </ul> 191. Number of 1 Bits - Python Solution<pre><code># Bit Manipulation\ndef hammingWeight1(n: int) -&gt; int:\n    res = 0\n\n    while n != 0:\n        n = n &amp; (n - 1)  # Unset the rightmost 1-bit\n        res += 1\n\n    return res\n\n\ndef hammingWeight2(n: int) -&gt; int:\n    return bin(n).count(\"1\")\n\n\ndef hammingWeight3(n: int) -&gt; int:\n    def decimalToBinary(n: int) -&gt; str:\n        if n == 0:\n            return \"0\"\n\n        binary = \"\"\n        while n &gt; 0:\n            binary = str(n % 2) + binary\n            n //= 2\n\n        return binary\n\n    binary = decimalToBinary(n)\n\n    return binary.count(\"1\")\n\n\nn = 11\nprint(hammingWeight1(n))  # 3\nprint(hammingWeight2(n))  # 3\n\nn = 47\nprint(bin(n))\n</code></pre>"},{"location":"neetcode150/bit_manipulation/#338-counting-bits","title":"338. Counting Bits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: dynamic programming, bit manipulation</p> </li> </ul> 338. Counting Bits - Python Solution<pre><code>from typing import List\n\n\n# Bit Manipulation\ndef countBits(n: int) -&gt; List[int]:\n    bits = [0 for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        bits[i] = bits[i &gt;&gt; 1] + (i &amp; 1)\n\n    return bits\n\n\nn = 5\nprint(countBits(n))  # [0, 1, 1, 2, 1, 2]\n</code></pre>"},{"location":"neetcode150/bit_manipulation/#190-reverse-bits","title":"190. Reverse Bits","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: divide and conquer, bit manipulation</p> </li> </ul> 190. Reverse Bits - Python Solution<pre><code># Bit Manipulation\ndef reverseBits(n: int) -&gt; int:\n    res = 0\n\n    for i in range(32):\n        res = (res &lt;&lt; 1) | (n &amp; 1)\n        n &gt;&gt;= 1\n\n    return res\n\n\nn = 0b00000010100101000001111010011100\nprint(reverseBits(n))  # 964176192\n</code></pre>"},{"location":"neetcode150/bit_manipulation/#268-missing-number","title":"268. Missing Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, math, binary search, bit manipulation, sorting</p> </li> </ul> 268. Missing Number - Python Solution<pre><code>from typing import List\n\n\n# Math\ndef missingNumberMath(nums: List[int]) -&gt; int:\n    n = len(nums)\n    return (n * (n + 1)) // 2 - sum(nums)\n\n\n# Bit Manipulation (XOR)\ndef missingNumberXOR(nums: List[int]) -&gt; int:\n    n = len(nums)\n\n    for i, num in enumerate(nums):\n        n ^= i ^ num\n\n    return n\n\n\nnums = [3, 0, 1]\nprint(missingNumberMath(nums))  # 2\nprint(missingNumberXOR(nums))  # 2\n</code></pre>"},{"location":"neetcode150/bit_manipulation/#371-sum-of-two-integers","title":"371. Sum of Two Integers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, bit manipulation</p> </li> </ul> 371. Sum of Two Integers - Python Solution<pre><code># Bit Manipulation\ndef getSum(a: int, b: int) -&gt; int:\n    MASK = 0xFFFFFFFF\n    MAX_INT = 0x7FFFFFFF\n\n    while b != 0:\n        temp = (a ^ b) &amp; MASK\n        b = ((a &amp; b) &lt;&lt; 1) &amp; MASK\n        a = temp\n\n    return a if a &lt;= MAX_INT else ~(a ^ MASK)\n\n\nprint(getSum(1, 2))  # 3\n</code></pre>"},{"location":"neetcode150/bit_manipulation/#7-reverse-integer","title":"7. Reverse Integer","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math</p> </li> </ul> 7. Reverse Integer - Python Solution<pre><code># Math\ndef reverse(x: int) -&gt; int:\n    INT_MAX = 2**31 - 1\n\n    sign = -1 if x &lt; 0 else 1\n    x = abs(x)\n    res = 0\n\n    while x != 0:\n        x, pop = divmod(x, 10)\n\n        if res &gt; (INT_MAX - pop) // 10:\n            return 0\n\n        res = res * 10 + pop\n\n    return res * sign\n\n\nprint(reverse(123))  # 321\nprint(reverse(-123))  # -321\n</code></pre>"},{"location":"neetcode150/graphs/","title":"Graphs","text":"<ul> <li> 200. Number of Islands (Medium)</li> <li> 695. Max Area of Island (Medium)</li> <li> 133. Clone Graph (Medium)</li> <li> 286. Walls and Gates (Medium)</li> <li> 994. Rotting Oranges (Medium)</li> <li> 417. Pacific Atlantic Water Flow (Medium)</li> <li> 130. Surrounded Regions (Medium)</li> <li> 207. Course Schedule (Medium)</li> <li> 210. Course Schedule II (Medium)</li> <li> 261. Graph Valid Tree (Medium)</li> <li> 323. Number of Connected Components in an Undirected Graph (Medium)</li> <li> 684. Redundant Connection (Medium)</li> <li> 127. Word Ladder (Hard)</li> </ul>"},{"location":"neetcode150/graphs/#200-number-of-islands","title":"200. Number of Islands","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix</p> </li> <li>Count the number of islands in a 2D grid.</li> <li>Method 1: DFS</li> <li> <p>Method 2: BFS (use a queue to traverse the grid)</p> </li> <li> <p>How to keep track of visited cells?</p> <ol> <li>Mark the visited cell as <code>0</code> (or any other value) to avoid revisiting it.</li> <li>Use a set to store the visited cells.</li> </ol> </li> <li> <p>Steps:</p> <ol> <li>Init: variables</li> <li>DFS/BFS: starting from the cell with <code>1</code>, turn all the connected <code>1</code>s to <code>0</code>.</li> <li>Traverse the grid, and if the cell is <code>1</code>, increment the count and call DFS/BFS.</li> </ol> </li> </ul> <p></p> 200. Number of Islands - Python Solution<pre><code>from collections import deque\nfrom copy import deepcopy\nfrom typing import List\n\n\n# DFS\ndef numIslandsDFS(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    res = 0\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] != \"1\":\n            return\n\n        grid[r][c] = \"2\"\n\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\":\n                dfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Set\ndef numIslandsBFS1(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == \"0\"\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == \"1\" and (r, c) not in visited:\n                visited.add((r, c))\n                bfs(r, c)\n                res += 1\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = dr + row, dc + col\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] != \"1\"\n                ):\n                    continue\n                grid[nr][nc] = \"2\"\n                q.append((nr, nc))\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == \"1\":\n                grid[i][j] = \"2\"\n                bfs(i, j)\n                res += 1\n\n    return res\n\n\ngrid = [\n    [\"1\", \"1\", \"1\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"0\", \"0\", \"0\", \"0\", \"0\"],\n]\n\nprint(numIslandsDFS(deepcopy(grid)))  # 1\nprint(numIslandsBFS1(deepcopy(grid)))  # 1\nprint(numIslandsBFS2(deepcopy(grid)))  # 1\n</code></pre>"},{"location":"neetcode150/graphs/#695-max-area-of-island","title":"695. Max Area of Island","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix</p> </li> </ul> 695. Max Area of Island - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef maxAreaOfIslandDFS(grid: List[List[int]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n\n    def dfs(r, c):\n        if r &lt; 0 or r &gt;= m or c &lt; 0 or c &gt;= n or grid[r][c] != 1:\n            return 0\n\n        grid[r][c] = 2\n\n        return (\n            1 + dfs(r - 1, c) + dfs(r + 1, c) + dfs(r, c + 1) + dfs(r, c - 1)\n        )\n\n    area = 0\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                area = max(area, dfs(r, c))\n\n    return area\n\n\n# BFS\ndef maxAreaOfIslandBFS1(grid: List[List[int]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = set()\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        area = 0\n\n        while q:\n            row, col = q.popleft()\n            area += 1\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr &lt; 0\n                    or nr &gt;= m\n                    or nc &lt; 0\n                    or nc &gt;= n\n                    or grid[nr][nc] == 0\n                    or (nr, nc) in visited\n                ):\n                    continue\n\n                visited.add((nr, nc))\n                q.append((nr, nc))\n\n        return area\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1 and (r, c) not in visited:\n                visited.add((r, c))\n                res = max(res, bfs(r, c))\n\n    return res\n\n\n# BFS + Grid\ndef numIslandsBFS2(grid: List[List[str]]) -&gt; int:\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    res = 0\n\n    def bfs(r, c):\n        q = deque([(r, c)])\n        area = 0\n\n        while q:\n            row, col = q.popleft()\n            area += 1\n\n            for dr, dc in dirs:\n                nr, nc = row + dr, col + dc\n\n                if nr &lt; 0 or nr &gt;= m or nc &lt; 0 or nc &gt;= n or grid[nr][nc] == 0:\n                    continue\n\n                q.append((nr, nc))\n                grid[nr][nc] = 0\n\n        return area\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                grid[r][c] = 0\n                res = max(res, bfs(r, c))\n\n    return res\n\n\ngrid = [\n    [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0],\n    [0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],\n]\nprint(maxAreaOfIslandDFS(grid))  # 6\nprint(maxAreaOfIslandBFS1(grid))  # 6\nprint(numIslandsBFS2(grid))  # 6\n</code></pre>"},{"location":"neetcode150/graphs/#133-clone-graph","title":"133. Clone Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, depth first search, breadth first search, graph</p> </li> </ul> 133. Clone Graph - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\n\nclass Node:\n    def __init__(self, val=0, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\n\n# 1. DFS\ndef cloneGraphDFS(node: Optional[\"Node\"]) -&gt; Optional[\"Node\"]:\n    if not node:\n        return None\n\n    cloned = {}  # {old: new}\n\n    def dfs(node):\n        if node in cloned:\n            return cloned[node]\n\n        new = Node(node.val)\n        cloned[node] = new\n\n        for neighbor in node.neighbors:\n            new.neighbors.append(dfs(neighbor))\n\n        return new\n\n    return dfs(node)\n\n\n# 2. BFS\ndef cloneGraphBFS(node: Optional[\"Node\"]) -&gt; Optional[\"Node\"]:\n    if not node:\n        return None\n\n    cloned = {node: Node(node.val)}\n    q = deque([node])\n\n    while q:\n        cur = q.popleft()\n\n        for neighbor in cur.neighbors:\n            if neighbor not in cloned:\n                cloned[neighbor] = Node(neighbor.val)\n                q.append(neighbor)\n\n            cloned[cur].neighbors.append(cloned[neighbor])\n\n    return cloned[node]\n</code></pre>"},{"location":"neetcode150/graphs/#286-walls-and-gates","title":"286. Walls and Gates","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, breadth first search, matrix </p> </li> </ul> 286. Walls and Gates - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# Multi-source BFS\ndef wallsAndGates(rooms: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify rooms in-place instead.\n    \"\"\"\n    m, n = len(rooms), len(rooms[0])\n    visited = set()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def addRoom(r, c):\n        if (\n            r in range(m)\n            and c in range(n)\n            and (r, c) not in visited\n            and rooms[r][c] != -1\n        ):\n            q.append((r, c))\n            visited.add((r, c))\n\n    q = deque()\n    for r in range(m):\n        for c in range(n):\n            if rooms[r][c] == 0:\n                q.append((r, c))\n                visited.add((r, c))\n\n    dist = 0\n\n    while q:\n        for _ in range(len(q)):\n            r, c = q.popleft()\n            rooms[r][c] = dist\n\n            for dr, dc in directions:\n                addRoom(r + dr, c + dc)\n        dist += 1\n\n\nrooms = [\n    [2147483647, -1, 0, 2147483647],\n    [2147483647, 2147483647, 2147483647, -1],\n    [2147483647, -1, 2147483647, -1],\n    [0, -1, 2147483647, 2147483647],\n]\nwallsAndGates(rooms)\nprint(rooms)\n# [[3, -1, 0,  1],\n#  [2,  2, 1, -1],\n#  [1, -1, 2, -1],\n#  [0, -1, 3,  4]]\n</code></pre>"},{"location":"neetcode150/graphs/#994-rotting-oranges","title":"994. Rotting Oranges","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, breadth first search, matrix</p> </li> <li>Return the minimum number of minutes that must elapse until no cell has a fresh orange.</li> <li>Hint: Multi-source BFS to count the level.</li> </ul> <p></p> 994. Rotting Oranges - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# BFS\ndef orangesRotting(grid: List[List[int]]) -&gt; int:\n    # 1. Init\n    q = deque()\n    time, fresh = 0, 0\n    m, n = len(grid), len(grid[0])\n    dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n\n    # 2. Make a queue of rotten oranges and count fresh oranges\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] == 1:\n                fresh += 1\n            if grid[r][c] == 2:\n                q.append([r, c])\n\n    # 3. BFS\n    while q and fresh &gt; 0:\n        size = len(q)\n\n        for _ in range(size):\n            r, c = q.popleft()\n\n            for dr, dc in dirs:\n                nr, nc = r + dr, c + dc\n                if nr &lt; 0 or nc &lt; 0 or nr &gt;= m or nc &gt;= n or grid[nr][nc] != 1:\n                    continue\n                grid[nr][nc] = 2\n                q.append([nr, nc])\n                fresh -= 1\n        time += 1\n\n    return time if fresh == 0 else -1\n\n\ngrid = [[2, 1, 1], [1, 1, 0], [0, 1, 1]]\nprint(orangesRotting(grid))\n</code></pre>"},{"location":"neetcode150/graphs/#417-pacific-atlantic-water-flow","title":"417. Pacific Atlantic Water Flow","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, matrix</p> </li> </ul> 417. Pacific Atlantic Water Flow - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# DFS\ndef pacificAtlanticDFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(r, c, visited, prev_height):\n        if (\n            r not in range(m)\n            or c not in range(n)\n            or heights[r][c] &lt; prev_height\n            or (r, c) in visited\n        ):\n            return None\n\n        visited.add((r, c))\n        height = heights[r][c]\n        for dr, dc in directions:\n            dfs(dr + r, dc + c, visited, height)\n\n    for c in range(n):\n        dfs(0, c, pac, heights[0][c])\n        dfs(m - 1, c, atl, heights[m - 1][c])\n\n    for r in range(m):\n        dfs(r, 0, pac, heights[r][0])\n        dfs(r, n - 1, atl, heights[r][n - 1])\n\n    return list(pac &amp; atl)\n\n\n# BFS\ndef pacificAtlanticBFS(heights: List[List[int]]) -&gt; List[List[int]]:\n    m, n = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def bfs(r, c, visited):\n        q = deque([(r, c)])\n        visited.add((r, c))\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr, nc = row + dr, col + dc\n\n                if (\n                    nr in range(m)\n                    and nc in range(n)\n                    and heights[row][col] &lt;= heights[nr][nc]\n                    and (nr, nc) not in visited\n                ):\n                    q.append((nr, nc))\n                    visited.add((nr, nc))\n\n    for c in range(n):\n        bfs(0, c, pac)  # top\n        bfs(m - 1, c, atl)  # bottom\n\n    for r in range(m):\n        bfs(r, 0, pac)  # left\n        bfs(r, n - 1, atl)  # right\n\n    return list(pac &amp; atl)\n\n\nheights = [\n    [1, 2, 2, 3, 5],\n    [3, 2, 3, 4, 4],\n    [2, 4, 5, 3, 1],\n    [6, 7, 1, 4, 5],\n    [5, 1, 1, 2, 4],\n]\nprint(pacificAtlanticDFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\nprint(pacificAtlanticBFS(heights))\n# [(4, 0), (0, 4), (3, 1), (1, 4), (3, 0), (2, 2), (1, 3)]\n</code></pre>"},{"location":"neetcode150/graphs/#130-surrounded-regions","title":"130. Surrounded Regions","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, union find, matrix</p> </li> </ul> 130. Surrounded Regions - Python Solution<pre><code>from collections import deque\nfrom copy import deepcopy\nfrom pprint import pprint\nfrom typing import List\n\n\n# 1. DFS\ndef solveDFS(board: List[List[str]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n    if not board and not board[0]:\n        return None\n\n    m, n = len(board), len(board[0])\n\n    def capture(r, c):\n        if r not in range(m) or c not in range(n) or board[r][c] != \"O\":\n            return None\n\n        board[r][c] = \"T\"\n        capture(r + 1, c)\n        capture(r - 1, c)\n        capture(r, c + 1)\n        capture(r, c - 1)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\" and (r in [0, m - 1] or c in [0, n - 1]):\n                capture(r, c)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\":\n                board[r][c] = \"X\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"T\":\n                board[r][c] = \"O\"\n\n\n# 2. BFS\ndef solveBFS(board: List[List[str]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify board in-place instead.\n    \"\"\"\n    if not board and not board[0]:\n        return None\n\n    m, n = len(board), len(board[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def capture(r, c):\n        q = deque([(r, c)])\n\n        while q:\n            row, col = q.popleft()\n\n            for dr, dc in directions:\n                nr = row + dr\n                nc = col + dc\n                if nr in range(m) and nc in range(n) and board[nr][nc] == \"O\":\n                    q.append((nr, nc))\n                    board[nr][nc] = \"T\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\" and (r in [0, m - 1] or c in [0, n - 1]):\n                board[r][c] = \"T\"\n                capture(r, c)\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"O\":\n                board[r][c] = \"X\"\n\n    for r in range(m):\n        for c in range(n):\n            if board[r][c] == \"T\":\n                board[r][c] = \"O\"\n\n\nboard = [\n    [\"X\", \"X\", \"X\", \"X\"],\n    [\"X\", \"O\", \"O\", \"X\"],\n    [\"X\", \"X\", \"O\", \"X\"],\n    [\"X\", \"O\", \"X\", \"X\"],\n]\nboard1 = deepcopy(board)\nsolveDFS(board1)\npprint(board1)\n# [['X', 'X', 'X', 'X'],\n#  ['X', 'X', 'X', 'X'],\n#  ['X', 'X', 'X', 'X'],\n#  ['X', 'O', 'X', 'X']]\n\nboard2 = deepcopy(board)\nsolveBFS(board2)\npprint(board2)\n# [['X', 'X', 'X', 'X'],\n#  ['X', 'X', 'X', 'X'],\n#  ['X', 'X', 'X', 'X'],\n#  ['X', 'O', 'X', 'X']]\n</code></pre>"},{"location":"neetcode150/graphs/#207-course-schedule","title":"207. Course Schedule","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort</p> </li> <li>Return true if it is possible to finish all courses, otherwise return false.</li> <li>Dependency relationships imply the topological sort algorithm.</li> <li>Cycle detection</li> <li>Topological Sort<ul> <li>DAG (Directed Acyclic Graph)</li> <li>Time complexity: O(V+E)</li> <li>Space complexity: O(V+E)</li> <li>Prerequisites: Indegree (Look at the problem 1557. Minimum Number of Vertices to Reach All Nodes)<ul> <li>Indegree: Number of incoming edges to a vertex</li> </ul> </li> <li>Applications: task scheduling, course scheduling, build systems, dependency resolution, compiler optimization, etc.</li> </ul> </li> </ul> <p></p> <p></p> <p>Course to prerequisites mapping</p> <pre><code>flowchart LR\n    0((0)) --&gt; 1((1))\n    0((0)) --&gt; 2((2))\n    1((1)) --&gt; 3((3))\n    3((3)) --&gt; 4((4))\n    1((1)) --&gt; 4((4))</code></pre> <p>Prerequisites to course mapping</p> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    2((2)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))\n    4((4)) --&gt; 3((3))\n    4((4)) --&gt; 1((1))</code></pre> course 0 0 1 1 3 prerequisite 1 2 3 4 4 index 0 1 2 3 4 in-degree 0 0 0 0 0 <p>Initialize</p> <ul> <li>graph</li> </ul> prerequisite 1 2 3 4 course <code>[0]</code> <code>[0]</code> <code>[1]</code> <code>[1, 3]</code> <ul> <li>in-degree</li> </ul> 0 1 2 3 4 in-degree 2 2 0 1 0 <ul> <li>queue: <code>[2, 4]</code></li> <li>pop <code>2</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))\n    4((4)) --&gt; 3((3))\n    4((4)) --&gt; 1((1))</code></pre> 0 1 2 3 4 in-degree 1 2 0 1 0 <ul> <li>queue: <code>[4]</code></li> <li>pop <code>4</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))\n    3((3)) --&gt; 1((1))</code></pre> 0 1 2 3 4 in-degree 1 1 0 0 0 <ul> <li>queue: <code>[3]</code></li> <li>pop <code>3</code> from the queue</li> </ul> <pre><code>flowchart LR\n    1((1)) --&gt; 0((0))</code></pre> 0 1 2 3 4 in-degree 1 0 0 0 0 <ul> <li>queue: <code>[1]</code></li> <li>pop <code>1</code> from the queue</li> </ul> <pre><code>flowchart LR\n    0((0))</code></pre> 0 1 2 3 4 in-degree 0 0 0 0 0 <ul> <li>queue: <code>[0]</code></li> <li>pop <code>0</code> from the queue</li> <li>All courses are taken. Return <code>True</code>.</li> </ul> 207. Course Schedule - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS (Kahn's Algorithm)\ndef canFinishBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    count = 0\n\n    while q:\n        crs = q.popleft()\n        count += 1\n\n        for nxt in graph[crs]:\n            indegree[nxt] -= 1\n\n            if indegree[nxt] == 0:\n                q.append(nxt)\n\n    return count == numCourses\n\n\n# DFS + Set\ndef canFinishDFS1(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for crs, pre in prerequisites:\n        graph[crs].append(pre)\n\n    visiting = set()\n\n    def dfs(crs):\n        if crs in visiting:  # cycle detected\n            return False\n        if graph[crs] == []:\n            return True\n\n        visiting.add(crs)\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        visiting.remove(crs)\n        graph[crs] = []\n\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\n# DFS + List\ndef canFinishDFS2(numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\n    graph = defaultdict(list)\n    for pre, crs in prerequisites:\n        graph[crs].append(pre)\n\n    # 0: init, 1: visiting, 2: visited\n    status = [0] * numCourses\n\n    def dfs(crs):\n        if status[crs] == 1:  # cycle detected\n            return False\n        if status[crs] == 2:\n            return True\n\n        status[crs] = 1\n\n        for pre in graph[crs]:\n            if not dfs(pre):\n                return False\n\n        status[crs] = 2\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return False\n    return True\n\n\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(canFinishBFS(5, prerequisites))  # True\nprint(canFinishDFS1(5, prerequisites))  # True\nprint(canFinishDFS2(5, prerequisites))  # True\n</code></pre>"},{"location":"neetcode150/graphs/#210-course-schedule-ii","title":"210. Course Schedule II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, graph, topological sort</p> </li> <li>Return the ordering of courses you should take to finish all courses. If there are multiple valid answers, return any of them.</li> </ul> <p></p> 210. Course Schedule II - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# 1. BFS - Kahn's Algorithm\ndef findOrderBFS(numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]:\n    graph = defaultdict(list)\n    indegree = defaultdict(int)\n\n    for crs, pre in prerequisites:\n        graph[pre].append(crs)\n        indegree[crs] += 1\n\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    order = []\n\n    while q:\n        pre = q.popleft()\n        order.append(pre)\n\n        for crs in graph[pre]:\n            indegree[crs] -= 1\n            if indegree[crs] == 0:\n                q.append(crs)\n\n    return order if len(order) == numCourses else []\n\n\n# 2. DFS + Set\ndef findOrderDFS1(\n    numCourses: int, prerequisites: List[List[int]]\n) -&gt; List[int]:\n    adj = defaultdict(list)\n    for crs, pre in prerequisites:\n        adj[crs].append(pre)\n\n    visit, cycle = set(), set()\n    order = []\n\n    def dfs(crs):\n        if crs in cycle:\n            return False\n        if crs in visit:\n            return True\n\n        cycle.add(crs)\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        cycle.remove(crs)\n        visit.add(crs)\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order\n\n\n# 3. DFS + List\ndef findOrderDFS2(\n    numCourses: int, prerequisites: List[List[int]]\n) -&gt; List[int]:\n    adj = defaultdict(list)\n    for pre, crs in prerequisites:\n        adj[crs].append(pre)\n\n    # 0: not visited, 1: visiting, 2: visited\n    state = [0] * numCourses\n    order = []\n\n    def dfs(crs):\n        if state[crs] == 1:\n            return False\n        if state[crs] == 2:\n            return True\n\n        state[crs] = 1\n\n        for pre in adj[crs]:\n            if not dfs(pre):\n                return False\n\n        state[crs] = 2\n        order.append(crs)\n        return True\n\n    for crs in range(numCourses):\n        if not dfs(crs):\n            return []\n\n    return order[::-1]\n\n\nnumCourses = 5\nprerequisites = [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]\nprint(findOrderBFS(numCourses, prerequisites))  # [2, 4, 3, 1, 0]\nprint(findOrderDFS1(numCourses, prerequisites))  # [4, 3, 1, 2, 0]\nprint(findOrderDFS2(numCourses, prerequisites))  # [4, 3, 2, 1, 0]\n</code></pre>"},{"location":"neetcode150/graphs/#261-graph-valid-tree","title":"261. Graph Valid Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> </ul> 261. Graph Valid Tree - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Graph\ndef validTree(n: int, edges: List[List[int]]) -&gt; bool:\n    if n == 0:\n        return False\n    if len(edges) != n - 1:\n        return False\n\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = set()\n\n    def dfs(node, parent):\n        if node in visited:\n            return False\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor != parent and not dfs(neighbor, node):\n                return False\n        return True\n\n    return dfs(0, -1) and len(visited) == n\n\n\nprint(validTree(5, [[0, 1], [0, 2], [0, 3], [1, 4]]))  # True\nprint(validTree(5, [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]))  # False\n</code></pre>"},{"location":"neetcode150/graphs/#323-number-of-connected-components-in-an-undirected-graph","title":"323. Number of Connected Components in an Undirected Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> </ul> 323. Number of Connected Components in an Undirected Graph - Python Solution<pre><code>from typing import List\n\n\n# Union Find\ndef countComponents(n: int, edges: List[List[int]]) -&gt; int:\n    uf = UnionFind(n)\n    count = n\n\n    for u, v in edges:\n        count -= uf.union(u, v)\n\n    return count\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(n)}\n        self.rank = {i: 1 for i in range(n)}\n\n    def find(self, n):\n        p = self.par[n]\n        while self.par[p] != p:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return 0\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.par[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.par[p1] = p2\n        else:\n            self.par[p2] = p1\n            self.rank[p1] += 1\n\n        return 1\n\n\nprint(countComponents(5, [[0, 1], [1, 2], [3, 4]]))  # 2\n</code></pre>"},{"location":"neetcode150/graphs/#684-redundant-connection","title":"684. Redundant Connection","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> </ul> 684. Redundant Connection - Python Solution<pre><code>from typing import List\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(1, n + 1)}\n        self.rank = {i: 1 for i in range(1, n + 1)}\n\n    def find(self, n):\n        p = self.par[n]\n        while self.par[p] != p:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return False\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.par[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.par[p1] = p2\n        else:\n            self.par[p2] = p1\n            self.rank[p1] += 1\n\n        return True\n\n\n# Union Find\ndef findRedundantConnectionUF(edges: List[List[int]]) -&gt; List[int]:\n    n = len(edges)\n    uf = UnionFind(n)\n\n    for u, v in edges:\n        if not uf.union(u, v):\n            return (u, v)\n\n\n# DFS\ndef findRedundantConnectionDFS(edges: List[List[int]]) -&gt; List[int]:\n    graph, cycle = {}, {}\n    for a, b in edges:\n        graph.setdefault(a, []).append(b)\n        graph.setdefault(b, []).append(a)\n\n    def dfs(node, parent):\n        if node in cycle:\n            for k in list(cycle.keys()):\n                if k == node:\n                    return True\n                del cycle[k]\n\n        cycle[node] = None\n        for child in graph[node]:\n            if child != parent and dfs(child, node):\n                return True\n        del cycle[node]\n        return False\n\n    dfs(edges[0][0], -1)\n    for a, b in edges[::-1]:\n        if a in cycle and b in cycle:\n            return (a, b)\n\n\nedges = [[1, 2], [1, 3], [2, 3]]\nprint(findRedundantConnectionUF(edges))  # (2, 3)\nprint(findRedundantConnectionDFS(edges))  # (2, 3)\n</code></pre>"},{"location":"neetcode150/graphs/#127-word-ladder","title":"127. Word Ladder","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, breadth first search</p> </li> <li>The most classic BFS problem.</li> <li>Return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.</li> </ul> Approach Time Space BFS O(n * m^2) O(n * m) 127. Word Ladder - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS\ndef ladderLength(beginWord: str, endWord: str, wordList: List[str]) -&gt; int:\n    if endWord not in wordList:\n        return 0\n\n    n = len(beginWord)\n    graph = defaultdict(list)  # pattern: words\n    wordList.append(beginWord)\n\n    for word in wordList:\n        for i in range(n):\n            pattern = word[:i] + \"*\" + word[i + 1 :]\n            graph[pattern].append(word)\n\n    visited = set([beginWord])\n    q = deque([beginWord])\n    res = 1\n\n    while q:\n        size = len(q)\n        for _ in range(size):\n            word = q.popleft()\n            if word == endWord:\n                return res\n\n            for i in range(n):\n                pattern = word[:i] + \"*\" + word[i + 1 :]\n                for neighbor in graph[pattern]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        q.append(neighbor)\n        res += 1\n\n    return 0\n\n\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]\nprint(ladderLength(beginWord, endWord, wordList))  # 5\n</code></pre>"},{"location":"neetcode150/greedy/","title":"Greedy","text":"<ul> <li> 53. Maximum Subarray (Medium)</li> <li> 55. Jump Game (Medium)</li> <li> 45. Jump Game II (Medium)</li> <li> 134. Gas Station (Medium)</li> <li> 846. Hand of Straights (Medium)</li> <li> 1899. Merge Triplets to Form Target Triplet (Medium)</li> <li> 763. Partition Labels (Medium)</li> <li> 678. Valid Parenthesis String (Medium)</li> </ul>"},{"location":"neetcode150/greedy/#53-maximum-subarray","title":"53. Maximum Subarray","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, divide and conquer, dynamic programming</p> </li> </ul> 53. Maximum Subarray - Python Solution<pre><code>from typing import List\n\n\n# DP - Kadane\ndef maxSubArrayDP(nums: List[int]) -&gt; int:\n    dp = [0 for _ in range(len(nums))]\n\n    dp[0] = nums[0]\n    maxSum = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(\n            dp[i - 1] + nums[i],  # continue the previous subarray\n            nums[i],  # start a new subarray\n        )\n        maxSum = max(maxSum, dp[i])\n\n    return maxSum\n\n\n# Greedy\ndef maxSubArrayGreedy(nums: List[int]) -&gt; int:\n    max_sum = nums[0]\n    cur_sum = 0\n\n    for num in nums:\n        cur_sum = max(cur_sum + num, num)\n        max_sum = max(max_sum, cur_sum)\n\n    return max_sum\n\n\nnums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(maxSubArrayDP(nums))  # 6\nprint(maxSubArrayGreedy(nums))  # 6\n</code></pre>"},{"location":"neetcode150/greedy/#55-jump-game","title":"55. Jump Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> <li>Return <code>True</code> if you can reach the last index, otherwise <code>False</code>.</li> </ul> <ul> <li>Example: <code>[2, 3, 1, 1, 4, 1, 2, 0, 0]</code></li> </ul> Index Value Index + Value Max Reach Max Reach &gt;= Last Index 0 2 2 2 False 1 3 4 4 False 2 1 3 4 False 3 1 4 4 False 4 4 8 8 True 5 1 6 8 True 6 2 8 8 True 7 0 7 8 True 8 0 8 8 True 55. Jump Game - Python Solution<pre><code>from typing import List\n\n\n# Greedy - Interval\ndef canJump(nums: List[int]) -&gt; bool:\n    maxReach = 0\n    i = 0\n    n = len(nums)\n\n    while i &lt;= maxReach:\n        maxReach = max(maxReach, i + nums[i])\n        if maxReach &gt;= n - 1:\n            return True\n        i += 1\n\n    return False\n\n\nprint(canJump([2, 3, 1, 1, 4, 1, 2, 0, 0]))  # True\n</code></pre>"},{"location":"neetcode150/greedy/#45-jump-game-ii","title":"45. Jump Game II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy</p> </li> <li>Return the minimum number of jumps to reach the last index.</li> </ul> 45. Jump Game II - Python Solution<pre><code>from typing import List\n\n\n# Greedy - Interval\ndef jump(nums: List[int]) -&gt; int:\n    n = len(nums)\n    if len(nums) == 1:\n        return 0\n\n    maxReach = 0\n    step = 0\n    left, right = 0, 0\n\n    while right &lt; n - 1:\n        for i in range(left, right + 1):\n            maxReach = max(maxReach, i + nums[i])\n        left = right + 1\n        right = maxReach\n        step += 1\n\n    return step\n\n\nprint(jump([2, 3, 1, 1, 4, 2, 1]))  # 3\n</code></pre>"},{"location":"neetcode150/greedy/#134-gas-station","title":"134. Gas Station","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy</p> </li> </ul> 134. Gas Station - Python Solution<pre><code>from typing import List\n\n\n# Greedy\ndef canCompleteCircuit(gas: List[int], cost: List[int]) -&gt; int:\n    curSum = 0\n    totalSum = 0\n    start = 0\n\n    for i in range(len(gas)):\n        curSum += gas[i] - cost[i]\n        totalSum += gas[i] - cost[i]\n\n        if curSum &lt; 0:\n            start = i + 1\n            curSum = 0\n\n    if totalSum &lt; 0:\n        return -1\n\n    return start\n\n\ngas = [1, 2, 3, 4, 5]\ncost = [3, 4, 5, 1, 2]\nprint(canCompleteCircuit(gas, cost))  # 3\n</code></pre>"},{"location":"neetcode150/greedy/#846-hand-of-straights","title":"846. Hand of Straights","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, greedy, sorting</p> </li> </ul> 846. Hand of Straights - Python Solution<pre><code>from collections import Counter\nfrom typing import List\n\n\n# Greedy\ndef isNStraightHand(hand: List[int], groupSize: int) -&gt; bool:\n    if len(hand) % groupSize != 0:\n        return False\n\n    count = Counter(hand)\n\n    while count:\n        minVal = min(count)\n        for i in range(minVal, minVal + groupSize):\n            if count[i] == 0:\n                return False\n            count[i] -= 1\n            if count[i] == 0:\n                del count[i]\n    return True\n\n\nhand = [1, 2, 3, 6, 2, 3, 4, 7, 8]\ngroupSize = 3\nprint(isNStraightHand(hand, groupSize))  # True\n</code></pre>"},{"location":"neetcode150/greedy/#1899-merge-triplets-to-form-target-triplet","title":"1899. Merge Triplets to Form Target Triplet","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy</p> </li> </ul> 1899. Merge Triplets to Form Target Triplet - Python Solution<pre><code>from typing import List\n\n\ndef mergeTriplets(triplets: List[List[int]], target: List[int]) -&gt; bool:\n    can_form = [False, False, False]\n\n    for triplet in triplets:\n        if all(triplet[i] &lt;= target[i] for i in range(3)):\n            for i in range(3):\n                if triplet[i] == target[i]:\n                    can_form[i] = True\n\n    return all(can_form)\n\n\ntriplets = [[2, 5, 3], [1, 8, 4], [1, 7, 5]]\ntarget = [2, 7, 5]\nprint(mergeTriplets(triplets, target))  # True\n</code></pre>"},{"location":"neetcode150/greedy/#763-partition-labels","title":"763. Partition Labels","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, two pointers, string, greedy</p> </li> </ul> 763. Partition Labels - Python Solution<pre><code>from typing import List\n\n\n# 1. Hashmap\ndef partitionLabels1(s: str) -&gt; List[int]:\n    # Time complexity: O(nlogn)\n    # Space complexity: O(n)\n    hashmap = {}\n\n    for i, j in enumerate(s):\n        if j not in hashmap:\n            hashmap[j] = [i, i]\n        else:\n            hashmap[j][1] = i\n\n    intervals = list(hashmap.values())\n    intervals.sort(key=lambda x: x[0])\n\n    if len(intervals) &lt; 2:\n        return len(intervals)\n\n    result = []\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &lt; intervals[i - 1][1]:\n            intervals[i][1] = max(intervals[i][1], intervals[i - 1][1])\n        else:\n            result.append(intervals[i][0])\n\n    result.append(intervals[-1][1] + 1)\n\n    if len(result) == 1:\n        return result\n    else:\n        for i in range(len(result) - 1, 0, -1):\n            result[i] -= result[i - 1]\n        return result\n\n\n# 2. Single Pass Partitioning\ndef partitionLabels2(s: str) -&gt; List[int]:\n    # Time complexity: O(n)\n    # Space complexity: O(n)\n    last = {c: i for i, c in enumerate(s)}\n\n    start, end = 0, 0\n    result = []\n\n    for i, c in enumerate(s):\n        end = max(end, last[c])\n        if i == end:\n            result.append(end - start + 1)\n            start = i + 1\n\n    return result\n\n\nprint(partitionLabels1(\"abaccd\"))  # [3, 2, 1]\nprint(partitionLabels2(\"abaccd\"))  # [3, 2, 1]\n</code></pre>"},{"location":"neetcode150/greedy/#678-valid-parenthesis-string","title":"678. Valid Parenthesis String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming, stack, greedy</p> </li> </ul> 678. Valid Parenthesis String - Python Solution<pre><code># Greedy\ndef checkValidString(s: str) -&gt; bool:\n    min_open, max_open = 0, 0\n\n    for char in s:\n        if char == \"(\":\n            min_open += 1\n            max_open += 1\n        elif char == \")\":\n            min_open = max(min_open - 1, 0)\n            max_open -= 1\n        elif char == \"*\":\n            min_open = max(min_open - 1, 0)\n            max_open += 1\n\n        if max_open &lt; 0:\n            return False\n\n    return min_open == 0\n\n\ns = \"(*))\"\nprint(checkValidString(s))  # True\n</code></pre>"},{"location":"neetcode150/heap/","title":"Heap","text":"<ul> <li> 703. Kth Largest Element in a Stream (Easy)</li> <li> 1046. Last Stone Weight (Easy)</li> <li> 973. K Closest Points to Origin (Medium)</li> <li> 215. Kth Largest Element in an Array (Medium)</li> <li> 621. Task Scheduler (Medium)</li> <li> 355. Design Twitter (Medium)</li> <li> 295. Find Median from Data Stream (Hard)</li> </ul>"},{"location":"neetcode150/heap/#703-kth-largest-element-in-a-stream","title":"703. Kth Largest Element in a Stream","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, design, binary search tree, heap priority queue, binary tree, data stream</p> </li> </ul> 703. Kth Largest Element in a Stream - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Heap\nclass KthLargest:\n\n    def __init__(self, k: int, nums: List[int]):\n        self.k = k\n        self.heap = []\n        for num in nums:\n            self.add(num)\n\n    def add(self, val: int) -&gt; int:\n        heapq.heappush(self.heap, val)\n\n        if len(self.heap) &gt; self.k:\n            heapq.heappop(self.heap)\n\n        return self.heap[0]\n\n\nobj = KthLargest(3, [4, 5, 8, 2])\nprint(obj.add(3))  # 4\nprint(obj.add(5))  # 5\nprint(obj.add(10))  # 5\n</code></pre>"},{"location":"neetcode150/heap/#1046-last-stone-weight","title":"1046. Last Stone Weight","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, heap priority queue</p> </li> </ul> 1046. Last Stone Weight - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Heap\ndef lastStoneWeightHeap(stones: List[int]) -&gt; int:\n    heap = [-stone for stone in stones]\n    heapq.heapify(heap)\n\n    while len(heap) &gt; 1:\n        s1 = heapq.heappop(heap)\n        s2 = heapq.heappop(heap)\n\n        if s1 != s2:\n            heapq.heappush(heap, s1 - s2)\n\n    return -heap[0] if heap else 0\n\n\n# 0/1 Knapsack\ndef lastStoneWeightKnapsack(stones: List[int]) -&gt; int:\n    total = sum(stones)\n    target = total // 2\n\n    dp = [0 for _ in range(target + 1)]\n\n    for i in stones:\n        for j in range(target, i - 1, -1):\n            dp[j] = max(dp[j], dp[j - i] + i)\n\n    return total - 2 * dp[target]\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Heap     |   O(n log n)    |     O(n)     |\n# |  Knapsack   |      O(n)       |     O(n)     |\n# |-------------|-----------------|--------------|\n\n\nstones = [2, 7, 4, 1, 8, 1]\nprint(lastStoneWeightHeap(stones))  # 1\nprint(lastStoneWeightKnapsack(stones))  # 1\n</code></pre>"},{"location":"neetcode150/heap/#973-k-closest-points-to-origin","title":"973. K Closest Points to Origin","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, divide and conquer, geometry, sorting, heap priority queue, quickselect</p> </li> </ul> 973. K Closest Points to Origin - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\ndef kClosest(points: List[List[int]], k: int) -&gt; List[List[int]]:\n    heap = []\n\n    for x, y in points:\n        dist = -(x**2 + y**2)  # max heap\n        if len(heap) &lt; k:\n            heapq.heappush(heap, (dist, x, y))\n        else:\n            heapq.heappushpop(heap, (dist, x, y))  # push and pop the smallest\n\n    return [[x, y] for (_, x, y) in heap]\n\n\n# Time complexity: O(n * log(k))\n#   - O(log(k)) for heapify\n#   - O(n) for iterating through the input list\n# Space complexity: O(k)\n\npoints = [[1, 3], [-2, 2]]\nk = 1\nprint(kClosest(points, k))  # [[-2, 2]]\n</code></pre>"},{"location":"neetcode150/heap/#215-kth-largest-element-in-an-array","title":"215. Kth Largest Element in an Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, divide and conquer, sorting, heap priority queue, quickselect</p> </li> </ul> 215. Kth Largest Element in an Array - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\ndef findKthLargest(nums: List[int], k: int) -&gt; int:\n    heap = nums[:k]\n    heapq.heapify(heap)  # min heap\n\n    for num in nums[k:]:\n        if num &gt; heap[0]:\n            heapq.heappop(heap)  # pop the smallest element\n            heapq.heappush(heap, num)  # push the new element\n\n    return heap[0]\n\n\n# Time complexity: O(n * log(k))\n#   - O(log(k)) for heapify\n#   - O(n) for iterating through the input list\n# Space complexity: O(k)\n\nnums = [3, 2, 1, 5, 6, 4]\nk = 2\nprint(findKthLargest(nums, k))  # 5\n</code></pre>"},{"location":"neetcode150/heap/#621-task-scheduler","title":"621. Task Scheduler","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, greedy, sorting, heap priority queue, counting</p> </li> </ul> 621. Task Scheduler - Python Solution<pre><code>import heapq\nfrom collections import Counter, deque\nfrom typing import List\n\n\n# Heap\ndef leastInterval1(tasks: List[str], n: int) -&gt; int:\n    count = Counter(tasks)\n    heap = [-c for c in count.values()]\n    heapq.heapify(heap)\n\n    time = 0\n\n    q = deque()\n\n    while heap or q:\n        time += 1\n\n        if heap:\n            cnt = 1 + heapq.heappop(heap)\n            if cnt:\n                q.append((cnt, time + n))\n\n        if q and q[0][1] == time:\n            heapq.heappush(heap, q.popleft()[0])\n\n    return time\n\n\ndef leastInterval2(tasks: List[str], n: int) -&gt; int:\n    freq = Counter(tasks)\n\n    maxExec = max(freq.values())\n    maxCount = sum(1 for v in freq.values() if v == maxExec)\n\n    return max((maxExec - 1) * (n + 1) + maxCount, len(tasks))\n\n\ntasks = [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\"]\nn = 2\nprint(leastInterval1(tasks, n))  # 8\nprint(leastInterval2(tasks, n))  # 8\n</code></pre>"},{"location":"neetcode150/heap/#355-design-twitter","title":"355. Design Twitter","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, linked list, design, heap priority queue</p> </li> <li>Similar question: 23. Merge K Sorted Lists (Hard)</li> </ul> 355. Design Twitter - Python Solution<pre><code>import heapq\nfrom collections import defaultdict\nfrom typing import List\n\n\n# Design\nclass Twitter:\n\n    def __init__(self):\n        self.tweets = defaultdict(list)\n        self.followees = defaultdict(set)\n        self.time = 0\n\n    def postTweet(self, userId: int, tweetId: int) -&gt; None:\n        self.tweets[userId].append((self.time, tweetId))\n        self.time += 1\n\n    def getNewsFeed(self, userId: int) -&gt; List[int]:\n        news_feed = []\n        news_feed.extend(self.tweets[userId])\n        for followee in self.followees[userId]:\n            news_feed.extend(self.tweets[followee])\n\n        return [tweet for _, tweet in heapq.nlargest(10, news_feed)]\n\n    def follow(self, followerId: int, followeeId: int) -&gt; None:\n        if followerId != followeeId:\n            self.followees[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -&gt; None:\n        if followerId != followeeId:\n            self.followees[followerId].discard(followeeId)\n\n\ntwitter = Twitter()\nprint(twitter.postTweet(1, 5))  # None\nprint(twitter.getNewsFeed(1))  # [5]\nprint(twitter.follow(1, 2))  # None\nprint(twitter.postTweet(2, 6))  # None\nprint(twitter.getNewsFeed(1))  # [6, 5]\nprint(twitter.unfollow(1, 2))  # None\nprint(twitter.getNewsFeed(1))  # [5]\n</code></pre>"},{"location":"neetcode150/heap/#295-find-median-from-data-stream","title":"295. Find Median from Data Stream","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: two pointers, design, sorting, heap priority queue, data stream</p> </li> </ul> 295. Find Median from Data Stream - Python Solution<pre><code>from heapq import heappop, heappush\n\n\n# Heap - Two Heaps\nclass MedianFinder:\n    def __init__(self):\n        self.max = []\n        self.min = []\n\n    def addNum(self, num: int) -&gt; None:\n        heappush(self.max, -num)\n        heappush(self.min, -heappop(self.max))\n\n        if len(self.min) &gt; len(self.max):\n            heappush(self.max, -heappop(self.min))\n\n    def findMedian(self) -&gt; float:\n        if len(self.max) == len(self.min):\n            return (-self.max[0] + self.min[0]) / 2.0\n        else:\n            return -self.max[0]\n\n\n# TC: O(log n)\n# SC: O(n)\n\nmedian_finder = MedianFinder()\nmedian_finder.addNum(1)\nmedian_finder.addNum(2)\nassert median_finder.findMedian() == 1.5\nmedian_finder.addNum(3)\nassert median_finder.findMedian() == 2\nmedian_finder.addNum(4)\nassert median_finder.findMedian() == 2.5\nmedian_finder.addNum(5)\nassert median_finder.findMedian() == 3\nprint(\"All Passed.\")\n</code></pre>"},{"location":"neetcode150/intervals/","title":"Intervals","text":"<ul> <li> 57. Insert Interval (Medium)</li> <li> 56. Merge Intervals (Medium)</li> <li> 435. Non-overlapping Intervals (Medium)</li> <li> 252. Meeting Rooms (Easy)</li> <li> 253. Meeting Rooms II (Medium)</li> <li> 1851. Minimum Interval to Include Each Query (Hard)</li> </ul>"},{"location":"neetcode150/intervals/#57-insert-interval","title":"57. Insert Interval","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array</p> </li> </ul> 57. Insert Interval - Python Solution<pre><code>from typing import List\n\n\n# Interval\ndef insert(\n    intervals: List[List[int]], newInterval: List[int]\n) -&gt; List[List[int]]:\n    n = len(intervals)\n\n    if n == 0:\n        return [newInterval]\n\n    if newInterval[1] &lt; intervals[0][0]:\n        return [newInterval] + intervals\n\n    if newInterval[0] &gt; intervals[-1][1]:\n        return intervals + [newInterval]\n\n    i = 0\n    result = []\n\n    while i &lt; n and intervals[i][1] &lt; newInterval[0]:\n        result.append(intervals[i])\n        i += 1\n\n    while i &lt; n and intervals[i][0] &lt;= newInterval[1]:\n        newInterval[0] = min(newInterval[0], intervals[i][0])\n        newInterval[1] = max(newInterval[1], intervals[i][1])\n        i += 1\n\n    result.append(newInterval)\n\n    while i &lt; n:\n        result.append(intervals[i])\n        i += 1\n\n    return result\n\n\nintervals = [[1, 3], [6, 9]]\nnewInterval = [2, 5]\nprint(insert(intervals, newInterval))  # [[1, 5], [6, 9]]\n</code></pre>"},{"location":"neetcode150/intervals/#56-merge-intervals","title":"56. Merge Intervals","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, sorting</p> </li> <li>Merge all overlapping intervals.</li> </ul> 56. Merge Intervals - Python Solution<pre><code>from typing import List\n\n\n# Intervals\ndef merge(intervals: List[List[int]]) -&gt; List[List[int]]:\n    n = len(intervals)\n    if n &lt;= 1:\n        return intervals\n\n    intervals.sort(key=lambda x: x[0])\n    res = [intervals[0]]\n\n    for i in range(1, n):\n        if intervals[i][0] &lt;= res[-1][1]:\n            res[-1][1] = max(res[-1][1], intervals[i][1])\n        else:\n            res.append(intervals[i])\n\n    return res\n\n\nprint(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))\n# [[1, 6], [8, 10], [15, 18]]\n</code></pre>"},{"location":"neetcode150/intervals/#435-non-overlapping-intervals","title":"435. Non-overlapping Intervals","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, greedy, sorting</p> </li> </ul> 435. Non-overlapping Intervals - Python Solution<pre><code>from typing import List\n\n\ndef eraseOverlapIntervals(intervals: List[List[int]]) -&gt; int:\n    if len(intervals) &lt;= 1:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n    result = 0\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &gt;= intervals[i - 1][1]:\n            continue\n        else:\n            result += 1\n            intervals[i][1] = min(intervals[i][1], intervals[i - 1][1])\n\n    return result\n\n\nprint(eraseOverlapIntervals([[1, 2], [2, 3], [3, 4], [1, 3]]))  # 1\n</code></pre>"},{"location":"neetcode150/intervals/#252-meeting-rooms","title":"252. Meeting Rooms","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, sorting</p> </li> </ul> 252. Meeting Rooms - Python Solution<pre><code>from typing import List\n\n\n# Interval\ndef canAttendMeetings(intervals: List[List[int]]) -&gt; bool:\n    intervals.sort(key=lambda x: x[0])\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &lt; intervals[i - 1][1]:\n            return False\n\n    return True\n\n\nintervals = [[0, 30], [5, 10], [15, 20]]\nprint(canAttendMeetings(intervals))  # False\n</code></pre>"},{"location":"neetcode150/intervals/#253-meeting-rooms-ii","title":"253. Meeting Rooms II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy, sorting, heap priority queue, prefix sum</p> </li> </ul> 253. Meeting Rooms II - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Heap\ndef minMeetingRooms(intervals: List[List[int]]) -&gt; int:\n    if not intervals:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n    heap = [intervals[0][1]]\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &gt;= heap[0]:\n            heapq.heappop(heap)\n        heapq.heappush(heap, intervals[i][1])\n\n    return len(heap)\n\n\nintervals = [[0, 30], [5, 10], [15, 20]]\nprint(minMeetingRooms(intervals))  # 2\n</code></pre>"},{"location":"neetcode150/intervals/#1851-minimum-interval-to-include-each-query","title":"1851. Minimum Interval to Include Each Query","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, line sweep, sorting, heap priority queue</p> </li> </ul>"},{"location":"neetcode150/linked_list/","title":"Linked List","text":"<ul> <li> 206. Reverse Linked List (Easy)</li> <li> 21. Merge Two Sorted Lists (Easy)</li> <li> 143. Reorder List (Medium)</li> <li> 19. Remove Nth Node From End of List (Medium)</li> <li> 138. Copy List with Random Pointer (Medium)</li> <li> 2. Add Two Numbers (Medium)</li> <li> 141. Linked List Cycle (Easy)</li> <li> 287. Find the Duplicate Number (Medium)</li> <li> 146. LRU Cache (Medium)</li> <li> 23. Merge k Sorted Lists (Hard)</li> <li> 25. Reverse Nodes in k-Group (Hard)</li> </ul>"},{"location":"neetcode150/linked_list/#206-reverse-linked-list","title":"206. Reverse Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: linked list, recursion</p> </li> <li>Reverse a singly linked list.</li> </ul> <pre><code>graph LR\nA[1] --&gt; B[2]\nB --&gt; C[3]\nC --&gt; D[4]\nD --&gt; E[5]</code></pre> <pre><code>graph RL\nE[5] --&gt; D[4]\nD --&gt; C[3]\nC --&gt; B[2]\nB --&gt; A[1]</code></pre> 206. Reverse Linked List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Iterative\ndef reverseListIterative(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    cur = head\n    prev = None\n\n    while cur:\n        temp = cur.next\n        cur.next = prev\n\n        prev = cur\n        cur = temp\n\n    return prev\n\n\n# Recursive\ndef reverseListRecursive(head: Optional[ListNode]) -&gt; Optional[ListNode]:\n    def reverse(cur, prev=None):\n        if not cur:\n            return prev\n\n        temp = cur.next\n        cur.next = prev\n\n        return reverse(temp, cur)\n\n    return reverse(head)\n\n\nnums = [1, 2, 3, 4, 5]\nhead1 = ListNode.create(nums)\nprint(head1)\n# 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(reverseListIterative(head1))\n# 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1\nhead2 = ListNode.create(nums)\nprint(reverseListRecursive(head2))\n# 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1\n</code></pre>"},{"location":"neetcode150/linked_list/#21-merge-two-sorted-lists","title":"21. Merge Two Sorted Lists","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: linked list, recursion</p> </li> <li>Merge the two lists into one sorted list.</li> </ul> 21. Merge Two Sorted Lists - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef mergeTwoLists(\n    list1: Optional[ListNode], list2: Optional[ListNode]\n) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    while list1 and list2:\n        if list1.val &lt; list2.val:\n            cur.next = list1\n            list1 = list1.next\n        else:\n            cur.next = list2\n            list2 = list2.next\n        cur = cur.next\n\n    if list1:\n        cur.next = list1\n    elif list2:\n        cur.next = list2\n\n    return dummy.next\n\n\nlist1 = ListNode.create([1, 2, 4])\nlist2 = ListNode.create([1, 3, 4])\nprint(mergeTwoLists(list1, list2))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4\n</code></pre>"},{"location":"neetcode150/linked_list/#143-reorder-list","title":"143. Reorder List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, two pointers, stack, recursion</p> </li> </ul> 143. Reorder List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef reorderList(head: Optional[ListNode]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify head in-place instead.\n    \"\"\"\n    if not head or not head.next:\n        return\n\n    # Middle of the linked list\n    slow, fast = head, head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n    # Reverse the second half\n    pre, cur = None, slow\n    while cur:\n        temp = cur.next\n        cur.next = pre\n        pre = cur\n        cur = temp\n\n    # Merge two linked lists\n    first, second = head, pre\n    while second.next:\n        temp1, temp2 = first.next, second.next\n        first.next = second\n        second.next = temp1\n        first, second = temp1, temp2\n\n\nhead = ListNode.create([1, 2, 3, 4, 5, 6])\nprint(head)  # 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6\nreorderList(head)\nprint(head)  # 1 -&gt; 6 -&gt; 2 -&gt; 5 -&gt; 3 -&gt; 4\n</code></pre>"},{"location":"neetcode150/linked_list/#19-remove-nth-node-from-end-of-list","title":"19. Remove Nth Node From End of List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, two pointers</p> </li> <li>Given the <code>head</code> of a linked list, remove the <code>n-th</code> node from the end of the list and return its head.</li> </ul> 19. Remove Nth Node From End of List - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef removeNthFromEnd(head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:\n    dummy = ListNode(0, head)\n    fast = slow = dummy\n\n    for _ in range(n + 1):\n        fast = fast.next\n\n    while fast:\n        fast = fast.next\n        slow = slow.next\n\n    slow.next = slow.next.next\n\n    return dummy.next\n\n\nhead = [1, 2, 3, 4, 5]\nn = 2\nhead = ListNode.create(head)\nprint(head)  # 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\nprint(removeNthFromEnd(head, n))  # 1 -&gt; 2 -&gt; 3 -&gt; 5\n</code></pre>"},{"location":"neetcode150/linked_list/#138-copy-list-with-random-pointer","title":"138. Copy List with Random Pointer","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, linked list</p> </li> </ul> 138. Copy List with Random Pointer - Python Solution<pre><code>from typing import Optional\n\n\nclass Node:\n    def __init__(self, x: int, next: \"Node\" = None, random: \"Node\" = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\n\ndef copyRandomList(head: \"Optional[Node]\") -&gt; \"Optional[Node]\":\n    if not head:\n        return None\n\n    # Copy nodes and link them together\n    cur = head\n    while cur:\n        new_node = Node(cur.val)\n        new_node.next = cur.next\n        cur.next = new_node\n        cur = new_node.next\n\n    # Copy random pointers\n    cur = head\n    while cur:\n        cur.next.random = cur.random.next if cur.random else None\n        cur = cur.next.next\n\n    # Separate the original and copied lists\n    cur = head\n    new_head = head.next\n    while cur:\n        new_node = cur.next\n        cur.next = new_node.next\n        new_node.next = new_node.next.next if new_node.next else None\n        cur = cur.next\n\n    return new_head\n</code></pre>"},{"location":"neetcode150/linked_list/#2-add-two-numbers","title":"2. Add Two Numbers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, math, recursion</p> </li> <li>Represent the sum of two numbers as a linked list.</li> </ul> 2. Add Two Numbers - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\n# Linked List\ndef addTwoNumbers(\n    l1: Optional[ListNode], l2: Optional[ListNode]\n) -&gt; Optional[ListNode]:\n    dummy = ListNode(0)\n    cur = dummy\n    carry = 0\n\n    while l1 or l2:\n        v1 = l1.val if l1 else 0\n        v2 = l2.val if l2 else 0\n\n        carry, val = divmod(v1 + v2 + carry, 10)\n        cur.next = ListNode(val)\n        cur = cur.next\n\n        if l1:\n            l1 = l1.next\n        if l2:\n            l2 = l2.next\n\n    if carry:\n        cur.next = ListNode(val=carry)\n\n    return dummy.next\n\n\nl1 = ListNode.create([2, 4, 3])\nl2 = ListNode.create([5, 6, 4])\nprint(addTwoNumbers(l1, l2))  # 7 -&gt; 0 -&gt; 8\n</code></pre>"},{"location":"neetcode150/linked_list/#141-linked-list-cycle","title":"141. Linked List Cycle","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, linked list, two pointers</p> </li> <li>Determine if a linked list has a cycle in it.</li> </ul> <pre><code>graph LR\nA[3] --&gt; B[2]\nB --&gt; C[0]\nC --&gt; D[-4]</code></pre> <pre><code>graph LR\nA[3] --&gt; B[2]\nB --&gt; C[0]\nC --&gt; D[-4]\nD --&gt; B</code></pre> 141. Linked List Cycle - Python Solution<pre><code>from typing import Optional\n\nfrom template import ListNode\n\n\ndef hasCycle(head: Optional[ListNode]) -&gt; bool:\n    slow, fast = head, head\n\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n        if slow == fast:\n            return True\n\n    return False\n\n\nprint(hasCycle(ListNode.create([3, 2, 0, -4])))  # False\nprint(hasCycle(ListNode.create([3, 2, 0, -4], 1)))  # True\n</code></pre>"},{"location":"neetcode150/linked_list/#287-find-the-duplicate-number","title":"287. Find the Duplicate Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search, bit manipulation</p> </li> <li>Find the duplicate number in an array containing <code>n + 1</code> integers where each integer is between <code>1</code> and <code>n</code> inclusive.</li> </ul> 287. Find the Duplicate Number - Python Solution<pre><code>from typing import List\n\n\n# Fast Slow Pointer\ndef findDuplicate(nums: List[int]) -&gt; int:\n\n    fast, slow = nums[0], nums[0]\n\n    while True:\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n        if slow == fast:\n            break\n\n    slow = nums[0]\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[fast]\n\n    return slow\n\n\n# | Algorithm          | TC   | SC   |\n# |--------------------|------|------|\n# | Fast Slow Pointer  | O(n) | O(1) |\n# |--------------------|------|------|\n\nnums = [1, 3, 4, 2, 2]\nprint(findDuplicate(nums))  # 2\n</code></pre>"},{"location":"neetcode150/linked_list/#146-lru-cache","title":"146. LRU Cache","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, linked list, design, doubly linked list</p> </li> <li>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.</li> </ul> <p></p> Data structure Description Doubly Linked List To store the key-value pairs. Hash Map To store the key-node pairs. Approach Time Complexity Space Complexity LRU O(1) O(n) 146. LRU Cache - Python Solution<pre><code>from collections import OrderedDict\n\n\n# Doubly Linked List\nclass Node:\n    def __init__(self, key=0, val=0):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.cache = {}\n        self.head = Node()\n        self.tail = Node()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def add_to_last(self, node):\n        self.tail.prev.next = node\n        node.prev = self.tail.prev\n        node.next = self.tail\n        self.tail.prev = node\n\n    def move_to_last(self, node):\n        self.remove(node)\n        self.add_to_last(node)\n\n    def get(self, key: int) -&gt; int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self.move_to_last(node)\n        return node.val\n\n    def put(self, key: int, value: int) -&gt; None:\n        if key in self.cache:\n            node = self.cache[key]\n            node.val = value\n            self.move_to_last(node)\n            return None\n\n        if len(self.cache) == self.cap:\n            del self.cache[self.head.next.key]\n            self.remove(self.head.next)\n\n        node = Node(key=key, val=value)\n        self.cache[key] = node\n        self.add_to_last(node)\n\n\n# OrderedDict\nclass LRUCacheOrderedDict:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.cap = capacity\n\n    def get(self, key: int):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key, last=True)\n        return self.cache[key]\n\n    def put(self, key: int, value: int):\n        if key in self.cache:\n            self.cache.move_to_end(key, last=True)\n        elif len(self.cache) &gt;= self.cap:\n            self.cache.popitem(last=False)\n\n        self.cache[key] = value\n\n\ncache = LRUCache(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\n\ncache = LRUCacheOrderedDict(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4\n\nprint(\"LRU Cache passed\")\nprint(\"LRU Cache Ordered Dict passed\")\n</code></pre>"},{"location":"neetcode150/linked_list/#23-merge-k-sorted-lists","title":"23. Merge k Sorted Lists","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: linked list, divide and conquer, heap priority queue, merge sort</p> </li> <li>Prerequisite: 21. Merge Two Sorted Lists</li> </ul> 23. Merge k Sorted Lists - Python Solution<pre><code>import copy\nimport heapq\nfrom typing import List, Optional\n\nfrom template import ListNode\n\n\n# Divide and Conquer\ndef mergeKListsDC(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    if not lists or len(lists) == 0:\n        return None\n\n    def mergeTwo(l1, l2):\n        dummy = ListNode()\n        cur = dummy\n\n        while l1 and l2:\n            if l1.val &lt; l2.val:\n                cur.next = l1\n                l1 = l1.next\n            else:\n                cur.next = l2\n                l2 = l2.next\n\n            cur = cur.next\n\n        cur.next = l1 if l1 else l2\n\n        return dummy.next\n\n    while len(lists) &gt; 1:\n        merged = []\n\n        for i in range(0, len(lists), 2):\n            l1 = lists[i]\n            l2 = lists[i + 1] if i + 1 &lt; len(lists) else None\n            merged.append(mergeTwo(l1, l2))\n\n        lists = merged\n\n    return lists[0]\n\n\n# Heap - Merge k Sorted\ndef mergeKLists(lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]:\n    dummy = ListNode()\n    cur = dummy\n\n    minHeap = []  # (val, idx, node)\n\n    for idx, head in enumerate(lists):\n        if head:\n            heapq.heappush(minHeap, (head.val, idx, head))\n\n    while minHeap:\n        _, idx, node = heapq.heappop(minHeap)\n        cur.next = node\n        cur = cur.next\n\n        node = node.next\n        if node:\n            heapq.heappush(minHeap, (node.val, idx, node))\n\n    return dummy.next\n\n\nn1 = ListNode.create([1, 4, 5])\nn2 = ListNode.create([1, 3, 4])\nn3 = ListNode.create([2, 6])\nlists = [n1, n2, n3]\nlists1 = copy.deepcopy(lists)\nlists2 = copy.deepcopy(lists)\nprint(mergeKListsDC(lists1))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6\nprint(mergeKLists(lists2))\n# 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 -&gt; 6\n</code></pre>"},{"location":"neetcode150/linked_list/#25-reverse-nodes-in-k-group","title":"25. Reverse Nodes in k-Group","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: linked list, recursion</p> </li> </ul>"},{"location":"neetcode150/math_geometry/","title":"Math Geometry","text":"<ul> <li> 48. Rotate Image (Medium)</li> <li> 54. Spiral Matrix (Medium)</li> <li> 73. Set Matrix Zeroes (Medium)</li> <li> 202. Happy Number (Easy)</li> <li> 66. Plus One (Easy)</li> <li> 50. Pow(x, n) (Medium)</li> <li> 43. Multiply Strings (Medium)</li> <li> 166. Fraction to Recurring Decimal (Medium)</li> </ul>"},{"location":"neetcode150/math_geometry/#48-rotate-image","title":"48. Rotate Image","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, matrix</p> </li> </ul> 48. Rotate Image - Python Solution<pre><code>from copy import deepcopy\nfrom typing import List\n\n\n# Math\ndef rotate1(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    n = len(matrix)\n\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n\n\ndef rotate2(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    n = len(matrix)\n    for i in range(n):\n        for j in range(i, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\n    for i in range(n):\n        matrix[i].reverse()\n\n\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nprint(matrix)\n# [[1, 2, 3],\n#  [4, 5, 6],\n#  [7, 8, 9]]\nmatrix1 = deepcopy(matrix)\nrotate1(matrix1)\nprint(matrix1)\n# [[7, 4, 1],\n#  [8, 5, 2],\n#  [9, 6, 3]]\nmatrix2 = deepcopy(matrix)\nrotate2(matrix2)\nprint(matrix2)\n# [[7, 4, 1],\n#  [8, 5, 2],\n#  [9, 6, 3]]\n</code></pre>"},{"location":"neetcode150/math_geometry/#54-spiral-matrix","title":"54. Spiral Matrix","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, matrix, simulation</p> </li> <li>Return all elements of the matrix in spiral order.</li> </ul> 54. Spiral Matrix - Python Solution<pre><code>from typing import List\n\n\n# Array\ndef spiralOrder(matrix: List[List[int]]) -&gt; List[int]:\n    if not matrix or not matrix[0]:\n        return []\n\n    result = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n\n    while top &lt;= bottom and left &lt;= right:\n\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n\n        if top &lt;= bottom:\n\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n\n        if left &lt;= right:\n\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n\n    return result\n\n\n# |-------------|-----------------|--------------|\n# |  Approach   |      Time       |    Space     |\n# |-------------|-----------------|--------------|\n# |    Naive    |      O(N)       |     O(1)     |\n# |-------------|-----------------|--------------|\n\n\nprint(spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n# [1, 2, 3, 6, 9, 8, 7, 4, 5]\n</code></pre>"},{"location":"neetcode150/math_geometry/#73-set-matrix-zeroes","title":"73. Set Matrix Zeroes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, matrix</p> </li> </ul> 73. Set Matrix Zeroes - Python Solution<pre><code>from copy import deepcopy\nfrom typing import List\n\n\n# Math\ndef setZeroes1(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    m, n = len(matrix), len(matrix[0])\n\n    rows, cols = set(), set()\n\n    for i in range(m):\n        for j in range(n):\n            if matrix[i][j] == 0:\n                rows.add(i)\n                cols.add(j)\n\n    for i in rows:\n        for j in range(n):\n            matrix[i][j] = 0\n\n    for i in range(m):\n        for j in cols:\n            matrix[i][j] = 0\n\n\n# Math - Optimized\ndef setZeroes2(matrix: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    m, n = len(matrix), len(matrix[0])\n    row_zero, col_zero = False, False\n\n    for i in range(m):\n        if matrix[i][0] == 0:\n            col_zero = True\n            break\n\n    for j in range(n):\n        if matrix[0][j] == 0:\n            row_zero = True\n            break\n\n    for i in range(1, m):\n        for j in range(1, n):\n            if matrix[i][j] == 0:\n                matrix[i][0] = 0\n                matrix[0][j] = 0\n\n    for i in range(1, m):\n        if matrix[i][0] == 0:\n            for j in range(1, n):\n                matrix[i][j] = 0\n\n    for j in range(1, n):\n        if matrix[0][j] == 0:\n            for i in range(1, m):\n                matrix[i][j] = 0\n\n    if col_zero:\n        for i in range(m):\n            matrix[i][0] = 0\n\n    if row_zero:\n        for j in range(n):\n            matrix[0][j] = 0\n\n\nmatrix = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]\nprint(matrix)\n# [[1, 1, 1],\n#  [1, 0, 1],\n#  [1, 1, 1]]\nmatrix1 = deepcopy(matrix)\nsetZeroes1(matrix1)\nprint(matrix1)\n# [[1, 0, 1],\n#  [0, 0, 0],\n#  [1, 0, 1]]\nmatrix2 = deepcopy(matrix)\nsetZeroes2(matrix2)\nprint(matrix2)\n# [[1, 0, 1],\n#  [0, 0, 0],\n#  [1, 0, 1]]\n</code></pre>"},{"location":"neetcode150/math_geometry/#202-happy-number","title":"202. Happy Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, math, two pointers</p> </li> <li>Return <code>True</code> if the number is a happy number, otherwise, return <code>False</code>.</li> <li>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.</li> </ul> 202. Happy Number - Python Solution<pre><code>def isHappy(n: int) -&gt; bool:\n\n    def getSum(n):\n        sum_of_squares = 0\n        while n:\n            a, b = divmod(n, 10)\n            sum_of_squares += b**2\n            n = a\n        return sum_of_squares\n\n    record = set()\n\n    while True:\n        if n == 1:\n            return True\n\n        if n in record:\n            return False\n        else:\n            record.add(n)\n\n        n = getSum(n)\n\n\nn = 19\nprint(isHappy(n))  # True\n</code></pre>"},{"location":"neetcode150/math_geometry/#66-plus-one","title":"66. Plus One","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, math</p> </li> </ul> 66. Plus One - Python Solution<pre><code>from typing import List\n\n\n# Math\ndef plusOne(digits: List[int]) -&gt; List[int]:\n    n = len(digits)\n\n    for i in range(n - 1, -1, -1):\n        if digits[i] &lt; 9:\n            digits[i] += 1\n            return digits\n        else:\n            digits[i] = 0\n\n    return [1] + digits\n\n\ndigits = [4, 3, 2, 1]\nprint(plusOne(digits))  # [4, 3, 2, 2]\n</code></pre>"},{"location":"neetcode150/math_geometry/#50-powx-n","title":"50. Pow(x, n)","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, recursion</p> </li> </ul> 50. Pow(x, n) - Python Solution<pre><code># Iterative\ndef myPowIterative(x: float, n: int) -&gt; float:\n    if n == 0:\n        return 1\n    if n &lt; 0:\n        x = 1 / x\n        n = -n\n\n    result = 1\n    cur = x\n\n    while n &gt; 0:\n        if n % 2 == 1:\n            result *= cur\n\n        cur *= cur\n        n //= 2\n\n    return result\n\n\n# Recursive\ndef myPowRecursive(x: float, n: int) -&gt; float:\n    if n == 0:\n        return 1\n    if n &lt; 0:\n        x = 1 / x\n        n = -n\n\n    if n % 2 == 0:\n        return myPowRecursive(x * x, n // 2)\n    else:\n        return x * myPowRecursive(x * x, n // 2)\n\n\nx = 2.00000\nn = 10\nprint(myPowIterative(x, n))  # 1024.0\nprint(myPowRecursive(x, n))  # 1024.0\n</code></pre>"},{"location":"neetcode150/math_geometry/#43-multiply-strings","title":"43. Multiply Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, string, simulation</p> </li> </ul> 43. Multiply Strings - Python Solution<pre><code># Math\ndef multiply(num1: str, num2: str) -&gt; str:\n    if num1 == \"0\" or num2 == \"0\":\n        return \"0\"\n\n    m, n = len(num1), len(num2)\n    result = [0 for _ in range(m + n)]\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            mul = int(num1[i]) * int(num2[j])\n            sum = mul + result[i + j + 1]\n\n            result[i + j + 1] = sum % 10\n            result[i + j] += sum // 10\n\n    result_str = \"\".join(map(str, result)).lstrip(\"0\")\n\n    return result_str if result_str else \"0\"\n\n\nnum1 = \"2\"\nnum2 = \"3\"\nprint(multiply(num1, num2))  # \"6\"\n</code></pre>"},{"location":"neetcode150/math_geometry/#166-fraction-to-recurring-decimal","title":"166. Fraction to Recurring Decimal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, math, string</p> </li> </ul> 166. Fraction to Recurring Decimal - Python Solution<pre><code># Math\ndef fractionToDecimal(numerator: int, denominator: int) -&gt; str:\n    if numerator == 0:\n        return \"0\"\n\n    res = []\n\n    if (numerator &lt; 0) ^ (denominator &lt; 0):\n        res.append(\"-\")\n\n    numerator, denominator = abs(numerator), abs(denominator)\n\n    # Integer part\n    res.append(str(numerator // denominator))\n    remainder = numerator % denominator\n\n    if remainder == 0:\n        return \"\".join(res)\n\n    res.append(\".\")\n\n    # Dictionary to store remainders and their corresponding indices\n    remainder_map = {}\n\n    while remainder != 0:\n        if remainder in remainder_map:\n            res.insert(remainder_map[remainder], \"(\")\n            res.append(\")\")\n            break\n\n        remainder_map[remainder] = len(res)\n        remainder *= 10\n        res.append(str(remainder // denominator))\n        remainder %= denominator\n\n    return \"\".join(res)\n\n\nnumerator = 4\ndenominator = 333\nprint(fractionToDecimal(numerator, denominator))  # 0.(012)\n</code></pre>"},{"location":"neetcode150/sliding_window/","title":"Sliding Window","text":"<ul> <li> 121. Best Time to Buy and Sell Stock (Easy)</li> <li> 3. Longest Substring Without Repeating Characters (Medium)</li> <li> 424. Longest Repeating Character Replacement (Medium)</li> <li> 76. Minimum Window Substring (Hard)</li> <li> 567. Permutation in String (Medium)</li> <li> 239. Sliding Window Maximum (Hard)</li> </ul>"},{"location":"neetcode150/sliding_window/#121-best-time-to-buy-and-sell-stock","title":"121. Best Time to Buy and Sell Stock","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> <li>Return the maximum profit that can be achieved from buying on one day and selling on another day.</li> </ul> 121. Best Time to Buy and Sell Stock - Python Solution<pre><code>from typing import List\n\n\n# Brute Force\ndef maxProfitBF(prices: List[int]) -&gt; int:\n    max_profit = 0\n    n = len(prices)\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_profit = max(max_profit, prices[j] - prices[i])\n\n    return max_profit\n\n\n# DP\ndef maxProfitDP(prices: List[int]) -&gt; int:\n    dp = [[0] * 2 for _ in range(len(prices))]\n    dp[0][0] = -prices[0]  # buy\n    dp[0][1] = 0  # sell\n\n    for i in range(1, len(prices)):\n        dp[i][0] = max(dp[i - 1][0], -prices[i])  # the lowest price to buy\n        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])\n\n    return dp[-1][1]\n\n\n# Greedy\ndef maxProfitGreedy(prices: List[int]) -&gt; int:\n    max_profit = 0\n    seen_min = prices[0]\n\n    for i in range(1, len(prices)):\n        max_profit = max(max_profit, prices[i] - seen_min)\n        seen_min = min(seen_min, prices[i])\n\n    return max_profit\n\n\n# Fast Slow Pointers\ndef maxProfitFS(prices: List[int]) -&gt; int:\n    max_profit = 0\n    slow, fast = 0, 1\n\n    while fast &lt; len(prices):\n        if prices[fast] &gt; prices[slow]:\n            max_profit = max(max_profit, prices[fast] - prices[slow])\n        else:\n            slow = fast\n        fast += 1\n\n    return max_profit\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force|  O(n^2)|  O(1)   |\n# | DP         |  O(n)  |  O(n)   |\n# | Greedy     |  O(n)  |  O(1)   |\n# | Fast Slow  |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nprices = [7, 1, 5, 3, 6, 4]\nprint(maxProfitBF(prices))  # 5\nprint(maxProfitDP(prices))  # 5\nprint(maxProfitGreedy(prices))  # 5\nprint(maxProfitFS(prices))  # 5\n</code></pre>"},{"location":"neetcode150/sliding_window/#3-longest-substring-without-repeating-characters","title":"3. Longest Substring Without Repeating Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> <li>Classic sliding window problem. Use a set to keep track of the characters in the current window.</li> <li>Return the length of the longest substring without repeating characters.</li> </ul> 3. Longest Substring Without Repeating Characters - Python Solution<pre><code># Sliding Window Variable Size\ndef lengthOfLongestSubstring(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 1:\n        return n\n\n    window = set()\n    left = 0\n    res = 0\n\n    for right in range(n):\n        while s[right] in window:\n            window.remove(s[left])\n            left += 1\n        window.add(s[right])\n        res = max(res, right - left + 1)\n\n    return res\n\n\ns = \"abcabcbb\"\nassert lengthOfLongestSubstring(s) == 3\n</code></pre>"},{"location":"neetcode150/sliding_window/#424-longest-repeating-character-replacement","title":"424. Longest Repeating Character Replacement","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> </ul> 424. Longest Repeating Character Replacement - Python Solution<pre><code>from collections import defaultdict\n\n\n# Sliding Window - Variable\ndef characterReplacement(s: str, k: int) -&gt; int:\n    left = 0\n    maxCount = 0\n    counts = defaultdict(int)\n    maxLen = 0\n\n    for right in range(len(s)):\n        counts[s[right]] += 1\n        maxCount = max(maxCount, counts[s[right]])\n\n        while right - left + 1 - maxCount &gt; k:\n            counts[s[left]] -= 1\n            left += 1\n\n        maxLen = max(maxLen, right - left + 1)\n\n    return maxLen\n\n\ns = \"ABAB\"\nk = 2\nprint(characterReplacement(s, k))  # 4\n</code></pre>"},{"location":"neetcode150/sliding_window/#76-minimum-window-substring","title":"76. Minimum Window Substring","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> </ul> 76. Minimum Window Substring - Python Solution<pre><code>from collections import Counter\n\n\ndef minWindow(s: str, t: str) -&gt; str:\n    if not t or not s:\n        return \"\"\n\n    counts = Counter(t)\n    required = len(counts)\n\n    left, right = 0, 0\n    formed = 0\n    window_counts = dict()\n\n    result = float(\"inf\"), None, None\n\n    while right &lt; len(s):\n        char = s[right]\n        window_counts[char] = window_counts.get(char, 0) + 1\n        if char in counts and window_counts[char] == counts[char]:\n            formed += 1\n\n        while left &lt;= right and formed == required:\n            char = s[left]\n            if right - left + 1 &lt; result[0]:\n                result = (right - left + 1, left, right)\n            window_counts[char] -= 1\n            if char in counts and window_counts[char] &lt; counts[char]:\n                formed -= 1\n            left += 1\n\n        right += 1\n\n    return \"\" if result[0] == float(\"inf\") else s[result[1] : result[2] + 1]\n\n\ns = \"ADOBECODEBANC\"\nt = \"ABC\"\nprint(minWindow(s, t))  # BANC\n</code></pre>"},{"location":"neetcode150/sliding_window/#567-permutation-in-string","title":"567. Permutation in String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, two pointers, string, sliding window</p> </li> </ul> 567. Permutation in String - Python Solution<pre><code>def checkInclusion(s1: str, s2: str) -&gt; bool:\n    if len(s1) &gt; len(s2):\n        return False\n\n    count1 = [0] * 26\n    count2 = [0] * 26\n\n    for i in range(len(s1)):\n        count1[ord(s1[i]) - ord(\"a\")] += 1\n        count2[ord(s2[i]) - ord(\"a\")] += 1\n\n    matches = 0\n    for i in range(26):\n        if count1[i] == count2[i]:\n            matches += 1\n\n    l = 0\n    for r in range(len(s1), len(s2)):\n        if matches == 26:\n            return True\n\n        index = ord(s2[r]) - ord(\"a\")\n        count2[index] += 1\n        if count1[index] == count2[index]:\n            matches += 1\n        elif count1[index] + 1 == count2[index]:\n            matches -= 1\n\n        index = ord(s2[l]) - ord(\"a\")\n        count2[index] -= 1\n        if count1[index] == count2[index]:\n            matches += 1\n        elif count1[index] - 1 == count2[index]:\n            matches -= 1\n\n        l += 1\n\n    return matches == 26\n\n\ns1 = \"ab\"\ns2 = \"eidba\"\nprint(checkInclusion(s1, s2))  # True\n</code></pre>"},{"location":"neetcode150/sliding_window/#239-sliding-window-maximum","title":"239. Sliding Window Maximum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, queue, sliding window, heap priority queue, monotonic queue</p> </li> </ul> 239. Sliding Window Maximum - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# Monotonic Queue\ndef maxSlidingWindow(nums: List[int], k: int) -&gt; List[int]:\n    q = deque()\n    res = []\n\n    for i, num in enumerate(nums):\n        if q and q[0] &lt; i - k + 1:\n            q.popleft()\n\n        while q and nums[q[-1]] &lt; num:\n            q.pop()\n\n        q.append(i)\n\n        if i &gt;= k - 1:\n            res.append(nums[q[0]])\n\n    return res\n\n\nnums = [1, 3, -1, -3, 5, 3, 6, 7]\nk = 3\nprint(maxSlidingWindow(nums, k))  # [3, 3, 5, 5, 6, 7]\n</code></pre>"},{"location":"neetcode150/stack/","title":"Stack","text":"<ul> <li> 20. Valid Parentheses (Easy)</li> <li> 155. Min Stack (Medium)</li> <li> 150. Evaluate Reverse Polish Notation (Medium)</li> <li> 22. Generate Parentheses (Medium)</li> <li> 739. Daily Temperatures (Medium)</li> <li> 853. Car Fleet (Medium)</li> <li> 84. Largest Rectangle in Histogram (Hard)</li> </ul>"},{"location":"neetcode150/stack/#20-valid-parentheses","title":"20. Valid Parentheses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: string, stack</p> </li> <li>Determine if the input string is valid.</li> <li>Steps for the string <code>()[]{}</code>:</li> </ul> char action stack <code>(</code> push \"(\" <code>)</code> pop \"\" <code>[</code> push \"[\" <code>]</code> pop \"\" <code>{</code> push \"{\" <code>}</code> pop \"\" 20. Valid Parentheses - Python Solution<pre><code># Stack\ndef isValid(s: str) -&gt; bool:\n    hashmap = {\n        \")\": \"(\",\n        \"]\": \"[\",\n        \"}\": \"{\",\n    }\n    stack = []\n\n    for c in s:\n        if c in hashmap:\n            if stack and stack[-1] == hashmap[c]:\n                stack.pop()\n            else:\n                return False\n        else:\n            stack.append(c)\n\n    return True if not stack else False\n\n\nprint(isValid(\"()\"))  # True\nprint(isValid(\"()[]{}\"))  # True\nprint(isValid(\"(]\"))  # False\n</code></pre>"},{"location":"neetcode150/stack/#155-min-stack","title":"155. Min Stack","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: stack, design</p> </li> <li>Implement a stack that supports push, pop, top, and retrieving the minimum element in constant time.</li> </ul> 155. Min Stack - Python Solution<pre><code># Stack\nclass MinStack:\n\n    def __init__(self):\n        self.stack = []\n        self.minStack = []\n\n    def push(self, val: int) -&gt; None:\n        self.stack.append(val)\n        val = min(val, self.minStack[-1] if self.minStack else val)\n        self.minStack.append(val)\n\n    def pop(self) -&gt; None:\n        if self.stack:\n            self.stack.pop()\n        if self.minStack:\n            self.minStack.pop()\n\n    def top(self) -&gt; int:\n        return self.stack[-1] if self.stack else None\n\n    def getMin(self) -&gt; int:\n        return self.minStack[-1] if self.minStack else None\n\n\n# Your MinStack object will be instantiated and called as such:\nobj = MinStack()\nobj.push(3)\nobj.push(2)\nobj.pop()\nprint(obj.top())  # 3\nprint(obj.getMin())  # 3\n</code></pre>"},{"location":"neetcode150/stack/#150-evaluate-reverse-polish-notation","title":"150. Evaluate Reverse Polish Notation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, stack</p> </li> <li>Steps for the list <code>[\"2\", \"1\", \"+\", \"3\", \"*\"]</code>:</li> </ul> token action stack <code>2</code> push <code>[2]</code> <code>1</code> push <code>[2, 1]</code> <code>+</code> pop <code>[3]</code> <code>3</code> push <code>[3, 3]</code> <code>*</code> pop <code>[9]</code> 150. Evaluate Reverse Polish Notation - Python Solution<pre><code>from typing import List\n\n\n# Stack\ndef evalRPN(tokens: List[str]) -&gt; int:\n    stack = []\n\n    for c in tokens:\n        if c == \"+\":\n            stack.append(stack.pop() + stack.pop())\n        elif c == \"-\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(b - a)\n        elif c == \"*\":\n            stack.append(stack.pop() * stack.pop())\n        elif c == \"/\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(int(b / a))\n        else:\n            stack.append(int(c))\n\n    return stack[0]\n\n\nprint(evalRPN([\"2\", \"1\", \"+\", \"3\", \"*\"]))  # 9\nprint(evalRPN([\"4\", \"13\", \"5\", \"/\", \"-\"]))  # 2\nprint(evalRPN([\"18\"]))  # 18\nprint(evalRPN([\"4\", \"3\", \"-\"]))  # 1\n</code></pre>"},{"location":"neetcode150/stack/#22-generate-parentheses","title":"22. Generate Parentheses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, dynamic programming, backtracking</p> </li> </ul> 22. Generate Parentheses - Python Solution<pre><code>from typing import List\n\n\n# Stack\ndef generateParenthesis(n: int) -&gt; List[str]:\n    stack = []\n    result = []\n\n    def backtrack(openN, closeN):\n        if openN == closeN == n:\n            result.append(\"\".join(stack))\n            return None\n\n        if openN &lt; n:\n            stack.append(\"(\")\n            backtrack(openN + 1, closeN)\n            stack.pop()\n\n        if closeN &lt; openN:\n            stack.append(\")\")\n            backtrack(openN, closeN + 1)\n            stack.pop()\n\n    backtrack(0, 0)\n\n    return result\n\n\nprint(generateParenthesis(3))\n# ['((()))', '(()())', '(())()', '()(())', '()()()']\n</code></pre>"},{"location":"neetcode150/stack/#739-daily-temperatures","title":"739. Daily Temperatures","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, monotonic stack</p> </li> <li>Return an array <code>res</code> such that <code>res[i]</code> is the number of days you have to wait after the <code>ith</code> day to get a warmer temperature.</li> </ul> Index Temp &gt; stack last stack result 0 73 False <code>[ [73, 0] ]</code> 1 - 0 = 1 1 74 True <code>[ [74, 1] ]</code> 2 - 1 = 1 2 75 True <code>[ [75, 2] ]</code> 6 - 2 = 4 3 71 False <code>[ [75, 2], [71, 3] ]</code> 5 - 3 = 2 4 69 False <code>[ [75, 2], [71, 3], [69, 4] ]</code> 5 - 4 = 1 5 72 True <code>[ [75, 2], [72, 5] ]</code> 6 - 5 = 1 6 76 True <code>[ [76, 6] ]</code> 0 7 73 False <code>[[76, 6], [73, 7]]</code> 0 739. Daily Temperatures - Python Solution<pre><code>from typing import List\n\nimport matplotlib.pyplot as plt\n\n\n# Monotonic Stack\ndef dailyTemperatures(temperatures: List[int]) -&gt; List[int]:\n    res = [0 for _ in range(len(temperatures))]\n    stack = []\n\n    for idx, temp in enumerate(temperatures):\n        while stack and temp &gt; stack[-1][0]:\n            _, last_index = stack.pop()\n            res[last_index] = idx - last_index\n\n        stack.append([temp, idx])\n\n    return res\n\n\ndef utils_plot(idx: int, temps: List[int], stack: List[List[int]]) -&gt; None:\n    \"\"\"Plot the current state of the stack and the temperatures.\"\"\"\n    plt.figure(figsize=(8, 3))\n    plt.plot(\n        range(len(temps)),\n        temps,\n        marker=\"o\",\n        linestyle=\"-\",\n        color=\"b\",\n        label=\"Temperatures\",\n    )\n\n    # Highlight the current temperature in red\n    plt.scatter(idx, temps[idx], color=\"r\", s=100, label=\"Current\")\n\n    # Display the current state of the stack\n    for temp, stack_idx in stack:\n        plt.scatter(stack_idx, temp, color=\"g\", s=70)\n        plt.text(\n            stack_idx,\n            temp,\n            f\"({temp}, {stack_idx})\",\n            fontsize=10,\n            ha=\"center\",\n            va=\"bottom\",\n            color=\"red\",\n        )\n\n    plt.title(f\"Day {idx}\")\n    plt.xlabel(\"Days\")\n    plt.ylabel(\"Temperature\")\n    plt.legend()\n    plt.grid(True)\n    plt.show()\n\n\nprint(dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73]))\n# [1, 1, 4, 2, 1, 1, 0, 0]\n</code></pre>"},{"location":"neetcode150/stack/#853-car-fleet","title":"853. Car Fleet","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, sorting, monotonic stack</p> </li> </ul> 853. Car Fleet - Python Solution<pre><code>from typing import List\n\n\n# Stack\ndef carFleet(target: int, position: List[int], speed: List[int]) -&gt; int:\n    cars = sorted(zip(position, speed), reverse=True)\n    stack = []\n\n    for p, s in cars:\n        time = (target - p) / s\n\n        if not stack or time &gt; stack[-1]:\n            stack.append(time)\n\n    return len(stack)\n\n\nprint(carFleet(12, [10, 8, 0, 5, 3], [2, 4, 1, 1, 3]))  # 3\n</code></pre>"},{"location":"neetcode150/stack/#84-largest-rectangle-in-histogram","title":"84. Largest Rectangle in Histogram","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, stack, monotonic stack</p> </li> </ul> 84. Largest Rectangle in Histogram - Python Solution<pre><code>from typing import List\n\n\ndef largestRectangleArea(heights: List[int]) -&gt; int:\n    maxArea = 0\n    stack = []  # pair: (index, height)\n\n    for i, h in enumerate(heights):\n        start = i\n        while stack and stack[-1][1] &gt; h:\n            index, height = stack.pop()\n            maxArea = max(maxArea, height * (i - index))\n            start = index\n        stack.append((start, h))\n\n    for i, h in stack:\n        maxArea = max(maxArea, h * (len(heights) - i))\n\n    return maxArea\n\n\nprint(largestRectangleArea([2, 1, 5, 6, 2, 3]))  # 10\n</code></pre>"},{"location":"neetcode150/trees/","title":"Trees","text":"<ul> <li> 226. Invert Binary Tree (Easy)</li> <li> 104. Maximum Depth of Binary Tree (Easy)</li> <li> 543. Diameter of Binary Tree (Easy)</li> <li> 110. Balanced Binary Tree (Easy)</li> <li> 100. Same Tree (Easy)</li> <li> 572. Subtree of Another Tree (Easy)</li> <li> 235. Lowest Common Ancestor of a Binary Search Tree (Medium)</li> <li> 102. Binary Tree Level Order Traversal (Medium)</li> <li> 199. Binary Tree Right Side View (Medium)</li> <li> 1448. Count Good Nodes in Binary Tree (Medium)</li> <li> 98. Validate Binary Search Tree (Medium)</li> <li> 230. Kth Smallest Element in a BST (Medium)</li> <li> 105. Construct Binary Tree from Preorder and Inorder Traversal (Medium)</li> <li> 124. Binary Tree Maximum Path Sum (Hard)</li> <li> 297. Serialize and Deserialize Binary Tree (Hard)</li> </ul>"},{"location":"neetcode150/trees/#226-invert-binary-tree","title":"226. Invert Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree</p> </li> </ul> 226. Invert Binary Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef invertTreeRecursive(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    root.left, root.right = root.right, root.left\n\n    invertTreeRecursive(root.left)\n    invertTreeRecursive(root.right)\n\n    return root\n\n\n# Iterative\ndef invertTreeIterative(root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n    if not root:\n        return root\n\n    stack = [root]\n\n    while stack:\n        node = stack.pop()\n\n        node.left, node.right = node.right, node.left\n        if node.left:\n            stack.append(node.left)\n        if node.right:\n            stack.append(node.right)\n\n    return root\n\n\nroot = build([4, 2, 7, 1, 3, 6, 9])\nprint(root)\n#     __4__\n#    /     \\\n#   2       7\n#  / \\     / \\\n# 1   3   6   9\ninvertedRecursive = invertTreeRecursive(root)\nprint(invertedRecursive)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\nroot = build([4, 2, 7, 1, 3, 6, 9])\ninvertedIterative = invertTreeIterative(root)\nprint(invertedIterative)\n#     __4__\n#    /     \\\n#   7       2\n#  / \\     / \\\n# 9   6   3   1\n</code></pre>"},{"location":"neetcode150/trees/#104-maximum-depth-of-binary-tree","title":"104. Maximum Depth of Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree</p> </li> </ul> 104. Maximum Depth of Binary Tree - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Recursive\ndef maxDepthRecursive(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    left = maxDepthRecursive(root.left)\n    right = maxDepthRecursive(root.right)\n\n    return 1 + max(left, right)\n\n\n# DFS\ndef maxDepthDFS(root: Optional[TreeNode]) -&gt; int:\n    res = 0\n\n    def dfs(node, cnt):\n        if node is None:\n            return\n        cnt += 1\n        nonlocal res\n        res = max(res, cnt)\n\n        dfs(node.left, cnt)\n        dfs(node.right, cnt)\n\n    dfs(root, 0)\n\n    return res\n\n\n# Iterative\ndef maxDepthIterative(root: Optional[TreeNode]) -&gt; int:\n    if not root:\n        return 0\n\n    q = deque([root])\n    res = 0\n\n    while q:\n        res += 1\n        n = len(q)\n\n        for _ in range(n):\n            node = q.popleft()\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n\n    return res\n\n\nroot = [1, 2, 2, 3, 4, None, None, None, None, 5]\nroot = build(root)\nprint(root)\n#     ____1\n#    /     \\\n#   2__     2\n#  /   \\\n# 3     4\n#      /\n#     5\nprint(maxDepthRecursive(root))  # 4\nprint(maxDepthIterative(root))  # 4\nprint(maxDepthDFS(root))  # 4\n</code></pre>"},{"location":"neetcode150/trees/#543-diameter-of-binary-tree","title":"543. Diameter of Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul> 543. Diameter of Binary Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Tree DFS\ndef diameterOfBinaryTree(root: Optional[TreeNode]) -&gt; int:\n    diameter = 0\n\n    def dfs(node):\n        if not node:\n            return 0\n\n        left = dfs(node.left)\n        right = dfs(node.right)\n\n        nonlocal diameter\n        diameter = max(diameter, left + right)\n\n        return 1 + max(left, right)\n\n    dfs(root)\n    return diameter\n\n\nroot = build([1, 2, 3, 4, 5])\nprint(root)\n#     __1\n#    /   \\\n#   2     3\n#  / \\\n# 4   5\nprint(diameterOfBinaryTree(root))  # 3\n</code></pre>"},{"location":"neetcode150/trees/#110-balanced-binary-tree","title":"110. Balanced Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul> 110. Balanced Binary Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# Recursive\ndef isBalanced(root: Optional[TreeNode]) -&gt; bool:\n    def getHeight(node):\n        if not node:\n            return 0\n\n        # post order\n        leftHeight = getHeight(node.left)\n        rightHeight = getHeight(node.right)\n\n        if leftHeight == -1 or rightHeight == -1:\n            return -1\n\n        if abs(leftHeight - rightHeight) &gt; 1:\n            return -1\n        else:\n            return 1 + max(leftHeight, rightHeight)\n\n    if getHeight(root) != -1:\n        return True\n    else:\n        return False\n\n\nroot = [3, 9, 20, None, None, 15, 7]\nroot = build(root)\nprint(root)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(isBalanced(root))  # True\n</code></pre>"},{"location":"neetcode150/trees/#100-same-tree","title":"100. Same Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree</p> </li> </ul> 100. Same Tree - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\n# 1. Recursive\ndef isSameTreeRecursive(p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:\n    if not p and not q:\n        return True\n    if not p or not q:\n        return False\n    if p.val != q.val:\n        return False\n\n    return isSameTreeRecursive(p.left, q.left) and isSameTreeRecursive(\n        p.right, q.right\n    )\n\n\n# 2. Iterative with queue\ndef isSameTreeIterativeQueue(\n    p: Optional[TreeNode], q: Optional[TreeNode]\n) -&gt; bool:\n    queue = deque([(p, q)])\n\n    while queue:\n        p, q = queue.popleft()\n\n        if not p and not q:\n            continue\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n\n        queue.append((p.left, q.left))\n        queue.append((p.right, q.right))\n\n    return True\n\n\n# 3. Iterative with stack\ndef isSameTreeIterativeStack(\n    p: Optional[TreeNode], q: Optional[TreeNode]\n) -&gt; bool:\n    stack = [(p, q)]\n\n    while stack:\n        n1, n2 = stack.pop()\n\n        if not n1 and not n2:\n            continue\n        if not n1 or not n2:\n            return False\n        if n1.val != n2.val:\n            return False\n\n        stack.append((n1.left, n2.left))\n        stack.append((n1.right, n2.right))\n\n    return True\n\n\np1 = build([1, 2, 3])\nq1 = build([1, 2, 3])\np2 = build([1, 2])\nq2 = build([1, None, 2])\n\nprint(isSameTreeRecursive(p1, q1))  # True\nprint(isSameTreeRecursive(p2, q2))  # False\nprint(isSameTreeIterativeQueue(p1, q1))  # True\nprint(isSameTreeIterativeQueue(p2, q2))  # False\nprint(isSameTreeIterativeStack(p1, q1))  # True\nprint(isSameTreeIterativeStack(p2, q2))  # False\n</code></pre>"},{"location":"neetcode150/trees/#572-subtree-of-another-tree","title":"572. Subtree of Another Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: tree, depth first search, string matching, binary tree, hash function</p> </li> </ul> 572. Subtree of Another Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# DFS - Tree\ndef isSubtree(root: Optional[TreeNode], subRoot: Optional[TreeNode]) -&gt; bool:\n    def isSameTree(p, q):\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n\n        return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)\n\n    if not root:\n        return False\n\n    return (\n        isSameTree(root, subRoot)\n        or isSubtree(root.left, subRoot)\n        or isSubtree(root.right, subRoot)\n    )\n\n\n# |------------|---------|----------|\n# | Approach   | Time    | Space    |\n# |------------|---------|----------|\n# | DFS        | O(n * m)| O(n)     |\n# |------------|---------|----------|\n\n\nroot = build([3, 4, 5, 1, 2, None, None, None, None, 0])\nsubRoot = build([4, 1, 2])\nprint(root)\n#     ____3\n#    /     \\\n#   4__     5\n#  /   \\\n# 1     2\n#      /\n#     0\nprint(subRoot)\n#   4\n#  / \\\n# 1   2\nprint(isSubtree(root, subRoot))  # False\n</code></pre>"},{"location":"neetcode150/trees/#235-lowest-common-ancestor-of-a-binary-search-tree","title":"235. Lowest Common Ancestor of a Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree</p> </li> </ul> 235. Lowest Common Ancestor of a Binary Search Tree - Python Solution<pre><code>from binarytree import build\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef lowestCommonAncestor(\n    root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n) -&gt; \"TreeNode\":\n    while root:\n        if root.val &gt; p.val and root.val &gt; q.val:\n            root = root.left\n        elif root.val &lt; p.val and root.val &lt; q.val:\n            root = root.right\n        else:\n            return root\n\n\nroot = [6, 2, 8, 0, 4, 7, 9, None, None, 3, 5]\nroot = build(root)\np = root.left\nq = root.right\nprint(root)\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\nprint(lowestCommonAncestor(root, p, q))\n#     ______6__\n#    /         \\\n#   2__         8\n#  /   \\       / \\\n# 0     4     7   9\n#      / \\\n#     3   5\n</code></pre>"},{"location":"neetcode150/trees/#102-binary-tree-level-order-traversal","title":"102. Binary Tree Level Order Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, breadth first search, binary tree</p> </li> </ul> 102. Binary Tree Level Order Traversal - Python Solution<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef levelOrder(root: Optional[TreeNode]) -&gt; List[List[int]]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        level = []\n        n = len(q)\n\n        for _ in range(n):\n            cur = q.popleft()\n            level.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n        res.append(level)\n\n    return res\n\n\ntree = build([3, 9, 20, None, None, 15, 7])\nprint(tree)\n#   3___\n#  /    \\\n# 9     _20\n#      /   \\\n#     15    7\nprint(levelOrder(tree))  # [[3], [9, 20], [15, 7]]\n</code></pre>"},{"location":"neetcode150/trees/#199-binary-tree-right-side-view","title":"199. Binary Tree Right Side View","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree <pre><code>    ____1       &lt;---\n   /     \\\n  2__     2     &lt;--- Look at the rightmost node at each level\n /   \\     \\\n3     4     3   &lt;---\n     /\n    5           &lt;---\n</code></pre></p> </li> </ul> 199. Binary Tree Right Side View - Python Solution<pre><code>from collections import deque\nfrom typing import List, Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Binary Tree\ndef rightSideView(root: Optional[TreeNode]) -&gt; List[int]:\n    if not root:\n        return []\n\n    q = deque([root])\n    res = []\n\n    while q:\n        n = len(q)\n\n        for i in range(n):\n            cur = q.popleft()\n\n            # rightmost element\n            if i == n - 1:\n                res.append(cur.val)\n\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n\n    return res\n\n\nroot = [1, 2, 2, 3, 4, None, 3, None, None, 5]\nroot = build(root)\nprint(root)\n#     ____1\n#    /     \\\n#   2__     2\n#  /   \\     \\\n# 3     4     3\n#      /\n#     5\nprint(rightSideView(root))  # [1, 2, 3, 5]\n</code></pre>"},{"location":"neetcode150/trees/#1448-count-good-nodes-in-binary-tree","title":"1448. Count Good Nodes in Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, binary tree</p> </li> </ul> 1448. Count Good Nodes in Binary Tree - Python Solution<pre><code>from typing import List\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# Tree\ndef goodNodes(root: TreeNode) -&gt; int:\n    def dfs(node, max_val):\n        if not node:\n            return 0\n\n        good = 1 if node.val &gt;= max_val else 0\n\n        max_val = max(max_val, node.val)\n\n        good += dfs(node.left, max_val)\n        good += dfs(node.right, max_val)\n\n        return good\n\n    return dfs(root, root.val)\n\n\nroot = build([3, 1, 4, 3, None, 1, 5])\nprint(root)\n#     3__\n#    /   \\\n#   1     4\n#  /     / \\\n# 3     1   5\nprint(goodNodes(root))  # 4\n</code></pre>"},{"location":"neetcode150/trees/#98-validate-binary-search-tree","title":"98. Validate Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree</p> </li> </ul> 98. Validate Binary Search Tree - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef isValidBST(root: Optional[TreeNode]) -&gt; bool:\n    inorder = []  # inorder traversal of BST\n\n    def dfs(node):\n        if not node:\n            return None\n        dfs(node.left)\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    for i in range(1, len(inorder)):\n        if inorder[i] &lt;= inorder[i - 1]:\n            return False\n\n    return True\n\n\nroot = [5, 1, 4, None, None, 3, 6]\nroot = build(root)\nprint(root)\n#   5__\n#  /   \\\n# 1     4\n#      / \\\n#     3   6\nprint(isValidBST(root))  # False\n# [1, 5, 3, 4, 6]\n</code></pre>"},{"location":"neetcode150/trees/#230-kth-smallest-element-in-a-bst","title":"230. Kth Smallest Element in a BST","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary search tree, binary tree</p> </li> </ul> 230. Kth Smallest Element in a BST - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BST\ndef kthSmallest(root: Optional[TreeNode], k: int) -&gt; int:\n    inorder = []\n\n    def dfs(node):\n        if not node:\n            return None\n\n        dfs(node.left)\n        nonlocal inorder\n        inorder.append(node.val)\n        dfs(node.right)\n\n    dfs(root)\n\n    return inorder[k - 1]\n\n\n# |----------|------|-------|\n# | Approach | Time | Space |\n# |----------|------|-------|\n# | DFS      | O(n) | O(n)  |\n# |----------|------|-------|\n\n\nroot = build([3, 1, 4, None, 2])\nk = 1\nprint(root)\n#   __3\n#  /   \\\n# 1     4\n#  \\\n#   2\nprint(kthSmallest(root, k))  # 1\n</code></pre>"},{"location":"neetcode150/trees/#105-construct-binary-tree-from-preorder-and-inorder-traversal","title":"105. Construct Binary Tree from Preorder and Inorder Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, divide and conquer, tree, binary tree</p> </li> </ul> 105. Construct Binary Tree from Preorder and Inorder Traversal - Python Solution<pre><code>from typing import List, Optional\n\nfrom helper import TreeNode\n\n\ndef buildTree(preorder: List[int], inorder: List[int]) -&gt; Optional[TreeNode]:\n    \"\"\"\n    preorder  root left right  1  2  3\n    inorder   left root right  4  5  6\n    \"\"\"\n    if len(preorder) == 0:\n        return None\n\n    root_val = preorder[0]  # 1\n    root = TreeNode(root_val)\n\n    separator_idx = inorder.index(root_val)  # 5\n\n    left_inorder = inorder[:separator_idx]  # 4\n    right_inorder = inorder[separator_idx + 1 :]  # 6\n\n    left_preorder = preorder[1 : 1 + len(left_inorder)]  # 2\n    right_preorder = preorder[1 + len(left_inorder) :]  # 3\n\n    root.left = buildTree(left_preorder, left_inorder)\n    root.right = buildTree(right_preorder, right_inorder)\n\n    return root\n\n\npreorder = [3, 9, 20, 15, 7]\ninorder = [9, 3, 15, 20, 7]\nroot = buildTree(preorder, inorder)\nprint(root)\n#     3\n#    / \\\n#   9  20\n#     /  \\\n#    15   7\n</code></pre>"},{"location":"neetcode150/trees/#124-binary-tree-maximum-path-sum","title":"124. Binary Tree Maximum Path Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: dynamic programming, tree, depth first search, binary tree</p> </li> </ul> 124. Binary Tree Maximum Path Sum - Python Solution<pre><code>from typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\ndef maxPathSum(root: Optional[TreeNode]) -&gt; int:\n\n    res = float(\"-inf\")\n\n    def dfs(node):\n        if not node:\n            return 0\n\n        leftMax = max(dfs(node.left), 0)\n        rightMax = max(dfs(node.right), 0)\n\n        cur = node.val + leftMax + rightMax\n        nonlocal res\n        res = max(res, cur)\n\n        return node.val + max(leftMax, rightMax)\n\n    dfs(root)\n\n    return res\n\n\nroot = build([-10, 9, 20, None, None, 15, 7])\nprint(root)\n#   -10___\n#  /      \\\n# 9       _20\n#        /   \\\n#       15    7\nprint(maxPathSum(root))  # 42\n</code></pre>"},{"location":"neetcode150/trees/#297-serialize-and-deserialize-binary-tree","title":"297. Serialize and Deserialize Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, tree, depth first search, breadth first search, design, binary tree</p> </li> </ul> 297. Serialize and Deserialize Binary Tree - Python Solution<pre><code>from collections import deque\nfrom typing import Optional\n\nfrom binarytree import Node as TreeNode\nfrom binarytree import build\n\n\n# BFS\nclass BFS:\n    def serialize(self, root: Optional[TreeNode]) -&gt; str:\n        if not root:\n            return \"\"\n\n        res = []\n        q = deque([root])\n\n        while q:\n            node = q.popleft()\n\n            if node:\n                res.append(str(node.val))\n                q.append(node.left)\n                q.append(node.right)\n            else:\n                res.append(\"null\")\n\n        return \",\".join(res)\n\n    def deserialize(self, data: str) -&gt; Optional[TreeNode]:\n        if not data:\n            return None\n\n        nodes = data.split(\",\")\n        root = TreeNode(int(nodes[0]))\n        q = deque([root])\n        index = 1\n\n        while q:\n            node = q.popleft()\n\n            if nodes[index] != \"null\":\n                node.left = TreeNode(int(nodes[index]))\n                q.append(node.left)\n            index += 1\n\n            if nodes[index] != \"null\":\n                node.right = TreeNode(int(nodes[index]))\n                q.append(node.right)\n            index += 1\n\n        return root\n\n\n# DFS\nclass DFS:\n    def serialize(self, root: Optional[TreeNode]) -&gt; str:\n        def dfs(node):\n            if not node:\n                return [\"null\"]\n            return [str(node.val)] + dfs(node.left) + dfs(node.right)\n\n        return \",\".join(dfs(root))\n\n    def deserialize(self, data: str) -&gt; Optional[TreeNode]:\n        nodes = data.split(\",\")\n        self.index = 0\n\n        def dfs():\n            if nodes[self.index] == \"null\":\n                self.index += 1\n                return None\n\n            node = TreeNode(int(nodes[self.index]))\n            self.index += 1\n\n            node.left = dfs()\n            node.right = dfs()\n\n            return node\n\n        root = dfs()\n        return root\n\n\nroot = build([1, 2, 3, None, None, 4, 5])\nprint(root)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n\nbfs = BFS()\ndata1 = bfs.serialize(root)\nprint(data1)  # \"1,2,3,null,null,4,5,null,null,null,null\"\nroot1 = bfs.deserialize(data1)\nprint(root1)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n\ndfs = DFS()\ndata2 = dfs.serialize(root)\nprint(data2)  # \"1,2,null,null,3,4,null,null,5,null,null\"\nroot2 = dfs.deserialize(data2)\nprint(root2)\n#   1__\n#  /   \\\n# 2     3\n#      / \\\n#     4   5\n</code></pre>"},{"location":"neetcode150/tries/","title":"Tries","text":"<ul> <li> 208. Implement Trie (Prefix Tree) (Medium)</li> <li> 211. Design Add and Search Words Data Structure (Medium)</li> <li> 212. Word Search II (Hard)</li> </ul>"},{"location":"neetcode150/tries/#208-implement-trie-prefix-tree","title":"208. Implement Trie (Prefix Tree)","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, design, trie</p> </li> </ul>"},{"location":"neetcode150/tries/#trie","title":"Trie","text":"<ul> <li>A trie is a tree-like data structure whose nodes store the letters of an alphabet.</li> </ul> <pre><code>flowchart TD\nRoot(( ))\nRoot --- C1((\"C\"))\nRoot --- D((D))\nC1 --- A1((\"A\"))\nA1 --- T1((\"T\"))\nA1 --- R1((\"R\"))\nA1 --- N((N))\nRoot --- B1((B))\nB1 --- A2((A))\nA2 --- T2((T))\nA2 --- R2((R))</code></pre> 208. Implement Trie (Prefix Tree) - Python Solution<pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.endOfWord = None\n\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.endOfWord = True\n\n    def search(self, word: str) -&gt; bool:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return node.endOfWord\n\n    def startsWith(self, prefix: str) -&gt; bool:\n        node = self.root\n\n        for c in prefix:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return True\n\n\n# Your Trie object will be instantiated and called as such:\nobj = Trie()\nobj.insert(\"apple\")\nprint(obj.search(\"word\"))  # False\nprint(obj.startsWith(\"app\"))  # True\n</code></pre>"},{"location":"neetcode150/tries/#211-design-add-and-search-words-data-structure","title":"211. Design Add and Search Words Data Structure","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, depth first search, design, trie</p> </li> </ul> 211. Design Add and Search Words Data Structure - Python Solution<pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.word = False\n\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -&gt; None:\n        node = self.root\n\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.word = True\n\n    def search(self, word: str) -&gt; bool:\n\n        def dfs(j, root):\n            node = root\n\n            for i in range(j, len(word)):\n                c = word[i]\n\n                if c == \".\":\n                    for child in node.children.values():\n                        if dfs(i + 1, child):\n                            return True\n                    return False\n                else:\n                    if c not in node.children:\n                        return False\n                    node = node.children[c]\n            return node.word\n\n        return dfs(0, self.root)\n\n\n# Your WordDictionary object will be instantiated and called as such:\nobj = WordDictionary()\nobj.addWord(\"word\")\nprint(obj.search(\"word\"))\nprint(obj.search(\"w.rd\"))\n</code></pre>"},{"location":"neetcode150/tries/#212-word-search-ii","title":"212. Word Search II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, backtracking, trie, matrix</p> </li> </ul> 212. Word Search II - Python Solution<pre><code>from typing import List\n\nfrom template import TrieNode\n\n\n# Backtracking + Trie\ndef findWords(board: List[List[str]], words: List[str]) -&gt; List[str]:\n    root = TrieNode()\n    for word in words:\n        root.addWord(word)\n\n    m, n = len(board), len(board[0])\n    result, visit = set(), set()\n\n    def dfs(r, c, node, word):\n        if (\n            r &lt; 0\n            or r &gt;= m\n            or c &lt; 0\n            or c &gt;= n\n            or (r, c) in visit\n            or board[r][c] not in node.children\n        ):\n            return None\n\n        visit.add((r, c))\n\n        node = node.children[board[r][c]]\n        word += board[r][c]\n        if node.isWord:\n            result.add(word)\n\n        dfs(r - 1, c, node, word)\n        dfs(r + 1, c, node, word)\n        dfs(r, c - 1, node, word)\n        dfs(r, c + 1, node, word)\n\n        visit.remove((r, c))\n\n    for r in range(m):\n        for c in range(n):\n            dfs(r, c, root, \"\")\n\n    return list(result)\n\n\nboard = [\n    [\"o\", \"a\", \"a\", \"n\"],\n    [\"e\", \"t\", \"a\", \"e\"],\n    [\"i\", \"h\", \"k\", \"r\"],\n    [\"i\", \"f\", \"l\", \"v\"],\n]\nwords = [\"oath\", \"pea\", \"eat\", \"rain\"]\nprint(findWords(board, words))\n# ['eat', 'oath']\n</code></pre>"},{"location":"neetcode150/two_pointers/","title":"Two Pointers","text":"<ul> <li> 125. Valid Palindrome (Easy)</li> <li> 167. Two Sum II - Input Array Is Sorted (Medium)</li> <li> 15. 3Sum (Medium)</li> <li> 11. Container With Most Water (Medium)</li> <li> 42. Trapping Rain Water (Hard)</li> </ul>"},{"location":"neetcode150/two_pointers/#125-valid-palindrome","title":"125. Valid Palindrome","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: two pointers, string</p> </li> </ul> 125. Valid Palindrome - Python Solution<pre><code># List Comprehension\ndef isPalindrome(s: str) -&gt; bool:\n    s = [char.lower() for char in s if char.isalnum()]\n    return s == s[::-1]\n\n\n# Left Right Pointers\ndef isPalindromeLR(s: str) -&gt; bool:\n    left, right = 0, len(s) - 1\n\n    while left &lt; right:\n        while left &lt; right and not s[left].isalnum():\n            left += 1\n        while left &lt; right and not s[right].isalnum():\n            right -= 1\n\n        if s[left].lower() != s[right].lower():\n            return False\n\n        left += 1\n        right -= 1\n\n    return True\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\ns = \"A man, a plan, a canal: Panama\"\nprint(isPalindrome(s))  # True\nprint(isPalindromeLR(s))  # True\n</code></pre>"},{"location":"neetcode150/two_pointers/#167-two-sum-ii-input-array-is-sorted","title":"167. Two Sum II - Input Array Is Sorted","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, binary search</p> </li> </ul> 167. Two Sum II - Input Array Is Sorted - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef twoSum(numbers: List[int], target: int) -&gt; List[int]:\n    left, right = 0, len(numbers) - 1\n\n    while left &lt; right:\n        total = numbers[left] + numbers[right]\n\n        if total &gt; target:\n            right -= 1\n        elif total &lt; target:\n            left += 1\n        else:\n            return [left + 1, right + 1]\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nnumbers = [2, 7, 11, 15]\ntarget = 9\nprint(twoSum(numbers, target))  # [1, 2]\n</code></pre>"},{"location":"neetcode150/two_pointers/#15-3sum","title":"15. 3Sum","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, sorting</p> </li> </ul> 15. 3Sum - Python Solution<pre><code>from typing import List\n\n\n# Left Right Pointers\ndef threeSum(nums: List[int]) -&gt; List[List[int]]:\n    nums.sort()\n    res = []\n    n = len(nums)\n\n    for i in range(n - 2):\n        if i &gt; 0 and nums[i] == nums[i - 1]:\n            continue\n\n        left, right = i + 1, n - 1\n\n        while left &lt; right:\n            total = nums[i] + nums[left] + nums[right]\n\n            if total &gt; 0:\n                right -= 1\n            elif total &lt; 0:\n                left += 1\n            else:\n                res.append([nums[i], nums[left], nums[right]])\n\n                while left &lt; right and nums[left] == nums[left + 1]:\n                    left += 1\n\n                while left &lt; right and nums[right] == nums[right - 1]:\n                    right -= 1\n\n                left += 1\n                right -= 1\n\n    return res\n\n\nnums = [-1, 0, 1, 2, -1, -4]\nassert threeSum(nums) == [[-1, -1, 2], [-1, 0, 1]]\n</code></pre>"},{"location":"neetcode150/two_pointers/#11-container-with-most-water","title":"11. Container With Most Water","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy</p> </li> <li>Return the maximum area of water that can be trapped between the vertical lines.</li> </ul> <p></p> 11. Container With Most Water - Python Solution<pre><code>from typing import List\n\n\n# Brute Force\ndef maxAreaBF(height: List[int]) -&gt; int:\n    max_area = 0\n\n    for i in range(len(height)):\n        for j in range(i + 1, len(height)):\n            h = min(height[i], height[j])\n            w = j - i\n            max_area = max(max_area, h * w)\n\n    return max_area\n\n\n# Left Right Pointers\ndef maxAreaLR(height: List[int]) -&gt; int:\n    left, right = 0, len(height) - 1\n    res = 0\n\n    while left &lt; right:\n        h = min(height[left], height[right])\n        w = right - left\n        res = max(res, h * w)\n\n        if height[left] &lt; height[right]:\n            left += 1\n        else:\n            right -= 1\n\n    return res\n\n\n# |------------|------- |---------|\n# |  Approach  |  Time  |  Space  |\n# |------------|--------|---------|\n# | Brute Force| O(n^2) |  O(1)   |\n# | Left Right |  O(n)  |  O(1)   |\n# |------------|--------|---------|\n\n\nheight = [1, 8, 6, 2, 5, 4, 8, 3, 7]\nprint(maxAreaBF(height))  # 49\nprint(maxAreaLR(height))  # 49\n</code></pre>"},{"location":"neetcode150/two_pointers/#42-trapping-rain-water","title":"42. Trapping Rain Water","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, two pointers, dynamic programming, stack, monotonic stack</p> </li> <li></li> </ul> Approach Time Space DP O(N) O(N) Left Right O(N) O(1) Monotonic O(N) O(N) 42. Trapping Rain Water - Python Solution<pre><code>from typing import List\n\n\n# DP\ndef trapDP(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    n = len(height)\n    maxLeft, maxRight = [0 for _ in range(n)], [0 for _ in range(n)]\n\n    for i in range(1, n):\n        maxLeft[i] = max(maxLeft[i - 1], height[i - 1])\n\n    for i in range(n - 2, -1, -1):\n        maxRight[i] = max(maxRight[i + 1], height[i + 1])\n\n    res = 0\n    for i in range(n):\n        res += max(0, min(maxLeft[i], maxRight[i]) - height[i])\n\n    return res\n\n\n# Left Right Pointers\ndef trapLR(height: List[int]) -&gt; int:\n    if not height:\n        return 0\n\n    left, right = 0, len(height) - 1\n    maxL, maxR = height[left], height[right]\n    res = 0\n\n    while left &lt; right:\n        if maxL &lt; maxR:\n            left += 1\n            maxL = max(maxL, height[left])\n            res += maxL - height[left]\n        else:\n            right -= 1\n            maxR = max(maxR, height[right])\n            res += maxR - height[right]\n\n    return res\n\n\n# Monotonic Stack\ndef trapStack(height: List[int]) -&gt; int:\n    stack = []\n    total = 0\n\n    for i in range(len(height)):\n        while stack and height[i] &gt; height[stack[-1]]:\n            top = stack.pop()\n            if not stack:\n                break\n            distance = i - stack[-1] - 1\n            bounded_height = min(height[i], height[stack[-1]]) - height[top]\n            total += distance * bounded_height\n        stack.append(i)\n\n    return total\n\n\nheight = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\nprint(trapDP(height))  # 6\nprint(trapLR(height))  # 6\nprint(trapStack(height))  # 6\n</code></pre>"},{"location":"premium100/","title":"Premium 100","text":"<ul> <li> <p>Premium Algo 100</p> </li> <li> <p>Arrays / Strings</p> <ul> <li> 624. Maximum Distance in Arrays</li> <li> 280. Wiggle Sort</li> <li> 1056. Confusing Number</li> <li> 1427. Perform String Shifts</li> <li> 161. One Edit Distance</li> <li> 186. Reverse Words in a String II</li> <li> 1055. Shortest Way to Form String</li> </ul> </li> <li> <p>Sliding Window</p> <ul> <li> 159. Longest Substring with At Most Two Distinct Characters</li> <li> 340. Longest Substring with At Most K Distinct Characters</li> <li> 487. Max Consecutive Ones II</li> <li> 1100. Find K-Length Substrings With No Repeated Characters</li> </ul> </li> <li> <p>Hashing</p> <ul> <li> 760. Find Anagram Mappings</li> <li> 266. Palindrome Permutation</li> <li> 734. Sentence Similarity</li> <li> 1165. Single-Row Keyboard</li> <li> 249. Group Shifted Strings</li> <li> 1133. Largest Unique Number</li> <li> 1426. Counting Elements</li> <li> 1198. Find Smallest Common Element in All Rows</li> </ul> </li> <li> <p>Matrix</p> <ul> <li> 422. Valid Word Square</li> <li> 531. Lonely Pixel I</li> <li> 311. Sparse Matrix Multiplication</li> <li> 723. Candy Crush</li> </ul> </li> <li> <p>Interval Set</p> <ul> <li> 163. Missing Ranges</li> <li> 252. Meeting Rooms</li> <li> 253. Meeting Rooms II</li> <li> 616. Add Bold Tag in String</li> <li> 1272. Remove Interval</li> </ul> </li> <li> <p>Stack</p> <ul> <li> 439. Ternary Expression Parser</li> <li> 484. Find Permutation</li> <li> 772. Basic Calculator III</li> </ul> </li> <li> <p>Queue</p> <ul> <li> 346. Moving Average from Data Stream</li> <li> 1429. First Unique Number</li> </ul> </li> <li> <p>Linked List</p> <ul> <li> 1474. Delete N Nodes After M Nodes of a Linked List</li> <li> 708. Insert into a Sorted Circular Linked List</li> <li> 369. Plus One Linked List</li> <li> 1265. Print Immutable Linked List in Reverse</li> </ul> </li> <li> <p>Binary Tree</p> <ul> <li> 298. Binary Tree Longest Consecutive Sequence</li> <li> 549. Binary Tree Longest Consecutive Sequence II</li> <li> 250. Count Univalue Subtrees</li> <li> 1120. Maximum Average Subtree</li> <li> 545. Boundary of Binary Tree</li> <li> 366. Find Leaves of Binary Tree</li> <li> 314. Binary Tree Vertical Order Traversal</li> </ul> </li> <li> <p>Binary Search Tree</p> <ul> <li> 270. Closest Binary Search Tree Value</li> <li> 272. Closest Binary Search Tree Value II</li> <li> 255. Verify Preorder Sequence in Binary Search Tree</li> <li> 1214. Two Sum BSTs</li> <li> 333. Largest BST Subtree</li> </ul> </li> <li> <p>N-ary Tree</p> <ul> <li> 1490. Clone N-ary Tree</li> <li> 1506. Find Root of N-Ary Tree</li> <li> 1522. Diameter of N-Ary Tree</li> </ul> </li> <li> <p>Graph</p> <ul> <li> 277. Find the Celebrity</li> <li> 582. Kill Process</li> <li> 323. Number of Connected Components in an Undirected Graph</li> <li> 1059. All Paths from Source Lead to Destination</li> <li> 1236. Web Crawler</li> <li> 305. Number of Islands II</li> <li> 694. Number of Distinct Islands</li> <li> 1136. Parallel Courses</li> </ul> </li> <li> <p>Graph - Breadth-First Search</p> <ul> <li> 490. The Maze</li> <li> 505. The Maze II</li> <li> 499. The Maze III</li> <li> 1197. Minimum Knight Moves</li> <li> 286. Walls and Gates</li> <li> 317. Shortest Distance from All Buildings</li> <li> 269. Alien Dictionary</li> </ul> </li> <li> <p>Trie</p> <ul> <li> 588. Design In-Memory File System</li> <li> 642. Design Search Autocomplete System</li> </ul> </li> <li> <p>Heap</p> <ul> <li> 1086. High Five</li> <li> 1167. Minimum Cost to Connect Sticks</li> <li> 1057. Campus Bikes</li> <li> 358. Rearrange String k Distance Apart</li> </ul> </li> <li> <p>Binary Search</p> <ul> <li> 1228. Missing Number In Arithmetic Progression</li> <li> 1060. Missing Element in Sorted Array</li> <li> 1533. Find the Index of the Large Integer</li> <li> 1150. Check If a Number Is Majority Element in a Sorted Array</li> <li> 1231. Divide Chocolate</li> <li> 644. Maximum Average Subarray II</li> </ul> </li> <li> <p>Design</p> <ul> <li> 348. Design Tic-Tac-Toe</li> <li> 353. Design Snake Game</li> <li> 604. Design Compressed String Iterator</li> <li> 271. Encode and Decode Strings</li> <li> 281. Zigzag Iterator</li> <li> 716. Max Stack</li> <li> 1244. Design A Leaderboard</li> <li> 428. Serialize and Deserialize N-ary Tree</li> <li> 431. Encode N-ary Tree to Binary Tree</li> </ul> </li> <li> <p>Backtracking</p> <ul> <li> 247. Strobogrammatic Number II</li> <li> 254. Factor Combinations</li> <li> 1087. Brace Expansion</li> </ul> </li> <li> <p>Dynamic Programming</p> <ul> <li> 276. Paint Fence</li> <li> 256. Paint House</li> <li> 265. Paint House II</li> <li> 651. 4 Keys Keyboard</li> <li> 1259. Handshakes That Don't Cross</li> </ul> </li> <li> <p>Mathematics</p> <ul> <li> 1134. Armstrong Number</li> <li> 1180. Count Substrings with Only One Distinct Letter</li> <li> 1538. Guess the Majority in a Hidden Array</li> <li> 1183. Maximum Number of Ones</li> </ul> </li> </ul>"},{"location":"premium100/arrays_strings/","title":"Arrays Strings","text":"<ul> <li> 624. Maximum Distance in Arrays (Medium)</li> <li> 280. Wiggle Sort (Medium)</li> <li> 1056. Confusing Number (Easy)</li> <li> 1427. Perform String Shifts (Easy)</li> <li> 161. One Edit Distance (Medium)</li> <li> 186. Reverse Words in a String II (Medium)</li> <li> 1055. Shortest Way to Form String (Medium)</li> </ul>"},{"location":"premium100/arrays_strings/#624-maximum-distance-in-arrays","title":"624. Maximum Distance in Arrays","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy</p> </li> </ul> 624. Maximum Distance in Arrays - Python Solution<pre><code>from typing import List\n\n\n# Array\ndef maxDistance(arrays: List[List[int]]) -&gt; int:\n    mn, mx = float(\"inf\"), float(\"-inf\")\n    res = 0\n\n    for array in arrays:\n        mn = min(mn, array[0])\n        mx = max(mx, array[-1])\n        res = max(res, abs(array[-1] - mn), abs(mx - array[0]))\n\n    return res\n\n\narrays = [[1, 2, 3], [4, 5], [1, 2, 3]]\nprint(maxDistance(arrays))  # 4\n</code></pre>"},{"location":"premium100/arrays_strings/#280-wiggle-sort","title":"280. Wiggle Sort","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"premium100/arrays_strings/#1056-confusing-number","title":"1056. Confusing Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math</p> </li> </ul>"},{"location":"premium100/arrays_strings/#1427-perform-string-shifts","title":"1427. Perform String Shifts","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, math, string</p> </li> </ul>"},{"location":"premium100/arrays_strings/#161-one-edit-distance","title":"161. One Edit Distance","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string</p> </li> </ul>"},{"location":"premium100/arrays_strings/#186-reverse-words-in-a-string-ii","title":"186. Reverse Words in a String II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string</p> </li> </ul>"},{"location":"premium100/arrays_strings/#1055-shortest-way-to-form-string","title":"1055. Shortest Way to Form String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, string, binary search, greedy</p> </li> </ul>"},{"location":"premium100/backtracking/","title":"Backtracking","text":"<ul> <li> 247. Strobogrammatic Number II (Medium)</li> <li> 254. Factor Combinations (Medium)</li> <li> 1087. Brace Expansion (Medium)</li> </ul>"},{"location":"premium100/backtracking/#247-strobogrammatic-number-ii","title":"247. Strobogrammatic Number II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, recursion</p> </li> </ul>"},{"location":"premium100/backtracking/#254-factor-combinations","title":"254. Factor Combinations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: backtracking</p> </li> </ul>"},{"location":"premium100/backtracking/#1087-brace-expansion","title":"1087. Brace Expansion","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, backtracking, breadth first search</p> </li> </ul>"},{"location":"premium100/binary_search/","title":"Binary Search","text":"<ul> <li> 1228. Missing Number In Arithmetic Progression (Easy)</li> <li> 1060. Missing Element in Sorted Array (Medium)</li> <li> 1533. Find the Index of the Large Integer (Medium)</li> <li> 1150. Check If a Number Is Majority Element in a Sorted Array (Easy)</li> <li> 1231. Divide Chocolate (Hard)</li> <li> 644. Maximum Average Subarray II (Hard)</li> </ul>"},{"location":"premium100/binary_search/#1228-missing-number-in-arithmetic-progression","title":"1228. Missing Number In Arithmetic Progression","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, math</p> </li> </ul>"},{"location":"premium100/binary_search/#1060-missing-element-in-sorted-array","title":"1060. Missing Element in Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"premium100/binary_search/#1533-find-the-index-of-the-large-integer","title":"1533. Find the Index of the Large Integer","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, binary search, interactive</p> </li> </ul>"},{"location":"premium100/binary_search/#1150-check-if-a-number-is-majority-element-in-a-sorted-array","title":"1150. Check If a Number Is Majority Element in a Sorted Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"premium100/binary_search/#1231-divide-chocolate","title":"1231. Divide Chocolate","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search</p> </li> </ul>"},{"location":"premium100/binary_search/#644-maximum-average-subarray-ii","title":"644. Maximum Average Subarray II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, binary search, prefix sum</p> </li> </ul>"},{"location":"premium100/binary_search_tree/","title":"Binary Search Tree","text":"<ul> <li> 270. Closest Binary Search Tree Value (Easy)</li> <li> 272. Closest Binary Search Tree Value II (Hard)</li> <li> 255. Verify Preorder Sequence in Binary Search Tree (Medium)</li> <li> 1214. Two Sum BSTs (Medium)</li> <li> 333. Largest BST Subtree (Medium)</li> </ul>"},{"location":"premium100/binary_search_tree/#270-closest-binary-search-tree-value","title":"270. Closest Binary Search Tree Value","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: binary search, tree, depth first search, binary search tree, binary tree</p> </li> </ul>"},{"location":"premium100/binary_search_tree/#272-closest-binary-search-tree-value-ii","title":"272. Closest Binary Search Tree Value II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: two pointers, stack, tree, depth first search, binary search tree, heap priority queue, binary tree</p> </li> </ul>"},{"location":"premium100/binary_search_tree/#255-verify-preorder-sequence-in-binary-search-tree","title":"255. Verify Preorder Sequence in Binary Search Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, stack, tree, binary search tree, recursion, monotonic stack, binary tree</p> </li> </ul>"},{"location":"premium100/binary_search_tree/#1214-two-sum-bsts","title":"1214. Two Sum BSTs","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, binary search, stack, tree, depth first search, binary search tree, binary tree</p> </li> </ul>"},{"location":"premium100/binary_search_tree/#333-largest-bst-subtree","title":"333. Largest BST Subtree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming, tree, depth first search, binary search tree, binary tree</p> </li> </ul>"},{"location":"premium100/binary_tree/","title":"Binary Tree","text":"<ul> <li> 298. Binary Tree Longest Consecutive Sequence (Medium)</li> <li> 549. Binary Tree Longest Consecutive Sequence II (Medium)</li> <li> 250. Count Univalue Subtrees (Medium)</li> <li> 1120. Maximum Average Subtree (Medium)</li> <li> 545. Boundary of Binary Tree (Medium)</li> <li> 366. Find Leaves of Binary Tree (Medium)</li> <li> 314. Binary Tree Vertical Order Traversal (Medium)</li> </ul>"},{"location":"premium100/binary_tree/#298-binary-tree-longest-consecutive-sequence","title":"298. Binary Tree Longest Consecutive Sequence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"premium100/binary_tree/#549-binary-tree-longest-consecutive-sequence-ii","title":"549. Binary Tree Longest Consecutive Sequence II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"premium100/binary_tree/#250-count-univalue-subtrees","title":"250. Count Univalue Subtrees","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"premium100/binary_tree/#1120-maximum-average-subtree","title":"1120. Maximum Average Subtree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"premium100/binary_tree/#545-boundary-of-binary-tree","title":"545. Boundary of Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"premium100/binary_tree/#366-find-leaves-of-binary-tree","title":"366. Find Leaves of Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search, binary tree</p> </li> </ul>"},{"location":"premium100/binary_tree/#314-binary-tree-vertical-order-traversal","title":"314. Binary Tree Vertical Order Traversal","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, tree, depth first search, breadth first search, sorting, binary tree</p> </li> </ul>"},{"location":"premium100/design/","title":"Design","text":"<ul> <li> 348. Design Tic-Tac-Toe (Medium)</li> <li> 353. Design Snake Game (Medium)</li> <li> 604. Design Compressed String Iterator (Easy)</li> <li> 271. Encode and Decode Strings (Medium)</li> <li> 281. Zigzag Iterator (Medium)</li> <li> 716. Max Stack (Hard)</li> <li> 1244. Design A Leaderboard (Medium)</li> <li> 428. Serialize and Deserialize N-ary Tree (Hard)</li> <li> 431. Encode N-ary Tree to Binary Tree (Hard)</li> </ul>"},{"location":"premium100/design/#348-design-tic-tac-toe","title":"348. Design Tic-Tac-Toe","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, design, matrix, simulation</p> </li> </ul>"},{"location":"premium100/design/#353-design-snake-game","title":"353. Design Snake Game","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, design, queue, simulation</p> </li> </ul> 353. Design Snake Game - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\nclass SnakeGame:\n\n    def __init__(self, width: int, height: int, food: List[List[int]]):\n        self.width = width\n        self.height = height\n        self.food = deque(food)\n        self.snake = deque([(0, 0)])  # Snake starts at the top-left corner\n        self.snake_body = set([(0, 0)])  # To quickly check for collisions\n        self.score = 0\n        self.dirs = {\"U\": (-1, 0), \"L\": (0, -1), \"R\": (0, 1), \"D\": (1, 0)}\n\n    def move(self, direction: str) -&gt; int:\n        head = self.snake[0]\n        dx, dy = self.dirs[direction]\n        new_head = (head[0] + dx, head[1] + dy)\n\n        # Check if the new head is out of bounds\n        if not (\n            0 &lt;= new_head[0] &lt; self.height and 0 &lt;= new_head[1] &lt; self.width\n        ):\n            return -1\n\n        # Check if the new head collides with the snake body (excluding the tail)\n        if new_head in self.snake_body and new_head != self.snake[-1]:\n            return -1\n\n        # Check if the new head is on a food cell\n        if self.food and self.food[0] == list(new_head):\n            self.food.popleft()\n            self.score += 1\n        else:\n            tail = self.snake.pop()\n            self.snake_body.remove(tail)\n\n        # Add the new head to the snake\n        self.snake.appendleft(new_head)\n        self.snake_body.add(new_head)\n\n        return self.score\n\n\nsnake = SnakeGame(3, 2, [[1, 2], [0, 1]])\nprint(snake.move(\"R\"))  # 0\nprint(snake.move(\"D\"))  # 0\nprint(snake.move(\"R\"))  # 1\nprint(snake.move(\"U\"))  # 1\nprint(snake.move(\"L\"))  # 2\nprint(snake.move(\"U\"))  # -1\n</code></pre>"},{"location":"premium100/design/#604-design-compressed-string-iterator","title":"604. Design Compressed String Iterator","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, string, design, iterator</p> </li> </ul>"},{"location":"premium100/design/#271-encode-and-decode-strings","title":"271. Encode and Decode Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, design</p> </li> </ul> 271. Encode and Decode Strings - Python Solution<pre><code>from typing import List\n\n\nclass Codec:\n    def encode(self, strs: List[str]) -&gt; str:\n        \"\"\"Encodes a list of strings to a single string.\"\"\"\n        encoded = \"\"\n\n        for s in strs:\n            encoded += str(len(s)) + \"#\" + s\n\n        return encoded\n\n    def decode(self, s: str) -&gt; List[str]:\n        \"\"\"Decodes a single string to a list of strings.\"\"\"\n        decoded = []\n        i = 0\n\n        while i &lt; len(s):\n            j = i\n            while s[j] != \"#\":\n                j += 1\n\n            strLen = int(s[i:j])\n            decoded.append(s[j + 1 : j + 1 + strLen])\n            i = j + 1 + strLen\n\n        return decoded\n\n\n# |-------------|-------------|--------------|\n# |   Approach  |    Time     |    Space     |\n# |-------------|-------------|--------------|\n# | Two pointers|    O(n)     |     O(n)     |\n# |-------------|-------------|--------------|\n\n\ncodec = Codec()\nencoded = codec.encode([\"hello\", \"world\"])\nprint(encoded)  # \"5#hello5#world\"\ndecoded = codec.decode(encoded)\nprint(decoded)  # [\"hello\", \"world\"]\n</code></pre>"},{"location":"premium100/design/#281-zigzag-iterator","title":"281. Zigzag Iterator","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, design, queue, iterator</p> </li> </ul>"},{"location":"premium100/design/#716-max-stack","title":"716. Max Stack","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: linked list, stack, design, doubly linked list, ordered set</p> </li> </ul>"},{"location":"premium100/design/#1244-design-a-leaderboard","title":"1244. Design A Leaderboard","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, design, sorting</p> </li> </ul> 1244. Design A Leaderboard - Python Solution<pre><code>class Leaderboard:\n\n    def __init__(self):\n        self.scores = {}\n\n    def addScore(self, playerId: int, score: int) -&gt; None:\n        if playerId in self.scores:\n            self.scores[playerId] += score\n        else:\n            self.scores[playerId] = score\n\n    def top(self, K: int) -&gt; int:\n        topK = sorted(self.scores.values(), reverse=True)[:K]\n        return sum(topK)\n\n    def reset(self, playerId: int) -&gt; None:\n        if playerId in self.scores:\n            self.scores[playerId] = 0\n\n\nboard = Leaderboard()\nboard.addScore(1, 73)\nboard.addScore(2, 56)\nboard.addScore(3, 39)\nboard.addScore(4, 51)\nprint(board.top(1))  # 73\nboard.reset(1)\nboard.reset(2)\nprint(board.top(2))  # 90\n</code></pre>"},{"location":"premium100/design/#428-serialize-and-deserialize-n-ary-tree","title":"428. Serialize and Deserialize N-ary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, tree, depth first search, breadth first search</p> </li> </ul>"},{"location":"premium100/design/#431-encode-n-ary-tree-to-binary-tree","title":"431. Encode N-ary Tree to Binary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: tree, depth first search, breadth first search, design, binary tree</p> </li> </ul>"},{"location":"premium100/dynamic_programming/","title":"Dynamic Programming","text":"<ul> <li> 276. Paint Fence (Medium)</li> <li> 256. Paint House (Medium)</li> <li> 265. Paint House II (Hard)</li> <li> 651. 4 Keys Keyboard (Medium)</li> <li> 1259. Handshakes That Don't Cross (Hard)</li> </ul>"},{"location":"premium100/dynamic_programming/#276-paint-fence","title":"276. Paint Fence","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: dynamic programming</p> </li> </ul>"},{"location":"premium100/dynamic_programming/#256-paint-house","title":"256. Paint House","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"premium100/dynamic_programming/#265-paint-house-ii","title":"265. Paint House II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, dynamic programming</p> </li> </ul>"},{"location":"premium100/dynamic_programming/#651-4-keys-keyboard","title":"651. 4 Keys Keyboard","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: math, dynamic programming</p> </li> </ul>"},{"location":"premium100/dynamic_programming/#1259-handshakes-that-dont-cross","title":"1259. Handshakes That Don't Cross","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, dynamic programming</p> </li> </ul>"},{"location":"premium100/graph/","title":"Graph","text":"<ul> <li> 277. Find the Celebrity (Medium)</li> <li> 582. Kill Process (Medium)</li> <li> 323. Number of Connected Components in an Undirected Graph (Medium)</li> <li> 1059. All Paths from Source Lead to Destination (Medium)</li> <li> 1236. Web Crawler (Medium)</li> <li> 305. Number of Islands II (Hard)</li> <li> 694. Number of Distinct Islands (Medium)</li> <li> 1136. Parallel Courses (Medium)</li> </ul>"},{"location":"premium100/graph/#277-find-the-celebrity","title":"277. Find the Celebrity","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: two pointers, graph, interactive</p> </li> </ul>"},{"location":"premium100/graph/#582-kill-process","title":"582. Kill Process","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, tree, depth first search, breadth first search</p> </li> </ul>"},{"location":"premium100/graph/#323-number-of-connected-components-in-an-undirected-graph","title":"323. Number of Connected Components in an Undirected Graph","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: depth first search, breadth first search, union find, graph</p> </li> </ul> 323. Number of Connected Components in an Undirected Graph - Python Solution<pre><code>from typing import List\n\n\n# Union Find\ndef countComponents(n: int, edges: List[List[int]]) -&gt; int:\n    uf = UnionFind(n)\n    count = n\n\n    for u, v in edges:\n        count -= uf.union(u, v)\n\n    return count\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = {i: i for i in range(n)}\n        self.rank = {i: 1 for i in range(n)}\n\n    def find(self, n):\n        p = self.par[n]\n        while self.par[p] != p:\n            self.par[p] = self.par[self.par[p]]\n            p = self.par[p]\n        return p\n\n    def union(self, n1, n2):\n        p1, p2 = self.find(n1), self.find(n2)\n\n        if p1 == p2:\n            return 0\n\n        if self.rank[p1] &gt; self.rank[p2]:\n            self.par[p2] = p1\n        elif self.rank[p1] &lt; self.rank[p2]:\n            self.par[p1] = p2\n        else:\n            self.par[p2] = p1\n            self.rank[p1] += 1\n\n        return 1\n\n\nprint(countComponents(5, [[0, 1], [1, 2], [3, 4]]))  # 2\n</code></pre>"},{"location":"premium100/graph/#1059-all-paths-from-source-lead-to-destination","title":"1059. All Paths from Source Lead to Destination","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: graph, topological sort</p> </li> </ul>"},{"location":"premium100/graph/#1236-web-crawler","title":"1236. Web Crawler","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, depth first search, breadth first search, interactive</p> </li> </ul>"},{"location":"premium100/graph/#305-number-of-islands-ii","title":"305. Number of Islands II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, hash table, union find</p> </li> </ul> 305. Number of Islands II - Python Solution<pre><code>from collections import defaultdict\nfrom typing import List\n\n\n# Union Find\ndef numIslands2(m: int, n: int, positions: List[List[int]]) -&gt; List[int]:\n    parent = defaultdict(tuple)\n    islands = 0\n    result = []\n    visited = set()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def find(node):\n        p = parent[node]\n        while parent[p] != p:\n            parent[p] = parent[parent[p]]\n            p = parent[p]\n        return p\n\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 != p2:\n            parent[p1] = p2\n            return True\n        return False\n\n    for r, c in positions:\n        if (r, c) in visited:\n            result.append(islands)\n            continue\n\n        islands += 1\n        parent[(r, c)] = (r, c)\n        visited.add((r, c))\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if (nr, nc) in visited:\n                if union((r, c), (nr, nc)):\n                    islands -= 1\n\n        result.append(islands)\n\n    return result\n\n\nm = 3\nn = 3\npositions = [[0, 0], [0, 1], [1, 2], [2, 1]]\nprint(numIslands2(m, n, positions))  # [1, 1, 2, 3]\n</code></pre>"},{"location":"premium100/graph/#694-number-of-distinct-islands","title":"694. Number of Distinct Islands","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, depth first search, breadth first search, union find, hash function</p> </li> </ul>"},{"location":"premium100/graph/#1136-parallel-courses","title":"1136. Parallel Courses","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: graph, topological sort</p> </li> <li>Return the minimum number of semesters needed to take all courses.</li> </ul> <p></p> 1136. Parallel Courses - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# Topological Sort\ndef minimumSemesters(n: int, relations: List[List[int]]) -&gt; int:\n    graph = {i: [] for i in range(1, n + 1)}\n    indegree = {i: 0 for i in range(1, n + 1)}\n\n    for pre, nxt in relations:\n        graph[pre].append(nxt)\n        indegree[nxt] += 1\n\n    q = deque([i for i in range(1, n + 1) if indegree[i] == 0])\n    semester = 0\n    done = 0\n\n    while q:\n        semester += 1\n        size = len(q)\n\n        for _ in range(size):\n            pre = q.popleft()\n            done += 1\n\n            for nxt in graph[pre]:\n                indegree[nxt] -= 1\n                if indegree[nxt] == 0:\n                    q.append(nxt)\n\n    return semester if done == n else -1\n\n\nn = 3\nrelations = [[1, 3], [2, 3]]\nprint(minimumSemesters(n, relations))  # 2\n</code></pre>"},{"location":"premium100/graph_bfs/","title":"Graph BFS","text":"<ul> <li> 490. The Maze (Medium)</li> <li> 505. The Maze II (Medium)</li> <li> 499. The Maze III (Hard)</li> <li> 1197. Minimum Knight Moves (Medium)</li> <li> 286. Walls and Gates (Medium)</li> <li> 317. Shortest Distance from All Buildings (Hard)</li> <li> 269. Alien Dictionary (Hard)</li> </ul>"},{"location":"premium100/graph_bfs/#490-the-maze","title":"490. The Maze","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, matrix</p> </li> </ul>"},{"location":"premium100/graph_bfs/#505-the-maze-ii","title":"505. The Maze II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, depth first search, breadth first search, graph, heap priority queue, matrix, shortest path</p> </li> </ul> 505. The Maze II - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra\ndef shortestDistance(\n    maze: List[List[int]], start: List[int], destination: List[int]\n) -&gt; int:\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    m, n = len(maze), len(maze[0])\n\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    dist[start[0]][start[1]] = 0\n\n    heap = [(0, start[0], start[1])]\n\n    while heap:\n        d, r, c = heapq.heappop(heap)\n\n        if [r, c] == destination:\n            return d\n\n        for dr, dc in directions:\n            nr, nc, nd = r, c, d\n\n            while (\n                0 &lt;= nr + dr &lt; m\n                and 0 &lt;= nc + dc &lt; n\n                and maze[nr + dr][nc + dc] == 0\n            ):\n                nr += dr\n                nc += dc\n                nd += 1\n\n            if nd &lt; dist[nr][nc]:\n                dist[nr][nc] = nd\n                heapq.heappush(heap, (nd, nr, nc))\n\n    return -1\n\n\nmaze = [\n    [0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 0],\n    [0, 0, 0, 1, 0],\n    [1, 1, 0, 1, 1],\n    [0, 0, 0, 0, 0],\n]\nstart = [0, 4]\ndestination = [4, 4]\nprint(shortestDistance(maze, start, destination))  # 12\n</code></pre>"},{"location":"premium100/graph_bfs/#499-the-maze-iii","title":"499. The Maze III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, depth first search, breadth first search, graph, heap priority queue, matrix, shortest path</p> </li> </ul> 499. The Maze III - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Dijkstra\ndef findShortestWay(\n    maze: List[List[int]], ball: List[int], hole: List[int]\n) -&gt; str:\n    directions = [(-1, 0, \"u\"), (1, 0, \"d\"), (0, -1, \"l\"), (0, 1, \"r\")]\n    m, n = len(maze), len(maze[0])\n\n    dist = [[float(\"inf\")] * n for _ in range(m)]\n    dist[ball[0]][ball[1]] = 0\n\n    paths = [[\"\"] * n for _ in range(m)]\n    paths[ball[0]][ball[1]] = \"\"\n\n    heap = [(0, \"\", ball[0], ball[1])]\n\n    while heap:\n        d, path, x, y = heapq.heappop(heap)\n\n        if [x, y] == hole:\n            return path\n\n        for dx, dy, direction in directions:\n            nx, ny, nd = x, y, d\n\n            while (\n                0 &lt;= nx + dx &lt; m\n                and 0 &lt;= ny + dy &lt; n\n                and maze[nx + dx][ny + dy] == 0\n            ):\n                nx += dx\n                ny += dy\n                nd += 1\n\n                if [nx, ny] == hole:\n                    break\n\n            new_path = path + direction\n            if nd &lt; dist[nx][ny] or (\n                nd == dist[nx][ny] and new_path &lt; paths[nx][ny]\n            ):\n                dist[nx][ny] = nd\n                paths[nx][ny] = new_path\n                heapq.heappush(heap, (nd, new_path, nx, ny))\n\n    return \"impossible\"\n\n\nmaze = [\n    [0, 0, 0, 0, 0],\n    [1, 1, 0, 0, 1],\n    [0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 1],\n    [0, 1, 0, 0, 0],\n]\nball = [4, 3]\nhole = [0, 1]\nprint(findShortestWay(maze, ball, hole))  # \"lul\"\n</code></pre>"},{"location":"premium100/graph_bfs/#1197-minimum-knight-moves","title":"1197. Minimum Knight Moves","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: breadth first search</p> </li> </ul>"},{"location":"premium100/graph_bfs/#286-walls-and-gates","title":"286. Walls and Gates","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, breadth first search, matrix </p> </li> </ul> 286. Walls and Gates - Python Solution<pre><code>from collections import deque\nfrom typing import List\n\n\n# Multi-source BFS\ndef wallsAndGates(rooms: List[List[int]]) -&gt; None:\n    \"\"\"\n    Do not return anything, modify rooms in-place instead.\n    \"\"\"\n    m, n = len(rooms), len(rooms[0])\n    visited = set()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def addRoom(r, c):\n        if (\n            r in range(m)\n            and c in range(n)\n            and (r, c) not in visited\n            and rooms[r][c] != -1\n        ):\n            q.append((r, c))\n            visited.add((r, c))\n\n    q = deque()\n    for r in range(m):\n        for c in range(n):\n            if rooms[r][c] == 0:\n                q.append((r, c))\n                visited.add((r, c))\n\n    dist = 0\n\n    while q:\n        for _ in range(len(q)):\n            r, c = q.popleft()\n            rooms[r][c] = dist\n\n            for dr, dc in directions:\n                addRoom(r + dr, c + dc)\n        dist += 1\n\n\nrooms = [\n    [2147483647, -1, 0, 2147483647],\n    [2147483647, 2147483647, 2147483647, -1],\n    [2147483647, -1, 2147483647, -1],\n    [0, -1, 2147483647, 2147483647],\n]\nwallsAndGates(rooms)\nprint(rooms)\n# [[3, -1, 0,  1],\n#  [2,  2, 1, -1],\n#  [1, -1, 2, -1],\n#  [0, -1, 3,  4]]\n</code></pre>"},{"location":"premium100/graph_bfs/#317-shortest-distance-from-all-buildings","title":"317. Shortest Distance from All Buildings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, breadth first search, matrix</p> </li> </ul>"},{"location":"premium100/graph_bfs/#269-alien-dictionary","title":"269. Alien Dictionary","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: array, string, depth first search, breadth first search, graph, topological sort</p> </li> <li>Return the correct order of characters in the alien language.</li> </ul> 269. Alien Dictionary - Python Solution<pre><code>from collections import defaultdict, deque\nfrom typing import List\n\n\n# BFS - Kahn's algorithm (Topological Sort)\ndef alienOrderBFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    indegree = {c: 0 for word in words for c in word}\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                    indegree[w2[j]] += 1\n                break\n\n    q = deque([c for c in indegree if indegree[c] == 0])\n    result = []\n\n    while q:\n        char = q.popleft()\n        result.append(char)\n\n        for neighbor in graph[char]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                q.append(neighbor)\n\n    return \"\".join(result) if len(result) == len(indegree) else \"\"\n\n\n# DFS - Topological Sort\ndef alienOrderDFS(words: List[str]) -&gt; str:\n    graph = defaultdict(set)\n    visited = {}\n    result = []\n\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n\n        if len(w1) &gt; len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                break\n\n    def dfs(c):\n        if c in visited:\n            return visited[c]\n\n        visited[c] = False\n        for neighbor in graph[c]:\n            if not dfs(neighbor):\n                return False\n\n        visited[c] = True\n        result.append(c)\n        return True\n\n    for c in list(graph.keys()):\n        if not dfs(c):\n            return \"\"\n\n    return \"\".join(result[::-1])\n\n\nwords = [\"wrt\", \"wrf\", \"er\", \"ett\", \"rftt\"]\nprint(alienOrderBFS(words))  # wertf\nprint(alienOrderDFS(words))  # wertf\n</code></pre>"},{"location":"premium100/hashing/","title":"Hashing","text":"<ul> <li> 760. Find Anagram Mappings (Easy)</li> <li> 266. Palindrome Permutation (Easy)</li> <li> 734. Sentence Similarity (Easy)</li> <li> 1165. Single-Row Keyboard (Easy)</li> <li> 249. Group Shifted Strings (Medium)</li> <li> 1133. Largest Unique Number (Easy)</li> <li> 1426. Counting Elements (Easy)</li> <li> 1198. Find Smallest Common Element in All Rows (Medium)</li> </ul>"},{"location":"premium100/hashing/#760-find-anagram-mappings","title":"760. Find Anagram Mappings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table</p> </li> </ul>"},{"location":"premium100/hashing/#266-palindrome-permutation","title":"266. Palindrome Permutation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, string, bit manipulation</p> </li> </ul> 266. Palindrome Permutation - Python Solution<pre><code>from collections import defaultdict\n\n\n# Hash\ndef canPermutePalindromeDict(s: str) -&gt; bool:\n    if len(s) == 1:\n        return True\n\n    count = defaultdict(int)\n\n    for ch in s:\n        if count[ch] == 1:\n            count[ch] = 0\n            continue\n        count[ch] = 1\n\n    return sum(count.values()) &lt;= 1\n\n\n# Set\ndef canPermutePalindromeSet(s: str) -&gt; bool:\n    if len(s) == 1:\n        return True\n\n    seen = set()\n\n    for ch in s:\n        if ch in seen:\n            seen.remove(ch)\n        else:\n            seen.add(ch)\n\n    return len(seen) &lt;= 1\n\n\nassert canPermutePalindromeDict(\"carerac\") is True\nassert canPermutePalindromeSet(\"carerac\") is True\n</code></pre>"},{"location":"premium100/hashing/#734-sentence-similarity","title":"734. Sentence Similarity","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, string</p> </li> </ul>"},{"location":"premium100/hashing/#1165-single-row-keyboard","title":"1165. Single-Row Keyboard","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: hash table, string</p> </li> </ul>"},{"location":"premium100/hashing/#249-group-shifted-strings","title":"249. Group Shifted Strings","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string</p> </li> </ul>"},{"location":"premium100/hashing/#1133-largest-unique-number","title":"1133. Largest Unique Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, sorting</p> </li> </ul>"},{"location":"premium100/hashing/#1426-counting-elements","title":"1426. Counting Elements","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table</p> </li> </ul>"},{"location":"premium100/hashing/#1198-find-smallest-common-element-in-all-rows","title":"1198. Find Smallest Common Element in All Rows","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, binary search, matrix, counting</p> </li> </ul>"},{"location":"premium100/heap/","title":"Heap","text":"<ul> <li> 1086. High Five (Easy)</li> <li> 1167. Minimum Cost to Connect Sticks (Medium)</li> <li> 1057. Campus Bikes (Medium)</li> <li> 358. Rearrange String k Distance Apart (Hard)</li> </ul>"},{"location":"premium100/heap/#1086-high-five","title":"1086. High Five","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, hash table, sorting, heap priority queue</p> </li> </ul>"},{"location":"premium100/heap/#1167-minimum-cost-to-connect-sticks","title":"1167. Minimum Cost to Connect Sticks","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, heap priority queue</p> </li> </ul>"},{"location":"premium100/heap/#1057-campus-bikes","title":"1057. Campus Bikes","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, greedy, sorting</p> </li> </ul>"},{"location":"premium100/heap/#358-rearrange-string-k-distance-apart","title":"358. Rearrange String k Distance Apart","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, greedy, sorting, heap priority queue, counting</p> </li> </ul>"},{"location":"premium100/interval/","title":"Interval","text":"<ul> <li> 163. Missing Ranges (Easy)</li> <li> 252. Meeting Rooms (Easy)</li> <li> 253. Meeting Rooms II (Medium)</li> <li> 616. Add Bold Tag in String (Medium)</li> <li> 1272. Remove Interval (Medium)</li> </ul>"},{"location":"premium100/interval/#163-missing-ranges","title":"163. Missing Ranges","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array</p> </li> </ul>"},{"location":"premium100/interval/#252-meeting-rooms","title":"252. Meeting Rooms","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, sorting</p> </li> </ul> 252. Meeting Rooms - Python Solution<pre><code>from typing import List\n\n\n# Interval\ndef canAttendMeetings(intervals: List[List[int]]) -&gt; bool:\n    intervals.sort(key=lambda x: x[0])\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &lt; intervals[i - 1][1]:\n            return False\n\n    return True\n\n\nintervals = [[0, 30], [5, 10], [15, 20]]\nprint(canAttendMeetings(intervals))  # False\n</code></pre>"},{"location":"premium100/interval/#253-meeting-rooms-ii","title":"253. Meeting Rooms II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, greedy, sorting, heap priority queue, prefix sum</p> </li> </ul> 253. Meeting Rooms II - Python Solution<pre><code>import heapq\nfrom typing import List\n\n\n# Heap\ndef minMeetingRooms(intervals: List[List[int]]) -&gt; int:\n    if not intervals:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n    heap = [intervals[0][1]]\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] &gt;= heap[0]:\n            heapq.heappop(heap)\n        heapq.heappush(heap, intervals[i][1])\n\n    return len(heap)\n\n\nintervals = [[0, 30], [5, 10], [15, 20]]\nprint(minMeetingRooms(intervals))  # 2\n</code></pre>"},{"location":"premium100/interval/#616-add-bold-tag-in-string","title":"616. Add Bold Tag in String","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, string, trie, string matching</p> </li> </ul>"},{"location":"premium100/interval/#1272-remove-interval","title":"1272. Remove Interval","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array</p> </li> </ul>"},{"location":"premium100/linked_list/","title":"Linked List","text":"<ul> <li> 1474. Delete N Nodes After M Nodes of a Linked List (Easy)</li> <li> 708. Insert into a Sorted Circular Linked List (Medium)</li> <li> 369. Plus One Linked List (Medium)</li> <li> 1265. Print Immutable Linked List in Reverse (Medium)</li> </ul>"},{"location":"premium100/linked_list/#1474-delete-n-nodes-after-m-nodes-of-a-linked-list","title":"1474. Delete N Nodes After M Nodes of a Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: linked list</p> </li> </ul>"},{"location":"premium100/linked_list/#708-insert-into-a-sorted-circular-linked-list","title":"708. Insert into a Sorted Circular Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list</p> </li> </ul>"},{"location":"premium100/linked_list/#369-plus-one-linked-list","title":"369. Plus One Linked List","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, math</p> </li> </ul>"},{"location":"premium100/linked_list/#1265-print-immutable-linked-list-in-reverse","title":"1265. Print Immutable Linked List in Reverse","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: linked list, two pointers, stack, recursion</p> </li> </ul>"},{"location":"premium100/math/","title":"Math","text":"<ul> <li> 1134. Armstrong Number (Easy)</li> <li> 1180. Count Substrings with Only One Distinct Letter (Easy)</li> <li> 1538. Guess the Majority in a Hidden Array (Medium)</li> <li> 1183. Maximum Number of Ones (Hard)</li> </ul>"},{"location":"premium100/math/#1134-armstrong-number","title":"1134. Armstrong Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math</p> </li> </ul>"},{"location":"premium100/math/#1180-count-substrings-with-only-one-distinct-letter","title":"1180. Count Substrings with Only One Distinct Letter","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: math, string</p> </li> </ul>"},{"location":"premium100/math/#1538-guess-the-majority-in-a-hidden-array","title":"1538. Guess the Majority in a Hidden Array","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, math, interactive</p> </li> </ul>"},{"location":"premium100/math/#1183-maximum-number-of-ones","title":"1183. Maximum Number of Ones","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, greedy, sorting, heap priority queue</p> </li> </ul>"},{"location":"premium100/matrix/","title":"Matrix","text":"<ul> <li> 422. Valid Word Square (Easy)</li> <li> 531. Lonely Pixel I (Medium)</li> <li> 311. Sparse Matrix Multiplication (Medium)</li> <li> 723. Candy Crush (Medium)</li> </ul>"},{"location":"premium100/matrix/#422-valid-word-square","title":"422. Valid Word Square","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, matrix</p> </li> </ul>"},{"location":"premium100/matrix/#531-lonely-pixel-i","title":"531. Lonely Pixel I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, matrix</p> </li> </ul>"},{"location":"premium100/matrix/#311-sparse-matrix-multiplication","title":"311. Sparse Matrix Multiplication","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, matrix</p> </li> </ul>"},{"location":"premium100/matrix/#723-candy-crush","title":"723. Candy Crush","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, two pointers, matrix, simulation</p> </li> </ul>"},{"location":"premium100/n-ary_tree/","title":"N-ary Tree","text":"<ul> <li> 1490. Clone N-ary Tree (Medium)</li> <li> 1506. Find Root of N-Ary Tree (Medium)</li> <li> 1522. Diameter of N-Ary Tree (Medium)</li> </ul>"},{"location":"premium100/n-ary_tree/#1490-clone-n-ary-tree","title":"1490. Clone N-ary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, tree, depth first search, breadth first search</p> </li> </ul>"},{"location":"premium100/n-ary_tree/#1506-find-root-of-n-ary-tree","title":"1506. Find Root of N-Ary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, bit manipulation, tree, depth first search</p> </li> </ul>"},{"location":"premium100/n-ary_tree/#1522-diameter-of-n-ary-tree","title":"1522. Diameter of N-Ary Tree","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: tree, depth first search</p> </li> </ul>"},{"location":"premium100/queue/","title":"Queue","text":"<ul> <li> 346. Moving Average from Data Stream (Easy)</li> <li> 1429. First Unique Number (Medium)</li> </ul>"},{"location":"premium100/queue/#346-moving-average-from-data-stream","title":"346. Moving Average from Data Stream","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: array, design, queue, data stream</p> </li> </ul>"},{"location":"premium100/queue/#1429-first-unique-number","title":"1429. First Unique Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, hash table, design, queue, data stream</p> </li> </ul>"},{"location":"premium100/sliding_window/","title":"Sliding Window","text":"<ul> <li> 159. Longest Substring with At Most Two Distinct Characters (Medium)</li> <li> 340. Longest Substring with At Most K Distinct Characters (Medium)</li> <li> 487. Max Consecutive Ones II (Medium)</li> <li> 1100. Find K-Length Substrings With No Repeated Characters (Medium)</li> </ul>"},{"location":"premium100/sliding_window/#159-longest-substring-with-at-most-two-distinct-characters","title":"159. Longest Substring with At Most Two Distinct Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> <li>Prerequisite: 3. Longest Substring Without Repeating Characters</li> </ul> 159. Longest Substring with At Most Two Distinct Characters - Python Solution<pre><code>from collections import defaultdict\n\n\n# Sliding Window - Variable\ndef lengthOfLongestSubstringTwoDistinct(s: str) -&gt; int:\n    n = len(s)\n    if n &lt;= 2:\n        return n\n\n    window = defaultdict(int)\n    left, res = 0, 0\n\n    for right in range(n):\n        window[s[right]] += 1\n\n        while len(window) &gt; 2:\n            window[s[left]] -= 1\n            if window[s[left]] == 0:\n                del window[s[left]]\n            left += 1\n\n        res = max(res, right - left + 1)\n\n    return res\n\n\ns = \"ccaabbb\"\nassert lengthOfLongestSubstringTwoDistinct(s) == 5\n</code></pre>"},{"location":"premium100/sliding_window/#340-longest-substring-with-at-most-k-distinct-characters","title":"340. Longest Substring with At Most K Distinct Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> </ul> 340. Longest Substring with At Most K Distinct Characters - Python Solution<pre><code>from collections import defaultdict\n\n\n# Sliding Window Variable\ndef lengthOfLongestSubstringKDistinct(s: str, k: int) -&gt; int:\n    n = len(s)\n    if n &lt;= k:\n        return n\n\n    window = defaultdict(int)\n    left, res = 0, 0\n\n    for right in range(n):\n        window[s[right]] += 1\n        while len(window) &gt; k:\n            window[s[left]] -= 1\n            if window[s[left]] == 0:\n                del window[s[left]]\n            left += 1\n        res = max(res, right - left + 1)\n\n    return res\n\n\ns = \"eceba\"\nk = 2\nassert lengthOfLongestSubstringKDistinct(s, k) == 3\n</code></pre>"},{"location":"premium100/sliding_window/#487-max-consecutive-ones-ii","title":"487. Max Consecutive Ones II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, dynamic programming, sliding window</p> </li> </ul>"},{"location":"premium100/sliding_window/#1100-find-k-length-substrings-with-no-repeated-characters","title":"1100. Find K-Length Substrings With No Repeated Characters","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: hash table, string, sliding window</p> </li> </ul>"},{"location":"premium100/stack/","title":"Stack","text":"<ul> <li> 439. Ternary Expression Parser (Medium)</li> <li> 484. Find Permutation (Medium)</li> <li> 772. Basic Calculator III (Hard)</li> </ul>"},{"location":"premium100/stack/#439-ternary-expression-parser","title":"439. Ternary Expression Parser","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: string, stack, recursion</p> </li> </ul>"},{"location":"premium100/stack/#484-find-permutation","title":"484. Find Permutation","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: array, string, stack, greedy</p> </li> </ul>"},{"location":"premium100/stack/#772-basic-calculator-iii","title":"772. Basic Calculator III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: math, string, stack, recursion</p> </li> </ul> 772. Basic Calculator III - Python Solution<pre><code># Stack\ndef calculate(s: str) -&gt; int:\n    def helper(index):\n        stack = []\n        num = 0\n        sign = \"+\"\n\n        while index &lt; len(s):\n            char = s[index]\n            if char.isdigit():\n                num = num * 10 + int(char)\n            if char == \"(\":\n                num, index = helper(index + 1)\n            if char in \"+-*/)\" or index == len(s) - 1:\n                if sign == \"+\":\n                    stack.append(num)\n                elif sign == \"-\":\n                    stack.append(-num)\n                elif sign == \"*\":\n                    stack.append(stack.pop() * num)\n                elif sign == \"/\":\n                    stack.append(int(stack.pop() / num))  # \u5411\u96f6\u53d6\u6574\n                num = 0\n                sign = char\n            if char == \")\":\n                break\n            index += 1\n\n        return sum(stack), index\n\n    s = s.replace(\" \", \"\")\n    result, _ = helper(0)\n\n    return result\n\n\ns = \"2*(5+5*2)/3+(6/2+8)\"\nprint(calculate(s))  # 21\n</code></pre>"},{"location":"premium100/trie/","title":"Trie","text":"<ul> <li> 588. Design In-Memory File System (Hard)</li> <li> 642. Design Search Autocomplete System (Hard)</li> </ul>"},{"location":"premium100/trie/#588-design-in-memory-file-system","title":"588. Design In-Memory File System","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: hash table, string, design, trie, sorting</p> </li> </ul> 588. Design In-Memory File System - Python Solution<pre><code>from collections import defaultdict\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children = defaultdict(TrieNode)\n        self.content = \"\"\n\n\n# Trie\nclass FileSystem:\n\n    def __init__(self):\n        self.root = TrieNode()\n\n    def ls(self, path: str) -&gt; list:\n        cur = self.root\n\n        if path != \"/\":\n            paths = path.split(\"/\")[1:]\n            for p in paths:\n                cur = cur.children[p]\n        if cur.content:\n            return [path.split(\"/\")[-1]]\n\n        return sorted(cur.children.keys())\n\n    def mkdir(self, path: str) -&gt; None:\n        cur = self.root\n        paths = path.split(\"/\")[1:]\n        for p in paths:\n            cur = cur.children[p]\n\n    def addContentToFile(self, filePath: str, content: str) -&gt; None:\n        cur = self.root\n        paths = filePath.split(\"/\")[1:]\n        for p in paths:\n            cur = cur.children[p]\n        cur.content += content\n\n    def readContentFromFile(self, filePath: str) -&gt; str:\n        cur = self.root\n        paths = filePath.split(\"/\")[1:]\n        for p in paths:\n            cur = cur.children[p]\n        return cur.content\n\n\nobj = FileSystem()\nobj.mkdir(\"/a/b/c\")\nobj.addContentToFile(\"/a/b/c/d\", \"hello\")\nprint(obj.ls(\"/\"))  # [\"a\"]\nprint(obj.readContentFromFile(\"/a/b/c/d\"))  # \"hello\"\n</code></pre>"},{"location":"premium100/trie/#642-design-search-autocomplete-system","title":"642. Design Search Autocomplete System","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: string, depth first search, design, trie, sorting, heap priority queue, data stream</p> </li> </ul>"},{"location":"sql50/","title":"SQL 50","text":"<ul> <li>List: LeetCode SQL 50 | \u9ad8\u9891 SQL 50 \u9898\uff08\u57fa\u7840\u7248\uff09</li> <li>YouTube Playlist: SQL 50 Series by Everyday Data Science</li> </ul>"},{"location":"sql50/advanced_select_and_joins/","title":"Advanced Select and Joins","text":"<ul> <li> 1731. The Number of Employees Which Report to Each Employee (Easy)</li> <li> 1789. Primary Department for Each Employee (Easy)</li> <li> 610. Triangle Judgement (Easy)</li> <li> 180. Consecutive Numbers (Medium)</li> <li> 1164. Product Price at a Given Date (Medium)</li> <li> 1204. Last Person to Fit in the Bus (Medium)</li> <li> 1907. Count Salary Categories (Medium)</li> </ul>"},{"location":"sql50/advanced_select_and_joins/#1731-the-number-of-employees-which-report-to-each-employee","title":"1731. The Number of Employees Which Report to Each Employee","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"sql50/advanced_select_and_joins/#1789-primary-department-for-each-employee","title":"1789. Primary Department for Each Employee","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"sql50/advanced_select_and_joins/#610-triangle-judgement","title":"610. Triangle Judgement","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"sql50/advanced_select_and_joins/#180-consecutive-numbers","title":"180. Consecutive Numbers","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"sql50/advanced_select_and_joins/#1164-product-price-at-a-given-date","title":"1164. Product Price at a Given Date","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"sql50/advanced_select_and_joins/#1204-last-person-to-fit-in-the-bus","title":"1204. Last Person to Fit in the Bus","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"sql50/advanced_select_and_joins/#1907-count-salary-categories","title":"1907. Count Salary Categories","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"sql50/advanced_string_functions_regex_clause/","title":"Advanced String Functions Regex Clause","text":"<ul> <li> 1667. Fix Names in a Table (Easy)</li> <li> 1527. Patients With a Condition (Easy)</li> <li> 196. Delete Duplicate Emails (Easy)</li> <li> 176. Second Highest Salary (Medium)</li> <li> 1484. Group Sold Products By The Date (Easy)</li> <li> 1327. List the Products Ordered in a Period (Easy)</li> <li> 1517. Find Users With Valid E-Mails (Easy)</li> </ul>"},{"location":"sql50/advanced_string_functions_regex_clause/#1667-fix-names-in-a-table","title":"1667. Fix Names in a Table","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"sql50/advanced_string_functions_regex_clause/#1527-patients-with-a-condition","title":"1527. Patients With a Condition","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"sql50/advanced_string_functions_regex_clause/#196-delete-duplicate-emails","title":"196. Delete Duplicate Emails","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"sql50/advanced_string_functions_regex_clause/#176-second-highest-salary","title":"176. Second Highest Salary","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"sql50/advanced_string_functions_regex_clause/#1484-group-sold-products-by-the-date","title":"1484. Group Sold Products By The Date","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"sql50/advanced_string_functions_regex_clause/#1327-list-the-products-ordered-in-a-period","title":"1327. List the Products Ordered in a Period","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"sql50/advanced_string_functions_regex_clause/#1517-find-users-with-valid-e-mails","title":"1517. Find Users With Valid E-Mails","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"sql50/basic_aggregate_functions/","title":"Basic Aggregate Functions","text":"<ul> <li> 620. Not Boring Movies (Easy)</li> <li> 1251. Average Selling Price (Easy)</li> <li> 1075. Project Employees I (Easy)</li> <li> 1633. Percentage of Users Attended a Contest (Easy)</li> <li> 1211. Queries Quality and Percentage (Easy)</li> <li> 1193. Monthly Transactions I (Medium)</li> <li> 1174. Immediate Food Delivery II (Medium)</li> <li> 550. Game Play Analysis IV (Medium)</li> </ul>"},{"location":"sql50/basic_aggregate_functions/#620-not-boring-movies","title":"620. Not Boring Movies","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul> 620. Not Boring Movies<pre><code>SELECT\n    id,\n    movie,\n    description,\n    rating\nFROM\n    cinema\nWHERE\n    id % 2 = 1\n    AND LOWER(description) NOT LIKE '%boring%'\nORDER BY\n    rating DESC;\n</code></pre>"},{"location":"sql50/basic_aggregate_functions/#1251-average-selling-price","title":"1251. Average Selling Price","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul> 1251. Average Selling Price<pre><code>SELECT\n    p.product_id,\n    COALESCE(\n        ROUND(SUM(p.price * u.units) / SUM(u.units), 2),\n        0\n    ) AS average_price\nFROM\n    prices AS p\nLEFT JOIN unitssold AS u\n    ON\n        p.product_id = u.product_id\n        AND u.purchase_date BETWEEN p.start_date AND p.end_date\nGROUP BY\n    p.product_id;\n</code></pre>"},{"location":"sql50/basic_aggregate_functions/#1075-project-employees-i","title":"1075. Project Employees I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul> 1075. Project Employees I<pre><code>SELECT\n    p.project_id,\n    ROUND(AVG(e.experience_years), 2) AS average_years\nFROM\n    project AS p\nLEFT JOIN employee AS e ON p.employee_id = e.employee_id\nGROUP BY\n    p.project_id\n</code></pre>"},{"location":"sql50/basic_aggregate_functions/#1633-percentage-of-users-attended-a-contest","title":"1633. Percentage of Users Attended a Contest","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul> 1633. Percentage of Users Attended a Contest<pre><code>SELECT\n    r.contest_id,\n    ROUND(\n        COUNT(DISTINCT r.user_id) / COUNT(DISTINCT u.user_id) * 100,\n        2\n    ) AS percentage\nFROM\n    users AS u\nCROSS JOIN register AS r\nGROUP BY\n    r.contest_id\nORDER BY\n    percentage DESC,\n    contest_id ASC\n</code></pre>"},{"location":"sql50/basic_aggregate_functions/#1211-queries-quality-and-percentage","title":"1211. Queries Quality and Percentage","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul> 1211. Queries Quality and Percentage<pre><code>Input:\nQueries table:\n+------------+-------------------+----------+--------+\n| query_name | result            | position | rating |\n+------------+-------------------+----------+--------+\n| Dog        | Golden Retriever  | 1        | 5      |\n| Dog        | German Shepherd   | 2        | 5      |\n| Dog        | Mule              | 200      | 1      |\n| Cat        | Shirazi           | 5        | 2      |\n| Cat        | Siamese           | 3        | 3      |\n| Cat        | Sphynx            | 7        | 4      |\n+------------+-------------------+----------+--------+\nOutput:\n+------------+---------+-----------------------+\n| query_name | quality | poor_query_percentage |\n+------------+---------+-----------------------+\n| Dog        | 2.50    | 33.33                 |\n| Cat        | 0.66    | 33.33                 |\n+------------+---------+-----------------------+\n</code></pre> 1211. Queries Quality and Percentage<pre><code>SELECT\n    query_name,\n    ROUND(AVG(rating / POSITION), 2) AS quality,\n    ROUND(SUM(IF(rating &lt; 3, 1, 0)) / COUNT(*) * 100, 2)\n        AS poor_query_percentage\nFROM\n    queries\nWHERE\n    query_name IS NOT NULL\nGROUP BY\n    query_name;\n</code></pre>"},{"location":"sql50/basic_aggregate_functions/#1193-monthly-transactions-i","title":"1193. Monthly Transactions I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: database</p> </li> </ul> 1193. Monthly Transactions I<pre><code>Input:\nTransactions table:\n+------+---------+----------+--------+------------+\n| id   | country | state    | amount | trans_date |\n+------+---------+----------+--------+------------+\n| 121  | US      | approved | 1000   | 2018-12-18 |\n| 122  | US      | declined | 2000   | 2018-12-19 |\n| 123  | US      | approved | 2000   | 2019-01-01 |\n| 124  | DE      | approved | 2000   | 2019-01-07 |\n+------+---------+----------+--------+------------+\nOutput:\n+----------+---------+-------------+----------------+--------------------+-----------------------+\n| month    | country | trans_count | approved_count | trans_total_amount | approved_total_amount |\n+----------+---------+-------------+----------------+--------------------+-----------------------+\n| 2018-12  | US      | 2           | 1              | 3000               | 1000                  |\n| 2019-01  | US      | 1           | 1              | 2000               | 2000                  |\n| 2019-01  | DE      | 1           | 1              | 2000               | 2000                  |\n+----------+---------+-------------+----------------+--------------------+-----------------------+\n</code></pre> 1193. Monthly Transactions I<pre><code>SELECT\n    country,\n    DATE_FORMAT(trans_date, '%Y-%m') AS month,\n    COUNT(*) AS trans_count,\n    COUNT(IF(state = 'approved', 1, NULL)) AS approved_count,\n    SUM(amount) AS trans_total_amount,\n    SUM(IF(state = 'approved', amount, 0)) AS approved_total_amount\nFROM\n    transactions\nGROUP BY\n    month,\n    country;\n</code></pre>"},{"location":"sql50/basic_aggregate_functions/#1174-immediate-food-delivery-ii","title":"1174. Immediate Food Delivery II","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"sql50/basic_aggregate_functions/#550-game-play-analysis-iv","title":"550. Game Play Analysis IV","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"sql50/basic_joins/","title":"Basic Joins","text":"<ul> <li> 1378. Replace Employee ID With The Unique Identifier (Easy)</li> <li> 1068. Product Sales Analysis I (Easy)</li> <li> 1581. Customer Who Visited but Did Not Make Any Transactions (Easy)</li> <li> 197. Rising Temperature (Easy)</li> <li> 1661. Average Time of Process per Machine (Easy)</li> <li> 577. Employee Bonus (Easy)</li> <li> 1280. Students and Examinations (Easy)</li> <li> 570. Managers with at Least 5 Direct Reports (Medium)</li> <li> 1934. Confirmation Rate (Medium)</li> </ul>"},{"location":"sql50/basic_joins/#1378-replace-employee-id-with-the-unique-identifier","title":"1378. Replace Employee ID With The Unique Identifier","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul> 1378. Replace Employee ID With The Unique Identifier<pre><code>-- Replace employee id with the unique identifier\nSELECT\n    unique_id,\n    name\nFROM\n    employees\nLEFT JOIN employeeuni ON employees.id = employeeuni.id;\n</code></pre>"},{"location":"sql50/basic_joins/#1068-product-sales-analysis-i","title":"1068. Product Sales Analysis I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul> 1068. Product Sales Analysis I<pre><code>SELECT\n    p.product_name,\n    s.year,\n    s.price\nFROM\n    sales AS s\nLEFT JOIN product AS p ON s.product_id = p.product_id;\n</code></pre>"},{"location":"sql50/basic_joins/#1581-customer-who-visited-but-did-not-make-any-transactions","title":"1581. Customer Who Visited but Did Not Make Any Transactions","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul> 1581. Customer Who Visited but Did Not Make Any Transactions<pre><code>-- 1. Left Join\nSELECT\n    v.customer_id,\n    COUNT(v.visit_id) AS count_no_trans\nFROM\n    visits AS v\nLEFT JOIN transactions AS t ON v.visit_id = t.visit_id\nWHERE\n    t.transaction_id IS NULL\nGROUP BY\n    v.customer_id;\n\n-- 2. Subquery\nSELECT\n    customer_id,\n    COUNT(DISTINCT visit_id) AS count_no_trans\nFROM\n    visits\nWHERE\n    visit_id NOT IN (\n        SELECT visit_id\n        FROM\n            transactions\n    )\nGROUP BY\n    customer_id;\n</code></pre>"},{"location":"sql50/basic_joins/#197-rising-temperature","title":"197. Rising Temperature","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul> 197. Rising Temperature<pre><code>SELECT w1.id\nFROM\n    weather AS w1\nLEFT JOIN weather AS w2 ON w1.recorddate - INTERVAL 1 DAY = w2.recorddate\nWHERE\n    w1.temperature &gt; w2.temperature;\n</code></pre>"},{"location":"sql50/basic_joins/#1661-average-time-of-process-per-machine","title":"1661. Average Time of Process per Machine","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul> 1661. Average Time of Process per Machine<pre><code>SELECT\n    a1.machine_id,\n    ROUND(AVG(a2.timestamp - a1.timestamp), 3) AS processing_time\n    -- ROUND(SUM(a2.timestamp - a1.timestamp) / COUNT(*), 3) AS processing_time\nFROM\n    activity AS a1\nINNER JOIN activity AS a2\n    ON\n        a1.machine_id = a2.machine_id\n        AND a1.process_id = a2.process_id\n        AND a1.timestamp &lt; a2.timestamp\nGROUP BY\n    a1.machine_id;\n</code></pre>"},{"location":"sql50/basic_joins/#577-employee-bonus","title":"577. Employee Bonus","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul> 577. Employee Bonus<pre><code>-- 1.\nSELECT\n    e.name,\n    b.bonus\nFROM\n    employee AS e\nLEFT JOIN bonus AS b ON e.empid = b.empid\nWHERE\n    b.bonus &lt; 1000\n    OR b.bonus IS NULL;\n\n-- 2.\nSELECT\n    e.name,\n    b.bonus\nFROM\n    employee AS e\nLEFT JOIN bonus AS b ON e.empid = b.empid\nWHERE\n    COALESCE(b.bonus, 0) &lt; 1000;\n</code></pre>"},{"location":"sql50/basic_joins/#1280-students-and-examinations","title":"1280. Students and Examinations","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul> 1280. Students and Examinations<pre><code>SELECT\n    st.student_id,\n    st.student_name,\n    su.subject_name,\n    COUNT(ex.student_id) AS attended_exams\nFROM\n    students AS st\nCROSS JOIN subjects AS su\nLEFT JOIN examinations AS ex\n    ON\n        st.student_id = ex.student_id\n        AND su.subject_name = ex.subject_name\nGROUP BY\n    st.student_id,\n    st.student_name,\n    su.subject_name\nORDER BY\n    st.student_id,\n    su.subject_name;\n</code></pre>"},{"location":"sql50/basic_joins/#570-managers-with-at-least-5-direct-reports","title":"570. Managers with at Least 5 Direct Reports","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: database</p> </li> </ul> 570. Managers with at Least 5 Direct Reports<pre><code>SELECT e2.name\nFROM\n    employee AS e1\nINNER JOIN employee AS e2 ON e1.managerid = e2.id\nGROUP BY\n    e2.id,\n    e2.name\nHAVING\n    COUNT(e1.id) &gt;= 5;\n</code></pre>"},{"location":"sql50/basic_joins/#1934-confirmation-rate","title":"1934. Confirmation Rate","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: database</p> </li> </ul> 1934. Confirmation Rate<pre><code>SELECT\n    s.user_id,\n    ROUND(\n        SUM(IF(c.action = 'confirmed', 1, 0)) / COUNT(*),\n        2\n    ) AS confirmation_rate\nFROM\n    signups AS s\nLEFT JOIN confirmations AS c ON s.user_id = c.user_id\nGROUP BY\n    s.user_id;\n</code></pre>"},{"location":"sql50/select/","title":"Select","text":"<ul> <li> 1757. Recyclable and Low Fat Products (Easy)</li> <li> 584. Find Customer Referee (Easy)</li> <li> 595. Big Countries (Easy)</li> <li> 1148. Article Views I (Easy)</li> <li> 1683. Invalid Tweets (Easy)</li> </ul>"},{"location":"sql50/select/#1757-recyclable-and-low-fat-products","title":"1757. Recyclable and Low Fat Products","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul> 1757. Recyclable and Low Fat Products<pre><code>Input:\nProducts table:\n+-------------+----------+------------+\n| product_id  | low_fats | recyclable |\n+-------------+----------+------------+\n| 0           | Y        | N          |\n| 1           | Y        | Y          |\n| 2           | N        | Y          |\n| 3           | Y        | Y          |\n| 4           | N        | N          |\n+-------------+----------+------------+\nOutput:\n+-------------+\n| product_id  |\n+-------------+\n| 1           |\n| 3           |\n+-------------+\n</code></pre> 1757. Recyclable and Low Fat Products<pre><code>SELECT product_id\nFROM\n    products\nWHERE\n    low_fats = 'Y'\n    AND recyclable = 'Y';\n</code></pre>"},{"location":"sql50/select/#584-find-customer-referee","title":"584. Find Customer Referee","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul> 584. Find Customer Referee<pre><code>-- 1.\nSELECT NAME\nFROM\n    CUSTOMER\nWHERE\n    REFEREE_ID &lt;&gt; 2\n    OR REFEREE_ID IS NULL;\n\n-- 2.\nSELECT NAME\nFROM\n    CUSTOMER\nWHERE\n    COALESCE(REFEREE_ID, -1) &lt;&gt; 2;\n\n-- 3.\nSELECT NAME\nFROM\n    CUSTOMER\nWHERE\n    COALESCE(REFEREE_ID, -1) &lt;&gt; 2;\n</code></pre>"},{"location":"sql50/select/#595-big-countries","title":"595. Big Countries","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul> 595. Big Countries<pre><code>SELECT\n    NAME,\n    POPULATION,\n    AREA\nFROM\n    WORLD\nWHERE\n    POPULATION &gt;= 25000000\n    OR AREA &gt;= 3000000;\n</code></pre>"},{"location":"sql50/select/#1148-article-views-i","title":"1148. Article Views I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul> 1148. Article Views I<pre><code>SELECT DISTINCT author_id AS id\nFROM\n    views\nWHERE\n    author_id = viewer_id\nORDER BY\n    id ASC;\n</code></pre>"},{"location":"sql50/select/#1683-invalid-tweets","title":"1683. Invalid Tweets","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul> 1683. Invalid Tweets<pre><code>SELECT tweet_id\nFROM\n    tweets\nWHERE\n    CHAR_LENGTH(content) &gt; 15;\n</code></pre>"},{"location":"sql50/sorting_and_grouping/","title":"Sorting and Grouping","text":"<ul> <li> 2356. Number of Unique Subjects Taught by Each Teacher (Easy)</li> <li> 1141. User Activity for the Past 30 Days I (Easy)</li> <li> 1070. Product Sales Analysis III (Medium)</li> <li> 596. Classes More Than 5 Students (Easy)</li> <li> 1729. Find Followers Count (Easy)</li> <li> 619. Biggest Single Number (Easy)</li> <li> 1045. Customers Who Bought All Products (Medium)</li> </ul>"},{"location":"sql50/sorting_and_grouping/#2356-number-of-unique-subjects-taught-by-each-teacher","title":"2356. Number of Unique Subjects Taught by Each Teacher","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"sql50/sorting_and_grouping/#1141-user-activity-for-the-past-30-days-i","title":"1141. User Activity for the Past 30 Days I","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"sql50/sorting_and_grouping/#1070-product-sales-analysis-iii","title":"1070. Product Sales Analysis III","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"sql50/sorting_and_grouping/#596-classes-more-than-5-students","title":"596. Classes More Than 5 Students","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"sql50/sorting_and_grouping/#1729-find-followers-count","title":"1729. Find Followers Count","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"sql50/sorting_and_grouping/#619-biggest-single-number","title":"619. Biggest Single Number","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"sql50/sorting_and_grouping/#1045-customers-who-bought-all-products","title":"1045. Customers Who Bought All Products","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"sql50/subqueries/","title":"Subqueries","text":"<ul> <li> 1978. Employees Whose Manager Left the Company (Easy)</li> <li> 626. Exchange Seats (Medium)</li> <li> 1341. Movie Rating (Medium)</li> <li> 1321. Restaurant Growth (Medium)</li> <li> 602. Friend Requests II: Who Has the Most Friends (Medium)</li> <li> 585. Investments in 2016 (Medium)</li> <li> 185. Department Top Three Salaries (Hard)</li> </ul>"},{"location":"sql50/subqueries/#1978-employees-whose-manager-left-the-company","title":"1978. Employees Whose Manager Left the Company","text":"<ul> <li> <p>LeetCode | LeetCode CH (Easy)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"sql50/subqueries/#626-exchange-seats","title":"626. Exchange Seats","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"sql50/subqueries/#1341-movie-rating","title":"1341. Movie Rating","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"sql50/subqueries/#1321-restaurant-growth","title":"1321. Restaurant Growth","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"sql50/subqueries/#602-friend-requests-ii-who-has-the-most-friends","title":"602. Friend Requests II: Who Has the Most Friends","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"sql50/subqueries/#585-investments-in-2016","title":"585. Investments in 2016","text":"<ul> <li> <p>LeetCode | LeetCode CH (Medium)</p> </li> <li> <p>Tags: database</p> </li> </ul>"},{"location":"sql50/subqueries/#185-department-top-three-salaries","title":"185. Department Top Three Salaries","text":"<ul> <li> <p>LeetCode | LeetCode CH (Hard)</p> </li> <li> <p>Tags: database</p> </li> </ul>"}]}